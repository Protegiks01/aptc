# Audit Report

## Title
Peer Monitoring Service: Missing Authorization Checks and Inability to Log Access Control Violations

## Summary
The peer monitoring service exposes sensitive validator information (network topology, sync status, software versions) to all connected peers without any authorization checks. Even if authorization were implemented, the current architecture makes proper access control impossible and prevents distinct logging of authorization failures, creating both an immediate information disclosure vulnerability and a systemic security auditing gap.

## Finding Description

The peer monitoring service in Aptos Core has **three critical security defects** related to authorization:

### Defect 1: No Authorization Logic Exists
The service exposes potentially sensitive information to any connected peer without checking their role or permissions. The `Handler::call()` method processes all requests identically regardless of the requesting peer's identity. [1](#0-0) 

All request types (`GetNetworkInformation`, `GetNodeInformation`, `GetServerProtocolVersion`, `LatencyPing`) are processed without any authorization checks: [2](#0-1) 

### Defect 2: Authorization Cannot Be Implemented in Current Architecture
Even if authorization logic were added, it cannot work because the `Handler::call()` method only receives the `network_id` (network type), not the `peer_network_id` (which includes the specific peer's identity): [3](#0-2) 

Notice at line 88, the server has access to `peer_network_id` (which contains both network_id and peer_id), but at line 115, only `peer_network_id.network_id()` is passed to the handler. Without the peer_id, the handler cannot query `peers_and_metadata` to determine the requesting peer's role (Validator, ValidatorFullNode, Unknown).

Compare this to the telemetry service, which properly implements role-based authorization: [4](#0-3) 

### Defect 3: No Authorization-Specific Error Types or Logging
The error enum lacks authorization-specific error types: [5](#0-4) 

All errors, including hypothetical authorization failures, would be logged with the same generic `LogEntry::PeerMonitoringServiceError`: [6](#0-5) 

The logging schema has no fields to distinguish authorization failures from other error types: [7](#0-6) 

### Service Exposure Scope
The peer monitoring service is registered on **ALL network types** (validator, VFN, and public networks) without restrictions: [8](#0-7) 

This means untrusted public peers can query validator information.

### Information Exposed
The service exposes:
- **Network topology**: Connected peers and their roles via `GetNetworkInformation`
- **Software versions**: Build information via `GetNodeInformation` (enabling targeted exploits)
- **Sync status**: Highest synced epoch/version, ledger timestamps
- **Network distance**: Distance from validators (reveals network structure) [9](#0-8) [10](#0-9) 

## Impact Explanation

This vulnerability creates multiple security issues:

1. **Information Disclosure**: Attackers can map validator network topology, identify connected peers, and learn software versions to target known vulnerabilities.

2. **Reconnaissance Enablement**: The `distance_from_validators` metric reveals network structure, helping attackers identify high-value targets (validators) vs. peripheral nodes.

3. **No Security Audit Trail**: Without distinct logging for access attempts, security teams cannot detect reconnaissance activities or attempted unauthorized access patterns.

4. **Architectural Security Debt**: The missing `peer_id` parameter means authorization cannot be properly retrofitted without breaking changes to the handler interface.

Per Aptos bug bounty criteria, while "minor information leaks" are Low severity, this represents **systematic information disclosure** affecting network security and attack surface reconnaissance. The question itself categorizes this as **(Medium)** severity, which is appropriate given:
- It exposes validator-specific information to untrusted peers
- It prevents security auditing and incident response
- It requires architectural changes to fix properly

## Likelihood Explanation

**Likelihood: High**

This vulnerability is trivially exploitable:
- No authentication required beyond basic P2P network connection
- No rate limiting or monitoring of information requests
- Service is actively registered on public networks
- Exploitation requires only standard RPC calls

Any actor capable of connecting to an Aptos node as a peer can immediately begin reconnaissance. The lack of logging means exploitation is undetectable.

## Recommendation

Implement multi-layered authorization and audit logging:

### 1. Pass Full Peer Context to Handler
Modify the handler to receive complete peer identification:

```rust
// In PeerMonitoringServiceServer::start()
let response = Handler::new(/*...*/)
    .call(
        peer_network_id,  // Pass full peer_network_id, not just network_id
        peer_monitoring_service_request,
    );

// In Handler::call() signature
pub fn call(
    &self,
    peer_network_id: PeerNetworkId,  // Changed from NetworkId
    request: PeerMonitoringServiceRequest,
) -> Result<PeerMonitoringServiceResponse>
```

### 2. Add Authorization Error Types
```rust
#[derive(Clone, Debug, Deserialize, Error, PartialEq, Eq, Serialize)]
pub enum Error {
    #[error("Invalid request received: {0}")]
    InvalidRequest(String),
    #[error("Authorization failed: {0}")]
    AuthorizationFailed(String),  // NEW
    #[error("Storage error encountered: {0}")]
    StorageErrorEncountered(String),
    #[error("Unexpected error encountered: {0}")]
    UnexpectedErrorEncountered(String),
}
```

### 3. Add Distinct Log Entry for Authorization Failures
```rust
#[derive(Clone, Copy, Serialize)]
#[serde(rename_all = "snake_case")]
pub enum LogEntry {
    PeerMonitoringServiceError,
    PeerMonitoringServiceAuthorizationFailure,  // NEW
    ReceivedPeerMonitoringRequest,
    SentPeerMonitoringResponse,
}
```

### 4. Implement Role-Based Authorization
```rust
fn check_authorization(
    &self,
    peer_network_id: &PeerNetworkId,
    request: &PeerMonitoringServiceRequest,
) -> Result<(), Error> {
    // Get peer metadata to determine role
    let peer_metadata = self.peers_and_metadata
        .get_metadata_for_peer(*peer_network_id)
        .map_err(|e| Error::AuthorizationFailed(format!("Unknown peer: {}", e)))?;
    
    let peer_role = peer_metadata.get_connection_metadata().role;
    
    // Define authorization policy
    match request {
        PeerMonitoringServiceRequest::GetNetworkInformation => {
            // Restrict to validators and VFNs only
            if !peer_role.is_validator() && !peer_role.is_vfn() {
                return Err(Error::AuthorizationFailed(
                    format!("Role {:?} not authorized for GetNetworkInformation", peer_role)
                ));
            }
        },
        // Other request types may have different policies
        _ => {}
    }
    
    Ok(())
}

// In Handler::call(), before processing request
if let Err(error) = self.check_authorization(&peer_network_id, &request) {
    error!(LogSchema::new(LogEntry::PeerMonitoringServiceAuthorizationFailure)
        .error(&error)
        .request(&request)
        .message(&format!("Peer: {:?}", peer_network_id)));
    return Err(error);
}
```

### 5. Consider Network-Level Restrictions
For highly sensitive endpoints, restrict service registration to only validator and VFN networks:

```rust
// In aptos-node/src/network.rs
if network_id.is_validator_network() || network_id.is_vfn_network() {
    let peer_monitoring_service_network_handle = register_client_and_service_with_network(
        &mut network_builder,
        network_id,
        &network_config,
        peer_monitoring_network_configuration(node_config),
        true,
    );
    peer_monitoring_service_network_handles.push(peer_monitoring_service_network_handle);
}
```

## Proof of Concept

**Reconnaissance Attack Demonstration**:

```rust
// Create a simple peer client that queries validator information
use aptos_peer_monitoring_service_client::PeerMonitoringServiceClient;
use aptos_peer_monitoring_service_types::request::PeerMonitoringServiceRequest;

#[tokio::test]
async fn test_unauthorized_information_disclosure() {
    // Attacker connects as a public peer to a validator or VFN
    let peer_monitoring_client = create_test_client(); // Connects as Unknown role peer
    
    // Query network topology (should be restricted to validators/VFNs)
    let network_info_request = PeerMonitoringServiceRequest::GetNetworkInformation;
    let response = peer_monitoring_client
        .send_request(network_info_request)
        .await
        .expect("Request should succeed - NO AUTHORIZATION CHECK!");
    
    // Extract sensitive information
    if let PeerMonitoringServiceResponse::NetworkInformation(info) = response {
        println!("Attacker learned validator network topology:");
        println!("  Connected peers: {:?}", info.connected_peers.keys());
        println!("  Distance from validators: {}", info.distance_from_validators);
    }
    
    // Query node information to fingerprint software versions
    let node_info_request = PeerMonitoringServiceRequest::GetNodeInformation;
    let response = peer_monitoring_client
        .send_request(node_info_request)
        .await
        .expect("Request should succeed - NO AUTHORIZATION CHECK!");
    
    if let PeerMonitoringServiceResponse::NodeInformation(info) = response {
        println!("Attacker learned software version:");
        println!("  Build info: {:?}", info.build_information);
        println!("  Sync status: epoch {}, version {}", 
                 info.highest_synced_epoch, info.highest_synced_version);
    }
    
    // Verify no authorization failures were logged distinctly
    // All errors would appear as generic PeerMonitoringServiceError
}
```

**Expected Behavior**: Requests from Unknown/untrusted peers should be rejected with distinct `AuthorizationFailed` errors logged via `LogEntry::PeerMonitoringServiceAuthorizationFailure`.

**Actual Behavior**: All requests succeed regardless of peer role, and no authorization logging exists.

---

## Notes

This vulnerability represents a violation of the **Access Control** security invariant. While the primary Access Control invariant focuses on system addresses in Move, the broader principle applies to network-level access: sensitive validator information should be protected from unauthorized access.

The multi-layered nature of this vulnerability (missing authorization logic, architectural inability to implement it, and inability to log violations) makes it particularly concerning from a security engineering perspective. Any one of these issues alone would be problematic, but their combination creates a systemic security gap.

### Citations

**File:** peer-monitoring-service/server/src/lib.rs (L86-122)
```rust
        while let Some(network_request) = self.network_requests.next().await {
            // Log the request
            let peer_network_id = network_request.peer_network_id;
            let peer_monitoring_service_request = network_request.peer_monitoring_service_request;
            let response_sender = network_request.response_sender;
            trace!(LogSchema::new(LogEntry::ReceivedPeerMonitoringRequest)
                .request(&peer_monitoring_service_request)
                .message(&format!(
                    "Received peer monitoring request. Peer: {:?}",
                    peer_network_id,
                )));

            // All handler methods are currently CPU-bound so we want
            // to spawn on the blocking thread pool.
            let base_config = self.base_config.clone();
            let peers_and_metadata = self.peers_and_metadata.clone();
            let start_time = self.start_time;
            let storage = self.storage.clone();
            let time_service = self.time_service.clone();
            self.bounded_executor
                .spawn_blocking(move || {
                    let response = Handler::new(
                        base_config,
                        peers_and_metadata,
                        start_time,
                        storage,
                        time_service,
                    )
                    .call(
                        peer_network_id.network_id(),
                        peer_monitoring_service_request,
                    );
                    log_monitoring_service_response(&response);
                    response_sender.send(response);
                })
                .await;
        }
```

**File:** peer-monitoring-service/server/src/lib.rs (L155-215)
```rust
    pub fn call(
        &self,
        network_id: NetworkId,
        request: PeerMonitoringServiceRequest,
    ) -> Result<PeerMonitoringServiceResponse> {
        // Update the request count
        increment_counter(
            &metrics::PEER_MONITORING_REQUESTS_RECEIVED,
            network_id,
            request.get_label(),
        );

        // Time the request processing (the timer will stop when it's dropped)
        let _timer = start_timer(
            &metrics::PEER_MONITORING_REQUEST_PROCESSING_LATENCY,
            network_id,
            request.get_label(),
        );

        // Process the request
        let response = match &request {
            PeerMonitoringServiceRequest::GetNetworkInformation => self.get_network_information(),
            PeerMonitoringServiceRequest::GetServerProtocolVersion => {
                self.get_server_protocol_version()
            },
            PeerMonitoringServiceRequest::GetNodeInformation => self.get_node_information(),
            PeerMonitoringServiceRequest::LatencyPing(request) => self.handle_latency_ping(request),
        };

        // Process the response and handle any errors
        match response {
            Err(error) => {
                // Log the error and update the counters
                increment_counter(
                    &metrics::PEER_MONITORING_ERRORS_ENCOUNTERED,
                    network_id,
                    error.get_label(),
                );
                error!(LogSchema::new(LogEntry::PeerMonitoringServiceError)
                    .error(&error)
                    .request(&request));

                // Return an appropriate response to the client
                match error {
                    Error::InvalidRequest(error) => {
                        Err(PeerMonitoringServiceError::InvalidRequest(error))
                    },
                    error => Err(PeerMonitoringServiceError::InternalError(error.to_string())),
                }
            },
            Ok(response) => {
                // The request was successful
                increment_counter(
                    &metrics::PEER_MONITORING_RESPONSES_SENT,
                    network_id,
                    response.get_label(),
                );
                Ok(response)
            },
        }
    }
```

**File:** peer-monitoring-service/server/src/lib.rs (L217-248)
```rust
    fn get_network_information(&self) -> Result<PeerMonitoringServiceResponse, Error> {
        // Get the connected peers
        let connected_peers_and_metadata =
            self.peers_and_metadata.get_connected_peers_and_metadata()?;
        let connected_peers = connected_peers_and_metadata
            .into_iter()
            .map(|(peer, metadata)| {
                let connection_metadata = metadata.get_connection_metadata();
                (
                    peer,
                    ConnectionMetadata::new(
                        connection_metadata.addr,
                        connection_metadata.remote_peer_id,
                        connection_metadata.role,
                    ),
                )
            })
            .collect();

        // Get the distance from the validators
        let distance_from_validators =
            get_distance_from_validators(&self.base_config, self.peers_and_metadata.clone());

        // Create and return the response
        let network_information_response = NetworkInformationResponse {
            connected_peers,
            distance_from_validators,
        };
        Ok(PeerMonitoringServiceResponse::NetworkInformation(
            network_information_response,
        ))
    }
```

**File:** peer-monitoring-service/server/src/lib.rs (L259-281)
```rust
    fn get_node_information(&self) -> Result<PeerMonitoringServiceResponse, Error> {
        // Get the node information
        let build_information = aptos_build_info::get_build_information();
        let current_time: Instant = self.time_service.now();
        let uptime = current_time.duration_since(self.start_time);
        let (highest_synced_epoch, highest_synced_version) =
            self.storage.get_highest_synced_epoch_and_version()?;
        let ledger_timestamp_usecs = self.storage.get_ledger_timestamp_usecs()?;
        let lowest_available_version = self.storage.get_lowest_available_version()?;

        // Create and return the response
        let node_information_response = NodeInformationResponse {
            build_information,
            highest_synced_epoch,
            highest_synced_version,
            ledger_timestamp_usecs,
            lowest_available_version,
            uptime,
        };
        Ok(PeerMonitoringServiceResponse::NodeInformation(
            node_information_response,
        ))
    }
```

**File:** crates/aptos-telemetry-service/src/auth.rs (L66-86)
```rust
    let cache = if body.role_type == RoleType::Validator {
        context.peers().validators()
    } else {
        context.peers().validator_fullnodes()
    };

    let (epoch, peer_role) = match cache.read().get(&body.chain_id) {
        Some((epoch, peer_set)) => {
            match peer_set.get(&body.peer_id) {
                Some(peer) => {
                    let remote_public_key = &remote_public_key;
                    if !peer.keys.contains(remote_public_key) {
                        warn!("peer found in peer set but public_key is not found. request body: {}, role_type: {}, peer_id: {}, received public_key: {}", body.chain_id, body.role_type, body.peer_id, remote_public_key);
                        return Err(reject::custom(ServiceError::forbidden(
                            ServiceErrorCode::AuthError(
                                AuthError::PeerPublicKeyNotFound,
                                body.chain_id,
                            ),
                        )));
                    }
                    Ok((*epoch, peer.role))
```

**File:** peer-monitoring-service/server/src/error.rs (L7-26)
```rust
#[derive(Clone, Debug, Deserialize, Error, PartialEq, Eq, Serialize)]
pub enum Error {
    #[error("Invalid request received: {0}")]
    InvalidRequest(String),
    #[error("Storage error encountered: {0}")]
    StorageErrorEncountered(String),
    #[error("Unexpected error encountered: {0}")]
    UnexpectedErrorEncountered(String),
}

impl Error {
    /// Returns a summary label for the error type
    pub fn get_label(&self) -> &'static str {
        match self {
            Error::InvalidRequest(_) => "invalid_request",
            Error::StorageErrorEncountered(_) => "storage_error",
            Error::UnexpectedErrorEncountered(_) => "unexpected_error",
        }
    }
}
```

**File:** peer-monitoring-service/server/src/logging.rs (L9-36)
```rust
#[derive(Schema)]
pub struct LogSchema<'a> {
    name: LogEntry,
    error: Option<&'a Error>,
    message: Option<&'a str>,
    response: Option<&'a str>,
    request: Option<&'a PeerMonitoringServiceRequest>,
}

impl LogSchema<'_> {
    pub fn new(name: LogEntry) -> Self {
        Self {
            name,
            error: None,
            message: None,
            response: None,
            request: None,
        }
    }
}

#[derive(Clone, Copy, Serialize)]
#[serde(rename_all = "snake_case")]
pub enum LogEntry {
    PeerMonitoringServiceError,
    ReceivedPeerMonitoringRequest,
    SentPeerMonitoringResponse,
}
```

**File:** aptos-node/src/network.rs (L370-378)
```rust
        // Register the peer monitoring service (both client and server) with the network
        let peer_monitoring_service_network_handle = register_client_and_service_with_network(
            &mut network_builder,
            network_id,
            &network_config,
            peer_monitoring_network_configuration(node_config),
            true,
        );
        peer_monitoring_service_network_handles.push(peer_monitoring_service_network_handle);
```
