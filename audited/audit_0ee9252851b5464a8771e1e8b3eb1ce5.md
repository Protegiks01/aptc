# Audit Report

## Title
Unbounded Memory Allocation in RestStream ValidatorSet Deserialization Leads to Node Crash

## Summary
The `RestStream` discovery mechanism fetches `ValidatorSet` data from a configurable REST API endpoint without imposing size limits on the HTTP response or BCS deserialization. An attacker controlling or intercepting the REST API can send extremely large responses containing oversized `ValidatorSet` structures, causing unbounded memory allocation and node crash through Out-of-Memory (OOM) conditions.

## Finding Description
The vulnerability exists in the integration between `RestStream` and the REST client's BCS deserialization logic. When a node is configured to use REST-based discovery via `DiscoveryMethod::Rest`, it periodically polls a REST API endpoint to fetch the current `ValidatorSet`. [1](#0-0) 

The `get_account_resource_bcs` method retrieves the resource and deserializes it: [2](#0-1) 

The critical flaw occurs in two stages:

1. **Unbounded Response Reading**: The `check_and_parse_bcs_response` method reads the entire HTTP response into memory without size limits: [3](#0-2) 

2. **Unbounded BCS Deserialization**: The client uses `bcs::from_bytes` instead of `bcs::from_bytes_with_limit`, which other parts of the codebase use for untrusted input: [4](#0-3) 

The `ValidatorSet` structure contains unbounded `Vec<ValidatorInfo>` fields, where each `ValidatorInfo` contains `ValidatorConfig` with unbounded `Vec<u8>` fields for network addresses: [5](#0-4) 

**Attack Vector**: An attacker can exploit this by:
1. Compromising the configured REST API endpoint, or
2. Performing a Man-in-the-Middle attack on HTTP connections
3. Configuring a malicious REST URL (if they have config access)

The attacker crafts a malicious response with:
- A large number of validators (e.g., 65,536 - the `MAX_VALIDATOR_SET_SIZE`)
- Each validator having extremely large `validator_network_addresses` and `fullnode_network_addresses` fields (e.g., 10MB each)
- Total payload: 65,536 × 20MB = ~1.3TB theoretical maximum

Even smaller payloads (e.g., 1,000 validators × 10MB = 10GB) would exhaust memory on typical validator nodes. [6](#0-5) 

While the on-chain `MAX_VALIDATOR_SET_SIZE` limit exists, it's only enforced by the Move contract during state updates, not during REST API deserialization. [7](#0-6) 

## Impact Explanation
**High Severity** - This vulnerability enables denial-of-service attacks against validator nodes:

1. **Node Crashes**: Excessive memory allocation leads to OOM conditions, crashing the node
2. **Network Degradation**: Multiple affected validators reduce network liveness and consensus participation
3. **Repeated Exploitation**: The discovery mechanism polls continuously, allowing sustained attacks

This aligns with High Severity criteria: "Validator node slowdowns" and "API crashes." While not reaching Critical severity (requires network partition or consensus break), it significantly impacts network availability and node operations.

## Likelihood Explanation
**Medium-to-High Likelihood**:

**Prerequisites**:
- Node must be configured with `DiscoveryMethod::Rest` 
- Attacker must control or intercept the REST API endpoint

**Factors Increasing Likelihood**:
1. REST URLs are configurable via node config files
2. If HTTP (not HTTPS) is used, MitM attacks are feasible
3. No authentication required on REST API responses
4. The vulnerability triggers automatically once malicious responses are served

**Factors Decreasing Likelihood**:
- Most production deployments likely use on-chain discovery or trusted REST endpoints
- HTTPS connections reduce MitM attack surface

## Recommendation
Implement size limits on both HTTP response reading and BCS deserialization:

1. **Add response size limit in REST client**:
   - Add a maximum response size configuration parameter (e.g., 10MB)
   - Check response size before reading with `response.content_length()` or enforce during streaming

2. **Use bounded BCS deserialization**:
   ```rust
   // In get_account_resource_bcs function
   pub async fn get_account_resource_bcs<T: DeserializeOwned>(
       &self,
       address: AccountAddress,
       resource_type: &str,
   ) -> AptosResult<Response<T>> {
       let url = self.build_path(&format!(
           "accounts/{}/resource/{}",
           address.to_hex(),
           resource_type
       ))?;
       let response = self.get_bcs(url).await?;
       // Add limit matching network message size constraints
       const MAX_RESOURCE_SIZE: usize = 10 * 1024 * 1024; // 10MB
       Ok(response.and_then(|inner| bcs::from_bytes_with_limit(&inner, MAX_RESOURCE_SIZE))?)
   }
   ```

3. **Add ValidatorSet validation after deserialization**:
   ```rust
   // In extract_validator_set_updates or RestStream
   if node_set.active_validators.len() + node_set.pending_active.len() + 
      node_set.pending_inactive.len() > MAX_VALIDATOR_SET_SIZE {
       return Err(DiscoveryError::Parsing("ValidatorSet exceeds maximum size".to_string()));
   }
   ```

## Proof of Concept
```rust
// Malicious REST server proof of concept
use aptos_types::{
    on_chain_config::ValidatorSet,
    validator_config::ValidatorConfig,
    validator_info::ValidatorInfo,
};
use bcs;

fn create_malicious_validator_set() -> Vec<u8> {
    let mut validators = Vec::new();
    
    // Create 1000 validators with 10MB network addresses each
    for i in 0..1000 {
        let large_addresses = vec![0u8; 10 * 1024 * 1024]; // 10MB
        let config = ValidatorConfig::new(
            aptos_crypto::bls12381::PrivateKey::generate_for_testing().public_key(),
            large_addresses.clone(),
            large_addresses,
            i,
        );
        
        let validator = ValidatorInfo::new(
            aptos_types::account_address::AccountAddress::random(),
            1000,
            config,
        );
        validators.push(validator);
    }
    
    let validator_set = ValidatorSet::new(validators);
    bcs::to_bytes(&validator_set).unwrap() // ~20GB payload
}

// When served via REST API, this will cause the receiving node to:
// 1. Read 20GB into memory via response.bytes().await
// 2. Allocate another 20GB for BCS deserialization
// 3. Crash with OOM
```

**Notes**:
- The vulnerability bypasses all existing resource limits because REST discovery operates outside normal transaction/message processing
- The attack is sustainable since discovery polling repeats continuously
- Defense-in-depth requires multiple layers: transport size limits, BCS limits, and post-deserialization validation

### Citations

**File:** network/discovery/src/rest.rs (L48-51)
```rust
        let response = block_on(self.rest_client.get_account_resource_bcs::<ValidatorSet>(
            AccountAddress::ONE,
            "0x1::stake::ValidatorSet",
        ));
```

**File:** crates/aptos-rest-client/src/lib.rs (L1209-1221)
```rust
    pub async fn get_account_resource_bcs<T: DeserializeOwned>(
        &self,
        address: AccountAddress,
        resource_type: &str,
    ) -> AptosResult<Response<T>> {
        let url = self.build_path(&format!(
            "accounts/{}/resource/{}",
            address.to_hex(),
            resource_type
        ))?;
        let response = self.get_bcs(url).await?;
        Ok(response.and_then(|inner| bcs::from_bytes(&inner))?)
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L1773-1779)
```rust
    async fn check_and_parse_bcs_response(
        &self,
        response: reqwest::Response,
    ) -> AptosResult<Response<bytes::Bytes>> {
        let (response, state) = self.check_response(response).await?;
        Ok(Response::new(response.bytes().await?, state))
    }
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L259-262)
```rust
    /// Deserializes the value using BCS encoding (with a specified limit)
    fn bcs_decode<T: DeserializeOwned>(&self, bytes: &[u8], limit: usize) -> anyhow::Result<T> {
        bcs::from_bytes_with_limit(bytes, limit).map_err(|e| anyhow!("{:?}", e))
    }
```

**File:** types/src/validator_config.rs (L36-43)
```rust
pub struct ValidatorConfig {
    pub consensus_public_key: bls12381::PublicKey,
    /// This is an bcs serialized `Vec<NetworkAddress>`
    pub validator_network_addresses: Vec<u8>,
    /// This is an bcs serialized `Vec<NetworkAddress>`
    pub fullnode_network_addresses: Vec<u8>,
    pub validator_index: u64,
}
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L98-100)
```text
    /// Limit the maximum size to u16::max, it's the current limit of the bitvec
    /// https://github.com/aptos-labs/aptos-core/blob/main/crates/aptos-bitvec/src/lib.rs#L20
    const MAX_VALIDATOR_SET_SIZE: u64 = 65536;
```

**File:** config/src/config/network_config.rs (L361-364)
```rust
pub struct RestDiscovery {
    pub url: url::Url,
    pub interval_secs: u64,
}
```
