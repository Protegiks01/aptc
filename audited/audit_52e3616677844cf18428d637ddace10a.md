# Audit Report

## Title
Unauthenticated Failpoint Injection API Exposes Consensus to DoS Attacks on Non-Mainnet Production Networks

## Summary
The `/v1/set_failpoint` API endpoint is exposed without authentication, allowing any attacker with network access to inject failpoints that can disrupt consensus operations, block critical validator messages, and cause liveness failures on testnet/devnet validators or misconfigured mainnet nodes.

## Finding Description

The `set_failpoints` module exposes a public HTTP endpoint at `/v1/set_failpoint` that accepts unauthenticated GET requests to dynamically configure failure injection points throughout the consensus layer. [1](#0-0) 

The endpoint handler checks only a configuration flag but performs no authentication or access control: [2](#0-1) [3](#0-2) 

**Protection Layers:**

1. **Compile-time**: Requires `failpoints` feature flag [4](#0-3) 

2. **Runtime config**: Checks `api.failpoints_enabled` [5](#0-4) 

3. **Config sanitizer**: Blocks mainnet usage [6](#0-5) 

**Critical Consensus Failpoints:**

The consensus layer contains numerous failpoints that can be triggered remotely: [7](#0-6) [8](#0-7) [9](#0-8) 

**Attack Scenario:**

1. Attacker identifies testnet/devnet validator with public API access
2. Sends GET request: `/v1/set_failpoint?name=consensus::send::vote&actions=return`
3. Validator stops sending votes, causing consensus participation failure
4. Repeat with `consensus::send::proposal`, `consensus::process_proposal_msg`, etc.
5. Network experiences liveness degradation or halt

**Vulnerability Conditions:**

- **Testnet/Devnet**: Explicitly allowed by sanitizer and commonly deployed with failpoints for testing [10](#0-9) 

- **Mainnet (if misconfigured)**: Sanitizer can be bypassed [11](#0-10) 

## Impact Explanation

**Severity: HIGH** per Aptos Bug Bounty criteria:
- **Validator node slowdowns**: Blocking vote/proposal messages degrades consensus performance
- **Significant protocol violations**: Injecting errors in consensus message processing breaks protocol invariants
- **Liveness impact**: Coordinated failpoint injection can halt network progress

**Affected Networks:**
- Testnet/devnet validators with public APIs (common for developer access)
- Mainnet nodes if `skip_config_sanitizer=true` or `chain_id` is unset
- Any validator exposing the API endpoint without additional network-level protection

**Consensus Invariants Broken:**
- **Liveness**: Blocking critical messages prevents progress
- **Availability**: Validators become non-functional
- **Protocol correctness**: Error injection creates abnormal execution paths

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH** for testnet/devnet:
- Testnet validators often expose public APIs for ecosystem developers
- No attacker sophistication required (simple HTTP GET)
- Failpoints feature commonly compiled for testing environments
- Test infrastructure explicitly enables this functionality [12](#0-11) 

**Likelihood: LOW** for mainnet production:
- Config sanitizer prevents normal operation
- Production binaries likely exclude failpoints feature
- Requires operator misconfiguration

## Recommendation

**Immediate Fix: Add Authentication**

Implement bearer token or IP whitelist authentication for the failpoint endpoint:

```rust
pub fn set_failpoint_poem(
    context: Data<&std::sync::Arc<Context>>,
    authorization: Header<String>, // Add auth header
    Query(failpoint_conf): Query<FailpointConf>,
) -> poem::Result<String> {
    // Verify authorization token
    if !verify_failpoint_token(&authorization) {
        return Err(poem::Error::from(anyhow::anyhow!("Unauthorized")));
    }
    
    if context.failpoints_enabled() {
        // existing logic
    }
}
```

**Better Approach: Remove from Production API**

Move failpoint configuration to:
1. Local-only admin endpoint (127.0.0.1)
2. Separate admin service with authentication
3. Configuration file only (no runtime changes)

**Additional Protections:**
- Bind API to localhost by default in configs
- Add rate limiting for failpoint modifications
- Log all failpoint changes for security monitoring
- Document that testnet APIs should not be publicly exposed

## Proof of Concept

**Prerequisites:**
- Testnet validator with `failpoints` feature compiled
- `api.failpoints_enabled = true` in config
- Publicly accessible API endpoint

**Attack Steps:**

```bash
# 1. Identify target testnet validator
TARGET="http://testnet-validator.example.com:8080"

# 2. Block validator from sending votes
curl -X GET "${TARGET}/v1/set_failpoint?name=consensus::send::vote&actions=return"

# 3. Block proposal processing  
curl -X GET "${TARGET}/v1/set_failpoint?name=consensus::process_proposal_msg&actions=return"

# 4. Block round timeouts
curl -X GET "${TARGET}/v1/set_failpoint?name=consensus::send::round_timeout&actions=return"

# Validator now cannot participate in consensus
# Network liveness degrades as validators are disabled
```

**Expected Impact:**
- Targeted validator stops sending votes/proposals
- Consensus quorum reduced by 1
- If repeated across multiple validators, network halts
- Requires manual intervention to clear failpoints

**Test Environment Setup:** [13](#0-12) 

## Notes

**Protection Status by Network:**
- **Mainnet Production**: Protected by config sanitizer unless misconfigured
- **Testnet/Devnet**: Vulnerable by design - failpoints intentionally enabled for testing
- **Local Development**: Expected behavior for fault injection testing

**Design vs. Vulnerability:**
This is a debug/test feature inappropriately exposed as a production API endpoint without access controls. While mainnet has protections, the lack of authentication represents a significant security gap for non-mainnet production deployments that serve real users and developers.

### Citations

**File:** api/src/runtime.rs (L248-251)
```rust
                    .at(
                        "/set_failpoint",
                        poem::get(set_failpoints::set_failpoint_poem).data(context.clone()),
                    ),
```

**File:** api/src/set_failpoints.rs (L23-40)
```rust
pub fn set_failpoint_poem(
    context: Data<&std::sync::Arc<Context>>,
    Query(failpoint_conf): Query<FailpointConf>,
) -> poem::Result<String> {
    if context.failpoints_enabled() {
        fail::cfg(&failpoint_conf.name, &failpoint_conf.actions)
            .map_err(|e| poem::Error::from(anyhow::anyhow!(e)))?;
        info!(
            "Configured failpoint {} to {}",
            failpoint_conf.name, failpoint_conf.actions
        );
        Ok(format!("Set failpoint {}", failpoint_conf.name))
    } else {
        Err(poem::Error::from(anyhow::anyhow!(
            "Failpoints are not enabled at a config level"
        )))
    }
}
```

**File:** api/src/context.rs (L209-211)
```rust
    pub fn failpoints_enabled(&self) -> bool {
        self.node_config.api.failpoints_enabled
    }
```

**File:** api/Cargo.toml (L70-71)
```text
[features]
failpoints = ["fail/failpoints"]
```

**File:** config/src/config/api_config.rs (L32-34)
```rust
    /// Enables failpoints for error testing
    #[serde(default = "default_disabled")]
    pub failpoints_enabled: bool,
```

**File:** config/src/config/api_config.rs (L177-185)
```rust
        // Verify that failpoints are not enabled in mainnet
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() && api_config.failpoints_enabled {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Failpoints are not supported on mainnet nodes!".into(),
                ));
            }
        }
```

**File:** config/src/config/api_config.rs (L284-284)
```rust
        ApiConfig::sanitize(&node_config, NodeType::Validator, Some(ChainId::testnet())).unwrap();
```

**File:** consensus/src/network.rs (L479-482)
```rust
        fail_point!("consensus::send::vote", |_| ());
        let msg = ConsensusMsg::VoteMsg(Box::new(vote_msg));
        self.broadcast(msg).await
    }
```

**File:** consensus/src/network.rs (L521-524)
```rust
        fail_point!("consensus::send::vote", |_| ());
        let msg = ConsensusMsg::VoteMsg(Box::new(vote_msg));
        self.send(msg, recipients).await
    }
```

**File:** consensus/src/round_manager.rs (L727-729)
```rust
        fail_point!("consensus::process_proposal_msg", |_| {
            Err(anyhow::anyhow!("Injected error in process_proposal_msg"))
        });
```

**File:** config/src/config/config_sanitizer.rs (L45-48)
```rust
        // If config sanitization is disabled, don't do anything!
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }
```

**File:** testsuite/smoke-test/src/consensus/dag/dag_fault_tolerance.rs (L24-26)
```rust
        .with_init_config(Arc::new(move |_, config, _| {
            config.api.failpoints_enabled = true;
            config
```

**File:** testsuite/forge/src/test_utils/consensus_utils.rs (L301-308)
```rust
            validator_clients[validator_idx]
                .1
                .set_failpoint(name.clone(), actions.clone())
                .await
                .context(validator_clients[validator_idx].0.clone())
                .unwrap();
            self.modified_failpoints.insert((validator_idx, name));
        }
```
