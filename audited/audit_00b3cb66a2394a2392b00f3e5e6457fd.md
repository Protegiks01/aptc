# Audit Report

## Title
Protocol Upgrade Network Partition Vulnerability in Validator Discovery System

## Summary
During protocol upgrades that introduce new `Protocol` enum variants in `NetworkAddress` encoding, old nodes silently fail to parse upgraded validators' network addresses and treat them as having empty addresses. This prevents old nodes from establishing connections with upgraded validators, causing network partition and potential loss of consensus participation during rolling upgrades.

## Finding Description

The vulnerability exists in the validator discovery system's handling of network address deserialization failures. When the `Protocol` enum in `NetworkAddress` is extended with new variants (e.g., adding QUIC support), a critical failure path emerges:

**Step 1: Protocol Upgrade Adds New Variant**
A protocol upgrade extends the `Protocol` enum with a new variant. [1](#0-0) 

**Step 2: Validators Update Their Addresses**
Upgraded validators call `update_network_and_fullnode_addresses()` to advertise the new protocol in their network addresses. These changes take effect at the next epoch. [2](#0-1) 

The addresses are stored as BCS-serialized `vector<u8>` without content validation: [3](#0-2) 

**Step 3: Old Nodes Attempt Deserialization**
When old nodes receive the updated validator set from on-chain configuration, they attempt to deserialize these addresses: [4](#0-3) 

BCS deserialization fails because old nodes don't recognize the new `Protocol` variant index. The `Deserialize` implementation attempts to deserialize unknown enum variants, which causes a BCS error: [5](#0-4) 

**Step 4: Error Silently Swallowed**
The critical flaw occurs in `extract_validator_set_updates()` where the deserialization error is caught but handled incorrectly: [6](#0-5) 

The `.unwrap_or_default()` on line 140 causes the function to return an empty address vector instead of propagating the error or retaining old addresses.

**Step 5: Empty Peer Created**
A `Peer` is created with empty addresses, which also results in empty keys since keys are extracted from addresses: [7](#0-6) 

**Step 6: Peer Marked Ineligible**
In the connectivity manager, peers with empty keys fail the eligibility check: [8](#0-7) 

**Step 7: Network Partition**
Old nodes cannot dial upgraded validators because they're filtered out as ineligible, causing network partition during rolling upgrades.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program for the following reasons:

1. **Validator Node Disconnections**: Old nodes lose connectivity with upgraded validators, directly matching the "Validator node slowdowns" category.

2. **Significant Protocol Violation**: The validator discovery protocol fails to maintain network connectivity during legitimate protocol upgrades, violating the fundamental requirement that nodes should be able to discover and connect to validators.

3. **Potential Loss of Liveness**: If a sufficient number of validators upgrade simultaneously (which is common in coordinated upgrades), old nodes may lose quorum and be unable to participate in consensus, approaching "Total loss of liveness" territory.

4. **Breaks Consensus Safety Invariant**: The inability to connect to validators violates the critical invariant that "All validators must be able to communicate for consensus to function correctly."

While this doesn't reach Critical severity (no direct fund loss, can be recovered by upgrading remaining nodes), it represents a serious operational security issue that could disrupt the network during routine maintenance.

## Likelihood Explanation

**Likelihood: High**

This vulnerability will trigger automatically during any protocol upgrade that:
1. Adds new variants to the `Protocol` enum
2. Allows validators to use these new variants in their network addresses
3. Occurs as a rolling upgrade where not all nodes upgrade simultaneously

The likelihood is high because:
- Protocol upgrades are routine operations on blockchain networks
- Adding new transport protocols (QUIC, WebTransport) or encryption methods (TLS 1.3) would require new `Protocol` variants
- Rolling upgrades are standard practice to avoid network downtime
- There is no version gating mechanism preventing validators from updating addresses before all nodes upgrade
- The validator address update function permits arbitrary BCS-serialized addresses without validation

The vulnerability requires no malicious actorâ€”it occurs naturally during legitimate network evolution.

## Recommendation

**Immediate Fixes:**

1. **Do Not Silently Ignore Parse Errors** - Instead of returning empty addresses on parse failure, log an error and retain the previous known-good addresses:

```rust
let addrs = if is_validator {
    config.validator_network_addresses()
} else {
    config.fullnode_network_addresses()
}
.unwrap_or_else(|err| {
    inc_by_with_context(&DISCOVERY_COUNTS, &network_context, "read_failure", 1);
    error!(
        NetworkSchema::new(&network_context),
        "OnChainDiscovery: Failed to parse network addresses for peer {}, keeping previous addresses. Error: {}",
        peer_id,
        err
    );
    // Return previously known addresses or empty if this is first discovery
    Vec::new() // In production, retrieve from discovered_peers cache
});
```

2. **Add Version Field to NetworkAddress Serialization** - Implement forward-compatible serialization:

```rust
struct VersionedNetworkAddress {
    version: u8,
    protocols: Vec<Protocol>,
}
```

Old nodes can check the version field and handle unknown versions gracefully.

3. **Implement Feature Flag Gating** - Add on-chain feature flags that gate when validators can use new `Protocol` variants in their addresses:

```move
public fun can_use_protocol_version(version: u8): bool {
    features::is_enabled(PROTOCOL_VERSION_X_ENABLED)
}
```

4. **Add Address Validation** - Validate network addresses in `update_network_and_fullnode_addresses()` to ensure they can be parsed by the current protocol version.

**Long-term Solutions:**

1. Implement protocol version negotiation where nodes advertise supported protocol versions
2. Add minimum software version requirements before validators can update to new address formats
3. Implement gradual rollout mechanism with multiple epoch delay for address format changes

## Proof of Concept

```rust
#[cfg(test)]
mod network_partition_test {
    use super::*;
    use aptos_types::{
        network_address::{NetworkAddress, Protocol},
        validator_config::ValidatorConfig,
        validator_info::ValidatorInfo,
    };
    use aptos_crypto::{bls12381, x25519, PrivateKey, Uniform};
    use rand::{rngs::StdRng, SeedableRng};

    #[test]
    fn test_incompatible_protocol_causes_empty_addresses() {
        // Setup
        let mut rng = StdRng::from_seed([0u8; 32]);
        let network_context = NetworkContext::mock();
        
        // Create a validator with standard address
        let consensus_key = bls12381::PrivateKey::generate(&mut rng).public_key();
        let network_key = x25519::PrivateKey::generate(&mut rng).public_key();
        let peer_id = PeerId::random();
        
        // Create address with known protocol
        let old_addr = NetworkAddress::from_str("/ip4/127.0.0.1/tcp/6180")
            .unwrap()
            .append_prod_protos(network_key, 0);
        let old_encoded = bcs::to_bytes(&vec![old_addr.clone()]).unwrap();
        
        // Simulate protocol upgrade: add new Protocol::Quic(u16) variant
        // In real scenario, new code would have: enum Protocol { ..., Quic(u16) }
        // Old nodes don't know about Quic, so manually craft incompatible bytes
        
        // Serialize with new variant index (e.g., variant 8 for Quic)
        let mut new_encoded = vec![1u8]; // vec length = 1
        new_encoded.push(3u8); // number of protocols in address
        new_encoded.extend_from_slice(&[0, 127, 0, 0, 1]); // Ip4
        new_encoded.extend_from_slice(&[5, 0x18, 0x1c]); // Tcp(6180)
        new_encoded.push(8u8); // NEW UNKNOWN VARIANT INDEX (Quic)
        new_encoded.extend_from_slice(&[0x50, 0x00]); // port 80
        
        let config = ValidatorConfig::new(
            consensus_key,
            new_encoded, // Contains unknown Protocol variant
            old_encoded.clone(),
            0,
        );
        
        // Old node tries to parse - this should fail
        let result = config.validator_network_addresses();
        assert!(result.is_err(), "Should fail to parse unknown Protocol variant");
        
        // Simulate extract_validator_set_updates behavior
        let validator_info = ValidatorInfo::new(peer_id, 0, config);
        let node_set = ValidatorSet::new(vec![validator_info]);
        
        let peer_set = extract_validator_set_updates(network_context, node_set);
        
        // Verify that peer has empty addresses (the vulnerability)
        let peer = peer_set.get(&peer_id).unwrap();
        assert!(peer.addresses.is_empty(), "Addresses should be empty due to parse failure");
        assert!(peer.keys.is_empty(), "Keys should be empty since no addresses to extract from");
        
        // This peer would fail is_eligible() check in ConnectivityManager
        // causing network partition
    }
}
```

This test demonstrates that when an old node encounters a `ValidatorConfig` with addresses containing an unknown `Protocol` variant, the deserialization fails and `extract_validator_set_updates()` returns a peer with empty addresses and keys, making it ineligible for connection establishment.

### Citations

**File:** types/src/network_address/mod.rs (L111-127)
```rust
#[derive(Clone, Debug, Eq, Hash, PartialEq, Deserialize, Serialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub enum Protocol {
    Ip4(Ipv4Addr),
    Ip6(Ipv6Addr),
    Dns(DnsName),
    Dns4(DnsName),
    Dns6(DnsName),
    Tcp(u16),
    Memory(u16),
    // human-readable x25519::PublicKey is lower-case hex encoded
    NoiseIK(x25519::PublicKey),
    // TODO(philiphayes): use actual handshake::MessagingProtocolVersion. we
    // probably need to move network wire into its own crate to avoid circular
    // dependency b/w network and types.
    Handshake(u8),
}
```

**File:** types/src/network_address/mod.rs (L548-565)
```rust
impl<'de> Deserialize<'de> for NetworkAddress {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        if deserializer.is_human_readable() {
            let s = <String>::deserialize(deserializer)?;
            NetworkAddress::from_str(s.as_str()).map_err(de::Error::custom)
        } else {
            #[derive(Deserialize)]
            #[serde(rename = "NetworkAddress")]
            struct Wrapper(#[serde(with = "serde_bytes")] Vec<u8>);

            Wrapper::deserialize(deserializer)
                .and_then(|v| bcs::from_bytes(&v.0).map_err(de::Error::custom))
                .and_then(|v: Vec<Protocol>| NetworkAddress::try_from(v).map_err(de::Error::custom))
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L954-995)
```text
    /// Update the network and full node addresses of the validator. This only takes effect in the next epoch.
    public entry fun update_network_and_fullnode_addresses(
        operator: &signer,
        pool_address: address,
        new_network_addresses: vector<u8>,
        new_fullnode_addresses: vector<u8>,
    ) acquires StakePool, ValidatorConfig {
        check_stake_permission(operator);
        assert_reconfig_not_in_progress();
        assert_stake_pool_exists(pool_address);
        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        assert!(signer::address_of(operator) == stake_pool.operator_address, error::unauthenticated(ENOT_OPERATOR));
        assert!(exists<ValidatorConfig>(pool_address), error::not_found(EVALIDATOR_CONFIG));
        let validator_info = borrow_global_mut<ValidatorConfig>(pool_address);
        let old_network_addresses = validator_info.network_addresses;
        validator_info.network_addresses = new_network_addresses;
        let old_fullnode_addresses = validator_info.fullnode_addresses;
        validator_info.fullnode_addresses = new_fullnode_addresses;

        if (std::features::module_event_migration_enabled()) {
            event::emit(
                UpdateNetworkAndFullnodeAddresses {
                    pool_address,
                    old_network_addresses,
                    new_network_addresses,
                    old_fullnode_addresses,
                    new_fullnode_addresses,
                },
            );
        } else {
            event::emit_event(
                &mut stake_pool.update_network_and_fullnode_addresses_events,
                UpdateNetworkAndFullnodeAddressesEvent {
                    pool_address,
                    old_network_addresses,
                    new_network_addresses,
                    old_fullnode_addresses,
                    new_fullnode_addresses,
                },
            );
        };
    }
```

**File:** types/src/validator_config.rs (L38-42)
```rust
    /// This is an bcs serialized `Vec<NetworkAddress>`
    pub validator_network_addresses: Vec<u8>,
    /// This is an bcs serialized `Vec<NetworkAddress>`
    pub fullnode_network_addresses: Vec<u8>,
    pub validator_index: u64,
```

**File:** types/src/validator_config.rs (L60-66)
```rust
    pub fn fullnode_network_addresses(&self) -> Result<Vec<NetworkAddress>, bcs::Error> {
        bcs::from_bytes(&self.fullnode_network_addresses)
    }

    pub fn validator_network_addresses(&self) -> Result<Vec<NetworkAddress>, bcs::Error> {
        bcs::from_bytes(&self.validator_network_addresses)
    }
```

**File:** network/discovery/src/validator_set.rs (L121-140)
```rust
            let addrs = if is_validator {
                config
                    .validator_network_addresses()
                    .map_err(anyhow::Error::from)
            } else {
                config
                    .fullnode_network_addresses()
                    .map_err(anyhow::Error::from)
            }
            .map_err(|err| {
                inc_by_with_context(&DISCOVERY_COUNTS, &network_context, "read_failure", 1);

                warn!(
                    NetworkSchema::new(&network_context),
                    "OnChainDiscovery: Failed to parse any network address: peer: {}, err: {}",
                    peer_id,
                    err
                )
            })
            .unwrap_or_default();
```

**File:** config/src/config/network_config.rs (L498-504)
```rust
    pub fn from_addrs(role: PeerRole, addresses: Vec<NetworkAddress>) -> Peer {
        let keys: HashSet<x25519::PublicKey> = addresses
            .iter()
            .filter_map(NetworkAddress::find_noise_proto)
            .collect();
        Peer::new(addresses, keys, role)
    }
```

**File:** network/framework/src/connectivity_manager/mod.rs (L254-262)
```rust
    /// Peers without keys are not able to be mutually authenticated to
    pub fn is_eligible(&self) -> bool {
        !self.keys.is_empty()
    }

    /// Peers without addresses can't be dialed to
    pub fn is_eligible_to_be_dialed(&self) -> bool {
        self.is_eligible() && !self.addrs.is_empty()
    }
```
