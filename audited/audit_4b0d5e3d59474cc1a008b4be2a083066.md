# Audit Report

## Title
Consensus Safety Violation: Non-Persisted `preferred_round` Update in `sign_proposal()` Allows Leader Equivocation After Crash

## Summary
The `sign_proposal()` function in SafetyRules updates `preferred_round` in memory but explicitly does not persist it to storage for performance reasons. If a validator crashes after signing a proposal but before voting occurs, the `preferred_round` reverts to its pre-signature value on restart, allowing the leader to re-sign proposals with older quorum certificates that should have been rejected by the 2-chain safety rule.

## Finding Description
The AptosBFT consensus protocol relies on SafetyRules to enforce voting safety invariants, including the 2-chain rule that prevents validators from signing proposals with quorum certificates older than their current `preferred_round` (the highest observed 2-chain head). [1](#0-0) 

The vulnerability exists in the `guarded_sign_proposal()` function. When a leader calls `sign_proposal()` to sign a block proposal:

1. Line 353 loads `safety_data` from persistent storage
2. Line 365 calls `verify_and_update_preferred_round()`, which updates `preferred_round` in the in-memory `safety_data` structure
3. Line 366 contains an explicit comment: "we don't persist the updated preferred round to save latency (it'd be updated upon voting)"
4. Line 368 generates and returns the signature

Critically, there is **no call to `set_safety_data()`** to persist the updated `preferred_round` value. This contrasts with the voting path: [2](#0-1) 

In `construct_and_sign_vote_two_chain()`, line 84 updates the safety data via `observe_qc()`, and line 92 **persists** all updates via `self.persistent_storage.set_safety_data(safety_data)?`.

The `verify_and_update_preferred_round()` function enforces the 2-chain safety rule: [3](#0-2) 

This function checks that `one_chain_round >= preferred_round`, preventing leaders from signing proposals with stale quorum certificates. However, because the `preferred_round` update is not persisted in `sign_proposal()`, this safety check can be bypassed through a crash-restart cycle.

**Attack Scenario:**

**Initial State:**
- `preferred_round = 5`
- `last_voted_round = 4`

**Step 1:** Leader signs proposal P1
- Round: 10
- QC certifies block at round 8 (parent at round 7)
- `verify_and_update_preferred_round()` checks: `8 >= 5` ✓
- In-memory update: `preferred_round = 7`
- Returns signature S1
- **No persistence occurs**

**Step 2:** Node crashes before any voting
- On restart, storage contains: `preferred_round = 5` (old value)

**Step 3:** Leader re-signs proposal P2 for the same round
- Round: 10 (same as P1)
- QC certifies block at round 6 (parent at round 5)
- `verify_and_update_preferred_round()` checks: `6 >= 5` ✓ (passes with stale `preferred_round`)
- Returns signature S2

**Result:** The leader now has two valid signatures (S1 and S2) for round 10 with conflicting quorum certificates. This is **leader equivocation**, a fundamental consensus safety violation.

The vulnerability is confirmed by examining the SafetyData structure: [4](#0-3) 

The `preferred_round` field (line 14) is documented as "highest 2-chain round" and is the critical value that's not being persisted.

## Impact Explanation
This vulnerability constitutes a **High Severity** issue under the Aptos bug bounty program criteria for "Significant protocol violations."

The vulnerability violates the fundamental consensus safety guarantee documented in the README: [5](#0-4) 

The README explicitly states that SafetyRules "guarantees that the two voting rules are followed — even in the case of restart (since all safety data is persisted to local storage)." However, the `preferred_round` update in `sign_proposal()` is **not** persisted, violating this guarantee.

**Potential Impacts:**
1. **Leader Equivocation:** A Byzantine or crashed-and-restarted leader can sign multiple proposals for the same round with different quorum certificates
2. **Vote Splitting:** If both proposals are broadcast to different validator subsets, validators might vote on different proposals, preventing quorum formation
3. **Consensus Liveness Degradation:** Repeated equivocation could delay or prevent block commits
4. **Safety Violation (Conditional):** If combined with other protocol weaknesses, could potentially lead to chain splits

While the protocol has additional defenses (validators' own safety checks, equivocation detection), the existence of a bypassable safety check in the leader's proposal signing logic is itself a protocol violation that undermines the defense-in-depth security model.

## Likelihood Explanation
**Likelihood: Medium-High**

This vulnerability can manifest in two scenarios:

1. **Accidental Exploitation (High Probability):**
   - Validator experiences crash, OOM, power failure, or software bug during proposal generation
   - Crash window exists between signing and voting (typically seconds to minutes depending on network conditions)
   - On restart, validator might regenerate proposal for the same round with different state
   - No malicious intent required

2. **Deliberate Byzantine Exploitation (Medium Probability):**
   - Byzantine validator deliberately crashes after signing to exploit the persistence gap
   - Requires validator access but only single Byzantine node (within fault tolerance bounds)
   - Can be executed systematically to disrupt consensus

The vulnerability is particularly concerning because:
- The optimization comment suggests this is intentional design, meaning it may not be noticed or fixed in normal operations
- Crash-restart cycles are common in production distributed systems
- The time window for exploitation is relatively large (until voting completes)

## Recommendation
**Fix: Persist `preferred_round` update atomically with proposal signature**

Modify `guarded_sign_proposal()` to persist the safety data after updating `preferred_round`:

```rust
fn guarded_sign_proposal(
    &mut self,
    block_data: &BlockData,
) -> Result<bls12381::Signature, Error> {
    self.signer()?;
    self.verify_author(block_data.author())?;

    let mut safety_data = self.persistent_storage.safety_data()?;
    self.verify_epoch(block_data.epoch(), &safety_data)?;

    if block_data.round() <= safety_data.last_voted_round {
        return Err(Error::InvalidProposal(format!(
            "Proposed round {} is not higher than last voted round {}",
            block_data.round(),
            safety_data.last_voted_round
        )));
    }

    self.verify_qc(block_data.quorum_cert())?;
    let updated = self.verify_and_update_preferred_round(block_data.quorum_cert(), &mut safety_data)?;
    
    // CRITICAL FIX: Persist the preferred_round update before signing
    if updated {
        self.persistent_storage.set_safety_data(safety_data.clone())?;
    }

    let signature = self.sign(block_data)?;
    Ok(signature)
}
```

**Alternative Optimization:** If persistence latency is critical, implement a write-ahead log or two-phase commit:
1. Log the pending `preferred_round` update before signing
2. Return the signature
3. Asynchronously persist to storage
4. On crash recovery, replay any uncommitted updates from the log

This ensures crash-consistency while maintaining performance.

## Proof of Concept

```rust
#[test]
fn test_sign_proposal_crash_allows_equivocation() {
    use consensus::safety_rules::{PersistentSafetyStorage, SafetyRules};
    use consensus_types::block_data::BlockData;
    use aptos_crypto::bls12381;
    
    // Setup: Initialize SafetyRules with persistent storage
    let (mut safety_rules, signer) = setup_safety_rules_with_storage();
    let (proof, genesis_qc) = make_genesis(&signer);
    safety_rules.initialize(&proof).unwrap();
    
    // Step 1: Create and sign proposal P1 with QC at round 8
    let qc_round_8 = make_qc_at_round(8, &signer);
    let proposal_p1 = make_proposal_with_qc(10, qc_round_8.clone(), &signer);
    let signature_1 = safety_rules.sign_proposal(proposal_p1.block().block_data()).unwrap();
    
    // Verify preferred_round was updated in memory (but not persisted)
    let safety_data_before_crash = safety_rules.persistent_storage.safety_data().unwrap();
    assert_eq!(safety_data_before_crash.preferred_round, 0); // Still old value in storage!
    
    // Step 2: Simulate crash and restart
    drop(safety_rules);
    let mut safety_rules = SafetyRules::new(
        PersistentSafetyStorage::from_same_storage(), 
        false
    );
    
    // Step 3: Sign proposal P2 for the same round with older QC at round 6
    let qc_round_6 = make_qc_at_round(6, &signer);
    let proposal_p2 = make_proposal_with_qc(10, qc_round_6.clone(), &signer);
    let signature_2 = safety_rules.sign_proposal(proposal_p2.block().block_data()).unwrap();
    
    // VULNERABILITY: Both signatures are valid for round 10 with different QCs
    assert_ne!(signature_1, signature_2);
    assert_ne!(proposal_p1.block().id(), proposal_p2.block().id());
    
    // This demonstrates leader equivocation - signing two different proposals
    // for the same round, which violates consensus safety.
}
```

**Notes:**
- The vulnerability is explicitly acknowledged in the code comment but the security implications are not discussed
- The design assumes voting will quickly follow proposal signing, but this assumption breaks during crashes
- The issue affects only leaders during proposal generation, but consensus safety requires ALL validators to maintain correct safety invariants
- The fix requires careful consideration of performance vs. safety tradeoffs, but safety must take priority in a consensus protocol

### Citations

**File:** consensus/safety-rules/src/safety_rules.rs (L173-188)
```rust
    fn verify_and_update_preferred_round(
        &mut self,
        quorum_cert: &QuorumCert,
        safety_data: &mut SafetyData,
    ) -> Result<bool, Error> {
        let preferred_round = safety_data.preferred_round;
        let one_chain_round = quorum_cert.certified_block().round();

        if one_chain_round < preferred_round {
            return Err(Error::IncorrectPreferredRound(
                one_chain_round,
                preferred_round,
            ));
        }
        Ok(self.observe_qc(quorum_cert, safety_data))
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L346-370)
```rust
    fn guarded_sign_proposal(
        &mut self,
        block_data: &BlockData,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;
        self.verify_author(block_data.author())?;

        let mut safety_data = self.persistent_storage.safety_data()?;
        self.verify_epoch(block_data.epoch(), &safety_data)?;

        if block_data.round() <= safety_data.last_voted_round {
            return Err(Error::InvalidProposal(format!(
                "Proposed round {} is not higher than last voted round {}",
                block_data.round(),
                safety_data.last_voted_round
            )));
        }

        self.verify_qc(block_data.quorum_cert())?;
        self.verify_and_update_preferred_round(block_data.quorum_cert(), &mut safety_data)?;
        // we don't persist the updated preferred round to save latency (it'd be updated upon voting)

        let signature = self.sign(block_data)?;
        Ok(signature)
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L84-92)
```rust
        self.observe_qc(proposed_block.quorum_cert(), &mut safety_data);
        // Construct and sign vote
        let author = self.signer()?.author();
        let ledger_info = self.construct_ledger_info_2chain(proposed_block, vote_data.hash())?;
        let signature = self.sign(&ledger_info)?;
        let vote = Vote::new_with_signature(vote_data, author, ledger_info, signature);

        safety_data.last_vote = Some(vote.clone());
        self.persistent_storage.set_safety_data(safety_data)?;
```

**File:** consensus/consensus-types/src/safety_data.rs (L8-21)
```rust
/// Data structure for safety rules to ensure consensus safety.
#[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```

**File:** consensus/README.md (L46-46)
```markdown
* **SafetyRules** is responsible for the safety of the consensus protocol. It processes quorum certificates and LedgerInfo to learn about new commits and guarantees that the two voting rules are followed &mdash; even in the case of restart (since all safety data is persisted to local storage).
```
