# Audit Report

## Title
Missing Signature Verification for Remote Batch Transactions Enables Consensus DoS Attack

## Summary
Remote batches received from network peers do not validate transaction signatures before insertion into batch tracking structures, allowing malicious validators to broadcast batches containing transactions with invalid signatures. This enables transaction censorship, resource exhaustion, and consensus-level denial of service attacks.

## Finding Description

The Aptos quorum store batch verification flow has a critical gap in signature validation. When a validator receives batches from remote peers, the system validates batch-level integrity but **does not verify the cryptographic signatures of individual SignedTransaction objects** before inserting them into tracking structures.

**Attack Flow:**

1. **Local Batches (Safe Path):** Transactions submitted locally pass through mempool validation which includes signature verification via `AptosVM::validate_transaction()`. [1](#0-0) 

2. **Remote Batches (Vulnerable Path):** When `BatchMsg` is received from the network, it undergoes verification in `UnverifiedEvent::verify()`. [2](#0-1) 

3. **Insufficient Validation:** The `Batch::verify()` method only checks: payload author match, hash/digest match, transaction count, byte count, gas price constraints, and encryption status. [3](#0-2) 

   **Critically missing:** No call to `transaction.check_signature()` or `transaction.verify_signature()` to validate cryptographic signatures.

4. **Insertion Without Validation:** After passing batch-level checks, `BatchCoordinator::handle_batches_msg()` forwards transactions to `BatchGenerator` via `RemoteBatch` command. [4](#0-3) 

5. **Transaction Blocking:** The `insert_batch()` function creates `TransactionSummary` entries and adds them to `txns_in_progress_sorted` without signature validation. [5](#0-4) 

6. **Mempool Exclusion Mechanism:** When pulling transactions from mempool, `txns_in_progress_sorted` is used as an exclusion list, preventing legitimate transactions with the same (sender, sequence_number) from being batched. [6](#0-5) 

**Exploitation:** A malicious validator crafts batches containing `SignedTransaction` objects with invalid signatures but valid transaction structure. These transactions:
- Pass batch verification (no signature check)
- Get inserted into `batches_in_progress` and `txns_in_progress_sorted`
- Block legitimate transactions from the same accounts
- Consume memory and storage quota
- Force other validators to track and broadcast invalid data
- Only fail much later during execution (after resource damage)

## Impact Explanation

**High Severity** - This vulnerability enables multiple attack vectors:

1. **Transaction Censorship:** Malicious validators can prevent specific accounts from transacting by flooding batches with invalid-signature transactions matching those accounts' (sender, sequence_number) pairs. The exclusion mechanism blocks legitimate transactions until malicious batches expire.

2. **Resource Exhaustion:** Each invalid batch consumes memory in `batches_in_progress` and `txns_in_progress_sorted`, storage quota in `QuotaManager`, and network bandwidth. With sufficient batches, a malicious validator can exhaust victim nodes' resources.

3. **Consensus Disruption:** All validators tracking the same invalid batches waste collective resources. The protocol continues functioning but with degraded performance and increased latency.

4. **Network Amplification:** Invalid batches trigger signed batch info broadcasts, amplifying the attack across the network. [7](#0-6) 

This qualifies as **High Severity** per Aptos bug bounty criteria: "Validator node slowdowns" and "Significant protocol violations."

## Likelihood Explanation

**High Likelihood** - The attack is easily executable:

1. **Low Barrier:** Any validator can craft invalid-signature transactions using standard transaction construction with modified signatures.

2. **No Detection:** The vulnerable code path has no signature validation, so malicious batches are accepted deterministically.

3. **Amplification:** A single malicious validator can impact all validators in the network simultaneously.

4. **Persistence:** Invalid batches remain in tracking structures until timeout (configurable expiry periods), providing extended attack windows.

5. **Byzantine Tolerance:** While AptosBFT tolerates < 1/3 Byzantine validators for consensus safety, this vulnerability operates at the batch tracking layer before consensus, affecting all nodes regardless of fault tolerance thresholds.

## Recommendation

Add signature verification before inserting remote batches into tracking structures. Two implementation options:

**Option 1: Verify in `Batch::verify()` method:**
```rust
pub fn verify(&self) -> anyhow::Result<()> {
    // ... existing checks ...
    
    // Add signature verification
    for txn in self.payload.txns() {
        txn.verify_signature()
            .map_err(|_| anyhow::anyhow!("Invalid transaction signature"))?;
    }
    Ok(())
}
```

**Option 2: Verify in `BatchGenerator::handle_remote_batch()`:**
```rust
pub(crate) fn handle_remote_batch(
    &mut self,
    author: PeerId,
    batch_id: BatchId,
    txns: Vec<SignedTransaction>,
) {
    // Validate signatures before inserting
    let validated_txns: Vec<SignedTransaction> = txns
        .into_iter()
        .filter(|txn| txn.verify_signature().is_ok())
        .collect();
    
    if validated_txns.is_empty() {
        return; // Reject batch with all invalid signatures
    }
    
    let expiry_time_usecs = aptos_infallible::duration_since_epoch().as_micros() as u64
        + self.config.remote_batch_expiry_gap_when_init_usecs;
    self.insert_batch(author, batch_id, validated_txns, expiry_time_usecs);
}
```

**Recommendation:** Implement Option 1 (verify in `Batch::verify()`) as it provides defense-in-depth at the earliest validation point and is consistent with the existing verification pattern.

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[tokio::test]
async fn test_invalid_signature_batch_accepted() {
    use aptos_crypto::{ed25519::Ed25519PrivateKey, PrivateKey, Uniform};
    use aptos_types::transaction::{RawTransaction, SignedTransaction, TransactionPayload};
    use aptos_types::chain_id::ChainId;
    
    // Create a valid transaction
    let sender_key = Ed25519PrivateKey::generate_for_testing();
    let sender = aptos_types::account_address::AccountAddress::random();
    
    let raw_txn = RawTransaction::new(
        sender,
        0, // sequence number
        TransactionPayload::Script(Script::new(vec![], vec![], vec![])),
        1000000, // max_gas
        1, // gas_price
        u64::MAX, // expiration
        ChainId::test(),
    );
    
    // Create INVALID signature using wrong key
    let wrong_key = Ed25519PrivateKey::generate_for_testing();
    let invalid_signature = wrong_key.sign(&raw_txn).unwrap();
    
    let invalid_txn = SignedTransaction::new(
        raw_txn.clone(),
        sender_key.public_key(),
        invalid_signature, // WRONG signature
    );
    
    // Verify signature is actually invalid
    assert!(invalid_txn.verify_signature().is_err());
    
    // Create batch with invalid transaction
    let batch = Batch::new_v2(
        BatchId::new(1),
        vec![invalid_txn],
        1, // epoch
        u64::MAX,
        PeerId::random(),
        100,
        BatchKind::Normal,
    );
    
    // Batch verification SUCCEEDS despite invalid signature
    assert!(batch.verify().is_ok()); // This should fail but doesn't!
    
    // The batch would be inserted into tracking structures
    // and block legitimate transactions from the same sender
}
```

**Expected Behavior:** `batch.verify()` should return an error when transactions have invalid signatures.

**Actual Behavior:** `batch.verify()` succeeds, allowing invalid-signature transactions into the batch tracking system.

---

**Notes:**

The vulnerability stems from an incomplete threat model assumption. While local transactions undergo rigorous validation including signature verification before entering mempool, the code incorrectly assumes that remote batches from validators are pre-validated. This asymmetry creates an exploitable gap where Byzantine validators can inject invalid transactions into the consensus layer's batch tracking system, bypassing the signature verification that normal transaction submission paths enforce.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3232-3237)
```rust
        let txn = match transaction.check_signature() {
            Ok(t) => t,
            _ => {
                return VMValidatorResult::error(StatusCode::INVALID_SIGNATURE);
            },
        };
```

**File:** consensus/src/round_manager.rs (L166-183)
```rust
            UnverifiedEvent::BatchMsg(b) => {
                if !self_message {
                    b.verify(peer_id, max_num_batches, validator)?;
                    counters::VERIFY_MSG
                        .with_label_values(&["batch"])
                        .observe(start_time.elapsed().as_secs_f64());
                }
                VerifiedEvent::BatchMsg(Box::new((*b).into()))
            },
            UnverifiedEvent::BatchMsgV2(b) => {
                if !self_message {
                    b.verify(peer_id, max_num_batches, validator)?;
                    counters::VERIFY_MSG
                        .with_label_values(&["batch_v2"])
                        .observe(start_time.elapsed().as_secs_f64());
                }
                VerifiedEvent::BatchMsg(b)
            },
```

**File:** consensus/src/quorum_store/types.rs (L262-290)
```rust
    pub fn verify(&self) -> anyhow::Result<()> {
        ensure!(
            self.payload.author() == self.author(),
            "Payload author doesn't match the info"
        );
        ensure!(
            self.payload.hash() == *self.digest(),
            "Payload hash doesn't match the digest"
        );
        ensure!(
            self.payload.num_txns() as u64 == self.num_txns(),
            "Payload num txns doesn't match batch info"
        );
        ensure!(
            self.payload.num_bytes() as u64 == self.num_bytes(),
            "Payload num bytes doesn't match batch info"
        );
        for txn in self.payload.txns() {
            ensure!(
                txn.gas_unit_price() >= self.gas_bucket_start(),
                "Payload gas unit price doesn't match batch info"
            );
            ensure!(
                !txn.payload().is_encrypted_variant(),
                "Encrypted transaction is not supported yet"
            );
        }
        Ok(())
    }
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L102-111)
```rust
            if persist_requests[0].batch_info().is_v2() {
                let signed_batch_infos = batch_store.persist(persist_requests);
                if !signed_batch_infos.is_empty() {
                    if approx_created_ts_usecs > 0 {
                        observe_batch(approx_created_ts_usecs, peer_id, BatchStage::SIGNED);
                    }
                    network_sender
                        .send_signed_batch_info_msg_v2(signed_batch_infos, vec![peer_id])
                        .await;
                }
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L229-239)
```rust
        for batch in batches.into_iter() {
            // TODO: maybe don't message batch generator if the persist is unsuccessful?
            if let Err(e) = self
                .sender_to_batch_generator
                .send(BatchGeneratorCommand::RemoteBatch(batch.clone()))
                .await
            {
                warn!("Failed to send batch to batch generator: {}", e);
            }
            persist_requests.push(batch.into());
        }
```

**File:** consensus/src/quorum_store/batch_generator.rs (L134-158)
```rust
        let txns_in_progress: Vec<_> = txns
            .par_iter()
            .with_min_len(optimal_min_len(txns.len(), 32))
            .map(|txn| {
                (
                    TransactionSummary::new(
                        txn.sender(),
                        txn.replay_protector(),
                        txn.committed_hash(),
                    ),
                    TransactionInProgress::new(txn.gas_unit_price()),
                )
            })
            .collect();

        let mut txns = vec![];
        for (summary, info) in txns_in_progress {
            let txn_info = self
                .txns_in_progress_sorted
                .entry(summary)
                .or_insert_with(|| TransactionInProgress::new(info.gas_unit_price));
            txn_info.increment();
            txn_info.gas_unit_price = info.gas_unit_price.max(txn_info.gas_unit_price);
            txns.push(summary);
        }
```

**File:** consensus/src/quorum_store/batch_generator.rs (L352-360)
```rust
        let mut pulled_txns = self
            .mempool_proxy
            .pull_internal(
                max_count,
                self.config.sender_max_total_bytes as u64,
                self.txns_in_progress_sorted.clone(),
            )
            .await
            .unwrap_or_default();
```
