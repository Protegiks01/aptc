# Audit Report

## Title
Telemetry Authentication Vulnerable to Man-in-the-Middle Attack When HTTP is Configured

## Summary
The telemetry sender's `authenticate()` function fetches the server's public key over an unvalidated network connection. If the telemetry service URL is configured to use HTTP instead of HTTPS (via the `TELEMETRY_SERVICE_URL` environment variable), an attacker performing a man-in-the-middle (MitM) attack can substitute their own public key, completely compromising the Noise protocol's security guarantees and enabling interception of all telemetry data.

## Finding Description
The Aptos telemetry system uses the Noise IK handshake protocol to establish authenticated, encrypted connections between validator nodes and the telemetry service. The Noise protocol provides strong cryptographic security, but critically depends on the initiator (client) knowing the correct public key of the responder (server).

The vulnerability exists in the bootstrap process where the client fetches the server's public key: [1](#0-0) 

This initial public key fetch uses the `reqwest` HTTP client without any scheme validation: [2](#0-1) 

The telemetry service URL is determined from the `TELEMETRY_SERVICE_URL` environment variable or defaults to HTTPS URLs: [3](#0-2) [4](#0-3) 

However, there is **no validation** to enforce that the URL must use HTTPS. If an operator configures `TELEMETRY_SERVICE_URL=http://telemetry.example.com`, the code accepts it without warning.

**Attack Scenario:**

1. Node operator misconfigures or an attacker social engineers the use of HTTP: `TELEMETRY_SERVICE_URL=http://telemetry.aptoslabs.com`
2. Attacker positions themselves as network MitM (e.g., compromised router, DNS hijacking, ARP spoofing)
3. When the node attempts to fetch the server's public key via HTTP GET, the attacker intercepts
4. Attacker responds with their own x25519 public key instead of the legitimate server's key
5. The node proceeds with Noise handshake using the attacker's public key: [5](#0-4) 

6. The attacker's server accepts the handshake since it possesses the corresponding private key
7. All subsequent telemetry data (metrics, logs, custom events) is encrypted to the attacker's key
8. Attacker can decrypt, read, modify, or drop all telemetry data

The Noise protocol's cryptographic security is intact, but the client authenticated to the wrong server. The server-side validation at the telemetry service is irrelevant because the client connects to the attacker's server: [6](#0-5) 

## Impact Explanation
This vulnerability meets **Medium Severity** criteria per the Aptos bug bounty program:

- **Information Disclosure**: Exposure of telemetry data including node metrics, logs, custom events, chain ID, peer ID, node role, and potentially sensitive debugging information
- **Privacy Violation**: Node operators' operational data exposed to attackers
- **Limited Scope**: Only affects telemetry data, not consensus or funds
- **Requires Misconfiguration**: Defaults use HTTPS; exploitation requires HTTP to be configured

While the defaults are secure (HTTPS), the lack of validation constitutes a **missing security control** that could lead to real-world exploitation through operator error, documentation mistakes, or social engineering.

## Likelihood Explanation
**Likelihood: Low to Medium**

**Reducing Factors:**
- Default URLs use HTTPS
- Requires operator to explicitly set `TELEMETRY_SERVICE_URL` to HTTP
- Most production deployments likely use defaults

**Increasing Factors:**
- No validation or warning when HTTP is configured
- Easy to exploit if HTTP is used (standard MitM techniques)
- Social engineering could trick operators into using HTTP for "debugging"
- Automated deployment scripts might incorrectly configure HTTP in development that leaks to production
- No documentation explicitly warning against HTTP

The vulnerability is **highly exploitable** when the misconfiguration exists, making it worthy of remediation through code enforcement rather than relying solely on correct configuration.

## Recommendation
Add explicit HTTPS enforcement and validation in the telemetry sender initialization:

```rust
// In crates/aptos-telemetry/src/sender.rs, modify the new() function:

impl TelemetrySender {
    pub fn new(base_url: Url, chain_id: ChainId, node_config: &NodeConfig) -> Self {
        // Add HTTPS validation
        if base_url.scheme() != "https" {
            panic!(
                "Telemetry service URL must use HTTPS for security. Got: {}. \
                Please set TELEMETRY_SERVICE_URL to an HTTPS URL.",
                base_url
            );
        }
        
        let retry_policy = ExponentialBackoff::builder().build_with_total_retry_duration(
            Duration::from_secs(TELEMETRY_SERVICE_TOTAL_RETRY_DURATION_SECS),
        );
        // ... rest of implementation
    }
}
```

Alternatively, for a less disruptive approach, log a critical warning:

```rust
if base_url.scheme() != "https" {
    aptos_logger::error!(
        "SECURITY WARNING: Telemetry service URL is using insecure HTTP: {}. \
        This allows network attackers to intercept telemetry data. \
        Please configure TELEMETRY_SERVICE_URL with HTTPS.",
        base_url
    );
}
```

Additionally, update documentation to explicitly state the HTTPS requirement and security implications.

## Proof of Concept

```rust
// PoC demonstrating the vulnerability
// File: crates/aptos-telemetry/tests/mitm_test.rs

#[tokio::test]
async fn test_http_mitm_vulnerability() {
    use aptos_config::config::NodeConfig;
    use aptos_crypto::{x25519, Uniform};
    use aptos_telemetry::sender::TelemetrySender;
    use aptos_telemetry_service::types::response::IndexResponse;
    use aptos_types::chain_id::ChainId;
    use httpmock::MockServer;
    use reqwest::Url;

    // Attacker's key pair
    let mut rng = rand::thread_rng();
    let attacker_private_key = x25519::PrivateKey::generate(&mut rng);
    let attacker_public_key = attacker_private_key.public_key();

    // Mock server simulating attacker's MitM server (HTTP, not HTTPS)
    let mock_server = MockServer::start();
    
    // Attacker intercepts the public key fetch and returns their own key
    let mock = mock_server.mock(|when, then| {
        when.method("GET").path("/api/v1/");
        then.status(200).json_body_obj(&IndexResponse {
            public_key: attacker_public_key, // Attacker's key!
        });
    });

    // Node configured with HTTP URL (the misconfiguration)
    let http_url = Url::parse(&format!("http://{}", mock_server.address()))
        .expect("Failed to parse URL");
    
    let node_config = NodeConfig::default();
    let sender = TelemetrySender::new(http_url, ChainId::default(), &node_config);

    // When the node fetches the server public key, it gets the attacker's key
    let fetched_key = sender.server_public_key().await.unwrap();
    
    // Vulnerability confirmed: The node accepted the attacker's public key
    assert_eq!(fetched_key, attacker_public_key);
    
    // The subsequent Noise handshake will authenticate to the attacker's server,
    // allowing the attacker to decrypt all telemetry data
    
    mock.assert();
    println!("VULNERABILITY CONFIRMED: HTTP allows MitM public key substitution");
}
```

**Notes**
- This vulnerability is a **Trust On First Use (TOFU)** problem where the initial key fetch lacks secure bootstrapping
- The Noise protocol itself is secure, but requires correct public key material
- The fix is simple: enforce HTTPS at the code level rather than relying on configuration
- While defaults are secure, defense-in-depth principles require validation of security-critical inputs
- Similar issues may exist in other components that fetch remote keys without TLS validation

### Citations

**File:** crates/aptos-telemetry/src/sender.rs (L61-70)
```rust
    pub fn new(base_url: Url, chain_id: ChainId, node_config: &NodeConfig) -> Self {
        let retry_policy = ExponentialBackoff::builder().build_with_total_retry_duration(
            Duration::from_secs(TELEMETRY_SERVICE_TOTAL_RETRY_DURATION_SECS),
        );

        let reqwest_client = reqwest::Client::new();
        let client = ClientBuilder::new(reqwest_client)
            .with(RetryTransientMiddleware::new_with_policy(retry_policy))
            .build();

```

**File:** crates/aptos-telemetry/src/sender.rs (L258-268)
```rust
    async fn get_public_key_from_server(&self) -> Result<x25519::PublicKey> {
        let response = self.client.get(self.build_path("")?).send().await?;

        match error_for_status_with_body(response).await {
            Ok(response) => {
                let response_payload = response.json::<IndexResponse>().await?;
                Ok(response_payload.public_key)
            },
            Err(err) => Err(anyhow!("Error getting server public key. {}", err)),
        }
    }
```

**File:** crates/aptos-telemetry/src/sender.rs (L287-353)
```rust
    pub async fn authenticate(&self) -> Result<String, anyhow::Error> {
        let noise_config = match &self.auth_context.noise_config {
            Some(config) => config,
            None => return Err(anyhow!("Cannot send telemetry without private key")),
        };
        let server_public_key = self.server_public_key().await?;

        // buffer to first noise handshake message
        let mut client_noise_msg = vec![0; noise::handshake_init_msg_len(0)];

        // build the prologue (chain_id | peer_id | server_public_key)
        const CHAIN_ID_LENGTH: usize = 1;
        const ID_SIZE: usize = CHAIN_ID_LENGTH + PeerId::LENGTH;
        const PROLOGUE_SIZE: usize = CHAIN_ID_LENGTH + PeerId::LENGTH + x25519::PUBLIC_KEY_SIZE;
        let mut prologue = [0; PROLOGUE_SIZE];
        prologue[..CHAIN_ID_LENGTH].copy_from_slice(&[self.chain_id.id()]);
        prologue[CHAIN_ID_LENGTH..ID_SIZE].copy_from_slice(self.peer_id.as_ref());
        prologue[ID_SIZE..PROLOGUE_SIZE].copy_from_slice(server_public_key.as_slice());

        let mut rng = rand::rngs::OsRng;

        // craft first handshake message  (-> e, es, s, ss)
        let initiator_state = noise_config
            .initiate_connection(
                &mut rng,
                &prologue,
                server_public_key,
                None,
                &mut client_noise_msg,
            )
            .unwrap();

        let auth_request = AuthRequest {
            chain_id: self.chain_id,
            peer_id: self.peer_id,
            role_type: self.role_type,
            server_public_key,
            handshake_msg: client_noise_msg,
            run_uuid: self.uuid,
        };

        let response = self
            .client
            .post(self.build_path("auth")?)
            .json::<AuthRequest>(&auth_request)
            .send()
            .await?;

        let resp = match error_for_status_with_body(response).await {
            Ok(response) => Ok(response.json::<AuthResponse>().await?),
            Err(err) => {
                debug!(
                    "[telemetry-client] Error sending authentication request: {}",
                    err,
                );
                Err(anyhow!("error {}", err))
            },
        }?;

        let (response_payload, _) = noise_config
            .finalize_connection(initiator_state, resp.handshake_msg.as_slice())
            .unwrap();

        let jwt = String::from_utf8(response_payload)?;

        Ok(jwt)
    }
```

**File:** crates/aptos-telemetry/src/constants.rs (L31-32)
```rust
pub(crate) const TELEMETRY_SERVICE_URL: &str = "https://telemetry.aptoslabs.com";
pub(crate) const MAINNET_TELEMETRY_SERVICE_URL: &str = "https://telemetry.mainnet.aptoslabs.com";
```

**File:** crates/aptos-telemetry/src/service.rs (L150-166)
```rust
    let telemetry_svc_url = env::var(ENV_TELEMETRY_SERVICE_URL).unwrap_or_else(|_| {
        if chain_id == ChainId::mainnet() {
            MAINNET_TELEMETRY_SERVICE_URL.into()
        } else {
            TELEMETRY_SERVICE_URL.into()
        }
    });

    let base_url = Url::parse(&telemetry_svc_url).unwrap_or_else(|err| {
        warn!(
            "Unable to parse telemetry service URL {}. Make sure {} is unset or is set properly: {}. Defaulting to {}.",
            telemetry_svc_url,
            ENV_TELEMETRY_SERVICE_URL, err, TELEMETRY_SERVICE_URL
        );
            Url::parse(TELEMETRY_SERVICE_URL)
                .expect("unable to parse telemetry service default URL")
    });
```

**File:** crates/aptos-telemetry-service/src/auth.rs (L36-44)
```rust
    // Check whether the client (validator) is using the correct server's public key, which the
    // client includes in its request body.
    // This is useful for returning a refined error response to the client if it is using an
    // invalid server public key.
    if body.server_public_key != context.noise_config().public_key() {
        return Err(reject::custom(ServiceError::bad_request(
            ServiceErrorCode::AuthError(AuthError::InvalidServerPublicKey, body.chain_id),
        )));
    }
```
