# Audit Report

## Title
Epoch Reconfiguration Can Result in Empty Validator Set Causing Total Network Halt

## Summary
During epoch reconfiguration, the `stake::on_new_epoch()` function filters validators by minimum stake requirement without verifying that at least one validator remains. This can result in an empty validator set with quorum threshold of 0, causing permanent network liveness failure requiring a hard fork to recover.

## Finding Description
The vulnerability exists in the epoch reconfiguration logic where validators are filtered based on minimum stake requirements without ensuring validator set non-emptiness. [1](#0-0) 

During `on_new_epoch()`, the function iterates through all active validators and only includes those with `voting_power >= minimum_stake` in the next epoch. Line 1401 directly assigns this filtered set without any validation that it contains at least one validator.

In contrast, the manual validator removal function `leave_validator_set()` includes an explicit check: [2](#0-1) 

This protection is **absent** in the automatic filtering path during epoch reconfiguration.

When a `ValidatorVerifier` is constructed from an empty validator set, the quorum threshold is set to 0: [3](#0-2) 

With zero validators, no blocks can be proposed or voted on, resulting in complete network halt. The special case handling for `quorum_voting_power == 0` only exists in test/fuzzing builds: [4](#0-3) 

This breaks the **Consensus Safety** and **Deterministic Execution** invariants, as the network cannot make progress and requires a hard fork to restore validator set.

## Impact Explanation
This vulnerability qualifies as **Critical Severity** under the Aptos bug bounty criteria:

- **Total loss of liveness/network availability**: With zero validators, the network cannot propose or commit blocks, resulting in complete halt
- **Non-recoverable network partition (requires hardfork)**: The empty validator set is committed to on-chain state; normal reconfiguration cannot add validators back, requiring emergency hard fork intervention

The attack vector requires either:
1. Governance proposal that increases `minimum_stake` above all validators' current stake
2. Coordinated mass withdrawal by validators reducing their stake below minimum
3. Combination of slashing and natural stake decreases

## Likelihood Explanation
**Moderate to High likelihood** depending on governance controls:

- Governance has the capability to modify `minimum_stake` via `staking_config::update_required_stake()`
- No validation exists preventing `minimum_stake` from being set to arbitrarily high values
- During economic downturns or reward rate changes, validators might reduce their stake
- A malicious or misconfigured governance proposal could trigger this scenario

The likelihood increases if:
- Validator stake amounts are relatively uniform
- Governance security controls are insufficient
- Economic incentives encourage stake withdrawal

## Recommendation
Add a mandatory check in `stake::on_new_epoch()` to ensure the validator set remains non-empty after filtering:

```move
// After line 1399 in stake.move, before line 1401:
assert!(
    vector::length(&next_epoch_validators) > 0,
    error::invalid_state(ELAST_VALIDATOR)
);

validator_set.active_validators = next_epoch_validators;
```

Additionally, add validation in `staking_config::update_required_stake()` to prevent setting `minimum_stake` above the current minimum active validator's stake:

```move
// In staking_config.move update_required_stake function:
let validator_set = borrow_global<ValidatorSet>(@aptos_framework);
if (vector::length(&validator_set.active_validators) > 0) {
    // Ensure at least one validator will remain after applying new minimum
    let min_current_stake = /* compute minimum stake among active validators */;
    assert!(
        minimum_stake <= min_current_stake,
        error::invalid_argument(EWOULD_REMOVE_ALL_VALIDATORS)
    );
}
```

## Proof of Concept

```move
#[test_only]
module test_addr::empty_validator_set_poc {
    use aptos_framework::stake;
    use aptos_framework::staking_config;
    use aptos_framework::reconfiguration;
    use std::vector;

    #[test(aptos_framework = @aptos_framework)]
    #[expected_failure] // Should fail but currently doesn't
    public entry fun test_empty_validator_set_after_epoch(aptos_framework: &signer) {
        // Setup: Initialize staking with validators having 100 stake each
        // (initialization code omitted for brevity)
        
        // Governance increases minimum stake to 1000
        // All validators have only 100 stake
        staking_config::update_required_stake(aptos_framework, 1000, 10000);
        
        // Trigger epoch reconfiguration
        reconfiguration::reconfigure();
        
        // At this point, validator set should be empty
        // Network is completely halted - no new blocks can be proposed
        let validator_set = stake::get_validator_set();
        assert!(vector::length(&validator_set.active_validators) == 0, 0);
        
        // This state requires hard fork to recover
    }
}
```

**Notes:**
- The vulnerability affects the core consensus liveness guarantee
- No minimum validator count is enforced anywhere in the staking configuration [5](#0-4) 

- The `ELAST_VALIDATOR` error code exists but is only used in manual removal, not automatic filtering during reconfiguration [6](#0-5)

### Citations

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L58-58)
```text
    const ELAST_VALIDATOR: u64 = 6;
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1255-1255)
```text
            assert!(vector::length(&validator_set.active_validators) > 0, error::invalid_state(ELAST_VALIDATOR));
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1372-1401)
```text
        let next_epoch_validators = vector::empty();
        let (minimum_stake, _) = staking_config::get_required_stake(&config);
        let vlen = vector::length(&validator_set.active_validators);
        let total_voting_power = 0;
        let i = 0;
        while ({
            spec {
                invariant spec_validators_are_initialized(next_epoch_validators);
                invariant i <= vlen;
            };
            i < vlen
        }) {
            let old_validator_info = vector::borrow_mut(&mut validator_set.active_validators, i);
            let pool_address = old_validator_info.addr;
            let validator_config = borrow_global<ValidatorConfig>(pool_address);
            let stake_pool = borrow_global<StakePool>(pool_address);
            let new_validator_info = generate_validator_info(pool_address, stake_pool, *validator_config);

            // A validator needs at least the min stake required to join the validator set.
            if (new_validator_info.voting_power >= minimum_stake) {
                spec {
                    assume total_voting_power + new_validator_info.voting_power <= MAX_U128;
                };
                total_voting_power = total_voting_power + (new_validator_info.voting_power as u128);
                vector::push_back(&mut next_epoch_validators, new_validator_info);
            };
            i = i + 1;
        };

        validator_set.active_validators = next_epoch_validators;
```

**File:** types/src/validator_verifier.rs (L206-214)
```rust
    pub fn new(validator_infos: Vec<ValidatorConsensusInfo>) -> Self {
        let total_voting_power = sum_voting_power(&validator_infos);
        let quorum_voting_power = if validator_infos.is_empty() {
            0
        } else {
            total_voting_power * 2 / 3 + 1
        };
        Self::build_index(validator_infos, quorum_voting_power, total_voting_power)
    }
```

**File:** types/src/validator_verifier.rs (L364-372)
```rust
        #[cfg(any(test, feature = "fuzzing"))]
        {
            if self.quorum_voting_power == 0 {
                // This should happen only in case of tests.
                // TODO(skedia): Clean up the test behaviors to not rely on empty signature
                // verification
                return Ok(());
            }
        }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/staking_config.move (L49-72)
```text
    struct StakingConfig has copy, drop, key {
        // A validator needs to stake at least this amount to be able to join the validator set.
        // If after joining the validator set and at the start of any epoch, a validator's stake drops below this amount
        // they will be removed from the set.
        minimum_stake: u64,
        // A validator can only stake at most this amount. Any larger stake will be rejected.
        // If after joining the validator set and at the start of any epoch, a validator's stake exceeds this amount,
        // their voting power and rewards would only be issued for the max stake amount.
        maximum_stake: u64,
        recurring_lockup_duration_secs: u64,
        // Whether validators are allow to join/leave post genesis.
        allow_validator_set_change: bool,
        // DEPRECATING: staking reward configurations will be in StakingRewardsConfig once REWARD_RATE_DECREASE flag is enabled.
        // The maximum rewards given out every epoch. This will be divided by the rewards rate denominator.
        // For example, 0.001% (0.00001) can be represented as 10 / 1000000.
        rewards_rate: u64,
        // DEPRECATING: staking reward configurations will be in StakingRewardsConfig once REWARD_RATE_DECREASE flag is enabled.
        rewards_rate_denominator: u64,
        // Only this % of current total voting power is allowed to join the validator set in each epoch.
        // This is necessary to prevent a massive amount of new stake from joining that can potentially take down the
        // network if corresponding validators are not ready to participate in consensus in time.
        // This value is within (0, 50%), not inclusive.
        voting_power_increase_limit: u64,
    }
```
