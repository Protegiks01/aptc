# Audit Report

## Title
Unauthorized Information Disclosure in Peer Monitoring Service - Missing Authorization Controls for Sensitive Node and Network Data

## Summary
The peer monitoring service in Aptos Core lacks authorization checks to restrict which peers can query sensitive node and network information. Any connected peer, including untrusted peers with `PeerRole::Unknown`, can send `GetNetworkInformation` and `GetNodeInformation` requests to validators and fullnodes, obtaining complete network topology, validator addresses, blockchain state, and build version information.

## Finding Description

The peer monitoring service exposes two sensitive request types without authorization controls: [1](#0-0) 

The `Handler::call()` method processes these requests without verifying the peer's role or authorization level: [2](#0-1) 

**GetNetworkInformation** exposes complete network topology: [3](#0-2) 

This returns all connected peers with their network addresses, peer IDs, and roles: [4](#0-3) 

**GetNodeInformation** exposes internal node state: [5](#0-4) 

This returns sensitive operational data: [6](#0-5) 

The storage interface queries blockchain state directly from the ledger: [7](#0-6) 

**Attack Path:**

1. Attacker connects as an untrusted peer (e.g., public fullnode with `PeerRole::Unknown`)
2. Sends `GetNetworkInformation` request to a validator or VFN
3. Receives complete list of connected validators with network addresses and peer IDs
4. Sends `GetNodeInformation` request
5. Obtains exact build version, blockchain state, and uptime information

Test evidence confirms no authorization checks exist: [8](#0-7) 

The test creates a random peer ID without authentication and successfully queries the service.

## Impact Explanation

This vulnerability represents **HIGH severity** per Aptos bug bounty criteria as a "Significant protocol violation."

**Security Impact:**

1. **Validator Network Reconnaissance**: Attackers can map the entire validator network topology, identifying all validators and their network addresses
2. **Targeted Exploit Development**: Exact build versions enable attackers to identify nodes running vulnerable software versions
3. **DDoS Attack Facilitation**: Network addresses of validators can be used for coordinated DDoS attacks
4. **Timing Attack Intelligence**: Uptime information reveals when validators restart, enabling timing-based attacks
5. **Blockchain State Intelligence**: Current epoch and version information aids in identifying sync delays or attack opportunities

This breaks the **Access Control** invariant - sensitive validator network information should only be accessible to authorized peers within the trust boundary.

## Likelihood Explanation

**Likelihood: HIGH**

- **Attacker Requirements**: Only requires ability to connect as a peer to the network (trivial for public fullnodes)
- **Complexity**: Extremely low - simple RPC requests with no authentication bypass required
- **Detection Difficulty**: Indistinguishable from legitimate peer monitoring traffic
- **Exploitability**: Immediate - vulnerability exists in production code without configuration mitigations

The network configuration shows no role-based access controls: [9](#0-8) 

All connected peers can access the RPC protocol without restrictions.

## Recommendation

Implement role-based authorization checks in the request handler to restrict sensitive queries based on peer trust level:

```rust
pub fn call(
    &self,
    network_id: NetworkId,
    peer_network_id: PeerNetworkId,  // Add peer info
    request: PeerMonitoringServiceRequest,
) -> Result<PeerMonitoringServiceResponse> {
    // Get peer role from metadata
    let peer_metadata = self.peers_and_metadata
        .get_metadata_for_peer(peer_network_id)
        .ok_or(Error::InvalidRequest("Unknown peer".to_string()))?;
    let peer_role = peer_metadata.get_connection_metadata().role;
    
    // Process the request with authorization
    let response = match &request {
        PeerMonitoringServiceRequest::GetNetworkInformation => {
            // Only allow trusted peers (validators, VFNs)
            if !peer_role.is_validator() && !peer_role.is_vfn() {
                return Err(Error::InvalidRequest(
                    "Unauthorized: GetNetworkInformation requires trusted peer role".to_string()
                ));
            }
            self.get_network_information()
        },
        PeerMonitoringServiceRequest::GetNodeInformation => {
            // Only allow trusted peers for detailed node info
            if !peer_role.is_validator() && !peer_role.is_vfn() {
                return Err(Error::InvalidRequest(
                    "Unauthorized: GetNodeInformation requires trusted peer role".to_string()
                ));
            }
            self.get_node_information()
        },
        PeerMonitoringServiceRequest::GetServerProtocolVersion => {
            // Public information - no restriction
            self.get_server_protocol_version()
        },
        PeerMonitoringServiceRequest::LatencyPing(request) => {
            // Public information - no restriction
            self.handle_latency_ping(request)
        },
    };
    // ... rest of error handling
}
```

The server initialization must pass peer network ID to the handler: [10](#0-9) 

Modify line 114-117 to pass `peer_network_id` to the handler.

## Proof of Concept

```rust
#[tokio::test]
async fn test_unauthorized_information_disclosure() {
    // Create a validator node with peer monitoring service
    let base_config = BaseConfig {
        role: RoleType::Validator,
        ..Default::default()
    };
    let (mut mock_client, service, _, peers_and_metadata) =
        MockClient::new(Some(base_config), None, None);
    tokio::spawn(service.start());
    
    // Connect a validator peer to the server
    let validator_peer_id = PeerId::random();
    let validator_network_id = PeerNetworkId::new(NetworkId::Validator, validator_peer_id);
    let validator_metadata = create_connection_metadata(validator_peer_id, PeerRole::Validator);
    peers_and_metadata
        .insert_connection_metadata(validator_network_id, validator_metadata.clone())
        .unwrap();
    
    // Attacker creates an untrusted connection (simulating Unknown peer)
    // In production, this would be a public fullnode connecting to a VFN
    let attacker_request = PeerMonitoringServiceRequest::GetNetworkInformation;
    let response = mock_client.send_request(attacker_request).await.unwrap();
    
    // Verify attacker receives validator network topology
    match response {
        PeerMonitoringServiceResponse::NetworkInformation(info) => {
            // Attacker successfully obtained validator addresses and peer IDs
            assert!(info.connected_peers.contains_key(&validator_network_id));
            let validator_connection = info.connected_peers.get(&validator_network_id).unwrap();
            
            // Sensitive information leaked:
            // - validator_connection.peer_id (validator identity)
            // - validator_connection.network_address (validator IP/port)
            // - validator_connection.peer_role (confirms it's a validator)
            println!("LEAK: Validator address: {:?}", validator_connection.network_address);
            println!("LEAK: Validator peer_id: {:?}", validator_connection.peer_id);
        },
        _ => panic!("Expected NetworkInformation response"),
    }
    
    // Attacker queries node information
    let attacker_request = PeerMonitoringServiceRequest::GetNodeInformation;
    let response = mock_client.send_request(attacker_request).await.unwrap();
    
    match response {
        PeerMonitoringServiceResponse::NodeInformation(info) => {
            // Sensitive operational data leaked:
            println!("LEAK: Build version: {:?}", info.build_information);
            println!("LEAK: Blockchain state - Epoch: {}, Version: {}", 
                     info.highest_synced_epoch, info.highest_synced_version);
            println!("LEAK: Node uptime: {:?}", info.uptime);
        },
        _ => panic!("Expected NodeInformation response"),
    }
}
```

This PoC demonstrates that any peer can query sensitive validator information without authorization checks, enabling reconnaissance attacks against the validator network.

## Notes

The vulnerability exists because the peer monitoring service was designed for legitimate inter-node monitoring but lacks the security controls necessary for a trust-based network architecture. While `PeerRole` is determined at the network handshake layer, the peer monitoring service handler never consults this information to enforce access control policies. This creates a significant security gap where untrusted peers gain visibility into the validator network's internal structure and operational state.

### Citations

**File:** peer-monitoring-service/types/src/request.rs (L6-13)
```rust
/// A peer monitoring service request
#[derive(Clone, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub enum PeerMonitoringServiceRequest {
    GetNetworkInformation,    // Returns relevant network information for the peer
    GetNodeInformation,       // Returns relevant node information about the peer
    GetServerProtocolVersion, // Fetches the protocol version run by the server
    LatencyPing(LatencyPingRequest), // A simple message used by the client to ensure liveness and measure latency
}
```

**File:** peer-monitoring-service/server/src/lib.rs (L84-123)
```rust
    pub async fn start(mut self) {
        // Handle the service requests
        while let Some(network_request) = self.network_requests.next().await {
            // Log the request
            let peer_network_id = network_request.peer_network_id;
            let peer_monitoring_service_request = network_request.peer_monitoring_service_request;
            let response_sender = network_request.response_sender;
            trace!(LogSchema::new(LogEntry::ReceivedPeerMonitoringRequest)
                .request(&peer_monitoring_service_request)
                .message(&format!(
                    "Received peer monitoring request. Peer: {:?}",
                    peer_network_id,
                )));

            // All handler methods are currently CPU-bound so we want
            // to spawn on the blocking thread pool.
            let base_config = self.base_config.clone();
            let peers_and_metadata = self.peers_and_metadata.clone();
            let start_time = self.start_time;
            let storage = self.storage.clone();
            let time_service = self.time_service.clone();
            self.bounded_executor
                .spawn_blocking(move || {
                    let response = Handler::new(
                        base_config,
                        peers_and_metadata,
                        start_time,
                        storage,
                        time_service,
                    )
                    .call(
                        peer_network_id.network_id(),
                        peer_monitoring_service_request,
                    );
                    log_monitoring_service_response(&response);
                    response_sender.send(response);
                })
                .await;
        }
    }
```

**File:** peer-monitoring-service/server/src/lib.rs (L155-183)
```rust
    pub fn call(
        &self,
        network_id: NetworkId,
        request: PeerMonitoringServiceRequest,
    ) -> Result<PeerMonitoringServiceResponse> {
        // Update the request count
        increment_counter(
            &metrics::PEER_MONITORING_REQUESTS_RECEIVED,
            network_id,
            request.get_label(),
        );

        // Time the request processing (the timer will stop when it's dropped)
        let _timer = start_timer(
            &metrics::PEER_MONITORING_REQUEST_PROCESSING_LATENCY,
            network_id,
            request.get_label(),
        );

        // Process the request
        let response = match &request {
            PeerMonitoringServiceRequest::GetNetworkInformation => self.get_network_information(),
            PeerMonitoringServiceRequest::GetServerProtocolVersion => {
                self.get_server_protocol_version()
            },
            PeerMonitoringServiceRequest::GetNodeInformation => self.get_node_information(),
            PeerMonitoringServiceRequest::LatencyPing(request) => self.handle_latency_ping(request),
        };

```

**File:** peer-monitoring-service/server/src/lib.rs (L217-248)
```rust
    fn get_network_information(&self) -> Result<PeerMonitoringServiceResponse, Error> {
        // Get the connected peers
        let connected_peers_and_metadata =
            self.peers_and_metadata.get_connected_peers_and_metadata()?;
        let connected_peers = connected_peers_and_metadata
            .into_iter()
            .map(|(peer, metadata)| {
                let connection_metadata = metadata.get_connection_metadata();
                (
                    peer,
                    ConnectionMetadata::new(
                        connection_metadata.addr,
                        connection_metadata.remote_peer_id,
                        connection_metadata.role,
                    ),
                )
            })
            .collect();

        // Get the distance from the validators
        let distance_from_validators =
            get_distance_from_validators(&self.base_config, self.peers_and_metadata.clone());

        // Create and return the response
        let network_information_response = NetworkInformationResponse {
            connected_peers,
            distance_from_validators,
        };
        Ok(PeerMonitoringServiceResponse::NetworkInformation(
            network_information_response,
        ))
    }
```

**File:** peer-monitoring-service/server/src/lib.rs (L259-281)
```rust
    fn get_node_information(&self) -> Result<PeerMonitoringServiceResponse, Error> {
        // Get the node information
        let build_information = aptos_build_info::get_build_information();
        let current_time: Instant = self.time_service.now();
        let uptime = current_time.duration_since(self.start_time);
        let (highest_synced_epoch, highest_synced_version) =
            self.storage.get_highest_synced_epoch_and_version()?;
        let ledger_timestamp_usecs = self.storage.get_ledger_timestamp_usecs()?;
        let lowest_available_version = self.storage.get_lowest_available_version()?;

        // Create and return the response
        let node_information_response = NodeInformationResponse {
            build_information,
            highest_synced_epoch,
            highest_synced_version,
            ledger_timestamp_usecs,
            lowest_available_version,
            uptime,
        };
        Ok(PeerMonitoringServiceResponse::NodeInformation(
            node_information_response,
        ))
    }
```

**File:** peer-monitoring-service/types/src/response.rs (L50-75)
```rust
/// A response for the network information request
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct NetworkInformationResponse {
    pub connected_peers: BTreeMap<PeerNetworkId, ConnectionMetadata>, // Connected peers
    pub distance_from_validators: u64, // The distance of the peer from the validator set
}

// Display formatting provides a high-level summary of the response
impl Display for NetworkInformationResponse {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{{ num_connected_peers: {:?}, distance_from_validators: {:?} }}",
            self.connected_peers.len(),
            self.distance_from_validators,
        )
    }
}

/// Simple connection metadata associated with each peer
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct ConnectionMetadata {
    pub network_address: NetworkAddress,
    pub peer_id: PeerId,
    pub peer_role: PeerRole,
}
```

**File:** peer-monitoring-service/types/src/response.rs (L93-102)
```rust
/// A response for the node information request
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct NodeInformationResponse {
    pub build_information: BTreeMap<String, String>, // The build information of the node
    pub highest_synced_epoch: u64,                   // The highest synced epoch of the node
    pub highest_synced_version: u64,                 // The highest synced version of the node
    pub ledger_timestamp_usecs: u64, // The latest timestamp of the blockchain (in microseconds)
    pub lowest_available_version: u64, // The lowest stored version of the node (in storage)
    pub uptime: Duration,            // The amount of time the peer has been running
}
```

**File:** peer-monitoring-service/server/src/storage.rs (L44-53)
```rust
impl StorageReaderInterface for StorageReader {
    fn get_highest_synced_epoch_and_version(&self) -> Result<(u64, u64), Error> {
        let latest_ledger_info = self.get_latest_ledger_info()?;
        Ok((latest_ledger_info.epoch(), latest_ledger_info.version()))
    }

    fn get_ledger_timestamp_usecs(&self) -> Result<u64, Error> {
        let latest_ledger_info = self.get_latest_ledger_info()?;
        Ok(latest_ledger_info.timestamp_usecs())
    }
```

**File:** peer-monitoring-service/server/src/tests.rs (L545-586)
```rust
    async fn send_request(
        &mut self,
        request: PeerMonitoringServiceRequest,
    ) -> Result<PeerMonitoringServiceResponse, PeerMonitoringServiceError> {
        let peer_id = PeerId::random();
        let protocol_id = ProtocolId::PeerMonitoringServiceRpc;
        let network_id = get_random_network_id();

        // Create an inbound RPC request
        let request_data = protocol_id
            .to_bytes(&PeerMonitoringServiceMessage::Request(request))
            .unwrap();
        let (request_sender, request_receiver) = oneshot::channel();
        let request_notification = ReceivedMessage {
            message: NetworkMessage::RpcRequest(RpcRequest {
                protocol_id,
                request_id: 42,
                priority: 0,
                raw_request: request_data.clone(),
            }),
            sender: PeerNetworkId::new(network_id, peer_id),
            receive_timestamp_micros: 0,
            rpc_replier: Some(Arc::new(request_sender)),
        };

        // Send the request to the peer monitoring service
        self.peer_manager_notifiers
            .get(&network_id)
            .unwrap()
            .push((peer_id, protocol_id), request_notification)
            .unwrap();

        // Wait for the response from the peer monitoring service
        let response_data = request_receiver.await.unwrap().unwrap();
        let response = protocol_id
            .from_bytes::<PeerMonitoringServiceMessage>(&response_data)
            .unwrap();
        match response {
            PeerMonitoringServiceMessage::Response(response) => response,
            _ => panic!("Unexpected response message: {:?}", response),
        }
    }
```

**File:** aptos-node/src/network.rs (L125-144)
```rust
/// Returns the network application config for the peer monitoring client and server
pub fn peer_monitoring_network_configuration(node_config: &NodeConfig) -> NetworkApplicationConfig {
    let direct_send_protocols = vec![]; // The monitoring service does not use direct send
    let rpc_protocols = vec![ProtocolId::PeerMonitoringServiceRpc];
    let max_network_channel_size =
        node_config.peer_monitoring_service.max_network_channel_size as usize;

    let network_client_config =
        NetworkClientConfig::new(direct_send_protocols.clone(), rpc_protocols.clone());
    let network_service_config = NetworkServiceConfig::new(
        direct_send_protocols,
        rpc_protocols,
        aptos_channel::Config::new(max_network_channel_size)
            .queue_style(QueueStyle::FIFO)
            .counters(
                &aptos_peer_monitoring_service_server::metrics::PENDING_PEER_MONITORING_SERVER_NETWORK_EVENTS,
            ),
    );
    NetworkApplicationConfig::new(network_client_config, network_service_config)
}
```
