# Audit Report

## Title
Split-Brain Condition in Indexer-GRPC-Manager: Lack of Multi-Master Detection Enables Duplicate File Uploads and Cache Corruption

## Summary

The indexer-grpc-manager lacks validation to prevent or detect when multiple instances are misconfigured with `is_master=true`. While the `IS_MASTER` metric itself has no race conditions (it's set once during initialization), the architecture allows multiple masters to run simultaneously, causing duplicate file uploads, metadata corruption, and cache inconsistencies without detection or recovery mechanisms.

## Finding Description

The indexer-grpc-manager uses a static boolean configuration `is_master` to designate which instance should upload transaction data to the file store. The `IS_MASTER` metric is set once during initialization and never updated: [1](#0-0) 

The critical security issue is that **there are no race conditions in setting IS_MASTER** as the question premises - the metric is deterministically set from configuration. However, the real vulnerability is that **multiple instances can be misconfigured with `is_master=true`**, and the system has:

1. **No validation preventing multiple masters** - No checks exist to detect when multiple instances claim to be master
2. **No runtime master coordination** - Although instances exchange `master_address` via heartbeats, this doesn't stop duplicate masters from running [2](#0-1) 

3. **Decoupled metric and behavior** - The `IS_MASTER` metric shows static config but doesn't reflect actual master state after heartbeats

When multiple masters run:

- Both start `FileStoreUploader` that runs indefinitely: [3](#0-2) 

- Both have independent `Cache.file_store_version` counters (AtomicU64 in separate processes): [4](#0-3) 

- Both upload duplicate transaction files to the same file store paths
- Both race to update `metadata.json`, potentially causing version tracking corruption: [5](#0-4) 

The system explicitly acknowledges static master configuration without election: [6](#0-5) 

## Impact Explanation

**Medium Severity** - This qualifies as "State inconsistencies requiring intervention" per Aptos bug bounty criteria:

- **Indexer data corruption**: Racing metadata.json updates can cause inconsistent version tracking
- **Resource waste**: Duplicate file uploads consume bandwidth and storage
- **Cache desynchronization**: Each master maintains independent file_store_version views
- **Monitoring failure**: IS_MASTER metric incorrectly reports state for both instances
- **No automatic recovery**: System cannot detect or recover from split-brain without manual intervention

**Not Critical** because:
- No blockchain consensus violation (indexer is off-chain)
- No fund loss or theft
- Doesn't affect validator nodes or mainnet operation
- Requires operator misconfiguration, not exploitable by external attackers

## Likelihood Explanation

**Medium-High Likelihood** in production environments:

- Operators deploying multiple instances for high availability may accidentally configure both as master
- No startup validation warns about configuration conflicts
- No runtime monitoring detects split-brain conditions
- Kubernetes deployments with replicated configs increase risk
- Silent failure mode - both instances appear healthy while corrupting data

## Recommendation

Implement distributed master election with split-brain detection:

```rust
// In MetadataManager initialization
pub(crate) fn new(
    chain_id: u64,
    self_advertised_address: GrpcAddress,
    grpc_manager_addresses: Vec<GrpcAddress>,
    fullnode_addresses: Vec<GrpcAddress>,
    master_address: Option<GrpcAddress>,
) -> Self {
    // Validate: if configured as master, verify no other master via heartbeats
    // Add epoch-based master election or use external coordination (etcd/consul)
    // Fail fast if multiple masters detected
}

// In handle_grpc_manager_info
fn handle_grpc_manager_info(&self, address: GrpcAddress, info: GrpcManagerInfo) -> Result<()> {
    let received_master = info.master_address.clone();
    let local_master = self.master_address.lock().unwrap().clone();
    
    // SPLIT-BRAIN DETECTION
    if received_master.is_some() && local_master.is_some() 
       && received_master != local_master {
        // Multiple masters detected!
        // 1. Emit critical alert
        // 2. Update IS_MASTER metric to reflect conflict
        // 3. Stop FileStoreUploader on lower-priority instance
        panic!("Split-brain detected: multiple masters running!");
    }
    
    self.master_address.lock().unwrap().clone_from(&info.master_address);
    Ok(())
}

// Update IS_MASTER metric dynamically when master state changes
IS_MASTER.set(if self.is_actually_master() { 1 } else { 0 });
```

Additional safeguards:
- Add distributed locking on metadata.json updates (file locks or external coordination)
- Implement master health checks and automatic failover
- Add startup validation that queries peer instances for master status
- Emit metrics when heartbeat master_address conflicts with local is_master config

## Proof of Concept

```rust
// Deploy two indexer-grpc-manager instances with this config:

// instance_a.yaml
// is_master: true
// self_advertised_address: "http://instance-a:50051"

// instance_b.yaml  
// is_master: true  // MISCONFIGURATION
// self_advertised_address: "http://instance-b:50051"

// Both instances will:
// 1. Set IS_MASTER=1 independently
// 2. Start FileStoreUploader
// 3. Upload duplicate files to GCS
// 4. Race on metadata.json updates
// 5. Show IS_MASTER=1 despite heartbeats revealing conflict

// Verification:
// - Check Prometheus: both show IS_MASTER=1
// - Check GCS: duplicate uploads for same versions
// - Check logs: "Updated file_store_version" from both instances
// - Check metadata.json: version may be inconsistent between reads
```

**Notes:**

This is **not** a race condition in setting the IS_MASTER metric itself - that operation is deterministic and happens once during initialization. The vulnerability is the **lack of validation and coordination** that allows misconfigured split-brain scenarios to persist undetected, causing indexer data corruption. The issue is specific to the off-chain indexer infrastructure and does not affect blockchain consensus or validator operations.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/grpc_manager.rs (L80-80)
```rust
        IS_MASTER.set(config.is_master as i64);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/grpc_manager.rs (L112-120)
```rust
            if self.is_master {
                s.spawn(async move {
                    self.file_store_uploader
                        .lock()
                        .await
                        .start(self.data_manager.clone(), tx)
                        .await
                        .unwrap();
                });
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L135-136)
```rust
    // NOTE: We assume the master is statically configured for now.
    master_address: Mutex<Option<GrpcAddress>>,
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L552-556)
```rust
    fn handle_grpc_manager_info(&self, address: GrpcAddress, info: GrpcManagerInfo) -> Result<()> {
        self.master_address
            .lock()
            .unwrap()
            .clone_from(&info.master_address);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L127-135)
```rust
        if update_file_store_version {
            if !transactions.is_empty() {
                let old_version = self
                    .file_store_version
                    .fetch_add(transactions.len() as u64, Ordering::SeqCst);
                let new_version = old_version + transactions.len() as u64;
                FILE_STORE_VERSION_IN_CACHE.set(new_version as i64);
                info!("Updated file_store_version in cache to {new_version}.");
            }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs (L262-273)
```rust
    async fn update_file_store_metadata(&self, version: u64) -> Result<()> {
        FILE_STORE_VERSION.set(version as i64);
        let metadata = FileStoreMetadata {
            chain_id: self.chain_id,
            num_transactions_per_folder: NUM_TXNS_PER_FOLDER,
            version,
        };

        let raw_data = serde_json::to_vec(&metadata).map_err(anyhow::Error::msg)?;
        self.writer
            .save_raw_file(PathBuf::from(METADATA_FILE_NAME), raw_data)
            .await
```
