# Audit Report

## Title
Memory Exhaustion via Unvalidated ExecutionPoolWindow.block_ids Vector in Consensus Observer

## Summary
The consensus observer's `verify_window_contents()` method is not implemented, allowing attackers to send `OrderedBlockWithWindow` messages with excessively large `block_ids` vectors (up to ~2 million entries within the 64 MiB network limit), causing memory exhaustion on consensus observer nodes without any validation or peer banning mechanism.

## Finding Description

The vulnerability exists in the consensus observer's execution pool window validation logic. When a peer sends an `OrderedBlockWithWindow` message, the `ExecutionPoolWindow` structure contains a `block_ids` field that is supposed to represent the execution pool dependency chain. [1](#0-0) 

The critical security flaw is that `verify_window_contents()` is completely unimplemented and always returns `Ok(())`, bypassing any size validation. The expected window size when execution pool is enabled is typically 1 block, as defined by `DEFAULT_ENABLED_WINDOW_SIZE`. [2](#0-1) 

During message processing, the consensus observer calls this unimplemented validation: [3](#0-2) 

**Attack Flow:**

1. Attacker subscribes to a consensus observer node
2. Constructs an `OrderedBlockWithWindow` message with a `block_ids` vector containing millions of `HashValue` entries (each 32 bytes)
3. The network layer accepts messages up to `MAX_MESSAGE_SIZE = 64 MiB` [4](#0-3) 

4. Message is deserialized using BCS with compression: [5](#0-4) 

5. During deserialization, a vector with ~2 million `HashValue` entries (64 MB) is allocated in memory
6. The unimplemented `verify_window_contents()` passes without checking the size
7. Although the message is currently dropped due to incomplete implementation (TODO comment), the memory allocation has already occurred [6](#0-5) 

8. No peer banning mechanism exists for invalid messages - only metrics tracking: [7](#0-6) 

9. Attacker can repeatedly send such messages faster than garbage collection can free memory, causing memory exhaustion

## Impact Explanation

This vulnerability qualifies as **High Severity** per the Aptos Bug Bounty criteria:

- **Validator node slowdowns**: Memory pressure from processing malicious messages degrades consensus observer performance
- **API crashes**: Out-of-memory conditions can crash the consensus observer service
- **Significant protocol violations**: The Resource Limits invariant is violated - operations should respect memory constraints but currently do not

The attack can:
- Exhaust memory on consensus observer nodes running on validators
- Cause node instability or crashes via OOM killer
- Degrade overall network health if multiple consensus observers are targeted
- Potentially impact validator consensus participation if the observer crashes affect the main consensus process

This breaks **Critical Invariant #9**: "All operations must respect gas, storage, and computational limits" - the unbounded memory allocation violates resource limit guarantees.

## Likelihood Explanation

**Likelihood: High**

- **Low Attack Complexity**: Attacker only needs to connect as a peer and send crafted messages
- **No Authentication Required**: Any peer can subscribe to consensus observer
- **No Rate Limiting**: No automatic peer banning or message rate limits
- **Immediate Impact**: Memory allocation occurs during deserialization before any validation
- **Repeatable**: Attacker can send multiple messages in rapid succession
- **Network Limits Allow**: The 64 MiB message size limit permits ~2 million HashValue entries (2,000,000x the expected window size of 1)

## Recommendation

Implement the `verify_window_contents()` method to validate the `block_ids` vector size:

```rust
/// Verifies the execution pool window contents and returns an error if the data is invalid
pub fn verify_window_contents(&self, expected_window_size: u64) -> Result<(), Error> {
    // Validate the block_ids vector size against expected window size
    let block_ids_count = self.block_ids.len() as u64;
    
    // Allow some tolerance for network delays, but enforce reasonable bounds
    let max_allowed_window_size = expected_window_size.saturating_mul(10); // 10x tolerance
    
    if block_ids_count > max_allowed_window_size {
        return Err(Error::InvalidMessageError(format!(
            "ExecutionPoolWindow block_ids vector too large! Expected: {}, Max allowed: {}, Received: {}",
            expected_window_size, max_allowed_window_size, block_ids_count
        )));
    }
    
    // Additional validation: ensure block_ids is not empty if window is enabled
    if expected_window_size > 0 && self.block_ids.is_empty() {
        return Err(Error::InvalidMessageError(
            "ExecutionPoolWindow block_ids is empty when execution pool is enabled".to_string()
        ));
    }
    
    Ok(())
}
```

Additionally, implement peer banning for repeated invalid messages:

1. Track invalid message counts per peer
2. Disconnect and ban peers exceeding threshold (e.g., 10 invalid messages)
3. Implement exponential backoff for reconnection attempts

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_crypto::HashValue;
    
    #[test]
    fn test_memory_exhaustion_attack() {
        // Create a malicious ExecutionPoolWindow with 2 million entries
        let malicious_window_size = 2_000_000;
        let block_ids: Vec<HashValue> = (0..malicious_window_size)
            .map(|i| HashValue::sha3_256_of(&i.to_le_bytes()))
            .collect();
        
        // Calculate memory consumption
        let memory_bytes = block_ids.len() * std::mem::size_of::<HashValue>();
        println!("Memory allocated: {} MB", memory_bytes / (1024 * 1024));
        
        // Create the execution pool window
        let execution_pool_window = ExecutionPoolWindow::new(block_ids);
        
        // Expected window size is 1, but we're sending 2 million
        let expected_window_size = 1;
        
        // VULNERABILITY: This should fail but currently passes
        let result = execution_pool_window.verify_window_contents(expected_window_size);
        
        // This assertion demonstrates the vulnerability
        assert!(result.is_ok(), "verify_window_contents is not implemented and allows oversized vectors");
        
        // Create a full OrderedBlockWithWindow message
        let ordered_block = create_test_ordered_block(); // Helper function
        let malicious_message = OrderedBlockWithWindow::new(
            ordered_block,
            execution_pool_window,
        );
        
        // Serialize to verify it fits within network limits
        let serialized = bcs::to_bytes(&malicious_message).unwrap();
        let serialized_size_mb = serialized.len() / (1024 * 1024);
        println!("Serialized message size: {} MB", serialized_size_mb);
        
        // Assert that the attack is feasible within network limits
        assert!(serialized.len() < MAX_MESSAGE_SIZE, 
            "Message must fit within network limits for attack to work");
    }
}
```

**Notes:**

This vulnerability exists because the execution pool window feature is still under development (indicated by TODO comments), but the network interface already accepts these messages. The lack of input validation combined with no peer punishment mechanism creates a trivial denial-of-service vector against consensus observer nodes.

### Citations

**File:** consensus/src/consensus_observer/network/observer_message.rs (L312-333)
```rust
/// The execution pool window information for an ordered block
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct ExecutionPoolWindow {
    // TODO: identify exactly what information is required here
    block_ids: Vec<HashValue>, // The list of parent block hashes in chronological order
}

impl ExecutionPoolWindow {
    pub fn new(block_ids: Vec<HashValue>) -> Self {
        Self { block_ids }
    }

    /// Returns a reference to the block IDs in the execution pool window
    pub fn block_ids(&self) -> &Vec<HashValue> {
        &self.block_ids
    }

    /// Verifies the execution pool window contents and returns an error if the data is invalid
    pub fn verify_window_contents(&self, _expected_window_size: u64) -> Result<(), Error> {
        Ok(()) // TODO: Implement this method!
    }
}
```

**File:** types/src/on_chain_config/consensus_config.rs (L10-13)
```rust
/// Default Window Size for Execution Pool.
/// This describes the number of blocks in the Execution Pool Window
pub const DEFAULT_WINDOW_SIZE: Option<u64> = None;
pub const DEFAULT_ENABLED_WINDOW_SIZE: Option<u64> = Some(1);
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L849-867)
```rust
        // Verify the execution pool window contents
        let execution_pool_window = ordered_block_with_window.execution_pool_window();
        if let Err(error) = execution_pool_window.verify_window_contents(execution_pool_window_size)
        {
            // Log the error and update the invalid message counter
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to verify execution pool window contents! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                    ordered_block.proof_block_info(),
                    peer_network_id,
                    error
                ))
            );
            increment_invalid_message_counter(
                &peer_network_id,
                metrics::ORDERED_BLOCK_WITH_WINDOW_LABEL,
            );
            return;
        };
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L895-895)
```rust
        // TODO: process the ordered block with window message (instead of just dropping it!)
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L1355-1362)
```rust
/// Increments the invalid message counter for the given peer and message
fn increment_invalid_message_counter(peer_network_id: &PeerNetworkId, message_label: &str) {
    metrics::increment_counter(
        &metrics::OBSERVER_INVALID_MESSAGES,
        message_label,
        peer_network_id,
    );
}
```

**File:** config/src/config/network_config.rs (L50-50)
```rust
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L162-162)
```rust
            ProtocolId::ConsensusObserver => Encoding::CompressedBcs(RECURSION_LIMIT),
```
