# Audit Report

## Title
Error Code Collision Due to Inconsistent Bit Masking in Abort Info Extraction

## Summary
The `extract_abort_info` function uses a 12-bit mask (`0xFFF`) when looking up error codes, but the canonical error code format specifies 16 bits for the reason field. This inconsistency can cause error description collisions when crafted error codes share the same lower 12 bits, leading to incorrect error reporting and debugging difficulties.

## Finding Description
The Aptos error code system defines a canonical format where abort codes use the lowest 3 bytes:
- Bits 16-23: Error category (1 byte)
- Bits 0-15: Error reason (2 bytes, 16 bits) [1](#0-0) 

The `error_split` function correctly parses this format using a 16-bit mask: [2](#0-1) 

However, the `extract_abort_info` function uses only 12 bits (`0xFFF`) for the initial lookup: [3](#0-2) 

**Collision Scenarios:**
1. If a module defines `const ESIMPLE: u64 = 0xABC;` and a transaction aborts with canonical code `0x10ABC` (category 0x1, reason 0x0ABC), the masked lookup `0x10ABC & 0xFFF = 0xABC` will incorrectly match `ESIMPLE`'s error description.

2. Two different canonical error codes like `0x11234` (reason 0x1234) and `0x12234` (reason 0x2234) both mask to `0x234`, potentially matching a simple error code `0x234` if it exists in the error map.

The error map is built with full abort codes as keys: [4](#0-3) 

## Impact Explanation
This issue falls under **Low Severity** per the Aptos bug bounty program as it only affects error reporting and debugging, not consensus, execution, or funds. The issue does not break any critical invariants:
- Consensus remains deterministic (abort codes are correct)
- State transitions are unaffected
- No fund theft or loss is possible
- Execution correctness is maintained

The impact is limited to:
- Users receiving incorrect error descriptions
- Developers debugging with misleading error messages  
- Potential confusion masking actual contract issues

## Likelihood Explanation
Likelihood is **MODERATE** because:
- Any module author can define error codes
- Collisions occur when lower 12 bits match
- Framework modules use small reason codes (< 0xFFF), reducing practical collision risk
- The fallback to full code lookup mitigates some cases

However, malicious actors could intentionally craft colliding error codes to confuse users or hide failure reasons.

## Recommendation
Change the mask from `0xFFF` (12 bits) to `0xFFFF` (16 bits) to match the canonical error format:

```rust
pub fn extract_abort_info(&self, code: u64) -> Option<AbortInfo> {
    self.error_map
        .get(&(code & 0xFFFF))  // Use 16 bits instead of 12
        .or_else(|| self.error_map.get(&code))
        .map(|descr| AbortInfo {
            reason_name: descr.code_name.clone(),
            description: descr.code_description.clone(),
        })
}
```

## Proof of Concept
```move
module 0xCAFE::collision_test {
    // Simple error code with lower 12 bits = 0xABC
    const ESIMPLE_ERROR: u64 = 0xABC;
    
    // Canonical error: category 0x1 (INVALID_ARGUMENT), reason 0x0ABC
    // When masked with 0xFFF, this becomes 0xABC, colliding with ESIMPLE_ERROR
    const ECOLLIDING_ERROR: u64 = 0x10ABC;
    
    public entry fun trigger_simple() {
        abort ESIMPLE_ERROR
    }
    
    public entry fun trigger_collision() {
        // This will show ESIMPLE_ERROR's description due to mask collision
        abort ECOLLIDING_ERROR  
    }
}
```

**Note**: This is a **Low severity** finding. While the collision mechanism is real and exploitable for error message confusion, it does not meet the Critical/High/Medium severity thresholds required for bounty eligibility as it does not affect consensus, state integrity, or fund security.

### Citations

**File:** aptos-move/framework/move-stdlib/sources/error.move (L1-22)
```text
/// This module defines a set of canonical error codes which are optional to use by applications for the
/// `abort` and `assert!` features.
///
/// Canonical error codes use the 3 lowest bytes of the u64 abort code range (the upper 5 bytes are free for other use).
/// Of those, the highest byte represents the *error category* and the lower two bytes the *error reason*.
/// Given an error category `0x1` and a reason `0x3`, a canonical abort code looks as `0x10003`.
///
/// A module can use a canonical code with a constant declaration of the following form:
///
/// ```
/// ///  An invalid ASCII character was encountered when creating a string.
/// const EINVALID_CHARACTER: u64 = 0x010003;
/// ```
///
/// This code is both valid in the worlds with and without canonical errors. It can be used as a plain module local
/// error reason understand by the existing error map tooling, or as a canonical code.
///
/// The actual canonical categories have been adopted from Google's canonical error codes, which in turn are derived
/// from Unix error codes [see here](https://cloud.google.com/apis/design/errors#handling_errors). Each code has an
/// associated HTTP error code which can be used in REST apis. The mapping from error code to http code is not 1:1;
/// error codes here are a bit richer than HTTP codes.
module std::error {
```

**File:** aptos-move/aptos-vm/src/errors.rs (L63-67)
```rust
fn error_split(code: u64) -> (u8, u64) {
    let reason = code & 0xFFFF;
    let category = ((code >> 16) & 0xFF) as u8;
    (category, reason)
}
```

**File:** types/src/vm/module_metadata.rs (L548-556)
```rust
    pub fn extract_abort_info(&self, code: u64) -> Option<AbortInfo> {
        self.error_map
            .get(&(code & 0xFFF))
            .or_else(|| self.error_map.get(&code))
            .map(|descr| AbortInfo {
                reason_name: descr.code_name.clone(),
                description: descr.code_description.clone(),
            })
    }
```

**File:** aptos-move/framework/src/extended_checks.rs (L829-858)
```rust
    fn build_error_map(&mut self, module: &ModuleEnv<'_>) {
        // Compute the error map, we are using the `ErrorMapping` type from Move which
        // is more general as we need as it works for multiple modules.
        let module_id = self.get_runtime_module_id(module);
        if module_id == self.error_category_module {
            return;
        }
        let mut error_map = ErrorMapping::default();
        for named_constant in module.get_named_constants() {
            let name = self.name_string(named_constant.get_name());
            if name.starts_with(ERROR_PREFIX) {
                if let Some(abort_code) = self.get_abort_code(&named_constant) {
                    // If an error is returned (because of duplicate entry) ignore it.
                    let _ = error_map.add_module_error(
                        &module_id.to_string(),
                        abort_code,
                        ErrorDescription {
                            code_name: name.trim().to_string(),
                            code_description: named_constant.get_doc().trim().to_string(),
                        },
                    );
                }
            }
        }
        // Inject it into runtime info
        self.output.entry(module_id).or_default().error_map = error_map
            .module_error_maps
            .remove(&module_id.to_string())
            .unwrap_or_default();
    }
```
