# Audit Report

## Title
Transaction Pruner Hash Index Deletion Without Version Validation Enables Data Loss on Hash Collision

## Summary
The transaction pruner unconditionally deletes transaction hash indices without verifying that the stored version matches the transaction being pruned. If two transactions share the same hash (due to cryptographic collision or implementation bug), pruning the older transaction will delete the hash index entry that points to the newer transaction, making it permanently unretrievable via the `get_transaction_by_hash` API despite still existing in storage.

## Finding Description

The `TransactionByHashSchema` maintains a 1-to-1 mapping from transaction hash to version number for efficient hash-based lookups: [1](#0-0) 

When a transaction is committed, its hash is stored in this schema: [2](#0-1) 

The critical issue is that when a second transaction with the same hash H is committed at version V2, it **overwrites** the previous mapping. If transaction T1 at version V1 had hash H, and transaction T2 at version V2 > V1 also has hash H, after T2 is committed, `TransactionByHashSchema[H]` points to V2, and the V1 mapping is lost.

The pruning logic then blindly deletes hash indices for all pruned transactions: [3](#0-2) [4](#0-3) 

**Attack Scenario:**
1. Transaction T1 with hash H is committed at version 100
2. Transaction T2 with the same hash H is committed at version 200 (overwrites the index)
3. Pruning runs with target version 150, includes T1 in candidates
4. Pruner deletes `TransactionByHashSchema[H]` 
5. Transaction T2 at version 200 is now **unretrievable by hash** despite being recent and unpruned

The lookup function will return None: [5](#0-4) 

## Impact Explanation

**Severity: Medium to High**

This breaks the **data availability guarantee** for transaction retrieval by hash, which is a core API feature used by:
- REST API endpoints (`/transactions/by_hash/:txn_hash`)
- Blockchain explorers and indexers
- Application integrations relying on transaction hash lookups
- Transaction confirmation workflows

While the transaction remains retrievable by version number and the blockchain state is unaffected, this violates the expected behavior that all non-pruned transactions should be retrievable by their hash. This could cause:

- Service disruptions for applications relying on hash-based lookups
- User confusion when recent transactions appear "lost"
- Potential incorrect behavior in smart contracts or off-chain systems that track transactions by hash

**Why not Critical:** The transaction data and blockchain state remain intact and accessible via version-based queries. No funds are lost and consensus is not affected.

## Likelihood Explanation

**Likelihood: Very Low (but non-zero)**

Hash collisions with SHA3-256 are cryptographically infeasible under normal circumstances (probability ~2^-128). However, this vulnerability could be triggered by:

1. **Implementation bugs** in transaction serialization causing duplicate hashes
2. **StateCheckpoint transactions** with duplicate block_ids due to system bugs
3. **Future cryptographic weaknesses** (though currently considered secure)
4. **Malicious or buggy system code** that generates transactions with controlled hashes

While unlikely, the lack of defensive validation means that if hash collisions ever occur (through any mechanism), data loss is guaranteed. The system has no safeguards against this scenario.

## Recommendation

Add version validation before deleting hash indices. The pruner should verify that the version stored in `TransactionByHashSchema` matches the version being pruned:

```rust
pub(crate) fn prune_transaction_by_hash_indices(
    &self,
    transaction_hashes_with_versions: impl Iterator<Item = (HashValue, Version)>,
    db_batch: &mut SchemaBatch,
) -> Result<()> {
    for (hash, pruned_version) in transaction_hashes_with_versions {
        // Only delete if the stored version matches the pruned version
        if let Some(stored_version) = self.db.get::<TransactionByHashSchema>(&hash)? {
            if stored_version == pruned_version {
                db_batch.delete::<TransactionByHashSchema>(&hash)?;
            }
            // If versions don't match, a newer transaction has this hash - don't delete
        }
    }
    Ok(())
}
```

Update the caller to pass version information:

```rust
self.ledger_db
    .transaction_db()
    .prune_transaction_by_hash_indices(
        candidate_transactions.iter().map(|(version, txn)| (txn.hash(), *version)),
        &mut batch,
    )?;
```

## Proof of Concept

Due to the cryptographic security of SHA3-256, creating a practical PoC requires artificially inducing hash collisions. However, the vulnerability can be demonstrated conceptually:

```rust
// Conceptual test demonstrating the vulnerability logic
#[test]
fn test_hash_collision_pruning_bug() {
    let db = setup_test_db();
    
    // Simulate hash collision scenario
    let collision_hash = HashValue::random();
    let txn1_version = 100;
    let txn2_version = 200;
    
    // Commit transaction 1 at version 100
    db.put::<TransactionByHashSchema>(&collision_hash, &txn1_version);
    assert_eq!(db.get::<TransactionByHashSchema>(&collision_hash), Some(txn1_version));
    
    // Commit transaction 2 at version 200 with same hash (collision)
    db.put::<TransactionByHashSchema>(&collision_hash, &txn2_version);
    assert_eq!(db.get::<TransactionByHashSchema>(&collision_hash), Some(txn2_version));
    
    // Prune up to version 150 (should prune txn1, not txn2)
    let mut batch = SchemaBatch::new();
    batch.delete::<TransactionByHashSchema>(&collision_hash);
    db.write_schemas(batch);
    
    // BUG: Transaction 2 at version 200 is now unretrievable by hash!
    assert_eq!(db.get::<TransactionByHashSchema>(&collision_hash), None);
    // Transaction 2 should still be accessible, but hash index is gone
}
```

The vulnerability is confirmed by code analysis: the pruning logic has no version checking, making it susceptible to data loss if hash collisions occur through any mechanism.

### Citations

**File:** storage/aptosdb/src/schema/transaction_by_hash/mod.rs (L23-28)
```rust
define_schema!(
    TransactionByHashSchema,
    HashValue,
    Version,
    TRANSACTION_BY_HASH_CF_NAME
);
```

**File:** storage/aptosdb/src/ledger_db/transaction_db.rs (L74-83)
```rust
    pub(crate) fn get_transaction_version_by_hash(
        &self,
        hash: &HashValue,
        ledger_version: Version,
    ) -> Result<Option<Version>> {
        Ok(match self.db.get::<TransactionByHashSchema>(hash)? {
            Some(version) if version <= ledger_version => Some(version),
            _ => None,
        })
    }
```

**File:** storage/aptosdb/src/ledger_db/transaction_db.rs (L148-163)
```rust
        let transaction_hash = transaction.hash();

        if let Some(signed_txn) = transaction.try_as_signed_user_txn() {
            let txn_summary = IndexedTransactionSummary::V1 {
                sender: signed_txn.sender(),
                replay_protector: signed_txn.replay_protector(),
                version,
                transaction_hash,
            };
            batch.put::<TransactionSummariesByAccountSchema>(
                &(signed_txn.sender(), version),
                &txn_summary,
            )?;
        }
        batch.put::<TransactionByHashSchema>(&transaction_hash, &version)?;
        batch.put::<TransactionSchema>(&version, transaction)?;
```

**File:** storage/aptosdb/src/ledger_db/transaction_db.rs (L182-191)
```rust
    pub(crate) fn prune_transaction_by_hash_indices(
        &self,
        transaction_hashes: impl Iterator<Item = HashValue>,
        db_batch: &mut SchemaBatch,
    ) -> Result<()> {
        for hash in transaction_hashes {
            db_batch.delete::<TransactionByHashSchema>(&hash)?;
        }
        Ok(())
    }
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs (L41-46)
```rust
        self.ledger_db
            .transaction_db()
            .prune_transaction_by_hash_indices(
                candidate_transactions.iter().map(|(_, txn)| txn.hash()),
                &mut batch,
            )?;
```
