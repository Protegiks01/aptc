# Audit Report

## Title
Windows Reserved Device Names Bypass in Move Package Name Validation Causes Cross-Platform File System Failures

## Summary
The `is_valid_package_name()` function in the Move package manifest validation system does not check for Windows reserved device names (CON, PRN, AUX, NUL, COM1-COM9, LPT1-LPT9). When packages with these names are used, they pass validation but cause file system errors on Windows during package caching, compilation, and dependency resolution, resulting in denial of service for Windows-based developers and build systems.

## Finding Description

The package name validation only checks character composition (alphanumeric, hyphen, underscore) but fails to reject Windows reserved device names: [1](#0-0) 

This validated package name is then used directly in file system operations without sanitization. When fetching on-chain packages, the package name is incorporated into directory paths: [2](#0-1) 

The package name is concatenated into the canonical name and used as a directory: [3](#0-2) 

Similarly, during compilation, package names are joined directly to create dependency directory paths: [4](#0-3) 

**Attack Path:**
1. Attacker publishes a Move package with name "CON" (or PRN, AUX, NUL, COM1-9, LPT1-9)
2. Package passes validation since "CON" contains only ASCII letters
3. When a Windows user attempts to depend on or cache this package, the system tries to create a directory named "CON"
4. On Windows, "CON" is a reserved device name that cannot be used as a file or directory name
5. File system operation fails with ERROR_ACCESS_DENIED or ERROR_INVALID_NAME
6. Package installation/compilation fails, causing denial of service

The codebase demonstrates awareness of Windows file system restrictions in other areas: [5](#0-4) 

However, this protection was not applied to package names.

## Impact Explanation

**Severity: Medium** (per Aptos Bug Bounty criteria - up to $10,000)

This vulnerability causes:
- **State inconsistencies requiring intervention**: Windows developers cannot cache or compile packages with reserved names, creating inconsistent package availability across platforms
- **Denial of Service**: Windows-based CI/CD pipelines, build systems, and developer environments fail when encountering these packages
- **Platform fragmentation**: Packages that work on Linux/macOS fail on Windows, breaking the cross-platform guarantee
- **Build system disruption**: Automated builds and testing infrastructure on Windows become unreliable

While this does not directly lead to funds loss or consensus violations, it creates operational disruption and could be exploited maliciously to target Windows-based development infrastructure.

## Likelihood Explanation

**Likelihood: Medium**

- Any developer can publish a package with a reserved name (no special privileges required)
- The names CON, PRN, AUX, NUL are valid English words/abbreviations that could be used innocently
- Windows is commonly used for development (estimates suggest 20-30% of developers use Windows)
- The vulnerability affects all Windows users attempting to use the affected package
- Detection is difficult until runtime when file system operations fail

The likelihood is elevated by the fact that the codebase already shows awareness of Windows filename restrictions, suggesting Windows compatibility is a design goal.

## Recommendation

Add Windows reserved name validation to the `is_valid_package_name()` function:

```rust
fn is_valid_package_name(s: &str) -> bool {
    let mut chars = s.chars();

    match chars.next() {
        Some(c) if c.is_ascii_alphabetic() || c == '_' => (),
        _ => return false,
    }

    if !chars.all(|c| c.is_ascii_alphanumeric() || c == '-' || c == '_') {
        return false;
    }

    // Check for Windows reserved device names (case-insensitive)
    let upper = s.to_uppercase();
    let reserved = ["CON", "PRN", "AUX", "NUL", "COM1", "COM2", "COM3", "COM4", 
                    "COM5", "COM6", "COM7", "COM8", "COM9", "LPT1", "LPT2", 
                    "LPT3", "LPT4", "LPT5", "LPT6", "LPT7", "LPT8", "LPT9"];
    
    // Check both exact match and with any extension (e.g., "CON.txt" is also reserved)
    if reserved.contains(&upper.as_str()) {
        return false;
    }
    
    // Check if name starts with reserved name followed by a dot
    for res in &reserved {
        if upper.starts_with(res) && upper.len() > res.len() {
            if let Some('.') = upper.chars().nth(res.len()) {
                return false;
            }
        }
    }

    true
}
```

Update the error message in deserialization to include this restriction: [6](#0-5) 

## Proof of Concept

**Rust Test (add to `package_name.rs`):**

```rust
#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_rejects_windows_reserved_names() {
        // Basic reserved device names
        assert!(!is_valid_package_name("CON"));
        assert!(!is_valid_package_name("PRN"));
        assert!(!is_valid_package_name("AUX"));
        assert!(!is_valid_package_name("NUL"));
        
        // COM and LPT ports
        assert!(!is_valid_package_name("COM1"));
        assert!(!is_valid_package_name("COM9"));
        assert!(!is_valid_package_name("LPT1"));
        assert!(!is_valid_package_name("LPT9"));
        
        // Case insensitive
        assert!(!is_valid_package_name("con"));
        assert!(!is_valid_package_name("Con"));
        assert!(!is_valid_package_name("cOn"));
        
        // Valid names that are similar but not reserved
        assert!(is_valid_package_name("CONSOLE"));
        assert!(is_valid_package_name("CON_UTIL"));
        assert!(is_valid_package_name("MY_CON"));
    }

    #[test]
    #[cfg(target_os = "windows")]
    fn test_windows_file_creation_fails_with_reserved_names() {
        use std::fs;
        use std::path::Path;
        
        let temp_dir = std::env::temp_dir();
        let reserved_path = temp_dir.join("CON");
        
        // This should fail on Windows
        let result = fs::create_dir(&reserved_path);
        assert!(result.is_err(), "Windows should reject CON as directory name");
    }
}
```

**Manual Reproduction Steps:**

1. On a Windows machine with Aptos CLI installed
2. Create a Move.toml with a package named "CON":
```toml
[package]
name = "CON"
version = "1.0.0"
```
3. Attempt to build or init the package: `aptos move compile`
4. Observe file system error when attempting to create directories

**Notes**

The vulnerability stems from insufficient validation of user-controlled input (package names) that is later used in file system operations. While the primary impact is on Windows platforms, this represents a cross-platform compatibility issue that violates the principle of consistent package behavior across operating systems. The fix is straightforward and adds minimal overhead to the validation process.

### Citations

**File:** third_party/move/tools/move-package-manifest/src/package_name.rs (L58-67)
```rust
fn is_valid_package_name(s: &str) -> bool {
    let mut chars = s.chars();

    match chars.next() {
        Some(c) if c.is_ascii_alphabetic() || c == '_' => (),
        _ => return false,
    }

    chars.all(|c| c.is_ascii_alphanumeric() || c == '-' || c == '_')
}
```

**File:** third_party/move/tools/move-package-manifest/src/package_name.rs (L74-76)
```rust
        let make_err = || {
            serde::de::Error::custom("Invalid package name -- must start with a letter or _; only letters, digits, - and _ allowed.")
        };
```

**File:** third_party/move/tools/move-package-cache/src/package_cache.rs (L290-298)
```rust
        let on_chain_packages_path = self.root.join("on-chain");

        let canonical_node_identity = CanonicalNodeIdentity::new(fullnode_url)?;
        let canonical_name = format!(
            "{}+{}+{}+{}",
            &*canonical_node_identity, network_version, address, package_name
        );

        let cached_package_path = on_chain_packages_path.join(&canonical_name);
```

**File:** third_party/move/tools/move-package/src/compilation/compiled_package.rs (L303-323)
```rust
    fn get_compiled_units_paths(&self, package_name: Symbol) -> Result<Vec<String>> {
        let package_dir = if self.package.compiled_package_info.package_name == package_name {
            self.root_path.clone()
        } else {
            self.root_path
                .join(CompiledPackageLayout::Dependencies.path())
                .join(package_name.as_str())
        };
        let mut compiled_unit_paths = vec![];
        let module_path = package_dir.join(CompiledPackageLayout::CompiledModules.path());
        if module_path.exists() {
            compiled_unit_paths.push(module_path);
        }
        let script_path = package_dir.join(CompiledPackageLayout::CompiledScripts.path());
        if script_path.exists() {
            compiled_unit_paths.push(script_path);
        }
        find_filenames(&compiled_unit_paths, |path| {
            extension_equals(path, MOVE_COMPILED_EXTENSION)
        })
    }
```

**File:** aptos-move/e2e-tests/src/executor.rs (L1736-1741)
```rust
        // 'test_name' includes ':' in the names, lets re-write these to be '_'s so that these
        // files can persist on windows machines.
        let file_name = test_name.replace(':', "_");
        self.executed_output = Some(GoldenOutputs::new(&file_name));
        self.set_tracing(test_name, file_name)
    }
```
