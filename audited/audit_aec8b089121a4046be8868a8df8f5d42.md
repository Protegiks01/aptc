# Audit Report

## Title
Consensus Split Vulnerability Due to Inconsistent Config Fetch Error Handling in Environment Hash Calculation

## Summary
The `fetch_config_and_update_hash()` function silently swallows storage errors when fetching on-chain configurations, treating them identically to legitimately missing configs. This causes validators experiencing transient storage errors to compute different environment hashes and use different default values, leading to non-deterministic transaction execution and consensus splits.

## Finding Description

The vulnerability exists in the environment initialization path during block execution. When validators fetch on-chain configurations (Features, ChainId, gas parameters), storage errors are incorrectly conflated with legitimately missing configs, breaking the deterministic execution invariant.

**Root Cause**: The `fetch_config_bytes` implementation uses `.ok()?` to convert both storage errors and missing configs to `None`: [1](#0-0) 

This conflation occurs because `get_state_value()` returns `Result<Option<StateValue>, StateViewError>`, and `.ok()?` converts:
- `Ok(None)` → `None` (config doesn't exist - correct)
- `Err(storage_error)` → `None` (storage error - incorrect)

**Hash Calculation Impact**: The `fetch_config_and_update_hash` function only updates the environment hash when config fetch succeeds: [2](#0-1) 

When `None` is returned, the hash is NOT updated with config bytes, and default values are used.

**Environment Creation During Block Execution**: The environment is created during consensus block execution from the state view: [3](#0-2) 

**Default Fallback Behavior**: When configs fail to load, the system uses defaults that may differ significantly from on-chain values: [4](#0-3) 

For gas parameters: [5](#0-4) 

**Features Default Contains 70+ Flags**: The default Features enables numerous feature flags that may differ from on-chain governance-modified configs: [6](#0-5) 

**Environment Comparison by Hash**: Validators compare environments by their computed hash: [7](#0-6) 

**Storage Errors Map to StateViewError**: Database I/O errors, timeouts, and corruption all convert to `StateViewError::Other`: [8](#0-7) [9](#0-8) 

**Attack Scenario**:
1. Validator A successfully fetches `Features` from storage → hash includes Features bytes, uses on-chain feature flags
2. Validator B experiences transient DB I/O error → fetch returns `None` → hash excludes Features bytes, uses `Features::default()`
3. On-chain `Features` differs from `Features::default()` (modified via governance)
4. Both validators have different environment hashes, different feature flags, different VM configurations
5. They execute identical transactions differently
6. They produce different state roots
7. **Consensus split occurs**

## Impact Explanation

**Severity: HIGH**

This qualifies as HIGH severity under the Aptos bug bounty program because it causes **"Consensus/Safety Violations"** - specifically consensus splits where different validators produce different state roots for identical blocks.

**Impact**:
- **Consensus Safety Violation**: Different validators execute identically-ordered blocks non-deterministically
- **Network Partition**: Validators split into groups with incompatible state roots, requiring manual intervention or hard fork to resolve
- **Loss of Liveness**: Consensus cannot progress when validators disagree on block validity
- **State Inconsistency**: Different nodes maintain fundamentally different views of blockchain state

The vulnerability requires no attacker - it occurs naturally from:
- Transient database I/O errors (disk failures, timeouts, corruption)
- Storage backend performance degradation
- Race conditions during state synchronization
- Hardware failures affecting storage subsystems

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

The vulnerability is likely to manifest in production because:

1. **Common Trigger Conditions**: Database I/O errors and storage latency spikes are common in distributed systems running on commodity hardware
2. **No Error Visibility**: Errors are silently converted to `None` with no logging or alerts, making diagnosis impossible
3. **Production Scale**: Large validator sets increase the probability that at least one validator experiences storage errors during critical config fetches
4. **Active Governance**: Feature flag governance means on-chain configs frequently differ from hardcoded defaults
5. **No Retry Logic**: No automatic retry mechanism exists for transient storage errors during environment initialization

## Recommendation

Distinguish between legitimate missing configs and storage errors. Propagate storage errors instead of silently converting them to `None`:

**Fix for `fetch_config_bytes`**:
```rust
fn fetch_config_bytes(&self, state_key: &StateKey) -> Result<Option<Bytes>, StateViewError> {
    self.get_state_value(state_key)
        .map(|opt| opt.map(|s| s.bytes().clone()))
}
```

**Fix for `fetch_config_and_update_hash`**:
```rust
fn fetch_config_and_update_hash<T: OnChainConfig>(
    sha3_256: &mut Sha3_256,
    state_view: &impl StateView,
) -> Result<Option<T>, StateViewError> {
    match T::fetch_config_and_bytes(state_view) {
        Ok(Some((config, bytes))) => {
            sha3_256.update(&bytes);
            Ok(Some(config))
        },
        Ok(None) => Ok(None),
        Err(e) => Err(e), // Propagate storage errors
    }
}
```

**Fix for `Environment::new`**:
Handle storage errors explicitly and either retry with backoff or fail-fast to prevent consensus divergence.

## Proof of Concept

The vulnerability is evident from code inspection. A PoC would require:
1. A test validator setup with injected storage failures
2. Demonstrating different environment hashes when one validator experiences storage errors
3. Showing different transaction execution results leading to state root divergence

The code path is clear and the vulnerability is inherent in the error handling design.

## Notes

This is a **determinism violation** at the core of the consensus layer. The silent error handling breaks the fundamental assumption that all validators execute blocks identically. The vulnerability is particularly insidious because:

1. It's non-deterministic - only affects validators experiencing storage errors
2. It's silent - no error logs or alerts are generated
3. It's cumulative - differences compound across transactions
4. It's governance-dependent - impact increases when on-chain configs diverge from defaults

The fix must ensure that storage errors during environment initialization are treated as fatal errors that prevent block execution, rather than silently falling back to potentially different default values.

### Citations

**File:** types/src/on_chain_config/mod.rs (L204-210)
```rust
impl<S: StateView> ConfigStorage for S {
    fn fetch_config_bytes(&self, state_key: &StateKey) -> Option<Bytes> {
        self.get_state_value(state_key)
            .ok()?
            .map(|s| s.bytes().clone())
    }
}
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L152-156)
```rust
impl PartialEq for AptosEnvironment {
    fn eq(&self, other: &Self) -> bool {
        self.0.hash == other.0.hash
    }
}
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L219-224)
```rust
        let features =
            fetch_config_and_update_hash::<Features>(&mut sha3_256, state_view).unwrap_or_default();

        // If no chain ID is in storage, we assume we are in a testing environment.
        let chain_id = fetch_config_and_update_hash::<ChainId>(&mut sha3_256, state_view)
            .unwrap_or_else(ChainId::test);
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L248-264)
```rust
        let (native_gas_params, misc_gas_params, ty_builder) = match &gas_params {
            Ok(gas_params) => {
                let ty_builder = aptos_prod_ty_builder(gas_feature_version, gas_params);
                (
                    gas_params.natives.clone(),
                    gas_params.vm.misc.clone(),
                    ty_builder,
                )
            },
            Err(_) => {
                let ty_builder = aptos_default_ty_builder();
                (
                    NativeGasParameters::zeros(),
                    MiscGasParameters::zeros(),
                    ty_builder,
                )
            },
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L328-336)
```rust
/// Fetches config from storage and updates the hash if it exists. Returns the fetched config.
fn fetch_config_and_update_hash<T: OnChainConfig>(
    sha3_256: &mut Sha3_256,
    state_view: &impl StateView,
) -> Option<T> {
    let (config, bytes) = T::fetch_config_and_bytes(state_view)?;
    sha3_256.update(&bytes);
    Some(config)
}
```

**File:** aptos-move/block-executor/src/code_cache_global_manager.rs (L212-213)
```rust
        let storage_environment =
            AptosEnvironment::new_with_delayed_field_optimization_enabled(&state_view);
```

**File:** types/src/on_chain_config/aptos_features.rs (L287-297)
```rust
impl Default for Features {
    fn default() -> Self {
        let mut features = Features {
            features: vec![0; 5],
        };

        for feature in FeatureFlag::default_features() {
            features.enable(feature);
        }
        features
    }
```

**File:** storage/storage-interface/src/errors.rs (L69-86)
```rust
impl From<AptosDbError> for StateViewError {
    fn from(error: AptosDbError) -> Self {
        match error {
            AptosDbError::NotFound(msg) => StateViewError::NotFound(msg),
            AptosDbError::Other(msg) => StateViewError::Other(msg),
            _ => StateViewError::Other(format!("{}", error)),
        }
    }
}

impl From<StateViewError> for AptosDbError {
    fn from(error: StateViewError) -> Self {
        match error {
            StateViewError::NotFound(msg) => AptosDbError::NotFound(msg),
            StateViewError::Other(msg) => AptosDbError::Other(msg),
            StateViewError::BcsError(err) => AptosDbError::BcsError(err.to_string()),
        }
    }
```

**File:** types/src/state_store/errors.rs (L6-15)
```rust
#[derive(Debug, Error)]
pub enum StateViewError {
    #[error("{0} not found.")]
    NotFound(String),
    /// Other non-classified error.
    #[error("{0}")]
    Other(String),
    #[error(transparent)]
    BcsError(#[from] bcs::Error),
}
```
