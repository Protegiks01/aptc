# Audit Report

## Title
Silent Fast Randomness Configuration Mismatch Causes Consensus Liveness Failure

## Summary
When validators compute different `fast_rand_config` values during epoch initialization, the silent failure of augmented data verification causes the randomness generation protocol to stall, leading to complete consensus liveness loss. This occurs because verification failures are silently dropped without logging, preventing validators from detecting and recovering from the configuration mismatch.

## Finding Description

The vulnerability exists in the randomness generation subsystem where validators exchange augmented data to enable randomness generation. The critical issue manifests when:

**Configuration Divergence:**
During epoch initialization in `try_get_rand_config_for_new_epoch()`, validators independently compute whether to enable fast randomness based on multiple conditions. If these conditions evaluate differently across validators (e.g., due to DKG transcript decryption producing different results, software version mismatches, or implementation bugs), some validators will have `fast_rand_config = Some(RandConfig)` while others have `fast_rand_config = None`. [1](#0-0) [2](#0-1) 

**Silent Verification Failure:**
When validators exchange augmented data, the `AugmentedData` struct contains both `delta` and `fast_delta` fields. The verification logic strictly enforces that `fast_delta` must be present if and only if `fast_rand_config` is present: [3](#0-2) 

When a validator with `fast_rand_config = Some(...)` sends `AugmentedData` with `fast_delta = Some(...)` to a validator with `fast_rand_config = None`, the verification fails. However, this failure is **silently dropped** in the verification task: [4](#0-3) 

The `.is_ok()` check means verification failures produce no error logsâ€”messages are simply discarded. Only deserialization errors trigger warnings.

**Consensus Impact:**
1. Validators cannot successfully exchange augmented data due to incompatible `fast_delta` expectations
2. The reliable broadcast protocol for augmented data certification cannot complete
3. Randomness generation stalls indefinitely
4. If randomness is required for consensus (when `randomness_enabled() = true`), the entire network loses liveness
5. No validator can detect the root cause since verification failures are silent

The invariant violation occurs when validators have different `fast_rand_config` states in the same epoch, causing them to be unable to participate in the same randomness protocol despite all running the same on-chain configuration.

## Impact Explanation

**Severity: Critical** - This vulnerability meets the "Total loss of liveness/network availability" criterion from the Aptos bug bounty program.

When the configuration mismatch occurs:
- All validators enter a deadlock state waiting for augmented data that will never arrive
- Block production halts if randomness is required
- The network requires manual intervention (likely a hard fork) to recover
- No automatic recovery mechanism exists since errors are silent

The impact is network-wide and non-recoverable through normal consensus mechanisms, qualifying as Critical severity (up to $1,000,000).

## Likelihood Explanation

**Likelihood: Medium to High** depending on deployment practices.

This can occur when:
1. **Software Version Mismatches**: If validators run different versions of the consensus code with DKG implementation differences, they may decrypt the transcript differently
2. **DKG Implementation Bugs**: Any bug in the DKG decryption that produces non-deterministic results (e.g., based on timing, RNG initialization, or platform differences)
3. **Epoch Transition Race Conditions**: If validators load epoch state at slightly different times and the on-chain DKG state is being modified
4. **Malformed DKG Transcript**: If the on-chain DKG transcript is malformed or partially corrupted, different validators may interpret it differently

The likelihood increases significantly in heterogeneous validator environments where not all operators upgrade simultaneously.

## Recommendation

**Immediate Fix:**
Add explicit error logging for verification failures in the RandManager verification task:

```rust
// In rand_manager.rs, verification_task function
match bcs::from_bytes::<RandMessage<S, D>>(rand_gen_msg.req.data()) {
    Ok(msg) => {
        match msg.verify(
            &epoch_state_clone,
            &config_clone,
            &fast_config_clone,
            rand_gen_msg.sender,
        ) {
            Ok(_) => {
                let _ = tx.unbounded_send(RpcRequest {
                    req: msg,
                    protocol: rand_gen_msg.protocol,
                    response_sender: rand_gen_msg.response_sender,
                });
            }
            Err(e) => {
                // CRITICAL: Log verification failures explicitly
                error!(
                    "[RandManager] Message verification failed from {}: {:?}. \
                    This may indicate fast_rand_config mismatch.",
                    rand_gen_msg.sender, e
                );
                counters::RAND_MESSAGE_VERIFICATION_FAILURES
                    .with_label_values(&[&format!("{:?}", rand_gen_msg.sender)])
                    .inc();
            }
        }
    },
    Err(e) => {
        warn!("Invalid rand gen message: {}", e);
    },
}
```

**Comprehensive Fix:**
1. Add determinism checks during epoch initialization to verify all validators computed the same `fast_rand_config` state
2. Include `fast_rand_config` hash in epoch initialization messages to detect mismatches early
3. Implement a consensus-level check that all validators agree on randomness configuration before proceeding
4. Add monitoring/alerting for silent verification failures
5. Make fast randomness configuration part of the signed epoch state to ensure byzantine agreement

**Fail-Safe Mechanism:**
If augmented data verification fails due to `fast_delta` mismatch, validators should:
1. Log an emergency alert
2. Attempt to re-initialize randomness with `fast_rand_config = None` for all validators
3. Trigger an epoch recovery protocol

## Proof of Concept

```rust
#[cfg(test)]
mod test_fast_randomness_split {
    use super::*;
    
    #[tokio::test]
    async fn test_fast_config_mismatch_causes_silent_failure() {
        // Setup two validators with different fast_rand_config states
        let epoch = 10;
        let num_validators = 2;
        
        // Validator A: has fast_rand_config = Some(...)
        let validator_a_fast_config = Some(create_test_rand_config(epoch, 0));
        let aug_data_a = AugmentedData {
            delta: create_test_delta(),
            fast_delta: Some(create_test_fast_delta()), // Has fast_delta
        };
        
        // Validator B: has fast_rand_config = None  
        let validator_b_fast_config = None;
        let aug_data_b = AugmentedData {
            delta: create_test_delta(),
            fast_delta: None, // No fast_delta
        };
        
        // Test verification from A to B
        let result_b_receives_a = aug_data_a.verify(
            &create_test_rand_config(epoch, 1),
            &validator_b_fast_config, // B has None
            &validator_a_address(),
        );
        
        // This should FAIL due to fast_delta mismatch
        assert!(result_b_receives_a.is_err());
        assert!(result_b_receives_a
            .unwrap_err()
            .to_string()
            .contains("Fast path delta should be present iff fast_rand_config is present"));
        
        // Test verification from B to A
        let result_a_receives_b = aug_data_b.verify(
            &create_test_rand_config(epoch, 0),
            &validator_a_fast_config, // A has Some
            &validator_b_address(),
        );
        
        // This should also FAIL
        assert!(result_a_receives_b.is_err());
        
        // Critical: In production, these failures are silently dropped
        // causing the randomness protocol to deadlock without any error logs
    }
}
``` [5](#0-4) [6](#0-5) 

**Notes:**

This vulnerability is particularly insidious because:
1. It manifests during epoch transitions when the network is already in a sensitive state
2. No validator logs indicate the root cause (silent failure)
3. Operators cannot diagnose the issue without deep code analysis
4. The network appears "stuck" with no obvious error messages
5. Recovery requires coordinated action across all validators

The fix requires both immediate logging improvements and longer-term protocol changes to ensure deterministic randomness configuration across all validators.

### Citations

**File:** consensus/src/epoch_manager.rs (L1074-1078)
```rust
        let fast_randomness_is_enabled = onchain_randomness_config.fast_randomness_enabled()
            && sk.fast.is_some()
            && pk.fast.is_some()
            && transcript.fast.is_some()
            && dkg_pub_params.pvss_config.fast_wconfig.is_some();
```

**File:** consensus/src/epoch_manager.rs (L1137-1159)
```rust
        let fast_rand_config = if let (Some((ask, apk)), Some(trx), Some(wconfig)) = (
            fast_augmented_key_pair,
            transcript.fast.as_ref(),
            dkg_pub_params.pvss_config.fast_wconfig.as_ref(),
        ) {
            let pk_shares = (0..new_epoch_state.verifier.len())
                .map(|id| trx.get_public_key_share(wconfig, &Player { id }))
                .collect::<Vec<_>>();

            let fast_keys = RandKeys::new(ask, apk, pk_shares, new_epoch_state.verifier.len());
            let fast_wconfig = wconfig.clone();

            Some(RandConfig::new(
                self.author,
                new_epoch,
                new_epoch_state.verifier.clone(),
                vuf_pp,
                fast_keys,
                fast_wconfig,
            ))
        } else {
            None
        };
```

**File:** consensus/src/epoch_manager.rs (L1243-1261)
```rust
        let (rand_config, fast_rand_config) = match rand_configs {
            Ok((rand_config, fast_rand_config)) => (Some(rand_config), fast_rand_config),
            Err(reason) => {
                if onchain_randomness_config.randomness_enabled() {
                    if epoch_state.epoch > 2 {
                        error!(
                            "Failed to get randomness config for new epoch [{}]: {:?}",
                            epoch_state.epoch, reason
                        );
                    } else {
                        warn!(
                            "Failed to get randomness config for new epoch [{}]: {:?}",
                            epoch_state.epoch, reason
                        );
                    }
                }
                (None, None)
            },
        };
```

**File:** consensus/src/rand/rand_gen/types.rs (L196-215)
```rust
    fn verify(
        &self,
        rand_config: &RandConfig,
        fast_rand_config: &Option<RandConfig>,
        author: &Author,
    ) -> anyhow::Result<()> {
        rand_config
            .derive_apk(author, self.delta.clone())
            .map(|_| ())?;

        ensure!(
            self.fast_delta.is_some() == fast_rand_config.is_some(),
            "Fast path delta should be present iff fast_rand_config is present."
        );
        if let (Some(config), Some(fast_delta)) = (fast_rand_config, self.fast_delta.as_ref()) {
            config.derive_apk(author, fast_delta.clone()).map(|_| ())
        } else {
            Ok(())
        }
    }
```

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L236-260)
```rust
                    match bcs::from_bytes::<RandMessage<S, D>>(rand_gen_msg.req.data()) {
                        Ok(msg) => {
                            if msg
                                .verify(
                                    &epoch_state_clone,
                                    &config_clone,
                                    &fast_config_clone,
                                    rand_gen_msg.sender,
                                )
                                .is_ok()
                            {
                                let _ = tx.unbounded_send(RpcRequest {
                                    req: msg,
                                    protocol: rand_gen_msg.protocol,
                                    response_sender: rand_gen_msg.response_sender,
                                });
                            }
                        },
                        Err(e) => {
                            warn!("Invalid rand gen message: {}", e);
                        },
                    }
                })
                .await;
        }
```
