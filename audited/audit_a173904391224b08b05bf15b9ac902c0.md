# Audit Report

## Title
Invalid Weight Configuration Causes Complete Network Halt via Division-by-Zero Panic in Leader Selection

## Summary
When all three leader reputation weights (`active_weight`, `inactive_weight`, `failed_weight`) are set to 0 through on-chain governance configuration, every validator node will panic with a division-by-zero error during leader selection, causing complete and immediate network halt requiring a hard fork to recover.

## Finding Description

The leader reputation system uses three configurable weights to calculate validator selection probabilities: `active_weight`, `inactive_weight`, and `failed_weight`. These weights are stored in the on-chain `ConsensusConfig` and can be modified through governance proposals. [1](#0-0) 

The vulnerability exists because there is **no validation** preventing all three weights from being set to 0:

1. The Move contract only validates that config bytes are non-empty, not the actual weight values: [2](#0-1) 

2. The Rust deserialization has no validation: [3](#0-2) 

3. During leader selection, the `get_weights()` function returns one of these three weights for each validator based on their performance: [4](#0-3) 

4. If all three weights are 0, every validator receives weight 0. These weights are then multiplied by voting powers, but `0 Ã— any_value = 0`, so all `stake_weights` remain 0: [5](#0-4) 

5. The `choose_index()` function is called with all-zero weights, which causes `total_weight` to become 0: [6](#0-5) 

6. When `next_in_range(state, 0)` is called, it attempts `u128::from_le_bytes(temp) % 0`, causing an immediate panic: [7](#0-6) 

This breaks the **Consensus Liveness** invariant - the network cannot proceed with block production when leader selection fails on all validator nodes simultaneously.

## Impact Explanation

**Severity: Critical** (up to $1,000,000)

This vulnerability meets the **"Total loss of liveness/network availability"** and **"Non-recoverable network partition (requires hardfork)"** criteria:

- **Complete Network Halt**: Every validator node crashes simultaneously when attempting leader selection
- **No Automatic Recovery**: Once triggered, the network cannot produce new blocks
- **Governance Cannot Fix**: Since governance requires consensus to execute proposals, the network cannot apply a governance fix
- **Requires Hard Fork**: The only recovery path is a coordinated hard fork with corrected configuration
- **Deterministic Failure**: All validators will fail at the exact same round when leader selection is attempted

The impact affects **all validators** and **all network users** - no transactions can be processed, no state transitions occur, and the blockchain is completely halted.

## Likelihood Explanation

**Likelihood: Medium-Low** (but consequences are catastrophic)

Attack vectors include:

1. **Malicious Governance Proposal**: An attacker with 50%+ voting power could intentionally set all weights to 0
2. **Compromised Governance**: If there's a vulnerability in the governance voting mechanism, an attacker could inject a malicious config
3. **Accidental Misconfiguration**: During a governance upgrade, weights could be accidentally set to 0 due to:
   - Human error in parameter specification
   - Bug in governance tooling
   - Misunderstanding of default values

While requiring governance access increases the attack complexity, governance is explicitly part of the attack surface in Aptos's trust model. Additionally, the potential for accidental misconfiguration during upgrades is non-trivial.

## Recommendation

**Immediate Fix**: Add validation to prevent all three weights from being 0 simultaneously.

**Option 1 - Rust-side validation** (add to `ProposerAndVoterHeuristic::new()`):
```rust
pub fn new(
    author: Author,
    active_weight: u64,
    inactive_weight: u64,
    failed_weight: u64,
    // ... other params
) -> Result<Self> {
    ensure!(
        active_weight > 0 || inactive_weight > 0 || failed_weight > 0,
        "At least one weight must be non-zero"
    );
    Ok(Self { /* ... */ })
}
```

**Option 2 - Move-side validation** (add to `consensus_config.move::set_for_next_epoch()`):
```move
native fun validate_consensus_config(config_bytes: vector<u8>): bool;

public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
    system_addresses::assert_aptos_framework(account);
    assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
    assert!(validate_consensus_config(config), error::invalid_argument(EINVALID_CONFIG));
    std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
}
```

**Option 3 - Defensive fix in `choose_index()`**:
```rust
pub(crate) fn choose_index(mut weights: Vec<u128>, state: Vec<u8>) -> usize {
    let mut total_weight = 0;
    for w in &mut weights {
        total_weight = total_weight.checked_add(w)
            .expect("Total stake shouldn't exceed u128::MAX");
        *w = total_weight;
    }
    
    // Defensive check
    if total_weight == 0 {
        error!("All weights are zero - using round-robin fallback");
        let hash = aptos_crypto::HashValue::sha3_256_of(&state);
        return (u128::from_le_bytes(...) % weights.len() as u128) as usize;
    }
    
    let chosen_weight = next_in_range(state, total_weight);
    // ... rest of function
}
```

**Recommended approach**: Implement **both** Option 1 (fail-fast at configuration time) and Option 3 (defense-in-depth at runtime).

## Proof of Concept

**Step 1**: Create a malicious governance proposal with all weights set to 0:

```rust
// In a test environment
let malicious_config = ProposerAndVoterConfig {
    active_weight: 0,
    inactive_weight: 0,
    failed_weight: 0,
    failure_threshold_percent: 10,
    proposer_window_num_validators_multiplier: 10,
    voter_window_num_validators_multiplier: 1,
    weight_by_voting_power: true,
    use_history_from_previous_epoch_max_count: 5,
};

let consensus_config = OnChainConsensusConfig::V5 {
    alg: ConsensusAlgorithmConfig::JolteonV2 {
        main: ConsensusConfigV1 {
            // ... other fields
        },
        quorum_store_enabled: true,
        order_vote_enabled: true,
    },
    vtxn: ValidatorTxnConfig::default(),
    window_size: Some(1),
    rand_check_enabled: true,
};

// Serialize and apply through governance
let config_bytes = bcs::to_bytes(&consensus_config).unwrap();
// Apply via governance proposal
```

**Step 2**: Once the epoch transition applies the config, any call to leader selection will panic:

```rust
// This will panic with "attempt to calculate the remainder with a divisor of zero"
let weights = vec![0u128, 0u128, 0u128, 0u128]; // All validators have weight 0
let state = vec![1, 2, 3, 4];
let chosen = choose_index(weights, state); // PANIC HERE
```

**Expected Result**: Validator node crashes with:
```
thread 'main' panicked at 'attempt to calculate the remainder with a divisor of zero'
```

**Network Impact**: All validators crash simultaneously when attempting to select the leader for the next round, causing complete network halt.

## Notes

- The default configuration uses non-zero weights (1000, 10, 1), so this issue doesn't occur under normal operation
- The vulnerability only manifests when **all three** weights are simultaneously set to 0 through governance
- Recovery would require a coordinated hard fork where validators apply a corrected configuration before restarting
- This represents a critical supply chain risk if governance is compromised or misconfigured during upgrades

### Citations

**File:** types/src/on_chain_config/consensus_config.rs (L464-468)
```rust
    fn deserialize_into_config(bytes: &[u8]) -> Result<Self> {
        let raw_bytes: Vec<u8> = bcs::from_bytes(bytes)?;
        bcs::from_bytes(&raw_bytes)
            .map_err(|e| format_err!("[on-chain config] Failed to deserialize into config: {}", e))
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L552-575)
```rust
#[derive(Clone, Copy, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct ProposerAndVoterConfig {
    // Selection weight for active validators with proposer failures below threshold
    pub active_weight: u64,
    // Selection weight for inactive validators with proposer failures below threshold
    pub inactive_weight: u64,
    // Selection weight for validators with proposer failures above threshold
    pub failed_weight: u64,
    // Thresholed of failures in the rounds validator was selected to be proposer
    // integer values representing percentages, i.e. 12 is 12%.
    pub failure_threshold_percent: u32,
    // Window into history considered for proposer statistics, multiplier
    // on top of number of validators
    pub proposer_window_num_validators_multiplier: usize,
    // Window into history considered for votre statistics, multiplier
    // on top of number of validators
    pub voter_window_num_validators_multiplier: usize,
    // Flag whether to use voting power as multiplier to the weights
    pub weight_by_voting_power: bool,
    // Flag whether to use history from previous epoch (0 if not),
    // representing a number of historical epochs (beyond the current one)
    // to consider.
    pub use_history_from_previous_epoch_max_count: u32,
}
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```

**File:** consensus/src/liveness/leader_reputation.rs (L534-551)
```rust
        epoch_to_candidates[&epoch]
            .iter()
            .map(|author| {
                let cur_votes = *votes.get(author).unwrap_or(&0);
                let cur_proposals = *proposals.get(author).unwrap_or(&0);
                let cur_failed_proposals = *failed_proposals.get(author).unwrap_or(&0);

                if cur_failed_proposals * 100
                    > (cur_proposals + cur_failed_proposals) * self.failure_threshold_percent
                {
                    self.failed_weight
                } else if cur_proposals > 0 || cur_votes > 0 {
                    self.active_weight
                } else {
                    self.inactive_weight
                }
            })
            .collect()
```

**File:** consensus/src/liveness/leader_reputation.rs (L710-715)
```rust
        // Multiply weights by voting power:
        let stake_weights: Vec<u128> = weights
            .iter_mut()
            .enumerate()
            .map(|(i, w)| *w as u128 * self.voting_powers[i] as u128)
            .collect();
```

**File:** consensus/src/liveness/proposer_election.rs (L39-46)
```rust
fn next_in_range(state: Vec<u8>, max: u128) -> u128 {
    // hash = SHA-3-256(state)
    let hash = aptos_crypto::HashValue::sha3_256_of(&state).to_vec();
    let mut temp = [0u8; 16];
    copy_slice_to_vec(&hash[..16], &mut temp).expect("next failed");
    // return hash[0..16]
    u128::from_le_bytes(temp) % max
}
```

**File:** consensus/src/liveness/proposer_election.rs (L49-59)
```rust
pub(crate) fn choose_index(mut weights: Vec<u128>, state: Vec<u8>) -> usize {
    let mut total_weight = 0;
    // Create cumulative weights vector
    // Since we own the vector, we can safely modify it in place
    for w in &mut weights {
        total_weight = total_weight
            .checked_add(w)
            .expect("Total stake shouldn't exceed u128::MAX");
        *w = total_weight;
    }
    let chosen_weight = next_in_range(state, total_weight);
```
