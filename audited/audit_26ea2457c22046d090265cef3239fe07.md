# Audit Report

## Title
Panic in Aptos Debugger When Processing Transactions with Invalid Signatures

## Summary
The `aptos-debugger` tool panics when attempting to replay committed transactions that have invalid signatures. The conversion at line 75 is safe, but the immediate usage of converted transactions at line 86 calls `expect_valid()` which panics on `SignatureVerifiedTransaction::Invalid` variants.

## Finding Description

The vulnerability exists in the transaction statistics printing logic, not in the conversion itself: [1](#0-0) 

The `Into<SignatureVerifiedTransaction>` conversion at line 75 is safe and handles all Transaction variants correctly: [2](#0-1) 

However, the converted transactions are immediately passed to `print_transaction_stats` which unsafely calls `expect_valid()`: [3](#0-2) 

The `expect_valid()` method panics on Invalid transactions: [4](#0-3) 

In contrast, the production VM execution path correctly handles Invalid transactions before calling `expect_valid()`: [5](#0-4) 

## Impact Explanation

**HIGH Severity** - This qualifies as "API crashes" per the Aptos bug bounty criteria. The debugger is a production tool used by validators for:
- Debugging transaction execution issues during incidents
- Replaying historical blocks for forensic analysis  
- Recovery operations during network issues
- Genesis transaction application

A panic prevents validators from using critical debugging infrastructure, potentially prolonging incident response times.

## Likelihood Explanation

**MEDIUM-LOW Likelihood** - For this to trigger, a UserTransaction with an invalid signature must be committed to the blockchain. While mempool validation normally rejects such transactions, edge cases exist:

1. **Database corruption**: Signature data corruption in AptosDB
2. **Feature flag changes**: Historical transactions with now-disabled signature types (e.g., deprecated keyless variants)
3. **Manual database operations**: Test data or recovery operations
4. **Consensus bugs**: Hypothetical validation bypass (separate issue)

The debugger operates on committed historical data, re-verifying signatures that may have been valid at commit time but fail verification during replay.

## Recommendation

Add defensive checks before calling `expect_valid()`, following the pattern used in production VM code:

```rust
fn print_transaction_stats(sig_verified_txns: &[SignatureVerifiedTransaction], version: u64) {
    let transaction_types = sig_verified_txns
        .iter()
        .filter_map(|txn| {
            if !txn.is_valid() {
                return Some("invalid_signature".to_string());
            }
            Some(txn.expect_valid().type_name().to_string())
        })
        // ... rest of implementation
```

Alternatively, use `borrow_into_inner()` which doesn't panic: [6](#0-5) 

## Proof of Concept

```rust
#[test]
fn test_debugger_invalid_signature_panic() {
    // Create a transaction with invalid signature
    let raw_txn = RawTransaction::new(/* ... */);
    let bad_signature = Ed25519Signature::dummy_signature();
    let txn = SignedTransaction::new(raw_txn, /* wrong key */, bad_signature);
    
    // Simulate conversion (would create Invalid variant)
    let sig_verified: SignatureVerifiedTransaction = Transaction::UserTransaction(txn).into();
    assert!(!sig_verified.is_valid());
    
    // This would panic in print_transaction_stats
    // sig_verified.expect_valid(); // PANIC!
}
```

To trigger in production debugger:
1. Manually corrupt a transaction's signature data in AptosDB
2. Run `aptos-debugger aptos-db replay --begin-version <corrupted_txn_version>`
3. Observe panic at `print_transaction_stats:403`

**Notes:**
- The conversion itself (line 75) is safe for all Transaction variants
- Only `UserTransaction` variants undergo signature verification; other variants are always marked Valid
- The bug is in the immediate usage pattern, not the conversion
- Production VM code correctly guards `expect_valid()` calls with Invalid checks
- This affects debugger availability but not consensus or execution correctness

### Citations

**File:** aptos-move/aptos-debugger/src/aptos_debugger.rs (L74-86)
```rust
        let sig_verified_txns: Vec<SignatureVerifiedTransaction> =
            txns.into_iter().map(|x| x.into()).collect::<Vec<_>>();

        // Convert persisted auxiliary infos to auxiliary infos
        let auxiliary_infos = auxiliary_infos
            .into_iter()
            .map(|persisted_info| AuxiliaryInfo::new(persisted_info, None))
            .collect::<Vec<_>>();

        let txn_provider = DefaultTxnProvider::new(sig_verified_txns, auxiliary_infos);
        let state_view = DebuggerStateView::new(self.debugger.clone(), version);

        print_transaction_stats(txn_provider.get_txns(), version);
```

**File:** aptos-move/aptos-debugger/src/aptos_debugger.rs (L400-419)
```rust
fn print_transaction_stats(sig_verified_txns: &[SignatureVerifiedTransaction], version: u64) {
    let transaction_types = sig_verified_txns
        .iter()
        .map(|txn| txn.expect_valid().type_name().to_string())
        // conflate same consecutive elements into one with count
        .chunk_by(|k| k.clone())
        .into_iter()
        .map(|(k, r)| {
            let num = r.count();
            if num > 1 {
                format!("{} {}s", num, k)
            } else {
                k
            }
        })
        .collect::<Vec<_>>();
    let entry_functions = sig_verified_txns
        .iter()
        .filter_map(|txn| {
            txn.expect_valid().try_as_signed_user_txn().map(|txn| {
```

**File:** types/src/transaction/signature_verified_transaction.rs (L51-56)
```rust
    pub fn borrow_into_inner(&self) -> &Transaction {
        match self {
            SignatureVerifiedTransaction::Valid(txn) => txn,
            SignatureVerifiedTransaction::Invalid(txn) => txn,
        }
    }
```

**File:** types/src/transaction/signature_verified_transaction.rs (L82-87)
```rust
    pub fn expect_valid(&self) -> &Transaction {
        match self {
            SignatureVerifiedTransaction::Valid(txn) => txn,
            SignatureVerifiedTransaction::Invalid(_) => panic!("Expected valid transaction"),
        }
    }
```

**File:** types/src/transaction/signature_verified_transaction.rs (L129-139)
```rust
impl From<Transaction> for SignatureVerifiedTransaction {
    fn from(txn: Transaction) -> Self {
        match txn {
            Transaction::UserTransaction(txn) => match txn.verify_signature() {
                Ok(_) => SignatureVerifiedTransaction::Valid(Transaction::UserTransaction(txn)),
                Err(_) => SignatureVerifiedTransaction::Invalid(Transaction::UserTransaction(txn)),
            },
            _ => SignatureVerifiedTransaction::Valid(txn),
        }
    }
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2881-2887)
```rust
        if let SignatureVerifiedTransaction::Invalid(_) = txn {
            let vm_status = VMStatus::error(StatusCode::INVALID_SIGNATURE, None);
            let discarded_output = discarded_output(vm_status.status_code());
            return Ok((vm_status, discarded_output));
        }

        Ok(match txn.expect_valid() {
```
