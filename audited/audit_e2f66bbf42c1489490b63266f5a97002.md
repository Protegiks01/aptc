# Audit Report

## Title
Transaction Filter Bypass via Multisig Transactions with On-Chain Stored Payloads

## Summary
The `matches_entry_function()` function in transaction filters uses `.unwrap_or(false)` when checking multisig transactions with `None` payloads, causing DENY rules to fail to match. Attackers can bypass entry function filters by storing the target payload on-chain via `create_transaction()`, then submitting a multisig transaction with `transaction_payload = None`. The filter checks only the inline payload (None), returns no match, and allows the transaction through—but during execution, the VM retrieves and executes the denied function from on-chain storage.

## Finding Description

The vulnerability exists in the transaction filtering logic for multisig transactions. When a filter rule attempts to block specific entry functions using DENY rules, it only examines payloads that are directly embedded in the transaction. [1](#0-0) 

This code returns `false` (no match) when `transaction_payload` is `None`, causing DENY rules for specific entry functions to not trigger. The transaction then passes through with the default ALLOW behavior. [2](#0-1) 

However, multisig transactions legitimately support `None` payloads for cases where the payload is already stored on-chain: [3](#0-2) 

During execution, the VM retrieves the actual payload from on-chain storage: [4](#0-3) 

**Attack Path:**

1. Attacker creates a multisig account and uses `create_transaction()` to store a transaction payload on-chain that calls a denied entry function (e.g., `0x1::coin::transfer` if the filter blocks coin transfers)

2. Attacker submits a multisig transaction with `transaction_payload = None` to the mempool

3. The transaction filter's `matches_entry_function()` checks the transaction:
   - Sees `transaction_payload = None`
   - Returns `false` (no match)
   
4. The DENY rule doesn't trigger, transaction passes filter and enters mempool

5. During execution, the VM converts `None` to `TransactionExecutableRef::Empty`: [5](#0-4) 

6. VM calls `get_next_transaction_payload()` with empty bytes, which returns the stored on-chain payload [6](#0-5) 

7. The denied entry function executes successfully, bypassing the filter

The filter is applied before mempool insertion: [7](#0-6) 

## Impact Explanation

This is a **High Severity** issue per Aptos bug bounty criteria as it represents a "Significant protocol violation."

Transaction filters are a critical security mechanism that allows validators and node operators to enforce policies about which transactions they will process. When operators configure DENY rules for specific entry functions (e.g., to block experimental features, known vulnerable contracts, or governance attack vectors), they expect those rules to be enforced comprehensively.

This vulnerability completely bypasses that protection for multisig transactions, creating a security gap where:
- Direct calls to a function are blocked
- Indirect calls via multisig with on-chain payloads are allowed
- Operators have a false sense of security that their filters are working

While this doesn't directly cause fund loss or consensus violations, it undermines a defense-in-depth security layer that operators rely on for protecting their nodes.

## Likelihood Explanation

**Likelihood: Medium-High**

The attack requires:
- Creating a multisig account (straightforward, no special permissions)
- Calling `create_transaction()` to store payload on-chain (public entry function)
- Submitting a transaction with `None` payload (standard transaction submission)

The attack is **not detectable** from the transaction itself—the filter sees only an empty multisig transaction, not what will actually execute.

Likelihood is increased by:
- No special permissions required
- Simple execution (3 standard operations)
- Works against any DENY rule targeting entry functions
- No existing tests cover this case, suggesting it's an oversight

Likelihood is limited by:
- Requires operators to actually use entry function DENY filters (not all do)
- Impact depends on what functions are being filtered

## Recommendation

The filter logic should check on-chain stored payloads for multisig transactions. When encountering a multisig transaction with `None` payload, the filter should:

1. Query the on-chain state to retrieve the stored payload using the multisig account's next pending transaction
2. Apply filter rules to the retrieved payload, not just the inline payload
3. Only allow the transaction if the actual-to-be-executed payload passes filter rules

**Recommended fix for `matches_entry_function()`:**

```rust
TransactionPayload::Multisig(multisig) => {
    match &multisig.transaction_payload {
        Some(payload) => match payload {
            MultisigTransactionPayload::EntryFunction(entry_function) => {
                compare_entry_function(entry_function, address, module_name, function)
            },
        },
        None => {
            // For None payloads, we cannot determine the actual entry function
            // without on-chain state access. Conservative approach: either
            // 1. Query on-chain state to get the stored payload (requires state access)
            // 2. Treat as potential match if filtering is critical (safer default)
            // 3. Document this limitation clearly
            //
            // For now, recommend treating None payloads conservatively for DENY rules
            false // Keep current behavior but document the limitation
        }
    }
},
```

**Alternative approach:** Add a new filter matcher type `MultisigAddress` that can deny all multisig transactions from specific accounts, preventing the bypass.

**Documentation fix:** At minimum, clearly document that entry function filters only apply to inline payloads and do not cover multisig transactions with on-chain stored payloads.

## Proof of Concept

```rust
#[test]
fn test_entry_function_filter_multisig_bypass() {
    use aptos_types::transaction::{Multisig, MultisigTransactionPayload, TransactionPayload};
    use crate::transaction_filter::TransactionFilter;
    
    // Setup: Create a filter that DENIES a specific entry function
    let denied_address = AccountAddress::from_hex_literal("0x1").unwrap();
    let denied_module = "coin".to_string();
    let denied_function = "transfer".to_string();
    
    let filter = TransactionFilter::empty()
        .add_entry_function_filter(
            false, // DENY
            denied_address,
            denied_module.clone(),
            denied_function.clone(),
        )
        .add_all_filter(true); // Allow all others
    
    // Attack Step 1: Create a multisig transaction with inline payload (gets blocked)
    let entry_function = EntryFunction::new(
        ModuleId::new(denied_address, Identifier::new(denied_module.clone()).unwrap()),
        Identifier::new(denied_function.clone()).unwrap(),
        vec![],
        vec![],
    );
    
    let multisig_with_payload = Multisig {
        multisig_address: AccountAddress::random(),
        transaction_payload: Some(MultisigTransactionPayload::EntryFunction(entry_function.clone())),
    };
    
    let txn_with_payload = create_signed_transaction(
        TransactionPayload::Multisig(multisig_with_payload),
        false,
    );
    
    // This transaction should be DENIED
    assert!(!filter.allows_transaction(&txn_with_payload));
    
    // Attack Step 2: Create a multisig transaction with None payload (bypasses filter!)
    let multisig_no_payload = Multisig {
        multisig_address: AccountAddress::random(),
        transaction_payload: None, // Payload stored on-chain
    };
    
    let txn_no_payload = create_signed_transaction(
        TransactionPayload::Multisig(multisig_no_payload),
        false,
    );
    
    // This transaction is ALLOWED even though it will execute the same denied function!
    assert!(filter.allows_transaction(&txn_no_payload));
    
    // ^^^ This demonstrates the bypass - same function execution, different filter result
}
```

**Notes:**
- The same `matches_entry_function_module_address()` function has an identical vulnerability pattern for module address filtering
- Block-level and batch-level transaction filters likely inherit the same issue
- The vulnerability affects any filter rule that checks entry function properties (function name, module address, etc.)
- No existing tests in the codebase cover multisig transactions with `None` payloads, suggesting this case was overlooked during development

### Citations

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L46-46)
```rust
        true // No rules match (allow the transaction by default)
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L342-350)
```rust
        TransactionPayload::Multisig(multisig) => multisig
            .transaction_payload
            .as_ref()
            .map(|payload| match payload {
                MultisigTransactionPayload::EntryFunction(entry_function) => {
                    compare_entry_function(entry_function, address, module_name, function)
                },
            })
            .unwrap_or(false),
```

**File:** types/src/transaction/multisig.rs (L15-16)
```rust
    // Transaction payload is optional if already stored on chain.
    pub transaction_payload: Option<MultisigTransactionPayload>,
```

**File:** types/src/transaction/multisig.rs (L52-52)
```rust
            None => TransactionExecutableRef::Empty,
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L393-404)
```text
    public fun get_next_transaction_payload(
        multisig_account: address, provided_payload: vector<u8>): vector<u8> acquires MultisigAccount {
        let multisig_account_resource = borrow_global<MultisigAccount>(multisig_account);
        let sequence_number = multisig_account_resource.last_executed_sequence_number + 1;
        let transaction = table::borrow(&multisig_account_resource.transactions, sequence_number);

        if (option::is_some(&transaction.payload)) {
            *option::borrow(&transaction.payload)
        } else {
            provided_payload
        }
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1241-1250)
```rust
        let payload_bytes: Vec<Vec<u8>> = session
            .execute(|session| {
                session.execute_function_bypass_visibility(
                    &MULTISIG_ACCOUNT_MODULE,
                    GET_NEXT_TRANSACTION_PAYLOAD,
                    vec![],
                    serialize_values(&vec![
                        MoveValue::Address(multisig_address),
                        MoveValue::vector_u8(provided_payload),
                    ]),
```

**File:** mempool/src/shared_mempool/tasks.rs (L435-437)
```rust
            if transaction_filter_config
                .transaction_filter()
                .allows_transaction(&transaction)
```
