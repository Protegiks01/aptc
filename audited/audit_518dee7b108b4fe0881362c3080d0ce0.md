# Audit Report

## Title
DKG Transcript Verification Panic: Unchecked Empty Vector Access in `get_dealt_public_key()` During Peer Transcript Aggregation

## Summary
A malicious validator can craft a DKG transcript with an empty `V_hat` vector and submit it during the DKG transcript aggregation phase. This causes a panic in `get_dealt_public_key()` when `verify_transcript_extra()` is called before proper vector length validation occurs, resulting in validator node crashes.

## Finding Description

The Aptos DKG (Distributed Key Generation) system has a critical ordering issue in transcript verification. When peer transcripts are received during DKG aggregation, the code calls `verify_transcript_extra()` before `verify_transcript()`, which breaks the security invariant that all vector accesses must be bounds-checked before use.

**Attack Flow:**

1. A malicious validator crafts a `Transcripts` struct containing a `WeightedTranscript` with an empty `V_hat` vector
2. The attacker serializes this malicious transcript and submits it as a peer transcript during DKG
3. In the transcript aggregation logic, the transcript is deserialized successfully (BCS deserialization doesn't validate business logic constraints) [1](#0-0) 

4. The code immediately calls `verify_transcript_extra()` BEFORE `verify_transcript()` [2](#0-1) 

5. Inside `verify_transcript_extra()`, when checking fast path consistency, the code calls `get_dealt_public_key()` on both main and fast transcripts [3](#0-2) 

6. The `get_dealt_public_key()` implementation uses `.last().unwrap()` on the `V_hat` vector without any prior length check [4](#0-3) 

7. **PANIC**: The `.unwrap()` on an empty vector causes a thread panic, crashing the validator node

The proper length validation only occurs later in `verify_transcript()` → `verify()` → `check_sizes()`, which checks `V_hat.len() == W + 1` [5](#0-4) 

However, this validation never executes because the panic occurs first.

## Impact Explanation

This vulnerability meets **High Severity** criteria per the Aptos bug bounty program:

- **Validator node crashes**: A malicious validator can force other validators to panic and crash during the DKG phase
- **DKG disruption**: The attack prevents successful completion of distributed key generation, blocking randomness generation for the epoch
- **Denial of Service**: Repeated attacks during each DKG attempt can prevent the network from generating randomness indefinitely
- **No recovery mechanism**: The panic is not caught, so the validator process terminates abnormally

The impact is amplified because:
- DKG runs during critical epoch transitions
- All honest validators processing the malicious transcript will crash
- The attacker can repeatedly submit malicious transcripts
- No automatic recovery; manual intervention required to restart nodes

This does not reach Critical severity because it doesn't cause permanent network partition (validators can restart), loss of funds, or consensus safety violations. It fits squarely in the "Validator node slowdowns" and "API crashes" category (High: up to $50,000).

## Likelihood Explanation

**Likelihood: HIGH**

The attack is highly likely to succeed because:

1. **Low barrier to entry**: Any validator can submit peer transcripts during DKG [6](#0-5) 

2. **Simple exploit**: Crafting a malicious transcript only requires serializing a `WeightedTranscript` with empty vectors

3. **No cryptographic requirements**: The attack doesn't require breaking any cryptographic primitives or signatures

4. **Deterministic outcome**: The panic always occurs when the malicious transcript is processed

5. **No rate limiting**: The attacker can submit multiple malicious transcripts during DKG phase

6. **Affects all peers**: Every validator that receives and processes the malicious transcript will crash

## Recommendation

**Fix the verification order** by calling `verify_transcript()` BEFORE `verify_transcript_extra()`:

```rust
// In dkg/src/transcript_aggregation/mod.rs, lines 96-101
// CURRENT (VULNERABLE):
S::verify_transcript_extra(&transcript, &self.epoch_state.verifier, false, Some(sender))
    .context("extra verification failed")?;

S::verify_transcript(&self.dkg_pub_params, &transcript).map_err(|e| {
    anyhow!("[DKG] adding peer transcript failed with trx verification failure: {e}")
})?;

// FIXED:
S::verify_transcript(&self.dkg_pub_params, &transcript).map_err(|e| {
    anyhow!("[DKG] adding peer transcript failed with trx verification failure: {e}")
})?;

S::verify_transcript_extra(&transcript, &self.epoch_state.verifier, false, Some(sender))
    .context("extra verification failed")?;
```

**Additional defensive fix** - Add bounds checking in `get_dealt_public_key()`:

```rust
// In crates/aptos-dkg/src/pvss/das/weighted_protocol.rs
fn get_dealt_public_key(&self) -> Self::DealtPubKey {
    Self::DealtPubKey::new(
        *self.V_hat.last().expect("V_hat must not be empty")
    )
}
```

This provides defense-in-depth by making the error more explicit if the ordering issue recurs.

## Proof of Concept

```rust
// PoC demonstrating the panic
use aptos_dkg::pvss::das::weighted_protocol::Transcript;
use aptos_types::dkg::{DKGTrait, DefaultDKG};
use bcs;

#[test]
#[should_panic(expected = "called `Option::unwrap()` on a `None` value")]
fn test_empty_vhat_panic() {
    // 1. Create a malicious WeightedTranscript with empty V_hat
    let malicious_transcript = Transcript {
        soks: vec![],
        V: vec![],
        V_hat: vec![], // EMPTY - will cause panic
        R: vec![],
        R_hat: vec![],
        C: vec![],
    };
    
    // 2. Serialize it
    let transcript_bytes = bcs::to_bytes(&malicious_transcript).unwrap();
    
    // 3. Deserialize (succeeds)
    let deserialized: Transcript = bcs::from_bytes(&transcript_bytes).unwrap();
    
    // 4. Call get_dealt_public_key() WITHOUT calling verify() first
    // This mimics what happens in verify_transcript_extra()
    let _ = deserialized.get_dealt_public_key(); // PANIC HERE
}
```

**Notes:**
- The vulnerability exists specifically in the weighted DKG protocol implementation, which is the production DKG scheme used by Aptos
- The unweighted protocol has an identical issue at line 174 but is not used in production
- The same `.last().unwrap()` pattern also appears in `maul_signature()` at line 354, but that function is only used in testing/benchmarking contexts
- A comprehensive fix should reorder verification calls network-wide and add defensive bounds checking in all vector access methods

### Citations

**File:** dkg/src/transcript_aggregation/mod.rs (L79-83)
```rust
        let peer_power = self.epoch_state.verifier.get_voting_power(&sender);
        ensure!(
            peer_power.is_some(),
            "[DKG] adding peer transcript failed with illegal dealer"
        );
```

**File:** dkg/src/transcript_aggregation/mod.rs (L88-90)
```rust
        let transcript = bcs::from_bytes(transcript_bytes.as_slice()).map_err(|e| {
            anyhow!("[DKG] adding peer transcript failed with trx deserialization error: {e}")
        })?;
```

**File:** dkg/src/transcript_aggregation/mod.rs (L96-101)
```rust
        S::verify_transcript_extra(&transcript, &self.epoch_state.verifier, false, Some(sender))
            .context("extra verification failed")?;

        S::verify_transcript(&self.dkg_pub_params, &transcript).map_err(|e| {
            anyhow!("[DKG] adding peer transcript failed with trx verification failure: {e}")
        })?;
```

**File:** types/src/dkg/real_dkg/mod.rs (L324-327)
```rust
        if let Some(fast_trx) = &trx.fast {
            ensure!(fast_trx.get_dealers() == main_trx_dealers);
            ensure!(trx.main.get_dealt_public_key() == fast_trx.get_dealt_public_key());
        }
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L215-217)
```rust
    fn get_dealt_public_key(&self) -> Self::DealtPubKey {
        Self::DealtPubKey::new(*self.V_hat.last().unwrap())
    }
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L426-432)
```rust
        if self.V_hat.len() != W + 1 {
            bail!(
                "Expected {} G_2 (polynomial) commitment elements, but got {}",
                W + 1,
                self.V_hat.len()
            );
        }
```
