# Audit Report

## Title
Signature Verification Bypass in One-Off State Snapshot Restore Allows Complete State Fabrication

## Summary
The one-off state snapshot restore path completely bypasses signature verification on `LedgerInfoWithSignatures`, allowing an attacker to provide a fabricated backup with stripped or invalid signatures. This enables restoration of entirely fake blockchain state that was never agreed upon by any validator quorum, violating fundamental consensus safety guarantees.

## Finding Description

The `StateSnapshotBackup` struct contains a `proof` field that holds a BCS-serialized tuple of `(TransactionInfoWithProof, LedgerInfoWithSignatures)`. [1](#0-0) 

During restoration, the proof is loaded and the `TransactionInfoWithProof` is verified against the `LedgerInfo`. [2](#0-1) 

However, signature verification only occurs if `epoch_history` is present. [3](#0-2) 

In the one-off restore path used by the db-tool, `epoch_history` is explicitly passed as `None`. [4](#0-3) 

The documentation explicitly acknowledges this limitation: "LedgerInfos are NOT checked at all when doing one-shot restoring of the transaction and state backups." [5](#0-4) 

**Attack Flow:**
1. Attacker creates a completely fabricated backup containing:
   - A fake `LedgerInfo` with arbitrary version and state root
   - A matching `TransactionInfoWithProof` that verifies against the fake `LedgerInfo`
   - State snapshot chunks with matching root hash
   - A `LedgerInfoWithSignatures` with zero, invalid, or stripped signatures

2. All integrity checks pass because they only verify internal consistency:
   - `TransactionInfoWithProof.verify()` only checks accumulator proof consistency [6](#0-5) 
   - Root hash check only ensures state tree matches transaction info
   - No signature verification occurs

3. The victim's node restores the fake state and believes it has legitimate blockchain data

The only cryptographic proof that authenticates a `LedgerInfo` is signature verification by a quorum of validators. The `verify_multi_signatures` method enforces quorum via `check_voting_power` with a 2f+1 threshold. [7](#0-6)  However, this verification is completely bypassed in the one-off restore path.

## Impact Explanation

**Critical Severity** - This vulnerability breaks multiple critical invariants:

1. **Consensus Safety Violation**: The fundamental guarantee of AptosBFT is that all honest nodes agree on committed state. By accepting unverified state, nodes can have completely divergent views of the blockchain.

2. **State Consistency Violation**: Nodes should only accept state transitions that have been cryptographically proven valid by a quorum. This vulnerability allows acceptance of arbitrary state.

3. **Cryptographic Correctness Violation**: The entire security model relies on BLS signature verification to prove validator agreement. Bypassing this verification undermines the trust model.

**Impact Consequences:**
- Nodes restored from malicious backups would have fake balances, transactions, and contract state
- If such a node becomes a validator, it could cause consensus failures or vote based on incorrect state
- Attackers could create backups showing they own funds they never had
- Network partitions could occur if multiple nodes restore different fake states

This meets the Critical Severity criteria: "Consensus/Safety violations" and potentially "Non-recoverable network partition."

## Likelihood Explanation

**Medium Likelihood** - The attack requires:

1. **Social Engineering**: Convincing an operator to restore from attacker-provided backup
2. **Deployment Scenario**: Victim using one-off restore rather than coordinated restore
3. **No Technical Barriers**: Once conditions are met, attack succeeds with 100% probability

Common scenarios where this could occur:
- New node operators bootstrapping from "trusted" community backups
- Disaster recovery scenarios where operators seek fast restoration
- Development/testing environments using production-like data
- Air-gapped or isolated nodes that don't immediately sync with network

While coordinated restores with `epoch_history` are more common in production, one-off restores are documented and supported functionality, making this a realistic attack vector.

## Recommendation

**Primary Fix**: Enforce signature verification for state snapshot restores by requiring either `epoch_history` or trusted waypoints.

**Option 1** - Require epoch_history for state snapshot restore:
```rust
// In StateSnapshotRestoreController::new()
pub fn new(
    opt: StateSnapshotRestoreOpt,
    global_opt: GlobalRestoreOptions,
    storage: Arc<dyn BackupStorage>,
    epoch_history: Option<Arc<EpochHistory>>,
) -> Result<Self> {
    ensure!(
        epoch_history.is_some(),
        "State snapshot restore requires epoch_history for signature verification. \
         Use coordinated restore or provide trusted waypoints."
    );
    // ... rest of constructor
}
```

**Option 2** - Add explicit trusted waypoint verification for state snapshots: [8](#0-7) 

Modify to verify against trusted waypoints:
```rust
let manifest: StateSnapshotBackup = self.storage.load_json_file(&self.manifest_handle).await?;
let (txn_info_with_proof, li): (TransactionInfoWithProof, LedgerInfoWithSignatures) =
    self.storage.load_bcs_file(&manifest.proof).await?;

// NEW: Require either epoch_history or trusted waypoint
if let Some(epoch_history) = self.epoch_history.as_ref() {
    epoch_history.verify_ledger_info(&li)?;
} else if let Some(trusted_wp) = self.trusted_waypoints.get(&manifest.version) {
    let waypoint = Waypoint::new_any(li.ledger_info());
    ensure!(
        *trusted_wp == waypoint,
        "Ledger info doesn't match trusted waypoint"
    );
} else {
    return Err(anyhow!(
        "State snapshot restore requires either epoch_history or trusted waypoint \
         at version {} for signature verification",
        manifest.version
    ));
}
```

**Option 3** - Add prominent warning and require explicit flag:
Add a `--skip-signature-verification` flag that must be explicitly set, with clear warnings about security implications.

## Proof of Concept

```rust
// Proof of Concept demonstrating the vulnerability
// Place in storage/backup/backup-cli/src/backup_types/state_snapshot/tests.rs

#[test]
fn test_signature_stripping_vulnerability() {
    use crate::storage::local_fs::LocalFs;
    use aptos_crypto::HashValue;
    use aptos_types::{
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
        proof::TransactionInfoWithProof,
        transaction::{TransactionInfo, Version},
        aggregate_signature::AggregateSignature,
    };
    use std::sync::Arc;
    use tempfile::TempDir;
    
    let storage_dir = TempDir::new().unwrap();
    let backup_dir = TempDir::new().unwrap();
    let storage = Arc::new(LocalFs::new(backup_dir.path().to_path_buf()));
    
    // Create a FAKE LedgerInfo (not from real blockchain)
    let fake_ledger_info = LedgerInfo::new(
        BlockInfo::empty(),
        HashValue::random(), // Fake transaction accumulator
    );
    
    // Create LedgerInfoWithSignatures with ZERO signatures
    let fake_li_with_sigs = LedgerInfoWithSignatures::new(
        fake_ledger_info,
        AggregateSignature::empty(), // NO SIGNATURES!
    );
    
    // Create matching TransactionInfoWithProof (internally consistent with fake LI)
    let fake_txn_info = TransactionInfo::new(
        HashValue::random(),
        HashValue::random(), // State checkpoint hash
        HashValue::random(),
        None,
        0,
    );
    
    // Serialize the proof tuple
    let proof_data = bcs::to_bytes(&(fake_txn_info, fake_li_with_sigs)).unwrap();
    
    // Save to backup storage and create manifest
    // ... (create manifest with proof FileHandle)
    
    // Attempt restore with epoch_history = None
    let result = StateSnapshotRestoreController::new(
        StateSnapshotRestoreOpt {
            manifest_handle: /* manifest file handle */,
            version: 100,
            validate_modules: false,
            restore_mode: StateSnapshotRestoreMode::Default,
        },
        GlobalRestoreOpt {
            dry_run: false,
            db_dir: Some(storage_dir.path().to_path_buf()),
            target_version: None,
            trusted_waypoints: TrustedWaypointOpt::default(),
            rocksdb_opt: RocksdbOpt::default(),
            concurrent_downloads: ConcurrentDownloadsOpt::default(),
            replay_concurrency_level: ReplayConcurrencyLevelOpt::default(),
            enable_state_indices: false,
        }.try_into().unwrap(),
        storage,
        None, // epoch_history = None, signature verification BYPASSED!
    ).run().await;
    
    // Restore SUCCEEDS even though signatures were stripped
    assert!(result.is_ok(), "Restore succeeded with fabricated state!");
    
    // The database now contains completely fake state that was never
    // agreed upon by any validators
}
```

## Notes

This vulnerability is particularly dangerous because:

1. **Documented Behavior**: The lack of verification is documented, suggesting it may be perceived as acceptable. [9](#0-8) 

2. **No Runtime Warning**: The system provides no warning when performing unverified restoration.

3. **Trusted Waypoints Don't Help**: Even with trusted waypoints configured, state snapshot restores don't verify against them - waypoints only apply to epoch ending restores.

4. **Post-Restore Detection Uncertain**: While network sync might eventually detect inconsistencies, nodes could operate with fake state in air-gapped environments, during network partitions, or before initial sync.

The fundamental issue is that backup restoration should never trust file contents without cryptographic verification. The current design assumes backup storage is trusted, but this assumption doesn't hold against active attackers who can provide malicious backups through social engineering or supply chain attacks.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/manifest.rs (L41-50)
```rust
    /// `Tuple(TransactionInfoWithProof, LedgerInfoWithSignatures)`.
    ///   - The `TransactionInfoWithProof` is at `Version` above, and carries the same `root_hash`
    /// above; It proves that at specified version the root hash is as specified in a chain
    /// represented by the LedgerInfo below.
    ///   - The signatures on the `LedgerInfoWithSignatures` has a version greater than or equal to
    /// the version of this backup but is within the same epoch, so the signatures on it can be
    /// verified by the validator set in the same epoch, which can be provided by an
    /// `EpochStateBackup` recovered prior to this to the DB; Requiring it to be in the same epoch
    /// limits the requirement on such `EpochStateBackup` to no older than the same epoch.
    pub proof: FileHandle,
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L113-140)
```rust
    async fn run_impl(self) -> Result<()> {
        if self.version > self.target_version {
            warn!(
                "Trying to restore state snapshot to version {}, which is newer than the target version {}, skipping.",
                self.version,
                self.target_version,
            );
            return Ok(());
        }

        let manifest: StateSnapshotBackup =
            self.storage.load_json_file(&self.manifest_handle).await?;
        let (txn_info_with_proof, li): (TransactionInfoWithProof, LedgerInfoWithSignatures) =
            self.storage.load_bcs_file(&manifest.proof).await?;
        txn_info_with_proof.verify(li.ledger_info(), manifest.version)?;
        let state_root_hash = txn_info_with_proof
            .transaction_info()
            .ensure_state_checkpoint_hash()?;
        ensure!(
            state_root_hash == manifest.root_hash,
            "Root hash mismatch with that in proof. root hash: {}, expected: {}",
            manifest.root_hash,
            state_root_hash,
        );
        if let Some(epoch_history) = self.epoch_history.as_ref() {
            epoch_history.verify_ledger_info(&li)?;
        }

```

**File:** storage/db-tool/src/restore.rs (L88-95)
```rust
                        StateSnapshotRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                            None, /* epoch_history */
                        )
                        .run()
                        .await?;
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L332-346)
```rust
pub struct TrustedWaypointOpt {
    #[clap(
        long,
        help = "(multiple) When provided, an epoch ending LedgerInfo at the waypoint version will be \
        checked against the hash in the waypoint, but signatures on it are NOT checked. \
        Use this for two purposes: \
        1. set the genesis or the latest waypoint to confirm the backup is compatible. \
        2. set waypoints at versions where writeset transactions were used to overwrite the \
        validator set, so that the signature check is skipped. \
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
    )]
    pub trust_waypoint: Vec<Waypoint>,
}
```

**File:** types/src/proof/mod.rs (L40-61)
```rust
fn verify_transaction_info(
    ledger_info: &LedgerInfo,
    transaction_version: Version,
    transaction_info: &TransactionInfo,
    ledger_info_to_transaction_info_proof: &TransactionAccumulatorProof,
) -> Result<()> {
    ensure!(
        transaction_version <= ledger_info.version(),
        "Transaction version {} is newer than LedgerInfo version {}.",
        transaction_version,
        ledger_info.version(),
    );

    let transaction_info_hash = transaction_info.hash();
    ledger_info_to_transaction_info_proof.verify(
        ledger_info.transaction_accumulator_hash(),
        transaction_info_hash,
        transaction_version,
    )?;

    Ok(())
}
```

**File:** types/src/validator_verifier.rs (L345-386)
```rust
    pub fn verify_multi_signatures<T: CryptoHash + Serialize>(
        &self,
        message: &T,
        multi_signature: &AggregateSignature,
    ) -> std::result::Result<(), VerifyError> {
        // Verify the number of signature is not greater than expected.
        Self::check_num_of_voters(self.len() as u16, multi_signature.get_signers_bitvec())?;
        let mut pub_keys = vec![];
        let mut authors = vec![];
        for index in multi_signature.get_signers_bitvec().iter_ones() {
            let validator = self
                .validator_infos
                .get(index)
                .ok_or(VerifyError::UnknownAuthor)?;
            authors.push(validator.address);
            pub_keys.push(validator.public_key());
        }
        // Verify the quorum voting power of the authors
        self.check_voting_power(authors.iter(), true)?;
        #[cfg(any(test, feature = "fuzzing"))]
        {
            if self.quorum_voting_power == 0 {
                // This should happen only in case of tests.
                // TODO(skedia): Clean up the test behaviors to not rely on empty signature
                // verification
                return Ok(());
            }
        }
        // Verify empty multi signature
        let multi_sig = multi_signature
            .sig()
            .as_ref()
            .ok_or(VerifyError::EmptySignature)?;
        // Verify the optimistically aggregated signature.
        let aggregated_key =
            PublicKey::aggregate(pub_keys).map_err(|_| VerifyError::FailedToAggregatePubKey)?;

        multi_sig
            .verify(message, &aggregated_key)
            .map_err(|_| VerifyError::InvalidMultiSignature)?;
        Ok(())
    }
```
