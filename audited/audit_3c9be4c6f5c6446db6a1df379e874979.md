# Audit Report

## Title
Validator Cache Epoch Regression via Unvalidated REST API Responses in Telemetry Service

## Summary
The `update_for_chain()` function in the aptos-telemetry-service accepts REST API responses containing epoch, ledger version, and block height without validating their consistency or monotonicity. This allows stale or manipulated responses to overwrite current cache state with outdated validator set information, potentially causing authentication failures for legitimate validators.

## Finding Description

The telemetry service maintains a cache of validator sets indexed by chain ID and epoch. [1](#0-0) 

The REST API response includes state metadata extracted from HTTP headers containing chain_id, epoch, version, block_height, and other fields. [2](#0-1) 

The critical vulnerability occurs where the cache is unconditionally updated with the epoch from the response without any validation: [3](#0-2) 

**Missing Validations:**

1. **No Monotonicity Check**: The code does not verify that the new epoch is greater than or equal to the currently cached epoch, allowing cache regression.

2. **No Consistency Validation**: The code does not validate that epoch, version, and block_height are consistent with each other. In the Aptos blockchain, these values have a deterministic relationship - each version belongs to a specific epoch, and block_height increments with blocks within epochs. [4](#0-3) 

**Attack Scenario:**

1. Current cache state: Chain ID 25, Epoch 100, Validator Set V100
2. Attacker provides stale REST response (via MITM, DNS poisoning, or compromised endpoint): Epoch 50, Version 50000, Block Height 25000, Validator Set V50
3. Cache updates to: Epoch 50, Validator Set V50 (regression by 50 epochs)
4. Validators from epochs 51-100 attempt authentication
5. Authentication fails because the cache has outdated validator set [5](#0-4) 
6. JWT token validation also fails due to epoch mismatch [6](#0-5) 

The blockchain itself enforces epoch continuity during ledger commits [7](#0-6) , but the telemetry service's external cache has no such protection.

## Impact Explanation

**Severity Assessment: Medium**

This vulnerability causes state inconsistencies in the telemetry service requiring operational intervention to restore correct cache state. Per the Aptos bug bounty criteria, this falls under Medium severity: "State inconsistencies requiring intervention."

**Impact Scope:**
- Legitimate validators from current epoch cannot authenticate to telemetry service
- Telemetry data collection disrupted until cache refreshes from valid source
- No impact on consensus operations, blockchain state, or funds
- The telemetry service is an auxiliary monitoring component, not part of the critical consensus path

**Limitations:**
- Does not affect validator nodes' ability to participate in consensus
- Does not affect transaction processing or blockchain state
- Does not cause validator node slowdowns (which would be High severity)
- Validators continue operating normally; only telemetry submission is affected

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability can be triggered through several realistic scenarios:

1. **REST API Caching Issues**: If the queried full node has stale cached responses, the service receives outdated data
2. **Network MITM**: If TLS is not properly configured or certificate validation is bypassed, an attacker can intercept and modify responses
3. **DNS Poisoning**: Redirecting to a malicious endpoint serving fabricated responses
4. **Compromised REST Endpoint**: If the trusted full node is compromised, it can serve arbitrary data

The telemetry service queries REST endpoints periodically [8](#0-7) , so any transient issue can corrupt the cache.

## Recommendation

Implement two critical validations in `update_for_chain()`:

**1. Monotonicity Check:**
```rust
// Before line 176, add:
if let Some((current_epoch, _)) = validator_cache.get(&chain_id) {
    if state.epoch < *current_epoch {
        return Err(ValidatorCacheUpdateError::StaleEpochResponse {
            current: *current_epoch,
            received: state.epoch,
        });
    }
}
```

**2. Consistency Validation:**
Validate that the state fields are internally consistent. While the telemetry service cannot independently verify the exact epoch-version mapping without blockchain access, it can detect obviously inconsistent states:

```rust
// Add validation that version and block_height are reasonable for the epoch
// At minimum, verify they're not decreasing if epoch stays the same
if let Some((current_epoch, _)) = validator_cache.get(&chain_id) {
    if state.epoch == *current_epoch {
        // For same epoch, version should not decrease
        // (This catches responses mixing data from different states)
        debug!(
            "Warning: Epoch unchanged but received new validator set data. \
            Epoch: {}, Version: {}, Block Height: {}",
            state.epoch, state.version, state.block_height
        );
    }
}
```

**3. Add Staleness Detection:**
Track the version along with epoch in the cache and reject responses with lower versions for the same epoch.

## Proof of Concept

```rust
#[cfg(test)]
mod vulnerability_poc {
    use super::*;
    use aptos_crypto::{bls12381::{PrivateKey, PublicKey}, test_utils::KeyPair, Uniform};
    use aptos_types::{
        chain_id::ChainId, 
        network_address::NetworkAddress,
        on_chain_config::ValidatorSet,
        validator_config::ValidatorConfig, 
        validator_info::ValidatorInfo, 
        PeerId,
    };
    use httpmock::MockServer;
    use std::str::FromStr;

    #[tokio::test]
    async fn test_cache_regression_vulnerability() {
        let mut rng = rand_core::OsRng;
        let keypair = KeyPair::<PrivateKey, PublicKey>::generate(&mut rng);
        
        // Create validator for epoch 10
        let validator_epoch_10 = ValidatorInfo::new(
            PeerId::random(),
            10,
            ValidatorConfig::new(
                keypair.public_key,
                bcs::to_bytes(&vec![NetworkAddress::from_str("/ip4/10.0.0.1/tcp/6180").unwrap()]).unwrap(),
                bcs::to_bytes(&vec![NetworkAddress::from_str("/ip4/10.0.0.1/tcp/6182").unwrap()]).unwrap(),
                10,
            ),
        );
        let validator_set_epoch_10 = ValidatorSet::new(vec![validator_epoch_10.clone()]);

        // Create validator for epoch 5 (stale)
        let validator_epoch_5 = ValidatorInfo::new(
            PeerId::random(),
            5,
            ValidatorConfig::new(
                keypair.public_key,
                bcs::to_bytes(&vec![NetworkAddress::from_str("/ip4/10.0.0.2/tcp/6180").unwrap()]).unwrap(),
                bcs::to_bytes(&vec![NetworkAddress::from_str("/ip4/10.0.0.2/tcp/6182").unwrap()]).unwrap(),
                5,
            ),
        );
        let validator_set_epoch_5 = ValidatorSet::new(vec![validator_epoch_5]);

        let server = MockServer::start();
        
        // First response: epoch 10 (current)
        let mock_current = server.mock(|when, then| {
            when.method("GET").path("/v1/accounts/0000000000000000000000000000000000000000000000000000000000000001/resource/0x1::stake::ValidatorSet");
            then.status(200)
                .body(bcs::to_bytes(&validator_set_epoch_10).unwrap())
                .header("x-aptos-chain-id", "25")
                .header("x-aptos-epoch", "10")
                .header("x-aptos-ledger-version", "100000")
                .header("x-aptos-block-height", "50000")
                .header("x-aptos-ledger-oldest-version", "0")
                .header("x-aptos-oldest-block-height", "0")
                .header("x-aptos-ledger-timestamp", "1000000");
        });

        let mut fullnodes = std::collections::HashMap::new();
        fullnodes.insert("testnet".to_string(), server.base_url());

        let updater = PeerSetCacheUpdater::new(
            Arc::new(RwLock::new(std::collections::HashMap::new())),
            Arc::new(RwLock::new(std::collections::HashMap::new())),
            fullnodes.clone(),
            Duration::from_secs(10),
        );

        // Update with epoch 10
        updater.update().await;
        mock_current.assert();
        
        // Verify cache has epoch 10
        let cache = updater.validators.read();
        assert_eq!(cache.get(&ChainId::new(25)).unwrap().0, 10);
        assert!(cache.get(&ChainId::new(25)).unwrap().1.contains_key(validator_epoch_10.account_address()));
        drop(cache);

        // Second response: epoch 5 (stale/attack)
        server.mock(|when, then| {
            when.method("GET").path("/v1/accounts/0000000000000000000000000000000000000000000000000000000000000001/resource/0x1::stake::ValidatorSet");
            then.status(200)
                .body(bcs::to_bytes(&validator_set_epoch_5).unwrap())
                .header("x-aptos-chain-id", "25")
                .header("x-aptos-epoch", "5")  // STALE EPOCH
                .header("x-aptos-ledger-version", "50000")
                .header("x-aptos-block-height", "25000")
                .header("x-aptos-ledger-oldest-version", "0")
                .header("x-aptos-oldest-block-height", "0")
                .header("x-aptos-ledger-timestamp", "500000");
        });

        // Update with stale epoch 5
        updater.update().await;

        // VULNERABILITY: Cache regressed from epoch 10 to epoch 5
        let cache = updater.validators.read();
        assert_eq!(cache.get(&ChainId::new(25)).unwrap().0, 5, 
            "VULNERABILITY: Cache accepted stale epoch 5, overwriting epoch 10");
        assert!(!cache.get(&ChainId::new(25)).unwrap().1.contains_key(validator_epoch_10.account_address()),
            "Validator from epoch 10 is no longer in cache");
    }
}
```

**Notes:**
- This vulnerability exists in an auxiliary telemetry service, not the core consensus path
- While the bug is real (missing validation), its impact is limited to telemetry collection
- The blockchain's core consensus, fund security, and validator operations remain unaffected
- Classification as Medium severity reflects state inconsistency requiring operational intervention, but without critical system impact

### Citations

**File:** crates/aptos-telemetry-service/src/validator_cache.rs (L51-58)
```rust
    pub fn run(self) {
        let mut interval = time::interval(self.update_interval);
        tokio::spawn(async move {
            loop {
                self.update().await;
                interval.tick().await;
            }
        });
```

**File:** crates/aptos-telemetry-service/src/validator_cache.rs (L86-99)
```rust
    async fn update_for_chain(
        &self,
        chain_name: &ChainCommonName,
        url: &str,
    ) -> Result<(), ValidatorCacheUpdateError> {
        let client = aptos_rest_client::Client::new(Url::parse(url).map_err(|e| {
            error!("invalid url for chain_id {}: {}", chain_name, e);
            ValidatorCacheUpdateError::InvalidUrl
        })?);
        let response: Response<ValidatorSet> = client
            .get_account_resource_bcs(CORE_CODE_ADDRESS, "0x1::stake::ValidatorSet")
            .await
            .map_err(ValidatorCacheUpdateError::RestError)?;

```

**File:** crates/aptos-telemetry-service/src/validator_cache.rs (L176-176)
```rust
            validator_cache.insert(chain_id, (state.epoch, validator_peers));
```

**File:** crates/aptos-rest-client/src/state.rs (L10-20)
```rust
#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd)]
pub struct State {
    pub chain_id: u8,
    pub epoch: u64,
    pub version: u64,
    pub timestamp_usecs: u64,
    pub oldest_ledger_version: u64,
    pub oldest_block_height: u64,
    pub block_height: u64,
    pub cursor: Option<String>,
}
```

**File:** api/types/src/ledger_info.rs (L9-20)
```rust
/// The Ledger information representing the current state of the chain
#[derive(Clone, Debug, Deserialize, Serialize, PartialEq, Eq, PoemObject)]
pub struct LedgerInfo {
    /// Chain ID of the current chain
    pub chain_id: u8,
    pub epoch: U64,
    pub ledger_version: U64,
    pub oldest_ledger_version: U64,
    pub block_height: U64,
    pub oldest_block_height: U64,
    pub ledger_timestamp: U64,
}
```

**File:** crates/aptos-telemetry-service/src/auth.rs (L72-114)
```rust
    let (epoch, peer_role) = match cache.read().get(&body.chain_id) {
        Some((epoch, peer_set)) => {
            match peer_set.get(&body.peer_id) {
                Some(peer) => {
                    let remote_public_key = &remote_public_key;
                    if !peer.keys.contains(remote_public_key) {
                        warn!("peer found in peer set but public_key is not found. request body: {}, role_type: {}, peer_id: {}, received public_key: {}", body.chain_id, body.role_type, body.peer_id, remote_public_key);
                        return Err(reject::custom(ServiceError::forbidden(
                            ServiceErrorCode::AuthError(
                                AuthError::PeerPublicKeyNotFound,
                                body.chain_id,
                            ),
                        )));
                    }
                    Ok((*epoch, peer.role))
                },
                None => {
                    // if not, verify that their peerid is constructed correctly from their public key
                    let derived_remote_peer_id =
                        aptos_types::account_address::from_identity_public_key(remote_public_key);
                    if derived_remote_peer_id != body.peer_id {
                        return Err(reject::custom(ServiceError::forbidden(
                            ServiceErrorCode::AuthError(
                                AuthError::PublicKeyMismatch,
                                body.chain_id,
                            ),
                        )));
                    } else {
                        Ok((*epoch, PeerRole::Unknown))
                    }
                },
            }
        },
        None => {
            warn!(
                "Validator set unavailable for Chain ID {}. Rejecting request.",
                body.chain_id
            );
            Err(reject::custom(ServiceError::unauthorized(
                ServiceErrorCode::AuthError(AuthError::ValidatorSetUnavailable, body.chain_id),
            )))
        },
    }?;
```

**File:** crates/aptos-telemetry-service/src/jwt_auth.rs (L57-78)
```rust
    let current_epoch = match context.peers().validators().read().get(&claims.chain_id) {
        Some(info) => info.0,
        None => {
            return Err(reject::custom(ServiceError::unauthorized(
                JwtAuthError::ExpiredAuthToken.into(),
            )));
        },
    };

    if !allow_roles.contains(&claims.node_type) {
        return Err(reject::custom(ServiceError::forbidden(
            JwtAuthError::AccessDenied.into(),
        )));
    }

    if claims.epoch == current_epoch && claims.exp > Utc::now().timestamp() as usize {
        Ok(claims)
    } else {
        Err(reject::custom(ServiceError::unauthorized(
            JwtAuthError::ExpiredAuthToken.into(),
        )))
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L571-580)
```rust
        // Verify epoch continuity.
        let current_epoch = self
            .ledger_db
            .metadata_db()
            .get_latest_ledger_info_option()
            .map_or(0, |li| li.ledger_info().next_block_epoch());
        ensure!(
            ledger_info_with_sig.ledger_info().epoch() == current_epoch,
            "Gap in epoch history. Trying to put in LedgerInfo in epoch: {}, current epoch: {}",
            ledger_info_with_sig.ledger_info().epoch(),
```
