# Audit Report

## Title
Critical Consensus Safety Violation: Version Field Not Validated in SafetyRules Allowing Transaction Count Mismatch

## Summary
The `match_ordered_only()` method used by SafetyRules to validate execution consistency fails to check the `version` field in BlockInfo, allowing validators to sign commit votes with mismatched transaction counts. This enables consensus safety violations where different validators commit different numbers of transactions for the same block, potentially causing chain splits, transaction censorship, or double-spending.

## Finding Description

The Aptos consensus pipeline validates that executed BlockInfo matches ordered BlockInfo before validators sign commit votes. However, the validation function `match_ordered_only()` has a critical gap: [1](#0-0) 

This function only validates `epoch`, `round`, `id`, and `timestamp_usecs` - but **completely omits validation of the `version` field**, which represents the last transaction version in the block and determines how many transactions are committed.

The flawed validation is used in the critical SafetyRules path: [2](#0-1) 

When validators execute a block, the version is calculated based on the number of transactions committed: [3](#0-2) [4](#0-3) 

**Attack Scenario:**

1. Block B at round R, epoch E with ID=X is ordered, containing ordered BlockInfo with version=0 (dummy value used during ordering)
2. Validators execute block B with 100 transactions, first_version=1000
3. Due to an execution bug, non-determinism, or malicious manipulation:
   - Validator V1 commits all 100 transactions → version=1099
   - Validator V2 commits only 95 transactions → version=1094
4. Both validators call `SafetyRules::sign_commit_vote()` with their respective BlockInfos
5. The `match_ordered_only()` check passes for BOTH because it only validates epoch, round, id, timestamp - **not version**
6. Both validators successfully sign commit votes with different versions (1099 vs 1094)
7. If enough validators sign version 1094, block B commits with only 95 transactions
8. Transactions 95-99 are censored, potentially causing:
   - Double-spending if those transactions are later reintroduced
   - Loss of funds if they contained critical state transitions
   - Consensus split if different nodes commit different versions

The version field determines which transactions are included in the committed ledger state. By not validating it, SafetyRules allows validators to sign inconsistent execution results that commit different transaction sets for the same consensus block.

## Impact Explanation

**Critical Severity** - This vulnerability breaks fundamental consensus safety guarantees:

1. **Consensus Safety Violation**: Different validators can commit different transaction sets for the same block (same epoch/round/id), violating the core AptosBFT safety property that all honest validators agree on committed state.

2. **Transaction Censorship**: Malicious or buggy validators can cause fewer transactions to be committed than were actually executed, censoring valid user transactions.

3. **Potential Double-Spending**: If censored transactions are later reintroduced with different nonces/sequence numbers, funds could be double-spent.

4. **Chain Split Risk**: If validator sets diverge on which version was committed, the network could experience non-recoverable partitions requiring a hard fork.

This meets the **Critical Severity** category per the Aptos bug bounty: "Consensus/Safety violations" worth up to $1,000,000.

While storage-level validation exists in `check_and_put_ledger_info()`: [5](#0-4) 

By the time this check runs, validators have already signed potentially inconsistent state, and the consensus damage is done. SafetyRules is supposed to be the first line of defense preventing validators from signing invalid execution results.

## Likelihood Explanation

**High Likelihood** for the following reasons:

1. **Multiple Trigger Conditions**:
   - Any bug causing non-deterministic execution across validators
   - Race conditions in transaction counting
   - Malicious validator deliberately manipulating execution results
   - Edge cases in block execution (reconfigurations, empty blocks, etc.)

2. **No Defense in Depth**: The missing version validation means there's no safety check at the consensus signing layer, so any execution inconsistency propagates to signed commits.

3. **Deterministic Execution Not Guaranteed**: While Move execution aims to be deterministic, the complexity of the system (parallel execution, gas metering, native functions, I/O operations) creates multiple potential sources of non-determinism.

4. **Real-World Precedent**: Many blockchain systems have experienced consensus bugs related to non-deterministic execution or state calculation errors.

The vulnerability requires execution to produce different versions, but the missing validation means ANY such bug immediately becomes a consensus safety violation rather than being caught early.

## Recommendation

Add version field validation to the `match_ordered_only()` method:

```rust
pub fn match_ordered_only(&self, executed_block_info: &BlockInfo) -> bool {
    self.epoch == executed_block_info.epoch
        && self.round == executed_block_info.round
        && self.id == executed_block_info.id
        // ADD VERSION VALIDATION:
        && (self.version == 0 || self.version == executed_block_info.version)
        && (self.timestamp_usecs == executed_block_info.timestamp_usecs
            || (self.timestamp_usecs > executed_block_info.timestamp_usecs
                && executed_block_info.has_reconfiguration()))
}
```

The check `self.version == 0 || self.version == executed_block_info.version` allows:
- Ordered blocks to have version=0 (dummy value)
- Executed blocks must match if the ordered block has a non-zero version
- This preserves the current ordering semantics while adding the critical validation

Alternatively, if ordered blocks should always have version=0, make the check more explicit:

```rust
pub fn match_ordered_only(&self, executed_block_info: &BlockInfo) -> bool {
    // Ordered blocks should have version=0, executed blocks have actual version
    let version_valid = if self.is_ordered_only() {
        self.version == 0
    } else {
        self.version == executed_block_info.version
    };
    
    self.epoch == executed_block_info.epoch
        && self.round == executed_block_info.round
        && self.id == executed_block_info.id
        && version_valid
        && (self.timestamp_usecs == executed_block_info.timestamp_usecs
            || (self.timestamp_usecs > executed_block_info.timestamp_usecs
                && executed_block_info.has_reconfiguration()))
}
```

## Proof of Concept

```rust
#[test]
fn test_version_mismatch_not_caught() {
    use aptos_types::block_info::BlockInfo;
    use aptos_crypto::hash::HashValue;
    
    // Ordered block with dummy version=0
    let ordered_block_info = BlockInfo::new(
        1,  // epoch
        10, // round
        HashValue::random(),  // id
        *aptos_crypto::hash::ACCUMULATOR_PLACEHOLDER_HASH,  // dummy state
        0,  // version = 0 (ordered only)
        1234567890,  // timestamp
        None,  // no epoch change
    );
    
    let block_id = ordered_block_info.id();
    
    // Executed block with version=100 (should be 100 transactions committed)
    let executed_block_info_v100 = BlockInfo::new(
        1,  // same epoch
        10, // same round
        block_id,  // same id
        HashValue::random(),  // actual execution state
        100,  // version = 100
        1234567890,  // same timestamp
        None,
    );
    
    // Executed block with DIFFERENT version=50 (only 50 transactions committed)
    let executed_block_info_v50 = BlockInfo::new(
        1,  // same epoch
        10, // same round
        block_id,  // same id
        HashValue::random(),  // different execution state
        50,  // version = 50 (WRONG - should be 100)
        1234567890,  // same timestamp
        None,
    );
    
    // VULNERABILITY: Both pass validation even though versions differ!
    assert!(ordered_block_info.match_ordered_only(&executed_block_info_v100));
    assert!(ordered_block_info.match_ordered_only(&executed_block_info_v50));
    
    // This means SafetyRules would sign BOTH version 100 and version 50
    // for the same block (epoch=1, round=10, id=X)
    // Different validators could commit different transaction counts!
    println!("CRITICAL: Version mismatch not detected!");
    println!("Validator 1 would sign version 100");
    println!("Validator 2 would sign version 50");
    println!("Both for the same block - consensus safety violation!");
}
```

This test demonstrates that `match_ordered_only()` returns `true` for BlockInfos with the same epoch/round/id but **different versions**, allowing SafetyRules to sign inconsistent execution results and enabling consensus safety violations.

### Citations

**File:** types/src/block_info.rs (L196-204)
```rust
    pub fn match_ordered_only(&self, executed_block_info: &BlockInfo) -> bool {
        self.epoch == executed_block_info.epoch
            && self.round == executed_block_info.round
            && self.id == executed_block_info.id
            && (self.timestamp_usecs == executed_block_info.timestamp_usecs
            // executed block info has changed its timestamp because it's a reconfiguration suffix
                || (self.timestamp_usecs > executed_block_info.timestamp_usecs
                    && executed_block_info.has_reconfiguration()))
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L395-403)
```rust
        if !old_ledger_info
            .commit_info()
            .match_ordered_only(new_ledger_info.commit_info())
        {
            return Err(Error::InconsistentExecutionResult(
                old_ledger_info.commit_info().to_string(),
                new_ledger_info.commit_info().to_string(),
            ));
        }
```

**File:** execution/executor-types/src/execution_output.rs (L140-142)
```rust
    pub fn next_version(&self) -> Version {
        self.first_version + self.num_transactions_to_commit() as Version
    }
```

**File:** execution/executor-types/src/state_compute_result.rs (L134-136)
```rust
    pub fn last_version_or_0(&self) -> Version {
        self.next_version().saturating_sub(1)
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L548-554)
```rust
        // Verify the version.
        ensure!(
            ledger_info.version() == version,
            "Version in LedgerInfo doesn't match last version. {:?} vs {:?}",
            ledger_info.version(),
            version,
        );
```
