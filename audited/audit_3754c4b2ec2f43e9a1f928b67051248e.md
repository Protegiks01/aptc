# Audit Report

## Title
Missing Length Validation Before MSM Operation in Zeromorph Verification Leads to Potential DoS

## Summary
The `verify()` function in Zeromorph's polynomial commitment scheme fails to validate that the number of quotient commitments (`proof.q_k_com.len()`) matches the evaluation point length (`point.len()`) before performing a multi-scalar multiplication (MSM). This allows a malicious prover to trigger a panic or error during verification by submitting proofs with mismatched commitment counts.

## Finding Description

The vulnerability exists in the `verify()` function where bases and scalars for the MSM operation are constructed with potentially mismatched lengths. [1](#0-0) 

The scalars are constructed as: [2](#0-1) 

This creates a scalar vector of length `3 + point.len()` (3 fixed scalars plus one for each element in `point`).

The bases are constructed as: [3](#0-2) 

This creates a base vector of length `3 + proof.q_k_com.len()` (3 fixed bases plus one for each q_k commitment).

The MSM is then called without any prior validation: [4](#0-3) 

**Attack Vector:** A malicious prover can craft a proof where `proof.q_k_com.len() â‰  point.len()`, causing the bases and scalars vectors to have different lengths. When the MSM is called, it will either:
1. Return an error that triggers the `.expect()` panic
2. Behave unexpectedly based on arkworks implementation details

The Aptos codebase confirms that MSM operations require explicit length validation, as seen in the Move native functions: [5](#0-4) 

Additionally, the aptos-dkg README documents known issues with multiexp length mismatches: [6](#0-5) 

## Impact Explanation

**Severity: Medium**

This vulnerability enables a Denial-of-Service attack against verifier nodes:

1. **Availability Impact**: A malicious prover can cause verifier nodes to crash or panic when attempting to verify invalid proofs
2. **No Funds at Risk**: The vulnerability doesn't directly affect funds or state
3. **Graceful Degradation Failure**: Rather than returning a proper error, the system panics, which is poor error handling

The impact is mitigated by the fact that the code is explicitly marked as experimental: [7](#0-6) 

And is currently only used in benchmarks: [8](#0-7) 

However, if this code were to be promoted to production use without addressing this issue, it would represent a medium-severity vulnerability per the Aptos bug bounty criteria (state inconsistencies requiring intervention / node crashes).

## Likelihood Explanation

**Likelihood: High (if deployed to production)**

- **Attack Complexity**: Low - attacker simply needs to construct a proof with arbitrary number of q_k_com commitments
- **Attacker Requirements**: No special privileges required; any party submitting proofs can trigger this
- **Detection**: The vulnerability will manifest immediately upon verification attempt with malformed proof
- **Current Risk**: Low - code is not yet in production and is marked for benchmarking only

The honest prover implementation shows the expected behavior: [9](#0-8) 

Where `q_k_com.len()` equals `quotients.len()` equals `poly.num_vars` equals `point.len()` by construction. However, the verifier doesn't enforce this invariant.

## Recommendation

Add explicit length validation before the MSM operation:

```rust
// Add this validation before line 423
if proof.q_k_com.len() != point.len() {
    return Err(anyhow::anyhow!(
        "Invalid proof structure: q_k_com length ({}) does not match point length ({})",
        proof.q_k_com.len(),
        point.len()
    ));
}
```

This follows the pattern used elsewhere in the codebase: [10](#0-9) 

## Proof of Concept

```rust
#[cfg(test)]
mod test_length_mismatch {
    use super::*;
    use ark_bls12_381::Bls12_381 as E;
    use ark_std::UniformRand;
    use rand::thread_rng;

    #[test]
    #[should_panic(expected = "MSM failed")]
    fn test_verify_with_mismatched_proof_length() {
        let mut rng = thread_rng();
        let num_vars = 4;
        let degree_bounds = vec![1; num_vars];
        
        // Setup
        let (pk, vk) = Zeromorph::<E>::setup(degree_bounds, &mut rng);
        
        // Create honest polynomial and point
        let poly = DenseMultilinearExtension::rand(num_vars, &mut rng);
        let point: Vec<_> = (0..num_vars)
            .map(|_| <E as Pairing>::ScalarField::rand(&mut rng))
            .collect();
        let eval = poly.evaluate(&point);
        
        // Create honest commitment
        let r = <E as Pairing>::ScalarField::rand(&mut rng);
        let comm = Zeromorph::commit(&pk, &poly, r);
        
        // Create a MALICIOUS proof with wrong number of q_k_com commitments
        let mut proof = Zeromorph::open(
            &pk,
            &poly,
            &point,
            eval,
            Scalar(r),
            &mut rng,
            &mut merlin::Transcript::new(b"test"),
        );
        
        // Maliciously add extra q_k_com commitments
        proof.q_k_com.push(proof.q_k_com[0].clone());
        
        // This will panic due to length mismatch in MSM
        let mut transcript = merlin::Transcript::new(b"test");
        Zeromorph::verify(&vk, &comm, &point, &eval, &proof, &mut transcript).unwrap();
    }
}
```

This test demonstrates that a proof with `proof.q_k_com.len() = point.len() + 1` will cause the verification to panic at the MSM operation.

## Notes

- This code is currently marked as **"NOT YET BEEN VETTED, ONLY USE FOR BENCHMARKING PURPOSES"** and is not deployed in production consensus or DKG operations
- The vulnerability should be addressed before any production deployment
- The fix is straightforward and aligns with validation patterns used throughout the Aptos codebase
- The MSM input validation pattern in `crates/aptos-crypto/src/arkworks/msm.rs` should be the standard approach for all MSM operations

### Citations

**File:** crates/aptos-dkg/src/pcs/zeromorph.rs (L6-6)
```rust
// THIS CODE HAS NOT YET BEEN VETTED, ONLY USE FOR BENCHMARKING PURPOSES!!!!!
```

**File:** crates/aptos-dkg/src/pcs/zeromorph.rs (L286-304)
```rust
        let (quotients, _): (Vec<UniPoly<P::ScalarField>>, P::ScalarField) =
            compute_multilinear_quotients::<P>(poly, point);
        assert_eq!(quotients.len(), poly.num_vars);
        // assert_eq!(remainder, *eval); TODO: put back in?

        // Step 1: commit to all of the q_k
        let rs: Vec<Scalar<P::ScalarField>> =
            sample_field_elements::<P::ScalarField, _>(quotients.len(), rng)
                .into_iter()
                .map(Scalar)
                .collect();
        //let r = Scalar(sample_field_element::<P::ScalarField>(rng));
        let q_k_com: Vec<univariate_hiding_kzg::Commitment<P>> = quotients
            .iter()
            .zip(rs.iter())
            .map(|(quotient, r)| {
                univariate_hiding_kzg::commit_with_randomness(&pp.commit_pp, &quotient.coeffs, r)
            })
            .collect();
```

**File:** crates/aptos-dkg/src/pcs/zeromorph.rs (L371-446)
```rust
    pub fn verify(
        vk: &ZeromorphVerifierKey<P>,
        comm: &ZeromorphCommitment<P>,
        point: &[P::ScalarField],
        eval: &P::ScalarField,
        proof: &ZeromorphProof<P>,
        transcript: &mut merlin::Transcript,
    ) -> anyhow::Result<()> {
        transcript.append_sep(Self::protocol_name());

        //let q_comms: Vec<P::G1> = proof.q_k_com.iter().map(|c| c.into_group()).collect();
        proof
            .q_k_com
            .iter()
            .for_each(|c| transcript.append_point(&c.0));

        // Challenge y
        let y_challenge: P::ScalarField = transcript.challenge_scalar();

        // Receive commitment C_q_hat
        transcript.append_point(&proof.q_hat_com.0);

        // Get x and z challenges
        let x_challenge = transcript.challenge_scalar();
        let z_challenge = transcript.challenge_scalar();

        // Compute batched degree and ZM-identity quotient polynomial pi
        let (eval_scalar, (mut q_scalars, zmpoly_q_scalars)): (
            P::ScalarField,
            (Vec<P::ScalarField>, Vec<P::ScalarField>),
        ) = eval_and_quotient_scalars::<P>(y_challenge, x_challenge, z_challenge, point);
        q_scalars
            .iter_mut()
            .zip(zmpoly_q_scalars)
            .for_each(|(scalar, zm_poly_q_scalar)| {
                *scalar += zm_poly_q_scalar;
            });
        let scalars = [
            vec![P::ScalarField::one(), z_challenge, eval_scalar * *eval],
            q_scalars,
        ]
        .concat();

        let mut bases_proj = Vec::with_capacity(3 + proof.q_k_com.len());

        bases_proj.push(proof.q_hat_com.0);
        bases_proj.push(comm.0);
        bases_proj.push(vk.kzg_vk.group_generators.g1.into_group()); // Not so ideal to include this in `normalize_batch` but the effect should be negligible
        bases_proj.extend(proof.q_k_com.iter().map(|w| w.0));

        let bases = P::G1::normalize_batch(&bases_proj);

        let zeta_z_com = <P::G1 as VariableBaseMSM>::msm(&bases, &scalars)
            .expect("MSM failed in ZeroMorph")
            .into_affine();

        // e(pi, [tau]_2 - x * [1]_2) == e(C_{\zeta,Z}, -[X^(N_max - 2^n - 1)]_2) <==> e(C_{\zeta,Z} - x * pi, [X^{N_max - 2^n - 1}]_2) * e(-pi, [tau_2]) == 1
        let pairing = P::multi_pairing(
            [
                zeta_z_com,
                proof.pi.pi_1.0.into_affine(),
                proof.pi.pi_2.into_affine(),
            ],
            [
                (-vk.tau_N_max_sub_2_N.into_group()).into_affine(),
                (vk.kzg_vk.tau_2.into_group() - (vk.kzg_vk.group_generators.g2 * x_challenge))
                    .into(),
                vk.kzg_vk.xi_2,
            ],
        );
        if !pairing.is_zero() {
            return Err(anyhow::anyhow!("Expected zero during multi-pairing check"));
        }

        Ok(())
    }
```

**File:** aptos-move/framework/src/natives/cryptography/algebra/arithmetics/scalar_mul.rs (L199-205)
```rust
        let num_elements = element_handles.len();
        let num_scalars = scalar_handles.len();
        if num_elements != num_scalars {
            return Err(SafeNativeError::Abort {
                abort_code: MOVE_ABORT_CODE_INPUT_VECTOR_SIZES_NOT_MATCHING,
            });
        }
```

**File:** crates/aptos-dkg/README.md (L41-45)
```markdown
### Multiexps with more exponents than bases fail. 

See `test_crypto_g1_multiexp_less_points`.

Instead, they should truncate the exponents to be the size of the bases.
```

**File:** crates/aptos-dkg/benches/pcs.rs (L112-118)
```rust
/// Benchmark entry point for the Zeromorph commitment scheme instantiated
/// over the BLS12-381 pairing-friendly curve.
fn bench_zeromorph(c: &mut Criterion) {
    type E = ark_bls12_381::Bls12_381;

    benchmark_commitment_scheme::<Zeromorph<E>>(c);
}
```

**File:** crates/aptos-crypto/src/arkworks/msm.rs (L77-86)
```rust
    fn new(bases: Vec<Self::Base>, scalars: Vec<Self::Scalar>) -> anyhow::Result<Self> {
        if bases.len() != scalars.len() {
            anyhow::bail!(
                "MsmInput length mismatch: {} bases, {} scalars",
                bases.len(),
                scalars.len(),
            );
        }
        Ok(Self { bases, scalars })
    }
```
