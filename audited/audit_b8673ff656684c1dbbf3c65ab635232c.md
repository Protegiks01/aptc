# Audit Report

## Title
Lack of Freshness Validation in Peer Network Topology Data Enables Malicious Peer Selection Manipulation

## Summary
The peer monitoring service's `GetNetworkInformation` request-response protocol lacks temporal freshness guarantees, allowing malicious peers to replay cached `NetworkInformationResponse` data. This enables manipulation of peer selection decisions across consensus observer, state sync, and mempool subsystems, potentially causing validator node slowdowns and network inefficiency.

## Finding Description

The `create_monitoring_service_request()` function in `NetworkInfoState` returns a stateless `GetNetworkInformation` request without any challenge, nonce, or timestamp: [1](#0-0) 

The corresponding `NetworkInformationResponse` structure contains no timestamp or freshness indicator: [2](#0-1) 

When responses are received, the only validation performed is checking the response type and performing sanity checks on the `distance_from_validators` value based on peer role: [3](#0-2) 

Notably, there are **no checks for**:
1. Response timestamp or age
2. Monotonic increase in data freshness
3. Challenge-response validation
4. Cryptographic binding to request time

While the RPC framework provides request_id matching to correlate requests and responses within the same connection: [4](#0-3) 

This only prevents out-of-order responses or responses for expired RPC calls—it does **not** prevent a malicious peer from responding with old but valid application-layer data for a current request.

**Attack Scenario:**

1. A malicious peer at `distance_from_validators=10` (poorly connected) caches a `NetworkInformationResponse` from when it was at `distance=1` (well-connected)
2. When queried via `GetNetworkInformation`, the peer returns the cached stale response with the current RPC `request_id`
3. The victim node accepts the response because the `request_id` matches and the distance value passes sanity checks
4. The victim incorrectly believes the malicious peer is close to validators

**Impact on Critical Subsystems:**

The stale `distance_from_validators` value directly affects peer selection in three critical subsystems:

**1. Consensus Observer**: Sorts peers by distance to prioritize subscription targets: [5](#0-4) 

**2. State Sync**: Uses distance for weighted peer selection: [6](#0-5) 

**3. Mempool**: Prioritizes peers with lower validator distance for transaction forwarding: [7](#0-6) 

Network information is queried periodically at 60-second intervals: [8](#0-7) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty criteria due to "Validator node slowdowns" and "Significant protocol violations."

A malicious peer falsely claiming low distance from validators would be prioritized for:
- **Consensus observer subscriptions**: Victims receive consensus data from a suboptimal source, potentially causing slower block propagation and synchronization delays
- **State sync operations**: Victims fetch state from poorly-connected peers, degrading sync performance
- **Mempool transaction forwarding**: Transactions are sent to less-connected peers, delaying propagation

If multiple validators are affected simultaneously, this could cause network-wide performance degradation. The 60-second refresh interval means stale data persists for up to one minute per query, allowing sustained impact.

**Importantly**, this does NOT violate consensus safety—blocks and proofs are still cryptographically validated regardless of source. The impact is confined to performance and resource efficiency, not correctness.

## Likelihood Explanation

**Likelihood: High**

- **Attacker requirements**: Only requires being a connected peer on the network (no validator privileges needed)
- **Exploitation complexity**: Trivial—simply cache and replay old responses
- **Detection difficulty**: Victims cannot distinguish stale data from fresh data without additional mechanisms
- **Affected population**: All nodes that query the malicious peer (every 60 seconds)

The attack is highly practical and requires minimal sophistication.

## Recommendation

Implement freshness validation through one or more mechanisms:

**Option 1: Add timestamp to NetworkInformationResponse**
```rust
pub struct NetworkInformationResponse {
    pub connected_peers: BTreeMap<PeerNetworkId, ConnectionMetadata>,
    pub distance_from_validators: u64,
    pub timestamp_usecs: u64,  // Add timestamp field
}
```

Validate response age on the client side:
```rust
const MAX_NETWORK_INFO_AGE_SECS: u64 = 120; // 2 minutes

// In handle_monitoring_service_response:
let response_age_usecs = current_time_usecs - network_info_response.timestamp_usecs;
if response_age_usecs > MAX_NETWORK_INFO_AGE_SECS * 1_000_000 {
    warn!("Received stale network info response");
    self.handle_request_failure();
    return;
}
```

**Option 2: Add challenge-response mechanism**
```rust
pub enum PeerMonitoringServiceRequest {
    GetNetworkInformation { challenge: u64 },  // Add challenge
    // ...
}

pub struct NetworkInformationResponse {
    pub connected_peers: BTreeMap<PeerNetworkId, ConnectionMetadata>,
    pub distance_from_validators: u64,
    pub challenge: u64,  // Echo challenge
}
```

**Option 3 (Recommended): Combine both approaches** for defense-in-depth, adding both timestamps and optional challenges for high-value queries.

## Proof of Concept

```rust
// Malicious peer server implementation
impl PeerMonitoringServiceServer<T> {
    fn get_network_information_malicious(&self) -> Result<PeerMonitoringServiceResponse, Error> {
        // Instead of calling the real implementation, return cached stale data
        static CACHED_RESPONSE: Lazy<NetworkInformationResponse> = Lazy::new(|| {
            NetworkInformationResponse {
                connected_peers: BTreeMap::new(),
                distance_from_validators: 1,  // Falsely claim distance=1
            }
        });
        
        // Return stale cached response for current request
        Ok(PeerMonitoringServiceResponse::NetworkInformation(
            CACHED_RESPONSE.clone()
        ))
    }
}

// Victim node will:
// 1. Send GetNetworkInformation request with request_id=X
// 2. Receive response with request_id=X (matches, accepted by RPC layer)
// 3. Response contains distance=1 (passes sanity checks)
// 4. Store stale distance=1 value
// 5. Prioritize malicious peer for consensus/state-sync/mempool operations
```

**Notes**

This vulnerability is classified as High Severity specifically due to the "Validator node slowdowns" criterion in the Aptos bug bounty program. While it does not compromise consensus safety, state integrity, or cause fund loss (all safety-critical properties remain intact due to cryptographic validation), it does enable targeted performance degradation attacks against validators and other nodes.

The lack of freshness validation is a protocol-level design weakness rather than an implementation bug. The encrypted/authenticated Noise transport prevents traditional man-in-the-middle replay attacks, but cannot prevent a malicious peer from replaying its own old data at the application layer.

### Citations

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L78-80)
```rust
    fn create_monitoring_service_request(&mut self) -> PeerMonitoringServiceRequest {
        PeerMonitoringServiceRequest::GetNetworkInformation
    }
```

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L91-158)
```rust
    fn handle_monitoring_service_response(
        &mut self,
        peer_network_id: &PeerNetworkId,
        peer_metadata: PeerMetadata,
        _monitoring_service_request: PeerMonitoringServiceRequest,
        monitoring_service_response: PeerMonitoringServiceResponse,
        _response_time_secs: f64,
    ) {
        // Verify the response type is valid
        let network_info_response = match monitoring_service_response {
            PeerMonitoringServiceResponse::NetworkInformation(network_information_response) => {
                network_information_response
            },
            _ => {
                warn!(LogSchema::new(LogEntry::NetworkInfoRequest)
                    .event(LogEvent::ResponseError)
                    .peer(peer_network_id)
                    .message(
                        "An unexpected response was received instead of a network info response!"
                    ));
                self.handle_request_failure();
                return;
            },
        };

        // Sanity check the response depth from the peer metadata
        let network_id = peer_network_id.network_id();
        let is_valid_depth = match network_info_response.distance_from_validators {
            0 => {
                // Verify the peer is a validator and has the correct network id
                let peer_is_validator = peer_metadata.get_connection_metadata().role.is_validator();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_validator_network(), // We're a validator
                    RoleType::FullNode => network_id.is_vfn_network(),        // We're a VFN
                };
                peer_is_validator && peer_has_correct_network
            },
            1 => {
                // Verify the peer is a VFN and has the correct network id
                let peer_is_vfn = peer_metadata.get_connection_metadata().role.is_vfn();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_vfn_network(), // We're a validator
                    RoleType::FullNode => network_id.is_public_network(), // We're a VFN or PFN
                };
                peer_is_vfn && peer_has_correct_network
            },
            distance_from_validators => {
                // The distance must be less than or equal to the max
                distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS
            },
        };

        // If the depth did not pass our sanity checks, handle a failure
        if !is_valid_depth {
            warn!(LogSchema::new(LogEntry::NetworkInfoRequest)
                .event(LogEvent::InvalidResponse)
                .peer(peer_network_id)
                .message(&format!(
                    "Peer returned invalid depth from validators: {}",
                    network_info_response.distance_from_validators
                )));
            self.handle_request_failure();
            return;
        }

        // Store the new latency ping result
        self.record_network_info_response(network_info_response);
    }
```

**File:** peer-monitoring-service/types/src/response.rs (L51-55)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct NetworkInformationResponse {
    pub connected_peers: BTreeMap<PeerNetworkId, ConnectionMetadata>, // Connected peers
    pub distance_from_validators: u64, // The distance of the peer from the validator set
}
```

**File:** network/framework/src/protocols/rpc/mod.rs (L688-731)
```rust
    pub fn handle_inbound_response(&mut self, response: RpcResponse) {
        let network_context = &self.network_context;
        let peer_id = &self.remote_peer_id;
        let request_id = response.request_id;

        let is_canceled = if let Some((protocol_id, response_tx)) =
            self.pending_outbound_rpcs.remove(&request_id)
        {
            self.update_inbound_rpc_response_metrics(
                protocol_id,
                response.raw_response.len() as u64,
            );
            response_tx.send(response).is_err()
        } else {
            true
        };

        if is_canceled {
            trace!(
                NetworkSchema::new(network_context).remote_peer(peer_id),
                request_id = request_id,
                "{} Received response for expired request_id {} from {}. Discarding.",
                network_context,
                request_id,
                peer_id.short_str(),
            );
            counters::rpc_messages(
                network_context,
                RESPONSE_LABEL,
                INBOUND_LABEL,
                EXPIRED_LABEL,
            )
            .inc();
        } else {
            trace!(
                NetworkSchema::new(network_context).remote_peer(peer_id),
                request_id = request_id,
                "{} Notified pending outbound rpc task of inbound response for request_id {} from {}",
                network_context,
                request_id,
                peer_id.short_str(),
            );
        }
    }
```

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L275-312)
```rust
/// Sorts the peers by subscription optimality (in descending order of
/// optimality). This requires: (i) sorting the peers by distance from the
/// validator set and ping latency (lower values are more optimal); and (ii)
/// filtering out peers that don't support consensus observer.
///
/// Note: we prioritize distance over latency as we want to avoid close
/// but not up-to-date peers. If peers don't have sufficient metadata
/// for sorting, they are given a lower priority.
pub fn sort_peers_by_subscription_optimality(
    peers_and_metadata: &HashMap<PeerNetworkId, PeerMetadata>,
) -> Vec<PeerNetworkId> {
    // Group peers and latencies by validator distance, i.e., distance -> [(peer, latency)]
    let mut unsupported_peers = Vec::new();
    let mut peers_and_latencies_by_distance = BTreeMap::new();
    for (peer_network_id, peer_metadata) in peers_and_metadata {
        // Verify that the peer supports consensus observer
        if !supports_consensus_observer(peer_metadata) {
            unsupported_peers.push(*peer_network_id);
            continue; // Skip the peer
        }

        // Get the distance and latency for the peer
        let distance = get_distance_for_peer(peer_network_id, peer_metadata);
        let latency = get_latency_for_peer(peer_network_id, peer_metadata);

        // If the distance is not found, use the maximum distance
        let distance =
            distance.unwrap_or(aptos_peer_monitoring_service_types::MAX_DISTANCE_FROM_VALIDATORS);

        // If the latency is not found, use a large latency
        let latency = latency.unwrap_or(MAX_PING_LATENCY_SECS);

        // Add the peer and latency to the distance group
        peers_and_latencies_by_distance
            .entry(distance)
            .or_insert_with(Vec::new)
            .push((*peer_network_id, OrderedFloat(latency)));
    }
```

**File:** state-sync/aptos-data-client/src/utils.rs (L230-260)
```rust
/// Gets the distance from the validators and measured latency (for the specified peer)
fn get_distance_and_latency_for_peer(
    peers_and_metadata: &Arc<PeersAndMetadata>,
    peer: PeerNetworkId,
) -> Option<(u64, f64)> {
    if let Some(peer_metadata) = get_metadata_for_peer(peers_and_metadata, peer) {
        // Get the distance and latency for the peer
        let peer_monitoring_metadata = peer_metadata.get_peer_monitoring_metadata();
        let distance = peer_monitoring_metadata
            .latest_network_info_response
            .as_ref()
            .map(|response| response.distance_from_validators);
        let latency = peer_monitoring_metadata.average_ping_latency_secs;

        // Return the distance and latency if both were found
        if let (Some(distance), Some(latency)) = (distance, latency) {
            return Some((distance, latency));
        }
    }

    // Otherwise, no distance and latency was found
    log_warning_with_sample(
        LogSchema::new(LogEntry::PeerStates)
            .event(LogEvent::PeerSelectionError)
            .message(&format!(
                "Unable to get distance and latency for peer! Peer: {:?}",
                peer
            )),
    );
    None
}
```

**File:** mempool/src/shared_mempool/priority.rs (L613-639)
```rust
/// Compares the validator distance for the given pair of monitoring metadata.
/// The peer with the lowest validator distance is prioritized.
fn compare_validator_distance(
    monitoring_metadata_a: &Option<&PeerMonitoringMetadata>,
    monitoring_metadata_b: &Option<&PeerMonitoringMetadata>,
) -> Ordering {
    // Get the validator distance from the monitoring metadata
    let validator_distance_a = get_distance_from_validators(monitoring_metadata_a);
    let validator_distance_b = get_distance_from_validators(monitoring_metadata_b);

    // Compare the distances
    match (validator_distance_a, validator_distance_b) {
        (Some(validator_distance_a), Some(validator_distance_b)) => {
            // Prioritize the peer with the lowest validator distance
            validator_distance_a.cmp(&validator_distance_b).reverse()
        },
        (Some(_), None) => {
            Ordering::Greater // Prioritize the peer with a validator distance
        },
        (None, Some(_)) => {
            Ordering::Less // Prioritize the peer with a validator distance
        },
        (None, None) => {
            Ordering::Equal // Neither peer has a validator distance
        },
    }
}
```

**File:** config/src/config/peer_monitoring_config.rs (L66-70)
```rust
    fn default() -> Self {
        Self {
            network_info_request_interval_ms: 60_000, // 1 minute
            network_info_request_timeout_ms: 10_000,  // 10 seconds
        }
```
