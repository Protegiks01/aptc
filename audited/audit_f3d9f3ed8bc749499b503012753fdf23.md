# Audit Report

## Title
Missing Configuration Validation for hot_state_kv_db_path Causes Node Startup Panic

## Summary
The `ConfigSanitizer::sanitize()` function in `storage_config.rs` validates path configurations for `state_kv_db_path`, `state_merkle_db_path`, and `hot_state_merkle_db_path`, but completely omits validation for `hot_state_kv_db_path`. This inconsistency allows invalid configurations (relative paths, invalid shard IDs) to pass sanitization, causing the node to panic during startup when the database attempts to open.

## Finding Description

The `DbPathConfig` structure defines five configurable database paths [1](#0-0) , but the `sanitize()` function only validates four of them.

The validation logic checks:
- `ledger_db_path` for absolute paths [2](#0-1) 
- `state_kv_db_path` for absolute metadata paths and valid shard configurations [3](#0-2) 
- `state_merkle_db_path` for absolute metadata paths and valid shard configurations [4](#0-3) 
- `hot_state_merkle_db_path` for absolute metadata paths and valid shard configurations [5](#0-4) 

**However, `hot_state_kv_db_path` has no validation block at all.**

When the node starts, `get_dir_paths()` processes all path overrides including `hot_state_kv_db_path` [6](#0-5) , which calls `ShardedDbPaths::new()` [7](#0-6) . This function calls `get_shard_paths().expect("Invalid config.")`, which will panic if the configuration contains:

- Non-absolute shard paths [8](#0-7) 
- Shard IDs outside [0, 16) range [9](#0-8) 
- Duplicate shard IDs [10](#0-9) 

This panic occurs during `AptosDB::open()` at node startup [11](#0-10) .

## Impact Explanation

This is a **Low Severity** issue per the Aptos bug bounty criteria. While it causes node failure, it:

1. **Requires privileged access**: Only node operators with configuration file modification rights can exploit this
2. **Local impact only**: Affects only the misconfigured node, not the network or consensus
3. **No data loss**: No funds, state, or consensus integrity is compromised
4. **Easily recoverable**: Simply correcting the configuration file resolves the issue

This falls under "Non-critical implementation bugs" in the Low severity category, as it's a robustness issue in configuration validation rather than a security vulnerability affecting network security or consensus.

## Likelihood Explanation

**Moderate likelihood of accidental occurrence, low likelihood of intentional exploit:**

- Node operators may inadvertently provide invalid hot state paths during configuration
- The missing validation makes configuration errors harder to debug (panic at runtime vs clear error at validation)
- However, exploiting this intentionally requires operator-level access, at which point an attacker has many more effective attack vectors
- The configuration error would be immediately apparent upon node restart, limiting persistent impact

## Recommendation

Add validation for `hot_state_kv_db_path` consistent with the other sharded database path validations. Insert the following block after line 777 in `storage_config.rs`:

```rust
if let Some(hot_state_kv_db_path) = db_path_overrides.hot_state_kv_db_path.as_ref() {
    if let Some(metadata_path) = hot_state_kv_db_path.metadata_path.as_ref() {
        if !metadata_path.is_absolute() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!("Path {metadata_path:?} in db_path_overrides is not an absolute path."),
            ));
        }
    }

    if let Err(e) = hot_state_kv_db_path.get_shard_paths() {
        return Err(Error::ConfigSanitizerFailed(sanitizer_name, e.to_string()));
    }
}
```

This ensures `hot_state_kv_db_path` receives the same validation as `state_kv_db_path`, `state_merkle_db_path`, and `hot_state_merkle_db_path`.

## Proof of Concept

Create a test configuration file with invalid `hot_state_kv_db_path`:

```yaml
storage:
  rocksdb_configs:
    enable_storage_sharding: true
  db_path_overrides:
    hot_state_kv_db_path:
      metadata_path: /valid/absolute/path
      shard_paths:
        - shards: "0-3"
          path: relative/invalid/path  # This is a relative path - should fail validation
```

**Steps to reproduce:**
1. Save the above configuration
2. Run `ConfigSanitizer::sanitize()` - it will **pass** (incorrectly)
3. Start the node with this configuration
4. Node will panic during `AptosDB::open()` when calling `get_dir_paths()` → `ShardedDbPaths::new()` → `get_shard_paths().expect()`

**Expected behavior:** The sanitizer should reject this configuration before node startup with a clear error message about the relative path.

**Actual behavior:** The sanitizer passes, and the node panics with a cryptic error during database initialization.

### Citations

**File:** config/src/config/storage_config.rs (L32-38)
```rust
struct DbPathConfig {
    ledger_db_path: Option<PathBuf>,
    state_kv_db_path: Option<ShardedDbPathConfig>,
    state_merkle_db_path: Option<ShardedDbPathConfig>,
    hot_state_kv_db_path: Option<ShardedDbPathConfig>,
    hot_state_merkle_db_path: Option<ShardedDbPathConfig>,
}
```

**File:** config/src/config/storage_config.rs (L60-63)
```rust
            ensure!(
                path.is_absolute(),
                "Path ({path:?}) is not an absolute path."
            );
```

**File:** config/src/config/storage_config.rs (L65-68)
```rust
                ensure!(
                    shard_id < 16,
                    "Shard id ({shard_id}) is out of range [0, 16)."
                );
```

**File:** config/src/config/storage_config.rs (L69-73)
```rust
                let exist = result.insert(shard_id, path.clone()).is_some();
                ensure!(
                    !exist,
                    "Duplicated shard id ({shard_id}) is not allowed in the config."
                );
```

**File:** config/src/config/storage_config.rs (L488-490)
```rust
            if let Some(hot_state_kv_db_path) = db_path_overrides.hot_state_kv_db_path.as_ref() {
                hot_state_kv_db_paths = ShardedDbPaths::new(hot_state_kv_db_path);
            }
```

**File:** config/src/config/storage_config.rs (L621-630)
```rust
    fn new(config: &ShardedDbPathConfig) -> Self {
        let mut shard_paths = arr![None; 16];
        for (shard_id, shard_path) in config.get_shard_paths().expect("Invalid config.") {
            shard_paths[shard_id as usize] = Some(shard_path);
        }

        Self {
            metadata_path: config.metadata_path.clone(),
            shard_paths,
        }
```

**File:** config/src/config/storage_config.rs (L738-747)
```rust
            if let Some(ledger_db_path) = db_path_overrides.ledger_db_path.as_ref() {
                if !ledger_db_path.is_absolute() {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        format!(
                            "Path {ledger_db_path:?} in db_path_overrides is not an absolute path."
                        ),
                    ));
                }
            }
```

**File:** config/src/config/storage_config.rs (L749-762)
```rust
            if let Some(state_kv_db_path) = db_path_overrides.state_kv_db_path.as_ref() {
                if let Some(metadata_path) = state_kv_db_path.metadata_path.as_ref() {
                    if !metadata_path.is_absolute() {
                        return Err(Error::ConfigSanitizerFailed(
                            sanitizer_name,
                            format!("Path {metadata_path:?} in db_path_overrides is not an absolute path."),
                        ));
                    }
                }

                if let Err(e) = state_kv_db_path.get_shard_paths() {
                    return Err(Error::ConfigSanitizerFailed(sanitizer_name, e.to_string()));
                }
            }
```

**File:** config/src/config/storage_config.rs (L764-777)
```rust
            if let Some(state_merkle_db_path) = db_path_overrides.state_merkle_db_path.as_ref() {
                if let Some(metadata_path) = state_merkle_db_path.metadata_path.as_ref() {
                    if !metadata_path.is_absolute() {
                        return Err(Error::ConfigSanitizerFailed(
                            sanitizer_name,
                            format!("Path {metadata_path:?} in db_path_overrides is not an absolute path."),
                        ));
                    }
                }

                if let Err(e) = state_merkle_db_path.get_shard_paths() {
                    return Err(Error::ConfigSanitizerFailed(sanitizer_name, e.to_string()));
                }
            }
```

**File:** config/src/config/storage_config.rs (L779-794)
```rust
            if let Some(hot_state_merkle_db_path) =
                db_path_overrides.hot_state_merkle_db_path.as_ref()
            {
                if let Some(metadata_path) = hot_state_merkle_db_path.metadata_path.as_ref() {
                    if !metadata_path.is_absolute() {
                        return Err(Error::ConfigSanitizerFailed(
                            sanitizer_name,
                            format!("Path {metadata_path:?} in db_path_overrides is not an absolute path."),
                        ));
                    }
                }

                if let Err(e) = hot_state_merkle_db_path.get_shard_paths() {
                    return Err(Error::ConfigSanitizerFailed(sanitizer_name, e.to_string()));
                }
            }
```

**File:** storage/aptosdb/src/fast_sync_storage_wrapper.rs (L48-59)
```rust
        let mut db_main = AptosDB::open(
            config.storage.get_dir_paths(),
            /*readonly=*/ false,
            config.storage.storage_pruner_config,
            config.storage.rocksdb_configs,
            config.storage.enable_indexer,
            config.storage.buffered_state_target_items,
            config.storage.max_num_nodes_per_lru_cache_shard,
            internal_indexer_db,
            config.storage.hot_state_config,
        )
        .map_err(|err| anyhow!("fast sync DB failed to open {}", err))?;
```
