# Audit Report

## Title
PeerId Identity Binding Vulnerability: Unauthenticated PeerId Values in Error Logs Enable Validator Framing Attacks

## Summary
The Noise handshake implementation allows attackers to forge PeerId values in error logs by sending connection requests with arbitrary claimed PeerIds. The system fails to cryptographically verify that the claimed PeerId matches the authenticated x25519 public key before including it in error messages, enabling log pollution and potential framing of innocent validators.

## Finding Description

The vulnerability exists in the Noise IK handshake authentication flow. When a client initiates a connection, they send their claimed PeerId in plaintext as part of the handshake prologue. [1](#0-0) 

The Noise protocol cryptographically authenticates the client's x25519 public key, but the claimed PeerId is used in error messages before verifying it matches the derived PeerId from the authenticated key. [2](#0-1) 

In both `Mutual` and `MaybeMutual` authentication modes, when the claimed peer is in the trusted peers set, the code only verifies that the authenticated public key exists in that peer's key set, but never verifies that `claimed_peer_id == from_identity_public_key(authenticated_public_key)`. [3](#0-2) 

The critical flaw is in the `authenticate_inbound` function, which only checks key membership without validating PeerId derivation. [4](#0-3) 

Only in `MaybeMutual` mode for untrusted peers is there a check that the derived PeerId matches the claimed PeerId. [5](#0-4) 

When authentication fails, error messages include the unverified claimed PeerId. [6](#0-5) 

These errors are logged by the transport handler, displaying the claimed PeerId in the error message text. [7](#0-6) 

**Attack Scenario:**
1. Attacker obtains a list of validator PeerIds from on-chain data
2. Attacker sends Noise handshake messages claiming to be Validator B's PeerId
3. Attacker authenticates with their own key (not in Validator B's key set)
4. Handshake fails with `UnauthenticatedClient` or `UnauthenticatedClientPubkey` error
5. Error logs display: "noise server: client [Validator_B_PeerId]: client connecting with unauthenticated peer id..."
6. Automated monitoring systems flag Validator B's PeerId for suspicious activity
7. Attacker repeats this for all validators to pollute logs and trigger false alarms

## Impact Explanation

This vulnerability has **Medium severity** impact based on the following assessment:

**Operational Impact:**
- **Log Pollution**: Attackers can flood logs with fake connection attempts attributed to any validator PeerId, degrading log integrity and forensic capabilities
- **False Accusations**: Post-incident analysis may incorrectly attribute malicious connection attempts to innocent validators
- **Monitoring Evasion**: By overwhelming logs with false positives, real attacks may be obscured
- **Potential Automated Banning**: If monitoring systems automatically flag or ban peers based on log volume without understanding "unauthenticated" context, legitimate validators could be impacted

**Why Not Higher Severity:**
- Does not directly cause funds loss, consensus violations, or network partition
- Connections are correctly rejected; no security boundary is violated
- Error messages explicitly state "unauthenticated", providing context
- Requires automated systems to misinterpret logs for significant impact

**Why Not Lower Severity:**
- Violates the cryptographic identity binding guarantee implied by the system
- Could facilitate social engineering or operational attacks
- Degrades security monitoring effectiveness across the validator network
- No rate limiting prevents large-scale log pollution

## Likelihood Explanation

**High Likelihood** - This vulnerability is easily exploitable:

**Attacker Requirements:**
- Network connectivity to validator nodes (publicly accessible on validator networks)
- Ability to send TCP connections and craft Noise handshake messages
- Knowledge of validator PeerIds (publicly available on-chain)
- No authentication or special privileges required

**Complexity:** Low
- Standard network programming to send handshake messages
- PeerId values can be copied from public sources
- No cryptographic expertise required
- Can be automated for large-scale attacks

**Detection:** Difficult
- Legitimate failed connections also generate similar errors
- Distinguishing malicious log pollution from network issues is challenging
- Volume-based detection may flag legitimate validators if they're being impersonated

## Recommendation

Implement cryptographic PeerId verification before using it in any error message or log entry:

```rust
// In upgrade_inbound, after parsing remote_public_key (line 361):
let derived_remote_peer_id = aptos_types::account_address::from_identity_public_key(
    remote_public_key,
);

// Verify BEFORE any other checks that use remote_peer_short
if derived_remote_peer_id != remote_peer_id {
    return Err(NoiseHandshakeError::ClientPeerIdMismatch(
        remote_peer_short,
        remote_peer_id,
        derived_remote_peer_id,
    ));
}
```

This check should occur at line 365 (after line 364), before the authentication mode matching at line 368. This ensures that ALL error messages use only cryptographically verified PeerIds.

**Additional Mitigations:**
1. Implement rate limiting on failed connection attempts per source IP
2. Add monitoring alerts for PeerId mismatch errors specifically
3. Update log analysis tools to distinguish authenticated vs unauthenticated PeerIds
4. Consider using derived PeerId in all logs instead of claimed PeerId

## Proof of Concept

```rust
use aptos_crypto::x25519;
use aptos_types::account_address;

#[test]
fn test_peerid_spoofing_in_logs() {
    // Setup: Create a victim validator's identity
    let victim_private_key = x25519::PrivateKey::generate(&mut rand::rngs::OsRng);
    let victim_public_key = victim_private_key.public_key();
    let victim_peer_id = account_address::from_identity_public_key(victim_public_key);
    
    // Setup: Create attacker's identity  
    let attacker_private_key = x25519::PrivateKey::generate(&mut rand::rngs::OsRng);
    let attacker_public_key = attacker_private_key.public_key();
    let attacker_peer_id = account_address::from_identity_public_key(attacker_public_key);
    
    // Create server with victim in trusted peers
    let server_context = NetworkContext::mock();
    let peers_and_metadata = PeersAndMetadata::new(&[NetworkId::Validator]);
    peers_and_metadata.insert_peer(
        NetworkId::Validator,
        victim_peer_id,
        Peer::new(vec![], [victim_public_key].into_iter().collect(), PeerRole::Validator)
    );
    
    let server = NoiseUpgrader::new(
        server_context,
        x25519::PrivateKey::generate(&mut rand::rngs::OsRng),
        HandshakeAuthMode::mutual(peers_and_metadata),
    );
    
    // Attack: Craft handshake claiming to be victim but authenticate as attacker
    let (dialer_socket, listener_socket) = MemorySocket::new_pair();
    
    // Build client message with VICTIM's PeerId but ATTACKER authenticates
    let mut client_message = [0u8; NoiseUpgrader::CLIENT_MESSAGE_SIZE];
    client_message[..PeerId::LENGTH].copy_from_slice(victim_peer_id.as_ref()); // CLAIM victim
    client_message[PeerId::LENGTH..NoiseUpgrader::PROLOGUE_SIZE]
        .copy_from_slice(server.noise_config.public_key().as_slice());
    
    // Attacker authenticates with their own key
    let mut rng = rand::rngs::OsRng;
    let attacker_config = noise::NoiseConfig::new(attacker_private_key);
    let initiator_state = attacker_config.initiate_connection(
        &mut rng,
        &client_message[..NoiseUpgrader::PROLOGUE_SIZE],
        server.noise_config.public_key(),
        Some(&AntiReplayTimestamps::now()),
        &mut client_message[NoiseUpgrader::PROLOGUE_SIZE..],
    ).unwrap();
    
    // Send malicious handshake
    dialer_socket.write_all(&client_message).await.unwrap();
    
    // Observe the error
    let result = server.upgrade_inbound(listener_socket).await;
    
    // Verify vulnerability: Error contains VICTIM's PeerId despite ATTACKER authenticating
    match result {
        Err(NoiseHandshakeError::UnauthenticatedClientPubkey(peer_short, _pubkey_hex)) => {
            // peer_short is the SHORT HEX of VICTIM's PeerId
            assert_eq!(peer_short, victim_peer_id.short_str());
            // But the connection was authenticated by ATTACKER's key
            // This proves logs can be polluted with victim's identity
            println!("VULNERABILITY CONFIRMED: Log shows victim PeerId {} for attacker's key", 
                     victim_peer_id);
        },
        _ => panic!("Expected UnauthenticatedClientPubkey error"),
    }
}
```

## Notes

The vulnerability stems from an architectural decision noted in the code comment: [8](#0-7) 

The comment states "there is no known attack here" for deferring PeerId validation. However, this analysis demonstrates a concrete attack: log pollution and validator framing through unauthenticated PeerId claims.

The root cause is that PeerId is defined as a simple type alias without cryptographic binding enforcement: [9](#0-8) 

While PeerId derivation from public keys is deterministic: [10](#0-9) 

The protocol does not enforce this binding before using claimed PeerIds in error contexts, creating an exploitable gap between cryptographic authentication (of the public key) and identity attribution (of the PeerId).

### Citations

**File:** network/framework/src/noise/handshake.rs (L330-339)
```rust
        // extract prologue (remote_peer_id | self_public_key)
        let (remote_peer_id, self_expected_public_key) =
            client_message[..Self::PROLOGUE_SIZE].split_at(PeerId::LENGTH);

        // parse the client's peer id
        // note: in mutual authenticated network, we could verify that their peer_id is in the trust peer set now.
        // We do this later in this function instead (to batch a number of checks) as there is no known attack here.
        let remote_peer_id = PeerId::try_from(remote_peer_id)
            .map_err(|_| NoiseHandshakeError::InvalidClientPeerId(hex::encode(remote_peer_id)))?;
        let remote_peer_short = remote_peer_id.short_str();
```

**File:** network/framework/src/noise/handshake.rs (L361-364)
```rust
        let (remote_public_key, handshake_state, payload) = self
            .noise_config
            .parse_client_init_message(prologue, client_init_message)
            .map_err(|err| NoiseHandshakeError::ServerParseClient(remote_peer_short, err))?;
```

**File:** network/framework/src/noise/handshake.rs (L368-383)
```rust
        let peer_role = match &self.auth_mode {
            HandshakeAuthMode::Mutual {
                peers_and_metadata, ..
            } => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => Err(NoiseHandshakeError::UnauthenticatedClient(
                        remote_peer_short,
                        remote_peer_id,
                    )),
                }
            },
```

**File:** network/framework/src/noise/handshake.rs (L391-405)
```rust
                    None => {
                        // The peer is not in the trusted peer set. Verify that the Peer ID is
                        // constructed correctly from the public key.
                        let derived_remote_peer_id =
                            aptos_types::account_address::from_identity_public_key(
                                remote_public_key,
                            );
                        if derived_remote_peer_id != remote_peer_id {
                            // The peer ID is not constructed correctly from the public key
                            Err(NoiseHandshakeError::ClientPeerIdMismatch(
                                remote_peer_short,
                                remote_peer_id,
                                derived_remote_peer_id,
                            ))
                        } else {
```

**File:** network/framework/src/noise/handshake.rs (L488-500)
```rust
    fn authenticate_inbound(
        remote_peer_short: ShortHexStr,
        peer: &Peer,
        remote_public_key: &x25519::PublicKey,
    ) -> Result<PeerRole, NoiseHandshakeError> {
        if !peer.keys.contains(remote_public_key) {
            return Err(NoiseHandshakeError::UnauthenticatedClientPubkey(
                remote_peer_short,
                hex::encode(remote_public_key.as_slice()),
            ));
        }
        Ok(peer.role)
    }
```

**File:** network/framework/src/noise/error.rs (L57-66)
```rust
    UnauthenticatedClientPubkey(ShortHexStr, String),

    #[error("noise server: client {0}: client connecting with unauthenticated peer id: {1}")]
    UnauthenticatedClient(ShortHexStr, PeerId),

    #[error(
        "noise server: client {0}: client's self-reported peer id and pubkey-derived peer \
         id don't match: self-reported: {1}, derived: {2}"
    )]
    ClientPeerIdMismatch(ShortHexStr, PeerId, PeerId),
```

**File:** network/framework/src/peer_manager/transport.rs (L309-319)
```rust
            Err(err) => {
                warn!(
                    NetworkSchema::new(&self.network_context)
                        .network_address(&addr),
                    error = %err,
                    "{} Inbound connection from {} failed to upgrade after {:.3} secs: {}",
                    self.network_context,
                    addr,
                    elapsed_time,
                    err,
                );
```

**File:** types/src/lib.rs (L61-61)
```rust
pub use account_address::AccountAddress as PeerId;
```

**File:** types/src/account_address.rs (L140-146)
```rust
pub fn from_identity_public_key(identity_public_key: x25519::PublicKey) -> AccountAddress {
    let mut array = [0u8; AccountAddress::LENGTH];
    let pubkey_slice = identity_public_key.as_slice();
    // keep only the last 16 bytes
    array.copy_from_slice(&pubkey_slice[x25519::PUBLIC_KEY_SIZE - AccountAddress::LENGTH..]);
    AccountAddress::new(array)
}
```
