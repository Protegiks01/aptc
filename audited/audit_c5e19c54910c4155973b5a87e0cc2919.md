# Audit Report

## Title
State Corruption in Spec Translator Due to Non-Reentrant `in_old` Flag Management

## Summary
The `rewrite_exp()` function in the Move specification translator uses a non-reentrant pattern to manage the `in_old` state flag. When processing nested `old()` expressions or block expressions containing `old()` in bindings, reentrant calls corrupt the `in_old` flag, causing subsequent expressions to be incorrectly translated. This results in memory state not being saved for pre-state access, breaking the semantic correctness of specifications.

## Finding Description

The vulnerability exists in the `rewrite_exp()` function's handling of the `in_old` state variable: [1](#0-0) 

The function uses a simple pattern: set `is_old=true` when encountering `Operation::Old`, set `self.in_old=true`, call `rewrite_exp_descent()`, then set `self.in_old=false`. However, `rewrite_exp_descent()` recursively processes sub-expressions by calling back to `rewrite_exp()` through the rewrite chain: [2](#0-1) 

**Attack Scenario:**

Consider a specification with a block expression inside `old()`:

```move
spec function_name {
    ensures old({
        let x = old(global<Counter>(@0x1).value);
        global<Counter>(@0x2).value > x
    });
}
```

**Execution trace:**

1. Outer `old()` is processed: `is_old=true`, `self.in_old=true`
2. `rewrite_exp_descent()` processes the block expression
3. Block processing first rewrites the binding `old(global<Counter>(@0x1).value)`:
   - Inner `rewrite_exp()` is called: `is_old=true`, `self.in_old=true` (no change)
   - After processing, sets `self.in_old=false` ⚠️
4. Block then processes the body `global<Counter>(@0x2).value > x` with **`self.in_old=false`**
5. When `global<Counter>(@0x2)` is encountered, `rewrite_call()` checks `self.in_old`: [3](#0-2) 

6. Since `self.in_old=false`, the condition `Global(None) if self.in_old` doesn't match
7. Memory is **not saved** for this global access
8. The global access reads from **post-state** instead of **pre-state**

The same issue affects `Exists` and `SpecFunction` operations: [4](#0-3) 

**Why This Matters:**

The spec translator generates `saved_memory` mappings that instruct the bytecode instrumentation to emit `SaveMem` operations. Without these saves, `old()` expressions read from the wrong state: [5](#0-4) 

## Impact Explanation

This is a **verification soundness bug** in the Move Prover toolchain. While the Move Prover is a development-time tool rather than a runtime component, incorrect verification has serious security implications:

**Direct Impact:**
- Specifications are incorrectly translated, causing the prover to verify against wrong semantics
- False negatives: Buggy code passes verification when it should fail
- False positives: Correct code fails verification when it should pass

**Indirect Security Impact:**
- Developers rely on the Move Prover to verify critical smart contracts
- If the prover incorrectly validates specifications due to this bug, vulnerable contracts could be deployed to production
- This could affect governance contracts, staking contracts, or financial contracts on Aptos
- Given the financial stakes, incorrect verification could lead to exploitable vulnerabilities in production

**Severity Assessment:**
This is a **Medium severity** issue. While it doesn't directly compromise the blockchain runtime, it undermines a critical security tool that developers rely on for correctness guarantees. The impact is indirect but potentially severe if vulnerable code is deployed due to incorrect verification.

## Likelihood Explanation

**Likelihood: Low to Medium**

The bug requires specific patterns to trigger:
1. Nested `old()` expressions (semantically redundant but syntactically valid)
2. Block expressions within `old()` that have `old()` in bindings and state-dependent expressions in the body

While these patterns are uncommon in typical specifications, they are:
- Not prevented by the type system or validator
- Possible in complex specifications for governance, staking, or financial contracts
- More likely in refactored code where inline expressions are extracted to let-bindings

The error check for `old()` applied to pure expressions does not prevent this bug: [6](#0-5) 

## Recommendation

**Fix: Use a stack-based approach for `in_old` state management**

Replace the boolean flag with a counter or stack to handle reentrant calls correctly:

```rust
// In the SpecTranslator struct:
in_old_depth: usize,  // Replace the boolean in_old field

// In rewrite_exp():
fn rewrite_exp(&mut self, exp: Exp) -> Exp {
    let env = self.builder.global_env();
    let mut is_old = false;
    match exp.as_ref() {
        ExpData::Call(id, Operation::Old, args) => {
            is_old = true;
            // Validation code...
        },
        // ... other cases
    }
    
    if is_old {
        self.in_old_depth += 1;  // Increment depth
    }
    let exp = self.rewrite_exp_descent(exp);
    if is_old {
        self.in_old_depth -= 1;  // Decrement depth
    }
    exp
}

// Update checks to use: self.in_old_depth > 0
```

This ensures that nested `old()` contexts are properly tracked and the flag is only cleared when exiting the outermost `old()` context.

## Proof of Concept

Create a test file `nested_old_bug.move`:

```move
module 0x1::NestedOldBug {
    struct Counter has key {
        value: u64
    }

    // This function modifies two counters
    public fun modify_counters(addr1: address, addr2: address) acquires Counter {
        let c1 = borrow_global_mut<Counter>(addr1);
        c1.value = c1.value + 1;
        
        let c2 = borrow_global_mut<Counter>(addr2);
        c2.value = c2.value + 10;
    }
    
    spec modify_counters {
        // This spec uses nested old() in a block - triggers the bug
        ensures old({
            let before_c1 = old(global<Counter>(addr1).value);
            global<Counter>(addr2).value == before_c1 + 10  // BUG: reads post-state!
        });
    }
}
```

**Expected behavior:** The spec should fail because `global<Counter>(addr2).value` should be evaluated in pre-state (before modifications), not post-state.

**Actual behavior with bug:** The spec is incorrectly translated - `global<Counter>(addr2)` doesn't save memory, so it reads post-state value, making the spec incorrectly pass/fail depending on the actual values.

**To verify:** Run the Move Prover with `--trace` flag and examine the generated bytecode to confirm that `SaveMem` operations are missing for the second global access.

---

## Notes

This vulnerability is in the Move specification translator, which is part of the verification toolchain rather than the blockchain runtime. While it doesn't directly affect consensus or execution, it compromises the correctness of formal verification, which is a critical security mechanism for Move smart contracts. The bug is particularly concerning for high-value contracts where developers rely on the prover for security guarantees.

### Citations

**File:** third_party/move/move-model/src/spec_translator.rs (L566-573)
```rust
    fn save_memory(&mut self, qid: QualifiedInstId<StructId>) -> MemoryLabel {
        let builder = &mut self.builder;
        *self
            .result
            .saved_memory
            .entry(qid)
            .or_insert_with(|| builder.global_env().new_global_id())
    }
```

**File:** third_party/move/move-model/src/spec_translator.rs (L589-655)
```rust
    fn rewrite_exp(&mut self, exp: Exp) -> Exp {
        // Do some pre-processing of the expression before actual rewrite, reporting
        // errors.
        let env = self.builder.global_env();
        let mut is_old = false;
        match exp.as_ref() {
            ExpData::Call(id, Operation::Old, args) => {
                is_old = true;
                // Generate an error if an `old` function is applied to a pure expression.
                let arg = &args[0];
                if arg.is_pure(self.builder.global_env()) {
                    let loc = self.builder.global_env().get_node_loc(*id);
                    // Compute labels for any sub-expressions which are included into this
                    // expression via substitution (from schema inclusion, for example). This
                    // is done via checking the location of the sub-expression. We also try
                    // to avoid to report a sub-expression which is a sub-expression of an
                    // already reported one.
                    let mut labels = vec![];
                    let loc_contained = |loc: &Loc, cont: &Loc| {
                        loc.file_id() == cont.file_id()
                            && cont.span().start() >= loc.span().start()
                            && cont.span().end() <= loc.span().end()
                    };
                    arg.visit_pre_order(&mut |e: &ExpData| {
                        let sub_loc = self.builder.global_env().get_node_loc(e.node_id());
                        if !loc_contained(&loc, &sub_loc)
                            && !labels.iter().any(|(l, _)| loc_contained(l, &sub_loc))
                        {
                            labels.push((sub_loc, "substituted sub-expression".to_owned()))
                        }
                        true // continue visit
                    });
                    self.builder.global_env().diag_with_labels(
                        Severity::Error,
                        &loc,
                        "`old(..)` applied to expression which does not depend on state",
                        labels,
                    )
                }
            },
            ExpData::Call(id, Operation::Trace(TraceKind::User), args) => {
                // Generate an error if a TRACE is applied to an expression where it is not
                // allowed, i.e. if there are free LocalVar terms, excluding locals from lets.
                let loc = env.get_node_loc(*id);
                let has_free_vars = args[0]
                    .free_vars_with_types(env)
                    .iter()
                    .any(|(s, _)| !self.let_locals.contains_key(s));
                if has_free_vars {
                    env.error(
                        &loc,
                        "`TRACE(..)` function cannot be used for expressions depending \
                             on quantified variables or spec function parameters",
                    )
                }
            },
            _ => {},
        }
        if is_old {
            self.in_old = true;
        }
        let exp = self.rewrite_exp_descent(exp);
        if is_old {
            self.in_old = false;
        }
        exp
    }
```

**File:** third_party/move/move-model/src/spec_translator.rs (L699-706)
```rust
            Global(None) if self.in_old => Some(
                Call(
                    id,
                    Global(Some(self.save_memory(self.builder.get_memory_of_node(id)))),
                    args.to_owned(),
                )
                .into_exp(),
            ),
```

**File:** third_party/move/move-model/src/spec_translator.rs (L707-730)
```rust
            Exists(None) if self.in_old => Some(
                Call(
                    id,
                    Exists(Some(self.save_memory(self.builder.get_memory_of_node(id)))),
                    args.to_owned(),
                )
                .into_exp(),
            ),
            SpecFunction(mid, fid, None) if self.in_old => {
                let used_memory = {
                    let module_env = self.builder.global_env().get_module(*mid);
                    let decl = module_env.get_spec_fun(*fid);
                    // Unfortunately, the below clones are necessary, as we cannot borrow decl
                    // and at the same time mutate self later.
                    decl.used_memory.clone()
                };
                let inst = self.builder.global_env().get_node_instantiation(id);
                let mut labels = vec![];
                for mem in used_memory {
                    let mem = mem.instantiate(&inst);
                    labels.push(self.save_memory(mem));
                }
                Some(Call(id, SpecFunction(*mid, *fid, Some(labels)), args.to_owned()).into_exp())
            },
```

**File:** third_party/move/move-model/src/exp_rewriter.rs (L292-598)
```rust
    fn rewrite_exp_descent(&mut self, exp: Exp) -> Exp {
        use ExpData::*;
        match exp.as_ref() {
            Value(id, value) => {
                let (id_changed, new_id) = self.internal_rewrite_id(*id);
                if let Some(new_exp) = self.rewrite_value(new_id, value) {
                    new_exp
                } else if id_changed {
                    Value(new_id, value.clone()).into_exp()
                } else {
                    exp
                }
            },
            LocalVar(id, sym) => {
                let (id_changed, new_id) = self.internal_rewrite_id(*id);
                if let Some(new_exp) = self.rewrite_local_var(new_id, *sym) {
                    new_exp
                } else if id_changed {
                    LocalVar(new_id, *sym).into_exp()
                } else {
                    exp
                }
            },
            Temporary(id, idx) => {
                let (id_changed, new_id) = self.internal_rewrite_id(*id);
                if let Some(new_exp) = self.rewrite_temporary(new_id, *idx) {
                    new_exp
                } else if id_changed {
                    Temporary(new_id, *idx).into_exp()
                } else {
                    exp
                }
            },
            Call(id, oper, args) => {
                let (id_changed, new_id) = self.internal_rewrite_id(*id);
                let new_args_opt = self.internal_rewrite_vec(args);
                let args_ref = if let Some(new_args) = &new_args_opt {
                    new_args.as_slice()
                } else {
                    args.as_slice()
                };
                if let Some(new_exp) = self.rewrite_call(new_id, oper, args_ref) {
                    new_exp
                } else if new_args_opt.is_some() || id_changed {
                    let args_owned = if let Some(new_args) = new_args_opt {
                        new_args
                    } else {
                        args.to_owned()
                    };
                    Call(new_id, oper.clone(), args_owned).into_exp()
                } else {
                    exp
                }
            },
            Invoke(id, target, args) => {
                let (id_changed, new_id) = self.internal_rewrite_id(*id);
                let (target_changed, new_target) = self.internal_rewrite_exp(target);
                let new_args_opt = self.internal_rewrite_vec(args);
                let args_ref = if let Some(new_args) = &new_args_opt {
                    new_args.as_slice()
                } else {
                    args.as_slice()
                };
                if let Some(new_exp) = self.rewrite_invoke(new_id, &new_target, args_ref) {
                    new_exp
                } else if id_changed || target_changed || new_args_opt.is_some() {
                    let args_owned = if let Some(new_args) = new_args_opt {
                        new_args
                    } else {
                        args.to_owned()
                    };
                    Invoke(new_id, new_target, args_owned).into_exp()
                } else {
                    exp
                }
            },
            Lambda(id, pat, body, capture_kind, spec_opt) => {
                let (id_changed, new_id) = self.internal_rewrite_id(*id);
                let (pat_changed, new_pat) = self.internal_rewrite_pattern(pat, true);
                self.rewrite_enter_scope(new_id, new_pat.vars().iter());
                let (body_changed, new_body) = self.internal_rewrite_exp(body);
                let (spec_body_changed, new_spec_opt) = if let Some(spec) = spec_opt {
                    let (spec_changed, new_spec) = self.internal_rewrite_exp(spec);
                    (spec_changed, Some(new_spec))
                } else {
                    (false, spec_opt.clone())
                };
                self.rewrite_exit_scope(new_id);
                if let Some(new_exp) =
                    self.rewrite_lambda(new_id, &new_pat, &new_body, *capture_kind, &new_spec_opt)
                {
                    new_exp
                } else if id_changed || pat_changed || body_changed || spec_body_changed {
                    Lambda(new_id, new_pat, new_body, *capture_kind, new_spec_opt).into_exp()
                } else {
                    exp
                }
            },
            Block(id, pat, binding, body) => {
                let (id_changed, new_id) = self.internal_rewrite_id(*id);
                // Note that `binding` expr must be evaluated *before* we enter new pattern scope.
                let (binding_changed, new_binding) = if let Some(b) = binding {
                    let (changed, b) = self.internal_rewrite_exp(b);
                    (changed, Some(b))
                } else {
                    (false, None)
                };
                let (pat_changed, new_pat) = self.internal_rewrite_pattern(pat, true);
                let optional_pat = self.rewrite_enter_block_scope(new_id, &new_pat, &new_binding);
                let (body_changed, new_body) = self.internal_rewrite_exp(body);
                self.rewrite_exit_scope(new_id);
                let (pat_changed, newer_pat) = if let Some(rewritten_pat) = optional_pat {
                    (true, rewritten_pat)
                } else {
                    (pat_changed, new_pat)
                };
                if let Some(new_exp) =
                    self.rewrite_block(new_id, &newer_pat, &new_binding, &new_body)
                {
                    new_exp
                } else if id_changed || pat_changed || binding_changed || body_changed {
                    Block(new_id, newer_pat, new_binding, new_body).into_exp()
                } else {
                    exp
                }
            },
            Quant(id, kind, ranges, triggers, cond, body) => {
                let (id_changed, new_id) = self.internal_rewrite_id(*id);
                let (ranges_changed, new_ranges) = self.internal_rewrite_quant_ranges(ranges);
                self.rewrite_enter_scope(
                    new_id,
                    ranges
                        .iter()
                        .flat_map(|(pat, _)| pat.vars())
                        .collect::<Vec<_>>()
                        .iter(),
                );
                let mut triggers_changed = false;
                let new_triggers = triggers
                    .iter()
                    .map(|p| {
                        let (c, new_p) = self
                            .internal_rewrite_vec(p)
                            .map(|pr| (true, pr))
                            .unwrap_or_else(|| (false, p.clone()));
                        triggers_changed = triggers_changed || c;
                        new_p
                    })
                    .collect_vec();
                let mut cond_changed = false;
                let new_cond = cond.as_ref().map(|c| {
                    let (c, new_c) = self.internal_rewrite_exp(c);
                    cond_changed = c;
                    new_c
                });
                let (body_changed, new_body) = self.internal_rewrite_exp(body);
                self.rewrite_exit_scope(new_id);
                if let Some(new_exp) =
                    self.rewrite_quant(new_id, &new_ranges, &new_triggers, &new_cond, &new_body)
                {
                    new_exp
                } else if id_changed
                    || ranges_changed
                    || triggers_changed
                    || cond_changed
                    || body_changed
                {
                    Quant(new_id, *kind, new_ranges, new_triggers, new_cond, new_body).into_exp()
                } else {
                    exp
                }
            },
            IfElse(id, cond, then, else_) => {
                let (id_changed, new_id) = self.internal_rewrite_id(*id);
                let (cond_changed, new_cond) = self.internal_rewrite_exp(cond);
                let (then_changed, new_then) = self.internal_rewrite_exp(then);
                let (else_changed, new_else) = self.internal_rewrite_exp(else_);
                if let Some(new_exp) = self.rewrite_if_else(new_id, &new_cond, &new_then, &new_else)
                {
                    new_exp
                } else if id_changed || cond_changed || then_changed || else_changed {
                    IfElse(new_id, new_cond, new_then, new_else).into_exp()
                } else {
                    exp
                }
            },
            Match(id, disc, arms) => {
                let (id_changed, new_id) = self.internal_rewrite_id(*id);
                let (disc_changed, new_disc) = self.internal_rewrite_exp(disc);

                let (mut arms_changed, mut new_arms) = (false, vec![]);
                for arm in arms {
                    let (pat_changed, new_pat) = self.internal_rewrite_pattern(&arm.pattern, true);
                    let optional_pat = self.rewrite_enter_block_scope(new_id, &new_pat, &None);
                    let (cond_changed, new_cond) = if let Some(c) = &arm.condition {
                        let (c, e) = self.internal_rewrite_exp(c);
                        (c, Some(e))
                    } else {
                        (false, None)
                    };
                    let (body_changed, new_body) = self.internal_rewrite_exp(&arm.body);
                    self.rewrite_exit_scope(new_id);
                    let (pat_changed, newer_pat) = if let Some(rewritten_pat) = optional_pat {
                        (true, rewritten_pat)
                    } else {
                        (pat_changed, new_pat)
                    };
                    let (arm_changed, new_arm) = if let Some(new_exp) =
                        self.rewrite_match_arm(new_id, &arm.loc, &newer_pat, &new_cond, &new_body)
                    {
                        (true, new_exp)
                    } else {
                        (false, MatchArm {
                            loc: arm.loc.clone(),
                            pattern: newer_pat,
                            condition: new_cond,
                            body: new_body,
                        })
                    };
                    new_arms.push(new_arm);
                    arms_changed =
                        arms_changed || arm_changed || pat_changed || cond_changed || body_changed;
                }
                if let Some(new_exp) = self.rewrite_match(new_id, &new_disc, &new_arms) {
                    new_exp
                } else if id_changed || disc_changed || arms_changed {
                    Match(new_id, new_disc, new_arms).into_exp()
                } else {
                    exp
                }
            },
            Sequence(id, es) => {
                let (id_changed, new_id) = self.internal_rewrite_id(*id);
                let changed_vec = self.internal_rewrite_vec(es);
                let vec_changed = changed_vec.is_some();
                let new_vec = changed_vec.unwrap_or_else(|| es.clone());
                if let Some(new_exp) = self.rewrite_sequence(new_id, &new_vec) {
                    new_exp
                } else if id_changed || vec_changed {
                    Sequence(new_id, new_vec).into_exp()
                } else {
                    exp
                }
            },
            Loop(id, body) => {
                let (id_changed, new_id) = self.internal_rewrite_id(*id);
                let (body_changed, new_body) = self.internal_rewrite_exp(body);
                if id_changed || body_changed {
                    Loop(new_id, new_body).into_exp()
                } else {
                    exp
                }
            },
            LoopCont(id, nest, do_cont) => {
                let (id_changed, new_id) = self.internal_rewrite_id(*id);
                if id_changed {
                    LoopCont(new_id, *nest, *do_cont).into_exp()
                } else {
                    exp
                }
            },
            Return(id, val) => {
                let (id_changed, new_id) = self.internal_rewrite_id(*id);
                let (val_changed, new_val) = self.internal_rewrite_exp(val);
                if id_changed || val_changed {
                    Return(new_id, new_val).into_exp()
                } else {
                    exp
                }
            },
            Assign(id, lhs, rhs) => {
                let (id_changed, new_id) = self.internal_rewrite_id(*id);
                let (rhs_changed, new_rhs) = self.internal_rewrite_exp(rhs);
                let (lhs_changed, new_lhs) = self.internal_rewrite_pattern(lhs, false);
                if let Some(new_exp) = self.rewrite_assign(new_id, &new_lhs, &new_rhs) {
                    new_exp
                } else if id_changed || lhs_changed || rhs_changed {
                    Assign(new_id, new_lhs, new_rhs).into_exp()
                } else {
                    exp
                }
            },
            Mutate(id, lhs, rhs) => {
                let (id_changed, new_id) = self.internal_rewrite_id(*id);
                let (rhs_changed, new_rhs) = self.internal_rewrite_exp(rhs);
                let (lhs_changed, new_lhs) = self.internal_rewrite_exp(lhs);
                if id_changed || lhs_changed || rhs_changed {
                    Mutate(new_id, new_lhs, new_rhs).into_exp()
                } else {
                    exp
                }
            },
            SpecBlock(id, spec) => {
                let (id_changed, new_id) = self.internal_rewrite_id(*id);
                let (spec_changed, new_spec) =
                    self.rewrite_spec_descent(&SpecBlockTarget::Inline, spec);
                if id_changed || spec_changed {
                    SpecBlock(new_id, new_spec).into_exp()
                } else {
                    exp
                }
            },
            // This can happen since we are calling the rewriter during type checking, and
            // we may have encountered an error which is represented as an Invalid expression.
            Invalid(id) => Invalid(*id).into_exp(),
        }
    }
```
