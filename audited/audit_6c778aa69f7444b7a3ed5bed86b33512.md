# Audit Report

## Title
Race Condition in Block Pruning Error Propagation Leading to Incorrect HTTP Status Code

## Summary
The `get_block_by_height()` function in `api/src/context.rs` contains a race condition where database errors from pruned blocks are incorrectly masked as "404 Not Found" instead of "410 Gone", violating the documented API contract. While this does not expose pruned data or cause panics, it represents a state inconsistency that can confuse API clients.

## Finding Description

The API endpoint documentation explicitly states that requests for pruned blocks should return HTTP 410 (Gone). [1](#0-0) 

However, the implementation in `get_block_by_height()` performs a Time-of-Check-Time-of-Use (TOCTOU) race condition:

1. The function first checks if the requested block height is below `oldest_block_height` from cached ledger info [2](#0-1) 

2. If the pruner runs between this check and the database access, the subsequent database call will fail because the block events have been deleted

3. The error handling uses `.map_err(|_| ...)` which **discards the actual error** and always converts it to a 404 Not Found error [3](#0-2) 

The same issue exists in `get_block_by_version()` [4](#0-3) 

**No Data Exposure:** The function returns errors, not pruned data, so there is no data exposure risk.

**No Panic Risk:** All errors are properly handled with `?` operators and `.map_err()`, so no panics occur.

## Impact Explanation

This is a **Medium severity** issue under the "State inconsistencies requiring intervention" category. While it doesn't cause direct security harm (no funds loss, no consensus violation), it creates an API contract violation that can cause:

1. **Client Confusion**: Clients expecting 410 for pruned blocks receive 404, potentially treating it as "never existed" rather than "existed but was pruned"
2. **Incorrect Retry Logic**: Clients may implement exponential backoff for 404s thinking the block might appear later, when it's actually permanently pruned
3. **Monitoring/Alerting Issues**: Systems monitoring for pruning may miss instances where blocks were incorrectly reported as not found

The documented error response function confirms 410 should be returned for pruned blocks. [5](#0-4) 

## Likelihood Explanation

**Likelihood: Low to Medium**

The race condition window is small (milliseconds to seconds depending on pruner frequency), but:
- Pruning runs periodically based on configuration [6](#0-5) 
- High-traffic APIs with many concurrent requests increase probability
- The issue is deterministic once the race condition is hit
- No test coverage exists for the 410 behavior, suggesting this bug may already be occurring in production

## Recommendation

Replace the generic `.map_err(|_| ...)` with proper error inspection that preserves pruning errors:

```rust
pub fn get_block_by_height<E: StdApiError>(
    &self,
    height: u64,
    latest_ledger_info: &LedgerInfo,
    with_transactions: bool,
) -> Result<BcsBlock, E> {
    if height < latest_ledger_info.oldest_block_height.0 {
        return Err(block_pruned_by_height(height, latest_ledger_info));
    } else if height > latest_ledger_info.block_height.0 {
        return Err(block_not_found_by_height(height, latest_ledger_info));
    }

    let (first_version, last_version, new_block_event) = self
        .db
        .get_block_info_by_height(height)
        .map_err(|err| {
            // Check if error is due to pruning
            if err.to_string().contains("pruned") {
                block_pruned_by_height(height, latest_ledger_info)
            } else {
                block_not_found_by_height(height, latest_ledger_info)
            }
        })?;
    
    // ... rest of function
}
```

Apply the same fix to `get_block_by_version()`.

Additionally, add proper test coverage for the 410 status code as it's currently missing from the test suite. [7](#0-6) 

## Proof of Concept

```rust
#[tokio::test]
async fn test_get_pruned_block_returns_410() {
    let mut context = new_test_context(current_function_name!());
    
    // Generate multiple blocks
    for _ in 0..100 {
        context.commit_genesis_transaction().await;
    }
    
    // Trigger pruning to make block 0 pruned
    context.prune_to_block_height(50).await;
    
    // Request block 0 should return 410 Gone
    let resp = context
        .expect_status_code(410)
        .get("/blocks/by_height/0")
        .await;
    
    let error: AptosError = resp.json().await;
    assert_eq!(error.error_code, AptosErrorCode::BlockPruned);
}
```

**Note**: The current implementation will fail this test by returning 404 instead of 410 when the race condition is triggered.

### Citations

**File:** api/src/blocks.rs (L35-35)
```rust
    /// If the block is pruned, it will return a 410
```

**File:** api/src/context.rs (L634-635)
```rust
        if height < latest_ledger_info.oldest_block_height.0 {
            return Err(block_pruned_by_height(height, latest_ledger_info));
```

**File:** api/src/context.rs (L640-643)
```rust
        let (first_version, last_version, new_block_event) = self
            .db
            .get_block_info_by_height(height)
            .map_err(|_| block_not_found_by_height(height, latest_ledger_info))?;
```

**File:** api/src/context.rs (L666-669)
```rust
        let (first_version, last_version, new_block_event) = self
            .db
            .get_block_info_by_version(version)
            .map_err(|_| block_not_found_by_version(version, latest_ledger_info))?;
```

**File:** api/src/response.rs (L786-792)
```rust
pub fn block_pruned_by_height<E: GoneError>(block_height: u64, ledger_info: &LedgerInfo) -> E {
    E::gone_with_code(
        format!("Block({}) has been pruned", block_height),
        AptosErrorCode::BlockPruned,
        ledger_info,
    )
}
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L336-338)
```rust
    fn get_first_viable_block(&self) -> Result<(Version, BlockHeight)> {
        gauged_api("get_first_viable_block", || {
            let min_version = self.ledger_pruner.get_min_viable_version();
```

**File:** api/src/tests/blocks_test.rs (L1-28)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use super::new_test_context;
use aptos_api_test_context::current_function_name;

#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
async fn test_get_genesis_block_by_height() {
    let mut context = new_test_context(current_function_name!());

    let resp = context.get(&blocks_by_height(0)).await;
    context.check_golden_output(resp);
}

#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
async fn test_get_unknown_block_by_height() {
    let mut context = new_test_context(current_function_name!());

    let resp = context
        .expect_status_code(404)
        .get(&blocks_by_height(1000))
        .await;
    context.check_golden_output(resp);
}

fn blocks_by_height(height: u64) -> String {
    format!("/blocks/by_height/{}", height)
}
```
