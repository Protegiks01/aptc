# Audit Report

## Title
Chain ID Validation Bypass in Indexer gRPC Manager Allows Cross-Chain Data Corruption

## Summary
The indexer-grpc-manager accepts arbitrary chain_id values from configuration without validation against known chain IDs or verification against connected fullnodes' chain IDs. This allows an indexer to process and serve transaction data from a different blockchain network than intended, causing cross-chain data corruption.

## Finding Description

The vulnerability exists in the indexer-grpc-manager's initialization and data processing flow:

**1. No Chain ID Whitelist Validation at Initialization**

The `GrpcManager::new()` function accepts the chain_id directly from configuration without validating it against known chain IDs (MAINNET=1, TESTNET=2, DEVNET=3, etc.): [1](#0-0) 

This chain_id is passed to FileStoreUploader and DataManager without any validation that it represents a legitimate Aptos network.

**2. No Chain ID Validation Against Fullnode Responses**

When the DataManager receives transaction data from fullnodes, it processes the responses without validating that the fullnode's chain_id matches the indexer's configured chain_id: [2](#0-1) 

Similarly, in the fullnode fallback path, responses are accepted without chain_id validation: [3](#0-2) 

**3. No Chain ID Validation in Metadata Manager**

When the MetadataManager receives FullnodeInfo (which includes the fullnode's chain_id), it stores this information without verifying it matches the indexer's configured chain_id: [4](#0-3) 

**Contrast with Backfiller Implementation**

The indexer-grpc-v2-file-store-backfiller correctly validates chain_id in responses: [5](#0-4) 

This validation is **missing** in the indexer-grpc-manager.

**Attack Scenario:**

1. Operator misconfigures indexer-grpc-manager with `chain_id: 2` (testnet) in configuration
2. Operator accidentally points `fullnode_addresses` to mainnet fullnodes
3. FileStoreUploader initializes with chain_id=2 in metadata: [6](#0-5) 

4. DataManager receives mainnet transactions (chain_id=1) from fullnodes but stores them without validation
5. File store metadata shows chain_id=2, but contains mainnet transaction data
6. Clients querying this indexer receive mainnet data labeled as testnet data

## Impact Explanation

**Severity: High** (Significant Protocol Violations per Aptos Bug Bounty criteria)

This vulnerability causes:

- **Cross-Chain Data Corruption**: Transaction data from one chain is stored and served with incorrect chain_id metadata
- **Application-Level Impact**: Applications consuming indexer data make decisions based on wrong chain context, potentially leading to:
  - Incorrect token price calculations if mixing mainnet/testnet data
  - Wrong contract state interpretations
  - Invalid transaction replay attempts on wrong chains
- **Data Integrity Violation**: Breaks the fundamental guarantee that indexer data accurately represents a specific blockchain

While this doesn't directly cause consensus failures or fund theft at the blockchain layer, it violates critical data integrity guarantees that applications depend on, qualifying as a "Significant protocol violation" under High Severity criteria.

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability can occur through:

1. **Configuration Errors**: Operators accidentally specify wrong chain_id or fullnode addresses
2. **Intentional Misconfiguration**: Malicious indexer operators serving corrupted data to downstream clients
3. **Infrastructure Changes**: Fullnode endpoints changing from testnet to mainnet without corresponding indexer configuration updates

The likelihood is elevated because:
- No validation prevents this misconfiguration
- Configuration files are manually managed
- Multi-network deployments increase chance of cross-wiring
- Error is silent with no warnings or alerts

## Recommendation

Add chain_id validation at three critical points:

**1. Validate chain_id against known chains at initialization:**

```rust
// In grpc_manager.rs GrpcManager::new()
pub(crate) async fn new(config: &IndexerGrpcManagerConfig) -> Self {
    let chain_id = config.chain_id;
    
    // Validate against known chain IDs
    use aptos_types::chain_id::NamedChain;
    match chain_id {
        1 | 2 | 3 | 4 | 5 => {}, // Known chain IDs
        _ => {
            warn!("Unknown chain_id {}, ensure this is correct", chain_id);
        }
    }
    // ... rest of initialization
}
```

**2. Validate fullnode chain_id matches configured chain_id:**

```rust
// In metadata_manager.rs handle_fullnode_info()
fn handle_fullnode_info(&self, address: GrpcAddress, info: FullnodeInfo) -> Result<()> {
    // Validate chain_id matches
    if info.chain_id != self.chain_id {
        bail!(
            "Chain ID mismatch: fullnode {} reports chain_id={}, but indexer expects chain_id={}",
            address, info.chain_id, self.chain_id
        );
    }
    // ... rest of handling
}
```

**3. Validate chain_id in transaction responses:**

```rust
// In data_manager.rs when processing responses
match response_item {
    Ok(r) => {
        // Validate chain_id
        if r.chain_id != self.chain_id as u32 {
            warn!(
                "Received data from fullnode with chain_id={}, but expected chain_id={}. Skipping.",
                r.chain_id, self.chain_id
            );
            continue 'out;
        }
        // ... process data
    }
}
```

## Proof of Concept

**Configuration-Based PoC:**

1. Create indexer configuration file `indexer_config.yaml`:
```yaml
chain_id: 2  # Testnet
fullnode_addresses:
  - "https://mainnet-fullnode.example.com:50051"  # Mainnet fullnode
# ... other config
```

2. Start indexer-grpc-manager with this configuration

3. Observe that:
   - FileStoreMetadata written with chain_id=2: [7](#0-6) 
   
   - But transactions from mainnet (chain_id=1) are accepted and stored without validation
   
4. Query the indexer - it will serve mainnet data with testnet chain_id in metadata

**Verification Steps:**

```bash
# Check file store metadata
cat /path/to/filestore/metadata.json
# Shows: {"chain_id": 2, ...}

# Check fullnode ping response
# Fullnode returns chain_id: 1 in FullnodeInfo

# Check stored transactions
# Transactions are from mainnet but stored under testnet chain_id
```

The vulnerability is demonstrable without code execution - it's a configuration and validation logic issue that leads to silent data corruption.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/grpc_manager.rs (L31-32)
```rust
    pub(crate) async fn new(config: &IndexerGrpcManagerConfig) -> Self {
        let chain_id = config.chain_id;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L257-279)
```rust
                match response_item {
                    Ok(r) => {
                        if let Some(response) = r.response {
                            match response {
                                Response::Data(data) => {
                                    trace!(
                                        "Putting data into cache, {} transaction(s).",
                                        data.transactions.len()
                                    );
                                    self.cache.write().await.put_transactions(data.transactions);
                                },
                                Response::Status(_) => continue,
                            }
                        } else {
                            warn!("Error when getting transactions from fullnode: no data.");
                            continue 'out;
                        }
                    },
                    Err(e) => {
                        warn!("Error when getting transactions from fullnode: {}", e);
                        continue 'out;
                    },
                }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L313-322)
```rust
                    while let Some(Ok(response_item)) = response.next().await {
                        if let Some(response) = response_item.response {
                            match response {
                                Response::Data(data) => {
                                    return Ok(data.transactions);
                                },
                                Response::Status(_) => continue,
                            }
                        }
                    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L533-549)
```rust
    fn handle_fullnode_info(&self, address: GrpcAddress, info: FullnodeInfo) -> Result<()> {
        let mut entry = self
            .fullnodes
            .entry(address.clone())
            .or_insert(Fullnode::new(address.clone()));
        entry.value_mut().recent_states.push_back(info);
        if let Some(known_latest_version) = info.known_latest_version {
            trace!(
                "Received known_latest_version ({known_latest_version}) from fullnode {address}."
            );
            self.update_known_latest_version(known_latest_version);
        }
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
```

**File:** ecosystem/indexer-grpc/indexer-grpc-v2-file-store-backfiller/src/processor.rs (L176-176)
```rust
                                    assert!(r.chain_id == chain_id);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs (L53-57)
```rust
            let metadata = FileStoreMetadata {
                chain_id,
                num_transactions_per_folder: NUM_TXNS_PER_FOLDER,
                version: 0,
            };
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs (L262-268)
```rust
    async fn update_file_store_metadata(&self, version: u64) -> Result<()> {
        FILE_STORE_VERSION.set(version as i64);
        let metadata = FileStoreMetadata {
            chain_id: self.chain_id,
            num_transactions_per_folder: NUM_TXNS_PER_FOLDER,
            version,
        };
```
