# Audit Report

## Title
Gas Charge Bypass in Resource Group Validation When Lazy Loading is Disabled

## Summary
The `validate_resource_groups` function in `resource_groups.rs` contains a conditional gas charging mechanism that can be bypassed when the `ENABLE_LAZY_LOADING` feature flag is disabled, allowing attackers to access and deserialize external resource group modules without paying gas costs.

## Finding Description

In the resource group validation flow, there is a critical discrepancy between conditional gas charging and unconditional module access. [1](#0-0) 

The vulnerability occurs at lines 63-78 where gas charging happens ONLY if two conditions are met:
1. `features.is_lazy_loading_enabled()` returns true
2. `traversal_context.visit_if_not_special_module_id(&group_module_id)` returns true

However, at line 79-82, the module is ALWAYS accessed via `unmetered_get_existing_deserialized_module()` regardless of whether gas was charged.

**Attack Scenario:**

When lazy loading is disabled, the code flow is:
1. During module publishing, `charge_package_dependencies` is called [2](#0-1) 
2. This function charges for all transitive dependencies via `check_dependencies_and_charge_gas` [3](#0-2) 
3. However, a resource group module is NOT necessarily a dependency - a module can declare `#[resource_group_member(group = X::Module::Struct)]` without importing or depending on module X
4. Later, `validate_resource_groups` is called, which accesses the group module
5. Since `features.is_lazy_loading_enabled()` is false, NO gas is charged
6. The module is still deserialized and its metadata extracted

**Example:** An attacker publishes a module M with struct S annotated with `#[resource_group_member(group = 0x1::large_framework_module::Group)]` where `large_framework_module` is NOT an actual dependency of M. When lazy loading is disabled, M's dependencies are charged, but `large_framework_module` is accessed without charge during validation.

This breaks the critical invariant: **"Resource Limits: All operations must respect gas, storage, and computational limits."** The comment at lines 61-62 explicitly states "we need to charge gas because this module is not in a bundle," yet gas charging is conditional on a feature flag.

## Impact Explanation

**Severity: Medium to High**

While lazy loading is enabled by default on mainnet [4](#0-3) , this vulnerability represents a critical defensive programming failure:

1. **Resource Exhaustion**: If lazy loading is disabled, attackers can publish small modules that reference large framework modules as resource groups, forcing validator nodes to deserialize large modules without paying proportional gas costs. This can cause validator slowdowns (High severity per bug bounty).

2. **Latent Vulnerability**: The feature flag CAN be disabled (not marked permanent like some flags). If there's ever a rollback, bug, or governance decision to disable lazy loading, this becomes immediately exploitable across the network.

3. **Code Comment Violation**: The explicit comment stating gas "needs to be charged" indicates this is a required security property, not an optional optimization.

## Likelihood Explanation

**Likelihood: Low to Medium**

- **Current Production**: Low - lazy loading is enabled by default and included in default features
- **Risk Scenarios**: Medium - vulnerable if:
  - Feature flag is disabled via governance proposal
  - Rollback scenario requires disabling lazy loading  
  - Bug causes lazy loading to malfunction
  - Test/staging environments with lazy loading disabled connect to production data

The vulnerability exists in the codebase today and would become exploitable immediately if the configuration changes.

## Recommendation

**Fix:** Make gas charging unconditional for external module access. The code should defensively charge gas regardless of lazy loading state when accessing modules that are not in the published bundle.

Modify lines 63-78 to separate the "visited" check (for deduplication) from the gas charging requirement:

```rust
if !groups.contains_key(&group_module_id) {
    // Note: module must exist for the group member to refer to it! Also, we need to
    // charge gas because this module is not in a bundle.
    let size = module_storage.unmetered_get_existing_module_size(
        group_module_id.address(),
        group_module_id.name(),
    )?;
    
    // ALWAYS charge gas for external module access, regardless of lazy loading
    let should_charge = if features.is_lazy_loading_enabled() {
        traversal_context.visit_if_not_special_module_id(&group_module_id)
    } else {
        !group_module_id.address().is_special()
    };
    
    if should_charge {
        gas_meter
            .charge_dependency(
                DependencyKind::Existing,
                group_module_id.address(),
                group_module_id.name(),
                NumBytes::new(size as u64),
            )
            .map_err(|err| err.finish(Location::Undefined))?;
    }
    
    let old_module = module_storage.unmetered_get_existing_deserialized_module(
        group_module_id.address(),
        group_module_id.name(),
    )?;
    // ... rest of code
}
```

## Proof of Concept

```rust
// Test scenario: Publish module with resource_group_member referencing external module
// when lazy loading is disabled

#[test]
fn test_resource_group_gas_bypass_when_lazy_loading_disabled() {
    let mut h = MoveHarness::new();
    
    // Disable lazy loading feature flag
    h.disable_feature(FeatureFlag::ENABLE_LAZY_LOADING);
    
    // Create a small module that references a large framework module as resource group
    let module_source = r#"
    module 0xCAFE::exploit {
        use std::signer;
        
        // Reference large framework module without depending on it
        #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
        struct ExploitResource has key {
            value: u64
        }
        
        public entry fun publish_resource(account: &signer) {
            move_to(account, ExploitResource { value: 42 });
        }
    }
    "#;
    
    let account = h.new_account_at(AccountAddress::from_hex_literal("0xCAFE").unwrap());
    
    // Measure gas used - should charge for object module but won't when bug exists
    let result = h.run_transaction_payload(
        &account,
        aptos_cached_packages::aptos_stdlib::code_publish_package_txn(
            bcs::to_bytes(&PackageMetadata::default()).unwrap(),
            vec![module_source.as_bytes().to_vec()],
        ),
    );
    
    // With the bug: gas charged only for exploit module, not for object module access
    // Without the bug: gas should include object module deserialization cost
    assert_success!(result);
    
    // The gas charged would be significantly less than it should be,
    // allowing repeated exploitation to exhaust validator resources
}
```

## Notes

This vulnerability demonstrates a **defensive programming failure** where critical security properties (gas metering) are made conditional on feature flags rather than being enforced unconditionally. While currently mitigated by the default configuration, the code should be robust to configuration changes. The explicit comment indicating gas must be charged, combined with conditional implementation, represents a mismatch between intent and implementation that could lead to exploitation under specific circumstances.

### Citations

**File:** aptos-move/aptos-vm/src/verifier/resource_groups.rs (L60-87)
```rust
            if !groups.contains_key(&group_module_id) {
                // Note: module must exist for the group member to refer to it! Also, we need to
                // charge gas because this module is not in a bundle.
                if features.is_lazy_loading_enabled()
                    && traversal_context.visit_if_not_special_module_id(&group_module_id)
                {
                    let size = module_storage.unmetered_get_existing_module_size(
                        group_module_id.address(),
                        group_module_id.name(),
                    )?;
                    gas_meter
                        .charge_dependency(
                            DependencyKind::Existing,
                            group_module_id.address(),
                            group_module_id.name(),
                            NumBytes::new(size as u64),
                        )
                        .map_err(|err| err.finish(Location::Undefined))?;
                }
                let old_module = module_storage.unmetered_get_existing_deserialized_module(
                    group_module_id.address(),
                    group_module_id.name(),
                )?;

                let (inner_groups, _, _) =
                    extract_resource_group_metadata_from_module(&old_module)?;
                groups.insert(group_tag.module_id(), inner_groups);
            }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1616-1630)
```rust
        if !self.features().is_lazy_loading_enabled() {
            check_dependencies_and_charge_gas(
                module_storage,
                gas_meter,
                traversal_context,
                modules
                    .iter()
                    .flat_map(|module| {
                        module
                            .immediate_dependencies_iter()
                            .chain(module.immediate_friends_iter())
                    })
                    .filter(|addr_and_name| !module_ids_in_bundle.contains(addr_and_name)),
            )?;
            return Ok(());
```

**File:** third_party/move/move-vm/runtime/src/storage/dependencies_gas_charging.rs (L62-108)
```rust
pub fn check_dependencies_and_charge_gas<'a, I>(
    module_storage: &impl ModuleStorage,
    gas_meter: &mut impl DependencyGasMeter,
    traversal_context: &mut TraversalContext<'a>,
    ids: I,
) -> VMResult<()>
where
    I: IntoIterator<Item = (&'a AccountAddress, &'a IdentStr)>,
    I::IntoIter: DoubleEndedIterator,
{
    let _timer = VM_TIMER.timer_with_label("check_dependencies_and_charge_gas");

    // Initialize the work list (stack) and the map of visited modules.
    //
    // TODO: Determine the reserved capacity based on the max number of dependencies allowed.
    let mut stack = Vec::with_capacity(512);
    traversal_context.push_next_ids_to_visit(&mut stack, ids);

    while let Some((addr, name)) = stack.pop() {
        let size = module_storage.unmetered_get_existing_module_size(addr, name)?;
        gas_meter
            .charge_dependency(
                DependencyKind::Existing,
                addr,
                name,
                NumBytes::new(size as u64),
            )
            .map_err(|err| err.finish(Location::Module(ModuleId::new(*addr, name.to_owned()))))?;

        // Extend the lifetime of the module to the remainder of the function body
        // by storing it in an arena.
        //
        // This is needed because we need to store references derived from it in the
        // work list.
        let compiled_module =
            module_storage.unmetered_get_existing_deserialized_module(addr, name)?;
        let compiled_module = traversal_context.referenced_modules.alloc(compiled_module);

        // Explore all dependencies and friends that have been visited yet.
        let imm_deps_and_friends = compiled_module
            .immediate_dependencies_iter()
            .chain(compiled_module.immediate_friends_iter());
        traversal_context.push_next_ids_to_visit(&mut stack, imm_deps_and_friends);
    }

    Ok(())
}
```

**File:** types/src/on_chain_config/aptos_features.rs (L266-266)
```rust
            FeatureFlag::ENABLE_LAZY_LOADING,
```
