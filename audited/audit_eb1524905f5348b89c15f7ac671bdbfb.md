# Audit Report

## Title
Unbounded Channel Memory Exhaustion via Byzantine Validator Secret Share Request Flooding

## Summary
The `verification_task()` function in the secret sharing manager uses an unbounded channel to queue verified messages, allowing a Byzantine validator to cause memory exhaustion by flooding the system with valid-but-excessive `RequestShare` messages that pass weak verification checks but accumulate faster than they can be processed downstream.

## Finding Description

The vulnerability exists in the message verification pipeline for secret sharing in consensus: [1](#0-0) 

The verification flow creates a critical bottleneck:

1. **Weak Verification for RequestShare**: The `verify()` method only checks epoch for `RequestShare` messages, performing no round validation or rate limiting: [2](#0-1) 

2. **Unbounded Queue**: Verified messages are sent to an unbounded channel at line 221, with no backpressure mechanism: [3](#0-2) 

3. **Pipeline Imbalance**: Multiple concurrent verifications (default 16 via `bounded_executor`) can process messages faster than single-threaded downstream consumption: [4](#0-3) [5](#0-4) 

**Attack Scenario:**

A Byzantine validator crafts thousands of `RequestShare` messages with:
- Valid epoch (passes verification)
- Various rounds (current, current+1, current+2, etc. up to `FUTURE_ROUNDS_TO_ACCEPT` = 200) [6](#0-5) 

Each message:
1. Arrives at the bounded per-sender channel (capacity 10): [7](#0-6) 

2. Gets consumed and spawned as verification task
3. Passes fast epoch-only verification
4. Accumulates in unbounded `verified_msg_tx` channel
5. Eventually processed downstream where many fail validation (invalid round, no share available)

The bounded executor and per-sender channel provide insufficient protection because:
- Verification tasks complete quickly (epoch check only)
- Each completion frees executor/channel capacity for more messages
- The unbounded channel between verification and processing allows unlimited accumulation

## Impact Explanation

This vulnerability achieves **High Severity** under Aptos bug bounty criteria:

- **Validator node slowdowns**: Memory pressure from unbounded queue accumulation degrades validator performance
- **API crashes**: Severe memory exhaustion can crash the validator node entirely

The attack breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." The unbounded channel violates memory constraints by allowing unlimited message queueing without backpressure.

A single Byzantine validator can target multiple honest validators simultaneously, degrading consensus network availability without requiring >1/3 Byzantine collusion.

## Likelihood Explanation

**High Likelihood:**

- **Low Complexity**: Attack requires only crafting messages with valid epoch and incrementing rounds
- **Single Attacker**: Only one Byzantine validator needed (well below 1/3 BFT threshold)
- **No Special Privileges**: Any validator can send secret share requests
- **Difficult Detection**: Messages pass verification legitimately, appearing as normal traffic initially
- **Guaranteed Impact**: With default config (16 concurrent verifications, unbounded channel), memory accumulation is inevitable under sustained flooding

The only prerequisite is being a validator in the active set, which is within the BFT threat model.

## Recommendation

Implement bounded channels with backpressure throughout the verification pipeline:

1. **Replace unbounded channel** with bounded channel for verified messages:
```rust
// In SecretShareManager::start()
let (verified_msg_tx, mut verified_msg_rx) = 
    aptos_channel::new::<(), SecretShareRpc>(
        QueueStyle::KLAST,
        self.config.internal_per_key_channel_size,
        None,
    );
```

2. **Add round validation in RequestShare verification**:
```rust
// In SecretShareMessage::verify()
match self {
    SecretShareMessage::RequestShare(request) => {
        ensure!(
            request.metadata().round <= 
            highest_known_round + FUTURE_ROUNDS_TO_ACCEPT,
            "Request from invalid future round"
        );
        Ok(())
    },
    SecretShareMessage::Share(share) => share.verify(config),
}
```

3. **Implement per-peer rate limiting** on verified messages to prevent single validator flooding.

## Proof of Concept

```rust
#[tokio::test]
async fn test_secret_share_request_flooding() {
    use futures_channel::mpsc::unbounded;
    use aptos_bounded_executor::BoundedExecutor;
    
    // Setup test environment
    let (incoming_tx, incoming_rx) = aptos_channel::new(
        QueueStyle::KLAST, 10, None
    );
    let (verified_tx, mut verified_rx) = unbounded();
    let bounded_executor = BoundedExecutor::new(16, 
        tokio::runtime::Handle::current());
    
    // Spawn verification task
    let verification_handle = tokio::spawn(
        SecretShareManager::verification_task(
            epoch_state, incoming_rx, verified_tx, 
            config, bounded_executor
        )
    );
    
    // Byzantine validator floods with requests
    let current_epoch = 1;
    for round in 0..10000 {
        let metadata = SecretShareMetadata::new(
            current_epoch, round, 0, HashValue::zero(), 
            Digest::default()
        );
        let request = SecretShareMessage::RequestShare(
            RequestSecretShare::new(metadata)
        );
        let msg = IncomingSecretShareRequest {
            req: request, /* ... */
        };
        incoming_tx.push(sender_addr, msg);
    }
    
    // Verify unbounded accumulation
    tokio::time::sleep(Duration::from_secs(5)).await;
    
    let mut count = 0;
    while verified_rx.try_next().is_ok() {
        count += 1;
    }
    
    // Demonstrates thousands of messages queued
    assert!(count > 5000, 
        "Unbounded channel accumulated {} messages", count);
}
```

## Notes

This vulnerability specifically affects the secret sharing subsystem in consensus randomness generation. The weak verification for `RequestShare` combined with the unbounded channel creates a memory exhaustion vector exploitable by any Byzantine validator. The fix requires both strengthening verification checks and adding proper backpressure mechanisms throughout the pipeline.

### Citations

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L205-235)
```rust
    async fn verification_task(
        epoch_state: Arc<EpochState>,
        mut incoming_rpc_request: aptos_channel::Receiver<Author, IncomingSecretShareRequest>,
        verified_msg_tx: UnboundedSender<SecretShareRpc>,
        config: SecretShareConfig,
        bounded_executor: BoundedExecutor,
    ) {
        while let Some(dec_msg) = incoming_rpc_request.next().await {
            let tx = verified_msg_tx.clone();
            let epoch_state_clone = epoch_state.clone();
            let config_clone = config.clone();
            bounded_executor
                .spawn(async move {
                    match bcs::from_bytes::<SecretShareMessage>(dec_msg.req.data()) {
                        Ok(msg) => {
                            if msg.verify(&epoch_state_clone, &config_clone).is_ok() {
                                let _ = tx.unbounded_send(SecretShareRpc {
                                    msg,
                                    protocol: dec_msg.protocol,
                                    response_sender: dec_msg.response_sender,
                                });
                            }
                        },
                        Err(e) => {
                            warn!("Invalid dec message: {}", e);
                        },
                    }
                })
                .await;
        }
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L333-333)
```rust
        let (verified_msg_tx, mut verified_msg_rx) = unbounded();
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L354-376)
```rust
            tokio::select! {
                Some(blocks) = incoming_blocks.next() => {
                    self.process_incoming_blocks(blocks).await;
                }
                Some(reset) = reset_rx.next() => {
                    while matches!(incoming_blocks.try_next(), Ok(Some(_))) {}
                    self.process_reset(reset);
                }
                Some(secret_shared_key) = self.decision_rx.next() => {
                    self.process_aggregated_key(secret_shared_key);
                }
                Some(request) = verified_msg_rx.next() => {
                    self.handle_incoming_msg(request);
                }
                _ = interval.tick().fuse() => {
                    self.observe_queue();
                },
            }
            let maybe_ready_blocks = self.block_queue.dequeue_ready_prefix();
            if !maybe_ready_blocks.is_empty() {
                self.process_ready_blocks(maybe_ready_blocks);
            }
        }
```

**File:** consensus/src/rand/secret_sharing/network_messages.rs (L28-38)
```rust
    pub fn verify(
        &self,
        epoch_state: &EpochState,
        config: &SecretShareConfig,
    ) -> anyhow::Result<()> {
        ensure!(self.epoch() == epoch_state.epoch);
        match self {
            SecretShareMessage::RequestShare(_) => Ok(()),
            SecretShareMessage::Share(share) => share.verify(config),
        }
    }
```

**File:** config/src/config/consensus_config.rs (L379-379)
```rust
            num_bounded_executor_tasks: 16,
```

**File:** consensus/src/rand/secret_sharing/types.rs (L16-16)
```rust
pub const FUTURE_ROUNDS_TO_ACCEPT: u64 = 200;
```

**File:** consensus/src/epoch_manager.rs (L1285-1290)
```rust
        let (secret_share_manager_tx, secret_share_manager_rx) =
            aptos_channel::new::<AccountAddress, IncomingSecretShareRequest>(
                QueueStyle::KLAST,
                self.config.internal_per_key_channel_size,
                None,
            );
```
