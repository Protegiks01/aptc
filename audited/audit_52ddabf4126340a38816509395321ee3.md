# Audit Report

## Title
Migration Control Bypass via Direct `fungible_transfer_only` Entry Function Call

## Summary
The `fungible_transfer_only` function in `aptos_account.move` is marked as `public(friend) entry`, making it callable by any user via transactions, yet it does not check the `operations_default_to_fa_apt_store_enabled()` feature flag. This allows users to bypass governance-controlled migration settings and force Fungible Asset (FA) operations even when the system is configured to use legacy Coin stores, creating a protocol violation and potential state inconsistencies.

## Finding Description

The Aptos blockchain is undergoing migration from the legacy Coin framework to the Fungible Asset (FA) framework for APT. This migration is controlled by the `OPERATIONS_DEFAULT_TO_FA_APT_STORE` feature flag (flag #65), which determines whether operations should default to FA or Coin implementations.

The `transfer()` function properly respects this flag: [1](#0-0) 

However, the `fungible_transfer_only()` function bypasses this check entirely: [2](#0-1) 

The function is marked `public(friend) entry`, which has two critical implications:
1. The `entry` modifier makes it callable as a transaction entry point by ANY user
2. It operates directly on FA stores without checking the migration flag

The function's documentation indicates it should be used "internally once migration of APT to FungibleAsset is complete": [3](#0-2) 

Despite this comment suggesting internal-only use, the function is already publicly callable via the SDK: [4](#0-3) 

The same bypass exists in the native executor benchmark code where `FaTransfer` transactions directly call FA functions without checking `fa_migration_complete`: [5](#0-4) 

Compare this to the `Transfer` transaction handler which properly checks the flag: [6](#0-5) 

**Attack Scenario:**
1. Governance disables the `OPERATIONS_DEFAULT_TO_FA_APT_STORE` flag (e.g., for emergency rollback or controlled migration)
2. The expectation is that all APT operations use CoinStore
3. An attacker calls `0x1::aptos_account::fungible_transfer_only(recipient, amount)` directly
4. This bypasses the flag check and operates on FA stores
5. System now has mixed state with some operations on Coin, others on FA
6. This violates the governance-intended migration control

The feature flag is enabled by default in production: [7](#0-6) 

However, it CAN be disabled via governance for emergency situations or controlled rollback, and when disabled, this bypass allows circumventing the intended control.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty criteria for the following reasons:

1. **Significant Protocol Violation**: The vulnerability bypasses a governance-controlled feature flag that is fundamental to the Coin-to-FA migration process. This undermines the governance mechanism's ability to control critical protocol changes.

2. **State Inconsistencies**: During migration periods or emergency rollbacks, the system can enter an inconsistent state where:
   - Some operations follow the governance-set flag (using CoinStore)
   - Other operations bypass the flag (using FungibleStore)
   - Accounts may have balances split across both systems unexpectedly
   - Accounting and balance tracking becomes unreliable

3. **Migration Control Bypass**: The migration from Coin to FA is a critical protocol upgrade. The ability to bypass the migration control flag undermines the safety mechanisms designed to ensure a smooth, controlled transition.

During the migration period, accounts can have both CoinStore and FungibleStore resources: [8](#0-7) 

This dual-state scenario combined with the bypass creates significant operational risks.

## Likelihood Explanation

**Likelihood: Medium to High**

The vulnerability is highly likely to be exploited because:

1. **Easy to Execute**: Any user can call the function with a simple transaction - no special privileges required
2. **Publicly Documented**: The SDK includes `aptos_stdlib::aptos_account_fungible_transfer_only()` making it easily discoverable
3. **Production Usage**: The function is already being used in production systems and tests
4. **Economic Incentive**: During migration rollbacks or emergency situations, attackers could exploit the inconsistent state to manipulate balances or create accounting discrepancies

The main factor reducing immediate likelihood is that the flag is currently enabled by default. However:
- Governance CAN disable it at any time for legitimate reasons
- Emergency situations requiring rollback could trigger exploitation
- The vulnerability exists NOW and will persist unless fixed

## Recommendation

**Immediate Fix**: Add feature flag check to `fungible_transfer_only()`:

```move
public(friend) entry fun fungible_transfer_only(
    source: &signer, to: address, amount: u64
) {
    // Add this check at the start of the function
    assert!(
        features::operations_default_to_fa_apt_store_enabled(),
        error::invalid_state(EMIGRATION_NOT_COMPLETE)
    );
    
    let sender_store =
        ensure_primary_fungible_store_exists(signer::address_of(source));
    let recipient_store = ensure_primary_fungible_store_exists(to);
    
    fungible_asset::withdraw_permission_check_by_address(
        source, sender_store, amount
    );
    fungible_asset::unchecked_deposit(
        recipient_store, fungible_asset::unchecked_withdraw(sender_store, amount)
    );
}
```

**Alternative Fix**: If the function is meant to be available before migration completion, change visibility from `public(friend) entry` to just `public(friend)` (removing `entry`) and only make it `entry` after migration is complete via a governance proposal.

**Native Executor Fix**: Update the native executor to check `fa_migration_complete` before allowing `FaTransfer` transactions:

```rust
NativeTransaction::FaTransfer {
    sender,
    sequence_number,
    recipient,
    amount,
} => {
    // Add migration check
    if !fa_migration_complete {
        bail!("FaTransfer not allowed when fa_migration_complete is false");
    }
    
    self.update_sequence_number(sender, sequence_number, state_view, &mut output)?;
    self.withdraw_fa_apt_from_signer(sender, amount, gas, state_view, &mut output)?;
    let _existed = self.deposit_fa_apt(recipient, amount, state_view, &mut output)?;
},
```

## Proof of Concept

```move
#[test(framework = @0x1, user1 = @0x123, user2 = @0x456)]
public fun test_fungible_transfer_bypass(
    framework: &signer,
    user1: &signer, 
    user2: &signer
) {
    use aptos_framework::aptos_account;
    use aptos_framework::features;
    use aptos_framework::coin;
    use aptos_framework::aptos_coin::AptosCoin;
    
    // Initialize framework and create accounts with APT
    let (burn_cap, mint_cap) = aptos_framework::aptos_coin::initialize_for_test(framework);
    aptos_account::create_account(signer::address_of(user1));
    aptos_account::create_account(signer::address_of(user2));
    coin::deposit(signer::address_of(user1), coin::mint(10000, &mint_cap));
    
    // Manually migrate user1 to have FA store
    coin::migrate_to_fungible_store<AptosCoin>(user1);
    
    // DISABLE the operations_default_to_fa flag - system should use CoinStore
    features::change_feature_flags(
        framework, 
        vector[], 
        vector[features::get_operations_default_to_fa_apt_store_feature()]
    );
    
    // Verify flag is disabled
    assert!(!features::operations_default_to_fa_apt_store_enabled(), 1);
    
    // Normal transfer() would use CoinStore (respects flag)
    // But we can BYPASS by calling fungible_transfer_only directly
    aptos_account::fungible_transfer_only(user1, signer::address_of(user2), 1000);
    
    // This succeeds even though flag says to use Coin! Bypass confirmed.
    // user2 now has FA store despite flag being disabled
    
    coin::destroy_burn_cap(burn_cap);
    coin::destroy_mint_cap(mint_cap);
}
```

## Notes

This vulnerability affects both the production Move framework and the native executor benchmark code. While the flag is currently enabled by default, the bypass undermines governance's ability to control the migration process during emergency situations or rollback scenarios. The discrepancy between the function's documentation (suggesting internal use) and its actual visibility (`public(friend) entry` making it publicly callable) indicates a design oversight during the migration implementation.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L87-96)
```text
        if (features::operations_default_to_fa_apt_store_enabled()) {
            fungible_transfer_only(source, to, amount)
        } else {
            // Resource accounts can be created without registering them to receive APT.
            // This conveniently does the registration if necessary.
            if (!coin::is_account_registered<AptosCoin>(to)) {
                coin::register<AptosCoin>(&create_signer(to));
            };
            coin::transfer<AptosCoin>(source, to, amount)
        }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L279-285)
```text
    /// APT Primary Fungible Store specific specialized functions,
    /// Utilized internally once migration of APT to FungibleAsset is complete.

    /// Convenient function to transfer APT to a recipient account that might not exist.
    /// This would create the recipient APT PFS first, which also registers it to receive APT, before transferring.
    /// TODO: once migration is complete, rename to just "transfer_only" and make it an entry function (for cheapest way
    /// to transfer APT) - if we want to allow APT PFS without account itself
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L286-304)
```text
    public(friend) entry fun fungible_transfer_only(
        source: &signer, to: address, amount: u64
    ) {
        let sender_store =
            ensure_primary_fungible_store_exists(signer::address_of(source));
        let recipient_store = ensure_primary_fungible_store_exists(to);

        // use internal APIs, as they skip:
        // - owner, frozen and dispatchable checks
        // as APT cannot be frozen or have dispatch, and PFS cannot be transfered
        // (PFS could potentially be burned. regular transfer would permanently unburn the store.
        // Ignoring the check here has the equivalent of unburning, transfers, and then burning again)
        fungible_asset::withdraw_permission_check_by_address(
            source, sender_store, amount
        );
        fungible_asset::unchecked_deposit(
            recipient_store, fungible_asset::unchecked_withdraw(sender_store, amount)
        );
    }
```

**File:** testsuite/smoke-test/src/aptos/account_creation.rs (L25-28)
```rust
    let send_fa_txn = account1.sign_with_transaction_builder(info.transaction_factory().payload(
        aptos_stdlib::aptos_account_fungible_transfer_only(account2.address(), 10_000_000_000),
    ));
    info.client().submit_and_wait(&send_fa_txn).await.unwrap();
```

**File:** execution/executor-benchmark/src/native/parallel_uncoordinated_block_executor.rs (L339-350)
```rust
            NativeTransaction::FaTransfer {
                sender,
                sequence_number,
                recipient,
                amount,
            } => {
                self.update_sequence_number(sender, sequence_number, state_view, &mut output)?;

                self.withdraw_fa_apt_from_signer(sender, amount, gas, state_view, &mut output)?;

                let _existed = self.deposit_fa_apt(recipient, amount, state_view, &mut output)?;
            },
```

**File:** execution/executor-benchmark/src/native/parallel_uncoordinated_block_executor.rs (L360-367)
```rust
                self.withdraw_apt_from_signer(
                    fa_migration_complete,
                    sender,
                    amount,
                    gas,
                    state_view,
                    &mut output,
                )?;
```

**File:** types/src/on_chain_config/aptos_features.rs (L235-235)
```rust
            FeatureFlag::OPERATIONS_DEFAULT_TO_FA_APT_STORE,
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L687-694)
```text
                // Note:
                // It is possible the primary fungible store may already exist before this function call.
                // In this case, if the account owns a frozen CoinStore and an unfrozen primary fungible store, this
                // function would convert and deposit the rest coin into the primary store and freeze it to make the
                // `frozen` semantic as consistent as possible.
                if (frozen != fungible_asset::is_frozen(store)) {
                    fungible_asset::set_frozen_flag_internal(store, frozen);
                }
```
