# Audit Report

## Title
Missing Validation of On-Chain Configs in DKG Epoch Manager Leading to Node Crash

## Summary
The DKG epoch manager's `await_reconfig_notification()` and `start_new_epoch()` functions do not validate on-chain configuration payloads before processing them. The code uses `.expect()` for critical configs like `ValidatorSet` and contains assertions that will panic if the data is malformed, missing, or corrupted. This creates a denial-of-service vulnerability where corrupted on-chain state can crash validator nodes.

## Finding Description

The `await_reconfig_notification()` function receives on-chain configs and passes them directly to `start_new_epoch()` without any validation: [1](#0-0) 

In `start_new_epoch()`, the `ValidatorSet` is extracted using `.expect()`, which panics if the config is missing or deserialization fails: [2](#0-1) 

The on-chain configs are read from the database and deserialized using BCS without additional validation: [3](#0-2) 

The `DbBackedOnChainConfig` provider performs raw BCS deserialization: [4](#0-3) 

During the conversion from `ValidatorSet` to `ValidatorVerifier`, there are unchecked array accesses and assertions that will panic if validator indices are corrupted: [5](#0-4) 

**Attack Vectors:**

1. **Database Corruption**: Hardware failures, filesystem corruption, or disk errors could corrupt the serialized on-chain configs, causing BCS deserialization to fail or produce malformed data.

2. **State Sync Attack**: A malicious peer could provide corrupted state snapshots during state synchronization, introducing invalid `ValidatorSet` data into the database.

3. **Index Out of Bounds**: If any validator's `validator_index` field is >= the number of validators (e.g., due to corruption), the array access at line 581 will panic.

4. **Assertion Failure**: If validator addresses don't match their indices (due to corruption), the assertion at lines 580-583 will panic.

**Invariant Violations:**

This breaks the **State Consistency** invariant: nodes should gracefully handle potentially corrupted state rather than panicking. It also violates defensive programming principles where external data (on-chain state from database) should be validated before use.

## Impact Explanation

**High Severity** per Aptos bug bounty criteria:
- **Validator node crashes**: A single corrupted on-chain config can cause immediate node panic and crash
- **Potential network liveness impact**: If multiple validators receive corrupted state (e.g., through state sync), it could affect network operation
- **API crashes**: The panic occurs in critical epoch management code

While this doesn't directly lead to consensus safety violations or fund loss, it can cause validator unavailability, which impacts network liveness and reliability.

## Likelihood Explanation

**Medium Likelihood:**
- Database corruption from hardware failures is rare but realistic in production environments
- State sync attacks require controlling a peer node but are feasible for sophisticated attackers
- The vulnerability triggers on every epoch transition if corrupted data is present
- No special timing or race conditions required - any corruption reaching this code will trigger the panic

The likelihood is reduced because:
- Normal operation through Move framework should maintain valid configs
- Requires external corruption vector (database or state sync)
- Not directly exploitable via transactions

## Recommendation

Implement defensive validation before processing on-chain configs:

```rust
async fn start_new_epoch(&mut self, payload: OnChainConfigPayload<P>) -> Result<()> {
    // Validate ValidatorSet exists and can be deserialized
    let validator_set: ValidatorSet = payload
        .get()
        .map_err(|e| anyhow!("Failed to get ValidatorSet from payload: {}", e))?;
    
    // Validate validator set is non-empty for active epochs
    if validator_set.active_validators.is_empty() && payload.epoch() > 0 {
        return Err(anyhow!("ValidatorSet cannot be empty for epoch {}", payload.epoch()));
    }
    
    // Validate validator indices before conversion
    let num_validators = validator_set.payload().count();
    for (idx, info) in validator_set.payload().enumerate() {
        let validator_index = info.config().validator_index as usize;
        if validator_index >= num_validators {
            return Err(anyhow!(
                "Invalid validator_index {} for validator {} (max: {})",
                validator_index,
                info.account_address,
                num_validators - 1
            ));
        }
    }

    let epoch_state = Arc::new(EpochState::new(payload.epoch(), (&validator_set).into()));
    // ... rest of the function
}
```

Additionally, modify the `From<&ValidatorSet>` conversion to return `Result` instead of using assertions:

```rust
impl TryFrom<&ValidatorSet> for ValidatorVerifier {
    type Error = anyhow::Error;
    
    fn try_from(validator_set: &ValidatorSet) -> Result<Self> {
        let sorted_validator_infos: BTreeMap<u64, ValidatorConsensusInfo> = validator_set
            .payload()
            .map(|info| {
                (
                    info.config().validator_index,
                    ValidatorConsensusInfo::new(
                        info.account_address,
                        info.consensus_public_key().clone(),
                        info.consensus_voting_power(),
                    ),
                )
            })
            .collect();
        let validator_infos: Vec<_> = sorted_validator_infos.values().cloned().collect();
        
        // Validate instead of assert
        for info in validator_set.payload() {
            let idx = info.config().validator_index as usize;
            if idx >= validator_infos.len() {
                return Err(anyhow!("validator_index {} out of bounds", idx));
            }
            if validator_infos[idx].address != info.account_address {
                return Err(anyhow!(
                    "Address mismatch at index {}: expected {}, got {}",
                    idx,
                    validator_infos[idx].address,
                    info.account_address
                ));
            }
        }
        Ok(ValidatorVerifier::new(validator_infos))
    }
}
```

## Proof of Concept

Since this requires database corruption or state sync manipulation, a realistic PoC would involve:

```rust
// Test demonstrating panic on corrupted ValidatorSet
#[test]
#[should_panic(expected = "failed to get ValidatorSet from payload")]
fn test_corrupted_validator_set_causes_panic() {
    // Create a payload with missing ValidatorSet
    let configs = HashMap::new(); // Empty configs
    let provider = InMemoryOnChainConfig::new(configs);
    let payload = OnChainConfigPayload::new(1, provider);
    
    // This will panic with .expect()
    let _validator_set: ValidatorSet = payload.get().expect("failed to get ValidatorSet from payload");
}

#[test]
#[should_panic(expected = "index out of bounds")]
fn test_invalid_validator_index_causes_panic() {
    use aptos_crypto::bls12381::PrivateKey;
    
    // Create ValidatorSet with corrupted validator_index
    let mut validators = vec![];
    for i in 0..3 {
        let private_key = PrivateKey::generate_for_testing();
        let public_key = PublicKey::from(&private_key);
        
        // Set validator_index to invalid value (out of bounds)
        let validator_index = if i == 1 { 999 } else { i as u64 };
        
        let info = ValidatorInfo::new_with_test_network_keys(
            AccountAddress::random(),
            public_key,
            100,
            validator_index,
        );
        validators.push(info);
    }
    
    let validator_set = ValidatorSet::new(validators);
    
    // This will panic when trying to access validator_infos[999]
    let _verifier = ValidatorVerifier::from(&validator_set);
}
```

**Notes:**

The vulnerability exists but has limited practical exploitability. An unprivileged attacker (transaction sender or random network peer) cannot directly trigger this without:
1. Gaining filesystem access to corrupt the database
2. Controlling a state sync peer to provide malicious snapshots
3. Exploiting a separate bug that writes corrupted configs

This is primarily a **defensive coding issue** where the code should gracefully handle potentially corrupted data rather than panicking. The security question asks if validation checks exist, and the answer is clearly **no** - the configs are processed without validation, which violates robust error handling principles.

### Citations

**File:** dkg/src/epoch_manager.rs (L146-155)
```rust
    async fn await_reconfig_notification(&mut self) {
        let reconfig_notification = self
            .reconfig_events
            .next()
            .await
            .expect("Reconfig sender dropped, unable to start new epoch");
        self.start_new_epoch(reconfig_notification.on_chain_configs)
            .await
            .unwrap();
    }
```

**File:** dkg/src/epoch_manager.rs (L157-163)
```rust
    async fn start_new_epoch(&mut self, payload: OnChainConfigPayload<P>) -> Result<()> {
        let validator_set: ValidatorSet = payload
            .get()
            .expect("failed to get ValidatorSet from payload");

        let epoch_state = Arc::new(EpochState::new(payload.epoch(), (&validator_set).into()));
        self.epoch_state = Some(epoch_state.clone());
```

**File:** state-sync/inter-component/event-notifications/src/lib.rs (L277-307)
```rust
    /// Fetches the configs on-chain at the specified version.
    /// Note: We cannot assume that all configs will exist on-chain. As such, we
    /// must fetch each resource one at a time. Reconfig subscribers must be able
    /// to handle on-chain configs not existing in a reconfiguration notification.
    fn read_on_chain_configs(
        &self,
        version: Version,
    ) -> Result<OnChainConfigPayload<DbBackedOnChainConfig>, Error> {
        let db_state_view = &self
            .storage
            .read()
            .reader
            .state_view_at_version(Some(version))
            .map_err(|error| {
                Error::UnexpectedErrorEncountered(format!(
                    "Failed to create account state view {:?}",
                    error
                ))
            })?;
        let epoch = ConfigurationResource::fetch_config(&db_state_view)
            .ok_or_else(|| {
                Error::UnexpectedErrorEncountered("Configuration resource does not exist!".into())
            })?
            .epoch();

        // Return the new on-chain config payload (containing all found configs at this version).
        Ok(OnChainConfigPayload::new(
            epoch,
            DbBackedOnChainConfig::new(self.storage.read().reader.clone(), version),
        ))
    }
```

**File:** state-sync/inter-component/event-notifications/src/lib.rs (L397-413)
```rust
impl OnChainConfigProvider for DbBackedOnChainConfig {
    fn get<T: OnChainConfig>(&self) -> Result<T> {
        let bytes = self
            .reader
            .get_state_value_by_version(&StateKey::on_chain_config::<T>()?, self.version)?
            .ok_or_else(|| {
                anyhow!(
                    "no config {} found in aptos root account state",
                    T::CONFIG_ID
                )
            })?
            .bytes()
            .clone();

        T::deserialize_into_config(&bytes)
    }
}
```

**File:** types/src/validator_verifier.rs (L563-586)
```rust
impl From<&ValidatorSet> for ValidatorVerifier {
    fn from(validator_set: &ValidatorSet) -> Self {
        let sorted_validator_infos: BTreeMap<u64, ValidatorConsensusInfo> = validator_set
            .payload()
            .map(|info| {
                (
                    info.config().validator_index,
                    ValidatorConsensusInfo::new(
                        info.account_address,
                        info.consensus_public_key().clone(),
                        info.consensus_voting_power(),
                    ),
                )
            })
            .collect();
        let validator_infos: Vec<_> = sorted_validator_infos.values().cloned().collect();
        for info in validator_set.payload() {
            assert_eq!(
                validator_infos[info.config().validator_index as usize].address,
                info.account_address
            );
        }
        ValidatorVerifier::new(validator_infos)
    }
```
