# Audit Report

## Title
Unauthorized Consensus Observer Subscription via Missing Peer Authentication

## Summary
The consensus observer publisher accepts subscription requests from any connected peer without verifying node authorization or type, allowing public fullnodes to bypass intended restrictions and receive real-time consensus messages containing validator voting patterns through the validator_bitmask in LedgerInfoWithSignatures.

## Finding Description

The consensus observer system is designed to allow authorized nodes (validators and validator fullnodes) to follow consensus in real-time. The configuration explicitly disables consensus observer for public fullnodes by default: [1](#0-0) 

However, the consensus publisher's subscription handler accepts ANY Subscribe request without authentication or authorization checks: [2](#0-1) 

The vulnerability manifests through the following attack path:

1. **Config Override**: A malicious actor runs a public fullnode and manually enables consensus observer in their local config file by setting `observer_enabled: true`, bypassing the default restriction.

2. **Network Registration**: When consensus observer is enabled, the protocols are registered on ALL network types including the Public network: [3](#0-2) 

3. **VFN Exposure**: Validator fullnodes (VFNs) enable both observer AND publisher by default and listen on both VFN and Public networks: [4](#0-3) [5](#0-4) 

4. **Unauthorized Subscription**: The public fullnode connects to a VFN via the Public network and sends a Subscribe RPC request, which is accepted without any verification.

5. **Information Disclosure**: The publisher broadcasts OrderedBlock and CommitDecision messages to ALL active subscribers: [6](#0-5) [7](#0-6) 

6. **Voting Pattern Extraction**: These messages contain LedgerInfoWithSignatures with AggregateSignature, which includes a validator_bitmask revealing exactly which validators signed: [8](#0-7) [9](#0-8) 

The network handler only checks if publisher is enabled, not whether the requesting peer is authorized: [10](#0-9) 

## Impact Explanation

This vulnerability qualifies as **Medium Severity** under the Aptos bug bounty criteria as it represents an authorization bypass that allows unauthorized information disclosure. While it doesn't directly cause funds loss or state inconsistencies, it:

1. **Bypasses Intended Access Controls**: The explicit default to disable observer on public fullnodes indicates intentional restriction, which is rendered ineffective.

2. **Exposes Validator Behavior**: Real-time access to voting patterns could enable:
   - Analysis of validator liveness and participation
   - Identification of validators for targeted attacks
   - Timing analysis correlating validators with specific decisions
   - Potential market manipulation if consensus outcomes can be predicted

3. **Information Disclosure at Scale**: Any number of unauthorized nodes can subscribe and receive this information, making it a systemic rather than isolated issue.

The re-export mentioned in the security question is not the root causeâ€”rather, it's the missing authentication in subscription handling that enables this bypass.

## Likelihood Explanation

**High Likelihood**: The attack is trivially executable and requires no special privileges:
- Single configuration change in a text file
- Standard network connectivity to a VFN
- Simple RPC call to subscribe
- No cryptographic operations or complex exploitation required

Any motivated actor with basic technical knowledge can exploit this vulnerability.

## Recommendation

Implement peer authorization checks before accepting subscriptions. The publisher should verify:

1. **Peer Role Verification**: Check the peer's node type (validator, VFN, or public) using network metadata
2. **Network-based Restrictions**: Only accept subscriptions from VFN and Validator networks, reject Public network subscriptions
3. **Cryptographic Authentication**: Optionally require proof that the subscriber is an authorized node (e.g., signed by a validator key)

Recommended fix in `consensus_publisher.rs`:

```rust
ConsensusObserverRequest::Subscribe => {
    // Verify peer is authorized to subscribe
    if !self.is_peer_authorized_subscriber(&peer_network_id) {
        warn!(LogSchema::new(LogEntry::ConsensusPublisher)
            .event(LogEvent::Subscription)
            .message(&format!(
                "Rejected unauthorized subscription from peer: {:?}",
                peer_network_id
            )));
        response_sender.send(ConsensusObserverResponse::UnauthorizedError);
        return;
    }
    
    // Add the peer to the set of active subscribers
    self.add_active_subscriber(peer_network_id);
    // ... rest of existing code
}

fn is_peer_authorized_subscriber(&self, peer_network_id: &PeerNetworkId) -> bool {
    // Only allow subscriptions from Validator and VFN networks
    matches!(
        peer_network_id.network_id(),
        NetworkId::Validator | NetworkId::Vfn
    )
}
```

## Proof of Concept

```rust
// Integration test demonstrating unauthorized subscription
#[tokio::test]
async fn test_unauthorized_public_fullnode_subscription() {
    // Setup: Create a VFN with publisher enabled
    let vfn_config = NodeConfig {
        consensus_observer: ConsensusObserverConfig {
            publisher_enabled: true,
            ..Default::default()
        },
        ..Default::default()
    };
    
    // Attacker: Create a public fullnode with observer manually enabled
    let attacker_config = NodeConfig {
        consensus_observer: ConsensusObserverConfig {
            observer_enabled: true,  // Manual override
            ..Default::default()
        },
        ..Default::default()
    };
    
    // Setup network: Connect attacker's public fullnode to VFN via Public network
    let attacker_peer = PeerNetworkId::new(NetworkId::Public, PeerId::random());
    
    // Attack: Send Subscribe request
    let subscribe_request = ConsensusObserverRequest::Subscribe;
    
    // Expected: Should be rejected, but currently accepted
    // Actual: Subscription succeeds without authorization check
    // Result: Attacker receives OrderedBlock and CommitDecision messages
    //         containing validator_bitmask revealing voting patterns
}
```

**Notes**

The vulnerability stems from a gap between configuration intent (disabling observer on public fullnodes) and enforcement (no runtime authorization checks). While the consensus information broadcast by the publisher eventually becomes public through committed blocks, the early access and lack of authorization controls violates the principle of least privilege and bypasses intended access restrictions. The validator_bitmask in LedgerInfoWithSignatures is particularly sensitive as it directly maps to specific validators' participation in consensus rounds.

### Citations

**File:** config/src/config/consensus_observer_config.rs (L14-14)
```rust
const ENABLE_ON_PUBLIC_FULLNODES: bool = false;
```

**File:** config/src/config/consensus_observer_config.rs (L119-128)
```rust
            NodeType::ValidatorFullnode => {
                if ENABLE_ON_VALIDATOR_FULLNODES
                    && !observer_manually_set
                    && !publisher_manually_set
                {
                    // Enable both the observer and the publisher for VFNs
                    consensus_observer_config.observer_enabled = true;
                    consensus_observer_config.publisher_enabled = true;
                    modified_config = true;
                }
```

**File:** consensus/src/consensus_observer/publisher/consensus_publisher.rs (L181-193)
```rust
            ConsensusObserverRequest::Subscribe => {
                // Add the peer to the set of active subscribers
                self.add_active_subscriber(peer_network_id);
                info!(LogSchema::new(LogEntry::ConsensusPublisher)
                    .event(LogEvent::Subscription)
                    .message(&format!(
                        "New peer subscribed to consensus updates! Peer: {:?}",
                        peer_network_id
                    )));

                // Send a simple subscription ACK
                response_sender.send(ConsensusObserverResponse::SubscribeAck);
            },
```

**File:** aptos-node/src/network.rs (L336-348)
```rust
        // Register consensus observer (both client and server) with the network
        if node_config
            .consensus_observer
            .is_observer_or_publisher_enabled()
        {
            // Create the network handle for this network type
            let network_handle = register_client_and_service_with_network(
                &mut network_builder,
                network_id,
                &network_config,
                consensus_observer_network_configuration(node_config),
                false,
            );
```

**File:** config/src/config/test_data/validator_full_node.yaml (L18-31)
```yaml
full_node_networks:
    - listen_address: "/ip4/0.0.0.0/tcp/6180"
      discovery_method: "onchain"
      identity:
          type: "from_storage"
          key_name: "fullnode_network"
          peer_id_name: "owner_account"
          backend:
              type: "vault"
              server: "https://127.0.0.1:8200"
              ca_certificate: "/full/path/to/certificate"
              token:
                  from_disk: "/full/path/to/token"
      network_id: "public"
```

**File:** consensus/src/pipeline/buffer_manager.rs (L400-406)
```rust
        if let Some(consensus_publisher) = &self.consensus_publisher {
            let message = ConsensusObserverMessage::new_ordered_block_message(
                ordered_blocks.clone(),
                ordered_proof.clone(),
            );
            consensus_publisher.publish_message(message);
        }
```

**File:** consensus/src/pipeline/buffer_manager.rs (L514-517)
```rust
                if let Some(consensus_publisher) = &self.consensus_publisher {
                    let message =
                        ConsensusObserverMessage::new_commit_decision_message(commit_proof.clone());
                    consensus_publisher.publish_message(message);
```

**File:** types/src/aggregate_signature.rs (L16-19)
```rust
pub struct AggregateSignature {
    validator_bitmask: BitVec,
    sig: Option<bls12381::Signature>,
}
```

**File:** types/src/aggregate_signature.rs (L43-58)
```rust
    pub fn get_signers_addresses(
        &self,
        validator_addresses: &[AccountAddress],
    ) -> Vec<AccountAddress> {
        validator_addresses
            .iter()
            .enumerate()
            .filter_map(|(index, addr)| {
                if self.validator_bitmask.is_set(index as u16) {
                    Some(*addr)
                } else {
                    None
                }
            })
            .collect()
    }
```

**File:** consensus/src/consensus_observer/network/network_handler.rs (L200-203)
```rust
        // Drop the message if the publisher is not enabled
        if !self.consensus_observer_config.publisher_enabled {
            return;
        }
```
