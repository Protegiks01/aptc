# Audit Report

## Title
Randomness Cancellation Vulnerability in batch_open() Due to Missing Commitment Transcript Binding

## Summary
The `batch_open()` function in the Zeromorph polynomial commitment scheme implementation aggregates blinding factors without first ensuring that the polynomial commitments are bound to the Fiat-Shamir transcript. This allows an attacker who can predict the batching challenge `gamma` to choose blinding factors that sum to zero, completely breaking the hiding property of the batched commitment. [1](#0-0) 

## Finding Description

The vulnerability exists in the `batch_open()` implementation where blinding factors are aggregated using powers of a challenge scalar `gamma`. The critical flaw occurs at line 544 where `gamma` is derived from the Fiat-Shamir transcript: [2](#0-1) 

The function then aggregates blinding factors as `s = Σ(gamma^i * r_i)` using the `powers` function which generates `[1, gamma, gamma^2, ..., gamma^(n-1)]`: [3](#0-2) [4](#0-3) 

**The Attack Path:**

1. An attacker creates a transcript in a known or predictable state (without adding commitments)
2. The attacker simulates `trs.challenge_scalar()` to predict the value of `gamma` (Fiat-Shamir challenges are deterministic based on transcript state)
3. The attacker chooses blinding factors `rs = [r_1, r_2, ..., r_n]` such that `Σ(gamma^i * r_i) = 0`
   - Example with 2 polynomials: If predicted `gamma = g`, choose `r_1 = g` and `r_2 = -1`
   - Then `s = 1·g + g·(-1) = 0`
4. The attacker creates polynomial commitments using these carefully chosen (but individually non-zero) blinding factors
5. The attacker calls `batch_open()` which derives the already-predicted `gamma` and aggregates the blinding factors to `s = 0`

**Why This Breaks Security:**

In the hiding KZG commitment scheme, commitments have the form `C = r·ξ_1 + f(τ)` where `r` is the blinding factor. The hiding property guarantees that given `C`, an adversary cannot learn information about `f(τ)`. When batching commitments, the combined commitment is `C_combined = s·ξ_1 + f_combined(τ)` where `s = Σ(gamma^i * r_i)`. [5](#0-4) 

If `s = 0`, the combined commitment reveals `f_combined(τ)` directly, breaking the hiding property. Each individual commitment appears properly hiding (has non-zero randomness), but the aggregation cancels out all randomness.

**Root Cause:**

The trait definition allows blinding factors to be provided as inputs but doesn't enforce that commitments are bound to the transcript before deriving `gamma`: [6](#0-5) 

The Fiat-Shamir transcript protocol defines how to append commitments: [7](#0-6) 

But `batch_open()` doesn't add commitments to the transcript before deriving the challenge, nor does it validate that they're already present.

## Impact Explanation

**Severity: HIGH**

This vulnerability breaks **Cryptographic Correctness** (Invariant #10), specifically the hiding property of polynomial commitment schemes. While the function is not currently used in the production Aptos randomness or DKG protocols, it represents a significant cryptographic flaw that could be exploited if:

1. The function is integrated into future randomness aggregation protocols
2. A distributed protocol uses batch_open() for combining validator contributions
3. Any security-critical component relies on this batching functionality

The impact qualifies as HIGH severity per Aptos bug bounty criteria because it constitutes a "significant protocol violation" - the hiding property is a fundamental security guarantee of commitment schemes used in DKG and randomness generation.

If exploited in a randomness generation context, this could lead to:
- Predictable randomness values
- Validator bias in leader election
- Compromise of DKG secret sharing protocols
- Loss of unpredictability in on-chain randomness

## Likelihood Explanation

**Likelihood: MEDIUM**

The vulnerability requires:
1. The `batch_open()` function to be used in a security-critical protocol (currently it is NOT used based on codebase analysis)
2. An attacker who can influence the protocol flow to call `batch_open()` with controlled parameters
3. A protocol implementation that fails to add commitments to the transcript before calling `batch_open()`

While the function is currently unused, its presence in the trait interface suggests intended future use. The vulnerability is in the implementation itself, not just in potential misuse, because the function doesn't enforce correct transcript usage.

## Recommendation

**Fix 1: Add commitments to transcript before deriving gamma**

Modify `batch_open()` to take commitments as parameters and add them to the transcript:

```rust
fn batch_open<R: RngCore + CryptoRng>(
    ck: Self::CommitmentKey,
    polys: Vec<Self::Polynomial>,
    coms: Vec<Self::Commitment>,  // ADD THIS
    challenge: Vec<Self::WitnessField>,
    rs: Option<Vec<Self::WitnessField>>,
    rng: &mut R,
    trs: &mut merlin::Transcript,
) -> Self::Proof {
    let rs = rs.expect("rs must be present");
    
    // ADD: Bind commitments to transcript BEFORE deriving gamma
    for com in &coms {
        trs.append_point(&com.0);
    }
    
    let gamma = trs.challenge_scalar();
    // ... rest of implementation
}
```

**Fix 2: Document security requirements**

Add clear documentation that callers MUST add commitments to the transcript before calling this function, and consider adding a debug assertion to verify transcript state in non-production builds.

**Fix 3: Update trait signature**

Update the trait definition to require commitments as a parameter: [6](#0-5) 

Change line 46 to: `coms: Vec<Self::Commitment>,`

## Proof of Concept

```rust
#[cfg(test)]
mod vulnerability_poc {
    use super::*;
    use ark_bn254::Bn254;
    use aptos_crypto::arkworks::random::sample_field_elements;
    use rand::thread_rng;
    
    #[test]
    fn test_randomness_cancellation_attack() {
        type E = Bn254;
        let mut rng = thread_rng();
        
        // Setup
        let degree_bounds = vec![4, 4];  // 2 polynomials
        let (ck, vk) = Zeromorph::<E>::setup(degree_bounds, &mut rng);
        
        // Attacker creates polynomials
        let poly1 = random_poly::<Zeromorph<E>, _>(&mut rng, 16, 64);
        let poly2 = random_poly::<Zeromorph<E>, _>(&mut rng, 16, 64);
        let polys = vec![poly1.clone(), poly2.clone()];
        
        // Attacker predicts gamma by simulating transcript
        let mut transcript_simulation = merlin::Transcript::new(b"test");
        transcript_simulation.append_sep(b"Zeromorph");
        let predicted_gamma: <E as Pairing>::ScalarField = 
            transcript_simulation.challenge_scalar();
        
        // Attacker chooses blinding factors to cancel out
        // For 2 polynomials: s = r_1 * 1 + r_2 * gamma = 0
        // Therefore: r_1 = gamma, r_2 = -1
        let r1 = predicted_gamma;
        let r2 = -<E as Pairing>::ScalarField::one();
        let rs = Some(vec![r1, r2]);
        
        // Attack: call batch_open (commitments NOT added to transcript)
        let mut transcript = merlin::Transcript::new(b"test");
        transcript.append_sep(b"Zeromorph");
        let challenge = random_point::<Zeromorph<E>, _>(&mut rng, 4);
        
        let proof = Zeromorph::<E>::batch_open(
            ck.clone(),
            polys,
            challenge.clone(),
            rs,
            &mut rng,
            &mut transcript,
        );
        
        // Verify that combined blinding is zero
        // The combined blinding s = r1 + predicted_gamma * r2 
        //                          = predicted_gamma + predicted_gamma * (-1) 
        //                          = 0
        let combined_blinding = r1 + predicted_gamma * r2;
        assert_eq!(combined_blinding, <E as Pairing>::ScalarField::zero(), 
                   "Attack successful: combined blinding is zero!");
    }
}
```

**Notes:**
- This vulnerability exists in the cryptographic implementation layer of the DKG crate
- While not currently exploited in production Aptos code, it represents a latent security flaw
- The function signature in the trait interface should be updated to prevent misuse
- Any future protocol using `batch_open()` must carefully ensure commitments are in the transcript before deriving challenges

### Citations

**File:** crates/aptos-dkg/src/pcs/zeromorph.rs (L533-563)
```rust
    fn batch_open<R: RngCore + CryptoRng>(
        ck: Self::CommitmentKey,
        polys: Vec<Self::Polynomial>,
        //   coms: Vec<Commitment>,
        challenge: Vec<Self::WitnessField>,
        rs: Option<Vec<Self::WitnessField>>,
        rng: &mut R,
        trs: &mut merlin::Transcript,
    ) -> Self::Proof {
        let rs = rs.expect("rs must be present");

        let gamma = trs.challenge_scalar();
        let gammas = powers(gamma, polys.len());

        let combined_poly = polys
            .iter()
            .zip(gammas.iter())
            .fold(Self::Polynomial::zero(), |acc, (poly, gamma_i)| {
                acc + poly * gamma_i
            });
        let eval = Self::evaluate_point(&combined_poly, &challenge);

        let s = rs
            .iter()
            .zip(gammas.iter())
            .fold(Self::WitnessField::zero(), |acc, (r, gamma_i)| {
                acc + (*r * gamma_i)
            });

        Zeromorph::open(&ck, &combined_poly, &challenge, eval, Scalar(s), rng, trs)
    }
```

**File:** crates/aptos-crypto/src/utils.rs (L10-25)
```rust
/// Returns the first `count` powers of a given `base` element, so
/// [1, base, base^2, base^3, ..., base^{count - 1}]
pub fn powers<T>(base: T, count: usize) -> Vec<T>
where
    T: MulAssign + One + Copy,
{
    let mut powers = Vec::with_capacity(count);
    let mut current = T::one();

    for _ in 0..count {
        powers.push(current);
        current *= base;
    }

    powers
}
```

**File:** crates/aptos-dkg/src/pcs/univariate_hiding_kzg.rs (L276-323)
```rust
/// A fixed-base homomorphism used for computing commitments in the
/// *Hiding KZG (HKZG)* commitment scheme.
///
/// # Overview
///
/// This struct defines a homomorphism used to map scalars
/// (the polynomial evaluations and blinding factor) into an elliptic curve point,
/// producing a commitment in the HKZG scheme as (presumably) described in Zeromorph [^KT23e].
///
/// The homomorphism implements the following formula:
///
/// \\[
/// C = \rho \cdot \xi_1 + \sum_i f(\theta^i) \cdot \ell_i(\tau)_1
/// \\]
///
/// where:
/// - `ρ` is the blinding scalar,
/// - `ξ₁` is the fixed base obtained from a trapdoor `ξ`,
/// - `f(ωᵢ)` are polynomial evaluations at roots of unity ωᵢ,
/// - `ℓᵢ(τ)₁` are the Lagrange basis polynomials evaluated at trapdoor `τ`,
///
/// This homomorphism can be expressed as a *multi-scalar multiplication (MSM)*
/// over fixed bases, making it compatible with the `fixed_base_msms` framework.
///
///
/// # Fields
///
/// - `lagr_g1`: A slice of precomputed Lagrange basis elements \\(\ell_i(\tau) \cdot g_1\\),
///   used to commit to polynomial evaluations.
/// - `xi_1`: The base point corresponding to the blinding term \\(\xi_1 = ξ \cdot g_1\\).
///
///
/// # Implementation Notes
///
/// For consistency with `univariate_kzg.rs` and use in future sigma protocols, this implementation uses the
/// `fixed_base_msms::Trait` to express the homomorphism as a sequence of `(base, scalar)` pairs:
/// - The first pair encodes the hiding term `(ξ₁, ρ)`.
/// - The remaining pairs encode the polynomial evaluation commitments `(ℓᵢ(τ)₁, f(ωᵢ))`.
///
/// The MSM evaluation is then performed using `E::G1::msm()`.
///
/// TODO: Since this code is quite similar to that of ordinary KZG, it may be possible to reduce it a bit
#[derive(CanonicalSerialize, Debug, Clone, PartialEq, Eq)]
pub struct CommitmentHomomorphism<'a, E: Pairing> {
    pub msm_basis: &'a [E::G1Affine],
    pub xi_1: E::G1Affine,
}

```

**File:** crates/aptos-dkg/src/pcs/traits.rs (L43-51)
```rust
    fn batch_open<R: RngCore + CryptoRng>(
        ck: Self::CommitmentKey,
        polys: Vec<Self::Polynomial>,
        //   coms: Vec<Commitment>,
        challenge: Vec<Self::WitnessField>,
        rs: Option<Vec<Self::WitnessField>>,
        rng: &mut R,
        trs: &mut merlin::Transcript,
    ) -> Self::Proof;
```

**File:** crates/aptos-dkg/src/fiat_shamir.rs (L100-106)
```rust
pub trait PolynomialCommitmentScheme {
    fn append_sep(&mut self, dst: &[u8]);

    fn append_point<C: CurveGroup>(&mut self, point: &C);

    fn challenge_scalar<F: PrimeField>(&mut self) -> F;
}
```
