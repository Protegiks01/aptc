# Audit Report

## Title
Division by Zero in Leader Election with Zero-Stake Validator Configuration

## Summary
The `choose_index()` function in `consensus/src/liveness/proposer_election.rs` panics with division by zero when all validators have zero total weight, causing complete consensus liveness failure. This can occur when governance sets `minimum_stake` to 0 and a validator with zero voting power enters the active set.

## Finding Description
The vulnerability exists in the weighted random selection algorithm used for leader election in the Aptos consensus protocol. [1](#0-0) 

When `choose_index()` calculates cumulative weights and all weights sum to zero, it calls `next_in_range(state, 0)`. [2](#0-1)  This function performs modulo operation `hash % max` where `max` is the `total_weight`. When `max = 0`, Rust panics with "attempt to divide by zero".

**Attack Path:**

1. **Governance Configuration**: Through the on-chain governance system, `minimum_stake` is set to 0. [3](#0-2)  The validation only requires `minimum_stake <= maximum_stake && maximum_stake > 0`, allowing `minimum_stake = 0`.

2. **Validator Joins with Zero Stake**: A validator joins the set with exactly 0 voting power. [4](#0-3)  Since `0 >= minimum_stake` (where `minimum_stake = 0`), the assertion passes.

3. **Epoch Transition Permits Zero-Power Validator**: During epoch transitions, the validator passes the filter. [5](#0-4)  The condition `new_validator_info.voting_power >= minimum_stake` evaluates to `0 >= 0`, which is true.

4. **Leader Election Invoked**: When `LeaderReputation::get_valid_proposer()` is called, it computes `stake_weights`. [6](#0-5)  With `voting_powers = [0]`, the resulting `stake_weights = [0]`.

5. **Consensus Halt**: The `choose_index([0], state)` call triggers division by zero panic, crashing all validator nodes attempting leader election. No leader can be elected, causing **total consensus liveness failure**.

## Impact Explanation
**Critical Severity** - This vulnerability causes:
- **Total Loss of Liveness**: All validators panic when attempting leader election, completely halting consensus
- **Non-Recoverable Without Intervention**: Requires manual intervention or hardfork to restore the network
- **Network-Wide Impact**: Affects all validator nodes simultaneously

This meets the **Critical severity** criteria per the Aptos bug bounty program: "Total loss of liveness/network availability" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation
**Low Likelihood** - This vulnerability requires:
- Governance vote to set `minimum_stake = 0` (requires 2/3+ voting power)
- Validator(s) joining with exactly 0 stake
- Configuration remaining until epoch transition

While technically possible through legitimate governance actions or configuration errors during network initialization/testing, it requires trusted actor involvement. The default production configuration would have `minimum_stake > 0`, preventing this scenario.

## Recommendation
Add validation to prevent zero total weight in `choose_index()`:

```rust
pub(crate) fn choose_index(mut weights: Vec<u128>, state: Vec<u8>) -> usize {
    let mut total_weight = 0;
    for w in &mut weights {
        total_weight = total_weight
            .checked_add(w)
            .expect("Total stake shouldn't exceed u128::MAX");
        *w = total_weight;
    }
    
    // Prevent division by zero
    assert!(
        total_weight > 0,
        "Total weight must be positive for leader selection"
    );
    
    let chosen_weight = next_in_range(state, total_weight);
    // ... rest of function
}
```

Additionally, enforce `minimum_stake > 0` in staking configuration: [3](#0-2) 

```move
fun validate_required_stake(minimum_stake: u64, maximum_stake: u64) {
    assert!(
        minimum_stake > 0 && minimum_stake <= maximum_stake && maximum_stake > 0,
        error::invalid_argument(EINVALID_STAKE_RANGE)
    );
}
```

## Proof of Concept
**Rust Unit Test:**

```rust
#[test]
#[should_panic(expected = "attempt to divide by zero")]
fn test_choose_index_zero_weight() {
    let weights = vec![0u128];
    let state = vec![1, 2, 3, 4];
    choose_index(weights, state); // Panics with division by zero
}

#[test]
fn test_choose_index_single_positive_weight() {
    let weights = vec![100u128];
    let state = vec![1, 2, 3, 4];
    let index = choose_index(weights, state);
    assert_eq!(index, 0); // Correctly returns 0
}
```

**Notes:**

This vulnerability represents a **defensive programming failure** rather than a typical security exploit. While it requires governance involvement (a trusted role per the trust model), the consensus layer should be resilient to configuration errors. The panic breaks the consensus liveness invariant and could occur through:
- Accidental misconfiguration during network upgrades
- Testing configurations inadvertently deployed to production  
- Governance proposals with unintended consequences

The fix is straightforward: add explicit zero-weight validation to fail gracefully rather than panic, and enforce `minimum_stake > 0` at the configuration level.

### Citations

**File:** consensus/src/liveness/proposer_election.rs (L39-46)
```rust
fn next_in_range(state: Vec<u8>, max: u128) -> u128 {
    // hash = SHA-3-256(state)
    let hash = aptos_crypto::HashValue::sha3_256_of(&state).to_vec();
    let mut temp = [0u8; 16];
    copy_slice_to_vec(&hash[..16], &mut temp).expect("next failed");
    // return hash[0..16]
    u128::from_le_bytes(temp) % max
}
```

**File:** consensus/src/liveness/proposer_election.rs (L49-69)
```rust
pub(crate) fn choose_index(mut weights: Vec<u128>, state: Vec<u8>) -> usize {
    let mut total_weight = 0;
    // Create cumulative weights vector
    // Since we own the vector, we can safely modify it in place
    for w in &mut weights {
        total_weight = total_weight
            .checked_add(w)
            .expect("Total stake shouldn't exceed u128::MAX");
        *w = total_weight;
    }
    let chosen_weight = next_in_range(state, total_weight);
    weights
        .binary_search_by(|w| {
            if *w <= chosen_weight {
                Ordering::Less
            } else {
                Ordering::Greater
            }
        })
        .expect_err("Comparison never returns equals, so it's always guaranteed to be error")
}
```

**File:** aptos-move/framework/aptos-framework/sources/configs/staking_config.move (L372-374)
```text
    fun validate_required_stake(minimum_stake: u64, maximum_stake: u64) {
        assert!(minimum_stake <= maximum_stake && maximum_stake > 0, error::invalid_argument(EINVALID_STAKE_RANGE));
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1072-1076)
```text
        let config = staking_config::get();
        let (minimum_stake, maximum_stake) = staking_config::get_required_stake(&config);
        let voting_power = get_next_epoch_voting_power(stake_pool);
        assert!(voting_power >= minimum_stake, error::invalid_argument(ESTAKE_TOO_LOW));
        assert!(voting_power <= maximum_stake, error::invalid_argument(ESTAKE_TOO_HIGH));
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1390-1397)
```text
            // A validator needs at least the min stake required to join the validator set.
            if (new_validator_info.voting_power >= minimum_stake) {
                spec {
                    assume total_voting_power + new_validator_info.voting_power <= MAX_U128;
                };
                total_voting_power = total_voting_power + (new_validator_info.voting_power as u128);
                vector::push_back(&mut next_epoch_validators, new_validator_info);
            };
```

**File:** consensus/src/liveness/leader_reputation.rs (L711-732)
```rust
        let stake_weights: Vec<u128> = weights
            .iter_mut()
            .enumerate()
            .map(|(i, w)| *w as u128 * self.voting_powers[i] as u128)
            .collect();

        let state = if self.use_root_hash {
            [
                root_hash.to_vec(),
                self.epoch.to_le_bytes().to_vec(),
                round.to_le_bytes().to_vec(),
            ]
            .concat()
        } else {
            [
                self.epoch.to_le_bytes().to_vec(),
                round.to_le_bytes().to_vec(),
            ]
            .concat()
        };

        let chosen_index = choose_index(stake_weights, state);
```
