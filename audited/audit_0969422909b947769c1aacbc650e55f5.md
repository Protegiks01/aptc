# Audit Report

## Title
Transaction Signature Validation Bypassed During Database Restore Operations

## Summary
During database restore operations, transaction signatures are never validated when applying transactions to the database. The restore process relies solely on Merkle proof verification and ledger info signatures, but does not re-verify individual transaction signatures. This creates a vulnerability where transactions with invalid signatures that were improperly committed to the original ledger (due to consensus compromise or VM bugs) would be restored without detection, perpetuating invalid state.

## Finding Description

The Aptos database restore process has two main paths for replaying transactions:

**1. KV Replay Path:** Transactions are directly saved to the database without any execution or signature verification. [1](#0-0) 

**2. Full Transaction Replay Path:** Transactions are processed through ChunkExecutor with `VerifyExecutionMode::NoVerify`. [2](#0-1) 

In both paths, the restoration coordinator explicitly uses `VerifyExecutionMode::NoVerify`, which causes the executor to skip execution verification: [3](#0-2) 

When `should_verify()` returns false, the ChunkExecutor bypasses the `verify_execution()` function and directly applies transactions via `remove_and_apply()`: [4](#0-3) 

The critical issue is that signature verification happens inside `verify_execution()` when transactions are converted to `SignatureVerifiedTransaction`: [5](#0-4) 

This conversion calls the `From<Transaction>` implementation which performs signature verification: [6](#0-5) 

However, since `VerifyExecutionMode::NoVerify` is used during restore, this signature verification never occurs. The only validation that happens is Merkle proof verification, which confirms transactions were in the original ledger but does NOT validate signatures: [7](#0-6) 

**Attack Scenario:**

1. A validator compromise or historical VM bug allows transactions with invalid signatures to be committed to the ledger
2. A backup is created from this compromised state
3. An operator restores a node from this backup
4. The invalid transactions are applied without signature verification
5. The restored node now contains transactions that would fail normal validation
6. If this node participates in consensus, it could cause state divergence

In contrast, during normal transaction validation, signatures are explicitly checked: [8](#0-7) 

## Impact Explanation

**Severity: HIGH** (up to $50,000 per Aptos Bug Bounty)

This vulnerability represents a significant protocol violation with the following impacts:

1. **State Consistency Violation**: Nodes restored from compromised backups would contain transactions that violate the fundamental invariant that all user transactions must have valid signatures.

2. **Consensus Risk**: If multiple nodes restore from the same compromised backup, they would all have consistent but invalid state. However, if some nodes restore from good backups and others from compromised backups, state divergence would occur during subsequent transaction execution.

3. **Defense-in-Depth Failure**: Even if the original compromise required consensus failure, the restore process should re-validate all invariants as a defense-in-depth measure. This is especially critical because backups might be shared across organizations or stored in locations with different security properties than the original blockchain.

4. **Replay Attack Surface**: An attacker who can compromise a backup source could inject transactions with invalid signatures, knowing they will be accepted during restore without verification.

While this does not directly enable theft of funds (as invalid transactions would still fail execution), it creates significant operational and security risks.

## Likelihood Explanation

**Likelihood: MEDIUM**

For this vulnerability to be exploited, one of the following conditions must be met:

1. **Historical Consensus Compromise**: A past incident where 2f+1 validators colluded to commit transactions with invalid signatures
2. **Historical VM Bug**: A past bug in the AptosVM that allowed invalid signatures to pass validation
3. **Backup Source Compromise**: An attacker gains write access to backup storage and modifies backup files

The likelihood is medium because:
- Backup sources are typically trusted infrastructure
- However, backups are often stored in separate systems with different security properties
- Historical bugs or compromises may not be immediately detected
- Organizations frequently restore from backups for disaster recovery or testing
- The Merkle proof provides some protection but doesn't validate signatures

## Recommendation

**Fix: Always verify transaction signatures during restore, regardless of verification mode**

Add an explicit signature verification step before applying transactions during restore:

```rust
// In ChunkExecutorInner::remove_and_apply()
fn remove_and_apply(
    &self,
    transactions: &mut Vec<Transaction>,
    // ... other params
) -> Result<()> {
    let num_txns = (end_version - begin_version) as usize;
    
    // NEW: Verify signatures for all user transactions
    for txn in transactions.iter().take(num_txns) {
        if let Transaction::UserTransaction(user_txn) = txn {
            user_txn.verify_signature().map_err(|_| {
                anyhow!("Invalid transaction signature detected during restore at version {}", 
                    begin_version)
            })?;
        }
    }
    
    // ... rest of existing code
}
```

Alternatively, modify the restore coordinator to use `VerifyExecutionMode::verify_all()` instead of `NoVerify`, though this would have performance implications.

For the KV replay path, add signature verification in `replay_kv()` before calling `save_transactions_and_replay_kv()`.

## Proof of Concept

```rust
#[cfg(test)]
mod test_restore_signature_bypass {
    use super::*;
    use aptos_crypto::{ed25519::Ed25519PrivateKey, PrivateKey, Uniform};
    use aptos_types::transaction::{
        RawTransaction, SignedTransaction, TransactionPayload, Script,
    };
    use aptos_types::account_address::AccountAddress;
    use aptos_types::chain_id::ChainId;
    
    #[test]
    fn test_restore_accepts_invalid_signature() {
        // Create a valid transaction
        let private_key = Ed25519PrivateKey::generate_for_testing();
        let public_key = private_key.public_key();
        let sender = AccountAddress::random();
        
        let raw_txn = RawTransaction::new_script(
            sender,
            0,
            Script::new(vec![], vec![], vec![]),
            100000,
            0,
            0,
            ChainId::test(),
        );
        
        let mut signed_txn = SignedTransaction::new(
            raw_txn.clone(),
            public_key.clone(),
            private_key.sign(&raw_txn).unwrap(),
        );
        
        // Corrupt the signature
        let wrong_key = Ed25519PrivateKey::generate_for_testing();
        signed_txn = SignedTransaction::new(
            raw_txn,
            public_key,
            wrong_key.sign(&signed_txn.clone().into_raw_transaction()).unwrap(),
        );
        
        // Verify signature check fails normally
        assert!(signed_txn.verify_signature().is_err());
        
        // Create a fake backup with this invalid transaction
        // and accompanying Merkle proof (assume attacker has access to backup)
        // ... setup code for fake backup ...
        
        // During restore with VerifyExecutionMode::NoVerify,
        // this transaction would be accepted without signature verification
        let txn = Transaction::UserTransaction(signed_txn);
        
        // In restore path, txn goes through remove_and_apply()
        // which does NOT check signatures
        // This demonstrates the vulnerability
    }
}
```

**Notes:**

This vulnerability highlights a critical gap in the restore process's defense-in-depth strategy. While Merkle proof verification provides cryptographic assurance that transactions were in the original ledger, it does not validate that those transactions were properly validated when originally committed. Signature verification should always be performed as a fundamental invariant check, even during restore operations, to prevent propagation of invalid state.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L553-637)
```rust
    // only apply KV to the DB
    async fn replay_kv(
        &self,
        restore_handler: &RestoreHandler,
        txns_to_execute_stream: impl Stream<
            Item = Result<(
                Transaction,
                PersistedAuxiliaryInfo,
                TransactionInfo,
                WriteSet,
                Vec<ContractEvent>,
            )>,
        >,
    ) -> Result<()> {
        let (first_version, _) = self.replay_from_version.unwrap();
        restore_handler.force_state_version_for_kv_restore(first_version.checked_sub(1))?;

        let mut base_version = first_version;
        let mut offset = 0u64;
        let replay_start = Instant::now();
        let arc_restore_handler = Arc::new(restore_handler.clone());

        let db_commit_stream = txns_to_execute_stream
            .try_chunks(BATCH_SIZE)
            .err_into::<anyhow::Error>()
            .map_ok(|chunk| {
                let (txns, persisted_aux_info, txn_infos, write_sets, events): (
                    Vec<_>,
                    Vec<_>,
                    Vec<_>,
                    Vec<_>,
                    Vec<_>,
                ) = chunk.into_iter().multiunzip();
                let handler = arc_restore_handler.clone();
                base_version += offset;
                offset = txns.len() as u64;
                async move {
                    let _timer = OTHER_TIMERS_SECONDS.timer_with(&["replay_txn_chunk_kv_only"]);
                    tokio::task::spawn_blocking(move || {
                        // we directly save transaction and kvs to DB without involving chunk executor
                        handler.save_transactions_and_replay_kv(
                            base_version,
                            &txns,
                            &persisted_aux_info,
                            &txn_infos,
                            &events,
                            write_sets,
                        )?;
                        // return the last version after the replaying
                        Ok(base_version + offset - 1)
                    })
                    .err_into::<anyhow::Error>()
                    .await
                }
            })
            .try_buffered_x(self.global_opt.concurrent_downloads, 1)
            .and_then(future::ready);

        let total_replayed = db_commit_stream
            .and_then(|version| async move {
                let _timer = OTHER_TIMERS_SECONDS.timer_with(&["commit_txn_chunk_kv_only"]);
                tokio::task::spawn_blocking(move || {
                    // version is the latest version finishing the KV replaying
                    let total_replayed = version - first_version;
                    TRANSACTION_REPLAY_VERSION.set(version as i64);
                    info!(
                        version = version,
                        accumulative_tps =
                            (total_replayed as f64 / replay_start.elapsed().as_secs_f64()) as u64,
                        "KV replayed."
                    );
                    Ok(version)
                })
                .await?
            })
            .try_fold(0, |_total, total| future::ok(total))
            .await?;
        info!(
            total_replayed = total_replayed,
            accumulative_tps =
                (total_replayed as f64 / replay_start.elapsed().as_secs_f64()) as u64,
            "KV Replay finished."
        );
        Ok(())
    }
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L360-371)
```rust
            TransactionRestoreBatchController::new(
                self.global_opt,
                self.storage,
                txn_manifests,
                first_version,
                replay_version,
                epoch_history,
                VerifyExecutionMode::NoVerify,
                None,
            )
            .run()
            .await?;
```

**File:** execution/executor-types/src/lib.rs (L240-242)
```rust
    pub fn should_verify(&self) -> bool {
        !matches!(self, Self::NoVerify)
    }
```

**File:** execution/executor/src/chunk_executor/mod.rs (L562-585)
```rust
            let next_begin = if verify_execution_mode.should_verify() {
                self.verify_execution(
                    transactions,
                    persisted_aux_info,
                    transaction_infos,
                    write_sets,
                    event_vecs,
                    batch_begin,
                    batch_end,
                    verify_execution_mode,
                )?
            } else {
                batch_end
            };
            self.remove_and_apply(
                transactions,
                persisted_aux_info,
                transaction_infos,
                write_sets,
                event_vecs,
                batch_begin,
                next_begin,
            )?;
            chunks_enqueued += 1;
```

**File:** execution/executor/src/chunk_executor/mod.rs (L606-611)
```rust
        let txns = transactions
            .iter()
            .take((end_version - begin_version) as usize)
            .cloned()
            .map(|t| t.into())
            .collect::<Vec<SignatureVerifiedTransaction>>();
```

**File:** types/src/transaction/signature_verified_transaction.rs (L129-138)
```rust
impl From<Transaction> for SignatureVerifiedTransaction {
    fn from(txn: Transaction) -> Self {
        match txn {
            Transaction::UserTransaction(txn) => match txn.verify_signature() {
                Ok(_) => SignatureVerifiedTransaction::Valid(Transaction::UserTransaction(txn)),
                Err(_) => SignatureVerifiedTransaction::Invalid(Transaction::UserTransaction(txn)),
            },
            _ => SignatureVerifiedTransaction::Valid(txn),
        }
    }
```

**File:** types/src/transaction/mod.rs (L2318-2332)
```rust
        self.transactions
            .par_iter()
            .zip_eq(self.proof.transaction_infos.par_iter())
            .map(|(txn, txn_info)| {
                let txn_hash = CryptoHash::hash(txn);
                ensure!(
                    txn_hash == txn_info.transaction_hash(),
                    "The hash of transaction does not match the transaction info in proof. \
                     Transaction hash: {:x}. Transaction hash in txn_info: {:x}.",
                    txn_hash,
                    txn_info.transaction_hash(),
                );
                Ok(())
            })
            .collect::<Result<Vec<_>>>()?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3232-3237)
```rust
        let txn = match transaction.check_signature() {
            Ok(t) => t,
            _ => {
                return VMValidatorResult::error(StatusCode::INVALID_SIGNATURE);
            },
        };
```
