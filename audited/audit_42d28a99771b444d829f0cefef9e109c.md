# Audit Report

## Title
Database Verification Proceeds with Incomplete State Due to Incorrect OverallCommitProgress Metadata

## Summary
The `replay_on_archive` tool can verify transactions using incomplete state when `OverallCommitProgress` metadata is set higher than the actual available state during database restore operations. This breaks deterministic execution guarantees and can produce incorrect verification results.

## Finding Description

The vulnerability exists in how the database restore process sets commit progress metadata and how the replay verification tool relies on it. The attack surface spans two components:

**Component 1: Incorrect Metadata During Restore** [1](#0-0) 

During restore operations, when `save_transactions` is called with `kv_replay=false`, the function writes transactions to the database but conditionally skips state replay (line 269-277). However, `OverallCommitProgress` is unconditionally set to `last_version` (lines 286-291), even when state was not replayed.

**Component 2: Unvalidated State During Verification** [2](#0-1) 

The `get_start_and_limit()` function uses `get_synced_version()` which reads `OverallCommitProgress` as the source of truth for database sync status. If this returns a value, verification proceeds assuming state is available up to that version. [3](#0-2) 

During verification, the tool creates state views at specific versions to execute transactions. When state doesn't exist (because it wasn't replayed during restore), the state read operations return `Ok(None)`. [4](#0-3) 

The database cannot distinguish between "state key doesn't exist" versus "state database is incomplete at this version." Both cases return `Ok(None)`, allowing execution to proceed with missing state treated as empty.

**Attack Scenario:**
1. Restore transactions using `save_transactions(..., kv_replay=false)` - transactions 0-100 are written
2. State is NOT replayed (state_kv_db remains incomplete)  
3. `OverallCommitProgress` is incorrectly set to version 100
4. Run `replay_on_archive` verification tool
5. Tool reads `get_synced_version()` â†’ returns Some(100)
6. Verification proceeds for transactions 0-100
7. When executing transaction 51, state view at version 50 is created
8. State reads return `Ok(None)` for missing keys (incomplete state, not deleted keys)
9. VM treats missing state as non-existent and executes accordingly
10. Verification produces incorrect results based on incomplete state

This breaks the **Deterministic Execution** invariant - different nodes with different state availability could produce different verification results for the same transactions.

## Impact Explanation

This is a **HIGH severity** vulnerability based on Aptos bug bounty criteria:

1. **Significant Protocol Violations**: The verification tool is designed to ensure transaction execution determinism. Allowing verification with incomplete state violates this fundamental guarantee.

2. **State Inconsistencies**: Verification results will differ between complete and incomplete databases, potentially allowing corrupted or manipulated databases to pass verification checks that should fail.

3. **Consensus Implications**: While not directly affecting live consensus, validators and node operators rely on verification tools to validate their database integrity. Incorrect verification results could lead to acceptance of invalid state.

4. **Attack Surface**: An attacker could craft a malicious archive/backup with transactions but incomplete state, set `OverallCommitProgress` appropriately, and have it pass verification when it shouldn't.

The vulnerability specifically affects the integrity of the database verification process, which is critical for maintaining network consistency.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

This vulnerability can occur in several realistic scenarios:

1. **Normal Restore Operations**: The restore handler explicitly calls `save_transactions` with `kv_replay=false` for initial transaction loading: [5](#0-4) 

2. **Archive Databases**: Archives created for historical analysis may have transactions without full state replay, yet set `OverallCommitProgress` through the restore process.

3. **Incomplete Restores**: If a restore operation is interrupted or partially completed, `OverallCommitProgress` may be set while state remains incomplete.

4. **Malicious Archives**: An attacker could craft a backup with this inconsistency to bypass verification checks.

The vulnerability requires access to the database restoration process, but doesn't require privileged validator credentials - any node operator performing database operations could encounter this.

## Recommendation

**Fix 1: Conditional OverallCommitProgress Update**

Modify `save_transactions_impl` to only set `OverallCommitProgress` when state has been properly replayed:

```rust
// Only set OverallCommitProgress if state was actually replayed
if kv_replay && first_version > 0 && state_store.get_usage(Some(first_version - 1)).is_ok() {
    ledger_db_batch
        .ledger_metadata_db_batches
        .put::<DbMetadataSchema>(
            &DbMetadataKey::OverallCommitProgress,
            &DbMetadataValue::Version(last_version),
        )?;
}
```

**Fix 2: State Availability Validation in Verification**

Add explicit state availability check in `get_start_and_limit()`:

```rust
let db_end = aptos_db
    .get_synced_version()?
    .ok_or(AptosDbError::NotFound("Synced version is None".to_string()))?;

// Validate that state is actually available at this version
// by checking if we can retrieve usage information
aptos_db.get_state_storage_usage(Some(db_end))
    .map_err(|_| AptosDbError::Other(
        format!("State not available at synced version {}", db_end)
    ))?;
```

**Fix 3: Separate State Commit Progress Tracking**

Introduce a separate metadata key `StateCommitProgress` to track state availability independently from transaction commit progress, ensuring verification can distinguish between transaction availability and state availability.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[test]
fn test_incomplete_state_verification() {
    // 1. Create database and save transactions WITHOUT state replay
    let db = create_test_db();
    let txns = create_test_transactions(100); // versions 0-99
    
    // Save transactions with kv_replay=false
    restore_handler.save_transactions(
        0,
        &txns,
        &aux_info,
        &txn_infos,
        &events,
        &write_sets,
    ).unwrap();
    
    // 2. Verify OverallCommitProgress is set to 99
    let synced_version = db.get_synced_version().unwrap();
    assert_eq!(synced_version, Some(99));
    
    // 3. Run replay_on_archive verification
    let verifier = Verifier::new(&replay_config).unwrap();
    
    // 4. Verification proceeds without error
    let result = verifier.run();
    assert!(result.is_ok()); // BUG: Should fail but doesn't!
    
    // 5. Verify that state was NOT available during execution
    // by checking state_kv_db directly
    for version in 0..100 {
        let state = db.state_store.get_state_value_by_version(&test_key, version);
        // State returns None for incomplete database
        assert!(state.unwrap().is_none());
    }
    
    // Expected: Verification should have failed due to incomplete state
    // Actual: Verification proceeds, treating missing state as empty
}
```

## Notes

A secondary bug was also identified at line 348 where the function returns `(start_version, limit)` instead of `(start, limit)`, which could cause the tool to attempt reading pruned transactions. However, this causes the tool to fail with an error rather than allowing incorrect verification, so it's a bug but not a security vulnerability in the same category. [6](#0-5) 

The calculated `start` value accounts for pruned transactions but the return value uses the original `start_version` parameter, creating a mismatch between the intended and actual verification range.

### Citations

**File:** storage/aptosdb/src/backup/restore_utils.rs (L269-291)
```rust
    if kv_replay && first_version > 0 && state_store.get_usage(Some(first_version - 1)).is_ok() {
        let (ledger_state, _hot_state_updates) = state_store.calculate_state_and_put_updates(
            &StateUpdateRefs::index_write_sets(first_version, write_sets, write_sets.len(), vec![]),
            &mut ledger_db_batch.ledger_metadata_db_batches, // used for storing the storage usage
            state_kv_batches,
        )?;
        // n.b. ideally this is set after the batches are committed
        state_store.set_state_ignoring_summary(ledger_state);
    }

    let last_version = first_version + txns.len() as u64 - 1;
    ledger_db_batch
        .ledger_metadata_db_batches
        .put::<DbMetadataSchema>(
            &DbMetadataKey::LedgerCommitProgress,
            &DbMetadataValue::Version(last_version),
        )?;
    ledger_db_batch
        .ledger_metadata_db_batches
        .put::<DbMetadataSchema>(
            &DbMetadataKey::OverallCommitProgress,
            &DbMetadataValue::Version(last_version),
        )?;
```

**File:** storage/db-tool/src/replay_on_archive.rs (L318-349)
```rust
    fn get_start_and_limit(
        aptos_db: &Arc<dyn DbReader>,
        start_version: Version,
        end_version: Version,
    ) -> Result<(Version, u64)> {
        let db_start = aptos_db
            .get_first_txn_version()?
            .ok_or(AptosDbError::NotFound(
                "First txn version is None".to_string(),
            ))?;
        let start = std::cmp::max(db_start, start_version);

        let db_end = aptos_db
            .get_synced_version()?
            .ok_or(AptosDbError::NotFound("Synced version is None".to_string()))?;
        let end = std::cmp::min(end_version, db_end);

        let limit = if start <= end {
            end - start + 1
        } else {
            warn!(
                start = start_version,
                db_start = db_start,
                end = end_version,
                db_end = db_end,
                "No transactions to verify in requested range."
            );
            0
        };

        Ok((start_version, limit))
    }
```

**File:** storage/db-tool/src/replay_on_archive.rs (L376-386)
```rust
            .execute_block(
                &txns_provider,
                &self
                    .arc_db
                    .state_view_at_version(current_version.checked_sub(1))?,
                BlockExecutorConfigFromOnchain::new_no_block_limit(),
                TransactionSliceMetadata::Chunk {
                    begin: *current_version,
                    end: *current_version + cur_txns.len() as u64,
                },
            )
```

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L27-46)
```rust
    fn get(&self, key: &StateKey) -> StateViewResult<Option<(Version, StateValue)>> {
        if let Some(version) = self.version {
            if let Some(root_hash) = self.maybe_verify_against_state_root_hash {
                // TODO(aldenhu): sample-verify proof inside DB
                // DB doesn't support returning proofs for buffered state, so only optionally
                // verify proof.
                // TODO: support returning state proof for buffered state.
                if let Ok((value, proof)) =
                    self.db.get_state_value_with_proof_by_version(key, version)
                {
                    proof.verify(root_hash, *key.crypto_hash_ref(), value.as_ref())?;
                }
            }
            Ok(self
                .db
                .get_state_value_with_version_by_version(key, version)?)
        } else {
            Ok(None)
        }
    }
```

**File:** storage/aptosdb/src/backup/restore_handler.rs (L90-98)
```rust
            first_version,
            txns,
            persisted_aux_info,
            txn_infos,
            events,
            write_sets,
            None,
            false,
        )
```
