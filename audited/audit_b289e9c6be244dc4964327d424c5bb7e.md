# Audit Report

## Title
Indexer gRPC Service Crash Due to Unhandled TransactionType Enum Conversion Failure

## Summary
The `parse_transaction_filter()` function accepts transaction filters with valid protobuf-defined transaction type values, but the `matches()` function in `TransactionRootFilter` panics when encountering blockchain transactions with transaction type values that are defined in the protobuf schema but not yet present in the compiled Rust `TransactionType` enum. This causes a complete crash of the indexer gRPC service.

## Finding Description
The vulnerability exists in the transaction matching logic where protobuf schema evolution can cause runtime panics. The attack flow is:

1. A user creates a legitimate filter using `parse_transaction_filter()` with a transaction type filter (e.g., filtering for `TRANSACTION_TYPE_USER`) [1](#0-0) 

2. The filter is successfully parsed and validated without errors [2](#0-1) 

3. When the indexer processes blockchain transactions, the `matches()` function is called to check if transactions match the filter [3](#0-2) 

4. The critical vulnerability occurs at line 69 where `TransactionType::try_from(item.r#type).expect("Invalid transaction type")` is called. The `item.r#type` field is stored as an `i32` in the protobuf-generated Transaction struct [4](#0-3) 

5. The `TransactionType` enum only contains specific variants (0, 1, 2, 3, 4, 20, 21), with values 5-19 explicitly skipped [5](#0-4) 

6. If a transaction arrives with `r#type` set to any value not in the enum (e.g., 5-19, or any future transaction type added to the protobuf definition), `try_from()` returns an `Err`, and the `.expect()` panics, crashing the entire indexer process.

This scenario realistically occurs when:
- The protobuf schema is updated to add new transaction types
- The blockchain starts producing transactions with these new types
- But the indexer binary hasn't been recompiled with the updated Rust enum definitions

## Impact Explanation
**Severity: High** (up to $50,000 per Aptos Bug Bounty)

This vulnerability causes **API crashes**, which is explicitly listed as High Severity in the bug bounty program. The impact includes:

- **Complete service unavailability**: Any transaction filter that checks transaction types will cause the indexer to panic and crash when processing transactions with unknown type values
- **Denial of Service**: All users relying on the indexer gRPC API lose access to transaction data
- **No authentication required**: Any user can trigger this by simply requesting a filtered transaction stream
- **Cascading failures**: The indexer crash affects all downstream applications and services depending on it

While this doesn't directly compromise blockchain consensus, it severely impacts the data availability layer that applications depend on.

## Likelihood Explanation
**Likelihood: Medium-High**

This vulnerability is highly likely to occur in production because:

1. **Version skew is common**: During rolling upgrades or when different components are deployed at different times, version mismatches naturally occur
2. **Protobuf evolution**: The comment "values 5-19 skipped for no reason" suggests the schema may be expanded in the future
3. **No validation**: There's no defensive check before calling `.expect()`, making the crash deterministic once the condition is met
4. **Easy to trigger**: Any user requesting filtered transactions triggers the vulnerable code path

The attack complexity is minimal - an attacker simply needs to send a transaction filter request when the blockchain contains transactions with newer types.

## Recommendation
Replace the `.expect()` panic with proper error handling. The function should gracefully handle unknown transaction types:

**Option 1: Skip unknown types (recommended)**
```rust
fn matches(&self, item: &Transaction) -> bool {
    if !self
        .success
        .matches_opt(&item.info.as_ref().map(|i| i.success))
    {
        return false;
    }

    if let Some(txn_type) = &self.txn_type {
        // Gracefully handle unknown transaction types by treating them as non-matching
        match TransactionType::try_from(item.r#type) {
            Ok(item_type) => {
                if txn_type != &item_type {
                    return false;
                }
            }
            Err(_) => {
                // Unknown transaction type - doesn't match any filter
                return false;
            }
        }
    }

    true
}
```

**Option 2: Log and skip**
```rust
if let Some(txn_type) = &self.txn_type {
    match TransactionType::try_from(item.r#type) {
        Ok(item_type) => {
            if txn_type != &item_type {
                return false;
            }
        }
        Err(e) => {
            tracing::warn!(
                "Encountered unknown transaction type {}: {}. Skipping match.",
                item.r#type,
                e
            );
            return false;
        }
    }
}
```

## Proof of Concept
```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_protos::transaction::v1::{Transaction, TransactionInfo};

    #[test]
    #[should_panic(expected = "Invalid transaction type")]
    fn test_crash_on_unknown_transaction_type() {
        // Create a filter that checks for User transactions
        let filter = TransactionRootFilter {
            success: None,
            txn_type: Some(TransactionType::User),
        };

        // Create a transaction with an unknown type (e.g., 5)
        // This simulates a new transaction type added to protobuf
        // but not yet in the Rust enum
        let mut txn = Transaction::default();
        txn.r#type = 5; // Unknown type not in the enum
        txn.info = Some(TransactionInfo {
            success: true,
            ..Default::default()
        });

        // This will panic with "Invalid transaction type"
        // causing the indexer to crash
        filter.matches(&txn);
    }

    #[test]
    fn test_graceful_handling_of_unknown_type() {
        // This test demonstrates the recommended fix
        // The filter should return false for unknown types
        // instead of panicking
        let filter = TransactionRootFilter {
            success: None,
            txn_type: Some(TransactionType::User),
        };

        let mut txn = Transaction::default();
        txn.r#type = 5; // Unknown type
        txn.info = Some(TransactionInfo {
            success: true,
            ..Default::default()
        });

        // Should return false, not panic
        // assert!(!filter.matches(&txn));  // With fix applied
    }
}
```

## Notes
This vulnerability specifically affects the indexer gRPC service's transaction filtering functionality. While the indexer is not part of the core blockchain consensus mechanism, it is a critical infrastructure component that many applications rely on for data access. The panic-based error handling using `.expect()` on protobuf enum conversions is an anti-pattern that should be avoided throughout the codebase, as it creates crash vulnerabilities during schema evolution.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs (L9-15)
```rust
pub fn parse_transaction_filter(
    proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
    max_filter_size_bytes: usize,
) -> Result<BooleanTransactionFilter, Status> {
    BooleanTransactionFilter::new_from_proto(proto_filter, Some(max_filter_size_bytes))
        .map_err(|e| Status::invalid_argument(format!("Invalid transaction_filter: {e:?}.")))
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L94-127)
```rust
    pub fn new_from_proto(
        proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
        max_filter_size: Option<usize>,
    ) -> Result<Self> {
        if let Some(max_filter_size) = max_filter_size {
            ensure!(
                proto_filter.encoded_len() <= max_filter_size,
                format!(
                    "Filter is too complicated. Max size: {} bytes, Actual size: {} bytes",
                    max_filter_size,
                    proto_filter.encoded_len()
                )
            );
        }
        Ok(
            match proto_filter
                .filter
                .ok_or(anyhow!("Oneof is not set in BooleanTransactionFilter."))?
            {
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::ApiFilter(
                    api_filter,
                ) => TryInto::<APIFilter>::try_into(api_filter)?.into(),
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::LogicalAnd(
                    logical_and,
                ) => BooleanTransactionFilter::And(logical_and.try_into()?),
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::LogicalOr(
                    logical_or,
                ) => BooleanTransactionFilter::Or(logical_or.try_into()?),
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::LogicalNot(
                    logical_not,
                ) => BooleanTransactionFilter::Not(logical_not.try_into()?),
            },
        )
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/transaction_root.rs (L58-77)
```rust
    #[inline]
    fn matches(&self, item: &Transaction) -> bool {
        if !self
            .success
            .matches_opt(&item.info.as_ref().map(|i| i.success))
        {
            return false;
        }

        if let Some(txn_type) = &self.txn_type {
            if txn_type
                != &TransactionType::try_from(item.r#type).expect("Invalid transaction type")
            {
                return false;
            }
        }

        true
    }
}
```

**File:** protos/rust/src/pb/aptos.transaction.v1.rs (L50-57)
```rust
    pub block_height: u64,
    #[prost(enumeration="transaction::TransactionType", tag="6")]
    pub r#type: i32,
    #[prost(message, optional, tag="22")]
    pub size_info: ::core::option::Option<TransactionSizeInfo>,
    #[prost(oneof="transaction::TxnData", tags="7, 8, 9, 10, 21, 23")]
    pub txn_data: ::core::option::Option<transaction::TxnData>,
}
```

**File:** protos/rust/src/pb/aptos.transaction.v1.rs (L60-71)
```rust
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum TransactionType {
        Unspecified = 0,
        Genesis = 1,
        BlockMetadata = 2,
        StateCheckpoint = 3,
        User = 4,
        /// values 5-19 skipped for no reason
        Validator = 20,
        BlockEpilogue = 21,
    }
```
