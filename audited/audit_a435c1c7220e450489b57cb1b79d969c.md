# Audit Report

## Title
Network Topology Information Disclosure via Inspection Service Peer Information Endpoint

## Summary
The `/peer_information` endpoint of the Aptos Inspection Service exposes detailed network topology information including connected peer IP addresses, peer IDs, and validator roles through the `internal_client_state` field. This information is publicly accessible by default on port 9101 and could aid attackers in reconnaissance for targeted network-level attacks against validators.

## Finding Description

The vulnerability exists in the peer monitoring client's `get_internal_client_state()` function which creates a detailed JSON string containing all peer state information. This data flows through several components before being exposed via HTTP: [1](#0-0) 

The function serializes peer state entries to JSON, which includes `NetworkInfoState` containing network topology data: [2](#0-1) 

This state includes the `NetworkInformationResponse` which contains a map of connected peers with their network addresses and roles: [3](#0-2) 

The peer monitoring server populates this data by collecting connection metadata for all connected peers: [4](#0-3) 

This internal state is stored in the public `internal_client_state` field of `PeerMonitoringMetadata`: [5](#0-4) 

The metadata is then exposed via the inspection service's `/peer_information` HTTP endpoint: [6](#0-5) 

The endpoint is accessible at the `/peer_information` path: [7](#0-6) 

And is **enabled by default** in the configuration: [8](#0-7) 

**Attack Flow:**
1. Attacker identifies an Aptos validator node
2. Sends HTTP GET request to `http://<validator-ip>:9101/peer_information`
3. Receives JSON response containing detailed peer topology including:
   - Network addresses (IP:port) of connected validators and VFNs
   - Peer IDs
   - Peer roles (validator, ValidatorFullNode, etc.)
   - Connection state and metadata
4. Uses this information for:
   - Mapping the validator network topology
   - Identifying validator IP addresses for targeted DDoS attacks
   - Understanding network connectivity patterns
   - Planning attacks against specific validators or network segments

## Impact Explanation

This vulnerability falls under **Medium Severity** according to the Aptos bug bounty criteria as it constitutes a sensitive information leak that aids attackers in targeting the node. While it doesn't directly lead to consensus violations or fund theft, it provides valuable reconnaissance information that significantly reduces the barrier for network-level attacks.

The exposed information includes:
- **Validator IP addresses**: Enables targeted DDoS attacks against specific validators
- **Network topology**: Reveals which validators are connected to which VFNs, allowing attackers to identify critical network paths
- **Peer roles**: Helps attackers distinguish between validators and full nodes for prioritized targeting

This aligns with the "Medium Severity" category: "State inconsistencies requiring intervention" as successful network attacks based on this information could lead to temporary validator disconnections or network partitioning requiring operator intervention.

## Likelihood Explanation

The likelihood of exploitation is **HIGH** due to:

1. **Trivial Exploitation**: Requires only a simple HTTP GET request with no authentication
2. **Default Enabled**: The `expose_peer_information` flag is set to `true` by default
3. **Public Exposure**: The inspection service binds to `0.0.0.0:9101` making it network-accessible
4. **No Rate Limiting**: The endpoint has no rate limiting or abuse prevention mechanisms
5. **Persistent Information**: The topology information remains accessible as long as the service runs

The only barrier is network access to port 9101, which may be firewalled in production environments. However, misconfigurations are common, and many operators may not realize this endpoint exposes sensitive topology data.

## Recommendation

**Immediate Mitigation:**
1. Change the default value of `expose_peer_information` to `false`
2. Add clear security warnings in documentation about the sensitivity of this endpoint
3. Implement IP whitelisting for the inspection service

**Long-term Fix:**
Remove network topology information from the `internal_client_state` field, or sanitize it before exposure. Modify the `get_internal_client_state()` function to exclude sensitive data:

```rust
fn get_internal_client_state(&self) -> Result<Option<String>, Error> {
    let mut client_state_strings = HashMap::new();
    for (state_key, state_value) in self.state_entries.read().iter() {
        let peer_state_label = state_key.get_label().to_string();
        // Sanitize the value to remove sensitive network information
        let peer_state_value = sanitize_peer_state_value(state_value.read().deref());
        client_state_strings.insert(peer_state_label, peer_state_value);
    }
    
    let client_state_string = serde_json::to_string_pretty(&client_state_strings)
        .map_err(|error| Error::UnexpectedError(format!(
            "Failed to serialize the client state string: {:?}", error
        )))?;
    Ok(Some(client_state_string))
}

fn sanitize_peer_state_value(state_value: &PeerStateValue) -> String {
    // Return only non-sensitive summary information
    match state_value {
        PeerStateValue::LatencyInfoState(_) => "Latency metrics available".to_string(),
        PeerStateValue::NetworkInfoState(_) => "Network info available (details redacted)".to_string(),
        PeerStateValue::NodeInfoState(_) => "Node info available".to_string(),
    }
}
```

Update configuration default: [8](#0-7) 

Change line 33 to: `expose_peer_information: false,`

## Proof of Concept

**Step 1: Start an Aptos node with default configuration** (inspection service enabled on port 9101)

**Step 2: Query the peer information endpoint:**
```bash
curl http://localhost:9101/peer_information
```

**Expected Output (demonstrating the vulnerability):**
```
Internal client state for each peer:
    - Peer: 00000000000000000000000000000000/vfn, internal client state: Some("{
  \"latency_info\": \"LatencyInfoState { latency_ping_counter, 42, recorded_latency_ping_durations_secs: {...} }\",
  \"network_info\": \"NetworkInfoState { recorded_network_info_response: Some(NetworkInformationResponse { 
    connected_peers: {
      PeerNetworkId { network_id: Validator, peer_id: 0xABCD1234... }: ConnectionMetadata { 
        network_address: /ip4/192.168.1.100/tcp/6180, 
        peer_id: 0xABCD1234..., 
        peer_role: Validator 
      },
      PeerNetworkId { network_id: Vfn, peer_id: 0xEF567890... }: ConnectionMetadata { 
        network_address: /ip4/192.168.1.101/tcp/6181, 
        peer_id: 0xEF567890..., 
        peer_role: ValidatorFullNode 
      }
    },
    distance_from_validators: 0 
  }) }\"
}")
```

This output reveals the complete network topology including IP addresses, ports, peer IDs, and validator roles - all sensitive information that aids attackers in targeting the network.

**Notes:**
- This vulnerability is exploitable on all Aptos nodes with default inspection service configuration
- The information exposed includes real-time network topology that updates as peer connections change
- No authentication or authorization is required to access this endpoint
- The Debug formatting of `NetworkInformationResponse` automatically exposes all fields including the sensitive `connected_peers` map

### Citations

**File:** peer-monitoring-service/client/src/peer_states/peer_state.rs (L276-293)
```rust
    fn get_internal_client_state(&self) -> Result<Option<String>, Error> {
        // Construct a string map for each of the state entries
        let mut client_state_strings = HashMap::new();
        for (state_key, state_value) in self.state_entries.read().iter() {
            let peer_state_label = state_key.get_label().to_string();
            let peer_state_value = format!("{}", state_value.read().deref());
            client_state_strings.insert(peer_state_label, peer_state_value);
        }

        // Pretty print and return the client state string
        let client_state_string =
            serde_json::to_string_pretty(&client_state_strings).map_err(|error| {
                Error::UnexpectedError(format!(
                    "Failed to serialize the client state string: {:?}",
                    error
                ))
            })?;
        Ok(Some(client_state_string))
```

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L197-204)
```rust
impl Display for NetworkInfoState {
    fn fmt(&self, f: &mut Formatter<'_>) -> fmt::Result {
        write!(
            f,
            "NetworkInfoState {{ recorded_network_info_response: {:?} }}",
            self.recorded_network_info_response
        )
    }
```

**File:** peer-monitoring-service/types/src/response.rs (L50-55)
```rust
/// A response for the network information request
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct NetworkInformationResponse {
    pub connected_peers: BTreeMap<PeerNetworkId, ConnectionMetadata>, // Connected peers
    pub distance_from_validators: u64, // The distance of the peer from the validator set
}
```

**File:** peer-monitoring-service/server/src/lib.rs (L217-247)
```rust
    fn get_network_information(&self) -> Result<PeerMonitoringServiceResponse, Error> {
        // Get the connected peers
        let connected_peers_and_metadata =
            self.peers_and_metadata.get_connected_peers_and_metadata()?;
        let connected_peers = connected_peers_and_metadata
            .into_iter()
            .map(|(peer, metadata)| {
                let connection_metadata = metadata.get_connection_metadata();
                (
                    peer,
                    ConnectionMetadata::new(
                        connection_metadata.addr,
                        connection_metadata.remote_peer_id,
                        connection_metadata.role,
                    ),
                )
            })
            .collect();

        // Get the distance from the validators
        let distance_from_validators =
            get_distance_from_validators(&self.base_config, self.peers_and_metadata.clone());

        // Create and return the response
        let network_information_response = NetworkInformationResponse {
            connected_peers,
            distance_from_validators,
        };
        Ok(PeerMonitoringServiceResponse::NetworkInformation(
            network_information_response,
        ))
```

**File:** peer-monitoring-service/types/src/lib.rs (L45-51)
```rust
pub struct PeerMonitoringMetadata {
    pub average_ping_latency_secs: Option<f64>, // The average latency ping for the peer
    pub latest_ping_latency_secs: Option<f64>,  // The latest latency ping for the peer
    pub latest_network_info_response: Option<NetworkInformationResponse>, // The latest network info response
    pub latest_node_info_response: Option<NodeInformationResponse>, // The latest node info response
    pub internal_client_state: Option<String>, // A detailed client state string for debugging and logging
}
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L128-146)
```rust
/// Displays the internal client state for each peer
fn display_internal_client_state(
    peer_information_output: &mut Vec<String>,
    all_peers: &Vec<PeerNetworkId>,
    peers_and_metadata: &PeersAndMetadata,
) {
    peer_information_output.push("Internal client state for each peer:".into());

    // Fetch and display the internal client state for each peer
    for peer in all_peers {
        if let Ok(peer_metadata) = peers_and_metadata.get_metadata_for_peer(*peer) {
            let peer_monitoring_metadata = peer_metadata.get_peer_monitoring_metadata();
            peer_information_output.push(format!(
                "\t- Peer: {}, internal client state: {:?}",
                peer, peer_monitoring_metadata.internal_client_state
            ));
        }
    }
}
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L40-40)
```rust
pub const PEER_INFORMATION_PATH: &str = "/peer_information";
```

**File:** config/src/config/inspection_service_config.rs (L26-36)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
```
