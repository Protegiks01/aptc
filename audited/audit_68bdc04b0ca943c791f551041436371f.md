# Audit Report

## Title
Indexer Ownership Inconsistency Due to Missing Sequence Numbers in Multi-Transfer Transactions

## Summary
TransferEvents do not include sequence numbers or version numbers in their payload structure. When multiple object transfers occur within a single transaction, the indexer discards all intermediate transfer events due to HashMap overwrites, causing ownership inconsistencies where previous owners incorrectly appear to still own NFTs in the `current_token_ownerships_v2` table.

## Finding Description

The `TransferEvent` struct contains only three fields without any ordering information: [1](#0-0) 

While V1 events do have sequence numbers at the `ContractEvent` wrapper level, these are per-EventHandle counters and not included in the TransferEvent payload itself: [2](#0-1) 

The critical vulnerability occurs in the indexer's event processing logic. When processing transaction events, the indexer stores transfer events in a HashMap keyed by object address: [3](#0-2) 

The HashMap insert at line 1183 **overwrites** any previously stored transfer event for the same object. If a transaction contains multiple transfers of the same object (e.g., Alice→Bob→Charlie), only the final transfer event (Bob→Charlie) is retained.

When creating ownership records, the indexer uses this stored transfer event to determine the "previous owner" for soft deletion: [4](#0-3) 

This creates ownership records for:
- The current owner (Charlie) with amount=1
- The previous owner from the event (Bob) with amount=0 (soft delete)
- **Missing**: Alice's soft delete record

The database upsert only updates existing records if a new record is inserted for that owner: [5](#0-4) 

Since no record is created for Alice in this transaction, her existing ownership record remains unchanged, resulting in both Alice and Charlie appearing to own the token.

**Attack Scenario:**
1. Initial state: Alice owns NFT at transaction version V-1
2. Multi-agent transaction V executes:
   - Alice transfers NFT to Bob (emits TransferEvent(from=Alice, to=Bob))
   - Bob transfers NFT to Charlie (emits TransferEvent(from=Bob, to=Charlie))
   - ObjectCore.owner = Charlie
3. Indexer processing:
   - Stores only TransferEvent(from=Bob, to=Charlie) due to HashMap overwrite
   - Creates: (NFT, Charlie, amount=1, version=V) ✓
   - Creates: (NFT, Bob, amount=0, version=V) ✓
   - **Missing**: (NFT, Alice, amount=0, version=V)
4. Result: Database shows both Alice (amount=1, stale) and Charlie (amount=1, current) as owners

## Impact Explanation

This constitutes **Medium severity** per the Aptos bug bounty criteria as "State inconsistencies requiring intervention":

- **Data Integrity Violation**: The indexer database violates the NFT uniqueness invariant where only one address should have amount=1 for a given non-fungible token
- **Financial Risk**: NFT marketplaces, wallets, and dApps relying on indexer data will display incorrect ownership, potentially enabling:
  - Double-listing attacks where both Alice and Charlie attempt to sell the same NFT
  - Incorrect access control in applications checking ownership via indexer queries
  - User confusion and loss of trust in ownership records
- **Scope**: Affects all NFT transfers in multi-agent transactions or programmatic transfer chains
- **Remediation Cost**: Requires database reindexing or manual cleanup to correct ownership records

While this does not affect on-chain consensus (ObjectCore.owner remains correct), it breaks critical integration guarantees for external applications.

## Likelihood Explanation

**High likelihood:**
- Multi-agent transactions are a standard Aptos feature requiring no special privileges
- Any user can construct a transaction with multiple signers
- Programmatic NFT transfer chains (e.g., marketplace escrow → buyer) naturally create this scenario
- The vulnerability triggers automatically without complex setup
- No existing validation prevents multiple transfers in a single transaction

The issue will manifest whenever:
1. A single transaction contains multiple transfers of the same object, OR
2. A script programmatically chains transfers using different signers

## Recommendation

**Fix 1: Track All Transfer Events (Recommended)**
Modify the indexer to store **all** transfer events for an object, not just the last one:

```rust
// In TokenV2AggregatedData struct
pub transfer_events: Vec<(EventIndex, TransferEvent)>,  // Changed from Option to Vec

// In event processing loop
if let Some(transfer_event) = TransferEvent::from_event(event, txn_version).unwrap() {
    if let Some(aggregated_data) = token_v2_metadata_helper.get_mut(&transfer_event.get_object_address()) {
        let index = if index == 0 { user_txn.events.len() } else { index };
        aggregated_data.transfer_events.push((index as i64, transfer_event));
    }
}

// In ownership creation, process all transfer events
for (event_index, transfer_event) in &metadata.transfer_events {
    // Create soft delete for each intermediate owner
    previous_ownerships.push(create_soft_delete(transfer_event.get_from_address()));
}
```

**Fix 2: Add Sequence Numbers to TransferEvent Payload**
Extend the TransferEvent structure to include explicit ordering:

```rust
pub struct TransferEvent {
    object: AccountAddress,
    from: AccountAddress,
    to: AccountAddress,
    sequence_number: u64,  // Add explicit sequence number
}
```

This requires a Move framework update and migration.

**Fix 3: Database Constraint Enforcement**
Add a database constraint ensuring only one owner has amount=1 per NFT, causing the indexer to fail fast on inconsistencies.

## Proof of Concept

```move
// Multi-agent transfer script demonstrating the vulnerability
script {
    use aptos_framework::object;
    use std::signer;

    fun exploit_ownership_tracking(
        alice: &signer,
        bob: &signer,
        nft_address: address,
    ) {
        // Assumes NFT has allow_ungated_transfer enabled
        // Alice transfers to Bob
        object::transfer_call(alice, nft_address, signer::address_of(bob));
        
        // Bob immediately transfers to Charlie
        object::transfer_call(bob, nft_address, @0xCHARLIE);
        
        // On-chain state: Charlie owns NFT ✓
        // Indexer state: Both Alice and Charlie appear to own NFT ✗
    }
}
```

**Verification Steps:**
1. Create an NFT owned by Alice
2. Submit the multi-agent transaction with Alice and Bob as signers
3. Query `current_token_ownerships_v2` table
4. Observe Alice still has amount=1 while Charlie also has amount=1
5. Verify on-chain ObjectCore.owner shows only Charlie

**Notes:**
- Requires multi-agent transaction support (standard Aptos feature)
- No special permissions needed
- Affects any NFT with ungated transfers enabled
- Database inconsistency persists until manual intervention or reindexing

### Citations

**File:** types/src/account_config/events/transfer_event.rs (L15-20)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct TransferEvent {
    object: AccountAddress,
    from: AccountAddress,
    to: AccountAddress,
}
```

**File:** types/src/contract_event.rs (L178-190)
```rust
#[derive(Hash, Clone, Eq, PartialEq, Serialize, Deserialize, CryptoHasher)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct ContractEventV1 {
    /// The unique key that the event was emitted to
    key: EventKey,
    /// The number of messages that have been emitted to the path previously
    sequence_number: u64,
    /// The type of the data
    type_tag: TypeTag,
    /// The data payload of the event
    #[serde(with = "serde_bytes")]
    event_data: Vec<u8>,
}
```

**File:** crates/indexer/src/processors/token_processor.rs (L762-795)
```rust
fn insert_current_token_ownerships_v2(
    conn: &mut PgConnection,
    items_to_insert: &[CurrentTokenOwnershipV2],
) -> Result<(), diesel::result::Error> {
    use schema::current_token_ownerships_v2::dsl::*;

    let chunks = get_chunks(
        items_to_insert.len(),
        CurrentTokenOwnershipV2::field_count(),
    );

    for (start_ind, end_ind) in chunks {
        execute_with_better_error(
            conn,
            diesel::insert_into(schema::current_token_ownerships_v2::table)
                .values(&items_to_insert[start_ind..end_ind])
                .on_conflict((token_data_id, property_version_v1, owner_address, storage_id))
                .do_update()
                .set((
                    amount.eq(excluded(amount)),
                    table_type_v1.eq(excluded(table_type_v1)),
                    token_properties_mutated_v1.eq(excluded(token_properties_mutated_v1)),
                    is_soulbound_v2.eq(excluded(is_soulbound_v2)),
                    token_standard.eq(excluded(token_standard)),
                    is_fungible_v2.eq(excluded(is_fungible_v2)),
                    last_transaction_version.eq(excluded(last_transaction_version)),
                    last_transaction_timestamp.eq(excluded(last_transaction_timestamp)),
                    inserted_at.eq(excluded(inserted_at)),
                    non_transferrable_by_owner.eq(excluded(non_transferrable_by_owner)),
                )),
            Some(" WHERE current_token_ownerships_v2.last_transaction_version <= excluded.last_transaction_version "),
        )?;
    }
    Ok(())
```

**File:** crates/indexer/src/processors/token_processor.rs (L1172-1184)
```rust
                if let Some(transfer_event) = TransferEvent::from_event(event, txn_version).unwrap()
                {
                    if let Some(aggregated_data) =
                        token_v2_metadata_helper.get_mut(&transfer_event.get_object_address())
                    {
                        // we don't want index to be 0 otherwise we might have collision with write set change index
                        let index = if index == 0 {
                            user_txn.events.len()
                        } else {
                            index
                        };
                        aggregated_data.transfer_event = Some((index as i64, transfer_event));
                    }
```

**File:** crates/indexer/src/models/token_models/v2_token_ownerships.rs (L165-210)
```rust
        // check if token was transferred
        if let Some((event_index, transfer_event)) = &metadata.transfer_event {
            // If it's a self transfer then skip
            if transfer_event.get_to_address() == transfer_event.get_from_address() {
                return Ok(Some((ownership, current_ownership, None, None)));
            }
            Ok(Some((
                ownership,
                current_ownership,
                Some(Self {
                    transaction_version: token_data.transaction_version,
                    // set to negative of event index to avoid collison with write set index
                    write_set_change_index: -1 * event_index,
                    token_data_id: token_data_id.clone(),
                    property_version_v1: BigDecimal::zero(),
                    // previous owner
                    owner_address: Some(transfer_event.get_from_address()),
                    storage_id: storage_id.clone(),
                    // soft delete
                    amount: BigDecimal::zero(),
                    table_type_v1: None,
                    token_properties_mutated_v1: None,
                    is_soulbound_v2: Some(is_soulbound),
                    token_standard: TokenStandard::V2.to_string(),
                    is_fungible_v2: token_data.is_fungible_v2,
                    transaction_timestamp: token_data.transaction_timestamp,
                    non_transferrable_by_owner: Some(is_soulbound),
                }),
                Some(CurrentTokenOwnershipV2 {
                    token_data_id,
                    property_version_v1: BigDecimal::zero(),
                    // previous owner
                    owner_address: transfer_event.get_from_address(),
                    storage_id,
                    // soft delete
                    amount: BigDecimal::zero(),
                    table_type_v1: None,
                    token_properties_mutated_v1: None,
                    is_soulbound_v2: Some(is_soulbound),
                    token_standard: TokenStandard::V2.to_string(),
                    is_fungible_v2: token_data.is_fungible_v2,
                    last_transaction_version: token_data.transaction_version,
                    last_transaction_timestamp: token_data.transaction_timestamp,
                    non_transferrable_by_owner: Some(is_soulbound),
                }),
            )))
```
