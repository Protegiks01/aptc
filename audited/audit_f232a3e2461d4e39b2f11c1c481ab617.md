# Audit Report

## Title
Unvalidated FullnodeInfo in PingFullnodeResponse Enables Denial of Service and Data Integrity Attacks

## Summary
The `metadata_manager.rs` module in the indexer-grpc-manager component consumes `FullnodeInfo` data from `PingFullnodeResponse` without validating critical fields like `known_latest_version` and `chain_id`. A malicious fullnode can send an inflated `known_latest_version` (e.g., `u64::MAX`) to monopolize all transaction request routing, leading to service disruption and potential data corruption in the indexer infrastructure.

## Finding Description
The vulnerability exists in how the indexer-grpc-manager handles fullnode metadata updates via the `PingFullnodeResponse` message. [1](#0-0) [2](#0-1) 

When a fullnode responds to a ping request, the `handle_fullnode_info` function processes the response without validation: [3](#0-2) 

The vulnerability manifests in three ways:

**1. Version Inflation Attack:**
The `known_latest_version` field is accepted without bounds checking and used to update a global version tracker via `fetch_max`, meaning it can only increase: [4](#0-3) 

**2. Preferential Selection Exploitation:**
The inflated version makes the malicious fullnode preferentially selected for ALL transaction requests because the selection logic filters nodes where `known_latest_version >= request.starting_version`: [5](#0-4) 

**3. No Chain ID Validation:**
Unlike the transaction streaming validation which checks chain IDs, the ping handler accepts any chain_id value without comparing it against the expected chain ID stored in `self.chain_id`.

**Attack Scenario:**
1. Attacker runs a malicious fullnode and connects to the indexer-grpc-manager
2. When pinged, the malicious node sends `PingFullnodeResponse` with `FullnodeInfo { chain_id: <valid>, known_latest_version: Some(u64::MAX), ... }`
3. The metadata_manager stores this value and updates the global known_latest_version to u64::MAX
4. For all subsequent transaction requests, `get_fullnode_for_request` always selects the malicious node (since u64::MAX >= any_requested_version)
5. The malicious node can then:
   - Refuse to respond → DoS
   - Send corrupted transaction data → data integrity compromise
   - Send incomplete data → indexer corruption
   - Intermittently fail → service instability [6](#0-5) 

## Impact Explanation
This vulnerability qualifies as **High Severity** under the Aptos Bug Bounty program criteria:

- **Validator node slowdowns**: The indexer infrastructure is critical for blockchain operation; disrupting it affects validators' ability to monitor network state
- **API crashes**: When the malicious fullnode refuses service, the data_manager's streaming requests fail, causing API unavailability
- **Significant protocol violations**: The indexer serves incorrect or incomplete blockchain data to clients, violating data integrity guarantees

The indexer-grpc system is a critical component of the Aptos infrastructure, used by:
- Block explorers and analytics platforms
- Wallet backends for transaction history
- DApps for querying on-chain state
- Monitoring and alerting systems

A successful attack disrupts the entire ecosystem's ability to access blockchain data reliably.

## Likelihood Explanation
**Likelihood: High**

Attack requirements are minimal:
- Attacker needs to run a fullnode and register it with the indexer-grpc-manager (standard operation)
- No privileged access, validator keys, or stake required
- Attack is trivial to execute (single malicious response message)
- No cryptographic operations to bypass
- Detection is difficult as the malicious node appears to have the "latest" version

The attack is **persistent** - once the global `known_latest_version` is set to u64::MAX via `fetch_max`, it cannot decrease, ensuring the malicious node remains preferentially selected even after legitimate nodes are updated.

## Recommendation
Implement comprehensive validation in `handle_fullnode_info`:

```rust
fn handle_fullnode_info(&self, address: GrpcAddress, info: FullnodeInfo) -> Result<()> {
    // Validate chain_id matches expected value
    if info.chain_id != self.chain_id {
        bail!("Chain ID mismatch: expected {}, got {}", self.chain_id, info.chain_id);
    }
    
    // Validate known_latest_version is reasonable
    if let Some(version) = info.known_latest_version {
        let current_max = self.known_latest_version.load(Ordering::SeqCst);
        // Reject versions that are suspiciously far ahead (e.g., >1 million blocks)
        const MAX_VERSION_DELTA: u64 = 1_000_000;
        if version > current_max + MAX_VERSION_DELTA {
            bail!(
                "Suspicious version from fullnode {}: {} (current max: {})",
                address, version, current_max
            );
        }
    }
    
    // Validate timestamp is not too far in future
    if let Some(timestamp) = info.timestamp {
        const MAX_CLOCK_DRIFT_SECS: u64 = 300; // 5 minutes
        let now = SystemTime::now().duration_since(UNIX_EPOCH).unwrap();
        let timestamp_duration = Duration::new(timestamp.seconds as u64, timestamp.nanos as u32);
        if timestamp_duration > now + Duration::from_secs(MAX_CLOCK_DRIFT_SECS) {
            bail!("Timestamp from fullnode {} is too far in future", address);
        }
    }
    
    let mut entry = self
        .fullnodes
        .entry(address.clone())
        .or_insert(Fullnode::new(address.clone()));
    entry.value_mut().recent_states.push_back(info);
    if let Some(known_latest_version) = info.known_latest_version {
        trace!(
            "Received known_latest_version ({known_latest_version}) from fullnode {address}."
        );
        self.update_known_latest_version(known_latest_version);
    }
    if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
        entry.value_mut().recent_states.pop_front();
    }

    Ok(())
}
```

Additionally, implement rate limiting and anomaly detection for rapid version jumps.

## Proof of Concept

```rust
// PoC demonstrating the vulnerability
// Add to ecosystem/indexer-grpc/indexer-grpc-manager/tests/

#[tokio::test]
async fn test_malicious_fullnode_version_inflation() {
    use aptos_protos::indexer::v1::FullnodeInfo;
    use aptos_protos::internal::fullnode::v1::{PingFullnodeRequest, PingFullnodeResponse};
    
    // Setup: Create a metadata_manager with one legitimate fullnode
    let manager = MetadataManager::new(
        1, // chain_id
        "127.0.0.1:50051".to_string(),
        vec![],
        vec!["127.0.0.1:50052".to_string()], // legitimate fullnode
        None,
    );
    
    // Step 1: Legitimate fullnode reports reasonable version
    let legit_info = FullnodeInfo {
        chain_id: 1,
        timestamp: Some(timestamp_now_proto()),
        known_latest_version: Some(1000),
    };
    manager.handle_fullnode_info("127.0.0.1:50052".to_string(), legit_info).unwrap();
    
    // Step 2: Malicious fullnode sends inflated version
    let malicious_info = FullnodeInfo {
        chain_id: 1,
        timestamp: Some(timestamp_now_proto()),
        known_latest_version: Some(u64::MAX), // Malicious inflation
    };
    manager.handle_fullnode_info("127.0.0.1:50053".to_string(), malicious_info).unwrap();
    
    // Step 3: Verify malicious node is always selected
    let request = GetTransactionsFromNodeRequest {
        starting_version: Some(5000),
        transactions_count: Some(100),
    };
    
    // The malicious fullnode should be selected because u64::MAX >= 5000
    let (selected_address, _) = manager.get_fullnode_for_request(&request);
    assert_eq!(selected_address, "127.0.0.1:50053");
    
    // Step 4: Verify global version is corrupted
    assert_eq!(manager.get_known_latest_version(), u64::MAX);
    
    println!("PoC successful: Malicious fullnode monopolized request routing");
}
```

**Notes:**
- The vulnerability affects the indexer-grpc infrastructure, not the core consensus layer directly
- However, indexer availability is critical for ecosystem functionality
- The fix requires adding validation that was assumed but not implemented
- Similar validation exists in transaction streaming but was missed in the ping handler

### Citations

**File:** protos/rust/src/pb/aptos.internal.fullnode.v1.rs (L101-106)
```rust
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct PingFullnodeResponse {
    #[prost(message, optional, tag="1")]
    pub info: ::core::option::Option<super::super::super::indexer::v1::FullnodeInfo>,
}
```

**File:** protos/rust/src/pb/aptos.indexer.v1.rs (L222-230)
```rust
#[derive(Clone, Copy, PartialEq, ::prost::Message)]
pub struct FullnodeInfo {
    #[prost(uint64, tag="1")]
    pub chain_id: u64,
    #[prost(message, optional, tag="2")]
    pub timestamp: ::core::option::Option<super::super::util::timestamp::Timestamp>,
    #[prost(uint64, optional, tag="3")]
    pub known_latest_version: ::core::option::Option<u64>,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L341-374)
```rust
    pub(crate) fn get_fullnode_for_request(
        &self,
        request: &GetTransactionsFromNodeRequest,
    ) -> (GrpcAddress, FullnodeDataClient<Channel>) {
        // TODO(grao): Double check the counters to see if we need a different way or additional
        // information.
        let mut rng = thread_rng();
        if let Some(fullnode) = self
            .fullnodes
            .iter()
            .filter(|fullnode| {
                fullnode
                    .recent_states
                    .back()
                    .is_some_and(|s| s.known_latest_version >= request.starting_version)
            })
            .choose(&mut rng)
            .map(|kv| (kv.key().clone(), kv.value().client.clone()))
        {
            COUNTER
                .with_label_values(&["get_fullnode_for_request__happy"])
                .inc();
            return fullnode;
        }

        COUNTER
            .with_label_values(&["get_fullnode_for_request__fallback"])
            .inc();
        self.fullnodes
            .iter()
            .choose(&mut rng)
            .map(|kv| (kv.key().clone(), kv.value().client.clone()))
            .unwrap()
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L405-409)
```rust
    fn update_known_latest_version(&self, version: u64) {
        self.known_latest_version
            .fetch_max(version, Ordering::SeqCst);
        KNOWN_LATEST_VERSION.set(version as i64);
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L533-550)
```rust
    fn handle_fullnode_info(&self, address: GrpcAddress, info: FullnodeInfo) -> Result<()> {
        let mut entry = self
            .fullnodes
            .entry(address.clone())
            .or_insert(Fullnode::new(address.clone()));
        entry.value_mut().recent_states.push_back(info);
        if let Some(known_latest_version) = info.known_latest_version {
            trace!(
                "Received known_latest_version ({known_latest_version}) from fullnode {address}."
            );
            self.update_known_latest_version(known_latest_version);
        }
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L207-230)
```rust
            let request = GetTransactionsFromNodeRequest {
                starting_version: Some(cache.start_version + cache.transactions.len() as u64),
                transactions_count: Some(100000),
            };
            drop(cache);

            debug!(
                "Requesting transactions from fullnodes, starting_version: {}.",
                request.starting_version.unwrap()
            );
            let (address, mut fullnode_client) =
                self.metadata_manager.get_fullnode_for_request(&request);
            trace!("Fullnode ({address}) is picked for request.");
            let response = fullnode_client.get_transactions_from_node(request).await;
            if response.is_err() {
                warn!(
                    "Error when getting transactions from fullnode ({address}): {}",
                    response.err().unwrap()
                );
                tokio::time::sleep(Duration::from_millis(100)).await;
                continue;
            } else {
                trace!("Got success response from fullnode.");
            }
```
