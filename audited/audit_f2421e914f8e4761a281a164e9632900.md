# Audit Report

## Title
Aggregator V1 Delta Operations Bypass I/O Gas Charging Allowing Free Storage Writes

## Summary
Transactions using Aggregator V1 operations (`add`/`sub`) do not pay I/O gas for the resulting write operations because `aggregator_v1_delta_set` entries are excluded from gas charging calculations. The deltas are only materialized into WriteOps after `charge_change_set()` has already been called, allowing attackers to perform expensive state modifications without paying the appropriate I/O gas costs.

## Finding Description
The vulnerability exists in the gas charging flow for Aggregator V1 operations. When a transaction calls aggregator operations like `aggregator::add()` or `aggregator::sub()`, these operations create entries in the `aggregator_v1_delta_set` within the VMChangeSet. [1](#0-0) 

However, when I/O gas is charged via `charge_change_set()`, the system only iterates over entries returned by `write_set_size_iter()`: [2](#0-1) 

The `write_set_size_iter()` implementation only includes `resource_write_set` and `aggregator_v1_write_set`, but critically EXCLUDES `aggregator_v1_delta_set`: [3](#0-2) 

The materialization of deltas into concrete WriteOps happens AFTER gas charging: [4](#0-3) 

This timing issue is explicitly acknowledged in a TODO comment: [5](#0-4) 

**Attack Path:**
1. Attacker creates aggregators using `aggregator_factory::create_aggregator()`
2. Attacker repeatedly calls `aggregator::add()` or `aggregator::sub()` in transactions
3. Each operation creates a delta entry in `aggregator_v1_delta_set`
4. Gas charging occurs via `charge_change_set()` but skips the delta set entries
5. Deltas are materialized into WriteOps after gas has been charged
6. Attacker performs storage writes without paying I/O gas

## Impact Explanation
This qualifies as **High Severity** ($50,000) under the "Gas calculation miscalculations enabling free computation" category. The vulnerability allows attackers to:

- Perform unlimited aggregator operations without paying I/O gas costs
- Each aggregator write operation normally costs `STORAGE_IO_PER_STATE_SLOT_WRITE + STORAGE_IO_PER_STATE_BYTE_WRITE * size` in I/O gas
- Attackers can create resource exhaustion by flooding the network with under-priced transactions
- Breaks the fundamental economic security model where operations must be paid for proportionally to their cost

The vulnerability directly violates **Invariant #9**: "Resource Limits: All operations must respect gas, storage, and computational limits."

While not directly causing fund loss, this enables protocol-level abuse that can degrade network performance and create unfair economic advantages for attackers who understand this bypass.

## Likelihood Explanation
**Likelihood: High**

The vulnerability is:
- **Easy to exploit**: Any user can call public Aggregator V1 APIs from Move code
- **Well-documented**: The aggregator module provides public `add()` and `sub()` functions
- **Already in production**: Aggregator V1 is actively used in the Aptos ecosystem
- **Requires no special permissions**: Any account can create and use aggregators
- **Leaves clear traces**: The TODO comment shows developers are aware but haven't fixed it

The only barrier is that an attacker needs to understand the Aggregator V1 API, which is publicly documented and used in production contracts. [6](#0-5) 

## Recommendation
Include `aggregator_v1_delta_set` entries in the I/O gas charging calculation. The fix should:

1. **Option A - Charge for deltas during materialization**: When `try_materialize_aggregator_v1_delta_set()` converts deltas to WriteOps, charge I/O gas for each resulting write operation. This requires passing the gas meter to the materialization function.

2. **Option B - Estimate and charge upfront**: During `charge_change_set()`, iterate over `aggregator_v1_delta_set` and charge estimated I/O gas based on the delta operation size. The actual write size can be computed from the serialized u128 value (16 bytes).

**Recommended Fix (Option B - simpler):**

Modify `write_set_size_iter()` to include delta set entries:

```rust
fn write_set_size_iter(&self) -> impl Iterator<Item = (&StateKey, WriteOpSize)> {
    self.resource_write_set()
        .iter()
        .map(|(k, v)| (k, v.materialized_size()))
        .chain(
            self.aggregator_v1_write_set()
                .iter()
                .map(|(k, v)| (k, v.write_op_size())),
        )
        .chain(
            self.aggregator_v1_delta_set()
                .iter()
                .map(|(k, _delta)| {
                    // Aggregator values are u128, serialized to 16 bytes
                    (k, WriteOpSize::Modification { write_len: 16 })
                })
        )
}
```

This ensures deltas are charged for I/O gas at the same point as other writes.

## Proof of Concept

```move
module attacker::exploit {
    use std::signer;
    use aptos_framework::aggregator::{Self, Aggregator};
    use aptos_framework::aggregator_factory;
    
    struct AttackResource has key {
        agg: Aggregator,
    }
    
    // Initialize aggregator
    public entry fun setup(account: &signer) {
        let agg = aggregator_factory::create_aggregator(account, 1000000000);
        move_to(account, AttackResource { agg });
    }
    
    // Perform many adds without paying I/O gas
    public entry fun exploit_free_writes(account: &signer) acquires AttackResource {
        let addr = signer::address_of(account);
        let res = borrow_global_mut<AttackResource>(addr);
        
        // Each add operation creates a delta that bypasses I/O gas charging
        // Normally each write would cost ~100-200 gas units for I/O
        // But with this bug, these operations cost nearly zero I/O gas
        let i = 0;
        while (i < 100) {
            aggregator::add(&mut res.agg, 1);
            i = i + 1;
        };
        // 100 aggregator modifications performed without I/O gas charges!
    }
}
```

**Expected vs Actual Gas Consumption:**
- **Expected**: Each aggregator write should cost `STORAGE_IO_PER_STATE_SLOT_WRITE + STORAGE_IO_PER_STATE_BYTE_WRITE * 16` for the u128 value
- **Actual**: Zero I/O gas charged for delta operations until materialization (which happens after gas charging)

This demonstrates a clear WriteOpSize inconsistency where the calculated `WriteOpSize` (zero, since deltas aren't counted) doesn't match the actual bytes written to storage (16 bytes per u128 aggregator value).

## Notes
This vulnerability specifically affects Aggregator V1 operations. The codebase includes explicit TODO comments acknowledging this issue, indicating it's a known technical debt that hasn't been addressed. The security impact justifies immediate remediation given the ability to bypass resource limits that are fundamental to the blockchain's economic security model.

### Citations

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L76-92)
```rust
/// A change set produced by the VM.
///
/// **WARNING**: Just like VMOutput, this type should only be used inside the
/// VM. For storage backends, use `ChangeSet`.
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct VMChangeSet {
    resource_write_set: BTreeMap<StateKey, AbstractResourceWriteOp>,
    events: Vec<(ContractEvent, Option<MoveTypeLayout>)>,

    // Changes separated out from the writes, for better concurrency,
    // materialized back into resources when transaction output is computed.
    delayed_field_change_set: BTreeMap<DelayedFieldID, DelayedChange<DelayedFieldID>>,

    // TODO[agg_v1](cleanup) deprecate aggregator_v1 fields.
    aggregator_v1_write_set: BTreeMap<StateKey, WriteOp>,
    aggregator_v1_delta_set: BTreeMap<StateKey, DeltaOp>,
}
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L365-399)
```rust
    /// Materializes this change set: all aggregator v1 deltas are converted into writes and
    /// are combined with existing aggregator writes. The aggregator v2 changeset is not touched.
    pub fn try_materialize_aggregator_v1_delta_set(
        &mut self,
        resolver: &impl AggregatorV1Resolver,
    ) -> VMResult<()> {
        let into_write =
            |(state_key, delta): (StateKey, DeltaOp)| -> VMResult<(StateKey, WriteOp)> {
                // Materialization is needed when committing a transaction, so
                // we need precise mode to compute the true value of an
                // aggregator.
                let write = resolver
                    .try_convert_aggregator_v1_delta_into_write_op(&state_key, &delta)
                    .map_err(|e| {
                        // We need to set abort location for Aggregator V1 to ensure correct VMStatus can
                        // be constructed.
                        const AGGREGATOR_V1_ADDRESS: AccountAddress = CORE_CODE_ADDRESS;
                        const AGGREGATOR_V1_MODULE_NAME: &IdentStr = ident_str!("aggregator");
                        e.finish(Location::Module(ModuleId::new(
                            AGGREGATOR_V1_ADDRESS,
                            AGGREGATOR_V1_MODULE_NAME.into(),
                        )))
                    })?;
                Ok((state_key, write))
            };

        let aggregator_v1_delta_set = std::mem::take(&mut self.aggregator_v1_delta_set);
        let materialized_aggregator_delta_set = aggregator_v1_delta_set
            .into_iter()
            .map(into_write)
            .collect::<VMResult<BTreeMap<StateKey, WriteOp>>>()?;
        self.aggregator_v1_write_set
            .extend(materialized_aggregator_delta_set);
        Ok(())
    }
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L862-871)
```rust
    fn write_set_size_iter(&self) -> impl Iterator<Item = (&StateKey, WriteOpSize)> {
        self.resource_write_set()
            .iter()
            .map(|(k, v)| (k, v.materialized_size()))
            .chain(
                self.aggregator_v1_write_set()
                    .iter()
                    .map(|(k, v)| (k, v.write_op_size())),
            )
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1112-1126)
```rust
    fn charge_change_set(
        &self,
        change_set: &mut impl ChangeSetInterface,
        gas_meter: &mut impl AptosGasMeter,
        txn_data: &TransactionMetadata,
        resolver: &impl AptosMoveResolver,
        module_storage: &impl AptosModuleStorage,
    ) -> Result<GasQuantity<Octa>, VMStatus> {
        gas_meter.charge_io_gas_for_transaction(txn_data.transaction_size())?;
        for event in change_set.events_iter() {
            gas_meter.charge_io_gas_for_event(event)?;
        }
        for (key, op_size) in change_set.write_set_size_iter() {
            gas_meter.charge_io_gas_for_write(key, &op_size)?;
        }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1150-1166)
```rust
        let storage_refund = self.charge_change_set(
            &mut user_session_change_set,
            gas_meter,
            txn_data,
            resolver,
            module_storage,
        )?;

        // TODO[agg_v1](fix): Charge for aggregator writes
        Ok(EpilogueSession::on_user_session_success(
            self,
            txn_data,
            resolver,
            user_session_change_set,
            storage_refund,
        ))
    }
```

**File:** aptos-move/e2e-move-tests/src/tests/aggregator.data/pack/sources/aggregator_test.move (L45-57)
```text
    public entry fun add(account: &signer, i: u64, value: u128) acquires AggregatorStore {
        let addr = signer::address_of(account);
        let aggregators = &mut borrow_global_mut<AggregatorStore>(addr).aggregators;
        let aggregator = table::borrow_mut(aggregators, i);
        aggregator::add(aggregator, value);
    }

    public entry fun sub(account: &signer, i: u64, value: u128) acquires AggregatorStore {
        let addr = signer::address_of(account);
        let aggregators = &mut borrow_global_mut<AggregatorStore>(addr).aggregators;
        let aggregator = table::borrow_mut(aggregators, i);
        aggregator::sub(aggregator, value);
    }
```
