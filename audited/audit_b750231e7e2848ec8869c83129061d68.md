# Audit Report

## Title
Missing OIDC Issuer Validation Allows Cross-Issuer JWK Misattribution in Keyless Authentication

## Summary
The JWK consensus implementation fails to validate that the `issuer` field returned by an OIDC provider's OpenID configuration matches the configured issuer name. This allows JWKs fetched from one provider to be misattributed to a different issuer, breaking the security model of keyless authentication.

## Finding Description

The vulnerability exists in the JWK observation and consensus flow. When validators fetch JWKs from OIDC providers, they perform the following steps:

1. Read on-chain OIDC provider configuration containing `(issuer, config_url)` pairs
2. Fetch the OpenID configuration from `config_url`
3. Extract the `jwks_uri` from the configuration response
4. Fetch JWKs from the `jwks_uri`
5. Attribute the fetched JWKs to the configured `issuer`

The critical flaw occurs at step 2-3: [1](#0-0) 

The OpenID configuration response includes an `issuer` field (per OIDC Discovery specification), but the implementation explicitly ignores this field by deserializing only the `jwks_uri` component. The issuer from the actual OIDC provider is discarded.

Later, when creating the reliable broadcast request: [2](#0-1) 

The function blindly copies the `issuer` from the `payload` (which came from on-chain configuration), without any validation against the actual OIDC provider's claimed issuer.

**Attack Path:**

A malicious governance proposal could add an OIDC provider configuration with:
- `issuer`: `"https://evil.com"`
- `config_url`: `"https://accounts.google.com/.well-known/openid-configuration"`

All honest validators would then:
1. Spawn JWKObserver with issuer="https://evil.com" [3](#0-2) 
2. Fetch Google's OpenID configuration (which returns `issuer: "https://accounts.google.com"`)
3. Ignore Google's issuer claim [4](#0-3) 
4. Fetch Google's JWKs
5. Create `ProviderJWKs` attributing Google's keys to "https://evil.com" [5](#0-4) 
6. Reach consensus and commit this misattribution to on-chain state

When keyless authentication occurs, the system retrieves JWKs by exact issuer matching: [6](#0-5) 

A malicious JWT with `"iss": "https://evil.com"` would then be validated using Google's JWKs, enabling authentication bypass.

## Impact Explanation

**Critical Severity** - This vulnerability enables:

1. **Authentication Bypass**: Attackers can authenticate as users from legitimate OIDC providers by forging issuer claims in JWTs, since the JWKs are misattributed
2. **Cross-Issuer Confusion**: Violates the fundamental OIDC security model where each issuer's JWKs should only validate JWTs from that specific issuer
3. **Keyless Account Compromise**: Could allow unauthorized access to keyless accounts, potentially leading to fund theft
4. **Consensus State Corruption**: All validators would reach consensus on the incorrect JWK attribution, making this a protocol-wide vulnerability

This meets the Critical severity criteria for "Loss of Funds" and represents a significant protocol violation in the keyless authentication subsystem.

## Likelihood Explanation

**Likelihood: Medium-High** (with governance access)

While this requires a malicious governance proposal to exploit, the likelihood is elevated because:

1. **Honest Validators Participate**: The attack succeeds even with all honest validators, as they correctly implement the flawed protocol
2. **No Warning Signs**: Validators have no indication that JWKs are being misattributed
3. **Persistent Impact**: Once the malicious configuration is added, the misattribution persists until corrected via another governance action
4. **Governance Attack Surface**: If governance is compromised through voting power concentration, stake manipulation, or proposal execution bugs, this attack becomes feasible

The primary barrier is governance control, but this is within the threat model when considering validator/governance insider threats as explicitly mentioned in the security question.

## Recommendation

Add validation to ensure the `issuer` field returned by the OIDC provider matches the configured issuer:

```rust
// In crates/jwk-utils/src/lib.rs

pub async fn fetch_jwks_uri_from_openid_config(
    config_url: &str,
    expected_issuer: &str,
) -> Result<String> {
    let client = reqwest::Client::new();
    let OpenIDConfiguration { issuer, jwks_uri } = client.get(config_url).send().await?.json().await?;
    
    // CRITICAL: Validate issuer matches expected value per OIDC Discovery spec
    if issuer != expected_issuer {
        anyhow::bail!(
            "OIDC issuer mismatch: expected '{}' but provider returned '{}' from {}",
            expected_issuer,
            issuer,
            config_url
        );
    }
    
    Ok(jwks_uri)
}
```

Update the call site in `jwk_observer.rs` to pass the expected issuer:

```rust
// In crates/aptos-jwk-consensus/src/jwk_observer.rs (line 74-75)

let jwks_uri = fetch_jwks_uri_from_openid_config(
    open_id_config_url.as_str(),
    issuer.as_str() // Pass expected issuer for validation
).await
.map_err(|e| anyhow!("fetch_jwks failed with open-id config request: {e}"))?;
```

This ensures compliance with [OIDC Discovery 1.0 Section 3](https://openid.net/specs/openid-connect-discovery-1_0.html#ProviderConfigurationValidation) which requires validating the issuer in the discovery document.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[tokio::test]
async fn test_cross_issuer_jwk_misattribution() {
    use aptos_jwk_utils::{fetch_jwks_uri_from_openid_config, fetch_jwks_from_jwks_uri};
    
    // Simulate malicious governance config:
    // Claiming issuer is "evil.com" but pointing to Google's config
    let malicious_issuer = "https://evil.com";
    let google_config_url = "https://accounts.google.com/.well-known/openid-configuration";
    
    // Current implementation ignores the issuer mismatch
    let jwks_uri = fetch_jwks_uri_from_openid_config(google_config_url)
        .await
        .expect("Should fetch Google's jwks_uri");
    
    let google_jwks = fetch_jwks_from_jwks_uri(None, &jwks_uri)
        .await
        .expect("Should fetch Google's JWKs");
    
    // Vulnerability: Google's JWKs would be attributed to "evil.com"
    let misattributed_provider_jwks = ProviderJWKs {
        issuer: malicious_issuer.as_bytes().to_vec(),
        version: 1,
        jwks: google_jwks.into_iter().map(JWKMoveStruct::from).collect(),
    };
    
    // This would reach consensus and be stored on-chain
    // A JWT with iss="evil.com" could now be validated with Google's keys
    println!("Vulnerability: Attributed {} JWKs to malicious issuer '{}'", 
             misattributed_provider_jwks.jwks.len(), 
             malicious_issuer);
}
```

### Citations

**File:** crates/jwk-utils/src/lib.rs (L40-44)
```rust
pub async fn fetch_jwks_uri_from_openid_config(config_url: &str) -> Result<String> {
    let client = reqwest::Client::new();
    let OpenIDConfiguration { jwks_uri, .. } = client.get(config_url).send().await?.json().await?;
    Ok(jwks_uri)
}
```

**File:** crates/aptos-jwk-consensus/src/mode/per_issuer.rs (L23-28)
```rust
    fn new_rb_request(epoch: u64, payload: &ProviderJWKs) -> anyhow::Result<ObservedUpdateRequest> {
        Ok(ObservedUpdateRequest {
            epoch,
            issuer: payload.issuer.clone(),
        })
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L117-124)
```rust
                    (Ok(issuer), Ok(config_url)) => Some(JWKObserver::spawn(
                        this.epoch_state.epoch,
                        this.my_addr,
                        issuer,
                        config_url,
                        Duration::from_secs(10),
                        local_observation_tx.clone(),
                    )),
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L197-201)
```rust
            let observed = ProviderJWKs {
                issuer: issuer.clone(),
                version: state.on_chain_version() + 1,
                jwks,
            };
```

**File:** types/src/jwks/mod.rs (L225-237)
```rust
    pub fn get_provider_jwks(&self, iss: &str) -> Option<&ProviderJWKs> {
        self.entries
            .iter()
            .find(|&provider_jwk_set| provider_jwk_set.issuer.eq(&issuer_from_str(iss)))
    }

    pub fn get_jwk(&self, iss: &str, kid: &str) -> anyhow::Result<&JWKMoveStruct> {
        let provider_jwk_set = self
            .get_provider_jwks(iss)
            .context("JWK not found for issuer")?;
        let jwk = provider_jwk_set.get_jwk(kid)?;
        Ok(jwk)
    }
```
