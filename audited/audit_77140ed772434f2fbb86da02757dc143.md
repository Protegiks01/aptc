# Audit Report

## Title
State Cache Pollution Leading to Incorrect Account Existence Check in Abort Hook Retry Mechanism

## Summary
The retry mechanism in `finish_aborted_transaction` can lead to inconsistent account state when `create_account_if_does_not_exist` is called with a metered gas meter that fails mid-execution, followed by a retry with `UnmeteredGasMeter`. Due to lack of transaction rollback semantics in the Move VM's data cache at the function call level, partial state changes from the first call persist, causing the second call to incorrectly detect the account as already existing.

## Finding Description

The vulnerability exists in the abort hook session handling within the transaction finalization flow. When a transaction aborts and account creation is needed (sequence number 0, account doesn't exist), the system attempts to create the account twice: [1](#0-0) 

The critical flaw is that the Move VM's `TransactionDataCache` does not rollback partial state modifications when a function fails. When the first call executes:

1. The `move_to` bytecode instruction successfully modifies the `GlobalValue` in the data cache from `None` to `Fresh` state: [2](#0-1) 

2. The `gv.move_to(resource)` operation at line 1522 succeeds, changing the GlobalValue state: [3](#0-2) 

3. Gas charging at line 1524 fails with out-of-gas, causing the function to return an error
4. **However, the GlobalValue remains in `Fresh` state in the data cache**

When the second call with `UnmeteredGasMeter` executes, the `exists<Account>` check sees the account as existing: [4](#0-3) 

The `exists()` method returns true for `Fresh` state: [5](#0-4) 

This causes the Move-level check to skip account creation: [6](#0-5) 

The critical issue is that when `gas_unit_price == 0` and `DEFAULT_ACCOUNT_RESOURCE` feature is enabled, the validation is bypassed: [7](#0-6) 

This breaks **Critical Invariant #3 (Move VM Safety)** - bytecode execution must respect gas limits, and **Invariant #9 (Resource Limits)** - all operations must respect gas, storage, and computational limits.

## Impact Explanation

**Severity: Medium (up to $10,000)**

While this doesn't directly cause loss of funds or consensus violations, it represents a **state inconsistency** that violates Move VM execution invariants:

1. **Gas Accounting Bypass**: Accounts can be created without proper gas/storage fee charging when the retry mechanism is triggered with specific gas conditions
2. **Deterministic Execution Violation**: The behavior depends on precise gas consumption timing, creating edge cases in transaction processing
3. **State Cache Corruption**: The data cache contains accounts that were "created" through partial function execution rather than complete successful execution

The impact is limited to Medium severity because:
- Requires specific conditions (`gas_unit_price = 0`, feature flag enabled, precise gas timing)
- Doesn't directly enable fund theft or consensus breaks
- The account is still properly initialized (not corrupted)
- Primarily affects fee collection and execution model consistency

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability requires specific conditions but is reproducible:

**Required Conditions:**
1. Transaction with `gas_unit_price = 0` (allowed, as minimum is 0): [8](#0-7) 

2. `DEFAULT_ACCOUNT_RESOURCE` feature flag enabled (network configuration dependent)
3. Transaction with sequence number 0 (new account)
4. Transaction must abort to trigger `finish_aborted_transaction`
5. Gas meter must have precise amount to fail during `move_to` gas charging

While condition #5 requires precise control, conditions #1-#4 are straightforward. An attacker with knowledge of gas costs could craft transactions that reliably trigger this edge case.

## Recommendation

**Fix: Implement proper session-level rollback for failed function calls**

The fundamental issue is that `execute_function_bypass_visibility` doesn't provide transactional semantics for the data cache. The fix should ensure that if a function call fails, any modifications to the data cache are rolled back before retrying.

**Recommended approach:**

1. **Snapshot data cache before first call**: Create a savepoint of the `TransactionDataCache` state before calling `create_account_if_does_not_exist` with the metered gas meter

2. **Rollback on failure**: If the first call fails, restore the data cache to the snapshot before retrying with `UnmeteredGasMeter`

3. **Alternative: Remove retry mechanism**: Since the comment indicates this is for out-of-gas scenarios, ensure sufficient gas is reserved for account creation operations instead of relying on unmetered retry

## Proof of Concept

```rust
// Test scenario demonstrating the vulnerability
// This would need to be integrated into the Aptos test framework

#[test]
fn test_abort_hook_account_creation_retry_pollution() {
    // Setup: Transaction with gas_unit_price = 0, sequence number 0
    let txn_metadata = TransactionMetadata {
        sequence_number: 0,
        gas_unit_price: 0,
        // ... other fields
    };
    
    // Create a gas meter with barely enough gas to execute move_to but fail on charging
    let mut limited_gas_meter = create_gas_meter_that_fails_on_move_to_charge();
    
    // Simulate first call - should partially execute
    let first_result = create_account_if_does_not_exist(
        &mut session,
        module_storage,
        &mut limited_gas_meter,
        sender_address,
        traversal_context,
    );
    
    // First call should fail
    assert!(first_result.is_err());
    
    // Check data cache state - GlobalValue should be Fresh (bug manifestation)
    let gv = session.data_cache.get_resource(&sender_address, account_type);
    assert!(matches!(gv, GlobalValueImpl::Fresh { .. })); // Account exists in cache!
    
    // Second call with UnmeteredGasMeter
    let second_result = create_account_if_does_not_exist(
        &mut session,
        module_storage,
        &mut UnmeteredGasMeter,
        sender_address,
        traversal_context,
    );
    
    // Second call succeeds but does nothing (account already "exists")
    assert!(second_result.is_ok());
    
    // Final state: Account created without proper gas charging
    // Validation is skipped due to zero gas price + feature flag
}
```

**Notes:**

This vulnerability demonstrates a fundamental architectural issue where the Move VM's execution model doesn't provide proper transactional semantics for individual function calls within a session, leading to state pollution when retry mechanisms are employed.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L712-739)
```rust
            abort_hook_session.execute(|session| {
                create_account_if_does_not_exist(
                    session,
                    module_storage,
                    gas_meter,
                    txn_data.sender(),
                    traversal_context,
                )
                // If this fails, it is likely due to out of gas, so we try again without metering
                // and then validate below that we charged sufficiently.
                .or_else(|_err| {
                    create_account_if_does_not_exist(
                        session,
                        module_storage,
                        &mut UnmeteredGasMeter,
                        txn_data.sender(),
                        traversal_context,
                    )
                })
                .map_err(expect_no_verification_errors)
                .or_else(|err| {
                    expect_only_successful_execution(
                        err,
                        &format!("{:?}::{}", ACCOUNT_MODULE, CREATE_ACCOUNT_IF_DOES_NOT_EXIST),
                        log_context,
                    )
                })
            })?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L762-785)
```rust
            if gas_unit_price != 0 || !self.features().is_default_account_resource_enabled() {
                let gas_used = fee_statement.gas_used();
                let storage_fee = fee_statement.storage_fee_used();
                let storage_refund = fee_statement.storage_fee_refund();

                let actual = gas_used * gas_unit_price + storage_fee - storage_refund;
                let expected = u64::from(
                    gas_meter
                        .disk_space_pricing()
                        .hack_account_creation_fee_lower_bound(&gas_params.vm.txn),
                );
                if actual < expected {
                    expect_only_successful_execution(
                        PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                            .with_message(
                                "Insufficient fee for storing account for lazy account creation"
                                    .to_string(),
                            )
                            .finish(Location::Undefined),
                        &format!("{:?}::{}", ACCOUNT_MODULE, CREATE_ACCOUNT_IF_DOES_NOT_EXIST),
                        log_context,
                    )?;
                }
            }
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L1438-1460)
```rust
    fn exists(
        &mut self,
        is_generic: bool,
        data_cache: &mut impl MoveVmDataCache,
        gas_meter: &mut impl GasMeter,
        traversal_context: &mut TraversalContext,
        addr: AccountAddress,
        ty: &Type,
    ) -> PartialVMResult<()> {
        let runtime_environment = self.loader.runtime_environment();
        let gv = self.load_resource(data_cache, gas_meter, traversal_context, addr, ty)?;
        let exists = gv.exists();
        gas_meter.charge_exists(
            is_generic,
            TypeWithRuntimeEnvironment {
                ty,
                runtime_environment,
            },
            exists,
        )?;
        self.check_access(runtime_environment, AccessKind::Reads, ty, addr)?;
        self.operand_stack.push(Value::bool(exists))?;
        Ok(())
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L1508-1548)
```rust
    fn move_to(
        &mut self,
        is_generic: bool,
        data_cache: &mut impl MoveVmDataCache,
        gas_meter: &mut impl GasMeter,
        traversal_context: &mut TraversalContext,
        addr: AccountAddress,
        ty: &Type,
        resource: Value,
    ) -> PartialVMResult<()> {
        let runtime_environment = self.loader.runtime_environment();
        let gv = self.load_resource_mut(data_cache, gas_meter, traversal_context, addr, ty)?;
        // NOTE(Gas): To maintain backward compatibility, we need to charge gas after attempting
        //            the move_to operation.
        match gv.move_to(resource) {
            Ok(()) => {
                gas_meter.charge_move_to(
                    is_generic,
                    TypeWithRuntimeEnvironment {
                        ty,
                        runtime_environment,
                    },
                    gv.view().unwrap(),
                    true,
                )?;
                self.check_access(runtime_environment, AccessKind::Writes, ty, addr)?;
                Ok(())
            },
            Err((err, resource)) => {
                gas_meter.charge_move_to(
                    is_generic,
                    TypeWithRuntimeEnvironment {
                        ty,
                        runtime_environment,
                    },
                    &resource,
                    false,
                )?;
                Err(err.with_message(format!("Failed to move resource into {:?}", addr)))
            },
        }
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L4289-4301)
```rust
    fn move_to(&mut self, val: Value) -> Result<(), (PartialVMError, Value)> {
        match self {
            Self::Fresh { .. } | Self::Cached { .. } => {
                return Err((
                    PartialVMError::new(StatusCode::RESOURCE_ALREADY_EXISTS),
                    val,
                ))
            },
            Self::None => *self = Self::fresh(val)?,
            Self::Deleted => *self = Self::cached(val, GlobalDataStatus::Dirty)?,
        }
        Ok(())
    }
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L4303-4308)
```rust
    fn exists(&self) -> bool {
        match self {
            Self::Fresh { .. } | Self::Cached { .. } => true,
            Self::None | Self::Deleted => false,
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L276-284)
```text
    public fun create_account_if_does_not_exist(account_address: address) {
        if (!resource_exists_at(account_address)) {
            assert!(
                account_address != @vm_reserved && account_address != @aptos_framework && account_address != @aptos_token,
                error::invalid_argument(ECANNOT_RESERVED_ADDRESS)
            );
            create_account_unchecked(account_address);
        }
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L64-64)
```rust
            aptos_global_constants::GAS_UNIT_PRICE
```
