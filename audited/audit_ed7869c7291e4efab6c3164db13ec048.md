# Audit Report

## Title
Absence of Version-Specific ULEB128 Decoding Creates Consensus Split Risk on Encoding Changes

## Summary
The Move bytecode deserializer uses a single, version-agnostic ULEB128 decoding implementation across all bytecode versions (V5-V10). If ULEB128 encoding rules change in a future bytecode version, there are no migration safeguards to prevent old-version bytecode from being misinterpreted by new-version parsers, potentially causing consensus splits between validators.

## Finding Description
ULEB128 (Unsigned Little Endian Base 128) encoding is used extensively throughout the Move binary format to compress indices into tables (MODULE_HANDLES, STRUCT_HANDLES, FUNCTION_HANDLES, etc.) and encode counts/lengths. [1](#0-0) 

The current implementation enforces canonical form validation that rejects non-canonical encodings with unnecessary leading zeros: [2](#0-1) 

However, this validation is NOT version-specific. The `VersionedCursor` structure has version information but doesn't use it when decoding ULEB128: [3](#0-2) 

The bytecode version is determined by on-chain feature flags and can vary across the network during rollouts: [4](#0-3) 

**Attack Scenario (IF encoding changes in future version):**
1. Suppose bytecode version 11 relaxes the canonical form check to allow non-canonical ULEB128 encodings
2. Attacker publishes a module with non-canonical indices (e.g., `[0x80, 0x00]` instead of `[0x00]`)
3. Validators with `max_binary_format_version=11` accept it using relaxed validation
4. Validators with `max_binary_format_version=10` reject it using strict validation
5. Network experiences consensus split

Integration tests confirm that old bytecode is accepted by parsers configured for newer versions, but all use the same ULEB128 decoding logic: [5](#0-4) 

## Impact Explanation
This represents a **Critical Severity** issue IF ULEB128 encoding rules change in a future version:
- **Consensus Safety Violation**: Different validators would commit different blocks based on their `max_binary_format_version` configuration
- **Non-Recoverable Network Partition**: Would require an emergency hard fork to resolve
- Breaks the "Deterministic Execution" invariant: validators must produce identical state roots for identical blocks

## Likelihood Explanation
**Current Likelihood: LOW**
- ULEB128 is a well-defined standard from DWARF3 specification
- No evidence exists that encoding rules will change
- Canonical form check is a security feature designed to prevent ambiguous encodings

**Future Risk: MEDIUM** 
- Each new bytecode version (currently up to V10) increases risk
- No architectural safeguards exist to prevent this class of issue
- Feature flag rollouts could create temporary inconsistencies

## Recommendation
Implement version-specific ULEB128 decoding in `VersionedCursor`:

```rust
// In file_format_common.rs, modify VersionedCursor::read_uleb128_as_u64
pub fn read_uleb128_as_u64(&mut self) -> Result<u64> {
    // Add version-specific logic if encoding changes in future versions
    match self.version {
        VERSION_MIN..=VERSION_10 => {
            // Current canonical form validation
            read_uleb128_as_u64(&mut self.cursor)
        },
        // Future: handle encoding changes in V11+
        // VERSION_11.. => read_uleb128_as_u64_v11(&mut self.cursor),
        _ => read_uleb128_as_u64(&mut self.cursor)
    }
}
```

Additionally:
1. Document ULEB128 encoding as version-dependent in binary format specification
2. Add explicit version compatibility tests for ULEB128 encoding
3. Enforce that ULEB128 encoding cannot change without incrementing bytecode version
4. Add deserialization-time checks that validate encoding consistency

## Proof of Concept
**Note**: A complete PoC cannot be created because ULEB128 encoding has not actually changed in any existing bytecode version. However, the vulnerability can be demonstrated by:

1. Examining that `read_uleb128_as_u64` is version-agnostic: [2](#0-1) 

2. Confirming `VersionedCursor` doesn't use version for ULEB128: [3](#0-2) 

3. Verifying canonical form tests reject non-canonical encodings: [6](#0-5) 

4. Observing no version-specific ULEB128 compatibility tests exist: [7](#0-6) 

**Conceptual Reproduction Steps** (if encoding changes):
```rust
// Hypothetical test demonstrating the issue
#[test]
fn test_uleb128_version_incompatibility() {
    // Serialize module with V10 (strict canonical form)
    let module_v10 = serialize_with_version(VERSION_10);
    
    // Deserialize with V11 parser (hypothetical relaxed form)
    let result = deserialize_with_version(module_v10, VERSION_11);
    
    // If encoding changed, indices could be misinterpreted
    assert!(result.is_ok()); // May succeed but with wrong semantics
}
```

---

**Notes:**
This is a **design weakness** rather than an immediately exploitable vulnerability. The issue only manifests IF ULEB128 encoding changes in future bytecode versions. Given that:
1. ULEB128 is an established standard unlikely to change
2. No evidence exists of planned encoding changes
3. Cannot create a working PoC with current codebase

The practical risk is LOW, but the architectural safeguard is missing. The security question specifically asks about "migration safeguards" - and the answer is definitively **NO, none exist**.

### Citations

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L245-249)
```rust
    MUT_BORROW_LOC              = 0x0D,
    IMM_BORROW_LOC              = 0x0E,
    MUT_BORROW_FIELD            = 0x0F,
    IMM_BORROW_FIELD            = 0x10,
    CALL                        = 0x11,
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L482-505)
```rust
pub fn read_uleb128_as_u64(cursor: &mut Cursor<&[u8]>) -> Result<u64> {
    let mut value: u64 = 0;
    let mut shift = 0;
    while let Ok(byte) = read_u8(cursor) {
        let cur = (byte & 0x7F) as u64;
        if (cur << shift) >> shift != cur {
            bail!("invalid ULEB128 repr for usize");
        }
        value |= cur << shift;

        if (byte & 0x80) == 0 {
            if shift > 0 && cur == 0 {
                bail!("invalid ULEB128 repr for usize");
            }
            return Ok(value);
        }

        shift += 7;
        if shift > u64::BITS {
            break;
        }
    }
    bail!("invalid ULEB128 repr for usize");
}
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L699-701)
```rust
        pub fn read_uleb128_as_u64(&mut self) -> Result<u64> {
            read_uleb128_as_u64(&mut self.cursor)
        }
```

**File:** types/src/on_chain_config/aptos_features.rs (L485-499)
```rust
    pub fn get_max_binary_format_version(&self) -> u32 {
        if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V10) {
            file_format_common::VERSION_10
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V9) {
            file_format_common::VERSION_9
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V8) {
            file_format_common::VERSION_8
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V7) {
            file_format_common::VERSION_7
        } else if self.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V6) {
            file_format_common::VERSION_6
        } else {
            file_format_common::VERSION_5
        }
    }
```

**File:** third_party/move/move-vm/integration-tests/src/tests/binary_format_version.rs (L1-108)
```rust
// Copyright (c) The Move Contributors
// SPDX-License-Identifier: Apache-2.0

use crate::tests::execute_script_for_test;
use claims::assert_ok;
use move_binary_format::{
    deserializer::DeserializerConfig,
    file_format::{basic_test_module, basic_test_script},
    file_format_common::{IDENTIFIER_SIZE_MAX, VERSION_MAX},
};
use move_core_types::vm_status::StatusCode;
use move_vm_runtime::{
    config::VMConfig, AsUnsyncModuleStorage, RuntimeEnvironment, StagingModuleStorage,
};
use move_vm_test_utils::InMemoryStorage;

fn initialize_storage_with_binary_format_version(binary_format_version: u32) -> InMemoryStorage {
    let vm_config = VMConfig {
        deserializer_config: DeserializerConfig::new(binary_format_version, IDENTIFIER_SIZE_MAX),
        ..VMConfig::default_for_test()
    };
    let runtime_environment = RuntimeEnvironment::new_with_config(vec![], vm_config);
    InMemoryStorage::new_with_runtime_environment(runtime_environment)
}

#[test]
fn test_publish_module_with_custom_max_binary_format_version() {
    let m = basic_test_module();

    let new_version = VERSION_MAX;
    let mut b_new = vec![];
    m.serialize_for_version(Some(new_version), &mut b_new)
        .unwrap();

    let old_version = new_version - 1;
    let mut b_old = vec![];
    m.serialize_for_version(Some(old_version), &mut b_old)
        .unwrap();

    // Should accept both modules with the default settings
    {
        let storage = initialize_storage_with_binary_format_version(new_version);
        let module_storage = storage.as_unsync_module_storage();

        let new_module_storage =
            StagingModuleStorage::create(m.self_addr(), &module_storage, vec![b_new
                .clone()
                .into()])
            .expect("New module should be publishable");
        StagingModuleStorage::create(m.self_addr(), &new_module_storage, vec![b_old
            .clone()
            .into()])
        .expect("Old module should be publishable");
    }

    // Should reject the module with newer version with max binary format version being set to VERSION_MAX - 1
    {
        let storage = initialize_storage_with_binary_format_version(old_version);
        let module_storage = storage.as_unsync_module_storage();

        let result_new = StagingModuleStorage::create(m.self_addr(), &module_storage, vec![b_new
            .clone()
            .into()]);
        if let Err(err) = result_new {
            assert_eq!(err.major_status(), StatusCode::UNKNOWN_VERSION);
        } else {
            panic!("New module should not be publishable")
        }
        StagingModuleStorage::create(m.self_addr(), &module_storage, vec![b_old.clone().into()])
            .expect("Old module should be publishable");
    }
}

#[test]
fn test_run_script_with_custom_max_binary_format_version() {
    let s = basic_test_script();

    let new_version = VERSION_MAX;
    let mut b_new = vec![];
    s.serialize_for_version(Some(new_version), &mut b_new)
        .unwrap();

    let old_version = new_version - 1;
    let mut b_old = vec![];
    s.serialize_for_version(Some(old_version), &mut b_old)
        .unwrap();

    // Should accept both modules with the default settings.
    {
        let storage = initialize_storage_with_binary_format_version(new_version);
        let result_new = execute_script_for_test(&storage, &b_new, &[], vec![]);
        let result_old = execute_script_for_test(&storage, &b_old, &[], vec![]);
        assert!(result_new.is_ok() && result_old.is_ok());
    }

    // Should reject the module with newer version with max binary format version being set to the
    // smaller one.
    {
        let storage = initialize_storage_with_binary_format_version(old_version);
        let status_new = execute_script_for_test(&storage, &b_new, &[], vec![])
            .unwrap_err()
            .major_status();
        assert_eq!(status_new, StatusCode::CODE_DESERIALIZATION_ERROR);

        let result_old = execute_script_for_test(&storage, &b_old, &[], vec![]);
        assert_ok!(result_old);
    }
}
```

**File:** third_party/move/move-binary-format/src/unit_tests/number_tests.rs (L62-70)
```rust
fn uleb128_canonicity_test() {
    assert!(read_uleb128_as_u64(&mut Cursor::new(&[0x80, 0x00])).is_err());
    assert!(read_uleb128_as_u64(&mut Cursor::new(&[0x80, 0x00, 0x00])).is_err());
    assert!(read_uleb128_as_u64(&mut Cursor::new(&[0x80, 0x80, 0x80, 0x80, 0x0F])).is_ok());
    assert!(read_uleb128_as_u64(&mut Cursor::new(&[
        0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x1
    ]))
    .is_ok());
}
```
