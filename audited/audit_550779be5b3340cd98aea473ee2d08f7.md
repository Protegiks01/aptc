# Audit Report

## Title
Stale Environment in CachedModuleView Can Cause Non-Deterministic Transaction Validation

## Summary
The CachedModuleView in vm-validator shares module loader state (including the AptosEnvironment) across validations. When blocks are committed, the `notify_commit()` function updates the state_view but keeps the stale environment and module cache, potentially causing validators to use outdated VM configurations, feature flags, and gas parameters when validating transactions.

## Finding Description

The vulnerability stems from how `CachedModuleView` handles state updates in the validation path: [1](#0-0) 

Each `VMValidator` maintains a `CachedModuleView` containing three critical components: [2](#0-1) 

When blocks are committed, the `notify_commit()` function is called: [3](#0-2) 

The critical issue is in `reset_state_view()` which only updates the state view: [4](#0-3) 

The environment contains critical execution configurations: [5](#0-4) 

**Attack Scenario:**
1. At block version 100, all validators have environment E100 with Feature X disabled
2. On-chain governance proposal passes enabling Feature X at version 101
3. Block is committed, `notify_commit()` calls `reset_state_view()` for linear version history
4. Validators now have state_view v101 but stale environment E100
5. Transaction A uses Feature X, gets assigned to VMValidator with stale env
6. Validation checks features with stale environment E100 → Feature X appears disabled → REJECTED
7. The same transaction could be accepted by a recently restarted validator with fresh environment E101

The validation code explicitly checks feature flags during transaction validation: [6](#0-5) 

Furthermore, the code comment acknowledges this limitation: [7](#0-6) 

## Impact Explanation

This violates the **Deterministic Execution** invariant: "All validators must produce identical state roots for identical blocks."

**High Severity** per Aptos bug bounty criteria due to:
- **Mempool Inconsistency**: Different validators accept/reject the same transaction
- **Consensus Risk**: Validators may disagree on transaction validity
- **User Experience**: Transactions randomly fail validation depending on validator assignment
- **Protocol Violations**: Breaks deterministic validation guarantee

While this doesn't directly cause consensus failure (since execution uses fresh environment), it creates mempool divergence where some validators accept transactions others reject, potentially causing transactions to be stuck or requiring multiple submission attempts.

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability occurs whenever:
1. On-chain configuration changes between reconfig events (which trigger `restart()`)
2. Validators process commits with `notify_commit()` between reconfigs
3. Environment becomes increasingly stale over time

Reconfig events are relatively infrequent (epoch changes), meaning validators operate with stale environments for extended periods. The PooledVMValidator uses random validator selection: [8](#0-7) 

This randomness combined with stale environments creates non-deterministic validation.

## Recommendation

**Fix: Update environment along with state_view on commit:**

```rust
pub fn notify_commit(&mut self) {
    let db_state_view = self.db_state_view();
    
    let base_view_id = self.state.state_view_id();
    let new_view_id = db_state_view.id();
    match (base_view_id, new_view_id) {
        (
            StateViewId::TransactionValidation {
                base_version: old_version,
            },
            StateViewId::TransactionValidation {
                base_version: new_version,
            },
        ) => {
            if old_version <= new_version {
                // FIX: Reset environment along with state view
                self.state.reset_all(db_state_view.into());
            }
        },
        _ => self.state.reset_all(db_state_view.into()),
    }
}
```

Or implement environment versioning similar to module versioning: [9](#0-8) 

Add `environment_version` tracking and check if environment needs updating on each validation.

## Proof of Concept

```rust
// Reproduction test for vm_validator_test.rs

#[test]
fn test_stale_environment_non_deterministic_validation() {
    // Setup: Create validator pool with multiple validators
    let db = MockDbReader::new();
    let pool = PooledVMValidator::new(Arc::new(db), 2);
    
    // Validator 1 validates at version 100 with Feature X disabled
    let tx_with_feature_x = create_tx_using_feature_x();
    let result1 = pool.validate_transaction(tx_with_feature_x.clone());
    assert!(result1.is_err()); // Rejected due to feature gating
    
    // Simulate commit to version 101 where Feature X is enabled
    pool.notify_commit();
    
    // Validator 2 (recently restarted) has fresh environment with Feature X enabled
    // Validator 1 still has stale environment with Feature X disabled
    
    // Retry same transaction - may get different result depending on random assignment
    let result2 = pool.validate_transaction(tx_with_feature_x.clone());
    
    // NON-DETERMINISTIC: result2 can be Ok or Err depending on which validator
    // was randomly selected, violating deterministic validation invariant
}
```

## Notes

The root cause is architectural: `reset_state_view()` was designed for performance (avoiding expensive cache flushes), but creates a correctness issue. The environment must stay synchronized with state_view to ensure deterministic validation. While `restart()` is called on reconfig events, the window between reconfigs allows stale environments to cause validation inconsistencies.

### Citations

**File:** vm-validator/src/vm_validator.rs (L42-45)
```rust
struct VMValidator {
    db_reader: Arc<dyn DbReader>,
    state: CachedModuleView<CachedDbStateView>,
}
```

**File:** vm-validator/src/vm_validator.rs (L76-99)
```rust
    fn notify_commit(&mut self) {
        let db_state_view = self.db_state_view();

        // On commit, we need to update the state view so that we can see the latest resources.
        let base_view_id = self.state.state_view_id();
        let new_view_id = db_state_view.id();
        match (base_view_id, new_view_id) {
            (
                StateViewId::TransactionValidation {
                    base_version: old_version,
                },
                StateViewId::TransactionValidation {
                    base_version: new_version,
                },
            ) => {
                // if the state view forms a linear history, just update the state view
                if old_version <= new_version {
                    self.state.reset_state_view(db_state_view.into());
                }
            },
            // if the version is incompatible, we flush the cache
            _ => self.state.reset_all(db_state_view.into()),
        }
    }
```

**File:** vm-validator/src/vm_validator.rs (L136-140)
```rust
    fn get_next_vm(&self) -> Arc<Mutex<VMValidator>> {
        let mut rng = thread_rng(); // Create a thread-local random number generator
        let random_index = rng.gen_range(0, self.vm_validators.len()); // Generate random index
        self.vm_validators[random_index].clone() // Return the VM at the random index
    }
```

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L93-103)
```rust
pub struct CachedModuleView<S> {
    /// The raw snapshot of the state used for validation.
    pub state_view: S,
    /// Stores configs needed for execution.
    pub environment: AptosEnvironment,
    /// Versioned cache for deserialized and verified Move modules. The versioning allows to detect
    /// when the version of the code is no longer up-to-date (a newer version has been committed to
    /// the state view) and update the cache accordingly.
    pub module_cache:
        UnsyncModuleCache<ModuleId, CompiledModule, Module, AptosModuleExtension, usize>,
}
```

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L121-125)
```rust
    /// Resets the state view snapshot to the new one. Does not invalidate the module cache, nor
    /// the VM.
    pub fn reset_state_view(&mut self, state_view: S) {
        self.state_view = state_view;
    }
```

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L127-130)
```rust
    ///  Returns the current state view ID for the caller to decide whether it's compatible with other state views.
    pub fn state_view_id(&self) -> StateViewId {
        self.state_view.id()
    }
```

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L241-243)
```rust
        // deserialize only relies on local config, so only need to detect changes on module bytes
        // if we want to support verified modules, we need
        // to detect changes on aptos environment too.
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L31-43)
```rust
/// A runtime environment which can be used for VM initialization and more. Contains features
/// used by execution, gas parameters, VM configs and global caches. Note that it is the user's
/// responsibility to make sure the environment is consistent, for now it should only be used per
/// block of transactions because all features or configs are updated only on per-block basis.
pub struct AptosEnvironment(TriompheArc<Environment>);

impl AptosEnvironment {
    /// Returns new execution environment based on the current state.
    pub fn new(state_view: &impl StateView) -> Self {
        Self(TriompheArc::new(Environment::new(state_view, false, None)))
    }

    /// Returns new execution environment based on the current state, also using the provided gas
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3172-3179)
```rust
        if !self
            .features()
            .is_enabled(FeatureFlag::SINGLE_SENDER_AUTHENTICATOR)
        {
            if let aptos_types::transaction::authenticator::TransactionAuthenticator::SingleSender{ .. } = transaction.authenticator_ref() {
                return VMValidatorResult::error(StatusCode::FEATURE_UNDER_GATING);
            }
        }
```
