# Audit Report

## Title
Unbounded Memory Growth in CaptchaManager Leading to Faucet Service Denial of Service

## Summary
The `CaptchaManager` struct in the Aptos faucet service stores captcha challenges in an in-memory `HashMap` without any cleanup mechanism for old, expired, or incorrectly-answered entries. This allows an attacker to exhaust server memory by repeatedly requesting captchas, eventually causing an Out-of-Memory (OOM) error and permanent faucet service unavailability.

## Finding Description

The `CaptchaManager` maintains a `HashMap<u32, String>` to store active captcha challenges. [1](#0-0) 

The developers explicitly acknowledge this vulnerability in the file's documentation. [2](#0-1) 

When `create_challenge()` is called, it generates a new captcha and inserts it into the HashMap without any bounds checking or cleanup. [3](#0-2) 

The `check_challenge()` method only removes entries when a **correct** answer is provided. [4](#0-3) 

When an incorrect answer is provided, the entry remains in the HashMap indefinitely. If a captcha is requested but never answered, it also remains in memory forever.

The `/request_captcha` endpoint directly exposes this functionality without rate limiting. [5](#0-4) 

**Attack Path:**
1. Attacker sends repeated GET requests to `/request_captcha`
2. Each request creates a new entry in `CaptchaManager.challenges` HashMap
3. Attacker never submits answers (or submits only incorrect answers)
4. HashMap grows unbounded until server exhausts memory
5. Faucet service crashes with OOM error
6. Service becomes permanently unavailable until manual restart

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria:
- **API crashes**: The faucet API will crash with an OOM error
- **Significant protocol violations**: Violates the Resource Limits invariant that "all operations must respect gas, storage, and computational limits"

While the faucet is not part of the consensus layer, it is a critical service for:
- Onboarding new developers to testnet/devnet
- Enabling testing and development on Aptos networks
- Supporting hackathons and educational initiatives

Permanent unavailability of the faucet service severely impacts the developer ecosystem and network growth. The attack requires minimal resources (simple HTTP requests) and can be executed by any unauthenticated attacker.

## Likelihood Explanation

**Likelihood: HIGH**

The attack is trivial to execute:
- No authentication required to access `/request_captcha`
- No rate limiting on the captcha creation endpoint
- Simple HTTP GET requests are sufficient
- Low bandwidth requirements (can be executed slowly over time)
- No special tools or knowledge required

The vulnerability is **already known to the developers** (as evidenced by the warning comment) but remains unpatched, indicating it may be in production systems.

## Recommendation

Implement a multi-layered defense strategy:

**1. Time-based expiration for captcha challenges:**
```rust
use std::time::{SystemTime, UNIX_EPOCH};

pub struct CaptchaManager {
    challenges: HashMap<u32, CaptchaEntry>,
}

struct CaptchaEntry {
    solution: String,
    created_at: u64,
}

impl CaptchaManager {
    const CAPTCHA_TTL_SECS: u64 = 300; // 5 minutes
    
    fn cleanup_expired(&mut self) {
        let now = SystemTime::now()
            .duration_since(UNIX_EPOCH)
            .unwrap()
            .as_secs();
        self.challenges.retain(|_, entry| {
            now - entry.created_at < Self::CAPTCHA_TTL_SECS
        });
    }
}
```

**2. Maximum size limit for the HashMap:**
```rust
impl CaptchaManager {
    const MAX_CHALLENGES: usize = 10_000;
    
    pub fn create_challenge(&mut self) -> Result<(u32, Vec<u8>)> {
        // Cleanup before checking size
        self.cleanup_expired();
        
        if self.challenges.len() >= Self::MAX_CHALLENGES {
            bail!("Too many pending captchas, try again later");
        }
        // ... rest of implementation
    }
}
```

**3. Remove entries on incorrect answers after N attempts:**
```rust
struct CaptchaEntry {
    solution: String,
    created_at: u64,
    attempts: u8,
}

pub fn check_challenge(&mut self, key: u32, value: &str) -> Result<bool> {
    match self.challenges.get_mut(&key) {
        Some(entry) => {
            if entry.solution == value {
                self.challenges.remove(&key);
                Ok(true)
            } else {
                entry.attempts += 1;
                if entry.attempts >= 3 {
                    self.challenges.remove(&key);
                }
                Ok(false)
            }
        },
        None => bail!("Captcha key unknown: {}", key),
    }
}
```

**4. Apply rate limiting to the `/request_captcha` endpoint** using existing `MemoryRatelimitChecker` or `RedisRatelimitChecker` mechanisms.

## Proof of Concept

```rust
// PoC: Stress test to demonstrate memory exhaustion
use reqwest;

#[tokio::test]
async fn poc_captcha_memory_exhaustion() {
    let faucet_url = "http://localhost:8081/request_captcha";
    let client = reqwest::Client::new();
    
    // Request 100,000 captchas without answering them
    for i in 0..100_000 {
        match client.get(faucet_url).send().await {
            Ok(response) => {
                if i % 1000 == 0 {
                    println!("Requested {} captchas, status: {}", i, response.status());
                }
            },
            Err(e) => {
                println!("Service crashed at {} requests: {}", i, e);
                break;
            }
        }
    }
}
```

**Expected outcome:** After sufficient requests (depends on available memory), the faucet service will crash with an OOM error, requiring manual restart.

## Notes

The vulnerability is **explicitly documented in the code** by the original developers but remains unpatched. [2](#0-1) 

The faucet service configuration system supports the `TapCaptcha` checker type, indicating this code path is deployable. [6](#0-5) 

The CaptchaManager is shared between the `/request_captcha` endpoint and the `TapCaptchaChecker` validation logic. [7](#0-6)

### Citations

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L4-6)
```rust
//! Warning: This could be attacked and cause the server to OOM because we
//! don't throw out captchas info if it has been sitting there for too long /
//! the map grows too large.
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L125-131)
```rust
#[derive(Debug, Default)]
pub struct CaptchaManager {
    /// When a challenge is created, we return to the client the captcha itself
    /// and a random key they must make the second request with. This is a map
    /// from that random key to the value of the captcha.
    challenges: HashMap<u32, String>,
}
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L142-162)
```rust
    pub fn create_challenge(&mut self) -> Result<(u32, Vec<u8>)> {
        // Generate a random key.
        let key = rand::thread_rng().gen_range(0, u32::MAX - 1);

        // Generate a captcha.
        let (name, image) = Captcha::new()
            .add_chars(5)
            .apply_filter(Noise::new(0.4))
            .apply_filter(Wave::new(4.0, 6.0).vertical())
            .apply_filter(Wave::new(3.0, 2.0).horizontal())
            .apply_filter(Grid::new(10, 6))
            .apply_filter(Dots::new(8))
            .as_tuple()
            .context("Failed to generate captcha")?;

        // Store the captcha information.
        self.challenges.insert(key, name);

        // Return (key, <captcha as base64>).
        Ok((key, image))
    }
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L165-177)
```rust
    pub fn check_challenge(&mut self, key: u32, value: &str) -> Result<bool> {
        match self.challenges.get(&key) {
            Some(captcha) => {
                if captcha == value {
                    self.challenges.remove(&key);
                    Ok(true)
                } else {
                    Ok(false)
                }
            },
            None => bail!("Captcha key unknown: {}", key),
        }
    }
```

**File:** crates/aptos-faucet/core/src/endpoints/captcha.rs (L40-58)
```rust
    async fn request_captcha(&self) -> Result<Response<Binary<Vec<u8>>>, AptosTapErrorResponse> {
        if !self.enabled {
            return Err(AptosTapError::new(
                "The CaptchaChecker is not enabled".to_string(),
                AptosTapErrorCode::EndpointNotEnabled,
            )
            .into());
        }
        let mut captcha_manager = self.captcha_manager.lock().await;
        let (key, image) = match captcha_manager.create_challenge() {
            Ok((key, image)) => (key, image),
            Err(e) => {
                return Err(
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError).into(),
                );
            },
        };
        Ok(Response::new(Binary(image)).header(CAPTCHA_KEY, key))
    }
```

**File:** crates/aptos-faucet/core/src/checkers/mod.rs (L105-107)
```rust
    /// In-house captcha solution.
    TapCaptcha(TapCaptchaCheckerConfig),
}
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L111-169)
```rust
        // Create a CaptchaManager.
        let captcha_manager = Arc::new(Mutex::new(CaptchaManager::new()));

        // Build Bypassers.
        let mut bypassers: Vec<Bypasser> = Vec::new();
        for bypasser_config in &self.bypasser_configs {
            let bypasser = bypasser_config.clone().build().with_context(|| {
                format!("Failed to build Bypasser with args: {:?}", bypasser_config)
            })?;
            bypassers.push(bypasser);
        }

        // Create a periodic task manager.
        let mut join_set = JoinSet::new();

        // Build Checkers and let them spawn tasks on the periodic task
        // manager if they want.
        let mut checkers: Vec<Checker> = Vec::new();
        for checker_config in &self.checker_configs {
            let checker = checker_config
                .clone()
                .build(captcha_manager.clone())
                .await
                .with_context(|| {
                    format!("Failed to build Checker with args: {:?}", checker_config)
                })?;
            checker.spawn_periodic_tasks(&mut join_set);
            checkers.push(checker);
        }

        // Sort Checkers by cost, where lower numbers is lower cost, and lower
        // cost Checkers are at the start of the vec.
        checkers.sort_by_key(|a| a.cost());

        // Using those, build the fund API components.
        let fund_api_components = Arc::new(FundApiComponents {
            bypassers,
            checkers,
            funder,
            return_rejections_early: self.handler_config.return_rejections_early,
            concurrent_requests_semaphore,
        });

        let fund_api = FundApi {
            components: fund_api_components.clone(),
        };

        // Build the CaptchaApi.
        let mut tap_captcha_api_enabled = false;
        for checker in &self.checker_configs {
            if let CheckerConfig::TapCaptcha(_) = checker {
                tap_captcha_api_enabled = true;
                break;
            }
        }
        let captcha_api = CaptchaApi {
            enabled: tap_captcha_api_enabled,
            captcha_manager,
        };
```
