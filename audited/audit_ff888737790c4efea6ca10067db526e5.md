# Audit Report

## Title
Unbounded BCS Deserialization in REST Client Enables DoS via Malicious API Servers

## Summary
The Aptos REST client uses `bcs::from_bytes()` without recursion or size limits when deserializing API responses, while other parts of the codebase use `bcs::from_bytes_with_limit()` with explicit bounds. This inconsistency allows malicious or compromised REST API servers to cause client denial-of-service through deeply nested structures or large payloads.

## Finding Description
The REST client's `get_account_resource_bcs` function and related BCS endpoints fail to enforce deserialization limits on API responses. When a client connects to a malicious REST API server, the server can return arbitrarily deep or large BCS-encoded data structures that cause stack overflow, memory exhaustion, or excessive CPU consumption during deserialization.

**Vulnerable Code Path:** [1](#0-0) 

The client uses unbounded `bcs::from_bytes(&inner)` without validation, while:

**Server-side protection:** [2](#0-1) [3](#0-2) 

**Network-layer protection:** [4](#0-3) [5](#0-4) 

**Attack Scenario:**
1. Attacker operates or compromises a REST API server
2. Victim client configured with custom URL via `AptosBaseUrl::Custom(url)`
3. Client calls `get_account_resource_bcs()` or other BCS methods
4. Malicious server returns deeply nested BCS structure (depth > 64) or very large payload
5. Client attempts unbounded deserialization
6. Client crashes (stack overflow), hangs (memory exhaustion), or becomes unresponsive

**Validation Gap:** [6](#0-5) 

The `check_response` function only validates HTTP status codes, not response structure, content type, or size limits. [7](#0-6) 

No size or recursion limits are enforced before passing raw bytes to BCS deserialization.

## Impact Explanation
This vulnerability meets **Medium Severity** criteria per Aptos bug bounty guidelines:
- **Client DoS**: Applications using the REST client SDK can crash or hang when connected to malicious servers
- **No consensus impact**: Does not affect validator nodes, consensus protocol, or blockchain state
- **Limited scope**: Requires victim to connect to attacker-controlled server
- **Availability impact**: Client applications become unresponsive, requiring restart

This does NOT qualify for High or Critical severity because it:
- Does not cause fund loss or theft
- Does not affect validator operations or network liveness
- Does not violate consensus safety guarantees

## Likelihood Explanation
**Likelihood: Medium**

Attack requirements:
1. Attacker must control or compromise a REST API endpoint
2. Victim client must be configured to connect to malicious server (via custom URL)
3. Client must call BCS endpoint methods

Feasibility factors:
- SDK allows arbitrary custom URLs via `ClientBuilder`
- Users may configure wrong endpoints via environment variables or misconfigurations
- Compromised infrastructure could serve malicious responses
- No client-side validation prevents this attack

## Recommendation
Implement recursion and size limits for all BCS deserialization in the REST client, matching the protections used in the server and network layers.

**Proposed Fix:**

```rust
// In crates/aptos-rest-client/src/lib.rs
const MAX_BCS_RECURSION_LIMIT: usize = 64; // Match network layer

pub async fn get_account_resource_bcs<T: DeserializeOwned>(
    &self,
    address: AccountAddress,
    resource_type: &str,
) -> AptosResult<Response<T>> {
    let url = self.build_path(&format!(
        "accounts/{}/resource/{}",
        address.to_hex(),
        resource_type
    ))?;
    let response = self.get_bcs(url).await?;
    Ok(response.and_then(|inner| {
        bcs::from_bytes_with_limit(&inner, MAX_BCS_RECURSION_LIMIT)
            .map_err(|e| anyhow!("BCS deserialization failed: {}", e).into())
    })?)
}
```

Apply similar changes to all BCS deserialization points:
- `get_account_resource_at_version_bcs`
- `get_account_resources_bcs`  
- `get_block_by_height_bcs`
- `get_transactions_bcs`
- `view_bcs`
- All other methods using `bcs::from_bytes`

Additionally, add response size validation: [8](#0-7) 

Consider adding HTTP response body size limits in the reqwest client configuration.

## Proof of Concept

```rust
// PoC: Malicious server causing client DoS via deep BCS nesting
// To run: cargo test --package aptos-rest-client test_bcs_depth_limit

#[tokio::test]
async fn test_bcs_depth_limit_vulnerability() {
    use aptos_rest_client::Client;
    use aptos_types::account_address::AccountAddress;
    use mockito::{mock, server_url};
    
    // Create deeply nested BCS structure (depth > 100)
    #[derive(Serialize, Deserialize)]
    struct Nested(Option<Box<Nested>>);
    
    let mut deep = Nested(None);
    for _ in 0..150 {
        deep = Nested(Some(Box::new(deep)));
    }
    
    let malicious_bcs = bcs::to_bytes(&deep).unwrap();
    
    // Mock malicious API server
    let _m = mock("GET", "/v1/accounts/0x1/resource/0x1::account::Account")
        .with_status(200)
        .with_header("content-type", "application/x-bcs")
        .with_body(malicious_bcs)
        .create();
    
    let client = Client::new(mockito::server_url().parse().unwrap());
    
    // This should fail gracefully but currently may cause stack overflow
    let result = client
        .get_account_resource_bcs::<Nested>(
            AccountAddress::ONE,
            "0x1::account::Account"
        )
        .await;
    
    // Currently: May panic or hang
    // Expected: Should return error with recursion limit exceeded
    assert!(result.is_err());
}
```

**Notes**
This vulnerability breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." The REST client performs unbounded computation during BCS deserialization without respecting recursion or memory limits that protect other parts of the system.

### Citations

**File:** crates/aptos-rest-client/src/lib.rs (L1209-1221)
```rust
    pub async fn get_account_resource_bcs<T: DeserializeOwned>(
        &self,
        address: AccountAddress,
        resource_type: &str,
    ) -> AptosResult<Response<T>> {
        let url = self.build_path(&format!(
            "accounts/{}/resource/{}",
            address.to_hex(),
            resource_type
        ))?;
        let response = self.get_bcs(url).await?;
        Ok(response.and_then(|inner| bcs::from_bytes(&inner))?)
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L1645-1656)
```rust
    async fn check_response(
        &self,
        response: reqwest::Response,
    ) -> AptosResult<(reqwest::Response, State)> {
        if !response.status().is_success() {
            Err(parse_error(response).await)
        } else {
            let state = parse_state(&response)?;

            Ok((response, state))
        }
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L1773-1779)
```rust
    async fn check_and_parse_bcs_response(
        &self,
        response: reqwest::Response,
    ) -> AptosResult<Response<bytes::Bytes>> {
        let (response, state) = self.check_response(response).await?;
        Ok(Response::new(response.bytes().await?, state))
    }
```

**File:** api/src/transactions.rs (L851-851)
```rust
    const MAX_SIGNED_TRANSACTION_DEPTH: usize = 16;
```

**File:** api/src/transactions.rs (L1224-1224)
```rust
                    bcs::from_bytes_with_limit(&data.0, Self::MAX_SIGNED_TRANSACTION_DEPTH)
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L38-39)
```rust
pub const USER_INPUT_RECURSION_LIMIT: usize = 32;
pub const RECURSION_LIMIT: usize = 64;
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L261-261)
```rust
        bcs::from_bytes_with_limit(bytes, limit).map_err(|e| anyhow!("{:?}", e))
```

**File:** crates/aptos-rest-client/src/client_builder.rs (L95-109)
```rust
    pub fn build(self) -> Client {
        let version_path_base = get_version_path_with_base(self.base_url.clone());

        Client {
            inner: self
                .reqwest_builder
                .default_headers(self.headers)
                .timeout(self.timeout)
                .cookie_store(true)
                .build()
                .unwrap(),
            base_url: self.base_url,
            version_path_base,
        }
    }
```
