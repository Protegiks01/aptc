# Audit Report

## Title
Reliable Broadcast Abort on Partial Serialization Failure Breaks Consensus Liveness

## Summary
The reliable broadcast mechanism in Aptos consensus aborts entirely when `to_bytes_by_protocol()` fails to serialize a message for any single protocol, preventing all validators from receiving critical consensus messages (CommitVote/CommitDecision). This violates the reliability guarantee of the broadcast protocol and can cause consensus liveness failures.

## Finding Description

The vulnerability exists in the interaction between the reliable broadcast implementation and protocol-specific message serialization: [1](#0-0) 

The `multicast()` function calls `to_bytes_by_protocol()` to pre-serialize messages for all peers according to their preferred protocols. The double `??` operator propagates any error, aborting the entire broadcast before any messages are sent.

The underlying serialization implementation groups peers by protocol and attempts serialization for each protocol group: [2](#0-1) 

At line 297, the `?` operator causes immediate failure if serialization fails for ANY protocol. This means if validators have negotiated different protocols (e.g., `ConsensusRpcBcs`, `ConsensusRpcCompressed`, `ConsensusRpcJson`), and message serialization succeeds for one protocol but fails for another (due to compression errors, size limit differences, or JSON encoding issues), the entire function returns an error.

The reliable broadcast code does have a fallback mechanism to handle missing pre-serialized messages: [3](#0-2) 

However, this fallback is never reached because the error at line 134 aborts the entire async block before any send operations begin.

The different protocols have varying encoding mechanisms that can fail independently: [4](#0-3) [5](#0-4) 

This implementation violates the **Consensus Safety** invariant by potentially preventing validators from participating in consensus when protocol-level serialization issues occur.

## Impact Explanation

**HIGH Severity** - This qualifies as "Significant protocol violations" per the Aptos bug bounty program:

1. **Consensus Liveness Impact**: When CommitVote or CommitDecision messages fail to broadcast due to partial serialization failures, validators cannot participate in the commit phase of consensus, potentially stalling the blockchain.

2. **Reliability Guarantee Violation**: The "reliable broadcast" protocol is supposed to ensure message delivery to all non-Byzantine validators. This implementation breaks that guarantee by aborting on partial failures instead of delivering to validators whose protocols succeeded.

3. **Protocol Version Vulnerability**: During network upgrades when validators may support different protocol versions, natural serialization incompatibilities can trigger total broadcast failures affecting the entire validator set.

4. **No Byzantine Fault Required**: This vulnerability can manifest without any malicious actors - simple protocol mismatches or serialization edge cases can trigger it.

## Likelihood Explanation

**Medium-High Likelihood**:

1. **Common Trigger Conditions**:
   - Network upgrades when validators support different protocol versions
   - Validators with heterogeneous configurations negotiating different protocols
   - Edge cases in message serialization (large messages, complex data structures)

2. **Natural Occurrence**: The vulnerability doesn't require exploitation - it can occur naturally during normal network operations when protocol diversity exists.

3. **Amplification Effect**: Once triggered, affects ALL validators simultaneously, not just a subset, making the impact system-wide.

## Recommendation

Modify `to_bytes_by_protocol()` to return partial results instead of failing entirely, and update the reliable broadcast code to handle partial serialization failures gracefully:

**Option 1: Return Partial Results from `to_bytes_by_protocol()`**

Change the implementation to collect successful serializations and log failures instead of aborting:

```rust
fn to_bytes_by_protocol(
    &self,
    peers: Vec<PeerNetworkId>,
    message: Message,
) -> anyhow::Result<HashMap<PeerNetworkId, Bytes>> {
    let peers_per_protocol = self.group_peers_by_protocol(peers);
    let mut bytes_per_peer = HashMap::new();
    
    for (protocol_id, peers) in peers_per_protocol {
        match protocol_id.to_bytes(&message) {
            Ok(bytes) => {
                let bytes: Bytes = bytes.into();
                for peer in peers {
                    bytes_per_peer.insert(peer, bytes.clone());
                }
            },
            Err(e) => {
                // Log the error but continue with other protocols
                warn!(
                    "Failed to serialize message for protocol {:?}: {:?}. Affected peers: {:?}",
                    protocol_id, e, peers
                );
                // These peers will use the fallback in send_message
            }
        }
    }
    
    Ok(bytes_per_peer)
}
```

**Option 2: Remove Pre-serialization Error Propagation**

Alternatively, make the pre-serialization step best-effort and always rely on the fallback:

```rust
let protocols = Arc::new(
    tokio::task::spawn_blocking(move || {
        sender.to_bytes_by_protocol(peers, message_clone)
            .unwrap_or_else(|e| {
                warn!("Pre-serialization failed: {:?}, will use per-peer fallback", e);
                HashMap::new()
            })
    })
    .await?,
);
```

This ensures the fallback mechanism at lines 148-151 is always available, maintaining the reliability guarantee of the broadcast protocol.

## Proof of Concept

```rust
#[cfg(test)]
mod test_reliable_broadcast_partial_failure {
    use super::*;
    use aptos_types::PeerId;
    use std::collections::HashMap;
    use bytes::Bytes;

    // Mock network sender that simulates partial serialization failure
    struct MockNetworkSender {
        failing_protocol: ProtocolId,
    }

    #[async_trait]
    impl RBNetworkSender<TestMessage> for MockNetworkSender {
        async fn send_rb_rpc_raw(
            &self,
            _receiver: Author,
            _message: Bytes,
            _timeout: Duration,
        ) -> anyhow::Result<TestMessage> {
            Ok(TestMessage::Ack)
        }

        async fn send_rb_rpc(
            &self,
            _receiver: Author,
            _message: TestMessage,
            _timeout: Duration,
        ) -> anyhow::Result<TestMessage> {
            Ok(TestMessage::Ack)
        }

        fn to_bytes_by_protocol(
            &self,
            peers: Vec<Author>,
            _message: TestMessage,
        ) -> anyhow::Result<HashMap<Author, Bytes>> {
            // Simulate: ConsensusRpcBcs works, ConsensusRpcCompressed fails
            for peer in &peers {
                // Simulate that peer uses the failing protocol
                if peer.as_ref()[0] % 2 == 0 {
                    // Fail on compression for even-numbered peers
                    anyhow::bail!("Compression failed for protocol");
                }
            }
            Ok(HashMap::new())
        }

        fn sort_peers_by_latency(&self, _peers: &mut [Author]) {}
    }

    #[tokio::test]
    async fn test_partial_serialization_failure_aborts_broadcast() {
        let validators = vec![
            Author::new([1u8; 32]),  // Uses BCS (succeeds)
            Author::new([2u8; 32]),  // Uses Compressed (fails)
        ];
        
        let network_sender = Arc::new(MockNetworkSender {
            failing_protocol: ProtocolId::ConsensusRpcCompressed,
        });

        let rb = ReliableBroadcast::new(
            validators[0],
            validators.clone(),
            network_sender,
            std::iter::repeat(Duration::from_millis(100)),
            TimeService::mock(),
            Duration::from_secs(5),
            BoundedExecutor::new(8, tokio::runtime::Handle::current()),
        );

        let status = Arc::new(MockBroadcastStatus::new(validators.clone()));
        
        // This should fail even though validator[0] could receive the message
        let result = rb.broadcast(TestMessage::Vote, status).await;
        
        assert!(result.is_err(), "Broadcast should fail due to partial serialization failure");
        // In reality, validator[0] should have received the message via fallback,
        // but the current implementation prevents this
    }
}
```

This PoC demonstrates that when `to_bytes_by_protocol()` fails for any peer, the entire broadcast aborts, even though some peers could successfully receive the message through the fallback mechanism.

## Notes

The vulnerability stems from overly aggressive error propagation that prevents the fallback mechanism from functioning as intended. The fix should preserve the optimization of pre-serialization while ensuring that partial failures don't break the reliability guarantee of the broadcast protocol. This is especially critical during network upgrades when protocol heterogeneity is expected and necessary for backwards compatibility.

### Citations

**File:** crates/reliable-broadcast/src/lib.rs (L130-135)
```rust
            let protocols = Arc::new(
                tokio::task::spawn_blocking(move || {
                    sender.to_bytes_by_protocol(peers, message_clone)
                })
                .await??,
            );
```

**File:** crates/reliable-broadcast/src/lib.rs (L146-152)
```rust
                    let send_fut = if receiver == self_author {
                        network_sender.send_rb_rpc(receiver, message, rpc_timeout_duration)
                    } else if let Some(raw_message) = protocols.get(&receiver).cloned() {
                        network_sender.send_rb_rpc_raw(receiver, raw_message, rpc_timeout_duration)
                    } else {
                        network_sender.send_rb_rpc(receiver, message, rpc_timeout_duration)
                    };
```

**File:** network/framework/src/application/interface.rs (L288-304)
```rust
    fn to_bytes_by_protocol(
        &self,
        peers: Vec<PeerNetworkId>,
        message: Message,
    ) -> anyhow::Result<HashMap<PeerNetworkId, Bytes>> {
        let peers_per_protocol = self.group_peers_by_protocol(peers);
        // Convert to bytes per protocol
        let mut bytes_per_peer = HashMap::new();
        for (protocol_id, peers) in peers_per_protocol {
            let bytes: Bytes = protocol_id.to_bytes(&message)?.into();
            for peer in peers {
                bytes_per_peer.insert(peer, bytes.clone());
            }
        }

        Ok(bytes_per_peer)
    }
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L156-172)
```rust
    fn encoding(self) -> Encoding {
        match self {
            ProtocolId::ConsensusDirectSendJson | ProtocolId::ConsensusRpcJson => Encoding::Json,
            ProtocolId::ConsensusDirectSendCompressed | ProtocolId::ConsensusRpcCompressed => {
                Encoding::CompressedBcs(RECURSION_LIMIT)
            },
            ProtocolId::ConsensusObserver => Encoding::CompressedBcs(RECURSION_LIMIT),
            ProtocolId::DKGDirectSendCompressed | ProtocolId::DKGRpcCompressed => {
                Encoding::CompressedBcs(RECURSION_LIMIT)
            },
            ProtocolId::JWKConsensusDirectSendCompressed
            | ProtocolId::JWKConsensusRpcCompressed => Encoding::CompressedBcs(RECURSION_LIMIT),
            ProtocolId::MempoolDirectSend => Encoding::CompressedBcs(USER_INPUT_RECURSION_LIMIT),
            ProtocolId::MempoolRpc => Encoding::Bcs(USER_INPUT_RECURSION_LIMIT),
            _ => Encoding::Bcs(RECURSION_LIMIT),
        }
    }
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L196-222)
```rust
    pub fn to_bytes<T: Serialize>(&self, value: &T) -> anyhow::Result<Vec<u8>> {
        // Start the serialization timer
        let serialization_timer = start_serialization_timer(*self, SERIALIZATION_LABEL);

        // Serialize the message
        let result = match self.encoding() {
            Encoding::Bcs(limit) => self.bcs_encode(value, limit),
            Encoding::CompressedBcs(limit) => {
                let compression_client = self.get_compression_client();
                let bcs_bytes = self.bcs_encode(value, limit)?;
                aptos_compression::compress(
                    bcs_bytes,
                    compression_client,
                    MAX_APPLICATION_MESSAGE_SIZE,
                )
                .map_err(|e| anyhow!("{:?}", e))
            },
            Encoding::Json => serde_json::to_vec(value).map_err(|e| anyhow!("{:?}", e)),
        };

        // Only record the duration if serialization was successful
        if result.is_ok() {
            serialization_timer.observe_duration();
        }

        result
    }
```
