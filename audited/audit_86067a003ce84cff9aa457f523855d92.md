# Audit Report

## Title
Write Set Verification Bypass in KV-Only Replay Allows Arbitrary State Manipulation

## Summary
The `replay_kv()` function bypasses write set integrity verification during database restoration, allowing an attacker who controls backup storage to inject malicious state changes that circumvent all Move VM access control checks. Write sets are applied directly to state without verifying their hash against `TransactionInfo.state_change_hash`, enabling complete state manipulation.

## Finding Description

The vulnerability exists in the backup restoration pipeline when using KV-only replay mode. The attack flow exploits a missing verification step:

**1. Missing Verification in LoadedChunk::load()**

When loading backup data, the code constructs a `TransactionListWithProof` for verification but critically **excludes write sets** from this verification: [1](#0-0) 

The write sets are loaded separately and returned unverified: [2](#0-1) [3](#0-2) 

**2. TransactionListWithProof Verification Gap**

The `TransactionListWithProof::verify()` method verifies transaction hashes, events, and transaction info proofs, but **does NOT verify** write set hashes against `TransactionInfo.state_change_hash`: [4](#0-3) 

**3. Direct State Application Without Validation**

The `replay_kv()` function directly applies unverified write sets to database state: [5](#0-4) 

This calls `save_transactions_and_replay_kv()` which applies write sets without verification: [6](#0-5) 

The underlying `save_transactions_impl()` with `kv_replay=true` directly applies write sets to state without any hash verification: [7](#0-6) 

**4. Comparison with Normal Replay**

In contrast, the normal `replay_transactions()` path re-executes transactions through the VM and verifies outputs match using `ensure_match_transaction_info()`: [8](#0-7) 

This verification **does verify** the write set hash matches `state_change_hash`: [9](#0-8) 

**5. Trusted Waypoints Do Not Protect Write Sets**

The trusted waypoint verification system only validates LedgerInfos for epoch endings and explicitly does NOT verify transaction/state backup data: [10](#0-9) 

**6. Both Restore Phases Use NoVerify Mode**

Both phase 1 and phase 2 of the restore process use `VerifyExecutionMode::NoVerify`, disabling all write set verification: [11](#0-10) [12](#0-11) 

**Attack Scenario:**

1. Attacker compromises backup storage (S3/GCS) or operates malicious backup service
2. Attacker modifies backup files keeping `Transaction`, `TransactionInfo`, `Events` unchanged
3. Attacker replaces `WriteSet` with malicious state changes (mint coins, modify validators, change governance)
4. All cryptographic verification (waypoints, signatures, Merkle proofs) passes because TransactionInfos are unchanged
5. Node operator restores using KV-only replay
6. Malicious write sets applied directly to state without hash verification
7. All Move VM access controls bypassed

## Impact Explanation

**CRITICAL Severity** - Aligns with Aptos Bug Bounty Category 1 (Loss of Funds) and Category 2 (Consensus/Safety Violations):

- **Loss of Funds**: Attacker can mint unlimited APT by crafting write sets that modify `CoinStore` resources at arbitrary addresses
- **Consensus Safety Violation**: Different validators restoring from different backup sources will have divergent state, breaking consensus
- **Validator Set Manipulation**: Complete control over validator set membership, stake amounts, and rewards
- **Governance Bypass**: Arbitrary modification of voting power, proposal states, and governance parameters
- **System Address Compromise**: Direct modification of `@aptos_framework` and `@core_resources` state without authorization

This violates core security invariants:
- **State Integrity**: Write set hashes in `TransactionInfo.state_change_hash` should match actual write sets
- **Deterministic Execution**: All nodes should derive identical state from identical transactions
- **Access Control**: System addresses should only be modifiable through authorized transactions

## Likelihood Explanation

**MEDIUM-HIGH Likelihood**:

**Attack Requirements:**
- Compromise backup storage OR operate malicious backup service provider
- Node operator uses KV-only replay (common for performance)
- No additional technical barriers

**Realistic Attack Vectors:**
1. **Supply Chain Attack**: Third-party backup service compromised or malicious
2. **Infrastructure Compromise**: S3/GCS bucket access via stolen credentials, misconfigurations, or insider threats
3. **Man-in-the-Middle**: Backup data modified during transfer if not properly secured
4. **Insider Threat**: Malicious backup administrator with storage access

The KV-only replay feature is specifically designed as a performance optimization and is commonly used during fast database restoration operations.

## Recommendation

Implement write set hash verification in the KV-only replay path:

1. In `LoadedChunk::load()`, verify write sets match `TransactionInfo.state_change_hash`:
   ```rust
   // After loading write sets, verify them
   for (txn_info, write_set) in txn_infos.iter().zip(write_sets.iter()) {
       let write_set_hash = CryptoHash::hash(write_set);
       ensure!(
           write_set_hash == txn_info.state_change_hash(),
           "Write set hash mismatch at version"
       );
   }
   ```

2. Alternatively, disable KV-only replay entirely and require full transaction replay with verification for all restoration operations.

3. Add explicit security warnings in documentation that backup storage must be cryptographically secured and access-controlled.

## Proof of Concept

A malicious actor with backup storage access can:

1. Extract valid transaction backup containing `(Txn, TxnInfo, Events, WriteSet)` tuples
2. Keep `Txn`, `TxnInfo`, `Events` unchanged (passes all existing verification)
3. Replace `WriteSet` with malicious state changes:
   - Modify `0x1::coin::CoinStore<AptosCoin>` to mint tokens
   - Modify `0x1::stake::ValidatorSet` to add attacker validators
   - Modify `0x1::aptos_governance::GovernanceProposals` to manipulate votes
4. Node restores using `--kv-only-replay` option
5. Malicious write sets applied without verification
6. Attacker achieves arbitrary state manipulation

The vulnerability is confirmed by code analysis showing write sets are never verified against `state_change_hash` during KV-only replay, despite this field existing specifically for integrity verification.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L110-136)
```rust
        let mut write_sets = Vec::new();

        while let Some(record_bytes) = file.read_record_bytes().await? {
            let (txn, aux_info, txn_info, events, write_set): (
                _,
                PersistedAuxiliaryInfo,
                _,
                _,
                WriteSet,
            ) = match manifest.format {
                TransactionChunkFormat::V0 => {
                    let (txn, txn_info, events, write_set) = bcs::from_bytes(&record_bytes)?;
                    (
                        txn,
                        PersistedAuxiliaryInfo::None,
                        txn_info,
                        events,
                        write_set,
                    )
                },
                TransactionChunkFormat::V1 => bcs::from_bytes(&record_bytes)?,
            };
            txns.push(txn);
            persisted_aux_info.push(aux_info);
            txn_infos.push(txn_info);
            event_vecs.push(events);
            write_sets.push(write_set);
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L156-167)
```rust
        // make a `TransactionListWithProof` to reuse its verification code.
        let txn_list_with_proof =
            TransactionListWithProofV2::new(TransactionListWithAuxiliaryInfos::new(
                TransactionListWithProof::new(
                    txns,
                    Some(event_vecs),
                    Some(manifest.first_version),
                    TransactionInfoListWithProof::new(range_proof, txn_infos),
                ),
                persisted_aux_info,
            ));
        txn_list_with_proof.verify(ledger_info.ledger_info(), Some(manifest.first_version))?;
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L184-184)
```rust
            write_sets,
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L593-600)
```rust
                        handler.save_transactions_and_replay_kv(
                            base_version,
                            &txns,
                            &persisted_aux_info,
                            &txn_infos,
                            &events,
                            write_sets,
                        )?;
```

**File:** types/src/transaction/mod.rs (L1898-1908)
```rust
        let write_set_hash = CryptoHash::hash(self.write_set());
        ensure!(
            write_set_hash == txn_info.state_change_hash(),
            "{}: version:{}, write_set_hash:{:?}, expected:{:?}, write_set: {:?}, expected(if known): {:?}",
            ERR_MSG,
            version,
            write_set_hash,
            txn_info.state_change_hash(),
            self.write_set,
            expected_write_set,
        );
```

**File:** types/src/transaction/mod.rs (L2295-2354)
```rust
    pub fn verify(
        &self,
        ledger_info: &LedgerInfo,
        first_transaction_version: Option<Version>,
    ) -> Result<()> {
        // Verify the first transaction versions match
        ensure!(
            self.get_first_transaction_version() == first_transaction_version,
            "First transaction version ({:?}) doesn't match given version ({:?}).",
            self.get_first_transaction_version(),
            first_transaction_version,
        );

        // Verify the lengths of the transactions and transaction infos match
        ensure!(
            self.proof.transaction_infos.len() == self.get_num_transactions(),
            "The number of TransactionInfo objects ({}) does not match the number of \
             transactions ({}).",
            self.proof.transaction_infos.len(),
            self.get_num_transactions(),
        );

        // Verify the transaction hashes match those of the transaction infos
        self.transactions
            .par_iter()
            .zip_eq(self.proof.transaction_infos.par_iter())
            .map(|(txn, txn_info)| {
                let txn_hash = CryptoHash::hash(txn);
                ensure!(
                    txn_hash == txn_info.transaction_hash(),
                    "The hash of transaction does not match the transaction info in proof. \
                     Transaction hash: {:x}. Transaction hash in txn_info: {:x}.",
                    txn_hash,
                    txn_info.transaction_hash(),
                );
                Ok(())
            })
            .collect::<Result<Vec<_>>>()?;

        // Verify the transaction infos are proven by the ledger info.
        self.proof
            .verify(ledger_info, self.get_first_transaction_version())?;

        // Verify the events if they exist.
        if let Some(event_lists) = &self.events {
            ensure!(
                event_lists.len() == self.get_num_transactions(),
                "The length of event_lists ({}) does not match the number of transactions ({}).",
                event_lists.len(),
                self.get_num_transactions(),
            );
            event_lists
                .into_par_iter()
                .zip_eq(self.proof.transaction_infos.par_iter())
                .map(|(events, txn_info)| verify_events_against_root_hash(events, txn_info))
                .collect::<Result<Vec<_>>>()?;
        }

        Ok(())
    }
```

**File:** storage/aptosdb/src/backup/restore_handler.rs (L105-126)
```rust
    pub fn save_transactions_and_replay_kv(
        &self,
        first_version: Version,
        txns: &[Transaction],
        persisted_aux_info: &[PersistedAuxiliaryInfo],
        txn_infos: &[TransactionInfo],
        events: &[Vec<ContractEvent>],
        write_sets: Vec<WriteSet>,
    ) -> Result<()> {
        restore_utils::save_transactions(
            self.state_store.clone(),
            self.ledger_db.clone(),
            first_version,
            txns,
            persisted_aux_info,
            txn_infos,
            events,
            write_sets,
            None,
            true,
        )
    }
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L269-277)
```rust
    if kv_replay && first_version > 0 && state_store.get_usage(Some(first_version - 1)).is_ok() {
        let (ledger_state, _hot_state_updates) = state_store.calculate_state_and_put_updates(
            &StateUpdateRefs::index_write_sets(first_version, write_sets, write_sets.len(), vec![]),
            &mut ledger_db_batch.ledger_metadata_db_batches, // used for storing the storage usage
            state_kv_batches,
        )?;
        // n.b. ideally this is set after the batches are committed
        state_store.set_state_ignoring_summary(ledger_state);
    }
```

**File:** execution/executor/src/chunk_executor/mod.rs (L636-641)
```rust
            if let Err(err) = txn_out.ensure_match_transaction_info(
                version,
                txn_info,
                Some(write_set),
                Some(events),
            ) {
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L332-345)
```rust
pub struct TrustedWaypointOpt {
    #[clap(
        long,
        help = "(multiple) When provided, an epoch ending LedgerInfo at the waypoint version will be \
        checked against the hash in the waypoint, but signatures on it are NOT checked. \
        Use this for two purposes: \
        1. set the genesis or the latest waypoint to confirm the backup is compatible. \
        2. set waypoints at versions where writeset transactions were used to overwrite the \
        validator set, so that the signature check is skipped. \
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
    )]
    pub trust_waypoint: Vec<Waypoint>,
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L294-296)
```rust
                Some((kv_replay_version, true /* only replay KV */)),
                epoch_history.clone(),
                VerifyExecutionMode::NoVerify,
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L365-367)
```rust
                replay_version,
                epoch_history,
                VerifyExecutionMode::NoVerify,
```
