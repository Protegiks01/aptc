# Audit Report

## Title
Resource Exhaustion DoS via Integer Overflow Bypass in Backup Service Transaction Iterator

## Summary
The `expect_continuous_versions()` function contains an edge case where `first_version = 0` and `limit = u64::MAX` bypasses the overflow check, allowing the backup service to accept unbounded transaction requests that cause resource exhaustion and denial of service.

## Finding Description

The vulnerability exists in the `expect_continuous_versions()` function where the overflow protection can be bypassed in a specific edge case. [1](#0-0) 

The critical issue is at line 98: when `first_version = 0` and `limit` is cast to `u64::MAX`, the expression `0u64.checked_add(u64::MAX)` returns `Some(u64::MAX)` rather than `None`, because `0 + u64::MAX = u64::MAX` is a valid `u64` value and does not overflow. This bypasses the error check and sets `end_version = u64::MAX`.

The backup service exposes this vulnerability through an unauthenticated HTTP endpoint that accepts `usize` parameters directly from the URL path without validation: [2](#0-1) 

An attacker can send a malicious request: `GET /transactions/0/18446744073709551615` where the second parameter is `u64::MAX` (on 64-bit systems where `usize::MAX = u64::MAX`). This creates an iterator attempting to fetch nearly all possible transaction versions (0 through u64::MAX - 1), causing:

1. **Excessive Database I/O**: Reading potentially millions/billions of transactions from disk
2. **Memory Exhaustion**: Buffering and serializing massive amounts of transaction data  
3. **CPU Saturation**: Continuous serialization of transaction records
4. **Network Bandwidth Exhaustion**: Streaming enormous response payloads
5. **Service Unavailability**: Backup service becomes unresponsive to legitimate requests

The backup service is started on validator nodes: [3](#0-2) 

This breaks the **Resource Limits** invariant (#9): "All operations must respect gas, storage, and computational limits." The backup service has no request size limits comparable to the `MAX_REQUEST_LIMIT = 20_000` enforced in other API endpoints. [4](#0-3) 

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty criteria for the following reasons:

1. **Validator Node Slowdowns**: The attack ties up critical database and network resources on validator nodes running the backup service, degrading overall node performance
2. **API Crashes**: The backup service can become completely unresponsive, and resource exhaustion may impact other services running on the same node
3. **No Authentication Required**: The backup service has no authentication, allowing any network-accessible attacker to exploit this
4. **Deterministic Attack**: The attack requires only a single malformed HTTP GET request to trigger

While this does not directly compromise consensus safety or cause loss of funds, it creates a reliable denial-of-service vector against validator infrastructure, which qualifies as "Validator node slowdowns" and "API crashes" under High Severity.

## Likelihood Explanation

**Likelihood: High**

- **Attacker Requirements**: Only requires network access to the backup service endpoint (HTTP request)
- **Complexity**: Trivial - a single GET request with specific parameters
- **Detection Difficulty**: May not be detected until resource exhaustion occurs
- **Exposure**: Any validator node running the backup service is vulnerable
- **No Rate Limiting**: The backup service lacks request size validation or rate limiting

The attack is highly likely to succeed whenever attempted against an exposed backup service endpoint.

## Recommendation

Implement request size validation in the backup service handlers, consistent with other API endpoints:

```rust
// In storage/backup/backup-service/src/handlers/mod.rs
use aptos_storage_interface::MAX_REQUEST_LIMIT;

let transactions = warp::path!(Version / usize)
    .and_then(move |start_version, num_transactions| async move {
        if num_transactions > MAX_REQUEST_LIMIT as usize {
            return Err(warp::reject::custom(RequestTooLarge));
        }
        // ... existing code
    })
```

Additionally, add a maximum bound check in `expect_continuous_versions()`:

```rust
fn expect_continuous_versions(
    self,
    first_version: Version,
    limit: usize,
) -> Result<ContinuousVersionIter<Self, T>> {
    // Prevent unreasonably large requests
    const MAX_ITERATOR_LIMIT: usize = 1_000_000;
    if limit > MAX_ITERATOR_LIMIT {
        return Err(AptosDbError::TooManyRequested(first_version, limit as u64));
    }
    
    Ok(ContinuousVersionIter {
        inner: self,
        first_version,
        expected_next_version: first_version,
        end_version: first_version
            .checked_add(limit as u64)
            .ok_or(AptosDbError::TooManyRequested(first_version, limit as u64))?,
        _phantom: Default::default(),
    })
}
```

## Proof of Concept

**Attack Scenario:**

1. Identify a validator node running the backup service (typically on a configured port)
2. Send the malicious request:

```bash
# On a 64-bit system, request u64::MAX transactions starting from version 0
curl "http://<validator-backup-service>:6186/transactions/0/18446744073709551615"

# This bypasses the overflow check because:
# 0u64.checked_add(18446744073709551615u64) = Some(18446744073709551615)
# The iterator is created with end_version = u64::MAX
```

**Expected Result:**
- The backup service attempts to iterate through all transactions from version 0 to u64::MAX - 1
- Database I/O spikes as it reads transaction records
- Memory usage increases as transactions are serialized
- The service becomes unresponsive to other requests
- Network bandwidth saturates attempting to stream the massive response

**Verification Steps:**

```rust
// Minimal Rust test to verify the overflow bypass
#[test]
fn test_overflow_bypass() {
    let first_version: u64 = 0;
    let limit: u64 = u64::MAX;
    
    // This should overflow for first_version >= 1
    assert!(1u64.checked_add(u64::MAX).is_none());
    
    // But NOT for first_version = 0 (the vulnerability)
    assert_eq!(0u64.checked_add(u64::MAX), Some(u64::MAX));
}
```

The vulnerability is confirmed through analysis of the code paths and arithmetic properties of `checked_add()`.

### Citations

**File:** storage/aptosdb/src/utils/iterators.rs (L88-102)
```rust
    fn expect_continuous_versions(
        self,
        first_version: Version,
        limit: usize,
    ) -> Result<ContinuousVersionIter<Self, T>> {
        Ok(ContinuousVersionIter {
            inner: self,
            first_version,
            expected_next_version: first_version,
            end_version: first_version
                .checked_add(limit as u64)
                .ok_or(AptosDbError::TooManyRequested(first_version, limit as u64))?,
            _phantom: Default::default(),
        })
    }
```

**File:** storage/backup/backup-service/src/handlers/mod.rs (L102-110)
```rust
    let bh = backup_handler.clone();
    let transactions = warp::path!(Version / usize)
        .map(move |start_version, num_transactions| {
            reply_with_bytes_sender(&bh, TRANSACTIONS, move |bh, sender| {
                bh.get_transaction_iter(start_version, num_transactions)?
                    .try_for_each(|record_res| sender.send_size_prefixed_bcs_bytes(record_res?))
            })
        })
        .recover(handle_rejection);
```

**File:** aptos-node/src/storage.rs (L70-71)
```rust
            let db_backup_service =
                start_backup_service(node_config.storage.backup_service_address, db_arc.clone());
```

**File:** storage/storage-interface/src/lib.rs (L56-58)
```rust
// This is last line of defense against large queries slipping through external facing interfaces,
// like the API and State Sync, etc.
pub const MAX_REQUEST_LIMIT: u64 = 20_000;
```
