# Audit Report

## Title
Verified Module Cache Not Flushed on VerifierConfig Changes Enabling Consensus Divergence Before RELEASE_V1_34

## Summary
Before gas feature version 38 (RELEASE_V1_34), changes to VerifierConfig limits during protocol upgrades do not flush the global verified module cache (`VERIFIED_MODULES_CACHE`). This allows previously-verified modules to bypass re-verification under stricter limits, causing consensus divergence when validators have inconsistent cache states.

## Finding Description

The Aptos Move VM maintains a global cache of verified module hashes to avoid expensive re-verification. When a module is loaded from storage, the system checks if its hash exists in `VERIFIED_MODULES_CACHE` and skips verification if found. [1](#0-0) 

The VerifierConfig contains limits like `max_type_nodes`, `max_function_return_values`, and `max_type_depth` that can change based on feature flags. When `ENABLE_FUNCTION_VALUES` is activated, these limits become more restrictive: [2](#0-1) 

**The Critical Bug**: Before RELEASE_V1_34, when the VerifierConfig changes during a protocol upgrade, the module cache is flushed but `VERIFIED_MODULES_CACHE` is NOT: [3](#0-2) 

This creates a consensus divergence scenario:

1. Module M is published with 200 type nodes (valid under `max_type_nodes = 256`)
2. Hash stored in `VERIFIED_MODULES_CACHE` on Validator A
3. `ENABLE_FUNCTION_VALUES` activates, changing `max_type_nodes` to 128
4. Validator B restarts and doesn't have M in cache
5. Transaction uses module M:
   - **Validator A**: Finds hash in cache → skips verification → uses module → SUCCESS
   - **Validator B**: Cache miss → verifies with new config (max=128) → module has 200 nodes → FAILS with `TOO_MANY_TYPE_NODES`
6. Different execution results → **Consensus Divergence**

The limits enforcement happens during verification: [4](#0-3) 

## Impact Explanation

This is **Critical Severity** as it causes:
- **Consensus Safety Violation**: Validators produce different state roots for identical blocks
- **Network Partition Risk**: Requires hardfork to resolve if validators split on incompatible states
- **Deterministic Execution Breakage**: Violates the fundamental invariant that all validators must execute identically

The issue exists in production networks that operated at `gas_feature_version < 38` before the fix was deployed.

## Likelihood Explanation

**Likelihood: High** during protocol upgrades that modify VerifierConfig:
- Feature flag changes happen through governance proposals at epoch boundaries
- Validators have different cache states based on execution history
- Validators that restart lose cache contents
- Any transaction loading an edge-case module triggers divergence
- No special privileges required - any module publisher can create the trigger condition

## Recommendation

The fix implemented in RELEASE_V1_34 must be applied: flush `VERIFIED_MODULES_CACHE` when verifier config bytes change. The corrected code checks: [5](#0-4) 

**Additional Recommendations:**
1. Ensure all networks upgrade to `gas_feature_version >= 38`
2. Add monitoring for verifier config changes
3. Consider persisting verifier config version with cached module hashes
4. Document that VerifierConfig changes require cache flush

## Proof of Concept

```rust
// Proof of Concept: Consensus Divergence via Stale Verification Cache

#[test]
fn test_verifier_config_cache_divergence() {
    use aptos_types::on_chain_config::FeatureFlag;
    use move_binary_format::CompiledModule;
    
    // Setup: Network at gas_feature_version < 38
    let mut harness = MoveHarness::new();
    harness.disable_feature(FeatureFlag::ENABLE_FUNCTION_VALUES);
    
    // Step 1: Publish module with 200 type nodes (valid under max=256)
    let account = harness.new_account_at(AccountAddress::from_hex_literal("0xcafe").unwrap());
    let module_bytes = create_module_with_type_nodes(200); // Helper creates module
    harness.publish_module(&account, module_bytes.clone());
    
    // Simulate Validator A caching the verified module
    let module = CompiledModule::deserialize(&module_bytes).unwrap();
    let hash = hash_module(&module);
    VERIFIED_MODULES_CACHE.put(hash); // Module now cached
    
    // Step 2: Enable ENABLE_FUNCTION_VALUES (changes max_type_nodes: 256→128)
    harness.enable_feature(FeatureFlag::ENABLE_FUNCTION_VALUES);
    harness.reconfigure(); // Triggers epoch change
    
    // Step 3: Simulate Validator B restart (cache cleared)
    let validator_b = MoveHarness::new();
    validator_b.enable_feature(FeatureFlag::ENABLE_FUNCTION_VALUES);
    
    // Step 4: Execute transaction using the module
    let txn = create_transaction_using_module("0xcafe::edge_case::function");
    
    // Validator A: Uses cached verification (SUCCESS)
    let result_a = harness.execute_transaction(txn.clone());
    assert!(result_a.status().is_success());
    
    // Validator B: Re-verifies with new config (FAILURE - TOO_MANY_TYPE_NODES)
    let result_b = validator_b.execute_transaction(txn);
    assert_eq!(result_b.status().status_code(), StatusCode::TOO_MANY_TYPE_NODES);
    
    // CONSENSUS DIVERGENCE: Different state roots for same transaction
    assert_ne!(result_a.state_root(), result_b.state_root());
}
```

## Notes

This vulnerability was patched in RELEASE_V1_34 (gas feature version 38) by adding verifier config comparison and cache flushing. Networks operating below this version remain vulnerable. The fix ensures cache consistency across all validators during protocol upgrades that modify verification limits.

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L184-198)
```rust
        if !VERIFIED_MODULES_CACHE.contains(module_hash) {
            let _timer =
                VM_TIMER.timer_with_label("move_bytecode_verifier::verify_module_with_config");

            // For regular execution, we cache already verified modules. Note that this even caches
            // verification for the published modules. This should be ok because as long as the
            // hash is the same, the deployed bytecode and any dependencies are the same, and so
            // the cached verification result can be used.
            move_bytecode_verifier::verify_module_with_config(
                &self.vm_config().verifier_config,
                compiled_module.as_ref(),
            )?;
            check_natives(compiled_module.as_ref())?;
            VERIFIED_MODULES_CACHE.put(*module_hash);
        }
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L162-192)
```rust
        max_type_nodes: if enable_function_values {
            Some(128)
        } else {
            Some(256)
        },
        max_push_size: Some(10000),
        max_struct_definitions: None,
        max_struct_variants: None,
        max_fields_in_struct: None,
        max_function_definitions: None,
        max_back_edges_per_function: None,
        max_back_edges_per_module: None,
        max_basic_blocks_in_script: None,
        max_per_fun_meter_units: Some(1000 * 80000),
        max_per_mod_meter_units: Some(1000 * 80000),
        _use_signature_checker_v2: true,
        sig_checker_v2_fix_script_ty_param_count,
        sig_checker_v2_fix_function_signatures,
        enable_enum_types,
        enable_resource_access_control,
        enable_function_values,
        max_function_return_values: if enable_function_values {
            Some(128)
        } else {
            None
        },
        max_type_depth: if enable_function_values {
            Some(20)
        } else {
            None
        },
```

**File:** aptos-move/block-executor/src/code_cache_global_manager.rs (L115-130)
```rust
        let environment_requires_update = self.environment.as_ref() != Some(&storage_environment);
        if environment_requires_update {
            if storage_environment.gas_feature_version() >= RELEASE_V1_34 {
                let flush_verifier_cache = self.environment.as_ref().is_none_or(|e| {
                    e.verifier_config_bytes() != storage_environment.verifier_config_bytes()
                });
                if flush_verifier_cache {
                    // Additionally, if the verifier config changes, we flush static verifier cache
                    // as well.
                    RuntimeEnvironment::flush_verified_module_cache();
                }
            }

            self.environment = Some(storage_environment);
            self.module_cache.flush();
        }
```

**File:** third_party/move/move-bytecode-verifier/src/limits.rs (L189-193)
```rust
        if let Some(limit) = config.max_type_nodes {
            if type_size > limit {
                return Err(PartialVMError::new(StatusCode::TOO_MANY_TYPE_NODES));
            }
        }
```
