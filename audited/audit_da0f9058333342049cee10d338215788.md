# Audit Report

## Title
Error Code Constant Mismatch Between Move Framework and VM Binary Causes Consensus Break During Protocol Upgrades

## Summary
The error code category constants (INVALID_ARGUMENT, OUT_OF_RANGE, etc.) are defined independently in both the Move framework (`error.move` at address 0x1) and the Rust VM binary (`aptos-vm/src/errors.rs`). These constants must match for the VM's error classification logic to work correctly. However, the framework can be upgraded via governance proposals independently of node binary upgrades, and there is no runtime validation ensuring the constants remain synchronized. During epoch transitions when nodes are upgrading or when framework upgrades occur mid-epoch, validators running different versions will classify prologue/epilogue errors differently, leading to non-deterministic transaction status decisions and different state roots, breaking consensus.

## Finding Description

The vulnerability exists across three layers of the codebase:

**Layer 1: Move Framework Error Constants** [1](#0-0) 

These constants define error categories that are shifted left 16 bits and combined with reason codes to create canonical error codes used throughout the framework.

**Layer 2: Rust Type System Error Constants** [2](#0-1) 

These are duplicate definitions in Rust, used by various components.

**Layer 3: VM Error Classification Constants** [3](#0-2) 

The VM uses LOCAL constants for pattern matching when converting Move abort codes to StatusCodes. The critical pattern matching logic is here: [4](#0-3) 

**The Vulnerability Chain:**

1. Transaction validation functions use error category functions to construct abort codes: [5](#0-4) 

2. When a transaction aborts, the `convert_prologue_error` function extracts the category using `error_split`: [6](#0-5) 

3. The StatusCode determines the StatusType (Validation, Execution, etc.): [7](#0-6) 

4. The StatusType determines whether the transaction is Kept or Discarded: [8](#0-7) 

5. TransactionStatus affects what gets committed to state: [9](#0-8) 

**Attack Scenario:**

The Move stdlib at address 0x1 uses the `compat` upgrade policy by default: [10](#0-9) 

This allows framework upgrades via governance: [11](#0-10) 

During a protocol upgrade where:
- Framework is upgraded (changing `OUT_OF_RANGE` from `0x2` to `0x8`)
- Some validators have upgraded their binaries, some haven't
- A transaction calls `error::out_of_range(PROLOGUE_ESEQUENCE_NUMBER_TOO_BIG)`

Result:
- Old binary: abort code = (0x2 << 16) + 1008, matches `(LIMIT_EXCEEDED, 1008)` → `StatusCode::SEQUENCE_NUMBER_TOO_BIG` → Discard
- New binary: abort code = (0x8 << 16) + 1008, no match → `StatusCode::UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION` → Discard or Keep depending on feature flag
- **Different TransactionStatus → Different state roots → Consensus break**

## Impact Explanation

This is **Critical Severity** per Aptos bug bounty criteria because:

1. **Consensus/Safety Violation**: Breaks the fundamental invariant that all validators must produce identical state roots for identical blocks. Different nodes would compute different state roots when processing the same transactions.

2. **Non-recoverable Network Partition**: Once the mismatch occurs, the chain would fork. Different validators would be on different branches, unable to reach consensus. This would require a hardfork to recover.

3. **Breaks Deterministic Execution**: Violates Invariant #1 - the core guarantee that all validators execute transactions identically.

The vulnerability affects the critical transaction validation path (prologue/epilogue), which processes every transaction on the network. The impact is network-wide and immediate.

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability can occur through:

1. **Uncoordinated Protocol Upgrades**: During routine protocol upgrades, if framework changes and binary changes aren't perfectly synchronized, a window exists where validators have mismatched constants. Protocol upgrades happen regularly (every few months).

2. **Governance-Driven Framework Upgrades**: Any governance proposal that modifies error constants in `error.move` would create immediate inconsistency if node binaries haven't been updated. The framework uses `compat` policy, which allows such changes.

3. **Staggered Validator Upgrades**: Validators don't all upgrade simultaneously at epoch boundaries. There's typically a transition period where some have upgraded and others haven't.

No malicious intent is required - this can happen through normal operational processes. The lack of runtime validation makes it easy to miss during testing.

## Recommendation

Implement a multi-layered defense:

**1. Runtime Validation Check:**
Add a genesis/initialization check that validates Move constants match Rust constants:

```rust
// In aptos-vm/src/aptos_vm.rs or similar initialization code
fn validate_error_constants() -> Result<()> {
    // Query the on-chain error.move constants via the state view
    let move_invalid_arg = /* read INVALID_ARGUMENT from @0x1::error */;
    let move_out_of_range = /* read OUT_OF_RANGE from @0x1::error */;
    
    // Compare with Rust constants
    ensure!(
        move_invalid_arg == INVALID_ARGUMENT as u64,
        "Error constant mismatch: INVALID_ARGUMENT"
    );
    ensure!(
        move_out_of_range == LIMIT_EXCEEDED as u64,
        "Error constant mismatch: OUT_OF_RANGE"  
    );
    // ... validate all constants
    Ok(())
}
```

**2. Make Error Constants Immutable:**
Change the upgrade policy for `move-stdlib` to `immutable` to prevent governance-driven changes: [12](#0-11) 

**3. Protocol Version Gating:**
Add explicit feature flags that gate changes to error constants, ensuring binary and framework upgrades are atomic.

**4. Documentation:**
Add clear warnings in code comments that these constants MUST remain synchronized across Move and Rust.

## Proof of Concept

```rust
// Reproduction steps for consensus break:

// 1. Setup: Two validator nodes in same epoch
// Node A: Old binary with LIMIT_EXCEEDED = 0x2
// Node B: New binary with LIMIT_EXCEEDED = 0x8

// 2. Framework state: error.move has been upgraded with OUT_OF_RANGE = 0x8

// 3. Submit transaction with sequence number too big:
let txn = Transaction::UserTransaction(
    SignedTransaction::new(
        RawTransaction::new(
            sender_addr,
            999999, // sequence_number way too high
            TransactionPayload::EntryFunction(/* any valid entry function */),
            /* ... */
        ),
        /* signature */
    )
);

// 4. In prologue_common(), validation fails:
// transaction_validation.move line 230 calls:
// error::out_of_range(PROLOGUE_ESEQUENCE_NUMBER_TOO_BIG)
// This produces: (0x8 << 16) + 1008 = 524296

// 5. Node A's convert_prologue_error():
// error_split(524296) = (category: 0x8, reason: 1008)
// Pattern match at line 142 expects (0x2, 1008), doesn't match
// Falls to default case line 156 → UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION
// This is InvariantViolation → Discard (or Keep if CHARGE_INVARIANT_VIOLATION enabled)

// 6. Node B's convert_prologue_error():
// error_split(524296) = (category: 0x8, reason: 1008)  
// Pattern match expects (0x8, 1008) with updated constant → MATCHES!
// Returns SEQUENCE_NUMBER_TOO_BIG → Validation error → Discard

// 7. If feature flag differs or one node Keeps and one Discards:
// Different TransactionStatus → Different state transitions
// Node A computes state_root_A, Node B computes state_root_B
// state_root_A ≠ state_root_B → CONSENSUS BREAK
```

The PoC demonstrates how identical transaction processing produces different state roots when error constants are mismatched between binary versions during framework upgrades.

### Citations

**File:** aptos-move/framework/move-stdlib/sources/error.move (L25-61)
```text
  const INVALID_ARGUMENT: u64 = 0x1;

  /// An input or result of a computation is out of range (http: 400)
  const OUT_OF_RANGE: u64 = 0x2;

  /// The system is not in a state where the operation can be performed (http: 400)
  const INVALID_STATE: u64 = 0x3;

  /// Request not authenticated due to missing, invalid, or expired auth token (http: 401)
  const UNAUTHENTICATED: u64 = 0x4;

  /// client does not have sufficient permission (http: 403)
  const PERMISSION_DENIED: u64 = 0x5;

  /// A specified resource is not found (http: 404)
  const NOT_FOUND: u64 = 0x6;

  /// Concurrency conflict, such as read-modify-write conflict (http: 409)
  const ABORTED: u64 = 0x7;

  /// The resource that a client tried to create already exists (http: 409)
  const ALREADY_EXISTS: u64 = 0x8;

  /// Out of gas or other forms of quota (http: 429)
  const RESOURCE_EXHAUSTED: u64 = 0x9;

  /// Request cancelled by the client (http: 499)
  const CANCELLED: u64 = 0xA;

  /// Internal error (http: 500)
  const INTERNAL: u64 = 0xB;

  /// Feature not implemented (http: 501)
  const NOT_IMPLEMENTED: u64 = 0xC;

  /// The service is currently unavailable. Indicates that a retry could solve the issue (http: 503)
  const UNAVAILABLE: u64 = 0xD;
```

**File:** types/src/error.rs (L116-153)
```rust
pub const INVALID_ARGUMENT: u64 = 0x1;

/// An input or result of a computation is out of range (http: 400)
pub const OUT_OF_RANGE: u64 = 0x2;

/// The system is not in a state where the operation can be performed (http: 400)
pub const INVALID_STATE: u64 = 0x3;

/// Request not authenticated due to missing, invalid, or expired auth token (http: 401)
pub const UNAUTHENTICATED: u64 = 0x4;

/// client does not have sufficient permission (http: 403)
pub const PERMISSION_DENIED: u64 = 0x5;

/// A specified resource is not found (http: 404)
pub const NOT_FOUND: u64 = 0x6;

/// Concurrency conflict, such as read-modify-write conflict (http: 409)
pub const ABORTED: u64 = 0x7;

/// The resource that a client tried to create already exists (http: 409)
pub const ALREADY_EXISTS: u64 = 0x8;

/// Out of gas or other forms of quota (http: 429)
pub const RESOURCE_EXHAUSTED: u64 = 0x9;

/// Request cancelled by the client (http: 499)
pub const CANCELLED: u64 = 0xA;

/// Internal error (http: 500)
pub const INTERNAL: u64 = 0xB;

/// Feature not implemented (http: 501)
pub const NOT_IMPLEMENTED: u64 = 0xC;

/// The service is currently unavailable. Indicates that a retry could solve the issue (http: 503)
pub const UNAVAILABLE: u64 = 0xD;

```

**File:** aptos-move/aptos-vm/src/errors.rs (L57-61)
```rust
const INVALID_ARGUMENT: u8 = 0x1;
const LIMIT_EXCEEDED: u8 = 0x2;
const INVALID_STATE: u8 = 0x3;
const PERMISSION_DENIED: u8 = 0x5;
const NOT_FOUND: u8 = 0x6;
```

**File:** aptos-move/aptos-vm/src/errors.rs (L63-67)
```rust
fn error_split(code: u64) -> (u8, u64) {
    let reason = code & 0xFFFF;
    let category = ((code >> 16) & 0xFF) as u8;
    (category, reason)
}
```

**File:** aptos-move/aptos-vm/src/errors.rs (L124-172)
```rust
            let new_major_status = match error_split(code) {
                // Invalid authentication key
                (INVALID_ARGUMENT, EBAD_ACCOUNT_AUTHENTICATION_KEY) => StatusCode::INVALID_AUTH_KEY,
                // Sequence number too old
                (INVALID_ARGUMENT, ESEQUENCE_NUMBER_TOO_OLD) => StatusCode::SEQUENCE_NUMBER_TOO_OLD,
                // Sequence number too new
                (INVALID_ARGUMENT, ESEQUENCE_NUMBER_TOO_NEW) => StatusCode::SEQUENCE_NUMBER_TOO_NEW,
                // Sequence number too new
                (INVALID_ARGUMENT, EACCOUNT_DOES_NOT_EXIST) => {
                    StatusCode::SENDING_ACCOUNT_DOES_NOT_EXIST
                },
                // Can't pay for transaction gas deposit/fee
                (INVALID_ARGUMENT, ECANT_PAY_GAS_DEPOSIT) => {
                    StatusCode::INSUFFICIENT_BALANCE_FOR_TRANSACTION_FEE
                },
                (INVALID_ARGUMENT, ETRANSACTION_EXPIRED) => StatusCode::TRANSACTION_EXPIRED,
                (INVALID_ARGUMENT, EBAD_CHAIN_ID) => StatusCode::BAD_CHAIN_ID,
                // Sequence number will overflow
                (LIMIT_EXCEEDED, ESEQUENCE_NUMBER_TOO_BIG) => StatusCode::SEQUENCE_NUMBER_TOO_BIG,
                (INVALID_ARGUMENT, ESECONDARY_KEYS_ADDRESSES_COUNT_MISMATCH) => {
                    StatusCode::SECONDARY_KEYS_ADDRESSES_COUNT_MISMATCH
                },
                (INVALID_ARGUMENT, EGAS_PAYER_ACCOUNT_MISSING) => {
                    StatusCode::GAS_PAYER_ACCOUNT_MISSING
                },
                (INVALID_STATE, EINSUFFICIENT_BALANCE_FOR_REQUIRED_DEPOSIT) => {
                    StatusCode::INSUFFICIENT_BALANCE_FOR_REQUIRED_DEPOSIT
                },
                (INVALID_ARGUMENT, ETRANSACTION_EXPIRATION_TOO_FAR_IN_FUTURE) => {
                    StatusCode::TRANSACTION_EXPIRATION_TOO_FAR_IN_FUTURE
                },
                (INVALID_ARGUMENT, ENONCE_ALREADY_USED) => StatusCode::NONCE_ALREADY_USED,
                (category, reason) => {
                    let mut err_msg = format!(
                        "[aptos_vm] Unexpected prologue Move abort: {:?}::{:?} (Category: {:?} Reason: {:?})",
                        location, code, category, reason
                    );
                    if let Some(abort_msg) = message {
                        err_msg.push_str(" Message: ");
                        err_msg.push_str(&abort_msg);
                    }
                    speculative_error!(log_context, err_msg.clone());
                    return Err(VMStatus::Error {
                        status_code: StatusCode::UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION,
                        sub_status: None,
                        message: Some(err_msg),
                    });
                },
            };
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L228-231)
```text
            assert!(
                txn_sequence_number < (1u64 << 63),
                error::out_of_range(PROLOGUE_ESEQUENCE_NUMBER_TOO_BIG)
            );
```

**File:** third_party/move/move-core/types/src/vm_status.rs (L292-314)
```rust
                match code.status_type() {
                    // Any unknown error should be discarded
                    StatusType::Unknown => Err(code),
                    // Any error that is a validation status (i.e. an error arising from the prologue)
                    // causes the transaction to not be included.
                    StatusType::Validation => Err(code),
                    // If the VM encountered an invalid internal state, we should discard the transaction.
                    StatusType::InvariantViolation => Err(code),
                    // A transaction that publishes code that cannot be verified will be charged.
                    StatusType::Verification => Ok(KeptVMStatus::MiscellaneousError),
                    // If we are able to decode the`SignedTransaction`, but failed to decode
                    // `SingedTransaction.raw_transaction.payload` (i.e., the transaction script),
                    // there should be a charge made to that user's account for the gas fees related
                    // to decoding, running the prologue etc.
                    StatusType::Deserialization => Ok(KeptVMStatus::MiscellaneousError),
                    // Any error encountered during the execution of the transaction will charge gas.
                    StatusType::Execution => Ok(KeptVMStatus::ExecutionFailure {
                        location: AbortLocation::Script,
                        function: 0,
                        code_offset: 0,
                        message,
                    }),
                }
```

**File:** third_party/move/move-core/types/src/vm_status.rs (L980-1014)
```rust
    /// Return the status type for this status code
    pub fn status_type(self) -> StatusType {
        let major_status_number: u64 = self.into();
        if major_status_number >= VALIDATION_STATUS_MIN_CODE
            && major_status_number <= VALIDATION_STATUS_MAX_CODE
        {
            return StatusType::Validation;
        }

        if major_status_number >= VERIFICATION_STATUS_MIN_CODE
            && major_status_number <= VERIFICATION_STATUS_MAX_CODE
        {
            return StatusType::Verification;
        }

        if major_status_number >= INVARIANT_VIOLATION_STATUS_MIN_CODE
            && major_status_number <= INVARIANT_VIOLATION_STATUS_MAX_CODE
        {
            return StatusType::InvariantViolation;
        }

        if major_status_number >= DESERIALIZATION_STATUS_MIN_CODE
            && major_status_number <= DESERIALIZATION_STATUS_MAX_CODE
        {
            return StatusType::Deserialization;
        }

        if major_status_number >= EXECUTION_STATUS_MIN_CODE
            && major_status_number <= EXECUTION_STATUS_MAX_CODE
        {
            return StatusType::Execution;
        }

        StatusType::Unknown
    }
```

**File:** types/src/transaction/mod.rs (L1620-1648)
```rust
    pub fn from_vm_status(
        vm_status: VMStatus,
        features: &Features,
        memory_limit_exceeded_as_miscellaneous_error: bool,
    ) -> Self {
        let status_code = vm_status.status_code();
        // TODO: keep_or_discard logic should be deprecated from Move repo and refactored into here.
        match vm_status.keep_or_discard(
            features.is_enabled(FeatureFlag::ENABLE_FUNCTION_VALUES),
            memory_limit_exceeded_as_miscellaneous_error,
            features.is_enabled(FeatureFlag::VM_BINARY_FORMAT_V10),
        ) {
            Ok(recorded) => match recorded {
                // TODO(bowu):status code should be removed from transaction status
                KeptVMStatus::MiscellaneousError => {
                    Self::Keep(ExecutionStatus::MiscellaneousError(Some(status_code)))
                },
                _ => Self::Keep(recorded.into()),
            },
            Err(code) => {
                if code.status_type() == StatusType::InvariantViolation
                    && features.is_enabled(FeatureFlag::CHARGE_INVARIANT_VIOLATION)
                {
                    Self::Keep(ExecutionStatus::MiscellaneousError(Some(code)))
                } else {
                    Self::Discard(code)
                }
            },
        }
```

**File:** aptos-move/framework/src/built_package.rs (L527-531)
```rust
        let upgrade_policy = if let Some(val) = custom_props.get(UPGRADE_POLICY_CUSTOM_FIELD) {
            str::parse::<UpgradePolicy>(val.as_ref())?
        } else {
            UpgradePolicy::compat()
        };
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L230-252)
```text
    public fun freeze_code_object(publisher: &signer, code_object: Object<PackageRegistry>) acquires PackageRegistry {
        check_code_publishing_permission(publisher);
        let code_object_addr = object::object_address(&code_object);
        assert!(exists<PackageRegistry>(code_object_addr), error::not_found(ECODE_OBJECT_DOES_NOT_EXIST));
        assert!(
            object::is_owner(code_object, signer::address_of(publisher)),
            error::permission_denied(ENOT_PACKAGE_OWNER)
        );

        let registry = borrow_global_mut<PackageRegistry>(code_object_addr);
        vector::for_each_mut(&mut registry.packages, |pack| {
            let package: &mut PackageMetadata = pack;
            package.upgrade_policy = upgrade_policy_immutable();
        });

        // We unfortunately have to make a copy of each package to avoid borrow checker issues as check_dependencies
        // needs to borrow PackageRegistry from the dependency packages.
        // This would increase the amount of gas used, but this is a rare operation and it's rare to have many packages
        // in a single code object.
        vector::for_each(registry.packages, |pack| {
            check_dependencies(code_object_addr, &pack);
        });
    }
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L256-259)
```text
    public entry fun publish_package_txn(owner: &signer, metadata_serialized: vector<u8>, code: vector<vector<u8>>)
    acquires PackageRegistry {
        publish_package(owner, util::from_bytes<PackageMetadata>(metadata_serialized), code)
    }
```
