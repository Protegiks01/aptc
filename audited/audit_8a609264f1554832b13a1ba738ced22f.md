# Audit Report

## Title
Denial of Service via Unbounded ValidatorVerifier Construction During VoteData Deserialization

## Summary
VoteData deserialization lacks dedicated fuzzing with malformed inputs. This testing gap has revealed a resource exhaustion vulnerability where an attacker can send malicious VoteMsg messages containing arbitrarily large ValidatorVerifier structures, causing excessive memory allocation and CPU consumption during deserialization, potentially degrading validator node performance.

## Finding Description

The VoteData struct is deserialized as part of consensus network messages without adequate bounds checking on nested structure sizes. [1](#0-0) 

The attack path follows:
1. Attacker crafts a VoteMsg containing VoteData with BlockInfo that includes `next_epoch_state: Some(EpochState)`
2. The EpochState contains `Arc<ValidatorVerifier>` which has a custom deserializer [2](#0-1) 
3. ValidatorVerifier deserializes `validator_infos: Vec<ValidatorConsensusInfo>` without bounds checking [3](#0-2) 
4. The deserializer calls `ValidatorVerifier::new()` which constructs expensive data structures [4](#0-3) 
5. `build_index()` creates a HashMap with potentially hundreds of thousands of entries [5](#0-4) 

BCS deserialization uses a recursion limit of 64 for consensus protocols [6](#0-5) , but this only limits recursion depth, not vector lengths. With MAX_APPLICATION_MESSAGE_SIZE of ~61.9 MiB [7](#0-6) , an attacker can send a ValidatorVerifier with approximately 450,000 validators (each ValidatorConsensusInfo is ~136 bytes).

The deserialization and expensive construction happens BEFORE validation in the message processing pipeline. The network layer deserializes the message using BCS [8](#0-7) , and only after successful deserialization (which triggers the expensive ValidatorVerifier construction) does the consensus layer validate the message via `Vote::verify()` [9](#0-8) .

**Critical Testing Gap**: No fuzzing targets exist for VoteData/Vote/VoteMsg deserialization with arbitrary bytes. The fuzzer infrastructure only includes property-based tests that generate structurally valid instances [10](#0-9) , not raw BCS deserialization fuzzing like the pattern used for SignedTransaction [11](#0-10) .

## Impact Explanation

**High Severity**: This qualifies as "Validator node slowdowns" under the bug bounty program. An attacker can:
- Send multiple malformed VoteMsg messages to validator nodes
- Each message triggers allocation of hundreds of megabytes and expensive HashMap construction
- Sustained attacks could degrade consensus performance or trigger OOM crashes
- No authentication required - any network peer can send these messages
- Affects consensus liveness if sufficient validators are impacted simultaneously

While on-chain stake.move enforces MAX_VALIDATOR_SET_SIZE of 65,536 [12](#0-11) , this limit is not enforced during network message deserialization, allowing attackers to bypass it with malformed messages.

## Likelihood Explanation

**High Likelihood**:
- Simple to exploit: Craft BCS-serialized VoteMsg with large validator_infos vector
- No special privileges required: Any network peer can send consensus messages
- Deserialization happens before authentication/validation
- No existing bounds checks on vector sizes during deserialization
- Testing gap means this vulnerability class is undiscovered

## Recommendation

1. **Add deserialization fuzzing**: Create `fuzz_targets/vote_data_deserialize.rs` and `fuzz_targets/vote_deserialize.rs` following the pattern:
```rust
// Similar to signed_transaction_deserialize.rs
fuzz_target!(|fuzz_data: FuzzData| {
    let _ = bcs::from_bytes::<VoteData>(&fuzz_data.data);
});
```

2. **Add bounds checking**: Enforce MAX_VALIDATOR_SET_SIZE during ValidatorVerifier deserialization:
```rust
// In types/src/validator_verifier.rs, modify deserialize:
impl<'de> Deserialize<'de> for ValidatorVerifier {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        // ... existing code ...
        
        // Add bounds check
        const MAX_VALIDATOR_SET_SIZE: usize = 65536;
        if validator_infos.len() > MAX_VALIDATOR_SET_SIZE {
            return Err(serde::de::Error::custom(
                format!("validator_infos size {} exceeds maximum {}", 
                    validator_infos.len(), MAX_VALIDATOR_SET_SIZE)
            ));
        }
        
        Ok(ValidatorVerifier::new(validator_infos))
    }
}
```

3. **Add early size validation**: Check message payload sizes before full deserialization in the network layer.

## Proof of Concept

```rust
// testsuite/fuzzer/fuzz/fuzz_targets/vote_data_deserialize.rs
#![no_main]
use aptos_consensus_types::vote_data::VoteData;
use arbitrary::Arbitrary;
use libfuzzer_sys::fuzz_target;

#[derive(Arbitrary, Debug)]
struct FuzzData {
    data: Vec<u8>,
}

fuzz_target!(|fuzz_data: FuzzData| {
    // This will reveal resource exhaustion issues
    let _ = bcs::from_bytes::<VoteData>(&fuzz_data.data);
});

// Add to testsuite/fuzzer/fuzz/Cargo.toml:
// [[bin]]
// name = "vote_data_deserialize"
// path = "fuzz_targets/vote_data_deserialize.rs"
// test = false
// doc = false
// required-features = ["consensus"]
```

Run with: `cargo fuzz run vote_data_deserialize`

This fuzzer would discover the unbounded validator_infos allocation issue and other malformed input handling problems.

## Notes

The vulnerability stems from a fundamental testing gap: consensus types use BCS deserialization from untrusted network peers but lack dedicated fuzzing with malicious inputs. The existing property-based tests only validate business logic with structurally valid data, missing entire classes of deserialization vulnerabilities. This finding demonstrates why the security question about fuzzing gaps is critical - the absence of fuzzing has left exploitable attack surfaces undiscovered.

### Citations

**File:** consensus/consensus-types/src/vote_data.rs (L10-16)
```rust
#[derive(Deserialize, Serialize, Clone, Debug, PartialEq, Eq, CryptoHasher, BCSCryptoHash)]
pub struct VoteData {
    /// Contains all the block information needed for voting for the proposed round.
    proposed: BlockInfo,
    /// Contains all the block information for the block the proposal is extending.
    parent: BlockInfo,
}
```

**File:** types/src/epoch_state.rs (L17-22)
```rust
#[derive(Clone, Deserialize, Eq, PartialEq, Serialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct EpochState {
    pub epoch: u64,
    pub verifier: Arc<ValidatorVerifier>,
}
```

**File:** types/src/validator_verifier.rs (L164-179)
```rust
impl<'de> Deserialize<'de> for ValidatorVerifier {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        #[derive(Deserialize)]
        #[serde(rename = "ValidatorVerifier")]
        struct RawValidatorVerifier {
            validator_infos: Vec<ValidatorConsensusInfo>,
        }

        let RawValidatorVerifier { validator_infos } =
            RawValidatorVerifier::deserialize(deserializer)?;

        Ok(ValidatorVerifier::new(validator_infos))
    }
```

**File:** types/src/validator_verifier.rs (L183-202)
```rust
    /// Private constructor to calculate the in-memory index
    fn build_index(
        validator_infos: Vec<ValidatorConsensusInfo>,
        quorum_voting_power: u128,
        total_voting_power: u128,
    ) -> Self {
        let address_to_validator_index = validator_infos
            .iter()
            .enumerate()
            .map(|(index, info)| (info.address, index))
            .collect();
        Self {
            validator_infos,
            quorum_voting_power,
            total_voting_power,
            address_to_validator_index,
            pessimistic_verify_set: DashSet::new(),
            optimistic_sig_verification: false,
        }
    }
```

**File:** types/src/validator_verifier.rs (L206-214)
```rust
    pub fn new(validator_infos: Vec<ValidatorConsensusInfo>) -> Self {
        let total_voting_power = sum_voting_power(&validator_infos);
        let quorum_voting_power = if validator_infos.is_empty() {
            0
        } else {
            total_voting_power * 2 / 3 + 1
        };
        Self::build_index(validator_infos, quorum_voting_power, total_voting_power)
    }
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L38-40)
```rust
pub const USER_INPUT_RECURSION_LIMIT: usize = 32;
pub const RECURSION_LIMIT: usize = 64;

```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L226-252)
```rust
    pub fn from_bytes<T: DeserializeOwned>(&self, bytes: &[u8]) -> anyhow::Result<T> {
        // Start the deserialization timer
        let deserialization_timer = start_serialization_timer(*self, DESERIALIZATION_LABEL);

        // Deserialize the message
        let result = match self.encoding() {
            Encoding::Bcs(limit) => self.bcs_decode(bytes, limit),
            Encoding::CompressedBcs(limit) => {
                let compression_client = self.get_compression_client();
                let raw_bytes = aptos_compression::decompress(
                    &bytes.to_vec(),
                    compression_client,
                    MAX_APPLICATION_MESSAGE_SIZE,
                )
                .map_err(|e| anyhow! {"{:?}", e})?;
                self.bcs_decode(&raw_bytes, limit)
            },
            Encoding::Json => serde_json::from_slice(bytes).map_err(|e| anyhow!("{:?}", e)),
        };

        // Only record the duration if deserialization was successful
        if result.is_ok() {
            deserialization_timer.observe_duration();
        }

        result
    }
```

**File:** config/src/config/network_config.rs (L47-50)
```rust
pub const MAX_APPLICATION_MESSAGE_SIZE: usize =
    (MAX_MESSAGE_SIZE - MAX_MESSAGE_METADATA_SIZE) - MESSAGE_PADDING_SIZE; /* The message size that applications should check against */
pub const MAX_FRAME_SIZE: usize = 4 * 1024 * 1024; /* 4 MiB large messages will be chunked into multiple frames and streamed */
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```

**File:** consensus/consensus-types/src/vote.rs (L151-175)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        // TODO(ibalajiarun): Ensure timeout is None if RoundTimeoutMsg is enabled.

        ensure!(
            self.ledger_info.consensus_data_hash() == self.vote_data.hash(),
            "Vote's hash mismatch with LedgerInfo"
        );
        validator
            .optimistic_verify(self.author(), &self.ledger_info, &self.signature)
            .context("Failed to verify Vote")?;
        if let Some((timeout, signature)) = &self.two_chain_timeout {
            ensure!(
                (timeout.epoch(), timeout.round())
                    == (self.epoch(), self.vote_data.proposed().round()),
                "2-chain timeout has different (epoch, round) than Vote"
            );
            timeout.verify(validator)?;
            validator
                .verify(self.author(), &timeout.signing_format(), signature)
                .context("Failed to verify 2-chain timeout signature")?;
        }
        // Let us verify the vote data as well
        self.vote_data().verify()?;
        Ok(())
    }
```

**File:** consensus/safety-rules/src/fuzzing_utils.rs (L217-239)
```rust
prop_compose! {
    pub fn arb_quorum_cert(
    )(
        proposed_block_info_gen in any::<BlockInfoGen>(),
        parent_block_info_gen in any::<BlockInfoGen>(),
        mut proposed_account_info_universe in
            any_with::<AccountInfoUniverse>(NUM_UNIVERSE_ACCOUNTS),
        mut parent_account_info_universe in any_with::<AccountInfoUniverse>(NUM_UNIVERSE_ACCOUNTS),
        proposed_block_size in 1..MAX_BLOCK_SIZE,
        parent_block_size in 1..MAX_BLOCK_SIZE,
        signed_ledger_info in any::<LedgerInfoWithSignatures>(),
    ) -> QuorumCert {
        let proposed_block_info = proposed_block_info_gen.materialize(
            &mut proposed_account_info_universe,
            proposed_block_size
        );
        let parent_block_info = parent_block_info_gen.materialize(
            &mut parent_account_info_universe,
            parent_block_size
        );
        let vote_data = VoteData::new(proposed_block_info, parent_block_info);
        QuorumCert::new(vote_data, signed_ledger_info)
    }
```

**File:** testsuite/fuzzer/fuzz/fuzz_targets/signed_transaction_deserialize.rs (L14-16)
```rust
fuzz_target!(|fuzz_data: FuzzData| {
    let _ = bcs::from_bytes::<SignedTransaction>(&fuzz_data.data);
});
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L100-100)
```text
    const MAX_VALIDATOR_SET_SIZE: u64 = 65536;
```
