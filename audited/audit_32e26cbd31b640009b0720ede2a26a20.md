# Audit Report

## Title
Missing Cross-Field Validation in AggregatorChangeSet Allows Silent Overwrite of Delayed Field Exchange Metadata

## Summary
The `into_change_set()` function returns an `AggregatorChangeSet` with four fields, but lacks validation to ensure consistency between `aggregator_v1_changes` and `reads_needing_exchange`. This allows duplicate StateKeys across these fields, leading to silent overwrites during write set materialization where aggregator v1 writes can overwrite `InPlaceDelayedFieldChange` operations, potentially causing incorrect delayed field materialization and state inconsistencies.

## Finding Description

The `AggregatorChangeSet` structure contains four fields that track different types of state changes: [1](#0-0) 

In the `into_change_set()` function, the `reads_needing_exchange` and `group_reads_needing_exchange` fields are computed based solely on `delayed_field_changes` with an empty skip set: [2](#0-1) 

This computation does NOT consider `aggregator_v1_changes`, allowing the same StateKey to appear in both fields without validation.

During change set conversion in `convert_change_set()`, the filtering logic only checks against `resource_write_set`, not `aggregator_v1_write_set`: [3](#0-2) 

The filtered `reads_needing_exchange` entries are then merged into `resource_write_set` in `VMChangeSet::new_expanded()`: [4](#0-3) 

However, `aggregator_v1_write_set` is kept as a separate field: [5](#0-4) 

When finalizing the transaction output, both write sets are combined, with `aggregator_v1_write_set` extended AFTER `resource_write_set`: [6](#0-5) 

This means if a StateKey exists in both, the aggregator v1 write silently overwrites the `InPlaceDelayedFieldChange` entry from `reads_needing_exchange`, causing the delayed field exchange to be skipped for that resource.

**Attack Scenario:**
1. A table item StateKey is read during transaction execution and contains delayed fields → added to `reads_needing_exchange`
2. The same table item is written via aggregator v1 native functions → added to `aggregator_v1_changes`
3. The table item is not written via table operations, so it's not in `resource_write_set` 
4. The filter on line 508 doesn't catch the duplication
5. Both entries proceed: one as `InPlaceDelayedFieldChange` in resource_write_set, one as WriteOp in aggregator_v1_write_set
6. During materialization, the aggregator write overwrites the delayed field change operation
7. Delayed fields in that resource are not properly exchanged, leading to inconsistent state

## Impact Explanation

This vulnerability breaks the **Deterministic Execution** invariant (Critical Invariant #1). Different validators may compute different state roots if they handle this edge case differently, particularly during:

1. **Parallel vs Sequential Execution:** Block executor's parallel execution path may materialize writes differently than sequential execution
2. **Delayed Field Materialization:** The loss of `InPlaceDelayedFieldChange` metadata means delayed fields won't be properly materialized, potentially leading to:
   - Incorrect final values written to storage
   - Consensus divergence if validators disagree on final state
   - State corruption requiring manual intervention

This qualifies as **High Severity** per the Aptos bug bounty criteria:
- Significant protocol violations (incorrect state materialization)
- Potential validator node inconsistencies
- State inconsistencies requiring intervention (Medium severity baseline, elevated by consensus impact)

## Likelihood Explanation

**Likelihood: Medium**

While the code path exists, exploitation requires specific conditions:
1. A StateKey must be both a table item (aggregator v1) and contain delayed fields
2. The same StateKey must be read and written in a single transaction
3. Aggregator v1 operations must be used rather than direct table operations

The likelihood is reduced because:
- Aggregator v1 table items typically store primitive u128 values
- Delayed fields are usually embedded in resource structures, not raw table items
- The intersection of these two systems may be rare in practice

However, the likelihood increases due to:
- No validation exists to prevent this scenario
- Table items CAN contain complex data structures with delayed fields
- The silent overwrite behavior makes this difficult to detect

## Recommendation

**Fix 1: Add Validation in `into_change_set()`**

Pass the aggregator v1 changed StateKeys as the skip set to `get_reads_needing_exchange`:

```rust
// In into_change_set(), collect aggregator v1 state keys
let aggregator_v1_state_keys = aggregators
    .iter()
    .map(|(id, _)| id.0.clone())
    .chain(destroyed_aggregators.iter().map(|id| id.0.clone()))
    .collect::<HashSet<_>>();

// Pass them as the skip set
reads_needing_exchange: if delayed_write_set_ids.is_empty() {
    BTreeMap::new()
} else {
    self.delayed_field_resolver
        .get_reads_needing_exchange(&delayed_write_set_ids, &aggregator_v1_state_keys)?
},
```

**Fix 2: Add Validation in `convert_change_set()`**

Filter against both `resource_write_set` AND `aggregator_v1_write_set`:

```rust
let reads_needing_exchange = aggregator_change_set
    .reads_needing_exchange
    .into_iter()
    .filter(|(state_key, _)| {
        !resource_write_set.contains_key(state_key) 
        && !aggregator_v1_write_set.contains_key(state_key)
    })
    .collect();
```

**Fix 3: Add Duplicate Detection**

In `try_combine_into_storage_change_set()`, check for duplicates before extending:

```rust
for (key, write_op) in &aggregator_v1_write_set {
    if write_set_mut.contains(key) {
        return Err(code_invariant_error(format!(
            "Duplicate key {} found in both resource and aggregator v1 write sets",
            key
        )));
    }
}
write_set_mut.extend(aggregator_v1_write_set);
```

## Proof of Concept

Due to the complexity of setting up the full transaction execution environment with both aggregator v1 and delayed fields, a complete PoC requires significant infrastructure. However, the following demonstrates the vulnerable code path:

```rust
// Pseudo-code demonstrating the vulnerability
// This would need to be integrated into the actual test framework

#[test]
fn test_aggregator_changeset_duplicate_key_vulnerability() {
    // Setup: Create a table item StateKey that will be used for both
    let table_handle = TableHandle(AccountAddress::random());
    let key_bytes = b"test_key".to_vec();
    let state_key = StateKey::table_item(&table_handle, &key_bytes);
    
    // Step 1: Transaction reads the table item (which contains delayed fields)
    // This causes it to be added to reads_needing_exchange
    let delayed_field_id = DelayedFieldID::new(123);
    // ... setup to make state_key associated with delayed_field_id ...
    
    // Step 2: Transaction writes to the same StateKey via aggregator v1
    let mut aggregator_data = AggregatorData::default();
    aggregator_data.create_new_aggregator(
        AggregatorID(state_key.clone()), 
        1000
    );
    // ... modify aggregator value ...
    
    // Step 3: Call into_change_set()
    let context = NativeAggregatorContext::new(
        [0; 32],
        &resolver,
        true,
        &resolver
    );
    let change_set = context.into_change_set().unwrap();
    
    // Verify the bug: same StateKey in both fields
    assert!(change_set.aggregator_v1_changes.contains_key(&state_key));
    assert!(change_set.reads_needing_exchange.contains_key(&state_key));
    
    // This will cause silent overwrite during materialization
    // The InPlaceDelayedFieldChange will be lost
}
```

**Notes**

The vulnerability exists in the validation logic, not in the data structures themselves. The missing cross-field consistency check allows inconsistent data to flow through the system uncaught. While the exact exploitation scenario depends on whether table items can realistically contain delayed fields in practice, the lack of defensive validation represents a significant code quality and safety issue that could lead to consensus divergence or state corruption under the right conditions.

### Citations

**File:** aptos-move/framework/src/natives/aggregator_natives/context.rs (L38-44)
```rust
pub struct AggregatorChangeSet {
    pub aggregator_v1_changes: BTreeMap<StateKey, AggregatorChangeV1>,
    pub delayed_field_changes: BTreeMap<DelayedFieldID, DelayedChange<DelayedFieldID>>,
    pub reads_needing_exchange:
        BTreeMap<StateKey, (StateValueMetadata, u64, TriompheArc<MoveTypeLayout>)>,
    pub group_reads_needing_exchange: BTreeMap<StateKey, (StateValueMetadata, u64)>,
}
```

**File:** aptos-move/framework/src/natives/aggregator_natives/context.rs (L152-163)
```rust
            reads_needing_exchange: if delayed_write_set_ids.is_empty() {
                BTreeMap::new()
            } else {
                self.delayed_field_resolver
                    .get_reads_needing_exchange(&delayed_write_set_ids, &HashSet::new())?
            },
            group_reads_needing_exchange: if delayed_write_set_ids.is_empty() {
                BTreeMap::new()
            } else {
                self.delayed_field_resolver
                    .get_group_reads_needing_exchange(&delayed_write_set_ids, &HashSet::new())?
            },
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/mod.rs (L504-515)
```rust
        // We need to remove values that are already in the writes.
        let reads_needing_exchange = aggregator_change_set
            .reads_needing_exchange
            .into_iter()
            .filter(|(state_key, _)| !resource_write_set.contains_key(state_key))
            .collect();

        let group_reads_needing_change = aggregator_change_set
            .group_reads_needing_exchange
            .into_iter()
            .filter(|(state_key, _)| !resource_group_write_set.contains_key(state_key))
            .collect();
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L163-175)
```rust
                .chain(reads_needing_delayed_field_exchange.into_iter().map(
                    |(k, (metadata, size, layout))| {
                        Ok((
                            k,
                            AbstractResourceWriteOp::InPlaceDelayedFieldChange(
                                InPlaceDelayedFieldChangeOp {
                                    layout,
                                    materialized_size: size,
                                    metadata,
                                },
                            ),
                        ))
                    },
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L206-210)
```rust
            events,
            delayed_field_change_set,
            aggregator_v1_write_set,
            aggregator_v1_delta_set,
        ))
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L247-264)
```rust
        let mut write_set_mut = WriteSetMut::default();
        write_set_mut.extend(
            resource_write_set
                .into_iter()
                .map(|(k, v)| {
                    Ok((
                        k,
                        v.try_into_concrete_write().ok_or_else(|| {
                            code_invariant_error(
                                "Cannot convert from VMChangeSet with non-materialized write set",
                            )
                        })?,
                    ))
                })
                .collect::<Result<Vec<_>, _>>()?,
        );
        write_set_mut.extend(module_write_set.into_write_ops());
        write_set_mut.extend(aggregator_v1_write_set);
```
