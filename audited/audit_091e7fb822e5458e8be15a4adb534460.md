# Audit Report

## Title
Equivocation Detection Failure After Node Restart Due to Non-Persisted State in UnequivocalProposerElection

## Summary
The `is_valid_proposal()` function in `UnequivocalProposerElection` fails to prevent equivocation after node restarts because the `already_proposed` state is not persisted. This allows multiple proposals for the same round to be accepted and stored in the BlockStore, violating the stated contract and the unequivocal proposer assumption.

## Finding Description
The `UnequivocalProposerElection` wrapper maintains an in-memory `already_proposed: Mutex<(Round, HashValue)>` field to detect and reject duplicate proposals from the same proposer within a round. [1](#0-0) 

However, this state is always initialized to `(0, HashValue::zero())` in the constructor and is never restored from persistent storage after a node restart. [2](#0-1) 

The validation logic in `is_valid_proposal()` compares the incoming block's round against `already_proposed.0`. When a block's round is **greater** than the stored round, it accepts the proposal and updates the state. [3](#0-2) 

**Attack Scenario:**
1. A proposer sends block B1 for round R to the network
2. Node N receives B1, validates it via `is_valid_proposal()`, and stores it in the BlockStore
3. Node N crashes and restarts
4. On restart, `already_proposed` resets to `(0, HashValue::zero())`, but the node recovers B1 from persistent storage
5. The same proposer sends a different block B2 for the same round R
6. Node N receives B2, and `is_valid_proposal()` evaluates: `R > 0` (Greater), so it **accepts** B2
7. B2 is inserted into the BlockStore alongside B1

The BlockTree allows multiple blocks for the same round and only logs a warning. [4](#0-3) 

While SafetyRules prevents the node from voting on B2 (it already voted on B1, and this state IS persisted), both conflicting blocks remain in the BlockStore. [5](#0-4) 

## Impact Explanation
This is a **Medium severity** issue based on the following:

**State Inconsistency**: Different nodes will have inconsistent views of which blocks are valid for a given round after restarts, violating the stated contract that the system "rejects if the same leader proposes multiple blocks." [6](#0-5) 

**Defense-in-Depth Failure**: While consensus safety is ultimately protected by SafetyRules, the equivocation detection layer fails its intended purpose, reducing the defense-in-depth protection.

**Resource Exhaustion**: A malicious proposer who can trigger node restarts could force nodes to store multiple equivocating blocks for the same round, leading to unbounded storage growth.

**NOT Critical** because:
- Consensus safety is maintained by SafetyRules (nodes won't vote on equivocating blocks)
- No direct fund loss or chain split occurs
- The system can recover without a hard fork

## Likelihood Explanation
**Medium-High likelihood** for the following reasons:

1. **Natural Occurrence**: Node restarts happen regularly in production due to upgrades, crashes, or maintenance
2. **Validator Role Required**: The attacker must be a validator and proposer for a specific round (privileged but realistic for Byzantine fault analysis)
3. **No Special Coordination**: The attack doesn't require collusion with other validators
4. **Detectable but Not Prevented**: While the BlockTree logs warnings about multiple blocks per round, the system continues to accept and store them

## Recommendation
Persist the `already_proposed` state to disk and restore it on node startup, similar to how SafetyRules persists `last_vote`.

**Implementation approach:**
1. Add `already_proposed_round` and `already_proposed_id` fields to `RecoveryData`
2. When building `RecoveryData`, scan the recovered blocks to find the highest round with a proposal
3. Initialize `UnequivocalProposerElection` with this state instead of `(0, HashValue::zero())`
4. Alternatively, scan the BlockStore after recovery to populate `already_proposed` with the latest proposal per round

**Alternative (simpler):** After recovery, iterate through all blocks in the BlockStore and update `already_proposed` to reflect the highest round that has a block. This ensures consistency between persistent state and in-memory state.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
// Add to consensus/src/liveness/unequivocal_proposer_election_test.rs

#[test]
fn test_equivocation_after_restart() {
    let proposer_election = Arc::new(RotatingProposer::new(
        vec![Author::random()],
        1,
    ));
    
    // Create the unequivocal proposer election
    let mut unequivocal = UnequivocalProposerElection::new(proposer_election.clone());
    
    // Create first block for round 5
    let block1 = create_test_block(5, HashValue::random());
    assert!(unequivocal.is_valid_proposal(&block1), "First block should be accepted");
    
    // Simulate restart by creating new instance (state lost)
    let mut unequivocal_after_restart = UnequivocalProposerElection::new(proposer_election);
    
    // Create different block for same round 5
    let block2 = create_test_block(5, HashValue::random());
    
    // BUG: This should be rejected but is accepted because already_proposed was reset to (0, 0)
    assert!(unequivocal_after_restart.is_valid_proposal(&block2), 
            "VULNERABILITY: Equivocating block accepted after restart");
}
```

The test would require helper functions to create test blocks, but it demonstrates that after "restart" (creating a new instance), the second equivocating block for the same round is incorrectly accepted.

## Notes
While this vulnerability allows equivocating blocks to be stored in the BlockStore after node restarts, **consensus safety is not directly compromised** because SafetyRules maintains its own persisted state and prevents double-voting. This represents a failure of the defense-in-depth architecture where an early validation layer (equivocation detection) can be bypassed, forcing reliance on the core safety mechanism.

The issue becomes more severe if combined with other bugs in SafetyRules or if an attacker can exploit the storage overhead to cause resource exhaustion attacks.

### Citations

**File:** consensus/src/liveness/unequivocal_proposer_election.rs (L14-17)
```rust
// Wrapper around ProposerElection.
//
// Provides is_valid_proposal that remembers, and rejects if
// the same leader proposes multiple blocks.
```

**File:** consensus/src/liveness/unequivocal_proposer_election.rs (L18-21)
```rust
pub struct UnequivocalProposerElection {
    proposer_election: Arc<dyn ProposerElection + Send + Sync>,
    already_proposed: Mutex<(Round, HashValue)>,
}
```

**File:** consensus/src/liveness/unequivocal_proposer_election.rs (L35-40)
```rust
    pub fn new(proposer_election: Arc<dyn ProposerElection + Send + Sync>) -> Self {
        Self {
            proposer_election,
            already_proposed: Mutex::new((0, HashValue::zero())),
        }
    }
```

**File:** consensus/src/liveness/unequivocal_proposer_election.rs (L63-68)
```rust
            match block.round().cmp(&already_proposed.0) {
                Ordering::Greater => {
                    already_proposed.0 = block.round();
                    already_proposed.1 = block.id();
                    true
                },
```

**File:** consensus/src/block_storage/block_tree.rs (L326-335)
```rust
            // Note: the assumption is that we have/enforce unequivocal proposer election.
            if let Some(old_block_id) = self.round_to_ids.get(&arc_block.round()) {
                warn!(
                    "Multiple blocks received for round {}. Previous block id: {}",
                    arc_block.round(),
                    old_block_id
                );
            } else {
                self.round_to_ids.insert(arc_block.round(), block_id);
            }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L68-74)
```rust
        // if already voted on this round, send back the previous vote
        // note: this needs to happen after verifying the epoch as we just check the round here
        if let Some(vote) = safety_data.last_vote.clone() {
            if vote.vote_data().proposed().round() == proposed_block.round() {
                return Ok(vote);
            }
        }
```
