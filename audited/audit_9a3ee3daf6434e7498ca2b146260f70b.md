# Audit Report

## Title
Waypoint Validation Bypass in Epoch Ending Restore Allows Arbitrary Validator Set Installation

## Summary
The `Oneoff::EpochEnding` restore command passes `None` to `EpochEndingRestoreController::run()`, bypassing critical waypoint validation when no trusted waypoints are provided via CLI. This allows an attacker to craft malicious epoch ending backups containing arbitrary validator sets that will be accepted and saved to the database without cryptographic verification, potentially enabling chain forks.

## Finding Description

The vulnerability exists in the epoch ending restoration flow when the standalone `Oneoff::EpochEnding` command is used without providing trusted waypoints. [1](#0-0) 

The code passes `None` as the `previous_epoch_ending_ledger_info` parameter. This bypasses a critical validation step in the restoration process.

The validation logic in `preheat_impl` checks each ledger info as follows: [2](#0-1) 

For the **first** ledger info in any backup:
- `previous_li` is initialized to `None`
- If no trusted waypoint exists for that version (user didn't provide `--trust-waypoint`), lines 129-135 are skipped
- Lines 136-147 require `previous_li` to be `Some`, but it's `None` for the first epoch
- **Result: NO verification happens**

The second validation opportunity in `run_impl` is also skipped: [3](#0-2) 

Since `None` is passed, this entire validation block is skipped.

The only verification that occurs is internal consistency checking between the manifest and chunk data: [4](#0-3) 

However, both the manifest and chunks are provided by the attacker, so this provides no security against malicious backups.

Finally, these unverified ledger infos are saved directly to the database: [5](#0-4) 

**Attack Scenario:**

1. Attacker creates a malicious epoch ending backup with fabricated validator sets
2. Ensures internal consistency (manifest waypoints match ledger info waypoints)
3. Compromises backup storage or tricks an operator via social engineering
4. Operator runs: `db-tool restore oneoff epoch-ending --epoch-ending-manifest <malicious_backup> --target-db-dir <db_path>`
5. Operator doesn't provide `--trust-waypoint` flags (which are optional per the CLI)
6. The malicious epoch ending ledger infos are accepted without cryptographic verification
7. Fake validator sets are installed in the database

## Impact Explanation

**Critical Severity** - This vulnerability enables **Consensus/Safety violations** per the Aptos bug bounty program:

1. **Validator Set Manipulation**: Epoch ending ledger infos define the validator sets for each epoch. Installing fake validator sets breaks the fundamental trust model of the blockchain.

2. **Chain Fork Potential**: If multiple nodes restore from the same malicious backup, they will have identical fake validator sets. These nodes could form a separate network partition, believing they are following the legitimate chain while actually operating on a forked chain.

3. **Consensus Safety Violation**: The AptosBFT consensus protocol's safety guarantees depend on correct validator set transitions. Bypassing epoch validation violates the invariant that "AptosBFT must prevent chain splits under < 1/3 Byzantine validators."

4. **Breaks Trust Assumptions**: The restore tool is critical infrastructure for bootstrapping nodes and disaster recovery. Operators reasonably expect that restored data undergoes cryptographic verification. This vulnerability breaks that security guarantee.

The trusted waypoint mechanism exists specifically to prevent this attack, but it's optional in the CLI and the code silently accepts restoration without any trusted anchor point.

## Likelihood Explanation

**High Likelihood:**

1. **Operator Behavior**: The `--trust-waypoint` flag is optional. Documentation emphasizes it's for specific use cases (genesis confirmation, writeset validator changes), not as a mandatory security control. Operators may not realize it's critical for security.

2. **Attack Vectors**:
   - Compromised backup storage (S3, GCS, etc.)
   - Supply chain attacks on backup distribution
   - Social engineering operators to use "updated" or "emergency" backups
   - Insider threats with backup access

3. **No Warning**: The tool provides no warnings when restoring without trusted waypoints. It silently accepts the backup and completes successfully.

4. **Operational Scenarios**: 
   - Emergency recovery situations where operators might skip security steps
   - Automated restore scripts that don't include trusted waypoints
   - New node operators unfamiliar with the security implications

## Recommendation

**Mandatory Trusted Waypoint for First Epoch:**

Require at least one trusted waypoint that covers the first epoch in the backup. Add validation in `EpochEndingRestoreController::new()`:

```rust
pub fn new(
    opt: EpochEndingRestoreOpt,
    global_opt: GlobalRestoreOptions,
    storage: Arc<dyn BackupStorage>,
) -> Self {
    // Load manifest to check first epoch
    // (In actual implementation, this would need to be async or deferred)
    
    Self {
        storage,
        run_mode: global_opt.run_mode,
        manifest_handle: opt.manifest_handle,
        target_version: global_opt.target_version,
        trusted_waypoints: global_opt.trusted_waypoints,
    }
}
```

Add validation in `preheat_impl` before processing:

```rust
async fn preheat_impl(&self) -> Result<EpochEndingRestorePreheatData> {
    let manifest: EpochEndingBackup =
        self.storage.load_json_file(&self.manifest_handle).await?;
    manifest.verify()?;

    // NEW: Require trusted waypoint for first epoch
    let first_epoch_waypoint = manifest.waypoints.first()
        .ok_or_else(|| anyhow!("Manifest contains no waypoints"))?;
    
    ensure!(
        self.trusted_waypoints.contains_key(&first_epoch_waypoint.version()),
        "SECURITY: Restoring epoch ending data requires a trusted waypoint for \
         the first epoch (version {}). Use --trust-waypoint to specify it. \
         This prevents accepting malicious backups with fake validator sets.",
        first_epoch_waypoint.version()
    );

    // ... rest of existing code
}
```

**Alternative: Require previous_epoch_ending_ledger_info:**

If allowing restoration without trusted waypoints is intentional for some use cases, then require passing the previous epoch ending ledger info instead of `None`:

```rust
// In restore.rs
Oneoff::EpochEnding { storage, opt, global } => {
    // Get the previous epoch ending ledger info from the database if it exists
    let db = storage.init_storage().await?;
    let previous_li = get_latest_epoch_ending_ledger_info(&db)?;
    
    EpochEndingRestoreController::new(
        opt,
        global.try_into()?,
        db,
    )
    .run(previous_li.as_ref())  // Pass the actual previous LI, not None
    .await?;
}
```

## Proof of Concept

```rust
// Create a malicious epoch ending backup
use aptos_types::{
    ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
    block_info::BlockInfo,
    epoch_state::EpochState,
    validator_verifier::ValidatorVerifier,
    aggregate_signature::AggregateSignature,
};
use aptos_crypto::HashValue;

// Step 1: Create fake validator set for epoch 1
let fake_validators = ValidatorVerifier::new(vec![/* attacker's validators */]);
let fake_epoch_state = EpochState {
    epoch: 1,
    verifier: Arc::new(fake_validators),
};

// Step 2: Create fake epoch ending ledger info
let fake_ledger_info = LedgerInfo::new(
    BlockInfo::new(
        0,  // epoch 0
        0,  // round
        HashValue::zero(),
        HashValue::zero(),
        100,  // version
        0,  // timestamp
        Some(fake_epoch_state),  // Next epoch state with fake validators
    ),
    HashValue::zero(),
);

// Step 3: Create ledger info with empty signatures (will not be checked!)
let fake_li_with_sigs = LedgerInfoWithSignatures::new(
    fake_ledger_info,
    AggregateSignature::empty(),  // No valid signatures!
);

// Step 4: Create backup manifest with matching waypoint
let waypoint = Waypoint::new_epoch_boundary(&fake_li_with_sigs.ledger_info())?;
let manifest = EpochEndingBackup {
    first_epoch: 0,
    last_epoch: 0,
    waypoints: vec![waypoint],  // Matches the fake ledger info
    chunks: vec![/* chunk pointing to fake data */],
};

// Step 5: Operator runs restore WITHOUT --trust-waypoint
// Command: db-tool restore oneoff epoch-ending \
//            --epoch-ending-manifest malicious.manifest \
//            --target-db-dir /victim/db

// Result: Fake validator set is installed in database without any verification!
// The node will now use this fake validator set for epoch 1,
// potentially accepting blocks from attacker's validators.
```

**Reproduction Steps:**

1. Set up a test environment with the db-tool
2. Create a malicious epoch ending backup using the PoC code above
3. Run the restore command WITHOUT providing `--trust-waypoint`:
   ```bash
   db-tool restore oneoff epoch-ending \
     --epoch-ending-manifest malicious.manifest \
     --target-db-dir ./test_db
   ```
4. Observe that the restore completes successfully
5. Inspect the database to confirm fake epoch ending ledger infos were saved
6. Attempt to start a node with this database and observe it uses the fake validator set

## Notes

The vulnerability exists because:

1. The CLI makes `--trust-waypoint` optional without clearly documenting it's a critical security control
2. Passing `None` to `run()` bypasses the chain verification that would catch malicious backups
3. The `EpochHistoryRestoreController` (used by full restore coordinator) also has this issue for its first epoch, though subsequent epochs are properly chained

The `BootstrapDB` command uses `RestoreCoordinator` which internally calls `EpochHistoryRestoreController`, which has the same issue for the very first epoch in the chain. However, the one-off restore command is particularly dangerous because it's explicitly designed for standalone operation and operators may not realize the security implications of omitting trusted waypoints.

### Citations

**File:** storage/db-tool/src/restore.rs (L70-82)
```rust
                    Oneoff::EpochEnding {
                        storage,
                        opt,
                        global,
                    } => {
                        EpochEndingRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                        )
                        .run(None)
                        .await?;
                    },
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L119-128)
```rust
                let wp_manifest = waypoint_iter.next().ok_or_else(|| {
                    anyhow!("More LedgerInfo's found than waypoints in manifest.")
                })?;
                let wp_li = Waypoint::new_epoch_boundary(li.ledger_info())?;
                ensure!(
                    *wp_manifest == wp_li,
                    "Waypoints don't match. In manifest: {}, In chunk: {}",
                    wp_manifest,
                    wp_li,
                );
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L129-147)
```rust
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
                }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L218-240)
```rust
        if let Some(li) = previous_epoch_ending_ledger_info {
            ensure!(
                li.next_block_epoch() == preheat_data.manifest.first_epoch,
                "Previous epoch ending LedgerInfo is not the one expected. \
                My first epoch: {}, previous LedgerInfo next_block_epoch: {}",
                preheat_data.manifest.first_epoch,
                li.next_block_epoch(),
            );
            // Waypoint has been verified in preheat if it's trusted, otherwise try to check
            // the signatures.
            if self
                .controller
                .trusted_waypoints
                .get(&first_li.ledger_info().version())
                .is_none()
            {
                li.next_epoch_state()
                    .ok_or_else(|| {
                        anyhow!("Previous epoch ending LedgerInfo doesn't end an epoch")
                    })?
                    .verify(first_li)?;
            }
        }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L247-252)
```rust
        match self.controller.run_mode.as_ref() {
            RestoreRunMode::Restore { restore_handler } => {
                restore_handler.save_ledger_infos(&preheat_data.ledger_infos)?;

                EPOCH_ENDING_EPOCH.set(last_li.epoch() as i64);
                EPOCH_ENDING_VERSION.set(last_li.version() as i64);
```
