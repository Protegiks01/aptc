# Audit Report

## Title
Timestamp Poisoning Attack via Unbounded u64 Values in Noise Handshake Anti-Replay Mechanism

## Summary
The `upgrade_inbound()` function in `network/framework/src/noise/handshake.rs` validates that the anti-replay timestamp payload is exactly 8 bytes in length but fails to validate that the timestamp value itself is within a reasonable range. A malicious or compromised validator can send extremely large timestamp values (e.g., `u64::MAX`) that permanently poison the anti-replay timestamp cache, causing all future legitimate connection attempts from that validator to be rejected as replays, resulting in network partition. [1](#0-0) 

## Finding Description

The anti-replay timestamp mechanism is designed to prevent replay attacks in mutually authenticated connections between validators. When a validator initiates a handshake, it includes a timestamp payload that the receiving validator checks and stores.

The vulnerability occurs at line 433-441 where the code:
1. Checks that `payload.len() == AntiReplayTimestamps::TIMESTAMP_SIZE` (8 bytes)
2. Copies the payload bytes directly into a fixed-size array
3. Converts to `u64` using `u64::from_le_bytes()` which accepts ANY 8-byte value
4. **Fails to validate the timestamp is within reasonable bounds** [2](#0-1) 

The `is_replay()` function checks if the incoming timestamp is less than or equal to the stored timestamp for that peer. Once a large value like `u64::MAX` is stored, all future legitimate timestamps (which are milliseconds since Unix epoch, currently around 1.7 × 10¹²) will be rejected. [3](#0-2) 

The `store_timestamp()` function unconditionally stores any timestamp value without bounds checking.

**Attack Scenario:**
1. A compromised or malicious validator (Validator A) connects to multiple other validators (B, C, D)
2. Validator A sends handshakes with `timestamp = u64::MAX` (0xFFFFFFFFFFFFFFFF = 1.8 × 10¹⁹)
3. Each victim validator stores this poisoned timestamp for Validator A's public key
4. When legitimate Validator A later attempts to reconnect (after attacker releases control or node restart), the connection fails with `ServerReplayDetected` error
5. Validator A is effectively partitioned from validators B, C, D until they restart [4](#0-3) 

The attack persists because there is no garbage collection mechanism for the `AntiReplayTimestamps` HashMap. [5](#0-4) 

## Impact Explanation

This vulnerability enables a **Denial of Service attack against the validator network**, which fits the **Medium Severity** category:
- "State inconsistencies requiring intervention" - Victim validators must be restarted to clear poisoned timestamps
- "Validator node slowdowns" - Affected validators cannot reconnect, disrupting consensus participation

If a compromised validator executes this attack against a sufficient number of other validators, it could:
- Create network partitions affecting consensus liveness
- Force manual intervention (node restarts) to restore connectivity
- Disrupt the victim validator's ability to participate in consensus rounds
- Potentially trigger safety issues if partitioning affects quorum calculations

The attack is particularly severe because:
1. It persists until victim nodes restart (in-memory storage with no garbage collection)
2. A single compromised validator can affect multiple victims simultaneously
3. The poisoned state is not observable through normal monitoring (requires security logging)

## Likelihood Explanation

**Likelihood: Medium-Low**

The attack requires the attacker to:
1. Be a trusted validator (public key in the `trusted_peers` set) OR compromise a validator's private key
2. Successfully complete the Noise handshake authentication before sending the malicious timestamp
3. Have the capability to provide a custom `time_provider` function that returns `u64::MAX` [6](#0-5) 

While this requires privileged access (validator credentials), validator compromise is a realistic threat in blockchain networks. The question explicitly asks about "manipulated" payloads, indicating malicious behavior is in scope. The relatively simple exploitation once access is obtained increases the likelihood once the preconditions are met.

## Recommendation

Add timestamp bounds validation to reject timestamps that are too far in the future. This follows the pattern used elsewhere in the Aptos codebase for transaction expiration validation.

**Recommended fix for `upgrade_inbound()` function:**

```rust
// After line 441, add timestamp bounds checking:
let client_timestamp = u64::from_le_bytes(client_timestamp);

// Validate timestamp is not unreasonably far in the future
const MAX_TIMESTAMP_DRIFT_MS: u64 = 300_000; // 5 minutes
let now_ms = duration_since_epoch().as_millis() as u64;
if client_timestamp > now_ms + MAX_TIMESTAMP_DRIFT_MS {
    return Err(NoiseHandshakeError::InvalidTimestamp(
        remote_peer_short,
        client_timestamp,
    ));
}

// Also check timestamp is not in the distant past (optional)
const MAX_TIMESTAMP_AGE_MS: u64 = 300_000; // 5 minutes  
if client_timestamp + MAX_TIMESTAMP_AGE_MS < now_ms {
    return Err(NoiseHandshakeError::InvalidTimestamp(
        remote_peer_short,
        client_timestamp,
    ));
}
```

Additionally, add a new error variant to `NoiseHandshakeError`:
```rust
InvalidTimestamp(ShortHexStr, u64)
```

This ensures timestamps are within a reasonable window around the current time, preventing both future-dated attacks and stale replay attempts.

## Proof of Concept

The existing test framework can be extended to demonstrate this vulnerability: [7](#0-6) 

```rust
#[test]
fn test_timestamp_poisoning_with_u64_max() {
    // 1. Generate peers
    let ((client, _), (server, server_public_key)) = build_peers(true, None);
    let server_peer_id = server.network_context.peer_id();

    // 2. Perform handshake with u64::MAX timestamp (attacker sends poisoned timestamp)
    let (dialer_socket, listener_socket) = MemorySocket::new_pair();
    let (client_session, server_session) = block_on(join(
        client.upgrade_outbound(
            dialer_socket,
            server_peer_id,
            server_public_key,
            bad_timestamp(u64::MAX), // Malicious timestamp
        ),
        server.upgrade_inbound(listener_socket),
    ));

    // First connection succeeds (poisoned timestamp is stored)
    client_session.unwrap();
    server_session.unwrap();

    // 3. Attempt legitimate reconnection with current timestamp
    let (dialer_socket, listener_socket) = MemorySocket::new_pair();
    let (client_session, server_session) = block_on(join(
        client.upgrade_outbound(
            dialer_socket,
            server_peer_id,
            server_public_key,
            AntiReplayTimestamps::now, // Real current timestamp
        ),
        server.upgrade_inbound(listener_socket),
    ));

    // Legitimate connection FAILS - victim validator permanently locked out
    match server_session.unwrap_err() {
        NoiseHandshakeError::ServerReplayDetected(_, timestamp) => {
            // Any real timestamp will be much less than u64::MAX
            assert!(timestamp < u64::MAX);
            println!("DoS successful: legitimate timestamp {} rejected because u64::MAX was stored", timestamp);
        },
        err => panic!("Expected ServerReplayDetected, got {:?}", err),
    }
    
    client_session.unwrap_err();
}
```

This test demonstrates that after a malicious validator sends `u64::MAX` as a timestamp, all future legitimate connection attempts from that validator are permanently rejected until the victim node restarts.

## Notes

- This vulnerability only affects mutual authentication mode used in the validator network, not server-only authentication modes
- The attack is detectable through security logging as `ServerReplayDetected` errors are marked for security logging
- Similar timestamp validation patterns exist elsewhere in the Aptos codebase (e.g., transaction expiration validation in Move framework) but were not applied here
- The TODO comment in `consensus/src/dag/types.rs` at line 342 indicates timestamp validation is a known concern area in the codebase [8](#0-7)

### Citations

**File:** network/framework/src/noise/handshake.rs (L59-65)
```rust
    pub fn is_replay(&self, pubkey: x25519::PublicKey, timestamp: u64) -> bool {
        if let Some(last_timestamp) = self.0.get(&pubkey) {
            &timestamp <= last_timestamp
        } else {
            false
        }
    }
```

**File:** network/framework/src/noise/handshake.rs (L68-73)
```rust
    pub fn store_timestamp(&mut self, pubkey: x25519::PublicKey, timestamp: u64) {
        self.0
            .entry(pubkey)
            .and_modify(|last_timestamp| *last_timestamp = timestamp)
            .or_insert(timestamp);
    }
```

**File:** network/framework/src/noise/handshake.rs (L86-91)
```rust
        // Only use anti replay protection in mutual-auth scenarios. In theory,
        // this is applicable everywhere; however, we would need to spend some
        // time making this more sophisticated so it garbage collects old
        // timestamps and doesn't use unbounded space. These are not problems in
        // mutual-auth scenarios because we have a bounded set of trusted peers
        // that rarely changes.
```

**File:** network/framework/src/noise/handshake.rs (L183-193)
```rust
    pub async fn upgrade_outbound<TSocket, F>(
        &self,
        mut socket: TSocket,
        remote_peer_id: PeerId,
        remote_public_key: x25519::PublicKey,
        time_provider: F,
    ) -> Result<(NoiseStream<TSocket>, PeerRole), NoiseHandshakeError>
    where
        TSocket: AsyncRead + AsyncWrite + Debug + Unpin,
        F: Fn() -> [u8; AntiReplayTimestamps::TIMESTAMP_SIZE],
    {
```

**File:** network/framework/src/noise/handshake.rs (L433-441)
```rust
            if payload.len() != AntiReplayTimestamps::TIMESTAMP_SIZE {
                return Err(NoiseHandshakeError::MissingAntiReplayTimestamp(
                    remote_peer_short,
                ));
            }

            let mut client_timestamp = [0u8; AntiReplayTimestamps::TIMESTAMP_SIZE];
            client_timestamp.copy_from_slice(&payload);
            let client_timestamp = u64::from_le_bytes(client_timestamp);
```

**File:** network/framework/src/noise/handshake.rs (L445-450)
```rust
            if anti_replay_timestamps.is_replay(remote_public_key, client_timestamp) {
                return Err(NoiseHandshakeError::ServerReplayDetected(
                    remote_peer_short,
                    client_timestamp,
                ));
            }
```

**File:** network/framework/src/noise/handshake.rs (L625-628)
```rust
    fn bad_timestamp(value: u64) -> impl Fn() -> [u8; AntiReplayTimestamps::TIMESTAMP_SIZE] {
        move || value.to_le_bytes()
    }

```

**File:** consensus/src/dag/types.rs (L342-342)
```rust
        // TODO: validate timestamp
```
