# Audit Report

## Title
Denial-of-Service via Manipulated known_latest_version in Indexer Data Service Cache Initialization

## Summary
The `InMemoryCache::new()` function initializes the cache's `DataManager` with `known_latest_version + 1` as the starting `end_version` without validation. If `known_latest_version` is manipulated to be significantly higher than the actual blockchain state, the cache initializes with an incorrect version range that causes all client requests to be rejected as "too old", resulting in a complete denial-of-service for the indexer data service.

## Finding Description

The vulnerability exists in the initialization flow of the LiveDataService's in-memory cache: [1](#0-0) 

The `known_latest_version` value comes from the ConnectionManager, which receives it from GrpcManager heartbeat responses: [2](#0-1) 

The GrpcManager obtains `known_latest_version` from fullnode info without validation: [3](#0-2) 

When the DataManager is initialized, it sets:
- `end_version = known_latest_version + 1`
- `start_version = end_version - num_slots` [4](#0-3) 

**Attack Scenario:**

1. Attacker operates a malicious fullnode that reports `known_latest_version = 1,000,000` when the actual blockchain is at version 1,000
2. GrpcManager's MetadataManager accepts this value via `update_known_latest_version()` (using `fetch_max`, so higher values always win)
3. LiveDataService initializes with this inflated value
4. DataManager is created with:
   - `end_version = 1,000,001`
   - `start_version = 1,000,001 - 1,000 (num_slots) = 999,001`
5. The cache now claims to serve versions [999,001, 1,000,001)
6. When clients request legitimate transactions (e.g., version 500), the cache checks: [5](#0-4) 

7. Since `500 < 999,001`, the request is rejected as "too old"
8. All client requests for actual blockchain data are rejected: [6](#0-5) 

This breaks the availability guarantee of the indexer service, causing a complete denial-of-service.

## Impact Explanation

This vulnerability meets **Medium Severity** criteria:
- **State inconsistencies requiring intervention**: The cache initializes with incorrect state that doesn't match actual blockchain data
- **API crashes/unavailability**: All client requests are rejected, making the indexer service effectively unavailable
- **Service disruption**: Legitimate users cannot query transaction data

While this doesn't affect blockchain consensus or validator operations (the indexer is a read-only service), it renders the data service unusable for all clients until manual intervention or service restart with corrected values.

## Likelihood Explanation

**Likelihood: Medium-High**

The attack requires:
1. Attacker controls a fullnode connected to the GrpcManager, OR
2. Attacker can inject malicious heartbeat responses (network-level attack)

Since the GrpcManager accepts connections from multiple fullnodes and uses `fetch_max` to update `known_latest_version`, a single malicious fullnode reporting an inflated value will corrupt the state. No validation or sanity checking is performed on the reported version.

The `update_known_latest_version()` implementation makes the system vulnerable: [7](#0-6) 

Using `fetch_max` means a malicious fullnode can always force its inflated value to be accepted, overriding legitimate fullnodes reporting correct values.

## Recommendation

Implement validation and bounds checking for `known_latest_version`:

1. **Add sanity checking in MetadataManager**: Reject version updates that are unreasonably far ahead of the current value (e.g., more than 1 million versions):

```rust
fn update_known_latest_version(&self, version: u64) {
    let current = self.known_latest_version.load(Ordering::SeqCst);
    // Reject suspiciously large jumps (more than 1M versions)
    if version > current + 1_000_000 {
        warn!("Rejecting suspicious known_latest_version update: {} -> {}", current, version);
        return;
    }
    self.known_latest_version.fetch_max(version, Ordering::SeqCst);
    KNOWN_LATEST_VERSION.set(version as i64);
}
```

2. **Add consensus-based version validation**: Require multiple fullnodes to report similar values before accepting large increases:

```rust
// Track recent reports from different fullnodes
// Only update if majority of fullnodes report similar values (within threshold)
```

3. **Validate at cache initialization**: Check that `known_latest_version` is reasonable before creating the cache:

```rust
pub fn new(
    connection_manager: Arc<ConnectionManager>,
    known_latest_version: u64,
    num_slots: usize,
    size_limit_bytes: usize,
) -> Self {
    // Validate known_latest_version isn't absurdly high
    if known_latest_version > 1_000_000_000 {
        warn!("Suspicious known_latest_version: {}, capping to 0", known_latest_version);
        known_latest_version = 0; // Fall back to safe default
    }
    
    let data_manager = Arc::new(RwLock::new(DataManager::new(
        known_latest_version + 1,
        num_slots,
        size_limit_bytes,
    )));
    // ... rest of implementation
}
```

## Proof of Concept

**Rust Reproduction Steps:**

1. Set up a malicious fullnode that sends inflated `known_latest_version` in heartbeat responses
2. Configure GrpcManager to connect to this malicious fullnode
3. Observe that `MetadataManager.known_latest_version` gets updated to the inflated value
4. Create a new `LiveDataService` that reads this inflated value
5. Attempt to request legitimate transactions from the data service
6. Verify that all requests are rejected with "Requested data is too old" error

**Minimal test case:**

```rust
#[tokio::test]
async fn test_dos_via_inflated_known_latest_version() {
    // Simulate actual blockchain at version 1000
    let actual_blockchain_version = 1000u64;
    
    // Attacker reports inflated version
    let malicious_known_latest_version = 1_000_000u64;
    
    // Create cache with inflated version
    let num_slots = 1000;
    let cache = InMemoryCache::new(
        connection_manager,
        malicious_known_latest_version,
        num_slots,
        10_000_000,
    );
    
    // Calculate expected start_version
    let expected_start = malicious_known_latest_version + 1 - num_slots as u64;
    // expected_start = 999_001
    
    // Try to request legitimate transaction
    let result = cache.get_data(500, 501, 100, 1000000, &None).await;
    
    // Request should be rejected as "too old" (500 < 999_001)
    assert!(result.is_none(), "Expected None for 'too old' data");
    
    // All legitimate requests below 999_001 will be rejected
    // This is a complete DoS of the indexer service
}
```

## Notes

This vulnerability specifically affects the **indexer-grpc data service**, which is a read-only query service for blockchain data. It does NOT affect:
- Blockchain consensus
- Validator operations
- Transaction processing
- Fund security

However, it completely breaks the availability of the indexer service, preventing legitimate users from querying transaction history. The attack is feasible because the system trusts fullnode-reported versions without validation and uses `fetch_max` semantics that allow a single malicious fullnode to corrupt the state.

The issue is exacerbated by the lack of fallback mechanisms - once the cache is initialized with incorrect values, there's no self-correction until service restart.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/in_memory_cache.rs (L22-38)
```rust
    pub(super) fn new(
        connection_manager: Arc<ConnectionManager>,
        known_latest_version: u64,
        num_slots: usize,
        size_limit_bytes: usize,
    ) -> Self {
        let data_manager = Arc::new(RwLock::new(DataManager::new(
            known_latest_version + 1,
            num_slots,
            size_limit_bytes,
        )));
        let fetch_manager = Arc::new(FetchManager::new(data_manager.clone(), connection_manager));
        Self {
            data_manager,
            fetch_manager,
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/in_memory_cache.rs (L68-71)
```rust
            trace!("Getting data from cache, requested_version: {starting_version}, oldest available version: {}.", data_manager.start_version);
            if starting_version < data_manager.start_version {
                return None;
            }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/connection_manager.rs (L185-188)
```rust
    pub(crate) fn update_known_latest_version(&self, version: u64) {
        self.known_latest_version
            .fetch_max(version, Ordering::SeqCst);
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L405-409)
```rust
    fn update_known_latest_version(&self, version: u64) {
        self.known_latest_version
            .fetch_max(version, Ordering::SeqCst);
        KNOWN_LATEST_VERSION.set(version as i64);
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L533-550)
```rust
    fn handle_fullnode_info(&self, address: GrpcAddress, info: FullnodeInfo) -> Result<()> {
        let mut entry = self
            .fullnodes
            .entry(address.clone())
            .or_insert(Fullnode::new(address.clone()));
        entry.value_mut().recent_states.push_back(info);
        if let Some(known_latest_version) = info.known_latest_version {
            trace!(
                "Received known_latest_version ({known_latest_version}) from fullnode {address}."
            );
            self.update_known_latest_version(known_latest_version);
        }
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/data_manager.rs (L27-38)
```rust
    pub(super) fn new(end_version: u64, num_slots: usize, size_limit_bytes: usize) -> Self {
        CACHE_SIZE_LIMIT_BYTES.set(size_limit_bytes as i64);
        Self {
            start_version: end_version.saturating_sub(num_slots as u64),
            end_version,
            data: vec![None; num_slots],
            num_slots,
            size_limit_bytes,
            eviction_target: size_limit_bytes,
            total_size: 0,
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/mod.rs (L225-233)
```rust
            } else {
                let err = Err(Status::not_found("Requested data is too old."));
                info!(stream_id = id, "Client error: {err:?}.");
                let _ = response_sender.send(err).await;
                COUNTER
                    .with_label_values(&["terminate_requested_data_too_old"])
                    .inc();
                break;
            }
```
