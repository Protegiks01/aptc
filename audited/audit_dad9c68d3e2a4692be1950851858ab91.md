# Audit Report

## Title
Missing Subgroup Checks on BLS Public Keys in CommitVote Signature Verification - Defense-in-Depth Violation

## Summary
The CommitVote signature verification path does not perform subgroup checks on BLS12-381 public keys, violating the documented security requirements of the underlying BLS cryptographic library and creating a single point of failure in the consensus security model.

## Finding Description

The Aptos consensus layer loads validator public keys from on-chain state and uses them for CommitVote signature verification without performing cryptographic subgroup checks, despite explicit requirements in the BLS library documentation.

**Violation of Cryptographic Library Requirements:**

The BLS12-381 library documentation explicitly states the security requirements: [1](#0-0) 

For normal (non-aggregated) signature verification, the library requires wrapping `PublicKey` objects using `Validatable<PublicKey>`. However, the CommitVote verification path uses raw `PublicKey` objects without this protection.

**Missing Subgroup Check in Signature Verification:**

When verifying CommitVote signatures, the code calls the BLS signature verification with `pk_validate=false`: [2](#0-1) 

The last parameter `false` disables public key validation/subgroup checking, with a warning comment that assumes the caller has already verified the public key.

**No Subgroup Check When Loading Public Keys:**

Public keys are loaded from on-chain state without subgroup verification: [3](#0-2) 

The `PublicKey::try_from()` method explicitly does NOT perform subgroup checks: [4](#0-3) 

**Security Model Assumption:**

While on-chain validator registration does verify proof-of-possession (PoP) which includes subgroup checks: [5](#0-4) 

The consensus layer assumes this invariant holds without re-verification, creating a single point of failure.

## Impact Explanation

**Defense-in-Depth Violation:** This issue violates defense-in-depth security principles. If ANY of the following occur, invalid public keys could be used in consensus without detection:

1. Bug in on-chain PoP verification logic
2. State corruption vulnerability  
3. Deserialization inconsistency between Move and Rust
4. Privileged operation bypassing PoP checks

With invalid (non-prime-order-subgroup) BLS public keys, pairing-based signature verification can be bypassed, potentially enabling:
- Forged CommitVotes
- Consensus safety violations
- Chain splits

This would constitute **Critical Severity** per Aptos bug bounty criteria (Consensus/Safety violations).

## Likelihood Explanation

**Low Direct Exploitability:** An attacker cannot directly exploit this issue without first compromising the on-chain PoP verification or finding a state manipulation vulnerability. All standard paths for validator key registration enforce PoP verification.

**High Impact if Exploited:** IF an attacker could inject an invalid public key (through any future vulnerability), the missing subgroup checks would allow immediate consensus compromise without additional exploitation.

## Recommendation

Implement defense-in-depth by adding subgroup checks when loading validator public keys from on-chain state:

```rust
impl TryFrom<ValidatorConsensusInfoMoveStruct> for ValidatorConsensusInfo {
    type Error = anyhow::Error;

    fn try_from(value: ValidatorConsensusInfoMoveStruct) -> Result<Self, Self::Error> {
        let ValidatorConsensusInfoMoveStruct {
            addr,
            pk_bytes,
            voting_power,
        } = value;
        
        // Deserialize the public key
        let public_key = bls12381_keys::PublicKey::try_from(pk_bytes.as_slice())?;
        
        // SECURITY: Perform subgroup check as defense-in-depth
        // Even though on-chain PoP verification should ensure validity,
        // re-verify to protect against state corruption or PoP bugs
        public_key.subgroup_check()
            .context("Public key failed subgroup check when loading from validator set")?;
        
        Ok(Self::new(addr, public_key, voting_power))
    }
}
```

Alternatively, use `Validatable<PublicKey>` wrapper as documented by the BLS library for normal signature verification.

## Proof of Concept

This vulnerability cannot be demonstrated with a standalone PoC as it requires first finding a way to bypass on-chain PoP verification. However, the code inspection clearly shows:

1. The BLS library's security requirements are violated
2. Subgroup checks are missing in the signature verification path  
3. No re-verification occurs when loading keys from state

The violation can be traced through:
- CommitVote::verify() → ValidatorVerifier::optimistic_verify() → Signature::verify_arbitrary_msg()
- Which calls blst with pk_validate=false
- Using public keys loaded without subgroup checks

**Notes**

While this issue violates documented cryptographic library requirements and defense-in-depth principles, it is **not directly exploitable** by an unprivileged attacker without first finding a separate vulnerability to bypass on-chain PoP verification. The Aptos security model correctly enforces PoP verification at the on-chain registration layer, but the consensus layer should re-verify as a defensive measure per the BLS library's documented security requirements.

This represents a **code quality issue** and **defense-in-depth gap** rather than an immediately exploitable vulnerability. However, it should be fixed to comply with cryptographic library requirements and provide layered security against potential future vulnerabilities in the on-chain verification path.

### Citations

**File:** crates/aptos-crypto/src/bls12381/mod.rs (L82-95)
```rust
//! # A note on subgroup checks
//!
//! This library was written so that users who know nothing about _small subgroup attacks_  [^LL97], [^BCM+15e]
//! need not worry about them, **as long as library users either**:
//!
//!  1. For normal (non-aggregated) signature verification, wrap `PublicKey` objects using
//!     `Validatable<PublicKey>`
//!
//!  2. For multisignature, aggregate signature and signature share verification, library users
//!     always verify a public key's proof-of-possession (PoP)** before aggregating it with other PKs
//!     and before verifying signature shares with it.
//!
//! Nonetheless, we still provide `subgroup_check` methods for the `PublicKey` and `Signature` structs,
//! in case manual verification of subgroup membership is ever needed.
```

**File:** crates/aptos-crypto/src/bls12381/bls12381_sigs.rs (L152-166)
```rust
    fn verify_arbitrary_msg(&self, message: &[u8], public_key: &PublicKey) -> Result<()> {
        let result = self.sig.verify(
            true,
            message,
            DST_BLS_SIG_IN_G2_WITH_POP,
            &[],
            &public_key.pubkey,
            false,
        );
        if result == BLST_ERROR::BLST_SUCCESS {
            Ok(())
        } else {
            Err(anyhow!("{:?}", result))
        }
    }
```

**File:** types/src/validator_verifier.rs (L115-127)
```rust
impl TryFrom<ValidatorConsensusInfoMoveStruct> for ValidatorConsensusInfo {
    type Error = anyhow::Error;

    fn try_from(value: ValidatorConsensusInfoMoveStruct) -> Result<Self, Self::Error> {
        let ValidatorConsensusInfoMoveStruct {
            addr,
            pk_bytes,
            voting_power,
        } = value;
        let public_key = bls12381_keys::PublicKey::try_from(pk_bytes.as_slice())?;
        Ok(Self::new(addr, public_key, voting_power))
    }
}
```

**File:** crates/aptos-crypto/src/bls12381/bls12381_keys.rs (L227-247)
```rust
impl TryFrom<&[u8]> for PublicKey {
    type Error = CryptoMaterialError;

    /// Deserializes a PublicKey from a sequence of bytes.
    ///
    /// WARNING: Does NOT subgroup-check the public key! Instead, the caller is responsible for
    /// verifying the public key's proof-of-possession (PoP) via `ProofOfPossession::verify`,
    /// which implicitly subgroup-checks the public key.
    ///
    /// NOTE: This function will only check that the PK is a point on the curve:
    ///  - `blst::min_pk::PublicKey::from_bytes(bytes)` calls `blst::min_pk::PublicKey::deserialize(bytes)`,
    ///    which calls `$pk_deser` in <https://github.com/supranational/blst/blob/711e1eec747772e8cae15d4a1885dd30a32048a4/bindings/rust/src/lib.rs#L734>,
    ///    which is mapped to `blst_p1_deserialize` in <https://github.com/supranational/blst/blob/711e1eec747772e8cae15d4a1885dd30a32048a4/bindings/rust/src/lib.rs#L1652>
    ///  - `blst_p1_deserialize` eventually calls `POINTonE1_Deserialize_BE`, which checks
    ///    the point is on the curve: <https://github.com/supranational/blst/blob/711e1eec747772e8cae15d4a1885dd30a32048a4/src/e1.c#L296>
    fn try_from(bytes: &[u8]) -> std::result::Result<Self, CryptoMaterialError> {
        Ok(Self {
            pubkey: blst::min_pk::PublicKey::from_bytes(bytes)
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
        })
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L926-931)
```text
        // Checks the public key has a valid proof-of-possession to prevent rogue-key attacks.
        let pubkey_from_pop = &bls12381::public_key_from_bytes_with_pop(
            new_consensus_pubkey,
            &proof_of_possession_from_bytes(proof_of_possession)
        );
        assert!(option::is_some(pubkey_from_pop), error::invalid_argument(EINVALID_PUBLIC_KEY));
```
