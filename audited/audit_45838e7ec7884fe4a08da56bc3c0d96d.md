# Audit Report

## Title
Missing Runtime Validation for Consensus Key Injection via overriding_identity_paths on Mainnet Validators

## Summary
While the smoke-test feature gate itself is properly enforced in production build configurations, there is a critical missing runtime validation that allows arbitrary consensus key injection through the `overriding_identity_paths` configuration field on mainnet validators, regardless of feature flags. This breaks the Consensus Safety invariant by enabling validator equivocation.

## Finding Description

The `InitialSafetyRulesConfig::FromFile` variant contains an `overriding_identity_paths` field that allows specifying additional identity blob paths containing consensus private keys. [1](#0-0) 

These paths are loaded at node startup and the consensus keys are injected into the safety rules storage: [2](#0-1) 

The field can be deserialized from YAML configuration files without any feature gate restriction: [3](#0-2) 

**Critical Gap:** The `SafetyRulesConfig::sanitize()` function validates several mainnet constraints but does NOT check if `overriding_identity_paths` is empty or unused: [4](#0-3) 

The sanitizer checks for in-memory backends, non-local services, and test configs, but completely ignores the `overriding_identity_paths` field.

**Regarding the smoke-test feature gate:** While the `overriding_identity_blob_paths_mut()` function is properly gated by `#[cfg(feature = "smoke-test")]` [5](#0-4) , production builds correctly prevent feature unification through isolated package builds [6](#0-5)  and explicit test exclusion in CI [7](#0-6) . The codebase also documents feature unification risks: [8](#0-7) 

However, the smoke-test feature gate is **irrelevant to the actual vulnerability** - an attacker with configuration file access can directly modify the YAML to inject consensus keys without needing the `_mut` function.

**Attack Vector:**
1. Attacker gains configuration file access (compromised admin, config management vulnerability, or insider threat)
2. Attacker creates malicious identity blob with different consensus key
3. Attacker adds malicious blob path to `overriding_identity_paths` in validator YAML config
4. Node restarts and loads malicious key into safety rules storage alongside legitimate key
5. Validator can now sign blocks with multiple keys, enabling equivocation attacks

## Impact Explanation

**Critical Severity** - This enables **Consensus Safety violations**, qualifying for the $1,000,000 bug bounty tier.

A validator with multiple consensus keys can sign conflicting blocks for the same round/height, causing:
- **Equivocation:** Breaking AptosBFT safety guarantees
- **Chain splits:** Different validators accepting different blocks
- **Consensus failures:** Violating the < 1/3 Byzantine fault tolerance assumption

This directly breaks Invariant #2: "Consensus Safety: AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine"

## Likelihood Explanation

**Likelihood: Medium-to-Low** due to required access privileges, but **Impact: Critical** when exploited.

**Requirements:**
- Attacker needs configuration file write access (compromised validator operator or config management system)
- OR ability to manipulate node configuration during deployment

**Mitigating factors:**
- Requires privileged access to validator infrastructure
- Mainnet validators typically have strict configuration management
- Would be detected through validator monitoring if keys mismatch on-chain registration

**Aggravating factors:**
- No runtime validation prevents this attack
- Silent failure mode - no alerts when multiple keys are loaded
- Legitimate use case (consensus key rotation) makes detection harder

## Recommendation

Add runtime validation in `SafetyRulesConfig::sanitize()` to reject non-empty `overriding_identity_paths` on mainnet:

```rust
// In SafetyRulesConfig::sanitize(), add after line 112:
if chain_id.is_mainnet() 
    && !matches!(
        node_config.consensus.safety_rules.initial_safety_rules_config,
        InitialSafetyRulesConfig::None
    )
{
    if let InitialSafetyRulesConfig::FromFile { overriding_identity_paths, .. } = 
        &node_config.consensus.safety_rules.initial_safety_rules_config 
    {
        if !overriding_identity_paths.is_empty() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Overriding identity paths are not allowed on mainnet validators! \
                 Consensus key rotation should be performed through on-chain governance.".to_string(),
            ));
        }
    }
}
```

Additionally, add monitoring/alerting when multiple consensus keys are loaded in safety rules storage to detect potential attacks.

## Proof of Concept

```rust
// Test demonstrating the missing validation
#[test]
fn test_sanitize_allows_overriding_identity_paths_on_mainnet() {
    use aptos_types::chain_id::ChainId;
    use std::path::PathBuf;
    
    // Create a mainnet validator config with overriding_identity_paths
    let node_config = NodeConfig {
        consensus: ConsensusConfig {
            safety_rules: SafetyRulesConfig {
                initial_safety_rules_config: InitialSafetyRulesConfig::FromFile {
                    identity_blob_path: PathBuf::from("/path/to/identity.yaml"),
                    overriding_identity_paths: vec![
                        PathBuf::from("/path/to/malicious_key1.yaml"),
                        PathBuf::from("/path/to/malicious_key2.yaml"),
                    ],
                    waypoint: WaypointConfig::FromFile(PathBuf::from("/path/to/waypoint.txt")),
                },
                ..Default::default()
            },
            ..Default::default()
        },
        ..Default::default()
    };

    // This should fail but currently passes - demonstrating the vulnerability
    let result = SafetyRulesConfig::sanitize(
        &node_config,
        NodeType::Validator,
        Some(ChainId::mainnet()),
    );
    
    // Currently this PASSES (vulnerability exists)
    assert!(result.is_ok()); 
    
    // After fix, this should FAIL with ConfigSanitizerFailed error
    // assert!(matches!(result, Err(Error::ConfigSanitizerFailed(_, _))));
}
```

**Notes:**
The smoke-test feature gate itself is properly enforced and production builds correctly prevent feature unification. However, the gate is irrelevant to the actual security vulnerability - the missing runtime validation for `overriding_identity_paths` on mainnet, which enables consensus key injection regardless of feature flags.

### Citations

**File:** config/src/config/safety_rules_config.rs (L71-117)
```rust
impl ConfigSanitizer for SafetyRulesConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let safety_rules_config = &node_config.consensus.safety_rules;

        // If the node is not a validator, there's nothing to be done
        if !node_type.is_validator() {
            return Ok(());
        }

        if let Some(chain_id) = chain_id {
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }

            // Verify that the safety rules service is set to local for optimal performance
            if chain_id.is_mainnet() && !safety_rules_config.service.is_local() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("The safety rules service should be set to local in mainnet for optimal performance! Given config: {:?}", &safety_rules_config.service)
                ));
            }

            // Verify that the safety rules test config is not enabled in mainnet
            if chain_id.is_mainnet() && safety_rules_config.test.is_some() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The safety rules test config should not be used in mainnet!".to_string(),
                ));
            }
        }

        Ok(())
    }
}
```

**File:** config/src/config/safety_rules_config.rs (L122-130)
```rust
pub enum InitialSafetyRulesConfig {
    FromFile {
        identity_blob_path: PathBuf,
        #[serde(skip_serializing_if = "Vec::is_empty", default)]
        overriding_identity_paths: Vec<PathBuf>,
        waypoint: WaypointConfig,
    },
    None,
}
```

**File:** config/src/config/safety_rules_config.rs (L189-200)
```rust
    #[cfg(feature = "smoke-test")]
    pub fn overriding_identity_blob_paths_mut(&mut self) -> &mut Vec<PathBuf> {
        match self {
            InitialSafetyRulesConfig::FromFile {
                overriding_identity_paths,
                ..
            } => overriding_identity_paths,
            InitialSafetyRulesConfig::None => {
                unreachable!()
            },
        }
    }
```

**File:** consensus/safety-rules/src/safety_rules_manager.rs (L79-99)
```rust
        // Ensuring all the overriding consensus keys are in the storage.
        let timer = Instant::now();
        for blob in config
            .initial_safety_rules_config
            .overriding_identity_blobs()
            .unwrap_or_default()
        {
            if let Some(sk) = blob.consensus_private_key {
                let pk_hex = hex::encode(PublicKey::from(&sk).to_bytes());
                let storage_key = format!("{}_{}", CONSENSUS_KEY, pk_hex);
                match storage.internal_store().set(storage_key.as_str(), sk) {
                    Ok(_) => {
                        info!("Setting {storage_key} succeeded.");
                    },
                    Err(e) => {
                        warn!("Setting {storage_key} failed with internal store set error: {e}");
                    },
                }
            }
        }
        info!("Overriding key work time: {:?}", timer.elapsed());
```

**File:** docker/builder/build-node.sh (L25-35)
```shellscript
# We have to do these separately because we need to avoid feature unification
# between aptos-node and other binaries
for PACKAGE in "${PACKAGES[@]}"; do
    # Build and overwrite the aptos-node binary with features if specified
    if [ -n "$FEATURES" ] && [ "$PACKAGE" = "aptos-node" ]; then
        echo "Building aptos-node with features ${FEATURES}"
        env "${BUILD_ENV[@]}" cargo build --profile=$PROFILE --features=$FEATURES -p $PACKAGE "$@"
    else 
        # Build aptos-node separately
        env "${BUILD_ENV[@]}" cargo build --locked --profile=$PROFILE -p $PACKAGE "$@"
    fi
```

**File:** .github/actions/rust-unit-tests/action.yaml (L38-39)
```yaml
          --workspace \
          --exclude smoke-test \
```

**File:** RUST_SECURE_CODING.md (L49-51)
```markdown
### Understanding Feature Unification

Be aware of Cargo's feature unification process. When multiple dependencies require the same crate with different feature flags, Cargo unifies these into a single configuration. This unification can inadvertently enable features that might not be desirable or secure for the project [[Rustbook: features unification]](https://doc.rust-lang.org/cargo/reference/features.html#feature-unification) [[Rustbook: feature resolver]](https://doc.rust-lang.org/cargo/reference/features.html#feature-resolver-version-2).
```
