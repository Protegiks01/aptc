# Audit Report

## Title
Epoch Transition Bypass via Round Gap Preventing Reconfiguration Block Commitment

## Summary
A critical vulnerability exists in the epoch-ending verification logic where an attacker can prevent epoch transitions by introducing a round gap after a reconfiguration block. The check at lines 541-544 validates the **committed** block info in the QuorumCert rather than the **certified** block info, allowing blocks to be proposed indefinitely in an "ended" epoch when the reconfiguration block remains uncommitted due to violated 2-chain commit rules. [1](#0-0) 

## Finding Description
The vulnerability stems from a fundamental mismatch between the epoch-ending check and the 2-chain commit protocol. The epoch-ending check examines `self.quorum_cert().ends_epoch()`, which delegates to checking if the QC's `signed_ledger_info` contains a `commit_info` BlockInfo with `next_epoch_state` set. [2](#0-1) 

However, the `commit_info` in the LedgerInfo represents the **committed** block according to the 2-chain rule, not the certified block. The 2-chain commit rule states that Block N-1 is committed when voting on Block N only if `round(N) = round(N-1) + 1`. [3](#0-2) 

**Attack Path:**

1. **Reconfiguration Execution**: Block N-1 at round R executes transactions that trigger reconfiguration (e.g., governance proposal changing validator set). Validators execute this block and populate `next_epoch_state` in the BlockInfo.

2. **Round Gap Creation**: After Block N-1 is certified via QC_N-1, an attacker (or natural timeout) causes the round to advance to R+2, skipping R+1. This can be achieved by withholding votes or proposals.

3. **Non-Committing Block Proposal**: Block N is proposed at round R+2 with QC_N-1. When validators vote on Block N, the commit rule evaluates: `round(N) = R+2`, `round(N-1) = R`, therefore `R+2 ≠ R+1`, so `commit_info = BlockInfo::empty()`.

4. **Empty Commit QC Formation**: QC_N is formed containing a LedgerInfo with empty `commit_info` (no `next_epoch_state`).

5. **Bypass Verification**: Block N+1 is proposed with QC_N. The check `!self.quorum_cert().ends_epoch()` examines the empty `commit_info` in QC_N, returns false, and Block N+1 passes validation.

6. **Continued Old Epoch Execution**: Subsequent blocks (N+1, N+2, ...) continue being proposed and executed in the old epoch. Block N-1 (the reconfiguration block) remains certified but **never committed**, preventing the epoch transition.

The reconfiguration suffix check at lines 483-488 only prevents payload on blocks immediately after a parent with reconfiguration, but Block N+1's parent (Block N) doesn't have `next_epoch_state`, so this check doesn't apply. [4](#0-3) 

The proposal generator includes the same flawed check at line 875, so honest proposers will also continue generating proposals after the round gap. [5](#0-4) 

## Impact Explanation
**Critical Severity** - This vulnerability breaks multiple critical invariants:

1. **Consensus Safety Violation**: The fundamental guarantee that epochs transition properly after reconfiguration is violated, breaking the consensus protocol's state machine.

2. **Governance Bypass**: On-chain governance proposals that trigger reconfiguration (validator set changes, protocol upgrades, configuration updates) never take effect, effectively disabling governance.

3. **Validator Set Manipulation**: If a compromised validator set needs to be replaced via governance, the attack prevents the replacement, keeping malicious validators in control indefinitely.

4. **Permanent Protocol Deadlock**: The reconfiguration block is certified but never committed, creating an inconsistent state where the on-chain state reflects the new configuration, but consensus continues using the old epoch state. This can lead to:
   - Permanent chain halt when validators eventually recognize the inconsistency
   - Chain fork if different validators handle the situation differently
   - State corruption requiring a hard fork to recover

5. **Non-Recoverable Without Hard Fork**: Recovery requires manual intervention and likely a hard fork since the protocol has no mechanism to commit a block that has been bypassed by a round gap.

This meets the **Critical** severity threshold ($1,000,000 bounty category) for "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation
**High Likelihood**:

1. **Natural Occurrence**: Round gaps occur naturally in BFT consensus due to network partitions, leader failures, or slow validators. No Byzantine behavior is required.

2. **Low Attack Complexity**: An attacker only needs to cause a timeout after a reconfiguration block, which can be achieved by:
   - Not voting on the next block (if attacker controls sufficient validators)
   - Network delays or partitions
   - Proposer withholding the next block

3. **No Special Privileges Required**: The attack works with the normal consensus flow - any proposer can propose the non-committing block, and honest validators will accept it.

4. **Persistent Effect**: Once triggered, the epoch never transitions without manual intervention, making this a persistent denial-of-service on governance and epoch transitions.

5. **Detection Difficulty**: Validators may not immediately detect the issue since all checks pass. The inconsistency only becomes apparent when comparing committed vs. certified blocks.

## Recommendation
The fix requires checking both the **committed** block and the **certified** block for epoch ending:

```rust
// In consensus/consensus-types/src/block.rs, modify verify_well_formed()
pub fn verify_well_formed(&self) -> anyhow::Result<()> {
    // ... existing checks ...
    
    // Check if committed block ends epoch
    ensure!(
        !self.quorum_cert().ends_epoch(),
        "Block cannot be proposed in an epoch that has ended (committed block)"
    );
    
    // NEW: Also check if certified block ends epoch
    // This prevents blocks after a reconfiguration block even if it's not yet committed
    ensure!(
        !self.quorum_cert().certified_block().has_reconfiguration(),
        "Block cannot be proposed after a reconfiguration block (certified block)"
    );
    
    // ... rest of function ...
}
```

Additionally, update the proposal generator:

```rust
// In consensus/src/liveness/proposal_generator.rs
fn ensure_highest_quorum_cert(&self, round: Round) -> anyhow::Result<Arc<QuorumCert>> {
    // ... existing checks ...
    
    ensure!(
        !hqc.ends_epoch(),
        "The epoch has already ended, a proposal is not allowed to be generated"
    );
    
    // NEW: Check certified block as well
    ensure!(
        !hqc.certified_block().has_reconfiguration(),
        "Cannot generate proposal after reconfiguration block"
    );
    
    Ok(hqc)
}
```

The reconfiguration suffix restriction should apply transitively until the reconfiguration block is committed and the epoch transitions.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
// Place in consensus/consensus-types/src/block_test.rs

#[test]
fn test_epoch_ending_bypass_via_round_gap() {
    use crate::{block::Block, quorum_cert::QuorumCert, vote_data::VoteData};
    use aptos_types::{
        block_info::BlockInfo,
        epoch_state::EpochState,
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
        validator_verifier::random_validator_verifier,
    };
    use aptos_crypto::hash::HashValue;
    
    let (signers, validator_verifier) = random_validator_verifier(4, None, false);
    let epoch_state = EpochState {
        epoch: 1,
        verifier: validator_verifier.into(),
    };
    
    // Create Block N-1 at round 10 with reconfiguration
    let block_n_minus_1_info = BlockInfo::new(
        1,                          // epoch
        10,                         // round
        HashValue::random(),        // id
        HashValue::random(),        // executed_state_id
        100,                        // version
        1000,                       // timestamp
        Some(epoch_state.clone()),  // next_epoch_state - RECONFIGURATION!
    );
    
    // Create Block N-2 at round 9 (parent of N-1)
    let block_n_minus_2_info = BlockInfo::new(
        1, 9, HashValue::random(), HashValue::random(), 99, 999, None,
    );
    
    // QC for Block N-1
    let vote_data_n_minus_1 = VoteData::new(block_n_minus_1_info.clone(), block_n_minus_2_info.clone());
    let ledger_info_n_minus_1 = LedgerInfo::new(
        block_n_minus_2_info.clone(),  // commits N-2 (if 2-chain rule satisfied)
        vote_data_n_minus_1.hash(),
    );
    let qc_n_minus_1 = QuorumCert::new(
        vote_data_n_minus_1,
        LedgerInfoWithSignatures::new(ledger_info_n_minus_1, AggregateSignature::empty()),
    );
    
    // Block N at round 12 (ROUND GAP - skips round 11)
    let block_n_data = BlockData::new_proposal(
        Payload::empty(true, false),
        signers[0].author(),
        vec![],
        12,                     // round = 12, NOT 11!
        2000,
        qc_n_minus_1.clone(),
    );
    let block_n = Block::new_proposal_from_block_data(block_n_data, &signers[0]).unwrap();
    
    // When voting on Block N (round 12), commit rule:
    // round(N) = 12, round(N-1) = 10
    // 12 ≠ 10 + 1, so commit_info = EMPTY (doesn't commit N-1!)
    
    let vote_data_n = VoteData::new(
        BlockInfo::new(1, 12, block_n.id(), HashValue::random(), 101, 2000, None),
        block_n_minus_1_info.clone(),
    );
    let ledger_info_n = LedgerInfo::new(
        BlockInfo::empty(),  // EMPTY commit_info due to round gap!
        vote_data_n.hash(),
    );
    let qc_n = QuorumCert::new(
        vote_data_n,
        LedgerInfoWithSignatures::new(ledger_info_n, AggregateSignature::empty()),
    );
    
    // Block N+1 at round 13
    let block_n_plus_1_data = BlockData::new_proposal(
        Payload::empty(true, false),  // Can have payload since parent doesn't have reconfiguration!
        signers[0].author(),
        vec![],
        13,
        3000,
        qc_n.clone(),
    );
    let block_n_plus_1 = Block::new_proposal_from_block_data(block_n_plus_1_data, &signers[0]).unwrap();
    
    // VULNERABILITY: Block N+1 passes epoch-ending check despite epoch ending at N-1!
    // qc_n.ends_epoch() returns false because commit_info is empty
    assert!(!qc_n.ends_epoch(), "QC should not indicate epoch ending due to round gap");
    
    // verify_well_formed() would pass (if we had valid timestamps, etc.)
    // The epoch-ending check at lines 541-544 checks qc_n.ends_epoch(), which is false
    // But Block N-1 (certified by qc_n_minus_1) has reconfiguration!
    assert!(qc_n_minus_1.certified_block().has_reconfiguration(), "Block N-1 has reconfiguration");
    
    // The vulnerability: blocks can continue being proposed after reconfiguration
    // The reconfiguration block (N-1) is certified but never committed
    // Epoch never transitions, governance never takes effect
}
```

**Notes:**
- The vulnerability allows continuous block proposals in an "ended" epoch by preventing reconfiguration block commitment through round gaps
- The check examines committed blocks (via 2-chain rule) rather than certified blocks, creating a bypass window
- Natural timeouts or Byzantine behavior can trigger this, requiring no special privileges
- Recovery requires hard fork intervention as the protocol cannot self-recover from this inconsistent state
- Both proposal generation and block verification use the same flawed check, so honest validators continue participating in the compromised epoch

### Citations

**File:** consensus/consensus-types/src/block.rs (L483-488)
```rust
        if parent.has_reconfiguration() {
            ensure!(
                self.payload().is_none_or(|p| p.is_empty()),
                "Reconfiguration suffix should not carry payload"
            );
        }
```

**File:** consensus/consensus-types/src/block.rs (L541-544)
```rust
        ensure!(
            !self.quorum_cert().ends_epoch(),
            "Block cannot be proposed in an epoch that has ended"
        );
```

**File:** consensus/consensus-types/src/quorum_cert.rs (L75-77)
```rust
    pub fn ends_epoch(&self) -> bool {
        self.signed_ledger_info.ledger_info().ends_epoch()
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L195-214)
```rust
    fn construct_ledger_info_2chain(
        &self,
        proposed_block: &Block,
        consensus_data_hash: HashValue,
    ) -> Result<LedgerInfo, Error> {
        let block1 = proposed_block.round();
        let block0 = proposed_block.quorum_cert().certified_block().round();

        // verify 2-chain rule
        let commit = next_round(block0)? == block1;

        // create a ledger info
        let commit_info = if commit {
            proposed_block.quorum_cert().certified_block().clone()
        } else {
            BlockInfo::empty()
        };

        Ok(LedgerInfo::new(commit_info, consensus_data_hash))
    }
```

**File:** consensus/src/liveness/proposal_generator.rs (L874-877)
```rust
        ensure!(
            !hqc.ends_epoch(),
            "The epoch has already ended,a proposal is not allowed to generated"
        );
```
