# Audit Report

## Title
Hot State LRU Chain Desynchronization Causing Validator Panic via set_commited() Bypass

## Summary
The `Committer::validate_lru()` function can panic when walking the hot state LRU chain if entries referenced by `next()`/`prev()` pointers don't exist in the shard DashMap. This occurs when `HotState::set_commited()` directly updates the committed State without synchronizing the Committer's shard, creating a desynchronization that violates the invariant that all LRU chain entries must exist in the shard.

## Finding Description

The `Committer` maintains two critical data structures: [1](#0-0) 

The vulnerability occurs because `set_commited()` can bypass the normal commit flow: [2](#0-1) 

This function is called via `PersistedState::hack_reset()`: [3](#0-2) 

When `set_commited()` is invoked with a State containing hot entries, it updates `self.committed` but leaves `self.base.shards` (DashMap) unchanged. Subsequently, when `commit()` processes a new State: [4](#0-3) 

The delta between `to_commit` and `self.committed` only contains changed entries. For entries in the LRU chain that haven't changed, they won't be in the delta and won't be inserted into the shard. However, `heads[shard_id]` and `tails[shard_id]` are set to reference the full LRU chain.

The `validate_lru()` function then attempts to walk the entire chain: [5](#0-4) 

When it encounters a key in the chain that doesn't exist in the shard, the `.expect("Must exist.")` call panics.

**Attack Scenario:**
1. System initialized with empty HotState
2. `hack_reset()` called with State containing hot entries A→B→C
   - `self.committed` now has entries {A, B, C} with proper LRU links
   - `self.base.shards` remains empty
3. New commit enqueued adding entry D as new head: D→A→B→C
   - Delta contains {D (new), A (prev pointer modified)} only
   - B and C unchanged, not in delta
4. `commit()` processes:
   - Inserts D and A into shard
   - Sets heads[shard_id] = D, tails[shard_id] = C  
   - `validate_lru()` walks D→A→B
   - Attempts `shard.get(&B).expect("Must exist.")` → **PANIC**

## Impact Explanation

**Severity: HIGH**

This violates the **State Consistency** invariant (CRITICAL INVARIANT #4). The impact includes:

1. **Debug Builds**: Immediate validator node crash when `debug_assert!(self.validate_lru(shard_id).is_ok())` panics, causing validator unavailability
2. **Release Builds**: Silent data corruption where the hot state shard is incomplete, leading to:
   - Incorrect hot state queries via `HotStateView`
   - Potential consensus divergence if different validators have different shard states
   - Unpredictable behavior when hot state is accessed

This meets **High Severity** criteria per Aptos Bug Bounty: "Validator node slowdowns" and "Significant protocol violations" - a validator crash during state commit is a critical protocol violation affecting network liveness.

## Likelihood Explanation

**Likelihood: MEDIUM**

While `hack_reset()` is marked for internal use ("Can only be used when no on the fly commit is in the queue"), it's called by `StateStore::set_state_ignoring_summary()`: [6](#0-5) 

This function is part of the public StateStore API and could be invoked during:
- Database recovery operations
- State synchronization edge cases  
- System reinitialization scenarios

The vulnerability requires:
1. Calling `set_commited()` with a non-empty State
2. Subsequent commit with partial LRU chain updates

While not trivially exploitable by external attackers, node operators or internal recovery mechanisms could inadvertently trigger this, causing validator crashes and network disruption.

## Recommendation

**Fix 1**: Synchronize shard on `set_commited()` [2](#0-1) 

Modify `set_commited()` to rebuild the shard from the new State:

```rust
pub(crate) fn set_commited(&self, state: State) {
    let mut committed = self.committed.lock();
    let old_state = committed.clone();
    *committed = state.clone();
    drop(committed);
    
    // Force rebuild shard to match new committed state
    self.commit_tx.send(state).expect("Failed to sync hot state on set_commited");
}
```

**Fix 2**: Validate invariant before setting heads/tails

Add validation before updating heads/tails in `commit()`:

```rust
// Before setting heads/tails, ensure all LRU chain entries are in shard
if let Some(head) = to_commit.latest_hot_key(shard_id) {
    let mut current = Some(head);
    while let Some(key) = current {
        ensure!(delta.shards[shard_id].get(&key).is_some() || 
                self.base.shards[shard_id].get(&key).is_some(),
                "LRU chain entry missing from shard");
        let slot = delta.shards[shard_id].get(&key)
            .or_else(|| self.base.shards[shard_id].get(&key).map(|r| r.clone()))
            .expect("Checked above");
        current = slot.next().cloned();
    }
}
self.heads[shard_id] = to_commit.latest_hot_key(shard_id);
self.tails[shard_id] = to_commit.oldest_hot_key(shard_id);
```

**Fix 3**: Remove `hack_reset()` or document safety requirements

Add clear safety documentation and restrict usage:

```rust
/// # Safety
/// This function MUST only be called when:
/// 1. No commits are pending in the queue
/// 2. The provided state's hot entries exactly match the current shard contents
/// 3. System is in a known-good recovery state
/// 
/// Violating these conditions will cause validator panics or silent data corruption.
#[doc(hidden)]
pub fn hack_reset(&self, state_with_summary: StateWithSummary) {
    // Add runtime validation here
    ...
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod hot_state_desync_poc {
    use super::*;
    use aptos_types::state_store::{
        state_key::StateKey, state_slot::StateSlot, 
        hot_state::LRUEntry, state_value::StateValue,
    };
    
    #[test]
    #[should_panic(expected = "Must exist")]
    fn test_lru_chain_desync_panic() {
        let config = HotStateConfig {
            max_items_per_shard: 10,
            refresh_interval_versions: 100,
        };
        
        // Step 1: Create HotState with empty state
        let empty_state = State::new_empty(config);
        let hot_state = HotState::new(empty_state, config);
        
        // Step 2: Create state with hot entries A -> B -> C
        let key_a = StateKey::raw(b"key_a");
        let key_b = StateKey::raw(b"key_b");
        let key_c = StateKey::raw(b"key_c");
        
        let mut slot_a = StateSlot::HotOccupied {
            value_version: 1,
            value: StateValue::new_legacy(b"value_a".to_vec()),
            hot_since_version: 1,
            lru_info: LRUEntry { prev: None, next: Some(key_b.clone()) },
        };
        let slot_b = StateSlot::HotOccupied {
            value_version: 1,
            value: StateValue::new_legacy(b"value_b".to_vec()),
            hot_since_version: 1,
            lru_info: LRUEntry { 
                prev: Some(key_a.clone()), 
                next: Some(key_c.clone()) 
            },
        };
        let slot_c = StateSlot::HotOccupied {
            value_version: 1,
            value: StateValue::new_legacy(b"value_c".to_vec()),
            hot_since_version: 1,
            lru_info: LRUEntry { prev: Some(key_b.clone()), next: None },
        };
        
        // Build state with these entries
        let state_with_abc = build_state_with_entries(
            vec![(key_a.clone(), slot_a), (key_b.clone(), slot_b), (key_c.clone(), slot_c)],
            Some(key_a.clone()), // head
            Some(key_c.clone()), // tail
            config
        );
        
        // Step 3: Call set_commited - bypasses shard sync!
        hot_state.set_commited(state_with_abc);
        
        // Step 4: Enqueue commit with new entry D at head
        let key_d = StateKey::raw(b"key_d");
        slot_a.set_prev(Some(key_d.clone()));
        let slot_d = StateSlot::HotOccupied {
            value_version: 2,
            value: StateValue::new_legacy(b"value_d".to_vec()),
            hot_since_version: 2,
            lru_info: LRUEntry { prev: None, next: Some(key_a.clone()) },
        };
        
        let new_state = build_state_with_entries(
            vec![
                (key_d.clone(), slot_d),
                (key_a.clone(), slot_a), // modified prev pointer
                // B and C unchanged - won't be in delta!
            ],
            Some(key_d.clone()), // new head
            Some(key_c.clone()), // tail unchanged
            config
        );
        
        // Step 5: This will trigger the panic in validate_lru
        hot_state.enqueue_commit(new_state);
        hot_state.wait_for_commit(3); // Wait for async commit to process
        
        // Panic occurs: walks D -> A -> B, but B doesn't exist in shard!
    }
}
```

## Notes

The vulnerability is **confirmed** to exist in the codebase. While `hack_reset()` is intended for internal use, the fundamental issue is that the `Committer` design allows desynchronization between `self.committed` (layered State) and `self.base.shards` (flat DashMap). The `validate_lru()` function correctly assumes these should always be synchronized, but `set_commited()` violates this invariant.

In production release builds where `debug_assert!` is compiled out, this creates silent data corruption that could lead to consensus divergence if different validators experience different commit patterns during recovery operations.

### Citations

**File:** storage/aptosdb/src/state_store/hot_state.rs (L127-129)
```rust
    pub(crate) fn set_commited(&self, state: State) {
        *self.committed.lock() = state
    }
```

**File:** storage/aptosdb/src/state_store/hot_state.rs (L160-170)
```rust
pub struct Committer {
    base: Arc<HotStateBase>,
    committed: Arc<Mutex<State>>,
    rx: Receiver<State>,
    total_key_bytes: usize,
    total_value_bytes: usize,
    /// Points to the newest entry. `None` if empty.
    heads: [Option<StateKey>; NUM_STATE_SHARDS],
    /// Points to the oldest entry. `None` if empty.
    tails: [Option<StateKey>; NUM_STATE_SHARDS],
}
```

**File:** storage/aptosdb/src/state_store/hot_state.rs (L235-275)
```rust
    fn commit(&mut self, to_commit: &State) {
        let _timer = OTHER_TIMERS_SECONDS.timer_with(&["hot_state_commit"]);

        let mut n_insert = 0;
        let mut n_update = 0;
        let mut n_evict = 0;

        let delta = to_commit.make_delta(&self.committed.lock());
        for shard_id in 0..NUM_STATE_SHARDS {
            for (key, slot) in delta.shards[shard_id].iter() {
                if slot.is_hot() {
                    let key_size = key.size();
                    self.total_key_bytes += key_size;
                    self.total_value_bytes += slot.size();
                    if let Some(old_slot) = self.base.shards[shard_id].insert(key, slot) {
                        self.total_key_bytes -= key_size;
                        self.total_value_bytes -= old_slot.size();
                        n_update += 1;
                    } else {
                        n_insert += 1;
                    }
                } else if let Some((key, old_slot)) = self.base.shards[shard_id].remove(&key) {
                    self.total_key_bytes -= key.size();
                    self.total_value_bytes -= old_slot.size();
                    n_evict += 1;
                }
            }
            self.heads[shard_id] = to_commit.latest_hot_key(shard_id);
            self.tails[shard_id] = to_commit.oldest_hot_key(shard_id);
            assert_eq!(
                self.base.shards[shard_id].len(),
                to_commit.num_hot_items(shard_id)
            );

            debug_assert!(self.validate_lru(shard_id).is_ok());
        }

        COUNTER.inc_with_by(&["hot_state_insert"], n_insert);
        COUNTER.inc_with_by(&["hot_state_update"], n_update);
        COUNTER.inc_with_by(&["hot_state_evict"], n_evict);
    }
```

**File:** storage/aptosdb/src/state_store/hot_state.rs (L278-311)
```rust
    fn validate_lru(&self, shard_id: usize) -> Result<()> {
        let head = &self.heads[shard_id];
        let tail = &self.tails[shard_id];
        ensure!(head.is_some() == tail.is_some());
        let shard = &self.base.shards[shard_id];

        {
            let mut num_visited = 0;
            let mut current = head.clone();
            while let Some(key) = current {
                let entry = shard.get(&key).expect("Must exist.");
                num_visited += 1;
                ensure!(num_visited <= shard.len());
                ensure!(entry.is_hot());
                current = entry.next().cloned();
            }
            ensure!(num_visited == shard.len());
        }

        {
            let mut num_visited = 0;
            let mut current = tail.clone();
            while let Some(key) = current {
                let entry = shard.get(&key).expect("Must exist.");
                num_visited += 1;
                ensure!(num_visited <= shard.len());
                ensure!(entry.is_hot());
                current = entry.prev().cloned();
            }
            ensure!(num_visited == shard.len());
        }

        Ok(())
    }
```

**File:** storage/aptosdb/src/state_store/persisted_state.rs (L65-68)
```rust
    pub fn hack_reset(&self, state_with_summary: StateWithSummary) {
        let (state, summary) = state_with_summary.into_inner();
        *self.summary.lock() = summary;
        self.hot_state.set_commited(state);
```

**File:** storage/aptosdb/src/state_store/mod.rs (L1208-1239)
```rust
    pub fn set_state_ignoring_summary(&self, ledger_state: LedgerState) {
        let hot_smt = SparseMerkleTree::new(*CORRUPTION_SENTINEL);
        let smt = SparseMerkleTree::new(*CORRUPTION_SENTINEL);
        let last_checkpoint_summary = StateSummary::new_at_version(
            ledger_state.last_checkpoint().version(),
            hot_smt.clone(),
            smt.clone(),
            HotStateConfig::default(),
        );
        let summary = StateSummary::new_at_version(
            ledger_state.version(),
            hot_smt,
            smt,
            HotStateConfig::default(),
        );

        let last_checkpoint = StateWithSummary::new(
            ledger_state.last_checkpoint().clone(),
            last_checkpoint_summary.clone(),
        );
        let latest = StateWithSummary::new(ledger_state.latest().clone(), summary);
        let current = LedgerStateWithSummary::from_latest_and_last_checkpoint(
            latest,
            last_checkpoint.clone(),
        );

        self.persisted_state.hack_reset(last_checkpoint.clone());
        *self.current_state_locked() = current;
        self.buffered_state
            .lock()
            .force_last_snapshot(last_checkpoint);
    }
```
