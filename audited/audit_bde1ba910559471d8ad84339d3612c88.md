> Searching codebase... [1](#0-0) [2](#0-1) [3](#0-2) [4](#0-3) [5](#0-4) [6](#0-5) [7](#0-6)

### Citations

**File:** consensus/consensus-types/src/common.rs (L575-612)
```rust
        &self,
        verifier: &ValidatorVerifier,
        proof_cache: &ProofCache,
        quorum_store_enabled: bool,
    ) -> anyhow::Result<()> {
        match (quorum_store_enabled, self) {
            (false, Payload::DirectMempool(_)) => Ok(()),
            (true, Payload::InQuorumStore(proof_with_status)) => {
                Self::verify_with_cache(&proof_with_status.proofs, verifier, proof_cache)
            },
            (true, Payload::InQuorumStoreWithLimit(proof_with_status)) => Self::verify_with_cache(
                &proof_with_status.proof_with_data.proofs,
                verifier,
                proof_cache,
            ),
            (true, Payload::QuorumStoreInlineHybrid(inline_batches, proof_with_data, _))
            | (true, Payload::QuorumStoreInlineHybridV2(inline_batches, proof_with_data, _)) => {
                Self::verify_with_cache(&proof_with_data.proofs, verifier, proof_cache)?;
                Self::verify_inline_batches(
                    inline_batches.iter().map(|(info, txns)| (info, txns)),
                )?;
                Ok(())
            },
            (true, Payload::OptQuorumStore(OptQuorumStorePayload::V1(p))) => {
                let proof_with_data = p.proof_with_data();
                Self::verify_with_cache(&proof_with_data.batch_summary, verifier, proof_cache)?;
                Self::verify_inline_batches(
                    p.inline_batches()
                        .iter()
                        .map(|batch| (batch.info(), batch.transactions())),
                )?;
                Self::verify_opt_batches(verifier, p.opt_batches())?;
                Ok(())
            },
            (true, Payload::OptQuorumStore(OptQuorumStorePayload::V2(p))) => {
                if true {
                    bail!("OptQuorumStorePayload::V2 cannot be accepted yet");
                }
```

**File:** consensus/consensus-types/src/common.rs (L634-637)
```rust
    pub(crate) fn verify_epoch(&self, epoch: u64) -> anyhow::Result<()> {
        match self {
            Payload::DirectMempool(_) => return Ok(()),
            Payload::InQuorumStore(proof_with_data) => {
```

**File:** consensus/consensus-types/src/block_retrieval.rs (L260-282)
```rust
    pub fn verify(
        &self,
        retrieval_request: BlockRetrievalRequest,
        sig_verifier: &ValidatorVerifier,
    ) -> anyhow::Result<()> {
        self.verify_inner(&retrieval_request)?;

        self.blocks
            .iter()
            .try_fold(retrieval_request.block_id(), |expected_id, block| {
                block.validate_signature(sig_verifier)?;
                block.verify_well_formed()?;
                ensure!(
                    block.id() == expected_id,
                    "blocks doesn't form a chain: expect {}, get {}",
                    expected_id,
                    block.id()
                );
                Ok(block.parent_id())
            })
            .map(|_| ())
    }
}
```

**File:** consensus/consensus-types/src/proposal_msg.rs (L97-102)
```rust
        let (payload_result, sig_result) = rayon::join(
            || {
                self.proposal().payload().map_or(Ok(()), |p| {
                    p.verify(validator, proof_cache, quorum_store_enabled)
                })
            },
```

**File:** consensus/src/epoch_manager.rs (L1806-1894)
```rust
    fn process_rpc_request(
        &mut self,
        peer_id: Author,
        request: IncomingRpcRequest,
    ) -> anyhow::Result<()> {
        fail_point!("consensus::process::any", |_| {
            Err(anyhow::anyhow!("Injected error in process_rpc_request"))
        });

        match request.epoch() {
            Some(epoch) if epoch != self.epoch() => {
                monitor!(
                    "process_different_epoch_rpc_request",
                    self.process_different_epoch(epoch, peer_id)
                )?;
                return Ok(());
            },
            None => {
                // TODO: @bchocho @hariria can change after all nodes upgrade to release with enum BlockRetrievalRequest (not struct)
                ensure!(matches!(
                    request,
                    IncomingRpcRequest::DeprecatedBlockRetrieval(_)
                        | IncomingRpcRequest::BlockRetrieval(_)
                ));
            },
            _ => {},
        }

        match request {
            // TODO @bchocho @hariria can remove after all nodes upgrade to release with enum BlockRetrievalRequest (not struct)
            IncomingRpcRequest::DeprecatedBlockRetrieval(
                DeprecatedIncomingBlockRetrievalRequest {
                    req,
                    protocol,
                    response_sender,
                },
            ) => {
                if let Some(tx) = &self.block_retrieval_tx {
                    let incoming_block_retrieval_request = IncomingBlockRetrievalRequest {
                        req: BlockRetrievalRequest::V1(req),
                        protocol,
                        response_sender,
                    };
                    tx.push(peer_id, incoming_block_retrieval_request)
                } else {
                    error!("Round manager not started (in IncomingRpcRequest::DeprecatedBlockRetrieval)");
                    Ok(())
                }
            },
            IncomingRpcRequest::BatchRetrieval(request) => {
                if let Some(tx) = &self.batch_retrieval_tx {
                    tx.push(peer_id, request)
                } else {
                    Err(anyhow::anyhow!("Quorum store not started"))
                }
            },
            IncomingRpcRequest::DAGRequest(request) => {
                if let Some(tx) = &self.dag_rpc_tx {
                    tx.push(peer_id, request)
                } else {
                    Err(anyhow::anyhow!("DAG not bootstrapped"))
                }
            },
            IncomingRpcRequest::CommitRequest(request) => {
                self.execution_client.send_commit_msg(peer_id, request)
            },
            IncomingRpcRequest::RandGenRequest(request) => {
                if let Some(tx) = &self.rand_manager_msg_tx {
                    tx.push(peer_id, request)
                } else {
                    bail!("Rand manager not started");
                }
            },
            IncomingRpcRequest::BlockRetrieval(request) => {
                if let Some(tx) = &self.block_retrieval_tx {
                    tx.push(peer_id, request)
                } else {
                    error!("Round manager not started");
                    Ok(())
                }
            },
            IncomingRpcRequest::SecretShareRequest(request) => {
                let Some(tx) = &self.secret_share_manager_tx else {
                    bail!("Secret share manager not started");
                };
                tx.push(peer_id, request)
            },
        }
    }
```

**File:** consensus/src/network.rs (L178-189)
```rust
    pub fn epoch(&self) -> Option<u64> {
        match self {
            IncomingRpcRequest::BatchRetrieval(req) => Some(req.req.epoch()),
            IncomingRpcRequest::DAGRequest(req) => Some(req.req.epoch()),
            IncomingRpcRequest::RandGenRequest(req) => Some(req.req.epoch()),
            IncomingRpcRequest::CommitRequest(req) => req.req.epoch(),
            IncomingRpcRequest::DeprecatedBlockRetrieval(_) => None,
            IncomingRpcRequest::BlockRetrieval(_) => None,
            IncomingRpcRequest::SecretShareRequest(req) => Some(req.req.epoch()),
        }
    }
}
```

**File:** consensus/consensus-types/src/block.rs (L490-492)
```rust
        if let Some(payload) = self.payload() {
            payload.verify_epoch(self.epoch())?;
        }
```
