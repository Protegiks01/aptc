# Audit Report

## Title
Missing Defense-in-Depth: Groth16 Verification Key Validation Never Executed During On-Chain Configuration

## Summary
The Groth16 verification key (VK) validation function exists in Move but is never called when VKs are set via governance or genesis. Lines 75-87 of `groth16_vk.rs` rely entirely on arkworks' BN254 deserialization for security with no defense-in-depth, creating a single point of failure. A Rust code comment incorrectly assumes Move-side validation occurs, potentially enabling future "optimizations" that remove all validation.

## Finding Description

The Aptos keyless account system uses Groth16 zero-knowledge proofs verified with a BN254 verification key stored on-chain. The verification key consists of elliptic curve points that must be validated.

**The validation function exists but is never called:** [1](#0-0) 

This function validates all curve points in the VK using Move's `crypto_algebra::deserialize`, but it is never invoked by either:

1. **Genesis VK setup:** [2](#0-1) 

2. **Governance VK updates:** [3](#0-2) 

**The ONLY validation occurs in Rust at runtime:** [4](#0-3) 

Lines 75-87 use arkworks' `G1Affine::deserialize_compressed` and `G2Affine::deserialize_compressed` for all validation. If these functions have vulnerabilities (accepting invalid points, wrong subgroup, points not on curve), the entire keyless security model fails.

**Critical false assumption documented:** [5](#0-4) 

This comment claims validation happens "when we set the VK in Move," which is **false**. This creates risk that future developers may remove Rust validation based on this incorrect assumption.

**Attack Scenario:**

If arkworks' BN254 implementation has a vulnerability allowing invalid curve point acceptance:
1. Governance proposal sets malicious VK (no Move validation performed)
2. VK stored on-chain and propagates to all validators
3. Validators fetch VK and call `try_into()` at environment initialization: [6](#0-5) 

4. Arkworks' vulnerable deserialization accepts the invalid points (lines 75-87)
5. Malicious VK used for Groth16 proof verification: [7](#0-6) 

6. Attackers forge proofs verifying against malicious VK
7. All keyless accounts compromised - funds stolen

## Impact Explanation

**Critical Severity** - Meets "Loss of Funds (theft)" criteria:

If arkworks has a BN254 curve validation vulnerability, this lack of defense-in-depth enables complete compromise of all keyless accounts on Aptos. The single-layer validation creates an unacceptable dependency risk for a system securing user funds.

Even without arkworks vulnerabilities, this represents a critical architectural flaw:
- Violates defense-in-depth security principles
- No validation at configuration time (set operation)
- Only validation at usage time (verify operation)  
- False documentation creates future risk of removing the only validation layer

The comment at line 262 acknowledges this risk: [8](#0-7) 

## Likelihood Explanation

**Likelihood: Medium-High**

1. **Arkworks vulnerability discovery**: Cryptographic implementations have historical precedent of point validation bugs (e.g., Zcash, various ECC libraries). BN254 is complex with subgroup checks required.

2. **Governance-based VK updates**: VKs can be changed via governance proposals, providing an attack vector if combined with arkworks vulnerability.

3. **Future code optimization**: The false comment about Move validation creates concrete risk that developers will remove Rust validation for "2x performance improvement."

4. **No circuit upgrade validation**: When circuits are upgraded (requiring VK changes), the lack of validation increases operational risk.

## Recommendation

**Immediate fixes:**

1. **Call validation function when setting VK:**
```move
public fun set_groth16_verification_key_for_next_epoch(fx: &signer, vk: Groth16VerificationKey) {
    system_addresses::assert_aptos_framework(fx);
    validate_groth16_vk(&vk);  // ADD THIS LINE
    config_buffer::upsert<Groth16VerificationKey>(vk);
}

public fun update_groth16_verification_key(fx: &signer, vk: Groth16VerificationKey) {
    system_addresses::assert_aptos_framework(fx);
    chain_status::assert_genesis();
    validate_groth16_vk(&vk);  // ADD THIS LINE
    move_to(fx, vk);
}
```

2. **Correct the false documentation:**
```rust
// NOTE: Points are validated both when VK is set (Move-side via validate_groth16_vk) 
// and when used (Rust-side via deserialize_compressed). This defense-in-depth approach
// protects against both configuration errors and potential deserialization vulnerabilities.
```

3. **Add explicit subgroup checks:** Ensure arkworks deserialization performs full validation including subgroup membership checks.

## Proof of Concept

```move
#[test(aptos_framework = @0x1)]
#[expected_failure(abort_code = 0x030002, location = aptos_framework::keyless_account)]
fun test_invalid_vk_should_be_rejected(aptos_framework: &signer) {
    use aptos_framework::keyless_account;
    
    // Create invalid VK with malformed G1 point
    let invalid_alpha = vector[0xFF, 0xFF, 0xFF, /* ... invalid point data ... */];
    let valid_beta = vector[/* valid G2 point */];
    let valid_gamma = vector[/* valid G2 point */];
    let valid_delta = vector[/* valid G2 point */];
    let valid_abc = vector[vector[/* valid G1 */], vector[/* valid G1 */]];
    
    let invalid_vk = keyless_account::new_groth16_verification_key(
        invalid_alpha, valid_beta, valid_gamma, valid_delta, valid_abc
    );
    
    // This SHOULD abort with E_INVALID_BN254_G1_SERIALIZATION but currently doesn't
    // because validate_groth16_vk is never called
    keyless_account::set_groth16_verification_key_for_next_epoch(
        aptos_framework, 
        invalid_vk
    );
    
    // Invalid VK is now on-chain, will cause DoS when validators try to use it
    // or worse, if arkworks accepts it due to vulnerability
}
```

**Notes:**
- This vulnerability requires either an arkworks implementation bug OR creates operational DoS risk
- The false documentation comment creates additional future risk
- Keyless accounts currently hold significant user funds on Aptos mainnet
- Defense-in-depth is critical for cryptographic systems securing funds

### Citations

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L183-192)
```text
    fun validate_groth16_vk(vk: &Groth16VerificationKey) {
        // Could be leveraged to speed up the VM deserialization of the VK by 2x, since it can assume the points are valid.
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(&vk.alpha_g1)), E_INVALID_BN254_G1_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.beta_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.gamma_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.delta_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        for (i in 0..vector::length(&vk.gamma_abc_g1)) {
            assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(vector::borrow(&vk.gamma_abc_g1, i))), E_INVALID_BN254_G1_SERIALIZATION);
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L198-203)
```text
    public fun update_groth16_verification_key(fx: &signer, vk: Groth16VerificationKey) {
        system_addresses::assert_aptos_framework(fx);
        chain_status::assert_genesis();
        // There should not be a previous resource set here.
        move_to(fx, vk);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L262-262)
```text
    /// WARNING: If a malicious key is set, this would lead to stolen funds.
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L263-266)
```text
    public fun set_groth16_verification_key_for_next_epoch(fx: &signer, vk: Groth16VerificationKey) {
        system_addresses::assert_aptos_framework(fx);
        config_buffer::upsert<Groth16VerificationKey>(vk);
    }
```

**File:** types/src/keyless/groth16_vk.rs (L62-91)
```rust
impl TryFrom<&Groth16VerificationKey> for PreparedVerifyingKey<Bn254> {
    type Error = CryptoMaterialError;

    fn try_from(vk: &Groth16VerificationKey) -> Result<Self, Self::Error> {
        if vk.gamma_abc_g1.len() != 2 {
            return Err(CryptoMaterialError::DeserializationError);
        }

        // NOTE: Technically, we already validate the points when we set the VK in Move, so we could
        // make this 2x faster by avoiding the point validation checks  via
        // `deserialize_with_mode(..., Compress::Yes, Validate::No)`. Due to paranoia, will not
        // optimize this for now.
        Ok(Self::from(VerifyingKey {
            alpha_g1: G1Affine::deserialize_compressed(vk.alpha_g1.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            beta_g2: G2Affine::deserialize_compressed(vk.beta_g2.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            gamma_g2: G2Affine::deserialize_compressed(vk.gamma_g2.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            delta_g2: G2Affine::deserialize_compressed(vk.delta_g2.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            gamma_abc_g1: vec![
                G1Affine::deserialize_compressed(vk.gamma_abc_g1[0].as_slice())
                    .map_err(|_| CryptoMaterialError::DeserializationError)?,
                G1Affine::deserialize_compressed(vk.gamma_abc_g1[1].as_slice())
                    .map_err(|_| CryptoMaterialError::DeserializationError)?,
            ],
        }))
    }
}
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L289-293)
```rust
        let keyless_pvk =
            Groth16VerificationKey::fetch_keyless_config(state_view).and_then(|(vk, vk_bytes)| {
                sha3_256.update(&vk_bytes);
                vk.try_into().ok()
            });
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L347-347)
```rust
                        let result = zksig.verify_groth16_proof(public_inputs_hash, pvk.unwrap());
```
