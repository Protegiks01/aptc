# Audit Report

## Title
Symlink-Following and TOCTOU Vulnerability in Backup Metadata Cache Directory Allows Privilege Escalation and Validator State Corruption

## Summary
The backup-cli metadata cache implementation lacks symlink verification when creating and using the cache directory. An attacker with local filesystem access can create a symlink at the cache directory path, causing the backup tool to follow it and perform file operations (deletion, writing, reading) on an unintended target location. This can lead to validator state corruption or privilege escalation when the backup-cli runs with elevated privileges.

## Finding Description

The `sync_and_load()` function in the metadata cache module creates and uses a cache directory without verifying that it is a genuine directory and not a symlink. [1](#0-0) 

The vulnerability manifests in several ways:

**1. Pre-existing Symlink Attack (Primary Vector):**
If an attacker creates a symlink at the cache directory path before the backup-cli executes, all subsequent operations will follow the symlink. The `create_dir_all()` function succeeds when the path is a symlink pointing to an existing directory, and no verification occurs afterward. [2](#0-1) 

**2. File Deletion Following Symlink:**
The code deletes "stale" metadata files from the cache directory without verifying the target is not a symlink. [3](#0-2) 

**3. File Writing Following Symlink:**
New metadata files are downloaded and written to the cache directory, following any symlink present. [4](#0-3) 

**4. File Reading Following Symlink:**
Cached files are opened and read from the cache directory, following symlinks. [5](#0-4) 

The cache directory path can be user-specified via the `--metadata-cache-dir` command-line option or defaults to a temporary directory. [6](#0-5) 

When the default `TempPath` is used, it creates a path with random components but still uses standard directory creation without symlink protection. [7](#0-6) 

**Exploitation Scenario:**

1. **Setup**: Validator operator plans to run: `sudo aptos-debugger aptos-db backup continuously --metadata-cache-dir=/var/cache/aptos-backup --backup-service-address=http://localhost:6186 --command-adapter-config=s3.yaml`

2. **Attack**: Local unprivileged attacker executes:
   ```bash
   mkdir -p /var/cache/aptos-backup
   ln -s /var/lib/aptos/validator-db /var/cache/aptos-backup/cache
   ```

3. **Trigger**: Backup-cli runs with elevated privileges, follows symlink

4. **Impact**: 
   - Deletes files from `/var/lib/aptos/validator-db` (line 139)
   - Writes metadata files to `/var/lib/aptos/validator-db` (lines 153-162)
   - Corrupts validator database structure
   - Validator fails to start or produces incorrect state roots

The same vulnerability exists in other backup-cli components that use `create_dir_all()` without symlink verification. [8](#0-7) 

## Impact Explanation

This vulnerability qualifies as **Medium severity** under the Aptos bug bounty program criteria:

1. **State Inconsistencies Requiring Intervention**: Corruption of validator state by deleting or overwriting critical files can cause the validator to fail consensus participation or produce inconsistent state roots, requiring manual intervention to restore from backups or resync.

2. **Limited Privilege Escalation**: An unprivileged local user can cause a privileged process to write files to protected locations, though the content is limited to downloaded metadata files.

3. **No Direct Consensus Violation**: This does not directly break consensus safety as it requires local filesystem access and affects only individual validator nodes, not the network consensus protocol itself.

4. **Environmental Dependency**: The vulnerability is exploitable primarily in manual/local deployment scenarios where the backup-cli runs with elevated privileges on multi-user systems.

## Likelihood Explanation

**Low to Medium Likelihood:**

**Limiting Factors:**
- Production Kubernetes deployments use strong security controls that prevent exploitation: non-root execution (UID 6180), emptyDir volumes, read-only root filesystems. [9](#0-8) 
- Default `TempPath` usage creates randomly-named directories, making pre-computation of symlink locations infeasible
- Requires local filesystem access and privilege differential between attacker and backup-cli process

**Enabling Factors:**
- Validator operators may run backup-cli manually with sudo for maintenance or debugging
- The validator Docker image includes sudo and debugging tools, suggesting privileged operations occur. [10](#0-9) 
- Custom deployments outside Kubernetes may lack security controls
- User-specified `--metadata-cache-dir` in accessible locations increases attack surface

**Realistic Attack Scenarios:**
1. Development/testing environments with relaxed security
2. Validator operators running manual backups on shared infrastructure
3. Migration or disaster recovery operations using elevated privileges

## Recommendation

Implement symlink verification before using the cache directory:

```rust
use tokio::fs::metadata;

pub async fn sync_and_load(
    opt: &MetadataCacheOpt,
    storage: Arc<dyn BackupStorage>,
    concurrent_downloads: usize,
) -> Result<MetadataView> {
    let timer = Instant::now();
    let cache_dir = opt.cache_dir();
    
    // Create cache directory if it doesn't exist
    create_dir_all(&cache_dir).await.err_notes(&cache_dir)?;
    
    // Verify cache_dir is a real directory, not a symlink
    let metadata = metadata(&cache_dir).await.err_notes(&cache_dir)?;
    ensure!(
        metadata.is_dir(),
        "Cache directory is not a directory: {:?}",
        cache_dir
    );
    
    // On Unix, verify it's not a symlink using symlink_metadata
    #[cfg(unix)]
    {
        let symlink_metadata = tokio::fs::symlink_metadata(&cache_dir)
            .await
            .err_notes(&cache_dir)?;
        ensure!(
            !symlink_metadata.file_type().is_symlink(),
            "Cache directory must not be a symlink: {:?}",
            cache_dir
        );
    }
    
    // Continue with existing logic...
    let dir = read_dir(&cache_dir).await.err_notes(&cache_dir)?;
    // ... rest of function
}
```

**Additional Hardening:**
1. Verify ownership and permissions of cache directory match expected values
2. Use `std::fs::canonicalize()` to resolve the absolute path and check it matches expectations
3. Set restrictive permissions (0700) on cache directory creation
4. Document security requirements for `--metadata-cache-dir` usage
5. Consider using O_NOFOLLOW equivalent for directory operations where available

The same fix should be applied to other `create_dir_all()` calls in the backup-cli codebase. [11](#0-10) 

## Proof of Concept

**Setup:**
```bash
#!/bin/bash
# Run as unprivileged user (attacker)

# Create the target directory for symlink
mkdir -p /tmp/attacker-controlled

# Create a cache directory location
mkdir -p /tmp/backup-cache

# Create symlink before backup-cli runs
ln -s /tmp/attacker-controlled /tmp/backup-cache/cache

# Create a fake metadata file in attacker's directory
echo '{"name":"malicious"}' > /tmp/attacker-controlled/fake.meta

echo "Symlink created: /tmp/backup-cache/cache -> /tmp/attacker-controlled"
ls -la /tmp/backup-cache/
```

**Trigger (run as privileged user/validator operator):**
```bash
#!/bin/bash
# This simulates the backup-cli running with elevated privileges

# The backup-cli would be invoked like:
# sudo aptos-debugger aptos-db backup continuously \
#   --metadata-cache-dir=/tmp/backup-cache \
#   --backup-service-address=http://localhost:6186 \
#   --command-adapter-config=local.yaml

# Expected behavior: cache operations happen in /tmp/backup-cache/cache
# Actual behavior: cache operations happen in /tmp/attacker-controlled (symlink target)
```

**Verification:**
```bash
# Check that files were written to attacker-controlled location
ls -la /tmp/attacker-controlled/

# Check that symlink was followed
stat /tmp/backup-cache/cache

# If backup-cli deleted stale files, they would be deleted from
# /tmp/attacker-controlled instead of the intended cache directory
```

**Expected Result:**
The backup-cli follows the symlink and performs file operations (reads, writes, deletes) in `/tmp/attacker-controlled` instead of creating a real cache directory. This demonstrates privilege escalation as the privileged backup-cli process operates on attacker-controlled filesystem locations.

---

## Notes

**Deployment Context Matters:**
- In production Kubernetes environments with proper security contexts, this vulnerability has very low exploitability due to emptyDir volumes, non-root execution, and filesystem restrictions
- The vulnerability is most relevant for manual backup operations, development environments, or custom deployments where security controls may be relaxed
- The absence of symlink verification represents a defense-in-depth failure that should be addressed regardless of current deployment security

**Related Code Locations:**
Similar patterns exist throughout the backup-cli codebase wherever directory creation occurs without symlink verification, suggesting a systemic need for secure filesystem operation utilities.

### Citations

**File:** storage/backup/backup-cli/src/metadata/cache.rs (L28-38)
```rust
pub struct MetadataCacheOpt {
    #[clap(
        long = "metadata-cache-dir",
        value_parser,
        help = "Metadata cache dir. If specified and shared across runs, \
        metadata files in cache won't be downloaded again from backup source, speeding up tool \
        boot up significantly. Cache content can be messed up if used across the devnet, \
        the testnet and the mainnet, hence it [Defaults to temporary dir]."
    )]
    dir: Option<PathBuf>,
}
```

**File:** storage/backup/backup-cli/src/metadata/cache.rs (L90-97)
```rust
pub async fn sync_and_load(
    opt: &MetadataCacheOpt,
    storage: Arc<dyn BackupStorage>,
    concurrent_downloads: usize,
) -> Result<MetadataView> {
    let timer = Instant::now();
    let cache_dir = opt.cache_dir();
    create_dir_all(&cache_dir).await.err_notes(&cache_dir)?; // create if not present already
```

**File:** storage/backup/backup-cli/src/metadata/cache.rs (L137-141)
```rust
    for h in stale_local_hashes {
        let file = cache_dir.join(h);
        remove_file(&file).await.err_notes(&file)?;
        info!(file_name = h, "Deleted stale metadata file in cache.");
    }
```

**File:** storage/backup/backup-cli/src/metadata/cache.rs (L151-162)
```rust
        async move {
            let file_handle = fh_by_h_ref.get(*h).expect("In map.");
            let local_file = cache_dir_ref.join(*h);
            let local_tmp_file = cache_dir_ref.join(format!(".{}", *h));

            match download_file(storage_ref, file_handle, &local_tmp_file).await {
                Ok(_) => {
                    // rename to target file only if successful; stale tmp file caused by failure will be
                    // reclaimed on next run
                    tokio::fs::rename(local_tmp_file.clone(), local_file)
                        .await
                        .err_notes(local_tmp_file)?;
```

**File:** storage/backup/backup-cli/src/metadata/cache.rs (L194-207)
```rust
    for h in new_remote_hashes.into_iter().chain(up_to_date_local_hashes) {
        let cached_file = cache_dir.join(h);
        metadata_vec.extend(
            OpenOptions::new()
                .read(true)
                .open(&cached_file)
                .await
                .err_notes(&cached_file)?
                .load_metadata_lines()
                .await
                .err_notes(&cached_file)?
                .into_iter(),
        )
    }
```

**File:** crates/aptos-temppath/src/lib.rs (L67-71)
```rust
    pub fn create_as_dir(&self) -> io::Result<()> {
        let builder = fs::DirBuilder::new();
        builder.create(self.path())?;
        Ok(())
    }
```

**File:** storage/backup/backup-cli/src/storage/local_fs/mod.rs (L130-133)
```rust
        // Check if the backup directory exists, create it if it doesn't
        if !dir.exists() {
            create_dir_all(&dir).await?;
        }
```

**File:** storage/backup/backup-cli/src/storage/local_fs/mod.rs (L155-155)
```rust
        create_dir_all(&dir).await.err_notes(name)?; // in case not yet created
```

**File:** terraform/helm/fullnode/templates/backup.yaml (L88-103)
```yaml
        - name: tmp
          mountPath: /tmp
        securityContext:
          readOnlyRootFilesystem: true
          allowPrivilegeEscalation: false
          capabilities:
            drop:
            - ALL
      securityContext:
        runAsNonRoot: true
        runAsUser: 6180
        runAsGroup: 6180
        fsGroup: 6180
        seccompProfile:
          type: RuntimeDefault
      {{- with .nodeSelector }}
```

**File:** docker/builder/validator.Dockerfile (L11-16)
```dockerfile
    apt-get update && apt-get install --no-install-recommends -y \
        # Needed to run debugging tools like perf
        linux-perf \
        sudo \
        procps \
        gdb
```
