# Audit Report

## Title
Integer Underflow in Address Standardization Causes Indexer-GRPC Service Crash

## Summary
The `standardize_address` function in the indexer-grpc transaction-filter component fails to validate address length before performing arithmetic operations, allowing an attacker to crash the service by sending filter requests with oversized addresses (>64 hex characters). [1](#0-0) 

## Finding Description
The vulnerability exists in the address standardization logic used by the indexer-grpc filtering system. When converting protobuf filter messages containing address strings, the code calls `standardize_address()` without validating input length. [2](#0-1) 

The critical flaw occurs when computing padding length: if `trimmed.len()` exceeds 64, the expression `64 - trimmed.len()` causes integer underflow (in debug builds) or wraparound (in release builds), followed by an out-of-bounds slice panic when accessing `ZEROS[..result]`. [3](#0-2) 

**Attack Path:**
1. Attacker sends `GetTransactionsRequest` to indexer-grpc endpoint with a `UserTransactionFilter` containing `sender = "0x" + 100 hex characters`
2. Request is parsed by the gRPC service [4](#0-3) 
3. Filter conversion invokes `From<proto>` trait which calls `standardize_address()` without validation [5](#0-4) 
4. Underflow triggers panic, crashing the indexer-grpc service

**Affected Components:**
- `UserTransactionFilter.sender` [6](#0-5) 
- `EntryFunctionFilter.address` [7](#0-6) 
- `MoveStructTagFilter.address` [8](#0-7) 

## Impact Explanation
This vulnerability qualifies as **High Severity** per Aptos bug bounty criteria under "API crashes." While the indexer-grpc service is not part of core consensus or execution layers, it provides critical data infrastructure for ecosystem applications. A service crash disrupts:
- Real-time transaction indexing for dApps
- Historical data queries for analytics
- Event streaming for monitoring systems

The indexer-grpc can run embedded on fullnodes or as standalone infrastructure. [9](#0-8)  A crash requires service restart and may cause data gaps if not properly handled.

**Note on Scope Limitation:** This vulnerability does NOT affect consensus, validator operations, Move VM execution, or on-chain state. It is limited to the data indexing infrastructure layer.

## Likelihood Explanation
**High likelihood** of exploitation:
- No authentication bypass required (assumes normal gRPC access)
- Trivial to execute (single malformed filter parameter)
- No complex timing or race conditions
- Protobuf string fields have no inherent length limits [10](#0-9) 
- Only validation is total filter size, not individual field constraints [11](#0-10) 

## Recommendation
Add input validation before arithmetic operations:

```rust
pub fn standardize_address(address: &str) -> String {
    let trimmed = address.strip_prefix("0x").unwrap_or(address);
    
    // Add validation: Aptos addresses are 32 bytes = 64 hex chars
    if trimmed.len() > 64 {
        // Option 1: Truncate to 64 chars (taking rightmost bytes)
        let trimmed = &trimmed[trimmed.len() - 64..];
        // Continue with normal logic...
        
        // Option 2: Return error for invalid addresses
        // return format!("0x{}", trimmed); // or panic/error
    }
    
    // Existing special address check...
    if let Some(last_char) = trimmed.chars().last() {
        if trimmed[..trimmed.len().saturating_sub(1)]
            .chars()
            .all(|c| c == '0')
            && last_char.is_ascii_hexdigit()
            && last_char <= 'f'
        {
            let mut result = String::with_capacity(3);
            result.push_str("0x");
            result.push(last_char);
            return result;
        }
    }
    
    // Safe: trimmed.len() <= 64
    let mut result = String::with_capacity(66);
    result.push_str("0x");
    result.push_str(&ZEROS[..64 - trimmed.len()]);
    result.push_str(trimmed);
    result
}
```

**Alternatively**, validate at protobuf conversion boundaries to reject malformed filters early and provide better error messages to clients.

## Proof of Concept

```rust
#[cfg(test)]
mod vulnerability_poc {
    use super::*;

    #[test]
    #[should_panic(expected = "range end index")]
    fn test_oversized_address_causes_panic() {
        // Create an address with 100 hex characters (exceeds 64 limit)
        let oversized_address = format!("0x{}", "a".repeat(100));
        
        // This will panic due to integer underflow at line 33 of utils.rs
        let _result = standardize_address(&oversized_address);
    }

    #[test]
    fn test_attack_via_user_transaction_filter() {
        use aptos_protos::indexer::v1::UserTransactionFilter as ProtoFilter;
        
        // Attacker crafts protobuf filter with oversized sender
        let malicious_proto = ProtoFilter {
            sender: Some(format!("0x{}", "f".repeat(100))),
            payload_filter: None,
        };
        
        // Conversion will panic when standardize_address is called
        // This demonstrates the attack path from gRPC request to crash
        let _filter: UserTransactionFilter = malicious_proto.into();
    }
}
```

**Compilation Note:** Run with `cargo test --package aptos-transaction-filter` in the workspace root. The first test will panic as expected; the second demonstrates the full attack path through filter conversion.

---

## Notes
This vulnerability is confined to the indexer-grpc data service layer and does not impact core blockchain consensus, execution, or state management. The security question specifically requested analysis of this component, which falls under "API crashes" in the High severity category. However, it should be noted that the primary focus areas (consensus, execution, storage, governance, staking) are not affected by this issue.

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/utils.rs (L10-36)
```rust
pub fn standardize_address(address: &str) -> String {
    // Remove "0x" prefix if it exists
    let trimmed = address.strip_prefix("0x").unwrap_or(address);

    // Check if the address is a special address by seeing if the first 31 bytes are zero and the last byte is smaller than 0b10000
    if let Some(last_char) = trimmed.chars().last() {
        if trimmed[..trimmed.len().saturating_sub(1)]
            .chars()
            .all(|c| c == '0')
            && last_char.is_ascii_hexdigit()
            && last_char <= 'f'
        {
            // Return special addresses in short format
            let mut result = String::with_capacity(3);
            result.push_str("0x");
            result.push(last_char);
            return result;
        }
    }

    // Return non-special addresses in long format
    let mut result = String::with_capacity(66);
    result.push_str("0x");
    result.push_str(&ZEROS[..64 - trimmed.len()]);
    result.push_str(trimmed);
    result
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L40-45)
```rust
        self.standardized_sender.get_or_init(|| {
            self.sender
                .clone()
                .map(|address| standardize_address(&address))
        })
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L48-60)
```rust
impl From<aptos_protos::indexer::v1::UserTransactionFilter> for UserTransactionFilter {
    fn from(proto_filter: aptos_protos::indexer::v1::UserTransactionFilter) -> Self {
        Self {
            standardized_sender: OnceCell::with_value(
                proto_filter
                    .sender
                    .as_ref()
                    .map(|address| standardize_address(address)),
            ),
            sender: proto_filter.sender,
            payload: proto_filter.payload_filter.map(|f| f.into()),
        }
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L146-152)
```rust
    fn get_standardized_address(&self) -> &Option<String> {
        self.standardized_address.get_or_init(|| {
            self.address
                .clone()
                .map(|address| standardize_address(&address))
        })
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/localnet_data_service.rs (L64-71)
```rust
        let filter = if let Some(proto_filter) = r.transaction_filter {
            Some(parse_transaction_filter(
                proto_filter,
                self.service_context.max_transaction_filter_size_bytes,
            )?)
        } else {
            None
        };
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/move_module.rs (L48-61)
```rust
impl From<aptos_protos::indexer::v1::MoveStructTagFilter> for MoveStructTagFilter {
    fn from(proto_filter: aptos_protos::indexer::v1::MoveStructTagFilter) -> Self {
        Self {
            standardized_address: OnceCell::with_value(
                proto_filter
                    .address
                    .as_ref()
                    .map(|address| standardize_address(address)),
            ),
            address: proto_filter.address,
            module: proto_filter.module,
            name: proto_filter.name,
        }
    }
```

**File:** config/src/config/indexer_grpc_config.rs (L15-40)
```rust

// Useful indexer defaults
const DEFAULT_PROCESSOR_BATCH_SIZE: u16 = 1000;
const DEFAULT_OUTPUT_BATCH_SIZE: u16 = 100;
const DEFAULT_TRANSACTION_CHANNEL_SIZE: usize = 35;
pub const DEFAULT_GRPC_STREAM_PORT: u16 = 50051;
const DEFAULT_MAX_TRANSACTION_FILTER_SIZE_BYTES: usize = 10_000;

pub fn get_default_processor_task_count(use_data_service_interface: bool) -> u16 {
    if use_data_service_interface {
        1
    } else {
        20
    }
}

#[derive(Clone, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct IndexerGrpcConfig {
    pub enabled: bool,

    /// If true, the GRPC stream interface exposed by the data service will be used
    /// instead of the standard fullnode GRPC stream interface. In other words, with
    /// this enabled, you can use an indexer fullnode like it is an instance of the
    /// indexer-grpc data service (aka the Transaction Stream Service API).
    pub use_data_service_interface: bool,
```

**File:** protos/proto/aptos/indexer/v1/filter.proto (L33-36)
```text
message UserTransactionFilter {
  optional string sender = 1;
  optional UserTransactionPayloadFilter payload_filter = 2;
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L94-107)
```rust
    pub fn new_from_proto(
        proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
        max_filter_size: Option<usize>,
    ) -> Result<Self> {
        if let Some(max_filter_size) = max_filter_size {
            ensure!(
                proto_filter.encoded_len() <= max_filter_size,
                format!(
                    "Filter is too complicated. Max size: {} bytes, Actual size: {} bytes",
                    max_filter_size,
                    proto_filter.encoded_len()
                )
            );
        }
```
