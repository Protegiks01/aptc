# Audit Report

## Title
Mempool DoS Attack via Malformed Signatures Bypassing Early Validation

## Summary
Attackers can flood validator nodes with transactions containing Ed25519 signatures that pass deserialization (`TryFrom`) but fail cryptographic verification (`verify()`), causing CPU resource exhaustion without paying any gas fees. This exploits the gap between cheap malleability checks during deserialization and expensive signature verification during mempool validation.

## Finding Description

The vulnerability exploits a critical design flaw in the transaction validation pipeline where signature verification occurs after deserialization but before gas metering.

**Attack Path:**

1. **Signature Construction**: An attacker crafts Ed25519 signatures with:
   - Correct length (64 bytes)
   - Valid S component (S < L, passing malleability check)
   - Cryptographically invalid signature (random or intentionally malformed)

2. **Deserialization Phase**: When transactions arrive over the network, the `DeserializeKey` macro deserializes signatures by calling `TryFrom`: [1](#0-0) 

   The `TryFrom` implementation only performs cheap checks: [2](#0-1) 

   This succeeds because the signature has correct length and S < L.

3. **Mempool Validation**: Transactions enter `validate_and_add_transactions()` where they are validated in parallel using `VALIDATION_POOL`: [3](#0-2) 

4. **Expensive Verification**: The VM validator calls `check_signature()` which performs expensive cryptographic verification: [4](#0-3) 

   This calls the expensive `verify_strict()` operation: [5](#0-4) 

5. **No Gas Payment**: When verification fails, the transaction is rejected with `INVALID_SIGNATURE` before any gas meter is created or gas is charged, allowing the attacker to consume validator CPU resources for free.

**Invariant Violation**: This breaks **Resource Limits** (Invariant #9): "All operations must respect gas, storage, and computational limits." Signature verification consumes significant CPU resources without any gas payment or rate limiting beyond network bandwidth.

## Impact Explanation

**Severity: HIGH** (up to $50,000)

This qualifies as **"Validator node slowdowns"** under the High Severity category because:

1. **CPU Exhaustion**: Ed25519 signature verification is computationally expensive, involving elliptic curve operations. An attacker can saturate all threads in the `VALIDATION_POOL`: [6](#0-5) 

2. **No Cost to Attacker**: Invalid signatures are rejected before gas metering, so attackers pay no transaction fees while consuming validator resources.

3. **Network-Wide Impact**: All validators processing transactions from the network are affected, degrading network performance and transaction throughput.

4. **Amplification Factor**: The computational cost of signature verification far exceeds the network bandwidth cost of transmitting the transaction, creating an asymmetric attack.

While network-level rate limiting exists at 100 KiB/s per IP, this provides insufficient protection because:
- An attacker with multiple IPs or a botnet can multiply the attack
- Each transaction (~200-300 bytes) requires expensive verification (~microseconds to milliseconds of CPU time)
- The rate limit is on bytes, not computational cost

## Likelihood Explanation

**Likelihood: HIGH**

1. **Easy to Execute**: 
   - No special privileges required (any network peer can submit transactions)
   - Simple to generate malformed signatures (random S component that passes S < L check)
   - Can be automated and scaled with botnets

2. **Difficult to Detect**:
   - Appears as normal transaction submission
   - Rejected transactions don't enter mempool, reducing visibility
   - Network rate limiting may not trigger if spread across multiple IPs

3. **Immediate Impact**:
   - Each malformed transaction immediately consumes CPU during validation
   - Effect is multiplicative across validator nodes
   - Can quickly degrade network performance

## Recommendation

**Implement pre-validation signature filtering before expensive verification:**

```rust
// In mempool/src/shared_mempool/tasks.rs, before validate_and_add_transactions()

fn quick_reject_invalid_transactions(
    transactions: Vec<(SignedTransaction, Option<u64>, Option<u64>, Option<BroadcastPeerPriority>)>,
    statuses: &mut Vec<(SignedTransaction, (MempoolStatus, Option<StatusCode>))>,
) -> Vec<(SignedTransaction, Option<u64>, Option<u64>, Option<BroadcastPeerPriority>)> {
    // Perform lightweight signature format validation
    // This catches obviously invalid signatures before expensive verification
    transactions.into_iter().filter_map(|(txn, seq, time, priority)| {
        // Add probabilistic early rejection or signature format checks here
        // For example, check if signature has unusual patterns that suggest it's invalid
        Some((txn, seq, time, priority))
    }).collect()
}
```

**Additional mitigations:**

1. **Rate limiting per-account**: Track failed signature verifications per sender address and temporarily ban addresses with excessive failures.

2. **Computational cost-based rate limiting**: Instead of byte-based rate limiting, implement rate limiting based on computational cost (e.g., limit signature verifications per IP per second).

3. **Early signature verification**: Consider verifying signatures during deserialization (accept the performance cost but prevent invalid signatures from entering the pipeline).

4. **Monitoring and alerting**: Add metrics tracking the ratio of failed signature verifications to successful ones, alerting operators to potential attacks.

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[test]
fn test_mempool_dos_via_invalid_signatures() {
    use aptos_crypto::ed25519::{Ed25519PrivateKey, Ed25519Signature};
    use aptos_types::transaction::{SignedTransaction, RawTransaction, TransactionPayload};
    use std::time::Instant;
    
    // Create a valid transaction template
    let private_key = Ed25519PrivateKey::generate_for_testing();
    let public_key = private_key.public_key();
    let raw_txn = RawTransaction::new(
        AccountAddress::random(),
        0,
        TransactionPayload::Script(Script::new(vec![], vec![], vec![])),
        1000,
        0,
        0,
        ChainId::new(1),
    );
    
    // Create malformed signatures that pass TryFrom but fail verify()
    let mut malformed_transactions = vec![];
    for _ in 0..1000 {
        // Create a signature with valid format (S < L) but cryptographically invalid
        let mut sig_bytes = [0u8; 64];
        rand::thread_rng().fill(&mut sig_bytes[..]);
        // Ensure S < L by setting high bit to 0
        sig_bytes[63] &= 0x7F;
        
        let malformed_sig = Ed25519Signature::try_from(&sig_bytes[..]).unwrap();
        let signed_txn = SignedTransaction::new(
            raw_txn.clone(),
            public_key.clone(),
            malformed_sig,
        );
        malformed_transactions.push(signed_txn);
    }
    
    // Measure CPU time consumed by validation
    let start = Instant::now();
    for txn in malformed_transactions {
        // This will consume CPU in check_signature()
        let _ = txn.check_signature();
    }
    let elapsed = start.elapsed();
    
    println!("Time to validate 1000 invalid signatures: {:?}", elapsed);
    // Demonstrates significant CPU consumption without gas payment
    assert!(elapsed.as_millis() > 100); // Verification is expensive
}
```

**Notes:**
- The vulnerability exists in the transaction validation pipeline between deserialization and gas metering
- Network-level rate limiting provides partial but insufficient protection
- The asymmetric cost (cheap to send, expensive to verify) makes this an effective DoS vector
- This is distinct from network-level DoS attacks; it exploits application-level signature verification logic

### Citations

**File:** crates/aptos-crypto-derive/src/lib.rs (L174-177)
```rust
                    let value = Value::deserialize(deserializer)?;
                    #name::try_from(value.0).map_err(|s| {
                        <D::Error as ::serde::de::Error>::custom(format!("{} with {}", s, #name_string))
                    })
```

**File:** crates/aptos-crypto/src/ed25519/ed25519_sigs.rs (L126-139)
```rust
    fn verify_arbitrary_msg(&self, message: &[u8], public_key: &Ed25519PublicKey) -> Result<()> {
        // NOTE: ed25519::PublicKey::verify_strict already checks that the s-component of the signature
        // is not mauled, but does so via an optimistic path which fails into a slower path. By doing
        // our own (much faster) checking here, we can ensure dalek's optimistic path always succeeds
        // and the slow path is never triggered.
        Ed25519Signature::check_s_malleability(&self.to_bytes())?;

        // NOTE: ed25519::PublicKey::verify_strict checks that the signature's R-component and
        // the public key are *not* in a small subgroup.
        public_key
            .0
            .verify_strict(message, &self.0)
            .map_err(|e| anyhow!("{}", e))
            .and(Ok(()))
```

**File:** crates/aptos-crypto/src/ed25519/ed25519_sigs.rs (L168-178)
```rust
impl TryFrom<&[u8]> for Ed25519Signature {
    type Error = CryptoMaterialError;

    fn try_from(bytes: &[u8]) -> std::result::Result<Ed25519Signature, CryptoMaterialError> {
        // We leave this check here to detect mauled signatures earlier, since it does not hurt
        // performance much. (This check is performed again in Ed25519Signature::verify_arbitrary_msg
        // and in ed25519-dalek's verify_strict API.)
        Ed25519Signature::check_s_malleability(bytes)?;
        Ed25519Signature::from_bytes_unchecked(bytes)
    }
}
```

**File:** mempool/src/shared_mempool/tasks.rs (L490-503)
```rust
    let validation_results = VALIDATION_POOL.install(|| {
        transactions
            .par_iter()
            .map(|t| {
                let result = smp.validator.read().validate_transaction(t.0.clone());
                // Pre-compute the hash and length if the transaction is valid, before locking mempool
                if result.is_ok() {
                    t.0.committed_hash();
                    t.0.txn_bytes_len();
                }
                result
            })
            .collect::<Vec<_>>()
    });
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3232-3236)
```rust
        let txn = match transaction.check_signature() {
            Ok(t) => t,
            _ => {
                return VMValidatorResult::error(StatusCode::INVALID_SIGNATURE);
            },
```

**File:** mempool/src/thread_pool.rs (L15-20)
```rust
pub(crate) static VALIDATION_POOL: Lazy<rayon::ThreadPool> = Lazy::new(|| {
    rayon::ThreadPoolBuilder::new()
        .thread_name(|index| format!("mempool_vali_{}", index))
        .build()
        .unwrap()
});
```
