# Audit Report

## Title
State Inconsistency via Race Condition Between reset() and pre_commit_ledger

## Summary
The `StateStore::reset()` function contains a critical race condition that can cause state inconsistency when called concurrently with `pre_commit_ledger()`. The function releases the buffered_state lock between calling `quit()` and recreating the BufferedState, allowing pre-committed but not yet finalized transactions to be lost from the in-memory state while remaining in the database.

## Finding Description

The vulnerability exists in the implementation of `StateStore::reset()`: [1](#0-0) 

This function performs two separate lock acquisitions:
1. First lock: calls `quit()` on the old BufferedState
2. Second lock: replaces the BufferedState with a newly created one

The issue arises from the interaction with the commit flow in `pre_commit_ledger()`: [2](#0-1) 

The pre_commit flow writes data to the database and updates the buffered state, but the `OverallCommitProgress` metadata is only updated later in `commit_ledger()`: [3](#0-2) 

**Race Condition Scenario:**

1. **Thread A (pre_commit)**: Acquires `pre_commit_lock` and writes transactions (versions 101-110) to the database, including state K/V data
2. **Thread A**: Calls `buffered_state.update()` to update in-memory state with versions 101-110
3. **Thread B (reset)**: Calls `reset()`, acquires buffered_state lock, calls `quit()` which drains pending commits
4. **Thread B**: Releases lock after `quit()` completes
5. **Thread B**: Re-acquires lock and calls `create_buffered_state_from_latest_snapshot()`
6. **Critical Issue**: The new BufferedState uses `get_synced_version()` which reads `OverallCommitProgress` from the database: [4](#0-3) 

7. Since Thread A hasn't called `commit_ledger()` yet, `OverallCommitProgress` still shows version 100 (not 110)
8. The new BufferedState replays transactions only up to version 100, missing versions 101-110
9. **Thread A**: Later calls `commit_ledger()` and updates `OverallCommitProgress` to 110

**Result**: The database contains committed data for versions 101-110, `OverallCommitProgress` indicates version 110, but the in-memory BufferedState only contains state up to version 100. This creates a critical state inconsistency.

The coordination between pre_commit and commit uses separate locks: [5](#0-4) [6](#0-5) 

These locks do not coordinate with `reset()`, allowing the race condition to occur.

## Impact Explanation

This is a **Critical Severity** vulnerability based on the following impacts:

1. **Consensus Safety Violation**: Different validators can have different in-memory states for the same committed version, breaking the fundamental invariant that "All validators must produce identical state roots for identical blocks"

2. **State Inconsistency**: The database and in-memory state become permanently desynchronized. Reads may return incorrect values, and subsequent state updates will build on incorrect base state

3. **Non-Deterministic Execution**: Validators experiencing this race will compute different state roots than validators that don't, causing consensus failures

4. **Exploitable During State Sync**: The `reset()` function is called during state synchronization operations (confirmed by examining the call site): [7](#0-6) 

This means the race can occur during normal network operations when validators are catching up or during epoch transitions.

## Likelihood Explanation

**Likelihood: HIGH**

This race condition has a high probability of occurrence because:

1. **State sync is common**: Validators regularly call reset() during state synchronization when catching up with the network
2. **Concurrent commits are expected**: The codebase explicitly allows pre-committing and committing in concurrency (as stated in comments)
3. **No synchronization barrier**: There is no lock or synchronization mechanism preventing `reset()` from being called while `pre_commit_ledger()` is in progress
4. **Timing window is significant**: The window between pre_commit and commit_ledger can be substantial, especially during batch processing

The vulnerability doesn't require attacker control - it can be triggered during normal validator operations, particularly during:
- State sync catch-up operations
- Recovery after temporary disconnection
- Epoch transitions
- State snapshot finalization

## Recommendation

**Fix the race condition by ensuring reset() uses the pre-committed version rather than the overall commit progress:**

```rust
pub fn reset(&self) {
    // Option 1: Use a single atomic operation
    let mut buffered_state_guard = self.buffered_state.lock();
    buffered_state_guard.quit();
    *buffered_state_guard = Self::create_buffered_state_from_latest_snapshot(
        &self.state_db,
        self.buffered_state_target_items,
        false,
        true,
        self.current_state.clone(),
        self.persisted_state.clone(),
        self.hot_state_config,
    )
    .expect("buffered state creation failed.");
    // Lock held throughout, preventing race
}
```

**Alternative approach - use pre-committed version for replay:**

Modify `create_buffered_state_from_latest_snapshot` to use `get_pre_committed_version()` instead of `get_synced_version()`: [8](#0-7) 

This ensures that any pre-committed but not yet finalized transactions are included in the replay.

**Best approach - add proper synchronization:**

Add a new lock that coordinates between pre_commit, commit, and reset operations to ensure they happen in a serialized manner when reset is involved.

## Proof of Concept

```rust
use std::sync::Arc;
use std::thread;
use std::time::Duration;

// Reproduction scenario:
// 1. Thread A starts pre_commit_ledger with transactions 101-110
// 2. Thread A writes to DB and updates buffered state
// 3. Thread B calls reset() before Thread A calls commit_ledger
// 4. Thread B's new BufferedState only replays up to version 100
// 5. Thread A completes commit_ledger, updating OverallCommitProgress to 110
// 6. Result: DB says version 110, but BufferedState has version 100

fn test_reset_race_condition() {
    let db = setup_test_db();
    
    // Thread A: Pre-commit transactions
    let db_clone1 = Arc::clone(&db);
    let handle1 = thread::spawn(move || {
        let chunk = create_test_chunk(101, 110);
        db_clone1.pre_commit_ledger(chunk, false).unwrap();
        // Simulate delay before commit
        thread::sleep(Duration::from_millis(50));
        db_clone1.commit_ledger(110, None, None).unwrap();
    });
    
    // Thread B: Reset during pre-commit
    let db_clone2 = Arc::clone(&db);
    let handle2 = thread::spawn(move || {
        thread::sleep(Duration::from_millis(25)); // Trigger race
        db_clone2.state_store.reset();
    });
    
    handle1.join().unwrap();
    handle2.join().unwrap();
    
    // Verify inconsistency
    let synced_version = db.get_synced_version().unwrap().unwrap();
    let buffered_version = db.state_store.current_state_locked().version().unwrap();
    
    assert_eq!(synced_version, 110); // DB shows 110
    // Bug: buffered_version may be 100, not 110!
    // This demonstrates the state inconsistency
}
```

The test demonstrates that after the race condition, the database's `OverallCommitProgress` shows version 110 while the BufferedState's in-memory state only reflects version 100, creating a 10-version gap in state consistency.

**Notes**

The vulnerability is exacerbated by the fact that `quit()` only ensures that previously enqueued async merkle commits are drained - it doesn't capture uncommitted state updates that exist between `pre_commit_ledger` and `commit_ledger`. The `sync_commit()` call within `quit()` uses `last_checkpoint()` not the `latest` state: [9](#0-8) 

This means any state updates after the last checkpoint but before the next commit_ledger are invisible to the quit() operation, making them vulnerable to being lost during the reset race window.

### Citations

**File:** storage/aptosdb/src/state_store/mod.rs (L561-565)
```rust
        let num_transactions = state_db
            .ledger_db
            .metadata_db()
            .get_synced_version()?
            .map_or(0, |v| v + 1);
```

**File:** storage/aptosdb/src/state_store/mod.rs (L707-719)
```rust
    pub fn reset(&self) {
        self.buffered_state.lock().quit();
        *self.buffered_state.lock() = Self::create_buffered_state_from_latest_snapshot(
            &self.state_db,
            self.buffered_state_target_items,
            false,
            true,
            self.current_state.clone(),
            self.persisted_state.clone(),
            self.hot_state_config,
        )
        .expect("buffered state creation failed.");
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L44-76)
```rust
    fn pre_commit_ledger(&self, chunk: ChunkToCommit, sync_commit: bool) -> Result<()> {
        gauged_api("pre_commit_ledger", || {
            // Pre-committing and committing in concurrency is allowed but not pre-committing at the
            // same time from multiple threads, the same for committing.
            // Consensus and state sync must hand over to each other after all pending execution and
            // committing complete.
            let _lock = self
                .pre_commit_lock
                .try_lock()
                .expect("Concurrent committing detected.");
            let _timer = OTHER_TIMERS_SECONDS.timer_with(&["pre_commit_ledger"]);

            chunk
                .state_summary
                .latest()
                .global_state_summary
                .log_generation("db_save");

            self.pre_commit_validation(&chunk)?;
            let _new_root_hash =
                self.calculate_and_commit_ledger_and_state_kv(&chunk, self.skip_index_and_usage)?;

            let _timer = OTHER_TIMERS_SECONDS.timer_with(&["save_transactions__others"]);

            self.state_store.buffered_state().lock().update(
                chunk.result_ledger_state_with_summary(),
                chunk.estimated_total_state_updates(),
                sync_commit || chunk.is_reconfig,
            )?;

            Ok(())
        })
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L78-112)
```rust
    fn commit_ledger(
        &self,
        version: Version,
        ledger_info_with_sigs: Option<&LedgerInfoWithSignatures>,
        chunk_opt: Option<ChunkToCommit>,
    ) -> Result<()> {
        gauged_api("commit_ledger", || {
            // Pre-committing and committing in concurrency is allowed but not pre-committing at the
            // same time from multiple threads, the same for committing.
            // Consensus and state sync must hand over to each other after all pending execution and
            // committing complete.
            let _lock = self
                .commit_lock
                .try_lock()
                .expect("Concurrent committing detected.");
            let _timer = OTHER_TIMERS_SECONDS.timer_with(&["commit_ledger"]);

            let old_committed_ver = self.get_and_check_commit_range(version)?;

            let mut ledger_batch = SchemaBatch::new();
            // Write down LedgerInfo if provided.
            if let Some(li) = ledger_info_with_sigs {
                self.check_and_put_ledger_info(version, li, &mut ledger_batch)?;
            }
            // Write down commit progress
            ledger_batch.put::<DbMetadataSchema>(
                &DbMetadataKey::OverallCommitProgress,
                &DbMetadataValue::Version(version),
            )?;
            self.ledger_db.metadata_db().write_schemas(ledger_batch)?;

            // Notify the pruners, invoke the indexer, and update in-memory ledger info.
            self.post_commit(old_committed_ver, version, ledger_info_with_sigs, chunk_opt)
        })
    }
```

**File:** consensus/src/state_computer.rs (L165-167)
```rust
        // Similarly, after state synchronization, we have to reset the cache of
        // the BlockExecutor to guarantee the latest committed state is up to date.
        self.executor.reset()?;
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L137-140)
```rust
    fn get_pre_committed_version(&self) -> Result<Option<Version>> {
        gauged_api("get_pre_committed_version", || {
            Ok(self.state_store.current_state_locked().version())
        })
```

**File:** storage/aptosdb/src/state_store/buffered_state.rs (L146-149)
```rust
    pub(crate) fn sync_commit(&mut self) {
        let checkpoint = self.current_state_locked().last_checkpoint().clone();
        self.maybe_commit(Some(checkpoint), true /* sync_commit */);
    }
```
