# Audit Report

## Title
State Persistence Inconsistency Between SafetyData and BlockStore Causes Validator Timeout Signing Failure

## Summary
The `safe_to_timeout()` function can incorrectly reject valid timeouts when `safety_data.one_chain_round` becomes stale relative to `block_store.highest_quorum_cert()` due to inconsistent state persistence between two independent storage backends. This occurs because `guarded_sign_timeout_with_qc()` never calls `observe_qc()` to update `one_chain_round` from the timeout's QC, creating a permanent liveness failure when validators cannot sign timeouts after crashes or restarts.

## Finding Description

The vulnerability exists in the timeout signing flow where two critical state invariants are maintained by separate storage systems:

1. **SafetyData** (containing `one_chain_round`) is persisted via `PersistentSafetyStorage` using SecureStorage backend
2. **BlockStore** (containing blocks and quorum certificates) is persisted via `ConsensusDB`

The core issue is in `guarded_sign_timeout_with_qc()`: [1](#0-0) 

This function calls `safe_to_timeout()` which performs the check: [2](#0-1) 

The check requires: `qc_round >= safety_data.one_chain_round` where `qc_round` comes from `timeout.hqc_round()` which is derived from `block_store.highest_quorum_cert()`.

**Critical Gap:** Unlike `guarded_construct_and_sign_vote_two_chain()` which updates `one_chain_round` via `observe_qc()`: [3](#0-2) 

The timeout signing path NEVER calls `observe_qc()` to update `one_chain_round` from the timeout's QC.

**Exploitation Scenario:**

1. Validator votes on block B20 carrying QC19 (certifying block B19, round 19)
2. `observe_qc(QC19)` updates `one_chain_round = 19` in SafetyData
3. `set_safety_data()` persists to SecureStorage immediately: [4](#0-3) 

4. System crashes before ConsensusDB flushes QC19 to disk (due to write buffering, WAL not flushed, etc.)
5. Upon restart:
   - SafetyData recovers with `one_chain_round = 19`
   - ConsensusDB recovers only up to block B15, so `block_store.highest_quorum_cert()` returns QC15 (round 15)
6. RoundManager constructs timeout with `hqc_round = 15`: [5](#0-4) 

7. SafetyRules check: `15 >= 19` â†’ **FAILS**
8. Validator **cannot sign timeout**
9. Validator is permanently stuck - cannot participate in consensus until manual intervention

**Why This Persists:** The validator cannot self-heal because timeout signing never calls `observe_qc()` to fix the stale `one_chain_round`. The validator remains unable to sign timeouts indefinitely.

## Impact Explanation

**Severity: Medium to High**

This vulnerability causes **liveness failure** in the consensus protocol:

- **Individual Validator Impact:** Affected validator cannot sign timeouts, effectively removing it from consensus participation
- **Network Impact:** If multiple validators (>1/3) hit this state simultaneously (e.g., datacenter power failure, coordinated infrastructure issue), the network **cannot form timeout certificates**, blocking consensus progress
- **Recovery:** Requires manual intervention (database rollback, SafetyData reset) or state sync to resolve

Per Aptos Bug Bounty criteria:
- **High Severity** - "Validator node slowdowns" and "Significant protocol violations" 
- **Medium Severity** - "State inconsistencies requiring intervention"

This qualifies as **Medium** severity with potential for **High** impact if affecting multiple validators, as it requires operator intervention and can cause consensus delays.

## Likelihood Explanation

**Likelihood: Medium**

This vulnerability can occur through natural system failures:

1. **Crash Timing:** Crashes during block voting operations (common in validator infrastructure)
2. **Storage Backend Differences:** SafetyData (SecureStorage) and ConsensusDB have different flush policies:
   - SecureStorage may use immediate fsync for safety-critical data
   - ConsensusDB (RocksDB) may use write-ahead logging with delayed flush for performance
3. **Infrastructure Failures:** Power outages, kernel panics, OOM kills can cause inconsistent persistence
4. **No Validation:** No startup validation checks that `one_chain_round <= highest_quorum_cert.round()`

The vulnerability is **exploitable without attacker intervention** - it's a bug in crash recovery logic that manifests under normal failure scenarios.

## Recommendation

Add `observe_qc()` call in `guarded_sign_timeout_with_qc()` to allow `one_chain_round` to be updated from the timeout's QC, providing self-healing capability:

```rust
pub(crate) fn guarded_sign_timeout_with_qc(
    &mut self,
    timeout: &TwoChainTimeout,
    timeout_cert: Option<&TwoChainTimeoutCertificate>,
) -> Result<bls12381::Signature, Error> {
    self.signer()?;
    let mut safety_data = self.persistent_storage.safety_data()?;
    self.verify_epoch(timeout.epoch(), &safety_data)?;
    if !self.skip_sig_verify {
        timeout
            .verify(&self.epoch_state()?.verifier)
            .map_err(|e| Error::InvalidTimeout(e.to_string()))?;
    }
    if let Some(tc) = timeout_cert {
        self.verify_tc(tc)?;
    }

    // FIX: Observe the QC in the timeout to update one_chain_round
    self.observe_qc(timeout.quorum_cert(), &mut safety_data);
    
    self.safe_to_timeout(timeout, timeout_cert, &safety_data)?;
    if timeout.round() < safety_data.last_voted_round {
        return Err(Error::IncorrectLastVotedRound(
            timeout.round(),
            safety_data.last_voted_round,
        ));
    }
    if timeout.round() > safety_data.last_voted_round {
        self.verify_and_update_last_vote_round(timeout.round(), &mut safety_data)?;
    }
    self.update_highest_timeout_round(timeout, &mut safety_data);
    self.persistent_storage.set_safety_data(safety_data)?;

    let signature = self.sign(&timeout.signing_format())?;
    Ok(signature)
}
```

**Additional Safeguard:** Add startup validation in `start_round_manager()` to detect and repair state inconsistencies:

```rust
// During epoch initialization, after BlockStore creation
let highest_qc_round = block_store.highest_quorum_cert().certified_block().round();
let safety_data = safety_rules.lock().consensus_state()?.safety_data();
if safety_data.one_chain_round > highest_qc_round {
    warn!("Detected stale one_chain_round: {} > highest_qc: {}, resetting", 
          safety_data.one_chain_round, highest_qc_round);
    // Reset one_chain_round to highest_qc_round
    // This prevents timeout signing failures after crash recovery
}
```

## Proof of Concept

```rust
// Test demonstrating the vulnerability
// Place in: consensus/safety-rules/src/tests/suite.rs

#[test]
fn test_stale_one_chain_round_blocks_timeout() {
    // Setup: Create validator with safety rules
    let (mut safety_rules, mut test_data) = test_setup();
    
    // Step 1: Vote on block B20 with QC19 (round 19)
    let block_20 = test_data.new_proposal(20, 19); // round 20, qc_round 19
    let vote = safety_rules
        .construct_and_sign_vote_two_chain(&block_20.vote_proposal(), None)
        .expect("Should vote successfully");
    
    // Verify one_chain_round was updated to 19
    let safety_data = safety_rules.consensus_state().unwrap().safety_data();
    assert_eq!(safety_data.one_chain_round, 19);
    
    // Step 2: Simulate crash and recovery where ConsensusDB lost QC19
    // Recreate safety_rules with same persistent storage but lower QC
    drop(safety_rules);
    let (mut safety_rules_recovered, _) = test_setup_with_safety_data(safety_data);
    
    // Step 3: Try to sign timeout with hqc_round = 15 (from recovered block_store)
    let qc_15 = test_data.new_qc(15); // QC for round 15
    let timeout = TwoChainTimeout::new(1, 16, qc_15); // round 16, hqc_round 15
    
    // Step 4: Timeout signing should fail because 15 < 19
    let result = safety_rules_recovered.sign_timeout_with_qc(&timeout, None);
    
    // BUG: This fails with NotSafeToTimeout error
    match result {
        Err(Error::NotSafeToTimeout(round, qc_round, _, one_chain)) => {
            assert_eq!(qc_round, 15);
            assert_eq!(one_chain, 19);
            // Validator is stuck - cannot sign timeouts!
            println!("VULNERABILITY CONFIRMED: Timeout rejected due to stale one_chain_round");
            println!("qc_round: {}, one_chain_round: {}", qc_round, one_chain);
        }
        _ => panic!("Expected NotSafeToTimeout error"),
    }
}
```

## Notes

This vulnerability demonstrates a critical gap in the consensus safety rules where the timeout signing path lacks the self-healing mechanism (`observe_qc`) present in the voting path. The root cause is the architectural decision to persist SafetyData and BlockStore state in separate storage backends without transactional consistency guarantees. The fix is straightforward: add `observe_qc()` call in timeout signing to mirror the voting path's behavior, allowing validators to recover from transient state inconsistencies.

### Citations

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L19-51)
```rust
    pub(crate) fn guarded_sign_timeout_with_qc(
        &mut self,
        timeout: &TwoChainTimeout,
        timeout_cert: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;
        let mut safety_data = self.persistent_storage.safety_data()?;
        self.verify_epoch(timeout.epoch(), &safety_data)?;
        if !self.skip_sig_verify {
            timeout
                .verify(&self.epoch_state()?.verifier)
                .map_err(|e| Error::InvalidTimeout(e.to_string()))?;
        }
        if let Some(tc) = timeout_cert {
            self.verify_tc(tc)?;
        }

        self.safe_to_timeout(timeout, timeout_cert, &safety_data)?;
        if timeout.round() < safety_data.last_voted_round {
            return Err(Error::IncorrectLastVotedRound(
                timeout.round(),
                safety_data.last_voted_round,
            ));
        }
        if timeout.round() > safety_data.last_voted_round {
            self.verify_and_update_last_vote_round(timeout.round(), &mut safety_data)?;
        }
        self.update_highest_timeout_round(timeout, &mut safety_data);
        self.persistent_storage.set_safety_data(safety_data)?;

        let signature = self.sign(&timeout.signing_format())?;
        Ok(signature)
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L84-84)
```rust
        self.observe_qc(proposed_block.quorum_cert(), &mut safety_data);
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L124-145)
```rust
    fn safe_to_timeout(
        &self,
        timeout: &TwoChainTimeout,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
        safety_data: &SafetyData,
    ) -> Result<(), Error> {
        let round = timeout.round();
        let qc_round = timeout.hqc_round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        if (round == next_round(qc_round)? || round == next_round(tc_round)?)
            && qc_round >= safety_data.one_chain_round
        {
            Ok(())
        } else {
            Err(Error::NotSafeToTimeout(
                round,
                qc_round,
                tc_round,
                safety_data.one_chain_round,
            ))
        }
    }
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L150-170)
```rust
    pub fn set_safety_data(&mut self, data: SafetyData) -> Result<(), Error> {
        let _timer = counters::start_timer("set", SAFETY_DATA);
        counters::set_state(counters::EPOCH, data.epoch as i64);
        counters::set_state(counters::LAST_VOTED_ROUND, data.last_voted_round as i64);
        counters::set_state(
            counters::HIGHEST_TIMEOUT_ROUND,
            data.highest_timeout_round as i64,
        );
        counters::set_state(counters::PREFERRED_ROUND, data.preferred_round as i64);

        match self.internal_store.set(SAFETY_DATA, data.clone()) {
            Ok(_) => {
                self.cached_safety_data = Some(data);
                Ok(())
            },
            Err(error) => {
                self.cached_safety_data = None;
                Err(Error::SecureStorageUnexpectedError(error.to_string()))
            },
        }
    }
```

**File:** consensus/src/round_manager.rs (L1009-1021)
```rust
                let timeout = TwoChainTimeout::new(
                    self.epoch_state.epoch,
                    round,
                    self.block_store.highest_quorum_cert().as_ref().clone(),
                );
                let signature = self
                    .safety_rules
                    .lock()
                    .sign_timeout_with_qc(
                        &timeout,
                        self.block_store.highest_2chain_timeout_cert().as_deref(),
                    )
                    .context("[RoundManager] SafetyRules signs 2-chain timeout")?;
```
