# Audit Report

## Title
JWK Consensus Version Validation Bypass Leading to State Corruption and Denial of Service

## Summary
The JWK consensus manager (both per-key and per-issuer modes) accepts quorum-certified updates without validating that the QC's version matches the expected version in the current consensus state. This allows stale QCs with old versions to be accepted during race conditions, causing permanent state corruption and denial of service for specific JWK updates.

## Finding Description

The vulnerability exists in the `process_quorum_certified_update` function which processes quorum-certified JWK updates. The function accepts any QC for a given session key (issuer, kid) as long as the consensus state is `InProgress`, without validating that the QC's version matches the state's expected version. [1](#0-0) 

The session key is defined without version information: [2](#0-1) [3](#0-2) 

When on-chain state updates, the `reset_with_on_chain_state` function clears states for affected issuers: [4](#0-3) 

**Attack Scenario:**

1. Validator observes JWK update for KID1, creates `KeyLevelUpdate` with `base_version=10` (will produce QC with version=11)
2. Reliable broadcast starts for session key `(Issuer, KID1)`
3. Concurrently, another key KID2 gets updated, advancing on-chain issuer version to 11
4. `reset_with_on_chain_state` is called, clearing the KID1 state and attempting to abort the broadcast
5. Due to race condition, the old broadcast completes before abort takes effect, producing QC with version=11
6. Observer detects KID1 update again, starts NEW consensus with `base_version=11` (will produce version=12)
7. Old QC arrives via `qc_update_rx` channel
8. Manager checks state for `(Issuer, KID1)` - finds `InProgress` (from new consensus)
9. **Manager accepts old QC without validating base_version** - stores QC with version=11 when expecting version=12
10. Transaction is submitted with version=11 but on-chain version is already 11
11. VM rejects transaction because `on_chain.version (11) + 1 != observed.version (11)` [5](#0-4) 

12. Manager's state is now `Finished` with wrong QC, blocking future updates

The same vulnerability exists in per-issuer mode: [6](#0-5) 

## Impact Explanation

This vulnerability meets **Medium Severity** criteria per Aptos bug bounty program: "State inconsistencies requiring intervention".

**Specific Impacts:**

1. **Permanent Denial of Service**: Once the manager accepts a stale QC, the consensus state becomes `Finished` for that key. The `maybe_start_consensus` function won't restart because it checks if consensus is already done: [7](#0-6) 

2. **State Consistency Violation**: The manager's internal state diverges from on-chain reality - it believes consensus succeeded when the transaction actually failed.

3. **No Recovery Mechanism**: The system has no automatic way to detect and recover from this condition. Manual intervention would be required.

4. **Breaks Critical Invariant**: Violates invariant #4 "State Consistency: State transitions must be atomic and verifiable" - the manager's state transition to `Finished` doesn't match the actual on-chain outcome.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability occurs naturally due to race conditions in concurrent operations:

1. **Natural Occurrence**: No malicious behavior required - normal timing variations between JWK observations, on-chain updates, and state resets can trigger this
2. **Multiple Keys Per Issuer**: Systems with multiple keys per issuer increase probability (each key update affects all other keys' consensus sessions for that issuer)
3. **Malicious Amplification**: A malicious validator can deliberately trigger this by timing their JWK observations and reliable broadcast completions
4. **No Rate Limiting**: There's no mechanism preventing rapid successive updates that increase race condition probability

The race window exists between:
- State reset clearing old consensus (T3)
- New consensus starting (T4)  
- Old QC arriving (T7)

## Recommendation

Add version validation in `process_quorum_certified_update` to ensure the received QC matches the expected version from the current consensus state:

```rust
pub fn process_quorum_certified_update(
    &mut self,
    issuer_level_repr: QuorumCertifiedUpdate,
) -> Result<()> {
    let key_level_update =
        KeyLevelUpdate::try_from_issuer_level_repr(&issuer_level_repr.update)
            .context("process_quorum_certified_update failed with repr err")?;
    let issuer = &key_level_update.issuer;
    let kid = &key_level_update.kid;
    
    let state = self
        .states_by_key
        .entry((issuer.clone(), kid.clone()))
        .or_default();
        
    match state {
        ConsensusState::InProgress { my_proposal, .. } => {
            // ADD VERSION VALIDATION HERE
            if key_level_update.base_version != my_proposal.observed.base_version {
                return Err(anyhow!(
                    "QC version mismatch: received base_version={}, expected base_version={}",
                    key_level_update.base_version,
                    my_proposal.observed.base_version
                ));
            }
            
            // Proceed with acceptance only if versions match
            let topic = Topic::JWK_CONSENSUS_PER_KEY_MODE {
                issuer: issuer.clone(),
                kid: kid.clone(),
            };
            // ... rest of function
        },
        _ => Err(anyhow!(...)),
    }
}
```

Apply the same fix to the per-issuer mode in `crates/aptos-jwk-consensus/src/jwk_manager/mod.rs`.

## Proof of Concept

```rust
#[tokio::test]
async fn test_stale_qc_acceptance_vulnerability() {
    // Setup: Create manager with on-chain version=10 for issuer
    let mut manager = create_test_manager();
    let issuer = b"test_issuer".to_vec();
    let kid1 = b"key1".to_vec();
    
    // Step 1: Observer detects update for KID1, starts consensus with base_version=10
    let update_v10 = KeyLevelUpdate {
        issuer: issuer.clone(),
        base_version: 10,
        kid: kid1.clone(),
        to_upsert: Some(test_jwk()),
    };
    manager.maybe_start_consensus(update_v10.clone()).unwrap();
    
    // Step 2: Simulate concurrent update advancing on-chain version to 11
    let new_onchain_state = create_state_with_version(&issuer, 11);
    manager.reset_with_on_chain_state(new_onchain_state).unwrap();
    
    // Step 3: Observer starts NEW consensus with base_version=11
    let update_v11 = KeyLevelUpdate {
        issuer: issuer.clone(),
        base_version: 11,
        kid: kid1.clone(),
        to_upsert: Some(test_jwk()),
    };
    manager.maybe_start_consensus(update_v11.clone()).unwrap();
    
    // Step 4: Simulate old QC arriving (base_version=10, version=11)
    let stale_qc = create_qc_from_update(&update_v10);
    
    // VULNERABILITY: Manager accepts stale QC without version validation
    let result = manager.process_quorum_certified_update(stale_qc);
    assert!(result.is_ok()); // BUG: Should reject but accepts!
    
    // Step 5: Verify state is corrupted
    let state = manager.states_by_key.get(&(issuer, kid1)).unwrap();
    match state {
        ConsensusState::Finished { quorum_certified, .. } => {
            // State shows Finished with wrong version (11 instead of 12)
            assert_eq!(quorum_certified.update.version, 11);
            // But expected version is 12 (base_version=11 + 1)
        },
        _ => panic!("State should be Finished"),
    }
    
    // Step 6: Demonstrate DoS - no new consensus will start
    let result = manager.maybe_start_consensus(update_v11);
    // Won't start because state is already Finished
    assert!(result.is_ok()); // Returns early, doesn't start new consensus
}
```

## Notes

While the VM's version check prevents actual on-chain state rollback, the vulnerability still causes critical state corruption in the consensus manager layer. This represents a **defense-in-depth failure** - the consensus layer should not accept invalid QCs and rely solely on VM validation to catch the error. The corrupted state prevents future legitimate updates from proceeding, effectively creating a permanent DoS condition for affected JWK keys.

### Citations

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L179-194)
```rust
    fn maybe_start_consensus(&mut self, update: KeyLevelUpdate) -> Result<()> {
        let consensus_already_started = match self
            .states_by_key
            .get(&(update.issuer.clone(), update.kid.clone()))
            .cloned()
        {
            Some(ConsensusState::InProgress { my_proposal, .. })
            | Some(ConsensusState::Finished { my_proposal, .. }) => {
                my_proposal.observed.to_upsert == update.to_upsert
            },
            _ => false,
        };

        if consensus_already_started {
            return Ok(());
        }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L233-263)
```rust
    /// Invoked on start, or on on-chain JWK updated event.
    pub fn reset_with_on_chain_state(&mut self, on_chain_state: AllProvidersJWKs) -> Result<()> {
        info!(
            epoch = self.epoch_state.epoch,
            "reset_with_on_chain_state starting."
        );

        let new_onchain_jwks = on_chain_state.indexed().context(
            "KeyLevelJWKManager::reset_with_on_chain_state failed at onchain state indexing",
        )?;
        // for an existing state entry (iss, kid) -> state, discard it unless `new_onchain_jwks[iss].version == self.onchain_jwks[iss].version`.
        self.states_by_key.retain(|(issuer, _), _| {
            new_onchain_jwks
                .get(issuer)
                .map(|jwks| jwks.version)
                .unwrap_or_default()
                == self
                    .onchain_jwks
                    .get(issuer)
                    .map(|jwks| jwks.version)
                    .unwrap_or_default()
        });

        self.onchain_jwks = new_onchain_jwks;

        info!(
            epoch = self.epoch_state.epoch,
            "reset_with_on_chain_state finished."
        );
        Ok(())
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L312-362)
```rust
    pub fn process_quorum_certified_update(
        &mut self,
        issuer_level_repr: QuorumCertifiedUpdate,
    ) -> Result<()> {
        let key_level_update =
            KeyLevelUpdate::try_from_issuer_level_repr(&issuer_level_repr.update)
                .context("process_quorum_certified_update failed with repr err")?;
        let issuer = &key_level_update.issuer;
        let issuer_str = String::from_utf8(issuer.clone()).ok();
        let kid = &key_level_update.kid;
        let kid_str = String::from_utf8(kid.clone()).ok();
        info!(
            epoch = self.epoch_state.epoch,
            issuer = issuer_str,
            kid = kid_str,
            base_version = key_level_update.base_version,
            "KeyLevelJWKManager processing certified key-level update."
        );
        let state = self
            .states_by_key
            .entry((issuer.clone(), kid.clone()))
            .or_default();
        match state {
            ConsensusState::InProgress { my_proposal, .. } => {
                let topic = Topic::JWK_CONSENSUS_PER_KEY_MODE {
                    issuer: issuer.clone(),
                    kid: kid.clone(),
                };
                let txn = ValidatorTransaction::ObservedJWKUpdate(issuer_level_repr.clone());
                let vtxn_guard = self.vtxn_pool.put(topic, Arc::new(txn), None);
                *state = ConsensusState::Finished {
                    vtxn_guard,
                    my_proposal: my_proposal.clone(),
                    quorum_certified: issuer_level_repr,
                };
                info!(
                    epoch = self.epoch_state.epoch,
                    issuer = issuer_str,
                    kid = kid_str,
                    base_version = key_level_update.base_version,
                    "certified key-level update accepted."
                );
                Ok(())
            },
            _ => Err(anyhow!(
                "qc update not expected for issuer {:?} in state {}",
                String::from_utf8(issuer.clone()),
                state.name()
            )),
        }
    }
```

**File:** crates/aptos-jwk-consensus/src/mode/per_key.rs (L32-40)
```rust
    fn new_rb_request(
        epoch: u64,
        payload: &ProviderJWKs,
    ) -> anyhow::Result<ObservedKeyLevelUpdateRequest> {
        let KeyLevelUpdate { issuer, kid, .. } =
            KeyLevelUpdate::try_from_issuer_level_repr(payload)
                .context("new_rb_request failed with repr translation")?;
        Ok(ObservedKeyLevelUpdateRequest { epoch, issuer, kid })
    }
```

**File:** crates/aptos-jwk-consensus/src/mode/per_key.rs (L59-64)
```rust
    fn session_key_from_qc(qc: &QuorumCertifiedUpdate) -> anyhow::Result<(Issuer, KID)> {
        let KeyLevelUpdate { issuer, kid, .. } =
            KeyLevelUpdate::try_from_issuer_level_repr(&qc.update)
                .context("session_key_from_qc failed with repr translation")?;
        Ok((issuer, kid))
    }
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L127-130)
```rust
        // Check version.
        if on_chain.version + 1 != observed.version {
            return Err(Expected(IncorrectVersion));
        }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L323-358)
```rust
    pub fn process_quorum_certified_update(&mut self, update: QuorumCertifiedUpdate) -> Result<()> {
        let issuer = update.update.issuer.clone();
        info!(
            epoch = self.epoch_state.epoch,
            issuer = String::from_utf8(issuer.clone()).ok(),
            version = update.update.version,
            "JWKManager processing certified update."
        );
        let state = self.states_by_issuer.entry(issuer.clone()).or_default();
        match &state.consensus_state {
            ConsensusState::InProgress { my_proposal, .. } => {
                //TODO: counters
                let txn = ValidatorTransaction::ObservedJWKUpdate(update.clone());
                let vtxn_guard =
                    self.vtxn_pool
                        .put(Topic::JWK_CONSENSUS(issuer.clone()), Arc::new(txn), None);
                state.consensus_state = ConsensusState::Finished {
                    vtxn_guard,
                    my_proposal: my_proposal.clone(),
                    quorum_certified: update.clone(),
                };
                info!(
                    epoch = self.epoch_state.epoch,
                    issuer = String::from_utf8(issuer).ok(),
                    version = update.update.version,
                    "certified update accepted."
                );
                Ok(())
            },
            _ => Err(anyhow!(
                "qc update not expected for issuer {:?} in state {}",
                String::from_utf8(issuer.clone()),
                state.consensus_state.name()
            )),
        }
    }
```
