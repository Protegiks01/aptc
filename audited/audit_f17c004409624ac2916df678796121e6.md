# Audit Report

## Title
Non-Deterministic JWK Sorting Causing Consensus Failure via UnsupportedJWK ID Generation

## Summary
The JWK consensus mechanism uses non-canonical JSON serialization to generate IDs for `UnsupportedJWK` objects, leading to different validators producing different sort orders for the same logical JWK set. This breaks the deterministic execution invariant and can cause consensus failure.

## Finding Description

The vulnerability exists in the `UnsupportedJWK` ID generation mechanism. When validators fetch JWKs from OIDC providers and encounter unsupported JWK types, they create `UnsupportedJWK` objects whose IDs are computed by hashing the JSON string representation. [1](#0-0) 

The critical issue is that `json_value.to_string()` does NOT produce canonical output. While `serde_json` preserves field order from parsing, different validators may receive JSON responses with different key orderings from:
- Load balancers routing to different backend servers
- CDN caches with different serialization
- Provider infrastructure changes during observation window

The JWK consensus flow is:

1. Validators fetch JWKs from OIDC providers [2](#0-1) 

2. JWKs are converted, with unsupported types becoming `UnsupportedJWK` [3](#0-2) 

3. JWKs are sorted by ID using `Ord::cmp()` [4](#0-3) [5](#0-4) 

4. The sorted list is stored on-chain and becomes part of consensus state [6](#0-5) 

5. Validators sign the BCS-encoded `ProviderJWKs` containing sorted JWKs [7](#0-6) 

**Attack Scenario:**
- Provider introduces new EdDSA JWK (not yet supported by Aptos)
- Validator A receives: `{"kty":"OKP","crv":"Ed25519","x":"...","kid":"key1"}`
- Validator B receives: `{"kid":"key1","kty":"OKP","crv":"Ed25519","x":"..."}`
- Different `to_string()` outputs → different SHA3-256 hashes → different IDs
- When sorted with other JWKs, different positions in array
- Different BCS encodings → different signatures → quorum fails
- Consensus blocked on JWK updates

The developers acknowledged this issue with the TODO comment but never implemented canonical serialization.

## Impact Explanation

**Critical Severity** - This is a consensus safety violation:

1. **Consensus Failure**: Different validators produce different state roots for identical logical states, violating the fundamental "Deterministic Execution" invariant.

2. **Network Partition Risk**: If validators cannot agree on JWK state, they sign different messages and fail to reach quorum, potentially halting JWK consensus indefinitely.

3. **Keyless Authentication Disruption**: JWK updates become impossible, breaking keyless transaction authentication for affected providers.

4. **Requires Hardfork Recovery**: If consensus fails on critical provider JWKs, manual intervention or hardfork may be needed to restore service.

This meets **Critical Severity** criteria: "Consensus/Safety violations" and potentially "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**High Likelihood** in production:

1. **UnsupportedJWK Usage**: When providers adopt new cryptographic standards (EdDSA, post-quantum algorithms), these initially appear as `UnsupportedJWK` until Aptos adds support.

2. **Common JSON Non-Determinism**: JSON serialization commonly produces different key orders across:
   - Different programming languages/libraries
   - Load balancer backends
   - Cache layers
   - Geographic regions

3. **Federated Keyless**: With federated keyless accounts (AIP-96), any dapp owner can deploy OIDC providers that may have non-deterministic serialization.

4. **No Attacker Privilege Required**: This can happen accidentally or be triggered by any OIDC provider, not requiring validator compromise.

## Recommendation

Implement canonical JSON serialization before hashing. Use a deterministic JSON canonicalization scheme:

```rust
impl From<serde_json::Value> for UnsupportedJWK {
    fn from(json_value: serde_json::Value) -> Self {
        // Use canonical JSON serialization (RFC 8785 JCS)
        let payload = canonical_json_serialize(&json_value);
        Self {
            id: HashValue::sha3_256_of(payload.as_slice()).to_vec(),
            payload,
        }
    }
}

fn canonical_json_serialize(value: &serde_json::Value) -> Vec<u8> {
    // Implement canonical JSON per RFC 8785:
    // 1. Sort all object keys lexicographically
    // 2. Remove whitespace
    // 3. Use consistent number formatting
    // 4. Use consistent unicode escaping
    match value {
        serde_json::Value::Object(map) => {
            let mut sorted_keys: Vec<_> = map.keys().collect();
            sorted_keys.sort();
            let mut result = String::from("{");
            for (i, key) in sorted_keys.iter().enumerate() {
                if i > 0 { result.push(','); }
                result.push_str(&format!("\"{}\":", key));
                let val_bytes = canonical_json_serialize(&map[*key]);
                result.push_str(&String::from_utf8(val_bytes).unwrap());
            }
            result.push('}');
            result.into_bytes()
        },
        // Handle other types...
        _ => value.to_string().into_bytes()
    }
}
```

Alternatively, use BCS encoding directly instead of JSON:
```rust
impl From<serde_json::Value> for UnsupportedJWK {
    fn from(json_value: serde_json::Value) -> Self {
        // Use BCS encoding which is deterministic
        let payload = bcs::to_bytes(&json_value).unwrap();
        Self {
            id: HashValue::sha3_256_of(payload.as_slice()).to_vec(),
            payload,
        }
    }
}
```

## Proof of Concept

```rust
#[test]
fn test_unsupported_jwk_non_deterministic_sorting() {
    use aptos_types::jwks::{jwk::JWK, unsupported::UnsupportedJWK};
    use serde_json::json;

    // Same logical JWK, different field orders
    let json_order1 = json!({"kty":"OKP","crv":"Ed25519","x":"base64data","kid":"key1"});
    let json_order2 = json!({"kid":"key1","kty":"OKP","crv":"Ed25519","x":"base64data"});

    // Convert to JWKs
    let jwk1 = JWK::from(json_order1);
    let jwk2 = JWK::from(json_order2);

    // Get IDs
    let id1 = jwk1.id();
    let id2 = jwk2.id();

    // VULNERABILITY: IDs differ despite identical semantic content
    assert_ne!(id1, id2, "IDs should differ due to non-canonical serialization");

    // Create a JWK set with another key
    let other_key = JWK::from(json!({"kid":"key0","kty":"OKP"}));
    
    // Validator A's sort order
    let mut jwks_a = vec![other_key.clone(), jwk1];
    jwks_a.sort();
    
    // Validator B's sort order  
    let mut jwks_b = vec![other_key, jwk2];
    jwks_b.sort();

    // CONSENSUS BREAK: Different sort orders despite same logical state
    assert_ne!(
        jwks_a.iter().map(|j| j.id()).collect::<Vec<_>>(),
        jwks_b.iter().map(|j| j.id()).collect::<Vec<_>>(),
        "Different validators produce different sort orders"
    );

    println!("Validator A IDs: {:?}", jwks_a.iter().map(|j| hex::encode(j.id())).collect::<Vec<_>>());
    println!("Validator B IDs: {:?}", jwks_b.iter().map(|j| hex::encode(j.id())).collect::<Vec<_>>());
}
```

This test demonstrates that two validators receiving the same JWK data with different JSON field orderings will produce different sorted lists, breaking consensus determinism.

## Notes

The TODO comment in the source code explicitly acknowledges this issue, indicating the developers were aware of the need for canonical serialization but never implemented it. This vulnerability becomes exploitable whenever UnsupportedJWKs appear in practice, which is likely as cryptographic standards evolve and new JWK types are introduced before Aptos adds support for them.

### Citations

**File:** types/src/jwks/unsupported/mod.rs (L51-59)
```rust
impl From<serde_json::Value> for UnsupportedJWK {
    fn from(json_value: serde_json::Value) -> Self {
        let payload = json_value.to_string().into_bytes(); //TODO: canonical to_string.
        Self {
            id: HashValue::sha3_256_of(payload.as_slice()).to_vec(),
            payload,
        }
    }
}
```

**File:** crates/aptos-jwk-consensus/src/jwk_observer.rs (L77-80)
```rust
                    if let Ok(mut jwks) = result {
                        OBSERVATION_SECONDS.with_label_values(&[issuer.as_str(), "ok"]).observe(secs);
                        jwks.sort();
                        let _ = observation_tx.push((), (issuer.as_bytes().to_vec(), jwks));
```

**File:** crates/aptos-jwk-consensus/src/jwk_observer.rs (L102-110)
```rust
async fn fetch_jwks(open_id_config_url: &str, my_addr: Option<AccountAddress>) -> Result<Vec<JWK>> {
    let jwks_uri = fetch_jwks_uri_from_openid_config(open_id_config_url)
        .await
        .map_err(|e| anyhow!("fetch_jwks failed with open-id config request: {e}"))?;
    let jwks = fetch_jwks_from_jwks_uri(my_addr, jwks_uri.as_str())
        .await
        .map_err(|e| anyhow!("fetch_jwks failed with jwks uri request: {e}"))?;
    Ok(jwks)
}
```

**File:** types/src/jwks/jwk/mod.rs (L74-78)
```rust
impl Ord for JWK {
    fn cmp(&self, other: &Self) -> Ordering {
        self.id().cmp(&other.id())
    }
}
```

**File:** types/src/jwks/jwk/mod.rs (L80-90)
```rust
impl From<serde_json::Value> for JWK {
    fn from(value: serde_json::Value) -> Self {
        match RSA_JWK::try_from(&value) {
            Ok(rsa) => Self::RSA(rsa),
            Err(_) => {
                let unsupported = UnsupportedJWK::from(value);
                Self::Unsupported(unsupported)
            },
        }
    }
}
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L626-654)
```text
    fun upsert_jwk(set: &mut ProviderJWKs, jwk: JWK): Option<JWK> {
        let found = false;
        let index = 0;
        let num_entries = vector::length(&set.jwks);
        while (index < num_entries) {
            let cur_entry = vector::borrow(&set.jwks, index);
            let comparison = compare_u8_vector(get_jwk_id(&jwk), get_jwk_id(cur_entry));
            if (is_greater_than(&comparison)) {
                index = index + 1;
            } else {
                found = is_equal(&comparison);
                break
            }
        };

        // Now if `found == true`, `index` points to the JWK we want to update/remove; otherwise, `index` points to
        // where we want to insert.
        let ret = if (found) {
            let entry = vector::borrow_mut(&mut set.jwks, index);
            let old_entry = option::some(*entry);
            *entry = jwk;
            old_entry
        } else {
            vector::insert(&mut set.jwks, index, jwk);
            option::none()
        };

        ret
    }
```

**File:** types/src/jwks/mod.rs (L122-128)
```rust
#[derive(Clone, Default, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
pub struct ProviderJWKs {
    #[serde(with = "serde_bytes")]
    pub issuer: Issuer,
    pub version: u64,
    pub jwks: Vec<JWKMoveStruct>,
}
```
