# Audit Report

## Title
Time-of-Check-Time-of-Use Race Condition in State Sync Epoch State Retrieval Causing Verification Failures

## Summary
The `get_highest_synced_version_and_epoch()` function in the continuous syncer performs two non-atomic storage reads that can become inconsistent during concurrent commits, particularly during epoch transitions. This TOCTOU race condition causes the node to initialize its speculative stream state with mismatched version-epoch pairs, leading to signature verification failures and state sync disruptions.

## Finding Description

The vulnerability exists in the `get_highest_synced_version_and_epoch()` function which reads storage state from two separate, non-atomic operations: [1](#0-0) 

These two reads access different storage components:
1. `fetch_pre_committed_version()` reads from `state_store.current_state_locked()`: [2](#0-1) 

2. `fetch_latest_epoch_state()` reads from `ledger_db.metadata_db()`: [3](#0-2) 

These storage components are updated separately by the commit process:
- `pre_commit_ledger` updates the state_store at: [4](#0-3) 
- `commit_ledger` updates the ledger_db at: [5](#0-4) 

The code explicitly allows concurrent pre-committing and committing: [6](#0-5) 

**Race Condition Scenario:**
1. Node has synced to version V (last transaction of epoch E1)
2. Thread A (continuous syncer) reads `version = V` from state_store
3. Thread B (consensus) commits transactions crossing into epoch E2, updating both state_store and ledger_db
4. Thread A reads `epoch = E2` from ledger_db
5. Result: version V (from epoch E1) paired with epoch E2

The mismatched pair is then used to initialize the SpeculativeStreamState: [7](#0-6) 

When the syncer receives ledger infos for transactions in the actual epoch (E1), but tries to verify them with epoch E2's validator set, verification fails due to epoch mismatch: [8](#0-7) 

This causes stream reset and verification error: [9](#0-8) 

## Impact Explanation

This vulnerability causes **state sync liveness failures** during epoch transitions. When the race condition occurs:

1. The node cannot verify incoming ledger infos due to validator set mismatch
2. The data stream repeatedly resets with verification errors
3. Under continuous commit activity during epoch boundaries, the race can recur on retry
4. The node experiences temporary inability to sync, requiring eventual timeout or manual intervention

While this doesn't cause consensus violations or fund loss, it creates **state inconsistencies requiring intervention**, qualifying as **Medium Severity** per Aptos bug bounty criteria. In extreme cases during busy epoch transitions, this could contribute to network-wide sync disruption if multiple nodes encounter the issue simultaneously.

## Likelihood Explanation

**Likelihood: LOW**

The race window is extremely narrow (nanoseconds between two memory reads), and exploitation requires:
- An epoch transition commit occurring during the race window
- Epoch changes happen infrequently (every few hours typically)
- Precise timing that cannot be controlled by external attackers

However, during periods of high transaction volume around epoch boundaries, the probability increases. Modern multi-core systems with concurrent consensus and state sync threads make this race theoretically possible, though rare in practice.

## Recommendation

Implement atomic read of both version and epoch from storage. Add a new DbReader method that returns both values in a single transaction-consistent read:

```rust
// In storage-interface/src/lib.rs
fn get_pre_committed_version_and_epoch(&self) -> Result<(Version, u64)> {
    // Implementation should read both from same consistent snapshot
    let version = self.ensure_pre_committed_version()?;
    let epoch_state = self.get_latest_epoch_state()?;
    Ok((version, epoch_state.epoch))
}

// In continuous_syncer.rs
fn get_highest_synced_version_and_epoch(&self) -> Result<(Version, Epoch), Error> {
    self.storage
        .get_pre_committed_version_and_epoch()
        .map_err(|e| Error::StorageError(format!(
            "Failed to get version and epoch: {:?}", e
        )))
}
```

The implementation should acquire a single read lock/snapshot that covers both reads to ensure atomicity.

## Proof of Concept

Due to the timing-dependent nature of this race condition, a deterministic PoC is not feasible. However, the issue can be observed through stress testing:

```rust
// Stress test setup (conceptual - would need integration test framework)
// 1. Start node in state sync mode at end of an epoch
// 2. Have consensus rapidly commit blocks crossing epoch boundary
// 3. Monitor for "LedgerInfo has unexpected epoch" errors in logs
// 4. Expected: Occasional verification failures during epoch transition
// 5. Stream resets observable via continuous_syncer error metrics
```

The vulnerability manifests as warning logs: "LedgerInfo has unexpected epoch X, expected Y" during epoch transitions, accompanied by stream resets and increased `CONTINUOUS_SYNCER_ERRORS` metric count.

---

**Notes:**

This is a classic TOCTOU (Time-of-Check-Time-of-Use) concurrency bug affecting state sync reliability during epoch transitions. While not directly exploitable by external attackers, it violates the state consistency invariant and can cause operational issues requiring monitoring and potential manual intervention during critical epoch boundaries.

### Citations

**File:** state-sync/state-sync-driver/src/continuous_syncer.rs (L172-176)
```rust
        self.speculative_stream_state = Some(SpeculativeStreamState::new(
            highest_epoch_state,
            None,
            highest_synced_version,
        ));
```

**File:** state-sync/state-sync-driver/src/continuous_syncer.rs (L267-272)
```rust
    fn get_highest_synced_version_and_epoch(&self) -> Result<(Version, Epoch), Error> {
        let highest_synced_version = utils::fetch_pre_committed_version(self.storage.clone())?;
        let highest_synced_epoch = utils::fetch_latest_epoch_state(self.storage.clone())?.epoch;

        Ok((highest_synced_version, highest_synced_epoch))
    }
```

**File:** state-sync/state-sync-driver/src/continuous_syncer.rs (L452-462)
```rust
        // Verify the ledger info state and signatures
        if let Err(error) = self
            .get_speculative_stream_state()?
            .verify_ledger_info_with_signatures(ledger_info_with_signatures)
        {
            self.reset_active_stream(Some(NotificationAndFeedback::new(
                notification_id,
                NotificationFeedback::PayloadProofFailed,
            )))
            .await?;
            Err(error)
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L137-141)
```rust
    fn get_pre_committed_version(&self) -> Result<Option<Version>> {
        gauged_api("get_pre_committed_version", || {
            Ok(self.state_store.current_state_locked().version())
        })
    }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L696-707)
```rust
    fn get_latest_epoch_state(&self) -> Result<EpochState> {
        gauged_api("get_latest_epoch_state", || {
            let latest_ledger_info = self.ledger_db.metadata_db().get_latest_ledger_info()?;
            match latest_ledger_info.ledger_info().next_epoch_state() {
                Some(epoch_state) => Ok(epoch_state.clone()),
                None => self
                    .ledger_db
                    .metadata_db()
                    .get_epoch_state(latest_ledger_info.ledger_info().epoch()),
            }
        })
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L46-49)
```rust
            // Pre-committing and committing in concurrency is allowed but not pre-committing at the
            // same time from multiple threads, the same for committing.
            // Consensus and state sync must hand over to each other after all pending execution and
            // committing complete.
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L68-72)
```rust
            self.state_store.buffered_state().lock().update(
                chunk.result_ledger_state_with_summary(),
                chunk.estimated_total_state_updates(),
                sync_commit || chunk.is_reconfig,
            )?;
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L99-107)
```rust
            if let Some(li) = ledger_info_with_sigs {
                self.check_and_put_ledger_info(version, li, &mut ledger_batch)?;
            }
            // Write down commit progress
            ledger_batch.put::<DbMetadataSchema>(
                &DbMetadataKey::OverallCommitProgress,
                &DbMetadataValue::Version(version),
            )?;
            self.ledger_db.metadata_db().write_schemas(ledger_batch)?;
```

**File:** types/src/epoch_state.rs (L41-49)
```rust
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> anyhow::Result<()> {
        ensure!(
            self.epoch == ledger_info.ledger_info().epoch(),
            "LedgerInfo has unexpected epoch {}, expected {}",
            ledger_info.ledger_info().epoch(),
            self.epoch
        );
        ledger_info.verify_signatures(&self.verifier)?;
        Ok(())
```
