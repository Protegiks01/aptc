# Audit Report

## Title
Incomplete Truncation of Composite Key Schemas Leaves Orphaned State Values in Database

## Summary
The `delete_state_value_and_index()` function in `truncation_helper.rs` incompletely truncates `StateValueSchema` and `StateValueByKeyHashSchema` (composite key schemas) because it only deletes entries with corresponding stale indices. First-time writes to state keys do not create stale indices, causing their StateValue entries to remain in the database after truncation, leading to state inconsistency. [1](#0-0) 

## Finding Description
The vulnerability occurs in the state KV database truncation logic. When state values are written, stale indices are only created in two cases:

1. **Deletion (tombstone)**: Creates `StaleIndex(stale_since=V, version=V, key=K)` [2](#0-1) 

2. **Overwrite**: Creates `StaleIndex(stale_since=V_new, version=V_old, key=K)` [3](#0-2) 

3. **First-time insert**: No stale index is created [4](#0-3) 

During truncation, `delete_state_value_and_index()` iterates only through stale indices where `stale_since_version >= start_version` and deletes the associated StateValue entries. [5](#0-4) 

**Exploitation scenario:**
- Version 100: First write to `KeyB` → Creates `StateValue(KeyB, 100)`, NO stale index
- Version 100: Overwrite `KeyA` → Creates `StateValue(KeyA, 100)` and `StaleIndex(100, 50, KeyA)`
- Truncate from version 100:
  - Finds `StaleIndex(100, 50, KeyA)` → Deletes `StateValue(KeyA, 100)` ✓
  - No stale index for `KeyB` → `StateValue(KeyB, 100)` remains ✗

This breaks the **State Consistency** invariant because the database contains state values at versions that should have been truncated.

## Impact Explanation
**Medium Severity** - State inconsistencies requiring intervention:

1. **Database corruption**: Orphaned StateValue entries accumulate at truncated versions
2. **Merkle tree inconsistency**: State root calculations may include data from truncated versions
3. **Storage bloat**: Orphaned data is never pruned and accumulates indefinitely
4. **Node divergence**: Different nodes may have different state after truncation operations
5. **State sync issues**: State synchronization may retrieve inconsistent state data

This affects the integrity of the ledger state and could cause nodes to diverge, requiring manual intervention to resolve. It does not directly cause fund loss but compromises state correctness, qualifying as Medium severity per the bug bounty program. [6](#0-5) 

## Likelihood Explanation
**Moderate likelihood:**

Truncation operations occur in several scenarios:
1. Database maintenance and cleanup operations
2. State sync recovery procedures [7](#0-6) 
3. Test and development environments
4. Node recovery from corrupted state

Each truncation operation that affects versions with first-time state key writes will trigger this bug, leaving orphaned data. Over time, this accumulates and degrades database integrity. The bug is deterministic and will occur every time these conditions are met.

## Recommendation
The truncation logic should iterate through ALL StateValue entries at versions >= start_version, not just those with stale indices. 

**Recommended fix for `delete_state_value_and_index()`:**

```rust
fn delete_state_value_and_index(
    state_kv_db_shard: &DB,
    start_version: Version,
    batch: &mut SchemaBatch,
    enable_sharding: bool,
) -> Result<()> {
    // Delete stale indices
    if enable_sharding {
        let mut iter = state_kv_db_shard.iter::<StaleStateValueIndexByKeyHashSchema>()?;
        iter.seek(&start_version)?;
        for item in iter {
            let (index, _) = item?;
            batch.delete::<StaleStateValueIndexByKeyHashSchema>(&index)?;
        }
        
        // Delete ALL state values at versions >= start_version
        let mut iter = state_kv_db_shard.iter::<StateValueByKeyHashSchema>()?;
        iter.seek_to_first();
        for item in iter {
            let ((key_hash, version), _) = item?;
            if version >= start_version {
                batch.delete::<StateValueByKeyHashSchema>(&(key_hash, version))?;
            }
        }
    } else {
        let mut iter = state_kv_db_shard.iter::<StaleStateValueIndexSchema>()?;
        iter.seek(&start_version)?;
        for item in iter {
            let (index, _) = item?;
            batch.delete::<StaleStateValueIndexSchema>(&index)?;
        }
        
        // Delete ALL state values at versions >= start_version
        let mut iter = state_kv_db_shard.iter::<StateValueSchema>()?;
        iter.seek_to_first();
        for item in iter {
            let ((key, version), _) = item?;
            if version >= start_version {
                batch.delete::<StateValueSchema>(&(key, version))?;
            }
        }
    }
    
    Ok(())
}
```

Alternatively, implement a `SeekKeyCodec` for the second component (Version) in the composite key to enable efficient seeking by version.

## Proof of Concept

```rust
#[cfg(test)]
mod truncation_bug_test {
    use super::*;
    use aptos_temppath::TempPath;
    use aptos_types::state_store::state_key::StateKey;
    use aptos_crypto::hash::HashValue;
    
    #[test]
    fn test_incomplete_truncation_of_first_write() {
        let tmpdir = TempPath::new();
        let db = DB::open(&tmpdir, "test", &[
            StateValueByKeyHashSchema::COLUMN_FAMILY_NAME,
            StaleStateValueIndexByKeyHashSchema::COLUMN_FAMILY_NAME,
        ]).unwrap();
        
        let key_a = StateKey::raw(b"key_a");
        let key_b = StateKey::raw(b"key_b");
        let key_a_hash = key_a.hash();
        let key_b_hash = key_b.hash();
        
        // Setup: Write values at version 100
        let mut batch = SchemaBatch::new();
        
        // KeyA: Overwrite (has stale index)
        batch.put::<StateValueByKeyHashSchema>(&(key_a_hash, 100), &Some(vec![1, 2, 3])).unwrap();
        batch.put::<StaleStateValueIndexByKeyHashSchema>(
            &StaleStateValueByKeyHashIndex {
                stale_since_version: 100,
                version: 50,
                state_key_hash: key_a_hash,
            },
            &(),
        ).unwrap();
        
        // KeyB: First write (NO stale index)
        batch.put::<StateValueByKeyHashSchema>(&(key_b_hash, 100), &Some(vec![4, 5, 6])).unwrap();
        
        db.write_schemas(batch).unwrap();
        
        // Verify data exists before truncation
        assert!(db.get::<StateValueByKeyHashSchema>(&(key_a_hash, 100)).unwrap().is_some());
        assert!(db.get::<StateValueByKeyHashSchema>(&(key_b_hash, 100)).unwrap().is_some());
        
        // Truncate from version 100
        let mut batch = SchemaBatch::new();
        delete_state_value_and_index(&db, 100, &mut batch, true).unwrap();
        db.write_schemas(batch).unwrap();
        
        // BUG: KeyA is deleted (has stale index) but KeyB remains (no stale index)
        assert!(db.get::<StateValueByKeyHashSchema>(&(key_a_hash, 100)).unwrap().is_none());
        assert!(db.get::<StateValueByKeyHashSchema>(&(key_b_hash, 100)).unwrap().is_some()); // ORPHANED!
    }
}
```

**Notes:**

This vulnerability specifically affects composite key schemas (`StateValueSchema` and `StateValueByKeyHashSchema`) during truncation operations. The `delete_per_version_data_impl()` function itself is type-safe and correctly handles simple `Version`-keyed schemas. However, the specialized handling for composite key schemas in `delete_state_value_and_index()` is incomplete, answering "yes" to the security question: schemas with composite keys CAN be incorrectly truncated.

### Citations

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L81-116)
```rust
pub(crate) fn truncate_state_kv_db(
    state_kv_db: &StateKvDb,
    current_version: Version,
    target_version: Version,
    batch_size: usize,
) -> Result<()> {
    assert!(batch_size > 0);
    let status = StatusLine::new(Progress::new("Truncating State KV DB", target_version));
    status.set_current_version(current_version);

    let mut current_version = current_version;
    // current_version can be the same with target_version while there is data written to the db before
    // the progress is recorded -- we need to run the truncate for at least one batch
    loop {
        let target_version_for_this_batch = std::cmp::max(
            current_version.saturating_sub(batch_size as Version),
            target_version,
        );
        // By writing the progress first, we still maintain that it is less than or equal to the
        // actual progress per shard, even if it dies in the middle of truncation.
        state_kv_db.write_progress(target_version_for_this_batch)?;
        // the first batch can actually delete more versions than the target batch size because
        // we calculate the start version of this batch assuming the latest data is at
        // `current_version`. Otherwise, we need to seek all shards to determine the
        // actual latest version of data.
        truncate_state_kv_db_shards(state_kv_db, target_version_for_this_batch)?;
        current_version = target_version_for_this_batch;
        status.set_current_version(current_version);

        if current_version <= target_version {
            break;
        }
    }
    assert_eq!(current_version, target_version);
    Ok(())
}
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L551-581)
```rust
fn delete_state_value_and_index(
    state_kv_db_shard: &DB,
    start_version: Version,
    batch: &mut SchemaBatch,
    enable_sharding: bool,
) -> Result<()> {
    if enable_sharding {
        let mut iter = state_kv_db_shard.iter::<StaleStateValueIndexByKeyHashSchema>()?;
        iter.seek(&start_version)?;

        for item in iter {
            let (index, _) = item?;
            batch.delete::<StaleStateValueIndexByKeyHashSchema>(&index)?;
            batch.delete::<StateValueByKeyHashSchema>(&(
                index.state_key_hash,
                index.stale_since_version,
            ))?;
        }
    } else {
        let mut iter = state_kv_db_shard.iter::<StaleStateValueIndexSchema>()?;
        iter.seek(&start_version)?;

        for item in iter {
            let (index, _) = item?;
            batch.delete::<StaleStateValueIndexSchema>(&index)?;
            batch.delete::<StateValueSchema>(&(index.state_key, index.stale_since_version))?;
        }
    }

    Ok(())
}
```

**File:** storage/aptosdb/src/state_store/mod.rs (L926-983)
```rust
    fn put_stale_state_value_index_for_shard<'kv>(
        shard_id: usize,
        first_version: Version,
        num_versions: usize,
        cache: &StateCacheShard,
        updates: &[(&'kv StateKey, StateUpdateRef<'kv>)],
        batch: &mut NativeBatch,
        enable_sharding: bool,
        ignore_state_cache_miss: bool,
    ) {
        let _timer = OTHER_TIMERS_SECONDS.timer_with(&[&format!("put_stale_kv_index__{shard_id}")]);

        let mut iter = updates.iter();
        for version in first_version..first_version + num_versions as Version {
            let ver_iter = iter
                .take_while_ref(|(_k, u)| u.version == version)
                // ignore hot state only ops
                // TODO(HotState): revisit
                .filter(|(_key, update)| update.state_op.is_value_write_op());

            for (key, update_to_cold) in ver_iter {
                if update_to_cold.state_op.expect_as_write_op().is_delete() {
                    // This is a tombstone, can be pruned once this `version` goes out of
                    // the pruning window.
                    Self::put_state_kv_index(batch, enable_sharding, version, version, key);
                }

                // TODO(aldenhu): cache changes here, should consume it.
                let old_entry = cache
                    // TODO(HotState): Revisit: assuming every write op results in a hot slot
                    .insert(
                        (*key).clone(),
                        update_to_cold
                            .to_result_slot()
                            .expect("hot state ops should have been filtered out above"),
                    )
                    .unwrap_or_else(|| {
                        // n.b. all updated state items must be read and recorded in the state cache,
                        // otherwise we can't calculate the correct usage. The is_untracked() hack
                        // is to allow some db tests without real execution layer to pass.
                        assert!(ignore_state_cache_miss, "Must cache read.");
                        StateSlot::ColdVacant
                    });

                if old_entry.is_occupied() {
                    // The value at the old version can be pruned once the pruning window hits
                    // this `version`.
                    Self::put_state_kv_index(
                        batch,
                        enable_sharding,
                        version,
                        old_entry.expect_value_version(),
                        key,
                    )
                }
            }
        }
    }
```

**File:** storage/aptosdb/src/schema/state_value/mod.rs (L33-40)
```rust
type Key = (StateKey, Version);

define_schema!(
    StateValueSchema,
    Key,
    Option<StateValue>,
    STATE_VALUE_CF_NAME
);
```
