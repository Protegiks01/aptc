# Audit Report

## Title
Missing Timestamp Validation During Deserialization Enables State Corruption to Break Critical Protocol Functions

## Summary
The `TimestampResource` and `CurrentTimeMicroseconds` structures lack validation during BCS deserialization, allowing a corrupted state database to load unreasonable timestamp values (e.g., `u64::MAX`) that break governance voting, stake lockup mechanisms, keyless authentication, and epoch transitions.

## Finding Description

The Rust `TimestampResource` struct uses standard serde deserialization without any validation of the `microseconds` field: [1](#0-0) 

Similarly, the `CurrentTimeMicroseconds` on-chain config uses default BCS deserialization: [2](#0-1) 

The `OnChainConfig` trait's default deserialization performs no validation: [3](#0-2) 

When state is loaded from the database, no sanity checks verify the timestamp value is reasonable: [4](#0-3) 

**Attack Vector 1: Governance Freeze**

If `microseconds = u64::MAX`, then `timestamp::now_seconds()` returns `u64::MAX / 1_000_000 â‰ˆ 18.4 trillion seconds` (584,542 years in the future). This breaks governance: [5](#0-4) 

All proposals would have `timestamp::now_seconds() > proposal_expiration`, causing `get_remaining_voting_power` to return 0, making voting impossible. [6](#0-5) 

This assertion would always fail, preventing proposal creation entirely.

**Attack Vector 2: Stake Lockup Bypass** [7](#0-6) 

With a corrupted timestamp far in the future, `lockup_time <= timestamp::now_seconds()` is always true, returning 0 remaining lockup for all validators, allowing immediate withdrawal.

**Attack Vector 3: Keyless Transaction Failure** [8](#0-7) 

The `checked_add` would overflow with `u64::MAX`, causing all keyless transactions to fail.

**Attack Vector 4: Epoch Transition Arithmetic Overflow** [9](#0-8) 

The addition at line 267-268 could overflow in Move (which aborts on overflow), preventing epoch transitions.

## Impact Explanation

**High Severity** - This meets significant protocol violation criteria:

1. **Governance Breakdown**: Complete inability to vote or create proposals violates Governance Integrity invariant
2. **Staking Security Violation**: Bypassed stake lockup allows premature validator withdrawals
3. **Authentication Failure**: All keyless users lose transaction capability
4. **Consensus Risk**: Potential epoch transition failures affecting liveness

While this requires state corruption as a prerequisite (not directly exploitable), the lack of validation represents a critical defense-in-depth failure that amplifies any state corruption vulnerability.

## Likelihood Explanation

**Medium Likelihood** - Requires state corruption through:
- Database bugs or hardware failures
- State sync vulnerabilities
- Consensus bugs allowing invalid state commitment

While not directly exploitable by unprivileged attackers, storage layer bugs or state sync issues could trigger this. The complete absence of validation means ANY corruption affecting timestamp propagates unchecked throughout the protocol.

## Recommendation

Add validation during deserialization to enforce reasonable timestamp bounds:

```rust
// In types/src/on_chain_config/timestamp.rs
impl OnChainConfig for CurrentTimeMicroseconds {
    const MODULE_IDENTIFIER: &'static str = "timestamp";
    const TYPE_IDENTIFIER: &'static str = "CurrentTimeMicroseconds";
    
    fn deserialize_into_config(bytes: &[u8]) -> Result<Self> {
        let timestamp = Self::deserialize_default_impl(bytes)?;
        
        // Validate timestamp is not unreasonably far in future (e.g., before year 3000)
        const MAX_REASONABLE_MICROSECONDS: u64 = 32_503_680_000_000_000; // ~year 3000
        
        if timestamp.microseconds > MAX_REASONABLE_MICROSECONDS {
            return Err(format_err!(
                "Invalid timestamp: {} exceeds maximum reasonable value",
                timestamp.microseconds
            ));
        }
        
        Ok(timestamp)
    }
}
```

Additionally, add validation in the Rust deserialization path: [4](#0-3) 

Modify to validate after deserialization.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[test]
fn test_corrupted_timestamp_breaks_governance() {
    // Simulate corrupted state with u64::MAX
    let corrupted_timestamp = TimestampResource {
        timestamp: Timestamp {
            microseconds: u64::MAX,
        },
    };
    
    // Serialize corrupted timestamp
    let bytes = bcs::to_bytes(&corrupted_timestamp).unwrap();
    
    // Deserialization succeeds without validation
    let loaded = bcs::from_bytes::<TimestampResource>(&bytes).unwrap();
    assert_eq!(loaded.timestamp.microseconds, u64::MAX);
    
    // now_seconds() calculation
    let seconds = u64::MAX / 1_000_000; // ~18.4 trillion
    
    // Any reasonable proposal expiration (e.g., 30 days from now)
    let proposal_expiry = 1_700_000_000; // ~year 2023
    
    // Check: timestamp::now_seconds() > proposal_expiration
    assert!(seconds > proposal_expiry); // Always true - voting impossible
}
```

**Notes**

This vulnerability exists because there is no validation layer between raw BCS deserialization and critical protocol usage. While state corruption requires a separate vulnerability, defense-in-depth principles mandate validation at deserialization boundaries to prevent cascading failures. The Move-level validation in `update_global_time` only applies during normal block execution, not when loading existing state from storage.

### Citations

**File:** types/src/timestamp.rs (L11-14)
```rust
#[derive(Debug, Deserialize, Serialize)]
pub struct TimestampResource {
    pub timestamp: Timestamp,
}
```

**File:** types/src/on_chain_config/timestamp.rs (L7-10)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
pub struct CurrentTimeMicroseconds {
    pub microseconds: u64,
}
```

**File:** types/src/on_chain_config/mod.rs (L162-165)
```rust
    fn deserialize_default_impl(bytes: &[u8]) -> Result<Self> {
        bcs::from_bytes::<Self>(bytes)
            .map_err(|e| format_err!("[on-chain config] Failed to deserialize into config: {}", e))
    }
```

**File:** execution/executor/src/db_bootstrapper/mod.rs (L207-215)
```rust
fn get_state_timestamp(state_view: &CachedStateView) -> Result<u64> {
    let rsrc_bytes = &state_view
        .get_state_value_bytes(&StateKey::resource_typed::<TimestampResource>(
            &CORE_CODE_ADDRESS,
        )?)?
        .ok_or_else(|| format_err!("TimestampResource missing."))?;
    let rsrc = bcs::from_bytes::<TimestampResource>(rsrc_bytes)?;
    Ok(rsrc.timestamp.microseconds)
}
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L326-335)
```text
        let proposal_expiration = voting::get_proposal_expiration_secs<GovernanceProposal>(
            @aptos_framework,
            proposal_id
        );
        let lockup_until = stake::get_lockup_secs(stake_pool);
        // The voter's stake needs to be locked up at least as long as the proposal's expiration.
        // Also no one can vote on a expired proposal.
        if (proposal_expiration > lockup_until || timestamp::now_seconds() > proposal_expiration) {
            return 0
        };
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L361-364)
```text
        assert!(
            timestamp::now_seconds() <= proposal_expiration,
            error::invalid_argument(EPROPOSAL_EXPIRED),
        );
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L398-406)
```text
    public fun get_remaining_lockup_secs(pool_address: address): u64 acquires StakePool {
        assert_stake_pool_exists(pool_address);
        let lockup_time = borrow_global<StakePool>(pool_address).locked_until_secs;
        if (lockup_time <= timestamp::now_seconds()) {
            0
        } else {
            lockup_time - timestamp::now_seconds()
        }
    }
```

**File:** types/src/keyless/mod.rs (L202-212)
```rust
    pub fn verify_expiry(&self, current_time_microseconds: u64) -> anyhow::Result<()> {
        let block_time = UNIX_EPOCH.checked_add(Duration::from_micros(current_time_microseconds))
            .ok_or_else(|| anyhow::anyhow!("Overflowed on UNIX_EPOCH + current_time_microseconds when checking exp_date_secs"))?;
        let expiry_time = seconds_from_epoch(self.exp_date_secs)?;

        if block_time > expiry_time {
            bail!("Keyless signature is expired");
        } else {
            Ok(())
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/staking_config.move (L242-268)
```text
        let current_time_in_secs = timestamp::now_seconds();
        assert!(
            current_time_in_secs >= staking_rewards_config.last_rewards_rate_period_start_in_secs,
            error::invalid_argument(EINVALID_LAST_REWARDS_RATE_PERIOD_START)
        );
        if (current_time_in_secs - staking_rewards_config.last_rewards_rate_period_start_in_secs < staking_rewards_config.rewards_rate_period_in_secs) {
            return *staking_rewards_config
        };
        // Rewards rate decrease rate cannot be greater than 100%. Otherwise rewards rate will be negative.
        assert!(
            fixed_point64::ceil(staking_rewards_config.rewards_rate_decrease_rate) <= 1,
            error::invalid_argument(EINVALID_REWARDS_RATE_DECREASE_RATE)
        );
        let new_rate = math_fixed64::mul_div(
            staking_rewards_config.rewards_rate,
            fixed_point64::sub(
                fixed_point64::create_from_u128(1),
                staking_rewards_config.rewards_rate_decrease_rate,
            ),
            fixed_point64::create_from_u128(1),
        );
        new_rate = fixed_point64::max(new_rate, staking_rewards_config.min_rewards_rate);

        staking_rewards_config.rewards_rate = new_rate;
        staking_rewards_config.last_rewards_rate_period_start_in_secs =
            staking_rewards_config.last_rewards_rate_period_start_in_secs +
            staking_rewards_config.rewards_rate_period_in_secs;
```
