# Audit Report

## Title
IPv4-Mapped IPv6 Address Bypass in Faucet IP Filtering

## Summary
The `IpRangeManager.contains_ip()` function does not normalize IPv4-mapped IPv6 addresses (e.g., `::ffff:192.168.1.1`) to their IPv4 equivalents before checking against IP ranges. This allows attackers to bypass IPv4-based blocklists or allowlists when the faucet service is configured to accept IPv6 connections.

## Finding Description
The IP range checking logic in the faucet service treats IPv4 and IPv6 addresses as completely separate address spaces without handling the special case of IPv4-mapped IPv6 addresses. [1](#0-0) 

When a client connects to an IPv6 socket using IPv4, the operating system may represent the source address as an IPv4-mapped IPv6 address (format: `::ffff:x.x.x.x`). Rust's `IpAddr` enum treats this as `IpAddr::V6`, which is then checked against the `ipv6_list` rather than the `ipv4_list`.

The same issue exists in the direct implementation used by `IpBlocklistChecker`: [2](#0-1) 

And in the `IpAllowlistBypasser`: [3](#0-2) 

**Attack Scenario:**
1. Faucet operator configures `listen_address: "::"` to support both IPv4 and IPv6 clients
2. Operator adds `192.168.1.0/24` to the IPv4 blocklist to prevent abuse
3. Attacker with IPv4 address `192.168.1.50` connects to the faucet
4. OS represents the connection as `::ffff:192.168.1.50` (IPv4-mapped IPv6)
5. The source IP extraction passes this through as `IpAddr::V6` [4](#0-3) 

6. The blocklist check looks in `ipv6_list`, not finding the IPv4-mapped address
7. Attacker bypasses the blocklist and obtains testnet funds

## Impact Explanation
**Severity: Low to Medium** (Out of Primary Scope)

This vulnerability does NOT meet the Critical or High severity criteria because:

1. **Not a Core Blockchain Component**: The faucet is an auxiliary testnet service, not part of the consensus, execution, storage, or governance layers that are the primary focus of this audit.

2. **No Impact on Core Invariants**: This does not break any of the 10 critical blockchain invariants (consensus safety, deterministic execution, state consistency, etc.).

3. **Limited Funds at Risk**: The faucet only distributes testnet tokens which have no economic value. There is no loss of mainnet funds or impact on the production blockchain.

4. **No Consensus/Protocol Impact**: This cannot affect validator operations, block production, or network liveness.

However, the issue does have limited impact:
- Allows rate limit bypass and resource abuse on testnet faucets
- Could lead to testnet token exhaustion affecting legitimate developers
- Undermines IP-based access controls for faucet distribution

## Likelihood Explanation
**Likelihood: Low**

For this vulnerability to be exploitable:
1. The faucet must be configured with `listen_address: "::"` instead of the default `"0.0.0.0"` [5](#0-4) 

2. The operator must have configured IPv4-based blocklists without corresponding IPv4-mapped IPv6 entries
3. The attacker must connect in a way that results in IPv4-mapped IPv6 representation

While technically feasible, this requires non-default configuration choices by the operator.

## Recommendation
Normalize IPv4-mapped IPv6 addresses to their IPv4 equivalents before checking ranges. Modify the `contains_ip()` function:

```rust
pub fn contains_ip(&self, ip: &IpAddr) -> bool {
    match ip {
        IpAddr::V4(ipv4) => self.ipv4_list.contains(ipv4),
        IpAddr::V6(ipv6) => {
            // Check if this is an IPv4-mapped IPv6 address
            if let Some(ipv4) = ipv6.to_ipv4_mapped() {
                self.ipv4_list.contains(&ipv4)
            } else {
                self.ipv6_list.contains(ipv6)
            }
        }
    }
}
```

Apply the same logic to `IpBlocklistChecker` to maintain consistency.

## Proof of Concept
```rust
#[test]
fn test_ipv4_mapped_ipv6_bypass() {
    use std::net::{IpAddr, Ipv6Addr};
    use ipnet::Ipv4Net;
    use iprange::IpRange;
    
    // Create a blocklist with an IPv4 range
    let mut ipv4_list = IpRange::<Ipv4Net>::new();
    ipv4_list.add("192.168.1.0/24".parse().unwrap());
    
    let mut ipv6_list = IpRange::<Ipv6Net>::new();
    
    let manager = IpRangeManager { ipv4_list, ipv6_list };
    
    // This IPv4 address should be blocked
    let ipv4_blocked: IpAddr = "192.168.1.50".parse().unwrap();
    assert!(manager.contains_ip(&ipv4_blocked)); // Correctly blocked
    
    // But the IPv4-mapped IPv6 equivalent bypasses the check
    let ipv4_mapped: IpAddr = IpAddr::V6("::ffff:192.168.1.50".parse().unwrap());
    assert!(!manager.contains_ip(&ipv4_mapped)); // Incorrectly allowed!
}
```

---

## Notes
While this is a **valid technical issue** in the faucet implementation, it falls outside the primary scope of this blockchain security audit. The faucet is not part of the consensus, execution, storage, or governance layers that are critical to blockchain security. The vulnerability only affects testnet token distribution and does not impact mainnet funds, consensus safety, or any of the critical blockchain invariants outlined in the audit scope.

This should be addressed as a **code quality and testnet operations issue**, but does not qualify as a Critical, High, or Medium severity vulnerability per the Aptos bug bounty criteria focused on core blockchain components.

### Citations

**File:** crates/aptos-faucet/core/src/common/ip_range_manager.rs (L55-60)
```rust
    pub fn contains_ip(&self, ip: &IpAddr) -> bool {
        match ip {
            IpAddr::V4(ipv4) => self.ipv4_list.contains(ipv4),
            IpAddr::V6(ipv6) => self.ipv6_list.contains(ipv6),
        }
    }
```

**File:** crates/aptos-faucet/core/src/checkers/ip_blocklist.rs (L32-49)
```rust
        match &data.source_ip {
            IpAddr::V4(source_ip) => {
                if self.manager.ipv4_list.contains(source_ip) {
                    return Ok(vec![RejectionReason::new(
                        format!("IP {} is in blocklist", source_ip),
                        RejectionReasonCode::IpInBlocklist,
                    )]);
                }
            },
            IpAddr::V6(source_ip) => {
                if self.manager.ipv6_list.contains(source_ip) {
                    return Ok(vec![RejectionReason::new(
                        format!("IP {} is in blocklist", source_ip),
                        RejectionReasonCode::IpInBlocklist,
                    )]);
                }
            },
        }
```

**File:** crates/aptos-faucet/core/src/bypasser/ip_allowlist.rs (L26-28)
```rust
    async fn request_can_bypass(&self, data: CheckerData) -> Result<bool> {
        Ok(self.manager.contains_ip(&data.source_ip))
    }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L217-225)
```rust
        let source_ip = match source_ip.0 {
            Some(ip) => ip,
            None => {
                return Err(AptosTapError::new(
                    "No source IP found in the request".to_string(),
                    AptosTapErrorCode::SourceIpMissing,
                ))
            },
        };
```

**File:** crates/aptos-faucet/core/src/server/server_args.rs (L22-24)
```rust
    fn default_listen_address() -> String {
        "0.0.0.0".to_string()
    }
```
