# Audit Report

## Title
Insecure Temporary File Permissions Expose Root Private Keys in ValidateProposals Command

## Summary
The `ValidateProposals` command handler in `aptos-release-builder` writes Ed25519 root private keys to temporary files with insecure default permissions (0644), making them readable by all users on multi-tenant systems. This exposes governance root keys to potential theft by local attackers.

## Finding Description

The vulnerability exists in the `ValidateProposals` command handler where root private keys are written to temporary files without setting secure permissions. [1](#0-0) 

The code creates a temporary path using `TempPath::new()` and `create_as_file()`. However, the actual private key is written using a different file path: [2](#0-1) 

The root cause is that `std::fs::write()` at line 306 creates files with default umask permissions (typically 0644 on Unix systems), making them world-readable. Additionally, the `TempPath::create_as_file()` method itself does not set secure permissions: [3](#0-2) 

The `OpenOptions` builder does not include `.mode(0o600)` for Unix systems, which would restrict read/write access to the file owner only.

**Attack Scenario:**
1. A governance operator runs the `ValidateProposals` command on a shared/multi-tenant system (cloud VM, shared hosting, etc.)
2. The root private key is written to `/tmp/<random>.key` with 0644 permissions
3. An attacker with local user access monitors `/tmp` and reads the newly created key file
4. The attacker exfiltrates the root private key
5. The attacker can now use this key to submit unauthorized governance proposals or manipulate governance operations

The codebase already has proper implementations for creating secure files: [4](#0-3) 

## Impact Explanation

This is **HIGH severity** according to Aptos bug bounty criteria because:

1. **Cryptographic Key Exposure**: Root Ed25519 private keys used for governance operations are exposed
2. **Governance Compromise**: The root key has privileged access to governance operations including proposal submission and voting
3. **Access Control Violation**: Violates the "Access Control: System addresses must be protected" invariant
4. **Significant Protocol Violation**: Compromised governance keys can manipulate on-chain governance

While not Critical (requires local system access, not remote), this represents a significant security risk on multi-tenant systems where the tool is commonly used (CI/CD pipelines, cloud VMs, shared development servers).

## Likelihood Explanation

**Likelihood: Medium to High**

- **Multi-tenant systems are common**: Cloud VMs, shared hosting, CI/CD runners often have multiple user accounts
- **Attack is trivial**: Simply monitoring `/tmp` for new `.key` files and reading them requires minimal sophistication
- **Limited time window**: Files exist only during command execution, but automated monitoring makes this feasible
- **Common deployment scenario**: Governance operations are often performed on shared infrastructure

The attack requires:
- Local user access to the same system (no remote exploitation)
- Timing to catch the file during its brief existence (or continuous monitoring)
- Basic file system access permissions

## Recommendation

**Fix Option 1: Modify TempPath::create_as_file() to use secure permissions**

Add mode 0600 to the `create_as_file()` method:

```rust
pub fn create_as_file(&self) -> io::Result<()> {
    let mut builder = fs::OpenOptions::new();
    builder.write(true).create_new(true);
    #[cfg(unix)]
    builder.mode(0o600);
    builder.open(self.path())?;
    Ok(())
}
```

**Fix Option 2: Use secure file writing in main.rs**

Replace `std::fs::write()` with the existing secure utility:

```rust
use aptos::common::utils::write_to_user_only_file;

// Replace line 306
write_to_user_only_file(
    root_key_path.parent().unwrap(),
    root_key_path.file_name().unwrap().to_str().unwrap(),
    &bcs::to_bytes(&root_key)?
)?;
```

**Recommended Approach**: Implement Fix Option 1 to ensure all TempPath files have secure permissions by default, as temporary files often contain sensitive data. This prevents similar issues across the codebase.

## Proof of Concept

**PoC: Demonstrating Insecure Permissions**

```rust
// File: test_insecure_temppath.rs
use aptos_temppath::TempPath;
use std::fs;
use std::os::unix::fs::PermissionsExt;

fn main() {
    // Create temp file using current implementation
    let temp_path = TempPath::new();
    temp_path.create_as_file().unwrap();
    
    // Write sensitive data (simulating line 306 in main.rs)
    let mut key_path = temp_path.path().to_path_buf();
    key_path.set_extension("key");
    fs::write(&key_path, b"SENSITIVE_PRIVATE_KEY_DATA").unwrap();
    
    // Check permissions
    let metadata = fs::metadata(&key_path).unwrap();
    let permissions = metadata.permissions();
    let mode = permissions.mode();
    
    println!("File: {:?}", key_path);
    println!("Permissions (octal): {:o}", mode & 0o777);
    
    // On typical Unix systems, this will print 0644
    // Meaning: owner=rw, group=r, others=r (WORLD READABLE!)
    
    if mode & 0o044 != 0 {
        println!("❌ VULNERABLE: File is readable by group/others!");
        println!("   Any user on this system can read the private key!");
    } else {
        println!("✓ SECURE: File is only readable by owner");
    }
}
```

**Expected Output (demonstrating vulnerability):**
```
File: "/tmp/<random>.key"
Permissions (octal): 644
❌ VULNERABLE: File is readable by group/others!
   Any user on this system can read the private key!
```

**Notes:**
- The vulnerability is exploitable on any Unix-like system where multiple users exist
- Common scenarios include: AWS EC2 instances, GCP VMs, shared development servers, CI/CD runners
- The codebase already has the solution implemented in `write_to_user_only_file()` but it's not being used for these temporary key files
- The issue affects the governance subsystem's access control guarantees

### Citations

**File:** aptos-move/aptos-release-builder/src/main.rs (L284-285)
```rust
            let root_key_path = aptos_temppath::TempPath::new();
            root_key_path.create_as_file()?;
```

**File:** aptos-move/aptos-release-builder/src/main.rs (L299-306)
```rust
                    let root_key = Ed25519PrivateKey::from_encoded_string(&root_key)?;
                    let validator_key = Ed25519PrivateKey::from_encoded_string(&validator_key)?;
                    let validator_account = AccountAddress::from_hex(validator_address.as_bytes())?;

                    let mut root_key_path = root_key_path.path().to_path_buf();
                    root_key_path.set_extension("key");

                    std::fs::write(root_key_path.as_path(), bcs::to_bytes(&root_key)?)?;
```

**File:** crates/aptos-temppath/src/lib.rs (L60-65)
```rust
    pub fn create_as_file(&self) -> io::Result<()> {
        let mut builder = fs::OpenOptions::new();
        builder.write(true).create_new(true);
        builder.open(self.path())?;
        Ok(())
    }
```

**File:** crates/aptos/src/common/utils.rs (L223-228)
```rust
/// Write a User only read / write file
pub fn write_to_user_only_file(path: &Path, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    let mut opts = OpenOptions::new();
    #[cfg(unix)]
    opts.mode(0o600);
    write_to_file_with_opts(path, name, bytes, &mut opts)
```
