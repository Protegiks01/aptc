# Audit Report

## Title
Genesis Vesting Contract Timestamp Validation Bypass Allows Immediate Token Withdrawal

## Summary
The genesis initialization process fails to validate that `employee_vesting_start` timestamps are greater than zero, allowing vesting contracts to be created with Unix epoch (timestamp=0) as the start time. When combined with the genesis timestamp initialization at 0 microseconds, this enables immediate vesting of all tokens that should be locked over years, breaking the time-lock mechanism.

## Finding Description

The vulnerability exists in a validation gap across three layers of the system:

**Layer 1 - Rust Genesis Configuration Validation:**
The `validate_genesis_config` function validates many genesis parameters but completely omits validation for `employee_vesting_start`: [1](#0-0) 

**Layer 2 - Genesis Timestamp Initialization:**
During genesis, the timestamp is explicitly set to 0 microseconds (Unix epoch): [2](#0-1) 

The genesis block event confirms this with `time_microseconds: 0`: [3](#0-2) 

**Layer 3 - Move Vesting Schedule Validation:**
The vesting schedule creation validates that the start time is not in the past, but during genesis when `timestamp::now_seconds()` returns 0, a `start_timestamp_secs` of 0 passes validation: [4](#0-3) 

**Exploitation Path:**
When `vest()` is called after the first real block (with actual wall clock time ~1.7 billion seconds since Unix epoch), the calculation becomes: [5](#0-4) 

With `start_timestamp_secs = 0` and current time = 1,700,000,000 seconds (year 2023), and a 30-day period (2,592,000 seconds):
- `last_completed_period = (1,700,000,000 - 0) / 2,592,000 â‰ˆ 655 periods`
- All vesting periods are considered elapsed
- Tokens meant to vest over 4 years become immediately withdrawable

**Broken Invariants:**
1. **Time-lock Security**: Vesting contracts must enforce gradual token release over the specified schedule
2. **State Consistency**: Token lockup state must accurately reflect intended vesting timelines
3. **Deterministic Execution**: All validators will consistently allow premature vesting, creating a consensus-valid but economically incorrect state

## Impact Explanation

**Severity: Medium** (up to $10,000 per Aptos bug bounty criteria)

This qualifies as "Limited funds loss or manipulation" because:

1. **Direct Financial Impact**: All employee vesting contracts created during genesis with `employee_vesting_start = 0` would have their entire token allocation immediately available for withdrawal instead of being locked over the intended vesting period (typically 4 years).

2. **Scope of Impact**: Only affects vesting contracts created at genesis with misconfigured timestamps. Does not affect:
   - Validator staking operations
   - Regular user funds
   - Governance mechanisms
   - Consensus safety

3. **Exploitation Requirements**: Requires genesis to be deployed with `employee_vesting_start = 0`, which while possible due to missing validation, is not the typical configuration (default values in code use timestamp 1663456089).

## Likelihood Explanation

**Likelihood: Low-Medium**

**Factors Decreasing Likelihood:**
- Default genesis configurations use proper timestamp values (1663456089 = September 2022)
- Genesis deployment is typically performed by experienced core team members
- Testing on devnet/testnet would likely reveal the issue before mainnet deployment

**Factors Increasing Likelihood:**
- No validation exists to prevent the misconfiguration
- The error would be silent during genesis execution
- Quick-fork scenarios or side chains might copy genesis templates carelessly
- The Option<u64> type for employee_vesting_start in configuration could lead to default/zero values if improperly handled: [6](#0-5) 

## Recommendation

**Add multi-layer validation:**

1. **Rust-side validation in `validate_genesis_config`:**
```rust
fn validate_genesis_config(genesis_config: &GenesisConfiguration) {
    // ... existing validations ...
    
    assert!(
        genesis_config.employee_vesting_start > 0,
        "employee_vesting_start must be > 0 (cannot be Unix epoch)"
    );
    
    // Additional safety: ensure it's a reasonable future timestamp
    // For example, must be after September 2022 for any realistic deployment
    assert!(
        genesis_config.employee_vesting_start >= 1663456089,
        "employee_vesting_start must be a realistic future timestamp"
    );
    
    assert!(
        genesis_config.employee_vesting_period_duration > 0,
        "employee_vesting_period_duration must be > 0"
    );
}
```

2. **Move-side enhanced validation in `create_vesting_schedule`:**
```move
public fun create_vesting_schedule(
    schedule: vector<FixedPoint32>,
    start_timestamp_secs: u64,
    period_duration: u64,
): VestingSchedule {
    assert!(vector::length(&schedule) > 0, error::invalid_argument(EEMPTY_VESTING_SCHEDULE));
    assert!(period_duration > 0, error::invalid_argument(EZERO_VESTING_SCHEDULE_PERIOD));
    
    // Enhanced validation: start time must be reasonable (not Unix epoch)
    assert!(
        start_timestamp_secs > 0,
        error::invalid_argument(EVESTING_START_TOO_SOON),
    );
    
    // Original validation remains
    assert!(
        start_timestamp_secs >= timestamp::now_seconds(),
        error::invalid_argument(EVESTING_START_TOO_SOON),
    );
    
    // ... rest of function
}
```

## Proof of Concept

**Scenario:** Genesis deployed with employee_vesting_start = 0

```rust
// In genesis configuration (aptos-move/vm-genesis/src/lib.rs)
GenesisConfiguration {
    // ... other fields ...
    employee_vesting_start: 0,  // VULNERABILITY: Should be validated as > 0
    employee_vesting_period_duration: 2592000, // 30 days
    // ... other fields ...
}
```

**Attack Flow:**
1. Genesis executes with timestamp=0, creates vesting contracts with start_timestamp_secs=0
2. Vesting contract created for employee with 1M tokens vesting over 48 months
3. First block after genesis has timestamp ~1.7B seconds (current time)
4. Employee calls `vest()` function
5. Calculation: `last_completed_period = (1,700,000,000 - 0) / 2,592,000 = 655 periods`
6. All 48 vesting periods are considered complete
7. Employee can withdraw entire 1M token allocation immediately

**Test pseudocode:**
```move
#[test]
fun test_zero_timestamp_vesting_bypass() {
    // Setup genesis with timestamp=0
    timestamp::set_time_has_started_for_testing(&framework);
    
    // Create vesting schedule with start=0 (should fail but doesn't)
    let schedule = create_vesting_schedule(
        vector[...], 
        0,  // start_timestamp_secs = 0
        2592000  // 30 day periods
    );
    
    // Fast forward to realistic timestamp
    timestamp::update_global_time_for_test(1700000000 * 1000000);
    
    // Call vest() - should only unlock 1 period, but unlocks ALL
    vest(contract_address);
    
    // Assert: can withdraw entire grant immediately (VULNERABILITY)
}
```

## Notes

This vulnerability represents a defense-in-depth failure where missing input validation at the genesis configuration layer, combined with the inherent timestamp=0 at genesis, creates a path to bypass vesting time-locks. While the default configuration values are safe, the absence of validation creates risk for network forks, test deployments, or configuration errors. The reconfiguration module's explicit check for `timestamp::now_microseconds() == 0` demonstrates awareness of this edge case, but the validation gap in vesting schedule creation leaves the system vulnerable to misconfiguration. [7](#0-6)

### Citations

**File:** aptos-move/vm-genesis/src/lib.rs (L405-439)
```rust
fn validate_genesis_config(genesis_config: &GenesisConfiguration) {
    assert!(
        genesis_config.min_stake <= genesis_config.max_stake,
        "Min stake must be smaller than or equal to max stake"
    );
    assert!(
        genesis_config.epoch_duration_secs > 0,
        "Epoch duration must be > 0"
    );
    assert!(
        genesis_config.recurring_lockup_duration_secs > 0,
        "Recurring lockup duration must be > 0"
    );
    assert!(
        genesis_config.recurring_lockup_duration_secs >= genesis_config.epoch_duration_secs,
        "Recurring lockup duration must be at least as long as epoch duration"
    );
    assert!(
        genesis_config.rewards_apy_percentage > 0 && genesis_config.rewards_apy_percentage < 100,
        "Rewards APY must be > 0% and < 100%"
    );
    assert!(
        genesis_config.voting_duration_secs > 0,
        "On-chain voting duration must be > 0"
    );
    assert!(
        genesis_config.voting_duration_secs < genesis_config.recurring_lockup_duration_secs,
        "Voting duration must be strictly smaller than recurring lockup"
    );
    assert!(
        genesis_config.voting_power_increase_limit > 0
            && genesis_config.voting_power_increase_limit <= 50,
        "voting_power_increase_limit must be > 0 and <= 50"
    );
}
```

**File:** aptos-move/framework/aptos-framework/sources/timestamp.move (L25-29)
```text
    public(friend) fun set_time_has_started(aptos_framework: &signer) {
        system_addresses::assert_aptos_framework(aptos_framework);
        let timer = CurrentTimeMicroseconds { microseconds: 0 };
        move_to(aptos_framework, timer);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L291-308)
```text
    fun emit_genesis_block_event(vm: signer) acquires BlockResource, CommitHistory {
        let block_metadata_ref = borrow_global_mut<BlockResource>(@aptos_framework);
        let genesis_id = @0x0;
        emit_new_block_event(
            &vm,
            &mut block_metadata_ref.new_block_events,
            NewBlockEvent {
                hash: genesis_id,
                epoch: 0,
                round: 0,
                height: 0,
                previous_block_votes_bitvec: vector::empty(),
                proposer: @vm_reserved,
                failed_proposer_indices: vector::empty(),
                time_microseconds: 0,
            },
        );
    }
```

**File:** aptos-move/framework/aptos-framework/sources/vesting.move (L524-542)
```text
    public fun create_vesting_schedule(
        schedule: vector<FixedPoint32>,
        start_timestamp_secs: u64,
        period_duration: u64,
    ): VestingSchedule {
        assert!(vector::length(&schedule) > 0, error::invalid_argument(EEMPTY_VESTING_SCHEDULE));
        assert!(period_duration > 0, error::invalid_argument(EZERO_VESTING_SCHEDULE_PERIOD));
        assert!(
            start_timestamp_secs >= timestamp::now_seconds(),
            error::invalid_argument(EVESTING_START_TOO_SOON),
        );

        VestingSchedule {
            schedule,
            start_timestamp_secs,
            period_duration,
            last_vested_period: 0,
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/vesting.move (L695-699)
```text
        let last_completed_period =
            (timestamp::now_seconds() - vesting_schedule.start_timestamp_secs) / vesting_schedule.period_duration;
        if (last_completed_period < next_period_to_vest) {
            return
        };
```

**File:** crates/aptos-genesis/src/config.rs (L68-71)
```rust
    /// Timestamp (in seconds) when employee vesting starts.
    pub employee_vesting_start: Option<u64>,
    /// Duration of each vesting period (in seconds).
    pub employee_vesting_period_duration: Option<u64>,
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration.move (L106-110)
```text
    public(friend) fun reconfigure() acquires Configuration {
        // Do not do anything if genesis has not finished.
        if (chain_status::is_genesis() || timestamp::now_microseconds() == 0 || !reconfiguration_enabled()) {
            return
        };
```
