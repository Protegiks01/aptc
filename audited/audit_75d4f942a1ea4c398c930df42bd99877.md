# Audit Report

## Title
Credential Disclosure via Debug Trait in NFT Metadata Crawler Configuration

## Summary
The `ParserConfig` struct in the NFT metadata crawler derives the `Debug` trait, which causes sensitive credentials (`google_application_credentials` and `ipfs_auth_key`) to be exposed in plaintext when the configuration is logged during service startup.

## Finding Description
The `ParserConfig` struct contains sensitive authentication credentials but derives the `Debug` trait without redacting these fields. [1](#0-0) 

When the NFT metadata crawler service starts, it logs the entire configuration using Debug formatting, which automatically triggers the exposure of these credentials. [2](#0-1) 

The `ServerConfig` enum wraps `ParserConfig` and also derives `Debug`, allowing the credentials to propagate through the logging chain. [3](#0-2) 

**Attack Path:**
1. NFT metadata crawler service starts with valid Google Cloud and IPFS credentials configured
2. Service logs configuration during initialization using `info!` macro with `{:?}` formatter
3. Credentials are written in plaintext to log files, centralized logging systems, or monitoring dashboards
4. Unauthorized personnel with log access can retrieve these credentials
5. Attacker uses leaked credentials to access Google Cloud Storage buckets or IPFS resources

## Impact Explanation
This vulnerability allows credential disclosure through log files. According to the Aptos bug bounty program, this falls under **Low Severity** (up to $1,000) as a "Minor information leak." 

While the leaked credentials could potentially be used to access or manipulate NFT metadata storage infrastructure, this does not directly impact:
- Blockchain consensus or safety
- Transaction execution or validation  
- On-chain state integrity
- Validator operations or staking
- User funds on the blockchain

The impact is limited to the NFT metadata indexing infrastructure, which is separate from core blockchain operations.

## Likelihood Explanation
**High Likelihood** - This vulnerability is triggered automatically every time the NFT metadata crawler service starts with credentials configured. The exposure happens by design due to the derived `Debug` implementation, making it inevitable rather than requiring special conditions or attacker actions.

However, exploitation requires the attacker to have access to log files, monitoring systems, or error tracking platforms where these logs are stored.

## Recommendation
Implement a custom `Debug` implementation for `ParserConfig` that redacts sensitive fields:

```rust
impl std::fmt::Debug for ParserConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("ParserConfig")
            .field("google_application_credentials", &"[REDACTED]")
            .field("bucket", &self.bucket)
            .field("cdn_prefix", &self.cdn_prefix)
            .field("ipfs_prefix", &self.ipfs_prefix)
            .field("ipfs_auth_key", &"[REDACTED]")
            .field("max_file_size_bytes", &self.max_file_size_bytes)
            .field("image_quality", &self.image_quality)
            .field("max_image_dimensions", &self.max_image_dimensions)
            .field("max_num_parse_retries", &self.max_num_parse_retries)
            .field("ack_parsed_uris", &self.ack_parsed_uris)
            .field("uri_blacklist", &self.uri_blacklist)
            .finish()
    }
}
```

Remove `Debug` from the derive macro and implement it manually to ensure credentials are never printed.

## Proof of Concept

Create a test file demonstrating the credential leakage:

```rust
// test_credential_leak.rs
use serde_json;

#[derive(Clone, Debug, serde::Deserialize, serde::Serialize)]
struct ParserConfig {
    pub google_application_credentials: Option<String>,
    pub ipfs_auth_key: Option<String>,
    pub bucket: String,
}

fn main() {
    let config = ParserConfig {
        google_application_credentials: Some("/path/to/secret/credentials.json".to_string()),
        ipfs_auth_key: Some("super_secret_ipfs_key_12345".to_string()),
        bucket: "my-nft-bucket".to_string(),
    };
    
    // This simulates what happens in config.rs line 88
    println!("Starting with config: {:?}", config);
    
    // Output shows:
    // Starting with config: ParserConfig { 
    //   google_application_credentials: Some("/path/to/secret/credentials.json"), 
    //   ipfs_auth_key: Some("super_secret_ipfs_key_12345"), 
    //   bucket: "my-nft-bucket" 
    // }
    
    // Credentials are exposed in plaintext!
}
```

Run with: `rustc test_credential_leak.rs && ./test_credential_leak`

The output clearly shows both credentials in plaintext, demonstrating how they would appear in production logs.

## Notes
While this is a legitimate security concern for credential management best practices, it should be noted that this issue is in the NFT metadata crawler infrastructure component, not in the core Aptos blockchain consensus, execution, or state management layers. The vulnerability does not affect blockchain safety, transaction validity, or on-chain asset security.

### Citations

**File:** ecosystem/nft-metadata-crawler/src/parser/config.rs (L10-17)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct ParserConfig {
    pub google_application_credentials: Option<String>,
    pub bucket: String,
    pub cdn_prefix: String,
    pub ipfs_prefix: String,
    pub ipfs_auth_key: Option<String>,
```

**File:** ecosystem/nft-metadata-crawler/src/config.rs (L30-37)
```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(tag = "type")]
pub enum ServerConfig {
    Parser(ParserConfig),
    AssetUploaderWorker(AssetUploaderWorkerConfig),
    AssetUploaderApi,
    AssetUploaderThrottler(AssetUploaderThrottlerConfig),
}
```

**File:** ecosystem/nft-metadata-crawler/src/config.rs (L88-88)
```rust
        info!("[NFT Metadata Crawler] Starting with config: {:?}", self);
```
