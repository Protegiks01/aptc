# Audit Report

## Title
Block Epilogue Transaction Logs Not Flushed Due to Incorrect partition_point Calculation

## Summary
The `partition_point` calculation in `execute_block_on_thread_pool()` incorrectly assumes transaction outputs are properly partitioned (all non-retry before all retry statuses). When a block is cut early and a block epilogue transaction is created, this assumption is violated, causing speculative logs for the block epilogue transaction to not be flushed.

## Finding Description

The vulnerability exists in the speculative log flushing logic: [1](#0-0) 

The code uses `partition_point` to find the boundary between non-retry and retry transactions, then flushes logs up to that point. However, `partition_point` assumes the array is properly partitioned—all elements satisfying the predicate come before all elements that don't.

This assumption breaks when a block epilogue transaction is created. The block epilogue execution records its output at a different index than its data: [2](#0-1) 

When blocks are cut early (e.g., gas limits), the output vector structure becomes:
- Indices 0 to k: Non-retry status (committed transactions)
- Indices k+1 to num_txns-1: Retry status (skip_output placeholders)
- Index num_txns: Non-retry status (block epilogue transaction)

This violates the partitioning assumption. The `partition_point` returns k+1 (first retry index), causing `flush_speculative_logs(k+1)` to only flush logs for indices 0 to k, completely missing the block epilogue transaction at index num_txns.

The skip_output placeholder has Retry status: [3](#0-2) 

Meanwhile, the block epilogue transaction is executed normally and has a Keep status: [4](#0-3) 

The final results array is initialized with skip_output placeholders: [5](#0-4) 

And the TransactionStatus::Retry check confirms only the Retry variant returns true: [6](#0-5) 

## Impact Explanation

This is a **Medium Severity** vulnerability as it causes state inconsistencies requiring intervention:

1. **Lost Diagnostic Information**: Block epilogue transaction logs are never flushed, causing loss of critical debugging and monitoring information
2. **Inconsistent Logging State**: The speculative logging system maintains incorrect state, potentially affecting subsequent block executions
3. **Information Leakage Risk**: Unflushed logs remain in memory longer than intended, potentially exposing sensitive execution details
4. **Operational Impact**: Validator operators lose visibility into block epilogue execution, hindering debugging of consensus or execution issues

While this doesn't directly cause fund loss or consensus violations, it creates state inconsistencies that require manual intervention and affects the observability guarantees of the system.

## Likelihood Explanation

**High Likelihood** - This occurs in normal blockchain operation:

1. **Common Trigger**: Blocks frequently hit gas limits in production, triggering early termination
2. **Automatic Creation**: Block epilogue transactions are automatically created when blocks are cut early with certain conditions
3. **No Special Privileges**: No attacker action needed—this is a bug in normal execution flow
4. **Reproducible**: Happens deterministically whenever a block is cut early and must_create_epilogue_txn is true

The conditions are met in standard validator operation, making this a regularly occurring issue.

## Recommendation

Fix the partition_point calculation to account for the block epilogue transaction at the end of the array. Two approaches:

**Option 1: Find the actual number of non-retry transactions**
```rust
let pos = output_vec.iter().filter(|o| !o.status().is_retry()).count();
```

**Option 2: Check if block epilogue exists and add it**
```rust
let pos = output_vec.partition_point(|o| !o.status().is_retry());
let pos = if block_epilogue_txn.is_some() && pos < output_vec.len() 
    && !output_vec.last().unwrap().status().is_retry() {
    output_vec.len()
} else {
    pos
};
```

**Option 3 (Recommended): Fix the output ordering**
Ensure block epilogue output is placed contiguously with committed transactions rather than at the end, maintaining proper partitioning.

## Proof of Concept

```rust
// Reproduction scenario:
// 1. Create a block with 10 transactions
// 2. Execute transactions 0-4 successfully
// 3. Transaction 4 triggers gas limit (SkipRest)
// 4. Block epilogue is created at index 5, output recorded at index 10
// 5. Final output_vec structure:
//    [0..4]: Keep(Success) - is_retry() = false
//    [5..9]: Retry - is_retry() = true  
//    [10]: Keep(Success) - is_retry() = false (BLOCK EPILOGUE)
//
// partition_point returns 5 (first retry)
// flush_speculative_logs(5) only flushes [0..4]
// Block epilogue logs at index 10 are NEVER FLUSHED

#[test]
fn test_partition_point_block_epilogue_bug() {
    use aptos_types::transaction::TransactionStatus;
    
    let mut outputs = vec![];
    // Committed transactions
    for _ in 0..5 {
        outputs.push(create_output_with_status(TransactionStatus::Keep(ExecutionStatus::Success)));
    }
    // Retry placeholders
    for _ in 0..5 {
        outputs.push(create_output_with_status(TransactionStatus::Retry));
    }
    // Block epilogue at end
    outputs.push(create_output_with_status(TransactionStatus::Keep(ExecutionStatus::Success)));
    
    let pos = outputs.iter().position(|o| o.status().is_retry()).unwrap();
    assert_eq!(pos, 5); // partition_point would return 5
    
    // But we have 6 non-retry transactions (0-4 and 10)!
    let actual_non_retry = outputs.iter().filter(|o| !o.status().is_retry()).count();
    assert_eq!(actual_non_retry, 6);
    
    // Bug: only 5 logs flushed instead of 6
    assert_ne!(pos, actual_non_retry);
}
```

## Notes

The vulnerability affects all block executions where early termination and block epilogue creation coincide. The block epilogue is responsible for updating epoch information and distributing fees, making its logs particularly important for validator operations and debugging. The lost logs could hide critical execution anomalies or consensus-related issues during epoch transitions.

### Citations

**File:** aptos-move/aptos-vm/src/block_executor/mod.rs (L379-381)
```rust
    fn skip_output() -> Self {
        Self::new(VMOutput::empty_with_status(TransactionStatus::Retry))
    }
```

**File:** aptos-move/aptos-vm/src/block_executor/mod.rs (L560-573)
```rust
                let (transaction_outputs, block_epilogue_txn) = block_output.into_inner();
                let output_vec: Vec<_> = transaction_outputs
                    .into_iter()
                    .map(|output| output.take_output())
                    .collect();

                // Flush the speculative logs of the committed transactions.
                let pos = output_vec.partition_point(|o| !o.status().is_retry());

                if state_view.id() != StateViewId::Miscellaneous {
                    // Speculation is disabled in Miscellaneous context, which is used by testing and
                    // can even lead to concurrent execute_block invocations, leading to errors on flush.
                    flush_speculative_logs(pos);
                }
```

**File:** aptos-move/block-executor/src/executor.rs (L1658-1673)
```rust
                Self::execute_txn_after_commit(
                    &epilogue_txn,
                    &block_epilogue_aux_info,
                    epilogue_txn_idx,
                    incarnation,
                    scheduler,
                    versioned_cache,
                    last_input_output,
                    start_shared_counter,
                    shared_counter,
                    executor,
                    base_view,
                    module_cache,
                    runtime_environment,
                    &self.config.onchain.block_gas_limit_type,
                )?;
```

**File:** aptos-move/block-executor/src/executor.rs (L1680-1684)
```rust
                self.record_finalized_output(
                    epilogue_txn_idx,
                    num_txns as TxnIndex,
                    shared_sync_params,
                )?;
```

**File:** aptos-move/block-executor/src/executor.rs (L1720-1724)
```rust
        let final_results = ExplicitSyncWrapper::new(
            (0..num_txns + 1)
                .map(|_| E::Output::skip_output())
                .collect::<Vec<_>>(),
        );
```

**File:** types/src/transaction/mod.rs (L1609-1611)
```rust
    pub fn is_retry(&self) -> bool {
        matches!(self, Self::Retry)
    }
```
