# Audit Report

## Title
Panic-Inducing Index Out-of-Bounds in Sharded Block Executor Due to Missing Round Count Validation

## Summary
The `ShardedBlockExecutor::execute_block()` function lacks validation that all executor shards return results with identical round counts. The code assumes all shards have the same number of rounds as the first shard, but performs no verification. If any shard returns a different number of rounds (due to bugs, remote executor manipulation, or network corruption), the aggregation logic will panic due to out-of-bounds vector access, crashing the validator node during consensus-critical block execution. [1](#0-0) 

## Finding Description

The vulnerability exists in the result aggregation logic of `ShardedBlockExecutor::execute_block()`. The function determines the number of rounds solely from the first shard's output, then allocates `ordered_results` vector based on this assumption. However, when iterating through all shards to populate this vector, there is no validation that each shard actually has the same number of rounds.

**Critical Code Path:**

1. Line 98 determines rounds from first shard only [2](#0-1) 

2. Line 100 allocates vector based on first shard's round count [3](#0-2) 

3. Lines 102-105 iterate without validation, causing panic if any shard has more rounds than the first [4](#0-3) 

The same vulnerability pattern exists in the aggregator service: [5](#0-4) 

**Attack Vectors:**

1. **Remote Executor Manipulation**: When using `RemoteExecutorClient`, results are deserialized from network messages with no structural validation. A compromised or malicious remote executor could send `RemoteExecutionResult` with inconsistent round counts. [6](#0-5) 

2. **Executor Implementation Bugs**: The `ShardedExecutorService` executes sub-blocks and returns results. A bug causing different execution paths could result in inconsistent round counts. [7](#0-6) 

3. **Network/Deserialization Corruption**: BCS deserialization of `RemoteExecutionResult` has no post-deserialization validation. [8](#0-7) 

This breaks the **Deterministic Execution** invariant: validators must produce identical state roots, but validators experiencing different execution paths (crashes vs. success) cannot maintain consensus.

## Impact Explanation

**Severity: High (potentially Critical)**

This vulnerability causes validator node panics during block execution, which qualifies as **"API crashes" and "Validator node slowdowns"** (High severity) in the Aptos bug bounty criteria. If multiple validators crash simultaneously, it could escalate to **"Total loss of liveness/network availability"** (Critical severity).

**Specific Impacts:**
- **Validator Crashes**: Panic during `execute_block()` terminates the validator process
- **Consensus Disruption**: Crashed validators cannot participate in consensus voting
- **Non-Deterministic Behavior**: Different validators may crash at different times depending on remote executor configuration
- **Chain Halt Risk**: If enough validators (>1/3) crash simultaneously, consensus cannot proceed
- **State Inconsistency**: Partial execution before crash could leave validator state inconsistent

The impact is amplified because this occurs in the critical path between consensus and execution: [9](#0-8) 

## Likelihood Explanation

**Likelihood: Medium to High**

While the `PartitionerV2` correctly creates all shards with identical round counts initially: [10](#0-9) 

The likelihood of exploitation depends on several factors:

**Increasing Likelihood Factors:**
1. **Remote Execution Deployment**: Production systems using `REMOTE_SHARDED_BLOCK_EXECUTOR` are vulnerable to remote executor bugs or compromise
2. **No Input Validation**: Complete absence of defensive validation makes this a latent bug waiting to be triggered
3. **Multiple Vulnerable Code Paths**: Both aggregation functions share this vulnerability
4. **Network Operations**: Deserialization of network messages is inherently risky without validation

**Decreasing Likelihood Factors:**
1. **Correct Implementation Expected**: Under normal operation, executors should return matching structures
2. **Trusted Infrastructure**: Remote executors are likely part of validator's own infrastructure

However, defense-in-depth principles require validation even for trusted components. A single bug in any executor shard can crash the entire validator.

## Recommendation

Add explicit validation that all shards return identical round counts before processing results:

```rust
pub fn execute_block(
    &self,
    state_view: Arc<S>,
    transactions: PartitionedTransactions,
    concurrency_level_per_shard: usize,
    onchain_config: BlockExecutorConfigFromOnchain,
) -> Result<Vec<TransactionOutput>, VMStatus> {
    // ... existing code ...
    
    let (sharded_output, global_output) = self
        .executor_client
        .execute_block(/* ... */)?.into_inner();
    
    // VALIDATION: Ensure all shards have identical round counts
    let num_shards = sharded_output.len();
    if num_shards == 0 {
        return Err(VMStatus::Error(/* appropriate error */));
    }
    
    let expected_num_rounds = sharded_output[0].len();
    for (shard_id, results_from_shard) in sharded_output.iter().enumerate() {
        if results_from_shard.len() != expected_num_rounds {
            return Err(VMStatus::Error(/* error indicating shard_id and round mismatch */));
        }
    }
    
    let num_rounds = expected_num_rounds;
    // ... continue with existing aggregation logic ...
}
```

Apply the same validation in `aggregate_and_update_total_supply`: [11](#0-10) 

## Proof of Concept

```rust
#[test]
fn test_inconsistent_round_counts_cause_panic() {
    use aptos_types::transaction::TransactionOutput;
    
    // Simulate sharded_output with inconsistent round counts
    let num_executor_shards = 3;
    
    // First shard has 2 rounds
    let shard_0 = vec![
        vec![/* TransactionOutput */],
        vec![/* TransactionOutput */],
    ];
    
    // Second shard has 2 rounds (matches)
    let shard_1 = vec![
        vec![/* TransactionOutput */],
        vec![/* TransactionOutput */],
    ];
    
    // Third shard has 3 rounds (MISMATCH - one extra round)
    let shard_2 = vec![
        vec![/* TransactionOutput */],
        vec![/* TransactionOutput */],
        vec![/* TransactionOutput */], // Extra round
    ];
    
    let sharded_output = vec![shard_0, shard_1, shard_2];
    
    // This is the vulnerable code pattern from mod.rs line 98-105
    let num_rounds = sharded_output[0].len(); // = 2
    let mut ordered_results = vec![vec![]; num_executor_shards * num_rounds]; // size = 6
    
    // This loop will panic when processing shard_2's third round (round=2)
    for (shard_id, results_from_shard) in sharded_output.into_iter().enumerate() {
        for (round, result) in results_from_shard.into_iter().enumerate() {
            // When shard_id=2, round=2: index = 2*3 + 2 = 8, but vector size is only 6
            // This causes panic: "index out of bounds: the len is 6 but the index is 8"
            ordered_results[round * num_executor_shards + shard_id] = result;
        }
    }
}
```

**Notes**

This vulnerability is a **defense-in-depth violation** rather than a guaranteed exploit. While the partitioner correctly generates consistent structures, the executor layer performs no validation of this invariant. The vulnerability is exploitable through:

1. Remote executor compromise or bugs
2. Network message corruption during BCS deserialization
3. Any future changes to the partitioner that break the round count invariant

The fix is straightforward: add explicit validation before processing results. This follows the principle that each layer should validate its inputs rather than blindly trusting upstream components, especially when network boundaries are involved.

### Citations

**File:** aptos-move/aptos-vm/src/sharded_block_executor/mod.rs (L98-105)
```rust
        let num_rounds = sharded_output[0].len();
        let mut aggregated_results = vec![];
        let mut ordered_results = vec![vec![]; num_executor_shards * num_rounds];
        // Append the output from individual shards in the round order
        for (shard_id, results_from_shard) in sharded_output.into_iter().enumerate() {
            for (round, result) in results_from_shard.into_iter().enumerate() {
                ordered_results[round * num_executor_shards + shard_id] = result;
            }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_aggregator_service.rs (L168-176)
```rust
pub fn aggregate_and_update_total_supply<S: StateView>(
    sharded_output: &mut Vec<Vec<Vec<TransactionOutput>>>,
    global_output: &mut [TransactionOutput],
    state_view: &S,
    executor_thread_pool: Arc<rayon::ThreadPool>,
) {
    let num_shards = sharded_output.len();
    let num_rounds = sharded_output[0].len();

```

**File:** execution/executor-service/src/remote_executor_client.rs (L163-172)
```rust
    fn get_output_from_shards(&self) -> Result<Vec<Vec<Vec<TransactionOutput>>>, VMStatus> {
        trace!("RemoteExecutorClient Waiting for results");
        let mut results = vec![];
        for rx in self.result_rxs.iter() {
            let received_bytes = rx.recv().unwrap().to_bytes();
            let result: RemoteExecutionResult = bcs::from_bytes(&received_bytes).unwrap();
            results.push(result.inner?);
        }
        Ok(results)
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_executor_service.rs (L185-213)
```rust
    fn execute_block(
        &self,
        transactions: SubBlocksForShard<AnalyzedTransaction>,
        state_view: &S,
        config: BlockExecutorConfig,
    ) -> Result<Vec<Vec<TransactionOutput>>, VMStatus> {
        let mut result = vec![];
        for (round, sub_block) in transactions.into_sub_blocks().into_iter().enumerate() {
            let _timer = SHARDED_BLOCK_EXECUTION_BY_ROUNDS_SECONDS
                .timer_with(&[&self.shard_id.to_string(), &round.to_string()]);
            SHARDED_BLOCK_EXECUTOR_TXN_COUNT.observe_with(
                &[&self.shard_id.to_string(), &round.to_string()],
                sub_block.transactions.len() as f64,
            );
            info!(
                "executing sub block for shard {} and round {}, number of txns {}",
                self.shard_id,
                round,
                sub_block.transactions.len()
            );
            result.push(self.execute_sub_block(sub_block, round, state_view, config.clone())?);
            trace!(
                "Finished executing sub block for shard {} and round {}",
                self.shard_id,
                round
            );
        }
        Ok(result)
    }
```

**File:** execution/executor-service/src/lib.rs (L32-35)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RemoteExecutionResult {
    pub inner: Result<Vec<Vec<TransactionOutput>>, VMStatus>,
}
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L256-276)
```rust
    fn execute_block_sharded<V: VMBlockExecutor>(
        partitioned_txns: PartitionedTransactions,
        state_view: Arc<CachedStateView>,
        onchain_config: BlockExecutorConfigFromOnchain,
    ) -> Result<Vec<TransactionOutput>> {
        if !get_remote_addresses().is_empty() {
            Ok(V::execute_block_sharded(
                &REMOTE_SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        } else {
            Ok(V::execute_block_sharded(
                &SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        }
    }
```

**File:** execution/block-partitioner/src/v2/build_edge.rs (L72-86)
```rust
        let final_num_rounds = state.sub_block_matrix.len();
        let sharded_txns = (0..state.num_executor_shards)
            .map(|shard_id| {
                let sub_blocks: Vec<SubBlock<AnalyzedTransaction>> = (0..final_num_rounds)
                    .map(|round_id| {
                        state.sub_block_matrix[round_id][shard_id]
                            .lock()
                            .unwrap()
                            .take()
                            .unwrap()
                    })
                    .collect();
                SubBlocksForShard::new(shard_id, sub_blocks)
            })
            .collect();
```
