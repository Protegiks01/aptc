# Audit Report

## Title
Aptos Rosetta CLI Missing HTTP Timeout Allows Indefinite Hang via Malicious API Server

## Summary
The `RosettaClient` used by the Aptos Rosetta CLI creates HTTP clients without any timeout configuration, allowing malicious Rosetta API servers to cause indefinite hangs in CLI operations by accepting connections but never responding. This enables denial-of-service attacks against CLI users.

## Finding Description
The `RosettaClient` implementation creates a `reqwest::Client` without timeout configuration. [1](#0-0) 

When the CLI executes account balance queries, it uses this client to make HTTP requests. [2](#0-1) 

The underlying HTTP request in `make_call()` has no timeout protection. [3](#0-2) 

By default, `reqwest::Client::new()` creates a client with **no timeout**, meaning HTTP requests can hang indefinitely if the server accepts the TCP connection but never sends a response. This violates the **Resource Limits** invariant that "all operations must respect gas, storage, and computational limits" - including reasonable timeout limits.

**Attack scenario:**
1. Attacker sets up a malicious Rosetta API server that accepts TCP connections but never sends HTTP responses
2. Attacker tricks user into connecting to malicious server (via social engineering, DNS hijacking, or misconfiguration)
3. User runs: `aptos-rosetta-cli account balance --rosetta-api-url http://malicious-server:8082 --account 0x1`
4. CLI hangs indefinitely waiting for response that never arrives

Other HTTP clients in the Aptos codebase consistently implement timeout protection. The REST client defaults to 10 seconds [4](#0-3) , and the FaucetClient explicitly sets 10-second timeouts. [5](#0-4) 

## Impact Explanation
This is a **Low Severity** vulnerability per the Aptos bug bounty program, falling under "Non-critical implementation bugs." The impact is limited to:
- Denial-of-service against individual CLI users (not the blockchain network)
- Only affects users who connect to malicious or compromised API servers
- Does not impact consensus, validator operations, or blockchain security
- No funds loss, state corruption, or network-wide impact

The vulnerability affects CLI tool availability but does not compromise the core blockchain infrastructure.

## Likelihood Explanation
**Moderate likelihood** - while the vulnerability is easily exploitable, it requires:
- User to connect to an attacker-controlled or compromised Rosetta API server
- Social engineering or DNS hijacking to redirect users
- Users typically connect to trusted API endpoints

The vulnerability affects both the CLI tool [6](#0-5)  and test code [7](#0-6) .

## Recommendation
Add timeout configuration to `RosettaClient` following the pattern used by other HTTP clients in the codebase:

```rust
// In crates/aptos-rosetta/src/client.rs
use std::time::Duration;

impl RosettaClient {
    pub fn new(address: Url) -> RosettaClient {
        RosettaClient {
            address,
            inner: ReqwestClient::builder()
                .timeout(Duration::from_secs(10))
                .build()
                .unwrap(),
        }
    }
    
    // Optional: Add a constructor with configurable timeout
    pub fn new_with_timeout(address: Url, timeout: Duration) -> RosettaClient {
        RosettaClient {
            address,
            inner: ReqwestClient::builder()
                .timeout(timeout)
                .build()
                .unwrap(),
        }
    }
}
```

## Proof of Concept

**Step 1: Create malicious server (Python)**
```python
import socket
import time

# Create server that accepts but never responds
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind(('0.0.0.0', 8082))
server.listen(5)

print("Malicious Rosetta API server listening on port 8082...")
print("Accepts connections but never sends response")

while True:
    client, addr = server.accept()
    print(f"Connection from {addr} - accepting but not responding")
    # Accept connection but never send response
    time.sleep(999999)
```

**Step 2: Run Aptos Rosetta CLI**
```bash
# This will hang indefinitely
aptos-rosetta-cli account balance \
  --rosetta-api-url http://localhost:8082 \
  --account 0x1 \
  --chain-id TESTING
```

**Expected result with current code:** CLI hangs indefinitely (no timeout)

**Expected result after fix:** CLI returns timeout error after 10 seconds

## Notes
The vulnerability is consistent across all `RosettaClient` operations (account balance, block queries, construction endpoints) since they all use the same underlying `make_call()` method without timeout protection. The fix should be applied at the client initialization level to protect all API calls uniformly.

### Citations

**File:** crates/aptos-rosetta/src/client.rs (L39-44)
```rust
    pub fn new(address: Url) -> RosettaClient {
        RosettaClient {
            address,
            inner: ReqwestClient::new(),
        }
    }
```

**File:** crates/aptos-rosetta/src/client.rs (L131-149)
```rust
    async fn make_call<'a, I: Serialize + Debug, O: DeserializeOwned>(
        &'a self,
        path: &'static str,
        request: &'a I,
    ) -> anyhow::Result<O> {
        let response = self
            .inner
            .post(self.address.join(path)?)
            .header(CONTENT_TYPE, JSON)
            .body(serde_json::to_string(request)?)
            .send()
            .await?;
        if !response.status().is_success() {
            let error: Error = response.json().await?;
            return Err(anyhow!("Failed API with: {:?}", error));
        }

        Ok(response.json().await?)
    }
```

**File:** crates/aptos-rosetta-cli/src/account.rs (L61-73)
```rust
        let client = self.url_args.client();
        client
            .account_balance(&AccountBalanceRequest {
                network_identifier: self.network_args.network_identifier(),
                account_identifier,
                block_identifier: self.block_args.into(),
                currencies: if self.filter_currency {
                    Some(vec![native_coin()])
                } else {
                    None
                },
            })
            .await
```

**File:** crates/aptos-rest-client/src/client_builder.rs (L50-56)
```rust
        let mut client_builder = Self {
            reqwest_builder: ReqwestClient::builder(),
            base_url: aptos_base_url.to_url(),
            version_path_base: DEFAULT_VERSION_PATH_BASE.to_string(),
            timeout: Duration::from_secs(10), // Default to 10 seconds
            headers,
        };
```

**File:** crates/aptos-rest-client/src/faucet.rs (L42-45)
```rust
            inner: ReqwestClient::builder()
                .timeout(Duration::from_secs(10))
                .build()
                .unwrap(),
```

**File:** crates/aptos-rosetta-cli/src/common.rs (L53-58)
```rust
impl UrlArgs {
    /// Retrieve a [`RosettaClient`]
    pub fn client(self) -> RosettaClient {
        RosettaClient::new(self.rosetta_api_url)
    }
}
```

**File:** testsuite/smoke-test/src/rosetta.rs (L105-105)
```rust
    let rosetta_client = RosettaClient::new(rosetta_url);
```
