# Audit Report

## Title
Critical Authorization Bypass in Aptos Inspection Service Exposing Validator Network Topology and Internal State

## Summary
The Aptos Inspection Service exposes highly sensitive validator information (peer network topology, connection metadata, validator set, and internal node state) over HTTP without implementing any authorization, authentication, or IP-based access control mechanisms. Any network attacker who can reach the service port (default 9101) can query internal validator state, enabling reconnaissance for targeted attacks on the consensus network.

## Finding Description

The `start_inspection_service()` function creates an HTTP server that processes requests through the `serve_requests()` handler [1](#0-0) , which implements **zero authorization checks**. The function only verifies whether configuration flags are enabled, but performs no authentication, IP whitelisting, or any other access control before serving sensitive data.

The service binds to `0.0.0.0` by default [2](#0-1) , making it accessible from all network interfaces. Multiple sensitive endpoints are enabled by default:

- `expose_peer_information: true` - Exposes complete network topology
- `expose_identity_information: true` - Exposes validator peer IDs

For non-mainnet nodes, the configuration optimizer automatically enables ALL endpoints including configuration exposure [3](#0-2) .

The `/peer_information` endpoint exposes critical validator network data without authorization [4](#0-3) . This includes:

1. **Complete peer network topology** - All connected peer IDs, network addresses, and roles [5](#0-4) 

2. **Trusted validator set** - The complete list of trusted peers including validator set members [6](#0-5) 

3. **Internal client states** - Detailed debugging information about peer connections [7](#0-6) 

4. **State sync metadata** - Peer scores, bucket IDs, advertised storage summaries, and request/response counts [8](#0-7) 

The exposed `NetworkInformationResponse` structure reveals each peer's network address, peer ID, and role [9](#0-8) , while `NodeInformationResponse` exposes build information, sync status, ledger version, and uptime [10](#0-9) .

The codebase demonstrates awareness of this security issue: the Docker Compose configuration explicitly comments to "Preface these with 127 to only expose them locally" and binds the port to `127.0.0.1:9101` [11](#0-10) , proving developers recognize the need for network-level protection.

**Attack Scenario:**
1. Attacker identifies an Aptos validator node IP address (e.g., from public network scanners)
2. Attacker sends: `curl http://<validator-ip>:9101/peer_information`
3. Service returns complete network topology, peer IDs, connection states, and validator set without authentication
4. Attacker queries multiple validators to map entire consensus network
5. Attacker uses this intelligence to:
   - Identify high-value validator targets with critical network positions
   - Time attacks based on sync status and block propagation patterns
   - Launch targeted DDoS attacks on specific validators
   - Perform eclipse attacks by understanding peer relationships
   - Exploit timing windows during state synchronization

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under the Aptos Bug Bounty program for the following reasons:

**Information Disclosure Leading to Consensus Attack Enablement:**
While this is an information disclosure vulnerability, it directly enables attacks on consensus safety and liveness by providing attackers with:

- Complete validator network topology for targeted attacks
- Real-time sync status for timing attacks during block propagation
- Validator identity and connectivity for eclipse attack planning
- Peer relationship mapping for network partition attacks

**Operational Security Breach:**
The vulnerability breaks fundamental security principles of validator operation:
- Exposes internal network architecture that should be private
- Reveals validator identities and their network positions
- Provides real-time operational intelligence to adversaries
- Enables reconnaissance without any detection mechanism

**Wide Attack Surface:**
- Affects ALL Aptos validators and fullnodes that don't explicitly firewall port 9101
- Default configuration creates vulnerability on fresh deployments
- No warning or security guidance in code or documentation
- Automatic enablement on non-mainnet networks increases exposure

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to be exploited because:

1. **Default Insecure Configuration:** The service binds to `0.0.0.0` by default with sensitive endpoints enabled, requiring operators to explicitly secure it

2. **No Security Warnings:** There are no code comments, documentation warnings, or configuration sanitizers that alert operators to this security risk (except for the sanitizer preventing configuration exposure on mainnet validators)

3. **Easy Exploitation:** Attack requires only a simple HTTP GET request with no authentication bypass techniques needed

4. **Discoverable:** Port 9101 is easily identifiable through network scanning, and validators often have public IP addresses

5. **Deployment Variability:** While Docker Compose configurations show secure localhost binding, many operators:
   - Deploy without Docker
   - Use custom deployment scripts
   - May not be aware of the security implications
   - May assume config flags provide sufficient protection

6. **Real-World Impact:** Any production validator that hasn't explicitly configured firewall rules or localhost binding is vulnerable

## Recommendation

**Immediate Mitigations:**

1. **Change Default Binding Address:**
   Modify the default address to bind only to localhost:
   ```rust
   address: "127.0.0.1".to_string(),  // Changed from "0.0.0.0"
   ```

2. **Disable Sensitive Endpoints by Default:**
   Change default values in `InspectionServiceConfig`:
   ```rust
   expose_peer_information: false,      // Changed from true
   expose_identity_information: false,  // Changed from true
   ```

3. **Implement Authorization Layer:**
   Add IP whitelist or authentication token support:
   ```rust
   pub struct InspectionServiceConfig {
       pub address: String,
       pub port: u16,
       pub allowed_ips: Vec<String>,  // New field
       pub auth_token: Option<String>, // New field
       // ... existing fields
   }
   ```

4. **Add Request Authorization Check:**
   Modify `serve_requests()` to verify authorization before processing requests:
   ```rust
   async fn serve_requests(
       req: Request<Body>,
       node_config: NodeConfig,
       aptos_data_client: AptosDataClient,
       peers_and_metadata: Arc<PeersAndMetadata>,
   ) -> Result<Response<Body>, hyper::Error> {
       // Verify authorization (IP whitelist or token)
       if !is_authorized(&req, &node_config) {
           return Ok(Response::builder()
               .status(StatusCode::FORBIDDEN)
               .body(Body::from("Unauthorized"))
               .unwrap());
       }
       // ... rest of function
   }
   ```

5. **Add Configuration Sanitizer:**
   Add a sanitizer check to prevent exposing sensitive endpoints on public networks:
   ```rust
   // In ConfigSanitizer implementation
   if inspection_service_config.address == "0.0.0.0" 
       && (inspection_service_config.expose_peer_information
           || inspection_service_config.expose_identity_information) {
       return Err(Error::ConfigSanitizerFailed(
           sanitizer_name,
           "Inspection service must not bind to 0.0.0.0 with sensitive endpoints enabled. Use 127.0.0.1 or implement IP whitelisting.".to_string(),
       ));
   }
   ```

6. **Add Security Documentation:**
   Document in code comments and deployment guides that this service must be protected by firewalls or bound to localhost only.

## Proof of Concept

**Setup:**
Deploy an Aptos validator or fullnode with default configuration.

**Exploitation Steps:**

```bash
# Step 1: Identify target validator IP
TARGET_IP="<validator-ip-address>"

# Step 2: Query peer information endpoint (no authentication required)
curl -v "http://${TARGET_IP}:9101/peer_information"

# Expected output: Complete network topology including:
# - All connected peer IDs and network addresses
# - Trusted validator set members
# - Connection states and metadata
# - State sync status and peer scores
# - Internal client states

# Step 3: Query identity information
curl -v "http://${TARGET_IP}:9101/identity_information"

# Expected output: Validator network peer IDs and fullnode network peer IDs

# Step 4: Query node information
curl -v "http://${TARGET_IP}:9101/system_information"

# Expected output: Build information, sync status, uptime

# Step 5: Repeat for multiple validators to map entire network
for validator in validator1 validator2 validator3; do
    curl "http://${validator}:9101/peer_information" >> network_topology.txt
done

# Result: Complete Aptos consensus network topology without any authentication
```

**Verification Test (Rust):**

```rust
#[tokio::test]
async fn test_unauthorized_access_to_sensitive_endpoints() {
    // Start inspection service with default config
    let node_config = NodeConfig::default();
    let aptos_data_client = create_test_data_client();
    let peers_and_metadata = Arc::new(create_test_peers_metadata());
    
    start_inspection_service(
        node_config.clone(),
        aptos_data_client,
        peers_and_metadata
    );
    
    // Attempt to access peer information without credentials
    let client = reqwest::Client::new();
    let response = client
        .get(format!(
            "http://{}:{}/peer_information",
            node_config.inspection_service.address,
            node_config.inspection_service.port
        ))
        .send()
        .await
        .unwrap();
    
    // VULNERABILITY: Should return 401/403, but returns 200 with sensitive data
    assert_eq!(response.status(), 200);
    let body = response.text().await.unwrap();
    assert!(body.contains("Peer information summary"));
    assert!(body.contains("Connection metadata"));
    assert!(body.contains("Trusted peers"));
}
```

## Notes

This vulnerability represents a critical operational security failure that breaks the principle of defense-in-depth. While the inspection service is intended for debugging and monitoring, the lack of any authorization mechanism transforms it into an intelligence-gathering tool for adversaries.

The issue is particularly concerning because:
- The default configuration creates the vulnerability
- There's evidence (Docker Compose file) that developers understand the risk but haven't enforced protection at the code level
- Operators may reasonably assume that disabling `expose_configuration` is sufficient, while peer and identity information remain exposed by default
- The automatic enablement of all endpoints on non-mainnet networks (testnets, devnets) may lead operators to overlook security hardening when deploying to production

This finding emphasizes the need for secure-by-default configurations and explicit authorization mechanisms for any service exposing internal system state, especially in blockchain validator environments where operational security directly impacts consensus safety.

### Citations

**File:** crates/aptos-inspection-service/src/server/mod.rs (L104-198)
```rust
async fn serve_requests(
    req: Request<Body>,
    node_config: NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> Result<Response<Body>, hyper::Error> {
    // Process the request and get the response components
    let (status_code, body, content_type) = match req.uri().path() {
        CONFIGURATION_PATH => {
            // /configuration
            // Exposes the node configuration
            configuration::handle_configuration_request(&node_config)
        },
        CONSENSUS_HEALTH_CHECK_PATH => {
            // /consensus_health_check
            // Exposes the consensus health check
            metrics::handle_consensus_health_check(&node_config).await
        },
        FORGE_METRICS_PATH => {
            // /forge_metrics
            // Exposes forge encoded metrics
            metrics::handle_forge_metrics()
        },
        IDENTITY_INFORMATION_PATH => {
            // /identity_information
            // Exposes the identity information of the node
            identity_information::handle_identity_information_request(&node_config)
        },
        INDEX_PATH => {
            // /
            // Exposes the index and list of available endpoints
            index::handle_index_request()
        },
        JSON_METRICS_PATH => {
            // /json_metrics
            // Exposes JSON encoded metrics
            metrics::handle_json_metrics_request()
        },
        METRICS_PATH => {
            // /metrics
            // Exposes text encoded metrics
            metrics::handle_metrics_request()
        },
        PEER_INFORMATION_PATH => {
            // /peer_information
            // Exposes the peer information
            peer_information::handle_peer_information_request(
                &node_config,
                aptos_data_client,
                peers_and_metadata,
            )
        },
        SYSTEM_INFORMATION_PATH => {
            // /system_information
            // Exposes the system and build information
            system_information::handle_system_information_request(node_config)
        },
        _ => {
            // Handle the invalid path
            (
                StatusCode::NOT_FOUND,
                Body::from(INVALID_ENDPOINT_MESSAGE),
                CONTENT_TYPE_TEXT.into(),
            )
        },
    };

    // Create a response builder
    let response_builder = Response::builder()
        .header(HEADER_CONTENT_TYPE, content_type)
        .status(status_code);

    // Build the response based on the request methods
    let response = match *req.method() {
        Method::HEAD => response_builder.body(Body::empty()), // Return only the headers
        Method::GET => response_builder.body(body),           // Include the response body
        _ => {
            // Invalid method found
            Response::builder()
                .status(StatusCode::METHOD_NOT_ALLOWED)
                .body(Body::empty())
        },
    };

    // Return the processed response
    Ok(response.unwrap_or_else(|error| {
        // Log the internal error
        debug!("Error encountered when generating response: {:?}", error);

        // Return a failure response
        let mut response = Response::new(Body::from(UNEXPECTED_ERROR_MESSAGE));
        *response.status_mut() = StatusCode::INTERNAL_SERVER_ERROR;
        response
    }))
}
```

**File:** config/src/config/inspection_service_config.rs (L26-37)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
}
```

**File:** config/src/config/inspection_service_config.rs (L71-109)
```rust
impl ConfigOptimizer for InspectionServiceConfig {
    fn optimize(
        node_config: &mut NodeConfig,
        local_config_yaml: &Value,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<bool, Error> {
        let inspection_service_config = &mut node_config.inspection_service;
        let local_inspection_config_yaml = &local_config_yaml["inspection_service"];

        // Enable all endpoints for non-mainnet nodes (to aid debugging)
        let mut modified_config = false;
        if let Some(chain_id) = chain_id {
            if !chain_id.is_mainnet() {
                if local_inspection_config_yaml["expose_configuration"].is_null() {
                    inspection_service_config.expose_configuration = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_identity_information"].is_null() {
                    inspection_service_config.expose_identity_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_peer_information"].is_null() {
                    inspection_service_config.expose_peer_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_system_information"].is_null() {
                    inspection_service_config.expose_system_information = true;
                    modified_config = true;
                }
            }
        }

        Ok(modified_config)
    }
}
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L20-38)
```rust
/// Handles a new peer information request
pub fn handle_peer_information_request(
    node_config: &NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> (StatusCode, Body, String) {
    // Only return peer information if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_peer_information {
        let peer_information = get_peer_information(aptos_data_client, peers_and_metadata);
        (StatusCode::OK, Body::from(peer_information))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(PEER_INFO_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L128-146)
```rust
/// Displays the internal client state for each peer
fn display_internal_client_state(
    peer_information_output: &mut Vec<String>,
    all_peers: &Vec<PeerNetworkId>,
    peers_and_metadata: &PeersAndMetadata,
) {
    peer_information_output.push("Internal client state for each peer:".into());

    // Fetch and display the internal client state for each peer
    for peer in all_peers {
        if let Ok(peer_metadata) = peers_and_metadata.get_metadata_for_peer(*peer) {
            let peer_monitoring_metadata = peer_metadata.get_peer_monitoring_metadata();
            peer_information_output.push(format!(
                "\t- Peer: {}, internal client state: {:?}",
                peer, peer_monitoring_metadata.internal_client_state
            ));
        }
    }
}
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L148-168)
```rust
/// Displays connection metadata for each peer
fn display_peer_connection_metadata(
    peer_information_output: &mut Vec<String>,
    all_peers: &Vec<PeerNetworkId>,
    peers_and_metadata: &PeersAndMetadata,
) {
    peer_information_output.push("Connection metadata for each peer:".into());

    // Fetch and display the connection metadata for each peer
    for peer in all_peers {
        if let Ok(peer_metadata) = peers_and_metadata.get_metadata_for_peer(*peer) {
            let connection_metadata = peer_metadata.get_connection_metadata();
            peer_information_output.push(format!(
                "\t- Peer: {}, connection state: {:?}, connection metadata: {}",
                peer,
                peer_metadata.get_connection_state(),
                serde_json::to_string(&connection_metadata).unwrap_or_default()
            ));
        }
    }
}
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L205-271)
```rust
/// Displays state sync metadata for each peer
fn display_state_sync_metadata(
    peer_information_output: &mut Vec<String>,
    all_peers: &Vec<PeerNetworkId>,
    aptos_data_client: AptosDataClient,
) {
    peer_information_output.push("State sync metadata for each peer:".into());

    // Fetch and display the priority and regular peers
    if let Ok((priority_peers, regular_peers)) = aptos_data_client.get_priority_and_regular_peers()
    {
        // Sort the peer lists before displaying them
        let mut priority_peers: Vec<_> = priority_peers.into_iter().collect();
        priority_peers.sort();
        let mut regular_peers: Vec<_> = regular_peers.into_iter().collect();
        regular_peers.sort();

        // Display the priority and regular peers
        peer_information_output.push(format!(
            "\t- Priority peers: {:?}, regular peers: {:?}",
            priority_peers, regular_peers
        ));
    }

    // Fetch and display the global advertised data summary
    let global_data_summary = aptos_data_client.get_global_data_summary();
    peer_information_output.push(format!(
        "\t- Global advertised data summary: {:?}",
        global_data_summary
    ));

    // Fetch and display the state sync metadata for each peer
    let peer_to_state = aptos_data_client.get_peer_states().get_peer_to_states();
    for peer in all_peers {
        if let Some(peer_state_entry) = peer_to_state.get(peer) {
            // Get the peer states
            let peer = *peer_state_entry.key();
            let peer_bucket_id = peer_states::get_bucket_id_for_peer(peer);
            let peer_score = peer_state_entry.get_score();
            let peer_storage_summary = peer_state_entry.get_storage_summary();

            // Display the peer states
            peer_information_output.push(format!(
                "\t- Peer: {}, score: {}, bucket ID: {}",
                peer, peer_score, peer_bucket_id
            ));
            peer_information_output.push(format!(
                "\t\t- Advertised storage summary: {:?}",
                peer_storage_summary
            ));

            // Get the peer's request/response counts
            let sent_requests_by_type = peer_state_entry.get_sent_requests_by_type();
            let received_responses_by_type = peer_state_entry.get_received_responses_by_type();

            // Display the peer's request/response counts
            peer_information_output.push(format!(
                "\t\t- Sent requests by type: {:?}",
                sent_requests_by_type
            ));
            peer_information_output.push(format!(
                "\t\t- Received responses by type: {:?}",
                received_responses_by_type
            ));
        }
    }
}
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L273-300)
```rust
/// Displays the entire set of trusted peers
fn display_trusted_peers(
    peer_information_output: &mut Vec<String>,
    registered_networks: Vec<NetworkId>,
    peers_and_metadata: &PeersAndMetadata,
) {
    peer_information_output.push("Trusted peers (validator set & seeds):".into());

    // Fetch and display the trusted peers for each network
    for network in registered_networks {
        peer_information_output.push(format!("\t- Network: {}", network));
        if let Ok(trusted_peers) = peers_and_metadata.get_trusted_peers(&network) {
            // Sort the peers before displaying them
            let mut sorted_trusted_peers = BTreeMap::new();
            for (peer_id, peer_info) in trusted_peers {
                sorted_trusted_peers.insert(peer_id, peer_info);
            }

            // Display the trusted peers
            for (peer_id, peer_info) in sorted_trusted_peers {
                peer_information_output.push(format!(
                    "\t\t- Peer: {:?}, peer information: {:?}",
                    peer_id, peer_info
                ));
            }
        }
    }
}
```

**File:** peer-monitoring-service/types/src/response.rs (L50-75)
```rust
/// A response for the network information request
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct NetworkInformationResponse {
    pub connected_peers: BTreeMap<PeerNetworkId, ConnectionMetadata>, // Connected peers
    pub distance_from_validators: u64, // The distance of the peer from the validator set
}

// Display formatting provides a high-level summary of the response
impl Display for NetworkInformationResponse {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{{ num_connected_peers: {:?}, distance_from_validators: {:?} }}",
            self.connected_peers.len(),
            self.distance_from_validators,
        )
    }
}

/// Simple connection metadata associated with each peer
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct ConnectionMetadata {
    pub network_address: NetworkAddress,
    pub peer_id: PeerId,
    pub peer_role: PeerRole,
}
```

**File:** peer-monitoring-service/types/src/response.rs (L93-102)
```rust
/// A response for the node information request
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct NodeInformationResponse {
    pub build_information: BTreeMap<String, String>, // The build information of the node
    pub highest_synced_epoch: u64,                   // The highest synced epoch of the node
    pub highest_synced_version: u64,                 // The highest synced version of the node
    pub ledger_timestamp_usecs: u64, // The latest timestamp of the blockchain (in microseconds)
    pub lowest_available_version: u64, // The lowest stored version of the node (in storage)
    pub uptime: Duration,            // The amount of time the peer has been running
}
```

**File:** docker/compose/aptos-node/docker-compose-src.yaml (L31-32)
```yaml
      # Preface these with 127 to only expose them locally
      - "127.0.0.1:9101:9101"
```
