# Audit Report

## Title
Missing Cryptographic Verification on DAG Bootstrap Allows Alternative Consensus History Creation via Database Manipulation

## Summary
The DAG consensus system fails to cryptographically verify `CertifiedNode` objects when loading them from the database during bootstrap. While nodes received over the network are properly verified (digest + signatures), nodes loaded from persistent storage undergo only structural validation without verifying digest correctness or signature validity. This allows an attacker with database write access to inject forged nodes that can create alternative consensus histories.

## Finding Description

The vulnerability exists in the bootstrap recovery path of the DAG consensus system. There are two distinct code paths for adding certified nodes to the DAG store:

**Path 1: Network Reception (SECURE)**
When a `CertifiedNode` arrives over the network, it undergoes full cryptographic verification: [1](#0-0) 

This calls `DAGMessage::verify()` which dispatches to `CertifiedNode::verify()`: [2](#0-1) 

This verification checks both digest correctness and signature validity.

**Path 2: Database Bootstrap (VULNERABLE)**
When certified nodes are loaded from the database during node restart, the verification is missing: [3](#0-2) 

The `add_node()` method only calls `validate_new_node()`: [4](#0-3) 

The critical issue is in `validate_new_node()`, which performs only structural checks: [5](#0-4) 

This function checks epoch, author, round range, parent existence, and duplicates, but **NEVER calls `node.verify()`** to validate the digest or signatures.

**Attack Scenario:**
1. Attacker gains write access to the consensus database (via backup manipulation, filesystem exploit, or container escape)
2. Attacker crafts a malicious `CertifiedNode` with:
   - Altered payload (different transactions)
   - Modified parents (different consensus history)
   - Different validator transactions
3. Attacker computes the digest that a legitimate node at that (epoch, round, author) would have
4. Attacker stores the malicious node using BCS serialization with the legitimate digest as the database key: [6](#0-5) 
5. When the validator restarts, `DagStore::new()` loads all nodes from storage
6. The malicious node passes structural validation because the attacker can craft it to have valid epoch, known author, acceptable round, and existing parents
7. The node is accepted into the DAG without cryptographic verification
8. This creates an alternative consensus history that diverges from honest validators

**Broken Invariants:**
- **Consensus Safety**: Violated by allowing consensus history manipulation
- **Cryptographic Correctness**: Signature verification bypassed on bootstrap path

## Impact Explanation

**Critical Severity** - This vulnerability enables **Consensus/Safety violations**, qualifying for the Critical severity category ($1,000,000 per Aptos bug bounty).

**Specific Impacts:**
1. **Consensus Split**: If different validators load different forged nodes, the network can split into incompatible chains
2. **Double-Spending**: Forged nodes with different transaction payloads can enable double-spending attacks
3. **History Rewriting**: Attackers can alter the causal ordering of the DAG, affecting which anchors get committed
4. **Chain Reorganization**: By modifying parent references, attackers can create alternative consensus histories

The attack violates the fundamental security guarantee that "AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine validators."

## Likelihood Explanation

**Prerequisites:**
- Write access to the consensus database filesystem (consensusdb/)
- Knowledge of DAG structure and BCS serialization
- Ability to compute valid digest values

**Likelihood Assessment: MEDIUM**

While this requires database access (not achievable via network alone), realistic attack vectors exist:
1. **Backup/Restore Attack**: Validator operators regularly backup databases; a compromised backup could be modified and restored
2. **Secondary Vulnerability Chaining**: Another vulnerability (RCE, container escape, privilege escalation) could provide database access
3. **Supply Chain Attack**: Compromised deployment/orchestration tools with database access
4. **Insider Threat**: Malicious validator operator with filesystem access

The impact is severe enough that defense-in-depth principles mandate cryptographic verification even for trusted storage.

## Recommendation

Add cryptographic verification to the bootstrap path by calling `verify()` on nodes loaded from storage:

```rust
// In consensus/src/dag/dag_store.rs, modify DagStore::new()
pub fn new(
    epoch_state: Arc<EpochState>,
    storage: Arc<dyn DAGStorage>,
    payload_manager: Arc<dyn TPayloadManager>,
    start_round: Round,
    window_size: u64,
) -> Self {
    let mut all_nodes = storage.get_certified_nodes().unwrap_or_default();
    all_nodes.sort_unstable_by_key(|(_, node)| node.round());
    let mut to_prune = vec![];
    
    let dag = Self::new_empty(
        epoch_state.clone(),
        storage.clone(),
        payload_manager,
        start_round,
        window_size,
    );
    
    for (digest, certified_node) in all_nodes {
        // ADD CRYPTOGRAPHIC VERIFICATION HERE
        if let Err(e) = certified_node.verify(&epoch_state.verifier) {
            debug!("Delete node after bootstrap due to verification failure: {}", e);
            to_prune.push(digest);
            continue;
        }
        
        // Then proceed with existing structural validation
        if let Err(e) = dag.add_node(certified_node) {
            debug!("Delete node after bootstrap due to {}", e);
            to_prune.push(digest);
        }
    }
    
    if let Err(e) = storage.delete_certified_nodes(to_prune) {
        error!("Error deleting expired nodes: {:?}", e);
    }
    
    if dag.read().is_empty() {
        warn!(
            "[DAG] Start with empty DAG store at {}, need state sync",
            start_round
        );
    }
    dag
}
```

This ensures nodes loaded from storage undergo the same cryptographic verification as nodes received over the network.

## Proof of Concept

```rust
// Test demonstrating the vulnerability
// File: consensus/src/dag/tests/dag_store_bootstrap_test.rs

#[cfg(test)]
mod test {
    use super::*;
    use aptos_crypto::HashValue;
    use aptos_consensus_types::common::Payload;
    
    #[test]
    fn test_unverified_node_accepted_from_storage() {
        // Setup: Create legitimate certified node
        let (epoch_state, signer, storage, payload_manager) = setup_test_environment();
        let legitimate_node = create_certified_node(/* ... */);
        let legitimate_digest = legitimate_node.digest();
        
        // Attack: Create malicious node with different payload
        let malicious_payload = Payload::DirectMempool(vec![/* different txns */]);
        let malicious_node = CertifiedNode::new(
            Node::new(
                legitimate_node.epoch(),
                legitimate_node.round(),
                legitimate_node.author(),
                legitimate_node.timestamp(),
                vec![],
                malicious_payload, // DIFFERENT PAYLOAD
                legitimate_node.parents().to_vec(),
                Extensions::empty(),
            ),
            legitimate_node.signatures().clone(), // Signatures won't match!
        );
        
        // Store malicious node with legitimate digest as key
        storage.put::<CertifiedNodeSchema>(&legitimate_digest, &malicious_node).unwrap();
        
        // Bootstrap DAG store - this should reject the node but currently doesn't
        let dag_store = DagStore::new(
            epoch_state,
            storage,
            payload_manager,
            1,
            100,
        );
        
        // BUG: The malicious node is accepted even though:
        // 1. Its digest doesn't match its content
        // 2. Its signatures don't validate
        let loaded_node = dag_store.read().get_node(
            legitimate_node.metadata()
        ).unwrap();
        
        // This assertion SHOULD fail but currently passes
        assert_eq!(loaded_node.payload(), &malicious_payload);
        
        // Cryptographic verification would catch this:
        assert!(loaded_node.verify(&epoch_state.verifier).is_err());
    }
}
```

## Notes

This vulnerability represents a defense-in-depth failure. While database access requires elevated privileges, the cryptographic verification should be consistent across all code paths. The network path correctly enforces verification; the bootstrap path must do the same to maintain security invariants even when storage is compromised.

### Citations

**File:** consensus/src/dag/dag_handler.rs (L102-102)
```rust
                                dag_message.verify(rpc_request.sender, &epoch_state.verifier)
```

**File:** consensus/src/dag/types.rs (L438-442)
```rust
    pub fn verify(&self, verifier: &ValidatorVerifier) -> anyhow::Result<()> {
        ensure!(self.digest() == self.calculate_digest(), "invalid digest");

        Ok(verifier.verify_multi_signatures(self.metadata(), self.signatures())?)
    }
```

**File:** consensus/src/dag/dag_store.rs (L128-164)
```rust
    fn validate_new_node(&mut self, node: &CertifiedNode) -> anyhow::Result<()> {
        ensure!(
            node.epoch() == self.epoch_state.epoch,
            "different epoch {}, current {}",
            node.epoch(),
            self.epoch_state.epoch
        );
        let author = node.metadata().author();
        let index = *self
            .author_to_index
            .get(author)
            .ok_or_else(|| anyhow!("unknown author"))?;
        let round = node.metadata().round();
        ensure!(
            round >= self.lowest_round(),
            "round too low {}, lowest in dag {}",
            round,
            self.lowest_round()
        );
        ensure!(
            round <= self.highest_round() + 1,
            "round too high {}, highest in dag {}",
            round,
            self.highest_round()
        );
        if round > self.lowest_round() {
            for parent in node.parents() {
                ensure!(self.exists(parent.metadata()), "parent not exist");
            }
        }
        let round_ref = self
            .nodes_by_round
            .entry(round)
            .or_insert_with(|| vec![None; self.author_to_index.len()]);
        ensure!(round_ref[index].is_none(), "duplicate node");
        Ok(())
    }
```

**File:** consensus/src/dag/dag_store.rs (L461-477)
```rust
        let mut all_nodes = storage.get_certified_nodes().unwrap_or_default();
        all_nodes.sort_unstable_by_key(|(_, node)| node.round());
        let mut to_prune = vec![];
        // Reconstruct the continuous dag starting from start_round and gc unrelated nodes
        let dag = Self::new_empty(
            epoch_state,
            storage.clone(),
            payload_manager,
            start_round,
            window_size,
        );
        for (digest, certified_node) in all_nodes {
            // TODO: save the storage call in this case
            if let Err(e) = dag.add_node(certified_node) {
                debug!("Delete node after bootstrap due to {}", e);
                to_prune.push(digest);
            }
```

**File:** consensus/src/dag/dag_store.rs (L518-536)
```rust
    pub fn add_node(&self, node: CertifiedNode) -> anyhow::Result<()> {
        self.dag.write().validate_new_node(&node)?;

        // Note on concurrency: it is possible that a prune operation kicks in here and
        // moves the window forward making the `node` stale. Any stale node inserted
        // due to this race will be cleaned up with the next prune operation.

        // mutate after all checks pass
        self.storage.save_certified_node(&node)?;

        debug!("Added node {}", node.id());
        self.payload_manager.prefetch_payload_data(
            node.payload(),
            *node.author(),
            node.metadata().timestamp(),
        );

        self.dag.write().add_validated_node(node)
    }
```

**File:** consensus/src/dag/adapter.rs (L367-371)
```rust
    fn save_certified_node(&self, node: &CertifiedNode) -> anyhow::Result<()> {
        Ok(self
            .consensus_db
            .put::<CertifiedNodeSchema>(&node.digest(), node)?)
    }
```
