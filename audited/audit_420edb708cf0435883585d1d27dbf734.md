# Audit Report

## Title
Type Safety Violation in Randomness Generation Storage Causes Cross-Version Protocol Incompatibility During Upgrades

## Summary
The randomness generation storage layer (`RandDb`) lacks type versioning for `AugData<D>` serialization, causing silent data loss during validator restarts and network protocol incompatibility during rolling upgrades when the `AugmentedData` structure evolves. This breaks consensus liveness by preventing validators on different software versions from exchanging certified augmented data and verifying randomness shares.

## Finding Description

The `get_all_aug_data()` function uses BCS deserialization without any type version discrimination or schema migration mechanism. [1](#0-0) 

When `AugDataStore` initializes, it silently swallows deserialization errors: [2](#0-1) 

The same silent failure occurs for certified augmented data: [3](#0-2) 

The `AugmentedData` structure is defined with fields that have already evolved (note the `Option<Delta>` suggesting later addition): [4](#0-3) 

During rolling upgrades, network messages are deserialized without version checking: [5](#0-4) 

When deserialization fails, messages are silently dropped, preventing validators from receiving certified augmented data from peers running different software versions.

The critical consequence occurs during share verification, which requires certified augmented public keys (APKs). Without receiving certified augmented data from peers, these APKs remain unpopulated: [6](#0-5) 

When APKs are missing, share verification fails with a bail, preventing randomness aggregation. This breaks the consensus invariant that randomness generation must succeed for all validators to process blocks.

The production code hardcodes the type as `RandManager::<Share, AugmentedData>`: [7](#0-6) 

Critically, block processing is gated on having certified augmented data: [8](#0-7) 

There is no database migration or version tracking infrastructure for the randomness database, confirmed by the absence of versioning mechanisms in the schema definitions: [9](#0-8) 

## Impact Explanation

**High Severity** - This meets the "Significant protocol violations" and "Validator node slowdowns" criteria from the Aptos bug bounty program.

**Exploitation Scenario:**
1. Aptos releases v2.0 with modified `AugmentedData` structure (e.g., adding `ultra_fast_delta: Option<Delta>`)
2. During rolling upgrade, validators restart with new binary
3. Validators on v2.0 cannot deserialize certified augmented data from v1.0 validators (and vice versa)
4. Cross-version validators lack certified APKs for each other
5. Share verification fails between version groups
6. If either version group has insufficient stake for quorum (< 2/3), randomness generation fails
7. Consensus blocks waiting for randomness, causing liveness degradation or failure

This breaks the **Deterministic Execution** and **Consensus Safety** invariants - validators on different versions cannot participate in randomness generation together, potentially halting the network during upgrades.

## Likelihood Explanation

**High Likelihood** - This vulnerability will manifest during every software upgrade that modifies the `AugmentedData` structure. The presence of `fast_delta` as an `Option<Delta>` indicates the structure has already evolved and will likely continue evolving as the randomness protocol is enhanced.

Rolling upgrades are standard practice for validator networks to minimize downtime. The vulnerability is not caused by any malicious actor - it's an inherent design flaw in the type system that lacks version discrimination.

## Recommendation

Implement a versioned storage schema and network protocol for augmented data:

```rust
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub enum AugmentedDataVersioned {
    V1(AugmentedDataV1),
    V2(AugmentedDataV2),
}

// Current structure becomes V1
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AugmentedDataV1 {
    delta: Delta,
    fast_delta: Option<Delta>,
}

// Add migration logic in AugDataStore::new()
let all_data = db.get_all_aug_data().unwrap_or_else(|e| {
    error!("Failed to load augmented data: {:?}", e);
    vec![]
});

// In network message handling, add explicit version error handling
match bcs::from_bytes::<RandMessage<S, D>>(rand_gen_msg.req.data()) {
    Ok(msg) => { /* process */ },
    Err(e) => {
        error!("Failed to deserialize rand message (possible version mismatch): {}", e);
        // Optionally: send version negotiation message
    },
}
```

Additionally, add database schema versioning similar to other Aptos storage components, with migration logic to handle upgrades gracefully.

## Proof of Concept

```rust
// Test demonstrating deserialization failure across type changes
#[test]
fn test_augmented_data_version_incompatibility() {
    use bcs;
    use serde::{Deserialize, Serialize};
    
    // Simulate old version
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    struct AugmentedDataOld {
        delta: Vec<u8>, // Simplified for test
        fast_delta: Option<Vec<u8>>,
    }
    
    // Simulate new version with additional field
    #[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
    struct AugmentedDataNew {
        delta: Vec<u8>,
        fast_delta: Option<Vec<u8>>,
        ultra_fast_delta: Option<Vec<u8>>, // NEW FIELD
    }
    
    // Serialize with old structure
    let old_data = AugmentedDataOld {
        delta: vec![1, 2, 3],
        fast_delta: Some(vec![4, 5, 6]),
    };
    let serialized = bcs::to_bytes(&old_data).unwrap();
    
    // Attempt to deserialize as new structure - FAILS
    let result: Result<AugmentedDataNew, _> = bcs::from_bytes(&serialized);
    assert!(result.is_err(), "Deserialization should fail due to missing field");
    
    // Simulate new structure serialization
    let new_data = AugmentedDataNew {
        delta: vec![1, 2, 3],
        fast_delta: Some(vec![4, 5, 6]),
        ultra_fast_delta: Some(vec![7, 8, 9]),
    };
    let serialized_new = bcs::to_bytes(&new_data).unwrap();
    
    // Attempt to deserialize as old structure - FAILS
    let result: Result<AugmentedDataOld, _> = bcs::from_bytes(&serialized_new);
    assert!(result.is_err(), "Deserialization should fail due to extra bytes");
    
    println!("VULNERABILITY CONFIRMED: Cross-version deserialization fails");
}
```

**Notes**

This vulnerability is particularly insidious because:
1. It doesn't cause immediate crashes - errors are silently suppressed
2. It manifests during routine operations (software upgrades) rather than attacks
3. It can cause network-wide liveness failures if upgrade timing is poor
4. There's no recovery mechanism except rollback or emergency hard fork
5. The generic type parameter `D: TAugmentedData` provides compile-time type safety but zero runtime version checking

The fix requires implementing proper versioning at both the storage layer and network protocol layer, similar to how other consensus messages handle backward compatibility.

### Citations

**File:** consensus/src/rand/rand_gen/storage/db.rs (L102-104)
```rust
    fn get_all_aug_data(&self) -> Result<Vec<(AugDataId, AugData<D>)>> {
        Ok(self.get_all::<AugDataSchema<D>>()?)
    }
```

**File:** consensus/src/rand/rand_gen/aug_data_store.rs (L51-51)
```rust
        let all_data = db.get_all_aug_data().unwrap_or_default();
```

**File:** consensus/src/rand/rand_gen/aug_data_store.rs (L57-57)
```rust
        let all_certified_data = db.get_all_certified_aug_data().unwrap_or_default();
```

**File:** consensus/src/rand/rand_gen/types.rs (L45-49)
```rust
#[derive(Clone, Debug, PartialEq, Serialize, Deserialize)]
pub struct AugmentedData {
    delta: Delta,
    fast_delta: Option<Delta>,
}
```

**File:** consensus/src/rand/rand_gen/types.rs (L63-79)
```rust
        let maybe_apk = &rand_config.keys.certified_apks[index];
        if let Some(apk) = maybe_apk.get() {
            WVUF::verify_share(
                &rand_config.vuf_pp,
                apk,
                bcs::to_bytes(&rand_metadata)
                    .map_err(|e| anyhow!("Serialization failed: {}", e))?
                    .as_slice(),
                &self.share,
            )?;
        } else {
            bail!(
                "[RandShare] No augmented public key for validator id {}, {}",
                index,
                author
            );
        }
```

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L236-256)
```rust
                    match bcs::from_bytes::<RandMessage<S, D>>(rand_gen_msg.req.data()) {
                        Ok(msg) => {
                            if msg
                                .verify(
                                    &epoch_state_clone,
                                    &config_clone,
                                    &fast_config_clone,
                                    rand_gen_msg.sender,
                                )
                                .is_ok()
                            {
                                let _ = tx.unbounded_send(RpcRequest {
                                    req: msg,
                                    protocol: rand_gen_msg.protocol,
                                    response_sender: rand_gen_msg.response_sender,
                                });
                            }
                        },
                        Err(e) => {
                            warn!("Invalid rand gen message: {}", e);
                        },
```

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L380-381)
```rust
                Some(blocks) = incoming_blocks.next(), if self.aug_data_store.my_certified_aug_data_exists() => {
                    self.process_incoming_blocks(blocks);
```

**File:** consensus/src/pipeline/execution_client.rs (L240-240)
```rust
        let rand_manager = RandManager::<Share, AugmentedData>::new(
```

**File:** consensus/src/rand/rand_gen/storage/schema.rs (L36-45)
```rust
pub(crate) const AUG_DATA_CF_NAME: ColumnFamilyName = "aug_data";
#[derive(Debug)]
pub struct AugDataSchema<D>(PhantomData<D>);

impl<D: TAugmentedData> Schema for AugDataSchema<D> {
    type Key = AugDataId;
    type Value = AugData<D>;

    const COLUMN_FAMILY_NAME: ColumnFamilyName = AUG_DATA_CF_NAME;
}
```
