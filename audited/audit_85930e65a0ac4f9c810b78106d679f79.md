# Audit Report

## Title
Transaction List Integrity Violation: Partial Transaction Ranges Accepted as Complete in State Sync

## Summary
The `notify_peer_of_new_data()` function in the state sync storage service can return incomplete transaction ranges when the underlying storage iterator terminates early, and the receiving peer accepts this partial data as complete without validation. This breaks the State Consistency invariant, allowing nodes to diverge in their blockchain state.

## Finding Description

The vulnerability exists across three layers of the state sync system:

**Layer 1 - Storage Fetching:** When fetching transactions in `get_transactions_with_proof_by_size`, the function uses storage iterators that may terminate early due to missing data or database corruption. [1](#0-0) 

When the iterator returns `None` prematurely, the code only logs a warning but continues to create a valid cryptographic proof for the **partial** set of transactions actually fetched: [2](#0-1) 

**Layer 2 - Response Creation:** The `notify_peer_of_new_data()` function receives this partial transaction list and directly forwards it without any validation of completeness: [3](#0-2) 

**Layer 3 - Client Validation:** The client processes the response in `create_notification_for_new_data`, calculating the last version based solely on the number of transactions received, without verifying that all requested transactions were returned: [4](#0-3) 

The `update_stream_version_and_epoch` method is called with both `request_end_version` and `last_received_version` set to the **actual last version received**, not the **requested end version**, making gap detection impossible.

The cryptographic verification in `TransactionListWithProof::verify()` only validates that the returned transactions are correct, not that all requested transactions were returned: [5](#0-4) 

**Attack Scenario:**

1. Node A requests transactions 100-109 from Node B (via optimistic fetch or subscription)
2. Node B's storage has corruption/missing data after transaction 104
3. The storage iterator in `get_transactions_with_proof_by_size` terminates at transaction 104
4. Node B creates a valid proof for transactions 100-104 only
5. Node A receives the response and calculates `last_version = 100 + 5 - 1 = 104`
6. Node A updates its state to version 104 and requests 105-109 next
7. If versions 105-109 are also missing, Node A permanently has a gap in its blockchain state
8. Node A now has different state than nodes that successfully synced all transactions

This breaks the **State Consistency** invariant: different nodes can have different transaction histories at the same version number, leading to consensus divergence.

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under the Aptos bug bounty program:

- **Consensus/Safety violations**: Nodes accepting partial transaction ranges will have different state roots at the same ledger version, violating the fundamental consensus invariant that all honest nodes must agree on the blockchain state
- **State inconsistencies requiring intervention**: Once a node accepts incomplete data, it continues syncing from the wrong point, creating permanent gaps that require manual intervention to fix
- **Deterministic Execution violation**: Different nodes executing the "same" set of transactions (but actually different due to gaps) will produce different state roots

The impact extends to:
- **Governance**: Missing governance transactions could cause voting power miscalculations
- **Staking**: Missing stake pool updates could corrupt validator set management  
- **Fund transfers**: Missing transactions mean lost visibility into fund movements
- **Smart contracts**: Missing events and state updates break contract functionality

## Likelihood Explanation

This vulnerability has **HIGH likelihood** of occurrence:

1. **Natural triggers**: Database corruption, disk failures, or incomplete replication can cause storage iterators to end early - these are realistic operational scenarios
2. **No explicit validation**: There is no check anywhere in the codebase that validates `num_received_transactions == num_requested_transactions`
3. **Silent failures**: The only indication is a warning log that may be missed during normal operation
4. **Amplification**: Once one node has gaps, it may propagate incomplete data to other nodes requesting state sync from it

The code explicitly handles the case of iterators ending early (with the warning at line 459), indicating this is an expected scenario, yet no safeguards prevent accepting partial data.

## Recommendation

**Add explicit validation at multiple layers:**

**Layer 1 - Storage Service:** Reject requests when unable to fulfill the complete range:

```rust
// In get_transactions_with_proof_by_size after the loop (line 471)
let expected_num_transactions = min(expected_num_transactions, num_transactions_to_fetch);
if transactions.len() < expected_num_transactions as usize {
    return Err(Error::UnexpectedErrorEncountered(format!(
        "Unable to fetch all requested transactions. Expected: {}, Got: {}. \
        Start version: {}, End version: {}",
        expected_num_transactions,
        transactions.len(),
        start_version,
        end_version
    )));
}
```

**Layer 2 - Client Validation:** Verify completeness in `update_stream_version_and_epoch`:

```rust
// In update_stream_version_and_epoch (line 1041)
fn update_stream_version_and_epoch(
    &mut self,
    request_start_version: Version,
    request_end_version: Version,
    target_ledger_info: &LedgerInfoWithSignatures,
    last_received_version: Version,
) -> Result<(), Error> {
    // Verify the client request indices
    let (next_stream_version, mut next_stream_epoch) = self.next_stream_version_and_epoch;
    verify_client_request_indices(
        next_stream_version,
        request_start_version,
        request_end_version,
    )?;

    // ADD THIS CHECK:
    if last_received_version < request_end_version {
        return Err(Error::AptosDataClientResponseIsInvalid(format!(
            "Incomplete transaction range received. Expected end: {}, Got: {}",
            request_end_version,
            last_received_version
        )));
    }
    // ... rest of function
}
```

**Layer 3 - TransactionListWithProof:** Add optional expected count validation:

```rust
pub fn verify(
    &self,
    ledger_info: &LedgerInfo,
    first_transaction_version: Option<Version>,
    expected_num_transactions: Option<usize>, // NEW PARAMETER
) -> Result<()> {
    // Existing checks...
    
    // ADD THIS CHECK:
    if let Some(expected) = expected_num_transactions {
        ensure!(
            self.get_num_transactions() == expected,
            "Transaction count mismatch. Expected: {}, Got: {}",
            expected,
            self.get_num_transactions()
        );
    }
    
    Ok(())
}
```

## Proof of Concept

```rust
// Reproduction steps for testing:

#[test]
fn test_partial_transaction_range_accepted() {
    // 1. Setup: Create a mock storage with transactions 100-104 only (missing 105-109)
    let mut mock_storage = MockStorage::new();
    mock_storage.insert_transactions(100, vec![/* txns 100-104 */]);
    // Intentionally do not insert transactions 105-109
    
    // 2. Client requests transactions 100-109 via optimistic fetch
    let request = DataRequest::GetNewTransactionsWithProof(NewTransactionsWithProofRequest {
        known_version: 99,
        known_epoch: 0,
        include_events: false,
    });
    
    // 3. Storage service processes the request
    let response = handler.process_request(&peer_id, request, true);
    
    // 4. Verify the response contains only 5 transactions instead of 10
    match response.unwrap().get_data_response().unwrap() {
        DataResponse::TransactionsWithProof(txn_list) => {
            assert_eq!(txn_list.get_num_transactions(), 5); // Only got 100-104
            assert_eq!(txn_list.get_first_transaction_version(), Some(100));
            // NO ERROR RAISED - this is the vulnerability!
        }
        _ => panic!("Wrong response type"),
    }
    
    // 5. Client processes this response
    let stream_engine = ContinuousTransactionStreamEngine::new(/* ... */);
    let notification = stream_engine.create_notification_for_new_data(
        100,
        ResponsePayload::TransactionsWithProof(txn_list),
        id_generator,
    );
    
    // 6. Verify client's next_stream_version is now 105, not 110
    assert_eq!(stream_engine.next_stream_version_and_epoch.0, 105);
    // The client has accepted incomplete data and will miss versions 105-109!
}
```

**Notes:**
- This vulnerability requires the storage iterator to terminate early, which can occur during database corruption, partial replication, or storage pruning edge cases
- The warning logged at line 459 in storage.rs confirms this scenario is anticipated but not properly handled
- The fix should be implemented at all three layers for defense in depth
- Backward compatibility can be maintained by making the strict validation optional via configuration flag during a transition period

### Citations

**File:** state-sync/storage-service/server/src/storage.rs (L457-469)
```rust
                None => {
                    // Log a warning that the iterators did not contain all the expected data
                    warn!(
                        "The iterators for transactions, transaction infos, events and \
                        persisted auxiliary infos are missing data! Start version: {:?}, \
                        end version: {:?}, num transactions to fetch: {:?}, num fetched: {:?}.",
                        start_version,
                        end_version,
                        num_transactions_to_fetch,
                        transactions.len()
                    );
                    break;
                },
```

**File:** state-sync/storage-service/server/src/storage.rs (L473-510)
```rust
        // Create the transaction info list with proof
        let accumulator_range_proof = self.storage.get_transaction_accumulator_range_proof(
            start_version,
            transactions.len() as u64,
            proof_version,
        )?;
        let info_list_with_proof =
            TransactionInfoListWithProof::new(accumulator_range_proof, transaction_infos);

        // Create the transaction list with proof
        let transaction_events = if include_events {
            Some(transaction_events)
        } else {
            None
        };
        let transaction_list_with_proof = TransactionListWithProof::new(
            transactions,
            transaction_events,
            Some(start_version),
            info_list_with_proof,
        );

        // Update the data truncation metrics
        response_progress_tracker
            .update_data_truncation_metrics(DataResponse::get_transactions_with_proof_v2_label());

        // Create the transaction data with proof response
        let transaction_list_with_proof_v2 =
            TransactionListWithProofV2::new(TransactionListWithAuxiliaryInfos::new(
                transaction_list_with_proof,
                persisted_auxiliary_infos,
            ));
        let response = TransactionDataWithProofResponse {
            transaction_data_response_type: TransactionDataResponseType::TransactionData,
            transaction_list_with_proof: Some(transaction_list_with_proof_v2),
            transaction_output_list_with_proof: None,
        };
        Ok(response)
```

**File:** state-sync/storage-service/server/src/utils.rs (L151-160)
```rust
            Ok(DataResponse::TransactionDataWithProof(transaction_data_with_proof)) => {
                DataResponse::NewTransactionDataWithProof(NewTransactionDataWithProofResponse {
                    transaction_data_response_type: transaction_data_with_proof
                        .transaction_data_response_type,
                    transaction_list_with_proof: transaction_data_with_proof
                        .transaction_list_with_proof,
                    transaction_output_list_with_proof: transaction_data_with_proof
                        .transaction_output_list_with_proof,
                    ledger_info_with_signatures: target_ledger_info,
                })
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L605-622)
```rust
        // Calculate the number of data items and target ledger info
        let (num_versions, target_ledger_info) =
            extract_new_versions_and_target(&client_response_payload)?;

        // Calculate the last version (last_version = first_version + num_versions - 1)
        let last_version = first_version
            .checked_add(num_versions as u64)
            .and_then(|v| v.checked_sub(1))
            .ok_or_else(|| Error::IntegerOverflow("Last version has overflown!".into()))?;

        // Update the request and stream versions
        self.update_request_version_and_epoch(last_version, &target_ledger_info)?;
        self.update_stream_version_and_epoch(
            first_version,
            last_version,
            &target_ledger_info,
            last_version,
        )?;
```

**File:** types/src/transaction/mod.rs (L2295-2354)
```rust
    pub fn verify(
        &self,
        ledger_info: &LedgerInfo,
        first_transaction_version: Option<Version>,
    ) -> Result<()> {
        // Verify the first transaction versions match
        ensure!(
            self.get_first_transaction_version() == first_transaction_version,
            "First transaction version ({:?}) doesn't match given version ({:?}).",
            self.get_first_transaction_version(),
            first_transaction_version,
        );

        // Verify the lengths of the transactions and transaction infos match
        ensure!(
            self.proof.transaction_infos.len() == self.get_num_transactions(),
            "The number of TransactionInfo objects ({}) does not match the number of \
             transactions ({}).",
            self.proof.transaction_infos.len(),
            self.get_num_transactions(),
        );

        // Verify the transaction hashes match those of the transaction infos
        self.transactions
            .par_iter()
            .zip_eq(self.proof.transaction_infos.par_iter())
            .map(|(txn, txn_info)| {
                let txn_hash = CryptoHash::hash(txn);
                ensure!(
                    txn_hash == txn_info.transaction_hash(),
                    "The hash of transaction does not match the transaction info in proof. \
                     Transaction hash: {:x}. Transaction hash in txn_info: {:x}.",
                    txn_hash,
                    txn_info.transaction_hash(),
                );
                Ok(())
            })
            .collect::<Result<Vec<_>>>()?;

        // Verify the transaction infos are proven by the ledger info.
        self.proof
            .verify(ledger_info, self.get_first_transaction_version())?;

        // Verify the events if they exist.
        if let Some(event_lists) = &self.events {
            ensure!(
                event_lists.len() == self.get_num_transactions(),
                "The length of event_lists ({}) does not match the number of transactions ({}).",
                event_lists.len(),
                self.get_num_transactions(),
            );
            event_lists
                .into_par_iter()
                .zip_eq(self.proof.transaction_infos.par_iter())
                .map(|(events, txn_info)| verify_events_against_root_hash(events, txn_info))
                .collect::<Result<Vec<_>>>()?;
        }

        Ok(())
    }
```
