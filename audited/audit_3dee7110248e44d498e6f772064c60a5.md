# Audit Report

## Title
State Merkle Pruner Progress Inconsistency Due to Non-Persisted Metadata Progress

## Summary
When `maybe_prune_single_version()` returns `None`, the state Merkle pruner jumps directly to the target version for shard pruning but fails to persist the metadata database progress to disk. This creates a critical inconsistency where shard progress is ahead of metadata progress after node restart, causing shard progress to be reset backwards during reinitialization, violating the State Consistency invariant.

## Finding Description
The vulnerability exists in the version increment logic of the `StateMerklePruner::prune()` function. The pruner maintains two types of progress tracking:

1. **Metadata DB progress** - tracks pruning progress in the metadata database
2. **Shard DB progress** - tracks pruning progress in individual shard databases

The bug occurs in this flow: [1](#0-0) 

When `maybe_prune_single_version()` returns `None` (line 85), it means `max(next_version, current_progress) > target_version`. In this case: [2](#0-1) 

The else branch executes, which:
1. Prunes shards from `progress` to `target_version` (line 86)
2. Calls `record_progress(target_version)` (line 87)

However, `record_progress()` only updates in-memory state: [3](#0-2) 

It does **NOT** persist to disk. In contrast, when `maybe_prune_single_version()` returns `Some(...)`, it persists the metadata progress: [4](#0-3) 

Meanwhile, shard pruning DOES persist progress to disk: [5](#0-4) 

**After the else branch executes:**
- Shard progress on disk: `target_version` (e.g., 200)
- Metadata progress on disk: old value (e.g., 100)
- In-memory progress: `target_version` (200)

**After node restart:**
- Metadata progress loads as 100
- Shard progress loads as 200
- During shard initialization, the code attempts to "catch up": [6](#0-5) 

This calls `prune(200, 100, ...)` which is backwards! The prune function then writes `target_version=100` to disk, **resetting shard progress from 200 back to 100** even though versions 101-200 have already been pruned from the shard.

This breaks **Invariant #4: State Consistency** - the system now believes versions 101-200 are unpruned in shards when they are actually pruned, creating a critical inconsistency between the persisted progress metadata and the actual pruned state.

## Impact Explanation
This qualifies as **High Severity** per Aptos bug bounty criteria:

1. **Significant protocol violation**: The pruner's progress tracking is corrupted, with shards marked as unpruned when they are actually pruned. This violates the fundamental assumption that progress accurately reflects pruned state.

2. **State inconsistency**: The gap between actual pruned state and tracked progress creates a window where:
   - Queries checking "is version X pruned?" return incorrect answers
   - Systems relying on progress for data availability assumptions may fail
   - Re-pruning attempts on already-pruned data may cause unexpected behavior

3. **Requires intervention**: While the system eventually self-heals, the inconsistent state persists across restarts and may require manual intervention if it causes cascading failures in state synchronization or data access paths.

## Likelihood Explanation
**High likelihood** - This occurs automatically during normal operation:

1. **Trigger condition**: Happens whenever `next_version > target_version`, which is common when:
   - The gap between stale node indices is large
   - The pruner jumps ahead to catch up after falling behind
   - Normal operation after node restarts

2. **No attacker required**: This is a logic bug that triggers during legitimate pruning operations, not requiring any malicious input or validator collusion.

3. **Persistent across restarts**: The inconsistency persists after node restart and only self-heals through subsequent pruning cycles, creating an extended window of vulnerability.

## Recommendation
Persist the metadata database progress to disk when jumping to target version in the else branch:

**Fix in `storage/aptosdb/src/pruner/state_merkle_pruner/mod.rs`:**

Modify the else branch to persist metadata progress before updating shards:

```rust
} else {
    // Persist metadata progress before pruning shards
    self.metadata_pruner.record_metadata_progress(target_version)?;
    self.prune_shards(progress, target_version, batch_size)?;
    self.record_progress(target_version);
    break;
}
```

**Add to `StateMerkleMetadataPruner`:**

```rust
pub(in crate::pruner) fn record_metadata_progress(&self, progress: Version) -> Result<()> {
    let mut batch = SchemaBatch::new();
    batch.put::<DbMetadataSchema>(
        &S::progress_metadata_key(None),
        &DbMetadataValue::Version(progress),
    )?;
    self.metadata_db.write_schemas(batch)?;
    Ok(())
}
```

This ensures metadata progress is always persisted before shard progress, maintaining the invariant that metadata progress ≥ shard progress.

## Proof of Concept

**Reproduction Steps:**

1. Start node and initialize pruner at version 0
2. Process transactions up to version 100, creating stale indices
3. Prune to version 100 (metadata and shards both at 100)
4. Process more transactions creating next stale index at version 250
5. Update `next_version` to 250 through pruning
6. Set `target_version = 200`
7. Call `prune()`:
   - `maybe_prune_single_version(100, 200)` returns `None` (since 250 > 200)
   - Shards pruned 100→200, progress persisted to disk
   - Metadata progress NOT persisted, remains 100 on disk
   - In-memory progress updated to 200
8. Restart node:
   - Metadata progress loads as 100
   - Shard progress loads as 200
9. During shard initialization:
   - Calls `prune(200, 100, ...)`
   - Resets shard progress to 100 on disk
10. **Result**: Versions 101-200 are pruned but progress shows 100

**Verification:**
Query the metadata database for `DbMetadataKey::StateMerklePrunerProgress` and `DbMetadataKey::StateMerkleShardPrunerProgress(shard_id)` after step 7 and step 9 to observe the inconsistency and backwards reset.

### Citations

**File:** storage/aptosdb/src/pruner/state_merkle_pruner/mod.rs (L76-90)
```rust
        while progress < target_version {
            if let Some(target_version_for_this_round) = self
                .metadata_pruner
                .maybe_prune_single_version(progress, target_version)?
            {
                self.prune_shards(progress, target_version_for_this_round, batch_size)?;
                progress = target_version_for_this_round;
                info!(name = S::name(), progress = progress);
                self.record_progress(target_version_for_this_round);
            } else {
                self.prune_shards(progress, target_version, batch_size)?;
                self.record_progress(target_version);
                break;
            }
        }
```

**File:** storage/aptosdb/src/pruner/state_merkle_pruner/mod.rs (L112-117)
```rust
    fn record_progress(&self, progress: Version) {
        self.progress.store(progress, Ordering::SeqCst);
        PRUNER_VERSIONS
            .with_label_values(&[S::name(), "progress"])
            .set(progress as i64);
    }
```

**File:** storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_metadata_pruner.rs (L40-50)
```rust
    pub(in crate::pruner) fn maybe_prune_single_version(
        &self,
        current_progress: Version,
        target_version: Version,
    ) -> Result<Option<Version>> {
        let next_version = self.next_version.load(Ordering::SeqCst);
        // This max here is only to handle the case when next version is not initialized.
        let target_version_for_this_round = max(next_version, current_progress);
        if target_version_for_this_round > target_version {
            return Ok(None);
        }
```

**File:** storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_metadata_pruner.rs (L66-69)
```rust
        batch.put::<DbMetadataSchema>(
            &S::progress_metadata_key(None),
            &DbMetadataValue::Version(target_version_for_this_round),
        )?;
```

**File:** storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_shard_pruner.rs (L47-53)
```rust
        info!(
            progress = progress,
            metadata_progress = metadata_progress,
            "Catching up {} shard {shard_id}.",
            S::name(),
        );
        myself.prune(progress, metadata_progress, usize::MAX)?;
```

**File:** storage/aptosdb/src/pruner/state_merkle_pruner/state_merkle_shard_pruner.rs (L85-90)
```rust
            if done {
                batch.put::<DbMetadataSchema>(
                    &S::progress_metadata_key(Some(self.shard_id)),
                    &DbMetadataValue::Version(target_version),
                )?;
            }
```
