# Audit Report

## Title
Consensus Configuration Allows Zero Weight Parameters Leading to Network-Wide Validator Panic and Complete Liveness Failure

## Summary
The consensus configuration system lacks validation for critical weight parameters (`active_weight`, `inactive_weight`, `failed_weight`) and window multipliers. Governance can set these values to zero through on-chain proposals, causing all validator nodes to panic with division-by-zero errors during proposer election, resulting in complete network liveness failure requiring an emergency hard fork.

## Finding Description

The `OnChainConsensusConfig` structure contains critical parameters for leader reputation-based proposer election, specifically `ProposerAndVoterConfig` with three weight fields that determine how validators are selected as block proposers. The system contains **no validation** at any layer to prevent these weights from being set to zero. [1](#0-0) 

The Move governance contract only validates that the configuration bytes are non-empty, but performs no semantic validation of the actual parameter values: [2](#0-1) 

The formal verification spec explicitly states this is the only validation requirement: [3](#0-2) 

**Attack Path:**

1. **Malicious Governance Proposal**: An attacker (or compromised governance) creates a proposal with:
   - `active_weight = 0`
   - `inactive_weight = 0`  
   - `failed_weight = 0`

2. **Configuration Applied**: After the proposal passes and epoch transitions, `EpochManager::create_proposer_election()` creates the leader reputation system with these zero weights: [4](#0-3) 

3. **Weight Calculation Returns All Zeros**: In `ProposerAndVoterHeuristic::get_weights()`, every validator receives one of the three zero weights: [5](#0-4) 

4. **Stake Weights Become Zero**: All weights multiplied by voting power remain zero: [6](#0-5) 

5. **Division by Zero Panic**: The `choose_index()` function calculates `total_weight = 0`, then calls `next_in_range(state, 0)` which performs modulo zero: [7](#0-6) [8](#0-7) 

The modulo operation `% 0` on line 45 causes an immediate panic, crashing the validator node.

**Alternative Attack Vector - Zero Window Multipliers:**

Setting `proposer_window_num_validators_multiplier = 0` causes: [9](#0-8) 

This results in `window_size = 0`, causing an empty history window. All validators then receive `inactive_weight`. If `inactive_weight` is also zero, the same division-by-zero panic occurs.

## Impact Explanation

**Severity: CRITICAL** (Total loss of liveness/network availability)

This vulnerability results in:

1. **Complete Network Halt**: All validator nodes panic simultaneously at epoch boundary when attempting proposer election
2. **No Block Production**: Network cannot produce any blocks as no proposer can be selected
3. **Non-Recoverable Without Hard Fork**: Requires emergency coordinator intervention to override on-chain configuration
4. **Transaction Processing Stops**: All user transactions are blocked indefinitely
5. **State Freezing**: Network state cannot advance until manual intervention

This meets the Critical Severity criteria: "Total loss of liveness/network availability" and "Non-recoverable network partition (requires hardfork)" per the Aptos Bug Bounty Program.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

While requiring governance approval, this is highly likely because:

1. **No Technical Barriers**: The configuration system accepts arbitrary zero values without any validation warnings
2. **Governance Can Be Compromised**: A coordinated attack, social engineering, or bug in governance voting could lead to malicious proposal passage
3. **Accidental Misconfiguration**: Even well-intentioned governance participants could accidentally set zero values without understanding the consequences
4. **No Warning Systems**: The system provides no validation errors or warnings during proposal creation or voting
5. **Immediate Effect**: Takes effect at next epoch boundary (typically within hours)

The lack of ANY validation layer makes this a realistic attack vector that could be triggered either maliciously or accidentally.

## Recommendation

Add multi-layer validation to prevent zero values in critical consensus parameters:

**Layer 1 - Rust Type System (Compile-time):**
```rust
// In types/src/on_chain_config/consensus_config.rs
impl ProposerAndVoterConfig {
    pub fn validate(&self) -> Result<(), String> {
        if self.active_weight == 0 {
            return Err("active_weight must be greater than 0".to_string());
        }
        if self.inactive_weight == 0 {
            return Err("inactive_weight must be greater than 0".to_string());
        }
        if self.failed_weight == 0 {
            return Err("failed_weight must be greater than 0".to_string());
        }
        if self.proposer_window_num_validators_multiplier == 0 {
            return Err("proposer_window_num_validators_multiplier must be greater than 0".to_string());
        }
        if self.voter_window_num_validators_multiplier == 0 {
            return Err("voter_window_num_validators_multiplier must be greater than 0".to_string());
        }
        Ok(())
    }
}

impl OnChainConsensusConfig {
    pub fn validate(&self) -> Result<(), String> {
        match self {
            OnChainConsensusConfig::V1(config) | OnChainConsensusConfig::V2(config) => {
                if let ProposerElectionType::LeaderReputation(rep_type) = &config.proposer_election_type {
                    match rep_type {
                        LeaderReputationType::ProposerAndVoter(cfg) 
                        | LeaderReputationType::ProposerAndVoterV2(cfg) => cfg.validate()?,
                    }
                }
            },
            OnChainConsensusConfig::V3 { alg, .. }
            | OnChainConsensusConfig::V4 { alg, .. }
            | OnChainConsensusConfig::V5 { alg, .. } => {
                match alg {
                    ConsensusAlgorithmConfig::Jolteon { main, .. }
                    | ConsensusAlgorithmConfig::JolteonV2 { main, .. } => {
                        if let ProposerElectionType::LeaderReputation(rep_type) = &main.proposer_election_type {
                            match rep_type {
                                LeaderReputationType::ProposerAndVoter(cfg)
                                | LeaderReputationType::ProposerAndVoterV2(cfg) => cfg.validate()?,
                            }
                        }
                    },
                    ConsensusAlgorithmConfig::DAG(dag) => {
                        if let AnchorElectionMode::LeaderReputation(rep_type) = &dag.anchor_election_mode {
                            match rep_type {
                                LeaderReputationType::ProposerAndVoter(cfg)
                                | LeaderReputationType::ProposerAndVoterV2(cfg) => cfg.validate()?,
                            }
                        }
                    },
                }
            },
        }
        Ok(())
    }
}
```

**Layer 2 - Deserialization Validation:**
```rust
// Modify deserialize_into_config to validate
fn deserialize_into_config(bytes: &[u8]) -> Result<Self> {
    let raw_bytes: Vec<u8> = bcs::from_bytes(bytes)?;
    let config: Self = bcs::from_bytes(&raw_bytes)
        .map_err(|e| format_err!("[on-chain config] Failed to deserialize: {}", e))?;
    config.validate()
        .map_err(|e| format_err!("[on-chain config] Validation failed: {}", e))?;
    Ok(config)
}
```

**Layer 3 - Move Native Function Validation:**
Add a native function to validate config bytes before storing:
```rust
// In aptos-move/framework/src/natives/consensus_config.rs
pub fn validate_consensus_config(bytes: Vec<u8>) -> Result<(), String> {
    let config: OnChainConsensusConfig = bcs::from_bytes(&bytes)
        .map_err(|e| format!("Deserialization failed: {}", e))?;
    config.validate()
}
```

Call this validation in the Move module before accepting the configuration.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use crate::on_chain_config::consensus_config::*;
    
    #[test]
    #[should_panic(expected = "attempt to calculate the remainder with a divisor of zero")]
    fn test_zero_weights_cause_panic() {
        use crate::liveness::proposer_election::choose_index;
        
        // Create config with all zero weights
        let malicious_config = ProposerAndVoterConfig {
            active_weight: 0,      // MALICIOUS: Set to 0
            inactive_weight: 0,    // MALICIOUS: Set to 0
            failed_weight: 0,      // MALICIOUS: Set to 0
            failure_threshold_percent: 10,
            proposer_window_num_validators_multiplier: 10,
            voter_window_num_validators_multiplier: 1,
            weight_by_voting_power: true,
            use_history_from_previous_epoch_max_count: 5,
        };
        
        // Simulate what happens in leader reputation with zero weights
        let num_validators = 4;
        let weights: Vec<u64> = vec![0; num_validators]; // All validators get 0 weight
        let voting_powers: Vec<u64> = vec![100, 100, 100, 100];
        
        // Calculate stake weights (all become 0)
        let stake_weights: Vec<u128> = weights
            .iter()
            .zip(voting_powers.iter())
            .map(|(w, vp)| (*w as u128) * (*vp as u128))
            .collect();
        
        // This will PANIC with division by zero
        let state = vec![1u8, 2, 3, 4];
        let _chosen = choose_index(stake_weights, state);
        // Never reaches here - validator node has crashed!
    }
    
    #[test]
    #[should_panic(expected = "attempt to calculate the remainder with a divisor of zero")]
    fn test_zero_multiplier_with_zero_inactive_weight() {
        // Alternative attack: zero multiplier + zero inactive_weight
        let malicious_config = ProposerAndVoterConfig {
            active_weight: 1000,
            inactive_weight: 0,    // MALICIOUS: Set to 0
            failed_weight: 1,
            failure_threshold_percent: 10,
            proposer_window_num_validators_multiplier: 0,  // MALICIOUS: Set to 0
            voter_window_num_validators_multiplier: 1,
            weight_by_voting_power: true,
            use_history_from_previous_epoch_max_count: 5,
        };
        
        // With window_size = 0, history is empty
        // All validators have no proposals/votes
        // All get inactive_weight = 0
        // Same panic occurs
        
        let num_validators = 4;
        let weights: Vec<u64> = vec![0; num_validators]; // All get inactive_weight = 0
        let voting_powers: Vec<u64> = vec![100, 100, 100, 100];
        
        let stake_weights: Vec<u128> = weights
            .iter()
            .zip(voting_powers.iter())
            .map(|(w, vp)| (*w as u128) * (*vp as u128))
            .collect();
        
        let state = vec![1u8, 2, 3, 4];
        let _chosen = choose_index(stake_weights, state); // PANIC!
    }
}
```

**Notes**

This vulnerability represents a critical failure in defense-in-depth principles. The consensus configuration system should implement validation at multiple layers (Move contract, Rust deserialization, runtime checks) to prevent catastrophic failures. The absence of ANY validation layer for these critical parameters creates a single point of failure that can bring down the entire network through either malicious governance proposals or accidental misconfiguration. The fix requires adding comprehensive parameter validation before any consensus configuration is accepted and applied to the system.

### Citations

**File:** types/src/on_chain_config/consensus_config.rs (L552-575)
```rust
#[derive(Clone, Copy, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct ProposerAndVoterConfig {
    // Selection weight for active validators with proposer failures below threshold
    pub active_weight: u64,
    // Selection weight for inactive validators with proposer failures below threshold
    pub inactive_weight: u64,
    // Selection weight for validators with proposer failures above threshold
    pub failed_weight: u64,
    // Thresholed of failures in the rounds validator was selected to be proposer
    // integer values representing percentages, i.e. 12 is 12%.
    pub failure_threshold_percent: u32,
    // Window into history considered for proposer statistics, multiplier
    // on top of number of validators
    pub proposer_window_num_validators_multiplier: usize,
    // Window into history considered for votre statistics, multiplier
    // on top of number of validators
    pub voter_window_num_validators_multiplier: usize,
    // Flag whether to use voting power as multiplier to the weights
    pub weight_by_voting_power: bool,
    // Flag whether to use history from previous epoch (0 if not),
    // representing a number of historical epochs (beyond the current one)
    // to consider.
    pub use_history_from_previous_epoch_max_count: u32,
}
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.spec.move (L17-21)
```text
    /// Requirement: Only a valid configuration can be used during initialization and update.
    /// Criticality: Medium
    /// Implementation: Both the initialize and set functions validate the config by ensuring its length to be greater
    /// than 0.
    /// Enforcement: Formally verified via [high-level-req-3.1](initialize) and [high-level-req-3.2](set).
```

**File:** consensus/src/epoch_manager.rs (L314-317)
```rust
                        let proposer_window_size = proposers.len()
                            * proposer_and_voter_config.proposer_window_num_validators_multiplier;
                        let voter_window_size = proposers.len()
                            * proposer_and_voter_config.voter_window_num_validators_multiplier;
```

**File:** consensus/src/epoch_manager.rs (L319-328)
```rust
                            Box::new(ProposerAndVoterHeuristic::new(
                                self.author,
                                proposer_and_voter_config.active_weight,
                                proposer_and_voter_config.inactive_weight,
                                proposer_and_voter_config.failed_weight,
                                proposer_and_voter_config.failure_threshold_percent,
                                voter_window_size,
                                proposer_window_size,
                                leader_reputation_type.use_reputation_window_from_stale_end(),
                            ));
```

**File:** consensus/src/liveness/leader_reputation.rs (L536-550)
```rust
            .map(|author| {
                let cur_votes = *votes.get(author).unwrap_or(&0);
                let cur_proposals = *proposals.get(author).unwrap_or(&0);
                let cur_failed_proposals = *failed_proposals.get(author).unwrap_or(&0);

                if cur_failed_proposals * 100
                    > (cur_proposals + cur_failed_proposals) * self.failure_threshold_percent
                {
                    self.failed_weight
                } else if cur_proposals > 0 || cur_votes > 0 {
                    self.active_weight
                } else {
                    self.inactive_weight
                }
            })
```

**File:** consensus/src/liveness/leader_reputation.rs (L710-715)
```rust
        // Multiply weights by voting power:
        let stake_weights: Vec<u128> = weights
            .iter_mut()
            .enumerate()
            .map(|(i, w)| *w as u128 * self.voting_powers[i] as u128)
            .collect();
```

**File:** consensus/src/liveness/proposer_election.rs (L39-46)
```rust
fn next_in_range(state: Vec<u8>, max: u128) -> u128 {
    // hash = SHA-3-256(state)
    let hash = aptos_crypto::HashValue::sha3_256_of(&state).to_vec();
    let mut temp = [0u8; 16];
    copy_slice_to_vec(&hash[..16], &mut temp).expect("next failed");
    // return hash[0..16]
    u128::from_le_bytes(temp) % max
}
```

**File:** consensus/src/liveness/proposer_election.rs (L49-59)
```rust
pub(crate) fn choose_index(mut weights: Vec<u128>, state: Vec<u8>) -> usize {
    let mut total_weight = 0;
    // Create cumulative weights vector
    // Since we own the vector, we can safely modify it in place
    for w in &mut weights {
        total_weight = total_weight
            .checked_add(w)
            .expect("Total stake shouldn't exceed u128::MAX");
        *w = total_weight;
    }
    let chosen_weight = next_in_range(state, total_weight);
```
