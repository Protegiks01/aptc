# Audit Report

## Title
IP Spoofing via Unauthenticated Proxy Protocol Headers in Network Transport Layer

## Summary
The `enable_proxy_protocol` configuration option allows Aptos nodes to accept HAProxy PROXY protocol v2 headers to extract real client IP addresses. However, this implementation lacks source validation, allowing any client to forge proxy protocol headers and spoof their source IP address when the node is not properly isolated behind a trusted proxy.

## Finding Description

The proxy protocol implementation accepts and trusts PROXY v2 headers from any incoming connection without validating the source. [1](#0-0) 

When `enable_proxy_protocol` is enabled, the `upgrade_inbound` function reads proxy headers from incoming connections and uses the extracted IP address as the connection's source address: [2](#0-1) 

This extracted address becomes part of the `ConnectionMetadata` and is used throughout the networking layer: [3](#0-2) 

**Attack Path:**

1. Node operator enables proxy protocol in configuration: [4](#0-3) 

2. Node is deployed without proper network isolation (not behind HAProxy or with inadequate firewall rules)

3. Attacker connects directly to the node and sends a forged PROXY v2 header claiming any source IP

4. The node accepts the spoofed IP as the real source, bypassing HAProxy's IP-based security controls: [5](#0-4) 

HAProxy implements critical IP-based defenses including blocklists and per-IP bandwidth limits (50 MB/s), which can be bypassed when clients spoof their addresses.

## Impact Explanation

**High Severity** - This vulnerability enables multiple security control bypasses:

1. **Rate Limit Evasion**: Attackers can bypass HAProxy's 50 MB/s per-source-IP bandwidth limits by claiming different IPs for each connection, potentially enabling resource exhaustion attacks against validator nodes.

2. **Blocklist Bypass**: Malicious IPs that have been blocked can evade the blocklist mechanism, continuing attacks despite being identified and blocked.

3. **False Attribution**: Security logs and monitoring systems will record incorrect source IPs, making incident response and attack attribution impossible.

While this doesn't directly compromise consensus or funds (thus not Critical severity), it can cause **validator node slowdowns** through resource exhaustion, qualifying as High severity per the bug bounty criteria.

## Likelihood Explanation

**Medium-High Likelihood** in production deployments:

1. The configuration option is exposed in Helm templates: [6](#0-5) 

2. Operators may enable this feature without understanding the security requirement for network isolation

3. Firewall misconfigurations or cloud security group errors could inadvertently expose the backend

4. The attack requires only basic network access and is trivial to execute (standard PROXY v2 header format)

## Recommendation

**Immediate Fix:** Add source IP validation to only accept proxy protocol headers from trusted sources:

```rust
// In NetworkConfig
pub struct NetworkConfig {
    pub enable_proxy_protocol: bool,
    pub proxy_protocol_trusted_sources: Option<Vec<IpAddr>>, // Add this field
    // ... rest of fields
}

// In proxy_protocol.rs
pub async fn read_header<T: AsyncRead + std::marker::Unpin>(
    original_addr: &NetworkAddress,
    stream: &mut T,
    trusted_sources: Option<&[IpAddr]>, // Add this parameter
) -> io::Result<NetworkAddress> {
    // If trusted sources are configured, verify the actual socket peer IP
    if let Some(allowed_ips) = trusted_sources {
        let actual_peer_ip = extract_actual_peer_ip(stream)?;
        if !allowed_ips.contains(&actual_peer_ip) {
            return Err(io::Error::new(
                io::ErrorKind::PermissionDenied,
                "ProxyProtocol: Connection not from trusted source",
            ));
        }
    }
    // ... rest of existing implementation
}
```

**Documentation Fix:** Add prominent warnings in configuration documentation:

```yaml
# WARNING: Only enable proxy_protocol when running behind a trusted HAProxy instance
# and when the backend is NOT directly accessible from untrusted networks.
# Firewall rules MUST restrict connections to only the proxy's IP address.
enable_proxy_protocol: false
proxy_protocol_trusted_sources: ["10.0.0.1"] # IPs allowed to send PROXY headers
```

## Proof of Concept

```rust
// PoC demonstrating IP spoofing via forged PROXY v2 header
use aptos_memsocket::MemorySocket;
use futures::io::AsyncWriteExt;
use aptos_types::network_address::NetworkAddress;

#[tokio::test]
async fn test_proxy_protocol_ip_spoofing() {
    let (mut client, mut server) = MemorySocket::new_pair();
    
    // Attacker forges PROXY v2 header claiming to be from 1.1.1.1
    let forged_header = vec![
        // PPv2 signature
        0x0D, 0x0A, 0x0D, 0x0A, 0x00, 0x0D, 0x0A, 0x51, 0x55, 0x49, 0x54, 0x0A,
        // Version 2, PROXY command
        0x21,
        // TCP IPv4
        0x11,
        // Address size (12 bytes)
        0x00, 0x0C,
        // Source IP: 1.1.1.1 (spoofed)
        0x01, 0x01, 0x01, 0x01,
        // Dest IP: 10.0.0.1
        0x0A, 0x00, 0x00, 0x01,
        // Source port: 12345
        0x30, 0x39,
        // Dest port: 6180
        0x18, 0x2C,
    ];
    
    client.write_all(&forged_header).await.unwrap();
    
    let original_addr = NetworkAddress::from_str("/ip4/192.168.1.100/tcp/6180").unwrap();
    let extracted_addr = proxy_protocol::read_header(&original_addr, &mut server).await.unwrap();
    
    // Node accepts spoofed IP 1.1.1.1 instead of real IP 192.168.1.100
    assert_eq!(extracted_addr.to_string(), "/ip4/1.1.1.1/tcp/12345");
    
    // Attacker has successfully spoofed their IP, bypassing rate limits
}
```

## Notes

This vulnerability represents a **deployment configuration security issue** rather than a pure code bug. The proxy protocol implementation correctly follows the HAProxy PROXY v2 specification, which intentionally lacks authentication because it assumes trusted network segments.

However, the current implementation provides no safeguards against operator misconfiguration, making it easy to inadvertently create an exploitable scenario. The recommended fix adds defense-in-depth by requiring explicit declaration of trusted proxy sources, preventing accidental exposure even if firewall rules are misconfigured.

### Citations

**File:** network/netcore/src/transport/proxy_protocol.rs (L51-132)
```rust
pub async fn read_header<T: AsyncRead + std::marker::Unpin>(
    original_addr: &NetworkAddress,
    stream: &mut T,
) -> io::Result<NetworkAddress> {
    // This is small enough that it should not be fragmented by TCP
    let mut header = [0u8; 16];
    stream.read_exact(&mut header).await?;

    // If it's not proxy protocol, let's stop
    if header[0..12] != PPV2_SIGNATURE {
        return Err(io::Error::new(
            io::ErrorKind::InvalidInput,
            "ProxyProtocol: Invalid signature",
        ));
    }

    // High 4 bits is version, low 4 bits is command
    let version_and_command = header[12];
    match version_and_command {
        PPV2_LOCAL | PPV2_PROXY => (),
        _ => {
            return Err(io::Error::new(
                io::ErrorKind::InvalidInput,
                "ProxyProtocol: Unsupported command or protocol version",
            ));
        },
    };

    // High 4 bits is family, low 4 bits is protocol
    let family_and_protocol = header[13];
    let address_size: [u8; 2] = header[14..16].try_into().unwrap();
    let address_size = u16::from_be_bytes(address_size);

    let mut address_bytes: Vec<u8> = vec![0; address_size as usize];
    stream.read_exact(&mut address_bytes).await?;

    let source_address = match family_and_protocol {
        // TODO: Support UDP in the future
        LOCAL_PROTOCOL | UDP_IPV4 | UDP_IPV6 | TCP_UNIX | UDP_UNIX => {
            // UNSPEC, UDP, and UNIX Steam/datagram
            // Accept connection but ignore address info as per spec
            original_addr.clone()
        },
        TCP_IPV4 => {
            // This is not mentioned in the spec, but if it doesn't match we might not read correctly
            if address_size < IPV4_SIZE {
                return Err(io::Error::new(
                    io::ErrorKind::InvalidInput,
                    "ProxyProtocol: Header size doesn't match expected address type",
                ));
            }

            let src_addr = u32::from_be_bytes(address_bytes[0..4].try_into().unwrap());
            let src_port = u16::from_be_bytes(address_bytes[8..10].try_into().unwrap());
            let socket_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::from(src_addr)), src_port);
            NetworkAddress::from(socket_addr)
        },
        TCP_IPV6 => {
            // This is not mentioned in the spec, but if it doesn't match we might not read correctly
            if address_size < IPV6_SIZE {
                return Err(io::Error::new(
                    io::ErrorKind::InvalidInput,
                    "ProxyProtocol: Header size doesn't match expected address type",
                ));
            }

            let src_addr = u128::from_be_bytes(address_bytes[0..16].try_into().unwrap());
            let src_port = u16::from_be_bytes(address_bytes[32..34].try_into().unwrap());

            let socket_addr = SocketAddr::new(IpAddr::V6(Ipv6Addr::from(src_addr)), src_port);
            NetworkAddress::from(socket_addr)
        },
        _ => {
            return Err(io::Error::new(
                io::ErrorKind::InvalidInput,
                "ProxyProtocol: Unsupported Address Family or Protocol",
            ));
        },
    };

    Ok(source_address)
}
```

**File:** network/framework/src/transport/mod.rs (L260-274)
```rust
    let addr = if proxy_protocol_enabled {
        proxy_protocol::read_header(&addr, &mut socket)
            .await
            .map_err(|err| {
                debug!(
                    network_address = addr,
                    error = %err,
                    "ProxyProtocol: Failed to read header: {}",
                    err
                );
                err
            })?
    } else {
        addr
    };
```

**File:** network/framework/src/transport/mod.rs (L322-330)
```rust
        metadata: ConnectionMetadata::new(
            remote_peer_id,
            CONNECTION_ID_GENERATOR.next(),
            addr,
            origin,
            messaging_protocol,
            application_protocols,
            peer_role,
        ),
```

**File:** config/src/config/network_config.rs (L105-105)
```rust
    pub enable_proxy_protocol: bool,
```

**File:** terraform/helm/aptos-node/files/haproxy.cfg (L54-78)
```text
    # Create TCP request bandwidth limits of 50 MB/s (per source IP)
    filter bwlim-in incoming-src-limit key src table limit-by-src limit 50m
    filter bwlim-out outgoing-src-limit key src table limit-by-src limit 50m
    tcp-request content set-bandwidth-limit incoming-src-limit
    tcp-request content set-bandwidth-limit outgoing-src-limit

## Specify the validator network backend
backend {{ include "aptos-validator.fullname" $ }}-validator
    server {{ include "aptos-validator.fullname" $ }}-{{ $.Values.i }}-validator {{ include "aptos-validator.fullname" $ }}-{{ $.Values.i }}-validator:6180

    # Create TCP response bandwidth limits of 25 MB/s (per TCP stream)
    filter bwlim-in incoming-limit default-limit 25m default-period 1s
    filter bwlim-out outgoing-limit default-limit 25m default-period 1s
    tcp-response content set-bandwidth-limit incoming-limit
    tcp-response content set-bandwidth-limit outgoing-limit

    # Create TCP response bandwidth limits of 50 MB/s (per source IP)
    filter bwlim-in incoming-src-limit key src table limit-by-src limit 50m
    filter bwlim-out outgoing-src-limit key src table limit-by-src limit 50m
    tcp-response content set-bandwidth-limit incoming-src-limit
    tcp-response content set-bandwidth-limit outgoing-src-limit

## Specify the source IP filter backend
backend limit-by-src
    stick-table type ip size 1m expire 300s store bytes_out_rate(1s),bytes_in_rate(1s)
```

**File:** terraform/helm/aptos-node/files/configs/fullnode-base.yaml (L26-26)
```yaml
  enable_proxy_protocol: {{ $.Values.haproxy.config.send_proxy_protocol }}
```
