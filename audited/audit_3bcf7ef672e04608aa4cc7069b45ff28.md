# Audit Report

## Title
Server-Side Request Forgery (SSRF) in Node Health Checker Service Allows Access to Internal Infrastructure

## Summary

The Aptos Node Health Checker service accepts a user-controlled `node_url` parameter without validating whether it points to internal/private IP addresses or cloud metadata endpoints. This allows an attacker to exploit the health checker as an SSRF proxy to access internal resources, including cloud provider metadata services that may contain sensitive credentials.

## Finding Description

The `/check` endpoint in the Node Health Checker service accepts a `node_url` query parameter from untrusted users and uses it to make server-side HTTP requests without validation. [1](#0-0) 

The vulnerability exists because the `NodeAddress::new()` constructor accepts any URL without validation: [2](#0-1) 

The attack flow works as follows:

1. Attacker sends a malicious request: `GET /check?node_url=http://169.254.169.254&baseline_configuration_id=devnet_fullnode&api_port=80`

2. The API endpoint creates a `NodeAddress` with the attacker-controlled URL: [3](#0-2) 

3. The `SyncRunner` creates HTTP clients using this URL and makes requests to internal endpoints: [4](#0-3) 

4. The `MetricsProvider` makes GET requests to construct URLs like `http://169.254.169.254:80/metrics`: [5](#0-4) 

5. Similarly, `SystemInformationProvider` makes requests to `/system_information`: [6](#0-5) 

The responses from these internal endpoints are returned to the attacker, enabling:
- **Cloud Metadata Access**: AWS EC2 metadata at `http://169.254.169.254/latest/meta-data/` contains IAM credentials
- **Internal Network Scanning**: Testing connectivity to internal services
- **Localhost Access**: Accessing services bound to `127.0.0.1`
- **Private Network Access**: Reaching RFC1918 addresses (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16)

## Impact Explanation

This vulnerability qualifies as **HIGH severity** according to Aptos bug bounty criteria for multiple reasons:

1. **Significant Protocol Violations**: The health checker service bypasses security boundaries by making requests to arbitrary attacker-controlled destinations, violating the principle that untrusted input should be validated.

2. **API Exploitation**: The public-facing `/check` API can be exploited without authentication, allowing any external attacker to abuse the service.

3. **Credential Theft Potential**: On cloud platforms (AWS, GCP, Azure), the metadata services contain:
   - IAM role credentials with temporary access keys
   - Service account tokens
   - Instance identity documents
   - User data scripts that may contain secrets

4. **Internal Infrastructure Exposure**: Attackers can probe internal networks, discover services, and potentially access sensitive internal APIs.

5. **No Authentication Required**: The attack requires only HTTP GET requests to a public endpoint.

While this doesn't directly impact consensus or blockchain state, it represents a serious security violation of the Node Health Checker infrastructure that could lead to broader infrastructure compromise.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to be exploited because:

1. **Low Complexity**: Exploitation requires only a single HTTP GET request with malicious parameters
2. **No Authentication**: The `/check` endpoint appears to be publicly accessible
3. **Well-Known Attack Pattern**: SSRF against cloud metadata services is a common and well-documented attack vector
4. **Immediate Value**: Successful exploitation provides immediate access to credentials or internal network information
5. **Automated Scanning**: Attackers regularly scan for SSRF vulnerabilities in public services

The only barrier is discovering that the Node Health Checker service exists and is publicly accessible, which is likely if it's deployed as part of the Aptos infrastructure.

## Recommendation

Implement URL validation to block requests to internal/private IP address ranges and cloud metadata endpoints. Add the following validation in `NodeAddress::new()`:

```rust
use std::net::IpAddr;

impl NodeAddress {
    pub fn new(
        url: Url,
        api_port: Option<u16>,
        metrics_port: Option<u16>,
        noise_port: Option<u16>,
        public_key: Option<x25519::PublicKey>,
    ) -> Result<Self> {
        // Validate URL doesn't point to internal/private addresses
        if let Some(host) = url.host() {
            // Check for localhost
            if host.to_string() == "localhost" || host.to_string() == "127.0.0.1" {
                bail!("URL cannot point to localhost");
            }
            
            // If it's an IP address, validate it's not private
            if let Some(ip_addr) = host.to_string().parse::<IpAddr>().ok() {
                if is_private_ip(&ip_addr) {
                    bail!("URL cannot point to private IP addresses");
                }
            }
        }
        
        Ok(Self {
            url,
            api_port,
            metrics_port,
            noise_port,
            public_key,
            cookie_store: Arc::new(Jar::default()),
        })
    }
}

fn is_private_ip(ip: &IpAddr) -> bool {
    match ip {
        IpAddr::V4(ipv4) => {
            ipv4.is_private() || 
            ipv4.is_loopback() || 
            ipv4.is_link_local() ||  // 169.254.0.0/16
            ipv4.octets()[0] == 10 ||  // 10.0.0.0/8
            (ipv4.octets()[0] == 172 && ipv4.octets()[1] >= 16 && ipv4.octets()[1] <= 31) ||  // 172.16.0.0/12
            (ipv4.octets()[0] == 192 && ipv4.octets()[1] == 168)  // 192.168.0.0/16
        }
        IpAddr::V6(ipv6) => {
            ipv6.is_loopback() || 
            ipv6.is_unspecified() ||
            ((ipv6.segments()[0] & 0xfe00) == 0xfc00)  // fc00::/7 unique local
        }
    }
}
```

Additionally:
1. Implement DNS rebinding protection by resolving hostnames and checking the resolved IPs
2. Consider using an allowlist approach if only specific node addresses should be checked
3. Add rate limiting to prevent abuse
4. Log all URL validation failures for security monitoring

## Proof of Concept

**Setup**: Assuming the Node Health Checker service is running and accessible at `https://nhc.aptos.example.com`

**Step 1**: Attempt to access AWS EC2 metadata service
```bash
curl -v "https://nhc.aptos.example.com/check?node_url=http://169.254.169.254&baseline_configuration_id=devnet_fullnode&api_port=80&metrics_port=80"
```

**Expected Result (Vulnerable)**: The response contains error messages indicating the health checker attempted to connect to `http://169.254.169.254:80/metrics` or similar, potentially including response data from the metadata service.

**Step 2**: Attempt to access localhost services
```bash
curl -v "https://nhc.aptos.example.com/check?node_url=http://127.0.0.1&baseline_configuration_id=devnet_fullnode&api_port=6060&metrics_port=6060"
```

**Expected Result (Vulnerable)**: The health checker attempts to connect to localhost port 6060, potentially revealing internal services.

**Step 3**: Attempt to scan internal network
```bash
curl -v "https://nhc.aptos.example.com/check?node_url=http://10.0.1.1&baseline_configuration_id=devnet_fullnode&api_port=8080&metrics_port=9091"
```

**Expected Result (Vulnerable)**: The health checker attempts connections to internal network addresses, revealing their existence through timing differences or error messages.

**Note**: After implementing the recommended fix, all these requests should be rejected with an error message indicating that private/internal IP addresses are not allowed.

## Notes

- This vulnerability is specific to the Node Health Checker service and does not directly affect blockchain consensus or validator operations
- However, compromise of infrastructure credentials could lead to broader attacks on the Aptos network infrastructure
- The vulnerability has been present since the `NodeAddress` type was introduced without URL validation
- Similar validation should be reviewed in other services that accept user-provided URLs, such as the faucet service (which already has IP validation via `IpRangeManager`)

### Citations

**File:** ecosystem/node-checker/src/server/api.rs (L29-45)
```rust
    #[oai(path = "/check", method = "get")]
    async fn check(
        &self,
        /// The ID of the baseline node configuration to use for the evaluation, e.g. devnet_fullnode
        baseline_configuration_id: Query<String>,
        /// The URL of the node to check, e.g. http://44.238.19.217 or http://fullnode.mysite.com
        node_url: Query<Url>,
        /// If given, we will assume the metrics service is available at the given port.
        metrics_port: Query<Option<u16>>,
        /// If given, we will assume the API is available at the given port.
        api_port: Query<Option<u16>>,
        /// If given, we will assume that clients can communicate with your node via noise at the given port.
        noise_port: Query<Option<u16>>,
        /// A public key for the node, e.g. 0x44fd1324c66371b4788af0b901c9eb8088781acb29e6b8b9c791d5d9838fbe1f.
        /// This is only necessary for certain checkers, e.g. HandshakeChecker.
        public_key: Query<Option<String>>,
    ) -> poem::Result<Json<CheckSummary>> {
```

**File:** ecosystem/node-checker/src/server/api.rs (L81-87)
```rust
        let target_node_address = NodeAddress::new(
            node_url.0,
            api_port.0,
            metrics_port.0,
            noise_port.0,
            public_key,
        );
```

**File:** ecosystem/node-checker/src/configuration/node_address.rs (L38-53)
```rust
    pub fn new(
        url: Url,
        api_port: Option<u16>,
        metrics_port: Option<u16>,
        noise_port: Option<u16>,
        public_key: Option<x25519::PublicKey>,
    ) -> Self {
        Self {
            url,
            api_port,
            metrics_port,
            noise_port,
            public_key,
            cookie_store: Arc::new(Jar::default()),
        }
    }
```

**File:** ecosystem/node-checker/src/runner/sync_runner.rs (L104-111)
```rust
        if let Ok(metrics_client) = target_node_address.get_metrics_client(Duration::from_secs(4)) {
            let metrics_client = Arc::new(metrics_client);
            provider_collection.target_metrics_provider = Some(MetricsProvider::new(
                self.provider_configs.metrics.clone(),
                metrics_client.clone(),
                target_node_address.url.clone(),
                target_node_address.get_metrics_port().unwrap(),
            ));
```

**File:** ecosystem/node-checker/src/provider/metrics.rs (L59-66)
```rust
    pub async fn get_scrape(&self) -> Result<Scrape, ProviderError> {
        let response = self
            .client
            .get(self.metrics_url.clone())
            .send()
            .await
            .with_context(|| format!("Failed to get data from {}", self.metrics_url))
            .map_err(|e| ProviderError::RetryableEndpointError("/metrics", e))?;
```

**File:** ecosystem/node-checker/src/provider/system_information.rs (L57-65)
```rust
    pub async fn get_data(&self) -> Result<SystemInformation, ProviderError> {
        let response = self
            .client
            .get(self.metrics_url.clone())
            .send()
            .await
            .with_context(|| format!("Failed to get data from {}", self.metrics_url))
            .map_err(|e| ProviderError::RetryableEndpointError("/system_information", e))?;
        let text = response
```
