# Audit Report

## Title
Missing Hostname Verification in Google reCAPTCHA Allows Captcha Token Phishing Attack

## Summary
The Google Captcha checker in the Aptos faucet service fails to verify the `hostname` field returned by Google's reCAPTCHA API. This allows an attacker to solve captchas on a phishing site and use those tokens to bypass the faucet's captcha protection, enabling unauthorized fund drainage. [1](#0-0) 

## Finding Description
The `CaptchaChecker::check()` function sends captcha tokens to Google's verification endpoint and receives a JSON response. According to Google's official reCAPTCHA API documentation (referenced in the code), the response includes several fields including `success` (boolean), `challenge_ts` (timestamp), `hostname` (the site where the captcha was solved), and `error-codes` (array). [2](#0-1) 

The current implementation only checks the `success` field to determine if the captcha is valid, completely ignoring the `hostname` field. This breaks the security guarantee that captcha tokens can only be used by the site they were generated for. [3](#0-2) 

**Attack Scenario:**
1. Attacker creates a phishing site at `evil-faucet.com` that mimics the legitimate Aptos faucet UI
2. Attacker registers their own reCAPTCHA site key (or potentially reuses the legitimate one if it's not domain-restricted)
3. Unsuspecting users visit the phishing site and solve captchas, believing they're using the legitimate faucet
4. Attacker captures the valid captcha tokens generated on `evil-faucet.com`
5. Attacker sends funding requests to the legitimate Aptos faucet API with the phished tokens in the `COMPLETED_CAPTCHA_TOKEN` header
6. The faucet's Google Captcha checker validates the token with Google's API, which returns `success: true` and `hostname: "evil-faucet.com"`
7. Because the code only checks `success` and ignores `hostname`, the validation passes
8. Attacker successfully bypasses captcha protection and drains the faucet [4](#0-3) 

## Impact Explanation
This vulnerability qualifies as **High Severity** per the Aptos bug bounty criteria because it represents a significant protocol violation that allows bypassing security controls. The faucet is designed to prevent automated abuse through captcha verification, but this vulnerability allows an attacker to completely circumvent this protection mechanism.

The impact includes:
- **Fund Drainage**: Attacker can exhaust faucet funds through automated requests using phished captcha tokens
- **Resource Abuse**: Defeats the purpose of rate-limiting and anti-bot protections
- **User Deception**: Legitimate users solving captchas on phishing sites unknowingly help attackers

While this doesn't directly affect consensus or validator operations, it enables unauthorized fund distribution and violates the **Resource Limits** invariant (operations must respect access controls and usage limits).

## Likelihood Explanation
This vulnerability is **highly likely** to be exploited because:

1. **Low Barrier to Entry**: Creating phishing sites is trivial and commonly done by attackers
2. **No Technical Sophistication Required**: Attacker only needs to capture captcha tokens and replay them - no cryptographic or protocol knowledge needed
3. **Scalable Attack**: Once the phishing infrastructure is set up, the attacker can collect tokens from multiple users and automate fund requests
4. **User Trust**: Users may not realize they're on a phishing site if it closely mimics the legitimate UI
5. **Existing Attack Pattern**: Captcha token phishing is a known attack vector in web security

The attack requires no insider access, no special privileges, and no blockchain-specific expertise - just basic web development skills and social engineering.

## Recommendation
The fix requires validating the `hostname` field from Google's reCAPTCHA response to ensure it matches the expected legitimate domain(s). The implementation should:

1. Add a configuration parameter for expected hostname(s)
2. Parse the `hostname` field from the response JSON
3. Verify it matches one of the allowed domains before accepting the captcha

**Recommended Code Fix:**

```rust
// In GoogleCaptchaCheckerConfig
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct GoogleCaptchaCheckerConfig {
    pub google_captcha_api_key: KeyString,
    /// Expected hostname(s) where captcha should be solved
    pub expected_hostnames: Vec<String>,
}

// In CaptchaChecker::check() - after line 105
let resp: serde_json::Value = serde_json::from_str(resp.as_str()).map_err(|e| {
    AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError)
})?;

if resp["success"].as_bool().unwrap_or(false) {
    // Verify hostname field
    let hostname = resp["hostname"].as_str().unwrap_or("");
    if !self.config.expected_hostnames.contains(&hostname.to_string()) {
        debug!(
            message = "Captcha hostname mismatch",
            expected = ?self.config.expected_hostnames,
            actual = hostname,
            source_ip = data.source_ip
        );
        return Ok(vec![RejectionReason::new(
            format!("Captcha solved on unexpected domain: {}", hostname),
            RejectionReasonCode::CaptchaInvalid,
        )]);
    }
    return Ok(vec![]);
}
``` [5](#0-4) 

## Proof of Concept

**Step 1: Setup Phishing Site**
```bash
# Attacker creates evil-faucet.com with reCAPTCHA
# HTML includes: <div class="g-recaptcha" data-sitekey="ATTACKER_SITE_KEY"></div>
```

**Step 2: Capture Valid Token**
```javascript
// On phishing site, capture token after user solves captcha
grecaptcha.getResponse() // Returns valid token like "03AGdBq26P..."
// Send to attacker's server
```

**Step 3: Exploit Legitimate Faucet**
```bash
curl -X POST https://legitimate-aptos-faucet.com/fund \
  -H "Content-Type: application/json" \
  -H "COMPLETED_CAPTCHA_TOKEN: 03AGdBq26P..." \
  -d '{
    "address": "0xATTACKER_ADDRESS",
    "amount": 100000000
  }'
```

**Step 4: Verify Exploitation**
The request succeeds because:
1. Google's API returns `{"success": true, "hostname": "evil-faucet.com", ...}`
2. Current code only checks `success` field (line 106)
3. Ignores `hostname: "evil-faucet.com"` completely
4. Funds are transferred to attacker

**Reproduction Steps:**
1. Deploy a test instance of the faucet with Google Captcha enabled
2. Create a secondary domain with reCAPTCHA configured
3. Solve captcha on the secondary domain to obtain a valid token
4. Send fund request to the primary faucet with the cross-domain token
5. Observe that the request succeeds despite the hostname mismatch

The vulnerability can be confirmed by examining the response from Google's API which will contain `"hostname": "secondary-domain.com"` while the code never validates this field. [6](#0-5) 

## Notes
This vulnerability is specific to the faucet service and does not directly impact consensus, validator operations, or on-chain security. However, it represents a critical failure in the faucet's access control mechanism and could lead to unauthorized fund drainage, requiring manual intervention and potential service disruption.

The fix should be implemented alongside proper configuration validation to ensure `expected_hostnames` is populated and includes all legitimate domains serving the faucet UI.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/google_captcha.rs (L32-35)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct GoogleCaptchaCheckerConfig {
    pub google_captcha_api_key: KeyString,
}
```

**File:** crates/aptos-faucet/core/src/checkers/google_captcha.rs (L47-47)
```rust
/// Request payload for captcha verify API. See https://developers.google.com/recaptcha/docs/verify#api_request
```

**File:** crates/aptos-faucet/core/src/checkers/google_captcha.rs (L60-121)
```rust
    async fn check(
        &self,
        data: CheckerData,
        _dry_run: bool,
    ) -> Result<Vec<RejectionReason>, AptosTapError> {
        let captcha_token = match data.headers.get(COMPLETED_CAPTCHA_TOKEN) {
            Some(header_value) => header_value.to_str().map_err(|e| {
                AptosTapError::new_with_error_code(e, AptosTapErrorCode::InvalidRequest)
            })?,
            None => {
                return Ok(vec![RejectionReason::new(
                    format!("Captcha header {} not found", COMPLETED_CAPTCHA_TOKEN),
                    RejectionReasonCode::CaptchaInvalid,
                )])
            },
        };

        let verify_result = reqwest::Client::new()
            .post(GOOGLE_CAPTCHA_ENDPOINT)
            // Google captcha API only accepts form encoded payload, lol
            .form::<VerifyRequest>(&VerifyRequest {
                secret: self.config.google_captcha_api_key.0.clone(),
                response: captcha_token.to_string(),
                remoteip: data.source_ip.to_string(),
            })
            .send()
            .await
            .map_err(|e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError))?;

        let status_code = verify_result.status();
        let resp = verify_result
            .text()
            .await
            .map_err(|e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError))?;
        if !status_code.is_success() {
            debug!(
                message = "Google captcha API returned error status code",
                status = status_code.as_str(),
                resp = resp
            );
        } else {
            // Rather than `verify_result.json`, we parse the result with serde_json to have more flexibilities
            let resp: serde_json::Value = serde_json::from_str(resp.as_str()).map_err(|e| {
                AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError)
            })?;

            if resp["success"].as_bool().unwrap_or(false) {
                return Ok(vec![]);
            } else {
                debug!(
                    message = "Invalid captcha token",
                    source_ip = data.source_ip,
                    resp = resp
                );
            }
        };

        Ok(vec![RejectionReason::new(
            "Failed to pass captcha check".to_string(),
            RejectionReasonCode::CaptchaInvalid,
        )])
    }
```
