# Audit Report

## Title
Voting Power Inflation in Quorum Store Proof Coordinator Through Duplicate Signature Processing

## Summary
The `IncrementalProofState::add_signature()` function in the Quorum Store proof coordinator does not check for duplicate signatures from the same validator. When duplicate `SignedBatchInfo` messages are processed, the `aggregated_voting_power` counter is incorrectly incremented multiple times while the underlying `SignatureAggregator` only stores one signature per validator. This causes the `observe_voting_pct()` function to calculate inflated voting percentages, resulting in incorrect monitoring metrics that can reach 255% prematurely or wrap around to lower values.

## Finding Description

The vulnerability exists in the signature aggregation logic within the Quorum Store's proof coordinator: [1](#0-0) 

When a `SignedBatchInfo` is processed, the function always increments `aggregated_voting_power` by the validator's voting power, regardless of whether this validator has already signed: [2](#0-1) 

However, the underlying `SignatureAggregator` uses a `BTreeMap` that deduplicates signatures by validator address: [3](#0-2) 

This mismatch creates a vulnerability where:
1. A validator sends the same `SignedBatchInfo` multiple times (either maliciously or due to network issues)
2. Each message passes through the network listener without deduplication: [4](#0-3) 
3. Each call to `add_signature` increments `aggregated_voting_power` 
4. But the `SignatureAggregator` BTreeMap only stores one entry per validator
5. The `observe_voting_pct()` function calculates percentage using the inflated counter: [5](#0-4) 

The percentage calculation `(aggregated_voting_power * 100) / total_voting_power` can produce values exceeding 100%. When cast to `u8`, values above 255 wrap around (e.g., 260% becomes 4%) rather than saturating at 255%.

**Important Note**: While the `SignedBatchInfoError::DuplicatedSignature` error variant exists, it is never used in the codebase: [6](#0-5) 

**Consensus Safety is NOT Affected**: The actual proof verification uses `SignatureAggregator::aggregate_and_verify()`, which correctly iterates over the deduplicated BTreeMap: [7](#0-6) 

## Impact Explanation

This vulnerability is classified as **Low Severity** per Aptos bug bounty criteria: "Non-critical implementation bugs" that affect monitoring but not consensus safety.

**Impact Scope**:
- **Monitoring Corruption**: The `BATCH_VOTE_PROGRESS` metric will record incorrect voting percentages: [8](#0-7) 

- **No Consensus Impact**: The actual quorum verification and proof-of-store creation remain secure because they use the properly deduplicated signature map

- **Potential Operational Confusion**: Operators monitoring batch vote progress will see misleading metrics, potentially causing incorrect operational decisions

## Likelihood Explanation

**Likelihood: Medium to High**

The vulnerability can be triggered through:
1. **Malicious Validator**: A single validator can intentionally spam duplicate signatures
2. **Network Issues**: Message duplication or retransmission in the P2P network layer
3. **Implementation Bugs**: Client-side bugs causing duplicate message sends

The attack requires no special privileges beyond being a validator, and there is no rate limiting or deduplication at the network layer to prevent it.

## Recommendation

Add duplicate signature detection in `IncrementalProofState::add_signature()`:

```rust
fn add_signature(
    &mut self,
    signed_batch_info: &SignedBatchInfo<BatchInfoExt>,
    validator_verifier: &ValidatorVerifier,
) -> Result<(), SignedBatchInfoError> {
    if signed_batch_info.batch_info() != &self.signature_aggregator.data() {
        return Err(SignedBatchInfoError::WrongInfo((
            signed_batch_info.batch_info().batch_id().id,
            self.signature_aggregator.data().batch_id().id,
        )));
    }

    match validator_verifier.get_voting_power(&signed_batch_info.signer()) {
        Some(voting_power) => {
            // Check if this validator has already signed
            let signer = signed_batch_info.signer();
            if self.signature_aggregator.signatures.contains_key(&signer) {
                return Err(SignedBatchInfoError::DuplicatedSignature);
            }
            
            self.signature_aggregator.add_signature(
                signer,
                signed_batch_info.signature_with_status(),
            );
            self.aggregated_voting_power += voting_power as u128;
            if signer == self.signature_aggregator.data().author() {
                self.self_voted = true;
            }
        },
        None => {
            error!(
                "Received signature from author not in validator set: {}",
                signed_batch_info.signer()
            );
            return Err(SignedBatchInfoError::InvalidAuthor);
        },
    }

    Ok(())
}
```

Alternatively, track which validators have already signed in a separate `HashSet`:

```rust
struct IncrementalProofState {
    signature_aggregator: BatchSignatureAggregator,
    aggregated_voting_power: u128,
    self_voted: bool,
    completed: bool,
    last_increment_pct: u8,
    signed_validators: HashSet<PeerId>, // Add this field
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_duplicate_signature_inflates_voting_power() {
        // Setup validator verifier with total voting power of 1000
        let validator_infos = vec![
            ValidatorConsensusInfo::new(peer_id_1, public_key_1, 100),
            // ... other validators totaling 1000
        ];
        let verifier = ValidatorVerifier::new(validator_infos);
        
        // Create batch info
        let batch_info = BatchInfoExt::new(/* ... */);
        let mut proof_state = IncrementalProofState::new_batch_info_ext(batch_info.clone());
        
        // Create signed batch info from validator with 100 voting power
        let signed_batch = SignedBatchInfo::new(batch_info, &validator_signer_1).unwrap();
        
        // Add signature first time - voting power should be 100
        proof_state.add_signature(&signed_batch, &verifier).unwrap();
        assert_eq!(proof_state.aggregated_voting_power, 100);
        
        // Add same signature again - voting power incorrectly becomes 200
        proof_state.add_signature(&signed_batch, &verifier).unwrap();
        assert_eq!(proof_state.aggregated_voting_power, 200); // BUG: Should still be 100
        
        // After 25 duplicate signatures, percentage reaches 255%
        for _ in 0..23 {
            proof_state.add_signature(&signed_batch, &verifier).unwrap();
        }
        
        let pct = (proof_state.aggregated_voting_power * 100) 
            .saturating_div(verifier.total_voting_power()) as u8;
        assert_eq!(pct, 250); // 250% voting when only one validator signed
        
        // One more duplicate causes percentage = 260%, which wraps to 4 when cast to u8
        proof_state.add_signature(&signed_batch, &verifier).unwrap();
        let pct = (proof_state.aggregated_voting_power * 100) 
            .saturating_div(verifier.total_voting_power()) as u8;
        assert_eq!(pct, 4); // Wraps around!
    }
}
```

## Notes

While this vulnerability affects monitoring accuracy, it does **not** compromise consensus safety. The actual signature verification and quorum checking use the properly deduplicated signature map from `SignatureAggregator`. However, inaccurate monitoring can lead to operational issues and should be fixed to maintain system observability.

### Citations

**File:** consensus/src/quorum_store/proof_coordinator.rs (L145-178)
```rust
    fn add_signature(
        &mut self,
        signed_batch_info: &SignedBatchInfo<BatchInfoExt>,
        validator_verifier: &ValidatorVerifier,
    ) -> Result<(), SignedBatchInfoError> {
        if signed_batch_info.batch_info() != &self.signature_aggregator.data() {
            return Err(SignedBatchInfoError::WrongInfo((
                signed_batch_info.batch_info().batch_id().id,
                self.signature_aggregator.data().batch_id().id,
            )));
        }

        match validator_verifier.get_voting_power(&signed_batch_info.signer()) {
            Some(voting_power) => {
                self.signature_aggregator.add_signature(
                    signed_batch_info.signer(),
                    signed_batch_info.signature_with_status(),
                );
                self.aggregated_voting_power += voting_power as u128;
                if signed_batch_info.signer() == self.signature_aggregator.data().author() {
                    self.self_voted = true;
                }
            },
            None => {
                error!(
                    "Received signature from author not in validator set: {}",
                    signed_batch_info.signer()
                );
                return Err(SignedBatchInfoError::InvalidAuthor);
            },
        }

        Ok(())
    }
```

**File:** consensus/src/quorum_store/proof_coordinator.rs (L192-202)
```rust
    fn observe_voting_pct(&mut self, timestamp: u64, validator_verifier: &ValidatorVerifier) {
        let pct = self
            .aggregated_voting_power
            .saturating_mul(100)
            .saturating_div(validator_verifier.total_voting_power()) as u8;
        let author = self.signature_aggregator.data().author();
        if pct >= self.last_increment_pct + 10 {
            observe_batch_vote_pct(timestamp, author, pct);
            self.last_increment_pct = pct;
        }
    }
```

**File:** types/src/ledger_info.rs (L460-462)
```rust
    pub fn add_signature(&mut self, validator: AccountAddress, signature: &SignatureWithStatus) {
        self.signatures.insert(validator, signature.clone());
    }
```

**File:** types/src/ledger_info.rs (L517-536)
```rust
    pub fn aggregate_and_verify(
        &mut self,
        verifier: &ValidatorVerifier,
    ) -> Result<(T, AggregateSignature), VerifyError> {
        let aggregated_sig = self.try_aggregate(verifier)?;

        match verifier.verify_multi_signatures(&self.data, &aggregated_sig) {
            Ok(_) => {
                // We are not marking all the signatures as "verified" here, as two malicious
                // voters can collude and create a valid aggregated signature.
                Ok((self.data.clone(), aggregated_sig))
            },
            Err(_) => {
                self.filter_invalid_signatures(verifier);

                let aggregated_sig = self.try_aggregate(verifier)?;
                Ok((self.data.clone(), aggregated_sig))
            },
        }
    }
```

**File:** consensus/src/quorum_store/network_listener.rs (L57-67)
```rust
                    VerifiedEvent::SignedBatchInfo(signed_batch_infos) => {
                        counters::QUORUM_STORE_MSG_COUNT
                            .with_label_values(&["NetworkListener::signedbatchinfo"])
                            .inc();
                        let cmd =
                            ProofCoordinatorCommand::AppendSignature(sender, *signed_batch_infos);
                        self.proof_coordinator_tx
                            .send(cmd)
                            .await
                            .expect("Could not send signed_batch_info to proof_coordinator");
                    },
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L542-551)
```rust
pub enum SignedBatchInfoError {
    WrongAuthor,
    WrongInfo((u64, u64)),
    DuplicatedSignature,
    InvalidAuthor,
    NotFound,
    AlreadyCommitted,
    NoTimeStamps,
    UnableToAggregate,
}
```

**File:** consensus/src/quorum_store/tracing.rs (L27-34)
```rust
pub fn observe_batch_vote_pct(timestamp: u64, author: Author, pct: u8) {
    if let Some(t) = duration_since_epoch().checked_sub(Duration::from_micros(timestamp)) {
        let pct = (pct / 10) * 10;
        counters::BATCH_VOTE_PROGRESS
            .with_label_values(&[author.short_str().as_str(), &pct.to_string()])
            .observe(t.as_secs_f64());
    }
}
```
