# Audit Report

## Title
Transaction Atomicity Violation: Type Safety Checks Performed After Commit with async_runtime_checks Enabled

## Summary
When both `paranoid_type_verification=true` and `async_runtime_checks=true` are configured, the Aptos VM performs runtime type safety checks asynchronously in the post-commit hook rather than during execution. This creates a critical race condition where transactions with type violations can be committed to the blockchain before the violations are detected, breaking transaction atomicity and potentially causing consensus divergence across validators. [1](#0-0) [2](#0-1) 

## Finding Description

The vulnerability arises from the interaction between two configuration flags that control runtime type checking in the Move VM:

**Configuration Analysis:**

The `ExecutionConfig` struct defines two relevant fields that control type safety verification. When `async_runtime_checks` is enabled, the comment explicitly states that "runtime checks like paranoid type checks may be performed in parallel in post commit hook in Block-STM." [3](#0-2) [4](#0-3) 

**Type Check Bypass During Execution:**

In the Move VM interpreter, when trace recording is enabled (which happens when async runtime checks are enabled), the paranoid type checks are explicitly disabled during execution. This means transactions execute WITHOUT type safety verification. [5](#0-4) 

The interpreter then selects `NoRuntimeTypeCheck` mode when `paranoid_type_checks` is false, completely bypassing synchronous type verification: [6](#0-5) 

**Transaction Commit Happens First:**

During parallel execution, the `commit()` method in `TxnLastInputOutput` marks the transaction as committed by adding it to the post-commit queue. The code includes a critical warning that after this point, the output can be taken for materialization. [7](#0-6) [8](#0-7) 

**Type Checks Performed After Commit:**

The async type checks are performed in `materialize_txn_commit`, which is called from `drain_commit_queue` AFTER transactions have been committed. If type violations are detected at this stage, the function returns a `PanicError`, but the transaction is already committed. [9](#0-8) [10](#0-9) [11](#0-10) 

The comment mentions "fallback to sequential execution" but this occurs AFTER the transaction has been committed, meaning there is no rollback mechanism. [12](#0-11) 

**Exploitation Path:**

1. A node operator configures both `paranoid_type_verification=true` and `async_runtime_checks=true` in their execution config
2. An attacker submits a transaction (script or untrusted entry function) containing deliberate type violations
3. The transaction executes without synchronous type checks (bypassed due to trace recording)
4. The transaction passes validation and is committed via `commit()` method
5. The transaction is added to the post-commit queue
6. Later, `materialize_txn_commit` performs async type checking via `TypeChecker::replay()`
7. The type violation is detected and returns an error
8. However, the transaction's state changes are already committed and irreversible

## Impact Explanation

**Critical Severity** - This vulnerability meets multiple criteria for Critical severity under the Aptos bug bounty program:

**1. Consensus/Safety Violations:**
The vulnerability directly violates the fundamental consensus invariant #1: "Deterministic Execution: All validators must produce identical state roots for identical blocks." Different validators may experience different timing in their async type checks relative to commit operations, potentially causing them to diverge on which transactions succeeded. This could lead to:
- Non-recoverable network partition requiring a hardfork
- Chain splits where validators disagree on valid state
- Total loss of consensus safety guarantees

**2. State Consistency Violation:**
Breaks invariant #4: "State Consistency: State transitions must be atomic and verifiable via Merkle proofs." Transactions with type violations can have their state changes committed before violations are detected, making state transitions non-atomic. This allows type-unsafe code to permanently modify blockchain state.

**3. Move VM Safety Violation:**
Breaks invariant #3: "Move VM Safety: Bytecode execution must respect gas limits and memory constraints." Type safety is a fundamental Move VM guarantee. Allowing type-unsafe code to commit violates core VM safety properties and could enable:
- Memory corruption
- Gas calculation bypasses
- Resource access violations
- Unpredictable VM behavior

**4. No Rollback Mechanism:**
Once a transaction is added to the post-commit queue, there is no mechanism to roll back its state changes if the async type check subsequently fails. The committed state is permanent.

## Likelihood Explanation

**Likelihood: Medium to High**

**Factors Increasing Likelihood:**

1. **Configuration Combination:** While `async_runtime_checks` defaults to false, the TODO comment at line 93-94 suggests the Aptos team is considering making it true by default for performance optimization. If this change is made, the vulnerability becomes immediately exploitable on all mainnet nodes. [13](#0-12) 

2. **Performance Incentive:** Node operators may enable `async_runtime_checks` to improve performance, as the feature is designed to reduce overhead during speculative execution in Block-STM by deferring checks to post-commit time.

3. **Automatic Targeting:** The vulnerability automatically affects scripts and untrusted entry functions based on the heuristic in `should_perform_async_runtime_checks_for_txn`. [14](#0-13) 

4. **Mainnet Enforcement:** The sanitizer enforces that `paranoid_type_verification` must be enabled on mainnet, making half of the vulnerable configuration mandatory. [15](#0-14) 

**Factors Reducing Likelihood:**

1. The `async_runtime_checks` feature is currently disabled by default
2. Requires specific configuration combination
3. The feature appears to be experimental/optimization-focused

However, the **severity of impact** (consensus failure) far outweighs the moderate likelihood, making this a critical security concern.

## Recommendation

**Immediate Fix:**

1. **Add Configuration Validation:** Prevent the unsafe combination of `paranoid_type_verification=true` and `async_runtime_checks=true` in the config sanitizer:

```rust
// In config/src/config/execution_config.rs, add to sanitize() method:
if execution_config.paranoid_type_verification && execution_config.async_runtime_checks {
    return Err(Error::ConfigSanitizerFailed(
        sanitizer_name,
        "async_runtime_checks cannot be enabled when paranoid_type_verification is enabled. \
         Type checks must be performed synchronously to ensure transaction atomicity.".into(),
    ));
}
```

2. **Perform Sync Checks Regardless:** Modify the interpreter to always perform synchronous type checks when `paranoid_type_verification` is enabled, even if trace recording is active:

```rust
// In third_party/move/move-vm/runtime/src/interpreter.rs:
let paranoid_type_checks = interpreter.vm_config.paranoid_type_checks;
// Remove the !trace_recorder.is_enabled() condition
```

**Long-term Solution:**

3. **Move Type Checks to Pre-Commit:** Refactor the async type checking to occur BEFORE commit, not in the post-commit hook. Add a pre-commit validation phase:
   - Collect trace during execution
   - Validate trace before calling `commit()`
   - Only commit if validation passes
   - This preserves the performance benefit while maintaining atomicity

4. **Add Consensus Assertion:** Add an assertion in the commit path that no pending async checks exist for the transaction being committed.

## Proof of Concept

```rust
// Proof of Concept - Rust test demonstrating the vulnerability

#[test]
fn test_async_type_check_after_commit_vulnerability() {
    // 1. Setup: Create a node config with both settings enabled
    let mut config = NodeConfig::default();
    config.execution.paranoid_type_verification = true;
    config.execution.async_runtime_checks = true;  // Vulnerable config
    
    // 2. Create a Move transaction with intentional type violations
    // (e.g., incorrect type arguments in generics, type confusion)
    let malicious_txn = create_type_violating_transaction();
    
    // 3. Execute the transaction through Block-STM
    let block = vec![malicious_txn];
    let executor = BlockExecutor::new(config, ...);
    let result = executor.execute_block(block);
    
    // 4. Observe that:
    // - Transaction executes WITHOUT sync type checks (bypassed)
    // - Transaction COMMITS successfully (passes validation)
    // - Async type check in materialize_txn_commit detects violation
    // - But transaction state is ALREADY COMMITTED
    
    // Expected: Transaction should fail BEFORE commit
    // Actual: Transaction commits, then fails async check
    assert!(transaction_was_committed_before_type_check_failure(&result));
}

fn create_type_violating_transaction() -> SignedTransaction {
    // Create a Move script/entry function with type violations
    // For example:
    // - Generic type parameter mismatch
    // - Struct field type mismatch in serialization
    // - Vector element type confusion
    // These would be caught by paranoid type checks if synchronous
    ...
}
```

```move
// Move PoC module - demonstrates type violation that could commit

module attacker::type_violation {
    use std::vector;
    
    // Function with intentional type confusion that paranoid checks would catch
    public entry fun exploit_type_confusion() {
        // This creates a type violation that would be caught by
        // paranoid_type_verification if performed synchronously,
        // but if async, the transaction commits before detection
        
        let v = vector::empty<u64>();
        // ... perform operations that create type stack violations ...
        // ... that would be caught by FullRuntimeTypeCheck ...
        // ... but NOT caught if NoRuntimeTypeCheck is used ...
    }
}
```

**Notes:**

- The vulnerability is a direct consequence of the architectural decision to defer safety checks to post-commit time
- The comment at line 1244-1246 in executor.rs acknowledges the issue but incorrectly assumes sequential fallback can handle it
- The race condition is not about thread timing, but about the logical ordering: commit happens before safety verification
- Different validators could have different async check completion timing, causing consensus divergence
- This is particularly dangerous because mainnet REQUIRES `paranoid_type_verification=true`, so only the `async_runtime_checks` flag needs to be enabled to trigger the vulnerability

### Citations

**File:** config/src/config/execution_config.rs (L43-44)
```rust
    /// Enables paranoid mode for types, which adds extra runtime VM checks
    pub paranoid_type_verification: bool,
```

**File:** config/src/config/execution_config.rs (L57-59)
```rust
    /// If enabled, runtime checks like paranoid type checks may be performed in parallel in post
    /// commit hook in Block-STM.
    pub async_runtime_checks: bool,
```

**File:** config/src/config/execution_config.rs (L93-94)
```rust
            // TODO: consider setting to be true by default.
            async_runtime_checks: false,
```

**File:** config/src/config/execution_config.rs (L176-181)
```rust
                if !execution_config.paranoid_type_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_type_verification must be enabled for mainnet nodes!".into(),
                    ));
                }
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L244-245)
```rust
        let paranoid_type_checks =
            !trace_recorder.is_enabled() && interpreter.vm_config.paranoid_type_checks;
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L276-276)
```rust
            (false, _, false) => execute_main!(NoRuntimeTypeCheck, NoRuntimeRefCheck),
```

**File:** aptos-move/block-executor/src/txn_last_input_output.rs (L376-376)
```rust
        scheduler.add_to_post_commit(txn_idx)?;
```

**File:** aptos-move/block-executor/src/txn_last_input_output.rs (L378-380)
```rust
        // !!! CAUTION !!! after the txn_idx is added to the post commit queue, it is no longer
        // safe to expect an output be stored for txn_idx: post-commit materialization takes
        // the output (instead of cloning for efficiency) for parallel post-processing.
```

**File:** aptos-move/block-executor/src/executor.rs (L1234-1241)
```rust
        if environment.async_runtime_checks_enabled() && !trace.is_empty() {
            // Note that the trace may be empty (if block was small and executor decides not to
            // collect the trace and replay, or if the VM decides it is not profitable to do this
            // check for this particular transaction), so we check it in advance.
            let result = {
                counters::update_txn_trace_counters(&trace);
                let _timer = TRACE_REPLAY_SECONDS.start_timer();
                TypeChecker::new(&latest_view).replay(&trace)
```

**File:** aptos-move/block-executor/src/executor.rs (L1244-1246)
```rust
            // In case of runtime type check errors, fallback to sequential execution. There errors
            // are supposed to be unlikely so this fallback is fine, and is mostly needed to make
            // sure transaction epilogue runs after failure, etc.
```

**File:** aptos-move/block-executor/src/executor.rs (L1247-1256)
```rust
            if let Err(err) = result {
                alert!(
                    "Runtime type check failed during replay of transaction {}: {:?}",
                    txn_idx,
                    err
                );
                return Err(PanicError::CodeInvariantError(format!(
                    "Sequential fallback on type check failure for transaction {}: {:?}",
                    txn_idx, err
                )));
```

**File:** aptos-move/block-executor/src/executor.rs (L1311-1322)
```rust
        let drain_commit_queue = || -> Result<(), PanicError> {
            while let Ok(txn_idx) = scheduler.pop_from_commit_queue() {
                self.materialize_txn_commit(
                    txn_idx,
                    scheduler_wrapper,
                    environment,
                    shared_sync_params,
                )?;
                self.record_finalized_output(txn_idx, txn_idx, shared_sync_params)?;
            }
            Ok(())
        };
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L409-423)
```rust
    fn should_perform_async_runtime_checks_for_txn(&self, txn: &SignedTransaction) -> bool {
        self.async_runtime_checks_enabled
            && match txn.payload().executable_ref() {
                Ok(TransactionExecutableRef::Script(_)) => {
                    // For now, always delay checks for scripts.
                    true
                },
                Ok(TransactionExecutableRef::EntryFunction(f)) => {
                    // If entry function is defined at special address - it is part of trusted code
                    // and so no need to delay any checks (as there are none).
                    !f.module().address().is_special()
                },
                Ok(TransactionExecutableRef::Empty) | Err(_) => false,
            }
    }
```
