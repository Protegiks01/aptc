# Audit Report

## Title
DKG Protocol Lacks Panic Recovery - Validator Process Termination on Any Panic

## Summary
The Distributed Key Generation (DKG) protocol in Aptos validators cannot recover from panics. Any panic in DKG code paths terminates the entire validator process, requiring manual restart. While specific panic locations exist in cryptographic utilities, they appear adequately protected by validation checks, making this primarily an architectural robustness concern rather than an immediately exploitable vulnerability.

## Finding Description

The DKG subsystem has three critical architectural components that interact to create a non-recoverable failure mode:

**1. Panic Sites in Cryptographic Utilities** [1](#0-0) [2](#0-1) 

These functions explicitly panic when `bases.len() != scalars.len()` to work around known bugs in the underlying `blstrs` library.

**2. DKG Manager Task Spawning Without Monitoring** [3](#0-2) 

The DKGManager is spawned as a tokio task without capturing the `JoinHandle`, meaning the epoch manager cannot detect if the task panics and dies.

**3. Global Panic Handler Terminates Process** [4](#0-3) [5](#0-4) 

The panic handler installed at validator startup calls `process::exit(12)` on any panic (except verifier/deserializer threads), ensuring any DKG panic terminates the validator.

**Validation Checks That Mitigate Risk**

The codebase includes validation that should prevent length mismatches in normal operation: [6](#0-5) [7](#0-6) [8](#0-7) 

## Impact Explanation

This qualifies as **High Severity** under "Validator node slowdowns" and "Significant protocol violations" because:

- **Availability Impact**: A panic forces complete validator shutdown, not just DKG subsystem failure
- **Manual Intervention Required**: Operators must manually restart the validator process
- **No Graceful Degradation**: The validator cannot continue consensus participation without DKG
- **Network-Wide Risk**: If multiple validators experience similar issues simultaneously, network liveness degrades

However, this does NOT reach Critical severity because:
- No funds are at risk
- Consensus safety is not violated (the validator simply stops participating)
- Recovery is possible via restart (not permanent)
- No evidence of deliberate exploitability

## Likelihood Explanation

**Likelihood: Low** 

While the architectural vulnerability is confirmed, actual exploitation likelihood is low because:

1. **Strong Input Validation**: All identified call sites to `g1_multi_exp`/`g2_multi_exp` include length checks
2. **No Clear Attack Vector**: Investigation found no realistic path for malicious input to bypass validation and trigger mismatched lengths
3. **Crypto Library Reliability**: The `hash_to_scalar` panic requiring SHA3-512 to return wrong size is essentially impossible barring catastrophic library bugs
4. **Requires Bug Introduction**: Most likely trigger would be future code changes introducing bugs, not current exploitable conditions

The vulnerability represents a **fragility** rather than an **exploit**: the system will fail catastrophically IF a panic occurs, but causing that panic appears difficult with current protections.

## Recommendation

Implement panic recovery and monitoring for the DKG subsystem:

**1. Capture and Monitor JoinHandle**

```rust
// In dkg/src/epoch_manager.rs, replace line 253:
let dkg_handle = tokio::spawn(dkg_manager.run(
    in_progress_session,
    dkg_start_event_rx,
    dkg_rpc_msg_rx,
    dkg_manager_close_rx,
));

// Store handle and monitor it:
self.dkg_manager_handle = Some(dkg_handle);

// In the event loop, add:
dkg_result = self.dkg_manager_handle.as_mut().unwrap() => {
    match dkg_result {
        Ok(_) => info!("DKG manager exited cleanly"),
        Err(e) => {
            error!("DKG manager panicked: {:?}", e);
            // Attempt recovery: restart DKG manager or enter safe mode
        }
    }
}
```

**2. Replace Panics with Result Types**

```rust
// In crates/aptos-dkg/src/utils/mod.rs:
pub fn g1_multi_exp(bases: &[G1Projective], scalars: &[blstrs::Scalar]) 
    -> anyhow::Result<G1Projective> 
{
    if bases.len() != scalars.len() {
        bail!(
            "blstrs's multiexp requires # of bases == # of scalars ({} != {})",
            bases.len(), scalars.len()
        );
    }
    Ok(match bases.len() {
        0 => G1Projective::identity(),
        1 => bases[0].mul(scalars[0]),
        _ => G1Projective::multi_exp(bases, scalars),
    })
}
```

**3. Implement DKG Circuit Breaker**

Add state tracking to prevent repeated failures and allow validators to continue consensus participation even if DKG fails.

## Proof of Concept

**Cannot be provided.** 

After thorough investigation, I could not construct a realistic PoC that:
1. Bypasses existing validation checks
2. Triggers the panic conditions via malicious input
3. Demonstrates attacker-controlled exploitation

The validation checks in `check_sizes`, `augment_pubkey`, and other locations appear adequate to prevent malicious transcripts from causing length mismatches. The `hash_to_scalar` panic is only triggerable by underlying crypto library failure, not attacker input.

## Notes

**Critical Distinction**: This report describes an **architectural fragility** (lack of panic recovery) rather than a **concrete exploit** (attacker-triggerable panic). The security question asked "can the DKG protocol recover from panics?" - the answer is definitively **NO**. However, demonstrating HOW an attacker would cause those panics proved impossible with current code protections.

The issue should be addressed as a **robustness improvement** to harden the system against future bugs, unexpected edge cases, or memory corruption scenarios, rather than as an immediately exploitable vulnerability requiring emergency patching.

### Citations

**File:** crates/aptos-dkg/src/utils/mod.rs (L58-72)
```rust
pub fn g1_multi_exp(bases: &[G1Projective], scalars: &[blstrs::Scalar]) -> G1Projective {
    if bases.len() != scalars.len() {
        panic!(
            "blstrs's multiexp has heisenbugs when the # of bases != # of scalars ({} != {})",
            bases.len(),
            scalars.len()
        );
    }

    match bases.len() {
        0 => G1Projective::identity(),
        1 => bases[0].mul(scalars[0]),
        _ => G1Projective::multi_exp(bases, scalars),
    }
}
```

**File:** crates/aptos-dkg/src/utils/mod.rs (L75-88)
```rust
pub fn g2_multi_exp(bases: &[G2Projective], scalars: &[blstrs::Scalar]) -> G2Projective {
    if bases.len() != scalars.len() {
        panic!(
            "blstrs's multiexp has heisenbugs when the # of bases != # of scalars ({} != {})",
            bases.len(),
            scalars.len()
        );
    }
    match bases.len() {
        0 => G2Projective::identity(),
        1 => bases[0].mul(scalars[0]),
        _ => G2Projective::multi_exp(bases, scalars),
    }
}
```

**File:** dkg/src/epoch_manager.rs (L253-258)
```rust
            tokio::spawn(dkg_manager.run(
                in_progress_session,
                dkg_start_event_rx,
                dkg_rpc_msg_rx,
                dkg_manager_close_rx,
            ));
```

**File:** aptos-node/src/lib.rs (L233-234)
```rust
    // Setup panic handler
    aptos_crash_handler::setup_panic_handler();
```

**File:** crates/crash-handler/src/lib.rs (L56-57)
```rust
    // Kill the process
    process::exit(12);
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L288-288)
```rust
        self.check_sizes(sc)?;
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L442-447)
```rust
        if self.R_hat.len() != W {
            bail!(
                "Expected {} G_2 commitment(s) to ElGamal randomness, but got {}",
                W,
                self.R_hat.len()
            );
```

**File:** crates/aptos-dkg/src/weighted_vuf/pinkas/mod.rs (L114-120)
```rust
        if delta.rks.len() != pk.len() {
            bail!(
                "Expected PKs and RKs to be of the same length. Got {} and {}, respectively.",
                delta.rks.len(),
                pk.len()
            );
        }
```
