# Audit Report

## Title
Critical Information Loss in V2 to V1 Event Translation: coin_type Field Discarded

## Summary
The translation from V2 to V1 event format systematically discards the `coin_type` field from coin-related events (deposits, withdrawals), causing downstream API consumers to receive incomplete event data that prevents them from determining which cryptocurrency was involved in a transaction.

## Finding Description

The V2 to V1 event translation mechanism contains a fundamental semantic information loss vulnerability. When V2 events are translated to V1 format for API consumers, critical fields are permanently discarded.

**Event Structure Comparison:**

V2 `CoinDeposit` event contains: [1](#0-0) 

V1 `DepositEvent` contains: [2](#0-1) 

**Translation Code Path:**

The `CoinDepositTranslator` extracts `coin_type` from the V2 event but only preserves `amount` in the V1 event: [3](#0-2) 

**API Exposure:**

When API consumers request events, V2 events are automatically replaced with translated V1 events: [4](#0-3) 

The API layer applies this translation to all event responses: [5](#0-4) 

**Exploitation Scenario:**

1. User deposits 100 USDC to their account (V2 event emitted with `coin_type="0x1::usdc::USDC"`, `account=0xABC`, `amount=100`)
2. User deposits 100 AptosCoin to the same account (V2 event emitted with `coin_type="0x1::aptos_coin::AptosCoin"`, `account=0xABC`, `amount=100`)
3. Wallet/indexer queries events via API
4. Both events are translated to V1 format containing only `amount=100`
5. Wallet cannot determine which coin was deposited and may display incorrect balances or treat all deposits as the same coin type

**Verification in Move Framework:**

The Move framework shows V2 events contain `coin_type` while V1 events do not: [6](#0-5) 

## Impact Explanation

**Severity: High** - This meets the "Significant protocol violations" criterion as it breaks the semantic contract that events should preserve transaction effects.

The impact affects the entire ecosystem:

1. **Wallets**: Cannot accurately display which coins were deposited/withdrawn, leading to user confusion and potential loss of funds due to incorrect balance displays
2. **Indexers**: Must implement complex workarounds using `EventToCoinType` mappings from transaction writesets, as evidenced in the indexer codebase: [7](#0-6) 

3. **DeFi Protocols**: Smart contracts or off-chain systems tracking coin movements cannot rely on events alone and must query additional state
4. **Analytics Platforms**: Historical event analysis is incomplete without coin_type information

The vulnerability breaks the fundamental expectation that blockchain events preserve all semantic information about state transitions.

## Likelihood Explanation

**Likelihood: Certain** - This occurs on every coin deposit/withdrawal transaction when the MODULE_EVENT_MIGRATION feature is enabled.

The issue is systematic and affects:
- All API consumers reading events through standard endpoints
- All wallets integrating with Aptos REST API
- All indexers not implementing the complex EventToCoinType mapping workaround
- Transaction simulation endpoints that return translated events

Testing confirms this behavior: [8](#0-7) 

## Recommendation

**Option 1: Preserve coin_type in translated events (BREAKING CHANGE)**

Modify the V1 event structure to include coin_type or encode it in the type_tag generics. However, this breaks V1 compatibility.

**Option 2: Provide V2 events alongside V1 (NON-BREAKING)**

Modify the API to return both V2 and V1 events, allowing consumers to choose:
```rust
pub struct EventWithVersion {
    pub transaction_version: Version,
    pub event: ContractEvent,        // Translated V1 for backward compatibility
    pub original_event: Option<ContractEvent>, // Original V2 if available
}
```

**Option 3: Add metadata to V1 events**

Include a metadata field in the API response with coin_type extracted from the original V2 event:
```rust
pub struct EventWithMetadata {
    pub event: ContractEventV1,
    pub metadata: HashMap<String, String>, // {"coin_type": "0x1::aptos_coin::AptosCoin"}
}
```

**Recommended Approach**: Option 2 - Provide both events, defaulting to V1 for backward compatibility but allowing consumers to access V2 for complete information.

## Proof of Concept

```move
// poc_coin_type_loss.move
script {
    use std::signer;
    use aptos_framework::coin;
    use aptos_framework::aptos_coin::AptosCoin;
    
    fun test_coin_type_loss(account: &signer) {
        // Deposit AptosCoin - emits V2 event with coin_type
        let coins = coin::withdraw<AptosCoin>(account, 100);
        coin::deposit(signer::address_of(account), coins);
        
        // Deposit USDC - emits V2 event with different coin_type  
        // When API consumer queries these events, both will show
        // only amount=100 with no way to distinguish coin types
    }
}
```

```rust
// Rust test demonstrating the information loss
#[test]
fn test_v2_to_v1_translation_loses_coin_type() {
    let v2_event = CoinDeposit::new(
        "0x1::usdc::USDC".to_string(),
        AccountAddress::from_hex_literal("0xABC").unwrap(),
        100,
    );
    
    let v2_contract_event = ContractEventV2::new(
        COIN_DEPOSIT_TYPE.clone(),
        bcs::to_bytes(&v2_event).unwrap(),
    ).unwrap();
    
    let translator = CoinDepositTranslator;
    let v1_event = translator.translate_event_v2_to_v1(
        &v2_contract_event, 
        &engine
    ).unwrap();
    
    // V1 event only contains amount, coin_type is lost
    let v1_data: DepositEvent = bcs::from_bytes(v1_event.event_data()).unwrap();
    assert_eq!(v1_data.amount(), 100);
    // No way to retrieve coin_type from v1_event
}
```

---

**Notes**

While the translation preserves `account` information in the EventKey and `amount` in the event data, the `coin_type` field—critical for distinguishing between different cryptocurrencies—is permanently discarded during V2→V1 conversion. This forces downstream consumers to either:
1. Implement complex workarounds using state queries and writeset analysis
2. Accept incomplete event data leading to potential misinterpretation
3. Miss critical information about which asset was actually transferred

The same information loss pattern affects `CoinWithdraw` events and potentially other event types in the translation system.

### Citations

**File:** types/src/account_config/events/coin_deposit.rs (L16-20)
```rust
pub struct CoinDeposit {
    pub coin_type: String,
    pub account: AccountAddress,
    pub amount: u64,
}
```

**File:** types/src/account_config/events/deposit_event.rs (L15-18)
```rust
#[derive(Debug, Serialize, Deserialize)]
pub struct DepositEvent {
    amount: u64,
}
```

**File:** storage/indexer/src/event_v2_translator.rs (L238-273)
```rust
struct CoinDepositTranslator;
impl EventV2Translator for CoinDepositTranslator {
    fn translate_event_v2_to_v1(
        &self,
        v2: &ContractEventV2,
        engine: &EventV2TranslationEngine,
    ) -> Result<ContractEventV1> {
        let coin_deposit = CoinDeposit::try_from_bytes(v2.event_data())?;
        let struct_tag_str = format!("0x1::coin::CoinStore<{}>", coin_deposit.coin_type());
        let struct_tag = StructTag::from_str(&struct_tag_str)?;
        let (key, sequence_number) = if let Some(state_value_bytes) =
            engine.get_state_value_bytes_for_resource(coin_deposit.account(), &struct_tag)?
        {
            // We can use `DummyCoinType` as it does not affect the correctness of deserialization.
            let coin_store_resource: CoinStoreResource<DummyCoinType> =
                bcs::from_bytes(&state_value_bytes)?;
            let key = *coin_store_resource.deposit_events().key();
            let sequence_number = engine
                .get_next_sequence_number(&key, coin_store_resource.deposit_events().count())?;
            (key, sequence_number)
        } else {
            // The creation number of DepositEvent is deterministically 2.
            static DEPOSIT_EVENT_CREATION_NUMBER: u64 = 2;
            (
                EventKey::new(DEPOSIT_EVENT_CREATION_NUMBER, *coin_deposit.account()),
                0,
            )
        };
        let deposit_event = DepositEvent::new(coin_deposit.amount());
        Ok(ContractEventV1::new(
            key,
            sequence_number,
            DEPOSIT_EVENT_TYPE.clone(),
            bcs::to_bytes(&deposit_event)?,
        )?)
    }
```

**File:** storage/indexer/src/db_indexer.rs (L692-718)
```rust
        let mut events_with_version = event_indices
            .into_iter()
            .map(|(seq, ver, idx)| {
                let event = match self
                    .main_db_reader
                    .get_event_by_version_and_index(ver, idx)?
                {
                    event @ ContractEvent::V1(_) => event,
                    ContractEvent::V2(_) => ContractEvent::V1(
                        self.indexer_db
                            .get_translated_v1_event_by_version_and_index(ver, idx)?,
                    ),
                };
                let v0 = match &event {
                    ContractEvent::V1(event) => event,
                    ContractEvent::V2(_) => bail!("Unexpected module event"),
                };
                ensure!(
                    seq == v0.sequence_number(),
                    "Index broken, expected seq:{}, actual:{}",
                    seq,
                    v0.sequence_number()
                );

                Ok(EventWithVersion::new(ver, event))
            })
            .collect::<Result<Vec<_>>>()?;
```

**File:** api/src/context.rs (L1020-1036)
```rust
    fn translate_v2_to_v1_events_for_version(
        &self,
        version: u64,
        events: &mut [ContractEvent],
    ) -> Result<()> {
        for (idx, event) in events.iter_mut().enumerate() {
            let translated_event = self
                .indexer_reader
                .as_ref()
                .ok_or(anyhow!("Internal indexer reader doesn't exist"))?
                .get_translated_v1_event_by_version_and_index(version, idx as u64);
            if let Ok(translated_event) = translated_event {
                *event = ContractEvent::V1(translated_event);
            }
        }
        Ok(())
    }
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L177-217)
```text
    #[event]
    /// Module event emitted when some amount of a coin is deposited into an account.
    struct CoinDeposit has drop, store {
        coin_type: String,
        account: address,
        amount: u64
    }

    #[event]
    /// Module event emitted when some amount of a coin is withdrawn from an account.
    struct CoinWithdraw has drop, store {
        coin_type: String,
        account: address,
        amount: u64
    }

    // DEPRECATED, NEVER USED
    #[deprecated]
    #[event]
    struct Deposit<phantom CoinType> has drop, store {
        account: address,
        amount: u64
    }

    // DEPRECATED, NEVER USED
    #[deprecated]
    #[event]
    struct Withdraw<phantom CoinType> has drop, store {
        account: address,
        amount: u64
    }

    /// Event emitted when some amount of a coin is deposited into an account.
    struct DepositEvent has drop, store {
        amount: u64
    }

    /// Event emitted when some amount of a coin is withdrawn from an account.
    struct WithdrawEvent has drop, store {
        amount: u64
    }
```

**File:** crates/indexer/src/models/coin_models/coin_activities.rs (L221-233)
```rust
        let event_move_guid = EventGuidResource {
            addr: event.guid.account_address.to_string(),
            creation_num: event.guid.creation_number.0 as i64,
        };
        let coin_type =
            event_to_coin_type
                .get(&event_move_guid)
                .unwrap_or_else(|| {
                    panic!(
                        "Could not find event in resources (CoinStore), version: {}, event guid: {:?}, mapping: {:?}",
                        txn_version, event_move_guid, event_to_coin_type
                    )
                }).clone();
```

**File:** api/src/tests/event_v2_translation_test.rs (L45-108)
```rust
#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
#[ignore]
async fn test_event_v2_translation_coin_deposit_event() {
    let context = &mut new_test_context(current_function_name!());

    // Start with the MODULE_EVENT_MIGRATION feature disabled
    context.disable_feature(MODULE_EVENT_MIGRATION).await;

    // Create two accounts
    let account1 = &mut context.api_create_account().await;
    let account2 = &mut context.api_create_account().await;

    // Transfer coins from account1 to account2, emitting V1 events as the feature is disabled
    context
        .api_execute_aptos_account_transfer(account2, account1.address(), 101)
        .await;

    // Enable the MODULE_EVENT_MIGRATION feature
    context.enable_feature(MODULE_EVENT_MIGRATION).await;

    // Check the simulation API outputs the translated V1 event rather than the V2 event as it is
    let payload = json!({
        "type": "entry_function_payload",
        "function": "0x1::coin::transfer",
        "type_arguments": ["0x1::aptos_coin::AptosCoin"],
        "arguments": [
            account1.address().to_hex_literal(), "102"
        ]
    });
    let resp = context.simulate_transaction(account2, payload, 200).await;

    let is_expected_event = |e: &Value| {
        matches_event_details(e, "0x1::coin::DepositEvent", 2, account1.address(), 2)
            && e["data"]["amount"] == "102"
    };

    assert!(resp[0]["events"]
        .as_array()
        .unwrap()
        .iter()
        .any(is_expected_event));

    // Transfer coins from account2 to account1, emitting V2 events as the feature is enabled
    context
        .api_execute_aptos_account_transfer(account2, account1.address(), 102)
        .await;
    context.wait_for_internal_indexer_caught_up().await;

    // Check the event_by_creation_number API outputs the translated V1 event
    let resp = context
        .gen_events_by_creation_num(&account1.address(), 2)
        .await;
    assert!(is_expected_event(resp.as_array().unwrap().last().unwrap()));

    // Check the event_by_handle API outputs the translated V1 event
    let resp = context
        .gen_events_by_handle(
            &account1.address(),
            "0x1::coin::CoinStore%3C0x1::aptos_coin::AptosCoin%3E",
            "deposit_events",
        )
        .await;
    assert!(is_expected_event(resp.as_array().unwrap().last().unwrap()));

```
