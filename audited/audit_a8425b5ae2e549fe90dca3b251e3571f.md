# Audit Report

## Title
Case-Sensitive Address Comparison in Shared Filter Utility Enables Cross-Filter Vulnerability Propagation

## Summary
The `standardize_address` utility function preserves the case of hexadecimal characters while the Aptos blockchain always produces lowercase addresses. This case-sensitivity mismatch in the shared utility propagates to all filter modules (EventFilter, MoveStructTagFilter, UserTransactionFilter, EntryFunctionFilter), allowing attackers to bypass filters by manipulating address casing.

## Finding Description

The vulnerability exists in the shared `standardize_address` function that all filter modules depend on. This function is used by:
- `MoveStructTagFilter` for module addresses [1](#0-0) 
- `EventFilter` which depends on `MoveStructTagFilter` [2](#0-1) 
- `UserTransactionFilter` for sender addresses [3](#0-2) 
- `EntryFunctionFilter` for entry function addresses [4](#0-3) 

The bug occurs because `standardize_address` preserves the input case for special addresses (0x0-0xf): [5](#0-4) 

However, the Aptos blockchain always produces lowercase addresses. The `AccountAddress::Display` trait uses `to_standard_string()` [6](#0-5) , which uses `hex::encode()` that produces lowercase strings [7](#0-6) .

When converting transactions to protobuf, addresses use `.to_string()`: [8](#0-7) 

String comparison is case-sensitive: [9](#0-8) 

**Attack Path:**
1. Attacker creates filter with uppercase address "0xA" via protobuf API
2. Filter standardizes to "0xA" (uppercase preserved)
3. Blockchain emits event from address 0xA (value 10)
4. Blockchain serializes as "0xa" (lowercase via `hex::encode()`)
5. Matching: `standardize_address("0xa")` returns "0xa"
6. Comparison: "0xA" ≠ "0xa" → **Filter bypassed**

This demonstrates vulnerability propagation through shared state - the bug in `standardize_address` affects ALL filter types that use it.

## Impact Explanation

**Medium Severity** - This vulnerability causes state inconsistencies in the indexer infrastructure:

1. **Filter Bypass**: Attackers can evade event filters, transaction filters, and data service stripping by using different address casing
2. **Indexer Data Inconsistency**: Missing transactions/events that should be indexed leads to incomplete data
3. **Data Service Security**: If filters are used for access control or rate limiting in the data service [10](#0-9) , they can be bypassed
4. **Stream Filtering Bypass**: The fullnode stream coordinator applies filters [11](#0-10)  which can be evaded

While this doesn't directly affect consensus, it compromises the integrity of off-chain indexing infrastructure that applications depend on.

## Likelihood Explanation

**High Likelihood:**
- Trivial to exploit - simply use uppercase hex digits in addresses
- No special privileges required - any API user can create filters
- Affects all address-based filters across all filter types
- The shared utility design ensures the vulnerability propagates to every dependent module

## Recommendation

Normalize all hexadecimal characters to lowercase in the `standardize_address` function:

```rust
pub fn standardize_address(address: &str) -> String {
    // Remove "0x" prefix if it exists
    let trimmed = address.strip_prefix("0x").unwrap_or(address);
    
    // Convert to lowercase for case-insensitive comparison
    let trimmed = trimmed.to_lowercase();

    // Check if the address is a special address
    if let Some(last_char) = trimmed.chars().last() {
        if trimmed[..trimmed.len().saturating_sub(1)]
            .chars()
            .all(|c| c == '0')
            && last_char.is_ascii_hexdigit()
            && last_char <= 'f'
        {
            // Return special addresses in short format (lowercase)
            let mut result = String::with_capacity(3);
            result.push_str("0x");
            result.push(last_char);
            return result;
        }
    }

    // Return non-special addresses in long format (lowercase)
    let mut result = String::with_capacity(66);
    result.push_str("0x");
    result.push_str(&ZEROS[..64 - trimmed.len()]);
    result.push_str(&trimmed);
    result
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test_case_sensitivity_vulnerability {
    use super::*;
    use aptos_transaction_filter::{
        MoveStructTagFilterBuilder, EventFilterBuilder, Filterable
    };
    use aptos_protos::transaction::v1::{Event, MoveType, MoveStructTag};
    use aptos_protos::transaction::v1::move_type::Content;

    #[test]
    fn test_uppercase_address_filter_bypass() {
        // Create filter with UPPERCASE address 0xA
        let filter = EventFilterBuilder::default()
            .struct_type(
                MoveStructTagFilterBuilder::default()
                    .address("0xA")  // Uppercase A
                    .build()
                    .unwrap()
            )
            .build()
            .unwrap();

        // Create event with lowercase address 0xa (as blockchain would produce)
        let event = Event {
            r#type: Some(MoveType {
                content: Some(Content::Struct(MoveStructTag {
                    address: "0xa".to_string(),  // Lowercase a (from blockchain)
                    module: "test".to_string(),
                    name: "Event".to_string(),
                    generic_type_params: vec![],
                }))
            }),
            data: "{}".to_string(),
            ..Default::default()
        };

        // BUG: Filter should match (both represent value 10) but doesn't due to case sensitivity
        assert!(!filter.matches(&event), 
            "Filter bypass: uppercase 0xA filter doesn't match lowercase 0xa event");
        
        // This demonstrates the vulnerability: same address value, different case, no match
    }
}
```

This vulnerability demonstrates that the shared `standardize_address` utility creates a cross-module dependency that propagates the case-sensitivity bug to all filter types, breaking filter isolation guarantees.

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/move_module.rs (L39-45)
```rust
    fn get_standardized_address(&self) -> &Option<String> {
        self.standardized_address.get_or_init(|| {
            self.address
                .as_ref()
                .map(|address| standardize_address(address))
        })
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/event.rs (L38-38)
```rust
    pub struct_type: Option<MoveStructTagFilter>,
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L39-45)
```rust
    fn get_standardized_sender(&self) -> &Option<String> {
        self.standardized_sender.get_or_init(|| {
            self.sender
                .clone()
                .map(|address| standardize_address(&address))
        })
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L146-152)
```rust
    fn get_standardized_address(&self) -> &Option<String> {
        self.standardized_address.get_or_init(|| {
            self.address
                .clone()
                .map(|address| standardize_address(&address))
        })
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/utils.rs (L14-27)
```rust
    // Check if the address is a special address by seeing if the first 31 bytes are zero and the last byte is smaller than 0b10000
    if let Some(last_char) = trimmed.chars().last() {
        if trimmed[..trimmed.len().saturating_sub(1)]
            .chars()
            .all(|c| c == '0')
            && last_char.is_ascii_hexdigit()
            && last_char <= 'f'
        {
            // Return special addresses in short format
            let mut result = String::with_capacity(3);
            result.push_str("0x");
            result.push(last_char);
            return result;
        }
```

**File:** third_party/move/move-core/types/src/account_address.rs (L132-134)
```rust
    pub fn to_canonical_string(&self) -> String {
        hex::encode(self.0)
    }
```

**File:** third_party/move/move-core/types/src/account_address.rs (L267-270)
```rust
impl fmt::Display for AccountAddress {
    fn fmt(&self, f: &mut fmt::Formatter) -> std::fmt::Result {
        write!(f, "{}", self.to_standard_string())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/convert.rs (L337-347)
```rust
pub fn convert_move_struct_tag(struct_tag: &MoveStructTag) -> transaction::MoveStructTag {
    transaction::MoveStructTag {
        address: struct_tag.address.to_string(),
        module: struct_tag.module.to_string(),
        name: struct_tag.name.to_string(),
        generic_type_params: struct_tag
            .generic_type_params
            .iter()
            .map(convert_move_type)
            .collect(),
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/traits.rs (L114-121)
```rust
    #[inline]
    fn matches(&self, item: &String) -> bool {
        match self {
            Some(filter) => filter == item,
            None => true,
        }
    }
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs (L924-954)
```rust
fn strip_transactions(
    transactions: Vec<Transaction>,
    txns_to_strip_filter: &BooleanTransactionFilter,
) -> (Vec<Transaction>, usize) {
    let mut stripped_count = 0;

    let stripped_transactions: Vec<Transaction> = transactions
        .into_iter()
        .map(|mut txn| {
            // Note: `is_allowed` means the txn matches the filter, in which case
            // we strip it.
            if txns_to_strip_filter.matches(&txn) {
                stripped_count += 1;
                if let Some(info) = txn.info.as_mut() {
                    info.changes = vec![];
                }
                if let Some(TxnData::User(user_transaction)) = txn.txn_data.as_mut() {
                    user_transaction.events = vec![];
                    if let Some(utr) = user_transaction.request.as_mut() {
                        // Wipe the payload and signature.
                        utr.payload = None;
                        utr.signature = None;
                    }
                }
            }
            txn
        })
        .collect();

    (stripped_transactions, stripped_count)
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L175-182)
```rust
                let pb_txns = if let Some(ref filter) = filter {
                    pb_txns
                        .into_iter()
                        .filter(|txn| filter.matches(txn))
                        .collect::<Vec<_>>()
                } else {
                    pb_txns
                };
```
