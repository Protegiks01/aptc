# Audit Report

## Title
Config Buffer Initialization Failure Causes Governance Proposal Abortion on Older Chains

## Summary
Governance proposals generated by `oidc_providers.rs` to update OIDC providers will abort with a runtime error on chains where the `PendingConfigs` resource has not been initialized at the `@aptos_framework` address. This prevents legitimate governance operations from executing successfully, creating a denial-of-service condition for OIDC provider management.

## Finding Description

The `write_op()` function generates Move script calls to `jwks::upsert_oidc_provider_for_next_epoch()` and `jwks::remove_oidc_provider_for_next_epoch()`, which depend on the `config_buffer` system: [1](#0-0) 

These functions use the config buffer pattern to stage changes for the next epoch: [2](#0-1) 

The critical vulnerability occurs at line 328 where `config_buffer::upsert()` is called. This function directly calls `borrow_global_mut<PendingConfigs>(@aptos_framework)` without checking if the resource exists: [3](#0-2) 

The formal specification explicitly documents this abort condition: [4](#0-3) 

**Attack Path:**
1. Chain is deployed before `config_buffer` was added to genesis initialization, OR framework is upgraded without calling `config_buffer::initialize()`
2. The `PendingConfigs` resource does not exist at `@aptos_framework`
3. Governance proposal is created using the release builder to update OIDC providers
4. Proposal is approved and executed
5. Transaction ABORTs with `RESOURCE_DOES_NOT_EXIST` error when `config_buffer::upsert()` attempts to borrow the non-existent resource
6. No changes are applied, and governance functionality is blocked

## Impact Explanation

This is a **Medium severity** issue per the Aptos bug bounty criteria:

- **Not Critical**: Does not cause fund loss, consensus violation, or network partition
- **Not High**: Does not cause validator slowdowns or API crashes
- **Medium**: Causes "state inconsistencies requiring intervention" - governance proposals fail to execute, blocking legitimate governance operations until `config_buffer::initialize()` is manually called

The impact is limited to chains that:
1. Were deployed before config_buffer genesis initialization was added
2. Had their framework upgraded without proper migration
3. Have not yet called `config_buffer::initialize()`

This affects the **Governance Integrity** invariant, as governance proposals cannot execute correctly.

## Likelihood Explanation

**Likelihood: Medium to High** depending on chain deployment history

- **High likelihood** for chains deployed before the config_buffer system was introduced to genesis
- **Low likelihood** for newly deployed chains that include config_buffer initialization in genesis
- The issue will manifest on **every** governance proposal attempting to update OIDC providers on affected chains

The vulnerability is deterministic once triggered - there is no probabilistic element. Any governance proposal to modify OIDC providers will abort on affected chains until the underlying issue is fixed.

## Recommendation

**Immediate Fix**: Add defensive initialization check in the config buffer operations or in the jwks functions:

```move
public fun upsert_oidc_provider_for_next_epoch(fx: &signer, name: vector<u8>, config_url: vector<u8>): Option<vector<u8>> acquires SupportedOIDCProviders {
    system_addresses::assert_aptos_framework(fx);
    
    // Initialize config_buffer if not already initialized
    if (!exists<config_buffer::PendingConfigs>(@aptos_framework)) {
        config_buffer::initialize(fx);
    };
    
    let provider_set = if (config_buffer::does_exist<SupportedOIDCProviders>()) {
        config_buffer::extract_v2<SupportedOIDCProviders>()
    } else {
        *borrow_global<SupportedOIDCProviders>(@aptos_framework)
    };
    
    let old_config_url = remove_oidc_provider_internal(&mut provider_set, name);
    vector::push_back(&mut provider_set.providers, OIDCProvider { name, config_url });
    config_buffer::upsert(provider_set);
    old_config_url
}
```

**Alternative**: Modify `config_buffer::upsert()` to auto-initialize:

```move
public(friend) fun upsert<T: drop + store>(config: T) acquires PendingConfigs {
    if (!exists<PendingConfigs>(@aptos_framework)) {
        // Emergency initialization - should not normally happen
        move_to(
            &create_signer(@aptos_framework), 
            PendingConfigs { configs: simple_map::new() }
        );
    };
    let configs = borrow_global_mut<PendingConfigs>(@aptos_framework);
    let key = type_info::type_name<T>();
    let value = any::pack(config);
    simple_map::upsert(&mut configs.configs, key, value);
}
```

**Migration Path**: For existing chains, run a governance proposal to call `config_buffer::initialize()` before attempting to update any configs using the `_for_next_epoch` pattern.

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework)]
#[expected_failure(abort_code = 0x60001, location = aptos_framework::config_buffer)]
fun test_oidc_update_fails_without_config_buffer_init(aptos_framework: &signer) {
    use aptos_framework::jwks;
    use aptos_framework::account::create_account_for_test;
    use std::features;
    
    // Initialize framework WITHOUT config_buffer
    create_account_for_test(@aptos_framework);
    features::change_feature_flags_for_testing(aptos_framework, vector[], vector[]);
    jwks::initialize(aptos_framework);
    
    // Attempt to upsert OIDC provider - this should ABORT because PendingConfigs doesn't exist
    jwks::upsert_oidc_provider_for_next_epoch(
        aptos_framework,
        b"https://accounts.google.com",
        b"https://accounts.google.com/.well-known/openid-configuration"
    );
    
    // Test expects abort with RESOURCE_DOES_NOT_EXIST (0x60001) from config_buffer
}

#[test(aptos_framework = @aptos_framework)]
fun test_oidc_update_succeeds_with_config_buffer_init(aptos_framework: &signer) {
    use aptos_framework::jwks;
    use aptos_framework::config_buffer;
    use aptos_framework::account::create_account_for_test;
    use std::features;
    
    // Initialize framework WITH config_buffer
    create_account_for_test(@aptos_framework);
    features::change_feature_flags_for_testing(aptos_framework, vector[], vector[]);
    config_buffer::initialize(aptos_framework);  // THIS IS THE CRITICAL STEP
    jwks::initialize(aptos_framework);
    
    // Now upsert should succeed
    jwks::upsert_oidc_provider_for_next_epoch(
        aptos_framework,
        b"https://accounts.google.com",
        b"https://accounts.google.com/.well-known/openid-configuration"
    );
    
    // Verify it was buffered correctly
    assert!(config_buffer::does_exist<jwks::SupportedOIDCProviders>(), 1);
}
```

**Notes:**

This vulnerability affects not just OIDC provider updates, but ALL on-chain configs using the `config_buffer` pattern (consensus_config, execution_config, gas_schedule, randomness_config, etc.) on chains where `PendingConfigs` was not properly initialized. The fix should be applied systematically across all `set_for_next_epoch()` implementations or at the config_buffer module level to prevent similar issues.

### Citations

**File:** aptos-move/aptos-release-builder/src/components/oidc_providers.rs (L50-81)
```rust
fn write_op(writer: &CodeWriter, signer_arg: &str, op: &OidcProviderOp) {
    match op {
        OidcProviderOp::Upsert { issuer, config_url } => {
            emitln!(
                writer,
                "jwks::upsert_oidc_provider_for_next_epoch({}, b\"{}\", b\"{}\");",
                signer_arg,
                issuer,
                config_url
            );
        },
        OidcProviderOp::Remove {
            issuer,
            keep_observed_jwks,
        } => {
            emitln!(
                writer,
                "jwks::remove_oidc_provider_for_next_epoch({}, b\"{}\");",
                signer_arg,
                issuer
            );
            if !keep_observed_jwks {
                emitln!(
                    writer,
                    "jwks::remove_issuer_from_observed_jwks({}, b\"{}\");",
                    signer_arg,
                    issuer
                );
            }
        },
    }
}
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L317-330)
```text
    public fun upsert_oidc_provider_for_next_epoch(fx: &signer, name: vector<u8>, config_url: vector<u8>): Option<vector<u8>> acquires SupportedOIDCProviders {
        system_addresses::assert_aptos_framework(fx);

        let provider_set = if (config_buffer::does_exist<SupportedOIDCProviders>()) {
            config_buffer::extract_v2<SupportedOIDCProviders>()
        } else {
            *borrow_global<SupportedOIDCProviders>(@aptos_framework)
        };

        let old_config_url = remove_oidc_provider_internal(&mut provider_set, name);
        vector::push_back(&mut provider_set.providers, OIDCProvider { name, config_url });
        config_buffer::upsert(provider_set);
        old_config_url
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/config_buffer.move (L65-70)
```text
    public(friend) fun upsert<T: drop + store>(config: T) acquires PendingConfigs {
        let configs = borrow_global_mut<PendingConfigs>(@aptos_framework);
        let key = type_info::type_name<T>();
        let value = any::pack(config);
        simple_map::upsert(&mut configs.configs, key, value);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/config_buffer.spec.move (L21-23)
```text
    spec upsert<T: drop + store>(config: T) {
        aborts_if !exists<PendingConfigs>(@aptos_framework);
    }
```
