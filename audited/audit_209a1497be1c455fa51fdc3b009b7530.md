# Audit Report

## Title
TOCTOU Race Condition in CLI Key Retrieval Causing Transaction Signature Inconsistencies

## Summary
The `get_key_and_address()` function in the Aptos CLI lacks caching, causing it to read the configuration file from disk on every invocation. This creates Time-of-Check to Time-of-Use (TOCTOU) vulnerabilities where the configuration file can be modified between multiple calls during transaction submission, potentially causing transactions to be signed with mismatched keys and addresses.

## Finding Description
The vulnerability exists in the transaction submission flow where cryptographic material (private keys and addresses) is retrieved from the user's configuration file multiple times without caching. [1](#0-0) 

This function delegates to `extract_private_key_and_address()` which calls `CliConfig::load_profile()`: [2](#0-1) 

The profile loading function reads from the filesystem on every call: [3](#0-2) [4](#0-3) 

**The TOCTOU vulnerability manifests in `submit_transaction()`** where key material is retrieved twice:

1. First retrieval at line 1943: `get_public_key_and_address()` - reads config file for public key and sender address
2. Second retrieval at line 2053: `get_key_and_address()` - reads config file again for private key [5](#0-4) [6](#0-5) 

Between these two filesystem reads (spanning ~110 lines of code including async operations for gas estimation and simulation), the configuration file can be modified, causing:
- Address retrieved in first call to differ from the address associated with the key in the second call
- Sequence number fetched for address A but transaction signed with key B
- Transaction authentication failure on-chain

**Attack Scenario:**
1. User initiates transaction (e.g., stake operation): `aptos stake add-stake --amount 1000`
2. CLI reads config file, retrieves address A (line 1943)
3. Attacker/script modifies `.aptos/config.yaml` replacing private_key with a different key
4. CLI performs gas estimation and simulation (lines 1948-2041)
5. CLI reads config file again, retrieves private key B (line 2053)
6. Transaction created with sender=address A, but signed with key B
7. On-chain validation rejects transaction due to signature mismatch

## Impact Explanation
This vulnerability is classified as **Low Severity**, not Medium, based on the Aptos Bug Bounty criteria:

**Why NOT Medium Severity:**
- Does NOT cause "limited funds loss" - transactions simply fail validation
- Does NOT cause "state inconsistencies requiring intervention" - blockchain state is unaffected
- No funds can be stolen or misdirected
- Blockchain's transaction validation (signature verification in prologue) prevents any unauthorized operations

**Actual Impact (Low Severity):**
- **Transaction Denial of Service**: User's legitimate transactions fail, requiring retries
- **User Confusion**: Cryptic authentication errors without clear indication of config file modification
- **Operational Reliability**: Reduces reliability of CLI tool in environments with concurrent config modifications

**Why Blockchain Security is NOT Compromised:**
The blockchain's transaction validation invariants remain intact:
- Signature verification in transaction prologue ensures only valid signatures are accepted
- Sequence number checks prevent replay attacks
- Authentication key validation prevents unauthorized account access [7](#0-6) 

Even if keys mismatch, the blockchain will reject the transaction, protecting user funds.

## Likelihood Explanation
**Likelihood: Low to Medium**

**Required Conditions:**
1. User running Aptos CLI command that submits transactions
2. Concurrent modification of `.aptos/config.yaml` during the ~100ms-1s window between reads
3. Filesystem access by attacker or accidental modification by user/script

**Exploitation Complexity:**
- **Local Attack**: Requires filesystem access to victim's machine (malware, compromised script)
- **Race Window**: ~100-1000ms between reads (network calls for gas estimation), feasible for exploitation
- **Detection**: Hard to detect as failed transactions appear as normal authentication failures

**Realistic Scenarios:**
- User has malicious script/malware with filesystem access
- User manually edits config during long-running transaction
- Automated backup/sync tools modifying config during CLI execution
- Multiple CLI instances running concurrently modifying shared config

## Recommendation
Implement caching of cryptographic material within the `TxnOptions` structure to ensure consistency across the transaction lifecycle:

```rust
pub struct TxnOptions {
    // ... existing fields ...
    
    // Add cached fields
    #[clap(skip)]
    cached_key_and_address: Option<(Ed25519PrivateKey, AccountAddress)>,
}

impl TxnOptions {
    /// Retrieves the private key and the associated address with caching
    pub fn get_key_and_address(&mut self) -> CliTypedResult<(Ed25519PrivateKey, AccountAddress)> {
        if let Some(cached) = &self.cached_key_and_address {
            return Ok(cached.clone());
        }
        
        let result = self.private_key_options.extract_private_key_and_address(
            self.encoding_options.encoding,
            &self.profile_options,
            self.sender_account,
        )?;
        
        self.cached_key_and_address = Some(result.clone());
        Ok(result)
    }
    
    /// Clear cache when starting new command
    pub fn clear_cache(&mut self) {
        self.cached_key_and_address = None;
    }
}
```

**Alternative: Read-once pattern:**
Refactor `submit_transaction()` to read config once at the beginning and pass key material as parameters throughout the function.

## Proof of Concept
```rust
// PoC: Demonstrate TOCTOU by simulating concurrent config modification
// File: test_toctou.rs

use std::fs;
use std::thread;
use std::time::Duration;

#[test]
fn test_toctou_config_modification() {
    // Setup: Create initial config with key A
    let config_path = "/tmp/.aptos_test/config.yaml";
    let initial_config = r#"
profiles:
  default:
    private_key: "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
    account: "0xabcd1234"
"#;
    fs::write(config_path, initial_config).unwrap();
    
    // Thread 1: Simulate CLI transaction submission
    let handle = thread::spawn(|| {
        let opts = TxnOptions::parse_from(vec!["cmd", "--profile", "default"]);
        
        // First read - gets address and public key
        let (pub_key1, addr1) = opts.get_public_key_and_address().unwrap();
        println!("First read: addr={}", addr1);
        
        // Simulate gas estimation delay
        thread::sleep(Duration::from_millis(100));
        
        // Second read - gets private key (potentially different now!)
        let (priv_key2, addr2) = opts.get_key_and_address().unwrap();
        println!("Second read: addr={}", addr2);
        
        // Check if addresses match
        assert_eq!(addr1, addr2, "TOCTOU detected! Addresses don't match!");
    });
    
    // Thread 2: Modify config during execution (simulating attacker)
    thread::sleep(Duration::from_millis(50));
    let modified_config = r#"
profiles:
  default:
    private_key: "0xfedcba0987654321fedcba0987654321fedcba0987654321fedcba0987654321"
    account: "0x9876fedc"
"#;
    fs::write(config_path, modified_config).unwrap();
    
    // This will panic with "TOCTOU detected!" if addresses differ
    handle.join().unwrap();
}
```

**Expected Result:** Test fails with TOCTOU detection message, demonstrating that addresses retrieved from two separate config reads can differ within the same transaction flow.

---

## Notes
While this is a real TOCTOU vulnerability in the implementation, its severity is **Low** rather than Medium because:

1. **No blockchain invariants are violated** - the blockchain's own security mechanisms (signature verification, sequence number validation) prevent any unauthorized operations
2. **No funds loss is possible** - transactions with mismatched signatures are rejected by on-chain validation
3. **Impact is limited to DoS** - only affects individual user's transaction reliability, not network-wide security
4. **Requires local filesystem access** - not remotely exploitable without prior compromise

The TODO comment at line 117 correctly identifies this as an implementation issue that should be fixed for reliability and user experience, but it does not constitute a security vulnerability meeting the Aptos Bug Bounty's Medium severity threshold.

### Citations

**File:** crates/aptos/src/common/transactions.rs (L116-124)
```rust
    /// Retrieves the private key and the associated address
    /// TODO: Cache this information
    pub fn get_key_and_address(&self) -> CliTypedResult<(Ed25519PrivateKey, AccountAddress)> {
        self.private_key_options.extract_private_key_and_address(
            self.encoding_options.encoding,
            &self.profile_options,
            self.sender_account,
        )
    }
```

**File:** crates/aptos/src/common/types.rs (L370-391)
```rust
    pub fn load(mode: ConfigSearchMode) -> CliTypedResult<Self> {
        let folder = Self::aptos_folder(mode)?;

        let config_file = folder.join(CONFIG_FILE);
        let old_config_file = folder.join(LEGACY_CONFIG_FILE);
        if config_file.exists() {
            from_yaml(
                &String::from_utf8(read_from_file(config_file.as_path())?)
                    .map_err(CliError::from)?,
            )
        } else if old_config_file.exists() {
            from_yaml(
                &String::from_utf8(read_from_file(old_config_file.as_path())?)
                    .map_err(CliError::from)?,
            )
        } else {
            Err(CliError::ConfigNotFoundError(format!(
                "{}",
                config_file.display()
            )))
        }
    }
```

**File:** crates/aptos/src/common/types.rs (L915-952)
```rust
    pub fn extract_private_key_and_address(
        &self,
        encoding: EncodingType,
        profile: &ProfileOptions,
        maybe_address: Option<AccountAddress>,
    ) -> CliTypedResult<(Ed25519PrivateKey, AccountAddress)> {
        // Order of operations
        // 1. CLI inputs
        // 2. Profile
        // 3. Derived
        if let Some(key) = self.extract_private_key_cli(encoding)? {
            // If we use the CLI inputs, then we should derive or use the address from the input
            if let Some(address) = maybe_address {
                Ok((key, address))
            } else {
                let address = account_address_from_public_key(&key.public_key());
                Ok((key, address))
            }
        } else if let Some((Some(key), maybe_config_address)) = CliConfig::load_profile(
            profile.profile_name(),
            ConfigSearchMode::CurrentDirAndParents,
        )?
        .map(|p| (p.private_key, p.account))
        {
            match (maybe_address, maybe_config_address) {
                (Some(address), _) => Ok((key, address)),
                (_, Some(address)) => Ok((key, address)),
                (None, None) => {
                    let address = account_address_from_public_key(&key.public_key());
                    Ok((key, address))
                },
            }
        } else {
            Err(CliError::CommandArgumentError(
                "One of ['--private-key', '--private-key-file'] must be used".to_string(),
            ))
        }
    }
```

**File:** crates/aptos/src/common/types.rs (L1938-1960)
```rust
    pub async fn submit_transaction(
        &self,
        payload: TransactionPayload,
    ) -> CliTypedResult<Transaction> {
        let client = self.rest_client()?;
        let (sender_public_key, sender_address) = self.get_public_key_and_address()?;

        // Ask to confirm price if the gas unit price is estimated above the lowest value when
        // it is automatically estimated
        let ask_to_confirm_price;
        let gas_unit_price = if let Some(gas_unit_price) = self.gas_options.gas_unit_price {
            ask_to_confirm_price = false;
            gas_unit_price
        } else {
            let gas_unit_price = client.estimate_gas_price().await?.into_inner().gas_estimate;

            ask_to_confirm_price = true;
            gas_unit_price
        };

        // Get sequence number for account
        let (account, state) = get_account_with_state(&client, sender_address).await?;
        let sequence_number = account.sequence_number;
```

**File:** crates/aptos/src/common/types.rs (L2050-2062)
```rust
        // Sign it with the appropriate signer
        let transaction = match self.get_transaction_account_type() {
            Ok(AccountType::Local) => {
                let (private_key, _) = self.get_key_and_address()?;
                let sender_account =
                    &mut LocalAccount::new(sender_address, private_key, sequence_number);
                let mut txn_builder = transaction_factory.payload(payload);
                if self.replay_protection_type == ReplayProtectionType::Nonce {
                    let mut rng = rand::thread_rng();
                    txn_builder = txn_builder.upgrade_payload_with_rng(&mut rng, true, true);
                };
                sender_account.sign_with_transaction_builder(txn_builder)
            },
```

**File:** crates/aptos/src/common/utils.rs (L213-216)
```rust
pub fn read_from_file(path: &Path) -> CliTypedResult<Vec<u8>> {
    std::fs::read(path)
        .map_err(|e| CliError::UnableToReadFile(format!("{}", path.display()), e.to_string()))
}
```
