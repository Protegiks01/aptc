# Audit Report

## Title
Unauthenticated Network Topology Disclosure via GetNetworkInformation Enables Eclipse Attack Reconnaissance

## Summary
The `GetNetworkInformation` RPC endpoint in the peer monitoring service is exposed on all networks including public networks without any access control. Any peer can query this endpoint to obtain complete network topology information including all connected peers (with their PeerNetworkIds, NetworkAddresses, PeerIds, and roles) and the node's distance from validators. This information leak enables attackers to map the network topology, identify isolated or poorly-connected nodes, and launch targeted eclipse attacks.

## Finding Description

The peer monitoring service registers the `GetNetworkInformation` RPC handler on **all networks** including public networks where unauthenticated peers can connect. [1](#0-0) 

The handler processes requests without any authentication or authorization checks: [2](#0-1) 

The response reveals comprehensive network topology information: [3](#0-2) 

**Attack Scenario:**

1. **Reconnaissance Phase:** An attacker connects to public fullnodes (PFNs) on the public network. Public networks do not require mutual authentication, allowing any peer to connect up to the `max_inbound_connections` limit (default 100). [4](#0-3) 

2. **Topology Mapping:** The attacker sends `GetNetworkInformation` requests to multiple nodes across the network. Each response contains:
   - `connected_peers`: A complete BTreeMap of all peers the target node is connected to
   - `distance_from_validators`: The network distance from the validator set (0 for validators, 1 for VFNs, higher for PFNs)

3. **Vulnerability Identification:** By aggregating responses, the attacker can:
   - Identify nodes with few connections (vulnerable to eclipse attacks)
   - Identify nodes with high `distance_from_validators` (poorly connected to the core network)
   - Map the complete network graph including peer relationships
   - Identify specific PeerIds and NetworkAddresses for targeted attacks

4. **Eclipse Attack Execution:** Armed with this intelligence, the attacker can:
   - Target isolated nodes by establishing multiple connections from different IP addresses (Sybil attack)
   - Gradually become the dominant or sole connection source for the victim node
   - Feed the eclipsed node false blockchain information
   - Cause double-spending vulnerabilities for the eclipsed node
   - Partition the network by eclipsing critical bridge nodes

The connection limit enforcement only applies per-node and doesn't prevent distributed reconnaissance: [5](#0-4) 

## Impact Explanation

This vulnerability qualifies as **HIGH severity** per Aptos bug bounty criteria for the following reasons:

1. **Enables Eclipse Attacks:** Eclipse attacks can lead to:
   - Validator node slowdowns if VFNs serving validators are eclipsed
   - Consensus view manipulation for eclipsed nodes
   - Double-spending attacks against eclipsed nodes
   - Network partition if critical bridge nodes are targeted

2. **Significant Protocol Violation:** The ability to map network topology and identify vulnerable nodes undermines the security assumption that the network is sufficiently decentralized and resistant to targeted attacks.

3. **No Authentication Required:** Any peer can exploit this on public networks without privileged access.

4. **Public Fullnodes Most Vulnerable:** PFNs lack trusted peer sets and rely on dynamic discovery, making them particularly susceptible to eclipse attacks once identified through this information leak.

While not reaching CRITICAL severity (as it doesn't directly cause consensus violations or fund loss), it enables attacks that could lead to such outcomes and represents a significant degradation of network security guarantees.

## Likelihood Explanation

**Likelihood: HIGH**

1. **Trivial to Exploit:** The attack requires only:
   - Ability to connect to public network nodes (no authentication required)
   - Sending standard RPC requests
   - Basic network scanning capabilities

2. **Scalable Reconnaissance:** An attacker can:
   - Connect to multiple nodes simultaneously (up to 100 per node)
   - Use multiple IP addresses to bypass per-node connection limits
   - Automate the entire reconnaissance process
   - Build a comprehensive network map in minutes to hours

3. **Actionable Intelligence:** The disclosed information is immediately useful for:
   - Identifying high-value targets (well-connected nodes serving many peers)
   - Finding isolated nodes (few connections, high distance from validators)
   - Planning targeted eclipse attacks

4. **Economic Incentive:** Successfully eclipsing nodes can enable:
   - Double-spending attacks
   - Front-running opportunities
   - Network disruption for competitive advantage

## Recommendation

Implement access control and information limiting for the `GetNetworkInformation` endpoint:

**Option 1: Remove from Public Networks (Recommended)**
Only register the peer monitoring service on validator and VFN networks where mutual authentication is enforced. Remove it from public networks entirely.

**Option 2: Restrict Information Disclosure**
If the service must remain on public networks, significantly limit the information returned:
- Do not return the complete `connected_peers` list to unauthenticated peers
- Return only aggregate statistics (e.g., total connection count, average distance)
- Remove specific peer identifiers (PeerIds, NetworkAddresses) from responses
- Add role-based access control to return full information only to authenticated trusted peers

**Option 3: Rate Limiting and Throttling**
Implement strict per-peer rate limiting specifically for `GetNetworkInformation` requests from unknown peers to prevent rapid network scanning.

**Suggested Code Fix (Option 1):**

In `aptos-node/src/network.rs`, conditionally register the peer monitoring service:

```rust
// Only register peer monitoring service on authenticated networks
if network_id.is_validator_network() || network_id.is_vfn_network() {
    let peer_monitoring_service_network_handle = register_client_and_service_with_network(
        &mut network_builder,
        network_id,
        &network_config,
        peer_monitoring_network_configuration(node_config),
        true,
    );
    peer_monitoring_service_network_handles.push(peer_monitoring_service_network_handle);
}
```

## Proof of Concept

**Rust Reconnaissance Script:**

```rust
use aptos_network::application::interface::NetworkClient;
use aptos_peer_monitoring_service_types::{
    request::PeerMonitoringServiceRequest,
    response::PeerMonitoringServiceResponse,
};
use std::collections::HashMap;

async fn reconnaissance_scan(target_addresses: Vec<String>) -> HashMap<String, NetworkTopology> {
    let mut topology_map = HashMap::new();
    
    for address in target_addresses {
        // Connect to target node on public network
        let network_client = connect_to_peer(&address).await;
        
        // Send GetNetworkInformation request
        let request = PeerMonitoringServiceRequest::GetNetworkInformation;
        let response = network_client.send_rpc_request(request).await.unwrap();
        
        // Extract sensitive topology information
        if let PeerMonitoringServiceResponse::NetworkInformation(info) = response {
            let topology = NetworkTopology {
                num_connections: info.connected_peers.len(),
                distance_from_validators: info.distance_from_validators,
                connected_peer_ids: info.connected_peers.keys().cloned().collect(),
                connected_addresses: info.connected_peers
                    .values()
                    .map(|m| m.network_address.clone())
                    .collect(),
            };
            
            topology_map.insert(address, topology);
            
            // Identify vulnerable targets
            if topology.num_connections < 5 || topology.distance_from_validators > 3 {
                println!("VULNERABLE TARGET: {}", address);
                println!("  Connections: {}", topology.num_connections);
                println!("  Distance: {}", topology.distance_from_validators);
            }
        }
    }
    
    topology_map
}

// Attack execution: Identify and target isolated nodes
async fn execute_eclipse_attack(vulnerable_node: String) {
    // Use the topology information to:
    // 1. Establish multiple connections from different IPs
    // 2. Become the dominant connection source
    // 3. Feed false blockchain information
    println!("Targeting isolated node: {}", vulnerable_node);
}
```

**Expected Output:**
```
VULNERABLE TARGET: /ip4/192.168.1.100/tcp/6180
  Connections: 3
  Distance: 5
  Connected Peers: [PeerId(0x...), PeerId(0x...), PeerId(0x...)]
```

This PoC demonstrates how an attacker can systematically scan the network to identify vulnerable nodes for targeted eclipse attacks, breaking the network's security invariants around decentralization and attack resistance.

## Notes

- The vulnerability affects all nodes that enable public network connections (PFNs and VFNs with public endpoints)
- While connection limits exist (default 100 inbound connections for unknown peers), they don't prevent the information leak or distributed reconnaissance
- The `distance_from_validators` metric is particularly valuable for attackers as it indicates how isolated a node is from the trusted validator set [6](#0-5) 
- Client-side validation of responses exists but doesn't prevent the server from leaking information [7](#0-6)

### Citations

**File:** aptos-node/src/network.rs (L370-378)
```rust
        // Register the peer monitoring service (both client and server) with the network
        let peer_monitoring_service_network_handle = register_client_and_service_with_network(
            &mut network_builder,
            network_id,
            &network_config,
            peer_monitoring_network_configuration(node_config),
            true,
        );
        peer_monitoring_service_network_handles.push(peer_monitoring_service_network_handle);
```

**File:** peer-monitoring-service/server/src/lib.rs (L217-248)
```rust
    fn get_network_information(&self) -> Result<PeerMonitoringServiceResponse, Error> {
        // Get the connected peers
        let connected_peers_and_metadata =
            self.peers_and_metadata.get_connected_peers_and_metadata()?;
        let connected_peers = connected_peers_and_metadata
            .into_iter()
            .map(|(peer, metadata)| {
                let connection_metadata = metadata.get_connection_metadata();
                (
                    peer,
                    ConnectionMetadata::new(
                        connection_metadata.addr,
                        connection_metadata.remote_peer_id,
                        connection_metadata.role,
                    ),
                )
            })
            .collect();

        // Get the distance from the validators
        let distance_from_validators =
            get_distance_from_validators(&self.base_config, self.peers_and_metadata.clone());

        // Create and return the response
        let network_information_response = NetworkInformationResponse {
            connected_peers,
            distance_from_validators,
        };
        Ok(PeerMonitoringServiceResponse::NetworkInformation(
            network_information_response,
        ))
    }
```

**File:** peer-monitoring-service/server/src/lib.rs (L296-340)
```rust
/// Returns the distance from the validators using the given base config
/// and the peers and metadata information.
fn get_distance_from_validators(
    base_config: &BaseConfig,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> u64 {
    // Get the connected peers and metadata
    let connected_peers_and_metadata = match peers_and_metadata.get_connected_peers_and_metadata() {
        Ok(connected_peers_and_metadata) => connected_peers_and_metadata,
        Err(error) => {
            warn!(LogSchema::new(LogEntry::PeerMonitoringServiceError).error(&error.into()));
            return MAX_DISTANCE_FROM_VALIDATORS;
        },
    };

    // If we're a validator and we have active validator peers, we're in the validator set.
    // TODO: figure out if we need to deal with validator set forks here.
    if base_config.role.is_validator() {
        for peer_metadata in connected_peers_and_metadata.values() {
            if peer_metadata.get_connection_metadata().role.is_validator() {
                return 0;
            }
        }
    }

    // Otherwise, go through our peers, find the min, and return a distance relative to the min
    let mut min_peer_distance_from_validators = MAX_DISTANCE_FROM_VALIDATORS;
    for peer_metadata in connected_peers_and_metadata.values() {
        if let Some(ref latest_network_info_response) = peer_metadata
            .get_peer_monitoring_metadata()
            .latest_network_info_response
        {
            min_peer_distance_from_validators = min(
                min_peer_distance_from_validators,
                latest_network_info_response.distance_from_validators,
            );
        }
    }

    // We're one hop away from the peer
    min(
        MAX_DISTANCE_FROM_VALIDATORS,
        min_peer_distance_from_validators + 1,
    )
}
```

**File:** peer-monitoring-service/types/src/response.rs (L50-75)
```rust
/// A response for the network information request
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct NetworkInformationResponse {
    pub connected_peers: BTreeMap<PeerNetworkId, ConnectionMetadata>, // Connected peers
    pub distance_from_validators: u64, // The distance of the peer from the validator set
}

// Display formatting provides a high-level summary of the response
impl Display for NetworkInformationResponse {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{{ num_connected_peers: {:?}, distance_from_validators: {:?} }}",
            self.connected_peers.len(),
            self.distance_from_validators,
        )
    }
}

/// Simple connection metadata associated with each peer
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct ConnectionMetadata {
    pub network_address: NetworkAddress,
    pub peer_id: PeerId,
    pub peer_role: PeerRole,
}
```

**File:** config/src/config/network_config.rs (L44-44)
```rust
pub const MAX_INBOUND_CONNECTIONS: usize = 100;
```

**File:** network/framework/src/peer_manager/mod.rs (L351-389)
```rust
        // Verify that we have not reached the max connection limit for unknown inbound peers
        if conn.metadata.origin == ConnectionOrigin::Inbound {
            // Everything below here is meant for unknown peers only. The role comes from
            // the Noise handshake and if it's not `Unknown` then it is trusted.
            if conn.metadata.role == PeerRole::Unknown {
                // TODO: Keep track of somewhere else to not take this hit in case of DDoS
                // Count unknown inbound connections
                let unknown_inbound_conns = self
                    .active_peers
                    .iter()
                    .filter(|(peer_id, (metadata, _))| {
                        metadata.origin == ConnectionOrigin::Inbound
                            && trusted_peers
                                .get(peer_id)
                                .is_none_or(|peer| peer.role == PeerRole::Unknown)
                    })
                    .count();

                // Reject excessive inbound connections made by unknown peers
                // We control outbound connections with Connectivity manager before we even send them
                // and we must allow connections that already exist to pass through tie breaking.
                if !self
                    .active_peers
                    .contains_key(&conn.metadata.remote_peer_id)
                    && unknown_inbound_conns + 1 > self.inbound_connection_limit
                {
                    info!(
                        NetworkSchema::new(&self.network_context)
                            .connection_metadata_with_address(&conn.metadata),
                        "{} Connection rejected due to connection limit: {}",
                        self.network_context,
                        conn.metadata
                    );
                    counters::connections_rejected(&self.network_context, conn.metadata.origin)
                        .inc();
                    self.disconnect(conn);
                    return;
                }
            }
```

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L116-154)
```rust
        // Sanity check the response depth from the peer metadata
        let network_id = peer_network_id.network_id();
        let is_valid_depth = match network_info_response.distance_from_validators {
            0 => {
                // Verify the peer is a validator and has the correct network id
                let peer_is_validator = peer_metadata.get_connection_metadata().role.is_validator();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_validator_network(), // We're a validator
                    RoleType::FullNode => network_id.is_vfn_network(),        // We're a VFN
                };
                peer_is_validator && peer_has_correct_network
            },
            1 => {
                // Verify the peer is a VFN and has the correct network id
                let peer_is_vfn = peer_metadata.get_connection_metadata().role.is_vfn();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_vfn_network(), // We're a validator
                    RoleType::FullNode => network_id.is_public_network(), // We're a VFN or PFN
                };
                peer_is_vfn && peer_has_correct_network
            },
            distance_from_validators => {
                // The distance must be less than or equal to the max
                distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS
            },
        };

        // If the depth did not pass our sanity checks, handle a failure
        if !is_valid_depth {
            warn!(LogSchema::new(LogEntry::NetworkInfoRequest)
                .event(LogEvent::InvalidResponse)
                .peer(peer_network_id)
                .message(&format!(
                    "Peer returned invalid depth from validators: {}",
                    network_info_response.distance_from_validators
                )));
            self.handle_request_failure();
            return;
        }
```
