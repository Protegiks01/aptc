# Audit Report

## Title
Missing Validation in EventByVersionSchema Queries Allows Silent Corruption to Return Incorrect Events

## Summary
EventByVersionSchema queries lack validation that returned event indices actually point to events with matching metadata. Unlike EventByKeySchema queries which validate sequence number correctness, EventByVersionSchema-based functions (`get_latest_sequence_number`, `lookup_event_before_or_at_version`, etc.) return event indices without verifying the actual event matches the expected EventKey and sequence number. This allows corrupted index data to silently return incorrect events, affecting critical operations including timestamp-based version lookups used in consensus-adjacent paths.

## Finding Description
The EventByVersionSchema uses a composite key structure `(EventKey, Version, SeqNum) -> Index` to enable efficient event lookups by version. [1](#0-0) 

This schema is populated during event indexing for both V1 and translated V2 events. [2](#0-1) [3](#0-2) 

Critical query functions using EventByVersionSchema include `get_latest_sequence_number` [4](#0-3)  and `lookup_event_before_or_at_version` [5](#0-4) . These functions return `(version, index, seq_num)` tuples based solely on the EventByVersionSchema key components, without validating that the event at `EventSchema[(version, index)]` actually matches the expected EventKey and sequence number.

In contrast, EventByKeySchema queries implement explicit validation. [6](#0-5)  This validation ensures that if EventByKeySchema points to the wrong event, an error is raised: "Index broken, expected seq:{}, actual:{}".

**How Corruption Propagates:**

If EventByVersionSchema becomes corrupted (wrong index value for a composite key) through:
1. Bugs in V2 event translation logic assigning incorrect sequence numbers
2. Reindexing operations with inconsistent state views
3. Database corruption from hardware/software failures

Then queries will silently return incorrect event indices. Critically, `get_latest_sequence_number` is used by `get_last_version_before_timestamp` [7](#0-6) , which performs timestamp-to-version mapping for block synchronization and consensus-adjacent operations.

The simulation code explicitly handles potential duplicate sequence numbers within transactions using a count_map adjustment mechanism [8](#0-7) , suggesting awareness that the translation layer can produce ambiguous sequence numbers requiring special handling.

## Impact Explanation
**High Severity** - This constitutes a significant protocol violation affecting API reliability and state consistency:

1. **API Reliability**: Corrupted EventByVersionSchema causes event queries to return incorrect events without error detection, breaking client applications that depend on accurate event data for state tracking, indexing, and transaction processing.

2. **Timestamp-Version Mapping**: The `get_last_version_before_timestamp` function relies on EventByVersionSchema queries. Incorrect sequence numbers could cause wrong version mappings, affecting state synchronization and block production timing.

3. **No Detection Mechanism**: Unlike EventByKeySchema (which validates), EventByVersionSchema queries have no validation layer. Corruption is silent until downstream systems detect inconsistencies, potentially after significant damage.

4. **State Consistency Violation**: Breaks the documented invariant that "State transitions must be atomic and verifiable" by allowing unverifiable, incorrect state reads.

This meets **High Severity** criteria: "API crashes" and "Significant protocol violations" per Aptos bug bounty guidelines.

## Likelihood Explanation
**Medium Likelihood** - While direct database corruption requires node-level access, several realistic scenarios enable corruption:

1. **V2 Translation Bugs**: Complex translation logic reading on-chain state could have edge cases producing duplicate or incorrect sequence numbers. The existence of special handling in simulation code suggests this is a known concern.

2. **Reindexing Inconsistencies**: When nodes reindex historical transactions, if state views differ (due to state sync, pruning, or fork scenarios), translated V2 events could produce different event keys/sequence numbers, overwriting EventByVersionSchema entries with inconsistent values.

3. **Race Conditions**: Although indexing uses sequential batch processing, complex interaction between caching (`event_sequence_number_cache`) and database reads could produce edge cases under specific timing conditions.

4. **Database-Level Corruption**: Hardware failures, OS bugs, or RocksDB issues affecting EventByVersionSchema specifically.

The lack of validation makes this exploitable once any corruption occurs, regardless of cause.

## Recommendation
Implement validation in all EventByVersionSchema query paths to match the protection level of EventByKeySchema queries:

```rust
// In event_store/mod.rs - get_latest_sequence_number
pub fn get_latest_sequence_number(
    &self,
    ledger_version: Version,
    event_key: &EventKey,
) -> Result<Option<u64>> {
    let mut iter = self.event_db.iter::<EventByVersionSchema>()?;
    iter.seek_for_prev(&(*event_key, ledger_version, u64::MAX));

    match iter.next().transpose()? {
        None => Ok(None),
        Some(((key, version, seq), idx)) => {
            if &key == event_key {
                // ADDED: Validate the event at this index actually matches
                if let Ok(event) = self.get_event_by_version_and_index(version, idx) {
                    if let ContractEvent::V1(v1) = &event {
                        ensure!(
                            v1.key() == event_key && v1.sequence_number() == seq,
                            "EventByVersionSchema index broken: expected key {:?} seq {}, actual key {:?} seq {}",
                            event_key, seq, v1.key(), v1.sequence_number()
                        );
                    }
                }
                Ok(Some(seq))
            } else {
                Ok(None)
            }
        }
    }
}
```

Apply similar validation to `lookup_event_before_or_at_version`, `lookup_event_at_or_after_version`, and `lookup_event_after_version`.

Additionally, consider adding consistency checks during EventByVersionSchema writes to detect corruption at insertion time rather than query time.

## Proof of Concept
```rust
// Rust test demonstrating the vulnerability
// File: storage/aptosdb/src/event_store/test.rs

#[test]
fn test_corrupted_event_by_version_schema() {
    use aptos_types::{contract_event::ContractEventV1, event::EventKey};
    use aptos_schemadb::SchemaBatch;
    
    let tmpdir = aptos_temppath::TempPath::new();
    let db = setup_event_db(&tmpdir);
    let event_store = EventStore::new(Arc::new(db));
    
    // Setup: Create a legitimate event at (version=100, index=5)
    let event_key = EventKey::random();
    let event = ContractEventV1::new(
        event_key,
        10, // sequence_number
        TypeTag::Bool,
        vec![1, 2, 3],
    ).unwrap();
    
    let mut batch = SchemaBatch::new();
    batch.put::<EventSchema>(&(100, 5), &ContractEvent::V1(event.clone())).unwrap();
    batch.put::<EventByVersionSchema>(
        &(event_key, 100, 10),
        &5_u64, // correct index
    ).unwrap();
    
    // Corruption: Insert EventByVersionSchema entry pointing to wrong index
    batch.put::<EventByVersionSchema>(
        &(event_key, 100, 10),
        &999_u64, // CORRUPTED: wrong index
    ).unwrap();
    
    event_store.event_db.write_schemas(batch).unwrap();
    
    // Query: get_latest_sequence_number returns seq 10 based on corrupted key
    let result = event_store.get_latest_sequence_number(100, &event_key).unwrap();
    assert_eq!(result, Some(10)); // Returns sequence number from key
    
    // But attempting to retrieve the actual event at index 999 fails
    // because no event exists there - demonstrating silent corruption
    let event_result = event_store.get_event_by_version_and_index(100, 999);
    assert!(event_result.is_err()); // Event not found at corrupted index
    
    // The corruption goes undetected by get_latest_sequence_number
    // which doesn't validate the returned index actually points to
    // an event with matching metadata
}
```

## Notes
This vulnerability represents a missing defensive programming pattern rather than an immediately exploitable attack vector. The core issue is that EventByVersionSchema queries trust their indexed data without verification, while EventByKeySchema queries implement proper validation. This asymmetry creates a silent failure mode where corrupted indices cause incorrect data to be returned without detection, potentially affecting critical blockchain operations including timestamp-based synchronization.

The existence of special duplicate-handling code in the simulation path strongly suggests the Aptos team recognized potential for sequence number collisions in V2 event translation, but the production indexing path lacks equivalent safeguards at the validation layer.

### Citations

**File:** storage/indexer_schemas/src/schema/event_by_version/mod.rs (L23-29)
```rust
define_pub_schema!(EventByVersionSchema, Key, Value, EVENT_BY_VERSION_CF_NAME);

type SeqNum = u64;
type Key = (EventKey, Version, SeqNum);

type Index = u64;
type Value = Index;
```

**File:** storage/indexer/src/db_indexer.rs (L441-446)
```rust
                        batch
                            .put::<EventByVersionSchema>(
                                &(*v1.key(), version, v1.sequence_number()),
                                &(idx as u64),
                            )
                            .expect("Failed to put events by version to a batch");
```

**File:** storage/indexer/src/db_indexer.rs (L470-475)
```rust
                                batch
                                    .put::<EventByVersionSchema>(
                                        &(key, version, sequence_number),
                                        &(idx as u64),
                                    )
                                    .expect("Failed to put events by version to a batch");
```

**File:** storage/aptosdb/src/event_store/mod.rs (L77-88)
```rust
    pub fn get_latest_sequence_number(
        &self,
        ledger_version: Version,
        event_key: &EventKey,
    ) -> Result<Option<u64>> {
        let mut iter = self.event_db.iter::<EventByVersionSchema>()?;
        iter.seek_for_prev(&(*event_key, ledger_version, u64::MAX));

        Ok(iter.next().transpose()?.and_then(
            |((key, _version, seq), _idx)| if &key == event_key { Some(seq) } else { None },
        ))
    }
```

**File:** storage/aptosdb/src/event_store/mod.rs (L163-187)
```rust
    pub fn lookup_event_before_or_at_version(
        &self,
        event_key: &EventKey,
        version: Version,
    ) -> Result<
        Option<(
            Version, // version
            u64,     // index
            u64,     // sequence number
        )>,
    > {
        let mut iter = self.event_db.iter::<EventByVersionSchema>()?;
        iter.seek_for_prev(&(*event_key, version, u64::MAX))?;

        match iter.next().transpose()? {
            None => Ok(None),
            Some(((key, ver, seq_num), idx)) => {
                if key == *event_key {
                    Ok(Some((ver, idx, seq_num)))
                } else {
                    Ok(None)
                }
            },
        }
    }
```

**File:** storage/aptosdb/src/event_store/mod.rs (L287-300)
```rust
    pub(crate) fn get_last_version_before_timestamp(
        &self,
        timestamp: u64,
        ledger_version: Version,
    ) -> Result<Version> {
        let event_key = new_block_event_key();
        let seq_at_or_after_ts = self.search_for_event_lower_bound(
            &event_key,
            |event| {
                let new_block_event: NewBlockEvent = event.try_into()?;
                Ok(new_block_event.proposed_time() < timestamp)
            },
            ledger_version,
        )?.ok_or_else(|| AptosDbError::NotFound(
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L1161-1166)
```rust
                ensure!(
                    seq == v0.sequence_number(),
                    "Index broken, expected seq:{}, actual:{}",
                    seq,
                    v0.sequence_number()
                );
```

**File:** api/src/context.rs (L1042-1059)
```rust
        let mut count_map: HashMap<EventKey, u64> = HashMap::new();
        for event in events.iter_mut() {
            if let ContractEvent::V2(v2) = event {
                let translated_event = self
                    .indexer_reader
                    .as_ref()
                    .ok_or(anyhow!("Internal indexer reader doesn't exist"))?
                    .translate_event_v2_to_v1(v2)?;
                if let Some(v1) = translated_event {
                    let count = count_map.get(v1.key()).unwrap_or(&0);
                    let v1_adjusted = ContractEventV1::new(
                        *v1.key(),
                        v1.sequence_number() + count,
                        v1.type_tag().clone(),
                        v1.event_data().to_vec(),
                    )?;
                    *event = ContractEvent::V1(v1_adjusted);
                    count_map.insert(*v1.key(), count + 1);
```
