# Audit Report

## Title
Aptos Debugger Truncate Command Lacks Signal Handler Protection Leading to Database Inconsistency on Interruption

## Summary
The `aptos-debugger` tool's Truncate command performs multi-step database modifications without SIGTERM/SIGINT signal handlers. If interrupted during execution, in-flight database operations are not properly rolled back, leaving the database in an inconsistent state that may require manual repair or prevent validator node startup.

## Finding Description

The `aptos-debugger` main entry point has no signal handlers installed for graceful shutdown: [1](#0-0) 

The Truncate command performs a multi-step database modification sequence that is not atomic: [2](#0-1) 

This sequence includes:
1. Writing `OverallCommitProgress` to metadata
2. Calling `StateStore::sync_commit_progress` which performs multiple separate database writes across ledger_db, state_kv_db, and state_merkle_db
3. Optionally calling `StateStore::catch_up_state_merkle_db`

The `sync_commit_progress` function itself makes multiple non-atomic write operations: [3](#0-2) 

Each `write_schemas` call is atomic within RocksDB, but the overall sequence across multiple databases is not. When SIGTERM/SIGINT is sent during execution:
- The Tokio runtime drops the async task without graceful cleanup
- Database writes may be partially completed
- Different database components (ledger, state_kv, state_merkle) may be at inconsistent versions

While `StateStore::new()` includes recovery logic via `sync_commit_progress`: [4](#0-3) 

This recovery has critical limitations:
- Only executes when the database is reopened
- Crashes if version difference exceeds MAX_COMMIT_PROGRESS_DIFFERENCE (1,000,000 versions): [5](#0-4) 

- May fail if RocksDB internal state is corrupted

## Impact Explanation

**Severity: High** per Aptos bug bounty criteria.

This vulnerability causes:
1. **State inconsistencies requiring intervention** (Medium/High severity category) - Different database components desynchronized
2. **Validator node startup failures** - If version difference exceeds 1M, node crashes on initialization with assertions in sync_commit_progress
3. **Manual database repair required** - In worst cases, operators must manually restore from backup or rebuild database

Impact on production:
- Validator operators using Truncate for database maintenance face corruption risk
- If multiple validators experience this simultaneously, network liveness degrades
- No automated recovery if crash assertions are triggered
- Potential data loss if truncation partially completed before interruption

## Likelihood Explanation

**Likelihood: High**

This is highly likely to occur because:
1. **Common trigger**: Users naturally press Ctrl-C to interrupt long-running operations
2. **Legitimate use case**: Operators use Truncate command for database maintenance and pruning
3. **Long execution time**: Truncating large version ranges takes significant time, increasing interruption probability
4. **No warnings**: Tool provides no indication that interruption is unsafe
5. **No protection mechanisms**: Zero signal handlers or graceful shutdown logic implemented

Any operator performing database maintenance with this tool is at risk.

## Recommendation

Implement signal handlers for graceful shutdown in the aptos-debugger main.rs:

```rust
use tokio::signal;
use tokio::sync::oneshot;

#[tokio::main]
async fn main() -> Result<()> {
    Logger::new().level(Level::Info).init();
    let _mp = MetricsPusher::start(vec![]);

    let (shutdown_tx, shutdown_rx) = oneshot::channel();
    
    // Spawn signal handler
    tokio::spawn(async move {
        let _ = signal::ctrl_c().await;
        eprintln!("\nReceived interrupt signal. Please wait for cleanup...");
        let _ = shutdown_tx.send(());
    });

    tokio::select! {
        result = Cmd::parse().run() => result,
        _ = shutdown_rx => {
            eprintln!("Operation interrupted. Database may be in inconsistent state.");
            eprintln!("Run the same command again or restart validator to recover.");
            Err(anyhow::anyhow!("Operation interrupted by user"))
        }
    }
}
```

Additionally, the Truncate command should:
1. Implement transactional semantics by writing a "truncation in progress" marker before starting
2. Clear the marker only after all operations complete successfully
3. Check for incomplete truncations on startup and complete or roll back

Alternative: Modify StateStore to handle partial truncations more robustly by making the entire operation idempotent and restartable.

## Proof of Concept

**Reproduction Steps:**

1. Set up an AptosDB with significant data (e.g., 100K+ versions)
2. Run the truncate command targeting a much earlier version:
   ```bash
   cargo run --bin aptos-debugger -- aptos-db debug truncate \
     --db-dir /path/to/db \
     --target-version 10000 \
     --opt-out-backup-checkpoint
   ```
3. After the command prints "Starting db truncation..." but before "Done!", send SIGINT (Ctrl-C)
4. Attempt to open the database with a validator node
5. Observe one of:
   - Crash with assertion failure in sync_commit_progress if version difference is large
   - Inconsistent state where ledger_db, state_kv_db, and state_merkle_db are at different versions
   - Failure to find valid state root requiring manual intervention

**Expected Result**: Database enters inconsistent state requiring manual repair or preventing node startup.

**Rust Test Framework** (pseudo-code for integration test):
```rust
#[tokio::test]
async fn test_truncate_interruption_safety() {
    let tmp_dir = TempPath::new();
    let db = setup_test_db_with_data(&tmp_dir, 100_000);
    drop(db);
    
    let handle = tokio::spawn(async move {
        // Run truncate command
        run_truncate_command(&tmp_dir, 10_000).await
    });
    
    // Simulate SIGINT after short delay
    tokio::time::sleep(Duration::from_millis(100)).await;
    handle.abort();
    
    // Try to reopen database
    let result = AptosDB::open(&tmp_dir, /* readonly */ false, ...);
    
    // Should either auto-recover or fail gracefully
    assert!(result.is_ok() || result.err().unwrap().to_string().contains("inconsistent"));
}
```

## Notes

This vulnerability specifically affects the **aptos-debugger** tool, not the core validator runtime. However, since the debugger operates on production validator databases, any corruption directly impacts validator availability and network health. The lack of signal handling violates the **State Consistency** invariant that "State transitions must be atomic and verifiable."

The issue is compounded by the fact that the Truncate command explicitly disables the crash protection in its call to `sync_commit_progress` (setting `crash_if_difference_is_too_large=false`), but the subsequent validator startup will have it enabled, creating an asymmetric failure mode.

### Citations

**File:** crates/aptos-debugger/src/main.rs (L14-19)
```rust
#[tokio::main]
async fn main() -> Result<()> {
    Logger::new().level(Level::Info).init();
    let _mp = MetricsPusher::start(vec![]);

    Cmd::parse().run().await
```

**File:** storage/aptosdb/src/db_debugger/truncate/mod.rs (L130-143)
```rust
        let mut batch = SchemaBatch::new();
        batch.put::<DbMetadataSchema>(
            &DbMetadataKey::OverallCommitProgress,
            &DbMetadataValue::Version(target_version),
        )?;
        ledger_db.metadata_db().write_schemas(batch)?;

        StateStore::sync_commit_progress(
            Arc::clone(&ledger_db),
            Arc::clone(&state_kv_db),
            Arc::clone(&state_merkle_db),
            /*crash_if_difference_is_too_large=*/ false,
        );
        println!("Done!");
```

**File:** storage/aptosdb/src/state_store/mod.rs (L107-107)
```rust
pub const MAX_COMMIT_PROGRESS_DIFFERENCE: u64 = 1_000_000;
```

**File:** storage/aptosdb/src/state_store/mod.rs (L353-359)
```rust
        if !hack_for_tests && !empty_buffered_state_for_restore {
            Self::sync_commit_progress(
                Arc::clone(&ledger_db),
                Arc::clone(&state_kv_db),
                Arc::clone(&state_merkle_db),
                /*crash_if_difference_is_too_large=*/ true,
            );
```

**File:** storage/aptosdb/src/state_store/mod.rs (L410-500)
```rust
    pub fn sync_commit_progress(
        ledger_db: Arc<LedgerDb>,
        state_kv_db: Arc<StateKvDb>,
        state_merkle_db: Arc<StateMerkleDb>,
        crash_if_difference_is_too_large: bool,
    ) {
        let ledger_metadata_db = ledger_db.metadata_db();
        if let Some(overall_commit_progress) = ledger_metadata_db
            .get_synced_version()
            .expect("DB read failed.")
        {
            info!(
                overall_commit_progress = overall_commit_progress,
                "Start syncing databases..."
            );
            let ledger_commit_progress = ledger_metadata_db
                .get_ledger_commit_progress()
                .expect("Failed to read ledger commit progress.");
            assert_ge!(ledger_commit_progress, overall_commit_progress);

            let state_kv_commit_progress = state_kv_db
                .metadata_db()
                .get::<DbMetadataSchema>(&DbMetadataKey::StateKvCommitProgress)
                .expect("Failed to read state K/V commit progress.")
                .expect("State K/V commit progress cannot be None.")
                .expect_version();
            assert_ge!(state_kv_commit_progress, overall_commit_progress);

            // LedgerCommitProgress was not guaranteed to commit after all ledger changes finish,
            // have to attempt truncating every column family.
            info!(
                ledger_commit_progress = ledger_commit_progress,
                "Attempt ledger truncation...",
            );
            let difference = ledger_commit_progress - overall_commit_progress;
            if crash_if_difference_is_too_large {
                assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
            }
            truncate_ledger_db(ledger_db.clone(), overall_commit_progress)
                .expect("Failed to truncate ledger db.");

            // State K/V commit progress isn't (can't be) written atomically with the data,
            // because there are shards, so we have to attempt truncation anyway.
            info!(
                state_kv_commit_progress = state_kv_commit_progress,
                "Start state KV truncation..."
            );
            let difference = state_kv_commit_progress - overall_commit_progress;
            if crash_if_difference_is_too_large {
                assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
            }
            truncate_state_kv_db(
                &state_kv_db,
                state_kv_commit_progress,
                overall_commit_progress,
                std::cmp::max(difference as usize, 1), /* batch_size */
            )
            .expect("Failed to truncate state K/V db.");

            let state_merkle_max_version = get_max_version_in_state_merkle_db(&state_merkle_db)
                .expect("Failed to get state merkle max version.")
                .expect("State merkle max version cannot be None.");
            if state_merkle_max_version > overall_commit_progress {
                let difference = state_merkle_max_version - overall_commit_progress;
                if crash_if_difference_is_too_large {
                    assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
                }
            }
            let state_merkle_target_version = find_tree_root_at_or_before(
                ledger_metadata_db,
                &state_merkle_db,
                overall_commit_progress,
            )
            .expect("DB read failed.")
            .unwrap_or_else(|| {
                panic!(
                    "Could not find a valid root before or at version {}, maybe it was pruned?",
                    overall_commit_progress
                )
            });
            if state_merkle_target_version < state_merkle_max_version {
                info!(
                    state_merkle_max_version = state_merkle_max_version,
                    target_version = state_merkle_target_version,
                    "Start state merkle truncation..."
                );
                truncate_state_merkle_db(&state_merkle_db, state_merkle_target_version)
                    .expect("Failed to truncate state merkle db.");
            }
        } else {
            info!("No overall commit progress was found!");
```
