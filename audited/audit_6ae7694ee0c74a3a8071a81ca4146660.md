# Audit Report

## Title
Stack Overflow in API ABI Parser Causes Denial of Service When Processing Modules with Deeply Nested Types

## Summary
The API layer's `try_parse_abi()` function can trigger an uncaught stack overflow when processing Move modules with deeply nested types. When `ENABLE_FUNCTION_VALUES` feature flag is disabled, the verifier permits unlimited type depth during module publishing. Later, when the API processes these modules in `try_access_path_into_write_set_changes()`, the recursive `new_move_type()` function causes a stack overflow that crashes the API server.

## Finding Description
The vulnerability exists in the interaction between module verification, storage, and API conversion:

**1. Verification Gap:**
The production verifier configuration conditionally sets type depth limits: [1](#0-0) 

When `ENABLE_FUNCTION_VALUES` is disabled, `max_type_depth` is `None`, allowing unlimited type nesting during module publishing.

**2. Vulnerable Code Path:**
When the API processes WriteSet changes containing module bytecode: [2](#0-1) 

The `try_parse_abi()` function deserializes and converts the module: [3](#0-2) 

**3. Unprotected Recursion:**
The critical issue is that `module.try_into()` calls the `From<CompiledModule> for MoveModule` conversion: [4](#0-3) 

This invokes `new_move_type()` which is **recursively defined without depth checking**: [5](#0-4) 

**4. Missing Panic Protection:**
While `CompiledModule::deserialize()` wraps deserialization in `catch_unwind()`: [6](#0-5) 

The `try_parse_abi()` function does NOT protect the subsequent `try_into()` call, so stack overflow panics propagate and crash the API server.

**Attack Scenario:**
1. When `ENABLE_FUNCTION_VALUES` feature is disabled, publish a module with deeply nested types (e.g., `Vector<Vector<Vector<...>>>` nested 1000+ levels)
2. Module passes verification since `max_type_depth = None`
3. Module is stored on-chain and can be executed
4. When API endpoint serves transaction data containing this module, `try_access_path_into_write_set_changes()` is called
5. `try_parse_abi()` deserializes successfully but crashes during recursive `new_move_type()` processing
6. Uncaught panic crashes the API server thread/process

## Impact Explanation
**High Severity** - API crashes meet the "API crashes" criterion under High Severity ($50,000 bounty).

This vulnerability causes **Denial of Service** affecting API availability:
- All API requests processing transactions that wrote modules with deep types will crash
- Repeated requests can cause sustained API unavailability
- Affects indexer services that process historical transactions
- Does not affect consensus or validator nodes directly, but impacts ecosystem services

The vulnerability violates the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." The API layer fails to enforce computational limits (stack depth) when processing module bytecode.

## Likelihood Explanation
**Medium-High Likelihood**

Requirements for exploitation:
1. `ENABLE_FUNCTION_VALUES` feature flag must be disabled (observable from chain config)
2. Attacker must be able to publish modules (requires gas payment)
3. Attacker must craft module with deeply nested types (trivial with compiler modifications)
4. API must process transactions involving this module (guaranteed for indexer, likely for user queries)

The likelihood is significant because:
- Feature flag state is verifiable on-chain
- Module publishing is permissionless (anyone can publish)
- Crafting deep types is straightforward
- Historical data will trigger this indefinitely once published

## Recommendation
Implement multiple layers of defense:

**1. Add panic protection in `try_parse_abi()`:**
```rust
pub fn try_parse_abi(mut self) -> anyhow::Result<Self> {
    if self.abi.is_none() {
        if let Ok(module) = CompiledModule::deserialize(self.bytecode.inner()) {
            // Wrap conversion in panic catching
            let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
                module.try_into()
            }));
            match result {
                Ok(Ok(abi)) => self.abi = Some(abi),
                _ => {
                    // Log error but don't fail - return bytecode without ABI
                    sample!(
                        SampleRate::Duration(Duration::from_secs(1)),
                        warn!("Failed to parse ABI for module, returning without ABI")
                    );
                }
            }
        }
    }
    Ok(self)
}
```

**2. Replace recursive `new_move_type()` with iterative implementation:**
Use a stack-based algorithm similar to `preorder_traversal_with_depth()` to avoid unbounded recursion.

**3. Always enforce type depth limits:**
In `aptos_prod_verifier_config()`, set a reasonable default even when function values are disabled:
```rust
max_type_depth: Some(20), // Always enforce, not conditional
```

## Proof of Concept
```rust
// Rust test demonstrating the vulnerability
#[test]
#[should_panic(expected = "stack overflow")]
fn test_deep_type_nesting_crashes_abi_parser() {
    use move_binary_format::file_format::*;
    use api_types::move_types::MoveModuleBytecode;
    
    // Create a module with deeply nested Vector types
    let mut module = CompiledModule {
        version: 6,
        module_handles: vec![/* ... */],
        struct_handles: vec![/* ... */],
        function_handles: vec![/* ... */],
        // Create signature with Vector<Vector<Vector<...>>> nested 2000 levels
        signatures: vec![Signature(vec![create_deep_vector_type(2000)])],
        // ... rest of module fields
    };
    
    let bytecode = {
        let mut bytes = vec![];
        module.serialize(&mut bytes).unwrap();
        bytes
    };
    
    // This should crash with stack overflow when max_type_depth is None
    let move_module = MoveModuleBytecode::new(bytecode);
    let _result = move_module.try_parse_abi(); // Panics with stack overflow
}

fn create_deep_vector_type(depth: usize) -> SignatureToken {
    let mut token = SignatureToken::U8;
    for _ in 0..depth {
        token = SignatureToken::Vector(Box::new(token));
    }
    token
}
```

```move
// Move module that triggers the vulnerability
module attacker::deep_types {
    // Craft a struct with deeply nested type parameter
    // (actual compilation would require custom compiler to bypass checks)
    struct DeepNesting<T> {
        value: vector<vector<vector<vector<vector<
            vector<vector<vector<vector<vector<T>>>>>>>>>>  // Repeat many times
    }
}
```

**Notes:**
- The vulnerability is only exploitable when `max_type_depth` verification limit is `None`
- Production deployments with `ENABLE_FUNCTION_VALUES` enabled and `max_type_depth = Some(20)` are protected
- Historical modules published before limits were enforced remain vulnerable
- The fix should be applied defensively regardless of current feature flag state

### Citations

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L188-192)
```rust
        max_type_depth: if enable_function_values {
            Some(20)
        } else {
            None
        },
```

**File:** api/types/src/convert.rs (L493-497)
```rust
                Path::Code(_) => vec![WriteSetChange::WriteModule(WriteModule {
                    address: access_path.address.into(),
                    state_key_hash,
                    data: MoveModuleBytecode::new(bytes.to_vec()).try_parse_abi()?,
                })],
```

**File:** api/types/src/move_types.rs (L1003-1036)
```rust
impl From<CompiledModule> for MoveModule {
    fn from(m: CompiledModule) -> Self {
        let (address, name) = <(AccountAddress, Identifier)>::from(m.self_id());
        Self {
            address: address.into(),
            name: name.into(),
            friends: m
                .immediate_friends()
                .into_iter()
                .map(|f| f.into())
                .collect(),
            exposed_functions: m
                .function_defs
                .iter()
                // Return all entry or public functions.
                // Private entry functions are still callable by entry function transactions so
                // they should be included.
                .filter(|def| {
                    def.is_entry
                        || match def.visibility {
                            Visibility::Public | Visibility::Friend => true,
                            Visibility::Private => false,
                        }
                })
                .map(|def| m.new_move_function(def))
                .collect(),
            structs: m
                .struct_defs
                .iter()
                .map(|def| m.new_move_struct(def))
                .collect(),
        }
    }
}
```

**File:** api/types/src/move_types.rs (L1338-1348)
```rust
    pub fn try_parse_abi(mut self) -> anyhow::Result<Self> {
        if self.abi.is_none() {
            // Ignore error, because it is possible a transaction module payload contains
            // invalid bytecode.
            // So we ignore the error and output bytecode without abi.
            if let Ok(module) = CompiledModule::deserialize(self.bytecode.inner()) {
                self.abi = Some(module.try_into()?);
            }
        }
        Ok(self)
    }
```

**File:** api/types/src/bytecode.rs (L89-134)
```rust
    fn new_move_type(&self, token: &SignatureToken) -> MoveType {
        match token {
            SignatureToken::Bool => MoveType::Bool,
            SignatureToken::U8 => MoveType::U8,
            SignatureToken::U16 => MoveType::U16,
            SignatureToken::U32 => MoveType::U32,
            SignatureToken::U64 => MoveType::U64,
            SignatureToken::U128 => MoveType::U128,
            SignatureToken::U256 => MoveType::U256,
            SignatureToken::I8 => MoveType::I8,
            SignatureToken::I16 => MoveType::I16,
            SignatureToken::I32 => MoveType::I32,
            SignatureToken::I64 => MoveType::I64,
            SignatureToken::I128 => MoveType::I128,
            SignatureToken::I256 => MoveType::I256,
            SignatureToken::Address => MoveType::Address,
            SignatureToken::Signer => MoveType::Signer,
            SignatureToken::Vector(t) => MoveType::Vector {
                items: Box::new(self.new_move_type(t.borrow())),
            },
            SignatureToken::Struct(v) => MoveType::Struct(self.new_move_struct_tag(v, &[])),
            SignatureToken::StructInstantiation(shi, type_params) => {
                MoveType::Struct(self.new_move_struct_tag(shi, type_params))
            },
            SignatureToken::TypeParameter(i) => MoveType::GenericTypeParam { index: *i },
            SignatureToken::Reference(t) => MoveType::Reference {
                mutable: false,
                to: Box::new(self.new_move_type(t.borrow())),
            },
            SignatureToken::MutableReference(t) => MoveType::Reference {
                mutable: true,
                to: Box::new(self.new_move_type(t.borrow())),
            },
            SignatureToken::Function(args, result, abilities) => {
                let new_vec = |toks: &[SignatureToken]| {
                    toks.iter()
                        .map(|t| self.new_move_type(t))
                        .collect::<Vec<_>>()
                };
                MoveType::Function {
                    args: new_vec(args),
                    results: new_vec(result),
                    abilities: *abilities,
                }
            },
        }
```

**File:** third_party/move/move-binary-format/src/deserializer.rs (L56-71)
```rust
        let prev_state = move_core_types::state::set_state(VMState::DESERIALIZER);
        let result = std::panic::catch_unwind(|| {
            let module = deserialize_compiled_module(binary, config)?;
            BoundsChecker::verify_module(&module)?;

            Ok(module)
        })
        .unwrap_or_else(|_| {
            Err(PartialVMError::new(
                StatusCode::VERIFIER_INVARIANT_VIOLATION,
            ))
        });
        move_core_types::state::set_state(prev_state);

        result
    }
```
