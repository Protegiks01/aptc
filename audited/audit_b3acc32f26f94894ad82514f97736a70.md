# Audit Report

## Title
Proof Version Boundary Validation Failure Causes State Sync Disruption at Epoch Transitions

## Summary
The `GetTransactionDataWithProofRequest` handler lacks validation to ensure `proof_version >= end_version`, allowing requests that cross epoch boundaries to pass serviceability checks but fail during proof generation. This causes unnecessary resource consumption, service disruption, and potential state sync failures when proof_version is set to an epoch boundary while requesting data from multiple epochs.

## Finding Description

The vulnerability exists in a validation gap between the request serviceability check and the actual proof generation logic.

**Validation Logic** [1](#0-0) 

The `can_create_proof` method only verifies that the storage node's synced ledger info version is greater than or equal to the requested `proof_version`. It does NOT validate the relationship between `proof_version` and `end_version`.

**Request Routing** [2](#0-1) 

When a `GetTransactionDataWithProofRequest` is received, it routes to `can_service_transactions_with_proof`, which checks if transactions are available AND if a proof can be created, but never validates that `proof_version >= end_version`.

**Proof Generation Enforcement** [3](#0-2) 

The accumulator's `get_range_proof_positions` enforces that `last_leaf_index < self.num_leaves`, where `last_leaf_index = end_version` and `self.num_leaves = proof_version + 1`. This validation will fail when `end_version > proof_version`, causing an error: "Invalid last_leaf_index: {end_version}, num_leaves: {proof_version + 1}".

**Attack Scenario:**
1. Epoch N ends at version 1000
2. Attacker sends: `GetTransactionDataWithProofRequest { proof_version: 1000, start_version: 950, end_version: 1050, ... }`
3. Validation passes because: (a) transactions [950, 1050] exist in storage, and (b) synced_ledger_info_version >= 1000
4. During proof generation, the accumulator tries to prove transactions up to version 1050 using the accumulator state at version 1000
5. The check fails because transaction 1050 doesn't exist in the accumulator at version 1000 (which only contains transactions 0-1000)
6. Error is returned after consuming database reads and computation resources

This invariant violation is particularly severe at epoch boundaries where state sync operations are critical.

## Impact Explanation

**High Severity** - This vulnerability qualifies for the "Significant protocol violations" category:

1. **State Sync Disruption**: Nodes attempting to sync across epoch boundaries can encounter systematic failures if they miscalculate the proof_version or if malicious peers send crafted responses with invalid proof versions.

2. **Resource Exhaustion Attack**: An attacker can repeatedly send requests with `proof_version` at epoch boundaries while requesting data that spans beyond them, causing the server to:
   - Perform database lookups for transactions
   - Create iterators for transaction data
   - Consume CPU cycles before failing at proof generation
   - Return errors that must be handled by retry logic

3. **Service Degradation**: The request passes through multiple validation layers before failing deep in the stack [4](#0-3) , wasting resources on every invalid request.

4. **Inconsistent Behavior**: The serviceability check incorrectly signals that the request can be serviced, violating the contract between the validation layer and the execution layer.

## Likelihood Explanation

**High Likelihood** - This vulnerability is easily exploitable:

1. **No Authentication Required**: Any network peer can send storage service requests
2. **Trivial to Trigger**: Simply set `proof_version = epoch_ending_version` and `end_version > epoch_ending_version`
3. **Predictable Epoch Boundaries**: Epoch ending versions are public information available from epoch ending ledger infos
4. **Common in Practice**: Test utilities explicitly avoid this scenario by chunking data at epoch boundaries [5](#0-4) , indicating the developers are aware this is problematic

## Recommendation

Add validation in the `can_create_proof` method or create a new validation method that checks the relationship between `proof_version`, `start_version`, and `end_version`:

```rust
/// Returns true iff the peer can create a proof for the given version range
fn can_create_proof_for_range(&self, start_version: u64, end_version: u64, proof_version: u64) -> bool {
    // Proof version must be at least as high as the end version
    if proof_version < end_version {
        return false;
    }
    
    // Synced ledger info must be at least at the proof version
    self.synced_ledger_info
        .as_ref()
        .map(|li| li.ledger_info().version() >= proof_version)
        .unwrap_or(false)
}
```

Then update all proof-with-data validation methods:

```rust
fn can_service_transactions_with_proof(
    &self,
    start_version: u64,
    end_version: u64,
    proof_version: u64,
) -> bool {
    let desired_range = match CompleteDataRange::new(start_version, end_version) {
        Ok(desired_range) => desired_range,
        Err(_) => return false,
    };

    let can_service_transactions = self.can_service_transactions(&desired_range);
    let can_create_proof = self.can_create_proof_for_range(start_version, end_version, proof_version);
    can_service_transactions && can_create_proof
}
```

Apply similar fixes to `can_service_transaction_outputs_with_proof` and `can_service_transactions_or_outputs_with_proof`.

## Proof of Concept

```rust
use aptos_storage_service_types::requests::{DataRequest, GetTransactionDataWithProofRequest, TransactionDataRequestType, TransactionData};
use aptos_storage_service_types::responses::DataSummary;

#[test]
fn test_proof_version_epoch_boundary_validation_gap() {
    // Setup: Epoch ends at version 1000, node has synced to version 2000
    let synced_ledger_info = create_ledger_info_at_version(2000);
    let epoch_ending_version = 1000;
    
    let data_summary = DataSummary {
        synced_ledger_info: Some(synced_ledger_info),
        transactions: Some(CompleteDataRange::new(0, 2000).unwrap()),
        ..Default::default()
    };
    
    // Attack: Request transactions that span across the epoch boundary
    // but set proof_version to the epoch ending version
    let malicious_request = GetTransactionDataWithProofRequest {
        transaction_data_request_type: TransactionDataRequestType::TransactionData(
            TransactionData { include_events: false }
        ),
        proof_version: epoch_ending_version,  // 1000
        start_version: 950,
        end_version: 1050,  // Spans beyond proof_version!
        max_response_bytes: 1024 * 1024,
    };
    
    let request = StorageServiceRequest::new(
        DataRequest::GetTransactionDataWithProof(malicious_request),
        false
    );
    
    // Bug: This validation PASSES even though it will fail during proof generation
    assert!(data_summary.can_service(&default_config(), time_service, &request));
    
    // When the actual proof generation is attempted, it will fail with:
    // "Invalid last_leaf_index: 1050, num_leaves: 1001"
}
```

The test demonstrates that a request with `proof_version < end_version` incorrectly passes the `can_service` validation check, but would fail during actual proof generation in the storage layer.

### Citations

**File:** state-sync/storage-service/types/src/responses.rs (L777-796)
```rust
            GetTransactionDataWithProof(request) => match request.transaction_data_request_type {
                TransactionDataRequestType::TransactionData(_) => self
                    .can_service_transactions_with_proof(
                        request.start_version,
                        request.end_version,
                        request.proof_version,
                    ),
                TransactionDataRequestType::TransactionOutputData => self
                    .can_service_transaction_outputs_with_proof(
                        request.start_version,
                        request.end_version,
                        request.proof_version,
                    ),
                TransactionDataRequestType::TransactionOrOutputData(_) => self
                    .can_service_transactions_or_outputs_with_proof(
                        request.start_version,
                        request.end_version,
                        request.proof_version,
                    ),
            },
```

**File:** state-sync/storage-service/types/src/responses.rs (L811-816)
```rust
    fn can_create_proof(&self, proof_version: u64) -> bool {
        self.synced_ledger_info
            .as_ref()
            .map(|li| li.ledger_info().version() >= proof_version)
            .unwrap_or(false)
    }
```

**File:** storage/accumulator/src/lib.rs (L421-429)
```rust
        let last_leaf_index = first_leaf_index
            .checked_add(num_leaves - 1)
            .ok_or_else(|| format_err!("Requesting too many leaves."))?;
        ensure!(
            last_leaf_index < self.num_leaves,
            "Invalid last_leaf_index: {}, num_leaves: {}",
            last_leaf_index,
            self.num_leaves,
        );
```

**File:** state-sync/storage-service/server/src/handler.rs (L426-428)
```rust
            DataRequest::GetTransactionDataWithProof(request) => {
                self.get_transaction_data_with_proof(request)
            },
```

**File:** state-sync/storage-service/server/src/tests/utils.rs (L84-110)
```rust
pub fn create_data_chunks_with_epoch_boundary(
    chunk_size: u64,
    num_chunks_to_create: u64,
    start_version: u64,
    epoch_change_version: u64,
) -> Vec<(u64, u64)> {
    (0..num_chunks_to_create)
        .map(|i| {
            let chunk_start_version = start_version + (i * chunk_size) + 1;
            let chunk_end_version = chunk_start_version + chunk_size - 1;
            if chunk_end_version < epoch_change_version {
                (chunk_start_version, chunk_end_version) // The chunk is before the epoch change
            } else if chunk_start_version < epoch_change_version
                && epoch_change_version < chunk_end_version
            {
                (chunk_start_version, epoch_change_version) // The chunk would cross the epoch boundary
            } else {
                let chunk_shift_amount =
                    (chunk_start_version - epoch_change_version - 1) % chunk_size;
                (
                    chunk_start_version - chunk_shift_amount,
                    chunk_end_version - chunk_shift_amount,
                ) // The chunk is after the epoch change (shift it left)
            }
        })
        .collect()
}
```
