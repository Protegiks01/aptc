# Audit Report

## Title
Panic-Induced Denial of Service at Maximum Jellyfish Merkle Tree Depth

## Summary
The Jellyfish Merkle tree implementation contains an off-by-one boundary handling error that causes validator node crashes when processing tree operations at the maximum allowed depth of 64 nibbles. While theoretically the code supports nibble paths up to ROOT_NIBBLE_HEIGHT (64), the tree update logic incorrectly assumes depth must be strictly less than 64, leading to assertion failures. [1](#0-0) 

## Finding Description
The vulnerability stems from a mismatch between data structure capabilities and operational assumptions:

1. **NibblePath allows 64-nibble paths**: The NibblePath structure explicitly supports paths up to and including ROOT_NIBBLE_HEIGHT (64 nibbles), as evidenced by the invariant comment and validation logic. [2](#0-1) [3](#0-2) 

2. **Tree operations assume depth < 64**: The NibbleRangeIterator, critical for tree traversal and updates, contains an assertion requiring nibble_idx to be strictly less than ROOT_NIBBLE_HEIGHT. [4](#0-3) 

3. **Boundary access violations**: The get_nibble trait implementation attempts unchecked array access that would be out-of-bounds when index equals 64. [5](#0-4) 

When nodes exist at depth 63 with children at depth 64, subsequent update operations trigger this code path. During tree updates via batch_insert_at or batch_update_subtree_with_existing_leaf, if depth reaches 64:

- Line 511 in batch_insert_at calls NibbleRangeIterator::new(kvs, 64) [6](#0-5) 

- Line 994 in batch_update_subtree_with_existing_leaf calls NibbleRangeIterator::new(kvs, 64) [7](#0-6) 

Both trigger the assertion failure assert!(64 < 64), causing a panic.

The attack scenario requires:
1. State keys whose SHA3-256 hashes share the first 63 nibbles (252 bits)
2. Insertion of these keys into the tree, creating nodes at maximum depth
3. Any subsequent update operation on these keys

## Impact Explanation
This represents a **High Severity** vulnerability per Aptos bug bounty criteria:

- **Validator Node Crashes**: The assertion failure causes immediate thread panic, potentially crashing validator nodes
- **Network Liveness Degradation**: Multiple validators encountering the same block with problematic tree operations would experience simultaneous failures
- **Deterministic Execution Violation**: While all nodes would fail consistently, the panic prevents proper transaction processing and state root computation

However, the practical exploitability is severely limited:

The probability of naturally occurring keys sharing 63 nibbles is approximately 2^-252, making this essentially impossible without hash collisions. An attacker would need to either:
- Break SHA3-256 preimage resistance to craft colliding hashes
- Perform ~2^126 hash operations to find a collision (birthday paradox)
- Exploit unknown weaknesses in the hash function

Given that cryptographic primitives are assumed secure per the audit scope, this vulnerability exists as a **theoretical boundary case** rather than a practically exploitable attack vector.

## Likelihood Explanation
**Extremely Low** - Exploitation requires cryptographic hash collisions:

- Natural occurrence: Probability 2^-252 per key pair
- Deliberate collision: Requires breaking SHA3-256 (computationally infeasible)
- Corrupted database: Would require compromising storage layer integrity

The defensive assertions prevent undefined behavior but convert rare edge cases into availability failures rather than silent corruption.

## Recommendation
Add explicit depth validation before tree operations that could reach maximum depth:

```rust
// In batch_insert_at, batch_update_subtree, and batch_update_subtree_with_existing_leaf
fn batch_insert_at(..., depth: usize, ...) -> Result<Option<Node<K>>> {
    ensure!(
        depth < ROOT_NIBBLE_HEIGHT,
        "Tree depth {} exceeds maximum allowed depth {}",
        depth,
        ROOT_NIBBLE_HEIGHT
    );
    // ... rest of function
}
```

Additionally, consider whether the invariant should be `num_nibbles < ROOT_NIBBLE_HEIGHT` instead of `num_nibbles <= ROOT_NIBBLE_HEIGHT` to prevent creation of maximum-length paths entirely, or properly support depth-64 operations if intentional.

## Proof of Concept
```rust
// Theoretical PoC - Not practically executable without hash collisions
use aptos_crypto::HashValue;
use aptos_types::state_store::state_key::StateKey;

#[test]
#[should_panic(expected = "assertion failed")]
fn test_maximum_depth_panic() {
    // This test demonstrates the panic but cannot execute without
    // crafting keys that produce hash collisions (SHA3-256)
    
    // Hypothetical: Two keys whose hashes share first 63 nibbles
    // In practice, finding such keys requires breaking SHA3-256
    let key1 = HashValue::from_hex("000000000000000000000000000000000000000000000000000000000000001").unwrap();
    let key2 = HashValue::from_hex("000000000000000000000000000000000000000000000000000000000000002").unwrap();
    
    // Tree operations at depth 64 would trigger:
    // assert!(nibble_idx < ROOT_NIBBLE_HEIGHT) where nibble_idx = 64
    // Resulting in panic
}
```

**Note**: Due to the reliance on hash collisions, a working exploit cannot be demonstrated without compromising cryptographic assumptions excluded from the audit scope. The vulnerability exists as a boundary condition defect rather than a practically exploitable attack.

### Citations

**File:** types/src/nibble/mod.rs (L17-17)
```rust
pub const ROOT_NIBBLE_HEIGHT: usize = HashValue::LENGTH * 2;
```

**File:** types/src/nibble/nibble_path/mod.rs (L31-31)
```rust
    // invariant num_nibbles <= ROOT_NIBBLE_HEIGHT
```

**File:** types/src/nibble/nibble_path/mod.rs (L116-116)
```rust
        assert!(num_nibbles <= ROOT_NIBBLE_HEIGHT);
```

**File:** storage/jellyfish-merkle/src/lib.rs (L261-263)
```rust
    fn new(sorted_kvs: &'a [(HashValue, K)], nibble_idx: usize) -> Self {
        assert!(nibble_idx < ROOT_NIBBLE_HEIGHT);
        NibbleRangeIterator {
```

**File:** storage/jellyfish-merkle/src/lib.rs (L511-511)
```rust
                let range_iter = NibbleRangeIterator::new(kvs, depth);
```

**File:** storage/jellyfish-merkle/src/lib.rs (L994-994)
```rust
        for (left, right) in NibbleRangeIterator::new(kvs, depth) {
```

**File:** storage/jellyfish-merkle/src/lib.rs (L1057-1067)
```rust
impl NibbleExt for HashValue {
    /// Returns the `index`-th nibble.
    fn get_nibble(&self, index: usize) -> Nibble {
        Nibble::from(
            if index % 2 == 0 {
                self[index / 2] >> 4
            } else {
                self[index / 2] & 0x0F
            },
        )
    }
```
