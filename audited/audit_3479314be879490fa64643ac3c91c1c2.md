# Audit Report

## Title
Inconsistent Feature Flag Fallback Handling Creates Consensus Disagreement Risk During JWK Consensus Migration

## Summary
When `OnChainJWKConsensusConfig` is not yet initialized and the `Features` config fails to load, the consensus layer defaults JWK consensus to "Off" while the JWK manager component assumes it's "On" (via `Features::default()`). This inconsistency can cause validator nodes to reject valid proposals containing `ObservedJWKUpdate` validator transactions, leading to consensus participation failures.

## Finding Description

During the migration period when `OnChainJWKConsensusConfig` is not yet initialized on-chain, the codebase has a fallback mechanism that constructs an equivalent config from the deprecated `Features` flag and `SupportedOIDCProviders`. [1](#0-0) 

However, when `Features` fails to load (due to deserialization errors, storage corruption, or database issues), two different code paths handle this failure inconsistently:

**Path 1: consensus/src/epoch_manager.rs (Round Manager)** [2](#0-1) 

This path uses `.ok()` to convert the error to `None`, which then triggers the `from()` implementation that defaults to `OnChainJWKConsensusConfig::Off`.

**Path 2: aptos-jwk-consensus/src/epoch_manager.rs (JWK Manager)** [3](#0-2) 

This path uses `unwrap_or_default()`, which creates `Features::default()` that includes `JWK_CONSENSUS` enabled: [4](#0-3) 

**Critical Consequence:**

When proposals containing `ObservedJWKUpdate` validator transactions arrive, the round manager validates them using `is_vtxn_expected()`: [5](#0-4) [6](#0-5) 

If `jwk_consensus_config` is incorrectly set to `Off` due to Features loading failure, the node will reject valid proposals with "unexpected validator txn" error, causing it to fall out of consensus.

## Impact Explanation

This qualifies as **High Severity** per Aptos bug bounty criteria:
- **Validator node slowdowns**: Affected nodes cannot participate in consensus and must wait for epoch transition or manual intervention
- **Significant protocol violations**: Creates consensus disagreement where some nodes accept valid proposals while others reject them
- **Network partition risk**: If multiple validators experience Features loading failures simultaneously (e.g., during software upgrades with migration issues), a subset of the validator set could become unable to participate

The issue breaks the **Deterministic Execution** invariant - validators with identical blocks should produce identical decisions, but here they diverge based on whether Features loaded successfully.

## Likelihood Explanation

**Likelihood: Low to Medium**

The vulnerability requires:
1. System to be in migration period (OnChainJWKConsensusConfig not yet initialized)
2. Features config to fail loading (storage corruption, deserialization error, I/O failure)

While Features failures are uncommon in normal operation, they can occur during:
- Software upgrades with schema changes
- State sync issues causing incomplete config data
- Storage corruption or hardware failures
- Race conditions during epoch transitions
- Migration deployment where OnChainJWKConsensusConfig rollout is incomplete

The inconsistency is deterministic once triggered - it will reliably cause the affected node to reject proposals.

## Recommendation

**Option 1: Consistent Default Handling (Safer)**
Change the consensus layer to use `unwrap_or_default()` consistently:

```rust
fn equivalent_jwk_consensus_config_from_deprecated_resources(
    payload: &OnChainConfigPayload<P>,
) -> OnChainJWKConsensusConfig {
    let features = payload.get::<Features>().unwrap_or_default(); // Changed from .ok()
    let oidc_providers = payload.get::<SupportedOIDCProviders>().ok();
    OnChainJWKConsensusConfig::from((Some(features), oidc_providers)) // Changed from (features, ...)
}
```

This ensures both paths produce the same result when Features fails to load.

**Option 2: Explicit Error Handling with Logging**
```rust
fn equivalent_jwk_consensus_config_from_deprecated_resources(
    payload: &OnChainConfigPayload<P>,
) -> OnChainJWKConsensusConfig {
    let features = match payload.get::<Features>() {
        Ok(f) => Some(f),
        Err(e) => {
            error!("Failed to load Features config during JWK consensus fallback: {}", e);
            // Use default features to maintain consistency with JWK manager
            Some(Features::default())
        }
    };
    let oidc_providers = payload.get::<SupportedOIDCProviders>().ok();
    OnChainJWKConsensusConfig::from((features, oidc_providers))
}
```

**Option 3: Remove Fallback Path (Best Long-term)**
Once `OnChainJWKConsensusConfig` is fully deployed, remove the deprecated fallback entirely and make it mandatory, failing loudly if not present.

## Proof of Concept

Due to the nature of this vulnerability (requires system failures rather than malicious input), a realistic PoC would need to simulate storage failures. However, the logic flow can be demonstrated:

```rust
// Simulated test showing the inconsistency
#[test]
fn test_jwk_consensus_config_inconsistency() {
    // Simulate Features loading failure by passing None
    let features_failed = None;
    let oidc_providers = None;
    
    // Path 1: consensus layer (via From implementation)
    let consensus_config = OnChainJWKConsensusConfig::from((features_failed, oidc_providers));
    assert_eq!(consensus_config, OnChainJWKConsensusConfig::Off); // Defaults to Off
    
    // Path 2: JWK manager would use Features::default()
    let default_features = Features::default();
    assert!(default_features.is_enabled(FeatureFlag::JWK_CONSENSUS)); // JWK_CONSENSUS enabled by default
    
    // This demonstrates the inconsistency:
    // - Consensus layer thinks JWK consensus is OFF
    // - JWK manager thinks JWK consensus is ON
    // - Result: Node rejects valid ObservedJWKUpdate transactions
}
```

**Notes**

This vulnerability is a **defensive programming issue** that could manifest during migration periods or system failures. While not directly exploitable by external attackers, it represents a consensus safety risk where transient failures can cause validator nodes to diverge in their treatment of validator transactions. The fix is straightforward and should be implemented to ensure robust handling of edge cases during the OnChainJWKConsensusConfig migration.

### Citations

**File:** types/src/on_chain_config/jwk_consensus_config.rs (L112-132)
```rust
impl From<(Option<Features>, Option<SupportedOIDCProviders>)> for OnChainJWKConsensusConfig {
    fn from(
        (features, supported_oidc_providers): (Option<Features>, Option<SupportedOIDCProviders>),
    ) -> Self {
        if let Some(features) = features {
            if features.is_enabled(FeatureFlag::JWK_CONSENSUS) {
                let oidc_providers = supported_oidc_providers
                    .unwrap_or_default()
                    .providers
                    .into_iter()
                    .filter_map(|deprecated| OIDCProvider::try_from(deprecated).ok())
                    .collect();
                OnChainJWKConsensusConfig::V1(ConfigV1 { oidc_providers })
            } else {
                OnChainJWKConsensusConfig::Off
            }
        } else {
            OnChainJWKConsensusConfig::Off
        }
    }
}
```

**File:** consensus/src/epoch_manager.rs (L1963-1969)
```rust
    fn equivalent_jwk_consensus_config_from_deprecated_resources(
        payload: &OnChainConfigPayload<P>,
    ) -> OnChainJWKConsensusConfig {
        let features = payload.get::<Features>().ok();
        let oidc_providers = payload.get::<SupportedOIDCProviders>().ok();
        OnChainJWKConsensusConfig::from((features, oidc_providers))
    }
```

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L172-194)
```rust
        let features = payload.get::<Features>().unwrap_or_default();
        let jwk_consensus_config = payload.get::<OnChainJWKConsensusConfig>();
        let onchain_observed_jwks = payload.get::<ObservedJWKs>().ok();
        let onchain_consensus_config = payload.get::<OnChainConsensusConfig>().unwrap_or_default();

        let (jwk_manager_should_run, oidc_providers) = match jwk_consensus_config {
            Ok(config) => {
                let should_run =
                    config.jwk_consensus_enabled() && onchain_consensus_config.is_vtxn_enabled();
                let providers = config
                    .oidc_providers_cloned()
                    .into_iter()
                    .map(jwks::OIDCProvider::from)
                    .collect();
                (should_run, Some(SupportedOIDCProviders { providers }))
            },
            Err(_) => {
                //TODO: remove this case once the framework change of this commit is published.
                let should_run = features.is_enabled(FeatureFlag::JWK_CONSENSUS)
                    && onchain_consensus_config.is_vtxn_enabled();
                let providers = payload.get::<SupportedOIDCProviders>().ok();
                (should_run, providers)
            },
```

**File:** types/src/on_chain_config/aptos_features.rs (L221-221)
```rust
            FeatureFlag::JWK_CONSENSUS,
```

**File:** consensus/src/round_manager.rs (L1126-1136)
```rust
        if let Some(vtxns) = proposal.validator_txns() {
            for vtxn in vtxns {
                let vtxn_type_name = vtxn.type_name();
                ensure!(
                    is_vtxn_expected(&self.randomness_config, &self.jwk_consensus_config, vtxn),
                    "unexpected validator txn: {:?}",
                    vtxn_type_name
                );
                vtxn.verify(self.epoch_state.verifier.as_ref())
                    .context(format!("{} verify failed", vtxn_type_name))?;
            }
```

**File:** consensus/src/util/mod.rs (L15-24)
```rust
pub fn is_vtxn_expected(
    randomness_config: &OnChainRandomnessConfig,
    jwk_consensus_config: &OnChainJWKConsensusConfig,
    vtxn: &ValidatorTransaction,
) -> bool {
    match vtxn {
        ValidatorTransaction::DKGResult(_) => randomness_config.randomness_enabled(),
        ValidatorTransaction::ObservedJWKUpdate(_) => jwk_consensus_config.jwk_consensus_enabled(),
    }
}
```
