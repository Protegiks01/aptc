# Audit Report

## Title
Validator Transaction DoS: Malicious Proposers Can Waste Computational Resources Through Invalid Validator Transactions

## Summary
A malicious validator acting as proposer can include validator transactions in their proposals that pass lightweight consensus-layer verification but fail expensive VM-layer cryptographic verification, causing all validators to waste significant computational resources on multi-pairing operations (DKG) or multi-signature verification (JWK) before discarding the invalid transactions.

## Finding Description

The vulnerability exists in the two-phase verification of validator transactions:

**Phase 1: Consensus Verification (Lightweight)**

During proposal processing, validator transactions are verified using minimal checks: [1](#0-0) 

For `DKGResult` transactions, this calls: [2](#0-1) 

Which only invokes `verify_transcript_extra()`: [3](#0-2) 

The `verify_transcript_extra()` function performs only lightweight checks (dealer indices, voting power, consistency) without cryptographic verification: [4](#0-3) 

For `ObservedJWKUpdate` transactions, consensus verification does **nothing**: [5](#0-4) 

**Phase 2: VM Execution (Expensive)**

During block execution, expensive cryptographic verification occurs:

For DKG transactions, the VM calls `verify_transcript()` which performs costly PVSS multi-pairing operations: [6](#0-5) 

This verification involves ~100+ elliptic curve pairing operations for a typical validator set: [7](#0-6) 

For JWK transactions, expensive multi-signature verification occurs: [8](#0-7) 

**The Problem:**

When VM verification fails, the transaction is discarded without causing consensus failure: [9](#0-8) 

This means:
1. A malicious proposer crafts a validator transaction with valid structure but invalid cryptographic proofs
2. All validators accept the proposal (lightweight check passes)
3. All validators perform expensive cryptographic verification during execution
4. Verification fails, transaction is discarded
5. **All validators wasted significant CPU resources with no consequence to the malicious proposer**

There is no punishment mechanism for proposers whose blocks contain discarded validator transactions, as "failed proposers" only tracks validators who failed to produce blocks entirely: [10](#0-9) 

## Impact Explanation

**Severity: High** (per "Validator node slowdowns" category in Aptos bug bounty)

Impact:
- **Resource Exhaustion**: Each invalid DKG transaction forces all validators to perform ~100+ expensive pairing operations
- **Network-wide Impact**: Every validator processes the malicious transaction during execution
- **Sustained Attack**: Malicious validator can repeat this in every round they propose
- **No Mitigation**: No rate limiting or punishment mechanism exists
- **Computational Cost**: PVSS pairing operations are among the most expensive cryptographic operations

For a network with 100 validators and 4 second block times, a malicious proposer (assuming they propose every 100 rounds) could force unnecessary cryptographic verification ~21 times per day, consuming significant computational resources network-wide.

## Likelihood Explanation

**Likelihood: Medium-High**

- Requires a single malicious validator (within BFT threat model of < 1/3 Byzantine)
- Attack is trivial to execute (craft invalid cryptographic proofs)
- No technical barriers or complex exploitation required
- Can be executed repeatedly during proposer's rounds
- Detection is difficult as discarded transactions appear in logs but don't cause consensus issues
- No automatic penalties or defenses exist

## Recommendation

Implement expensive cryptographic verification during the consensus phase before accepting proposals, or add a punishment mechanism for proposers whose blocks contain invalid validator transactions.

**Option 1: Move Cryptographic Verification to Consensus (Preferred)**

Modify `DKGTranscript::verify()` to call both `verify_transcript_extra()` AND `verify_transcript()`:

```rust
// In types/src/dkg/mod.rs
pub(crate) fn verify(&self, verifier: &ValidatorVerifier) -> Result<()> {
    let transcripts: Transcripts = bcs::from_bytes(&self.transcript_bytes)
        .context("Transcripts deserialization failed")?;
    
    // Perform full verification including expensive cryptographic checks
    let pub_params = RealDKG::new_public_params(&session_metadata);
    RealDKG::verify_transcript(&pub_params, &transcripts)
        .context("Transcript verification failed")?;
    
    RealDKG::verify_transcript_extra(&transcripts, verifier, true, None)
}
```

Similarly for JWK updates:

```rust
// In types/src/validator_txn.rs
pub fn verify(&self, verifier: &ValidatorVerifier) -> anyhow::Result<()> {
    match self {
        ValidatorTransaction::DKGResult(dkg_result) => /* ... */,
        ValidatorTransaction::ObservedJWKUpdate(update) => {
            // Add verification logic here
            update.verify(verifier)?;
            Ok(())
        },
    }
}
```

**Option 2: Add Punishment Mechanism**

Track invalid validator transactions and penalize proposers through the staking system, similar to failed proposals.

## Proof of Concept

```rust
// Proof of Concept: Crafting an invalid DKG transaction
// This would be run by a malicious validator during their proposer round

use aptos_types::{
    dkg::{DKGTranscript, DKGTranscriptMetadata},
    validator_txn::ValidatorTransaction,
};
use rand::Rng;

fn craft_malicious_dkg_transaction(epoch: u64, author: AccountAddress) -> ValidatorTransaction {
    // Create a transcript with random invalid cryptographic proofs
    // This will pass verify_transcript_extra() but fail verify_transcript()
    
    let mut rng = rand::thread_rng();
    
    // Generate random bytes that will deserialize to Transcripts with invalid proofs
    let malicious_transcript_bytes = (0..10000)
        .map(|_| rng.gen::<u8>())
        .collect::<Vec<u8>>();
    
    let dkg_transcript = DKGTranscript::new(
        epoch,
        author,
        malicious_transcript_bytes,
    );
    
    ValidatorTransaction::DKGResult(dkg_transcript)
}

// In the malicious proposer's block creation logic:
// 1. Create block with valid transactions
// 2. Add malicious validator transaction
// 3. All validators will waste CPU verifying the invalid PVSS proofs
// 4. Transaction gets discarded but computational damage is done
```

The attack exploits the gap between lightweight consensus checks and expensive VM verification, allowing resource exhaustion without consensus failure or proposer punishment.

### Citations

**File:** consensus/src/round_manager.rs (L1127-1136)
```rust
            for vtxn in vtxns {
                let vtxn_type_name = vtxn.type_name();
                ensure!(
                    is_vtxn_expected(&self.randomness_config, &self.jwk_consensus_config, vtxn),
                    "unexpected validator txn: {:?}",
                    vtxn_type_name
                );
                vtxn.verify(self.epoch_state.verifier.as_ref())
                    .context(format!("{} verify failed", vtxn_type_name))?;
            }
```

**File:** types/src/validator_txn.rs (L45-52)
```rust
    pub fn verify(&self, verifier: &ValidatorVerifier) -> anyhow::Result<()> {
        match self {
            ValidatorTransaction::DKGResult(dkg_result) => dkg_result
                .verify(verifier)
                .context("DKGResult verification failed"),
            ValidatorTransaction::ObservedJWKUpdate(_) => Ok(()),
        }
    }
```

**File:** types/src/dkg/mod.rs (L83-87)
```rust
    pub(crate) fn verify(&self, verifier: &ValidatorVerifier) -> Result<()> {
        let transcripts: Transcripts = bcs::from_bytes(&self.transcript_bytes)
            .context("Transcripts deserialization failed")?;
        RealDKG::verify_transcript_extra(&transcripts, verifier, true, None)
    }
```

**File:** types/src/dkg/real_dkg/mod.rs (L295-329)
```rust
    fn verify_transcript_extra(
        trx: &Self::Transcript,
        verifier: &ValidatorVerifier,
        checks_voting_power: bool,
        ensures_single_dealer: Option<AccountAddress>,
    ) -> anyhow::Result<()> {
        let all_validator_addrs = verifier.get_ordered_account_addresses();
        let main_trx_dealers = trx.main.get_dealers();
        let mut dealer_set = HashSet::with_capacity(main_trx_dealers.len());
        for dealer in main_trx_dealers.iter() {
            if let Some(dealer_addr) = all_validator_addrs.get(dealer.id) {
                dealer_set.insert(*dealer_addr);
            } else {
                bail!("invalid dealer idx");
            }
        }
        ensure!(main_trx_dealers.len() == dealer_set.len());
        if ensures_single_dealer.is_some() {
            let expected_dealer_set: HashSet<AccountAddress> =
                ensures_single_dealer.into_iter().collect();
            ensure!(expected_dealer_set == dealer_set);
        }

        if checks_voting_power {
            verifier
                .check_voting_power(dealer_set.iter(), true)
                .context("not enough power")?;
        }

        if let Some(fast_trx) = &trx.fast {
            ensure!(fast_trx.get_dealers() == main_trx_dealers);
            ensure!(trx.main.get_dealt_public_key() == fast_trx.get_dealt_public_key());
        }
        Ok(())
    }
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L68-77)
```rust
            Err(Expected(failure)) => {
                // Pretend we are inside Move, and expected failures are like Move aborts.
                Ok((
                    VMStatus::MoveAbort {
                        location: AbortLocation::Script,
                        code: failure as u64,
                        message: None,
                    },
                    VMOutput::empty_with_status(TransactionStatus::Discard(StatusCode::ABORTED)),
                ))
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L111-112)
```rust
        DefaultDKG::verify_transcript(&pub_params, &transcript)
            .map_err(|_| Expected(TranscriptVerificationFailed))?;
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L280-377)
```rust
    fn verify<A: Serialize + Clone>(
        &self,
        sc: &<Self as traits::Transcript>::SecretSharingConfig,
        pp: &Self::PublicParameters,
        spks: &[Self::SigningPubKey],
        eks: &[Self::EncryptPubKey],
        auxs: &[A],
    ) -> anyhow::Result<()> {
        self.check_sizes(sc)?;
        let n = sc.get_total_num_players();
        if eks.len() != n {
            bail!("Expected {} encryption keys, but got {}", n, eks.len());
        }
        let W = sc.get_total_weight();

        // Deriving challenges by flipping coins: less complex to implement & less likely to get wrong. Creates bad RNG risks but we deem that acceptable.
        let mut rng = rand::thread_rng();
        let extra = random_scalars(2 + W * 3, &mut rng);

        let sok_vrfy_challenge = &extra[W * 3 + 1];
        let g_2 = pp.get_commitment_base();
        let g_1 = pp.get_encryption_public_params().pubkey_base();
        batch_verify_soks::<G1Projective, A>(
            self.soks.as_slice(),
            g_1,
            &self.V[W],
            spks,
            auxs,
            sok_vrfy_challenge,
        )?;

        let ldt = LowDegreeTest::random(
            &mut rng,
            sc.get_threshold_weight(),
            W + 1,
            true,
            sc.get_batch_evaluation_domain(),
        );
        ldt.low_degree_test_on_g1(&self.V)?;

        //
        // Correctness of encryptions check
        //

        let alphas_betas_and_gammas = &extra[0..W * 3 + 1];
        let (alphas_and_betas, gammas) = alphas_betas_and_gammas.split_at(2 * W + 1);
        let (alphas, betas) = alphas_and_betas.split_at(W + 1);
        assert_eq!(alphas.len(), W + 1);
        assert_eq!(betas.len(), W);
        assert_eq!(gammas.len(), W);

        let lc_VR_hat = G2Projective::multi_exp_iter(
            self.V_hat.iter().chain(self.R_hat.iter()),
            alphas_and_betas.iter(),
        );
        let lc_VRC = G1Projective::multi_exp_iter(
            self.V.iter().chain(self.R.iter()).chain(self.C.iter()),
            alphas_betas_and_gammas.iter(),
        );
        let lc_V_hat = G2Projective::multi_exp_iter(self.V_hat.iter().take(W), gammas.iter());
        let mut lc_R_hat = Vec::with_capacity(n);

        for i in 0..n {
            let p = sc.get_player(i);
            let weight = sc.get_player_weight(&p);
            let s_i = sc.get_player_starting_index(&p);

            lc_R_hat.push(g2_multi_exp(
                &self.R_hat[s_i..s_i + weight],
                &gammas[s_i..s_i + weight],
            ));
        }

        let h = pp.get_encryption_public_params().message_base();
        let g_2_neg = g_2.neg();
        let eks = eks
            .iter()
            .map(Into::<G1Projective>::into)
            .collect::<Vec<G1Projective>>();
        // The vector of left-hand-side ($\mathbb{G}_2$) inputs to each pairing in the multi-pairing.
        let lhs = [g_1, &lc_VRC, h].into_iter().chain(&eks);
        // The vector of right-hand-side ($\mathbb{G}_2$) inputs to each pairing in the multi-pairing.
        let rhs = [&lc_VR_hat, &g_2_neg, &lc_V_hat]
            .into_iter()
            .chain(&lc_R_hat);

        let res = multi_pairing(lhs, rhs);
        if res != Gt::identity() {
            bail!(
                "Expected zero during multi-pairing check for {} {}, but got {}",
                sc,
                <Self as traits::Transcript>::scheme_name(),
                res
            );
        }

        return Ok(());
    }
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L135-142)
```rust
        verifier
            .check_voting_power(authors.iter(), true)
            .map_err(|_| Expected(NotEnoughVotingPower))?;

        // Verify multi-sig.
        verifier
            .verify_multi_signatures(&observed, &multi_sig)
            .map_err(|_| Expected(MultiSigVerificationFailed))?;
```

**File:** consensus/src/liveness/proposal_generator.rs (L1-1)
```rust
// Copyright (c) Aptos Foundation
```
