# Audit Report

## Title
Access Control Bypass via Public Schema Visibility Allows Unauthorized Direct Database Manipulation

## Summary
The consensus crate exports a custom `define_schema!` macro that creates `pub struct` schemas instead of the standard `pub(crate)` visibility. Combined with public generic database methods on `ConsensusDB`, this allows any internal crate with access to `StorageWriteProxy` to bypass the intended consensus API and directly read/write/delete consensus data using custom schema definitions.

## Finding Description
The consensus crate deliberately deviates from the standard schema visibility pattern used throughout Aptos. While the standard `aptos_schemadb::define_schema!` creates `pub(crate)` schema structs to restrict access within a crate, the consensus crate defines its own macro that creates `pub` structs. [1](#0-0) 

This macro is exported at the crate root via `#[macro_export]`, making it available to any crate that depends on `aptos-consensus`. The column family names are simple strings that can be easily known or guessed. [2](#0-1) 

The `ConsensusDB` struct exposes public generic methods that accept any type implementing the `Schema` trait: [3](#0-2) 

The `PersistentLivenessStorage` trait, which is publicly exported, provides direct access to the `ConsensusDB` instance: [4](#0-3) [5](#0-4) 

An internal crate like `aptos-admin-service` obtains this access: [6](#0-5) 

**Exploitation Path:**

Any internal crate with access to `StorageWriteProxy` can:

1. Use the exported `consensus::define_schema!` macro to define custom schemas matching consensus column families ("block", "quorum_certificate", etc.)
2. Implement the required `KeyCodec` and `ValueCodec` traits using public types (`Block`, `QuorumCert`, `HashValue`)
3. Call `consensus_db()` to obtain `Arc<ConsensusDB>`
4. Use `get<S>()`, `put<S>()`, `delete<S>()`, or `get_all<S>()` with their custom schemas to directly manipulate consensus data

This bypasses the intended API (`save_blocks_and_quorum_certificates()`, `get_data()`, etc.) which may contain validation logic or access restrictions.

## Impact Explanation
This violates the **Access Control** invariant by allowing internal crates to bypass consensus APIs and directly manipulate the consensus database. While this doesn't allow external attackers to compromise the system, it represents a significant defense-in-depth failure:

- **State Corruption Risk**: Buggy or compromised internal crates could write invalid consensus data, potentially corrupting the consensus state
- **API Bypass**: Critical validation logic in the intended API methods can be circumvented  
- **Privilege Escalation**: Crates that should only have limited consensus access gain full database manipulation capabilities

This qualifies as **Medium Severity** per the Aptos bug bounty criteria: "State inconsistencies requiring intervention" - direct database manipulation could create consensus state corruption requiring manual intervention or recovery procedures.

## Likelihood Explanation
**Likelihood: Low-Medium**

The vulnerability requires:
- A malicious or severely buggy crate within the aptos-core workspace
- That crate having legitimate access to `StorageWriteProxy`
- Deliberate misuse of the exported macro and generic methods

While internal crates are generally trusted, this represents an unnecessarily large attack surface. Supply chain compromises, developer mistakes, or future architectural changes could make this exploitable. The standard `pub(crate)` pattern exists precisely to prevent this class of issues.

## Recommendation
Align with the standard schema visibility pattern used throughout Aptos:

1. **Remove the custom macro**: Delete the exported `define_schema!` macro from `consensus/src/consensusdb/schema/mod.rs`

2. **Use standard macros**: Import and use `aptos_schemadb::define_schema!` (for internal schemas) or `aptos_schemadb::define_pub_schema!` (only if external visibility is required) 

3. **Make schemas crate-private**: Change all schema definitions to use the standard `define_schema!` which creates `pub(crate)` structs

4. **Remove generic method exports**: If the schemas are properly restricted, consider making the generic methods `pub(crate)` as well, forcing external usage through the specific API methods

Example fix for `BlockSchema`:

```rust
// Instead of:
use crate::define_schema;
define_schema!(BlockSchema, HashValue, Block, BLOCK_CF_NAME);

// Use:
use aptos_schemadb::define_schema;
define_schema!(BlockSchema, HashValue, Block, BLOCK_CF_NAME);  // Creates pub(crate) struct
```

## Proof of Concept
```rust
// In an internal crate like aptos-admin-service that has StorageWriteProxy access

use consensus::define_schema;  // Use the exported macro
use aptos_consensus_types::block::Block;
use aptos_crypto::HashValue;
use aptos_schemadb::schema::{KeyCodec, ValueCodec};
use anyhow::Result;

// Define unauthorized schema with known CF name
consensus::define_schema!(UnauthorizedBlockSchema, HashValue, Block, "block");

// Implement codecs (copy from actual implementation)
impl KeyCodec<UnauthorizedBlockSchema> for HashValue {
    fn encode_key(&self) -> Result<Vec<u8>> {
        Ok(self.to_vec())
    }
    fn decode_key(data: &[u8]) -> Result<Self> {
        Ok(HashValue::from_slice(data)?)
    }
}

impl ValueCodec<UnauthorizedBlockSchema> for Block {
    fn encode_value(&self) -> Result<Vec<u8>> {
        Ok(bcs::to_bytes(&self)?)
    }
    fn decode_value(data: &[u8]) -> Result<Self> {
        Ok(bcs::from_bytes(data)?)
    }
}

// Exploit: Direct database access bypassing consensus API
fn exploit_direct_db_access(storage: &StorageWriteProxy) -> Result<()> {
    let consensus_db = storage.consensus_db();
    
    // Read all blocks directly, bypassing intended API
    let all_blocks = consensus_db.get_all::<UnauthorizedBlockSchema>()?;
    
    // Could also write or delete blocks, corrupting consensus state
    // consensus_db.put::<UnauthorizedBlockSchema>(&malicious_hash, &malicious_block)?;
    // consensus_db.delete::<UnauthorizedBlockSchema>(vec![some_hash])?;
    
    Ok(())
}
```

This PoC demonstrates that any internal crate can define custom schemas and directly access ConsensusDB, bypassing the intended consensus API surface.

### Citations

**File:** consensus/src/consensusdb/schema/mod.rs (L21-35)
```rust
/// Copied from aptos-schemdadb to define pub struct instead of pub(crate)
#[macro_export]
macro_rules! define_schema {
    ($schema_type:ident, $key_type:ty, $value_type:ty, $cf_name:expr) => {
        #[derive(Debug)]
        pub struct $schema_type;

        impl aptos_schemadb::schema::Schema for $schema_type {
            type Key = $key_type;
            type Value = $value_type;

            const COLUMN_FAMILY_NAME: ColumnFamilyName = $cf_name;
        }
    };
}
```

**File:** consensus/src/consensusdb/schema/block/mod.rs (L21-23)
```rust
pub const BLOCK_CF_NAME: ColumnFamilyName = "block";

define_schema!(BlockSchema, HashValue, Block, BLOCK_CF_NAME);
```

**File:** consensus/src/consensusdb/mod.rs (L188-209)
```rust
    pub fn put<S: Schema>(&self, key: &S::Key, value: &S::Value) -> Result<(), DbError> {
        let mut batch = SchemaBatch::new();
        batch.put::<S>(key, value)?;
        self.commit(batch)?;
        Ok(())
    }

    pub fn delete<S: Schema>(&self, keys: Vec<S::Key>) -> Result<(), DbError> {
        let mut batch = SchemaBatch::new();
        keys.iter().try_for_each(|key| batch.delete::<S>(key))?;
        self.commit(batch)
    }

    pub fn get_all<S: Schema>(&self) -> Result<Vec<(S::Key, S::Value)>, DbError> {
        let mut iter = self.db.iter::<S>()?;
        iter.seek_to_first();
        Ok(iter.collect::<Result<Vec<(S::Key, S::Value)>, AptosDbError>>()?)
    }

    pub fn get<S: Schema>(&self, key: &S::Key) -> Result<Option<S::Value>, DbError> {
        Ok(self.db.get::<S>(key)?)
    }
```

**File:** consensus/src/persistent_liveness_storage.rs (L63-64)
```rust
    // Returns a handle of the consensus db
    fn consensus_db(&self) -> Arc<ConsensusDB>;
```

**File:** consensus/src/persistent_liveness_storage.rs (L620-622)
```rust
    fn consensus_db(&self) -> Arc<ConsensusDB> {
        self.db.clone()
    }
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L39-39)
```rust
    consensus_db: RwLock<Option<Arc<StorageWriteProxy>>>,
```
