# Audit Report

## Title
OptBlockData Payload Size Bypass Allows Memory Exhaustion DoS Attack

## Summary
The `verify_well_formed()` function in `OptBlockData` does not validate payload size, allowing attackers to send optimistic proposals with payloads up to 64 MiB (network limit) that bypass early validation despite the 6 MiB consensus block limit. This causes unbounded memory consumption and resource exhaustion before the payload size is eventually validated downstream.

## Finding Description

The vulnerability exists in the validation flow for optimistic block proposals (`OptProposalMsg`). When a validator receives an `OptProposalMsg`, the system performs early validation via `verify_well_formed()` before storing the block data in memory. [1](#0-0) 

The `verify_well_formed()` function validates round relationships, epoch consistency, and timestamps, but **completely omits payload size validation**. It only calls `self.payload().verify_epoch(self.epoch())` which validates the epoch field, not the size. [2](#0-1) 

Meanwhile, the network layer permits messages up to 64 MiB: [3](#0-2) 

And the consensus layer expects blocks to respect a 6 MiB limit: [4](#0-3) 

**Attack Flow:**

1. Attacker crafts `OptProposalMsg` with 60 MiB payload (below 64 MiB network limit, above 6 MiB consensus limit)
2. Message passes network deserialization (< 64 MiB)
3. `OptProposalMsg::verify()` is called, which invokes `verify_well_formed()` with no size check [5](#0-4) 

4. The verified `OptBlockData` is stored in unbounded data structures: [6](#0-5) 

5. OptBlockData is either buffered in the unbounded `BTreeMap` or sent through the unbounded channel [7](#0-6) 

6. Payload size is only checked much later in `process_proposal()` after conversion: [8](#0-7) 

By this point, significant resources have been consumed: network bandwidth for deserialization, CPU cycles for verification, and memory for storage in unbounded collections.

## Impact Explanation

This is a **Medium Severity** vulnerability per the Aptos bug bounty program because it enables:

1. **Validator Node Slowdowns** (Medium severity): Processing multiple oversized OptProposalMsg messages wastes CPU on deserialization and verification, and memory on buffering, degrading validator performance.

2. **Resource Exhaustion DoS**: An attacker can send numerous OptProposalMsg instances with 60 MiB payloads. Since `pending_opt_proposals` is an unbounded `BTreeMap` and `opt_proposal_loopback_tx` is an `UnboundedSender`, memory consumption grows without limit until the node runs out of memory or becomes unresponsive.

3. **Bypass of Resource Limits**: This breaks the documented invariant "Resource Limits: All operations must respect gas, storage, and computational limits" by allowing resource consumption that bypasses intended consensus block size limits.

The attack does not achieve:
- Consensus safety violations (no Byzantine behavior)
- Permanent loss of funds or liveness
- Therefore not Critical severity

## Likelihood Explanation

**High Likelihood** - The attack is straightforward to execute:

- No validator privileges required - any network peer can send consensus messages
- No complex timing or race conditions needed
- Attacker only needs to craft `OptProposalMsg` with oversized payloads
- Multiple messages can be sent in parallel to amplify the effect
- The unbounded data structures guarantee memory growth
- Network layer permits up to 64 MiB, creating a 58 MiB exploitable window

The only requirement is that `enable_optimistic_proposal_rx` is enabled on the target validator, which is a standard configuration option.

## Recommendation

Add payload size validation to `verify_well_formed()` to fail fast before storing OptBlockData in memory:

```rust
pub fn verify_well_formed(&self) -> anyhow::Result<()> {
    let parent = self.parent();
    let grandparent_qc = self.grandparent_qc().certified_block();
    
    // ... existing checks ...
    
    self.payload().verify_epoch(self.epoch())?;
    
    // ADD THIS CHECK:
    let payload_size = self.payload().size();
    ensure!(
        payload_size as u64 <= MAX_RECEIVING_BLOCK_BYTES,
        "OptBlockData payload size {} exceeds the limit {}",
        payload_size,
        MAX_RECEIVING_BLOCK_BYTES,
    );
    
    // ... remaining checks ...
}
```

Where `MAX_RECEIVING_BLOCK_BYTES` should be imported from the consensus config. This ensures that oversized payloads are rejected before any resource-intensive operations or memory allocation occurs.

## Proof of Concept

```rust
#[test]
fn test_opt_block_data_oversized_payload_bypass() {
    use crate::opt_block_data::OptBlockData;
    use crate::common::{Payload, Author};
    use aptos_types::{block_info::BlockInfo, validator_txn::ValidatorTransaction};
    use aptos_crypto::HashValue;
    
    // Create a large payload exceeding consensus limits but under network limits
    let large_txns: Vec<SignedTransaction> = (0..10000)
        .map(|_| create_dummy_signed_transaction()) // Each ~6KB = 60MB total
        .collect();
    
    let payload = Payload::DirectMempool(large_txns);
    
    let grandparent_qc = create_test_qc_for_genesis();
    let parent = BlockInfo::new(
        1, // epoch
        2, // round
        HashValue::zero(),
        HashValue::zero(),
        0,
        2000,
        None,
    );
    
    let opt_block_data = OptBlockData::new(
        vec![],
        payload,
        Author::random(),
        1, // epoch
        3, // round
        3000, // timestamp
        parent,
        grandparent_qc,
    );
    
    // This should fail but currently passes
    let result = opt_block_data.verify_well_formed();
    
    // BUG: verify_well_formed() does not check payload size
    assert!(result.is_ok()); // This passes when it should fail!
    
    // Payload size is ~60MB, exceeding 6MB consensus limit
    assert!(opt_block_data.payload().size() > 6 * 1024 * 1024);
    
    // This OptBlockData would be stored in unbounded collections
    // before size validation occurs in process_proposal()
}
```

## Notes

This vulnerability specifically affects the optimistic proposal feature where blocks can be proposed speculatively. While the payload eventually gets rejected during `process_proposal()`, the validation gap allows attackers to consume significant resources before rejection occurs. The fix should align early validation with the consensus size limits to prevent resource exhaustion attacks.

### Citations

**File:** consensus/consensus-types/src/opt_block_data.rs (L75-116)
```rust
    pub fn verify_well_formed(&self) -> anyhow::Result<()> {
        let parent = self.parent();
        let grandparent_qc = self.grandparent_qc().certified_block();
        ensure!(
            grandparent_qc.round() + 1 == parent.round(),
            "Block's parent's round {} must be one more than grandparent's round {}",
            parent.round(),
            grandparent_qc.round(),
        );
        ensure!(
            parent.round() + 1 == self.round(),
            "Block's round {} must be one more than parent's round {}",
            self.round(),
            parent.round(),
        );
        ensure!(
            grandparent_qc.epoch() == self.epoch() && parent.epoch() == self.epoch(),
            "Block's parent and grantparent should be in the same epoch"
        );
        ensure!(
            !grandparent_qc.has_reconfiguration(),
            "Optimistic proposals are disallowed after the reconfiguration block"
        );

        self.payload().verify_epoch(self.epoch())?;

        ensure!(
            self.timestamp_usecs() > parent.timestamp_usecs()
                && parent.timestamp_usecs() > grandparent_qc.timestamp_usecs(),
            "Blocks must have strictly increasing timestamps"
        );

        let current_ts = duration_since_epoch();

        // we can say that too far is 5 minutes in the future
        const TIMEBOUND: u64 = 300_000_000;
        ensure!(
            self.timestamp_usecs() <= (current_ts.as_micros() as u64).saturating_add(TIMEBOUND),
            "Blocks must not be too far in the future"
        );
        Ok(())
    }
```

**File:** consensus/consensus-types/src/common.rs (L634-669)
```rust
    pub(crate) fn verify_epoch(&self, epoch: u64) -> anyhow::Result<()> {
        match self {
            Payload::DirectMempool(_) => return Ok(()),
            Payload::InQuorumStore(proof_with_data) => {
                ensure!(
                    proof_with_data.proofs.iter().all(|p| p.epoch() == epoch),
                    "Payload epoch doesn't match given epoch"
                );
            },
            Payload::InQuorumStoreWithLimit(proof_with_data_with_txn_limit) => {
                ensure!(
                    proof_with_data_with_txn_limit
                        .proof_with_data
                        .proofs
                        .iter()
                        .all(|p| p.epoch() == epoch),
                    "Payload epoch doesn't match given epoch"
                );
            },
            Payload::QuorumStoreInlineHybrid(inline_batches, proof_with_data, _)
            | Payload::QuorumStoreInlineHybridV2(inline_batches, proof_with_data, _) => {
                ensure!(
                    proof_with_data.proofs.iter().all(|p| p.epoch() == epoch),
                    "Payload proof epoch doesn't match given epoch"
                );
                ensure!(
                    inline_batches.iter().all(|b| b.0.epoch() == epoch),
                    "Payload inline batch epoch doesn't match given epoch"
                )
            },
            Payload::OptQuorumStore(opt_quorum_store_payload) => {
                opt_quorum_store_payload.check_epoch(epoch)?;
            },
        };
        Ok(())
    }
```

**File:** network/framework/src/constants.rs (L20-21)
```rust
pub const MAX_FRAME_SIZE: usize = 4 * 1024 * 1024; /* 4 MiB */
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```

**File:** config/src/config/consensus_config.rs (L227-231)
```rust
            max_sending_block_bytes: 3 * 1024 * 1024, // 3MB
            max_receiving_block_txns: *MAX_RECEIVING_BLOCK_TXNS,
            max_sending_inline_txns: 100,
            max_sending_inline_bytes: 200 * 1024,       // 200 KB
            max_receiving_block_bytes: 6 * 1024 * 1024, // 6MB
```

**File:** consensus/consensus-types/src/opt_proposal_msg.rs (L96-123)
```rust
    pub fn verify(
        &self,
        sender: Author,
        validator: &ValidatorVerifier,
        proof_cache: &ProofCache,
        quorum_store_enabled: bool,
    ) -> Result<()> {
        ensure!(
            self.proposer() == sender,
            "OptProposal author {:?} doesn't match sender {:?}",
            self.proposer(),
            sender
        );

        let (payload_verify_result, qc_verify_result) = rayon::join(
            || {
                self.block_data()
                    .payload()
                    .verify(validator, proof_cache, quorum_store_enabled)
            },
            || self.block_data().grandparent_qc().verify(validator),
        );
        payload_verify_result?;
        qc_verify_result?;

        // Note that we postpone the verification of SyncInfo until it's being used.
        self.verify_well_formed()
    }
```

**File:** consensus/src/round_manager.rs (L330-331)
```rust
    pending_opt_proposals: BTreeMap<Round, OptBlockData>,
    opt_proposal_loopback_tx: aptos_channels::UnboundedSender<OptBlockData>,
```

**File:** consensus/src/round_manager.rs (L816-834)
```rust
        if self.round_state.current_round() == proposal_msg.round() {
            self.opt_proposal_loopback_tx
                .send(proposal_msg.take_block_data())
                .await
                .expect("Sending to a self loopback unbounded channel cannot fail");
        } else {
            // Pre-check that proposal is from valid proposer before queuing it.
            // This check is done after syncing up to sync info to ensure proposer
            // election provider is up to date.
            ensure!(
                self.proposer_election
                    .is_valid_proposer(proposal_msg.proposer(), proposal_msg.round()),
                "[OptProposal] Not a valid proposer for round {}: {}",
                proposal_msg.round(),
                proposal_msg.proposer()
            );
            self.pending_opt_proposals
                .insert(proposal_msg.round(), proposal_msg.take_block_data());
        }
```

**File:** consensus/src/round_manager.rs (L1187-1193)
```rust
        ensure!(
            validator_txns_total_bytes + payload_size as u64
                <= self.local_config.max_receiving_block_bytes,
            "Payload size {} exceeds the limit {}",
            payload_size,
            self.local_config.max_receiving_block_bytes,
        );
```
