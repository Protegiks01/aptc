# Audit Report

## Title
Silent Failure in Consensus Key Rotation Storage Initialization Leads to Validator Unavailability

## Summary
The `storage()` function in `safety_rules_manager.rs` uses `.unwrap_or_default()` when loading overriding identity blobs for consensus key rotation, causing file read errors to be silently ignored. This prevents rotated consensus keys from being stored, leading to validator inability to participate in consensus after on-chain key rotation.

## Finding Description

The vulnerability exists in the consensus key rotation mechanism. When a validator rotates their consensus key, they must:

1. Generate a new consensus private key and create an identity blob file
2. Add the file path to `overriding_identity_paths` in their configuration
3. Restart their node to load the new key
4. Submit an on-chain transaction to rotate the key
5. Participate in consensus with the new key starting next epoch

The critical flaw occurs during step 3. In the `storage()` function, overriding identity blobs are loaded using: [1](#0-0) 

When `overriding_identity_blobs()` encounters any error (corrupted file, malformed YAML, permission issues, missing file), the `.unwrap_or_default()` returns an empty vector instead of panicking. This is inconsistent with other error paths in the same function: [2](#0-1)  and [3](#0-2) 

The `overriding_identity_blobs()` method can fail when reading identity blob files: [4](#0-3) 

When the error is silently ignored, the loop that stores overriding keys never executes: [5](#0-4) 

Later, when the validator rotates their key on-chain and the next epoch begins, `SafetyRules` initialization attempts to retrieve the private key matching the new public key: [6](#0-5) 

The `consensus_sk_by_pk()` method tries to find the key with format `CONSENSUS_KEY_{public_key_hex}`, falls back to the default key, then validates the public key matches: [7](#0-6) 

Since the rotated key was never stored (due to silent error), and the fallback returns the old key which doesn't match the new public key, the initialization fails and sets `validator_signer = None`, preventing the validator from signing any consensus messages.

## Impact Explanation

**High Severity** - This qualifies as "Validator node slowdowns" and "Significant protocol violations" under the Aptos bug bounty criteria.

**Affected Components:**
- Validator consensus participation becomes impossible after key rotation
- Reduces total network voting power
- If multiple validators experience this simultaneously during coordinated key rotation, could impact network liveness
- Silent failure makes debugging extremely difficult for operators

**Invariant Violated:** This breaks the operational reliability requirement that validators must maintain consensus participation during normal operations like key rotation.

## Likelihood Explanation

**Medium to High Likelihood:**

**Triggering Conditions:**
- Consensus key rotation (normal operational procedure recommended for security)
- File corruption, permission errors, or malformed YAML in identity blob files
- Could affect multiple validators if using automated deployment with a configuration bug

**Why Likely:**
- Key rotation is a standard security practice that validators should perform periodically
- File system errors (corruption, permissions, typos in paths) are common operational issues
- The silent failure provides no warning until the validator fails to participate in the next epoch
- No validation occurs at configuration time

**Real-World Scenario:**
A validator generates a new consensus key, updates their configuration with the identity blob path, but makes a typo in the file path or the YAML file has incorrect formatting. The node restarts successfully with no errors logged. They submit the on-chain rotation transaction. At the next epoch, their node silently fails to initialize and stops participating in consensus, only discoverable through monitoring consensus participation metrics.

## Recommendation

Replace `.unwrap_or_default()` with `.expect()` to make failures visible and consistent with other initialization paths:

```rust
// Line 81-84: Current code
for blob in config
    .initial_safety_rules_config
    .overriding_identity_blobs()
    .unwrap_or_default()

// Fixed code
for blob in config
    .initial_safety_rules_config
    .overriding_identity_blobs()
    .expect("Failed to load overriding identity blobs for consensus key rotation")
```

Additionally, the storage operation should also panic on failure for consistency:

```rust
// Line 89-96: Current code  
match storage.internal_store().set(storage_key.as_str(), sk) {
    Ok(_) => {
        info!("Setting {storage_key} succeeded.");
    },
    Err(e) => {
        warn!("Setting {storage_key} failed with internal store set error: {e}");
    },
}

// Fixed code
storage.internal_store()
    .set(storage_key.as_str(), sk)
    .expect(&format!("Failed to store consensus key {storage_key} for key rotation"));
```

This ensures configuration errors are caught immediately during node startup rather than causing silent failures during epoch transitions.

## Proof of Concept

```rust
// This test demonstrates the vulnerability
// Place in consensus/safety-rules/src/safety_rules_manager.rs tests

#[cfg(test)]
mod vulnerability_test {
    use super::*;
    use aptos_config::config::{SafetyRulesConfig, InitialSafetyRulesConfig};
    use std::path::PathBuf;
    
    #[test]
    #[should_panic(expected = "Failed to load overriding identity blobs")]
    fn test_overriding_identity_blob_failure_should_panic() {
        // Create config with invalid overriding identity blob path
        let mut config = SafetyRulesConfig::default();
        config.initial_safety_rules_config = InitialSafetyRulesConfig::from_file(
            PathBuf::from("/valid/primary/identity.yaml"),
            vec![PathBuf::from("/nonexistent/overriding/identity.yaml")], // This will fail to load
            WaypointConfig::FromConfig(Waypoint::default()),
        );
        
        // This should panic but currently doesn't due to .unwrap_or_default()
        // Demonstrating silent failure
        let _storage = storage(&config);
        
        // If we reach here, the bug exists - error was silently ignored
        // The overriding key was never loaded into storage
        // Validator will fail at next epoch when trying to use the rotated key
    }
}
```

**Reproduction Steps:**
1. Set up validator node with initial consensus key
2. Generate new consensus key and create identity blob YAML file
3. Introduce error in the file (corrupt YAML, wrong permissions, or typo in path)
4. Add path to `overriding_identity_blob_paths` in validator config
5. Restart validator node - it starts successfully with no error
6. Submit on-chain consensus key rotation transaction
7. Wait for next epoch - validator fails to initialize SafetyRules and cannot participate in consensus

**Expected Behavior:** Node should panic during startup (step 5) with clear error message about identity blob loading failure.

**Actual Behavior:** Node starts successfully, error silently ignored, validator fails during next epoch with obscure `ValidatorKeyNotFound` error.

---

## Notes

This vulnerability specifically affects validators during consensus key rotation operations. While the error handling inconsistency exists in production code, the impact is limited to validators performing key rotation. The silent failure is particularly dangerous because:

1. No error appears in logs when the configuration is loaded
2. The validator appears healthy until the next epoch transition
3. Debugging requires deep knowledge of the SafetyRules initialization flow

The fix is straightforward: make error handling consistent by using `.expect()` throughout the initialization path, ensuring misconfigurations are caught immediately rather than causing runtime failures.

### Citations

**File:** consensus/safety-rules/src/safety_rules_manager.rs (L33-35)
```rust
            .expect("Missing consensus key in test config")
            .private_key();
        let waypoint = test_config.waypoint.expect("No waypoint in config");
```

**File:** consensus/safety-rules/src/safety_rules_manager.rs (L64-69)
```rust
                identity_blob
                    .account_address
                    .expect("AccountAddress needed for safety rules"),
                identity_blob
                    .consensus_private_key
                    .expect("Consensus key needed for safety rules"),
```

**File:** consensus/safety-rules/src/safety_rules_manager.rs (L81-84)
```rust
        for blob in config
            .initial_safety_rules_config
            .overriding_identity_blobs()
            .unwrap_or_default()
```

**File:** consensus/safety-rules/src/safety_rules_manager.rs (L86-97)
```rust
            if let Some(sk) = blob.consensus_private_key {
                let pk_hex = hex::encode(PublicKey::from(&sk).to_bytes());
                let storage_key = format!("{}_{}", CONSENSUS_KEY, pk_hex);
                match storage.internal_store().set(storage_key.as_str(), sk) {
                    Ok(_) => {
                        info!("Setting {storage_key} succeeded.");
                    },
                    Err(e) => {
                        warn!("Setting {storage_key} failed with internal store set error: {e}");
                    },
                }
            }
```

**File:** config/src/config/safety_rules_config.rs (L170-187)
```rust
    pub fn overriding_identity_blobs(&self) -> anyhow::Result<Vec<IdentityBlob>> {
        match self {
            InitialSafetyRulesConfig::FromFile {
                overriding_identity_paths,
                ..
            } => {
                let mut blobs = vec![];
                for path in overriding_identity_paths {
                    let blob = IdentityBlob::from_file(path)?;
                    blobs.push(blob);
                }
                Ok(blobs)
            },
            InitialSafetyRulesConfig::None => {
                bail!("loading overriding identity blobs failed with missing initial safety rules config")
            },
        }
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L313-343)
```rust
        let expected_key = epoch_state.verifier.get_public_key(&author);
        let initialize_result = match expected_key {
            None => Err(Error::ValidatorNotInSet(author.to_string())),
            Some(expected_key) => {
                let current_key = self.signer().ok().map(|s| s.public_key());
                if current_key == Some(expected_key.clone()) {
                    info!(
                        SafetyLogSchema::new(LogEntry::KeyReconciliation, LogEvent::Success),
                        "in set",
                    );
                    Ok(())
                } else {
                    // Try to export the consensus key directly from storage.
                    match self.persistent_storage.consensus_sk_by_pk(expected_key) {
                        Ok(consensus_key) => {
                            self.validator_signer =
                                Some(ValidatorSigner::new(author, Arc::new(consensus_key)));
                            Ok(())
                        },
                        Err(Error::SecureStorageMissingDataError(error)) => {
                            Err(Error::ValidatorKeyNotFound(error))
                        },
                        Err(error) => Err(error),
                    }
                }
            },
        };
        initialize_result.inspect_err(|error| {
            info!(SafetyLogSchema::new(LogEntry::KeyReconciliation, LogEvent::Error).error(error),);
            self.validator_signer = None;
        })
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L106-132)
```rust
    pub fn consensus_sk_by_pk(
        &self,
        pk: bls12381::PublicKey,
    ) -> Result<bls12381::PrivateKey, Error> {
        let _timer = counters::start_timer("get", CONSENSUS_KEY);
        let pk_hex = hex::encode(pk.to_bytes());
        let explicit_storage_key = format!("{}_{}", CONSENSUS_KEY, pk_hex);
        let explicit_sk = self
            .internal_store
            .get::<bls12381::PrivateKey>(explicit_storage_key.as_str())
            .map(|v| v.value);
        let default_sk = self.default_consensus_sk();
        let key = match (explicit_sk, default_sk) {
            (Ok(sk_0), _) => sk_0,
            (Err(_), Ok(sk_1)) => sk_1,
            (Err(_), Err(_)) => {
                return Err(Error::ValidatorKeyNotFound("not found!".to_string()));
            },
        };
        if key.public_key() != pk {
            return Err(Error::SecureStorageMissingDataError(format!(
                "Incorrect sk saved for {:?} the expected pk",
                pk
            )));
        }
        Ok(key)
    }
```
