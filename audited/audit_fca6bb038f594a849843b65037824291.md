# Audit Report

## Title
Path Traversal in Legacy Move Package Resolver Enables Arbitrary Code Injection via Transitive Dependencies

## Summary
The legacy Move package resolver in `resolution_graph.rs` does not validate or sanitize the `local` path field when resolving transitive dependencies. This allows a malicious dependency to specify arbitrary filesystem paths that will be used to load Move source code, enabling supply chain attacks and potential consensus violations.

## Finding Description

The vulnerability exists in the dependency resolution logic where package paths are constructed without validation. [1](#0-0) 

When parsing a dependency's manifest, the code directly uses `PathBuf::push()` with the unvalidated `dep.local` value. In Rust, `PathBuf::push()` has dangerous behavior: if the argument is an absolute path, it replaces the entire PathBuf; if it contains `..` sequences, they are not normalized.

The `dep.local` value comes from parsing the dependency's Move.toml without any validation: [2](#0-1) 

**Attack Flow:**
1. Attacker publishes PackageA to a git repository with a malicious Move.toml containing:
   ```toml
   [dependencies]
   Evil = { local = "/tmp/malicious" }
   # or with path traversal
   Evil = { local = "../../../../tmp/malicious" }
   ```

2. User's package depends on PackageA (directly or transitively via another package)

3. During resolution, the system:
   - Downloads PackageA to `~/.move/PackageA_main/`
   - Parses PackageA's dependencies and finds the Evil dependency
   - Calls `parse_package_manifest` with the cached PackageA path
   - Line 504 executes `root_path.push("/tmp/malicious")`, replacing the entire path
   - Reads `/tmp/malicious/Move.toml` and validates it as a legitimate dependency

4. During compilation, `get_sources()` is called on this dependency: [3](#0-2) 

5. The system loads Move source files from the attacker-controlled location and compiles them into the user's package

This is actively used in production as the main entry point still uses this resolver: [4](#0-3) 

## Impact Explanation

**Critical Severity - Consensus Safety Violation**

This vulnerability breaks the **Deterministic Execution** invariant (Invariant #1). Different validator nodes could compile different bytecode depending on what files exist at the targeted filesystem paths, leading to:

1. **Consensus Splits**: If validators have different files at `/tmp/malicious/sources/`, they will compile different bytecode, produce different state roots, and fail to reach consensus on block execution results.

2. **Arbitrary Code Execution**: Malicious Move code from unauthorized locations gets compiled into packages deployed on-chain. This code executes with full Move VM privileges during transaction processing.

3. **Supply Chain Attack**: Users building packages with transitive dependencies unknowingly include attacker-controlled code, bypassing digest-based integrity checks since the digest only covers the git package, not the externally referenced code.

4. **Validation Bypass**: The attack works even when the malicious dependency is several levels deep in the dependency tree, making it difficult to detect.

This meets **Critical Severity** criteria as it enables consensus violations and could lead to network partition requiring a hardfork.

## Likelihood Explanation

**High Likelihood** - The attack is practical and requires minimal sophistication:

- **Attacker Requirements**: Ability to publish a git package (trivial with public git hosting)
- **No Privileges Needed**: Works for any unprivileged package author
- **Difficult to Detect**: The malicious path is buried in a transitive dependency's Move.toml
- **Wide Attack Surface**: Affects any user building packages that include the malicious dependency

The newer resolver has protections via `CanonicalPath`, but the legacy resolver remains active and is the default code path: [5](#0-4) 

However, the legacy system lacks these protections entirely.

## Recommendation

**Immediate Fix**: Add path validation in `parse_package_manifest` before using the path:

```rust
fn parse_package_manifest(
    dep: &Dependency,
    dep_name: &PackageName,
    mut root_path: PathBuf,
) -> Result<(SourceManifest, PathBuf)> {
    // Validate the local path
    if dep.local.is_absolute() {
        bail!(
            "Dependency '{}' specifies an absolute local path '{}' which is not allowed",
            dep_name,
            dep.local.display()
        );
    }
    
    // Check for parent directory traversal attempts
    for component in dep.local.components() {
        if matches!(component, std::path::Component::ParentDir) {
            bail!(
                "Dependency '{}' contains parent directory traversal (..) which is not allowed: '{}'",
                dep_name,
                dep.local.display()
            );
        }
    }
    
    root_path.push(&dep.local);
    // ... rest of function
}
```

**Long-term Solution**: Migrate fully to the new resolver which has proper path canonicalization and validation.

## Proof of Concept

**Setup:**
1. Create malicious Move package at `/tmp/malicious/`:
```bash
mkdir -p /tmp/malicious/sources
cat > /tmp/malicious/Move.toml << EOF
[package]
name = "Malicious"
version = "1.0.0"

[addresses]
Malicious = "0xBAD"
EOF

cat > /tmp/malicious/sources/evil.move << EOF
module Malicious::Evil {
    public fun backdoor() {
        // Malicious code that gets compiled into victim's package
    }
}
EOF
```

2. Create attacker's git package with malicious dependency:
```toml
[package]
name = "AttackerPackage"
version = "1.0.0"

[dependencies]
Malicious = { local = "/tmp/malicious" }
```

3. Victim creates package depending on AttackerPackage:
```toml
[dependencies]
AttackerPackage = { git = "https://github.com/attacker/package", rev = "main" }
```

4. When victim runs `aptos move compile`, the system:
   - Resolves AttackerPackage from git
   - Parses its Move.toml and finds `Malicious = { local = "/tmp/malicious" }`
   - Line 504 replaces path with `/tmp/malicious`
   - Loads and compiles `/tmp/malicious/sources/evil.move` into victim's package

**Result**: Arbitrary attacker code is compiled into the victim's Move package without their knowledge.

---

## Notes

The newer package resolver (`move-package-resolver`) implements proper protections, but the legacy resolver remains the active code path and contains no validation. This creates a critical supply chain vulnerability in the Aptos Move package ecosystem that could compromise consensus determinism across the network.

### Citations

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L499-517)
```rust
    fn parse_package_manifest(
        dep: &Dependency,
        dep_name: &PackageName,
        mut root_path: PathBuf,
    ) -> Result<(SourceManifest, PathBuf)> {
        root_path.push(&dep.local);
        match fs::read_to_string(root_path.join(SourcePackageLayout::Manifest.path())) {
            Ok(contents) => {
                let source_package: SourceManifest =
                    parse_move_manifest_string(contents).and_then(parse_source_manifest)?;
                Ok((source_package, root_path))
            },
            Err(_) => Err(anyhow::format_err!(
                "Unable to find package manifest for '{}' at {:?}",
                dep_name,
                SourcePackageLayout::Manifest.path().join(root_path),
            )),
        }
    }
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L758-768)
```rust
    pub fn get_sources(&self, config: &BuildConfig) -> Result<Vec<FileName>> {
        let places_to_look =
            ResolvingPackage::get_source_paths_for_config(&self.package_path, config)?
                .into_iter()
                .map(|p| p.to_string_lossy().to_string())
                .collect::<Vec<_>>();
        Ok(find_move_filenames(&places_to_look, false)?
            .into_iter()
            .map(Symbol::from)
            .collect())
    }
```

**File:** third_party/move/tools/move-package/src/source_package/manifest_parser.rs (L342-354)
```rust
                (Some(local), None, None) => {
                    let local_str = local
                        .as_str()
                        .ok_or_else(|| format_err!("Local source path not a string"))?;
                    let local_path = PathBuf::from(local_str);
                    Ok(PM::Dependency {
                        subst,
                        version,
                        digest,
                        local: local_path,
                        git_info,
                        node_info,
                    })
```

**File:** third_party/move/tools/move-package/src/lib.rs (L203-222)
```rust
    pub fn resolution_graph_for_package<W: Write>(
        mut self,
        path: &Path,
        writer: &mut W,
    ) -> Result<ResolvedGraph> {
        if self.test_mode {
            self.dev_mode = true;
        }
        let path = SourcePackageLayout::try_find_root(path)?;
        let toml_manifest =
            self.parse_toml_manifest(path.join(SourcePackageLayout::Manifest.path()))?;
        let mutx = PackageLock::lock();
        // This should be locked as it inspects the environment for `MOVE_HOME` which could
        // possibly be set by a different process in parallel.
        let manifest = manifest_parser::parse_source_manifest(toml_manifest)?;
        let resolution_graph = ResolutionGraph::new(manifest, path, self, writer)?;
        let ret = resolution_graph.resolve();
        mutx.unlock();
        ret
    }
```

**File:** third_party/move/tools/move-package-resolver/src/resolver.rs (L329-340)
```rust
                let dep_manitest_path = if local_path.is_absolute() {
                    local_path
                } else {
                    parent_path.join(local_path)
                };
                let canonical_path = CanonicalPath::new(&dep_manitest_path).map_err(|err| {
                    anyhow!(
                        "failed to find package at {}: {}",
                        dep_manitest_path.display(),
                        err
                    )
                })?;
```
