# Audit Report

## Title
Improper Error Handling for Pruned Event Access Returns HTTP 500 Instead of HTTP 410

## Summary
The Events API endpoints (`get_events_by_creation_number` and `get_events_by_event_handle`) incorrectly handle requests for events at pruned sequence numbers by returning HTTP 500 (Internal Server Error) instead of HTTP 410 (Gone), potentially causing monitoring false positives and user confusion.

## Finding Description

The Events API allows clients to specify a `start` query parameter to retrieve events beginning from a specific sequence number. While the API validates that the requested ledger version is not pruned, it does not validate whether the individual event sequence numbers have been pruned. [1](#0-0) 

The `list()` function calls `context.get_events()` which eventually invokes the storage layer's `lookup_events_by_key()` method: [2](#0-1) 

When a user requests events starting from a sequence number that has been pruned (because the transaction version containing those events was pruned), the storage layer detects this at line 130-137 and returns an error: "First requested event is probably pruned." [3](#0-2) 

This error uses `db_other_bail!` which creates an `AptosDbError::Other`: [4](#0-3) 

However, in the Events API, this error is caught and incorrectly categorized as an `InternalError` (HTTP 500): [5](#0-4) 

The API should instead return a `GoneError` (HTTP 410) using the existing `version_pruned` helper: [6](#0-5) 

## Impact Explanation

**Severity: High** - This qualifies as "API crashes" under the Aptos bug bounty criteria, though it's more accurately described as API error mishandling.

The impact includes:
- **User Confusion**: Clients receive HTTP 500 (server error) when they should receive HTTP 410 (data gone), suggesting a server malfunction rather than expected pruning behavior
- **Monitoring False Positives**: HTTP 500 errors typically trigger alerts in production monitoring systems, creating false alarms when users legitimately request pruned events
- **API Stability Perception**: Repeated HTTP 500 errors make the API appear unstable or buggy when it's functioning as designed

## Likelihood Explanation

**Likelihood: High** - This issue occurs whenever:
1. A user queries events with a `start` sequence number parameter
2. The events at that sequence number were emitted in a transaction at a pruned ledger version
3. This is common in production as nodes continuously prune historical data

The attack requires no special privileges - any API user can trigger this by requesting events from older sequence numbers on nodes with aggressive pruning configurations.

## Recommendation

Modify the `list()` function in `api/src/events.rs` to detect pruning-related errors from the storage layer and return HTTP 410 (Gone) instead of HTTP 500:

```rust
fn list(
    &self,
    latest_ledger_info: LedgerInfo,
    accept_type: AcceptType,
    page: Page,
    event_key: EventKey,
) -> BasicResultWith404<Vec<VersionedEvent>> {
    let ledger_version = latest_ledger_info.version();
    let events = self
        .context
        .get_events(
            &event_key,
            page.start_option(),
            page.limit(&latest_ledger_info)?,
            ledger_version,
        )
        .context(format!("Failed to find events by key {}", event_key))
        .map_err(|err| {
            // Check if this is a pruning error
            if err.to_string().contains("pruned") {
                BasicErrorWith404::gone_with_code(
                    err,
                    AptosErrorCode::VersionPruned,
                    &latest_ledger_info,
                )
            } else {
                BasicErrorWith404::internal_with_code(
                    err,
                    AptosErrorCode::InternalError,
                    &latest_ledger_info,
                )
            }
        })?;
    // ... rest of function
}
```

Alternatively, the storage layer could return a more specific error type that the API layer can distinguish from other internal errors.

## Proof of Concept

**Setup**: Configure an Aptos node with aggressive pruning (e.g., `prune_window = 1000` versions)

**Steps**:
1. Wait for the node to prune historical data
2. Identify an event stream (e.g., coin transfer events on a well-known account)
3. Calculate a sequence number that would have been in a pruned transaction version
4. Make an API request:
   ```bash
   curl "https://api.node.com/v1/accounts/0x1/events/0/<creation_number>?start=<pruned_seq_num>"
   ```

**Expected (Current) Behavior**: Returns HTTP 500 with error message containing "First requested event is probably pruned"

**Expected (Correct) Behavior**: Returns HTTP 410 with `AptosErrorCode::VersionPruned`

**Reproduction in Rust tests**:
```rust
#[tokio::test]
async fn test_pruned_event_access() {
    // Create a test harness with a pruned database
    let (context, _) = new_test_context_with_pruning().await;
    let events_api = EventsApi { context: Arc::new(context) };
    
    // Request events with a sequence number from a pruned version
    let result = events_api.get_events_by_creation_number(
        AcceptType::Json,
        Path(Address::from_hex_literal("0x1").unwrap()),
        Path(U64::from(0)),
        Query(Some(U64::from(1000))), // pruned sequence number
        Query(Some(10)),
    ).await;
    
    // Currently returns 500, should return 410
    match result {
        Err(BasicErrorWith404::Gone(_)) => {}, // Expected
        Err(BasicErrorWith404::Internal(_)) => panic!("Returned 500 instead of 410"),
        _ => panic!("Unexpected response"),
    }
}
```

## Notes

While this issue returns incorrect HTTP status codes, it does **not** cause actual API crashes or panics - errors are properly caught and handled at the response level. The security concern is limited to operational monitoring and user experience, making this a quality/stability issue rather than a critical security vulnerability.

The root cause is that the storage layer doesn't distinguish between "data pruned" errors and other internal errors, so the API layer has no type-safe way to handle them differently. A more robust fix would involve creating a specific `AptosDbError::Pruned` variant.

### Citations

**File:** api/src/events.rs (L155-178)
```rust
    fn list(
        &self,
        latest_ledger_info: LedgerInfo,
        accept_type: AcceptType,
        page: Page,
        event_key: EventKey,
    ) -> BasicResultWith404<Vec<VersionedEvent>> {
        let ledger_version = latest_ledger_info.version();
        let events = self
            .context
            .get_events(
                &event_key,
                page.start_option(),
                page.limit(&latest_ledger_info)?,
                ledger_version,
            )
            .context(format!("Failed to find events by key {}", event_key))
            .map_err(|err| {
                BasicErrorWith404::internal_with_code(
                    err,
                    AptosErrorCode::InternalError,
                    &latest_ledger_info,
                )
            })?;
```

**File:** storage/aptosdb/src/event_store/mod.rs (L107-143)
```rust
    pub fn lookup_events_by_key(
        &self,
        event_key: &EventKey,
        start_seq_num: u64,
        limit: u64,
        ledger_version: u64,
    ) -> Result<
        Vec<(
            u64,     // sequence number
            Version, // transaction version it belongs to
            u64,     // index among events for the same transaction
        )>,
    > {
        let mut iter = self.event_db.iter::<EventByKeySchema>()?;
        iter.seek(&(*event_key, start_seq_num))?;

        let mut result = Vec::new();
        let mut cur_seq = start_seq_num;
        for res in iter.take(limit as usize) {
            let ((path, seq), (ver, idx)) = res?;
            if path != *event_key || ver > ledger_version {
                break;
            }
            if seq != cur_seq {
                let msg = if cur_seq == start_seq_num {
                    "First requested event is probably pruned."
                } else {
                    "DB corruption: Sequence number not continuous."
                };
                db_other_bail!("{} expected: {}, actual: {}", msg, cur_seq, seq);
            }
            result.push((seq, ver, idx));
            cur_seq += 1;
        }

        Ok(result)
    }
```

**File:** storage/storage-interface/src/lib.rs (L751-754)
```rust
macro_rules! db_other_bail {
    ($($arg:tt)*) => {
        return Err(AptosDbError::Other(format!($($arg)*)))
    };
```

**File:** api/src/response.rs (L664-670)
```rust
pub fn version_pruned<E: GoneError>(ledger_version: u64, ledger_info: &LedgerInfo) -> E {
    E::gone_with_code(
        format!("Ledger version({}) has been pruned", ledger_version),
        AptosErrorCode::VersionPruned,
        ledger_info,
    )
}
```
