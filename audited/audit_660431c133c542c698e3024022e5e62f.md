# Audit Report

## Title
Missing Equivocation Detection in Timeout Signature Aggregation Allows Silent Byzantine Behavior

## Summary
The `PartialSignaturesWithRound::add_signature()` function fails to detect when a validator signs multiple timeout messages for the same epoch/round with different HQC rounds. This Byzantine behavior goes undetected, unlogged, and unpunished, unlike vote equivocation which is properly detected and reported as a security event.

## Finding Description

The consensus protocol must detect Byzantine validator behavior to maintain security guarantees. When validators vote on proposals, the system properly detects equivocation [1](#0-0) , logging it as a `SecurityEvent::ConsensusEquivocatingVote` and returning `VoteReceptionResult::EquivocateVote`.

However, for timeout messages, no such detection exists. The vulnerable code path is:

1. A `RoundTimeoutMsg` arrives and is verified for signature validity [2](#0-1) 

2. The timeout is processed through `insert_round_timeout` [3](#0-2) 

3. Signatures are added via `TwoChainTimeoutWithPartialSignatures::add()` [4](#0-3) 

4. Finally reaching `PartialSignaturesWithRound::add_signature()` [5](#0-4) 

The critical vulnerability is in the `add_signature` implementation, which uses `entry().or_insert()` to add signatures. This means:
- If a validator has already signed a timeout for epoch E, round R with HQC round H1, it is stored
- If the **same validator** signs another timeout for epoch E, round R with HQC round H2 (where H2 â‰  H1), the second signature is **silently ignored**
- No error is returned, no security event is logged, no equivocation is detected

**Attack Scenario:**
A Byzantine validator can:
1. Sign a timeout for epoch 1, round 5 with HQC round 3
2. Sign another timeout for epoch 1, round 5 with HQC round 4  
3. Send both messages to different validators
4. The system silently keeps whichever arrives first, discarding the second without detection
5. No slashing occurs, no alert is raised, no other validators are notified

This violates the consensus protocol's assumption that Byzantine behavior will be detected and reported, which is critical for:
- Slashing mechanisms to punish malicious validators
- Security monitoring and incident response
- Alerting operators to active attacks
- Potentially removing Byzantine validators from future rounds

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty criteria for "Significant protocol violations."

While this doesn't directly cause consensus safety violations (the TC formation remains consistent because the first signature is kept), it represents a critical gap in Byzantine fault detection. The AptosBFT consensus protocol is designed to tolerate up to f Byzantine validators out of 3f+1, but this requires **detecting** Byzantine behavior to:

1. Enable slashing of malicious validators
2. Provide visibility into attacks for security teams
3. Support evidence-based validator removal
4. Maintain the integrity of the validator set over time

The asymmetry between vote equivocation detection (properly implemented) and timeout equivocation detection (missing) indicates this is an unintended security gap rather than a design choice.

## Likelihood Explanation

**Likelihood: High**

- Requires only a single Byzantine validator (no collusion needed)
- No special privileges beyond being a validator are required
- The attack is trivial to execute (sign two different timeouts)
- Byzantine validators are explicitly within the threat model (consensus must tolerate up to f Byzantine nodes)
- The vulnerability is in the core consensus path, executed frequently during normal operation

Any malicious validator can exploit this immediately with zero setup cost or technical complexity.

## Recommendation

Implement equivocation detection for timeout messages, matching the pattern used for vote equivocation:

```rust
pub fn add_signature(
    &mut self,
    validator: AccountAddress,
    round: Round,
    signature: bls12381::Signature,
) -> Result<(), EquivocationError> {
    if let Some((existing_round, _)) = self.signatures.get(&validator) {
        if *existing_round != round {
            // Equivocation detected: same validator, same epoch/round, different HQC rounds
            return Err(EquivocationError::ConflictingTimeout {
                validator,
                existing_hqc_round: *existing_round,
                new_hqc_round: round,
            });
        }
        // Duplicate of same timeout, ignore silently
        return Ok(());
    }
    self.signatures.insert(validator, (round, signature));
    Ok(())
}
```

Then propagate this error up through the call chain to log a security event similar to vote equivocation [6](#0-5)  and return `VoteReceptionResult::EquivocateVote` or a new `EquivocateTimeout` variant.

## Proof of Concept

```rust
#[test]
fn test_timeout_equivocation_detection() {
    use crate::{
        quorum_cert::QuorumCert,
        timeout_2chain::{TwoChainTimeout, TwoChainTimeoutWithPartialSignatures},
    };
    use aptos_crypto::hash::CryptoHash;
    use aptos_types::{
        aggregate_signature::PartialSignatures,
        block_info::BlockInfo,
        ledger_info::{LedgerInfo, LedgerInfoWithVerifiedSignatures},
        validator_verifier::random_validator_verifier,
    };

    let (signers, validators) = random_validator_verifier(4, None, false);
    
    // Create two QCs with different rounds
    let vote_data_1 = VoteData::new(BlockInfo::random(2), BlockInfo::random(0));
    let vote_data_2 = VoteData::new(BlockInfo::random(3), BlockInfo::random(0));
    
    let mut ledger_info_1 = LedgerInfoWithVerifiedSignatures::new(
        LedgerInfo::new(BlockInfo::empty(), vote_data_1.hash()),
        PartialSignatures::empty(),
    );
    let mut ledger_info_2 = LedgerInfoWithVerifiedSignatures::new(
        LedgerInfo::new(BlockInfo::empty(), vote_data_2.hash()),
        PartialSignatures::empty(),
    );
    
    for signer in &signers[0..3] {
        let sig1 = signer.sign(ledger_info_1.ledger_info()).unwrap();
        ledger_info_1.add_signature(signer.author(), sig1);
        let sig2 = signer.sign(ledger_info_2.ledger_info()).unwrap();
        ledger_info_2.add_signature(signer.author(), sig2);
    }
    
    let qc1 = QuorumCert::new(vote_data_1, ledger_info_1.aggregate_signatures(&validators).unwrap());
    let qc2 = QuorumCert::new(vote_data_2, ledger_info_2.aggregate_signatures(&validators).unwrap());
    
    // Byzantine validator signs two different timeouts for same epoch/round
    let timeout1 = TwoChainTimeout::new(1, 5, qc1); // epoch 1, round 5, HQC round 2
    let timeout2 = TwoChainTimeout::new(1, 5, qc2); // epoch 1, round 5, HQC round 3
    
    let sig1 = timeout1.sign(&signers[0]).unwrap();
    let sig2 = timeout2.sign(&signers[0]).unwrap();
    
    let mut partial_tc = TwoChainTimeoutWithPartialSignatures::new(timeout1.clone());
    
    // Add first timeout - should succeed
    partial_tc.add(signers[0].author(), timeout1, sig1);
    
    // Add second timeout with different HQC round - SHOULD DETECT EQUIVOCATION
    // but currently silently ignores it
    partial_tc.add(signers[0].author(), timeout2, sig2);
    
    // VULNERABILITY: No error, no detection, no logging
    // The second timeout is silently dropped via or_insert() logic
    println!("Equivocation went undetected - Byzantine behavior successful!");
}
```

**Notes**

The vulnerability exists in the timeout signature aggregation path and represents an asymmetry with the vote handling path. While immediate consensus safety is preserved (TC formation remains consistent), the failure to detect and report Byzantine behavior undermines long-term security assumptions of the protocol. This is particularly concerning as validators rely on equivocation detection for slashing and security monitoring, and the current implementation creates a blind spot for timeout-based Byzantine behavior.

### Citations

**File:** consensus/src/pending_votes.rs (L190-232)
```rust
    pub fn insert_round_timeout(
        &mut self,
        round_timeout: &RoundTimeout,
        validator_verifier: &ValidatorVerifier,
    ) -> VoteReceptionResult {
        //
        // Let's check if we can create a TC
        //

        let timeout = round_timeout.two_chain_timeout();
        let signature = round_timeout.signature();

        let validator_voting_power = validator_verifier
            .get_voting_power(&round_timeout.author())
            .unwrap_or(0);
        if validator_voting_power == 0 {
            warn!(
                "Received vote with no voting power, from {}",
                round_timeout.author()
            );
        }
        let cur_epoch = round_timeout.epoch();
        let cur_round = round_timeout.round();

        counters::CONSENSUS_CURRENT_ROUND_TIMEOUT_VOTED_POWER
            .with_label_values(&[&round_timeout.author().to_string()])
            .set(validator_voting_power as f64);
        counters::CONSENSUS_LAST_TIMEOUT_VOTE_EPOCH
            .with_label_values(&[&round_timeout.author().to_string()])
            .set(cur_epoch as i64);
        counters::CONSENSUS_LAST_TIMEOUT_VOTE_ROUND
            .with_label_values(&[&round_timeout.author().to_string()])
            .set(cur_round as i64);

        let two_chain_votes = self
            .maybe_2chain_timeout_votes
            .get_or_insert_with(|| TwoChainTimeoutVotes::new(timeout.clone()));
        two_chain_votes.add(
            round_timeout.author(),
            timeout.clone(),
            signature.clone(),
            round_timeout.reason().clone(),
        );
```

**File:** consensus/src/pending_votes.rs (L287-308)
```rust
        if let Some((previously_seen_vote, previous_li_digest)) =
            self.author_to_vote.get(&vote.author())
        {
            // is it the same vote?
            if &li_digest == previous_li_digest {
                // we've already seen an equivalent vote before
                let new_timeout_vote = vote.is_timeout() && !previously_seen_vote.is_timeout();
                if !new_timeout_vote {
                    // it's not a new timeout vote
                    return VoteReceptionResult::DuplicateVote;
                }
            } else {
                // we have seen a different vote for the same round
                error!(
                    SecurityEvent::ConsensusEquivocatingVote,
                    remote_peer = vote.author(),
                    vote = vote,
                    previous_vote = previously_seen_vote
                );

                return VoteReceptionResult::EquivocateVote;
            }
```

**File:** consensus/src/round_manager.rs (L147-154)
```rust
            UnverifiedEvent::RoundTimeoutMsg(v) => {
                if !self_message {
                    v.verify(validator)?;
                    counters::VERIFY_MSG
                        .with_label_values(&["timeout"])
                        .observe(start_time.elapsed().as_secs_f64());
                }
                VerifiedEvent::RoundTimeoutMsg(v)
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L242-263)
```rust
    pub fn add(
        &mut self,
        author: Author,
        timeout: TwoChainTimeout,
        signature: bls12381::Signature,
    ) {
        debug_assert_eq!(
            self.timeout.epoch(),
            timeout.epoch(),
            "Timeout should have the same epoch as TimeoutCert"
        );
        debug_assert_eq!(
            self.timeout.round(),
            timeout.round(),
            "Timeout should have the same round as TimeoutCert"
        );
        let hqc_round = timeout.hqc_round();
        if timeout.hqc_round() > self.timeout.hqc_round() {
            self.timeout = timeout;
        }
        self.signatures.add_signature(author, hqc_round, signature);
    }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L320-329)
```rust
    pub fn add_signature(
        &mut self,
        validator: AccountAddress,
        round: Round,
        signature: bls12381::Signature,
    ) {
        self.signatures
            .entry(validator)
            .or_insert((round, signature));
    }
```
