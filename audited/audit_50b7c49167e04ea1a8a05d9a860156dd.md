# Audit Report

## Title
Missing Gas Parameter Validation Allows Governance to Set Dangerously Low SHA2-256 Costs Enabling DoS Attacks

## Summary
The gas schedule update mechanism lacks validation of gas parameter values, allowing governance proposals to set SHA2-256 hashing costs (`hash.sha2_256.base` and `hash.sha2_256.per_byte`) to zero or dangerously low values. This would enable attackers to perform hash-based DoS attacks and preimage grinding at minimal cost, breaking the economic security model.

## Finding Description

The Aptos gas schedule system allows on-chain governance to update gas parameters through the `gas_schedule.move` module. However, critical validation is missing that should prevent invalid or dangerous gas parameter values.

**Missing Validation in Gas Schedule Module:**

The gas schedule update functions contain unimplemented validation checks: [1](#0-0) [2](#0-1) [3](#0-2) 

These TODO comments explicitly acknowledge that gas schedule consistency checks SHOULD exist but are not implemented. The functions only validate that the blob is non-empty and the feature version is monotonically increasing, but do NOT validate the actual parameter values.

**Direct Value Loading Without Bounds Checking:**

The Rust-side gas parameter loading mechanism directly converts on-chain values without validation: [4](#0-3) 

The macro starts with `zeros()` and then directly assigns values from the on-chain gas schedule using `.into()` with no minimum or maximum bounds checking.

**Gas Parameter Usage:**

The SHA2-256 native function charges gas based on these parameters: [5](#0-4) 

Normal values are: [6](#0-5) 

**Attack Scenario:**

1. A governance proposal (either malicious or buggy) sets `hash.sha2_256.base = 0` and `hash.sha2_256.per_byte = 0`
2. The proposal passes governance validation (only checks feature version, non-empty blob)
3. All validators load the new gas schedule at epoch boundary
4. Attackers can now hash maximum-size inputs (64KB per transaction, or 1MB for governance transactions) for essentially zero gas cost
5. SHA2-256 computation is expensive (~1-2 CPU cycles per byte), but is charged nothing
6. Attackers spam the network with transactions performing intensive hashing operations
7. Validator nodes experience CPU exhaustion while attackers pay minimal transaction fees [7](#0-6) 

## Impact Explanation

**High Severity** - This vulnerability enables significant protocol violations and resource exhaustion:

1. **DoS via Hash Spamming**: Attackers can submit transactions that hash maximum-size inputs at near-zero cost, causing CPU exhaustion on all validator nodes
2. **Economic Model Break**: Operations designed to be expensive become essentially free, violating the fundamental economic security assumption
3. **Preimage Grinding**: With cheap hashing, attackers can perform extensive preimage grinding attacks for minimal cost
4. **Validator Node Slowdowns**: All validators would simultaneously experience performance degradation when processing hash-heavy transactions

This meets the **High Severity** criteria per the Aptos bug bounty: "Validator node slowdowns" and "Significant protocol violations."

The vulnerability breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

## Likelihood Explanation

**Medium Likelihood:**

**Prerequisites:**
- Requires governance proposal submission and approval with @aptos_framework signer
- Could occur through either malicious governance compromise OR (more likely) a buggy governance proposal

**Likelihood factors:**
- The TODO comments indicate developers are AWARE validation should exist but haven't implemented it
- Governance proposals are complex and can contain bugs
- No runtime safeguards exist to detect or prevent dangerous gas values
- Once set, the incorrect values would affect all validators network-wide simultaneously
- The formal verification specs show no validation of parameter value ranges: [8](#0-7) 

The specs only verify non-empty blobs, not value ranges.

## Recommendation

**Implement gas parameter validation** as indicated by the TODO comments. Add minimum and maximum bounds checking for all gas parameters:

```move
// In gas_schedule.move, implement the validation function
fun validate_gas_schedule(gas_schedule: &GasScheduleV2): bool {
    let i = 0;
    let len = vector::length(&gas_schedule.entries);
    
    while (i < len) {
        let entry = vector::borrow(&gas_schedule.entries, i);
        let key = &entry.key;
        let val = entry.val;
        
        // Validate SHA2-256 parameters
        if (key == &string::utf8(b"move_stdlib.hash.sha2_256.base")) {
            assert!(val >= 1000, EINVALID_GAS_SCHEDULE); // Minimum 1000 gas units
            assert!(val <= 1000000, EINVALID_GAS_SCHEDULE); // Maximum 1M gas units
        };
        if (key == &string::utf8(b"move_stdlib.hash.sha2_256.per_byte")) {
            assert!(val >= 10, EINVALID_GAS_SCHEDULE); // Minimum 10 gas units per byte
            assert!(val <= 10000, EINVALID_GAS_SCHEDULE); // Maximum 10K gas units per byte  
        };
        
        // Add similar validation for all critical gas parameters
        i = i + 1;
    };
    true
}
```

Then call this validation in all update functions: [9](#0-8) 

Replace the TODO comment with actual validation call.

## Proof of Concept

```move
#[test_only]
module aptos_framework::gas_schedule_attack_test {
    use aptos_framework::gas_schedule;
    use std::vector;
    use std::string;
    
    #[test(framework = @aptos_framework)]
    #[expected_failure] // Should fail but currently doesn't due to missing validation
    fun test_zero_sha2_gas_parameters(framework: &signer) {
        // Create a malicious gas schedule with zero SHA2 costs
        let entries = vector::empty();
        
        // Set SHA2-256 base cost to 0 (should be rejected but isn't)
        vector::push_back(&mut entries, gas_schedule::GasEntry {
            key: string::utf8(b"move_stdlib.hash.sha2_256.base"),
            val: 0,  // DANGER: Zero cost for base SHA2-256
        });
        
        // Set SHA2-256 per-byte cost to 0 (should be rejected but isn't)
        vector::push_back(&mut entries, gas_schedule::GasEntry {
            key: string::utf8(b"move_stdlib.hash.sha2_256.per_byte"),
            val: 0,  // DANGER: Zero cost per byte
        });
        
        let malicious_schedule = gas_schedule::GasScheduleV2 {
            feature_version: 100,
            entries,
        };
        
        let blob = bcs::to_bytes(&malicious_schedule);
        
        // This should abort but doesn't - the vulnerability
        gas_schedule::set_for_next_epoch(framework, blob);
        
        // If this succeeds, attackers can hash arbitrary data for free
        // enabling DoS attacks via hash-heavy transactions
    }
}
```

**Note:** This vulnerability requires governance control to exploit, which is outside the scope of typical bug bounty programs that focus on unprivileged attackers. However, the missing validation is a clear defense-in-depth failure explicitly acknowledged by the TODO comments, and could enable significant harm through buggy (not necessarily malicious) governance proposals.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L47-47)
```text
        // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L67-67)
```text
            // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L75-75)
```text
            // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L34-45)
```rust
            fn from_on_chain_gas_schedule(gas_schedule: &std::collections::BTreeMap<String, u64>, feature_version: u64) -> Result<Self, String> {
                let mut params = $params_name::zeros();

                $(
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        let name = format!("{}.{}", $prefix, key);
                        params.$name = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?.into();
                    }
                )*

                Ok(params)
            }
```

**File:** aptos-move/framework/move-stdlib/src/natives/hash.rs (L37-39)
```rust
    context.charge(
        HASH_SHA2_256_BASE + HASH_SHA2_256_PER_BYTE * NumBytes::new(hash_arg.len() as u64),
    )?;
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/move_stdlib.rs (L23-24)
```rust
        [hash_sha2_256_base: InternalGas, "hash.sha2_256.base", 11028],
        [hash_sha2_256_per_byte: InternalGasPerByte, "hash.sha2_256.per_byte", 183],
```

**File:** aptos-move/aptos-vm/src/gas.rs (L109-120)
```rust
    } else if txn_metadata.transaction_size > txn_gas_params.max_transaction_size_in_bytes {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Transaction size too big {} (max {})",
                txn_metadata.transaction_size, txn_gas_params.max_transaction_size_in_bytes
            ),
        );
        return Err(VMStatus::error(
            StatusCode::EXCEEDED_MAX_TRANSACTION_SIZE,
            None,
        ));
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.spec.move (L18-21)
```text
    /// Requirement: Only valid gas schedule should be allowed for initialization and update.
    /// Criticality: Medium
    /// Implementation: The initialize and set_gas_schedule functions ensures that the gas_schedule_blob is not empty.
    /// Enforcement: Formally verified via [high-level-req-3.3](initialize) and [high-level-req-3.2](set_gas_schedule).
```
