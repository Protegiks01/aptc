# Audit Report

## Title
FixedProposer Deterministic Leader Selection Enables Predictable Centralization Attack

## Summary
The `FixedProposer` election type in Aptos consensus uses a deterministic `choose_leader()` function that always selects the validator with the minimum `AccountAddress`, rather than providing fair randomization. This creates a predictable single point of failure for consensus if `FixedProposer` is enabled via governance.

## Finding Description
When the on-chain consensus configuration is set to use `ProposerElectionType::FixedProposer`, the system selects a single validator to act as the permanent proposer through the `choose_leader()` function. The implementation uses `peers.into_iter().min()` which deterministically returns the validator with the lexicographically smallest `AccountAddress`. [1](#0-0) 

This chosen validator is then wrapped in a `RotatingProposer` with a single-element proposer list: [2](#0-1) 

The validator list is sourced from the `ValidatorVerifier`, which orders validators by their on-chain `validator_index`: [3](#0-2) [4](#0-3) 

The `AccountAddress` type derives `Ord` trait for lexicographic comparison: [5](#0-4) 

**Security Violation:** This breaks the expectation of fair proposer selection. The system provides NO randomization - the same validator is deterministically selected across all nodes and all epochs as long as `FixedProposer` remains configured. This creates:

1. **Predictable Centralization**: Any observer can determine which validator will be the fixed proposer by examining validator addresses
2. **Targeted Attack Surface**: Adversaries can focus DoS attacks on the specific validator with the minimum address
3. **Liveness Vulnerability**: As documented in the code comments, "A fixed proposer strategy loses liveness when the fixed proposer is down" [6](#0-5) 

## Impact Explanation
This qualifies as **Medium Severity** under Aptos bug bounty criteria for the following reasons:

- **State Inconsistencies**: If the fixed proposer becomes compromised or malicious, they can censor transactions and manipulate block ordering without immediate recourse
- **Liveness Risk**: Network availability depends entirely on a single, predictable validator
- **Consensus Integrity**: Violates the principle of decentralized block proposal in BFT consensus

While `FixedProposer` is not the default configuration, it is a valid on-chain setting that can be activated through governance proposals: [7](#0-6) 

The deterministic selection exacerbates the inherent risks of fixed proposer election by making the chosen validator predictable.

## Likelihood Explanation
**Likelihood: Medium**

While this requires a governance proposal to enable `FixedProposer`, the vulnerability has moderate likelihood because:

1. Governance can legitimately switch to `FixedProposer` for testing or emergency scenarios
2. Once enabled, the deterministic selection is automatic and affects all nodes
3. The code comments suggest this was intended as a "tmp hack" for testing, but remains in production code [8](#0-7) 

4. There is no randomization or rotation - the selection persists indefinitely

## Recommendation
Replace the deterministic `choose_leader()` with a verifiable random selection or remove `FixedProposer` entirely if intended only for testing.

**Option 1: Add VRF-based Selection**
```rust
pub fn choose_leader(peers: Vec<Author>, epoch_seed: &[u8]) -> Author {
    // Use VRF or hash-based selection with epoch entropy
    let seed = hash_combine(epoch_seed, b"fixed_proposer_selection");
    let index = u64::from_le_bytes(seed[..8]) % peers.len() as u64;
    peers[index as usize]
}
```

**Option 2: Remove from Production**
Gate `FixedProposer` behind a test-only feature flag or remove it entirely from the production `ProposerElectionType` enum since it's marked as a temporary hack.

## Proof of Concept
```rust
#[test]
fn test_fixed_proposer_deterministic_selection() {
    use aptos_types::account_address::AccountAddress;
    use consensus::liveness::rotating_proposer_election::choose_leader;
    
    // Create validators with different addresses
    let addr1 = AccountAddress::from_hex_literal("0x1").unwrap();
    let addr2 = AccountAddress::from_hex_literal("0x2").unwrap();
    let addr3 = AccountAddress::from_hex_literal("0xA").unwrap();
    
    let validators = vec![addr3, addr1, addr2]; // Unordered input
    
    // choose_leader always returns minimum address
    let chosen = choose_leader(validators.clone());
    assert_eq!(chosen, addr1); // Always picks 0x1 (minimum)
    
    // Running multiple times produces same result
    for _ in 0..100 {
        assert_eq!(choose_leader(validators.clone()), addr1);
    }
    
    // This validator is now predictably targetable for attacks
    println!("Fixed proposer will always be: {}", chosen);
}
```

## Notes
The codebase contains explicit comments acknowledging this is not production-ready ("tmp hack function"), yet `FixedProposer` remains a valid on-chain configuration option. The comment "We don't really have a fixed proposer!" in `epoch_manager.rs` further indicates awareness of the limitation. However, the security risk emerges when this feature can be activated through governance despite its known weaknesses. [9](#0-8)

### Citations

**File:** consensus/src/liveness/rotating_proposer_election.rs (L7-9)
```rust
/// The rotating proposer maps a round to an author according to a round-robin rotation.
/// A fixed proposer strategy loses liveness when the fixed proposer is down. Rotating proposers
/// won't gather quorum certificates to machine loss/byzantine behavior on f/n rounds.
```

**File:** consensus/src/liveness/rotating_proposer_election.rs (L18-23)
```rust
/// Choose a proposer that is going to be the single leader (relevant for a mock fixed proposer
/// election only).
pub fn choose_leader(peers: Vec<Author>) -> Author {
    // As it is just a tmp hack function, pick the min PeerId to be a proposer.
    peers.into_iter().min().expect("No trusted peers found!")
}
```

**File:** consensus/src/epoch_manager.rs (L292-295)
```rust
        let proposers = epoch_state
            .verifier
            .get_ordered_account_addresses_iter()
            .collect::<Vec<_>>();
```

**File:** consensus/src/epoch_manager.rs (L300-300)
```rust
            // We don't really have a fixed proposer!
```

**File:** consensus/src/epoch_manager.rs (L301-304)
```rust
            ProposerElectionType::FixedProposer(contiguous_rounds) => {
                let proposer = choose_leader(proposers);
                Arc::new(RotatingProposer::new(vec![proposer], *contiguous_rounds))
            },
```

**File:** types/src/validator_verifier.rs (L565-578)
```rust
        let sorted_validator_infos: BTreeMap<u64, ValidatorConsensusInfo> = validator_set
            .payload()
            .map(|info| {
                (
                    info.config().validator_index,
                    ValidatorConsensusInfo::new(
                        info.account_address,
                        info.consensus_public_key().clone(),
                        info.consensus_voting_power(),
                    ),
                )
            })
            .collect();
        let validator_infos: Vec<_> = sorted_validator_infos.values().cloned().collect();
```

**File:** third_party/move/move-core/types/src/account_address.rs (L12-18)
```rust
#[derive(Ord, PartialOrd, Eq, PartialEq, Hash, Clone, Copy)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(proptest_derive::Arbitrary))]
#[cfg_attr(
    any(test, feature = "fuzzing"),
    derive(arbitrary::Arbitrary, dearbitrary::Dearbitrary)
)]
pub struct AccountAddress([u8; AccountAddress::LENGTH]);
```

**File:** types/src/on_chain_config/consensus_config.rs (L510-513)
```rust
pub enum ProposerElectionType {
    // Choose the smallest PeerId as the proposer
    // with specified param contiguous_rounds
    FixedProposer(u32),
```
