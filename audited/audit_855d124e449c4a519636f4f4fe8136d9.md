# Audit Report

## Title
URL Credential Exposure in Transaction Simulation Session Configuration

## Summary
The `BaseState::Remote` struct stores `node_url` as a `Url` type which can contain embedded credentials (e.g., `http://user:apikey@node.com`). These credentials are exposed through multiple vectors: serialized to plaintext in configuration files, logged via `Debug` trait implementations, and included in error messages. This violates security best practices for credential handling that are already implemented elsewhere in the codebase for similar scenarios.

## Finding Description
The transaction simulation session system allows users to fork blockchain state from a remote node by providing a `node_url`. When credentials are embedded in this URL using the standard format (`http://username:password@host`), they are leaked through three primary vectors:

**Vector 1: Plaintext Configuration File** [1](#0-0) 

The configuration is serialized to JSON using `serde_json::to_string_pretty()` and written to disk. The Rust `url::Url` type serializes as a string, preserving embedded credentials in plaintext.

**Vector 2: Debug Trait Logging** [2](#0-1) 

Both `Config` and `BaseState` derive `Debug` without custom implementations to mask credentials. If these structs are logged anywhere in the application, credentials are exposed.

**Vector 3: REST Client URL Logging** [3](#0-2) 

The `path_prefix_string()` method converts `base_url` to string via `.to_string()`, which includes embedded credentials. This is logged in multiple locations: [4](#0-3) [5](#0-4) [6](#0-5) 

**Existing Protection Pattern Not Applied**

The Aptos codebase already implements credential masking for `postgres_uri` in two locations, proving the developers recognize this security issue: [7](#0-6) [8](#0-7) 

This same protective pattern was not applied to `BaseState::Remote` or the REST client.

## Impact Explanation
**Severity: Medium** (as specified in the security question)

While this is classified as an information leak, the impact extends beyond simple disclosure:

1. **Credential Compromise**: Leaked credentials could grant attackers access to privileged API endpoints, potentially allowing them to:
   - Access sensitive blockchain state data
   - Exhaust rate limits affecting legitimate users
   - Pivot to other systems using the same credentials

2. **Session Persistence**: Configuration files persist on disk indefinitely, creating a permanent credential exposure risk accessible to any process with filesystem read access.

3. **Log Aggregation**: In production environments, logs are typically aggregated to centralized systems, expanding the attack surface for credential theft.

4. **Inconsistency with Codebase Standards**: The failure to apply established password masking patterns indicates a gap in security review coverage.

## Likelihood Explanation
**Likelihood: Medium to High**

Users commonly embed API keys or credentials in URLs when:
- Accessing authenticated fullnode endpoints
- Using third-party node providers requiring API authentication
- Following documentation patterns that show URL-based authentication

The likelihood increases because:
- Configuration files are written automatically during session initialization
- Logs are generated during normal operation (transaction waiting, error conditions)
- No warnings are provided about credential exposure risk
- The URL format supports credentials per RFC 3986

## Recommendation
Implement the same credential masking pattern already used for `postgres_uri`:

**For `BaseState` and `Config`:**
```rust
impl Debug for Config {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        let base = match &self.base {
            BaseState::Empty => BaseState::Empty,
            BaseState::Remote { node_url, network_version, api_key } => {
                let mut masked_url = node_url.clone();
                if masked_url.password().is_some() {
                    masked_url.set_password(Some("*")).unwrap();
                }
                if !masked_url.username().is_empty() {
                    masked_url.set_username("*").unwrap();
                }
                BaseState::Remote {
                    node_url: masked_url,
                    network_version: *network_version,
                    api_key: api_key.as_ref().map(|_| "*".to_string()),
                }
            }
        };
        f.debug_struct("Config")
            .field("base", &base)
            .field("ops", &self.ops)
            .finish()
    }
}
```

**For REST Client:** [9](#0-8) 

Implement custom `Debug` for `Client` that masks credentials in `base_url`.

**For Configuration Serialization:**
Consider adding a warning when credentials are detected in URLs, or automatically strip credentials before serialization while preserving them in memory for runtime use.

## Proof of Concept
```rust
#[test]
fn test_url_credential_exposure() {
    use url::Url;
    use aptos_transaction_simulation_session::config::{Config, BaseState};
    
    // Simulate user providing URL with embedded credentials
    let malicious_url = Url::parse("http://apiuser:secret123@evil.com").unwrap();
    let config = Config::with_remote(malicious_url, 1, None);
    
    // Vector 1: Credentials in config file
    let temp_file = tempfile::NamedTempFile::new().unwrap();
    config.save_to_file(temp_file.path()).unwrap();
    let saved_content = std::fs::read_to_string(temp_file.path()).unwrap();
    assert!(saved_content.contains("apiuser:secret123"));
    
    // Vector 2: Credentials in Debug output
    let debug_output = format!("{:?}", config);
    assert!(debug_output.contains("apiuser"));
    assert!(debug_output.contains("secret123"));
    
    println!("EXPOSED in config file: {}", saved_content);
    println!("EXPOSED in debug output: {}", debug_output);
}
```

## Notes
This vulnerability represents an inconsistency in the codebase's security posture. The Aptos team has already recognized and mitigated this exact pattern for PostgreSQL URIs in multiple locations, demonstrating awareness of credential exposure risks. The failure to apply the same protection to transaction simulation session URLs and REST client URLs indicates a gap in security review coverage rather than a fundamental architectural flaw.

The fix is straightforward and follows established patterns within the codebase. Priority should be given to:
1. Implementing custom `Debug` traits for affected types
2. Adding credential detection warnings during URL configuration
3. Conducting a broader audit for similar credential exposure patterns in other URL-handling code

### Citations

**File:** aptos-move/aptos-transaction-simulation-session/src/config.rs (L11-21)
```rust
#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq)]
pub enum BaseState {
    /// No base state; the session is entirely local (e.g., for integration tests or synthetic simulations).
    Empty,
    /// The session starts from a remote network state (a "forked state").
    Remote {
        node_url: Url,
        network_version: u64,
        api_key: Option<String>,
    },
}
```

**File:** aptos-move/aptos-transaction-simulation-session/src/config.rs (L56-59)
```rust
    pub fn save_to_file(&self, path: &std::path::Path) -> Result<()> {
        let json = serde_json::to_string_pretty(self)?;
        std::fs::write(path, json)?;
        Ok(())
```

**File:** crates/aptos-rest-client/src/lib.rs (L80-85)
```rust
#[derive(Clone, Debug)]
pub struct Client {
    inner: ReqwestClient,
    base_url: Url,
    version_path_base: String,
}
```

**File:** crates/aptos-rest-client/src/lib.rs (L138-143)
```rust
    pub fn path_prefix_string(&self) -> String {
        self.base_url
            .join(&self.version_path_base)
            .map(|path| path.to_string())
            .unwrap_or_else(|_| "<bad_base_url>".to_string())
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L811-816)
```rust
                    sample!(
                        SampleRate::Duration(Duration::from_secs(30)),
                        debug!(
                            "Cannot yet find transaction in mempool on {:?}, continuing to wait.",
                            self.path_prefix_string(),
                        )
```

**File:** crates/aptos-rest-client/src/lib.rs (L829-833)
```rust
                        "Ledger on endpoint ({}) is more than {}s behind current time, timing out waiting for the transaction. Warning, transaction ({}) might still succeed.",
                        self.path_prefix_string(),
                        max_server_lag_wait_duration.as_secs(),
                        hash,
                    ).into());
```

**File:** crates/aptos-rest-client/src/lib.rs (L849-854)
```rust
                sample!(
                    SampleRate::Duration(Duration::from_secs(30)),
                    debug!(
                        "Continuing to wait for transaction {}, ledger on endpoint ({}) is {}",
                        hash,
                        self.path_prefix_string(),
```

**File:** config/src/config/indexer_config.rs (L92-117)
```rust
impl Debug for IndexerConfig {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        let postgres_uri = self.postgres_uri.as_ref().map(|u| {
            let mut parsed_url = url::Url::parse(u).expect("Invalid postgres uri");
            if parsed_url.password().is_some() {
                parsed_url.set_password(Some("*")).unwrap();
            }
            parsed_url.to_string()
        });
        f.debug_struct("IndexerConfig")
            .field("enabled", &self.enabled)
            .field("postgres_uri", &postgres_uri)
            .field("processor", &self.processor)
            .field("starting_version", &self.starting_version)
            .field("skip_migrations", &self.skip_migrations)
            .field("check_chain_id", &self.check_chain_id)
            .field("batch_size", &self.batch_size)
            .field("fetch_tasks", &self.fetch_tasks)
            .field("processor_tasks", &self.processor_tasks)
            .field("emit_every", &self.emit_every)
            .field("gap_lookback_versions", &self.gap_lookback_versions)
            .field("ans_contract_address", &self.ans_contract_address)
            .field("nft_points_contract", &self.nft_points_contract)
            .finish()
    }
}
```

**File:** aptos-node/src/logger.rs (L91-99)
```rust
    if let Some(u) = &node_config.indexer.postgres_uri {
        let mut parsed_url = url::Url::parse(u).expect("Invalid postgres uri");
        if parsed_url.password().is_some() {
            masked_config = node_config.clone();
            parsed_url.set_password(Some("*")).unwrap();
            masked_config.indexer.postgres_uri = Some(parsed_url.to_string());
            config = &masked_config;
        }
    }
```
