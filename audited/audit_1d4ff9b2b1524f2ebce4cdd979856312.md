# Audit Report

## Title
Incorrect BV Flag Handling in Move Prover Table Instances Causes Verification Soundness Violation

## Summary
The Move Prover's Boogie backend incorrectly determines the `bv_flag` parameter for table value types when generating verification code. This causes unsigned integer value types (u8, u16, u32, u64, u128, u256) to use unbounded mathematical integer semantics instead of bitvector semantics with wrapping overflow, allowing overflow bugs to pass formal verification.

## Finding Description [1](#0-0) 

The vulnerability exists in the BV (bitvector) table instance generation logic. When determining whether to use bitvector semantics for table value types, the code checks if ALL value types in the type argument set are numbers: [2](#0-1) 

The condition `v_ty.iter().all(|ty| ty.skip_reference().is_number())` returns true only if every value type is a number. The `is_number()` method returns true for both unsigned and signed integers: [3](#0-2) 

**The Problem**: If a Move module uses the same `Table` struct with multiple value types where at least one is NOT a number (e.g., `Table<address, u64>` and `Table<address, bool>`), then:

1. The collected value types are `v_ty = [u64, bool]`
2. The check `v_ty.iter().all(|ty| ty.is_number())` returns `false` (bool is not a number)
3. `bv_flag = false` is set for ALL instances, including the `u64` value type
4. In `MapImpl::new()`, this `bv_flag` is applied uniformly to all value types: [4](#0-3) 

5. When `bv_flag = false` for a `u64` value type, `TypeInfo::new()` uses `boogie_type()` instead of `boogie_bv_type()`: [5](#0-4) 

6. For unsigned integers, `boogie_type()` returns `"int"` (unbounded mathematical integers) instead of `"bv64"` (64-bit bitvectors): [6](#0-5) 

7. The generated Boogie code uses the wrong type representation: [7](#0-6) 

**Semantic Mismatch**: 
- Boogie `int` type: Unbounded mathematical integers with no overflow
- Move `u64` runtime: 64-bit wrapping arithmetic with overflow
- This mismatch allows overflow bugs to pass verification but fail at runtime

**Contrast with Correct Handling**: For general types, the code explicitly filters signed integers before creating BV instances: [8](#0-7) 

However, this per-type filtering logic is missing for table instances.

## Impact Explanation

This is a **High Severity - Verification Soundness** issue but does NOT meet the Aptos bug bounty criteria because:

**Why it's NOT a valid bounty finding:**
- The Move Prover is a development-time static analysis tool, not a runtime component
- It doesn't affect blockchain consensus, state management, or transaction execution
- No direct impact on funds, availability, or protocol invariants
- The impact is indirect: developers might deploy contracts with overflow bugs because the prover incorrectly verified them

The bug bounty categories focus exclusively on runtime impacts (consensus violations, funds loss, validator node issues), which don't apply to verification tooling bugs.

## Likelihood Explanation

**For occurring in code**: High
- Any Move module using `Table` with mixed value types (numeric and non-numeric) triggers the bug
- Common pattern: storing both data (u64) and flags (bool) in separate tables

**For causing actual harm**: Low
- Requires developers to rely on Move Prover for safety guarantees
- Requires the verified contract to have actual overflow vulnerabilities
- Requires the vulnerable contract to be deployed and exploited

## Recommendation

Fix the `bv_flag` determination logic to be per-value-type instead of global: [1](#0-0) 

The corrected logic should determine `bv_flag` individually for each value type, similar to how general types are handled. Each value type should get `bv_flag=true` only if it's an unsigned integer, not based on whether ALL value types are numbers.

## Proof of Concept

**Move code that triggers the bug:**

```move
module 0x42::vulnerable_table {
    use std::table::{Self, Table};
    
    struct MixedStorage has key {
        data: Table<address, u64>,    // u64 values - should use bv64
        flags: Table<address, bool>,   // bool values - should use int
    }
    
    // This function has an overflow bug
    fun unsafe_add(storage: &mut MixedStorage, addr: address, amount: u64) {
        let current = table::borrow_mut(&mut storage.data, addr);
        *current = *current + amount;  // Can overflow!
    }
    
    spec unsafe_add {
        // This specification should fail but will pass verification
        // because u64 is verified as unbounded int instead of bv64
        ensures table::spec_get(storage.data, addr) == 
                old(table::spec_get(storage.data, addr)) + amount;
    }
}
```

When the Move Prover generates Boogie code for this module, the `Table<address, u64>` instance will incorrectly use `"int"` type instead of `"bv64"`, causing overflow verification to be unsound.

---

**Note**: While this is a genuine bug in the Move Prover's code generation logic, it does not meet the strict validation criteria for the Aptos bug bounty program as it is a development tool issue rather than a runtime protocol vulnerability.

### Citations

**File:** third_party/move/move-prover/boogie-backend/src/lib.rs (L203-212)
```rust
    let mut bv_all_types = mono_info
        .all_types
        .iter()
        .filter(|ty| ty.can_be_type_argument() && !ty.is_signed_int())
        .map(|ty| TypeInfo::new(env, options, ty, true))
        .filter(|ty_info| !all_types.contains(ty_info))
        .collect::<BTreeSet<_>>()
        .into_iter()
        .collect_vec();
    all_types.append(&mut bv_all_types);
```

**File:** third_party/move/move-prover/boogie-backend/src/lib.rs (L258-270)
```rust
        let mut bv_table_instances = mono_info
            .table_inst
            .iter()
            .map(|(qid, ty_args)| {
                let v_ty = ty_args.iter().map(|(_, vty)| vty).collect_vec();
                let bv_flag = v_ty.iter().all(|ty| ty.skip_reference().is_number());
                MapImpl::new(env, options, *qid, ty_args, bv_flag)
            })
            .filter(|map_impl| !table_instances.contains(map_impl))
            .collect_vec();
        vec_instances.append(&mut bv_vec_instances);
        table_instances.append(&mut bv_table_instances);
    }
```

**File:** third_party/move/move-prover/boogie-backend/src/lib.rs (L426-433)
```rust
    fn new(env: &GlobalEnv, options: &BoogieOptions, ty: &Type, bv_flag: bool) -> Self {
        let name_fun = if bv_flag { boogie_bv_type } else { boogie_type };
        Self {
            name: name_fun(env, ty),
            suffix: boogie_type_suffix_bv(env, ty, bv_flag),
            has_native_equality: has_native_equality(env, options, ty),
        }
    }
```

**File:** third_party/move/move-prover/boogie-backend/src/lib.rs (L444-452)
```rust
        let insts = ty_args
            .iter()
            .map(|(kty, vty)| {
                (
                    TypeInfo::new(env, options, kty, false),
                    TypeInfo::new(env, options, vty, bv_flag),
                )
            })
            .collect();
```

**File:** third_party/move/move-model/src/ty.rs (L1220-1240)
```rust
    pub fn is_number(&self) -> bool {
        if let Type::Primitive(p) = self {
            if let PrimitiveType::U8
            | PrimitiveType::U16
            | PrimitiveType::U32
            | PrimitiveType::U64
            | PrimitiveType::U128
            | PrimitiveType::U256
            | PrimitiveType::I8
            | PrimitiveType::I16
            | PrimitiveType::I32
            | PrimitiveType::I64
            | PrimitiveType::I128
            | PrimitiveType::I256
            | PrimitiveType::Num = p
            {
                return true;
            }
        }
        false
    }
```

**File:** third_party/move/move-prover/boogie-backend/src/boogie_helpers.rs (L337-357)
```rust
pub fn boogie_type(env: &GlobalEnv, ty: &Type) -> String {
    use PrimitiveType::*;
    use Type::*;
    match ty {
        Primitive(p) => match p {
            U8 | U16 | U32 | U64 | U128 | U256 | I8 | I16 | I32 | I64 | I128 | I256 | Num
            | Address => "int".to_string(),
            Signer => "$signer".to_string(),
            Bool => "bool".to_string(),
            Range | EventStore => panic!("unexpected type"),
        },
        Vector(et) => format!("Vec ({})", boogie_type(env, et)),
        Struct(mid, sid, inst) => boogie_struct_name(&env.get_module(*mid).into_struct(*sid), inst),
        Reference(_, bt) => format!("$Mutation ({})", boogie_type(env, bt)),
        TypeParameter(idx) => boogie_type_param(env, *idx),
        Fun(param, result, abilities) => fun_type(env, param, result, *abilities),
        Tuple(..) | TypeDomain(..) | ResourceDomain(..) | Error | Var(..) => {
            format!("<<unsupported: {:?}>>", ty)
        },
    }
}
```

**File:** third_party/move/move-prover/boogie-backend/src/prelude/native.bpl (L348-375)
```text
{% macro table_module(impl, instance) %}
{%- set K = instance.0.name -%}
{%- set V = instance.1.name -%}
{%- set Type = impl.struct_name -%}
{%- set Self = "Table int (" ~ V ~ ")" -%}
{%- set S = "'" ~ instance.0.suffix ~ "_" ~ instance.1.suffix ~ "'" -%}
{%- set SV = "'" ~ instance.1.suffix ~ "'" -%}
{%- set ENC = "$EncodeKey'" ~ instance.0.suffix ~ "'" -%}

{%- if options.native_equality -%}
function $IsEqual'{{Type}}{{S}}'(t1: {{Self}}, t2: {{Self}}): bool {
    t1 == t2
}
{%- else -%}
function $IsEqual'{{Type}}{{S}}'(t1: {{Self}}, t2: {{Self}}): bool {
    LenTable(t1) == LenTable(t2) &&
    (forall k: int :: ContainsTable(t1, k) <==> ContainsTable(t2, k)) &&
    (forall k: int :: ContainsTable(t1, k) ==> GetTable(t1, k) == GetTable(t2, k)) &&
    (forall k: int :: ContainsTable(t2, k) ==> GetTable(t1, k) == GetTable(t2, k))
}
{%- endif %}

// Not inlined.
function $IsValid'{{Type}}{{S}}'(t: {{Self}}): bool {
    $IsValid'u64'(LenTable(t)) &&
    (forall i: int:: ContainsTable(t, i) ==> $IsValid{{SV}}(GetTable(t, i)))
}

```
