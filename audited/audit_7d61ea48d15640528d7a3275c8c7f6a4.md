# Audit Report

## Title
Symbolic Link Exploitation in StateKvDb Checkpoint Creation Enables State Data Exfiltration

## Summary
The `StateKvDb::create_checkpoint()` function uses silent error handling (`unwrap_or(())`) when removing and creating checkpoint directories, which allows pre-existing symbolic links to persist. Combined with the lack of symlink validation, an attacker with write access to the checkpoint directory can redirect checkpoint data to arbitrary locations, enabling complete state database exfiltration.

## Finding Description

The vulnerability exists in the checkpoint creation process where directory cleanup and creation errors are silently ignored. [1](#0-0) 

The attack flow proceeds as follows:

**Step 1: Attacker Setup**
An attacker with write access to the checkpoint directory pre-creates symbolic links at the expected checkpoint subdirectory paths:
- `cp_root_path/state_kv_db/metadata` → `/attacker/exfil/metadata`
- `cp_root_path/state_kv_db/shard_0` → `/attacker/exfil/shard_0`
- ... through `shard_15`

**Step 2: Checkpoint Creation Triggered**
When checkpoint creation is invoked (via db-tool or automated backup), the following occurs: [2](#0-1) 

The `remove_dir_all` operation may fail to remove the directory containing symlinks due to:
- Permission restrictions on the target directories
- Filesystem-specific symlink handling
- Concurrent access by another process
- Immutable file attributes

Because the error is silently ignored via `unwrap_or(())`, execution continues with the symlinks still in place.

**Step 3: Data Exfiltration**
The `create_dir_all` operation succeeds if the parent directory already exists, without removing existing symlink contents. When RocksDB's checkpoint mechanism is invoked for each database component, it follows the symbolic links and writes checkpoint data (hard links and copies) to the attacker-controlled locations.

The metadata database and all 16 state KV shards are written through the symlinks, exfiltrating the complete state database containing:
- All account states and balances
- Smart contract storage data  
- Resource values
- Historical state information

This same pattern exists in related checkpoint functions: [3](#0-2) 

The vulnerability breaks the **Access Control** security invariant: system addresses and state data should be protected from unauthorized access.

## Impact Explanation

This qualifies as **Medium Severity** ($10,000 impact category) under the Aptos bug bounty program for the following reasons:

1. **State Inconsistencies**: Enables unauthorized access to complete state database contents, violating data confidentiality guarantees

2. **Limited Privilege Escalation**: Allows an attacker with write access to the checkpoint directory (but not read access to the main database) to exfiltrate state data to a location where they have read permissions

3. **Information Disclosure**: Exposes sensitive blockchain state including:
   - All account balances and resource values
   - Private smart contract state
   - Validator states and configurations
   - Historical state data across all 16 shards

While this does not directly cause fund loss or consensus violations (which would be Critical severity), it enables significant security breaches by exposing the entire state database to unauthorized parties.

## Likelihood Explanation

**Likelihood: Low to Medium**

The attack requires specific preconditions:
1. **Write Access**: Attacker must have write access to the checkpoint directory before checkpoint creation
2. **Timing**: Must create symlinks before checkpoint runs OR cause `remove_dir_all` to fail
3. **Configuration**: Requires a security configuration where checkpoint directory is writable but main database is not readable by the attacker

Realistic attack scenarios include:
- **Compromised backup process**: A separate backup user/process with checkpoint write permissions but limited database read access
- **Container escape**: In containerized deployments, an attacker escaping the container might gain write access to mounted checkpoint volumes
- **Privilege escalation**: Exploiting another vulnerability to gain limited filesystem access
- **Misconfigured permissions**: Incorrect directory permissions allowing untrusted processes to write to checkpoint paths

The `create_checkpoint` function is exposed through: [4](#0-3) 

And is accessible via the db-tool administrative interface: [5](#0-4) 

## Recommendation

**Immediate Fix:**
1. **Validate paths for symlinks** before checkpoint creation
2. **Propagate errors** instead of silently ignoring them
3. **Canonicalize paths** to detect and reject symlink components

**Recommended Code Fix:**
```rust
pub(crate) fn create_checkpoint(
    db_root_path: impl AsRef<Path>,
    cp_root_path: impl AsRef<Path>,
) -> Result<()> {
    let state_kv_db = Self::open_sharded(
        &StorageDirPaths::from_path(db_root_path),
        RocksdbConfig::default(),
        None,
        None,
        false,
    )?;
    let cp_state_kv_db_path = cp_root_path.as_ref().join(STATE_KV_DB_FOLDER_NAME);

    info!("Creating state_kv_db checkpoint at: {cp_state_kv_db_path:?}");

    // Validate the checkpoint path doesn't contain symlinks
    if let Ok(canonical) = cp_state_kv_db_path.canonicalize() {
        if canonical != cp_state_kv_db_path {
            return Err(AptosDbError::Other(
                "Checkpoint path contains symbolic links".to_string()
            ));
        }
    }

    // Propagate errors instead of silently ignoring them
    if cp_state_kv_db_path.exists() {
        std::fs::remove_dir_all(&cp_state_kv_db_path)?;
    }
    std::fs::create_dir_all(&cp_state_kv_db_path)?;

    // Verify no symlinks were created in race window
    for entry in std::fs::read_dir(&cp_state_kv_db_path)? {
        let entry = entry?;
        if entry.file_type()?.is_symlink() {
            return Err(AptosDbError::Other(
                "Symbolic link detected in checkpoint directory".to_string()
            ));
        }
    }

    state_kv_db
        .metadata_db()
        .create_checkpoint(Self::metadata_db_path(cp_root_path.as_ref()))?;

    for shard_id in 0..NUM_STATE_SHARDS {
        state_kv_db
            .db_shard(shard_id)
            .create_checkpoint(Self::db_shard_path(
                cp_root_path.as_ref(),
                shard_id,
                /* is_hot = */ false,
            ))?;
    }

    Ok(())
}
```

**Additional Recommendations:**
- Apply the same fix to `LedgerDb::create_checkpoint()` and `StateMerkleDb::create_checkpoint()`
- Add filesystem permission checks to ensure checkpoint directories have restrictive permissions (0700)
- Implement mandatory access control (MAC) policies restricting checkpoint directory access
- Add audit logging when checkpoint creation occurs

## Proof of Concept

```rust
#[cfg(test)]
mod symlink_exploit_test {
    use super::*;
    use std::os::unix::fs::symlink;
    use tempfile::TempDir;

    #[test]
    fn test_symlink_checkpoint_exfiltration() {
        // Setup: Create source database
        let source_dir = TempDir::new().unwrap();
        let db = StateKvDb::open_sharded(
            &StorageDirPaths::from_path(source_dir.path()),
            RocksdbConfig::default(),
            None,
            None,
            false,
        ).unwrap();
        
        // Write test data to database
        let mut batch = db.new_sharded_native_batches();
        // ... populate with state data ...
        db.commit(0, None, batch).unwrap();

        // Attack: Create malicious checkpoint directory with symlinks
        let checkpoint_dir = TempDir::new().unwrap();
        let exfil_dir = TempDir::new().unwrap();
        
        let checkpoint_state_kv = checkpoint_dir.path().join("state_kv_db");
        std::fs::create_dir_all(&checkpoint_state_kv).unwrap();
        
        // Create symlink to attacker-controlled location
        let exfil_metadata = exfil_dir.path().join("metadata");
        symlink(&exfil_metadata, checkpoint_state_kv.join("metadata")).unwrap();
        
        for shard_id in 0..NUM_STATE_SHARDS {
            let exfil_shard = exfil_dir.path().join(format!("shard_{}", shard_id));
            symlink(&exfil_shard, checkpoint_state_kv.join(format!("shard_{}", shard_id))).unwrap();
        }

        // Execute: Create checkpoint (vulnerable code)
        StateKvDb::create_checkpoint(source_dir.path(), checkpoint_dir.path()).unwrap();

        // Verify: Data was written to exfiltration directory instead of checkpoint directory
        assert!(exfil_metadata.exists(), "Data exfiltrated to symlink target");
        assert!(exfil_dir.path().join("shard_0").exists(), "Shard data exfiltrated");
        
        // The checkpoint followed symlinks, writing state database to attacker location
        // Attacker can now read all blockchain state from exfil_dir
    }
}
```

**Notes:**
- This vulnerability requires the attacker to have write access to the checkpoint directory, which typically requires local access to the validator node filesystem
- The threat model assumes a privilege escalation scenario where the attacker has limited write permissions but seeks to exfiltrate protected database contents
- The same vulnerability pattern exists in `LedgerDb` and `StateMerkleDb` checkpoint functions, broadening the attack surface
- RocksDB's checkpoint mechanism uses hard links for efficiency, which will follow symbolic link targets in the destination path per standard POSIX behavior

### Citations

**File:** storage/aptosdb/src/state_kv_db.rs (L224-259)
```rust
    pub(crate) fn create_checkpoint(
        db_root_path: impl AsRef<Path>,
        cp_root_path: impl AsRef<Path>,
    ) -> Result<()> {
        // TODO(grao): Support path override here.
        let state_kv_db = Self::open_sharded(
            &StorageDirPaths::from_path(db_root_path),
            RocksdbConfig::default(),
            None,
            None,
            false,
        )?;
        let cp_state_kv_db_path = cp_root_path.as_ref().join(STATE_KV_DB_FOLDER_NAME);

        info!("Creating state_kv_db checkpoint at: {cp_state_kv_db_path:?}");

        std::fs::remove_dir_all(&cp_state_kv_db_path).unwrap_or(());
        std::fs::create_dir_all(&cp_state_kv_db_path).unwrap_or(());

        state_kv_db
            .metadata_db()
            .create_checkpoint(Self::metadata_db_path(cp_root_path.as_ref()))?;

        // TODO(HotState): should handle hot state as well.
        for shard_id in 0..NUM_STATE_SHARDS {
            state_kv_db
                .db_shard(shard_id)
                .create_checkpoint(Self::db_shard_path(
                    cp_root_path.as_ref(),
                    shard_id,
                    /* is_hot = */ false,
                ))?;
        }

        Ok(())
    }
```

**File:** storage/aptosdb/src/ledger_db/mod.rs (L336-336)
```rust
        std::fs::remove_dir_all(&cp_ledger_db_folder).unwrap_or(());
```

**File:** storage/aptosdb/src/db/mod.rs (L172-183)
```rust
    pub fn create_checkpoint(
        db_path: impl AsRef<Path>,
        cp_path: impl AsRef<Path>,
        sharding: bool,
    ) -> Result<()> {
        let start = Instant::now();

        info!(sharding = sharding, "Creating checkpoint for AptosDB.");

        LedgerDb::create_checkpoint(db_path.as_ref(), cp_path.as_ref(), sharding)?;
        if sharding {
            StateKvDb::create_checkpoint(db_path.as_ref(), cp_path.as_ref())?;
```

**File:** storage/db-tool/src/lib.rs (L34-34)
```rust
    Debug(db_debugger::Cmd),
```
