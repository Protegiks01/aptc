# Audit Report

## Title
Transaction Censorship Bypass in TPS Checker Allows Malicious Nodes to Fake Performance Metrics

## Summary
The TPS checker in the Aptos node-checker uses identifiable transaction sources that allow a malicious target node to selectively process only checker transactions while censoring real user traffic, thereby achieving high TPS scores in testing while providing low throughput in production.

## Finding Description

The TPS checker measures node performance by submitting transactions from a configured coin source account and measuring their commitment rate. However, this design has a critical flaw: the transaction sources are easily identifiable, allowing a malicious node operator to selectively process only the checker's transactions.

**Attack Flow:**

1. **Transaction Source Identification**: The TPS checker uses a configured coin source account specified in the baseline configuration. [1](#0-0) 

The checker creates a cluster targeting only the node being tested. [2](#0-1) 

2. **Predictable Account Generation**: All test accounts are funded from this single coin source in a burst pattern, making them easily identifiable by observing on-chain transactions. [3](#0-2) 

3. **Selective Transaction Processing**: A malicious node operator can modify their mempool's transaction selection logic to filter by sender address. The `get_batch()` function has no fairness requirements and simply iterates transactions by gas price. [4](#0-3) 

A malicious operator could add filtering logic to prioritize or exclusively select transactions from identified checker accounts while dropping or delaying other user transactions.

4. **Measurement Against Same Node**: The checker verifies commitment by querying sequence numbers from the same target node cluster. [5](#0-4) 

The commitment tracking queries the same client instances. [6](#0-5) 

5. **High TPS Score Achieved**: The checker measures committed rate and compares against minimum requirements. [7](#0-6) 

Since only checker transactions are processed, the node achieves high TPS scores while censoring real user traffic.

## Impact Explanation

This vulnerability allows malicious or underperforming node operators to bypass performance monitoring and appear compliant while actually censoring user transactions. This falls under **High Severity** per the Aptos bug bounty program as it enables "Significant protocol violations" where validator performance requirements can be circumvented.

The impact includes:
- Malicious nodes can pass TPS checks fraudulently
- Network reliability is compromised if such nodes become validators
- Real users experience transaction censorship
- Network monitoring and quality assurance mechanisms are undermined

## Likelihood Explanation

**Likelihood: HIGH**

The attack is trivial to execute:
1. Node operators have full control over their node software
2. Identifying checker accounts requires only observing funding transactions from the known coin source
3. Modifying `get_batch()` to filter by sender requires minimal code changes (< 10 lines)
4. The attack is undetectable by the current checker implementation
5. Operators have strong incentive to pass validation checks to qualify as validators

## Recommendation

Implement multiple layers of defense:

1. **Randomize Transaction Sources**: Don't use a single identifiable coin source. Generate test accounts from multiple sources with random timing to prevent pattern recognition.

2. **Anonymous Transaction Mixing**: Mix checker transactions with transactions from unrelated accounts (or better yet, sample real network traffic patterns).

3. **Independent Verification**: Query commitment status from multiple independent fullnodes or validators, not just the target node.

4. **Temporal Variance**: Submit transactions in waves with varying patterns rather than bursts, making identification harder.

5. **Cross-Validation**: Simultaneously monitor the target node's processing of real user transactions by sampling the network.

Example mitigation in TpsCheckerConfig:
```rust
pub struct TpsCheckerConfig {
    // Add multiple coin sources instead of one
    pub coin_source_args: Vec<CoinSourceArgs>,
    
    // Add independent verification nodes
    pub verification_nodes: Option<Vec<Url>>,
    
    // Add randomization parameters
    pub randomize_timing: bool,
    pub mix_with_background_traffic: bool,
}
```

## Proof of Concept

**Attack Implementation (for security research only):**

```rust
// Modified mempool/src/core_mempool/mempool.rs::get_batch()
// Add before line 449:

// Malicious modification - identify and prioritize checker accounts
let checker_accounts: HashSet<AccountAddress> = self.identify_checker_accounts();

for txn in self.transactions.iter_queue() {
    // Skip non-checker transactions
    if !checker_accounts.contains(&txn.address) {
        continue; // Censor user transactions
    }
    // ... rest of original logic
}
```

**Detection Method:**

```rust
// In the malicious node, identify checker accounts by tracking:
// 1. Burst funding patterns from known coin source
// 2. Accounts created within short time window  
// 3. High transaction rate immediately after funding

fn identify_checker_accounts(&self) -> HashSet<AccountAddress> {
    // Monitor recent funding transactions
    // from known coin sources
    // Return set of funded accounts
}
```

**Validation:**
1. Deploy modified node with selective processing logic
2. Run TPS checker against the modified node
3. Observe checker reports high TPS (e.g., > 1000 TPS)
4. Submit transactions from regular user accounts
5. Observe these transactions are dropped or severely delayed
6. The checker does not detect the censorship

This demonstrates that the node-checker cannot distinguish between a node serving all users fairly versus one selectively processing only test traffic.

### Citations

**File:** ecosystem/node-checker/src/checker/tps.rs (L62-66)
```rust
    // Ed25519PrivateKey, either on the CLI or from a file, for minting coins.
    // We choose to take this in in the baseline config because we can't
    // securely transmit this at request time over the wire.
    #[serde(flatten)]
    pub coin_source_args: CoinSourceArgs,
```

**File:** ecosystem/node-checker/src/checker/tps.rs (L130-136)
```rust
        let cluster_config = ClusterArgs {
            targets: Some(vec![target_url; self.config.repeat_target_count]),
            targets_file: None,
            coin_source_args: self.config.coin_source_args.clone(),
            chain_id: Some(chain_id),
            node_api_key: None,
        };
```

**File:** ecosystem/node-checker/src/checker/tps.rs (L164-177)
```rust
        let evaluation_result = if rate.committed >= (self.config.minimum_tps as f64) {
            if stats.committed == stats.submitted {
                description.push_str(
                    " Your node could theoretically hit \
                even higher TPS, the evaluation suite only tests to check \
                your node meets the minimum requirements.",
                );
            }
            Self::build_result(
                "Transaction processing speed is sufficient".to_string(),
                100,
                description,
            )
        } else {
```

**File:** crates/transaction-emitter-lib/src/emitter/account_minter.rs (L613-620)
```rust
    let seed = config.seed.unwrap_or_else(|| {
        let mut rng = StdRng::from_entropy();
        rng.r#gen()
    });
    info!(
        "AccountMinter Seed (reuse accounts by passing into --account-minter-seed): {:?}",
        seed
    );
```

**File:** mempool/src/core_mempool/mempool.rs (L425-456)
```rust
    pub(crate) fn get_batch(
        &self,
        max_txns: u64,
        max_bytes: u64,
        return_non_full: bool,
        exclude_transactions: BTreeMap<TransactionSummary, TransactionInProgress>,
    ) -> Vec<SignedTransaction> {
        let start_time = Instant::now();
        let exclude_size = exclude_transactions.len();
        let mut inserted = HashSet::new();

        let gas_end_time = start_time.elapsed();

        let mut result = vec![];
        // Helper DS. Helps to mitigate scenarios where account submits several transactions
        // with increasing gas price (e.g. user submits transactions with sequence number 1, 2
        // and gas_price 1, 10 respectively)
        // Later txn has higher gas price and will be observed first in priority index iterator,
        // but can't be executed before first txn. Once observed, such txn will be saved in
        // `skipped` DS and rechecked once it's ancestor becomes available
        let mut skipped = HashSet::new();
        let mut total_bytes = 0;
        let mut txn_walked = 0usize;
        // iterate over the queue of transactions based on gas price
        'main: for txn in self.transactions.iter_queue() {
            txn_walked += 1;
            let txn_ptr = TxnPointer::from(txn);

            // TODO: removed gas upgraded logic. double check if it's needed
            if exclude_transactions.contains_key(&txn_ptr) {
                continue;
            }
```

**File:** crates/transaction-emitter-lib/src/wrappers.rs (L90-91)
```rust
    let client = cluster.random_instance().rest_client();
    let coin_source_account = cluster.load_coin_source_account(&client).await?;
```

**File:** crates/transaction-emitter-lib/src/emitter/mod.rs (L1104-1110)
```rust
async fn wait_for_accounts_sequence(
    start_time: Instant,
    client: &RestClient,
    account_seqs: &HashMap<AccountAddress, (u64, u64)>,
    txn_expiration_ts_secs: u64,
    sleep_between_cycles: Duration,
) -> (HashMap<AccountAddress, u64>, u128) {
```
