# Audit Report

## Title
Path Traversal in ReleaseConfig Processing Enables Arbitrary File Read and Governance Proposal Manipulation

## Summary
The `components` module fails to validate file paths in `ReleaseEntry::RawScript` and `GasScheduleLocator::LocalFile`, allowing path traversal attacks that can read arbitrary files from the filesystem and embed their contents into governance proposals. This bypasses the static configuration security model.

## Finding Description

The release-builder components module processes `ReleaseConfig` entries without proper path validation, violating the security guarantee that only explicitly specified scripts should be included in governance proposals.

**Vulnerability Location:**

The `ReleaseEntry::RawScript` handler constructs file paths without validation: [1](#0-0) 

The path is constructed by joining `aptos_core_path()` with the user-provided `script_path` from the YAML configuration, with no validation that the resulting path remains within the intended directory.

**Root Cause Analysis:**

1. The `ReleaseConfig::parse` function only performs YAML deserialization without validation: [2](#0-1) 

2. The static `CURRENT_RELEASE_CONFIG` is parsed from an embedded YAML without validation: [3](#0-2) 

3. The `aptos_core_path` can be overridden without validation: [4](#0-3) 

4. Path normalization utilities exist in the codebase but are NOT used: [5](#0-4) 

**Exploitation Path:**

1. Attacker crafts malicious `release.yaml`:
```yaml
proposals:
  - name: malicious_proposal
    execution_mode: MultiStep
    update_sequence:
      - RawScript: ../../../../etc/passwd
```

2. When processed via CLI: [6](#0-5) 

3. The path traversal occurs at `PathBuf::join()` which does NOT prevent directory escape with `../` sequences

4. Arbitrary file content is read and embedded into governance proposal scripts

**Secondary Vulnerability:**

The same issue affects `GasScheduleLocator::LocalFile`: [7](#0-6) 

## Impact Explanation

**Severity: HIGH** - Significant Protocol Violation

This vulnerability enables multiple attack vectors:

1. **Information Disclosure**: Arbitrary file read from the filesystem where release-builder executes
   - In CI/CD environments: leakage of secrets, API keys, private keys
   - Could expose validator credentials, deployment keys, or sensitive configuration

2. **Governance Proposal Integrity Violation**: Malicious content injection into governance proposals
   - File contents embedded in Move scripts submitted to governance
   - Bypasses the intended constraint that only approved scripts are included
   - Could cause proposal compilation failures or unexpected behavior

3. **Supply Chain Attack Vector**: If release configs are stored in git repositories
   - Malicious contributor submits PR with path traversal
   - CI/CD automatically processes the config
   - Secrets leaked through proposal generation logs or outputs
   - Leaked credentials could lead to validator compromise or fund theft

While this vulnerability doesn't directly affect consensus or the Move VM runtime, it compromises the **integrity of the governance upgrade process**, which is critical infrastructure for protocol evolution. The leaked credentials could enable **Critical severity** attacks (validator compromise, fund theft).

## Likelihood Explanation

**High Likelihood** in CI/CD environments:

1. Release configurations are typically stored in version control systems
2. CI/CD pipelines commonly auto-process configuration files
3. Path traversal is a well-known attack technique
4. No validation creates a wide attack surface
5. Attacker only needs ability to submit configuration files (e.g., via PR)

**Low Likelihood** for local execution:
- Local attackers already have filesystem access
- No additional security boundary crossed

The CI/CD scenario is the primary concern, where automated processing of untrusted configuration files creates exploitable conditions.

## Recommendation

Implement strict path validation using the existing `NormalizedPath` utilities:

```rust
// In aptos-move/aptos-release-builder/src/components/mod.rs
use move_package_resolver::path::NormalizedPath;

ReleaseEntry::RawScript(script_path) => {
    // Normalize and validate the path
    let normalized = NormalizedPath::new(script_path.as_path());
    
    // Ensure path doesn't escape aptos_core_path
    if normalized.components().any(|c| matches!(c, Component::ParentDir)) {
        bail!("RawScript path must not contain parent directory references: {:?}", script_path);
    }
    
    let base_path = aptos_core_path().join(normalized.as_ref());
    
    // Additional validation: ensure resolved path is within aptos_core_path
    let canonical_base = aptos_core_path().canonicalize()?;
    let canonical_script = base_path.canonicalize()
        .with_context(|| format!("Script path does not exist: {:?}", script_path))?;
    
    if !canonical_script.starts_with(&canonical_base) {
        bail!("RawScript path must be within aptos-core directory: {:?}", script_path);
    }
    
    // Rest of existing logic...
}
```

Apply similar validation to:
1. `GasScheduleLocator::LocalFile` path handling
2. Any user-provided file paths in ReleaseConfig entries
3. The `initialize_aptos_core_path` override parameter

## Proof of Concept

```rust
#[test]
fn test_path_traversal_rawscript() {
    use std::fs;
    use std::path::PathBuf;
    use tempfile::TempDir;
    
    // Create temp directory structure
    let temp_dir = TempDir::new().unwrap();
    let secret_file = temp_dir.path().join("secret.txt");
    fs::write(&secret_file, "SENSITIVE_API_KEY=secret123").unwrap();
    
    // Create malicious YAML config with path traversal
    let malicious_yaml = format!(r#"
name: "exploit"
remote_endpoint: ~
proposals:
  - name: path_traversal_test
    metadata:
      title: "Exploit"
      description: "Path traversal test"
    execution_mode: MultiStep
    update_sequence:
      - RawScript: ../../../{}
"#, secret_file.display());
    
    // Parse the config
    let config = ReleaseConfig::parse(&malicious_yaml).unwrap();
    
    // Attempt to generate proposals - this will read the secret file
    let output_dir = temp_dir.path().join("output");
    fs::create_dir(&output_dir).unwrap();
    
    // This should FAIL with proper validation
    // Currently SUCCEEDS, reading arbitrary file
    let result = futures::executor::block_on(async {
        config.generate_release_proposal_scripts(&output_dir).await
    });
    
    // Verify the secret was leaked into the generated proposal
    if result.is_ok() {
        let proposal_path = output_dir.join("sources/exploit/path_traversal_test");
        let generated_files: Vec<_> = fs::read_dir(&proposal_path)
            .unwrap()
            .filter_map(|e| e.ok())
            .collect();
        
        // Check if secret content appears in generated scripts
        for entry in generated_files {
            let content = fs::read_to_string(entry.path()).unwrap();
            assert!(
                !content.contains("SENSITIVE_API_KEY"),
                "VULNERABILITY: Secret file content leaked into governance proposal!"
            );
        }
    }
}
```

**Notes**

This vulnerability specifically affects the governance proposal generation tooling, not the runtime blockchain protocol. However, it violates the **Governance Integrity** invariant by allowing unauthorized content injection into governance proposals and creates a **supply chain attack vector** that could compromise validator operations through credential leakage. The path validation utilities (`NormalizedPath`, `CanonicalPath`) already exist in the codebase but are not used in the critical `ReleaseEntry` processing paths.

### Citations

**File:** aptos-move/aptos-release-builder/src/components/mod.rs (L200-203)
```rust
            GasScheduleLocator::LocalFile(path) => {
                let file_contents = fs::read_to_string(path)?;
                let gas_schedule: GasScheduleV2 = serde_json::from_str(&file_contents)?;
                Ok(gas_schedule)
```

**File:** aptos-move/aptos-release-builder/src/components/mod.rs (L377-387)
```rust
            ReleaseEntry::RawScript(script_path) => {
                let base_path = aptos_core_path().join(script_path.as_path());
                let file_name = base_path
                    .file_name()
                    .and_then(|name| name.to_str())
                    .ok_or_else(|| {
                        anyhow!("Unable to obtain file name for proposal: {:?}", script_path)
                    })?
                    .to_string();
                let file_content = std::fs::read_to_string(base_path)
                    .with_context(|| format!("Unable to read file: {}", script_path.display()))?;
```

**File:** aptos-move/aptos-release-builder/src/components/mod.rs (L751-753)
```rust
    pub fn parse(serialized: &str) -> Result<Self> {
        serde_yaml::from_str(serialized).map_err(|e| anyhow!("Failed to parse the config: {:?}", e))
    }
```

**File:** aptos-move/aptos-release-builder/src/lib.rs (L17-20)
```rust
const RELEASE_CONFIG: &str = include_str!("../data/release.yaml");

static CURRENT_RELEASE_CONFIG: Lazy<ReleaseConfig> =
    Lazy::new(|| ReleaseConfig::parse(RELEASE_CONFIG).expect("YAML NOT PARSABLE"));
```

**File:** aptos-move/aptos-release-builder/src/lib.rs (L37-44)
```rust
pub fn initialize_aptos_core_path(overriden_path: Option<PathBuf>) {
    if let Some(path) = overriden_path {
        APTOS_CORE_PATH.set(path).unwrap();
    } else {
        APTOS_CORE_PATH
            .set(aptos_core_path_at_compile_time())
            .unwrap();
    };
```

**File:** third_party/move/tools/move-package-resolver/src/path.rs (L36-71)
```rust
/// Normalizes a path by removing all redundant `..` and `.` components.
/// Accepts both relative and absolute paths as input.
///
/// Examples:
/// - `./foo` -> `foo`
/// - `a/b/../c` -> `a/c`
/// - `/foo/../..` -> `/`
/// - `a/../../b` -> `../b`
fn normalize_path(path: impl AsRef<Path>) -> PathBuf {
    let path = path.as_ref();
    let mut stack = vec![];

    for component in path.components() {
        match &component {
            Component::CurDir => (),
            Component::ParentDir => match stack.last() {
                Some(Component::Prefix(_) | Component::RootDir) => (),
                Some(Component::Normal(_)) => {
                    stack.pop();
                },
                Some(Component::ParentDir) | None => {
                    stack.push(component);
                },
                Some(Component::CurDir) => unreachable!(),
            },
            Component::Prefix(_) | Component::RootDir | Component::Normal(_) => {
                stack.push(component);
            },
        }
    }

    stack
        .into_iter()
        .map(|c| c.as_os_str())
        .collect::<PathBuf>()
}
```

**File:** aptos-move/aptos-release-builder/src/main.rs (L233-237)
```rust
            aptos_release_builder::ReleaseConfig::load_config(release_config.as_path())
                .with_context(|| "Failed to load release config".to_string())?
                .generate_release_proposal_scripts(output_dir.as_path())
                .await
                .with_context(|| "Failed to generate release proposal scripts".to_string())?;
```
