# Audit Report

## Title
Missing Validation of ShardedTxnIndex References Enables Validator Node Crashes via Out-of-Bounds Array Access

## Summary
The `add_edges()` function in the block partitioner creates `ShardedTxnIndex` references in cross-shard dependencies without validating that the `round_id`, `shard_id`, and `txn_index` fields point to valid transactions. During sharded execution, these unvalidated indices are used for array indexing in cross-shard message routing, which can cause validator node panics if indices exceed allocated bounds. Specifically, if `max_partitioning_rounds` is configured above `MAX_ALLOWED_PARTITIONING_ROUNDS` (8) with `partition_last_round` enabled, or if any partitioning logic bug produces incorrect indices, nodes will crash during block execution.

## Finding Description

The block partitioner creates cross-shard dependencies containing `ShardedTxnIndex` objects in `take_txn_with_dep()`: [1](#0-0) [2](#0-1) 

These indices are created from values in the `ConflictingTxnTracker` which are populated during the `remove_cross_shard_dependencies()` process: [3](#0-2) 

**Critical Issue**: The `last_round_id` can equal or exceed the number of rounds, and there is **no validation** that:
1. `round_id < MAX_ALLOWED_PARTITIONING_ROUNDS` (8)
2. `shard_id < num_shards`
3. `txn_index` is within bounds for the target sub-block

During execution, these unvalidated indices are used for array indexing in `CrossShardCommitSender::send_remote_update_for_success()`: [4](#0-3) 

The `send_cross_shard_msg()` implementation performs direct array indexing without bounds checking: [5](#0-4) 

The message channel array is allocated with fixed dimensions: [6](#0-5) 

**Exploitation Path**:
1. Node operator configures `max_partitioning_rounds > 8` (or partitioning bug produces invalid indices)
2. Partitioner creates dependencies with `round_id >= 8`
3. During execution, `send_cross_shard_msg(shard_id, round_id, msg)` is called
4. Array access `message_txs[shard_id][round_id]` triggers out-of-bounds panic (round_id >= 8, but array size is 8)
5. Validator node crashes during block execution

**Proof of Missing Validation**: No bounds checking exists in the configuration system: [7](#0-6) 

The configuration allows arbitrary values without validation against the executor's hardcoded limits: [8](#0-7) 

## Impact Explanation

**Severity: High**

This vulnerability can cause:
1. **Validator node crashes**: Panic during block execution when out-of-bounds array access occurs
2. **Consensus disruption**: If some validators crash while others don't (due to configuration differences or timing), consensus could stall
3. **Deterministic execution violation**: Different nodes may panic at different points, breaking the invariant that all validators produce identical results

While the default configuration (`max_partitioning_rounds: 4`) is safe, the lack of validation creates a critical fragility. Any misconfiguration or future partitioning logic bug that produces invalid indices will immediately crash validators during execution.

According to Aptos bug bounty criteria, this qualifies as **High Severity** due to:
- Validator node crashes/availability impact
- Significant protocol violations (deterministic execution)

This does not reach Critical severity as it requires misconfiguration rather than being directly exploitable by transaction senders, and the network can recover once configuration is corrected.

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability requires either:
1. **Misconfiguration**: Node operator sets `max_partitioning_rounds > 8`, OR
2. **Partitioning bug**: Future bugs in partitioning logic produce invalid indices

Default configuration is safe, reducing immediate likelihood. However:
- The lack of validation means the system is **one configuration mistake away** from validator crashes
- No runtime safety net exists to catch invalid indices before they cause panics
- As the system evolves, partitioning logic complexity increases the risk of bugs that produce invalid indices

The defensive programming principle requires validation of all external inputs and internal assumptions. The current code violates this by trusting that partitioning always produces valid indices.

## Recommendation

**Add validation at multiple layers:**

1. **Configuration validation** - Enforce limit in config builder:
```rust
pub fn max_partitioning_rounds(mut self, val: usize) -> Self {
    assert!(val <= MAX_ALLOWED_PARTITIONING_ROUNDS, 
        "max_partitioning_rounds ({}) must not exceed MAX_ALLOWED_PARTITIONING_ROUNDS ({})", 
        val, MAX_ALLOWED_PARTITIONING_ROUNDS);
    self.max_partitioning_rounds = val;
    self
}
```

2. **Dependency creation validation** - Add bounds checking in `take_txn_with_dep()`:
```rust
let src_txn_idx = ShardedTxnIndex {
    txn_index: *self.final_idxs_by_pre_partitioned[txn_idx.pre_partitioned_txn_idx]
        .read()
        .unwrap(),
    shard_id: txn_idx.shard_id(),
    round_id: txn_idx.round_id(),
};
assert!(src_txn_idx.shard_id < self.num_executor_shards, 
    "Invalid shard_id in dependency");
assert!(src_txn_idx.round_id < MAX_ALLOWED_PARTITIONING_ROUNDS || 
    src_txn_idx.round_id == GLOBAL_ROUND_ID,
    "Invalid round_id in dependency");
```

3. **Runtime validation** - Add bounds checking before array access in cross-shard client (defensive):
```rust
fn send_cross_shard_msg(&self, shard_id: ShardId, round: RoundId, msg: CrossShardMsg) {
    assert!(shard_id < self.message_txs.len(), 
        "Invalid shard_id: {} >= {}", shard_id, self.message_txs.len());
    assert!(round < self.message_txs[shard_id].len(),
        "Invalid round: {} >= {}", round, self.message_txs[shard_id].len());
    self.message_txs[shard_id][round].send(msg).unwrap()
}
```

## Proof of Concept

**Reproduction Steps:**

1. Modify node configuration to set `max_partitioning_rounds = 10` (exceeds MAX_ALLOWED_PARTITIONING_ROUNDS of 8)
2. Set `partition_last_round = true` to prevent last round from being converted to GLOBAL_ROUND_ID
3. Submit a block with transactions that create cross-shard dependencies spanning multiple rounds
4. Partitioner will create dependencies with `round_id >= 8`
5. During execution, when `CrossShardCommitSender::send_remote_update_for_success()` calls `send_cross_shard_msg()` with `round_id = 8` or higher
6. Array access `message_txs[shard_id][8]` panics with index out of bounds (array has indices 0-7)

**Test case pseudocode:**
```rust
#[test]
#[should_panic(expected = "index out of bounds")]
fn test_invalid_round_id_causes_panic() {
    let config = PartitionerV2Config::default()
        .max_partitioning_rounds(10) // Exceeds MAX_ALLOWED_PARTITIONING_ROUNDS
        .partition_last_round(true);
    
    // Create block with cross-shard dependencies
    let partitioned = partitioner.partition(txns, num_shards);
    
    // Attempt execution - should panic on send_cross_shard_msg
    execute_partitioned_block(partitioned); // Panics!
}
```

## Notes

While the default configuration is safe, the lack of validation violates defense-in-depth principles and creates a landmine for future configuration changes or partitioning logic modifications. The system should fail gracefully with clear error messages rather than panicking during execution, which could be mistaken for consensus bugs or other critical failures.

### Citations

**File:** execution/block-partitioner/src/v2/state.rs (L312-318)
```rust
                let src_txn_idx = ShardedTxnIndex {
                    txn_index: *self.final_idxs_by_pre_partitioned[txn_idx.pre_partitioned_txn_idx]
                        .read()
                        .unwrap(),
                    shard_id: txn_idx.shard_id(),
                    round_id: txn_idx.round_id(),
                };
```

**File:** execution/block-partitioner/src/v2/state.rs (L337-344)
```rust
                    let dst_txn_idx = ShardedTxnIndex {
                        txn_index: *self.final_idxs_by_pre_partitioned
                            [follower_txn_idx.pre_partitioned_txn_idx]
                            .read()
                            .unwrap(),
                        shard_id: final_sub_blk_idx.shard_id,
                        round_id: final_sub_blk_idx.round_id,
                    };
```

**File:** execution/block-partitioner/src/v2/partition_to_matrix.rs (L60-70)
```rust
        let last_round_id = state.finalized_txn_matrix.len();
        state.thread_pool.install(|| {
            (0..state.num_executor_shards)
                .into_par_iter()
                .for_each(|shard_id| {
                    remaining_txns[shard_id].par_iter().for_each(|&txn_idx| {
                        state.update_trackers_on_accepting(txn_idx, last_round_id, shard_id);
                    });
                });
        });
        state.finalized_txn_matrix.push(remaining_txns);
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L116-130)
```rust
                for (dependent_shard_id, round_id) in dependent_shard_ids.iter() {
                    trace!("Sending remote update for success for shard id {:?} and txn_idx: {:?}, state_key: {:?}, dependent shard id: {:?}", self.shard_id, txn_idx, state_key, dependent_shard_id);
                    let message = RemoteTxnWriteMsg(RemoteTxnWrite::new(
                        state_key.clone(),
                        Some(write_op.clone()),
                    ));
                    if *round_id == GLOBAL_ROUND_ID {
                        self.cross_shard_client.send_global_msg(message);
                    } else {
                        self.cross_shard_client.send_cross_shard_msg(
                            *dependent_shard_id,
                            *round_id,
                            message,
                        );
                    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L98-104)
```rust
        ) = (0..num_shards)
            .map(|_| {
                (0..MAX_ALLOWED_PARTITIONING_ROUNDS)
                    .map(|_| unbounded())
                    .unzip()
            })
            .unzip();
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L331-333)
```rust
    fn send_cross_shard_msg(&self, shard_id: ShardId, round: RoundId, msg: CrossShardMsg) {
        self.message_txs[shard_id][round].send(msg).unwrap()
    }
```

**File:** execution/block-partitioner/src/v2/config.rs (L28-30)
```rust
    pub fn max_partitioning_rounds(mut self, val: usize) -> Self {
        self.max_partitioning_rounds = val;
        self
```

**File:** types/src/block_executor/partitioner.rs (L20-22)
```rust
pub static MAX_ALLOWED_PARTITIONING_ROUNDS: usize = 8;
pub static GLOBAL_ROUND_ID: usize = MAX_ALLOWED_PARTITIONING_ROUNDS + 1;
pub static GLOBAL_SHARD_ID: usize = usize::MAX;
```
