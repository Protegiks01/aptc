# Audit Report

## Title
Weak Distance Validation Allows Byzantine Peers to Manipulate Consensus Observer Subscription Priority

## Summary
Byzantine peers can report false `distance_from_validators` values in the range [2, MAX_DISTANCE_FROM_VALIDATORS] to manipulate consensus observer subscription priority. While role-based validation prevents critical attacks (false distance 0 or 1), the weak validation for distances > 1 allows Byzantine peers to gain unfair subscription priority over honest peers at similar or greater distances.

## Finding Description

The consensus observer uses peer distance from validators as a primary metric for selecting subscription targets. [1](#0-0) 

This distance is self-reported by peers via `NetworkInformationResponse`. [2](#0-1) 

The peer monitoring client validates these responses with sanity checks: [3](#0-2) 

**The Vulnerability:** For distances > 1, the validation only checks `distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS` without verifying the peer's role matches the claimed distance. Byzantine peers with `PeerRole::Unknown` can falsely report distance=2 (when their actual distance is ≥3) to gain priority in subscription selection.

**Attack Path:**
1. Byzantine PFN (actual distance ≥3) connects to consensus observer
2. Consensus observer requests network information
3. Byzantine PFN reports `distance_from_validators = 2` (false)
4. Validation passes (distance > 1, only checks ≤ MAX)
5. Consensus observer stores false distance in peer metadata
6. During subscription selection, Byzantine peer is prioritized over honest peers with distance ≥3 [4](#0-3) 

## Impact Explanation

This vulnerability affects **consensus observer synchronization performance**, not consensus safety. Per Aptos bug bounty criteria, this is **Medium Severity**:

- **Not Critical**: Validators run consensus publisher only (not observers). [5](#0-4)  Consensus observers do not participate in AptosBFT consensus, they only receive validated updates. Signature verification prevents Byzantine peers from sending invalid blocks. [6](#0-5) 

- **Limited Impact**: Byzantine peers can only delay/withhold messages up to timeout thresholds. Health checks detect suboptimal peers and trigger subscription rotation. [7](#0-6)  Fallback to state sync provides resilience.

- **Restricted Scope**: Public fullnodes have consensus observer disabled by default. [8](#0-7)  Attack primarily affects manually-enabled observers.

## Likelihood Explanation

**Likelihood: Medium**

- **Easy to Execute**: Byzantine peer simply reports false distance in response (no special privileges needed)
- **Limited Attack Surface**: Role-based validation prevents critical attacks (false distance 0 or 1) [9](#0-8) 
- **Mitigations Exist**: Multiple concurrent subscriptions, health monitoring, and state sync fallback reduce effectiveness
- **Configuration Dependent**: Most affected nodes (PFNs) have observer disabled by default

## Recommendation

Strengthen distance validation by implementing role-based checks for all distance ranges:

```rust
fn validate_distance_from_validators(
    distance: u64,
    peer_role: PeerRole,
    network_id: NetworkId,
    our_role: RoleType,
) -> bool {
    match distance {
        0 => {
            // Distance 0: must be validator
            peer_role.is_validator() && is_correct_network_for_distance_zero(network_id, our_role)
        },
        1 => {
            // Distance 1: must be VFN
            peer_role.is_vfn() && is_correct_network_for_distance_one(network_id, our_role)
        },
        2..=MAX_DISTANCE_FROM_VALIDATORS => {
            // Distance 2+: require authenticated peer role (not Unknown)
            // OR implement distance verification through multiple peer attestations
            peer_role != PeerRole::Unknown || verify_distance_through_peer_consensus(distance, peers)
        },
        _ => false,
    }
}
```

Alternative: Implement peer distance attestation where multiple peers must confirm a peer's claimed distance before accepting it.

## Proof of Concept

```rust
// Conceptual PoC - demonstrates the vulnerability flow
#[test]
fn test_byzantine_distance_manipulation() {
    // Setup: Create consensus observer with connected peers
    let mut peers_and_metadata = HashMap::new();
    
    // Honest peer at actual distance 3
    let honest_peer = create_peer_with_distance(3, PeerRole::Unknown);
    peers_and_metadata.insert(honest_peer.id, honest_peer.metadata);
    
    // Byzantine peer at actual distance 5, but reports distance 2
    let byzantine_peer = create_peer_with_false_distance(
        actual_distance: 5,
        reported_distance: 2,
        PeerRole::Unknown
    );
    peers_and_metadata.insert(byzantine_peer.id, byzantine_peer.metadata);
    
    // Sort peers for subscription
    let sorted_peers = sort_peers_by_subscription_optimality(&peers_and_metadata);
    
    // Byzantine peer gains priority due to false distance=2 vs honest distance=3
    assert_eq!(sorted_peers[0], byzantine_peer.id);
    assert_eq!(sorted_peers[1], honest_peer.id);
    
    // Consensus observer would subscribe to Byzantine peer first
}
```

## Notes

This vulnerability demonstrates a **transitive trust weakness** in peer-reported metrics. While critical distances (0 and 1) are protected by role-based validation tied to cryptographic authentication (trusted peers, onchain discovery), distances ≥2 lack equivalent verification. The attack surface is limited by health checks and fallback mechanisms, but Byzantine peers can still gain temporary subscription priority, degrading synchronization performance for non-validator nodes.

### Citations

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L196-218)
```rust
fn get_distance_for_peer(
    peer_network_id: &PeerNetworkId,
    peer_metadata: &PeerMetadata,
) -> Option<u64> {
    // Get the distance for the peer
    let peer_monitoring_metadata = peer_metadata.get_peer_monitoring_metadata();
    let distance = peer_monitoring_metadata
        .latest_network_info_response
        .as_ref()
        .map(|response| response.distance_from_validators);

    // If the distance is missing, log a warning
    if distance.is_none() {
        warn!(
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Unable to get distance for peer! Peer: {:?}",
                peer_network_id
            ))
        );
    }

    distance
}
```

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L283-350)
```rust
pub fn sort_peers_by_subscription_optimality(
    peers_and_metadata: &HashMap<PeerNetworkId, PeerMetadata>,
) -> Vec<PeerNetworkId> {
    // Group peers and latencies by validator distance, i.e., distance -> [(peer, latency)]
    let mut unsupported_peers = Vec::new();
    let mut peers_and_latencies_by_distance = BTreeMap::new();
    for (peer_network_id, peer_metadata) in peers_and_metadata {
        // Verify that the peer supports consensus observer
        if !supports_consensus_observer(peer_metadata) {
            unsupported_peers.push(*peer_network_id);
            continue; // Skip the peer
        }

        // Get the distance and latency for the peer
        let distance = get_distance_for_peer(peer_network_id, peer_metadata);
        let latency = get_latency_for_peer(peer_network_id, peer_metadata);

        // If the distance is not found, use the maximum distance
        let distance =
            distance.unwrap_or(aptos_peer_monitoring_service_types::MAX_DISTANCE_FROM_VALIDATORS);

        // If the latency is not found, use a large latency
        let latency = latency.unwrap_or(MAX_PING_LATENCY_SECS);

        // Add the peer and latency to the distance group
        peers_and_latencies_by_distance
            .entry(distance)
            .or_insert_with(Vec::new)
            .push((*peer_network_id, OrderedFloat(latency)));
    }

    // If there are peers that don't support consensus observer, log them
    if !unsupported_peers.is_empty() {
        info!(
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Found {} peers that don't support consensus observer! Peers: {:?}",
                unsupported_peers.len(),
                unsupported_peers
            ))
        );
    }

    // Sort the peers by distance and latency. Note: BTreeMaps are
    // sorted by key, so the entries will be sorted by distance in ascending order.
    let mut sorted_peers_and_latencies = Vec::new();
    for (_, mut peers_and_latencies) in peers_and_latencies_by_distance {
        // Sort the peers by latency
        peers_and_latencies.sort_by_key(|(_, latency)| *latency);

        // Add the peers to the sorted list (in sorted order)
        sorted_peers_and_latencies.extend(peers_and_latencies);
    }

    // Log the sorted peers and latencies
    info!(
        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
            "Sorted {} peers by subscription optimality! Peers and latencies: {:?}",
            sorted_peers_and_latencies.len(),
            sorted_peers_and_latencies
        ))
    );

    // Only return the sorted peers (without the latencies)
    sorted_peers_and_latencies
        .into_iter()
        .map(|(peer, _)| peer)
        .collect()
}
```

**File:** peer-monitoring-service/server/src/lib.rs (L217-248)
```rust
    fn get_network_information(&self) -> Result<PeerMonitoringServiceResponse, Error> {
        // Get the connected peers
        let connected_peers_and_metadata =
            self.peers_and_metadata.get_connected_peers_and_metadata()?;
        let connected_peers = connected_peers_and_metadata
            .into_iter()
            .map(|(peer, metadata)| {
                let connection_metadata = metadata.get_connection_metadata();
                (
                    peer,
                    ConnectionMetadata::new(
                        connection_metadata.addr,
                        connection_metadata.remote_peer_id,
                        connection_metadata.role,
                    ),
                )
            })
            .collect();

        // Get the distance from the validators
        let distance_from_validators =
            get_distance_from_validators(&self.base_config, self.peers_and_metadata.clone());

        // Create and return the response
        let network_information_response = NetworkInformationResponse {
            connected_peers,
            distance_from_validators,
        };
        Ok(PeerMonitoringServiceResponse::NetworkInformation(
            network_information_response,
        ))
    }
```

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L116-154)
```rust
        // Sanity check the response depth from the peer metadata
        let network_id = peer_network_id.network_id();
        let is_valid_depth = match network_info_response.distance_from_validators {
            0 => {
                // Verify the peer is a validator and has the correct network id
                let peer_is_validator = peer_metadata.get_connection_metadata().role.is_validator();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_validator_network(), // We're a validator
                    RoleType::FullNode => network_id.is_vfn_network(),        // We're a VFN
                };
                peer_is_validator && peer_has_correct_network
            },
            1 => {
                // Verify the peer is a VFN and has the correct network id
                let peer_is_vfn = peer_metadata.get_connection_metadata().role.is_vfn();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_vfn_network(), // We're a validator
                    RoleType::FullNode => network_id.is_public_network(), // We're a VFN or PFN
                };
                peer_is_vfn && peer_has_correct_network
            },
            distance_from_validators => {
                // The distance must be less than or equal to the max
                distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS
            },
        };

        // If the depth did not pass our sanity checks, handle a failure
        if !is_valid_depth {
            warn!(LogSchema::new(LogEntry::NetworkInfoRequest)
                .event(LogEvent::InvalidResponse)
                .peer(peer_network_id)
                .message(&format!(
                    "Peer returned invalid depth from validators: {}",
                    network_info_response.distance_from_validators
                )));
            self.handle_request_failure();
            return;
        }
```

**File:** config/src/config/consensus_observer_config.rs (L12-14)
```rust
const ENABLE_ON_VALIDATORS: bool = true;
const ENABLE_ON_VALIDATOR_FULLNODES: bool = true;
const ENABLE_ON_PUBLIC_FULLNODES: bool = false;
```

**File:** config/src/config/consensus_observer_config.rs (L112-118)
```rust
            NodeType::Validator => {
                if ENABLE_ON_VALIDATORS && !publisher_manually_set {
                    // Only enable the publisher for validators
                    consensus_observer_config.publisher_enabled = true;
                    modified_config = true;
                }
            },
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use crate::consensus_observer::common::error::Error;
use aptos_consensus_types::{
    common::{BatchPayload, Payload},
    payload::{InlineBatches, OptQuorumStorePayload},
    pipelined_block::PipelinedBlock,
    proof_of_store::{BatchInfo, ProofCache, ProofOfStore},
};
use aptos_crypto::{hash::CryptoHash, HashValue};
use aptos_types::{
    block_info::{BlockInfo, Round},
    epoch_change::Verifier,
    epoch_state::EpochState,
    ledger_info::LedgerInfoWithSignatures,
    transaction::SignedTransaction,
};
use rayon::{
    iter::{IntoParallelRefIterator, ParallelIterator},
    prelude::*,
};
use serde::{Deserialize, Serialize};
use std::{
    fmt::{Display, Formatter},
    sync::Arc,
    vec::IntoIter,
};

/// Types of messages that can be sent between the consensus publisher and observer
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub enum ConsensusObserverMessage {
    Request(ConsensusObserverRequest),
    Response(ConsensusObserverResponse),
    DirectSend(ConsensusObserverDirectSend),
}

impl ConsensusObserverMessage {
    /// Creates and returns a new ordered block message using the given blocks and ordered proof
    pub fn new_ordered_block_message(
        blocks: Vec<Arc<PipelinedBlock>>,
        ordered_proof: LedgerInfoWithSignatures,
    ) -> ConsensusObserverDirectSend {
        let ordered_block = OrderedBlock::new(blocks, ordered_proof);
        ConsensusObserverDirectSend::OrderedBlock(ordered_block)
    }

    /// Creates and returns a new commit decision message using the given commit decision
    pub fn new_commit_decision_message(
        commit_proof: LedgerInfoWithSignatures,
```

**File:** consensus/src/consensus_observer/observer/subscription.rs (L100-162)
```rust
    fn check_subscription_peer_optimality(
        &mut self,
        peers_and_metadata: &HashMap<PeerNetworkId, PeerMetadata>,
        skip_peer_optimality_check: bool,
    ) -> Result<(), Error> {
        // Get the last optimality check time and connected peers
        let (last_optimality_check_time, last_optimality_check_peers) =
            self.last_optimality_check_time_and_peers.clone();

        // If we're skipping the peer optimality check, update the last check time and return
        let time_now = self.time_service.now();
        if skip_peer_optimality_check {
            self.last_optimality_check_time_and_peers = (time_now, last_optimality_check_peers);
            return Ok(());
        }

        // Determine if enough time has elapsed to force a refresh
        let duration_since_last_check = time_now.duration_since(last_optimality_check_time);
        let refresh_interval = Duration::from_millis(
            self.consensus_observer_config
                .subscription_refresh_interval_ms,
        );
        let force_refresh = duration_since_last_check >= refresh_interval;

        // Determine if the peers have changed since the last check.
        // Note: we only check for peer changes periodically to avoid
        // excessive subscription churn due to peer connects/disconnects.
        let current_connected_peers = peers_and_metadata.keys().cloned().collect();
        let peer_check_interval = Duration::from_millis(
            self.consensus_observer_config
                .subscription_peer_change_interval_ms,
        );
        let peers_changed = duration_since_last_check >= peer_check_interval
            && current_connected_peers != last_optimality_check_peers;

        // Determine if we should perform the optimality check
        if !force_refresh && !peers_changed {
            return Ok(()); // We don't need to check optimality yet
        }

        // Otherwise, update the last peer optimality check time and peers
        self.last_optimality_check_time_and_peers = (time_now, current_connected_peers);

        // Sort the peers by subscription optimality
        let sorted_peers =
            subscription_utils::sort_peers_by_subscription_optimality(peers_and_metadata);

        // Verify that this peer is one of the most optimal peers
        let max_concurrent_subscriptions =
            self.consensus_observer_config.max_concurrent_subscriptions as usize;
        if !sorted_peers
            .iter()
            .take(max_concurrent_subscriptions)
            .any(|peer| peer == &self.peer_network_id)
        {
            return Err(Error::SubscriptionSuboptimal(format!(
                "Subscription to peer: {} is no longer optimal! New optimal peers: {:?}",
                self.peer_network_id, sorted_peers
            )));
        }

        Ok(())
    }
```

**File:** network/framework/src/noise/handshake.rs (L368-427)
```rust
        let peer_role = match &self.auth_mode {
            HandshakeAuthMode::Mutual {
                peers_and_metadata, ..
            } => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => Err(NoiseHandshakeError::UnauthenticatedClient(
                        remote_peer_short,
                        remote_peer_id,
                    )),
                }
            },
            HandshakeAuthMode::MaybeMutual(peers_and_metadata) => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => {
                        // The peer is not in the trusted peer set. Verify that the Peer ID is
                        // constructed correctly from the public key.
                        let derived_remote_peer_id =
                            aptos_types::account_address::from_identity_public_key(
                                remote_public_key,
                            );
                        if derived_remote_peer_id != remote_peer_id {
                            // The peer ID is not constructed correctly from the public key
                            Err(NoiseHandshakeError::ClientPeerIdMismatch(
                                remote_peer_short,
                                remote_peer_id,
                                derived_remote_peer_id,
                            ))
                        } else {
                            // Try to infer the role from the network context
                            if self.network_context.role().is_validator() {
                                if network_id.is_vfn_network() {
                                    // Inbound connections to validators on the VFN network must be VFNs
                                    Ok(PeerRole::ValidatorFullNode)
                                } else {
                                    // Otherwise, they're unknown. Validators will connect through
                                    // authenticated channels (on the validator network) so shouldn't hit
                                    // this, and PFNs will connect on public networks (which aren't common).
                                    Ok(PeerRole::Unknown)
                                }
                            } else {
                                // We're a VFN or PFN. VFNs get no inbound connections on the vfn network
                                // (so the peer won't be a validator). Thus, we're on the public network
                                // so mark the peer as unknown.
                                Ok(PeerRole::Unknown)
                            }
                        }
                    },
                }
            },
        }?;
```
