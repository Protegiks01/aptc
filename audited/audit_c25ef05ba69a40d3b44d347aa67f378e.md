# Audit Report

## Title
Storage Leak: Orphaned Stale State Value Indices After Sharding Migration

## Summary
When a node migrates from non-sharded to sharded storage mode (AIP-97), old stale state value index entries in the legacy `STALE_STATE_VALUE_INDEX_CF_NAME` column family are never pruned, causing permanent storage waste.

## Finding Description
The Aptos storage layer uses two mutually exclusive schemas for tracking stale state values:

1. **Non-sharded mode**: Uses `StaleStateValueIndexSchema` storing full state keys in the `STALE_STATE_VALUE_INDEX_CF_NAME` column family of the shared ledger_db [1](#0-0) 

2. **Sharded mode**: Uses `StaleStateValueIndexByKeyHashSchema` storing state key hashes in the `STALE_STATE_VALUE_INDEX_BY_KEY_HASH_CF_NAME` column family across shard databases [2](#0-1) 

The write path conditionally selects one schema based on the `enable_sharding` flag: [3](#0-2) 

**The vulnerability**: The pruning logic has the same conditional branching, but when sharding is enabled, it only prunes from the new schema: [4](#0-3) 

When `enabled_sharding()` is true (lines 35-50), the pruner iterates through shard databases but the old `ledger_db` with `STALE_STATE_VALUE_INDEX_CF_NAME` is never accessed. When false (lines 51-64), it prunes from `metadata_db()` which points to the shared ledger_db.

**Database path divergence**: The ledger metadata database uses different paths based on sharding: [5](#0-4) 

Non-sharded mode uses `ledger_db/` directly, while sharded mode creates `ledger_db/metadata/`. The old database files remain on disk at the original path but are never accessed after migration.

**Column family definitions confirm the split**:
- Legacy ledger_db includes STALE_STATE_VALUE_INDEX_CF_NAME: [6](#0-5) 

- New sharded databases use only the key-hash variant: [7](#0-6) 

## Impact Explanation
This qualifies as **Medium severity** under "State inconsistencies requiring intervention":

1. **Storage waste accumulation**: Pre-migration stale state value indices remain forever on disk, wasting storage proportional to the state history before migration
2. **No automatic cleanup**: There is no code path that prunes the orphaned indices
3. **Operational impact**: Nodes that migrated from non-sharded to sharded mode accumulate dead storage that can only be removed by manual database cleanup or node re-syncing from genesis

However, this does **not** meet higher severity criteria because:
- No consensus impact (validators continue to agree on state)
- No data corruption (current state remains correct)
- No funds at risk
- Does not affect node operation beyond storage overhead

## Likelihood Explanation
**High likelihood** for nodes that undergo the sharding migration:

1. AIP-97 makes sharding mandatory for testnet/mainnet: [8](#0-7) 

2. All nodes that existed before AIP-97 and migrated to sharded mode are affected
3. The issue occurs automatically during migration with no attacker involvement
4. Storage accumulation is proportional to the state history depth before migration

## Recommendation
Implement a cleanup routine that runs once during or after sharding migration to purge orphaned stale state value indices from the legacy ledger_db. Options include:

1. **Migration-time cleanup**: Add a step to the AIP-97 migration guide that deletes or compacts the old `STALE_STATE_VALUE_INDEX_CF_NAME` column family before enabling sharding

2. **Lazy cleanup on first sharded boot**: Add initialization logic that detects old non-sharded database files and prunes the stale index column family:

```rust
// In StateKvDb::new() or similar initialization
if enabled_sharding && legacy_ledger_db_exists() {
    cleanup_legacy_stale_indices(&legacy_ledger_db_path)?;
}
```

3. **Document manual cleanup**: Update the migration guide to explicitly instruct operators to manually delete or compact the old stale index column family after verifying successful migration

## Proof of Concept
```rust
// Reproduction steps (conceptual):
// 1. Start node with enable_storage_sharding = false
// 2. Process transactions to accumulate stale state values
// 3. Verify STALE_STATE_VALUE_INDEX_CF_NAME has entries in ledger_db/
// 4. Stop node and set enable_storage_sharding = true
// 5. Restart node - new metadata db created at ledger_db/metadata/
// 6. Process more transactions - new indices go to shard databases
// 7. Trigger pruning - observe old indices in ledger_db/ never deleted
// 8. Check disk usage - old stale indices consume space indefinitely

// Verification query:
use aptos_schemadb::DB;
let old_ledger_db = DB::open_cf_readonly(
    &opts, 
    "ledger_db/",
    "ledger_db",
    /* column families including STALE_STATE_VALUE_INDEX_CF_NAME */
)?;
let mut iter = old_ledger_db.iter::<StaleStateValueIndexSchema>()?;
iter.seek_to_first()?;
// Count entries - these will never be pruned after migration
let orphaned_count = iter.count();
assert!(orphaned_count > 0, "Orphaned stale indices found");
```

**Notes**:
This is a storage hygiene issue rather than a critical security vulnerability. The orphaned data does not affect consensus correctness or operational security, but does waste disk space indefinitely for migrated nodes. The fix should be included in the official AIP-97 migration documentation and tooling.

### Citations

**File:** storage/aptosdb/src/schema/stale_state_value_index/mod.rs (L21-39)
```rust
use crate::schema::{ensure_slice_len_eq, ensure_slice_len_gt, STALE_STATE_VALUE_INDEX_CF_NAME};
use anyhow::Result;
use aptos_schemadb::{
    define_schema,
    schema::{KeyCodec, SeekKeyCodec, ValueCodec},
};
use aptos_types::{
    state_store::{state_key::StateKey, state_value::StaleStateValueIndex},
    transaction::Version,
};
use byteorder::{BigEndian, ReadBytesExt, WriteBytesExt};
use std::{io::Write, mem::size_of};

define_schema!(
    StaleStateValueIndexSchema,
    StaleStateValueIndex,
    (),
    STALE_STATE_VALUE_INDEX_CF_NAME
);
```

**File:** storage/aptosdb/src/schema/stale_state_value_index_by_key_hash/mod.rs (L21-37)
```rust
use crate::schema::{ensure_slice_len_eq, STALE_STATE_VALUE_INDEX_BY_KEY_HASH_CF_NAME};
use anyhow::Result;
use aptos_crypto::HashValue;
use aptos_schemadb::{
    define_schema,
    schema::{KeyCodec, SeekKeyCodec, ValueCodec},
};
use aptos_types::{state_store::state_value::StaleStateValueByKeyHashIndex, transaction::Version};
use byteorder::{BigEndian, ReadBytesExt, WriteBytesExt};
use std::{io::Write, mem::size_of};

define_schema!(
    StaleStateValueIndexByKeyHashSchema,
    StaleStateValueByKeyHashIndex,
    (),
    STALE_STATE_VALUE_INDEX_BY_KEY_HASH_CF_NAME
);
```

**File:** storage/aptosdb/src/state_store/mod.rs (L985-1015)
```rust
    fn put_state_kv_index(
        batch: &mut NativeBatch,
        enable_sharding: bool,
        stale_since_version: Version,
        version: Version,
        key: &StateKey,
    ) {
        if enable_sharding {
            batch
                .put::<StaleStateValueIndexByKeyHashSchema>(
                    &StaleStateValueByKeyHashIndex {
                        stale_since_version,
                        version,
                        state_key_hash: key.hash(),
                    },
                    &(),
                )
                .unwrap();
        } else {
            batch
                .put::<StaleStateValueIndexSchema>(
                    &StaleStateValueIndex {
                        stale_since_version,
                        version,
                        state_key: (*key).clone(),
                    },
                    &(),
                )
                .unwrap();
        }
    }
```

**File:** storage/aptosdb/src/pruner/state_kv_pruner/state_kv_metadata_pruner.rs (L28-73)
```rust
    pub(in crate::pruner) fn prune(
        &self,
        current_progress: Version,
        target_version: Version,
    ) -> Result<()> {
        let mut batch = SchemaBatch::new();

        if self.state_kv_db.enabled_sharding() {
            let num_shards = self.state_kv_db.num_shards();
            // NOTE: This can be done in parallel if it becomes the bottleneck.
            for shard_id in 0..num_shards {
                let mut iter = self
                    .state_kv_db
                    .db_shard(shard_id)
                    .iter::<StaleStateValueIndexByKeyHashSchema>()?;
                iter.seek(&current_progress)?;
                for item in iter {
                    let (index, _) = item?;
                    if index.stale_since_version > target_version {
                        break;
                    }
                }
            }
        } else {
            let mut iter = self
                .state_kv_db
                .metadata_db()
                .iter::<StaleStateValueIndexSchema>()?;
            iter.seek(&current_progress)?;
            for item in iter {
                let (index, _) = item?;
                if index.stale_since_version > target_version {
                    break;
                }
                batch.delete::<StaleStateValueIndexSchema>(&index)?;
                batch.delete::<StateValueSchema>(&(index.state_key, index.version))?;
            }
        }

        batch.put::<DbMetadataSchema>(
            &DbMetadataKey::StateKvPrunerProgress,
            &DbMetadataValue::Version(target_version),
        )?;

        self.state_kv_db.metadata_db().write_schemas(batch)
    }
```

**File:** storage/aptosdb/src/ledger_db/mod.rs (L522-529)
```rust
    fn metadata_db_path<P: AsRef<Path>>(db_root_path: P, sharding: bool) -> PathBuf {
        let ledger_db_folder = db_root_path.as_ref().join(LEDGER_DB_FOLDER_NAME);
        if sharding {
            ledger_db_folder.join("metadata")
        } else {
            ledger_db_folder
        }
    }
```

**File:** storage/aptosdb/src/db_options.rs (L14-40)
```rust
pub(super) fn ledger_db_column_families() -> Vec<ColumnFamilyName> {
    vec![
        /* empty cf */ DEFAULT_COLUMN_FAMILY_NAME,
        BLOCK_BY_VERSION_CF_NAME,
        BLOCK_INFO_CF_NAME,
        EPOCH_BY_VERSION_CF_NAME,
        EVENT_ACCUMULATOR_CF_NAME,
        EVENT_BY_KEY_CF_NAME,
        EVENT_BY_VERSION_CF_NAME,
        EVENT_CF_NAME,
        LEDGER_INFO_CF_NAME,
        PERSISTED_AUXILIARY_INFO_CF_NAME,
        STALE_STATE_VALUE_INDEX_CF_NAME,
        STATE_VALUE_CF_NAME,
        TRANSACTION_CF_NAME,
        TRANSACTION_ACCUMULATOR_CF_NAME,
        TRANSACTION_ACCUMULATOR_HASH_CF_NAME,
        TRANSACTION_AUXILIARY_DATA_CF_NAME,
        ORDERED_TRANSACTION_BY_ACCOUNT_CF_NAME,
        TRANSACTION_SUMMARIES_BY_ACCOUNT_CF_NAME,
        TRANSACTION_BY_HASH_CF_NAME,
        TRANSACTION_INFO_CF_NAME,
        VERSION_DATA_CF_NAME,
        WRITE_SET_CF_NAME,
        DB_METADATA_CF_NAME,
    ]
}
```

**File:** storage/aptosdb/src/db_options.rs (L141-149)
```rust
pub(super) fn state_kv_db_new_key_column_families() -> Vec<ColumnFamilyName> {
    vec![
        /* empty cf */ DEFAULT_COLUMN_FAMILY_NAME,
        DB_METADATA_CF_NAME,
        STALE_STATE_VALUE_INDEX_BY_KEY_HASH_CF_NAME,
        STATE_VALUE_BY_KEY_HASH_CF_NAME,
        STATE_VALUE_INDEX_CF_NAME, // we still need this cf before deleting all the write callsites
    ]
}
```

**File:** config/src/config/storage_config.rs (L664-668)
```rust
            if (chain_id.is_testnet() || chain_id.is_mainnet())
                && config_yaml["rocksdb_configs"]["enable_storage_sharding"].as_bool() != Some(true)
            {
                panic!("Storage sharding (AIP-97) is not enabled in node config. Please follow the guide to migration your node, and set storage.rocksdb_configs.enable_storage_sharding to true explicitly in your node config. https://aptoslabs.notion.site/DB-Sharding-Migration-Public-Full-Nodes-1978b846eb7280b29f17ceee7d480730");
            }
```
