# Audit Report

## Title
Database Corruption Undetected: Missing Initial Transactions Silently Skipped in AccountOrderedTransactionsIter

## Summary
The validation logic in `AccountOrderedTransactionsIter::next_impl()` at lines 86-92 fails to detect database corruption when transactions at the beginning of the requested range are missing. The iterator only validates contiguity between consecutive transactions it reads, but does not verify that the first transaction matches the requested starting sequence number, allowing silent data loss.

## Finding Description

The `AccountOrderedTransactionsIter` is designed to iterate over account transactions and detect database corruption by ensuring sequence numbers are contiguous. [1](#0-0) 

However, this validation has a critical flaw: the `expected_next_seq_num` field is initialized to `None` when the iterator is created. [2](#0-1) 

When the iterator is created via `get_account_ordered_transactions_iter()`, it seeks to the requested starting position but does **not** pass the requested `min_seq_num` to the iterator constructor - only the `end_seq_num` is stored. [3](#0-2) 

**Attack Scenario:**

1. Database corruption causes transactions with sequence numbers [0, 1, 2, 3, 4] to be missing for account A
2. Only transactions [5, 6, 7, 8, 9] remain in the database
3. Client requests transactions starting from `seq_num=0` with `limit=10`
4. Iterator seeks to `(address, 0)` but database returns `(address, 5)` as the first available entry
5. First call to `next_impl()`: reads `seq_num=5`, but since `expected_next_seq_num` is `None`, **no validation occurs** at lines 86-92
6. Iterator sets `expected_next_seq_num = 6` and returns `(5, version)`
7. Subsequent transactions pass validation since they are contiguous (6, 7, 8, 9)
8. **Result**: Client receives transactions starting from seq_num 5 instead of 0, with no error indicating database corruption

The consumer code compounds this issue by discarding the sequence number returned by the iterator. [4](#0-3) 

The documentation promises that sequence numbers are contiguous but fails to guarantee they start from the requested position. [5](#0-4) 

## Impact Explanation

This vulnerability breaks the **State Consistency** invariant (Invariant #4) and constitutes a **High Severity** issue based on Aptos bug bounty criteria:

1. **State Inconsistencies**: Nodes with database corruption will serve incomplete transaction histories without detecting the corruption, leading to inconsistent views across the network
2. **Silent Data Loss**: Missing transactions are not reported as errors, causing downstream systems to operate on incomplete data
3. **API Contract Violation**: The API promises to return transactions starting from a specific sequence number but may return transactions from a later sequence without indication

While the `verify()` method on `AccountOrderedTransactionsWithProof` would catch this mismatch [6](#0-5) , it is **optional** and not called by the server-side storage layer, meaning corrupted data can be served to clients who don't perform verification.

This qualifies as a **High Severity** issue: "Significant protocol violations" and "State inconsistencies requiring intervention."

## Likelihood Explanation

**Likelihood: Medium-High**

Database corruption can occur through:
1. **Crash during write operations**: If a node crashes while indexing transactions, partial writes may leave gaps
2. **Disk failures**: Hardware issues can corrupt database files
3. **Pruning bugs**: Incorrect pruning logic could delete transactions it shouldn't
4. **Backup restoration**: Restoring from an incomplete backup could leave gaps

The vulnerability manifests immediately upon querying any account whose initial transactions are missing. No attacker action is required - this is a defensive coding failure that affects crash recovery scenarios.

## Recommendation

Add validation to ensure the first sequence number read matches the requested starting sequence number. The fix requires passing `min_seq_num` to the iterator constructor:

**Modified `AccountOrderedTransactionsIter` struct:**
```rust
pub struct AccountOrderedTransactionsIter<'a> {
    inner: SchemaIterator<'a, OrderedTransactionByAccountSchema>,
    address: AccountAddress,
    start_seq_num: u64,  // ADD THIS FIELD
    expected_next_seq_num: Option<u64>,
    end_seq_num: u64,
    prev_version: Option<Version>,
    ledger_version: Version,
}
```

**Modified constructor:**
```rust
pub fn new(
    inner: SchemaIterator<'a, OrderedTransactionByAccountSchema>,
    address: AccountAddress,
    start_seq_num: u64,  // ADD THIS PARAMETER
    end_seq_num: u64,
    ledger_version: Version,
) -> Self {
    Self {
        inner,
        address,
        start_seq_num,  // STORE IT
        end_seq_num,
        ledger_version,
        expected_next_seq_num: None,
        prev_version: None,
    }
}
```

**Modified validation in `next_impl()`:**
```rust
// Ensure seq_num_{i+1} == seq_num_{i} + 1
if let Some(expected_seq_num) = self.expected_next_seq_num {
    ensure!(
        seq_num == expected_seq_num,
        "DB corruption: account transactions sequence numbers are not contiguous: \
         actual: {}, expected: {}",
        seq_num,
        expected_seq_num,
    );
} else {
    // First transaction - validate it matches the requested start
    ensure!(
        seq_num == self.start_seq_num,
        "DB corruption: first transaction sequence number {} does not match \
         requested start sequence number {}. Missing transactions detected.",
        seq_num,
        self.start_seq_num,
    );
}
```

**Update all callers** to pass `min_seq_num` to the constructor in both `storage/indexer/src/db_indexer.rs` and `storage/aptosdb/src/transaction_store/mod.rs`.

## Proof of Concept

```rust
#[test]
fn test_missing_initial_transactions_not_detected() {
    use aptos_temppath::TempPath;
    use aptos_types::account_address::AccountAddress;
    
    let tmp_dir = TempPath::new();
    let db = AptosDB::new_for_test(&tmp_dir);
    
    let account = AccountAddress::random();
    
    // Simulate database with only transactions seq_num=[5,6,7,8,9]
    // Transactions [0,1,2,3,4] are missing due to corruption
    let mut batch = SchemaBatch::new();
    for seq in 5..10 {
        batch.put::<OrderedTransactionByAccountSchema>(
            &(account, seq),
            &(seq as Version)
        ).unwrap();
    }
    db.ledger_db.transaction_db_raw().write_schemas(batch).unwrap();
    
    // Request transactions starting from seq_num=0
    let iter = db.transaction_store.get_account_ordered_transactions_iter(
        account,
        0,  // Request starting from 0
        10,
        100,
    ).unwrap();
    
    let results: Vec<_> = iter.collect::<Result<Vec<_>>>().unwrap();
    
    // BUG: Should return error about missing transactions [0,1,2,3,4]
    // Instead, silently returns [(5,5), (6,6), (7,7), (8,8), (9,9)]
    assert_eq!(results.len(), 5);
    assert_eq!(results[0].0, 5);  // First seq_num is 5, not 0!
    
    // This should have failed with DB corruption error but didn't!
}
```

The test demonstrates that requesting transactions from seq_num 0 silently returns transactions starting from seq_num 5 when the earlier transactions are missing, without any database corruption error being raised.

## Notes

This vulnerability specifically affects crash recovery scenarios where the indexer database becomes corrupted. The main transaction database may be intact, but the secondary index (`OrderedTransactionByAccountSchema`) could have gaps. This creates a dangerous situation where some nodes serve incomplete data without knowing it, while the underlying blockchain data is actually complete.

### Citations

**File:** storage/indexer_schemas/src/utils.rs (L54-69)
```rust
impl<'a> AccountOrderedTransactionsIter<'a> {
    pub fn new(
        inner: SchemaIterator<'a, OrderedTransactionByAccountSchema>,
        address: AccountAddress,
        end_seq_num: u64,
        ledger_version: Version,
    ) -> Self {
        Self {
            inner,
            address,
            end_seq_num,
            ledger_version,
            expected_next_seq_num: None,
            prev_version: None,
        }
    }
```

**File:** storage/indexer_schemas/src/utils.rs (L85-93)
```rust
                if let Some(expected_seq_num) = self.expected_next_seq_num {
                    ensure!(
                        seq_num == expected_seq_num,
                        "DB corruption: account transactions sequence numbers are not contiguous: \
                     actual: {}, expected: {}",
                        seq_num,
                        expected_seq_num,
                    );
                };
```

**File:** storage/indexer/src/db_indexer.rs (L174-191)
```rust
    pub fn get_account_ordered_transactions_iter(
        &self,
        address: AccountAddress,
        min_seq_num: u64,
        num_versions: u64,
        ledger_version: Version,
    ) -> Result<AccountOrderedTransactionsIter<'_>> {
        let mut iter = self.db.iter::<OrderedTransactionByAccountSchema>()?;
        iter.seek(&(address, min_seq_num))?;
        Ok(AccountOrderedTransactionsIter::new(
            iter,
            address,
            min_seq_num
                .checked_add(num_versions)
                .ok_or(AptosDbError::TooManyRequested(min_seq_num, num_versions))?,
            ledger_version,
        ))
    }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L179-193)
```rust
            let txns_with_proofs = self
                .transaction_store
                .get_account_ordered_transactions_iter(
                    address,
                    start_seq_num,
                    limit,
                    ledger_version,
                )?
                .map(|result| {
                    let (_seq_num, txn_version) = result?;
                    self.get_transaction_with_proof(txn_version, ledger_version, include_events)
                })
                .collect::<Result<Vec<_>>>()?;

            Ok(AccountOrderedTransactionsWithProof::new(txns_with_proofs))
```

**File:** storage/aptosdb/src/transaction_store/mod.rs (L54-59)
```rust
    /// Gets an iterator that yields `(sequence_number, version)` for each
    /// transaction sent by an account, with minimum sequence number greater
    /// `min_seq_num`, and returning at most `num_versions` results with
    /// `version <= ledger_version`.
    /// Guarantees that the returned sequence numbers are sequential, i.e.,
    /// `seq_num_{i} + 1 = seq_num_{i+1}`.
```

**File:** types/src/transaction/mod.rs (L2910-2935)
```rust
        self.0
            .iter()
            .enumerate()
            .try_for_each(|(seq_num_offset, txn_with_proof)| {
                let expected_seq_num = start_seq_num.saturating_add(seq_num_offset as u64);
                let txn_version = txn_with_proof.version;

                ensure!(
                    include_events == txn_with_proof.events.is_some(),
                    "unexpected events or missing events"
                );
                ensure!(
                    txn_version <= ledger_version,
                    "transaction with version ({}) greater than requested ledger version ({})",
                    txn_version,
                    ledger_version,
                );

                txn_with_proof.verify_user_txn(
                    ledger_info,
                    txn_version,
                    account,
                    ReplayProtector::SequenceNumber(expected_seq_num),
                )
            })
    }
```
