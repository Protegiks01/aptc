# Audit Report

## Title
ABA Problem in Stall Mechanism Due to Relaxed Memory Ordering in is_stalled()

## Summary
The `remove_stall()` function contains a race condition where it uses `Ordering::Relaxed` to re-check the stall count, allowing an ABA-like scenario where `dependency_shortcut` can be incorrectly set to `IsSafe` when `num_stalls > 0`. This violates the invariant that the dependency shortcut should accurately reflect the actual stall state.

## Finding Description [1](#0-0) 

The `remove_stall()` function performs a critical re-check at line 433 to ensure the transaction is truly unstalled before updating the dependency shortcut: [2](#0-1) 

However, this re-check calls `is_stalled()` which uses `Ordering::Relaxed`: [3](#0-2) 

This creates a race condition where:

1. **Initial State**: `num_stalls = 0`, `dependency_shortcut = IsSafe`, status = `Executed`
2. **Thread A** (add_stall): `fetch_add(1, SeqCst)` returns 0, `num_stalls = 1` 
3. **Thread B** (remove_stall): `fetch_sub(1, SeqCst)` returns 1, `num_stalls = 0`
4. **Thread B**: Acquires lock
5. **Thread C** (add_stall): `fetch_add(1, SeqCst)` returns 0, `num_stalls = 1`
6. **Thread B** (holding lock): Calls `is_stalled()` with `Relaxed` ordering
7. **Thread B**: Due to Relaxed semantics, may still see stale value `num_stalls = 0`
8. **Thread B**: Sets `dependency_shortcut = IsSafe` and releases lock

**Final Incorrect State**: `num_stalls = 1` (stalled) but `dependency_shortcut = IsSafe` (not stalled)

The comment at lines 389-392 claims this ABA problem cannot occur: [4](#0-3) 

However, the Relaxed ordering in `is_stalled()` allows exactly this scenario. The scheduler uses this shortcut to make stall propagation decisions: [5](#0-4) 

When the shortcut is incorrectly `IsSafe`, the scheduler propagates `remove_stall` signals when it should propagate `add_stall` signals, causing dependent transactions to execute prematurely and leading to cascading aborts.

## Impact Explanation
This qualifies as **High Severity** per Aptos bug bounty criteria: "Validator node slowdowns."

The incorrect stall propagation causes:
- Excessive cascading transaction aborts
- Increased re-execution overhead
- Degraded parallel execution performance
- Reduced block processing throughput

However, this does **not** cause:
- Consensus violations (validation catches conflicts)
- Fund loss (deterministic validation ensures correctness)
- State corruption (MVCC with validation prevents this)

The stall mechanism is documented as "best-effort" at line 752: [6](#0-5) 

But the bug causes a complete inversion of state (stalled vs unstalled), not minor imprecision.

## Likelihood Explanation
**Likelihood: Medium-High** in high-throughput scenarios

This race condition occurs naturally during parallel block execution when:
- Multiple threads concurrently call `add_stall()` and `remove_stall()`
- High transaction throughput with complex dependencies
- Multi-core validator hardware with aggressive CPU reordering

The race window is small but reproducible. The existing test `remove_stall_recheck` attempts to test this but doesn't fully cover the concurrent scenario: [7](#0-6) 

## Recommendation
Change `is_stalled()` to use stronger memory ordering:

```rust
pub(crate) fn is_stalled(&self) -> bool {
    self.num_stalls.load(Ordering::SeqCst) > 0
}
```

Or at minimum `Ordering::Acquire` to synchronize with the `SeqCst` operations in `add_stall()` and `remove_stall()`. This ensures the re-check in `remove_stall()` observes the most recent stall count modifications.

## Proof of Concept
```rust
// Concurrent test demonstrating the race condition
#[test]
fn test_aba_race_condition() {
    use std::sync::{Arc, Barrier};
    use std::thread;
    
    let statuses = Arc::new(ExecutionStatuses::new_for_test(
        ExecutionQueueManager::new_for_test(1),
        vec![ExecutionStatus::new_for_test(
            StatusWithIncarnation::new_for_test(SchedulingStatus::Executed, 1),
            0,
        )],
    ));
    
    let barrier = Arc::new(Barrier::new(3));
    let mut handles = vec![];
    
    // Thread A: add_stall (will increment to 1)
    let statuses_a = statuses.clone();
    let barrier_a = barrier.clone();
    handles.push(thread::spawn(move || {
        barrier_a.wait();
        statuses_a.add_stall(0).unwrap();
    }));
    
    // Thread B: remove_stall (will decrement to 0 then check)
    let statuses_b = statuses.clone();
    let barrier_b = barrier.clone();
    handles.push(thread::spawn(move || {
        barrier_b.wait();
        // This may incorrectly see num_stalls = 0 due to Relaxed ordering
        statuses_b.remove_stall(0).ok();
    }));
    
    // Thread C: add_stall (will increment to 1 after B's fetch_sub)
    let statuses_c = statuses.clone();
    let barrier_c = barrier.clone();
    handles.push(thread::spawn(move || {
        barrier_c.wait();
        thread::sleep(std::time::Duration::from_micros(1));
        statuses_c.add_stall(0).unwrap();
    }));
    
    for h in handles {
        h.join().unwrap();
    }
    
    // Bug: num_stalls > 0 but dependency_shortcut may be IsSafe
    let status = &statuses.statuses[0];
    let num_stalls = status.num_stalls.load(Ordering::SeqCst);
    let shortcut = status.dependency_shortcut.load(Ordering::SeqCst);
    
    // This assertion may fail, demonstrating the bug
    if num_stalls > 0 {
        assert_ne!(shortcut, DependencyStatus::IsSafe as u8,
            "Invariant violated: stalled but shortcut is IsSafe");
    }
}
```

## Notes
While this is a real concurrency bug that violates the stated invariant, its practical impact is limited to performance degradation rather than security compromise. The block executor's validation layer provides a safety net that prevents state corruption or consensus violations even when the stall mechanism fails. Nevertheless, fixing the memory ordering would eliminate unnecessary abort cascades and improve validator performance under high load.

### Citations

**File:** aptos-move/block-executor/src/scheduler_status.rs (L389-392)
```rust
                    // May not update IsSafe dependency status at an incorrect time in the future
                    // (i.e. ABA), as observing num_stalls = 0 under status is required to set
                    // IsSafe status, but impossible until the corresponding remove_stall (that
                    // starts only after add_stall finishes).
```

**File:** aptos-move/block-executor/src/scheduler_status.rs (L417-461)
```rust
    pub(crate) fn remove_stall(&self, txn_idx: TxnIndex) -> Result<bool, PanicError> {
        let status = &self.statuses[txn_idx as usize];
        let prev_num_stalls = status.num_stalls.fetch_sub(1, Ordering::SeqCst);

        if prev_num_stalls == 0 {
            return Err(code_invariant_error(
                "remove_stall called when num_stalls == 0",
            ));
        }

        if prev_num_stalls == 1 {
            // Acquire write lock for (non-monitor) shortcut modifications.
            let status_guard = status.status_with_incarnation.lock();

            // num_stalls updates are not under the lock, so need to re-check (otherwise
            // a different add_stall might have already incremented the count).
            if status.is_stalled() {
                return Ok(false);
            }

            if let Some(incarnation) = status_guard.pending_scheduling() {
                if incarnation == 0 {
                    // Invariant due to scheduler logic: for a successful remove_stall there
                    // must have been an add_stall for incarnation 0, which is impossible.
                    return Err(code_invariant_error("0-th incarnation in remove_stall"));
                }
                self.execution_queue_manager
                    .add_to_schedule(incarnation == 1, txn_idx);
            } else if status_guard.is_executed() {
                // TODO(BlockSMTv2): Here, when waiting is supported, if inner status is executed,
                // would need to notify waiting workers.

                // Status is Executed so the dependency status may not be WaitForExecution
                // (finish_execution sets ShouldDefer or IsSafe dependency status).
                status.swap_dependency_status_any(
                    &[DependencyStatus::ShouldDefer, DependencyStatus::IsSafe],
                    DependencyStatus::IsSafe,
                    "remove_stall",
                )?;
            }

            return Ok(true);
        }
        Ok(false)
    }
```

**File:** aptos-move/block-executor/src/scheduler_status.rs (L750-752)
```rust
    /// Checks that the dependency status is IsSafe. This is used by the scheduler
    /// when removing a previously propagated stall signal, and it is safe to
    /// use the shortcutbecause of the best-effort nature of the stall mechanism.
```

**File:** aptos-move/block-executor/src/scheduler_status.rs (L959-961)
```rust
    pub(crate) fn is_stalled(&self) -> bool {
        self.num_stalls.load(Ordering::Relaxed) > 0
    }
```

**File:** aptos-move/block-executor/src/scheduler_status.rs (L1697-1727)
```rust
    #[test]
    fn remove_stall_recheck() {
        // Executed and stalled status.
        let statuses =
            ExecutionStatuses::new_for_test(ExecutionQueueManager::new_for_test(1), vec![
                ExecutionStatus::new_for_test(
                    StatusWithIncarnation::new_for_test(SchedulingStatus::Executed, 0),
                    1,
                ),
            ]);
        let status = &statuses.get_status(0);

        rayon::scope(|s| {
            // Acquire the lock to stop remove_stall call.
            let guard = status.status_with_incarnation.lock();

            s.spawn(|_| {
                // false due to the main thread incrementing stall count below.
                assert_ok_eq!(statuses.remove_stall(0), false);
            });

            while status.num_stalls.load(Ordering::Relaxed) != 0 {}
            status.num_stalls.fetch_add(1, Ordering::Relaxed);
            drop(guard);
        });

        assert_eq!(
            status.dependency_shortcut.load(Ordering::Relaxed),
            DependencyStatus::ShouldDefer as u8
        );
    }
```

**File:** aptos-move/block-executor/src/scheduler_v2.rs (L1224-1227)
```rust
            if self
                .txn_statuses
                .shortcut_executed_and_not_stalled(task_idx)
            {
```
