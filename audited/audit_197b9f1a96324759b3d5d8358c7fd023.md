# Audit Report

## Title
Frozen State Loss During Coin-to-Fungible Asset Migration with Zero Balance

## Summary
The `maybe_convert_to_fungible_store` function in the coin module fails to synchronize the frozen state when migrating a CoinStore with zero balance, allowing previously frozen accounts to become unfrozen if a primary fungible store already exists.

## Finding Description

The vulnerability exists in the migration logic that converts legacy `CoinStore` resources to the new `FungibleStore` system. The critical flaw is in the conditional check that guards frozen state synchronization: [1](#0-0) 

This condition requires BOTH `is_coin_initialized<CoinType>()` AND `coin.value > 0` to be true. When the coin balance is zero, the function takes the else branch: [2](#0-1) 

The frozen state synchronization logic is only executed inside the if-block: [3](#0-2) 

When `coin.value == 0`, this synchronization is completely bypassed. If a primary fungible store already exists (which can happen when the account receives fungible assets directly), it was created with the default frozen state of `false`: [4](#0-3) 

**Attack Scenario:**

1. Account A has a frozen CoinStore with 100 tokens (frozen for regulatory/fraud prevention)
2. Account A withdraws all 100 tokens, leaving `frozen=true, balance=0`
3. Account B sends Account A fungible assets directly via `primary_fungible_store::deposit`: [5](#0-4) 
   
   This creates a primary fungible store with `frozen=false` (default)
4. Migration is triggered (voluntarily or automatically when feature is enabled)
5. The CoinStore is destroyed, but frozen state is NOT synchronized (because balance is 0)
6. Account A now has an unfrozen primary fungible store despite being previously frozen

This breaks the security invariant that frozen accounts must remain frozen across system migrations.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria:

- **Significant Protocol Violation**: The frozen state is a critical security control mechanism used for regulatory compliance, fraud prevention, and asset protection. Losing this state during migration violates the fundamental guarantee that frozen accounts remain frozen.

- **Access Control Bypass**: Frozen accounts should be immutable with respect to transfers. This vulnerability allows bypassing that control simply by having zero balance during migration.

- **System-Wide Impact**: Any account with a frozen CoinStore and zero balance is vulnerable during migration. This affects regulatory compliance and can enable previously frozen malicious actors to resume asset transfers.

While this doesn't directly result in immediate loss of funds or consensus violations, it represents a significant security control bypass that could lead to regulatory issues and enable previously frozen accounts to move assets.

## Likelihood Explanation

The likelihood of this vulnerability occurring is **HIGH**:

1. **Common Scenario**: It's natural for accounts to have zero balance temporarily (after withdrawing all funds, burning coins, etc.) while maintaining frozen status
2. **Easy to Trigger**: Any account can receive fungible assets directly, automatically creating a primary store before migration
3. **Automatic Migration**: The migration can be triggered automatically when feature flags are enabled, affecting all accounts with CoinStores: [6](#0-5) 

4. **No Warning**: The code comments acknowledge that primary stores may exist before migration, but this acknowledgment is inside the conditional block that requires non-zero balance, missing the zero-balance case entirely: [7](#0-6) 

## Recommendation

Move the frozen state synchronization logic outside the `coin.value > 0` conditional check. The frozen state should be synchronized whenever a CoinStore exists, regardless of balance:

```move
fun maybe_convert_to_fungible_store<CoinType>(
    account: address
) acquires CoinStore, CoinConversionMap, CoinInfo {
    if (exists<CoinStore<CoinType>>(account)) {
        let CoinStore<CoinType> { coin, frozen, deposit_events, withdraw_events } =
            move_from<CoinStore<CoinType>>(account);
        
        // Always ensure primary store and sync frozen state if CoinStore existed
        let should_sync_frozen = is_coin_initialized<CoinType>();
        
        if (should_sync_frozen && coin.value > 0) {
            let metadata = ensure_paired_metadata<CoinType>();
            let store = primary_fungible_store::ensure_primary_store_exists(account, metadata);
            
            event::emit(CoinStoreDeletion { /* ... */ });
            
            fungible_asset::unchecked_deposit_with_no_events(
                object_address(&store),
                coin_to_fungible_asset(coin)
            );
            
            if (frozen != fungible_asset::is_frozen(store)) {
                fungible_asset::set_frozen_flag_internal(store, frozen);
            }
        } else if (should_sync_frozen) {
            // Sync frozen state even with zero balance
            let metadata = ensure_paired_metadata<CoinType>();
            let store = primary_fungible_store::ensure_primary_store_exists(account, metadata);
            
            if (frozen != fungible_asset::is_frozen(store)) {
                fungible_asset::set_frozen_flag_internal(store, frozen);
            }
            
            destroy_zero(coin);
        } else {
            destroy_zero(coin);
        };
        
        event::destroy_handle(deposit_events);
        event::destroy_handle(withdraw_events);
    };
}
```

## Proof of Concept

```move
#[test(framework = @0x1, user = @0x100)]
fun test_frozen_state_lost_on_zero_balance_migration(framework: &signer, user: &signer) {
    // Setup: Initialize coin and create frozen CoinStore with balance
    let (burn_cap, freeze_cap, mint_cap) = initialize<TestCoin>(framework);
    
    register<TestCoin>(user);
    let user_addr = signer::address_of(user);
    
    // Mint and deposit 100 coins
    let coins = mint<TestCoin>(100, &mint_cap);
    deposit(user_addr, coins);
    
    // Freeze the account
    freeze_coin_store<TestCoin>(user_addr, &freeze_cap);
    assert!(is_frozen<TestCoin>(user_addr), 1);
    
    // User withdraws all coins (balance becomes 0, frozen state remains)
    let all_coins = withdraw<TestCoin>(user, 100);
    burn(all_coins, &burn_cap);
    assert!(coin_balance<TestCoin>(user_addr) == 0, 2);
    assert!(is_frozen<TestCoin>(user_addr), 3); // Still frozen!
    
    // Someone sends fungible asset to user, creating primary store
    let metadata = ensure_paired_metadata<TestCoin>();
    let fa = fungible_asset::mint(&mint_cap, 50);
    primary_fungible_store::deposit(user_addr, fa);
    
    // Primary store exists and is UNFROZEN (default)
    assert!(primary_fungible_store::primary_store_exists(user_addr, metadata), 4);
    assert!(!primary_fungible_store::is_frozen(user_addr, metadata), 5);
    
    // Trigger migration
    migrate_to_fungible_store<TestCoin>(user);
    
    // VULNERABILITY: CoinStore is deleted but frozen state was NOT synchronized!
    // Primary store remains UNFROZEN despite original CoinStore being frozen
    assert!(!exists<CoinStore<TestCoin>>(user_addr), 6);
    assert!(!primary_fungible_store::is_frozen(user_addr, metadata), 7); // FAILS - should be frozen!
    
    // User can now transfer assets despite being previously frozen
    let fa_withdrawn = primary_fungible_store::withdraw(user, metadata, 50);
    primary_fungible_store::deposit(@0x200, fa_withdrawn); // Success - frozen state bypassed!
}
```

**Validation**: This PoC demonstrates that when a frozen CoinStore with zero balance is migrated while a primary fungible store already exists, the frozen state is completely lost, allowing the previously frozen account to perform transfers.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L656-656)
```text
            if (is_coin_initialized<CoinType>() && coin.value > 0) {
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L687-691)
```text
                // Note:
                // It is possible the primary fungible store may already exist before this function call.
                // In this case, if the account owns a frozen CoinStore and an unfrozen primary fungible store, this
                // function would convert and deposit the rest coin into the primary store and freeze it to make the
                // `frozen` semantic as consistent as possible.
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L692-694)
```text
                if (frozen != fungible_asset::is_frozen(store)) {
                    fungible_asset::set_frozen_flag_internal(store, frozen);
                }
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L695-696)
```text
            } else {
                destroy_zero(coin);
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L726-738)
```text
    public entry fun migrate_coin_store_to_fungible_store<CoinType>(
        accounts: vector<address>
    ) acquires CoinStore, CoinConversionMap, CoinInfo {
        if (features::new_accounts_default_to_fa_store_enabled()
            || features::new_accounts_default_to_fa_apt_store_enabled()) {
            std::vector::for_each(
                accounts,
                |account| {
                    maybe_convert_to_fungible_store<CoinType>(account);
                }
            );
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/fungible_asset.move (L886-886)
```text
            FungibleStore { metadata: metadata.convert(), balance: 0, frozen: false }
```

**File:** aptos-move/framework/aptos-framework/sources/primary_fungible_store.move (L195-199)
```text
    public fun deposit(owner: address, fa: FungibleAsset) acquires DeriveRefPod {
        let metadata = fa.asset_metadata();
        let store = ensure_primary_store_exists(owner, metadata);
        dispatchable_fungible_asset::deposit(store, fa);
    }
```
