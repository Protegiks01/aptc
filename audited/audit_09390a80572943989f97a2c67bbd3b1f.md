# Audit Report

## Title
Fee Payer Transaction Simulation Uses Incorrect Address for Balance Query Leading to Wrong Max Gas Calculation

## Summary
The `simulate_transaction()` function in `api/src/transactions.rs` queries the wrong account's balance when estimating maximum gas for fee payer transactions. It queries the transaction sender's balance instead of the fee payer's balance, causing incorrect `max_gas_amount` calculations that can lead to failed transactions or underutilization of available gas.

## Finding Description

When `simulate_transaction()` is called with `estimate_max_gas_amount=true`, the function queries the AptosCoin balance to calculate the maximum gas units available. However, for fee payer transactions (where a separate account pays gas fees instead of the sender), the code incorrectly uses the sender's address instead of the fee payer's address. [1](#0-0) 

The balance query uses `signed_transaction.sender().to_vec()` on line 675, but for fee payer transactions, gas is actually deducted from the fee payer, not the sender. This is confirmed by the transaction validation prologue which checks the gas payer's balance: [2](#0-1) 

The prologue explicitly validates that the **gas payer** (not sender) has sufficient balance at lines 203 and 208. The fee payer address can be extracted from the transaction authenticator: [3](#0-2) 

The transaction context module clearly distinguishes between sender and gas payer: [4](#0-3) 

## Impact Explanation

**Medium Severity** - This qualifies as "State inconsistencies requiring intervention" and can cause "Limited funds loss or manipulation" per the bug bounty criteria:

1. **Transaction Failure**: If sender has high balance but fee payer has low balance, the API returns an overestimated `max_gas_amount`. When the transaction is submitted for actual execution, it fails due to insufficient fee payer balance, wasting the sender's time and potentially causing application failures.

2. **Gas Underutilization**: If sender has low/zero balance but fee payer has high balance, the API returns an underestimated `max_gas_amount` or may fail the simulation entirely, preventing users from utilizing the full gas capacity available to them.

3. **Incorrect User Experience**: Simulations are used to predict transaction behavior before submission. Incorrect max gas estimates break this guarantee and can cause unexpected behavior in production.

The issue affects the simulation endpoint only (not actual execution), so it doesn't directly cause fund loss but creates state inconsistencies between simulation and execution.

## Likelihood Explanation

**High Likelihood** - This bug will occur every time someone:
1. Uses the fee payer transaction feature (a standard Aptos feature for sponsored transactions)
2. Calls `/transactions/simulate` with `estimate_max_gas_amount=true`
3. The sender and fee payer have different balances (common scenario)

Fee payer transactions are actively used for account abstraction and sponsored transaction use cases. The test suite confirms fee payer transactions are a core feature: [5](#0-4) 

This test shows fee payer transactions are tested in the simulation path, confirming they are expected to work correctly.

## Recommendation

The fix is to query the balance of the actual gas payer instead of the sender. The gas payer should be determined by checking if a fee payer exists in the transaction authenticator:

```rust
// Around line 670-677 in api/src/transactions.rs
let gas_payer_address = signed_transaction
    .authenticator_ref()
    .fee_payer_address()
    .unwrap_or_else(|| signed_transaction.sender());

let output = AptosVM::execute_view_function(
    &state_view,
    ModuleId::new(AccountAddress::ONE, ident_str!("coin").into()),
    ident_str!("balance").into(),
    vec![AptosCoinType::type_tag()],
    vec![gas_payer_address.to_vec()],  // Use gas_payer_address instead of sender
    context.node_config.api.max_gas_view_function,
);
```

This matches the logic in `TransactionMetadata` which properly extracts the fee payer: [6](#0-5) 

## Proof of Concept

```rust
// Reproduction steps:
// 1. Create a fee payer transaction where:
//    - Sender has 1000 APT balance
//    - Fee payer has 100 APT balance  
//    - Gas price is 100
// 2. Call simulate with estimate_max_gas_amount=true
// 3. Observe that max_gas_amount is calculated based on sender's 1000 APT
//    instead of fee payer's 100 APT
// 4. Result: max_gas_amount = min(1000/100, max_gas_units) = 10 units
//    Correct: max_gas_amount = min(100/100, max_gas_units) = 1 unit
// 5. Transaction will fail on actual submission due to insufficient fee payer funds

// Test can be added to api/src/tests/simulation_test.rs:
#[tokio::test(flavor = "multi_thread", worker_threads = 2)]
async fn test_simulate_fee_payer_max_gas_uses_wrong_balance() {
    let mut context = new_test_context(current_function_name!());
    
    // Setup: sender with high balance, fee payer with low balance
    let sender = &mut context.gen_account();
    let fee_payer = &mut context.gen_account();
    
    // Mint 1000 APT to sender
    let txn = context.mint_user_account(sender).await;
    context.commit_block(&vec![txn]).await;
    
    // Mint only 100 APT to fee payer  
    let txn = context.create_user_account(fee_payer).await;
    context.commit_block(&vec![txn]).await;
    let txn = context.mint_specific_amount(fee_payer, 100_000_000).await; // 100 APT
    context.commit_block(&vec![txn]).await;
    
    // Create fee payer transaction
    let transfer_txn = context.account_transfer_to(sender, AccountAddress::random(), 1);
    let raw_txn = transfer_txn.into_raw_transaction();
    let signed_txn = SignedTransaction::new_fee_payer(
        raw_txn,
        AccountAuthenticator::NoAccountAuthenticator,
        vec![],
        vec![],
        fee_payer.address(),
        AccountAuthenticator::NoAccountAuthenticator,
    );
    
    // Simulate with estimate_max_gas_amount=true
    // BUG: This will use sender's balance (1000 APT) instead of fee_payer's (100 APT)
    let resp = context
        .post_bcs_txn("/transactions/simulate?estimate_max_gas_amount=true", 
                      bcs::to_bytes(&signed_txn).unwrap())
        .await;
    
    // The max_gas_amount will be incorrectly high based on sender's balance
    // instead of fee payer's actual balance
}
```

**Notes**

This vulnerability breaks the invariant that "Resource Limits: All operations must respect gas, storage, and computational limits" by providing incorrect gas limit estimates that don't match the actual gas payer's capacity. While the bug is in the simulation endpoint and doesn't affect actual transaction execution, it creates a critical mismatch between simulated and real behavior, which is the exact purpose simulations are meant to prevent.

### Citations

**File:** api/src/transactions.rs (L670-677)
```rust
                let output = AptosVM::execute_view_function(
                    &state_view,
                    ModuleId::new(AccountAddress::ONE, ident_str!("coin").into()),
                    ident_str!("balance").into(),
                    vec![AptosCoinType::type_tag()],
                    vec![signed_transaction.sender().to_vec()],
                    context.node_config.api.max_gas_view_function,
                );
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L187-212)
```text
        // Check if the gas payer has enough balance to pay for the transaction
        let max_transaction_fee = txn_gas_price * txn_max_gas_units;
        if (!skip_gas_payment(
            is_simulation,
            gas_payer_address
        )) {
            assert!(
                permissioned_signer::check_permission_capacity_above(
                    gas_payer,
                    (max_transaction_fee as u256),
                    GasPermission {}
                ),
                error::permission_denied(PROLOGUE_PERMISSIONED_GAS_LIMIT_INSUFFICIENT)
            );
            if (features::operations_default_to_fa_apt_store_enabled()) {
                assert!(
                    aptos_account::is_fungible_balance_at_least(gas_payer_address, max_transaction_fee),
                    error::invalid_argument(PROLOGUE_ECANT_PAY_GAS_DEPOSIT)
                );
            } else {
                assert!(
                    coin::is_balance_at_least<AptosCoin>(gas_payer_address, max_transaction_fee),
                    error::invalid_argument(PROLOGUE_ECANT_PAY_GAS_DEPOSIT)
                );
            }
        };
```

**File:** types/src/transaction/authenticator.rs (L297-311)
```rust
    pub fn fee_payer_address(&self) -> Option<AccountAddress> {
        match self {
            Self::Ed25519 { .. }
            | Self::MultiEd25519 { .. }
            | Self::MultiAgent { .. }
            | Self::SingleSender { .. } => None,
            Self::FeePayer {
                sender: _,
                secondary_signer_addresses: _,
                secondary_signers: _,
                fee_payer_address,
                ..
            } => Some(*fee_payer_address),
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_context.move (L103-111)
```text
    /// Returns the gas payer address for the current transaction.
    /// It is either the sender's address if no separate gas fee payer is specified for the current transaction,
    /// or the address of the separate gas fee payer if one is specified.
    /// This function aborts if called outside of the transaction prologue, execution, or epilogue phases.
    public fun gas_payer(): address {
        assert!(features::transaction_context_extension_enabled(), error::invalid_state(ETRANSACTION_CONTEXT_EXTENSION_NOT_ENABLED));
        gas_payer_internal()
    }
    native fun gas_payer_internal(): address;
```

**File:** api/src/tests/simulation_test.rs (L464-515)
```rust
async fn bcs_simulate_fee_payer_transaction_without_gas_fee_check(context: &mut TestContext) {
    let alice = &mut context.gen_account();
    let bob = &mut context.gen_account();
    let txn = context.mint_user_account(alice).await;
    context.commit_block(&vec![txn]).await;

    let transfer_amount: u64 = SMALL_TRANSFER_AMOUNT;
    let txn = context.account_transfer_to(alice, bob.address(), transfer_amount);
    let mut raw_txn = txn.clone().into_raw_transaction();
    raw_txn.set_gas_unit_price(100);
    let txn = SignedTransaction::new_signed_transaction(
        raw_txn.clone(),
        TransactionAuthenticator::FeePayer {
            sender: AccountAuthenticator::NoAccountAuthenticator,
            secondary_signer_addresses: vec![],
            secondary_signers: vec![],
            fee_payer_address: AccountAddress::ONE,
            fee_payer_signer: AccountAuthenticator::NoAccountAuthenticator,
        },
    );
    let body = bcs::to_bytes(&txn).unwrap();
    let resp = context
        .expect_status_code(200)
        .post_bcs_txn("/transactions/simulate", body)
        .await;
    assert!(!resp[0]["success"].as_bool().unwrap(), "{}", pretty(&resp));
    assert!(
        resp[0]["vm_status"]
            .as_str()
            .unwrap()
            .contains("INSUFFICIENT_BALANCE_FOR_TRANSACTION_FEE"),
        "{}",
        pretty(&resp)
    );

    let txn = SignedTransaction::new_signed_transaction(
        raw_txn.clone(),
        TransactionAuthenticator::FeePayer {
            sender: AccountAuthenticator::NoAccountAuthenticator,
            secondary_signer_addresses: vec![],
            secondary_signers: vec![],
            fee_payer_address: AccountAddress::ZERO,
            fee_payer_signer: AccountAuthenticator::NoAccountAuthenticator,
        },
    );
    let body = bcs::to_bytes(&txn).unwrap();
    let resp = context
        .expect_status_code(200)
        .post_bcs_txn("/transactions/simulate", body)
        .await;
    assert!(resp[0]["success"].as_bool().unwrap(), "{}", pretty(&resp));
}
```

**File:** aptos-move/aptos-vm/src/transaction_metadata.rs (L44-60)
```rust
    pub fn new(txn: &SignedTransaction, auxiliary_info: &AuxiliaryInfo) -> Self {
        Self {
            sender: txn.sender(),
            authentication_proof: txn.authenticator().sender().authentication_proof(),
            secondary_signers: txn.authenticator().secondary_signer_addresses(),
            secondary_authentication_proofs: txn
                .authenticator()
                .secondary_signers()
                .iter()
                .map(|account_auth| account_auth.authentication_proof())
                .collect(),
            replay_protector: txn.replay_protector(),
            fee_payer: txn.authenticator_ref().fee_payer_address(),
            fee_payer_authentication_proof: txn
                .authenticator()
                .fee_payer_signer()
                .map(|signer| signer.authentication_proof()),
```
