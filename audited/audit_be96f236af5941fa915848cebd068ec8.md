# Audit Report

## Title
Keyless Account DoS via Unconstrained max_commited_epk_bytes Configuration Parameter

## Summary
The on-chain `Configuration.max_commited_epk_bytes` parameter can be modified via governance without validation, allowing it to diverge from the hardcoded ZK circuit constant `circuit_constants::MAX_COMMITED_EPK_BYTES` (93 bytes). This mismatch causes all keyless ZK proof verifications to fail, resulting in complete denial-of-service for keyless accounts until the configuration is reverted.

## Finding Description

The vulnerability stems from a critical mismatch between the immutable ZK circuit constraints and mutable on-chain configuration:

**Circuit Constant (Immutable):**
The ZK circuit is compiled with a fixed `MAX_COMMITED_EPK_BYTES = 93` bytes, defined as: [1](#0-0) 

This produces exactly 3 BN254 field elements when packing the ephemeral public key (EPK): `ceil(93 / 31) = 3 scalars`, where 31 bytes is the maximum data per scalar: [2](#0-1) 

**On-Chain Configuration (Mutable):**
The Move framework defines a `Configuration` struct with a mutable `max_commited_epk_bytes: u16` field: [3](#0-2) 

Governance can update this value via `set_configuration_for_next_epoch()` with **no validation**: [4](#0-3) 

**The Attack:**
When validators verify keyless signatures, they compute the public inputs hash using the on-chain configuration value: [5](#0-4) 

The packing function `pad_and_pack_bytes_to_scalars_with_len` generates `ceil(max_bytes / 31)` scalars: [6](#0-5) 

If governance changes `max_commited_epk_bytes` from 93 to any other value (e.g., 62 → 2 scalars, 124 → 4 scalars), the public inputs hash will differ from what the circuit expects, causing all ZK proof verifications to fail: [7](#0-6) 

**Attack Execution Path:**
1. Malicious or misconfigured governance proposal calls `set_configuration_for_next_epoch()` with `max_commited_epk_bytes = 62` (or any value ≠ 93)
2. Epoch reconfiguration applies the new configuration via `on_new_epoch()`
3. All subsequent keyless ZK proof verifications fail with "groth16 proof verification failed" because the public inputs hash computed by validators (using 2 scalars) doesn't match what provers generated (using 3 scalars)
4. All keyless account transactions are rejected, causing complete service disruption

## Impact Explanation

**HIGH Severity** - This vulnerability meets multiple high-severity criteria from the Aptos bug bounty program:

1. **Validator Node Slowdowns/Issues**: While proof verification will fail quickly, the broader impact is systemic dysfunction where all keyless transactions are rejected, effectively degrading validator performance for handling keyless traffic.

2. **Significant Protocol Violations**: This breaks the **Deterministic Execution** invariant - validators compute different public inputs hashes than prover services expect, violating the cryptographic protocol's correctness guarantees.

3. **State Inconsistencies Requiring Intervention**: Recovery requires emergency governance action to revert the configuration, similar to the Medium severity category but with more severe operational impact.

**Affected Systems:**
- All keyless account users (cannot submit transactions)
- Prover services (generate invalid proofs)
- Validators (waste resources rejecting valid-looking but unverifiable proofs)

**No Funds Loss**: While severe, this doesn't result in fund theft or minting, preventing Critical classification.

## Likelihood Explanation

**Likelihood: Medium to High**

**Favorable Attack Conditions:**
1. **Governance Access Required**: The attacker needs to pass a governance proposal, which requires significant stake/voting power
2. **Accidental Trigger**: More likely to occur through accidental misconfiguration during routine parameter updates than malicious intent
3. **Documentation Ambiguity**: The Move code includes detailed comments about circuit dependencies for other parameters but the relationship between the on-chain value and circuit constant is not validated at the protocol level

**Mitigation Factors:**
- Requires governance consensus
- Would be caught quickly due to immediate failure of all keyless transactions
- Can be reverted via emergency governance action

However, the **lack of any validation** makes accidental misconfiguration a realistic risk, especially as the keyless configuration evolves over time.

## Recommendation

**Immediate Fix: Add validation in the Move module**

Add a constant validation in `keyless_account.move` to enforce the circuit constraint:

```move
// In keyless_account.move
const MAX_COMMITED_EPK_BYTES_CIRCUIT_LIMIT: u16 = 93;

public fun new_configuration(
    override_aud_val: vector<String>,
    max_signatures_per_txn: u16,
    max_exp_horizon_secs: u64,
    training_wheels_pubkey: Option<vector<u8>>,
    max_commited_epk_bytes: u16,
    max_iss_val_bytes: u16,
    max_extra_field_bytes: u16,
    max_jwt_header_b64_bytes: u32
): Configuration {
    // Validate circuit constant match
    assert!(
        max_commited_epk_bytes == MAX_COMMITED_EPK_BYTES_CIRCUIT_LIMIT,
        E_INVALID_MAX_COMMITED_EPK_BYTES
    );
    
    Configuration {
        override_aud_vals: override_aud_val,
        max_signatures_per_txn,
        max_exp_horizon_secs,
        training_wheels_pubkey,
        max_commited_epk_bytes,
        max_iss_val_bytes,
        max_extra_field_bytes,
        max_jwt_header_b64_bytes,
    }
}
```

**Additional Safeguards:**
1. Add similar validation in `set_configuration_for_next_epoch()` 
2. Document the circuit dependency in the field's docstring
3. Consider making `max_commited_epk_bytes` immutable or require special circuit upgrade flag when changing it

## Proof of Concept

```move
// Test in keyless_account.move or governance test suite
#[test(framework = @aptos_framework)]
#[expected_failure(abort_code = E_INVALID_MAX_COMMITED_EPK_BYTES)]
fun test_reject_invalid_epk_bytes(framework: &signer) {
    // Attempt to create configuration with incorrect max_commited_epk_bytes
    let bad_config = new_configuration(
        vector[],
        3,
        10_000_000,
        option::none(),
        62,  // WRONG VALUE - should be 93
        120,
        350,
        300
    );
    
    // This should abort due to validation
    set_configuration_for_next_epoch(framework, bad_config);
}

#[test(framework = @aptos_framework)]
fun test_accept_valid_epk_bytes(framework: &signer) {
    // Valid configuration with correct max_commited_epk_bytes
    let good_config = new_configuration(
        vector[],
        3,
        10_000_000,
        option::none(),
        93,  // CORRECT VALUE
        120,
        350,
        300
    );
    
    // This should succeed
    set_configuration_for_next_epoch(framework, good_config);
}
```

## Notes

The vulnerability exists at the intersection of on-chain governance flexibility and off-chain ZK circuit immutability. While the Move code documents circuit dependencies for `max_iss_val_bytes`, `max_extra_field_bytes`, and `max_jwt_header_b64_bytes` (lines 117-134), the critical relationship between `max_commited_epk_bytes` and the circuit's scalar packing logic is not enforced programmatically.

The circuit constant is correctly initialized in `Configuration::new_for_devnet()`: [8](#0-7) 

However, once deployed on-chain, governance can bypass this initialization by directly calling `set_configuration_for_next_epoch()` with arbitrary values, breaking the critical circuit invariant.

### Citations

**File:** types/src/keyless/circuit_constants.rs (L25-26)
```rust
pub(crate) const MAX_COMMITED_EPK_BYTES: u16 =
    3 * poseidon_bn254::keyless::BYTES_PACKED_PER_SCALAR as u16;
```

**File:** crates/aptos-crypto/src/poseidon_bn254/keyless.rs (L16-16)
```rust
pub const BYTES_PACKED_PER_SCALAR: usize = 31;
```

**File:** crates/aptos-crypto/src/poseidon_bn254/keyless.rs (L85-111)
```rust
pub fn pad_and_pack_bytes_to_scalars_with_len(
    bytes: &[u8],
    max_bytes: usize,
) -> anyhow::Result<Vec<ark_bn254::Fr>> {
    let len = bytes.len();
    if max_bytes > MAX_NUM_INPUT_BYTES {
        bail!(
            "Cannot hash more than {} bytes. Was given {} bytes.",
            MAX_NUM_INPUT_BYTES,
            len
        );
    }
    if len > max_bytes {
        bail!(
            "Byte array length of {} is NOT <= max length of {} bytes.",
            bytes.len(),
            max_bytes
        );
    }

    let len_scalar = pack_bytes_to_one_scalar(&len.to_le_bytes())?;
    let scalars = pad_and_pack_bytes_to_scalars_no_len(bytes, max_bytes)?
        .into_iter()
        .chain([len_scalar])
        .collect::<Vec<ark_bn254::Fr>>();
    Ok(scalars)
}
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L111-111)
```text
        max_commited_epk_bytes: u16,
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L274-277)
```text
    public fun set_configuration_for_next_epoch(fx: &signer, config: Configuration) {
        system_addresses::assert_aptos_framework(fx);
        config_buffer::upsert<Configuration>(config);
    }
```

**File:** types/src/keyless/bn254_circom.rs (L331-334)
```rust
    let mut epk_frs = poseidon_bn254::keyless::pad_and_pack_bytes_to_scalars_with_len(
        epk.to_bytes().as_slice(),
        config.max_commited_epk_bytes as usize,
    )?;
```

**File:** types/src/keyless/groth16_sig.rs (L215-235)
```rust
    pub fn verify_proof(
        &self,
        public_inputs_hash: Fr,
        pvk: &PreparedVerifyingKey<Bn254>,
    ) -> anyhow::Result<()> {
        // let start = std::time::Instant::now();
        let proof: Proof<Bn254> = Proof {
            a: self.a.deserialize_into_affine()?,
            b: self.b.deserialize_into_affine()?,
            c: self.c.deserialize_into_affine()?,
        };
        // println!("Deserialization time: {:?}", start.elapsed());

        // let start = std::time::Instant::now();
        let verified = Groth16::<Bn254>::verify_proof(pvk, &proof, &[public_inputs_hash])?;
        // println!("Proof verification time: {:?}", start.elapsed());
        if !verified {
            bail!("groth16 proof verification failed")
        }
        Ok(())
    }
```

**File:** types/src/keyless/configuration.rs (L68-68)
```rust
            max_commited_epk_bytes: circuit_constants::MAX_COMMITED_EPK_BYTES,
```
