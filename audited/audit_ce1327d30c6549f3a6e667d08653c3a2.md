# Audit Report

## Title
Transaction Filter DoS via MultiKey Authenticator Public Key Enumeration

## Summary
An attacker can craft transactions with multiple MultiKey authenticators containing maximum public keys (32 each) but minimum signatures (1 each) to cause CPU exhaustion during transaction filtering when PublicKey or AccountAddress matchers are configured. The validation logic limits total signatures to 32, but the filtering logic iterates through all public keys, creating an exploitable asymmetry that allows up to 1024 public keys per transaction to be checked against each filter matcher.

## Finding Description
The vulnerability exists in a critical mismatch between transaction validation and filter matching complexity:

**Validation Logic** limits the total number of **signatures** across all authenticators to 32 via the MAX_NUM_OF_SIGS constant and verification in the TransactionAuthenticator::verify() method: [1](#0-0) [2](#0-1) 

For MultiKey authenticators, the number_of_signatures() method returns only the signature count, not the public key count: [3](#0-2) 

**Filter Matching Logic** iterates through **all public keys** in MultiKey authenticators when checking PublicKey matchers: [4](#0-3) 

Similarly, AccountAddress matchers iterate all public keys in MultiKey authenticators: [5](#0-4) 

For FeePayer transactions, the filter checks sender + all secondary_signers + fee_payer_signer: [6](#0-5) 

Each MultiKey can have up to 32 public keys, as enforced during construction: [7](#0-6) 

The filter is applied synchronously in mempool without timeout or computational budget during transaction processing: [8](#0-7) [9](#0-8) 

**Attack Path:**
1. Operator configures transaction filters with PublicKey or AccountAddress matchers (legitimate use case for regulatory compliance or access control)
2. Attacker crafts a FeePayer transaction with 32 AccountAuthenticators (sender + 30 secondary_signers + fee_payer_signer)
3. Each authenticator is a MultiKey with 32 public keys but only 1 signature
4. Total signatures: 32 (passes MAX_NUM_OF_SIGS validation)
5. Total public keys: 32 authenticators × 32 keys = 1024 keys
6. Filter checking iterates through all 1024 keys for each PublicKey/AccountAddress matcher
7. With N matchers in M rules, complexity becomes O(1024 × N × M) per transaction
8. Attacker submits multiple such transactions concurrently to exhaust CPU and block legitimate transaction processing

This breaks the **Resource Limits** security invariant requiring all operations to respect computational limits.

## Impact Explanation
**Severity: Medium** (up to $10,000 per Aptos bug bounty guidelines)

This qualifies as Medium severity under the "Limited Protocol Violations" category because:

**Impact achieved:**
- Causes validator node slowdowns through CPU exhaustion in mempool transaction processing
- Blocks legitimate transaction processing during the attack period
- Creates temporary liveness issues for affected nodes
- Exploits resource exhaustion through synchronous filter processing

**Impact NOT achieved:**
- Does not directly cause fund loss or theft
- Does not cause consensus violations or chain splits
- Does not permanently halt the network
- No persistent state corruption

**Constraining factors:**
- Only affects nodes with transaction filters enabled (not the default configuration)
- Specifically requires PublicKey or AccountAddress matchers to be configured
- Attack surface depends on specific filter rule configuration
- Nodes without filters or with different matcher types remain unaffected

However, enabling transaction filters for compliance, regulatory requirements, or access control is a **legitimate operational need**, making this a realistic attack vector in production environments where such controls are required.

## Likelihood Explanation
**Likelihood: Medium**

**Factors increasing likelihood:**
- Attack execution is straightforward once filters are configured
- No special privileges required beyond standard transaction submission capabilities
- Attacker can craft malicious transactions using the standard Aptos SDK
- Each crafted transaction is technically valid and passes all signature validation checks
- Attacker can submit multiple transactions concurrently for amplification
- The asymmetry between validation (O(32)) and filtering (O(1024 × N × M)) is exploitable

**Factors decreasing likelihood:**
- Requires operator to enable transaction filters (disabled by default)
- Specifically requires configuration of PublicKey or AccountAddress matchers
- Some deployments may not use transaction filters at all
- The fuzzing tests show awareness of performance concerns with multiple authenticators (limited to 10 for "slow signing"): [10](#0-9) 

The vulnerability becomes **highly exploitable** in environments where filters are legitimately deployed for access control, sanctions compliance, or regulatory requirements, making the Medium likelihood assessment appropriate.

## Recommendation

**Immediate Mitigation:**
1. Implement a computational budget or timeout for filter matching operations
2. Add a maximum limit on total public keys across all authenticators (e.g., MAX_TOTAL_KEYS = 64)
3. Count both signatures AND public keys in the MAX_NUM_OF_SIGS validation check

**Recommended Fix:**

Modify the TransactionAuthenticator::verify() method to also count and limit total public keys:

```rust
pub fn verify(&self, raw_txn: &RawTransaction) -> Result<()> {
    let num_sigs: usize = self.sender().number_of_signatures()
        + self
            .secondary_signers()
            .iter()
            .map(|auth| auth.number_of_signatures())
            .sum::<usize>();
    
    // NEW: Also count total public keys
    let num_keys: usize = self.sender().number_of_public_keys()
        + self
            .secondary_signers()
            .iter()
            .map(|auth| auth.number_of_public_keys())
            .sum::<usize>();
    
    if num_sigs > MAX_NUM_OF_SIGS {
        return Err(Error::new(AuthenticationError::MaxSignaturesExceeded));
    }
    
    // NEW: Limit total public keys
    if num_keys > MAX_NUM_OF_KEYS {
        return Err(Error::new(AuthenticationError::MaxPublicKeysExceeded));
    }
    
    // ... rest of verification logic
}
```

Additionally, implement a timeout wrapper around filter matching in mempool/src/shared_mempool/tasks.rs to prevent unbounded computation.

## Proof of Concept

The vulnerability can be demonstrated by constructing a FeePayer transaction with 32 MultiKey authenticators, each containing 32 public keys and 1 signature:

```rust
// Create 32 MultiKey authenticators, each with 32 keys and 1 signature
let authenticators: Vec<AccountAuthenticator> = (0..32)
    .map(|_| {
        let public_keys: Vec<AnyPublicKey> = (0..32)
            .map(|_| AnyPublicKey::ed25519(Ed25519PrivateKey::generate_for_testing().public_key()))
            .collect();
        
        let multi_key = MultiKey::new(public_keys, 1).unwrap();
        let signature = /* sign with first key */;
        
        AccountAuthenticator::MultiKey {
            authenticator: MultiKeyAuthenticator::new(multi_key, vec![(0, signature)]).unwrap()
        }
    })
    .collect();

// Construct FeePayer transaction with sender + 30 secondary + fee_payer = 32 total
let signed_txn = SignedTransaction::new_fee_payer(
    raw_txn,
    authenticators[0], // sender
    secondary_addresses[0..30].to_vec(),
    authenticators[1..31].to_vec(), // 30 secondary signers
    fee_payer_address,
    authenticators[31], // fee payer signer
);

// Configure filter with PublicKey matcher
let filter = TransactionFilter::empty()
    .add_public_key_filter(false, target_public_key);

// Filter will iterate through all 1024 keys (32 × 32)
// With N matchers and M rules: O(1024 × N × M) complexity
filter.allows_transaction(&signed_txn);
```

When this transaction is submitted to a mempool with filters enabled, the filter_transactions function will iterate through all 1024 public keys for each configured matcher, causing CPU exhaustion proportional to the number of such transactions submitted concurrently.

### Citations

**File:** types/src/transaction/authenticator.rs (L34-34)
```rust
pub const MAX_NUM_OF_SIGS: usize = 32;
```

**File:** types/src/transaction/authenticator.rs (L161-169)
```rust
        let num_sigs: usize = self.sender().number_of_signatures()
            + self
                .secondary_signers()
                .iter()
                .map(|auth| auth.number_of_signatures())
                .sum::<usize>();
        if num_sigs > MAX_NUM_OF_SIGS {
            return Err(Error::new(AuthenticationError::MaxSignaturesExceeded));
        }
```

**File:** types/src/transaction/authenticator.rs (L838-847)
```rust
    pub fn number_of_signatures(&self) -> usize {
        match self {
            Self::Ed25519 { .. } => 1,
            Self::MultiEd25519 { signature, .. } => signature.signatures().len(),
            Self::SingleKey { .. } => 1,
            Self::MultiKey { authenticator } => authenticator.signatures.len(),
            Self::NoAccountAuthenticator => 0,
            Self::Abstract { .. } => 0,
        }
    }
```

**File:** types/src/transaction/authenticator.rs (L1154-1177)
```rust
    pub fn new(public_keys: Vec<AnyPublicKey>, signatures_required: u8) -> Result<Self> {
        ensure!(
            signatures_required > 0,
            "The number of required signatures is 0."
        );

        ensure!(
            public_keys.len() <= MAX_NUM_OF_SIGS, // This max number of signatures is also the max number of public keys.
            "The number of public keys is greater than {}.",
            MAX_NUM_OF_SIGS
        );

        ensure!(
            public_keys.len() >= signatures_required as usize,
            "The number of public keys is smaller than the number of required signatures, {} < {}",
            public_keys.len(),
            signatures_required
        );

        Ok(Self {
            public_keys,
            signatures_required,
        })
    }
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L271-275)
```rust
        AccountAuthenticator::MultiKey { authenticator } => authenticator
            .public_keys()
            .public_keys()
            .iter()
            .any(|any_public_key| matches_any_public_key_address(any_public_key, address)),
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L303-308)
```rust
        AccountAuthenticator::MultiKey { authenticator } => authenticator
            .public_keys()
            .public_keys()
            .iter()
            .any(|key| key == any_public_key),
    }
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L558-569)
```rust
        TransactionAuthenticator::FeePayer {
            sender,
            secondary_signers,
            fee_payer_signer,
            ..
        } => {
            matches_account_authenticator_public_key(sender, any_public_key)
                || secondary_signers
                    .iter()
                    .any(|signer| matches_account_authenticator_public_key(signer, any_public_key))
                || matches_account_authenticator_public_key(fee_payer_signer, any_public_key)
        },
```

**File:** mempool/src/shared_mempool/tasks.rs (L318-326)
```rust
    // Filter out any disallowed transactions
    let mut statuses = vec![];
    let transactions =
        filter_transactions(&smp.transaction_filter_config, transactions, &mut statuses);

    // If there are no transactions left after filtering, return early
    if transactions.is_empty() {
        return statuses;
    }
```

**File:** mempool/src/shared_mempool/tasks.rs (L408-466)
```rust
fn filter_transactions(
    transaction_filter_config: &TransactionFilterConfig,
    transactions: Vec<(
        SignedTransaction,
        Option<u64>,
        Option<BroadcastPeerPriority>,
    )>,
    statuses: &mut Vec<(SignedTransaction, (MempoolStatus, Option<StatusCode>))>,
) -> Vec<(
    SignedTransaction,
    Option<u64>,
    Option<BroadcastPeerPriority>,
)> {
    // If the filter is not enabled, return early
    if !transaction_filter_config.is_enabled() {
        return transactions;
    }

    // Start the filter processing timer
    let transaction_filter_timer = counters::PROCESS_TXN_BREAKDOWN_LATENCY
        .with_label_values(&[counters::FILTER_TRANSACTIONS_LABEL])
        .start_timer();

    // Filter the transactions and update the statuses accordingly
    let transactions = transactions
        .into_iter()
        .filter_map(|(transaction, account_sequence_number, priority)| {
            if transaction_filter_config
                .transaction_filter()
                .allows_transaction(&transaction)
            {
                Some((transaction, account_sequence_number, priority))
            } else {
                info!(LogSchema::event_log(
                    LogEntry::TransactionFilter,
                    LogEvent::TransactionRejected
                )
                .message(&format!(
                    "Transaction {} rejected by filter",
                    transaction.committed_hash()
                )));

                statuses.push((
                    transaction.clone(),
                    (
                        MempoolStatus::new(MempoolStatusCode::RejectedByFilter),
                        None,
                    ),
                ));
                None
            }
        })
        .collect();

    // Update the filter processing latency metrics
    transaction_filter_timer.stop_and_record();

    transactions
}
```

**File:** testsuite/fuzzer/fuzz/fuzz_targets/move/aptosvm_authenticators.rs (L396-399)
```rust
            // higher number here slows down fuzzer significatly due to slow signing process.
            if secondary_signers.len() > 10 {
                return Err(Corpus::Keep);
            }
```
