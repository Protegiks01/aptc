# Audit Report

## Title
Missing Grandparent-Parent Chain Validation in OptimisticProposal Allows Inconsistent QC Relationships

## Summary
The OptimisticProposal validation in `block.rs` cryptographically verifies both `grandparent_qc` and `quorum_cert` independently but fails to validate that the `grandparent_qc` actually certifies the parent of the block certified by `quorum_cert`. This allows an attacker to construct an OptimisticProposal with a valid but semantically incorrect grandparent QC, breaking chain integrity assumptions.

## Finding Description

In the Aptos consensus protocol, an OptimisticProposal contains two quorum certificates: a `quorum_cert` (for the parent block) and a `grandparent_qc` (for the grandparent block). The system validates these QCs independently: [1](#0-0) [2](#0-1) 

The validation checks ensure:
1. Both QCs are cryptographically valid (have 2f+1 signatures)
2. Rounds are consecutive: `grandparent_qc.round() + 1 == parent.round()`
3. The local highest QC certifies the parent block [3](#0-2) 

**Critical Missing Check:** There is NO validation that `grandparent_qc.certified_block().id()` equals the `parent_id` of the block certified by `quorum_cert`.

**Attack Scenario:**

In a Byzantine scenario where two different blocks exist at round r-1 (due to equivocation):
- Block A at round r-1 (honest chain)
- Block B at round r-1 (malicious/equivocated block)
- Block C at round r with parent = Block A

An attacker crafts OptBlockData with:
- `parent`: BlockInfo for Block C (round r, id = hash_C)
- `grandparent_qc`: Valid QC certifying Block B (round r-1, id = hash_B ≠ parent of C)

When processed:
1. Node validates `grandparent_qc.round() + 1 == parent.round()` ✓ (r-1 + 1 == r)
2. Node validates `hqc.certified_block().id() == opt_block_data.parent_id()` ✓ (both equal hash_C)
3. Node creates Block with `quorum_cert` certifying C (parent A) and `grandparent_qc` certifying B
4. Block is accepted despite grandparent_qc certifying B ≠ A

**Consequences:**

1. **Incorrect Voter Attribution**: The `previous_bitvec()` function uses `grandparent_qc` voters for OptimisticProposals: [4](#0-3) 

This returns voters from Block B instead of Block A (the actual grandparent), corrupting historical voting data.

2. **Event Data Corruption**: BlockMetadata emitted on-chain contains incorrect `previous_block_votes_bitvec`: [5](#0-4) 

3. **Block Hash Inconsistency**: The block hash includes the `block_type` which contains `grandparent_qc`: [6](#0-5) 

Different `grandparent_qc` values produce different block IDs, enabling potential chain split if different nodes receive different OptBlockData.

## Impact Explanation

This vulnerability has **Medium severity** per the Aptos bug bounty criteria:

- **State inconsistencies requiring intervention**: Incorrect voter data in events and block metadata creates historical data corruption that affects off-chain indexers, reputation systems, and analytics
- **Protocol violation without immediate consensus break**: While consensus safety isn't immediately broken (all nodes seeing the same proposal accept it), the semantic invariant that grandparent_qc certifies the actual grandparent is violated
- **Potential for future exploitation**: Other protocol components or upgrades assuming correct grandparent_qc relationships could be compromised

This does NOT reach Critical/High severity because:
- It requires Byzantine conditions (equivocation with valid QCs for different blocks at same round)
- It doesn't directly break consensus safety if all honest nodes receive identical malicious proposals
- No immediate fund loss or network halt

## Likelihood Explanation

**Likelihood: Low to Medium**

The attack requires:
1. **Byzantine validators producing equivocation**: Two valid QCs for different blocks at the same round
2. **Network visibility**: Attacker must obtain both QCs
3. **Timing**: Must propose during the window when nodes accept OptimisticProposals

While Byzantine behavior is the explicit threat model (< 1/3 Byzantine), equivocation detection mechanisms and slashing make sustained attacks costly. However, during network partitions or targeted attacks, this becomes more feasible.

## Recommendation

Add validation in `process_opt_proposal()` or `verify_well_formed()` to ensure the grandparent_qc certifies the actual parent of the parent block:

```rust
// In consensus/src/round_manager.rs, process_opt_proposal()
async fn process_opt_proposal(&mut self, opt_block_data: OptBlockData) -> anyhow::Result<()> {
    // ... existing checks ...
    
    let hqc = self.block_store.highest_quorum_cert().as_ref().clone();
    
    // NEW: Validate grandparent_qc certifies the parent's parent
    let parent_block = self.block_store
        .get_block(hqc.certified_block().id())
        .ok_or_else(|| anyhow::anyhow!("Parent block not found"))?;
    
    ensure!(
        opt_block_data.grandparent_qc().certified_block().id() == parent_block.parent_id(),
        "Grandparent QC certifies block {} but parent's actual parent is {}",
        opt_block_data.grandparent_qc().certified_block().id(),
        parent_block.parent_id()
    );
    
    // ... rest of function ...
}
```

This ensures the grandparent_qc actually certifies the parent of the parent block, maintaining chain integrity.

## Proof of Concept

```rust
// Test demonstrating the vulnerability
// File: consensus/src/round_manager_tests/opt_proposal_vulnerability_test.rs

#[tokio::test]
async fn test_opt_proposal_inconsistent_grandparent_qc() {
    let (signers, validators) = random_validator_verifier(4, None, false);
    
    // Create two different blocks at round 1 (simulating equivocation)
    let block_a1 = create_test_block(1, &signers[0]);
    let block_b1 = create_test_block_different_id(1, &signers[1]);
    
    // Get QCs for both (simulating Byzantine validators signing both)
    let qc_a1 = create_qc_for_block(&block_a1, &signers[0..3]);
    let qc_b1 = create_qc_for_block(&block_b1, &signers[0..3]); // Both have 2f+1 sigs
    
    // Create block C at round 2 with parent A1
    let block_c2 = create_test_block_with_parent(2, &signers[0], qc_a1.clone());
    let qc_c2 = create_qc_for_block(&block_c2, &signers[0..3]);
    
    // Attacker creates OptBlockData with:
    // - parent = BlockInfo for C (whose real parent is A1)
    // - grandparent_qc = QC certifying B1 (NOT A1!)
    let malicious_opt_block_data = OptBlockData::new(
        vec![],
        Payload::empty(false, true),
        signers[0].author(),
        1, // epoch
        3, // round
        3000, // timestamp
        block_c2.block_info().clone(), // parent = C
        qc_b1.clone(), // grandparent_qc = B1 (NOT A1!)
    );
    
    // This should be rejected but currently passes validation
    assert!(malicious_opt_block_data.verify_well_formed().is_ok());
    // The grandparent_qc.certified_block().id() (B1) != C's parent (A1)
    // But validation doesn't check this!
}
```

## Notes

This vulnerability highlights the importance of validating not just the cryptographic validity of QCs but also their semantic correctness within the chain structure. While OptimisticProposals enable pipelining by proposing before parent QC arrives, the grandparent_qc must still maintain chain integrity by certifying the actual grandparent block.

### Citations

**File:** consensus/consensus-types/src/block.rs (L453-461)
```rust
            BlockType::OptimisticProposal(p) => {
                // Note: Optimistic proposal is not signed by proposer unlike normal proposal
                let (res1, res2) = rayon::join(
                    || p.grandparent_qc().verify(validator),
                    || self.quorum_cert().verify(validator),
                );
                res1?;
                res2
            },
```

**File:** consensus/consensus-types/src/block.rs (L570-578)
```rust
    fn previous_bitvec(&self) -> BitVec {
        match self.block_data.block_type() {
            BlockType::DAGBlock { parents_bitvec, .. } => parents_bitvec.clone(),
            BlockType::OptimisticProposal(p) => {
                p.grandparent_qc().ledger_info().get_voters_bitvec().clone()
            },
            _ => self.quorum_cert().ledger_info().get_voters_bitvec().clone(),
        }
    }
```

**File:** consensus/consensus-types/src/opt_block_data.rs (L75-89)
```rust
    pub fn verify_well_formed(&self) -> anyhow::Result<()> {
        let parent = self.parent();
        let grandparent_qc = self.grandparent_qc().certified_block();
        ensure!(
            grandparent_qc.round() + 1 == parent.round(),
            "Block's parent's round {} must be one more than grandparent's round {}",
            parent.round(),
            grandparent_qc.round(),
        );
        ensure!(
            parent.round() + 1 == self.round(),
            "Block's round {} must be one more than parent's round {}",
            self.round(),
            parent.round(),
        );
```

**File:** consensus/src/round_manager.rs (L851-863)
```rust
        let hqc = self.block_store.highest_quorum_cert().as_ref().clone();
        ensure!(
            hqc.certified_block().round() + 1 == opt_block_data.round(),
            "Opt proposal round {} is not the next round after the highest qc round {}",
            opt_block_data.round(),
            hqc.certified_block().round()
        );
        ensure!(
            hqc.certified_block().id() == opt_block_data.parent_id(),
            "Opt proposal parent id {} is not the same as the highest qc certified block id {}",
            opt_block_data.parent_id(),
            hqc.certified_block().id()
        );
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L181-190)
```text
        let new_block_event = NewBlockEvent {
            hash,
            epoch,
            round,
            height: block_metadata_ref.height,
            previous_block_votes_bitvec,
            proposer,
            failed_proposer_indices,
            time_microseconds: timestamp,
        };
```

**File:** consensus/consensus-types/src/block_data.rs (L110-128)
```rust
        if self.is_opt_block() {
            #[derive(Serialize)]
            struct OptBlockDataForHash<'a> {
                epoch: u64,
                round: Round,
                timestamp_usecs: u64,
                quorum_cert_vote_data: &'a VoteData,
                block_type: &'a BlockType,
            }

            let opt_block_data_for_hash = OptBlockDataForHash {
                epoch: self.epoch,
                round: self.round,
                timestamp_usecs: self.timestamp_usecs,
                quorum_cert_vote_data: self.quorum_cert.vote_data(),
                block_type: &self.block_type,
            };
            bcs::serialize_into(&mut state, &opt_block_data_for_hash)
                .expect("OptBlockDataForHash must be serializable");
```
