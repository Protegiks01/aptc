# Audit Report

## Title
Unsafe Float-to-Integer Conversion in Node Checker Allows Health Check Bypass via Malformed Prometheus Metrics

## Summary
The node checker's metric parsing logic performs unchecked conversions from floating-point Prometheus metric values to u64 integers. Malicious node operators can exploit this by serving malformed metrics containing NaN, infinity, or negative values, which are silently converted to 0 or u64::MAX. This allows nodes with genuine consensus issues (high timeout counts, stalled rounds, or failed proposals) to bypass health checks and remain in the validator set.

## Finding Description

The vulnerability exists in the `get_metric_value` function which converts Prometheus metric values to u64 integers: [1](#0-0) 

The function performs `v.round() as u64` conversions on Counter, Gauge, and Untyped metric values without validating for special float values. While modern Rust (1.45+) uses saturating semantics instead of undefined behavior for these conversions, the resulting behavior still creates a security vulnerability:

- **NaN** → converts to **0**
- **+Infinity** → converts to **u64::MAX** (18446744073709551615)
- **-Infinity** → converts to **0**
- **Negative values** → convert to **0**

The Prometheus text format specification explicitly allows NaN, +Inf, and -Inf as valid metric values, and the `prometheus-parse` crate (version 0.2.4) parses these into f64::NAN, f64::INFINITY, and f64::NEG_INFINITY respectively.

**Attack Scenario for Consensus Timeouts Checker:**

A validator node experiencing high consensus timeouts (e.g., 100 timeouts) can manipulate its `/metrics` endpoint to return:
```
aptos_consensus_timeout_count NaN
```

When the consensus timeouts checker executes: [2](#0-1) 

Both metric scrapes return 0 after the malformed value is parsed. The subsequent check evaluates: [3](#0-2) 

With both values as 0, the condition `0 > 0 + allowed_consensus_timeouts` evaluates to false, causing the node to pass with a perfect score of 100, even though it has serious consensus issues.

**Similar vulnerabilities exist in:**
- **Consensus Round Checker** (`consensus_round.rs`) - allows stalled nodes to appear healthy
- **Consensus Proposals Checker** (`consensus_proposals.rs`) - allows non-proposing nodes to appear active

All three checkers rely on the same vulnerable `get_metric_value` function.

## Impact Explanation

**Severity: Medium**

This vulnerability allows malicious or misconfigured nodes to bypass critical health monitoring infrastructure. The impact includes:

1. **Validator Set Integrity Compromise**: Nodes with genuine consensus problems can remain in the validator set by masking their issues with malformed metrics
2. **Network Reliability Degradation**: Multiple compromised validators could reduce network liveness and consensus participation rates
3. **Monitoring System Evasion**: The node checker is used for validator qualification in incentivized testnets (AITs) and mainnet health monitoring
4. **No Direct Fund Loss**: This is not a direct consensus break or fund theft, but undermines the security guarantees of the validator selection process

According to Aptos bug bounty criteria, this qualifies as **Medium Severity** due to:
- State inconsistencies requiring intervention (compromised validator set health)
- Significant protocol violations (health check bypass)
- Does not directly cause fund loss or consensus safety violations
- Requires active manipulation by node operators

## Likelihood Explanation

**Likelihood: Medium-High**

The attack is straightforward to execute:
1. **Low Technical Barrier**: Node operators have full control over their metrics endpoint
2. **No Special Privileges Required**: Any node being checked can serve malformed metrics
3. **Silent Failure Mode**: No error logs or alerts are generated when malformed values are processed
4. **Detection Difficulty**: Distinguishes from legitimate metric issues is challenging without deep inspection

However, likelihood is reduced by:
- Requires node operator to actively manipulate metrics (not accidental)
- May be detected through baseline comparisons with other nodes
- Node operators have reputational incentives to maintain legitimacy

## Recommendation

Add explicit validation for special float values before conversion to u64. Replace the unsafe conversions with checked conversions that detect and reject malformed metrics:

```rust
fn get_metric_value(
    metrics: &Scrape,
    metric_name: &str,
    expected_label: Option<&Label>,
) -> Option<u64> {
    let mut discovered_sample = None;
    for sample in &metrics.samples {
        if sample.metric == metric_name {
            match &expected_label {
                Some(expected_label) => {
                    let label_value = sample.labels.get(expected_label.key);
                    if let Some(label_value) = label_value {
                        if label_value == expected_label.value {
                            discovered_sample = Some(sample);
                            break;
                        }
                    }
                },
                None => {
                    discovered_sample = Some(sample);
                    break;
                },
            }
        }
    }
    match discovered_sample {
        Some(sample) => match &sample.value {
            Value::Counter(v) => validate_and_convert(*v),
            Value::Gauge(v) => validate_and_convert(*v),
            Value::Untyped(v) => validate_and_convert(*v),
            wildcard => {
                warn!("Found unexpected metric type: {:?}", wildcard);
                None
            },
        },
        None => None,
    }
}

fn validate_and_convert(value: f64) -> Option<u64> {
    // Explicitly reject NaN, infinity, and negative values
    if value.is_nan() {
        warn!("Metric value is NaN, rejecting");
        return None;
    }
    if value.is_infinite() {
        warn!("Metric value is infinite, rejecting");
        return None;
    }
    if value < 0.0 {
        warn!("Metric value is negative ({}), rejecting", value);
        return None;
    }
    // Only convert valid non-negative finite numbers
    Some(value.round() as u64)
}
```

This ensures malformed metrics are treated the same as missing metrics, causing the check to fail appropriately.

## Proof of Concept

```rust
// Test to demonstrate the vulnerability
#[cfg(test)]
mod tests {
    use super::*;
    use prometheus_parse::{Scrape, Sample, Value};
    use std::collections::HashMap;

    #[test]
    fn test_malformed_metric_bypass() {
        // Create a mock Scrape with NaN value for consensus timeouts
        let samples = vec![
            Sample {
                metric: "aptos_consensus_timeout_count".to_string(),
                value: Value::Counter(f64::NAN),
                labels: HashMap::new(),
                timestamp: None,
            }
        ];
        let scrape = Scrape {
            samples,
            docs: HashMap::new(),
        };

        // This should return None (indicating invalid metric)
        // but currently returns Some(0)
        let result = get_metric_value(&scrape, "aptos_consensus_timeout_count", None);
        
        // Current behavior: Some(0) - node passes check
        assert_eq!(result, Some(0));
        
        // Expected behavior after fix: None - node fails check
        // assert_eq!(result, None);
    }

    #[test]
    fn test_infinity_metric_bypass() {
        let samples = vec![
            Sample {
                metric: "aptos_consensus_timeout_count".to_string(),
                value: Value::Counter(f64::INFINITY),
                labels: HashMap::new(),
                timestamp: None,
            }
        ];
        let scrape = Scrape {
            samples,
            docs: HashMap::new(),
        };

        let result = get_metric_value(&scrape, "aptos_consensus_timeout_count", None);
        
        // Current behavior: Some(u64::MAX)
        assert_eq!(result, Some(u64::MAX));
        
        // Expected behavior after fix: None
        // assert_eq!(result, None);
    }

    #[test]
    fn test_negative_metric_bypass() {
        let samples = vec![
            Sample {
                metric: "aptos_consensus_timeout_count".to_string(),
                value: Value::Counter(-100.0),
                labels: HashMap::new(),
                timestamp: None,
            }
        ];
        let scrape = Scrape {
            samples,
            docs: HashMap::new(),
        };

        let result = get_metric_value(&scrape, "aptos_consensus_timeout_count", None);
        
        // Current behavior: Some(0) due to saturation
        assert_eq!(result, Some(0));
        
        // Expected behavior after fix: None
        // assert_eq!(result, None);
    }
}
```

To reproduce in a real environment:
1. Set up a node running the Aptos node checker
2. Configure a target node's metrics endpoint to return: `aptos_consensus_timeout_count NaN`
3. Run the consensus timeouts checker against this node
4. Observe that the node passes the check with score 100, despite the malformed metric

## Notes

This vulnerability affects all metric-based checkers in the node checker system that rely on the `get_metric_value` function. The fix should be applied centrally in the metrics provider module to protect all downstream checkers. Additionally, consider implementing metric validation at the scraping stage to detect and log anomalous metric values for operational monitoring.

### Citations

**File:** ecosystem/node-checker/src/provider/metrics.rs (L137-139)
```rust
            Value::Counter(v) => Some(v.round() as u64),
            Value::Gauge(v) => Some(v.round() as u64),
            Value::Untyped(v) => Some(v.round() as u64),
```

**File:** ecosystem/node-checker/src/checker/consensus_timeouts.rs (L69-70)
```rust
        if latest_timeouts_count > previous_timeouts_count + self.config.allowed_consensus_timeouts
        {
```

**File:** ecosystem/node-checker/src/checker/consensus_timeouts.rs (L137-143)
```rust
        let previous_round = self
            .get_consensus_timeouts(&first_scrape, "first")
            .unwrap(&mut check_results);

        let latest_round = self
            .get_consensus_timeouts(&second_scrape, "second")
            .unwrap(&mut check_results);
```
