# Audit Report

## Title
Aptos Inspection Service Lacks Authentication - Complete Reliance on Firewall Creates Information Disclosure Risk

## Summary
The Aptos Inspection Service exposes sensitive validator and network information through unauthenticated HTTP endpoints. The service implements **no authentication or authorization mechanisms** and binds to all network interfaces (`0.0.0.0`) by default, relying entirely on network firewalls for access control. If a firewall is misconfigured, attackers can access multiple endpoints that expose validator identities, peer network topology, consensus state, and system informationâ€”enabling targeted attacks on the validator network.

## Finding Description

The inspection service in `crates/aptos-inspection-service/src/server/mod.rs` starts an HTTP server that handles various endpoint requests without any authentication or authorization checks. [1](#0-0) 

The `serve_requests` function processes all incoming HTTP requests by matching the URI path to specific handlers, but **never verifies the identity or authorization of the requestor**. Any client that can establish a TCP connection to the service can access these endpoints.

The service binds to all network interfaces by default: [2](#0-1) 

**Sensitive Endpoints Exposed:**

1. **`/metrics`, `/json_metrics`, `/forge_metrics`** - These endpoints are **always enabled** with no configuration flag to disable them, exposing all Prometheus metrics including consensus state. [3](#0-2) 

2. **`/consensus_health_check`** - Always enabled, reveals whether the node is actively participating in consensus. [4](#0-3) 

3. **`/peer_information`** - Enabled by default, exposes comprehensive network topology information including all connected peers, their connection states, trust relationships, internal client states, state sync metadata, and request/response patterns. [5](#0-4) [6](#0-5) 

4. **`/identity_information`** - Enabled by default, exposes peer IDs and network IDs for validator and fullnode networks. [7](#0-6) [8](#0-7) 

5. **`/system_information`** - Enabled by default, exposes system and build information. [9](#0-8) 

While some endpoints have configuration flags to disable them, the **metrics and consensus health check endpoints cannot be disabled**. Additionally, the default configuration enables most sensitive endpoints: [2](#0-1) 

**Attack Scenario:**

1. Attacker discovers a validator node with port 9101 exposed (due to firewall misconfiguration)
2. Attacker sends `GET http://validator-ip:9101/peer_information` without any credentials
3. Attacker receives complete network topology including:
   - All connected peer IDs and network IDs
   - Connection metadata and states
   - Trusted peers (validator set members)
   - Internal client states
   - State sync metadata including peer scores and storage summaries
4. Attacker sends `GET http://validator-ip:9101/metrics` to obtain all Prometheus metrics
5. Attacker uses this information to:
   - Map the entire validator network topology
   - Identify specific validators for targeted attacks
   - Monitor consensus participation patterns
   - Time attacks based on validator health status

This breaks the **Access Control** invariant: sensitive operational information should be protected and only accessible to authorized administrators.

## Impact Explanation

This vulnerability is classified as **HIGH severity** according to Aptos Bug Bounty criteria for the following reasons:

1. **Significant Protocol Violations**: The exposure of validator network topology and consensus state violates the principle that operational information should be protected. This information disclosure enables attackers to:
   - Map validator network topology for targeted attacks
   - Identify specific validators by peer ID
   - Monitor consensus participation patterns to identify optimal attack windows
   - Observe peer connections to detect network partitions or isolation opportunities

2. **Validator Node Compromise Enabler**: While not directly causing validator slowdowns, the information disclosed significantly aids attackers in planning and executing attacks that could:
   - Target specific validators with DDoS attacks
   - Exploit network topology knowledge for eclipse attacks
   - Time attacks based on consensus health monitoring
   - Identify validators running vulnerable versions via system information

3. **Wide Attack Surface**: The service binds to `0.0.0.0` by default and multiple sensitive endpoints are enabled by default, creating a large attack surface that depends entirely on firewall configuration.

The impact qualifies as **HIGH** because it enables "Significant protocol violations" through unauthorized access to operational intelligence that aids targeted attacks on the validator network.

## Likelihood Explanation

The likelihood of this vulnerability being exploited is **MEDIUM-HIGH** for the following reasons:

1. **Common Misconfiguration**: Firewall misconfigurations are extremely common, especially in:
   - Development and testing environments
   - Cloud deployments with security group misconfigurations
   - Operators with limited security expertise
   - Nodes behind load balancers or reverse proxies

2. **Default Binding to All Interfaces**: The service binds to `0.0.0.0` by default, making it accessible from any network interface if the firewall allows it.

3. **Multiple Endpoints Enabled by Default**: The default configuration enables `expose_identity_information`, `expose_peer_information`, and `expose_system_information`, while metrics endpoints are **always enabled** regardless of configuration.

4. **No Warning or Security Guidance**: The codebase provides no warnings about the security implications of exposing this service, and there's no built-in authentication mechanism even for production deployments.

5. **Internet Scanning**: Attackers routinely scan for exposed management interfaces on common ports. Port 9101 would be an obvious target once the inspection service becomes known.

The only protection is network-level firewall configuration, which is frequently misconfigured or overlooked, especially in non-mainnet deployments.

## Recommendation

Implement **mandatory authentication and authorization** for the inspection service. Do not rely solely on network firewalls for security. Recommended fixes:

1. **Add Authentication Layer**: Implement authentication using one of the following approaches:
   - JWT tokens with configurable signing keys
   - mTLS (mutual TLS) with client certificate verification
   - API key authentication with configurable keys
   - Integration with the node's existing identity system

2. **Bind to Localhost by Default**: Change the default binding from `0.0.0.0` to `127.0.0.1` to prevent accidental exposure. Require explicit configuration to bind to external interfaces.

3. **Disable Sensitive Endpoints by Default**: Set `expose_identity_information`, `expose_peer_information`, and `expose_system_information` to `false` by default, requiring operators to explicitly enable them.

4. **Add Authorization for Metrics**: Implement an authentication requirement for the metrics endpoints that currently cannot be disabled.

**Example Fix (Pseudocode):**

```rust
// In inspection_service_config.rs
pub struct InspectionServiceConfig {
    pub address: String,
    pub port: u16,
    pub auth_token: Option<String>,  // NEW: Optional authentication token
    pub require_auth: bool,           // NEW: Require authentication
    // ... rest of config
}

impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "127.0.0.1".to_string(),  // CHANGED: Bind to localhost only
            port: 9101,
            auth_token: None,
            require_auth: true,  // NEW: Require auth by default
            expose_configuration: false,
            expose_identity_information: false,  // CHANGED: Disabled by default
            expose_peer_information: false,      // CHANGED: Disabled by default
            expose_system_information: false,    // CHANGED: Disabled by default
        }
    }
}

// In server/mod.rs - Add authentication check
async fn serve_requests(
    req: Request<Body>,
    node_config: NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> Result<Response<Body>, hyper::Error> {
    // NEW: Authentication check
    if node_config.inspection_service.require_auth {
        if let Some(expected_token) = &node_config.inspection_service.auth_token {
            let auth_header = req.headers().get("Authorization");
            if auth_header.is_none() || auth_header.unwrap() != expected_token.as_str() {
                return Ok(Response::builder()
                    .status(StatusCode::UNAUTHORIZED)
                    .body(Body::from("Authentication required"))
                    .unwrap());
            }
        } else {
            // Auth required but no token configured - deny all requests
            return Ok(Response::builder()
                .status(StatusCode::FORBIDDEN)
                .body(Body::from("Authentication not configured"))
                .unwrap());
        }
    }
    
    // Continue with existing request handling...
    // ... rest of function
}
```

5. **Add Security Documentation**: Document the security implications of exposing the inspection service and provide clear guidance on proper firewall configuration and authentication setup.

## Proof of Concept

**Prerequisites:**
- Access to an Aptos validator or fullnode with the inspection service running
- The inspection service port (default 9101) must be accessible due to firewall misconfiguration

**Step 1: Discover exposed inspection service**
```bash
# Scan for exposed inspection service
curl -v http://<target-validator-ip>:9101/
```

**Step 2: Extract peer network topology**
```bash
# Get complete peer information including network topology
curl http://<target-validator-ip>:9101/peer_information

# Response includes:
# - All connected peer IDs and network IDs
# - Connection states and metadata
# - Trusted peers (validator set)
# - Internal client states
# - State sync metadata
```

**Step 3: Extract validator identity information**
```bash
# Get validator identity information
curl http://<target-validator-ip>:9101/identity_information

# Response includes:
# - Validator network peer ID
# - Fullnode network peer IDs
```

**Step 4: Monitor consensus health**
```bash
# Check consensus participation status
curl http://<target-validator-ip>:9101/consensus_health_check

# Response indicates if validator is actively participating in consensus
```

**Step 5: Extract all metrics including consensus state**
```bash
# Get all Prometheus metrics
curl http://<target-validator-ip>:9101/metrics

# Response includes hundreds of metrics including:
# - Consensus round numbers
# - Committed block counts
# - Validator voting patterns
# - Network message queues
# - Performance metrics
```

**Step 6: Extract system information**
```bash
# Get system and build information
curl http://<target-validator-ip>:9101/system_information

# Response includes:
# - Operating system details
# - Build version and commit hash
# - System resource information
```

**Impact Demonstration:**

An attacker with access to this information can:
1. **Map the validator network**: Identify all validators and their peer relationships
2. **Plan targeted attacks**: Use peer IDs to target specific validators
3. **Monitor network health**: Observe consensus participation to identify vulnerable periods
4. **Identify software versions**: Use system information to identify nodes running vulnerable versions
5. **Time attacks**: Monitor consensus health checks to identify optimal attack windows

This PoC demonstrates that with simple HTTP GET requests (no authentication required), an attacker can extract comprehensive operational intelligence about the validator network, enabling sophisticated targeted attacks.

**Notes:**
- The vulnerability affects all Aptos nodes (validators and fullnodes) running the inspection service with accessible ports
- The issue is particularly severe for validators, as network topology information can be used to plan consensus-disrupting attacks
- No authentication, authorization, or rate limiting protects these endpoints
- The service relies entirely on network firewalls, which are frequently misconfigured

### Citations

**File:** crates/aptos-inspection-service/src/server/mod.rs (L104-169)
```rust
async fn serve_requests(
    req: Request<Body>,
    node_config: NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> Result<Response<Body>, hyper::Error> {
    // Process the request and get the response components
    let (status_code, body, content_type) = match req.uri().path() {
        CONFIGURATION_PATH => {
            // /configuration
            // Exposes the node configuration
            configuration::handle_configuration_request(&node_config)
        },
        CONSENSUS_HEALTH_CHECK_PATH => {
            // /consensus_health_check
            // Exposes the consensus health check
            metrics::handle_consensus_health_check(&node_config).await
        },
        FORGE_METRICS_PATH => {
            // /forge_metrics
            // Exposes forge encoded metrics
            metrics::handle_forge_metrics()
        },
        IDENTITY_INFORMATION_PATH => {
            // /identity_information
            // Exposes the identity information of the node
            identity_information::handle_identity_information_request(&node_config)
        },
        INDEX_PATH => {
            // /
            // Exposes the index and list of available endpoints
            index::handle_index_request()
        },
        JSON_METRICS_PATH => {
            // /json_metrics
            // Exposes JSON encoded metrics
            metrics::handle_json_metrics_request()
        },
        METRICS_PATH => {
            // /metrics
            // Exposes text encoded metrics
            metrics::handle_metrics_request()
        },
        PEER_INFORMATION_PATH => {
            // /peer_information
            // Exposes the peer information
            peer_information::handle_peer_information_request(
                &node_config,
                aptos_data_client,
                peers_and_metadata,
            )
        },
        SYSTEM_INFORMATION_PATH => {
            // /system_information
            // Exposes the system and build information
            system_information::handle_system_information_request(node_config)
        },
        _ => {
            // Handle the invalid path
            (
                StatusCode::NOT_FOUND,
                Body::from(INVALID_ENDPOINT_MESSAGE),
                CONTENT_TYPE_TEXT.into(),
            )
        },
    };
```

**File:** config/src/config/inspection_service_config.rs (L26-36)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
```

**File:** crates/aptos-inspection-service/src/server/metrics.rs (L16-48)
```rust
/// Handles a consensus health check request. This method returns
/// 200 if the node is currently participating in consensus.
///
/// Note: we assume that this endpoint will only be used every few seconds.
pub async fn handle_consensus_health_check(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    // Verify the node is a validator. If not, return an error.
    if !node_config.base.role.is_validator() {
        return (
            StatusCode::BAD_REQUEST,
            Body::from("This node is not a validator!"),
            CONTENT_TYPE_TEXT.into(),
        );
    }

    // Check the value of the consensus execution gauge
    let metrics = utils::get_all_metrics();
    if let Some(gauge_value) = metrics.get(CONSENSUS_EXECUTION_GAUGE) {
        if gauge_value == "1" {
            return (
                StatusCode::OK,
                Body::from("Consensus health check passed!"),
                CONTENT_TYPE_TEXT.into(),
            );
        }
    }

    // Otherwise, consensus is not executing
    (
        StatusCode::INTERNAL_SERVER_ERROR,
        Body::from("Consensus health check failed! Consensus is not executing!"),
        CONTENT_TYPE_TEXT.into(),
    )
}
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L21-38)
```rust
pub fn handle_peer_information_request(
    node_config: &NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> (StatusCode, Body, String) {
    // Only return peer information if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_peer_information {
        let peer_information = get_peer_information(aptos_data_client, peers_and_metadata);
        (StatusCode::OK, Body::from(peer_information))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(PEER_INFO_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L40-106)
```rust
/// Returns a simple text formatted string with peer and network information
fn get_peer_information(
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> String {
    // Get all registered networks
    let registered_networks: Vec<NetworkId> =
        peers_and_metadata.get_registered_networks().collect();

    // Get all peers (sorted by peer ID)
    let mut all_peers = peers_and_metadata.get_all_peers();
    all_peers.sort();

    // Display a summary of all peers and networks
    let mut peer_information_output = Vec::<String>::new();
    display_peer_information_summary(
        &mut peer_information_output,
        &all_peers,
        &registered_networks,
    );
    peer_information_output.push("\n".into());

    // Display connection metadata for each peer
    display_peer_connection_metadata(
        &mut peer_information_output,
        &all_peers,
        peers_and_metadata.deref(),
    );
    peer_information_output.push("\n".into());

    // Display the entire set of trusted peers
    display_trusted_peers(
        &mut peer_information_output,
        registered_networks,
        peers_and_metadata.deref(),
    );
    peer_information_output.push("\n".into());

    // Display basic peer metadata for each peer
    display_peer_monitoring_metadata(
        &mut peer_information_output,
        &all_peers,
        peers_and_metadata.deref(),
    );
    peer_information_output.push("\n".into());

    // Display state sync metadata for each peer
    display_state_sync_metadata(&mut peer_information_output, &all_peers, aptos_data_client);
    peer_information_output.push("\n".into());

    // Display detailed peer metadata for each peer
    display_detailed_monitoring_metadata(
        &mut peer_information_output,
        &all_peers,
        peers_and_metadata.deref(),
    );
    peer_information_output.push("\n".into());

    // Display the internal client state for each peer
    display_internal_client_state(
        &mut peer_information_output,
        &all_peers,
        peers_and_metadata.deref(),
    );

    peer_information_output.join("\n") // Separate each entry with a newline to construct the output
}
```

**File:** crates/aptos-inspection-service/src/server/identity_information.rs (L13-26)
```rust
pub fn handle_identity_information_request(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    // Only return identity information if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_identity_information {
        let identity_information = get_identity_information(node_config);
        (StatusCode::OK, Body::from(identity_information))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(IDENTITY_INFO_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}
```

**File:** crates/aptos-inspection-service/src/server/identity_information.rs (L29-52)
```rust
fn get_identity_information(node_config: &NodeConfig) -> String {
    let mut identity_information = Vec::<String>::new();
    identity_information.push("Identity Information:".into());

    // If the validator network is configured, fetch the identity information
    if let Some(validator_network) = &node_config.validator_network {
        identity_information.push(format!(
            "\t- Validator network ({}), peer ID: {}",
            validator_network.network_id,
            validator_network.peer_id()
        ));
    }

    // For each fullnode network, fetch the identity information
    for fullnode_network in &node_config.full_node_networks {
        identity_information.push(format!(
            "\t- Fullnode network ({}), peer ID: {}",
            fullnode_network.network_id,
            fullnode_network.peer_id()
        ));
    }

    identity_information.join("\n") // Separate each entry with a newline to construct the output
}
```

**File:** crates/aptos-inspection-service/src/server/system_information.rs (L14-42)
```rust
pub fn handle_system_information_request(node_config: NodeConfig) -> (StatusCode, Body, String) {
    // Only return system information if the endpoint is enabled
    if node_config.inspection_service.expose_system_information {
        (
            StatusCode::OK,
            Body::from(get_system_information_json()),
            CONTENT_TYPE_JSON.into(),
        )
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(SYS_INFO_DISABLED_MESSAGE),
            CONTENT_TYPE_TEXT.into(),
        )
    }
}

/// Returns a simple JSON formatted string with system information
fn get_system_information_json() -> String {
    // Get the system and build information
    let mut system_information = aptos_telemetry::system_information::get_system_information();
    system_information.extend(build_information!());

    // Return the system information as a JSON string
    match serde_json::to_string(&system_information) {
        Ok(system_information) => system_information,
        Err(error) => format!("Failed to get system information! Error: {}", error),
    }
}
```
