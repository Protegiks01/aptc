# Audit Report

## Title
Missing Groth16 Verification Key Validation in Governance Enables Complete Keyless Account Compromise

## Summary
The `set_groth16_verification_key_for_next_epoch` function in `keyless_account.move` accepts and stores any Groth16 verification key submitted through governance without validation. Although a `validate_groth16_vk` function exists to check curve point validity, it is never called. More critically, there is no verification that the submitted VK corresponds to the legitimate keyless authentication circuit. Once training wheels are disabled (as planned), an attacker controlling governance can set a malicious VK from a circuit with a known trapdoor, enabling them to forge authentication proofs for any keyless account and steal all associated funds.

## Finding Description

The keyless account system relies on Groth16 zero-knowledge proofs to authenticate users. The verification key (VK) used to validate these proofs is stored on-chain and can be updated via governance proposals. Three critical security failures exist in this update mechanism:

**Failure 1: Validation Function Never Called**

A validation function exists but is never invoked: [1](#0-0) 

However, the governance update function never calls this validation: [2](#0-1) 

The genesis function also omits validation: [3](#0-2) 

**Failure 2: Incorrect Implementation Claim**

The Rust environment code contains a false security claim: [4](#0-3) 

The comment states "currently, we do check for that in `keyless_account.move`" but this check never executes, as proven by grep search showing the validation function is only defined, never called.

**Failure 3: Insufficient Validation Even If Called**

Even if `validate_groth16_vk` were called, it only checks if the submitted points are valid BN254 curve points, not whether they form the correct VK for the legitimate keyless circuit. The expected VK is hardcoded for testing: [5](#0-4) 

But there is no on-chain validation against this expected VK.

**Attack Execution Path:**

1. Attacker gains governance control through legitimate staking mechanisms
2. Attacker generates a malicious Groth16 VK for a circuit where they control the trapdoor (toxic waste from trusted setup)
3. Attacker submits governance proposal calling `set_groth16_verification_key_for_next_epoch` with malicious VK
4. The malicious VK contains valid BN254 curve points, so Rust deserialization succeeds: [6](#0-5) 

5. VK is stored on-chain and converted to `PreparedVerifyingKey` successfully
6. While training wheels are enabled, the pepper service provides protection by only signing valid proofs. However, training wheels are designed to be temporary: [7](#0-6) 

7. Once training wheels are disabled (as intended by design), the attacker can forge Groth16 proofs for arbitrary public inputs using their malicious circuit
8. During proof verification, the forged proofs validate successfully against the malicious VK: [8](#0-7) 

9. Attacker can now authenticate as any keyless account user by forging proofs with:
   - Victim's keyless public key in the public inputs
   - Attacker's ephemeral public key
   - Valid proof against malicious VK

10. Attacker gains full control of victim accounts and can transfer all funds

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under Aptos bug bounty criteria (up to $1,000,000) because it enables:

- **Loss of Funds (theft)**: Complete compromise of all keyless account funds
- **Scale of Impact**: Affects every user using keyless accounts (potentially millions of accounts)
- **Permanence**: Once the malicious VK is set and training wheels disabled, the attack is undetectable until funds are stolen
- **Bypasses Core Security**: Defeats the entire cryptographic authentication mechanism

The code itself acknowledges this severity: [9](#0-8) 

The WARNING explicitly states "If a malicious key is set, this would lead to stolen funds."

## Likelihood Explanation

**Current Likelihood: Low-Medium** (with training wheels enabled)
- Requires governance majority control
- Training wheels currently provide protection
- Pepper service validates proofs before signing

**Future Likelihood: HIGH** (once training wheels disabled)
- Training wheels are explicitly designed to be temporary
- System is intended to operate without training wheels in production
- Once disabled, attack becomes immediately viable for any attacker with governance control
- No technical barriers prevent malicious VK after validation gap is exploited

**Likelihood Factors:**
- The validation function exists but was never wired up (implementation gap)
- The comment falsely claims validation occurs (documentation/code mismatch)
- No mechanism exists to verify VK correctness against expected circuit
- Governance system is the only barrier (social/economic, not technical)

## Recommendation

Implement a three-layer defense:

**Layer 1: Call Existing Validation (Immediate Fix)**

Modify the governance function to call validation:

```move
public fun set_groth16_verification_key_for_next_epoch(fx: &signer, vk: Groth16VerificationKey) {
    system_addresses::assert_aptos_framework(fx);
    validate_groth16_vk(&vk);  // ADD THIS LINE
    config_buffer::upsert<Groth16VerificationKey>(vk);
}
```

Also add to genesis function:
```move
public fun update_groth16_verification_key(fx: &signer, vk: Groth16VerificationKey) {
    system_addresses::assert_aptos_framework(fx);
    chain_status::assert_genesis();
    validate_groth16_vk(&vk);  // ADD THIS LINE
    move_to(fx, vk);
}
```

**Layer 2: Add VK Hash Verification (Strong Defense)**

Store a hash of the expected VK and validate against it:

```move
// In keyless_account.move
const EXPECTED_VK_HASH: vector<u8> = x"..."; // Hash of legitimate circuit VK

fun validate_groth16_vk(vk: &Groth16VerificationKey) {
    // Existing point validation
    assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(&vk.alpha_g1)), E_INVALID_BN254_G1_SERIALIZATION);
    // ... existing checks ...
    
    // NEW: Validate VK hash matches expected
    let vk_bytes = bcs::to_bytes(vk);
    let vk_hash = hash::sha3_256(vk_bytes);
    assert!(vk_hash == EXPECTED_VK_HASH, E_INCORRECT_VK_FOR_CIRCUIT);
}
```

**Layer 3: Multi-Signature VK Updates (Defense in Depth)**

Require multiple security council signatures to approve VK changes, separate from standard governance voting.

**Fix the Misleading Comment:**

Update environment.rs line 288: [4](#0-3) 

Change to accurately reflect reality or implement the claimed check.

## Proof of Concept

```move
#[test(framework = @0x1)]
#[expected_failure(abort_code = 0x1234)] // Should fail but doesn't
fun test_malicious_vk_accepted(framework: &signer) {
    use aptos_framework::keyless_account;
    use std::vector;
    
    // Generate malicious VK with valid curve points but wrong circuit
    // These are valid BN254 points from a different trusted setup
    let malicious_vk = keyless_account::new_groth16_verification_key(
        x"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef", // valid G1 point
        x"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef", // valid G2 point
        x"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef", // valid G2 point  
        x"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef", // valid G2 point
        vector[
            x"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef", // valid G1 point
            x"0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef"  // valid G1 point
        ]
    );
    
    // This should abort with validation error but currently succeeds
    keyless_account::set_groth16_verification_key_for_next_epoch(framework, malicious_vk);
    
    // Test passes (vulnerability): malicious VK accepted without validation
}
```

This test demonstrates that arbitrary VKs with valid curve points are accepted without checking they correspond to the correct keyless circuit.

## Notes

- This vulnerability requires the security question's premise: attacker controlling governance
- The missing validation call appears to be an implementation oversight, not a design decision (evidenced by the function's existence and false documentation claim)
- Training wheels provide temporary protection but are intended to be removed
- Impact is existential for keyless account security model
- Fix is straightforward: call existing validation and add VK hash verification
- Consider this a critical security control gap that undermines the entire keyless authentication architecture

### Citations

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L183-192)
```text
    fun validate_groth16_vk(vk: &Groth16VerificationKey) {
        // Could be leveraged to speed up the VM deserialization of the VK by 2x, since it can assume the points are valid.
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(&vk.alpha_g1)), E_INVALID_BN254_G1_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.beta_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.gamma_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.delta_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        for (i in 0..vector::length(&vk.gamma_abc_g1)) {
            assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(vector::borrow(&vk.gamma_abc_g1, i))), E_INVALID_BN254_G1_SERIALIZATION);
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L198-203)
```text
    public fun update_groth16_verification_key(fx: &signer, vk: Groth16VerificationKey) {
        system_addresses::assert_aptos_framework(fx);
        chain_status::assert_genesis();
        // There should not be a previous resource set here.
        move_to(fx, vk);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L256-262)
```text
    /// Queues up a change to the Groth16 verification key. The change will only be effective after reconfiguration.
    /// Only callable via governance proposal.
    ///
    /// WARNING: To mitigate against DoS attacks, a VK change should be done together with a training wheels PK change,
    /// so that old ZKPs for the old VK cannot be replayed as potentially-valid ZKPs.
    ///
    /// WARNING: If a malicious key is set, this would lead to stolen funds.
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L263-266)
```text
    public fun set_groth16_verification_key_for_next_epoch(fx: &signer, vk: Groth16VerificationKey) {
        system_addresses::assert_aptos_framework(fx);
        config_buffer::upsert<Groth16VerificationKey>(vk);
    }
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L287-293)
```rust
        // We use an `Option` to handle the VK not being set on-chain, or an incorrect VK being set
        // via governance (although, currently, we do check for that in `keyless_account.move`).
        let keyless_pvk =
            Groth16VerificationKey::fetch_keyless_config(state_view).and_then(|(vk, vk_bytes)| {
                sha3_256.update(&vk_bytes);
                vk.try_into().ok()
            });
```

**File:** types/src/keyless/circuit_constants.rs (L30-99)
```rust
pub fn prepared_vk_for_testing() -> PreparedVerifyingKey<Bn254> {
    // Convert the projective points to affine.
    let alpha_g1 = g1_projective_str_to_affine(
        "20491192805390485299153009773594534940189261866228447918068658471970481763042",
        "9383485363053290200918347156157836566562967994039712273449902621266178545958",
    )
    .unwrap();

    let beta_g2 = g2_projective_str_to_affine(
        [
            "6375614351688725206403948262868962793625744043794305715222011528459656738731",
            "4252822878758300859123897981450591353533073413197771768651442665752259397132",
        ],
        [
            "10505242626370262277552901082094356697409835680220590971873171140371331206856",
            "21847035105528745403288232691147584728191162732299865338377159692350059136679",
        ],
    )
    .unwrap();

    let gamma_g2 = g2_projective_str_to_affine(
        [
            "10857046999023057135944570762232829481370756359578518086990519993285655852781",
            "11559732032986387107991004021392285783925812861821192530917403151452391805634",
        ],
        [
            "8495653923123431417604973247489272438418190587263600148770280649306958101930",
            "4082367875863433681332203403145435568316851327593401208105741076214120093531",
        ],
    )
    .unwrap();

    let delta_g2 = g2_projective_str_to_affine(
        [
            "6309950375468367434079888575625734658722834850554198467265341412057133512289",
            "290788916745604303732014379515714703987358626088033030814233237684691015915",
        ],
        [
            "18062633083579661887564610476476551517623934510295133920710347041696656037149",
            "18531177357310703535722548657431805690263733685063962985389260695754645724386",
        ],
    )
    .unwrap();

    let mut gamma_abc_g1 = Vec::new();
    for points in [
        g1_projective_str_to_affine(
            "3314139460766150258181182511839382093976747705712051605578952681462625768062",
            "15177929890957116336235565528373348502554233971408496072173139426537995658198",
        )
        .unwrap(),
        g1_projective_str_to_affine(
            "11040819149070528816396253292991080175919431363817777522273571096667537087166",
            "13976660124609527451731647657081915019685631850685519260597009755390746148997",
        )
        .unwrap(),
    ] {
        gamma_abc_g1.push(points);
    }

    let vk = VerifyingKey {
        alpha_g1,
        beta_g2,
        gamma_g2,
        delta_g2,
        gamma_abc_g1,
    };

    PreparedVerifyingKey::from(vk)
}
```

**File:** types/src/keyless/groth16_vk.rs (L62-91)
```rust
impl TryFrom<&Groth16VerificationKey> for PreparedVerifyingKey<Bn254> {
    type Error = CryptoMaterialError;

    fn try_from(vk: &Groth16VerificationKey) -> Result<Self, Self::Error> {
        if vk.gamma_abc_g1.len() != 2 {
            return Err(CryptoMaterialError::DeserializationError);
        }

        // NOTE: Technically, we already validate the points when we set the VK in Move, so we could
        // make this 2x faster by avoiding the point validation checks  via
        // `deserialize_with_mode(..., Compress::Yes, Validate::No)`. Due to paranoia, will not
        // optimize this for now.
        Ok(Self::from(VerifyingKey {
            alpha_g1: G1Affine::deserialize_compressed(vk.alpha_g1.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            beta_g2: G2Affine::deserialize_compressed(vk.beta_g2.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            gamma_g2: G2Affine::deserialize_compressed(vk.gamma_g2.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            delta_g2: G2Affine::deserialize_compressed(vk.delta_g2.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            gamma_abc_g1: vec![
                G1Affine::deserialize_compressed(vk.gamma_abc_g1[0].as_slice())
                    .map_err(|_| CryptoMaterialError::DeserializationError)?,
                G1Affine::deserialize_compressed(vk.gamma_abc_g1[1].as_slice())
                    .map_err(|_| CryptoMaterialError::DeserializationError)?,
            ],
        }))
    }
}
```

**File:** testsuite/smoke-test/src/keyless.rs (L828-847)
```rust
pub(crate) async fn remove_training_wheels(
    cli: &mut CliTestFramework,
    info: &mut AptosPublicInfo,
    root_idx: usize,
) {
    let script = format!(
        r#"
script {{
use aptos_framework::{};
use aptos_framework::aptos_governance;
use std::option;
fun main(core_resources: &signer) {{
    let framework_signer = aptos_governance::get_signer_testnet_only(core_resources, @0x1);
    {}::update_training_wheels_for_next_epoch(&framework_signer, option::none());
    aptos_governance::force_end_epoch(&framework_signer);
}}
}}
"#,
        KEYLESS_ACCOUNT_MODULE_NAME, KEYLESS_ACCOUNT_MODULE_NAME
    );
```

**File:** types/src/keyless/groth16_sig.rs (L215-235)
```rust
    pub fn verify_proof(
        &self,
        public_inputs_hash: Fr,
        pvk: &PreparedVerifyingKey<Bn254>,
    ) -> anyhow::Result<()> {
        // let start = std::time::Instant::now();
        let proof: Proof<Bn254> = Proof {
            a: self.a.deserialize_into_affine()?,
            b: self.b.deserialize_into_affine()?,
            c: self.c.deserialize_into_affine()?,
        };
        // println!("Deserialization time: {:?}", start.elapsed());

        // let start = std::time::Instant::now();
        let verified = Groth16::<Bn254>::verify_proof(pvk, &proof, &[public_inputs_hash])?;
        // println!("Proof verification time: {:?}", start.elapsed());
        if !verified {
            bail!("groth16 proof verification failed")
        }
        Ok(())
    }
```
