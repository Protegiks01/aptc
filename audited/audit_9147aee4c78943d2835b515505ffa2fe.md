# Audit Report

## Title
Quorum Store Batch Message Exploitation Enables Transaction Censorship by Malicious Validators

## Summary
A malicious validator can systematically censor specific users' transactions across the network by broadcasting batch messages containing those transactions. This causes honest validators to exclude the targeted transactions from their mempool pulls, preventing transaction inclusion in blocks. The attack requires no cryptographic commitment and can be sustained indefinitely with minimal cost.

## Finding Description

The vulnerability exists in the quorum store's batch coordination mechanism, specifically in how remote batches from other validators populate the transaction exclusion list.

**Attack Flow:**

1. Malicious validator V monitors the network and identifies target user U's transaction T in mempool
2. V creates a batch message containing T (along with other transactions to appear legitimate) [1](#0-0) 
3. V broadcasts this batch to other validators via the network [2](#0-1) 
4. Other validators receive the batch and forward it to their `BatchCoordinator` after minimal validation [3](#0-2) 
5. The batch is then sent to `BatchGenerator` as a `RemoteBatch` command [4](#0-3) 
6. `BatchGenerator.insert_batch()` adds T to the `txns_in_progress_sorted` map [5](#0-4) 
7. When honest validators pull transactions from mempool, `txns_in_progress_sorted` is passed as the exclusion list [6](#0-5) 
8. The mempool skips excluded transactions [7](#0-6) 
9. Transaction T cannot be included in blocks by honest validators
10. Remote batches expire after 500ms, but V can send new batches every ~400ms to maintain continuous censorship [8](#0-7) 

**Critical Vulnerability Points:**

The batch verification only checks that the author is a valid validator and matches the sender, but does NOT verify any cryptographic commitment to actually propose these transactions [9](#0-8) 

Individual batch verification only checks hash consistency, not intent to propose [10](#0-9) 

There is no penalty mechanism or rate limiting for validators who create batches that never result in blocks. The `ProofExpiration` mechanism simply removes tracking without consequences [11](#0-10) 

## Impact Explanation

This vulnerability enables **selective transaction censorship**, breaking the fundamental consensus property of transaction inclusion fairness. 

**Severity: HIGH** per Aptos bug bounty criteria - "Significant protocol violations"

The attack:
- Allows a single malicious validator to prevent specific users' transactions from being included in blocks
- Affects all honest validators who receive the malicious batches
- Requires no majority stake or collusion
- Can be sustained indefinitely with negligible cost to the attacker
- Breaks liveness guarantees for targeted users
- Could be used for front-running, MEV extraction, or censorship attacks

While this doesn't directly cause loss of funds or consensus safety violations, it fundamentally undermines the neutrality and permissionless nature of the blockchain, which is a core security property.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

The attack is straightforward to execute:
- Requires only validator status (which Byzantine validators in the threat model already have)
- No sophisticated cryptographic attacks needed
- Attacker can observe all transactions via normal mempool operation
- Batch creation and broadcasting uses standard protocol operations
- Detection is difficult as batches appear normal

The attack is sustainable because:
- No penalty for unused batches
- Low bandwidth cost (can include just a few targeted transactions)
- 500ms expiry means only 2 batches per second needed per targeted transaction
- No reputation system to detect malicious behavior

## Recommendation

Implement cryptographic commitment and economic penalties for batch creation:

1. **Batch Commitment with Slashing**: Require validators to cryptographically sign batch messages, creating a provable commitment. Track which batches result in actual block proposals. Validators who consistently create batches that don't result in proposals should face penalties or reputation degradation.

2. **Rate Limiting**: Implement per-validator rate limits on batch broadcasting to prevent spam attacks.

3. **Ownership Verification**: Only allow validators to create batches containing transactions they directly received, not arbitrary network transactions. This requires tracking transaction provenance.

4. **Proof-of-Proposal Requirement**: Require validators to obtain signatures from other validators before a batch's exclusion takes effect, similar to how quorum certificates work.

**Recommended Fix Approach:**
```rust
// In BatchCoordinator::handle_batches_msg()
// Add validation that the batch author has a valid proof-of-store
// before adding to exclusion list, or require minimum validator 
// signatures on the batch digest before accepting
```

Alternatively, redesign the exclusion mechanism to only exclude transactions that are in batches with valid quorum certificates, not just raw batch messages.

## Proof of Concept

**Rust Integration Test Steps:**

```rust
// Pseudocode for integration test
#[test]
fn test_malicious_batch_censorship() {
    // Setup: Create test network with 4 validators (V1, V2, V3, V4)
    // V1 is malicious, others are honest
    
    // Step 1: User U submits transaction T to mempool
    // All validators see T in their mempools
    
    // Step 2: Malicious V1 creates batch containing T
    let malicious_batch = create_batch_with_transaction(T);
    
    // Step 3: V1 broadcasts batch to V2, V3, V4
    broadcast_batch(malicious_batch, vec![V2, V3, V4]);
    
    // Step 4: Verify honest validators added T to exclusion list
    assert!(V2.txns_in_progress_sorted.contains_key(&T.summary()));
    assert!(V3.txns_in_progress_sorted.contains_key(&T.summary()));
    assert!(V4.txns_in_progress_sorted.contains_key(&T.summary()));
    
    // Step 5: Trigger mempool pull on honest validators
    let v2_txns = V2.mempool_proxy.pull_internal(...);
    let v3_txns = V3.mempool_proxy.pull_internal(...);
    
    // Step 6: Verify T was excluded from pulls
    assert!(!v2_txns.contains(&T));
    assert!(!v3_txns.contains(&T));
    
    // Step 7: V1 never creates proof-of-store or includes in block
    // Wait for batch expiry (500ms)
    sleep(500ms);
    
    // Step 8: Repeat batch creation to maintain censorship
    let new_malicious_batch = create_batch_with_transaction(T);
    broadcast_batch(new_malicious_batch, vec![V2, V3, V4]);
    
    // Step 9: Verify continued censorship
    assert!(V2.txns_in_progress_sorted.contains_key(&T.summary()));
}
```

**Notes**

The vulnerability exploits the trust assumption that validators only include transactions they intend to propose. The batch message system has no mechanism to verify this intent or penalize violations. While the 500ms expiry limits individual batch impact, an attacker can trivially maintain continuous censorship by sending new batches every ~400ms. This attack is particularly concerning because it allows a single Byzantine validator to affect the transaction selection of ALL honest validators, extending the attacker's influence beyond what standard BFT safety properties would allow.

The transaction filter mechanism [12](#0-11)  is disabled by default [13](#0-12)  and even when enabled, only filters based on static rules, not based on validator behavior patterns.

### Citations

**File:** consensus/src/quorum_store/batch_generator.rs (L123-171)
```rust
    fn insert_batch(
        &mut self,
        author: PeerId,
        batch_id: BatchId,
        txns: Vec<SignedTransaction>,
        expiry_time_usecs: u64,
    ) {
        if self.batches_in_progress.contains_key(&(author, batch_id)) {
            return;
        }

        let txns_in_progress: Vec<_> = txns
            .par_iter()
            .with_min_len(optimal_min_len(txns.len(), 32))
            .map(|txn| {
                (
                    TransactionSummary::new(
                        txn.sender(),
                        txn.replay_protector(),
                        txn.committed_hash(),
                    ),
                    TransactionInProgress::new(txn.gas_unit_price()),
                )
            })
            .collect();

        let mut txns = vec![];
        for (summary, info) in txns_in_progress {
            let txn_info = self
                .txns_in_progress_sorted
                .entry(summary)
                .or_insert_with(|| TransactionInProgress::new(info.gas_unit_price));
            txn_info.increment();
            txn_info.gas_unit_price = info.gas_unit_price.max(txn_info.gas_unit_price);
            txns.push(summary);
        }
        let updated_expiry_time_usecs = self
            .batches_in_progress
            .get(&(author, batch_id))
            .map_or(expiry_time_usecs, |batch_in_progress| {
                expiry_time_usecs.max(batch_in_progress.expiry_time_usecs)
            });
        self.batches_in_progress.insert(
            (author, batch_id),
            BatchInProgress::new(txns, updated_expiry_time_usecs),
        );
        self.batch_expirations
            .add_item((author, batch_id), updated_expiry_time_usecs);
    }
```

**File:** consensus/src/quorum_store/batch_generator.rs (L173-212)
```rust
    fn create_new_batch(
        &mut self,
        txns: Vec<SignedTransaction>,
        expiry_time: u64,
        bucket_start: u64,
    ) -> Batch<BatchInfoExt> {
        let batch_id = self.batch_id;
        self.batch_id.increment();
        self.db
            .save_batch_id(self.epoch, self.batch_id)
            .expect("Could not save to db");

        self.insert_batch(self.my_peer_id, batch_id, txns.clone(), expiry_time);

        counters::CREATED_BATCHES_COUNT.inc();
        counters::num_txn_per_batch(bucket_start.to_string().as_str(), txns.len());

        if self.config.enable_batch_v2 {
            // TODO(ibalajiarun): Specify accurate batch kind
            let batch_kind = BatchKind::Normal;
            Batch::new_v2(
                batch_id,
                txns,
                self.epoch,
                expiry_time,
                self.my_peer_id,
                bucket_start,
                batch_kind,
            )
        } else {
            Batch::new_v1(
                batch_id,
                txns,
                self.epoch,
                expiry_time,
                self.my_peer_id,
                bucket_start,
            )
        }
    }
```

**File:** consensus/src/quorum_store/batch_generator.rs (L352-360)
```rust
        let mut pulled_txns = self
            .mempool_proxy
            .pull_internal(
                max_count,
                self.config.sender_max_total_bytes as u64,
                self.txns_in_progress_sorted.clone(),
            )
            .await
            .unwrap_or_default();
```

**File:** consensus/src/quorum_store/batch_generator.rs (L554-563)
```rust
                        BatchGeneratorCommand::ProofExpiration(batch_ids) => {
                            for batch_id in batch_ids {
                                counters::BATCH_IN_PROGRESS_TIMEOUT.inc();
                                debug!(
                                    "QS: received timeout for proof of store, batch id = {}",
                                    batch_id
                                );
                                // Not able to gather the proof, allow transactions to be polled again.
                                self.remove_batch_in_progress(self.my_peer_id, batch_id);
                            }
```

**File:** consensus/src/quorum_store/network_listener.rs (L68-94)
```rust
                    VerifiedEvent::BatchMsg(batch_msg) => {
                        counters::QUORUM_STORE_MSG_COUNT
                            .with_label_values(&["NetworkListener::batchmsg"])
                            .inc();
                        // Batch msg verify function alreay ensures that the batch_msg is not empty.
                        let author = batch_msg.author().expect("Empty batch message");
                        let batches = batch_msg.take();
                        counters::RECEIVED_BATCH_MSG_COUNT.inc();

                        // Round-robin assignment to batch coordinator.
                        let idx = next_batch_coordinator_idx;
                        next_batch_coordinator_idx = (next_batch_coordinator_idx + 1)
                            % self.remote_batch_coordinator_tx.len();
                        trace!(
                            "QS: peer_id {:?},  # network_worker {}, hashed to idx {}",
                            author,
                            self.remote_batch_coordinator_tx.len(),
                            idx
                        );
                        counters::BATCH_COORDINATOR_NUM_BATCH_REQS
                            .with_label_values(&[&idx.to_string()])
                            .inc();
                        self.remote_batch_coordinator_tx[idx]
                            .send(BatchCoordinatorCommand::NewBatches(author, batches))
                            .await
                            .expect("Could not send remote batch");
                    },
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L173-213)
```rust
    pub(crate) async fn handle_batches_msg(
        &mut self,
        author: PeerId,
        batches: Vec<Batch<BatchInfoExt>>,
    ) {
        if let Err(e) = self.ensure_max_limits(&batches) {
            error!("Batch from {}: {}", author, e);
            counters::RECEIVED_BATCH_MAX_LIMIT_FAILED.inc();
            return;
        }

        let Some(batch) = batches.first() else {
            error!("Empty batch received from {}", author.short_str().as_str());
            return;
        };

        // Filter the transactions in the batches. If any transaction is rejected,
        // the message will be dropped, and all batches will be rejected.
        if self.transaction_filter_config.is_enabled() {
            let transaction_filter = &self.transaction_filter_config.batch_transaction_filter();
            for batch in batches.iter() {
                for transaction in batch.txns() {
                    if !transaction_filter.allows_transaction(
                        batch.batch_info().batch_id(),
                        batch.author(),
                        batch.digest(),
                        transaction,
                    ) {
                        error!(
                            "Transaction {}, in batch {}, from {}, was rejected by the filter. Dropping {} batches!",
                            transaction.committed_hash(),
                            batch.batch_info().batch_id(),
                            author.short_str().as_str(),
                            batches.len()
                        );
                        counters::RECEIVED_BATCH_REJECTED_BY_FILTER.inc();
                        return;
                    }
                }
            }
        }
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L231-237)
```rust
            if let Err(e) = self
                .sender_to_batch_generator
                .send(BatchGeneratorCommand::RemoteBatch(batch.clone()))
                .await
            {
                warn!("Failed to send batch to batch generator: {}", e);
            }
```

**File:** mempool/src/core_mempool/mempool.rs (L454-456)
```rust
            if exclude_transactions.contains_key(&txn_ptr) {
                continue;
            }
```

**File:** config/src/config/quorum_store_config.rs (L132-132)
```rust
            remote_batch_expiry_gap_when_init_usecs: Duration::from_millis(500).as_micros() as u64,
```

**File:** consensus/src/quorum_store/types.rs (L262-290)
```rust
    pub fn verify(&self) -> anyhow::Result<()> {
        ensure!(
            self.payload.author() == self.author(),
            "Payload author doesn't match the info"
        );
        ensure!(
            self.payload.hash() == *self.digest(),
            "Payload hash doesn't match the digest"
        );
        ensure!(
            self.payload.num_txns() as u64 == self.num_txns(),
            "Payload num txns doesn't match batch info"
        );
        ensure!(
            self.payload.num_bytes() as u64 == self.num_bytes(),
            "Payload num bytes doesn't match batch info"
        );
        for txn in self.payload.txns() {
            ensure!(
                txn.gas_unit_price() >= self.gas_bucket_start(),
                "Payload gas unit price doesn't match batch info"
            );
            ensure!(
                !txn.payload().is_encrypted_variant(),
                "Encrypted transaction is not supported yet"
            );
        }
        Ok(())
    }
```

**File:** consensus/src/quorum_store/types.rs (L433-461)
```rust
    pub fn verify(
        &self,
        peer_id: PeerId,
        max_num_batches: usize,
        verifier: &ValidatorVerifier,
    ) -> anyhow::Result<()> {
        ensure!(!self.batches.is_empty(), "Empty message");
        ensure!(
            self.batches.len() <= max_num_batches,
            "Too many batches: {} > {}",
            self.batches.len(),
            max_num_batches
        );
        let epoch_authors = verifier.address_to_validator_index();
        for batch in self.batches.iter() {
            ensure!(
                epoch_authors.contains_key(&batch.author()),
                "Invalid author {} for batch {} in current epoch",
                batch.author(),
                batch.digest()
            );
            ensure!(
                batch.author() == peer_id,
                "Batch author doesn't match sender"
            );
            batch.verify()?
        }
        Ok(())
    }
```

**File:** config/src/config/transaction_filters_config.rs (L81-88)
```rust
impl Default for BatchTransactionFilterConfig {
    fn default() -> Self {
        Self {
            filter_enabled: false,                                     // Disable the filter
            batch_transaction_filter: BatchTransactionFilter::empty(), // Use an empty filter
        }
    }
}
```
