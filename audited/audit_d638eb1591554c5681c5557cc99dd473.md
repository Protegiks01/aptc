# Audit Report

## Title
Sensitive Credentials Disclosure in Node Checker Error Messages via URL Embedding

## Summary
The node-checker service uses `{:#}` formatting for error messages which displays full error chains, including `reqwest::Error` instances that contain complete URLs. When users configure node URLs with embedded credentials (e.g., `http://apitoken@node.example.com` or `http://user:password@node.example.com`), these credentials are leaked through error messages returned to clients and server-side logs. Unlike other parts of the Aptos codebase that sanitize URL credentials, the node-checker does not implement this protection. [1](#0-0) 

## Finding Description

The vulnerability exists in multiple locations where the node-checker uses alternate display formatting (`{:#}`) to show full error chains:

1. **TPS Checker error handling**: When API calls fail, the error message includes the full error chain which contains `reqwest::Error` with the complete URL. [2](#0-1) 

2. **Provider error formatting**: `ProviderError` explicitly uses `{:#}` to display nested errors. [3](#0-2) 

3. **Checker error formatting**: `CheckerError` uses `{:#}` formatting for all error variants. [4](#0-3) 

4. **Direct URL logging**: URLs are logged without sanitization in error scenarios. [5](#0-4) 

5. **Retry error logging**: Errors are logged with full chains during retry attempts. [6](#0-5) 

The underlying issue is that `RestError::Http` wraps `reqwest::Error`, which includes the full URL in its display output: [7](#0-6) 

**Attack Path:**
1. User calls the node-checker `/check` endpoint with a URL containing embedded credentials: `http://apitoken@validator.example.com`
2. The API call fails (network error, timeout, connection refused, etc.)
3. A `reqwest::Error` is generated containing the full URL with credentials
4. The error propagates through `RestError` → `ProviderError` → `CheckerError`
5. Error formatting with `{:#}` displays the full chain including the URL with credentials
6. Credentials are exposed to:
   - The client in the API response
   - Server-side logs via `error!()` macro calls
   - Anyone with access to logs or error monitoring systems

**Evidence of Awareness:** The codebase demonstrates awareness of this vulnerability pattern in other components:
- Node logger masks PostgreSQL URI passwords before logging [8](#0-7) 

- IndexerConfig implements custom Debug to mask passwords [9](#0-8) 

## Impact Explanation

**Medium Severity** - This constitutes information disclosure that could escalate to validator compromise:

1. **Credential Leakage**: API tokens, HTTP basic authentication credentials, or other sensitive tokens embedded in URLs are exposed
2. **Validator Compromise Risk**: If leaked credentials grant access to validator nodes, attackers could:
   - Manipulate validator behavior
   - Access sensitive validator configuration
   - Cause denial of service
   - Potentially influence consensus if the validator is critical
3. **Operational Security Impact**: Leaked credentials could provide access to internal infrastructure, monitoring systems, or management APIs

While this doesn't directly cause "Loss of Funds" or "Consensus/Safety violations" (Critical), it enables attacks that could lead to "State inconsistencies requiring intervention" (Medium) if validator infrastructure is compromised.

Note: Private keys are protected via `SilentDebug` implementation and do not leak through this vulnerability. [10](#0-9) 

## Likelihood Explanation

**Medium to High Likelihood:**

1. **Common Pattern**: HTTP basic authentication (`http://user:pass@host`) is a well-known pattern that users might employ
2. **Natural Occurrence**: Network errors that trigger the vulnerability occur regularly (timeouts, connection failures, misconfigurations)
3. **Service Nature**: Node-checker is used for monitoring validator nodes, making it likely that operators might attempt to embed authentication tokens
4. **No Warning**: The service doesn't warn users against embedding credentials in URLs
5. **No Sanitization**: Unlike other Aptos components, the node-checker doesn't sanitize URLs before logging

## Recommendation

Implement URL credential sanitization throughout the node-checker codebase, following the pattern established in other Aptos components:

**1. Create a URL sanitization utility:**
```rust
// In ecosystem/node-checker/src/common/mod.rs or similar
pub fn sanitize_url(url: &url::Url) -> String {
    let mut sanitized = url.clone();
    if sanitized.password().is_some() {
        sanitized.set_password(Some("***")).unwrap();
    }
    if !sanitized.username().is_empty() {
        sanitized.set_username("***").unwrap();
    }
    sanitized.to_string()
}
```

**2. Implement custom Debug for NodeAddress:** [11](#0-10) 

Add a custom Debug implementation that sanitizes the URL before display.

**3. Sanitize URLs in error messages and logs:**
- Before logging URLs in api.rs line 100
- In error context strings that might include URLs
- Consider implementing a wrapper type for URLs that automatically sanitizes in Display/Debug

**4. Add validation:** Reject URLs with embedded credentials at input validation stage with a clear error message directing users to use proper authentication headers instead.

## Proof of Concept

**Reproduction Steps:**

1. Start the node-checker service
2. Call the `/check` endpoint with a URL containing credentials:
   ```bash
   curl "http://localhost:8080/check?baseline_configuration_id=devnet_fullnode&node_url=http://secret-token@invalid-node.example.com&api_port=8080"
   ```
3. Since the node doesn't exist, a connection error occurs
4. The error response will contain the full URL including `secret-token`:
   ```json
   {
     "error": "Something went wrong hitting endpoint /: error sending request for url (http://secret-token@invalid-node.example.com:8080/): ...",
     ...
   }
   ```
5. Server logs will also contain the unsanitized URL

**Rust Integration Test:**
```rust
#[tokio::test]
async fn test_url_credential_sanitization() {
    use url::Url;
    
    // Create URL with embedded credentials
    let url_with_creds = Url::parse("http://api-token:secret@validator.example.com").unwrap();
    
    // This should sanitize the credentials
    let sanitized = sanitize_url(&url_with_creds);
    
    assert!(!sanitized.contains("api-token"));
    assert!(!sanitized.contains("secret"));
    assert!(sanitized.contains("***"));
}
```

## Notes

- The vulnerability affects all node-checker endpoints and checkers that make HTTP requests
- While `Ed25519PrivateKey` types are protected by `SilentDebug`, URL-embedded credentials are not
- The fix should be applied consistently across all logging and error handling paths in the node-checker
- Consider adding input validation to reject URLs with embedded credentials entirely, forcing users to use proper authentication mechanisms (headers, certificates, etc.)

### Citations

**File:** ecosystem/node-checker/src/checker/tps.rs (L119-127)
```rust
        let chain_id = match target_api_index_provider.provide().await {
            Ok(response) => ChainId::new(response.chain_id),
            Err(err) => {
                return Ok(vec![Self::build_result(
                    "Failed to get chain ID of your node".to_string(),
                    0,
                    format!("There was an error querying your node's API: {:#}", err),
                )]);
            },
```

**File:** ecosystem/node-checker/src/provider/traits.rs (L28-38)
```rust
#[derive(Error, Debug)]
pub enum ProviderError {
    #[error("Something went wrong hitting endpoint {0}: {1:#}")]
    RetryableEndpointError(&'static str, #[source] anyhow::Error),

    #[error("Something went wrong hitting endpoint {0}: {1:#}")]
    NonRetryableEndpointError(&'static str, #[source] anyhow::Error),

    #[error("Something went wrong parsing the response from the node: {0:#}")]
    ParseError(#[from] anyhow::Error),
}
```

**File:** ecosystem/node-checker/src/checker/traits.rs (L46-63)
```rust
#[derive(Error, Debug)]
pub enum CheckerError {
    #[error("Provider failed to return data: {0:#}")]
    ProviderError(#[from] ProviderError),

    #[error("Something went wrong hitting endpoint {0}: {1:#}")]
    RetryableEndpointError(&'static str, #[source] anyhow::Error),

    #[error("Something went wrong hitting endpoint {0}: {1:#}")]
    NonRetryableEndpointError(&'static str, #[source] anyhow::Error),

    #[error("The necessary data ({0}) was mising: {1:#}")]
    MissingDataError(&'static str, #[source] anyhow::Error),

    // The TPS checker is pretty complex, we give it its own errors here.
    #[error("Something went wrong with the TPS checker: {0:#}")]
    TpsCheckerError(#[from] TpsCheckerError),
}
```

**File:** ecosystem/node-checker/src/server/api.rs (L96-106)
```rust
            Err(e) => {
                // We only get to this point if the evaluation failed due to an error
                // on our side, e.g. something wrong with NHC or the baseline.
                error!(
                    target_node_url = target_node_address.url,
                    event = "check_failed_our_fault"
                );
                Err(poem::Error::from((
                    StatusCode::INTERNAL_SERVER_ERROR,
                    anyhow!(e),
                )))
```

**File:** ecosystem/node-checker/src/runner/sync_runner.rs (L194-207)
```rust
                        warn!(
                            "Checker failed with a retryable error: {:#}. Retrying in {} seconds.",
                            err, self.config.retry_delay_secs
                        );
                        tokio::time::sleep(Duration::from_secs(
                            self.config.retry_delay_secs.into(),
                        ))
                        .await;
                    } else {
                        error!(
                            "Checker failed with a retryable error too many times ({}): {:#}.",
                            self.config.num_retries, err
                        );
                        return Err(err);
```

**File:** crates/aptos-rest-client/src/error.rs (L160-162)
```rust
    #[error("HTTP error {0}: {1}")]
    Http(StatusCode, reqwest::Error),
}
```

**File:** aptos-node/src/logger.rs (L91-98)
```rust
    if let Some(u) = &node_config.indexer.postgres_uri {
        let mut parsed_url = url::Url::parse(u).expect("Invalid postgres uri");
        if parsed_url.password().is_some() {
            masked_config = node_config.clone();
            parsed_url.set_password(Some("*")).unwrap();
            masked_config.indexer.postgres_uri = Some(parsed_url.to_string());
            config = &masked_config;
        }
```

**File:** config/src/config/indexer_config.rs (L92-100)
```rust
impl Debug for IndexerConfig {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        let postgres_uri = self.postgres_uri.as_ref().map(|u| {
            let mut parsed_url = url::Url::parse(u).expect("Invalid postgres uri");
            if parsed_url.password().is_some() {
                parsed_url.set_password(Some("*")).unwrap();
            }
            parsed_url.to_string()
        });
```

**File:** crates/transaction-emitter-lib/src/args.rs (L21-36)
```rust
#[derive(Clone, Debug, Default, Deserialize, Parser, Serialize)]
pub struct CoinSourceArgs {
    /// Ed25519PrivateKey for minting coins
    #[clap(long, value_parser = ConfigKey::<Ed25519PrivateKey>::from_encoded_string)]
    pub mint_key: Option<ConfigKey<Ed25519PrivateKey>>,

    #[clap(long, conflicts_with = "mint_key")]
    pub mint_file: Option<String>,

    /// Ed25519PrivateKey for minting coins
    #[clap(long, value_parser = ConfigKey::<Ed25519PrivateKey>::from_encoded_string, conflicts_with_all = &["mint_key", "mint_file"])]
    pub coin_source_key: Option<ConfigKey<Ed25519PrivateKey>>,

    #[clap(long, conflicts_with_all = &["mint_key", "mint_file", "coin_source_key"])]
    pub coin_source_file: Option<String>,
}
```

**File:** ecosystem/node-checker/src/configuration/node_address.rs (L13-35)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct NodeAddress {
    /// Target URL. This should include a scheme (e.g. http://). If there is no
    /// scheme, we will prepend http://.
    pub url: Url,

    /// API port.
    api_port: Option<u16>,

    /// Metrics port.
    metrics_port: Option<u16>,

    /// Validator communication port.
    noise_port: Option<u16>,

    /// Public key for the node. This is used for the HandshakeChecker.
    /// If that Checker is not enabled, this is not necessary.
    public_key: Option<x25519::PublicKey>,

    // Cookie store.
    #[serde(skip)]
    cookie_store: Arc<Jar>,
}
```
