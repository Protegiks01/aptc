# Audit Report

## Title
Missing Validation and Silent Error Handling in Groth16 Verification Key Loading Enables Denial of Service on Keyless Accounts

## Summary
The Groth16 verification key (VK) used for keyless authentication lacks proper validation during on-chain updates and silently fails during VM loading, enabling a complete denial of service for all keyless accounts using zero-knowledge proofs through governance-controlled VK corruption.

## Finding Description

The Groth16 verification key validation flow has three critical flaws:

**Flaw 1: Dead Validation Code**
A validation function `validate_groth16_vk()` exists in the Move code that properly validates all elliptic curve points, but it is **never called** during VK updates. [1](#0-0) 

This function is not invoked by either VK update path: [2](#0-1) 

**Flaw 2: Missing Boundary Checks**
The Rust `TryFrom` implementation lacks validation for:
- Empty byte vectors for curve points
- Maximum size limits (could accept gigabyte-sized vectors)
- Only checks `gamma_abc_g1.len() == 2` but not element sizes [3](#0-2) 

**Flaw 3: Silent Error Swallowing**
When the VM loads the VK from on-chain state, conversion failures are silently discarded using `.ok()`, resulting in `keyless_pvk = None`: [4](#0-3) 

When `keyless_pvk` is `None`, all ZK keyless transactions are rejected: [5](#0-4) 

**Attack Path:**
1. Governance proposal sets malformed VK with edge cases:
   - Empty vectors: `alpha_g1: vec![]`
   - Wrong sizes: `alpha_g1: vec![0u8; 31]` (should be 32)
   - Oversized: `beta_g2: vec![0u8; 1_000_000]` (should be 64)
   - Invalid points: `alpha_g1: vec![0u8; 32]` or `vec![0xFFu8; 32]`
2. No validation occurs during `set_groth16_verification_key_for_next_epoch()`
3. Malformed VK stored on-chain via epoch transition
4. All validators load VK, conversion fails
5. `keyless_pvk` becomes `None` across all nodes
6. All keyless ZK transactions permanently rejected with "Groth16 VK has not been set on-chain"

## Impact Explanation

**Severity: HIGH (approaching CRITICAL)**

This vulnerability causes **total loss of liveness for keyless accounts** using zero-knowledge proofs:
- All keyless ZK transactions fail across the entire network
- Affects all users relying on keyless authentication with ZK proofs
- Requires another governance proposal + epoch change to fix (days of downtime)
- Breaks the **Deterministic Execution** invariant (all validators agree VK is invalid)
- Breaks the **Resource Limits** invariant (no bounds on vector sizes)

While it doesn't meet "Total loss of liveness/network availability" (only affects keyless, not all transactions), it severely impacts a critical user-facing feature and could strand user funds if they can only access accounts via keyless auth.

## Likelihood Explanation

**Likelihood: MEDIUM**

This vulnerability requires governance access to exploit maliciously. However, the likelihood increases significantly considering:

1. **Accidental triggers during legitimate upgrades**: Well-meaning governance participants could accidentally submit malformed VK data during routine cryptographic upgrades
2. **No defensive checks**: The complete absence of validation makes mistakes inevitable
3. **Silent failures**: Operators won't know the VK is invalid until users start failing
4. **Governance compromise**: If governance is compromised through any means, this is trivial to exploit

The comment at line 262 explicitly warns "If a malicious key is set, this would lead to stolen funds," showing developers were aware of VK security importance but failed to implement validation. [6](#0-5) 

## Recommendation

**Immediate Fix:**

1. **Call the existing validation function** in `set_groth16_verification_key_for_next_epoch()`:

```move
public fun set_groth16_verification_key_for_next_epoch(fx: &signer, vk: Groth16VerificationKey) {
    system_addresses::assert_aptos_framework(fx);
    validate_groth16_vk(&vk);  // ADD THIS LINE
    config_buffer::upsert<Groth16VerificationKey>(vk);
}
```

2. **Add size bounds checks in Rust** before deserialization:

```rust
impl TryFrom<&Groth16VerificationKey> for PreparedVerifyingKey<Bn254> {
    type Error = CryptoMaterialError;
    
    fn try_from(vk: &Groth16VerificationKey) -> Result<Self, Self::Error> {
        // Validate sizes
        if vk.alpha_g1.len() != 32 { return Err(CryptoMaterialError::WrongLengthError); }
        if vk.beta_g2.len() != 64 { return Err(CryptoMaterialError::WrongLengthError); }
        if vk.gamma_g2.len() != 64 { return Err(CryptoMaterialError::WrongLengthError); }
        if vk.delta_g2.len() != 64 { return Err(CryptoMaterialError::WrongLengthError); }
        if vk.gamma_abc_g1.len() != 2 { return Err(CryptoMaterialError::DeserializationError); }
        if vk.gamma_abc_g1[0].len() != 32 { return Err(CryptoMaterialError::WrongLengthError); }
        if vk.gamma_abc_g1[1].len() != 32 { return Err(CryptoMaterialError::WrongLengthError); }
        
        // Rest of implementation...
    }
}
```

3. **Log conversion failures** instead of silent swallowing in environment.rs

## Proof of Concept

```move
#[test(fx = @aptos_framework)]
fun test_malformed_vk_dos(fx: &signer) {
    use aptos_framework::keyless_account;
    
    // Malformed VK with empty alpha_g1
    let bad_vk = keyless_account::new_groth16_verification_key(
        vector::empty(),  // Empty instead of 32 bytes
        vector::empty(),  // Empty instead of 64 bytes
        vector::empty(),
        vector::empty(),
        vector[vector::empty(), vector::empty()]
    );
    
    // This should fail but doesn't - no validation!
    keyless_account::set_groth16_verification_key_for_next_epoch(fx, bad_vk);
    
    // After epoch change, VK is on-chain but invalid
    // All validators will have keyless_pvk = None
    // All keyless ZK transactions will fail
}
```

## Notes

- Expected sizes per BN254 specification: G1 compressed = 32 bytes, G2 compressed = 64 bytes [7](#0-6) 

- No tests exist for edge cases in `groth16_vk.rs` (no `#[test]` or `#[cfg(test)]` blocks found)
- The Move validation function correctly implements all necessary checks but is dead code

### Citations

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L183-192)
```text
    fun validate_groth16_vk(vk: &Groth16VerificationKey) {
        // Could be leveraged to speed up the VM deserialization of the VK by 2x, since it can assume the points are valid.
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(&vk.alpha_g1)), E_INVALID_BN254_G1_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.beta_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.gamma_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.delta_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        for (i in 0..vector::length(&vk.gamma_abc_g1)) {
            assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(vector::borrow(&vk.gamma_abc_g1, i))), E_INVALID_BN254_G1_SERIALIZATION);
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L256-262)
```text
    /// Queues up a change to the Groth16 verification key. The change will only be effective after reconfiguration.
    /// Only callable via governance proposal.
    ///
    /// WARNING: To mitigate against DoS attacks, a VK change should be done together with a training wheels PK change,
    /// so that old ZKPs for the old VK cannot be replayed as potentially-valid ZKPs.
    ///
    /// WARNING: If a malicious key is set, this would lead to stolen funds.
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L263-266)
```text
    public fun set_groth16_verification_key_for_next_epoch(fx: &signer, vk: Groth16VerificationKey) {
        system_addresses::assert_aptos_framework(fx);
        config_buffer::upsert<Groth16VerificationKey>(vk);
    }
```

**File:** types/src/keyless/groth16_vk.rs (L62-91)
```rust
impl TryFrom<&Groth16VerificationKey> for PreparedVerifyingKey<Bn254> {
    type Error = CryptoMaterialError;

    fn try_from(vk: &Groth16VerificationKey) -> Result<Self, Self::Error> {
        if vk.gamma_abc_g1.len() != 2 {
            return Err(CryptoMaterialError::DeserializationError);
        }

        // NOTE: Technically, we already validate the points when we set the VK in Move, so we could
        // make this 2x faster by avoiding the point validation checks  via
        // `deserialize_with_mode(..., Compress::Yes, Validate::No)`. Due to paranoia, will not
        // optimize this for now.
        Ok(Self::from(VerifyingKey {
            alpha_g1: G1Affine::deserialize_compressed(vk.alpha_g1.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            beta_g2: G2Affine::deserialize_compressed(vk.beta_g2.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            gamma_g2: G2Affine::deserialize_compressed(vk.gamma_g2.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            delta_g2: G2Affine::deserialize_compressed(vk.delta_g2.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            gamma_abc_g1: vec![
                G1Affine::deserialize_compressed(vk.gamma_abc_g1[0].as_slice())
                    .map_err(|_| CryptoMaterialError::DeserializationError)?,
                G1Affine::deserialize_compressed(vk.gamma_abc_g1[1].as_slice())
                    .map_err(|_| CryptoMaterialError::DeserializationError)?,
            ],
        }))
    }
}
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L287-293)
```rust
        // We use an `Option` to handle the VK not being set on-chain, or an incorrect VK being set
        // via governance (although, currently, we do check for that in `keyless_account.move`).
        let keyless_pvk =
            Groth16VerificationKey::fetch_keyless_config(state_view).and_then(|(vk, vk_bytes)| {
                sha3_256.update(&vk_bytes);
                vk.try_into().ok()
            });
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L188-191)
```rust
    // If there are ZK authenticators, the Groth16 VK must have been set on-chain.
    if with_zk && pvk.is_none() {
        return Err(invalid_signature!("Groth16 VK has not been set on-chain"));
    }
```

**File:** aptos-move/framework/src/natives/cryptography/algebra/serialization.rs (L546-557)
```rust
        (Some(Structure::BN254G1), Some(SerializationFormat::BN254G1Compressed)) => {
            // Valid BN254G1AffineCompressed serialization should be 32-byte.
            if bytes.len() != 32 {
                return Ok(smallvec![Value::bool(false), Value::u64(0)]);
            }
            ark_ec_point_deserialize_internal!(
                context,
                bytes,
                ark_bn254::G1Affine,
                deserialize_compressed,
                ALGEBRA_ARK_BN254_G1_AFFINE_DESER_COMP
            )
```
