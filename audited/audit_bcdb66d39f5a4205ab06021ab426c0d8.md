# Audit Report

## Title
MultiEd25519 Duplicate Public Key Acceptance Breaks Multi-Signature Safety Assumptions

## Summary
The `MultiEd25519PublicKey` implementation allows duplicate public keys without validation, enabling an attacker with access to a single private key to meet arbitrary signature thresholds by reusing the same signature multiple times. This breaks the fundamental multi-signature safety invariant that k-of-n thresholds require k distinct signers.

## Finding Description

The `verify_arbitrary_msg()` function in the MultiEd25519 signature scheme correctly verifies each individual signature against its corresponding public key. However, the public key construction logic lacks validation to prevent duplicate public keys, creating a critical security vulnerability. [1](#0-0) 

The constructor for `MultiEd25519PublicKey::new()` only validates that threshold is non-zero, threshold ≤ number of keys, and total keys ≤ 32. It does NOT check for duplicate public keys in the vector.

During signature verification, the system iterates through signatures and matches them to public keys based on the bitmap: [2](#0-1) 

**Attack Scenario:**

1. Attacker creates a MultiEd25519 account with public keys `[pk_A, pk_A, pk_A, pk_B]` and threshold `3`
2. User believes this requires 3 different signers, but actually only needs signatures from key A
3. Attacker provides:
   - Bitmap: `0b11100000` (indicating positions 0, 1, 2)
   - Signatures: `[sig_A, sig_A, sig_A]` (same signature three times)
4. Verification succeeds:
   - First `sig_A` verified against `pk_A` at position 0 ✓
   - Second `sig_A` verified against `pk_A` at position 1 ✓  
   - Third `sig_A` verified against `pk_A` at position 2 ✓
   - Threshold of 3 met ✓

The attacker has bypassed multi-sig protection with a single private key, defeating the purpose of threshold signatures.

While legacy Diem documentation mentions this as a "weighted multisig" feature, Aptos framework provides no such documentation: [3](#0-2) 

The Aptos implementation lacks any similar documentation or warnings: [4](#0-3) 

## Impact Explanation

**Critical Severity** - This vulnerability enables:

1. **Loss of Funds**: Multi-sig wallets configured with duplicate keys can be drained by an attacker with a single compromised key
2. **Governance Manipulation**: Multi-sig governance accounts can be unilaterally controlled
3. **Consensus Impact**: If validator multi-sig operations use duplicate keys, single-key compromise breaks security assumptions

This breaks the **Cryptographic Correctness** invariant (#10): "BLS signatures, VRF, and hash operations must be secure" - while this involves Ed25519 not BLS, the multi-signature security guarantee is fundamentally violated.

It also violates **Access Control** invariant (#8) for multi-sig protected accounts, allowing single-signer control over multi-signer resources.

## Likelihood Explanation

**Medium-High Likelihood** because:

1. **User Confusion**: Users expect "3-of-4 multisig" to mean "3 different people must sign", not understanding duplicate keys are allowed
2. **UI/SDK Bugs**: Wallet interfaces or SDKs could accidentally create duplicate keys through implementation errors  
3. **No Warnings**: The API provides no error or warning when duplicate keys are detected
4. **Undocumented Behavior**: Aptos framework does not document this "weighted multisig" capability, making it an unexpected footgun

Attack requires either:
- User error in multi-sig setup (likely with poor tooling)
- Attacker social engineering victim into accepting duplicate keys
- Compromise of one key in a misconfigured multi-sig (standard attack surface)

## Recommendation

Add duplicate public key validation in `MultiEd25519PublicKey::new()`:

```rust
pub fn new(
    public_keys: Vec<Ed25519PublicKey>,
    threshold: u8,
) -> std::result::Result<Self, CryptoMaterialError> {
    let num_of_public_keys = public_keys.len();
    if threshold == 0 || num_of_public_keys < threshold as usize {
        Err(CryptoMaterialError::ValidationError)
    } else if num_of_public_keys > MAX_NUM_OF_KEYS {
        Err(CryptoMaterialError::WrongLengthError)
    } else {
        // NEW: Check for duplicate public keys
        let mut unique_keys = std::collections::HashSet::new();
        for pk in &public_keys {
            if !unique_keys.insert(pk.to_bytes()) {
                return Err(CryptoMaterialError::ValidationError);
            }
        }
        
        Ok(MultiEd25519PublicKey {
            public_keys,
            threshold,
        })
    }
}
```

If "weighted multisig" is a desired feature, create a separate API with explicit documentation and warnings, or add a boolean flag to opt-in to duplicate keys.

## Proof of Concept

```rust
#[test]
fn test_duplicate_keys_break_multisig_safety() {
    use crate::{
        ed25519::Ed25519PrivateKey,
        multi_ed25519::{MultiEd25519PublicKey, MultiEd25519Signature},
        traits::*,
    };
    
    // Generate a single key pair
    let private_key = Ed25519PrivateKey::generate_for_testing();
    let public_key = private_key.public_key();
    
    // Create multi-sig with DUPLICATE keys, threshold 3
    // User THINKS this requires 3 different signers
    let multi_public_key = MultiEd25519PublicKey::new(
        vec![public_key.clone(), public_key.clone(), public_key.clone()],
        3
    ).unwrap();
    
    // Sign message with the single key
    let message = b"Transfer 1000 APT to attacker";
    let single_signature = private_key.sign_arbitrary_message(message);
    
    // Create multi-sig with SAME signature repeated 3 times
    let multi_signature = MultiEd25519Signature::new(vec![
        (single_signature.clone(), 0),  // Position 0
        (single_signature.clone(), 1),  // Position 1  
        (single_signature, 2),          // Position 2
    ]).unwrap();
    
    // VULNERABILITY: Verification succeeds with single signer!
    assert!(multi_signature.verify_arbitrary_msg(message, &multi_public_key).is_ok());
    
    // Expected: Should FAIL because only 1 unique signer, not 3
    // Actual: PASSES, breaking multi-sig safety
}
```

This test demonstrates that an attacker with ONE private key can satisfy a threshold of THREE by exploiting duplicate public keys, fundamentally breaking multi-signature security guarantees.

### Citations

**File:** crates/aptos-crypto/src/multi_ed25519.rs (L82-103)
```rust
impl MultiEd25519PublicKey {
    /// Construct a new MultiEd25519PublicKey.
    /// --- Rules ---
    /// a) threshold cannot be zero.
    /// b) public_keys.len() should be equal to or larger than threshold.
    /// c) support up to MAX_NUM_OF_KEYS public keys.
    pub fn new(
        public_keys: Vec<Ed25519PublicKey>,
        threshold: u8,
    ) -> std::result::Result<Self, CryptoMaterialError> {
        let num_of_public_keys = public_keys.len();
        if threshold == 0 || num_of_public_keys < threshold as usize {
            Err(CryptoMaterialError::ValidationError)
        } else if num_of_public_keys > MAX_NUM_OF_KEYS {
            Err(CryptoMaterialError::WrongLengthError)
        } else {
            Ok(MultiEd25519PublicKey {
                public_keys,
                threshold,
            })
        }
    }
```

**File:** crates/aptos-crypto/src/multi_ed25519.rs (L544-557)
```rust
        let mut bitmap_index = 0;
        // TODO: Eventually switch to deterministic batch verification
        for sig in &self.signatures {
            while !bitmap_get_bit(self.bitmap, bitmap_index) {
                bitmap_index += 1;
            }
            let pk = public_key
                .public_keys
                .get(bitmap_index)
                .ok_or_else(|| anyhow::anyhow!("Public key index {bitmap_index} out of bounds"))?;
            sig.verify_arbitrary_msg(message, pk)?;
            bitmap_index += 1;
        }
        Ok(())
```

**File:** third_party/move/move-examples/diem-framework/move-packages/DPN/sources/Authenticator.move (L32-35)
```text
    /// Create a a multisig policy from a vector of ed25519 public keys and a threshold.
    /// Note: this does *not* check uniqueness of keys. Repeated keys are convenient to
    /// encode weighted multisig policies. For example Alice AND 1 of Bob or Carol is
    /// public_key: {alice_key, alice_key, bob_key, carol_key}, threshold: 3
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/multi_ed25519.move (L118-135)
```text
    /// Parses the input 32 bytes as an *unvalidated* MultiEd25519 public key.
    ///
    /// NOTE: This function could have also checked that the # of sub-PKs is > 0, but it did not. However, since such
    /// invalid PKs are rejected during signature verification  (see `bugfix_unvalidated_pk_from_zero_subpks`) they
    /// will not cause problems.
    ///
    /// We could fix this API by adding a new one that checks the # of sub-PKs is > 0, but it is likely not a good idea
    /// to reproduce the PK validation logic in Move. We should not have done so in the first place. Instead, we will
    /// leave it as is and continue assuming `UnvalidatedPublicKey` objects could be invalid PKs that will safely be
    /// rejected during signature verification.
    public fun new_unvalidated_public_key_from_bytes(bytes: vector<u8>): UnvalidatedPublicKey {
        let len = bytes.length();
        let num_sub_pks = len / INDIVIDUAL_PUBLIC_KEY_NUM_BYTES;

        assert!(num_sub_pks <= MAX_NUMBER_OF_PUBLIC_KEYS, error::invalid_argument(E_WRONG_PUBKEY_SIZE));
        assert!(len % INDIVIDUAL_PUBLIC_KEY_NUM_BYTES == THRESHOLD_SIZE_BYTES, error::invalid_argument(E_WRONG_PUBKEY_SIZE));
        UnvalidatedPublicKey { bytes }
    }
```
