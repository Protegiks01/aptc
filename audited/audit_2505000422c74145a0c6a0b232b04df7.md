# Audit Report

## Title
Aggregator V1 Delta Operations Bypass Storage Fee Calculation Leading to Unmetered State Modifications

## Summary
Aggregator V1 delta operations (add/subtract) are not included in storage fee calculations, allowing transactions to modify on-chain state without proper gas accounting. Additionally, materialized deltas create WriteOps with empty metadata, potentially causing loss of storage deposit tracking.

## Finding Description

The vulnerability exists in how Aggregator V1 delta operations are processed during transaction execution and fee calculation.

When an aggregator is modified via `add()` or `sub()` native functions, the change is recorded as a delta operation based on the aggregator's state: [1](#0-0) 

These deltas are stored in `aggregator_v1_delta_set` within the change set. However, when storage fees are calculated via `process_storage_fee_for_all`, the `write_op_info_iter_mut` iterator only processes `aggregator_v1_write_set` and explicitly excludes `aggregator_v1_delta_set`: [2](#0-1) 

After fee calculation completes, deltas are materialized into WriteOps through `try_materialize_aggregator_v1_delta_set`: [3](#0-2) 

The materialization process creates WriteOps as `legacy_modification` with empty metadata: [4](#0-3) [5](#0-4) 

This creates two issues:
1. **Fee Bypass**: Delta operations never go through storage fee calculation, allowing free state modifications
2. **Metadata Loss**: Materialized WriteOps have `StateValueMetadata::none()`, potentially overwriting existing metadata and causing loss of deposit tracking

The codebase contains an explicit TODO acknowledging this issue: [6](#0-5) 

## Impact Explanation

This violates the **Resource Limits** invariant (#9): "All operations must respect gas, storage, and computational limits."

**High Severity** - The vulnerability allows:
- **Incorrect gas metering**: Transactions can modify aggregator state without paying appropriate storage fees
- **Potential storage deposit loss**: If metadata is overwritten with empty values, future deletions may not receive proper refunds
- **Protocol violation**: State modifications bypass the intended fee mechanism, creating economic imbalances

Per Aptos Bug Bounty criteria, this falls under "Significant protocol violations" (High Severity).

## Likelihood Explanation

**High Likelihood** - This occurs automatically for any transaction using Aggregator V1's `add()` or `sub()` operations, which are commonly used throughout the Aptos framework for concurrent state updates (e.g., coin supply tracking, fee collection). No special attacker capability is required beyond submitting normal transactions that interact with aggregators.

## Recommendation

Modify the storage fee calculation logic to include aggregator deltas:

1. Update `write_op_info_iter_mut` to iterate over both `aggregator_v1_write_set` AND `aggregator_v1_delta_set`
2. For delta operations, fetch the existing metadata from storage and attach it to the materialized WriteOp
3. Ensure materialized WriteOps preserve existing metadata rather than creating empty metadata
4. Add proper fee charging logic for delta operations based on their size and nature

The fix should ensure deltas are charged appropriately before materialization and preserve existing metadata to maintain deposit tracking integrity.

## Proof of Concept

```move
// PoC demonstrating fee bypass via aggregator delta operations
script {
    use aptos_framework::aggregator_factory;
    use aptos_framework::aggregator;
    
    fun exploit_aggregator_fee_bypass(account: &signer) {
        // Create an aggregator (this pays fees normally)
        let agg_factory = aggregator_factory::borrow_factory(account);
        let agg = aggregator_factory::create_aggregator(&mut agg_factory, 1000000);
        
        // Perform delta operations (these bypass storage fee calculation)
        // Each add/sub modifies state but doesn't go through fee calculation
        aggregator::add(&mut agg, 100);  // Fee bypass
        aggregator::add(&mut agg, 200);  // Fee bypass
        aggregator::sub(&mut agg, 50);   // Fee bypass
        
        // These state modifications were made without proper storage fee charging
        // The deltas are materialized after fee calculation completes
        
        aggregator::destroy(agg);
        // If metadata was lost during delta materialization,
        // this deletion may not refund the original storage deposit
    }
}
```

**Notes**

The vulnerability stems from a fundamental architectural issue where delta operations are treated as second-class citizens in the fee calculation pipeline. The explicit TODO comment in the codebase confirms this is a known limitation that requires fixing. The impact is significant because Aggregator V1 is used extensively throughout the Aptos framework for parallel state updates, meaning this fee bypass affects many core operations.

### Citations

**File:** aptos-move/framework/src/natives/aggregator_natives/context.rs (L118-132)
```rust
            let change = match state {
                AggregatorState::Data => AggregatorChangeV1::Write(value),
                AggregatorState::PositiveDelta => {
                    let history = history.unwrap();
                    let plus = SignedU128::Positive(value);
                    let delta_op = DeltaOp::new(plus, limit, history);
                    AggregatorChangeV1::Merge(delta_op)
                },
                AggregatorState::NegativeDelta => {
                    let history = history.unwrap();
                    let minus = SignedU128::Negative(value);
                    let delta_op = DeltaOp::new(minus, limit, history);
                    AggregatorChangeV1::Merge(delta_op)
                },
            };
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L367-398)
```rust
    pub fn try_materialize_aggregator_v1_delta_set(
        &mut self,
        resolver: &impl AggregatorV1Resolver,
    ) -> VMResult<()> {
        let into_write =
            |(state_key, delta): (StateKey, DeltaOp)| -> VMResult<(StateKey, WriteOp)> {
                // Materialization is needed when committing a transaction, so
                // we need precise mode to compute the true value of an
                // aggregator.
                let write = resolver
                    .try_convert_aggregator_v1_delta_into_write_op(&state_key, &delta)
                    .map_err(|e| {
                        // We need to set abort location for Aggregator V1 to ensure correct VMStatus can
                        // be constructed.
                        const AGGREGATOR_V1_ADDRESS: AccountAddress = CORE_CODE_ADDRESS;
                        const AGGREGATOR_V1_MODULE_NAME: &IdentStr = ident_str!("aggregator");
                        e.finish(Location::Module(ModuleId::new(
                            AGGREGATOR_V1_ADDRESS,
                            AGGREGATOR_V1_MODULE_NAME.into(),
                        )))
                    })?;
                Ok((state_key, write))
            };

        let aggregator_v1_delta_set = std::mem::take(&mut self.aggregator_v1_delta_set);
        let materialized_aggregator_delta_set = aggregator_v1_delta_set
            .into_iter()
            .map(into_write)
            .collect::<VMResult<BTreeMap<StateKey, WriteOp>>>()?;
        self.aggregator_v1_write_set
            .extend(materialized_aggregator_delta_set);
        Ok(())
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L873-903)
```rust
    fn write_op_info_iter_mut<'a>(
        &'a mut self,
        executor_view: &'a dyn ExecutorView,
        _module_storage: &'a impl AptosModuleStorage,
        fix_prev_materialized_size: bool,
    ) -> impl Iterator<Item = PartialVMResult<WriteOpInfo<'a>>> {
        let resources = self.resource_write_set.iter_mut().map(move |(key, op)| {
            Ok(WriteOpInfo {
                key,
                op_size: op.materialized_size(),
                prev_size: op.prev_materialized_size(
                    key,
                    executor_view,
                    fix_prev_materialized_size,
                )?,
                metadata_mut: op.metadata_mut(),
            })
        });
        let v1_aggregators = self.aggregator_v1_write_set.iter_mut().map(|(key, op)| {
            Ok(WriteOpInfo {
                key,
                op_size: op.write_op_size(),
                prev_size: executor_view
                    .get_aggregator_v1_state_value_size(key)?
                    .unwrap_or(0),
                metadata_mut: op.metadata_mut(),
            })
        });

        resources.chain(v1_aggregators)
    }
```

**File:** aptos-move/aptos-aggregator/src/resolver.rs (L80-106)
```rust
    fn try_convert_aggregator_v1_delta_into_write_op(
        &self,
        id: &Self::Identifier,
        delta_op: &DeltaOp,
    ) -> PartialVMResult<WriteOp> {
        let base = self.get_aggregator_v1_value(id)?.ok_or_else(|| {
            PartialVMError::new(StatusCode::SPECULATIVE_EXECUTION_ABORT_ERROR)
                .with_message("Cannot convert delta for deleted aggregator".to_string())
        })?;
        delta_op
            .apply_to(base)
            .map_err(|e| match &e {
                PanicOr::Or(DelayedFieldsSpeculativeError::DeltaApplication {
                    reason: DeltaApplicationFailureReason::Overflow,
                    ..
                }) => addition_v1_error(e),
                PanicOr::Or(DelayedFieldsSpeculativeError::DeltaApplication {
                    reason: DeltaApplicationFailureReason::Underflow,
                    ..
                }) => subtraction_v1_error(e),
                // Because aggregator V1 never underflows or overflows, all other
                // application errors are bugs.
                _ => code_invariant_error(format!("Unexpected delta application error: {:?}", e))
                    .into(),
            })
            .map(|result| WriteOp::legacy_modification(serialize(&result).into()))
    }
```

**File:** types/src/write_set.rs (L282-292)
```rust
    pub fn legacy_creation(data: Bytes) -> Self {
        Self(BaseStateOp::Creation(StateValue::new_legacy(data)))
    }

    pub fn legacy_modification(data: Bytes) -> Self {
        Self(BaseStateOp::Modification(StateValue::new_legacy(data)))
    }

    pub fn legacy_deletion() -> Self {
        Self(BaseStateOp::Deletion(StateValueMetadata::none()))
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1158-1158)
```rust
        // TODO[agg_v1](fix): Charge for aggregator writes
```
