# Audit Report

## Title
Unimplemented ObjectAddress Function in Access Control Causes Guaranteed Transaction Failure and DoS Vector

## Summary
The `AddressSpecifierFunction::ObjectAddress` variant used in Move access specifiers is unimplemented in the runtime evaluation logic, causing any transaction that calls a function with `object::owner()` in its access specifier to fail with `ACCESS_CONTROL_INVARIANT_VIOLATION`. This creates a DoS vector where attackers can deploy modules containing trap functions that always fail when invoked.

## Finding Description

The Move VM supports access control specifiers that allow functions to declare which resources they access. These specifiers can include address specifier functions like `object::owner()` to dynamically compute addresses. However, there is a critical implementation gap: [1](#0-0) 

The `ObjectAddress` variant is parsed and loaded successfully during module compilation and deployment: [2](#0-1) 

The bytecode verifier only checks if the `enable_resource_access_control` feature flag is enabled, but does NOT validate that all address specifier functions are implemented: [3](#0-2) 

The resource access control feature is enabled by default in production: [4](#0-3) [5](#0-4) 

When a function with such an access specifier is called, the interpreter invokes `enter_function()`: [6](#0-5) 

This calls `specialize()` on the access specifier: [7](#0-6) 

Which attempts to evaluate the `ObjectAddress` function and fails: [8](#0-7) 

**Attack Flow:**
1. Attacker compiles a Move module with a public function that uses `object::owner()` in an access specifier
2. Module passes all bytecode verification checks during deployment
3. Module is published to blockchain successfully
4. Any transaction calling this function will fail with `ACCESS_CONTROL_INVARIANT_VIOLATION`
5. Users waste gas, and dependent contracts are denied service

## Impact Explanation

This qualifies as **Medium Severity** per Aptos bug bounty criteria:
- **State inconsistencies requiring intervention**: Creates modules that pass verification but fail deterministically at runtime
- **Limited DoS**: Attackers can create trap functions that always fail, causing DoS for any code path that calls them
- **Wasted gas**: Users attempting to call these functions will pay gas but receive guaranteed failures
- **Breaking protocol invariant**: Violates the deterministic execution invariant - valid bytecode should either succeed or fail based on input state, not unconditionally fail due to implementation gaps

The impact does NOT reach High or Critical because:
- No funds are directly stolen or locked
- No consensus safety violations occur
- Individual transactions fail but network continues operating
- No validator nodes are compromised

## Likelihood Explanation

**Likelihood: Medium-High**

The attack is straightforward to execute:
- Module deployment is permissionless on Aptos
- The vulnerability exists in production code with the feature enabled by default
- No special privileges required
- Attack can be executed by any user who can compile and deploy Move modules

Factors affecting likelihood:
- Requires knowledge of Move access specifier syntax
- Attackers must deliberately use `object::owner()` in access specifiers
- The feature is relatively new and may have limited adoption
- Most developers would discover the issue during testing

However, the attack could be weaponized to:
- Create honeypot contracts that appear functional but fail when called
- DoS critical infrastructure if legitimate projects mistakenly use this pattern
- Exploit protocols that dynamically call external functions

## Recommendation

**Immediate Fix:** Add bytecode verification to reject modules using unsupported address specifier functions:

In `third_party/move/move-bytecode-verifier/src/features.rs`, add validation logic:

```rust
fn verify_access_specifiers(&self, module: &CompiledModule) -> PartialVMResult<()> {
    if self.config.enable_resource_access_control {
        for function_handle in module.function_handles() {
            if let Some(access_specs) = &function_handle.access_specifiers {
                for spec in access_specs {
                    if let AddressSpecifier::Parameter(_, Some(fun_inst_idx)) = &spec.address {
                        // Validate that the function is implemented
                        let fun_inst = &module.function_instantiations()[fun_inst_idx.0 as usize];
                        let fun_handle = &module.function_handles()[fun_inst.handle.0 as usize];
                        let mod_handle = &module.module_handles()[fun_handle.module.0 as usize];
                        let mod_name = module.module_id_for_handle(mod_handle);
                        let fun_name = &module.identifiers()[fun_handle.name.0 as usize];
                        
                        if mod_name.short_str_lossless() == "0x1::object" && fun_name.as_str() == "owner" {
                            return Err(PartialVMError::new(StatusCode::FEATURE_NOT_ENABLED)
                                .with_message("object::owner() in access specifiers is not yet implemented".to_string()));
                        }
                    }
                }
            }
        }
    }
    Ok(())
}
```

**Long-term Fix:** Implement the `ObjectAddress` evaluation logic in `runtime_access_specifier.rs`:

```rust
ObjectAddress => {
    // Implementation needed: call object::owner() native function
    // and return the owner address
    let object_ref = arg.value_as::<Reference>()?;
    // Call native object::owner implementation
    // Return owner address
}
```

**Alternative:** Document that `object::owner()` is unsupported and ensure compiler rejects it during compilation phase.

## Proof of Concept

```move
module attacker::dos_trap {
    use std::signer;
    use aptos_framework::object::{Self, Object};
    
    struct TestResource has key {
        value: u64
    }
    
    // This function uses object::owner() in access specifier
    // It will compile and deploy successfully but ALWAYS fail when called
    public entry fun trap_function<T: key>(
        caller: &signer, 
        obj: Object<T>
    ) reads TestResource(object::owner(obj)) {
        // Function body - will never be reached
        let addr = signer::address_of(caller);
        assert!(exists<TestResource>(addr), 1);
    }
}
```

**Exploitation Steps:**
1. Compile and deploy the above module to Aptos blockchain
2. Module passes all verification checks and deploys successfully
3. Any transaction calling `trap_function()` will fail with `ACCESS_CONTROL_INVARIANT_VIOLATION`
4. Attacker can create multiple such functions or integrate them into seemingly legitimate protocols
5. Users waste gas attempting to call these functions
6. Dependent contracts that call these functions experience DoS

**Expected Error:** `ACCESS_CONTROL_INVARIANT_VIOLATION` with message "unimplemented address specifier function `ObjectAddress`"

## Notes

This vulnerability represents a dangerous implementation gap where the Move language infrastructure (parser, compiler, loader) supports a feature that the runtime does not implement. The bytecode verifier fails to catch this discrepancy, allowing unexecutable code to be deployed on-chain. While the immediate impact is limited to transaction failures and wasted gas, it creates an exploitable DoS vector and violates the fundamental expectation that valid bytecode should execute deterministically.

### Citations

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_access_specifier.rs (L232-237)
```rust
    fn specialize(&mut self, env: &impl AccessSpecifierEnv) -> PartialVMResult<()> {
        if let AddressSpecifier::Eval(fun, arg) = self {
            *self = AddressSpecifier::Literal(env.eval_address_specifier_function(*fun, *arg)?)
        }
        Ok(())
    }
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_access_specifier.rs (L241-247)
```rust
    pub fn parse(module_str: &str, fun_str: &str) -> Option<AddressSpecifierFunction> {
        match (module_str, fun_str) {
            ("0x1::signer", "address_of") => Some(AddressSpecifierFunction::SignerAddress),
            ("0x1::object", "owner") => Some(AddressSpecifierFunction::ObjectAddress),
            _ => None,
        }
    }
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_access_specifier.rs (L262-268)
```rust
            ObjectAddress => Err(PartialVMError::new(
                StatusCode::ACCESS_CONTROL_INVARIANT_VIOLATION,
            )
            .with_message(format!(
                "unimplemented address specifier function `{:?}`",
                self
            ))),
```

**File:** third_party/move/move-bytecode-verifier/src/features.rs (L111-116)
```rust
                if !self.config.enable_resource_access_control
                    && function_handle.access_specifiers.is_some()
                {
                    return Err(PartialVMError::new(StatusCode::FEATURE_NOT_ENABLED)
                        .at_index(IndexKind::FunctionHandle, idx as u16)
                        .with_message("resource access control feature not enabled".to_string()));
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L150-151)
```rust
    let enable_resource_access_control =
        features.is_enabled(FeatureFlag::ENABLE_RESOURCE_ACCESS_CONTROL);
```

**File:** types/src/on_chain_config/aptos_features.rs (L245-245)
```rust
            FeatureFlag::ENABLE_RESOURCE_ACCESS_CONTROL,
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L382-384)
```rust
        self.access_control
            .enter_function(&current_frame, &current_frame.function)
            .map_err(|e| self.set_location(e))?;
```

**File:** third_party/move/move-vm/runtime/src/access_control.rs (L43-45)
```rust
            // Specialize the functions access specifier and push it on the stack.
            let mut fun_specifier = fun.access_specifier().clone();
            fun_specifier.specialize(env)?;
```
