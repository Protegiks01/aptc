# Audit Report

## Title
Private Keys Exposed Through Configuration Serialization and Logging

## Summary
The `ConfigKey<T>` struct wraps private keys and implements `Serialize`, allowing validator consensus keys and network identity keys to be serialized as plaintext hex strings in JSON/YAML formats. These private keys are automatically logged to INFO-level logs at node startup and can be written to configuration files, creating multiple exposure vectors for critical cryptographic material.

## Finding Description

The vulnerability exists in the configuration system's handling of private keys through the `ConfigKey<T>` wrapper: [1](#0-0) 

This struct implements both `Serialize` and `Deserialize`, wrapping private key types that implement `SerializeKey`. The underlying crypto types serialize to human-readable hex strings: [2](#0-1) [3](#0-2) [4](#0-3) 

Critical configuration structures embed these serializable private keys: [5](#0-4) [6](#0-5) 

**Exposure Vector 1: Automatic Logging at Node Startup**

The `NodeConfig.log_all_configs()` method serializes the entire configuration to JSON and logs each section to INFO-level logs: [7](#0-6) 

This function is called automatically during node initialization: [8](#0-7) 

**Exposure Vector 2: Configuration File Persistence**

The `PersistableConfig` trait allows `NodeConfig` to be serialized to YAML files on disk: [9](#0-8) [10](#0-9) 

When validators save configuration files for backup or debugging purposes, private keys are written as plaintext hex strings in YAML format.

**Attack Scenarios:**

1. **Log Aggregation Exposure**: Validator operators using centralized logging systems (Splunk, ELK, CloudWatch) inadvertently forward INFO logs containing hex-encoded private keys to third-party services or shared log repositories.

2. **Version Control Leakage**: Configuration files containing embedded test keys or accidentally saved production keys are committed to version control (Git), exposing keys in repository history even after deletion.

3. **Backup Compromise**: Configuration backups stored in cloud storage or shared network drives contain plaintext private keys accessible to unauthorized personnel.

4. **Log File Access**: Attackers gaining read access to validator node logs (through compromised monitoring tools, log rotation scripts, or filesystem access) can extract private keys.

## Impact Explanation

**HIGH Severity** per Aptos bug bounty criteria - "Significant protocol violations" and "Validator node slowdowns."

This vulnerability enables:

1. **Validator Impersonation**: Compromised consensus keys (BLS12-381 private keys) allow attackers to sign consensus messages, participate in AptosBFT consensus as the victim validator, and potentially cause safety violations by signing conflicting blocks.

2. **Network-Level Attacks**: Compromised network identity keys (x25519 private keys) enable man-in-the-middle attacks against validator P2P communications, allowing message interception, modification, or replay attacks.

3. **Long-Term Persistence**: Once keys are logged or saved to files, they may persist in:
   - Log archives for compliance retention (often years)
   - Backup systems with different access controls
   - Version control history (git reflog, remote repositories)
   - Third-party monitoring/logging SaaS platforms

4. **Consensus Safety Risk**: While this requires < 1/3 Byzantine validators, each compromised validator increases the attack surface toward consensus safety violations.

The vulnerability affects any validator or node operator using embedded keys in configuration (common in test environments and initial deployment), though the comment acknowledges this is "for testing or for low security requirements." [11](#0-10) 

However, the code provides no technical safeguards to prevent production usage or accidental exposure.

## Likelihood Explanation

**HIGH Likelihood** - The vulnerability triggers automatically without operator error:

1. **Automatic Execution**: `log_all_configs()` is called unconditionally at node startup, requiring no misconfiguration or operator mistake.

2. **Default Behavior**: INFO-level logging is standard, and the serialization happens transparently through serde's derive macros.

3. **Common Deployment Patterns**: 
   - Test environments frequently use embedded keys
   - Initial validator setup may temporarily use config-embedded keys
   - Debugging scenarios often involve saving full configuration snapshots

4. **Insufficient Protection**: While `SilentDebug` protects against `{:?}` debug formatting, it does NOT protect against serde serialization via `Serialize` trait, creating a false sense of security.

5. **Multiple Exposure Paths**: The vulnerability exists in both logging (automatic) and file persistence (developer-triggered), increasing likelihood of exploitation.

## Recommendation

**Immediate Mitigations:**

1. **Remove Automatic Config Logging**: Remove or disable `log_all_configs()` call, or implement selective redaction:

```rust
pub fn log_all_configs(&self) {
    let mut config_value = serde_json::to_value(self)
        .expect("Failed to serialize the node config!");
    
    // Redact sensitive fields
    if let Some(obj) = config_value.as_object_mut() {
        // Redact validator network identity
        if let Some(validator_net) = obj.get_mut("validator_network") {
            redact_identity_keys(validator_net);
        }
        // Redact full node network identities
        if let Some(full_nets) = obj.get_mut("full_node_networks") {
            if let Some(arr) = full_nets.as_array_mut() {
                for net in arr {
                    redact_identity_keys(net);
                }
            }
        }
        // Redact consensus test keys
        if let Some(consensus) = obj.get_mut("consensus") {
            redact_consensus_keys(consensus);
        }
    }
    
    // Log redacted config
    for (config_name, config_value) in config_value.as_object().unwrap() {
        let config_string = serde_json::to_string(config_value)
            .expect("Failed to parse the config value!");
        info!("Using {} config: {}", config_name, config_string);
    }
}

fn redact_identity_keys(net_config: &mut serde_json::Value) {
    if let Some(identity) = net_config.get_mut("identity") {
        if let Some(obj) = identity.as_object_mut() {
            if obj.contains_key("key") {
                obj.insert("key".to_string(), 
                    serde_json::Value::String("<REDACTED>".to_string()));
            }
        }
    }
}

fn redact_consensus_keys(consensus: &mut serde_json::Value) {
    if let Some(safety_rules) = consensus.get_mut("safety_rules") {
        if let Some(test_config) = safety_rules.get_mut("test") {
            if let Some(obj) = test_config.as_object_mut() {
                if obj.contains_key("consensus_key") {
                    obj.insert("consensus_key".to_string(),
                        serde_json::Value::String("<REDACTED>".to_string()));
                }
            }
        }
    }
}
```

2. **Prevent Serialization of ConfigKey**: Implement custom `Serialize` for `ConfigKey` that always redacts:

```rust
impl<T: PrivateKey + Serialize> Serialize for ConfigKey<T> {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        serializer.serialize_str("<REDACTED_PRIVATE_KEY>")
    }
}
```

3. **Runtime Enforcement**: Add validation in `SafetyRulesConfig::sanitize()` to prevent embedded keys in production: [12](#0-11) 

Add check for embedded consensus keys in test config.

**Long-Term Solutions:**

1. **Mandatory Key Managers**: Enforce secure backend storage (Vault, KMS) for all production deployments
2. **Config Sanitization**: Implement pre-save hooks that strip private keys before persisting configs
3. **Security Audit Trail**: Log when configs containing keys are accessed or serialized
4. **Deprecate ConfigKey**: Move toward architecture where private keys are never in serializable config structures

## Proof of Concept

```rust
// File: config/src/config/test_key_exposure.rs
#[cfg(test)]
mod key_exposure_test {
    use crate::{
        config::{NodeConfig, SafetyRulesConfig, SafetyRulesTestConfig},
        keys::ConfigKey,
    };
    use aptos_crypto::{bls12381, Uniform};
    use aptos_types::PeerId;
    use rand::{rngs::StdRng, SeedableRng};

    #[test]
    fn test_private_key_exposed_in_json_serialization() {
        // Create a validator config with embedded consensus key
        let mut rng = StdRng::from_seed([0u8; 32]);
        let consensus_privkey = bls12381::PrivateKey::generate(&mut rng);
        let consensus_pubkey = consensus_privkey.public_key();
        
        // Create test config with embedded key
        let mut test_config = SafetyRulesTestConfig::new(PeerId::random());
        test_config.consensus_key = Some(ConfigKey::new(consensus_privkey));
        
        // Serialize to JSON (simulating log_all_configs behavior)
        let json_value = serde_json::to_value(&test_config)
            .expect("Failed to serialize");
        let json_string = serde_json::to_string_pretty(&json_value)
            .expect("Failed to convert to string");
        
        println!("Serialized config:\n{}", json_string);
        
        // VULNERABILITY: Private key is exposed as hex string in JSON
        assert!(json_string.contains("consensus_key"));
        assert!(json_string.len() > 100); // Hex key is present, not redacted
        
        // Demonstrate key recovery from JSON
        let recovered: SafetyRulesTestConfig = serde_json::from_str(&json_string)
            .expect("Failed to deserialize");
        let recovered_key = recovered.consensus_key.unwrap().private_key();
        let recovered_pubkey = recovered_key.public_key();
        
        // Attacker can recover the exact same key from logs
        assert_eq!(consensus_pubkey, recovered_pubkey);
        println!("\n[!] VULNERABILITY CONFIRMED: Private key successfully extracted from JSON serialization");
    }

    #[test]
    fn test_private_key_exposed_in_yaml_file() {
        use std::fs::File;
        use std::io::Write;
        use tempfile::TempDir;
        
        let mut rng = StdRng::from_seed([1u8; 32]);
        let consensus_privkey = bls12381::PrivateKey::generate(&mut rng);
        
        let mut test_config = SafetyRulesTestConfig::new(PeerId::random());
        test_config.consensus_key = Some(ConfigKey::new(consensus_privkey));
        
        // Serialize to YAML (simulating save_config behavior)
        let yaml_string = serde_yaml::to_string(&test_config)
            .expect("Failed to serialize to YAML");
        
        println!("YAML config:\n{}", yaml_string);
        
        // Write to file (simulating config persistence)
        let temp_dir = TempDir::new().unwrap();
        let config_path = temp_dir.path().join("validator_config.yaml");
        let mut file = File::create(&config_path).unwrap();
        file.write_all(yaml_string.as_bytes()).unwrap();
        
        // VULNERABILITY: Private key persisted to disk in plaintext
        let file_contents = std::fs::read_to_string(&config_path).unwrap();
        assert!(file_contents.contains("consensus_key"));
        
        println!("\n[!] VULNERABILITY CONFIRMED: Private key written to YAML file at {:?}", config_path);
    }
}
```

Run with: `cargo test -p aptos-config test_private_key_exposed_in_json_serialization -- --nocapture`

**Notes**

While the code comment acknowledges that `ConfigKey` is "for testing or for low security requirements," the implementation provides no technical enforcement of this guideline. The vulnerability is exacerbated by:

1. The `/configuration` inspection endpoint is actually PROTECTED because it uses debug formatting (`{:?}`) which respects `SilentDebug`, as noted in comments: [13](#0-12) 

2. However, this protection creates a **false sense of security** because developers may assume all config exposure paths are protected, when in fact the `Serialize` trait (used by `log_all_configs()` and `save_config()`) completely bypasses `SilentDebug`.

3. The asymmetry between debug formatting (protected) and serialization (unprotected) is a subtle but critical security gap that violates the principle of defense in depth.

This vulnerability requires immediate remediation for any production deployment using embedded configuration keys, even though the design intent was test-only usage.

### Citations

**File:** config/src/keys.rs (L20-24)
```rust
/// ConfigKey places a clonable wrapper around PrivateKeys for config purposes only. The only time
/// configs have keys is either for testing or for low security requirements. We recommend that
/// keys be stored in key managers. If we make keys unclonable, then the configs must be mutable
/// and that becomes a requirement strictly as a result of supporting test environments, which is
/// undesirable. Hence this internal wrapper allows for keys to be clonable but only from configs.
```

**File:** config/src/keys.rs (L25-29)
```rust
#[derive(Debug, Deserialize, Serialize)]
pub struct ConfigKey<T: PrivateKey + Serialize> {
    #[serde(bound(deserialize = "T: Deserialize<'de>"))]
    key: T,
}
```

**File:** crates/aptos-crypto-derive/src/lib.rs (L186-210)
```rust
pub fn serialize_key(source: TokenStream) -> TokenStream {
    let ast: DeriveInput = syn::parse(source).expect("Incorrect macro input");
    let name = &ast.ident;
    let name_string = find_key_name(&ast, name.to_string());
    quote! {
        impl ::serde::Serialize for #name {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: ::serde::Serializer,
            {
                if serializer.is_human_readable() {
                    self.to_encoded_string()
                        .map_err(<S::Error as ::serde::ser::Error>::custom)
                        .and_then(|str| serializer.serialize_str(&str[..]))
                } else {
                    // See comment in deserialize_key.
                    serializer.serialize_newtype_struct(
                        #name_string,
                        serde_bytes::Bytes::new(&ValidCryptoMaterial::to_bytes(self).as_slice()),
                    )
                }
            }
        }
    }
    .into()
```

**File:** crates/aptos-crypto/src/x25519.rs (L66-68)
```rust
#[derive(DeserializeKey, SilentDisplay, SilentDebug, SerializeKey)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Clone))]
pub struct PrivateKey(x25519_dalek::StaticSecret);
```

**File:** crates/aptos-crypto/src/bls12381/bls12381_keys.rs (L41-45)
```rust
#[derive(SerializeKey, DeserializeKey, SilentDebug, SilentDisplay)]
/// A BLS12381 private key
pub struct PrivateKey {
    pub(crate) privkey: blst::min_pk::SecretKey,
}
```

**File:** config/src/config/identity_config.rs (L130-139)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IdentityFromConfig {
    #[serde(flatten)]
    pub key: ConfigKey<x25519::PrivateKey>,
    pub peer_id: PeerId,

    #[serde(skip)]
    pub source: IdentitySource,
}
```

**File:** config/src/config/safety_rules_config.rs (L71-117)
```rust
impl ConfigSanitizer for SafetyRulesConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let safety_rules_config = &node_config.consensus.safety_rules;

        // If the node is not a validator, there's nothing to be done
        if !node_type.is_validator() {
            return Ok(());
        }

        if let Some(chain_id) = chain_id {
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }

            // Verify that the safety rules service is set to local for optimal performance
            if chain_id.is_mainnet() && !safety_rules_config.service.is_local() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("The safety rules service should be set to local in mainnet for optimal performance! Given config: {:?}", &safety_rules_config.service)
                ));
            }

            // Verify that the safety rules test config is not enabled in mainnet
            if chain_id.is_mainnet() && safety_rules_config.test.is_some() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The safety rules test config should not be used in mainnet!".to_string(),
                ));
            }
        }

        Ok(())
    }
}
```

**File:** config/src/config/safety_rules_config.rs (L241-245)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
pub struct SafetyRulesTestConfig {
    pub author: PeerId,
    pub consensus_key: Option<ConfigKey<bls12381::PrivateKey>>,
    pub waypoint: Option<Waypoint>,
```

**File:** config/src/config/node_config.rs (L97-111)
```rust
    pub fn log_all_configs(&self) {
        // Parse the node config as serde JSON
        let config_value =
            serde_json::to_value(self).expect("Failed to serialize the node config!");
        let config_map = config_value
            .as_object()
            .expect("Failed to get the config map!");

        // Log each config entry
        for (config_name, config_value) in config_map {
            let config_string =
                serde_json::to_string(config_value).expect("Failed to parse the config value!");
            info!("Using {} config: {}", config_name, config_string);
        }
    }
```

**File:** aptos-node/src/lib.rs (L690-698)
```rust
pub fn setup_environment_and_start_node(
    mut node_config: NodeConfig,
    remote_log_rx: Option<mpsc::Receiver<TelemetryLog>>,
    logger_filter_update_job: Option<LoggerFilterUpdater>,
    api_port_tx: Option<oneshot::Sender<u16>>,
    indexer_grpc_port_tx: Option<oneshot::Sender<u16>>,
) -> anyhow::Result<AptosHandle> {
    // Log the node config at node startup
    node_config.log_all_configs();
```

**File:** config/src/config/persistable_config.rs (L22-29)
```rust
    /// Save the config to disk at the given output path
    fn save_config<P: AsRef<Path>>(&self, output_file: P) -> Result<(), Error> {
        // Serialize the config to a string
        let serialized_config = serde_yaml::to_vec(&self)
            .map_err(|e| Error::Yaml(output_file.as_ref().to_str().unwrap().to_string(), e))?;

        Self::write_file(serialized_config, output_file)
    }
```

**File:** config/src/config/persistable_config.rs (L59-60)
```rust
impl PersistableConfig for NodeConfig {}
impl PersistableConfig for SafetyRulesConfig {}
```

**File:** crates/aptos-inspection-service/src/server/configuration.rs (L16-19)
```rust
        // We format the configuration using debug formatting. This is important to
        // prevent secret/private keys from being serialized and leaked (i.e.,
        // all secret keys are marked with SilentDisplay and SilentDebug).
        let encoded_configuration = format!("{:?}", node_config);
```
