# Audit Report

## Title
Subscription Stream Index Validation Gap Enables Resource Exhaustion and State Sync Denial of Service

## Summary
The storage service's subscription request handler accepts non-sequential `subscription_stream_index` values without validating index gaps, allowing attackers to create permanently blocked subscription streams that consume server resources and prevent data synchronization until timeout expires.

## Finding Description

The `SubscribeTransactionOutputsWithProofRequest` and related subscription requests use a `subscription_stream_index` field to maintain ordered delivery of blockchain data. The server validates incoming subscription requests in the `add_subscription_request` function but only enforces a lower bound check without validating index sequentiality or gap size. [1](#0-0) 

This validation only rejects indices below `next_index_to_serve`, but accepts any index value above it, regardless of the gap size. An attacker can exploit this by sending:
1. Request with index 0 (accepted and served immediately)
2. Request with index 1,000,000 (accepted because 1,000,000 >= 1)
3. Additional requests with indices 2,000,000, 3,000,000, etc., up to the maximum of 30 pending requests

The subscription stream uses a `BTreeMap` to store pending requests ordered by index and only serves requests when the first pending index matches `next_index_to_serve`: [2](#0-1) 

With gap indices, the stream permanently blocks waiting for missing indices (1-999,999) that never arrive. The stream only expires after the configured timeout: [3](#0-2) 

During this 30-second period:
- All 30 subscription request slots are occupied with unservable requests
- The server holds `ResponseSender` channels for each pending request
- The peer's `highest_known_version` and `highest_known_epoch` cannot advance
- Legitimate sequential requests from the same peer are rejected due to slot exhaustion [4](#0-3) 

## Impact Explanation

**Severity: High** - This vulnerability enables resource exhaustion and state synchronization denial of service:

1. **Validator/Fullnode Slowdowns**: Nodes using subscriptions for state sync experience 30-second delays repeatedly if targeted by malicious peers, meeting the "Validator node slowdowns" criterion from the Aptos bug bounty program.

2. **Resource Exhaustion**: Each blocked subscription consumes server memory (30 pending requests × response channels × peer connections), potentially affecting the server's ability to handle other requests.

3. **State Sync Disruption**: Nodes relying on subscriptions cannot advance their blockchain state during the blocking period, requiring fallback to slower synchronization methods.

4. **Amplification**: An attacker controlling multiple peer identities can create multiple blocked subscription streams simultaneously, multiplying the resource consumption impact.

## Likelihood Explanation

**Likelihood: High** - This vulnerability is easily exploitable:

- **No Authentication Required**: Any network peer can send subscription requests without special privileges
- **Simple Exploitation**: Requires only sending two subscription requests with non-sequential indices
- **Repeatable**: After the 30-second timeout, the attacker can immediately restart the attack with a new stream
- **Unintentional Trigger**: Buggy clients or network issues causing packet loss could accidentally trigger this, affecting legitimate users

## Recommendation

Add validation to reject subscription indices that create excessive gaps from `next_index_to_serve`. Implement a maximum acceptable gap threshold:

```rust
pub fn add_subscription_request(
    &mut self,
    storage_service_config: StorageServiceConfig,
    subscription_request: SubscriptionRequest,
) -> Result<(), (Error, SubscriptionRequest)> {
    // ... existing metadata validation ...

    // Verify that the subscription request index is valid
    let subscription_request_index = subscription_request.subscription_stream_index();
    if subscription_request_index < self.next_index_to_serve {
        return Err((
            Error::InvalidRequest(format!(
                "The subscription request index is too low! Next index to serve: {:?}, found: {:?}",
                self.next_index_to_serve, subscription_request_index
            )),
            subscription_request,
        ));
    }

    // NEW: Reject indices with excessive gaps
    let max_index_gap = storage_service_config.max_num_active_subscriptions;
    let index_gap = subscription_request_index.saturating_sub(self.next_index_to_serve);
    if index_gap >= max_index_gap {
        return Err((
            Error::InvalidRequest(format!(
                "The subscription request index gap is too large! Next index to serve: {:?}, found: {:?}, max gap: {:?}",
                self.next_index_to_serve, subscription_request_index, max_index_gap
            )),
            subscription_request,
        ));
    }

    // ... rest of existing validation ...
}
```

This ensures indices can arrive out-of-order for network resilience, but prevents exploitation via arbitrarily large gaps.

## Proof of Concept

```rust
#[tokio::test]
async fn test_subscription_index_gap_exploitation() {
    use crate::subscription::{SubscriptionRequest, SubscriptionStreamRequests};
    use aptos_config::config::StorageServiceConfig;
    use aptos_storage_service_types::requests::{
        DataRequest, StorageServiceRequest, 
        SubscribeTransactionOutputsWithProofRequest,
        SubscriptionStreamMetadata,
    };
    use aptos_time_service::TimeService;
    
    let time_service = TimeService::mock();
    let storage_config = StorageServiceConfig::default();
    
    // Create subscription metadata
    let metadata = SubscriptionStreamMetadata {
        known_version_at_stream_start: 100,
        known_epoch_at_stream_start: 1,
        subscription_stream_id: 12345,
    };
    
    // Create first request with index 0
    let request_0 = StorageServiceRequest::new(
        DataRequest::SubscribeTransactionOutputsWithProof(
            SubscribeTransactionOutputsWithProofRequest {
                subscription_stream_metadata: metadata,
                subscription_stream_index: 0,
            }
        ),
        false,
    );
    
    let (sender_0, _receiver_0) = oneshot::channel();
    let sub_request_0 = SubscriptionRequest::new(
        request_0,
        ResponseSender::new(sender_0),
        time_service.clone(),
    );
    
    // Create subscription stream with first request
    let mut stream = SubscriptionStreamRequests::new(sub_request_0, time_service.clone());
    
    // Simulate serving index 0 (next_index_to_serve becomes 1)
    stream.set_next_index_to_serve(1);
    
    // EXPLOIT: Send request with index 1,000,000 (huge gap)
    let request_exploit = StorageServiceRequest::new(
        DataRequest::SubscribeTransactionOutputsWithProof(
            SubscribeTransactionOutputsWithProofRequest {
                subscription_stream_metadata: metadata,
                subscription_stream_index: 1_000_000,
            }
        ),
        false,
    );
    
    let (sender_exploit, _receiver_exploit) = oneshot::channel();
    let sub_request_exploit = SubscriptionRequest::new(
        request_exploit,
        ResponseSender::new(sender_exploit),
        time_service.clone(),
    );
    
    // This should fail but currently succeeds
    let result = stream.add_subscription_request(storage_config, sub_request_exploit);
    assert!(result.is_ok(), "Gap index was accepted - vulnerability confirmed!");
    
    // Verify stream is blocked - index 1 is needed but we have 1,000,000
    assert_eq!(stream.get_next_index_to_serve(), 1);
    assert!(!stream.first_request_ready_to_be_served(), 
            "Stream is permanently blocked waiting for index 1");
}
```

## Notes

The vulnerability exists because the system was designed to handle legitimate out-of-order delivery (e.g., indices 0, 2, 1 due to network reordering) but lacks protection against malicious gap creation. The `BTreeMap` correctly maintains ordering, but the validation logic assumes peers will eventually fill gaps. This assumption breaks under adversarial conditions, enabling the resource exhaustion attack.

### Citations

**File:** state-sync/storage-service/server/src/subscription.rs (L358-368)
```rust
        // Verify that the subscription request index is valid
        let subscription_request_index = subscription_request.subscription_stream_index();
        if subscription_request_index < self.next_index_to_serve {
            return Err((
                Error::InvalidRequest(format!(
                    "The subscription request index is too low! Next index to serve: {:?}, found: {:?}",
                    self.next_index_to_serve, subscription_request_index
                )),
                subscription_request,
            ));
        }
```

**File:** state-sync/storage-service/server/src/subscription.rs (L370-381)
```rust
        // Verify that the number of active subscriptions respects the maximum
        let max_num_active_subscriptions =
            storage_service_config.max_num_active_subscriptions as usize;
        if self.pending_subscription_requests.len() >= max_num_active_subscriptions {
            return Err((
                Error::InvalidRequest(format!(
                    "The maximum number of active subscriptions has been reached! Max: {:?}, found: {:?}",
                    max_num_active_subscriptions, self.pending_subscription_requests.len()
                )),
                subscription_request,
            ));
        }
```

**File:** state-sync/storage-service/server/src/subscription.rs (L438-444)
```rust
    fn first_request_ready_to_be_served(&self) -> bool {
        if let Some(subscription_request) = self.first_pending_request() {
            subscription_request.subscription_stream_index() == self.next_index_to_serve
        } else {
            false
        }
    }
```

**File:** config/src/config/state_sync_config.rs (L206-210)
```rust
            max_num_active_subscriptions: 30,
            max_optimistic_fetch_period_ms: 5000, // 5 seconds
            max_state_chunk_size: MAX_STATE_CHUNK_SIZE,
            max_storage_read_wait_time_ms: 10_000, // 10 seconds
            max_subscription_period_ms: 30_000,    // 30 seconds
```
