# Audit Report

## Title
Lack of ECDSA Nonce Reuse Detection in Keyless Ephemeral Signature Validation

## Summary
The keyless validation system does not implement any runtime detection or protection mechanism against ECDSA nonce reuse attacks in ephemeral signatures. While the underlying p256 library uses RFC 6979 deterministic nonce generation, there is no defense-in-depth validation to detect if nonce reuse occurs due to implementation bugs, faulty hardware WebAuthn authenticators, or other edge cases.

## Finding Description
In ECDSA signature schemes, reusing the same nonce `k` for two different messages allows an attacker to recover the private key. The vulnerability exists in two signature paths:

1. **Software ECDSA path**: Uses the p256 library which implements RFC 6979 deterministic nonce generation
2. **WebAuthn hardware authenticator path**: Relies on external hardware devices for signature generation

The ephemeral signature verification flow occurs in: [1](#0-0) 

For WebAuthn signatures specifically: [2](#0-1) 

The underlying secp256r1 ECDSA signature verification: [3](#0-2) 

**The Critical Gap**: The validation code checks for signature malleability (S < n/2) but does NOT:
- Track previously seen r values across transactions
- Detect duplicate r values indicating nonce reuse  
- Validate that WebAuthn hardware authenticators generate proper nonces
- Provide any runtime monitoring or alerting for nonce reuse

**Attack Scenario**:
1. User employs a WebAuthn hardware authenticator with faulty ECDSA nonce generation
2. User signs two transactions (T1, T2) with the same ephemeral keypair, producing signatures (r, s1) and (r, s2) with identical r values
3. Attacker observes both signatures and messages
4. Attacker computes: `k = (H(T1) - H(T2)) / (s1 - s2) mod n`
5. Attacker recovers ephemeral private key: `d = (s1 * k - H(T1)) / r mod n`
6. Attacker signs fraudulent transactions until ephemeral key expires

## Impact Explanation
**Severity: High (defense-in-depth failure with conditional exploitability)**

While this doesn't meet the "Critical" threshold due to requiring specific preconditions, it represents a significant security gap:

- **If exploited**: Complete ephemeral private key compromise, enabling unauthorized transaction signing and potential fund theft
- **Affected scope**: Users with buggy hardware authenticators
- **Duration**: Until ephemeral key expiry (typically minutes to hours)
- **Detection**: No monitoring exists to detect this attack in progress

This does not reach Critical severity because:
- Requires buggy hardware (not proven to exist in current FIDO2 ecosystem)
- Limited to ephemeral key lifetime
- User's primary identity (OIDC-based) remains secure

## Likelihood Explanation
**Likelihood: Low to Medium**

**Factors increasing likelihood:**
- Historical precedent: Some hardware security tokens have had ECDSA nonce generation vulnerabilities
- WebAuthn authenticators are outside Aptos' control
- No defense-in-depth protection exists
- Attack is passive (observation only)

**Factors decreasing likelihood:**
- Modern FIDO2 authenticators are generally well-tested
- p256 library correctly implements RFC 6979 for software signatures
- Ephemeral keys have short lifetimes
- Attacker must observe multiple transactions from same ephemeral key

However, the complete absence of detection mechanisms means that IF such a vulnerability exists in any hardware authenticator, it would go completely unnoticed.

## Recommendation
Implement defense-in-depth nonce reuse detection:

**1. Add r-value tracking at transaction validation**:
```rust
// In keyless_validation.rs
fn validate_authenticators(...) -> Result<(), VMStatus> {
    let mut seen_r_values = HashSet::new();
    
    for (pk, sig) in authenticators {
        // Extract r value from signature
        let r_value = extract_r_value(&sig.ephemeral_signature)?;
        
        // Check for duplicate r value (nonce reuse)
        if !seen_r_values.insert(r_value) {
            return Err(invalid_signature!("ECDSA nonce reuse detected"));
        }
        
        // Continue with existing validation...
    }
}
```

**2. Add on-chain r-value tracking per ephemeral key** (more comprehensive):
- Store recent r values in Move resource indexed by ephemeral public key
- Reject transactions with duplicate r values
- Implement time-based cleanup for expired ephemeral keys

**3. Add monitoring and alerting**:
- Log when duplicate r values are detected
- Alert on patterns suggesting systematic nonce reuse

## Proof of Concept
Due to the requirement for a buggy hardware authenticator, a complete PoC cannot be demonstrated without such hardware. However, the vulnerability can be validated through:

**Conceptual PoC** (requires buggy hardware or mock):
```rust
#[test]
fn test_nonce_reuse_detection() {
    // This would require mocking a buggy WebAuthn authenticator
    // that produces signatures with the same r value
    
    let ephemeral_keypair = /* compromised by attacker */;
    let msg1 = Transaction::new(/* txn 1 */);
    let msg2 = Transaction::new(/* txn 2 */);
    
    // Simulate two signatures with same nonce k (same r value)
    let sig1 = buggy_sign(&msg1, &ephemeral_keypair); // (r, s1)
    let sig2 = buggy_sign(&msg2, &ephemeral_keypair); // (r, s2) - same r!
    
    // Attacker recovers key
    let recovered_key = recover_key_from_nonce_reuse(
        &sig1, &sig2, &msg1, &msg2
    );
    
    // Verify key recovery successful
    assert_eq!(recovered_key, ephemeral_keypair.private_key());
}
```

**Current system behavior**: The system would accept both transactions without detecting the nonce reuse, leaving the ephemeral key compromised.

---

**Notes**:
- The p256 library (v0.13.2) DOES implement RFC 6979 deterministic nonce generation for software-generated signatures: [4](#0-3) 
- WebAuthn hardware authenticators are external devices whose ECDSA implementations vary by manufacturer
- This vulnerability represents a **defense-in-depth gap** rather than a directly exploitable bug, as it requires external preconditions (buggy hardware) that are not proven to exist in current FIDO2 devices
- The validation code performs malleability checks but no nonce uniqueness validation: [5](#0-4)

### Citations

**File:** types/src/transaction/authenticator.rs (L1319-1347)
```rust
    fn verify_keyless_ephemeral_signature<T: Serialize + CryptoHash>(
        message: &T,
        signature: &KeylessSignature,
    ) -> Result<()> {
        // Verifies the ephemeral signature on (TXN [+ ZKP]). The rest of the verification,
        // i.e., [ZKPoK of] OpenID signature verification is done in
        // `AptosVM::run_prologue`.
        //
        // This is because the JWK, under which the [ZKPoK of an] OpenID signature verifies,
        // can only be fetched from on chain inside the `AptosVM`.
        //
        // This deferred verification is what actually ensures the `signature.ephemeral_pubkey`
        // used below is the right pubkey signed by the OIDC provider.

        let mut txn_and_zkp = TransactionAndProof {
            message,
            proof: None,
        };

        // Add the ZK proof into the `txn_and_zkp` struct, if we are in the ZK path
        match &signature.cert {
            EphemeralCertificate::ZeroKnowledgeSig(proof) => txn_and_zkp.proof = Some(proof.proof),
            EphemeralCertificate::OpenIdSig(_) => {},
        }

        signature
            .ephemeral_signature
            .verify(&txn_and_zkp, &signature.ephemeral_pubkey)
    }
```

**File:** types/src/transaction/webauthn.rs (L134-165)
```rust
    pub fn verify<T: Serialize + CryptoHash>(
        &self,
        message: &T,
        public_key: &AnyPublicKey,
    ) -> Result<()> {
        let collected_client_data: CollectedClientData =
            serde_json::from_slice(self.client_data_json.as_slice())?;
        let challenge_bytes = Bytes::try_from(collected_client_data.challenge.as_str())
            .map_err(|e| anyhow!("Failed to decode challenge bytes {:?}", e))?;

        // Check if expected challenge and actual challenge match. If there's no match, throw error
        verify_expected_challenge_from_message_matches_actual(message, challenge_bytes.as_slice())?;

        // Generates binary concatenation of authenticator_data and hash(client_data_json)
        let verification_data = generate_verification_data(
            self.authenticator_data.as_slice(),
            self.client_data_json.as_slice(),
        );

        // Note: We must call verify_arbitrary_msg instead of verify here. We do NOT want to
        // use verify because it BCS serializes and prefixes the message with a hash
        // via the signing_message function invocation
        match (&public_key, &self.signature) {
            (
                AnyPublicKey::Secp256r1Ecdsa { public_key },
                AssertionSignature::Secp256r1Ecdsa { signature },
            ) => signature.verify_arbitrary_msg(&verification_data, public_key),
            _ => Err(anyhow!(
                "WebAuthn verification failure, invalid key, signature pairing"
            )),
        }
    }
```

**File:** crates/aptos-crypto/src/secp256r1_ecdsa/secp256r1_ecdsa_sigs.rs (L64-72)
```rust
    pub fn check_s_malleability(bytes: &[u8]) -> std::result::Result<(), CryptoMaterialError> {
        if bytes.len() != SIGNATURE_LENGTH {
            return Err(CryptoMaterialError::WrongLengthError);
        }
        if !Signature::check_s_lt_order_half(&bytes[32..]) {
            return Err(CryptoMaterialError::CanonicalRepresentationError);
        }
        Ok(())
    }
```

**File:** crates/aptos-crypto/src/secp256r1_ecdsa/secp256r1_ecdsa_sigs.rs (L133-141)
```rust
    fn verify_arbitrary_msg(&self, message: &[u8], public_key: &PublicKey) -> Result<()> {
        Signature::check_s_malleability(&self.to_bytes())?;

        public_key
            .0
            .verify(message, &self.0)
            .map_err(|e| anyhow!("{}", e))
            .and(Ok(()))
    }
```

**File:** crates/aptos-crypto/src/secp256r1_ecdsa/secp256r1_ecdsa_keys.rs (L74-80)
```rust
    /// This function uses the `RustCrypto` secp256r1_ecdsa signing library, which uses,
    /// as of version 0.13.2, SHA2-256 as its hashing algorithm
    fn sign_arbitrary_message(&self, message: &[u8]) -> Signature {
        let secret_key = &self.0;
        let sig = Signature(secret_key.sign(message.as_ref()));
        Signature::make_canonical(&sig)
    }
```
