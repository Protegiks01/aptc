# Audit Report

## Title
Panic in TransactionRootFilter.matches() Causes Indexer gRPC Service Crash on Invalid Transaction Types

## Summary
The `TransactionRootFilter.matches()` method contains an `expect()` call on `TransactionType::try_from()` conversion that will panic when encountering invalid transaction type values. Since protobuf deserialization accepts any i32 value for enum fields without validation, transactions with invalid type values (e.g., 5-19 or values outside the valid range) can be deserialized from cache or file storage and cause the indexer service to crash when filter matching is applied.

## Finding Description
The vulnerability exists in the transaction filtering logic used by the indexer gRPC service: [1](#0-0) 

The `matches()` method calls `TransactionType::try_from(item.r#type).expect("Invalid transaction type")`, which will panic if the i32 value cannot be converted to a valid `TransactionType` enum variant. Valid values are: 0 (Unspecified), 1 (Genesis), 2 (BlockMetadata), 3 (StateCheckpoint), 4 (User), 20 (Validator), and 21 (BlockEpilogue). Values 5-19 and any other i32 value will cause the conversion to fail. [2](#0-1) 

The critical issue is that the `Transaction` protobuf message stores the type as an i32 field: [3](#0-2) 

When transactions are deserialized from cache or file storage, protobuf deserialization does not validate enum values: [4](#0-3) 

The deserialization will succeed even with invalid transaction type values. These transactions then flow through the filter matching code in the data service: [5](#0-4) 

And in the stream coordinator: [6](#0-5) 

When a transaction with an invalid type value reaches `filter.matches(txn)`, the panic occurs and crashes the service thread/task.

## Impact Explanation
This vulnerability causes **API crashes**, which is classified as **High Severity** in the Aptos bug bounty program. The indexer gRPC service is critical infrastructure that provides transaction and blockchain data to downstream applications, wallets, and services. A crash in this service results in:

1. **Service unavailability**: The crashed task/thread stops processing, potentially blocking the entire stream
2. **Downstream failures**: All clients and services depending on the indexer cannot function
3. **Data pipeline disruption**: The indexer cannot process and serve blockchain data

While the panic is contained to the specific task handling the request, it still represents a service degradation that affects availability.

## Likelihood Explanation
The likelihood is **MEDIUM to LOW** for malicious exploitation, but **MEDIUM to HIGH** for accidental occurrence:

**Accidental scenarios:**
- Data corruption in Redis cache or file storage (disk errors, memory corruption)
- Bugs in serialization/deserialization code paths
- Future protocol changes introducing new transaction types without updating filter code
- Race conditions during cache/storage updates

**Malicious scenarios (requires privileged access):**
- Direct manipulation of cache or file storage (requires system access)
- Exploiting other vulnerabilities to corrupt stored data

The defensive programming failure is the core issue - the code should handle unexpected data gracefully rather than panicking.

## Recommendation
Replace the `expect()` call with proper error handling that either:
1. Treats invalid transaction types as non-matching (fail-safe approach)
2. Logs the error and continues processing
3. Returns an error that can be handled upstream

**Recommended fix:**

```rust
#[inline]
fn matches(&self, item: &Transaction) -> bool {
    if !self
        .success
        .matches_opt(&item.info.as_ref().map(|i| i.success))
    {
        return false;
    }

    if let Some(txn_type) = &self.txn_type {
        match TransactionType::try_from(item.r#type) {
            Ok(item_txn_type) => {
                if txn_type != &item_txn_type {
                    return false;
                }
            }
            Err(_) => {
                // Invalid transaction type - log and treat as non-matching
                warn!("Invalid transaction type value: {}", item.r#type);
                return false;
            }
        }
    }

    true
}
```

## Proof of Concept
```rust
#[test]
fn test_invalid_transaction_type_panic() {
    use aptos_protos::transaction::v1::{Transaction, TransactionInfo};
    use aptos_transaction_filter::{TransactionRootFilterBuilder, Filterable};

    // Create a transaction with an invalid type value (5, which is in the skipped range)
    let mut invalid_txn = Transaction {
        version: 1,
        r#type: 5, // Invalid transaction type (values 5-19 are skipped)
        info: Some(TransactionInfo {
            success: true,
            ..Default::default()
        }),
        ..Default::default()
    };

    // Create a filter that checks transaction type
    let filter = TransactionRootFilterBuilder::default()
        .txn_type(aptos_protos::transaction::v1::transaction::TransactionType::User)
        .build()
        .unwrap();

    // This will panic with "Invalid transaction type"
    // In a real scenario, this would crash the indexer service
    filter.matches(&invalid_txn);
}
```

## Notes
This is a defensive programming issue where proper error handling is missing. While direct exploitation by remote attackers is difficult, the vulnerability represents a real crash risk in production environments where data corruption or future protocol changes could introduce invalid transaction type values. The fix is straightforward and should be implemented to ensure service resilience.

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/transaction_root.rs (L67-73)
```rust
        if let Some(txn_type) = &self.txn_type {
            if txn_type
                != &TransactionType::try_from(item.r#type).expect("Invalid transaction type")
            {
                return false;
            }
        }
```

**File:** protos/proto/aptos/transaction/v1/transaction.proto (L47-56)
```text
  enum TransactionType {
    TRANSACTION_TYPE_UNSPECIFIED = 0;
    TRANSACTION_TYPE_GENESIS = 1;
    TRANSACTION_TYPE_BLOCK_METADATA = 2;
    TRANSACTION_TYPE_STATE_CHECKPOINT = 3;
    TRANSACTION_TYPE_USER = 4;
    // values 5-19 skipped for no reason
    TRANSACTION_TYPE_VALIDATOR = 20;
    TRANSACTION_TYPE_BLOCK_EPILOGUE = 21;
  }
```

**File:** protos/rust/src/pb/aptos.transaction.v1.rs (L51-52)
```rust
    #[prost(enumeration="transaction::TransactionType", tag="6")]
    pub r#type: i32,
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/compression_util.rs (L142-156)
```rust
    pub fn into_transaction(self) -> Transaction {
        match self {
            CacheEntry::Lz4CompressionProto(bytes) => {
                let mut decompressor = Decoder::new(&bytes[..]).expect("Lz4 decompression failed.");
                let mut decompressed = Vec::new();
                decompressor
                    .read_to_end(&mut decompressed)
                    .expect("Lz4 decompression failed.");
                Transaction::decode(decompressed.as_slice()).expect("proto deserialization failed.")
            },
            CacheEntry::Base64UncompressedProto(bytes) => {
                let bytes: Vec<u8> = base64::decode(bytes).expect("base64 decoding failed.");
                Transaction::decode(bytes.as_slice()).expect("proto deserialization failed.")
            },
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs (L930-936)
```rust
    let stripped_transactions: Vec<Transaction> = transactions
        .into_iter()
        .map(|mut txn| {
            // Note: `is_allowed` means the txn matches the filter, in which case
            // we strip it.
            if txns_to_strip_filter.matches(&txn) {
                stripped_count += 1;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L175-179)
```rust
                let pb_txns = if let Some(ref filter) = filter {
                    pb_txns
                        .into_iter()
                        .filter(|txn| filter.matches(txn))
                        .collect::<Vec<_>>()
```
