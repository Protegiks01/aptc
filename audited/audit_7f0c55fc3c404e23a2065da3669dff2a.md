# Audit Report

## Title
Missing Groth16 Verification Key Validation Allows Governance to Set Malicious VK and Forge Keyless Account Proofs

## Summary
The Groth16 verification key validation function `validate_groth16_vk()` exists in the codebase but is never called when governance sets a new verification key. This allows a malicious governance proposal to set an arbitrary verification key without cryptographic validation, enabling complete forgery of keyless account signatures and theft of all funds secured by keyless authentication. [1](#0-0) 

## Finding Description

The keyless account system relies on Groth16 zero-knowledge proofs to authenticate transactions. The verification key (VK) is critical to security—it must match the proving key from a trusted setup for the specific circuit used.

**The vulnerability consists of two failures:**

1. **Validation function exists but is never called**: A `validate_groth16_vk()` function performs point validation checks but is not invoked in the governance setter functions. [2](#0-1) 

2. **No cryptographic relationship validation**: Even the existing validation only checks that points are on the curve—it does not verify the mathematical relationships between `gamma_g2` and `gamma_abc_g1` that are essential to Groth16 security. [3](#0-2) 

**Attack scenario:**

1. Attacker submits a governance proposal to change the Groth16 VK
2. Proposal sets a VK for which the attacker has the proving key (toxic waste)
3. Governance approves the proposal (due to insufficient review or attacker voting power)
4. Attacker can now generate valid Groth16 proofs for arbitrary public inputs
5. Attacker forges keyless account signatures for any user
6. Attacker drains funds from all keyless accounts

The code even contains a WARNING acknowledging this risk: [4](#0-3) 

The Groth16 verification equation shown in the Move example demonstrates how `gamma_g2` and `gamma_abc_g1` must be paired correctly: [5](#0-4) 

Without validating this relationship, an attacker can set arbitrary curve points that break the cryptographic security.

## Impact Explanation

**Severity: Critical** (up to $1,000,000 per Aptos bug bounty)

This vulnerability enables:
- **Loss of Funds**: Complete theft from all keyless accounts on the network
- **Access Control Bypass**: Forged authentication for any keyless account
- **Violation of Invariant #10**: Cryptographic Correctness is completely broken

The impact scope is **total**—all keyless accounts become compromised simultaneously once a malicious VK is set. Unlike targeted exploits, this is a systemic vulnerability affecting every user of keyless authentication.

## Likelihood Explanation

**Likelihood: Medium to High**

While this requires governance approval, several factors make exploitation realistic:

1. **Legitimate appearance**: A malicious proposal could appear legitimate (e.g., "upgrading to new circuit version")
2. **Technical complexity**: Most governance voters lack the expertise to validate VK correctness
3. **No technical safeguards**: The code explicitly warns of this risk but provides no protection
4. **Accumulation attack**: An attacker could gradually accumulate voting power
5. **Social engineering**: Proposal descriptions could mislead voters about the VK's purpose

The developers' decision to write `validate_groth16_vk()` and add WARNING comments indicates they recognized this as a real threat—they simply failed to connect the validation to the setter functions.

## Recommendation

**Immediate fix**: Call `validate_groth16_vk()` in all VK setter functions:

```move
public fun set_groth16_verification_key_for_next_epoch(fx: &signer, vk: Groth16VerificationKey) {
    system_addresses::assert_aptos_framework(fx);
    validate_groth16_vk(&vk);  // ADD THIS LINE
    config_buffer::upsert<Groth16VerificationKey>(vk);
}
``` [6](#0-5) 

**Additional protections needed:**

1. **Circuit fingerprint validation**: Store a hash of the expected circuit and validate the VK matches
2. **Multi-signature approval**: Require signatures from trusted cryptography experts before VK changes
3. **Timelocked updates**: Add a delay between VK proposal and activation to allow community review
4. **Test vector validation**: Require proof that the new VK correctly verifies known test cases

**Long-term solution**: Implement a circuit registry that maps circuit versions to their legitimate VKs, preventing arbitrary VK submission entirely.

## Proof of Concept

This vulnerability is demonstrated by the missing function call. To reproduce:

1. Deploy a malicious VK via governance:
```move
// In a governance proposal script:
let malicious_vk = keyless_account::new_groth16_verification_key(
    malicious_alpha_g1,
    malicious_beta_g2, 
    malicious_gamma_g2,  // Attacker controls discrete log
    malicious_delta_g2,
    malicious_gamma_abc_g1  // Computed to match malicious_gamma_g2
);
keyless_account::set_groth16_verification_key_for_next_epoch(&framework_signer, malicious_vk);
// No validation occurs - malicious VK is accepted
```

2. After epoch change, generate forged proofs:
```rust
// Attacker uses their proving key to generate arbitrary proofs
let forged_proof = generate_proof_with_trapdoor(
    &attacker_proving_key,  // Matches malicious VK
    arbitrary_public_inputs  // Target victim's account
);
// Proof verifies because VK matches attacker's setup
```

The presence of `TEST_GROTH16_SETUP` in the codebase demonstrates this concept: [7](#0-6) 

This test setup intentionally generates VK/proving key pairs with known trapdoors—exactly what an attacker would deploy via governance.

---

**Notes:**

This vulnerability exists because the validation function was written but never integrated into the execution path. The code comments acknowledge the risk explicitly, indicating this is a recognized threat that lacks proper mitigation. The training wheels mechanism provides no protection since governance can also update the training wheels public key simultaneously with the VK.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L183-192)
```text
    fun validate_groth16_vk(vk: &Groth16VerificationKey) {
        // Could be leveraged to speed up the VM deserialization of the VK by 2x, since it can assume the points are valid.
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(&vk.alpha_g1)), E_INVALID_BN254_G1_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.beta_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.gamma_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G2, bn254_algebra::FormatG2Compr>(&vk.delta_g2)), E_INVALID_BN254_G2_SERIALIZATION);
        for (i in 0..vector::length(&vk.gamma_abc_g1)) {
            assert!(option::is_some(&crypto_algebra::deserialize<bn254_algebra::G1, bn254_algebra::FormatG1Compr>(vector::borrow(&vk.gamma_abc_g1, i))), E_INVALID_BN254_G1_SERIALIZATION);
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L198-203)
```text
    public fun update_groth16_verification_key(fx: &signer, vk: Groth16VerificationKey) {
        system_addresses::assert_aptos_framework(fx);
        chain_status::assert_genesis();
        // There should not be a previous resource set here.
        move_to(fx, vk);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L262-262)
```text
    /// WARNING: If a malicious key is set, this would lead to stolen funds.
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L263-266)
```text
    public fun set_groth16_verification_key_for_next_epoch(fx: &signer, vk: Groth16VerificationKey) {
        system_addresses::assert_aptos_framework(fx);
        config_buffer::upsert<Groth16VerificationKey>(vk);
    }
```

**File:** types/src/keyless/groth16_vk.rs (L62-91)
```rust
impl TryFrom<&Groth16VerificationKey> for PreparedVerifyingKey<Bn254> {
    type Error = CryptoMaterialError;

    fn try_from(vk: &Groth16VerificationKey) -> Result<Self, Self::Error> {
        if vk.gamma_abc_g1.len() != 2 {
            return Err(CryptoMaterialError::DeserializationError);
        }

        // NOTE: Technically, we already validate the points when we set the VK in Move, so we could
        // make this 2x faster by avoiding the point validation checks  via
        // `deserialize_with_mode(..., Compress::Yes, Validate::No)`. Due to paranoia, will not
        // optimize this for now.
        Ok(Self::from(VerifyingKey {
            alpha_g1: G1Affine::deserialize_compressed(vk.alpha_g1.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            beta_g2: G2Affine::deserialize_compressed(vk.beta_g2.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            gamma_g2: G2Affine::deserialize_compressed(vk.gamma_g2.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            delta_g2: G2Affine::deserialize_compressed(vk.delta_g2.as_slice())
                .map_err(|_| CryptoMaterialError::DeserializationError)?,
            gamma_abc_g1: vec![
                G1Affine::deserialize_compressed(vk.gamma_abc_g1[0].as_slice())
                    .map_err(|_| CryptoMaterialError::DeserializationError)?,
                G1Affine::deserialize_compressed(vk.gamma_abc_g1[1].as_slice())
                    .map_err(|_| CryptoMaterialError::DeserializationError)?,
            ],
        }))
    }
}
```

**File:** aptos-move/move-examples/groth16_example/sources/groth16.move (L29-31)
```text
        let right = add(&right, &pairing<G1,G2,Gt>(vk_alpha_g1, vk_beta_g2));
        let right = add(&right, &pairing(&multi_scalar_mul(vk_uvw_gamma_g1, &scalars), vk_gamma_g2));
        let right = add(&right, &pairing(proof_c, vk_delta_g2));
```

**File:** types/src/keyless/circuit_constants.rs (L106-115)
```rust
pub static TEST_GROTH16_SETUP: Lazy<Groth16TrapdoorSetup> = Lazy::new(|| {
    let mut rng = StdRng::seed_from_u64(999);
    let (simulation_pk, vk) =
        Groth16SimulatorBn254::circuit_agnostic_setup_with_trapdoor(&mut rng, 1).unwrap();
    let prepared_vk = PreparedVerifyingKey::from(vk.clone());
    Groth16TrapdoorSetup {
        simulation_pk,
        prepared_vk,
    }
});
```
