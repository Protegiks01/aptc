# Audit Report

## Title
Reference Safety Processor Incompatibility Causes Non-Deterministic Bytecode Generation for Reference-Typed Locals

## Summary
The Move compiler v2 provides two reference safety processor implementations (v2 and v3) that produce incompatible `LifetimeAnnotation` outputs when analyzing reference-typed function parameters and locals. This incompatibility causes the ability processor to emit different Copy instructions, resulting in non-deterministic bytecode generation from identical Move source code depending on which processor is selected via the `REFERENCE_SAFETY_V3` experiment flag.

## Finding Description

The v2 and v3 reference safety processors implement the `LifetimeInfo::borrow_kind()` trait method with fundamentally different semantics: [1](#0-0) [2](#0-1) 

**V2 Implementation:** Checks if a temporary has children in the borrow graph (i.e., something is borrowed FROM it) by calling `label_for_temp_with_children()` which filters for labels with outgoing edges.

**V3 Implementation:** Checks if a local is borrowed from the frame root (i.e., the local itself is borrowed) using `is_local_borrowed()` and `is_local_mutably_borrowed()`. [3](#0-2) 

For **reference-typed parameters and locals**, these produce incompatible results:

**Scenario:** A function receives a reference parameter `r: &S`, then borrows a field: `let x = &r.f`

- **V2:** Returns `Some(Immutable)` for `borrow_kind(r)` because `r`'s node has outgoing edges to the field borrow
- **V3:** Returns `None` for `borrow_kind(r)` because reference parameters are not "borrowed from the frame root"

The ability processor consumes `LifetimeAnnotation` to determine whether explicit Copy instructions must be emitted: [4](#0-3) [5](#0-4) 

When `is_borrowed()` returns different values for v2 vs v3, the ability processor emits different Copy instructions, producing different bytecode from identical Move source code.

The processor selection happens via the `REFERENCE_SAFETY_V3` experiment flag, which defaults to `true` but can be changed: [6](#0-5) [7](#0-6) 

## Impact Explanation

This issue violates the **Deterministic Execution** invariant at the compilation layer. While validators execute pre-compiled bytecode (not recompile source code), the non-determinism manifests in multiple ways:

1. **Developer Environment Inconsistency**: Different developers compiling the same Move source with different experiment flags produce different bytecode hashes, causing confusion and potential deployment failures

2. **Build System Non-Determinism**: Automated build systems that change compiler flags between runs would produce different artifacts from identical source, breaking reproducible builds

3. **Historical Bytecode Divergence**: Modules compiled before/after the v3 processor was introduced (or when the default changed) would have different bytecode despite identical source

4. **Upgrade Verification Failures**: Module upgrade systems that verify bytecode consistency could falsely reject valid upgrades or accept invalid ones based on which processor was used

However, this does **NOT** directly cause:
- Validator consensus failures (they execute bytecode, not compile)
- Fund theft or loss
- Network partitions or liveness issues

The severity is therefore **Medium** as it causes "state inconsistencies requiring intervention" in the form of build system and deployment issues, but does not directly threaten consensus, funds, or availability.

## Likelihood Explanation

**Likelihood: Medium**

The issue manifests whenever:
1. The `REFERENCE_SAFETY_V3` flag is explicitly toggled from its default
2. Code with reference-typed parameters that have field borrows is compiled
3. Different build environments use different default settings

Since v3 is now the default (as of the flag's introduction), historical code compiled with v2 would differ from new compilations. The explicit experiment flag system makes this easily triggerable by developers or build scripts that modify compiler options.

## Recommendation

**Immediate Fix:** Deprecate and remove the v2 processor entirely, making v3 the only implementation. This ensures deterministic compilation going forward.

**Short-term Fix:** Make the `borrow_kind()` trait contract explicit and verify both implementations produce equivalent results for all test cases. Add integration tests that compile the same Move source with both processors and verify bytecode equivalence.

**Proposed Code Fix:**

1. Remove v2 processor option from pipeline selection
2. Add deprecation warning if REFERENCE_SAFETY_V3=false is explicitly set
3. Update documentation to clarify v3 is required for deterministic builds

**Alternative:** If both processors must be maintained, standardize their `borrow_kind()` semantics by defining the trait contract precisely and ensuring both implementations follow it. Add a validation layer that compares outputs from both processors in debug builds.

## Proof of Concept

```move
// test_module.move
module 0x1::test {
    struct S has copy, drop {
        field: u64
    }
    
    public fun test_reference_borrow(r: &S): u64 {
        let field_ref = &r.field;  // Borrow field from reference parameter
        
        // At this point:
        // v2: borrow_kind(r) = Some(Immutable) - r has children
        // v3: borrow_kind(r) = None - r not borrowed from frame
        
        let r_copy = r;  // Should emit Copy instruction?
        // v2: YES (r is marked borrowed)
        // v3: NO (r not marked borrowed)
        
        *field_ref
    }
}
```

**Compilation Steps:**

```bash
# Compile with v3 (default)
$ move-compiler-v2 test_module.move --dump-bytecode > v3_bytecode.txt

# Compile with v2
$ move-compiler-v2 test_module.move --experiment REFERENCE_SAFETY_V3=off --dump-bytecode > v2_bytecode.txt

# Compare bytecode
$ diff v3_bytecode.txt v2_bytecode.txt
# Expected: Different Copy instruction emission for r_copy assignment
```

The bytecode will differ in the presence/absence of explicit Copy operations at the `let r_copy = r` statement, demonstrating the non-deterministic compilation behavior.

## Notes

This is a compiler-level non-determinism issue rather than a runtime consensus vulnerability. While it doesn't directly threaten blockchain consensus (since validators execute pre-compiled bytecode), it violates build determinism and could cause deployment issues. The issue is contained to the compilation phase and does not expose the network to consensus failures, fund theft, or availability attacks. The bytecode verifier should still catch any unsafe bytecode generated by either processor.

### Citations

**File:** third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v2.rs (L2146-2150)
```rust
impl LifetimeInfo for LifetimeState {
    fn borrow_kind(&self, temp: TempIndex) -> Option<ReferenceKind> {
        self.label_for_temp_with_children(temp)
            .map(|label| ReferenceKind::from_is_mut(self.is_mut(label)))
    }
```

**File:** third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v3.rs (L312-322)
```rust
    /// Checks if local is borrowed
    fn is_local_borrowed(&self, local: TempIndex) -> bool {
        self.borrow_graph
            .has_consistent_borrows(self.frame_root(), Some(Label::Local(local)))
    }

    /// Checks if local is mutably borrowed
    fn is_local_mutably_borrowed(&self, local: TempIndex) -> bool {
        self.borrow_graph
            .has_consistent_mutable_borrows(self.frame_root(), Some(Label::Local(local)))
    }
```

**File:** third_party/move/move-compiler-v2/src/pipeline/reference_safety/reference_safety_processor_v3.rs (L1171-1180)
```rust
impl LifetimeInfo for LifetimeState {
    fn borrow_kind(&self, temp: TempIndex) -> Option<ReferenceKind> {
        if self.is_local_mutably_borrowed(temp) {
            Some(ReferenceKind::Mutable)
        } else if self.is_local_borrowed(temp) {
            Some(ReferenceKind::Immutable)
        } else {
            None
        }
    }
```

**File:** third_party/move/move-compiler-v2/src/pipeline/ability_processor.rs (L164-166)
```rust
        // Only temps which are used after or borrowed need a copy
        let temp_needs_copy =
            |temp, instr| live_var.is_temp_used_after(temp, instr) || lifetime.is_borrowed(*temp);
```

**File:** third_party/move/move-compiler-v2/src/pipeline/ability_processor.rs (L365-375)
```rust
                // Only need to perform the actual copy if src is borrowed, as this
                // information cannot be determined from live-var analysis in later
                // phases.
                if self.lifetime.get_info_at(code_offset).is_borrowed(*src) {
                    let ty = self.builder.get_local_type(*src);
                    let temp = self.builder.new_temp(ty);
                    self.builder.emit(Assign(id, temp, *src, AssignKind::Copy));
                    new_srcs.push(temp)
                } else {
                    new_srcs.push(*src)
                }
```

**File:** third_party/move/move-compiler-v2/src/lib.rs (L522-534)
```rust
    // Reference safety checkers need live variable annotation.
    pipeline.add_processor(Box::new(LiveVarAnalysisProcessor::new(false)));
    if options.experiment_on(Experiment::REFERENCE_SAFETY_V3) {
        pipeline.add_processor(Box::new(
            reference_safety_processor_v3::ReferenceSafetyProcessor {},
        ));
    } else {
        // Reference check is always run, but the legacy processor decides internally
        // based on `Experiment::REFERENCE_SAFETY` whether to report errors.
        pipeline.add_processor(Box::new(
            reference_safety_processor_v2::ReferenceSafetyProcessor {},
        ));
    }
```

**File:** third_party/move/move-compiler-v2/src/experiments.rs (L54-59)
```rust
        Experiment {
            name: Experiment::REFERENCE_SAFETY_V3.to_string(),
            description: "Turns on or off whether to use the new v3 reference safety checker"
                .to_string(),
            default: Given(true), // v3 is the default
        },
```
