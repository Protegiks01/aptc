# Audit Report

## Title
Mempool Capacity Bypass via Orderless Transactions Exploiting Unvalidated capacity_bytes Configuration

## Summary
The mempool's `capacity_bytes` limit can be exploited to cause a denial-of-service condition by submitting large orderless (nonce-based) transactions. The lack of configuration validation between `capacity_bytes` and `capacity` parameters, combined with orderless transactions being exempt from parking lot eviction, allows an attacker to fill the mempool with significantly fewer transactions than the configured capacity suggests.

## Finding Description

The mempool enforces two independent limits: a transaction count limit (`capacity`) and a byte size limit (`capacity_bytes`). The vulnerability arises from three interacting design decisions:

1. **No Configuration Validation**: The `ConfigSanitizer` implementation for `MempoolConfig` contains only a TODO comment and performs no actual validation. [1](#0-0) 

2. **Dual Limit Enforcement**: The mempool becomes full when either limit is reached, not both. [2](#0-1) 

3. **Orderless Transactions Exempt from Eviction**: Nonce-based transactions are always considered "ready" and are never stored in the parking lot, making them immune to eviction when the mempool fills. [3](#0-2) [4](#0-3) 

**Attack Path**:

With the default configuration (`capacity` = 2,000,000, `capacity_bytes` = 2GB), an attacker can:

1. Create a single account (or a small number of accounts)
2. Submit large orderless transactions (up to 6MB each per transaction size limits) [5](#0-4) 

3. With 5MB transactions and the orderless transaction per-user limit of 1,000: [6](#0-5) 

4. Fill the mempool: 2GB / 5MB â‰ˆ 410 transactions from a single account (well below the 1,000 per-user limit)

5. Once `capacity_bytes` is reached, all new transaction submissions are rejected with `MempoolIsFull` status: [7](#0-6) 

6. The parking lot eviction mechanism cannot help because orderless transactions are always "ready" and never enter the parking lot: [8](#0-7) 

The mempool's effective capacity is reduced from 2 million transactions to approximately 410 transactions (0.02% of expected capacity) when the attacker submits maximum-sized orderless transactions.

## Impact Explanation

**Severity: Medium** per Aptos bug bounty criteria.

This vulnerability enables:
- **Denial of Service**: Legitimate users cannot submit transactions while the mempool is filled with attacker transactions
- **Reduced Availability**: The attack persists until transactions expire (default `system_transaction_timeout_secs` = 600 seconds) or are committed [9](#0-8) 

The issue qualifies as **Medium severity** because:
- It causes temporary service degradation, not permanent network partition
- Requires gas payment for large transactions (economic cost to attacker)
- Does not directly lead to loss of funds or consensus violation
- State inconsistency is temporary and self-resolving through garbage collection

This does not qualify as High/Critical because:
- No funds are lost or stolen
- No consensus safety violation occurs
- Network remains functional after attack expires or node restarts
- Attack requires ongoing gas expenditure

## Likelihood Explanation

**Likelihood: High**

The attack is highly likely to succeed because:

1. **Low Cost**: Attacker needs only 1 account and ~410 large transactions
2. **No Special Access Required**: Any user can submit orderless transactions
3. **Predictable Behavior**: The mempool consistently enforces the byte limit
4. **Default Configuration Vulnerable**: The issue exists with default settings, requiring no node misconfiguration
5. **No Detection**: There is no warning when byte capacity is consistently hit before transaction count capacity

The only cost barrier is gas for transaction submission, but transactions sitting in mempool haven't executed yet, so the actual cost is primarily for account creation and transaction submission overhead.

## Recommendation

Implement comprehensive validation in the `ConfigSanitizer` for `MempoolConfig`:

```rust
impl ConfigSanitizer for MempoolConfig {
    fn sanitize(
        _node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        // Minimum reasonable average transaction size (accounting for overhead)
        const MIN_AVG_TXN_SIZE: usize = TXN_FIXED_ESTIMATED_BYTES + TXN_INDEX_ESTIMATED_BYTES + 200;
        
        // Verify capacity_bytes is sufficient for capacity
        let min_capacity_bytes = self.capacity * MIN_AVG_TXN_SIZE;
        if self.capacity_bytes < min_capacity_bytes {
            return Err(Error::ConfigError(format!(
                "capacity_bytes ({}) is too low for capacity ({}). Minimum required: {} bytes",
                self.capacity_bytes, self.capacity, min_capacity_bytes
            )));
        }
        
        // Warn if configuration allows very few max-sized transactions
        const MAX_TXN_SIZE: usize = 6 * 1024 * 1024; // 6MB
        let max_size_txn_capacity = self.capacity_bytes / MAX_TXN_SIZE;
        if max_size_txn_capacity < self.orderless_txn_capacity_per_user {
            warn!(
                "capacity_bytes configuration allows only {} maximum-sized transactions, \
                which is less than orderless_txn_capacity_per_user ({}). \
                Consider increasing capacity_bytes to prevent DoS attacks.",
                max_size_txn_capacity, self.orderless_txn_capacity_per_user
            );
        }
        
        Ok(())
    }
}
```

Additionally, consider implementing per-user byte limits alongside per-user transaction count limits to prevent a single account from consuming disproportionate mempool capacity.

## Proof of Concept

```rust
#[cfg(test)]
mod mempool_capacity_bypass_test {
    use super::*;
    use aptos_config::config::NodeConfig;
    use aptos_types::transaction::{ReplayProtector, Script, SignedTransaction, TransactionExecutable};
    use aptos_crypto::{ed25519::Ed25519PrivateKey, PrivateKey, Uniform, SigningKey};
    use aptos_types::chain_id::ChainId;
    
    #[test]
    fn test_orderless_txn_capacity_bytes_dos() {
        // Setup mempool with default configuration
        let mut config = NodeConfig::generate_random_config();
        config.mempool.capacity = 2_000_000;
        config.mempool.capacity_bytes = 2 * 1024 * 1024 * 1024; // 2GB
        config.mempool.orderless_txn_capacity_per_user = 1000;
        
        let mut pool = CoreMempool::new(&config);
        
        // Create large transactions (5MB payload each)
        let large_payload = vec![0u8; 5 * 1024 * 1024];
        let private_key = Ed25519PrivateKey::generate_for_testing();
        let sender = AccountAddress::random();
        
        // Submit orderless transactions until mempool is full
        let mut submitted = 0;
        for nonce in 0..1000 {
            let txn_executable = TransactionExecutable::Script(
                Script::new(large_payload.clone(), vec![], vec![])
            );
            
            let raw_txn = RawTransaction::new_txn(
                sender,
                ReplayProtector::Nonce(nonce),
                txn_executable,
                None,
                0,
                1000000,
                u64::MAX,
                ChainId::test(),
            );
            
            let signed_txn = SignedTransaction::new(
                raw_txn.clone(),
                private_key.public_key(),
                private_key.sign(&raw_txn).unwrap(),
            );
            
            let status = pool.add_txn(
                signed_txn,
                0,
                None,
                TimelineState::NotReady,
                false,
                None,
                Some(BroadcastPeerPriority::Primary),
            );
            
            if status.code == MempoolStatusCode::MempoolIsFull {
                break;
            }
            assert_eq!(status.code, MempoolStatusCode::Accepted);
            submitted += 1;
        }
        
        // Verify mempool filled with far fewer transactions than capacity suggests
        assert!(submitted < 500, "Expected < 500 transactions to fill 2GB with 5MB txns");
        assert!(submitted < config.mempool.capacity / 1000, "Effective capacity reduced by >1000x");
        
        // Verify legitimate transaction is rejected
        let small_payload = vec![0u8; 100];
        let txn_executable = TransactionExecutable::Script(
            Script::new(small_payload, vec![], vec![])
        );
        let raw_txn = RawTransaction::new_txn(
            AccountAddress::random(),
            ReplayProtector::Nonce(0),
            txn_executable,
            None,
            0,
            1000000,
            u64::MAX,
            ChainId::test(),
        );
        let signed_txn = SignedTransaction::new(
            raw_txn.clone(),
            private_key.public_key(),
            private_key.sign(&raw_txn).unwrap(),
        );
        
        let status = pool.add_txn(
            signed_txn,
            0,
            None,
            TimelineState::NotReady,
            false,
            None,
            Some(BroadcastPeerPriority::Primary),
        );
        
        assert_eq!(status.code, MempoolStatusCode::MempoolIsFull);
    }
}
```

**Notes**: This vulnerability demonstrates a configuration weakness where the mempool's dual-limit enforcement (transaction count and byte size) combined with orderless transactions' immunity to parking lot eviction creates a DoS vector. The lack of validation in the configuration sanitizer allows this misconfiguration to persist undetected. While the default configuration is mathematically balanced for average-sized transactions (~1KB), it becomes highly vulnerable when attackers submit maximum-sized orderless transactions.

### Citations

**File:** config/src/config/mempool_config.rs (L105-106)
```rust
    pub orderless_txn_capacity_per_user: usize,
}
```

**File:** config/src/config/mempool_config.rs (L129-129)
```rust
            system_transaction_timeout_secs: 600,
```

**File:** config/src/config/mempool_config.rs (L176-183)
```rust
impl ConfigSanitizer for MempoolConfig {
    fn sanitize(
        _node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        Ok(()) // TODO: add reasonable verifications
    }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L311-317)
```rust
        if self.check_is_full_after_eviction(&txn, account_sequence_number) {
            return MempoolStatus::new(MempoolStatusCode::MempoolIsFull).with_message(format!(
                "Mempool is full. Mempool size: {}, Capacity: {}",
                self.system_ttl_index.size(),
                self.capacity,
            ));
        }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L415-456)
```rust
    fn check_is_full_after_eviction(
        &mut self,
        txn: &MempoolTransaction,
        account_sequence_number: Option<u64>,
    ) -> bool {
        if self.is_full() && self.check_txn_ready(txn, account_sequence_number) {
            let now = Instant::now();
            // try to free some space in Mempool from ParkingLot by evicting non-ready txns
            let mut evicted_txns = 0;
            let mut evicted_bytes = 0;
            while let Some(txn_pointer) = self.parking_lot_index.get_poppable() {
                if let Some(txn) = self
                    .transactions
                    .get_mut(&txn_pointer.sender)
                    .and_then(|txns| txns.remove(&txn_pointer.replay_protector))
                {
                    debug!(
                        LogSchema::new(LogEntry::MempoolFullEvictedTxn).txns(TxnsLog::new_txn(
                            txn.get_sender(),
                            txn.get_replay_protector()
                        ))
                    );
                    evicted_bytes += txn.get_estimated_bytes() as u64;
                    evicted_txns += 1;
                    self.index_remove(&txn);
                    if !self.is_full() {
                        break;
                    }
                } else {
                    error!("Transaction not found in mempool while evicting from parking lot");
                    break;
                }
            }
            if evicted_txns > 0 {
                counters::CORE_MEMPOOL_PARKING_LOT_EVICTED_COUNT.observe(evicted_txns as f64);
                counters::CORE_MEMPOOL_PARKING_LOT_EVICTED_BYTES.observe(evicted_bytes as f64);
                counters::CORE_MEMPOOL_PARKING_LOT_EVICTED_LATENCY
                    .observe(now.elapsed().as_secs_f64());
            }
        }
        self.is_full()
    }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L458-460)
```rust
    fn is_full(&self) -> bool {
        self.system_ttl_index.size() >= self.capacity || self.size_bytes >= self.capacity_bytes
    }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L495-498)
```rust
            ReplayProtector::Nonce(_) => {
                // Nonce based transactions are always ready for broadcast
                true
            },
```

**File:** mempool/src/core_mempool/index.rs (L547-587)
```rust
    pub(crate) fn insert(&mut self, txn: &mut MempoolTransaction) {
        // Orderless transactions are always in the "ready" state and are not stored in the parking lot.
        match txn.get_replay_protector() {
            ReplayProtector::SequenceNumber(sequence_number) => {
                if txn.insertion_info.park_time.is_none() {
                    txn.insertion_info.park_time = Some(SystemTime::now());
                }
                txn.was_parked = true;

                let sender = &txn.txn.sender();
                let hash = txn.get_committed_hash();
                let is_new_entry = match self.account_indices.get(sender) {
                    Some(index) => {
                        if let Some((_account, seq_nums)) = self.data.get_mut(*index) {
                            seq_nums.insert((sequence_number, hash))
                        } else {
                            counters::CORE_MEMPOOL_INVARIANT_VIOLATION_COUNT.inc();
                            error!(
                                LogSchema::new(LogEntry::InvariantViolated),
                                "Parking lot invariant violated: for account {}, account index exists but missing entry in data",
                                sender
                            );
                            return;
                        }
                    },
                    None => {
                        let entry = [(sequence_number, hash)]
                            .iter()
                            .cloned()
                            .collect::<BTreeSet<_>>();
                        self.data.push((*sender, entry));
                        self.account_indices.insert(*sender, self.data.len() - 1);
                        true
                    },
                };
                if is_new_entry {
                    self.size += 1;
                }
            },
            ReplayProtector::Nonce(_) => {},
        }
```

**File:** aptos-move/e2e-testsuite/src/tests/verify_txn.rs (L30-30)
```rust
pub const MAX_TRANSACTION_SIZE_IN_BYTES: u64 = 6 * 1024 * 1024;
```
