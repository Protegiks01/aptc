# Audit Report

## Title
Lack of Integration Tests for Telemetry Data Sanitization Creates Regression Risk for Credential Leaks

## Summary
The CLI telemetry system in `send_cli_telemetry_event()` currently sanitizes error data correctly by only transmitting error types (not error messages), but there are **no integration tests** validating that sensitive data (keys, secrets, passwords) are never transmitted. This creates a high risk that future code changes could accidentally introduce credential leaks through telemetry without detection.

## Finding Description

The CLI telemetry flow currently implements correct sanitization: [1](#0-0) 

The critical protection is that `error.to_str()` only returns the error variant name (e.g., "ApiError", "CommandArgumentError"), NOT the full error message: [2](#0-1) 

However, error messages throughout the codebase CAN contain sensitive data:
- File paths to private key files
- Parsing errors that might include key fragments  
- Configuration values with tokens/secrets [3](#0-2) 

The telemetry data is sent to Google Analytics or telemetry services: [4](#0-3) 

**The Vulnerability:** There are **zero tests** in the telemetry codebase validating sensitive data exclusion. A simple one-character change from `error.to_str()` to `error.to_string()` would leak all error details including file paths, key fragments, and configuration secrets - and no automated test would catch this regression.

## Impact Explanation

This does **NOT** meet the Aptos bug bounty severity criteria as an exploitable vulnerability because:
- The current production code is **safe** and correctly sanitizes data
- There is no active attack path that an attacker can exploit
- This is a **test coverage gap**, not a production bug

However, it represents a **significant security hygiene issue** because:
- Future developers may not understand the sanitization requirements
- Code refactoring could accidentally remove the protection
- No CI/CD pipeline validation prevents credential leak regressions

## Likelihood Explanation

**Current Exploitation:** NONE - the code is currently safe.

**Future Regression Likelihood:** HIGH - error handling code changes are common, and without tests, accidental changes to `error.to_str()` → `error.to_string()` or `format!("{:#}", error)` would go undetected.

## Recommendation

Add integration tests to `crates/aptos-telemetry/src/cli_metrics.rs` that:

1. **Test error sanitization:** Verify that when a CLI command fails with an error containing sensitive data (e.g., a file path with "private_key" in the name), only the error type is included in telemetry, not the full message.

2. **Test command name safety:** Verify that `command` parameter is always a static string and never contains runtime arguments.

3. **Test build info safety:** Verify that `build_information` contains only non-sensitive build metadata.

Example test structure:
```rust
#[cfg(test)]
mod tests {
    #[tokio::test]
    async fn test_sensitive_data_not_in_telemetry() {
        // Create an error with sensitive data
        let error = CliError::UnableToReadFile(
            "/home/user/.aptos/private_key.txt".to_string(),
            "permission denied".to_string()
        );
        
        // Verify only error type is extracted
        assert_eq!(error.to_str(), "UnableToReadFile");
        assert!(!error.to_str().contains("private_key"));
        assert!(!error.to_str().contains("/home/user"));
    }
}
```

## Proof of Concept

**This is NOT an exploitable vulnerability** - the current code is safe. No PoC of exploitation can be provided because no exploit exists.

Instead, here is a demonstration that the **absence of tests** creates regression risk:

```rust
// Current SAFE implementation in utils.rs:
let error = if let Err(ref error) = result {
    Some(error.to_str())  // ✓ SAFE: Returns only error type
} else {
    None
};

// Hypothetical UNSAFE regression (would leak credentials):
let error = if let Err(ref error) = result {
    Some(&format!("{:#}", error))  // ✗ UNSAFE: Would leak full error details
} else {
    None
};
```

Without integration tests, such regressions would not be caught during code review or CI/CD.

---

**NOTE:** This finding addresses the **specific question asked**: "Are there integration tests validating that sensitive data are never transmitted in telemetry?" The answer is **NO**, creating regression risk. However, this does NOT constitute an exploitable vulnerability under bug bounty criteria, as the current production code is secure.

### Citations

**File:** crates/aptos/src/common/utils.rs (L94-100)
```rust
    if !telemetry_is_disabled() {
        let error = if let Err(ref error) = result {
            // Only print the error type
            Some(error.to_str())
        } else {
            None
        };
```

**File:** crates/aptos/src/common/types.rs (L158-177)
```rust
    pub fn to_str(&self) -> &'static str {
        match self {
            CliError::AbortedError => "AbortedError",
            CliError::ApiError(_) => "ApiError",
            CliError::BCS(_, _) => "BCS",
            CliError::CommandArgumentError(_) => "CommandArgumentError",
            CliError::ConfigLoadError(_, _) => "ConfigLoadError",
            CliError::ConfigNotFoundError(_) => "ConfigNotFoundError",
            CliError::IO(_, _) => "IO",
            CliError::MoveCompilationError(_) => "MoveCompilationError",
            CliError::MoveTestError => "MoveTestError",
            CliError::MoveProverError(_) => "MoveProverError",
            CliError::PackageSizeExceeded(_, _) => "PackageSizeExceeded",
            CliError::UnableToParse(_, _) => "UnableToParse",
            CliError::UnableToReadFile(_, _) => "UnableToReadFile",
            CliError::UnexpectedError(_) => "UnexpectedError",
            CliError::SimulationError(_) => "SimulationError",
            CliError::CoverageError(_) => "CoverageError",
        }
    }
```

**File:** crates/aptos-crypto/src/encoding_type.rs (L86-94)
```rust
                    .map_err(|err| EncodingError::UnableToParse(name, err.to_string()))
            },
            EncodingType::Base64 => {
                let string = String::from_utf8(data)?;
                let bytes = base64::decode(string.trim())
                    .map_err(|err| EncodingError::UnableToParse(name, err.to_string()))?;
                Key::try_from(bytes.as_slice()).map_err(|err| {
                    EncodingError::UnableToParse(name, format!("Failed to parse key {:?}", err))
                })
```

**File:** crates/aptos-telemetry/src/cli_metrics.rs (L19-53)
```rust
pub async fn send_cli_telemetry_event(
    mut build_information: BTreeMap<String, String>,
    command: String,
    latency: Duration,
    success: bool,
    error: Option<&str>,
) {
    // Collection information about the cli command
    collect_cli_info(command, latency, success, error, &mut build_information);

    // Create a new telemetry event
    let telemetry_event = TelemetryEvent {
        name: APTOS_CLI_METRICS.into(),
        params: build_information,
    };

    // TODO(joshlind): can we find a better way of identifying each CLI user?
    let user_id = uuid::Uuid::new_v4().to_string();

    // Send the event (we block on the join handle to ensure the
    // event is processed before terminating the cli command).
    let join_handle = service::prepare_and_send_telemetry_event(
        user_id,
        "NO_CHAIN".into(),
        None,
        telemetry_event,
    )
    .await;
    if let Err(error) = join_handle.await {
        debug!(
            "Failed to send telemetry event with join error: {:?}",
            error
        );
    }
}
```
