# Audit Report

## Title
Incomplete Backend Validation Allows Insecure OnDiskStorage on Mainnet Validators

## Summary
The mainnet configuration sanitizer for safety rules only validates against `InMemoryStorage` backends but fails to reject `OnDiskStorage`, despite OnDiskStorage being explicitly documented as unsafe for production use. This allows mainnet validators to pass validation with consensus keys stored in plaintext JSON files, creating a critical security exposure.

## Finding Description

The `SafetyRulesConfig::sanitize()` function is responsible for validating that mainnet validators use secure backends for storing consensus private keys. The current implementation only checks for `InMemoryStorage`: [1](#0-0) 

The `is_in_memory()` method only returns true for `InMemoryStorage`, allowing `OnDiskStorage` to pass validation: [2](#0-1) 

However, `OnDiskStorage` is explicitly documented as unsuitable for production. The implementation comments state: [3](#0-2) 

The README further clarifies: [4](#0-3) 

OnDiskStorage stores consensus private keys in plaintext JSON without encryption: [5](#0-4) 

These consensus keys are critical for validator operation and are stored through `PersistentSafetyStorage`: [6](#0-5) 

The test coverage confirms this gap - only `InMemoryStorage` is tested: [7](#0-6) 

**Attack Scenario:**
1. A validator operator configures mainnet node with `OnDiskStorage` backend (following docker-compose examples or misunderstanding documentation)
2. Configuration passes all validation checks
3. Consensus private keys are stored in plaintext JSON file
4. Attacker gains filesystem access through backup exposure, container escape, misconfigured permissions, or system compromise
5. Attacker extracts consensus keys and uses them to double-sign blocks
6. Validator is slashed for equivocation, losing stake

## Impact Explanation

This is a **Medium severity** vulnerability under the Aptos bug bounty criteria for the following reasons:

**Limited Funds Loss**: If consensus keys are compromised, an attacker can cause the validator to be slashed by creating equivocating votes. This results in direct financial loss to the validator operator through stake penalties.

**State Inconsistencies**: Compromised consensus keys could be used to disrupt consensus operations, though the AptosBFT protocol's 1/3 Byzantine fault tolerance limits the systemic impact to individual validator compromise.

The issue breaks the **Cryptographic Correctness** invariant by failing to enforce secure key storage requirements that are explicitly documented in the codebase.

## Likelihood Explanation

**Moderate likelihood** due to:

**High probability of misconfiguration**: 
- OnDiskStorage is used in docker-compose examples [8](#0-7) 
- Developers/operators following test configurations might accidentally deploy to mainnet
- No validation warning prevents this

**Multiple key compromise vectors**:
- Plaintext files in backups
- Container image exposure
- Filesystem permission errors  
- Log file leakage
- System compromise

**Mitigation factors**:
- Requires validator operator error
- Production documentation recommends Vault [9](#0-8) 
- Attacker still needs filesystem access

## Recommendation

Extend the mainnet validation to reject both `InMemoryStorage` AND `OnDiskStorage` backends for validators. Only `Vault` should be permitted on mainnet.

**Recommended fix** in `config/src/config/safety_rules_config.rs`:

```rust
// Add new method to SecureBackend
impl SecureBackend {
    pub fn is_production_ready(&self) -> bool {
        matches!(self, SecureBackend::Vault(_))
    }
}

// Update sanitize function (lines 86-96)
if chain_id.is_mainnet()
    && node_type.is_validator()
    && !safety_rules_config.backend.is_production_ready()
{
    return Err(Error::ConfigSanitizerFailed(
        sanitizer_name,
        format!(
            "Mainnet validators must use Vault backend for secure key storage. Current backend: {:?}",
            safety_rules_config.backend
        ),
    ));
}
```

## Proof of Concept

Add this test to `config/src/config/safety_rules_config.rs` to demonstrate the vulnerability:

```rust
#[test]
fn test_on_disk_storage_allowed_on_mainnet_vulnerability() {
    use crate::config::OnDiskStorageConfig;
    
    // Create a node config with OnDiskStorage backend (insecure for mainnet)
    let node_config = NodeConfig {
        consensus: ConsensusConfig {
            safety_rules: SafetyRulesConfig {
                backend: SecureBackend::OnDiskStorage(OnDiskStorageConfig::default()),
                ..Default::default()
            },
            ..Default::default()
        },
        ..Default::default()
    };

    // This currently PASSES but should FAIL
    // OnDiskStorage is documented as unsafe for production
    let result = SafetyRulesConfig::sanitize(
        &node_config,
        NodeType::Validator,
        Some(ChainId::mainnet()),
    );

    // VULNERABILITY: OnDiskStorage passes validation on mainnet
    assert!(result.is_ok(), "OnDiskStorage incorrectly passes mainnet validation!");
    
    // After fix, this should fail:
    // assert!(result.is_err());
    // assert!(matches!(result.unwrap_err(), Error::ConfigSanitizerFailed(_, _)));
}
```

This test demonstrates that `OnDiskStorage` currently passes mainnet validator validation, despite being explicitly documented as unsuitable for production use.

## Notes

The vulnerability is in the production validation logic, not the test file itself. The test coverage gap reveals incomplete enforcement of documented security requirements. While the example configurations correctly recommend Vault for production, the validation layer fails to enforce this requirement, creating a path for insecure deployments that should be programmatically prevented.

### Citations

**File:** config/src/config/safety_rules_config.rs (L87-96)
```rust
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }
```

**File:** config/src/config/safety_rules_config.rs (L273-294)
```rust
    fn test_sanitize_invalid_backend_for_mainnet() {
        // Create a node config with an invalid backend for mainnet
        let node_config = NodeConfig {
            consensus: ConsensusConfig {
                safety_rules: SafetyRulesConfig {
                    backend: SecureBackend::InMemoryStorage,
                    ..Default::default()
                },
                ..Default::default()
            },
            ..Default::default()
        };

        // Verify that the config sanitizer fails
        let error = SafetyRulesConfig::sanitize(
            &node_config,
            NodeType::Validator,
            Some(ChainId::mainnet()),
        )
        .unwrap_err();
        assert!(matches!(error, Error::ConfigSanitizerFailed(_, _)));
    }
```

**File:** config/src/config/secure_backend_config.rs (L45-48)
```rust
    /// Returns true iff the backend is in memory
    pub fn is_in_memory(&self) -> bool {
        matches!(self, SecureBackend::InMemoryStorage)
    }
```

**File:** secure/storage/src/on_disk.rs (L16-22)
```rust
/// OnDiskStorage represents a key value store that is persisted to the local filesystem and is
/// intended for single threads (or must be wrapped by a Arc<RwLock<>>). This provides no permission
/// checks and simply offers a proof of concept to unblock building of applications without more
/// complex data stores. Internally, it reads and writes all data to a file, which means that it
/// must make copies of all key material which violates the code base. It violates it because
/// the anticipation is that data stores would securely handle key material. This should not be used
/// in production.
```

**File:** secure/storage/src/on_disk.rs (L64-70)
```rust
    fn write(&self, data: &HashMap<String, Value>) -> Result<(), Error> {
        let contents = serde_json::to_vec(data)?;
        let mut file = File::create(self.temp_path.path())?;
        file.write_all(&contents)?;
        fs::rename(&self.temp_path, &self.file_path)?;
        Ok(())
    }
```

**File:** secure/storage/README.md (L37-42)
```markdown
- `OnDisk`: Similar to InMemory, the OnDisk secure storage implementation provides another
useful testing implementation: an on-disk storage engine, where the storage backend is
implemented using a single file written to local disk. In a similar fashion to the in-memory
storage, on-disk should not be used in production environments as it provides no security
guarantees (e.g., encryption before writing to disk). Moreover, OnDisk storage does not
currently support concurrent data accesses.
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L63-80)
```rust
    fn initialize_keys_and_accounts(
        internal_store: &mut Storage,
        author: Author,
        consensus_private_key: bls12381::PrivateKey,
    ) -> Result<(), Error> {
        let result = internal_store.set(CONSENSUS_KEY, consensus_private_key);
        // Attempting to re-initialize existing storage. This can happen in environments like
        // forge. Rather than be rigid here, leave it up to the developer to detect
        // inconsistencies or why they did not reset storage between rounds. Do not repeat the
        // checks again below, because it is just too strange to have a partially configured
        // storage.
        if let Err(aptos_secure_storage::Error::KeyAlreadyExists(_)) = result {
            warn!("Attempted to re-initialize existing storage");
            return Ok(());
        }

        internal_store.set(OWNER_ACCOUNT, author)?;
        Ok(())
```

**File:** docker/compose/aptos-node/validator.yaml (L11-13)
```yaml
    backend:
      type: "on_disk_storage"
      path: secure-data.json
```

**File:** config/src/config/test_data/validator.yaml (L5-10)
```yaml
        from_storage:
            type: "vault"
            server: "https://127.0.0.1:8200"
            ca_certificate: "/full/path/to/certificate"
            token:
                from_disk: "/full/path/to/token"
```
