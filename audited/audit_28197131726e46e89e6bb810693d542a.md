# Audit Report

## Title
Missing Epoch Validation in CommitDecision Verification Allows Cross-Epoch Replay Attacks

## Summary
The `CommitDecision::verify()` method lacks epoch validation, allowing attackers to replay valid commit decisions from previous epochs if there is validator set overlap between epochs. This bypasses epoch-based consensus safety guarantees and can cause state inconsistencies or consensus violations.

## Finding Description
The consensus pipeline's `CommitDecision` verification flow has a critical gap in epoch validation. When a `CommitDecisionMsg` is received from the network, it undergoes signature verification but does NOT validate that the commit decision belongs to the current epoch. [1](#0-0) 

The `CommitDecision::verify()` method only checks:
1. That the commit info is not "ordered_only"
2. That signatures are cryptographically valid via `verify_signatures()`

Crucially, it does NOT check the epoch field, unlike the consensus observer implementation which explicitly validates epoch matching: [2](#0-1) 

The proper epoch validation pattern exists in `EpochState::verify()`: [3](#0-2) 

However, the BufferManager's verification task uses `CommitDecision::verify()` which bypasses this: [4](#0-3) [5](#0-4) 

**Attack Scenario:**
1. Attacker collects a valid `CommitDecision` from epoch N with legitimate quorum signatures
2. Blockchain advances to epoch N+1 with partial validator set overlap (common in validator rotation)
3. Attacker sends the old `CommitDecision` to nodes in epoch N+1
4. `CommitDecision::verify()` checks signatures against epoch N+1's `ValidatorVerifier`
5. If enough validators from epoch N remain in epoch N+1 with sufficient voting power, signature verification PASSES
6. BufferManager accepts and processes the old commit decision, potentially causing:
   - Acceptance of blocks from wrong epoch
   - Confusion in consensus state tracking
   - Violation of epoch progression invariants [6](#0-5) 

The `verify_signatures()` method only validates cryptographic signatures and quorum voting power—it does not check epoch consistency.

## Impact Explanation
**Severity: Critical to High**

This vulnerability violates the **Consensus Safety** invariant by allowing cross-epoch message replay. The impact includes:

1. **Consensus Safety Violations**: Nodes could accept commit decisions for blocks from incorrect epochs, breaking the fundamental assumption that each epoch operates independently with its own validator set

2. **State Inconsistencies**: If old commit decisions advance buffer items from previous epochs, it could cause state corruption when these decisions reference blocks with outdated state roots

3. **Epoch Transition Attacks**: During epoch boundaries, attackers could flood the network with valid-but-stale commit decisions, causing confusion about which epoch's consensus is active

4. **Potential Chain Splits**: Different nodes might process old commit decisions at different times, leading to temporary inconsistencies in which blocks they consider finalized

Per Aptos Bug Bounty criteria, this qualifies as **Critical Severity** (Consensus/Safety violations) if exploitable to cause actual chain splits or finalization of incorrect blocks, or **High Severity** (Significant protocol violations) if it causes temporary state inconsistencies requiring manual intervention.

## Likelihood Explanation
**Likelihood: Medium to High**

The attack is feasible when:
1. **Validator Set Overlap Exists**: Common during normal validator rotation where many validators continue from epoch N to N+1
2. **Attacker Has Historical Data**: Anyone monitoring the network can capture valid `CommitDecision` messages during normal operation
3. **No Authentication Required**: Any network peer can send consensus messages; no privileged access needed

The attack becomes MORE likely when:
- Validator sets change gradually (high overlap between consecutive epochs)
- The attacker has stored multiple valid commit decisions from recent epochs
- Network conditions allow message delivery during epoch transitions

The vulnerability is NOT prevented by existing defenses because signature verification alone is insufficient—the cryptographic signatures remain valid as long as the signers are still in the validator set.

## Recommendation
Add explicit epoch validation to `CommitDecision::verify()` method to match the pattern used in `EpochState::verify()` and the consensus observer:

```rust
// In consensus/consensus-types/src/pipeline/commit_decision.rs
pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
    ensure!(
        !self.ledger_info.commit_info().is_ordered_only(),
        "Unexpected ordered only commit info"
    );
    
    // ADD THIS: Validate epoch matches
    ensure!(
        validator.epoch() == self.ledger_info.ledger_info().epoch(),
        "CommitDecision has unexpected epoch {}, expected {}",
        self.ledger_info.ledger_info().epoch(),
        validator.epoch()
    );
    
    // We do not need to check the author because as long as the signature tree
    // is valid, the message should be valid.
    self.ledger_info
        .verify_signatures(validator)
        .context("Failed to verify Commit Decision")
}
```

**Alternative approach**: Update `CommitMessage::verify()` to use `EpochState::verify()` instead of calling `CommitDecision::verify()` directly:

```rust
// In consensus/src/pipeline/commit_reliable_broadcast.rs
pub fn verify(&self, sender: Author, epoch_state: &EpochState) -> anyhow::Result<()> {
    match self {
        CommitMessage::Vote(vote) => {
            let _timer = counters::VERIFY_MSG
                .with_label_values(&["commit_vote"])
                .start_timer();
            vote.verify(sender, &epoch_state.verifier)
        },
        CommitMessage::Decision(decision) => {
            let _timer = counters::VERIFY_MSG
                .with_label_values(&["commit_decision"])
                .start_timer();
            epoch_state.verify(decision.ledger_info()) // Use EpochState::verify instead
        },
        CommitMessage::Ack(_) => bail!("Unexpected ack in incoming commit message"),
        CommitMessage::Nack => bail!("Unexpected NACK in incoming commit message"),
    }
}
```

## Proof of Concept
```rust
// This PoC demonstrates the epoch validation gap
// Place in consensus/consensus-types/src/pipeline/commit_decision.rs as a test

#[cfg(test)]
mod tests {
    use super::*;
    use aptos_types::{
        block_info::BlockInfo,
        ledger_info::LedgerInfo,
        validator_signer::ValidatorSigner,
        validator_verifier::{ValidatorVerifier, ValidatorConsensusInfo},
    };

    #[test]
    fn test_cross_epoch_commit_decision_accepted() {
        // Create validator set for epoch 1
        let validator = ValidatorSigner::random([0u8; 32]);
        let validator_infos = vec![ValidatorConsensusInfo::new(
            validator.author(),
            validator.public_key(),
            100,
        )];
        
        let epoch_1_verifier = ValidatorVerifier::new(validator_infos.clone());
        
        // Create a commit decision for epoch 1
        let block_info = BlockInfo::new(
            1, // epoch 1
            0,
            HashValue::random(),
            HashValue::random(),
            0,
            0,
            None,
        );
        let ledger_info = LedgerInfo::new(block_info, HashValue::random());
        let signature = validator.sign(&ledger_info).unwrap();
        
        let mut ledger_info_with_sigs = LedgerInfoWithSignatures::new(
            ledger_info,
            AggregateSignature::empty(),
        );
        ledger_info_with_sigs.add_signature(validator.author(), signature);
        
        let commit_decision = CommitDecision::new(ledger_info_with_sigs);
        
        // Verify with epoch 1 verifier - should pass
        assert!(commit_decision.verify(&epoch_1_verifier).is_ok());
        
        // Create validator set for epoch 2 (same validators, demonstrating overlap)
        let epoch_2_verifier = ValidatorVerifier::new(validator_infos);
        
        // BUG: Verify the epoch 1 commit decision with epoch 2 verifier
        // This SHOULD fail but currently PASSES because epoch is not checked!
        let result = commit_decision.verify(&epoch_2_verifier);
        
        // This assertion demonstrates the vulnerability:
        // The old commit decision from epoch 1 verifies successfully
        // against epoch 2's validator set
        assert!(result.is_ok(), 
            "Cross-epoch commit decision was rejected (vulnerability is fixed)");
        
        println!("VULNERABILITY CONFIRMED: Epoch 1 CommitDecision verified with Epoch 2 validator set");
        println!("Commit decision epoch: {}", commit_decision.epoch());
        println!("Expected failure but got: {:?}", result);
    }
}
```

## Notes
This vulnerability exists because the consensus pipeline and consensus observer evolved separately with different validation patterns. The observer correctly implements epoch checking at line 468 of `consensus_observer.rs`, but this defensive pattern was not backported to the main consensus pipeline's `CommitDecision::verify()` method. [7](#0-6) 

The buffer manager processes commit decisions without additional epoch guards, relying entirely on the verification step to catch invalid messages.

### Citations

**File:** consensus/consensus-types/src/pipeline/commit_decision.rs (L49-59)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        ensure!(
            !self.ledger_info.commit_info().is_ordered_only(),
            "Unexpected ordered only commit info"
        );
        // We do not need to check the author because as long as the signature tree
        // is valid, the message should be valid.
        self.ledger_info
            .verify_signatures(validator)
            .context("Failed to verify Commit Decision")
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L467-482)
```rust
        let epoch_state = self.get_epoch_state();
        if commit_epoch == epoch_state.epoch {
            // Verify the commit decision
            if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify commit decision! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                        commit_decision.proof_block_info(),
                        peer_network_id,
                        error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
                return;
            }
```

**File:** types/src/epoch_state.rs (L41-50)
```rust
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> anyhow::Result<()> {
        ensure!(
            self.epoch == ledger_info.ledger_info().epoch(),
            "LedgerInfo has unexpected epoch {}, expected {}",
            ledger_info.ledger_info().epoch(),
            self.epoch
        );
        ledger_info.verify_signatures(&self.verifier)?;
        Ok(())
    }
```

**File:** consensus/src/pipeline/buffer_manager.rs (L786-811)
```rust
            CommitMessage::Decision(commit_proof) => {
                let target_block_id = commit_proof.ledger_info().commit_info().id();
                info!(
                    "Receive commit decision {}",
                    commit_proof.ledger_info().commit_info()
                );
                let cursor = self
                    .buffer
                    .find_elem_by_key(*self.buffer.head_cursor(), target_block_id);
                if cursor.is_some() {
                    let item = self.buffer.take(&cursor);
                    let new_item = item.try_advance_to_aggregated_with_ledger_info(
                        commit_proof.ledger_info().clone(),
                    );
                    let aggregated = new_item.is_aggregated();
                    self.buffer.set(&cursor, new_item);

                    reply_ack(protocol, response_sender);
                    if aggregated {
                        return Some(target_block_id);
                    }
                } else if self.try_add_pending_commit_proof(commit_proof.into_inner()) {
                    reply_ack(protocol, response_sender);
                } else {
                    reply_nack(protocol, response_sender); // TODO: send_commit_proof() doesn't care about the response and this should be direct send not RPC
                }
```

**File:** consensus/src/pipeline/buffer_manager.rs (L919-934)
```rust
        spawn_named!("buffer manager verification", async move {
            while let Some((sender, commit_msg)) = commit_msg_rx.next().await {
                let tx = verified_commit_msg_tx.clone();
                let epoch_state_clone = epoch_state.clone();
                bounded_executor
                    .spawn(async move {
                        match commit_msg.req.verify(sender, &epoch_state_clone.verifier) {
                            Ok(_) => {
                                let _ = tx.unbounded_send(commit_msg);
                            },
                            Err(e) => warn!("Invalid commit message: {}", e),
                        }
                    })
                    .await;
            }
        });
```

**File:** consensus/src/pipeline/commit_reliable_broadcast.rs (L45-50)
```rust
            CommitMessage::Decision(decision) => {
                let _timer = counters::VERIFY_MSG
                    .with_label_values(&["commit_decision"])
                    .start_timer();
                decision.verify(verifier)
            },
```

**File:** types/src/ledger_info.rs (L303-308)
```rust
    pub fn verify_signatures(
        &self,
        validator: &ValidatorVerifier,
    ) -> ::std::result::Result<(), VerifyError> {
        validator.verify_multi_signatures(self.ledger_info(), &self.signatures)
    }
```
