# Audit Report

## Title
Incorrect Multisig Address Prediction in CLI Due to Hardcoded Sequence Number

## Summary
The CLI's vanity multisig key generation tool displays an incorrect multisig account address by assuming sequence number 0, while the actual on-chain multisig account creation uses the account's current sequence number. This mismatch can lead users to send funds to an address that differs from the actual multisig account address, resulting in inaccessible or lost funds.

## Finding Description

The Aptos CLI provides a `--vanity-multisig` flag that generates a private key for creating a multisig account with a vanity address prefix. When this feature is used, the CLI predicts and displays the future multisig account address.

**The vulnerability exists in two locations:**

1. In the key generation display logic: [1](#0-0) 

2. In the vanity address mining algorithm: [2](#0-1) 

Both locations hardcode the sequence number as `0` when calculating the multisig address.

**However, the on-chain implementation uses the account's CURRENT sequence number:**

The multisig account creation function retrieves the actual sequence number at execution time: [3](#0-2) 

The view function for predicting the next multisig address also uses the current sequence number: [4](#0-3) 

**Root Cause:**

Multisig account addresses are derived using the formula:
```
multisig_address = create_resource_address(creator, DOMAIN_SEPARATOR + BCS(sequence_number))
```

The implementation is defined here: [5](#0-4) 

The CLI assumes sequence number 0, but if the bootstrapper account sends ANY transaction before creating the multisig (incrementing its sequence number), the actual multisig will be created at a different address.

**Attack Scenario:**

1. User runs: `aptos key generate --vanity-prefix 0xaceface --vanity-multisig`
2. CLI displays: `Multisig Account Address: 0xaceface123...` (calculated with seq num = 0)
3. User sends a transaction from the bootstrapper account to fund it (sequence number → 1)
4. User creates the multisig account via `create_with_owners_then_remove_bootstrapper`
5. Actual multisig is created at `0xdifferent456...` (calculated with seq num = 1)
6. User (or others) send funds to the CLI-predicted address `0xaceface123...`
7. **Funds are inaccessible** - they went to a non-existent or wrong account

## Impact Explanation

This vulnerability falls under **Medium Severity** per the Aptos bug bounty program criteria:
- **"Limited funds loss or manipulation"**: Users can lose funds by sending them to the incorrect predicted address
- **"State inconsistencies requiring intervention"**: Funds end up at addresses that don't correspond to expected multisig accounts

The impact is limited because:
- Requires user error (sending transactions before creating the multisig)
- Funds are not permanently destroyed (theoretically recoverable if the user can recreate the exact sequence number scenario)
- Does not affect consensus, validator operations, or network-wide security

However, the practical impact is significant because:
- The CLI explicitly encourages this workflow for vanity addresses
- Users may naturally want to fund the bootstrapper account before creating the multisig
- No warning is provided about this requirement
- Recovery requires understanding the complex sequence number mechanism

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

This vulnerability is likely to occur in production because:

1. **Natural User Behavior**: Users generating vanity multisig addresses would naturally:
   - Generate the key
   - Fund the bootstrapper account (incrementing sequence number)
   - Create the multisig account
   - Send funds to the predicted address

2. **No Warnings**: The CLI provides no warning that the bootstrapper account must have sequence number 0 when creating the multisig

3. **Explicit Documentation**: The code comments state the assumption: [6](#0-5) 

But this critical requirement is not surfaced to users in the CLI output or error messages.

## Recommendation

**Fix Option 1: Query Sequence Number at Display Time (Recommended)**

Modify the CLI to query the current sequence number of the account and use it for prediction. However, this requires an active connection to the blockchain and the account must already exist.

**Fix Option 2: Add Warning and Validation**

Add a clear warning to the CLI output:
```rust
if self.vanity_multisig {
    let multisig_account_address =
        create_multisig_account_address(account_address, 0);
    result_map.insert(
        "Multisig Account Address:",
        PathBuf::from(multisig_account_address.to_hex_literal()),
    );
    result_map.insert(
        "⚠️ WARNING:",
        PathBuf::from("This address is only valid if the account's FIRST transaction creates the multisig. Do NOT send transactions from this account before creating the multisig."),
    );
}
```

**Fix Option 3: Document Correct Workflow**

Add validation when creating the multisig to check if the sequence number matches expectations:
```move
public entry fun create_with_owners_then_remove_bootstrapper(
    bootstrapper: &signer,
    owners: vector<address>,
    num_signatures_required: u64,
    metadata_keys: vector<String>,
    metadata_values: vector<vector<u8>>,
) acquires MultisigAccount {
    let bootstrapper_address = address_of(bootstrapper);
    let expected_sequence = account::get_sequence_number(bootstrapper_address);
    
    // Warning if sequence number is not 0
    assert!(
        expected_sequence == 0,
        error::invalid_state(ESEQUENCE_NUMBER_NOT_ZERO_FOR_VANITY)
    );
    
    // ... rest of function
}
```

## Proof of Concept

**Reproduction Steps:**

1. Generate a vanity multisig key:
```bash
aptos key generate --vanity-prefix 0xace --vanity-multisig --output-file vanity_key
```
Output shows: `Multisig Account Address: 0xace12345...` (using seq num 0)

2. Create the account on-chain and send a transaction to fund it:
```bash
aptos account fund-with-faucet --account <account_from_vanity_key>
# This increments sequence number to 1
```

3. Create the multisig account:
```bash
aptos multisig create-with-owners-then-remove-bootstrapper \
  --multisig-address <bootstrapper_account> \
  --owners 0xowner1,0xowner2 \
  --num-signatures-required 2
```

4. Check the actual multisig address created - it will be different:
```bash
aptos account list --account <bootstrapper_account>
# The actual multisig address will use sequence number 1, not 0
# It will be 0xdifferent678... instead of 0xace12345...
```

5. Any funds sent to `0xace12345...` (the CLI prediction) are now inaccessible or at the wrong account.

**Verification:**

The address derivation difference can be verified:
- `create_multisig_account_address(account, 0)` → produces address A
- `create_multisig_account_address(account, 1)` → produces address B
- A ≠ B (different SHA3-256 hashes due to different sequence numbers in the seed)

**Notes**

This vulnerability demonstrates a critical disconnect between CLI tooling and on-chain execution logic. The issue is particularly insidious because:

1. **The CLI comment acknowledges the assumption** about sequence number 0 but doesn't enforce or validate it
2. **The vanity generation function** explicitly mines for addresses assuming sequence number 0
3. **The on-chain implementation correctly uses current sequence number**, creating the mismatch
4. **No runtime validation** exists to warn users when the assumption is violated

The fix should either:
- Make the CLI dynamic (query sequence number at display time)
- Add explicit warnings about the sequence number requirement
- Add on-chain validation to abort if sequence number ≠ 0 for vanity multisig creation
- Provide a recovery mechanism to recreate addresses with arbitrary sequence numbers

This issue affects user experience and fund security, making it a valid **Medium severity** vulnerability per the Aptos bug bounty program.

### Citations

**File:** crates/aptos/src/op/key.rs (L250-251)
```rust
                        let multisig_account_address =
                            create_multisig_account_address(account_address, 0);
```

**File:** crates/aptos/src/common/utils.rs (L361-362)
```rust
/// For a multisig account, this function generates private keys until finding one that can create
/// a multisig account with the given vanity prefix as its first transaction (sequence number 0).
```

**File:** crates/aptos/src/common/utils.rs (L391-391)
```rust
            account_address = create_multisig_account_address(account_address, 0)
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L452-455)
```text
    public fun get_next_multisig_account_address(creator: address): address {
        let owner_nonce = account::get_sequence_number(creator);
        create_resource_address(&creator, create_multisig_account_seed(to_bytes(&owner_nonce)))
    }
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L1327-1330)
```text
    fun create_multisig_account(owner: &signer): (signer, SignerCapability) {
        let owner_nonce = account::get_sequence_number(address_of(owner));
        let (multisig_signer, multisig_signer_cap) =
            account::create_resource_account(owner, create_multisig_account_seed(to_bytes(&owner_nonce)));
```

**File:** types/src/account_address.rs (L238-246)
```rust
pub fn create_multisig_account_address(
    creator: AccountAddress,
    creator_nonce: u64,
) -> AccountAddress {
    let mut full_seed = vec![];
    full_seed.extend(MULTISIG_ACCOUNT_DOMAIN_SEPARATOR);
    full_seed.extend(bcs::to_bytes(&creator_nonce).unwrap());
    create_resource_address(creator, &full_seed)
}
```
