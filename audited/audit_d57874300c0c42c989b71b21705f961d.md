# Audit Report

## Title
Pre-Gas Signature Verification DoS via MAX_NUM_OF_SIGS Exploitation

## Summary
An attacker can submit transactions with exactly 32 signatures to force validators to perform expensive cryptographic verification before any gas metering occurs, causing validator CPU exhaustion and network slowdown. The vulnerability exists because signature verification happens before gas charging, allowing attackers to consume computational resources at no cost.

## Finding Description

The Aptos blockchain enforces a maximum of 32 signatures per transaction via the `MAX_NUM_OF_SIGS` constant. [1](#0-0) 

During transaction validation, the authenticator's `verify()` method counts all signatures across the sender and secondary signers, rejecting transactions that exceed this limit. [2](#0-1) 

The critical vulnerability lies in the validation sequence. When validators process incoming transactions, they call `validate_transaction()` which performs signature verification via `transaction.check_signature()` BEFORE creating the gas meter. [3](#0-2) 

The gas meter is only instantiated after signature verification completes. [4](#0-3) 

This creates an attack vector where malicious actors can structure transactions to maximize free signature verification work:

**Attack Construction:**
1. Create a FeePayer transaction with multiple MultiEd25519 authenticators
2. Distribute 32 signatures across: sender (10 sigs) + secondary signer 1 (10 sigs) + secondary signer 2 (10 sigs) + fee payer (2 sigs)
3. Each signature requires cryptographic verification (Ed25519: ~50-100 microseconds per signature)
4. Total free CPU work per transaction: ~1.6-3.2 milliseconds Ã— number of CPU cores

**Exploitation Flow:**
1. Attacker submits numerous transactions with 32 signatures each
2. Transactions enter mempool validation pipeline via `validate_and_add_transactions` [5](#0-4) 
3. Validation executes in parallel across all CPU cores using VALIDATION_POOL [6](#0-5) 
4. All 32 signatures are cryptographically verified before gas charging
5. Validator CPU resources are exhausted, slowing transaction processing
6. Even invalid signatures consume full verification cost before being detected

This violates the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." Signature verification bypasses gas limits entirely.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos Bug Bounty criteria, specifically "Validator node slowdowns."

**Quantified Impact:**
- Each malicious transaction forces 32 signature verifications pre-gas (total ~1.6-3.2ms CPU time per transaction)
- An attacker submitting 1,000 such transactions consumes ~3.2 seconds of aggregate CPU time across all cores
- This slows down legitimate transaction processing and validator responsiveness
- All network validators are affected simultaneously, degrading network throughput
- The attack can be sustained as long as the attacker can submit transactions within network and mempool limits

While mempool capacity limits eventually prevent unbounded resource consumption, the damage occurs during the validation phase before these limits are checked. The parallel validation using VALIDATION_POOL means all CPU cores are simultaneously engaged in expensive cryptographic operations for attacker transactions.

## Likelihood Explanation

This vulnerability has **HIGH** likelihood of exploitation:

**Attacker Requirements:**
- Minimal: Only requires ability to submit transactions to validator nodes
- No special privileges, stake, or validator access needed
- Can be executed by any network participant or direct client connection
- Attack transactions are structurally valid and pass basic filters

**Exploitation Complexity:**
- LOW: Straightforward to construct transactions with 32 signatures using standard transaction APIs
- MultiEd25519 and FeePayer authenticators are well-documented features
- No cryptographic sophistication required beyond generating key pairs
- Attacks can be automated and scaled easily

**Detection Difficulty:**
- Malicious transactions appear valid until signature verification completes
- No distinguish between legitimate multi-signature transactions and attack transactions
- Existing monitoring may not detect this CPU exhaustion pattern

## Recommendation

Implement gas charging for signature verification in the validation phase, or impose stricter pre-validation limits on signature counts:

**Solution 1: Pre-Gas Signature Verification Fee**
```rust
// In aptos_vm.rs validate_transaction()
// Charge a fixed validation fee before signature verification
let sig_count = transaction.authenticator_ref().sender().number_of_signatures()
    + transaction.authenticator_ref()
        .secondary_signers()
        .iter()
        .map(|auth| auth.number_of_signatures())
        .sum::<usize>();

// Reject transactions with excessive signatures
const MAX_FREE_SIGNATURES: usize = 4;
if sig_count > MAX_FREE_SIGNATURES {
    return VMValidatorResult::error(StatusCode::MAX_SIGNATURES_EXCEEDED);
}

// OR charge proportional validation fee deducted from sender balance
// before gas meter creation
```

**Solution 2: Reduce MAX_NUM_OF_SIGS**
Lower the signature limit to reduce attack surface:
```rust
// In types/src/transaction/authenticator.rs
pub const MAX_NUM_OF_SIGS: usize = 8; // Reduced from 32
```

**Solution 3: Rate Limiting Per Sender**
Track signature verification work per sender account and throttle high-cost submissions:
```rust
// Add to mempool validation logic
// Track cumulative signature count per sender over time window
// Reject if sender exceeds threshold (e.g., 100 signatures per minute)
```

## Proof of Concept

```rust
#[test]
fn test_dos_via_max_signatures() {
    use aptos_crypto::{
        ed25519::{Ed25519PrivateKey, Ed25519PublicKey},
        multi_ed25519::{MultiEd25519PublicKey, MultiEd25519Signature},
        PrivateKey, Uniform,
    };
    use aptos_types::transaction::{
        authenticator::{AccountAuthenticator, TransactionAuthenticator},
        RawTransaction, SignedTransaction,
    };
    use std::time::Instant;

    // Create 32 key pairs for maximum signatures
    let mut private_keys = vec![];
    let mut public_keys = vec![];
    for _ in 0..32 {
        let priv_key = Ed25519PrivateKey::generate_for_testing();
        let pub_key = priv_key.public_key();
        private_keys.push(priv_key);
        public_keys.push(pub_key);
    }

    // Create MultiEd25519 with 32-of-32 threshold
    let multi_public_key = MultiEd25519PublicKey::new(public_keys.clone(), 32).unwrap();

    // Create test transaction
    let sender = AccountAddress::random();
    let raw_txn = RawTransaction::new(
        sender,
        0,
        TransactionPayload::Script(Script::new(vec![], vec![], vec![])),
        100_000,
        1,
        u64::MAX,
        ChainId::test(),
    );

    // Sign with all 32 keys
    let mut signatures = vec![];
    for priv_key in &private_keys {
        signatures.push(priv_key.sign(&raw_txn).unwrap());
    }
    let multi_signature = MultiEd25519Signature::new(signatures).unwrap();

    // Create transaction with 32 signatures
    let authenticator = TransactionAuthenticator::multi_ed25519(
        multi_public_key,
        multi_signature,
    );
    let signed_txn = SignedTransaction::new(raw_txn, authenticator);

    // Measure verification time (happens before gas charging)
    let start = Instant::now();
    let result = signed_txn.verify_signature();
    let elapsed = start.elapsed();

    println!("Signature verification time for 32 signatures: {:?}", elapsed);
    println!("Verification result: {:?}", result);

    // Demonstrate that this verification happened WITHOUT gas charging
    // by showing the validator.validate_transaction() code path
    assert!(elapsed.as_millis() > 1, "Verification should take measurable time");
    
    // An attacker submitting 1000 such transactions would force:
    // 1000 * elapsed time of free cryptographic work on validators
}
```

## Notes

This vulnerability demonstrates a fundamental trade-off in blockchain transaction validation: signature verification must occur before gas charging to prevent unpaid transaction execution, but this creates an attack surface for computational DoS. The current 32-signature limit was likely chosen to balance multi-signature use cases with DoS prevention, but in practice allows significant free computation per transaction.

The parallel validation architecture (VALIDATION_POOL) amplifies the impact by engaging all CPU cores simultaneously, though it also provides natural rate limiting through core saturation. The vulnerability affects all network validators equally, so it doesn't create consensus divergence, but does degrade overall network performance.

Mitigation requires either reducing the signature limit, implementing pre-gas validation fees, or adding sender-based rate limiting on signature verification work.

### Citations

**File:** types/src/transaction/authenticator.rs (L32-34)
```rust
/// Maximum number of signatures supported in `TransactionAuthenticator`,
/// across all `AccountAuthenticator`s included.
pub const MAX_NUM_OF_SIGS: usize = 32;
```

**File:** types/src/transaction/authenticator.rs (L160-169)
```rust
    pub fn verify(&self, raw_txn: &RawTransaction) -> Result<()> {
        let num_sigs: usize = self.sender().number_of_signatures()
            + self
                .secondary_signers()
                .iter()
                .map(|auth| auth.number_of_signatures())
                .sum::<usize>();
        if num_sigs > MAX_NUM_OF_SIGS {
            return Err(Error::new(AuthenticationError::MaxSignaturesExceeded));
        }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3232-3237)
```rust
        let txn = match transaction.check_signature() {
            Ok(t) => t,
            _ => {
                return VMValidatorResult::error(StatusCode::INVALID_SIGNATURE);
            },
        };
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3271-3278)
```rust
        let mut gas_meter = make_prod_gas_meter(
            self.gas_feature_version(),
            vm_params,
            storage_gas_params,
            is_approved_gov_script,
            initial_balance,
            &NoopBlockSynchronizationKillSwitch {},
        );
```

**File:** mempool/src/shared_mempool/tasks.rs (L490-503)
```rust
    let validation_results = VALIDATION_POOL.install(|| {
        transactions
            .par_iter()
            .map(|t| {
                let result = smp.validator.read().validate_transaction(t.0.clone());
                // Pre-compute the hash and length if the transaction is valid, before locking mempool
                if result.is_ok() {
                    t.0.committed_hash();
                    t.0.txn_bytes_len();
                }
                result
            })
            .collect::<Vec<_>>()
    });
```

**File:** mempool/src/thread_pool.rs (L15-20)
```rust
pub(crate) static VALIDATION_POOL: Lazy<rayon::ThreadPool> = Lazy::new(|| {
    rayon::ThreadPoolBuilder::new()
        .thread_name(|index| format!("mempool_vali_{}", index))
        .build()
        .unwrap()
});
```
