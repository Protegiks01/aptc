# Audit Report

## Title
Error Code Information Loss in Prologue Validation Masks Permissioned Gas Security Failures

## Summary
The assert builtin properly propagates error codes to the VM in normal execution, but a critical mismatch between Move error categorization and Rust error handling in the prologue causes specific error information loss for the `PROLOGUE_PERMISSIONED_GAS_LIMIT_INSUFFICIENT` check. This masks security failures in transaction validation, making attack detection and monitoring significantly harder.

## Finding Description

The `assert!` macro in Move is expanded into conditional abort logic that propagates error codes through the VM execution stack. [1](#0-0) 

During normal transaction execution, abort error codes are correctly preserved through the entire path: the `Abort` instruction pops the error code from the operand stack and creates a `PartialVMError` with the code in the `sub_status` field. [2](#0-1) 

The error is then converted to `VMStatus::MoveAbort` with the code preserved. [3](#0-2) 

Through `keep_or_discard`, the error code remains in the final transaction status. [4](#0-3) 

**However, prologue/epilogue errors undergo special conversion that causes information loss.**

The `transaction_validation` module defines a permissioned gas limit check that uses error code 1011 with the `permission_denied` category: [5](#0-4) [6](#0-5) 

The Move `error::permission_denied()` function prepends category byte `0x5` (PERMISSION_DENIED) to the error code, resulting in error code `(0x5 << 16) | 1011`.

The Rust prologue error converter uses `error_split` to extract the category and reason: [7](#0-6) 

The conversion logic expects specific category-reason pairs. It defines constant `EINSUFFICIENT_BALANCE_FOR_REQUIRED_DEPOSIT = 1011` but expects it with category `INVALID_STATE (0x3)`: [8](#0-7) [9](#0-8) 

There is **no handler** for the actual error `(PERMISSION_DENIED=0x5, 1011)` that the Move code generates. When this error is raised, it falls through to the default case: [10](#0-9) 

This converts the error to `UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION` with **`sub_status: None`**, completely losing the specific error code. The original error code is only preserved in the log message string.

Since `UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION` (value 2015) is in the `InvariantViolation` range (2000-2999): [11](#0-10) [12](#0-11) 

The `keep_or_discard` function discards the transaction: [13](#0-12) 

**Impact:** When a permissioned signer exceeds their gas limit, the specific error code indicating this security check failure is lost. Only a generic "unexpected error" is returned, making forensic analysis, attack pattern detection, and security monitoring ineffective.

## Impact Explanation

This is a **Medium severity** vulnerability per Aptos bug bounty criteria:

1. **State inconsistencies requiring intervention**: While transactions are correctly rejected, the loss of specific error codes creates an information asymmetry that requires manual log analysis to understand security failures.

2. **Security monitoring failure**: Automated systems monitoring for specific prologue error codes to detect attack patterns will miss permissioned gas limit violations entirely, as they only see generic `UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION` errors.

3. **Forensic analysis impaired**: During incident response, investigators cannot programmatically distinguish between different types of prologue failures, making root cause analysis significantly harder.

4. **Attack pattern masking**: An attacker attempting to abuse permissioned gas limits will generate generic errors instead of specific ones, masking their attack pattern and evading detection systems.

The permissioned gas feature is a security mechanism for controlled gas payment where master signers grant specific gas allowances to permissioned signers. Failures in this system should be clearly observable for security auditing.

## Likelihood Explanation

**High likelihood of occurrence** because:

1. **Active code path**: The permissioned gas limit check is actively used in `prologue_common` for every transaction with a gas payer that has permission grants.

2. **No special privileges required**: Any user can create permissioned signers and attempt to exceed their gas limits, triggering the vulnerability.

3. **Already deployed**: The code mismatch exists in production, so every transaction that triggers this check loses error information.

4. **No mitigation**: There is no fallback mechanism to preserve the error code when the handler is missing.

## Recommendation

**Fix the error code mismatch** by adding the missing handler in `convert_prologue_error`: [14](#0-13) 

Add after line 155 (before the default case):

```rust
(PERMISSION_DENIED, PROLOGUE_PERMISSIONED_GAS_LIMIT_INSUFFICIENT) => {
    StatusCode::INSUFFICIENT_BALANCE_FOR_REQUIRED_DEPOSIT // or create new StatusCode
},
```

Where `PROLOGUE_PERMISSIONED_GAS_LIMIT_INSUFFICIENT = 1011` should be defined: [15](#0-14) 

**Better long-term fix**: Create a dedicated `StatusCode` for this error and ensure all Move prologue error codes have corresponding Rust handlers with proper category matching.

## Proof of Concept

Move test demonstrating error information loss:

```move
#[test(framework = @aptos_framework, sender = @0x123, gas_payer = @0x456)]
#[expected_failure(abort_code=0x50000 + 1011)] // This will NOT match due to conversion
fun test_permissioned_gas_limit_error_loss(
    framework: &signer,
    sender: signer,
    gas_payer: signer,
) {
    // Setup: Create accounts and grant limited gas permission
    account::create_account_for_test(@0x123);
    account::create_account_for_test(@0x456);
    
    // Grant only 1000 octas of gas permission
    transaction_validation::grant_gas_permission(&gas_payer, &sender, 1000);
    
    // Attempt transaction requiring 10000 octas
    // This should abort with PROLOGUE_PERMISSIONED_GAS_LIMIT_INSUFFICIENT
    // But the error code will be lost in Rust conversion
    transaction_validation::prologue_common(
        &sender,
        &gas_payer,
        ReplayProtector::SequenceNumber(0),
        option::some(x"dead"),
        100, // gas price
        100, // max gas units -> 10000 octas total
        99999999999,
        1,
        false,
    );
}
```

The test shows that when this error is raised, the Rust side will convert it to `UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION` instead of preserving the specific error code, breaking security monitoring and incident response capabilities.

### Citations

**File:** third_party/move/move-model/src/builder/macros.rs (L28-58)
```rust
    fn expand_assert(&self, loc: Loc, args: &Spanned<Vec<EA::Exp>>) -> EA::Exp_ {
        let (cond, abort_code) = match args.value.len() {
            1 => {
                self.check_language_version(
                    &self.to_loc(&loc),
                    "single-argument `assert!` macro",
                    LanguageVersion::V2_0,
                );
                (
                    args.value[0].clone(),
                    sp(
                        loc,
                        EA::Exp_::Value(sp(loc, EA::Value_::U64(UNSPECIFIED_ABORT_CODE))),
                    ),
                )
            },
            2 => (args.value[0].clone(), args.value[1].clone()),
            _ => {
                self.error(
                    &self.to_loc(&args.loc),
                    "assert macro must have one or two arguments",
                );
                return EA::Exp_::UnresolvedError;
            },
        };
        EA::Exp_::IfElse(
            Box::new(cond),
            Box::new(sp(loc, EA::Exp_::Unit { trailing: false })),
            Box::new(sp(loc, EA::Exp_::Abort(Box::new(abort_code)))),
        )
    }
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L2736-2758)
```rust
                    Instruction::Abort => {
                        gas_meter.charge_simple_instr(S::Abort)?;
                        let error_code = interpreter.operand_stack.pop_as::<u64>()?;
                        if is_tracing_for!(TraceCategory::Abort(error_code)) {
                            let mut str = String::new();
                            interpreter.debug_print_stack_trace(
                                &mut str,
                                interpreter.loader.runtime_environment(),
                            )?;
                            eprintln!("trace abort({}): {}", error_code, str);
                        }

                        // Important: do not attach a message here.
                        // We rely on the presence of an error message to distinguish
                        // aborts with explicit messages (see below) from those without.
                        let error =
                            PartialVMError::new(StatusCode::ABORTED).with_sub_status(error_code);

                        // Before returning an abort error, ensure the instruction is recorded in
                        // the trace, so the trace is full.
                        trace_recorder.record_successful_instruction(instruction);
                        return Err(error);
                    },
```

**File:** third_party/move/move-binary-format/src/errors.rs (L107-116)
```rust
            (StatusCode::ABORTED, Some(code), Location::Script) => VMStatus::MoveAbort {
                location: vm_status::AbortLocation::Script,
                code,
                message,
            },
            (StatusCode::ABORTED, Some(code), Location::Module(id)) => VMStatus::MoveAbort {
                location: vm_status::AbortLocation::Module(id),
                code,
                message,
            },
```

**File:** third_party/move/move-core/types/src/vm_status.rs (L211-223)
```rust
            VMStatus::MoveAbort {
                location,
                code,
                message,
            } => Ok(KeptVMStatus::MoveAbort {
                location,
                code,
                message: if abort_messages_enabled {
                    message
                } else {
                    None
                },
            }),
```

**File:** third_party/move/move-core/types/src/vm_status.rs (L297-299)
```rust
                    StatusType::Validation => Err(code),
                    // If the VM encountered an invalid internal state, we should discard the transaction.
                    StatusType::InvariantViolation => Err(code),
```

**File:** third_party/move/move-core/types/src/vm_status.rs (L846-846)
```rust
    UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION = 2015,
```

**File:** third_party/move/move-core/types/src/vm_status.rs (L995-999)
```rust
        if major_status_number >= INVARIANT_VIOLATION_STATUS_MIN_CODE
            && major_status_number <= INVARIANT_VIOLATION_STATUS_MAX_CODE
        {
            return StatusType::InvariantViolation;
        }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L72-72)
```text
    const PROLOGUE_PERMISSIONED_GAS_LIMIT_INSUFFICIENT: u64 = 1011;
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L193-200)
```text
            assert!(
                permissioned_signer::check_permission_capacity_above(
                    gas_payer,
                    (max_transaction_fee as u256),
                    GasPermission {}
                ),
                error::permission_denied(PROLOGUE_PERMISSIONED_GAS_LIMIT_INSUFFICIENT)
            );
```

**File:** aptos-move/aptos-vm/src/errors.rs (L38-38)
```rust
pub const EINSUFFICIENT_BALANCE_FOR_REQUIRED_DEPOSIT: u64 = 1011;
```

**File:** aptos-move/aptos-vm/src/errors.rs (L57-61)
```rust
const INVALID_ARGUMENT: u8 = 0x1;
const LIMIT_EXCEEDED: u8 = 0x2;
const INVALID_STATE: u8 = 0x3;
const PERMISSION_DENIED: u8 = 0x5;
const NOT_FOUND: u8 = 0x6;
```

**File:** aptos-move/aptos-vm/src/errors.rs (L63-67)
```rust
fn error_split(code: u64) -> (u8, u64) {
    let reason = code & 0xFFFF;
    let category = ((code >> 16) & 0xFF) as u8;
    (category, reason)
}
```

**File:** aptos-move/aptos-vm/src/errors.rs (L124-155)
```rust
            let new_major_status = match error_split(code) {
                // Invalid authentication key
                (INVALID_ARGUMENT, EBAD_ACCOUNT_AUTHENTICATION_KEY) => StatusCode::INVALID_AUTH_KEY,
                // Sequence number too old
                (INVALID_ARGUMENT, ESEQUENCE_NUMBER_TOO_OLD) => StatusCode::SEQUENCE_NUMBER_TOO_OLD,
                // Sequence number too new
                (INVALID_ARGUMENT, ESEQUENCE_NUMBER_TOO_NEW) => StatusCode::SEQUENCE_NUMBER_TOO_NEW,
                // Sequence number too new
                (INVALID_ARGUMENT, EACCOUNT_DOES_NOT_EXIST) => {
                    StatusCode::SENDING_ACCOUNT_DOES_NOT_EXIST
                },
                // Can't pay for transaction gas deposit/fee
                (INVALID_ARGUMENT, ECANT_PAY_GAS_DEPOSIT) => {
                    StatusCode::INSUFFICIENT_BALANCE_FOR_TRANSACTION_FEE
                },
                (INVALID_ARGUMENT, ETRANSACTION_EXPIRED) => StatusCode::TRANSACTION_EXPIRED,
                (INVALID_ARGUMENT, EBAD_CHAIN_ID) => StatusCode::BAD_CHAIN_ID,
                // Sequence number will overflow
                (LIMIT_EXCEEDED, ESEQUENCE_NUMBER_TOO_BIG) => StatusCode::SEQUENCE_NUMBER_TOO_BIG,
                (INVALID_ARGUMENT, ESECONDARY_KEYS_ADDRESSES_COUNT_MISMATCH) => {
                    StatusCode::SECONDARY_KEYS_ADDRESSES_COUNT_MISMATCH
                },
                (INVALID_ARGUMENT, EGAS_PAYER_ACCOUNT_MISSING) => {
                    StatusCode::GAS_PAYER_ACCOUNT_MISSING
                },
                (INVALID_STATE, EINSUFFICIENT_BALANCE_FOR_REQUIRED_DEPOSIT) => {
                    StatusCode::INSUFFICIENT_BALANCE_FOR_REQUIRED_DEPOSIT
                },
                (INVALID_ARGUMENT, ETRANSACTION_EXPIRATION_TOO_FAR_IN_FUTURE) => {
                    StatusCode::TRANSACTION_EXPIRATION_TOO_FAR_IN_FUTURE
                },
                (INVALID_ARGUMENT, ENONCE_ALREADY_USED) => StatusCode::NONCE_ALREADY_USED,
```

**File:** aptos-move/aptos-vm/src/errors.rs (L156-171)
```rust
                (category, reason) => {
                    let mut err_msg = format!(
                        "[aptos_vm] Unexpected prologue Move abort: {:?}::{:?} (Category: {:?} Reason: {:?})",
                        location, code, category, reason
                    );
                    if let Some(abort_msg) = message {
                        err_msg.push_str(" Message: ");
                        err_msg.push_str(&abort_msg);
                    }
                    speculative_error!(log_context, err_msg.clone());
                    return Err(VMStatus::Error {
                        status_code: StatusCode::UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION,
                        sub_status: None,
                        message: Some(err_msg),
                    });
                },
```
