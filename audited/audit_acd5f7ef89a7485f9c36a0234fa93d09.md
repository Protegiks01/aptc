# Audit Report

## Title
Protocol Support Bypass in Peer Message Handling - Malicious Peers Can Send Unsupported Protocol Messages

## Summary
A malicious peer can advertise support for specific protocols during the handshake but then send messages using different protocols that it did not advertise support for. The receiving node does not validate that incoming messages match the negotiated `application_protocols`, allowing the bypass of protocol filtering logic in `get_connected_supported_peers()`.

## Finding Description

The Aptos network layer implements a handshake protocol where peers negotiate which application protocols they mutually support. This negotiated set is stored in `ConnectionMetadata.application_protocols` and is used by `PeersAndMetadata::get_connected_supported_peers()` to filter peers based on protocol support. [1](#0-0) 

However, when a peer receives inbound messages, the `Peer::handle_inbound_network_message()` function does NOT validate that the `protocol_id` in the received message is within the negotiated `application_protocols`. Instead, it only checks if a local handler exists for that protocol. [2](#0-1) 

For RPC requests, the same validation gap exists. [3](#0-2) 

**Attack Flow:**

1. During handshake, the attacker peer claims to support only `ProtocolId::HealthCheckerRpc` [4](#0-3) 

2. The honest node's applications use `get_available_peers()` to find peers supporting specific protocols (e.g., `StorageServiceRpc` for state sync). The attacker peer is excluded from the list since it didn't advertise support. [5](#0-4) 

3. Despite not advertising support for `StorageServiceRpc`, the attacker sends messages with `protocol_id = StorageServiceRpc`.

4. The honest node's `Peer` actor receives the message and checks only if `upstream_handlers` contains an entry for `StorageServiceRpc` - it does NOT verify this protocol was negotiated. [6](#0-5) 

5. If a handler exists, the message is processed, bypassing the peer selection logic entirely.

This breaks the trust assumption that peers will only send messages for protocols they advertised support for during the handshake. Applications rely on `get_connected_supported_peers()` to filter peers, but this filtering is meaningless if peers can send arbitrary protocol messages.

## Impact Explanation

**Medium Severity** - This qualifies as "State inconsistencies requiring intervention" per the Aptos bug bounty criteria:

1. **Protocol Trust Boundary Violation**: The handshake protocol establishes which protocols peers support. Applications use this information to make peer selection decisions. Bypassing this breaks a fundamental network layer invariant.

2. **Resource Exhaustion**: Malicious peers can trigger expensive protocol handlers (e.g., storage service requests, consensus observer messages) even when they shouldn't have access to those protocols, potentially causing targeted DoS.

3. **Application Logic Confusion**: Applications like state sync use `get_available_peers()` to find suitable peers. [7](#0-6)  If unexpected protocol messages arrive from peers that weren't supposed to support those protocols, it can cause application-level inconsistencies.

4. **Bypassing Network Policy**: Node operators may configure their nodes to only accept certain protocols from certain peer types. This vulnerability allows attackers to bypass those restrictions.

This does not directly threaten consensus safety or fund security, but it violates network protocol guarantees and can lead to service degradation and unexpected behavior.

## Likelihood Explanation

**High Likelihood:**

- **Trivial to Exploit**: An attacker simply needs to send a `DirectSendMsg` or `RpcRequest` with any `protocol_id` they want, regardless of what they advertised during handshake.

- **No Special Privileges Required**: Any peer that can connect to the network can perform this attack. No validator privileges or cryptographic keys are needed.

- **No Detection**: The current implementation has no logging or detection when a peer sends messages for unsupported protocols - they are simply processed if a handler exists.

- **Widespread Impact**: This affects all protocol message handling, not just a specific subsystem.

## Recommendation

Add validation in `Peer::handle_inbound_network_message()` to verify that the `protocol_id` in received messages matches the negotiated `connection_metadata.application_protocols`:

```rust
// In network/framework/src/peer/mod.rs, in handle_inbound_network_message()

// For DirectSendMsg handling:
NetworkMessage::DirectSendMsg(direct) => {
    // ADD THIS VALIDATION:
    if !self.connection_metadata.application_protocols.contains(direct.protocol_id) {
        warn!(
            NetworkSchema::new(&self.network_context)
                .connection_metadata(&self.connection_metadata),
            protocol_id = ?direct.protocol_id,
            "Peer sent message for unsupported protocol, dropping"
        );
        counters::direct_send_messages(&self.network_context, "unsupported_protocol").inc();
        return Ok(());
    }
    
    // ... rest of existing handler logic
}

// For RpcRequest handling:
NetworkMessage::RpcRequest(request) => {
    // ADD THIS VALIDATION:
    if !self.connection_metadata.application_protocols.contains(request.protocol_id) {
        warn!(
            NetworkSchema::new(&self.network_context)
                .connection_metadata(&self.connection_metadata),
            protocol_id = ?request.protocol_id,
            "Peer sent RPC request for unsupported protocol, dropping"
        );
        counters::direct_send_messages(&self.network_context, "unsupported_protocol").inc();
        return Ok(());
    }
    
    // ... rest of existing handler logic
}
```

Additionally, consider disconnecting peers that repeatedly violate protocol support rules, as this indicates malicious behavior.

## Proof of Concept

```rust
// Add to network/framework/src/peer/test.rs

#[tokio::test]
async fn test_protocol_support_bypass() {
    use crate::protocols::wire::handshake::v1::ProtocolId;
    use crate::transport::ConnectionMetadata;
    
    // Setup: Create a peer connection that only advertises HealthCheckerRpc support
    let mut connection_metadata = ConnectionMetadata::mock(PeerId::random());
    let mut advertised_protocols = ProtocolIdSet::empty();
    advertised_protocols.insert(ProtocolId::HealthCheckerRpc);
    connection_metadata.application_protocols = advertised_protocols;
    
    // Setup peer with handlers for multiple protocols including StorageServiceRpc
    let mut upstream_handlers = HashMap::new();
    upstream_handlers.insert(
        ProtocolId::StorageServiceRpc,
        aptos_channel::new(...).0,
    );
    upstream_handlers.insert(
        ProtocolId::HealthCheckerRpc,
        aptos_channel::new(...).0,
    );
    
    // Create peer actor
    let peer = Peer::new(...);
    
    // Attack: Send a DirectSendMsg with StorageServiceRpc protocol
    // even though peer only advertised HealthCheckerRpc
    let malicious_msg = NetworkMessage::DirectSendMsg(DirectSendMsg {
        protocol_id: ProtocolId::StorageServiceRpc,
        priority: Priority::default(),
        raw_msg: vec![1, 2, 3],
    });
    
    // Current behavior: Message is processed (VULNERABILITY)
    // Expected behavior: Message should be rejected
    
    // Send the message and verify it gets processed
    // (In actual vulnerable code, this would succeed)
    // peer.handle_inbound_network_message(malicious_msg, ...);
    
    // Assertion: The message handler for StorageServiceRpc receives the message
    // even though the peer didn't advertise support for that protocol
    assert!(/* message was processed - this demonstrates the vulnerability */);
}
```

**Notes**

This vulnerability exists because the protocol negotiation during handshake and the message handling logic are disconnected. The handshake establishes `application_protocols` in the connection metadata, but this information is never consulted when processing inbound messages. The `upstream_handlers` map is global to all peers and doesn't account for per-peer protocol support.

The fix requires adding runtime validation to ensure the protocol contract established during handshake is enforced throughout the connection lifetime. This is a defense-in-depth measure that prevents malicious peers from exploiting protocol filtering bypasses.

### Citations

**File:** network/framework/src/application/storage.rs (L129-148)
```rust
    pub fn get_connected_supported_peers(
        &self,
        protocol_ids: &[ProtocolId],
    ) -> Result<Vec<PeerNetworkId>, Error> {
        // Get the cached peers and metadata
        let cached_peers_and_metadata = self.cached_peers_and_metadata.load();

        // Collect all connected peers that support at least one of the given protocols
        let mut connected_supported_peers = Vec::new();
        for (network_id, peers_and_metadata) in cached_peers_and_metadata.iter() {
            for (peer_id, peer_metadata) in peers_and_metadata.iter() {
                if peer_metadata.is_connected() && peer_metadata.supports_any_protocol(protocol_ids)
                {
                    let peer_network_id = PeerNetworkId::new(*network_id, *peer_id);
                    connected_supported_peers.push(peer_network_id);
                }
            }
        }
        Ok(connected_supported_peers)
    }
```

**File:** network/framework/src/peer/mod.rs (L456-492)
```rust
                    direct.protocol_id,
                    data_len as u64,
                );
                match self.upstream_handlers.get(&direct.protocol_id) {
                    None => {
                        counters::direct_send_messages(&self.network_context, UNKNOWN_LABEL).inc();
                        counters::direct_send_bytes(&self.network_context, UNKNOWN_LABEL)
                            .inc_by(data_len as u64);
                    },
                    Some(handler) => {
                        let key = (self.connection_metadata.remote_peer_id, direct.protocol_id);
                        let sender = self.connection_metadata.remote_peer_id;
                        let network_id = self.network_context.network_id();
                        let sender = PeerNetworkId::new(network_id, sender);
                        match handler.push(key, ReceivedMessage::new(message, sender)) {
                            Err(_err) => {
                                // NOTE: aptos_channel never returns other than Ok(()), but we might switch to tokio::sync::mpsc and then this would work
                                counters::direct_send_messages(
                                    &self.network_context,
                                    DECLINED_LABEL,
                                )
                                .inc();
                                counters::direct_send_bytes(&self.network_context, DECLINED_LABEL)
                                    .inc_by(data_len as u64);
                            },
                            Ok(_) => {
                                counters::direct_send_messages(
                                    &self.network_context,
                                    RECEIVED_LABEL,
                                )
                                .inc();
                                counters::direct_send_bytes(&self.network_context, RECEIVED_LABEL)
                                    .inc_by(data_len as u64);
                            },
                        }
                    },
                }
```

**File:** network/framework/src/peer/mod.rs (L505-530)
```rust
            NetworkMessage::RpcRequest(request) => {
                match self.upstream_handlers.get(&request.protocol_id) {
                    None => {
                        counters::direct_send_messages(&self.network_context, UNKNOWN_LABEL).inc();
                        counters::direct_send_bytes(&self.network_context, UNKNOWN_LABEL)
                            .inc_by(request.raw_request.len() as u64);
                    },
                    Some(handler) => {
                        let sender = self.connection_metadata.remote_peer_id;
                        let network_id = self.network_context.network_id();
                        let sender = PeerNetworkId::new(network_id, sender);
                        if let Err(err) = self
                            .inbound_rpcs
                            .handle_inbound_request(handler, ReceivedMessage::new(message, sender))
                        {
                            warn!(
                                NetworkSchema::new(&self.network_context)
                                    .connection_metadata(&self.connection_metadata),
                                error = %err,
                                "{} Error handling inbound rpc request: {}",
                                self.network_context,
                                err
                            );
                        }
                    },
                }
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L431-465)
```rust
    pub fn perform_handshake(
        &self,
        other: &HandshakeMsg,
    ) -> Result<(MessagingProtocolVersion, ProtocolIdSet), HandshakeError> {
        // verify that both peers are on the same chain
        if self.chain_id != other.chain_id {
            return Err(HandshakeError::InvalidChainId(
                other.chain_id,
                self.chain_id,
            ));
        }

        // verify that both peers are on the same network
        if self.network_id != other.network_id {
            return Err(HandshakeError::InvalidNetworkId(
                other.network_id,
                self.network_id,
            ));
        }

        // find the greatest common MessagingProtocolVersion where we both support
        // at least one common ProtocolId.
        for (our_handshake_version, our_protocols) in self.supported_protocols.iter().rev() {
            if let Some(their_protocols) = other.supported_protocols.get(our_handshake_version) {
                let common_protocols = our_protocols.intersect(their_protocols);

                if !common_protocols.is_empty() {
                    return Ok((*our_handshake_version, common_protocols));
                }
            }
        }

        // no intersection found
        Err(HandshakeError::NoCommonProtocols)
    }
```

**File:** network/framework/src/application/interface.rs (L214-223)
```rust
    fn get_available_peers(&self) -> Result<Vec<PeerNetworkId>, Error> {
        let supported_protocol_ids: Vec<ProtocolId> = self
            .direct_send_protocols_and_preferences
            .iter()
            .chain(self.rpc_protocols_and_preferences.iter())
            .cloned()
            .collect();
        self.peers_and_metadata
            .get_connected_supported_peers(&supported_protocol_ids)
    }
```

**File:** state-sync/storage-service/client/src/lib.rs (L65-70)
```rust
    pub fn get_available_peers(&self) -> Result<HashSet<PeerNetworkId>, Error> {
        self.network_client
            .get_available_peers()
            .map(|peers| peers.into_iter().collect())
            .map_err(|error| Error::NetworkError(error.to_string()))
    }
```
