# Audit Report

## Title
Incomplete Feature Flag Detection Allows Production Nodes to Run with Event Introspection Test Natives

## Summary
The `assert_no_test_natives` function fails to detect event module test natives due to an incorrect function name check. The check looks for `"emitted_events_internal"` but the actual registered test native functions are `"emitted_events_by_handle"` and `"emitted_events"`. This allows production nodes accidentally compiled with the `testing` feature to pass the safety check and run with dangerous debug natives enabled. [1](#0-0) 

## Finding Description

The Aptos node performs a critical safety check at startup to ensure no test-only native functions are included in production builds. [2](#0-1) 

This check is implemented in the `assert_no_test_natives` function, which validates that specific test native functions are not present in the native function table. [3](#0-2) 

However, the check contains an incorrect function name for the event module test natives. It checks for `"emitted_events_internal"` on line 185-186, but the actual test natives registered in the event module are named differently. [4](#0-3) 

The two test natives that are NOT detected by the check are:
1. `"emitted_events_by_handle"` - Returns all V1 events for a given event handle
2. `"emitted_events"` - Returns all V2 events of a specific type

These functions are conditionally compiled when the `testing` feature is enabled and allow Move code to read emitted events during execution. This breaks the fundamental security invariant that events are write-only during transaction execution and only readable off-chain.

**Attack Propagation Path:**

1. Developer accidentally builds aptos-node with `--features testing` due to Cargo feature unification (as documented in the error message itself)
2. Node starts and runs `assert_no_test_natives` check at startup
3. Check PASSES incorrectly (false negative) because it searches for wrong function name
4. Node runs in production with event introspection natives enabled
5. Attacker deploys malicious Move module that calls `0x1::event::emitted_events<T>()` or `0x1::event::emitted_events_by_handle<T>()`
6. Attacker can now read events during transaction execution, enabling:
   - Observing governance proposal events from other modules
   - Creating execution paths dependent on event data
   - Extracting sensitive information assumed to be write-only
   - Breaking deterministic execution if validators have different behaviors

## Impact Explanation

**Severity: CRITICAL** (Consensus/Safety Violation)

This vulnerability meets the Critical severity criteria because:

1. **Consensus Safety Violation**: The ability to read events during execution breaks the deterministic execution invariant. Different validators could potentially produce different execution results if their event introspection returns different data, leading to consensus splits.

2. **Security Invariant Violation**: Events in Aptos are designed to be write-only during execution. The Move VM specification explicitly treats events as side effects that do not affect computation. Breaking this invariant allows attackers to create execution logic that depends on event data, which was never intended to be accessible during transaction processing.

3. **Silent Failure**: The detection mechanism fails without any indication. Node operators would have no way to know their production nodes are running with test natives enabled, creating a persistent attack surface.

4. **Production Impact**: This affects ALL production nodes accidentally compiled with the testing feature, not just a subset. The error message acknowledges this is a real concern caused by Cargo's feature unification.

The vulnerability enables attackers to violate critical blockchain invariants and potentially cause consensus failures requiring emergency intervention.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

This is moderately to highly likely to occur because:

1. **Known Compilation Issue**: The ERROR_MSG_BAD_FEATURE_FLAGS explicitly mentions that Cargo's feature unification can cause this problem. This is a known, documented risk in the codebase.

2. **Complex Build System**: With 100+ crates and deep dependency trees, feature flags can be accidentally unified when building multiple binaries in the same workspace.

3. **Silent Detection Failure**: The flawed check provides false confidence. Developers trust the check to catch this issue, but it silently fails for event natives.

4. **CI/CD Gaps**: While there's a test with the `check-vm-features` flag [5](#0-4) , this only validates the detection logic works - it doesn't catch that the logic itself is incomplete.

5. **Production Deployment**: If a misconfigured build makes it to production, it remains exploitable until discovered and redeployed.

## Recommendation

**Immediate Fix**: Update the function name check in `assert_no_test_natives` to match the actual registered test native names.

In `aptos-move/aptos-vm/src/natives.rs`, lines 185-186, replace:
```rust
|| module_name.as_str() == "event"
    && func_name.as_str() == "emitted_events_internal"
```

With:
```rust
|| module_name.as_str() == "event"
    && (func_name.as_str() == "emitted_events_by_handle"
        || func_name.as_str() == "emitted_events")
```

**Additional Recommendations:**

1. **Add Compile-Time Test**: Create a compile-time test that compares the hardcoded check list against the actual test natives registered in each module. This prevents future drift.

2. **Automated Detection**: Use `#[cfg(feature = "testing")]` annotations as the source of truth and generate the check list programmatically rather than maintaining it manually.

3. **Build System Validation**: Add a CI check that explicitly builds aptos-node with various feature combinations and validates the `assert_no_test_natives` check catches all test natives.

4. **Runtime Assertion Enhancement**: Consider adding a hash-based verification of the entire native function table against a known-good production hash to detect any unexpected natives.

## Proof of Concept

**Step 1: Demonstrate the Detection Failure**

```rust
// File: aptos-move/aptos-vm/src/natives.rs
// Add this test to demonstrate the bug

#[cfg(all(test, feature = "testing"))]
mod detection_tests {
    use super::*;
    
    #[test]
    #[should_fail]
    fn test_event_natives_are_detected() {
        // This test will PASS (should fail) when it should FAIL,
        // demonstrating the detection bypass
        
        let natives = aptos_natives(
            LATEST_GAS_FEATURE_VERSION,
            NativeGasParameters::zeros(),
            MiscGasParameters::zeros(),
            TimedFeaturesBuilder::enable_all().build(),
            Features::default()
        );
        
        // Check if event test natives are present
        let has_emitted_events = natives.iter().any(|(_, module, func, _)| {
            module.as_str() == "event" && func.as_str() == "emitted_events"
        });
        
        let has_emitted_events_by_handle = natives.iter().any(|(_, module, func, _)| {
            module.as_str() == "event" && func.as_str() == "emitted_events_by_handle"
        });
        
        // When testing feature is enabled, these WILL be present
        assert!(has_emitted_events, "emitted_events native found but not checked");
        assert!(has_emitted_events_by_handle, "emitted_events_by_handle native found but not checked");
        
        // But assert_no_test_natives will NOT panic because it checks for wrong name
        assert_no_test_natives("This should panic but doesn't!");
    }
}
```

**Step 2: Verify Current Check Passes with Wrong Build**

```bash
# Build aptos-node with testing feature (simulating accidental compilation)
cargo build -p aptos-node --features testing

# The binary will start successfully despite having test natives
# because assert_no_test_natives doesn't detect the event test natives
./target/debug/aptos-node --config <config_path>
# Node starts successfully (SHOULD HAVE FAILED)
```

**Step 3: Exploitation via Move Module**

```move
// Malicious Move module that exploits the event introspection
module attacker::event_spy {
    use std::event;
    use aptos_framework::coin::{CoinStore, AptosCoin};
    
    struct SpyEvent has drop, store {
        amount: u64,
    }
    
    // Function that reads events to make execution non-deterministic
    public fun spy_on_transfers<CoinType>() {
        // This should NOT be possible in production!
        // But with the bug, these test natives are available
        let events = event::emitted_events<TransferEvent>();
        
        // Now execution depends on event data, breaking determinism
        if (vector::length(&events) > 0) {
            // Attacker's code path
            abort 0x1337
        } else {
            // Normal path
        }
    }
}
```

This demonstrates how the incomplete detection allows dangerous test natives to remain in production builds, creating a critical security vulnerability that breaks consensus safety guarantees.

### Citations

**File:** aptos-node/src/utils.rs (L20-29)
```rust
pub const ERROR_MSG_BAD_FEATURE_FLAGS: &str = r#"
aptos-node was compiled with feature flags that shouldn't be enabled.

This is caused by cargo's feature unification.
When you compile two crates with a shared dependency, if one enables a feature flag for the dependency, then it is also enabled for the other crate.

To resolve this issue, try the following methods:
- Recompile `aptos-node` SEPARATELY
- Check if a disallowed feature flag is enabled by a dependency in the build tree
"#;
```

**File:** aptos-node/src/main.rs (L22-23)
```rust
    // Check that we are not including any Move test natives
    aptos_vm::natives::assert_no_test_natives(ERROR_MSG_BAD_FEATURE_FLAGS);
```

**File:** aptos-move/aptos-vm/src/natives.rs (L161-191)
```rust
pub fn assert_no_test_natives(err_msg: &str) {
    assert!(
        aptos_natives(
            LATEST_GAS_FEATURE_VERSION,
            NativeGasParameters::zeros(),
            MiscGasParameters::zeros(),
            TimedFeaturesBuilder::enable_all().build(),
            Features::default()
        )
        .into_iter()
        .all(|(_, module_name, func_name, _)| {
            !(module_name.as_str() == "unit_test"
                && func_name.as_str() == "create_signers_for_testing"
                || module_name.as_str() == "ed25519"
                    && func_name.as_str() == "generate_keys_internal"
                || module_name.as_str() == "ed25519" && func_name.as_str() == "sign_internal"
                || module_name.as_str() == "multi_ed25519"
                    && func_name.as_str() == "generate_keys_internal"
                || module_name.as_str() == "multi_ed25519" && func_name.as_str() == "sign_internal"
                || module_name.as_str() == "bls12381"
                    && func_name.as_str() == "generate_keys_internal"
                || module_name.as_str() == "bls12381" && func_name.as_str() == "sign_internal"
                || module_name.as_str() == "bls12381"
                    && func_name.as_str() == "generate_proof_of_possession_internal"
                || module_name.as_str() == "event"
                    && func_name.as_str() == "emitted_events_internal")
        }),
        "{}",
        err_msg
    )
}
```

**File:** aptos-move/framework/src/natives/event.rs (L334-341)
```rust
    #[cfg(feature = "testing")]
    natives.extend([(
        "emitted_events_by_handle",
        native_emitted_events_by_handle as RawSafeNative,
    )]);

    #[cfg(feature = "testing")]
    natives.extend([("emitted_events", native_emitted_events as RawSafeNative)]);
```

**File:** aptos-node/src/tests.rs (L46-50)
```rust
#[cfg(feature = "check-vm-features")]
#[test]
fn test_aptos_vm_does_not_have_test_natives() {
    aptos_vm::natives::assert_no_test_natives(crate::utils::ERROR_MSG_BAD_FEATURE_FLAGS)
}
```
