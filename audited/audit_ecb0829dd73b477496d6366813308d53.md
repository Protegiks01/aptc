# Audit Report

## Title
Critical Epoch Transition Validation Bypass Allows Complete Chain Fork via Malicious Backup Restoration

## Summary
The epoch transition validation in backup restoration fails to cryptographically verify the first epoch-ending ledger info when no trusted waypoints are provided. This allows an attacker to create a malicious backup starting from an arbitrary epoch with a forged validator set, enabling a complete chain fork that bypasses all consensus guarantees.

## Finding Description

The vulnerability exists in the epoch ending backup restoration logic across two critical validation points:

**First Validation Gap - Preheat Phase:** [1](#0-0) 

During the preheat phase, each ledger info is validated using one of two methods: either against a trusted waypoint, or by verifying signatures using the previous ledger info's `next_epoch_state()`. However, for the **first** ledger info in the backup, `previous_li` is initialized to `None`: [2](#0-1) 

When processing the first ledger info, if no trusted waypoint exists for that version, **neither validation branch executes**, and the first epoch-ending ledger info is accepted without any cryptographic verification.

**Second Validation Gap - Run Phase:** [3](#0-2) 

The `run_impl()` function only validates continuity with the previous blockchain state if `previous_epoch_ending_ledger_info` is provided. However, when `EpochHistoryRestoreController` processes the first backup chunk, it starts with `previous_li = None`: [4](#0-3) 

This means the first backup chunk is never validated against the actual blockchain state.

**Attack Scenario:**

1. Attacker creates a malicious backup starting from epoch 100 (not genesis)
2. The backup contains forged epoch-ending ledger infos with a malicious validator set
3. Each subsequent epoch in the backup is signed by the previous epoch's validator set (maintaining internal consistency)
4. Victim node attempts restoration without providing trusted waypoints via `--trust-waypoint` flag
5. The first ledger info at epoch 100 passes preheat validation because:
   - No trusted waypoint exists (line 129 check fails)
   - `previous_li` is `None` (line 136 check is skipped)
6. The first ledger info passes run validation because:
   - `previous_epoch_ending_ledger_info` is `None` (line 218 check is skipped)
7. All subsequent ledger infos are validated against the malicious first one
8. The victim node's database now contains a completely forked chain from epoch 100 onwards

**Broken Invariant:**
This violates **Consensus Safety** (Invariant #2): "AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine". The vulnerability allows an external attacker (not even requiring validator access) to create arbitrary chain forks.

## Impact Explanation

**Severity: CRITICAL** (up to $1,000,000 per Aptos Bug Bounty)

This vulnerability enables:

1. **Complete Chain Fork**: An attacker can create a parallel blockchain history starting from any epoch, with arbitrary transactions, state transitions, and validator sets
2. **Consensus Safety Violation**: Directly breaks the fundamental safety guarantee of AptosBFT consensus
3. **Transaction History Manipulation**: Attacker controls all transaction history from the fork point forward
4. **Validator Set Control**: Malicious backup can define arbitrary validator sets, circumventing the staking system
5. **Governance Bypass**: All governance decisions from the fork point can be manipulated

Any node restoring from a malicious backup without trusted waypoints will diverge from the canonical chain, potentially:
- Accepting invalid transactions as valid
- Computing incorrect account balances
- Following different governance decisions
- Participating in a shadow network with other compromised nodes

This meets the **Critical Severity** criteria:
- ✅ Consensus/Safety violations
- ✅ Non-recoverable network partition (requires manual intervention/hardfork to detect and recover)

## Likelihood Explanation

**Likelihood: HIGH**

The vulnerability is highly exploitable because:

1. **No Privileged Access Required**: Any attacker can create backup files and distribute them
2. **Common Operational Scenario**: Node operators frequently restore from backups for:
   - Bootstrapping new nodes
   - Disaster recovery
   - Migration to new hardware
   - Archive node setup
3. **Documentation Unclear**: The `--trust-waypoint` flag is described as optional, with purpose "to confirm the backup is compatible": [5](#0-4) 

Operators may not realize that omitting trusted waypoints creates a critical security vulnerability.

4. **Social Engineering Vector**: Attackers could distribute "fast bootstrap" backups through community channels, forums, or compromised infrastructure providers

5. **No Runtime Detection**: Once restored, the forked chain appears internally consistent. The node operator may not realize they're on a forked chain until attempting to sync with the network or comparing state with other nodes.

## Recommendation

**Immediate Fix:**

1. **Require Trusted Waypoint for First Epoch**: Modify the restoration logic to mandate that a trusted waypoint must be provided for the first epoch in any backup. Add validation:

```rust
// In run_impl() after line 217:
if previous_epoch_ending_ledger_info.is_none() {
    // First epoch in restoration - MUST have trusted waypoint
    ensure!(
        self.controller.trusted_waypoints.get(&first_li.ledger_info().version()).is_some(),
        "First epoch in backup restoration requires a trusted waypoint. \
        Use --trust-waypoint to specify the expected waypoint at version {}. \
        This is a critical security check to prevent chain fork attacks.",
        first_li.ledger_info().version()
    );
}
```

2. **Enforce Genesis or Continuity**: Add validation that either:
   - The backup starts from epoch 0 (genesis), OR
   - A valid `previous_epoch_ending_ledger_info` is provided that cryptographically links to the backup's first epoch

```rust
// In preheat_impl() after line 88:
if manifest.first_epoch > 0 && previous_li.is_none() {
    // Non-genesis backup without previous context
    ensure!(
        self.trusted_waypoints.get(&first_li.ledger_info().version()).is_some(),
        "Backup starting from non-genesis epoch {} requires trusted waypoint validation. \
        Provide --trust-waypoint for version {} or restore from epoch 0.",
        manifest.first_epoch,
        first_li.ledger_info().version()
    );
}
```

3. **Update Documentation**: Clearly document that `--trust-waypoint` is **mandatory** for secure restoration, not optional. Add prominent security warnings.

4. **Add Restore Mode Flag**: Implement `--require-trusted-waypoints` that defaults to `true` in production builds, can only be disabled with explicit `--allow-unverified-restore` for testing purposes.

## Proof of Concept

```rust
// Conceptual PoC - demonstrates the attack flow
// File: storage/backup/backup-cli/tests/epoch_ending_restore_fork_attack.rs

#[tokio::test]
async fn test_malicious_backup_fork_attack() {
    // 1. Setup: Create a legitimate blockchain state up to epoch 10
    let mut test_env = TestEnvironment::new();
    test_env.bootstrap_genesis();
    test_env.advance_to_epoch(10);
    let legitimate_epoch_10_li = test_env.get_epoch_ending_ledger_info(10);
    
    // 2. Attacker creates malicious backup starting from epoch 10
    // with forged validator set (no legitimate signatures)
    let malicious_validator_set = create_malicious_validator_set();
    let forked_epoch_10_li = create_forged_ledger_info(
        epoch: 10,
        version: legitimate_epoch_10_li.version(),
        next_epoch_state: Some(malicious_validator_set.clone()),
        // Note: signatures are forged/self-signed by attacker
    );
    
    // 3. Create backup manifest with malicious chain
    let mut malicious_backup = EpochEndingBackup {
        first_epoch: 10,  // Starting from epoch 10, not genesis!
        last_epoch: 15,
        waypoints: vec![
            Waypoint::new_epoch_boundary(forked_epoch_10_li.ledger_info())?,
            // ... more forged waypoints
        ],
        chunks: vec![/* forged ledger infos */],
    };
    
    // 4. Victim restores WITHOUT trusted waypoints
    let restore_opt = GlobalRestoreOptions {
        trusted_waypoints: HashMap::new(), // NO TRUSTED WAYPOINTS!
        target_version: u64::MAX,
        // ...
    };
    
    // 5. Restoration succeeds despite malicious data!
    let restore_controller = EpochHistoryRestoreController::new(
        vec![malicious_backup.manifest_handle],
        restore_opt,
        storage,
    );
    
    let restored_history = restore_controller.run().await?;
    
    // 6. Verify the attack succeeded:
    // The restored chain diverges from canonical chain at epoch 10
    assert_ne!(
        restored_history.epoch_endings[10],
        legitimate_epoch_10_li.ledger_info(),
        "Attack succeeded: forked chain was accepted!"
    );
    
    // 7. The node is now on a forked chain with attacker-controlled
    //    validator set and can accept arbitrary transactions
    assert_eq!(
        restored_history.epoch_endings[10].next_epoch_state().unwrap().verifier,
        malicious_validator_set.into(),
        "Attacker controls the validator set!"
    );
}

// Attack succeeds because:
// - Line 129 check fails (no trusted waypoint)
// - Line 136 check is skipped (previous_li is None)
// - Line 218 check is skipped (previous_epoch_ending_ledger_info is None)
// Result: Malicious first epoch accepted without cryptographic validation!
```

**Attack Execution Steps:**
1. Attacker creates backup files starting from epoch N with forged data
2. Distribute backup via compromised infrastructure or social engineering
3. Victim runs: `aptos-db-tool restore --target-db-dir ./restored --epoch-ending-manifest malicious.manifest` (without `--trust-waypoint`)
4. Restoration completes successfully
5. Victim's node is now on a forked chain controlled by the attacker

**Notes**

This vulnerability is particularly insidious because:
- The backup CLI tool's help text suggests trusted waypoints are optional for "confirming compatibility"
- The internal consistency of the malicious backup (each epoch validates against the previous) gives a false sense of correctness
- There's no clear indication to the operator that they're on a forked chain until they attempt network synchronization
- The vulnerability affects backup restoration, a critical operational procedure for node operators and validators

The fix must treat the absence of trusted waypoints for non-genesis epochs as a critical security error, not a warning.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L88-89)
```rust
        let mut previous_li: Option<&LedgerInfoWithSignatures> = None;
        let mut ledger_infos = Vec::new();
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L129-147)
```rust
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
                }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L218-240)
```rust
        if let Some(li) = previous_epoch_ending_ledger_info {
            ensure!(
                li.next_block_epoch() == preheat_data.manifest.first_epoch,
                "Previous epoch ending LedgerInfo is not the one expected. \
                My first epoch: {}, previous LedgerInfo next_block_epoch: {}",
                preheat_data.manifest.first_epoch,
                li.next_block_epoch(),
            );
            // Waypoint has been verified in preheat if it's trusted, otherwise try to check
            // the signatures.
            if self
                .controller
                .trusted_waypoints
                .get(&first_li.ledger_info().version())
                .is_none()
            {
                li.next_epoch_state()
                    .ok_or_else(|| {
                        anyhow!("Previous epoch ending LedgerInfo doesn't end an epoch")
                    })?
                    .verify(first_li)?;
            }
        }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L376-381)
```rust
        let mut previous_li = None;
        let mut epoch_endings = Vec::new();

        while let Some(preheated_restore) = futs_stream.next().await {
            let manifest_handle = preheated_restore.controller.manifest_handle.clone();
            let lis = preheated_restore.run(previous_li).await?;
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L333-345)
```rust
    #[clap(
        long,
        help = "(multiple) When provided, an epoch ending LedgerInfo at the waypoint version will be \
        checked against the hash in the waypoint, but signatures on it are NOT checked. \
        Use this for two purposes: \
        1. set the genesis or the latest waypoint to confirm the backup is compatible. \
        2. set waypoints at versions where writeset transactions were used to overwrite the \
        validator set, so that the signature check is skipped. \
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
    )]
    pub trust_waypoint: Vec<Waypoint>,
```
