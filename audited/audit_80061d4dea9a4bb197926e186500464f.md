# Audit Report

## Title
Test Groth16 Verification Key with Known Trapdoor Exposed in Production Builds

## Summary
The `prepared_vk_for_testing()` function and `VERIFICATION_KEY_FOR_TESTING` constant expose a Groth16 verification key with a known cryptographic trapdoor in production builds, violating defense-in-depth principles and creating risk of authentication bypass if accidentally used in production deployments.

## Finding Description
The keyless authentication system uses Groth16 zero-knowledge proofs to verify transactions. The `prepared_vk_for_testing()` function in `circuit_constants.rs` returns a hardcoded verification key intended for testing purposes. [1](#0-0) 

This test verification key is paired with a known trapdoor (`simulation_pk`) that allows anyone to forge valid proofs without actual knowledge of the witness. [2](#0-1) 

The test verification key is exposed as a public static constant `VERIFICATION_KEY_FOR_TESTING`, making it easily accessible throughout the codebase. [3](#0-2) 

The keyless module is publicly exported from the types crate. [4](#0-3) 

**Attack Vector:**

While production nodes fetch the verification key from on-chain state [5](#0-4) , there are multiple code paths where the test VK could be accidentally used:

1. **Genesis Misconfiguration**: The genesis initialization system allows configuration of the verification key via environment variables or file paths. [6](#0-5) 

2. **SDK Direct Usage**: The SDK directly uses the test trapdoor to create simulated proofs, exposing the pattern. [7](#0-6) 

3. **Developer Error**: Any future code importing `VERIFICATION_KEY_FOR_TESTING` would use a compromised VK.

If the test VK is used in production, attackers with knowledge of the trapdoor (publicly available in `TEST_GROTH16_SETUP.simulation_pk`) can forge arbitrary Groth16 proofs, completely bypassing keyless authentication. This breaks the **Cryptographic Correctness** invariant.

The codebase already follows the pattern of gating test cryptographic material behind feature flags. For example, Ed25519 test functions are properly gated: [8](#0-7) 

## Impact Explanation
**Medium Severity** - This constitutes a defense-in-depth violation with potential for critical impact:

- **Direct Exploitation**: Not possible by external attackers without deployment control
- **Configuration Risk**: Deployment misconfiguration could enable complete authentication bypass
- **Future Risk**: Public API exposure creates ongoing risk of accidental production usage

If exploited through misconfiguration, the impact would be Critical (complete authentication bypass for keyless accounts), but the likelihood of external exploitation without insider access is low.

## Likelihood Explanation
**Low to Medium Likelihood**:

- Current production code paths correctly fetch VK from on-chain state
- No direct fallback to test VK exists in validation logic [9](#0-8) 
- However, genesis configuration mechanisms and public API exposure create ongoing risk
- Test VK is used in multiple test initialization paths, increasing risk of copy-paste errors [10](#0-9) 

## Recommendation
Apply the established codebase pattern of feature-gating test cryptographic material:

```rust
#[cfg(any(test, feature = "fuzzing"))]
pub fn prepared_vk_for_testing() -> PreparedVerifyingKey<Bn254> {
    // ... existing implementation
}

#[cfg(any(test, feature = "fuzzing"))]
pub static VERIFICATION_KEY_FOR_TESTING: Lazy<PreparedVerifyingKey<Bn254>> =
    Lazy::new(prepared_vk_for_testing);

#[cfg(any(test, feature = "fuzzing"))]
pub static TEST_GROTH16_SETUP: Lazy<Groth16TrapdoorSetup> = Lazy::new(|| {
    // ... existing implementation
});
```

This ensures test verification keys and trapdoors are completely absent from production builds, eliminating the attack surface.

## Proof of Concept
While this is not directly exploitable without deployment control, here's a demonstration of the risk:

```rust
// Hypothetical misconfiguration scenario
// If genesis or a developer accidentally uses:
use aptos_types::keyless::VERIFICATION_KEY_FOR_TESTING;

// Instead of fetching from on-chain state, an attacker could:
// 1. Access TEST_GROTH16_SETUP.simulation_pk (public constant)
// 2. Generate arbitrary valid proofs using Groth16SimulatorBn254::create_random_proof_with_trapdoor()
// 3. Submit keyless transactions that pass verification
// 4. Achieve complete authentication bypass

// Example from SDK showing trapdoor usage pattern:
// types/src/keyless/circuit_constants.rs line 106-115
// sdk/src/types.rs line 314
```

A full exploitation PoC would require deploying a test network with misconfigured genesis settings using the test VK, then demonstrating forged transaction acceptance using the known trapdoor.

## Notes
This finding represents a **security hardening opportunity** rather than a directly exploitable vulnerability. While external attackers cannot exploit this without deployment control, the violation of defense-in-depth principles and the established codebase patterns for protecting test cryptographic material warrant addressing this issue. The recommendation aligns with existing security practices throughout the Aptos codebase.

### Citations

**File:** types/src/keyless/circuit_constants.rs (L30-99)
```rust
pub fn prepared_vk_for_testing() -> PreparedVerifyingKey<Bn254> {
    // Convert the projective points to affine.
    let alpha_g1 = g1_projective_str_to_affine(
        "20491192805390485299153009773594534940189261866228447918068658471970481763042",
        "9383485363053290200918347156157836566562967994039712273449902621266178545958",
    )
    .unwrap();

    let beta_g2 = g2_projective_str_to_affine(
        [
            "6375614351688725206403948262868962793625744043794305715222011528459656738731",
            "4252822878758300859123897981450591353533073413197771768651442665752259397132",
        ],
        [
            "10505242626370262277552901082094356697409835680220590971873171140371331206856",
            "21847035105528745403288232691147584728191162732299865338377159692350059136679",
        ],
    )
    .unwrap();

    let gamma_g2 = g2_projective_str_to_affine(
        [
            "10857046999023057135944570762232829481370756359578518086990519993285655852781",
            "11559732032986387107991004021392285783925812861821192530917403151452391805634",
        ],
        [
            "8495653923123431417604973247489272438418190587263600148770280649306958101930",
            "4082367875863433681332203403145435568316851327593401208105741076214120093531",
        ],
    )
    .unwrap();

    let delta_g2 = g2_projective_str_to_affine(
        [
            "6309950375468367434079888575625734658722834850554198467265341412057133512289",
            "290788916745604303732014379515714703987358626088033030814233237684691015915",
        ],
        [
            "18062633083579661887564610476476551517623934510295133920710347041696656037149",
            "18531177357310703535722548657431805690263733685063962985389260695754645724386",
        ],
    )
    .unwrap();

    let mut gamma_abc_g1 = Vec::new();
    for points in [
        g1_projective_str_to_affine(
            "3314139460766150258181182511839382093976747705712051605578952681462625768062",
            "15177929890957116336235565528373348502554233971408496072173139426537995658198",
        )
        .unwrap(),
        g1_projective_str_to_affine(
            "11040819149070528816396253292991080175919431363817777522273571096667537087166",
            "13976660124609527451731647657081915019685631850685519260597009755390746148997",
        )
        .unwrap(),
    ] {
        gamma_abc_g1.push(points);
    }

    let vk = VerifyingKey {
        alpha_g1,
        beta_g2,
        gamma_g2,
        delta_g2,
        gamma_abc_g1,
    };

    PreparedVerifyingKey::from(vk)
}
```

**File:** types/src/keyless/circuit_constants.rs (L106-115)
```rust
pub static TEST_GROTH16_SETUP: Lazy<Groth16TrapdoorSetup> = Lazy::new(|| {
    let mut rng = StdRng::seed_from_u64(999);
    let (simulation_pk, vk) =
        Groth16SimulatorBn254::circuit_agnostic_setup_with_trapdoor(&mut rng, 1).unwrap();
    let prepared_vk = PreparedVerifyingKey::from(vk.clone());
    Groth16TrapdoorSetup {
        simulation_pk,
        prepared_vk,
    }
});
```

**File:** types/src/keyless/mod.rs (L62-64)
```rust
/// A VK that we use often for keyless e2e tests and smoke tests.
pub static VERIFICATION_KEY_FOR_TESTING: Lazy<PreparedVerifyingKey<Bn254>> =
    Lazy::new(prepared_vk_for_testing);
```

**File:** types/src/lib.rs (L68-68)
```rust
pub mod keyless;
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L289-293)
```rust
        let keyless_pvk =
            Groth16VerificationKey::fetch_keyless_config(state_view).and_then(|(vk, vk_bytes)| {
                sha3_256.update(&vk_bytes);
                vk.try_into().ok()
            });
```

**File:** aptos-node/src/lib.rs (L594-613)
```rust
            match env::var("ENABLE_KEYLESS_DEFAULT") {
                Ok(val) if val.as_str() == "1" => {
                    let response = ureq::get("https://api.devnet.aptoslabs.com/v1/accounts/0x1/resource/0x1::keyless_account::Groth16VerificationKey").call();
                    let json: Value = response.into_json().expect("Failed to parse JSON");
                    configure_keyless_with_vk(genesis_config, json).unwrap();
                },
                _ => {},
            };

            if let Ok(url) = env::var("INSTALL_KEYLESS_GROTH16_VK_FROM_URL") {
                let response = ureq::get(&url).call();
                let json: Value = response.into_json().expect("Failed to parse JSON");
                configure_keyless_with_vk(genesis_config, json).unwrap();
            };

            if let Ok(path) = env::var("INSTALL_KEYLESS_GROTH16_VK_FROM_PATH") {
                let file_content = fs::read_to_string(&path).unwrap_or_else(|_| panic!("Failed to read verification key file: {}", path));
                let json: Value = serde_json::from_str(&file_content).expect("Failed to parse JSON");
                configure_keyless_with_vk(genesis_config, json).unwrap();
            };
```

**File:** sdk/src/types.rs (L314-314)
```rust
            let groth16_proof = keyless::proof_simulation::Groth16SimulatorBn254::create_random_proof_with_trapdoor(&[public_inputs], &keyless::circuit_constants::TEST_GROTH16_SETUP.simulation_pk, rng).unwrap();
```

**File:** crates/aptos-crypto/src/ed25519/ed25519_keys.rs (L179-182)
```rust
    #[cfg(any(test, feature = "fuzzing"))]
    fn sign_arbitrary_message(&self, message: &[u8]) -> Ed25519Signature {
        Ed25519PrivateKey::sign_arbitrary_message(self, message)
    }
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L188-191)
```rust
    // If there are ZK authenticators, the Groth16 VK must have been set on-chain.
    if with_zk && pvk.is_none() {
        return Err(invalid_signature!("Groth16 VK has not been set on-chain"));
    }
```

**File:** aptos-move/e2e-move-tests/src/tests/keyless_feature_gating.rs (L52-56)
```rust
    run_upgrade_vk_script(
        &mut h,
        core_resources.clone(),
        Groth16VerificationKey::from(VERIFICATION_KEY_FOR_TESTING.clone()),
    );
```
