# Audit Report

## Title
Fail-Open Access Control in Telemetry Chain Access Validation Enables Unauthorized Information Disclosure

## Summary
The `check_chain_access()` function in the telemetry subsystem uses a fail-open pattern that defaults to `true` on any deserialization or network error, allowing unauthorized telemetry data exfiltration when the telemetry service should deny access. [1](#0-0) 

## Finding Description
The vulnerability exists in the JSON deserialization logic where malformed responses are handled insecurely. The function queries the telemetry service to determine if a chain ID has access, expecting a boolean response. However, the deserialization uses `.unwrap_or(true)`, which means any failure (malformed JSON, network errors, HTTP errors) results in granting access rather than denying it. [2](#0-1) 

This violates the security principle of "fail-closed" access control. The telemetry service correctly implements access control by checking if a chain ID is in the configured set [3](#0-2) , but the client-side implementation undermines this by defaulting to permissive behavior on errors.

**Attack Scenarios:**
1. **Man-in-the-Middle Attack**: An attacker intercepts the HTTPS response and corrupts the JSON payload (e.g., changing `false` to `"false"` or injecting malformed syntax), causing deserialization to fail and return `true`
2. **Server-Side Bug Exploitation**: If the telemetry service has a bug that returns non-boolean JSON (HTML error pages, strings like "yes"/"no", numbers), the client interprets this as granting access
3. **Network Corruption**: TCP/IP packet corruption or incomplete responses trigger the same fail-open behavior

The vulnerability is used to determine whether telemetry collection is enabled for a chain [4](#0-3) , which includes sensitive operational data: node configuration, system information, network metrics, Prometheus metrics, and logs.

## Impact Explanation
This vulnerability enables **unauthorized information disclosure** rather than direct blockchain compromise. The exposed telemetry data includes:
- Node configuration details that may reveal security settings
- System information (OS, hardware) useful for targeting exploits
- Network topology and metrics revealing validator connections
- Performance metrics and operational logs

While this information could assist in planning more sophisticated attacks, it does not directly cause loss of funds, consensus violations, or network unavailability. Per Aptos bug bounty criteria, this qualifies as **Low Severity** ("Minor information leaks") rather than Medium severity, as it doesn't meet the threshold of "Limited funds loss or manipulation" or "State inconsistencies requiring intervention" required for Medium classification.

## Likelihood Explanation
The likelihood is **MODERATE** for the following reasons:
- Requires either MITM capability (difficult with proper TLS validation) OR telemetry service bugs (possible but not guaranteed)
- Network corruption causing partial responses is rare with modern TCP/IP
- The telemetry system can be completely disabled via environment variable `ENV_APTOS_DISABLE_TELEMETRY`, reducing exposure
- Requires the node to actually be calling the telemetry service, which may not be universal

However, when conditions align (telemetry enabled, network position achieved, or service bug present), exploitation is straightforward with no authentication barriers beyond network access.

## Recommendation
Change the fail-open behavior to fail-closed by modifying line 360:

**Current (vulnerable):** [2](#0-1) 

**Fixed version:**
```rust
Ok(response) => response.json::<bool>().await.unwrap_or(false),
```

Additionally, modify lines 363 and 368 to also return `false` on errors:
```rust
Err(e) => {
    debug!("Unable to check chain access {}", e);
    false
},
```

This ensures that any error in checking chain access results in denying access rather than granting it, following the security principle of fail-closed access control.

## Proof of Concept

```rust
#[tokio::test]
async fn test_check_chain_access_malformed_json() {
    use httpmock::MockServer;
    use aptos_types::chain_id::ChainId;
    use aptos_config::config::NodeConfig;
    
    // Test 1: Server returns malformed JSON (string instead of bool)
    let server = MockServer::start();
    let mock = server.mock(|when, then| {
        when.method("GET").path("/api/v1/chain-access/24");
        then.status(200).body(r#""false""#); // String instead of boolean
    });

    let client = TelemetrySender::new(
        Url::parse(&server.base_url()).expect("unable to parse base url"),
        ChainId::default(),
        &NodeConfig::default(),
    );
    
    // BUG: Returns true even though JSON is malformed
    // Should return false (deny access) when JSON is invalid
    let result = client.check_chain_access(ChainId::new(24)).await;
    assert!(result); // Currently returns true - this is the vulnerability
    mock.assert();
    
    // Test 2: Server returns invalid JSON syntax
    let mock2 = server.mock(|when, then| {
        when.method("GET").path("/api/v1/chain-access/25");
        then.status(200).body("tru"); // Truncated/corrupted
    });
    
    let result2 = client.check_chain_access(ChainId::new(25)).await;
    assert!(result2); // Returns true on error - fail-open behavior
    mock2.assert();
    
    // Test 3: Server returns HTTP 500 error
    let mock3 = server.mock(|when, then| {
        when.method("GET").path("/api/v1/chain-access/26");
        then.status(500).body("Internal Server Error");
    });
    
    let result3 = client.check_chain_access(ChainId::new(26)).await;
    assert!(result3); // Returns true on HTTP error - fail-open behavior
    mock3.assert();
}
```

**Notes:**
- This vulnerability represents a fail-open access control pattern in the telemetry subsystem
- While the implementation flaw is clear and exploitable, the security impact is limited to information disclosure
- Per Aptos bug bounty criteria, this qualifies as **Low severity** rather than the Medium severity indicated in the security question
- The vulnerability does not affect consensus, transaction execution, or blockchain state - it only impacts operational telemetry data collection
- The fix is straightforward: change default behavior from `true` to `false` on all error conditions

### Citations

**File:** crates/aptos-telemetry/src/sender.rs (L355-371)
```rust
    pub(crate) async fn check_chain_access(&self, chain_id: ChainId) -> bool {
        debug!("checking chain access for chain id {}", chain_id);

        match self.try_check_chain_access(chain_id).await {
            Ok(response) => match error_for_status_with_body(response).await {
                Ok(response) => response.json::<bool>().await.unwrap_or(true),
                Err(e) => {
                    debug!("Unable to check chain access {}", e);
                    true
                },
            },
            Err(e) => {
                debug!("Unable to check chain access {}", e);
                true
            },
        }
    }
```

**File:** crates/aptos-telemetry-service/src/auth.rs (L199-205)
```rust
async fn handle_check_chain_access(
    chain_id: ChainId,
    context: Context,
) -> Result<impl Reply, Rejection> {
    let present = context.chain_set().contains(&chain_id);
    Ok(reply::json(&present))
}
```

**File:** crates/aptos-telemetry/src/service.rs (L170-196)
```rust
    if !force_enable_telemetry() && !telemetry_sender.check_chain_access(chain_id).await {
        warn!(
                "Aptos telemetry is not sent to the telemetry service because the service is not configured for chain ID {}",
                chain_id
            );
        // Spawn the custom event sender to send to GA4 only.
        // This is a temporary workaround while we deprecate and remove GA4 completely.
        let peer_id = fetch_peer_id(&node_config);
        let handle = tokio::spawn(custom_event_sender(
            None,
            peer_id,
            chain_id,
            node_config.clone(),
            build_info.clone(),
        ));
        info!("Telemetry service for GA4 started!");

        // Check for chain access periodically in case the service is configured later
        let mut interval = time::interval(Duration::from_secs(CHAIN_ACCESS_CHECK_FREQ_SECS));
        loop {
            interval.tick().await;
            if telemetry_sender.check_chain_access(chain_id).await {
                handle.abort();
                info!("Aptos telemetry service is now configured for Chain ID {}. Starting telemetry service...", chain_id);
                break;
            }
        }
```
