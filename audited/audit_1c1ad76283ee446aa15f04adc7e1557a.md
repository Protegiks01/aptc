# Audit Report

## Title
Indexer-grpc-manager Transaction Data Tampering via Unverified Fullnode Connection

## Summary
The indexer-grpc-manager lacks cryptographic verification of transaction data received from fullnodes, creating a data integrity vulnerability where an attacker with network access or control over a fullnode can serve tampered transaction data to downstream clients.

## Finding Description

The vulnerability exists in the data flow from fullnode to indexer-grpc-manager through the DataManager component. The system retrieves transaction data without cryptographic proofs and does not verify data integrity.

**Vulnerable Data Flow:**

1. **Unverified Fullnode Connection** - The MetadataManager creates plain gRPC connections to fullnodes without TLS or authentication: [1](#0-0) 

2. **Transaction Retrieval Without Proofs** - DataManager fetches transactions that contain only hashes, not Merkle proofs: [2](#0-1) 

3. **No Verification in Cache** - Transactions are cached directly without verification: [3](#0-2) 

4. **Served to Clients** - The GrpcManagerService serves unverified data to clients: [4](#0-3) 

**Missing Security Controls:**

The system fails to use Aptos's built-in verification mechanisms. Proper verification exists elsewhere in the codebase (TransactionWithProof::verify), but is not utilized by the indexer: [5](#0-4) 

**Attack Scenarios:**

1. **Network MITM**: Attacker intercepts unencrypted gRPC traffic between fullnode and indexer-grpc-manager, modifies transaction data in transit
2. **DNS Hijacking**: Attacker redirects fullnode_addresses to malicious endpoint serving fake transaction data
3. **Compromised Fullnode**: Malicious fullnode operator serves incorrect transaction data

## Impact Explanation

While this vulnerability exists in an auxiliary indexing service rather than core consensus infrastructure, it poses **Medium severity** risks:

**Data Integrity Impact:**
- Applications consuming indexer data (wallets, explorers, analytics) receive unverified information
- Incorrect transaction history, event logs, and state changes displayed to end users  
- Account balances and NFT ownership data could be misrepresented

**Trust Boundary Violation:**
- Clients assume data from the indexer represents committed blockchain state
- No mechanism for clients to independently verify received data against blockchain proofs

**Scope Limitation:**
This does NOT directly impact:
- Consensus safety (validators use separate verified data paths)
- On-chain fund security (transactions are validated before execution)
- Network liveness (indexer is read-only service)

The impact is limited to data consumers of the indexer service, not the authoritative blockchain state itself. However, applications making critical decisions based on this unverified data face integrity risks.

## Likelihood Explanation

**Attack Feasibility: Medium**

Required conditions:
1. Network access between fullnode and indexer-grpc-manager (for MITM), OR
2. Control over a fullnode in the configured fullnode_addresses list, OR  
3. Ability to perform DNS/routing attacks

Configuration analysis shows fullnode addresses are configurable strings, allowing remote connections: [6](#0-5) 

**Mitigating Factors:**
- Fullnodes typically operated by trusted entities (Aptos Foundation, validators)
- May be deployed on private networks in production
- Applications can implement client-side verification if needed

**Aggravating Factors:**
- Zero cryptographic protection on fullnode connections
- No authentication or TLS configuration found in codebase
- Silent failure - tampered data indistinguishable from legitimate data

## Recommendation

Implement cryptographic verification in the indexer-grpc-manager data path:

**1. Use Proof-Verified Endpoints**
Modify DataManager to request transactions with proofs from fullnode, similar to state-sync's verified approach. The fullnode already supports `get_transactions` which can return TransactionListWithProof.

**2. Add TLS/mTLS to Fullnode Connections**
Configure TLS for MetadataManager's fullnode connections:
```rust
// In Fullnode::new()
let tls_config = ClientTlsConfig::new()
    .ca_certificate(Certificate::from_pem(ca_cert))
    .domain_name("fullnode.aptos.example");
    
let channel = Channel::from_shared(address)?
    .tls_config(tls_config)?
    .connect_lazy();
```

**3. Verify Accumulator Proofs**
Before caching transactions, verify them against a trusted LedgerInfo:
```rust
// In DataManager::start() after receiving transactions
let ledger_info = self.get_trusted_ledger_info().await?;
for txn_with_proof in transactions {
    txn_with_proof.verify(&ledger_info, txn_with_proof.version)?;
}
```

**4. Add Configuration Options**
Provide configuration for:
- TLS certificates for fullnode connections
- Trusted validator set for LedgerInfo verification
- Option to disable verification for trusted deployments (with clear warnings)

## Proof of Concept

**Setup Requirements:**
- Running indexer-grpc-manager connected to fullnode
- Network position to intercept or malicious fullnode

**Attack Steps:**

1. **Intercept gRPC Connection:**
```bash
# MITM proxy between fullnode and indexer-grpc-manager
# Capture TransactionsFromNodeResponse
```

2. **Modify Transaction Data:**
```python
# Modify protobuf Transaction message
transaction.info.hash = malicious_hash
transaction.user.sender = attacker_address
# No cryptographic signature to break
```

3. **Forward to Indexer:**
```bash
# Indexer-grpc-manager caches tampered data
# Serves to clients with no indication of tampering
```

4. **Client Receives Fake Data:**
```bash
# Client queries get_transactions()
# Receives transaction showing incorrect sender/events/state
# No way to verify authenticity without external proof
```

**Verification:**
The lack of verification can be confirmed by code inspection showing transaction data flows from fullnode through cache to clients without any `verify()` calls on proofs or signature validation beyond what was done at transaction submission time.

---

**Notes:**

The vulnerability is architecturally significant even though the indexer-grpc-manager is an auxiliary service. The lack of cryptographic verification creates a trust requirement on network security and fullnode honesty that is inconsistent with blockchain security principles. Applications depending on this data for critical functionality face data integrity risks that could be eliminated through proper proof verification.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L66-80)
```rust
impl Fullnode {
    fn new(address: GrpcAddress) -> Self {
        let channel = Channel::from_shared(address)
            .expect("Bad address.")
            .connect_lazy();
        let client = FullnodeDataClient::new(channel)
            .send_compressed(CompressionEncoding::Zstd)
            .accept_compressed(CompressionEncoding::Zstd)
            .max_encoding_message_size(MAX_MESSAGE_SIZE)
            .max_decoding_message_size(MAX_MESSAGE_SIZE);
        Self {
            client,
            recent_states: VecDeque::new(),
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L207-220)
```rust
            let request = GetTransactionsFromNodeRequest {
                starting_version: Some(cache.start_version + cache.transactions.len() as u64),
                transactions_count: Some(100000),
            };
            drop(cache);

            debug!(
                "Requesting transactions from fullnodes, starting_version: {}.",
                request.starting_version.unwrap()
            );
            let (address, mut fullnode_client) =
                self.metadata_manager.get_fullnode_for_request(&request);
            trace!("Fullnode ({address}) is picked for request.");
            let response = fullnode_client.get_transactions_from_node(request).await;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L261-266)
```rust
                                Response::Data(data) => {
                                    trace!(
                                        "Putting data into cache, {} transaction(s).",
                                        data.transactions.len()
                                    );
                                    self.cache.write().await.put_transactions(data.transactions);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L129-146)
```rust
    async fn get_transactions(
        &self,
        request: Request<GetTransactionsRequest>,
    ) -> Result<Response<TransactionsResponse>, Status> {
        let request = request.into_inner();
        let transactions = self
            .data_manager
            .get_transactions(request.starting_version(), MAX_SIZE_BYTES_FROM_CACHE)
            .await
            .map_err(|e| Status::internal(format!("{e}")))?;

        Ok(Response::new(TransactionsResponse {
            transactions,
            chain_id: Some(self.chain_id),
            // Not used.
            processed_range: None,
        }))
    }
```

**File:** api/types/src/transaction.rs (L98-115)
```rust
/// A committed transaction
///
/// This is a representation of the onchain payload, outputs, events, and proof of a transaction.
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct TransactionOnChainData {
    /// The ledger version of the transaction
    pub version: u64,
    /// The transaction submitted
    pub transaction: aptos_types::transaction::Transaction,
    /// Information about the transaction
    pub info: aptos_types::transaction::TransactionInfo,
    /// Events emitted by the transaction
    pub events: Vec<ContractEvent>,
    /// The accumulator root hash at this version
    pub accumulator_root_hash: aptos_crypto::HashValue,
    /// Final state of resources changed by the transaction
    pub changes: aptos_types::write_set::WriteSet,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/config.rs (L29-42)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IndexerGrpcManagerConfig {
    pub(crate) chain_id: u64,
    pub(crate) service_config: ServiceConfig,
    #[serde(default = "default_cache_config")]
    pub(crate) cache_config: CacheConfig,
    pub(crate) file_store_config: IndexerGrpcFileStoreConfig,
    pub(crate) self_advertised_address: GrpcAddress,
    pub(crate) grpc_manager_addresses: Vec<GrpcAddress>,
    pub(crate) fullnode_addresses: Vec<GrpcAddress>,
    pub(crate) is_master: bool,
    pub(crate) allow_fn_fallback: bool,
}
```
