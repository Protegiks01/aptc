# Audit Report

## Title
Cache Entry API Race Condition Leading to Denial of Service in Native Executor Benchmark

## Summary
The `update_fa_balance()` function in the Native Value Cache executor contains a cache consistency bug where the `exists` flag is initialized outside the `cache.entry()` closure but modified inside it. This causes the flag to incorrectly report `true` on subsequent calls to the same account, even when the resource didn't exist initially. This bug enables a denial-of-service attack through parallel `create_account` transactions and produces incorrect execution semantics. [1](#0-0) 

## Finding Description

The vulnerability exists in the `update_fa_balance()` function where the `exists` variable is declared and initialized to `true` before the `cache.entry()` call, but is potentially modified to `false` inside the `or_insert_with` closure when the fungible store doesn't exist in the state view.

The problem occurs in parallel execution scenarios:

1. **First transaction** to a new account executes:
   - Cache is empty, closure executes
   - Resource doesn't exist in state_view, sets `exists = false`
   - Returns `false` correctly
   
2. **Second parallel transaction** to the same account:
   - Cache already has entry from first transaction
   - Closure does NOT execute (`or_insert_with` only inserts if key is missing)
   - `exists` remains at initial value of `true`
   - Returns `true` incorrectly (should return `false`)

This breaks the semantic contract where the return value should indicate whether the resource existed in the **original state view**, not the cache. [2](#0-1) 

The same pattern appears in `check_or_create_account()` with the `missing` flag: [3](#0-2) 

### Attack Path for DOS

When `aptos_account::create_account` transactions are parsed, they set `fail_on_recipient_account_existing: true`: [4](#0-3) 

In the execution logic: [5](#0-4) 

The attack sequence:
1. Attacker submits multiple `create_account(address_X)` transactions in one block
2. Transactions execute in parallel via rayon
3. Transaction A: `update_fa_balance` returns `false`, `check_or_create_account` creates account in cache
4. Transaction B (parallel): `update_fa_balance` returns `true` (bug), condition `!existed || fail_on_recipient_account_existing` evaluates to `!true || true` = `true`, so `check_or_create_account` is called
5. In `check_or_create_account`: account exists in cache, closure doesn't run, `missing` stays `false`
6. The assertion `assert!(missing)` at line 863 fails, causing panic [6](#0-5) 

## Impact Explanation

**CRITICAL LIMITATION**: This vulnerability is in the **executor-benchmark** tool, not production consensus code. [7](#0-6) 

The `NativeValueCacheParallelUncoordinated` executor is a benchmarking variant used for performance testing: [8](#0-7) 

**Impact Assessment:**
- **Benchmark Infrastructure DOS**: Attacker can crash benchmark runs with crafted transaction patterns
- **Incorrect Benchmark Results**: Cache consistency bugs produce results that don't match production VM behavior
- **NO Production Impact**: This code path is NOT used in validator consensus, block execution, or any production security-critical path

This does **NOT** meet the bug bounty severity criteria because:
- It doesn't affect production funds, consensus, or network availability
- It only impacts testing/benchmarking infrastructure
- No validator nodes or blockchain state are compromised

## Likelihood Explanation

**High likelihood within benchmark context**: Any workload with parallel `create_account` transactions will trigger this bug.

**Zero likelihood in production**: This code is never executed in production validator nodes or consensus.

## Recommendation

Move the flag initialization inside the closure or use a wrapper type to track whether the closure executed:

```rust
fn update_fa_balance(
    &self,
    account: AccountAddress,
    state_view: &(impl StateView + Sync),
    increment: u64,
    decrement: u64,
    fail_on_missing: bool,
) -> bool {
    let store_address = primary_apt_store(account);
    let fungible_store_rg_tag = &self.db_util.common.fungible_store;
    let cache_key = StateKey::resource(&store_address, fungible_store_rg_tag).unwrap();

    // Use a Cell to track existence status
    let exists = std::cell::Cell::new(true);
    let mut entry = self.cache.entry(cache_key).or_insert_with(|| {
        let fa_store_object_key = self
            .db_util
            .new_state_key_object_resource_group(&store_address);
        let rg_opt =
            DbAccessUtil::get_resource_group(&fa_store_object_key, state_view).unwrap();
        CachedResource::FungibleStore(match rg_opt {
            Some(mut rg) => {
                bcs::from_bytes(&rg.remove(fungible_store_rg_tag).unwrap()).unwrap()
            },
            None => {
                exists.set(false);
                assert!(!fail_on_missing);
                FungibleStoreResource::new(AccountAddress::TEN, 0, false)
            },
        })
    });
    
    match entry.value_mut() {
        CachedResource::FungibleStore(fungible_store_resource) => {
            fungible_store_resource.balance += increment;
            fungible_store_resource.balance -= decrement;
        },
        _ => panic!("wrong type"),
    };
    exists.get()
}
```

Apply the same fix to `update_coin_balance()` and `check_or_create_account()`.

## Proof of Concept

This Rust test demonstrates the vulnerability:

```rust
#[test]
fn test_parallel_create_account_dos() {
    use aptos_types::account_address::AccountAddress;
    use rayon::prelude::*;
    
    let executor = NativeValueCacheRawTransactionExecutor::new();
    let state_view = /* mock state view */;
    let target_address = AccountAddress::random();
    
    // Create 10 parallel create_account transactions for same address
    let transactions: Vec<_> = (0..10)
        .map(|i| NativeTransaction::Transfer {
            sender: AccountAddress::random(),
            sequence_number: i,
            recipient: target_address,
            amount: 0,
            fail_on_recipient_account_existing: true,
            fail_on_recipient_account_missing: false,
        })
        .collect();
    
    // This should panic due to the bug
    let result = std::panic::catch_unwind(|| {
        transactions.par_iter().for_each(|txn| {
            let _ = executor.execute_transaction(txn.clone(), &state_view, &true);
        });
    });
    
    assert!(result.is_err(), "Expected panic from assert!(missing) failure");
}
```

---

**FINAL ASSESSMENT**: While this is a valid bug with a clear exploitation path, it **does not meet the security criteria** for the Aptos bug bounty program because it only affects benchmarking infrastructure, not production consensus, validator security, or blockchain state integrity. The issue should be fixed for correctness, but it is not a security vulnerability in the production system.

### Citations

**File:** execution/executor-benchmark/src/native/parallel_uncoordinated_block_executor.rs (L369-386)
```rust
                let existed = self.deposit_apt(
                    fa_migration_complete,
                    recipient,
                    amount,
                    state_view,
                    &mut output,
                )?;

                if !existed || fail_on_recipient_account_existing {
                    self.check_or_create_account(
                        recipient,
                        fail_on_recipient_account_existing,
                        fail_on_recipient_account_missing,
                        !fa_migration_complete,
                        state_view,
                        &mut output,
                    )?;
                }
```

**File:** execution/executor-benchmark/src/native/parallel_uncoordinated_block_executor.rs (L841-866)
```rust
    fn check_or_create_account(
        &self,
        address: AccountAddress,
        fail_on_account_existing: bool,
        fail_on_account_missing: bool,
        _create_account_resource: bool,
        state_view: &(impl StateView + Sync),
        _output: &mut IncrementalOutput,
    ) -> Result<()> {
        let account_key = self.db_util.new_state_key_account(&address);
        let mut missing = false;
        self.cache_get_mut_or_init(&account_key, |key| {
            CachedResource::Account(match DbAccessUtil::get_account(key, state_view).unwrap() {
                Some(account) => account,
                None => {
                    missing = true;
                    assert!(!fail_on_account_missing);
                    DbAccessUtil::new_account_resource(address)
                },
            })
        });
        if fail_on_account_existing {
            assert!(missing);
        }
        Ok(())
    }
```

**File:** execution/executor-benchmark/src/native/parallel_uncoordinated_block_executor.rs (L1074-1112)
```rust
    fn update_fa_balance(
        &self,
        account: AccountAddress,
        state_view: &(impl StateView + Sync),
        increment: u64,
        decrement: u64,
        fail_on_missing: bool,
    ) -> bool {
        let store_address = primary_apt_store(account);
        let fungible_store_rg_tag = &self.db_util.common.fungible_store;
        let cache_key = StateKey::resource(&store_address, fungible_store_rg_tag).unwrap();

        let mut exists = true;
        let mut entry = self.cache.entry(cache_key).or_insert_with(|| {
            let fa_store_object_key = self
                .db_util
                .new_state_key_object_resource_group(&store_address);
            let rg_opt =
                DbAccessUtil::get_resource_group(&fa_store_object_key, state_view).unwrap();
            CachedResource::FungibleStore(match rg_opt {
                Some(mut rg) => {
                    bcs::from_bytes(&rg.remove(fungible_store_rg_tag).unwrap()).unwrap()
                },
                None => {
                    exists = false;
                    assert!(!fail_on_missing);
                    FungibleStoreResource::new(AccountAddress::TEN, 0, false)
                },
            })
        });
        match entry.value_mut() {
            CachedResource::FungibleStore(fungible_store_resource) => {
                fungible_store_resource.balance += increment;
                fungible_store_resource.balance -= decrement;
            },
            _ => panic!("wrong type"),
        };
        exists
    }
```

**File:** execution/executor-benchmark/src/native/native_transaction.rs (L80-89)
```rust
                            (AccountAddress::ONE, "aptos_account", "create_account") => {
                                Self::Transfer {
                                    sender: user_txn.sender(),
                                    sequence_number: user_txn.sequence_number(),
                                    recipient: bcs::from_bytes(&f.args()[0]).unwrap(),
                                    amount: 0,
                                    fail_on_recipient_account_existing: true,
                                    fail_on_recipient_account_missing: false,
                                }
                            },
```

**File:** execution/executor-benchmark/src/main.rs (L291-295)
```rust
    /// Transaction execution: Native rust code updating in-memory state, no WriteSet output
    /// Executing conflicts: All transactions execute on the state in the first come - first serve basis
    /// State: In-memory DashMap with rust values of state (i.e. StateKey -> Resource (either Account or FungibleStore)),
    ///        cached across blocks, filled upon first request
    NativeValueCacheParallelUncoordinated,
```

**File:** execution/executor-benchmark/src/main.rs (L697-701)
```rust
        BlockExecutorTypeOpt::NativeValueCacheParallelUncoordinated => {
            run::<NativeParallelUncoordinatedBlockExecutor<NativeValueCacheRawTransactionExecutor>>(
                opt,
            );
        },
```
