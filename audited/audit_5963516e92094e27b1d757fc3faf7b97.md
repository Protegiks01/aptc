# Audit Report

## Title
Incorrect first_transaction_version in Empty TransactionListWithProof Causes State Sync Stalls

## Summary
The `get_transactions_with_proof_by_size()` function in the storage service incorrectly sets `first_transaction_version = Some(start_version)` when returning an empty transaction list, violating the documented semantic contract. This causes state sync clients to calculate negative progress (`synced_version = start_version - 1`), leading to infinite retry loops where clients repeatedly request the same transaction version without advancing.

## Finding Description

The storage service violates a critical invariant documented in the `TransactionListWithProof` structure. The semantic contract explicitly states: "If `first_transaction_version` is None, the transaction list is empty. Otherwise, the transaction list starts at `first_transaction_version`." [1](#0-0) 

However, the `get_transactions_with_proof_by_size()` implementation unconditionally passes `Some(start_version)` as the `first_transaction_version` parameter, regardless of whether the transactions list is empty: [2](#0-1) 

This bug manifests when database iterators return `None` prematurely (before fetching the requested number of transactions). The iterator implementation uses `ContinuousVersionIter` which returns `None` when the underlying database iterator is exhausted: [3](#0-2) 

When this occurs, the fetch loop terminates with zero transactions but still constructs a response with `Some(start_version)`: [4](#0-3) 

**Client-Side Impact:**

State sync clients extract the `payload_start_version` from the received `TransactionListWithProof`: [5](#0-4) 

The client then validates this matches the expected version and calculates the new synced version: [6](#0-5) 

With zero transactions, this calculation becomes: `synced_version = start_version + 0 - 1 = start_version - 1`

The next iteration calculates `expected_next_version = synced_version + 1 = (start_version - 1) + 1 = start_version`: [7](#0-6) 

This creates an infinite loop where the client makes no progress and continuously requests the same `start_version`.

**Correct Implementation:**

The database reader correctly handles empty transaction lists by returning `None` as `first_transaction_version`: [8](#0-7) 

And only uses `Some(start_version)` when transactions actually exist: [9](#0-8) 

The same vulnerability exists in `get_transaction_outputs_with_proof_by_size()`: [10](#0-9) 

## Impact Explanation

**Severity: Medium** (aligns with Aptos Bug Bounty "State inconsistencies requiring manual intervention" category, up to $10,000)

This vulnerability causes state sync liveness failures:

1. **State Sync Stalls**: Affected clients enter infinite retry loops, unable to make forward progress in synchronization
2. **Requires Manual Intervention**: Operators must diagnose and restart affected nodes
3. **Network Health Degradation**: Multiple nodes experiencing this issue simultaneously reduces overall network resilience
4. **Semantic Contract Violation**: Breaks fundamental invariants that the state sync protocol depends on

This does not qualify as Critical severity because it:
- Does not enable direct fund theft or consensus violations
- Does not cause permanent network partition
- Affects individual nodes rather than entire network liveness
- Can be resolved through node restart

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability triggers under realistic operational conditions:

1. **Database Iterator Exhaustion**: The `ContinuousVersionIter` returns `None` when underlying data is unavailable, which occurs during:
   - Pruning operations where transactions are deleted but requests still reference pruned versions
   - Database inconsistencies or corruption
   - Race conditions between pruning and read operations
   - Incomplete state sync on the serving node

2. **Production Code Path**: The vulnerable code executes when `enable_size_and_time_aware_chunking = true`, which is the modern implementation

3. **No Protective Guards**: No validation prevents returning empty transaction lists with incorrect metadata

4. **Increased During**: Network stress, aggressive pruning, node recovery scenarios, and high transaction volumes

## Recommendation

Modify `get_transactions_with_proof_by_size()` to check if the transactions list is empty and set `first_transaction_version = None` accordingly:

```rust
let first_transaction_version = if transactions.is_empty() {
    None
} else {
    Some(start_version)
};

let transaction_list_with_proof = TransactionListWithProof::new(
    transactions,
    transaction_events,
    first_transaction_version,
    info_list_with_proof,
);
```

Apply the same fix to `get_transaction_outputs_with_proof_by_size()`:

```rust
let first_output_version = if transactions_and_outputs.is_empty() {
    None
} else {
    Some(start_version)
};

let transaction_output_list_with_proof = TransactionOutputListWithProof::new(
    transactions_and_outputs,
    first_output_version,
    transaction_info_list_with_proof,
);
```

## Proof of Concept

The vulnerability can be demonstrated by simulating a scenario where the database iterator returns no data:

1. Deploy a node with state sync enabled
2. Trigger aggressive pruning to remove transactions
3. Request transactions at a pruned version range
4. Observe the storage service returns empty list with `Some(version)`
5. Monitor client logs showing repeated requests for the same version
6. Observe `synced_version` does not advance (remains at `requested_version - 1`)

The infinite loop manifests as:
- Client expects version N
- Server returns empty list with `first_transaction_version = Some(N)`
- Client calculates `synced_version = N - 1`
- Client next requests version `(N-1) + 1 = N`
- Loop continues indefinitely

**Notes:**

This vulnerability represents a semantic contract violation in the state synchronization protocol. The documented behavior requires `first_transaction_version = None` for empty lists to signal to clients that no data is available, allowing proper error handling and stream reset. The current implementation bypasses this by providing a valid-looking version number for an empty dataset, causing clients to incorrectly believe they processed data and make negative progress. This is distinct from network DoS attacks as it stems from a protocol implementation bug rather than malicious network behavior.

### Citations

**File:** types/src/transaction/mod.rs (L2292-2293)
```rust
    /// 3. If `first_transaction_version` is None, the transaction list is empty.
    ///    Otherwise, the transaction list starts at `first_transaction_version`.
```

**File:** state-sync/storage-service/server/src/storage.rs (L457-469)
```rust
                None => {
                    // Log a warning that the iterators did not contain all the expected data
                    warn!(
                        "The iterators for transactions, transaction infos, events and \
                        persisted auxiliary infos are missing data! Start version: {:?}, \
                        end version: {:?}, num transactions to fetch: {:?}, num fetched: {:?}.",
                        start_version,
                        end_version,
                        num_transactions_to_fetch,
                        transactions.len()
                    );
                    break;
                },
```

**File:** state-sync/storage-service/server/src/storage.rs (L488-493)
```rust
        let transaction_list_with_proof = TransactionListWithProof::new(
            transactions,
            transaction_events,
            Some(start_version),
            info_list_with_proof,
        );
```

**File:** state-sync/storage-service/server/src/storage.rs (L711-715)
```rust
        let transaction_output_list_with_proof = TransactionOutputListWithProof::new(
            transactions_and_outputs,
            Some(start_version),
            transaction_info_list_with_proof,
        );
```

**File:** storage/aptosdb/src/utils/iterators.rs (L40-62)
```rust
    fn next_impl(&mut self) -> Result<Option<T>> {
        if self.expected_next_version >= self.end_version {
            return Ok(None);
        }

        let ret = match self.inner.next().transpose()? {
            Some((version, transaction)) => {
                ensure!(
                    version == self.expected_next_version,
                    "{} iterator: first version {}, expecting version {}, got {} from underlying iterator.",
                    std::any::type_name::<T>(),
                    self.first_version,
                    self.expected_next_version,
                    version,
                );
                self.expected_next_version += 1;
                Some(transaction)
            },
            None => None,
        };

        Ok(ret)
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L621-634)
```rust
                DataPayload::TransactionsWithProof(transactions_with_proof) => {
                    let payload_start_version =
                        transactions_with_proof.get_first_transaction_version();
                    let notification_metadata = NotificationMetadata::new(
                        data_notification.creation_time,
                        data_notification.notification_id,
                    );
                    self.process_transaction_or_output_payload(
                        notification_metadata,
                        Some(transactions_with_proof),
                        None,
                        payload_start_version,
                    )
                    .await?;
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L1255-1260)
```rust
        let synced_version = payload_start_version
            .checked_add(num_transactions_or_outputs as u64)
            .and_then(|version| version.checked_sub(1)) // synced_version = start + num txns/outputs - 1
            .ok_or_else(|| Error::IntegerOverflow("The synced version has overflown!".into()))?;
        self.get_speculative_stream_state()?
            .update_synced_version(synced_version);
```

**File:** state-sync/state-sync-driver/src/utils.rs (L67-72)
```rust
    /// Returns the next version that we expect along the stream
    pub fn expected_next_version(&self) -> Result<Version, Error> {
        self.synced_version.checked_add(1).ok_or_else(|| {
            Error::IntegerOverflow("The expected next version has overflown!".into())
        })
    }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L277-278)
```rust
            if start_version > ledger_version || limit == 0 {
                return Ok(TransactionListWithProofV2::new_empty());
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L319-324)
```rust
            Ok(TransactionListWithProofV2::new(
                TransactionListWithAuxiliaryInfos::new(
                    TransactionListWithProof::new(txns, events, Some(start_version), proof),
                    persisted_aux_info,
                ),
            ))
```
