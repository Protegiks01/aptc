# Audit Report

## Title
Missing Transaction Hash Verification in Replay Command Enables Data Spoofing

## Summary
The `Replay::execute()` function fetches transaction data from a REST API endpoint but fails to verify that the transaction's committed hash matches the `transaction_hash` field stored in the corresponding `TransactionInfo`. This allows an attacker controlling the REST endpoint (via MITM or malicious server) to provide fabricated transaction data that passes all verification checks, potentially misleading security auditors and developers analyzing blockchain transactions.

## Finding Description

The replay functionality in the Aptos CLI is designed to re-execute historical transactions for debugging, gas profiling, and security analysis. The execution flow is as follows: [1](#0-0) 

The transaction and its associated `TransactionInfo` are fetched from a REST API endpoint, then the transaction's committed hash is computed. However, this hash is never verified against the `transaction_hash` field within the `TransactionInfo`. [2](#0-1) 

The transaction is executed, and the output is compared against the `TransactionInfo`: [3](#0-2) 

The `ensure_match_transaction_info()` method only validates four fields: [4](#0-3) 

Notably absent is verification of the transaction hash. The `TransactionInfo` structure contains a `transaction_hash` field: [5](#0-4) 

But this field is never compared against the actual transaction's committed hash during replay.

**Attack Scenario:**
1. Attacker performs MITM attack on REST API traffic or tricks user into connecting to malicious endpoint
2. User executes: `aptos move replay --network <endpoint> --txn-id 12345`
3. Attacker responds with fabricated `Transaction` and `TransactionInfo` that are internally consistent
4. Replay executes the fake transaction and compares output against fake `TransactionInfo`
5. All checks pass because both transaction and metadata are attacker-controlled
6. User believes they analyzed transaction 12345 but actually analyzed attacker's fabricated transaction

This breaks the security guarantee that replay provides authentic transaction data from the blockchain. Users rely on this tool for security audits and forensic analysis.

## Impact Explanation

This issue falls into **Medium Severity** under the bug bounty criteria: "State inconsistencies requiring intervention."

While this is a client-side debugging tool rather than consensus-critical infrastructure, it has security-relevant implications:

1. **Compromised Security Analysis**: Security auditors using replay to investigate exploits or suspicious transactions could be analyzing completely fabricated data
2. **Evidence Tampering**: In dispute resolution or forensic investigations, an attacker could provide false "replay results" 
3. **Developer Misdirection**: Developers debugging transaction failures would be analyzing wrong execution paths
4. **False Confidence**: The tool provides no warning that data authenticity is not verified, giving users false confidence

The impact is limited because:
- No direct effect on consensus, validator operations, or on-chain funds
- Requires MITM or user connecting to malicious endpoint
- Does not affect the blockchain state itself

However, the missing cryptographic verification in a security-sensitive tool used for blockchain analysis justifies Medium severity classification.

## Likelihood Explanation

**Likelihood: Medium**

The attack requires:
- User running the replay command against an attacker-controlled or MITM'd endpoint
- User trusting the endpoint without independent verification

This is realistic because:
- REST API MITM attacks are practical on unsecured networks
- Users may test against custom or community-run endpoints
- No warning is provided about the lack of cryptographic verification
- The tool is commonly used for security-critical analysis

The attack complexity is low once the endpoint is controlled, as the attacker simply needs to provide consistent transaction and metadata pairs.

## Recommendation

Add explicit verification that the transaction hash matches the `TransactionInfo`'s `transaction_hash` field:

```rust
// In Replay::execute(), after line 2418:
let hash = txn.committed_hash();

// ADD THIS VERIFICATION:
if hash != txn_info.transaction_hash() {
    return Err(CliError::UnexpectedError(format!(
        "Transaction hash mismatch: computed {:?}, but TransactionInfo contains {:?}. \
         This indicates the transaction data may have been tampered with.",
        hash,
        txn_info.transaction_hash()
    )));
}
```

Additionally, consider implementing cryptographic proof verification using `TransactionWithProof` to ensure the `TransactionInfo` itself is authentic and part of the blockchain's accumulator: [6](#0-5) 

This would require fetching accumulator proofs alongside the transaction data and verifying them against a trusted ledger info.

## Proof of Concept

```rust
// Demonstration of the vulnerability:
// File: crates/aptos/tests/replay_spoof_test.rs

#[tokio::test]
async fn test_replay_accepts_mismatched_transaction_hash() {
    use aptos_types::transaction::{Transaction, SignedTransaction, TransactionInfo};
    use aptos_crypto::HashValue;
    
    // Simulate fetching from malicious REST API
    // Create transaction T1
    let txn1 = create_test_transaction(/* ... */);
    let hash1 = txn1.committed_hash();
    
    // Create different transaction T2 with matching output characteristics
    let txn2 = create_test_transaction_with_matching_outputs(/* ... */);
    let hash2 = txn2.committed_hash();
    
    // Create TransactionInfo for T1 but execute T2
    let txn_info = TransactionInfo::new(
        hash1, // Contains hash of T1
        /* ... other fields matching T2's output ... */
    );
    
    // Current implementation: This passes verification despite hash mismatch
    // because ensure_match_transaction_info() never checks transaction_hash
    assert_ne!(hash1, hash2); // Hashes are different
    
    // Execute T2 against TransactionInfo for T1
    let output = execute_transaction(txn2);
    
    // This should fail but currently passes
    output.ensure_match_transaction_info(version, &txn_info, None, None)
        .expect("Should detect hash mismatch but doesn't");
}
```

## Notes

This vulnerability is specific to the `Replay` command, a client-side debugging tool. It does not affect:
- Validator consensus operations
- Transaction validation in mempool or execution
- On-chain state or funds
- Other nodes or network participants

The security impact is limited to users of the replay tool who may be misled by spoofed data. The fix is straightforward: add explicit hash verification before executing the replayed transaction.

### Citations

**File:** crates/aptos/src/move_tool/mod.rs (L2404-2418)
```rust
        let (txn, txn_info, aux_info) = debugger
            .get_committed_transaction_at_version(self.txn_id)
            .await?;

        let txn = match txn {
            Transaction::UserTransaction(txn) => txn,
            _ => {
                return Err(CliError::UnexpectedError(
                    "Unsupported transaction type. Only user transactions are supported."
                        .to_string(),
                ))
            },
        };

        let hash = txn.committed_hash();
```

**File:** crates/aptos/src/move_tool/mod.rs (L2420-2448)
```rust
        // Execute the transaction.
        let (vm_status, vm_output) = if self.profile_gas {
            println!("Profiling transaction...");
            local_simulation::profile_transaction_using_debugger(
                &debugger,
                self.txn_id,
                txn.clone(),
                hash,
                aux_info,
            )?
        } else if self.benchmark {
            println!("Benchmarking transaction...");
            local_simulation::benchmark_transaction_using_debugger(
                &debugger,
                self.txn_id,
                txn.clone(),
                hash,
                aux_info,
            )?
        } else {
            println!("Replaying transaction...");
            local_simulation::run_transaction_using_debugger(
                &debugger,
                self.txn_id,
                txn.clone(),
                hash,
                aux_info,
            )?
        };
```

**File:** crates/aptos/src/move_tool/mod.rs (L2463-2467)
```rust
        if !self.skip_comparison {
            txn_output
                .ensure_match_transaction_info(self.txn_id, &txn_info, None, None)
                .map_err(|msg| CliError::UnexpectedError(msg.to_string()))?;
        }
```

**File:** types/src/transaction/mod.rs (L1417-1439)
```rust
    pub fn verify(&self, ledger_info: &LedgerInfo) -> Result<()> {
        let txn_hash = self.transaction.hash();
        ensure!(
            txn_hash == self.proof.transaction_info().transaction_hash(),
            "Transaction hash ({}) not expected ({}).",
            txn_hash,
            self.proof.transaction_info().transaction_hash(),
        );

        if let Some(events) = &self.events {
            let event_hashes: Vec<_> = events.iter().map(CryptoHash::hash).collect();
            let event_root_hash =
                InMemoryEventAccumulator::from_leaves(&event_hashes[..]).root_hash();
            ensure!(
                event_root_hash == self.proof.transaction_info().event_root_hash(),
                "Event root hash ({}) not expected ({}).",
                event_root_hash,
                self.proof.transaction_info().event_root_hash(),
            );
        }

        self.proof.verify(ledger_info, self.version)
    }
```

**File:** types/src/transaction/mod.rs (L1869-1928)
```rust
    pub fn ensure_match_transaction_info(
        &self,
        version: Version,
        txn_info: &TransactionInfo,
        expected_write_set: Option<&WriteSet>,
        expected_events: Option<&[ContractEvent]>,
    ) -> Result<()> {
        const ERR_MSG: &str = "TransactionOutput does not match TransactionInfo";

        let expected_txn_status: TransactionStatus = txn_info.status().clone().into();
        ensure!(
            self.status() == &expected_txn_status,
            "{}: version:{}, status:{:?}, auxiliary data:{:?}, expected:{:?}",
            ERR_MSG,
            version,
            self.status(),
            self.auxiliary_data(),
            expected_txn_status,
        );

        ensure!(
            self.gas_used() == txn_info.gas_used(),
            "{}: version:{}, gas_used:{:?}, expected:{:?}",
            ERR_MSG,
            version,
            self.gas_used(),
            txn_info.gas_used(),
        );

        let write_set_hash = CryptoHash::hash(self.write_set());
        ensure!(
            write_set_hash == txn_info.state_change_hash(),
            "{}: version:{}, write_set_hash:{:?}, expected:{:?}, write_set: {:?}, expected(if known): {:?}",
            ERR_MSG,
            version,
            write_set_hash,
            txn_info.state_change_hash(),
            self.write_set,
            expected_write_set,
        );

        let event_hashes = self
            .events()
            .iter()
            .map(CryptoHash::hash)
            .collect::<Vec<_>>();
        let event_root_hash = InMemoryEventAccumulator::from_leaves(&event_hashes).root_hash;
        ensure!(
            event_root_hash == txn_info.event_root_hash(),
            "{}: version:{}, event_root_hash:{:?}, expected:{:?}, events: {:?}, expected(if known): {:?}",
            ERR_MSG,
            version,
            event_root_hash,
            txn_info.event_root_hash(),
            self.events(),
            expected_events,
        );

        Ok(())
    }
```

**File:** types/src/transaction/mod.rs (L2025-2051)
```rust
pub struct TransactionInfoV0 {
    /// The amount of gas used.
    gas_used: u64,

    /// The vm status. If it is not `Executed`, this will provide the general error class. Execution
    /// failures and Move abort's receive more detailed information. But other errors are generally
    /// categorized with no status code or other information
    status: ExecutionStatus,

    /// The hash of this transaction.
    transaction_hash: HashValue,

    /// The root hash of Merkle Accumulator storing all events emitted during this transaction.
    event_root_hash: HashValue,

    /// The hash value summarizing all changes caused to the world state by this transaction.
    /// i.e. hash of the output write set.
    state_change_hash: HashValue,

    /// The root hash of the Sparse Merkle Tree describing the world state at the end of this
    /// transaction. Depending on the protocol configuration, this can be generated periodical
    /// only, like per block.
    state_checkpoint_hash: Option<HashValue>,

    /// The hash value summarizing PersistedAuxiliaryInfo.
    auxiliary_info_hash: Option<HashValue>,
}
```
