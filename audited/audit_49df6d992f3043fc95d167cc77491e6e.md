# Audit Report

## Title
Genesis Transaction Omission in Backup System Breaks Chain History Verification

## Summary
The backup system allows creation of transaction backups starting from version > 0 without validation, enabling genesis transactions (version 0) to be permanently omitted from backups. This breaks validators' ability to verify chain history from genesis and prevents disaster recovery scenarios.

## Finding Description

The Aptos backup system has a critical gap in validation that allows genesis transactions to be omitted from backups, breaking the ability to verify chain history from genesis.

**Root Cause**: The `TransactionBackupController` accepts an arbitrary `start_version` parameter via CLI without validation: [1](#0-0) 

An operator can manually create a backup starting from version 1 or higher, bypassing genesis (version 0). When saved, no validation occurs: [2](#0-1) 

**Propagation**: When the backup coordinator initializes or restarts, it loads the backup state and uses the maximum `last_version` across all backups without validating version 0 exists: [3](#0-2) 

The coordinator then continues backing up from this version onwards: [4](#0-3) 

The `get_batch_range` function determines the next backup range based on the last backed up version: [5](#0-4) 

If the first backup starts at version 1, `get_batch_range` returns `(0, 0)` initially, but since `latest_transaction_version = Some(1)` or higher, it instead returns `(version+1, ...)`, permanently skipping version 0.

**Detection**: The missing genesis is only detected during restore/verify when `select_transaction_backups` validates continuity from version 0: [6](#0-5) 

This check fails with error: "Transaction backup ranges not continuous, expecting version 0, got 1."

**Broken Invariant**: The State Consistency invariant is violated - backups are incomplete and validators cannot verify chain history from genesis, which is required for establishing trust in the chain's entire history.

## Impact Explanation

This is **HIGH severity** per Aptos bug bounty criteria:

1. **Significant Protocol Violation**: Validators cannot verify the complete chain history from genesis, which is fundamental to blockchain trust assumptions.

2. **Validator Operational Impact**: When a validator fails and needs to restore from backup, the restoration fails if genesis is missing. This causes "validator node slowdowns" or complete inability to rejoin the network.

3. **Disaster Recovery Failure**: In catastrophic scenarios requiring full chain restoration, if genesis is missing from backups, recovery is impossible without obtaining genesis data from alternative sources.

4. **Data Integrity**: Once genesis is omitted and the coordinator continues backing up, the backup storage is permanently broken for full chain verification unless manually corrected.

## Likelihood Explanation

**HIGH likelihood** due to multiple attack vectors:

1. **Accidental Misconfiguration**: Operator inadvertently runs manual backup with `--start-version 1`, or misconfigures initial backup automation.

2. **Accidental Deletion**: Operator or automated cleanup script deletes the backup file containing version 0, thinking it's old/unused data.

3. **Malicious Deletion**: Attacker with storage access deletes version 0 backup to sabotage disaster recovery capabilities.

4. **Storage System Error**: Storage system failure or corruption affects only the oldest backup files containing version 0.

No special privileges are required - just the ability to run backup commands or access backup storage. The issue persists silently until restore/verify is attempted, potentially months or years later.

## Recommendation

Implement multi-layered validation:

**1. Validate at Backup Creation:**
```rust
// In TransactionBackupController::new()
pub fn new(
    opt: TransactionBackupOpt,
    global_opt: GlobalBackupOpt,
    client: Arc<BackupServiceClient>,
    storage: Arc<dyn BackupStorage>,
) -> Self {
    // Add validation
    if opt.start_version > 0 {
        warn!(
            "Creating backup starting from version {} (not from genesis). \
            This may break chain history verification if version 0 is not backed up separately.",
            opt.start_version
        );
    }
    // ... rest of constructor
}
```

**2. Validate at Coordinator Initialization:**
```rust
// In BackupCoordinator::run()
pub async fn run(&self) -> Result<()> {
    let backup_state = metadata::cache::sync_and_load(...)
        .await?
        .get_storage_state()?;
    
    // Add validation
    if backup_state.latest_transaction_version.is_some() {
        // Verify version 0 exists
        let meta_view = metadata::cache::sync_and_load(...).await?;
        let genesis_backups = meta_view.select_transaction_backups(0, 0)?;
        ensure!(
            !genesis_backups.is_empty(),
            "Genesis transaction (version 0) is missing from backups. \
            Cannot continue - please restore version 0 backup before proceeding."
        );
    }
    // ... rest of function
}
```

**3. Add Explicit Genesis Validation:**
```rust
// In MetadataView::get_storage_state()
pub fn get_storage_state(&self) -> Result<BackupStorageState> {
    // existing code...
    let latest_transaction_version = self
        .transaction_backups
        .iter()
        .map(|t| t.last_version)
        .max();
    
    // Add validation
    if latest_transaction_version.is_some() {
        let has_genesis = self.transaction_backups
            .iter()
            .any(|b| b.first_version == 0);
        ensure!(
            has_genesis,
            "Genesis transaction (version 0) is missing from backup storage. \
            All backups must include genesis for chain history verification."
        );
    }
    
    Ok(BackupStorageState { /* ... */ })
}
```

## Proof of Concept

**Reproduction Steps:**

1. **Setup a test environment with AptosDB containing transactions 0-1000**

2. **Create a backup omitting genesis:**
```bash
# This command creates a backup starting from version 1, skipping genesis
aptos-db-tool backup one-shot Transaction \
    --start-version 1 \
    --num_transactions 1000 \
    --backup-service-address http://localhost:6186 \
    [storage-config]
```

3. **Start the backup coordinator:**
```bash
aptos-db-tool backup coordinator run \
    --backup-service-address http://localhost:6186 \
    [storage-config]
```

The coordinator will load `latest_transaction_version = Some(1000)` and continue backing up from version 1001 onwards. Genesis (version 0) is never backed up.

4. **Attempt to restore/verify:**
```bash
aptos-db-tool backup verify \
    [storage-config] \
    --target-version 2000
```

**Expected Result:** Error message:
```
Error: Transaction backup ranges not continuous, expecting version 0, got 1.
```

The restore/verify operation fails, proving validators cannot verify chain history from genesis when the backup omits version 0.

**Notes**

The vulnerability exists because:
1. No validation prevents backup creation starting from version > 0
2. Backup coordinator doesn't verify genesis exists before continuing
3. Detection only occurs during restore/verify operations, potentially months later
4. Recovery requires manual intervention or alternative data sources

This breaks the fundamental blockchain guarantee that the entire chain history from genesis is verifiable and recoverable.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/backup.rs (L24-30)
```rust
pub struct TransactionBackupOpt {
    #[clap(long = "start-version", help = "First transaction to backup.")]
    pub start_version: u64,

    #[clap(long = "num_transactions", help = "Number of transactions to backup")]
    pub num_transactions: usize,
}
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/backup.rs (L189-217)
```rust
    async fn write_manifest(
        &self,
        backup_handle: &BackupHandleRef,
        first_version: Version,
        last_version: Version,
        chunks: Vec<TransactionChunk>,
    ) -> Result<FileHandle> {
        let manifest = TransactionBackup {
            first_version,
            last_version,
            chunks,
        };
        let (manifest_handle, mut manifest_file) = self
            .storage
            .create_for_write(backup_handle, Self::manifest_name())
            .await?;
        manifest_file
            .write_all(&serde_json::to_vec(&manifest)?)
            .await?;
        manifest_file.shutdown().await?;

        let metadata =
            Metadata::new_transaction_backup(first_version, last_version, manifest_handle.clone());
        self.storage
            .save_metadata_line(&metadata.name(), &metadata.to_text_line()?)
            .await?;

        Ok(manifest_handle)
    }
```

**File:** storage/backup/backup-cli/src/metadata/view.rs (L80-101)
```rust
    pub fn get_storage_state(&self) -> Result<BackupStorageState> {
        let latest_epoch_ending_epoch =
            self.epoch_ending_backups.iter().map(|e| e.last_epoch).max();
        let latest_state_snapshot = self.select_state_snapshot(Version::MAX)?;
        let (latest_state_snapshot_epoch, latest_state_snapshot_version) =
            match latest_state_snapshot {
                Some(snapshot) => (Some(snapshot.epoch), Some(snapshot.version)),
                None => (None, None),
            };
        let latest_transaction_version = self
            .transaction_backups
            .iter()
            .map(|t| t.last_version)
            .max();

        Ok(BackupStorageState {
            latest_epoch_ending_epoch,
            latest_state_snapshot_epoch,
            latest_state_snapshot_version,
            latest_transaction_version,
        })
    }
```

**File:** storage/backup/backup-cli/src/metadata/view.rs (L132-160)
```rust
    pub fn select_transaction_backups(
        &self,
        start_version: Version,
        target_version: Version,
    ) -> Result<Vec<TransactionBackupMeta>> {
        // This can be more flexible, but for now we assume and check backups are continuous in
        // range (which is always true when we backup from a single backup coordinator)
        let mut next_ver = 0;
        let mut res = Vec::new();
        for backup in self.transaction_backups.iter().sorted() {
            if backup.first_version > target_version {
                break;
            }
            ensure!(
                backup.first_version == next_ver,
                "Transaction backup ranges not continuous, expecting version {}, got {}.",
                next_ver,
                backup.first_version,
            );

            if backup.last_version >= start_version {
                res.push(backup.clone());
            }

            next_ver = backup.last_version + 1;
        }

        Ok(res)
    }
```

**File:** storage/backup/backup-cli/src/coordinators/backup.rs (L269-302)
```rust
    async fn backup_transactions(
        &self,
        mut last_transaction_version_in_backup: Option<Version>,
        db_state: DbState,
    ) -> Result<Option<u64>> {
        loop {
            if let Some(version) = last_transaction_version_in_backup {
                TRANSACTION_VERSION.set(version as i64);
            }
            let (first, last) = get_batch_range(
                last_transaction_version_in_backup,
                self.transaction_batch_size,
            );

            if db_state.committed_version < last {
                // wait for the next db_state update
                return Ok(last_transaction_version_in_backup);
            }

            TransactionBackupController::new(
                TransactionBackupOpt {
                    start_version: first,
                    num_transactions: (last + 1 - first) as usize,
                },
                self.global_opt.clone(),
                Arc::clone(&self.client),
                Arc::clone(&self.storage),
            )
            .run()
            .await?;

            last_transaction_version_in_backup = Some(last);
        }
    }
```

**File:** storage/backup/backup-cli/src/coordinators/backup.rs (L490-500)
```rust
fn get_batch_range(last_in_backup: Option<u64>, batch_size: usize) -> (u64, u64) {
    // say, 7 is already in backup, and we target batches of size 10, we will return (8, 10) in this
    // case, so 8, 9, 10 will be in this batch, and next time the backup worker will pass in 10,
    // and we will return (11, 20). The transaction 0 will be in it's own batch.
    last_in_backup.map_or((0, 0), |n| {
        let first = n + 1;
        let batch = n / batch_size as u64 + 1;
        let last = batch * batch_size as u64;
        (first, last)
    })
}
```
