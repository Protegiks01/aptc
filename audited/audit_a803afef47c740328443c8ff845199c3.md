# Audit Report

## Title
Unvalidated Unwrap on BLS-to-DKG Key Conversion Can Panic Validator During Epoch Initialization

## Summary
A `.unwrap()` call during DKG encryption key derivation from validator consensus public keys can cause validator nodes to panic and crash during epoch transitions when randomness is enabled. This occurs when converting BLS public keys to DKG encryption keys, where differing validation levels between the two key types can trigger deserialization failures.

## Finding Description

The vulnerability lies in the DKG key setup code that executes during validator epoch initialization. When randomness/DKG is enabled on-chain, validators must convert BLS consensus public keys into DKG encryption keys during the `build_dkg_pvss_config` function.

**Critical Code Path:** [1](#0-0) 

This code performs the conversion:
1. Takes BLS public keys from the validator set (stored in DKG session metadata)
2. Serializes them to bytes via `to_bytes()`
3. Attempts to deserialize as `EncPK` (DKG encryption public key) via `try_into()`
4. Uses `.unwrap()` which panics on failure

**The Validation Mismatch:**

BLS public key deserialization does NOT perform subgroup validation: [2](#0-1) 

However, DKG encryption key deserialization via `g1_proj_from_bytes()` DOES enforce subgroup validation: [3](#0-2) 

The conversion path is: [4](#0-3) 

**Execution Flow:**

During epoch initialization: [5](#0-4) 

This calls: [6](#0-5) 

Which invokes: [7](#0-6) 

## Impact Explanation

**Severity: High (Validator Node Crash)**

This meets the High severity criteria of "Validator node slowdowns/API crashes" from the bug bounty program. While errors from `try_get_rand_config_for_new_epoch` are caught and handled gracefully, the `.unwrap()` panic occurs BEFORE the Result can be returned, causing immediate validator termination.

**Impact:**
- Validators crash during epoch transitions when randomness is enabled
- Affected validators cannot participate in consensus
- Network liveness is degraded if multiple validators are affected
- No permanent state corruption, but requires node restart

This breaks the **Consensus Liveness** invariant - validators must remain available to process blocks.

## Likelihood Explanation

**Likelihood: Low**

The vulnerability requires:
1. Randomness/DKG to be enabled on-chain
2. A BLS public key in the validator set that:
   - Is a valid curve point (passes on-chain validation)
   - Is NOT in the prime-order subgroup (fails DKG validation)
3. The malformed key to be present in the DKG session metadata

This is unlikely because:
- On-chain validator registration requires Proof-of-Possession (PoP) verification
- PoP verification implicitly performs subgroup validation
- The validator set goes through multiple validation layers

However, if through a bug or oversight a non-subgroup key enters the validator set, ALL validators would crash when attempting to start an epoch with randomness enabled.

## Recommendation

Replace the `.unwrap()` with proper error handling that propagates the error:

```rust
let consensus_keys: Result<Vec<EncPK>, _> = validator_consensus_keys
    .iter()
    .map(|k| k.to_bytes().as_slice().try_into())
    .collect();

let consensus_keys = consensus_keys
    .context("Failed to convert BLS public keys to DKG encryption keys")?;
```

This allows the error to propagate up to `try_get_rand_config_for_new_epoch`, which already handles errors gracefully by logging and disabling randomness rather than crashing.

Additionally, enforce consistent subgroup validation at the BLS public key level during on-chain validator registration to prevent this validation mismatch.

## Proof of Concept

```rust
// Theoretical PoC - cannot be directly tested without modifying on-chain state
// This demonstrates the panic condition

use aptos_crypto::bls12381::PublicKey;
use aptos_dkg::pvss::encryption_dlog::g1::EncryptPubKey;

// Assume we have a BLS public key that's on the curve but not in the subgroup
// (This would need to be crafted specifically and would fail PoP verification)
let malformed_pk_bytes: [u8; 48] = [...]; // Crafted bytes

// This succeeds - no subgroup check
let bls_pk = PublicKey::try_from(&malformed_pk_bytes[..]).unwrap();

// This fails - subgroup check enforced
let bytes = bls_pk.to_bytes();
let result = EncryptPubKey::try_from(bytes.as_slice());

// In build_dkg_pvss_config, this would panic:
// let enc_pk = bytes.as_slice().try_into().unwrap(); // PANIC!
```

**Note**: While this is a genuine code quality issue and potential panic point, it does NOT match the exact scenario described in the security question about "corrupted on-disk validator keys" causing failures. The keys involved come from on-chain state, not disk storage. The private keys stored on disk use different deserialization paths that don't involve `g1_proj_from_bytes()`.

### Citations

**File:** types/src/dkg/real_dkg/mod.rs (L124-127)
```rust
    let consensus_keys: Vec<EncPK> = validator_consensus_keys
        .iter()
        .map(|k| k.to_bytes().as_slice().try_into().unwrap())
        .collect::<Vec<_>>();
```

**File:** types/src/dkg/real_dkg/mod.rs (L211-217)
```rust
        let pvss_config = build_dkg_pvss_config(
            dkg_session_metadata.dealer_epoch,
            secrecy_threshold,
            reconstruct_threshold,
            maybe_fast_path_secrecy_threshold,
            &dkg_session_metadata.target_validator_consensus_infos_cloned(),
        );
```

**File:** crates/aptos-crypto/src/bls12381/bls12381_keys.rs (L230-234)
```rust
    /// Deserializes a PublicKey from a sequence of bytes.
    ///
    /// WARNING: Does NOT subgroup-check the public key! Instead, the caller is responsible for
    /// verifying the public key's proof-of-possession (PoP) via `ProofOfPossession::verify`,
    /// which implicitly subgroup-checks the public key.
```

**File:** crates/aptos-crypto/src/blstrs/mod.rs (L96-97)
```rust
/// Helper method to *securely* parse a sequence of bytes into a `G1Projective` point.
/// NOTE: This function will check for prime-order subgroup membership in $\mathbb{G}_1$.
```

**File:** crates/aptos-dkg/src/pvss/encryption_dlog.rs (L203-204)
```rust
            fn try_from(bytes: &[u8]) -> std::result::Result<EncryptPubKey, Self::Error> {
                $gt_proj_from_bytes(bytes).map(|ek| EncryptPubKey { ek })
```

**File:** consensus/src/epoch_manager.rs (L1046-1046)
```rust
        let dkg_pub_params = DefaultDKG::new_public_params(&dkg_session.metadata);
```

**File:** consensus/src/epoch_manager.rs (L1235-1241)
```rust
        let rand_configs = self.try_get_rand_config_for_new_epoch(
            loaded_consensus_key.clone(),
            &epoch_state,
            &onchain_randomness_config,
            dkg_state,
            &consensus_config,
        );
```
