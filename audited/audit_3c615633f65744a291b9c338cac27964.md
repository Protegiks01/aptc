# Audit Report

## Title
Missing BatchRequest Verification Allows Unauthorized Batch Data Retrieval

## Summary
The `BatchRequest::verify()` function exists to validate batch retrieval requests but is never called in the batch serving flow. Due to the `aptos_channel` design, the peer ID is lost when messages are dequeued, making it impossible to verify requests even if desired. This allows any authenticated validator to request arbitrary batches without authorization checks, potentially enabling early access to transaction data and bypassing intended access controls in the quorum store protocol.

## Finding Description
The quorum store protocol implements a batch request/response system where validators can request batches by digest. The `BatchRequest` struct includes a `verify()` method designed to validate that the claimed source matches the actual network peer ID. [1](#0-0) 

However, when batch retrieval requests are processed, this verification is never performed. The batch serving task receives requests through an `aptos_channel::Receiver<AccountAddress, IncomingBatchRetrievalRequest>` channel. [2](#0-1) 

The critical flaw is in how the channel is consumed. When `.next()` is called on the receiver, only the message (`IncomingBatchRetrievalRequest`) is returned, not the associated key (peer ID). [3](#0-2) 

The batch serving task directly processes requests without any validation: [4](#0-3) 

This breaks the intended security model where batch requests should be sent to specific "responders" (signers who have the batch). [5](#0-4) 

A malicious validator can:
1. Observe `BatchInfo` messages broadcast across the network
2. Create `BatchRequest` messages for any digest with an arbitrary `source` field
3. Send requests to any validator who has stored the batch
4. Receive batch payloads without verification of authorization
5. Potentially set `source` to another validator's peer ID, causing misattribution

## Impact Explanation
This vulnerability qualifies as **High Severity** based on the Aptos bug bounty criteria for "Significant protocol violations."

The impact includes:
- **Access Control Bypass**: Any validator can request batches they are not designated responders for, violating the intended quorum store access model
- **Information Leakage**: Malicious validators can gain early access to transaction batches before they are officially certified via ProofOfStore, potentially learning about pending transactions
- **Source Spoofing**: Without verification, the `source` field is untrusted, allowing attackers to impersonate other validators in batch requests
- **Protocol Integrity**: The existence of `verify()` indicates intended validation that is completely bypassed

While network-level authentication restricts connections to validators only, this doesn't mean all validators should have unrestricted access to all batches at all times. The quorum store protocol specifically identifies "signers" as responders for a reason - to control access to batch data.

## Likelihood Explanation
This vulnerability is **highly likely** to be exploitable:

**Attacker Requirements:**
- Must be an authenticated validator in the network (requires validator credentials)
- Must observe `BatchInfo` broadcasts to learn batch digests
- Must send crafted `BatchRequest` messages

**Feasibility:**
- A malicious or compromised validator can trivially exploit this
- No complex timing or race conditions required
- The vulnerability is systematic and affects all batch retrieval requests
- The peer ID is architecturally lost due to channel design, making proper validation impossible without code changes

**Current State:**
- The `verify()` function has never been called (confirmed by code search)
- All batch requests are processed without validation
- The security check exists but is completely bypassed

## Recommendation

**Immediate Fix:**
Modify the batch serving task to receive both the peer ID and the request message, then call `verify()`:

```rust
spawn_named!("batch_serve", async move {
    info!(epoch = epoch, "Batch retrieval task starts");
    while let Some((peer_id, rpc_request)) = batch_retrieval_rx.next().await {
        counters::RECEIVED_BATCH_REQUEST_COUNT.inc();
        
        // CRITICAL: Verify the request source matches the actual sender
        if let Err(e) = rpc_request.req.verify(peer_id) {
            warn!(
                epoch = epoch, 
                error = ?e, 
                peer_id = peer_id,
                "Batch request verification failed"
            );
            counters::BATCH_REQUEST_VERIFICATION_FAILED_COUNT.inc();
            continue;
        }
        
        // ... rest of the processing
    }
});
```

**Channel Design Fix:**
Since `aptos_channel::Receiver::next()` only returns the message, modify the receiving pattern to preserve the peer ID. This requires either:
1. Using the raw channel API that preserves keys, or
2. Storing the peer ID in the `IncomingBatchRetrievalRequest` struct itself

**Additional Authorization:**
Consider implementing additional checks beyond source verification:
- Verify the requester is in the current epoch's validator set
- Optionally verify the requester is a signer for the requested batch (though this may be too restrictive for legitimate use cases)
- Rate limit batch requests per peer to prevent resource exhaustion

## Proof of Concept

```rust
// Malicious validator exploit demonstration
use aptos_types::PeerId;
use aptos_crypto::HashValue;

// Attacker observes BatchInfo broadcast
let observed_digest = HashValue::random(); // From intercepted BatchInfo

// Attacker creates request claiming to be a different validator
let victim_peer_id = PeerId::random();
let attacker_peer_id = PeerId::random();

// Create spoofed request
let spoofed_request = BatchRequest::new(
    victim_peer_id,  // Claim to be victim
    current_epoch,
    observed_digest
);

// Send to validator who has the batch
// The batch_serve task will process without calling verify()
// Response is sent back to attacker's network connection
// Attacker receives full batch payload (all transactions)

// Expected behavior: verify() should fail
assert!(spoofed_request.verify(attacker_peer_id).is_err());

// Actual behavior: verify() is never called, request succeeds
// No validation performed in batch_serve task
```

**Notes**
- This vulnerability affects all batch retrieval requests across the entire validator network
- The `verify()` function exists as dead code, suggesting this was an oversight rather than intentional design
- The `aptos_channel` architecture loses the peer ID, making it architecturally impossible to perform validation without refactoring
- While all validators eventually need batch data for consensus, the timing and access control matter for security - unauthorized early access violates the quorum store protocol's intended security model

### Citations

**File:** consensus/src/quorum_store/types.rs (L385-395)
```rust
    pub fn verify(&self, peer_id: PeerId) -> anyhow::Result<()> {
        if self.source == peer_id {
            Ok(())
        } else {
            Err(anyhow::anyhow!(
                "Sender mismatch: peer_id: {}, source: {}",
                self.source,
                peer_id
            ))
        }
    }
```

**File:** consensus/src/quorum_store/quorum_store_builder.rs (L397-402)
```rust
        let (batch_retrieval_tx, mut batch_retrieval_rx) =
            aptos_channel::new::<AccountAddress, IncomingBatchRetrievalRequest>(
                QueueStyle::LIFO,
                10,
                Some(&counters::BATCH_RETRIEVAL_TASK_MSGS),
            );
```

**File:** consensus/src/quorum_store/quorum_store_builder.rs (L406-415)
```rust
            while let Some(rpc_request) = batch_retrieval_rx.next().await {
                counters::RECEIVED_BATCH_REQUEST_COUNT.inc();
                let response = if let Ok(value) =
                    batch_store.get_batch_from_local(&rpc_request.req.digest())
                {
                    let batch: Batch<BatchInfoExt> = value.try_into().unwrap();
                    let batch: Batch<BatchInfo> = batch
                        .try_into()
                        .expect("Batch retieval requests must be for V1 batch");
                    BatchResponse::Batch(batch)
```

**File:** crates/channel/src/aptos_channel.rs (L165-177)
```rust
impl<K: Eq + Hash + Clone, M> Stream for Receiver<K, M> {
    type Item = M;

    /// poll_next checks whether there is something ready for consumption from the internal
    /// queue. If there is, then it returns immediately. If the internal_queue is empty,
    /// it sets the waker passed to it by the scheduler/executor and returns Pending
    fn poll_next(self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        let mut shared_state = self.shared_state.lock();
        if let Some((val, status_ch)) = shared_state.internal_queue.pop() {
            if let Some(status_ch) = status_ch {
                let _err = status_ch.send(ElementStatus::Dequeued);
            }
            Poll::Ready(Some(val))
```

**File:** consensus/src/quorum_store/batch_store.rs (L663-667)
```rust
    fn get_or_fetch_batch(
        &self,
        batch_info: BatchInfo,
        responders: Vec<PeerId>,
    ) -> Shared<Pin<Box<dyn Future<Output = ExecutorResult<Vec<SignedTransaction>>> + Send>>> {
```
