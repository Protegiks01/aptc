# Audit Report

## Title
Gas Non-Refund for Algebra Operations Failing at Memory Limit Enables Economic Griefing Attack

## Summary
The `ark_inverse_internal` macro in the algebra cryptography natives charges gas before computing field inversions, but when the subsequent `store_element!` call fails due to the 1MB memory limit, the gas is not refunded. This creates an economic attack vector where users waste gas on computations that produce no usable results, while simultaneously wasting validator CPU resources.

## Finding Description

The vulnerability exists in the gas charging and error handling flow for algebra native operations. The execution sequence is:

1. **Gas is charged upfront** [1](#0-0) 

2. **Expensive field inverse is computed** [2](#0-1) 

3. **Storage attempt fails due to memory limit** - The `store_element!` macro checks if storing the new element would exceed the 1MB memory limit [3](#0-2) 

4. **Abort error preserves gas charge** - When the memory limit abort occurs, the SafeNativeBuilder converts it to a NativeResult that STILL charges all accumulated gas [4](#0-3) 

The memory limit constant is 1MB per session [5](#0-4) 

**Attack scenario:**
1. Attacker creates algebra elements (e.g., 7,280 G1 elements for BLS12-381) consuming ~1,048,000 bytes, just below the 1MB limit
2. Attacker repeatedly calls expensive operations like `inv()` on existing elements
3. Each call:
   - Charges substantial gas (215,450 internal gas units for Fr inverse, 737,122 for Fq12 inverse) [6](#0-5) [7](#0-6) 
   - Computes the expensive field inversion
   - Fails to store result due to memory limit
   - **Does not refund the gas**

This pattern affects all algebra operations using similar macros [8](#0-7) 

## Impact Explanation

This is a **Medium Severity** vulnerability per Aptos bug bounty criteria for "Limited funds loss or manipulation":

- **Economic damage**: Users pay gas (0.21-0.74 external gas units per operation) for computations that yield no result
- **Validator resource waste**: CPU cycles are consumed computing field inversions that cannot be stored
- **Griefing potential**: Attackers can craft transactions that maximize wasted gas and CPU while staying within transaction limits
- **Scale**: In a single transaction with sufficient gas, an attacker could trigger dozens of failed expensive operations

The impact is limited because:
- No funds are stolen or minted
- No consensus violations occur
- Damage is bounded by transaction gas limits
- Attacker also pays gas to set up the attack

However, it violates the fundamental gas metering principle that users should only pay for useful work or necessary validation checks, not for computations whose results cannot be used.

## Likelihood Explanation

**Likelihood: Medium to High**

The attack is easily executable:
- No special privileges required
- Attack setup is straightforward (allocate elements to memory limit)
- Repeated exploitation is possible within single transactions
- The vulnerability is deterministic and reliable

Factors increasing likelihood:
- The algebra operations are publicly accessible
- Memory limit testing shows the threshold is well-defined [9](#0-8) 
- Attacker requirements are minimal (basic understanding of algebra natives)

Factors limiting likelihood:
- Attack requires knowledge of the memory limit mechanism
- Economic benefit to attacker is indirect (griefing, not profit)
- Transaction gas limits bound the damage per transaction

## Recommendation

**Solution**: Check memory capacity BEFORE performing expensive computations. Modify the operation sequence to:

1. Calculate the size needed for the result
2. Verify memory limit would not be exceeded
3. Charge gas for the check (minimal)
4. If memory available: perform computation and charge main gas
5. If memory unavailable: abort early without charging main gas

**Proposed fix for `ark_inverse_internal` macro:**

```rust
macro_rules! ark_inverse_internal {
    ($context:expr, $args:ident, $ark_typ:ty, $gas:expr) => {{
        let handle = safely_pop_arg!($args, u64) as usize;
        safe_borrow_element!($context, handle, $ark_typ, element_ptr, element);
        
        // NEW: Check memory capacity BEFORE expensive computation
        let result_size = std::mem::size_of::<$ark_typ>();
        let context_mut = &mut $context.extensions_mut().get_mut::<AlgebraContext>();
        if context_mut.bytes_used + result_size > MEMORY_LIMIT_IN_BYTES {
            return Err(SafeNativeError::Abort {
                abort_code: E_TOO_MUCH_MEMORY_USED,
            });
        }
        
        // NOW charge gas and compute, knowing storage will succeed
        $context.charge($gas)?;
        match element.inverse() {
            Some(new_element) => {
                let new_handle = store_element!($context, new_element)?;
                Ok(smallvec![Value::bool(true), Value::u64(new_handle as u64)])
            },
            None => Ok(smallvec![Value::bool(false), Value::u64(0)]),
        }
    }};
}
```

Apply the same pattern to `ark_binary_op_internal` and `ark_unary_op_internal` macros.

## Proof of Concept

```move
#[test_only]
module test_addr::gas_waste_poc {
    use std::crypto_algebra::{Self, Element};
    use std::bls12381_algebra::{Fr, G1, FormatFrLsb, FormatG1Uncompr};
    use std::option;
    
    #[test(fx = @std)]
    fun test_gas_wasted_on_memory_limit_failure(fx: signer) {
        // Enable algebra natives
        std::cryptography_algebra_natives::enable(&fx);
        
        // Fill memory to just below limit (7280 G1 elements = ~1,048,320 bytes)
        let i = 0;
        let max_elements = 7280;
        while (i < max_elements) {
            let _ = crypto_algebra::zero<G1, FormatG1Uncompr>();
            i = i + 1;
        };
        
        // Create an Fr element for inversion
        let fr_element = crypto_algebra::from_u64<Fr, FormatFrLsb>(42);
        
        // This call will:
        // 1. Charge 215,450 internal gas units (0.21545 external gas units)
        // 2. Compute the inverse of 42 in Fr
        // 3. Attempt to store the result
        // 4. Fail with E_TOO_MUCH_MEMORY_USED (0x090003)
        // 5. NOT refund the gas charged in step 1
        //
        // The gas is wasted and the computation produced no usable result.
        let (success, _) = crypto_algebra::inv<Fr, FormatFrLsb>(&fr_element);
        
        // This assertion will fail, proving the operation aborted
        assert!(success, 0);
    }
}
```

**Expected behavior**: The test should abort with error code `0x090003` (E_TOO_MUCH_MEMORY_USED) after wasting gas on the inverse computation.

**Notes**
- The vulnerability affects all algebra arithmetic operations (add, mul, div, inv, sqr, etc.) that use similar macro patterns
- The same issue exists for BN254 algebra operations 
- The memory limit is a global session limit, making it easy to reach and maintain at the threshold
- A sophisticated attacker could batch multiple expensive operations in a single transaction to maximize wasted validator resources
- The fix should be applied consistently across all affected macros to prevent similar issues

### Citations

**File:** aptos-move/framework/src/natives/cryptography/algebra/arithmetics/inv.rs (L25-25)
```rust
        $context.charge($gas)?;
```

**File:** aptos-move/framework/src/natives/cryptography/algebra/arithmetics/inv.rs (L26-32)
```rust
        match element.inverse() {
            Some(new_element) => {
                let new_handle = store_element!($context, new_element)?;
                Ok(smallvec![Value::bool(true), Value::u64(new_handle as u64)])
            },
            None => Ok(smallvec![Value::bool(false), Value::u64(0)]),
        }
```

**File:** aptos-move/framework/src/natives/cryptography/algebra/mod.rs (L185-188)
```rust
const MEMORY_LIMIT_IN_BYTES: usize = 1 << 20;

/// Equivalent to `std::error::resource_exhausted(3)` in Move.
const E_TOO_MUCH_MEMORY_USED: u64 = 0x09_0003;
```

**File:** aptos-move/framework/src/natives/cryptography/algebra/mod.rs (L246-251)
```rust
        let context = &mut $context.extensions_mut().get_mut::<AlgebraContext>();
        let new_size = context.bytes_used + std::mem::size_of_val(&$obj);
        if new_size > MEMORY_LIMIT_IN_BYTES {
            Err(SafeNativeError::Abort {
                abort_code: E_TOO_MUCH_MEMORY_USED,
            })
```

**File:** aptos-move/aptos-native-interface/src/builder.rs (L134-136)
```rust
                    Abort { abort_code } => {
                        Ok(NativeResult::err(context.legacy_gas_used, abort_code))
                    },
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/aptos_framework.rs (L115-115)
```rust
        [algebra_ark_bls12_381_fq12_inv: InternalGas, { 8.. => "algebra.ark_bls12_381_fq12_inv" }, 737122],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/aptos_framework.rs (L129-129)
```rust
        [algebra_ark_bls12_381_fr_inv: InternalGas, { 8.. => "algebra.ark_bls12_381_fr_inv" }, 215450],
```

**File:** aptos-move/framework/src/natives/cryptography/algebra/arithmetics/mod.rs (L15-38)
```rust
macro_rules! ark_binary_op_internal {
    ($context:expr, $args:ident, $ark_typ:ty, $ark_func:ident, $gas:expr) => {{
        let handle_2 = aptos_native_interface::safely_pop_arg!($args, u64) as usize;
        let handle_1 = aptos_native_interface::safely_pop_arg!($args, u64) as usize;
        safe_borrow_element!($context, handle_1, $ark_typ, element_1_ptr, element_1);
        safe_borrow_element!($context, handle_2, $ark_typ, element_2_ptr, element_2);
        $context.charge($gas)?;
        let new_element = element_1.$ark_func(element_2);
        let new_handle = store_element!($context, new_element)?;
        Ok(smallvec![Value::u64(new_handle as u64)])
    }};
}

#[macro_export]
macro_rules! ark_unary_op_internal {
    ($context:expr, $args:ident, $ark_typ:ty, $ark_func:ident, $gas:expr) => {{
        let handle = aptos_native_interface::safely_pop_arg!($args, u64) as usize;
        safe_borrow_element!($context, handle, $ark_typ, element_ptr, element);
        $context.charge($gas)?;
        let new_element = element.$ark_func();
        let new_handle = store_element!($context, new_element)?;
        Ok(smallvec![Value::u64(new_handle as u64)])
    }};
}
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/bls12381_algebra.move (L836-845)
```text
    #[test(fx = @std)]
    #[expected_failure(abort_code = 0x090003, location = std::crypto_algebra)]
    fun test_memory_limit_exceeded_with_g1(fx: signer) {
        enable_cryptography_algebra_natives(&fx);
        let remaining = G1_NUM_MAX + 1;
        while (remaining > 0) {
            zero<G1>();
            remaining -= 1;
        }
    }
```
