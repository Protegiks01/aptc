# Audit Report

## Title
Unauthenticated Cross-Shard Messages Enable State Corruption and Denial of Service in Sharded Block Executor

## Summary
The sharded block executor's cross-shard communication system lacks authentication and validation of `RemoteTxnWrite` messages. While the current limited transaction support (coin transfers only) prevents direct access control bypass of system-protected resources, a compromised shard can cause denial of service by sending unexpected state keys, and can corrupt transaction execution state by sending malicious values for expected keys. This represents a critical defense-in-depth failure that will become a severe access control bypass once arbitrary Move transactions are supported.

## Finding Description

The sharded block executor implements cross-shard communication without cryptographic authentication or message validation. When a shard sends cross-shard write messages to inform other shards about committed state changes, there are three critical security failures: [1](#0-0) 

**Failure 1: No Authentication on Network Messages**
The `RemoteCrossShardClient` uses an unauthenticated gRPC transport. Messages are serialized with BCS and sent over plain gRPC channels with no cryptographic signatures, no sender verification, and no integrity checks. [2](#0-1) 

**Failure 2: No Validation of Message Content**
When receiving messages, the system directly deserializes them and applies state updates without validating that the `state_key` should have been written by the sending shard or matches the original transaction's write set. [3](#0-2) 

**Failure 3: Panic on Unexpected Keys (DoS Vector)**
The `CrossShardStateView::set_value` method panics with `.unwrap()` if the state_key is not in the expected cross-shard keys set, allowing a compromised shard to crash other shards. [4](#0-3) 

**Attack Scenarios:**

1. **Denial of Service**: Compromised Shard A sends `RemoteTxnWrite` messages with unexpected `state_key` values to Shard B. The `.unwrap()` panics, crashing Shard B's receiver thread and halting block execution.

2. **State Corruption**: For `state_key` values that ARE in the expected set (based on cross-shard dependencies), Shard A can send malicious values that corrupt transaction execution in Shard B, causing consensus divergence across validators.

3. **Future Access Control Bypass**: The current implementation only supports coin transfers and account creation with hardcoded read/write hints. These hints include system resources like `Features`, `ChainId`, and `CurrentTimeMicroseconds` as read-only dependencies. [5](#0-4) 

However, the code explicitly indicates future support for arbitrary transactions: [6](#0-5) 

Once arbitrary Move transactions are supported, malicious transactions could declare writes to system-protected resources, bypass Move VM access control enforcement (since the compromised shard ignores execution results), and propagate these malicious writes to other shards through unauthenticated `RemoteTxnWrite` messages.

## Impact Explanation

**Current Impact - High Severity:**
- **Denial of Service**: Single compromised shard can crash all other shards by sending messages with unexpected state keys, causing network-wide block execution failure
- **State Consistency Violation**: Corrupted state values in cross-shard dependencies cause different validators to produce different execution results for the same block, breaking the **Deterministic Execution** invariant
- **Consensus Divergence Risk**: If validators use different shard configurations or have different shards compromised, they may commit different state roots

**Future Impact - Critical Severity (when arbitrary transactions supported):**
- **Access Control Bypass**: Malicious transactions can bypass Move's access control for system addresses (`@aptos_framework`, `@core_resources`)
- **Validator Set Manipulation**: Write malicious values to validator configuration resources
- **Governance Compromise**: Corrupt governance state including voting power calculations
- **Complete System Compromise**: Arbitrary writes to system-protected resources enable complete control over blockchain state

## Likelihood Explanation

**Current Likelihood: Medium**
- Requires compromising a shard within a validator's infrastructure (insider threat or infrastructure breach)
- Sharded execution appears to be an optimization feature, not always enabled
- Attack is straightforward once shard access is obtained (no cryptographic barriers)

**Future Likelihood: High**
- Once arbitrary transactions are supported, attack surface expands dramatically
- Any compromised shard in any validator's infrastructure can exploit this
- No cryptographic or protocol-level defenses to prevent exploitation

## Recommendation

Implement comprehensive authentication and validation for all cross-shard messages:

1. **Message Authentication**: Add cryptographic signatures to all `CrossShardMsg` messages, signed by the sending shard's identity key
2. **State Key Validation**: Verify that received `state_key` values match the expected cross-shard dependencies computed during partitioning
3. **Write Set Verification**: Include transaction output proofs with `RemoteTxnWrite` messages and verify them against the transaction's actual write set
4. **Replace Panic with Error Handling**: Change `.unwrap()` to graceful error handling that logs and reports invalid messages without crashing

Example fix for message validation:

```rust
// In CrossShardCommitReceiver::start
pub fn start<S: StateView + Sync + Send>(
    cross_shard_state_view: Arc<CrossShardStateView<S>>,
    cross_shard_client: Arc<dyn CrossShardClient>,
    round: RoundId,
) {
    loop {
        let msg = cross_shard_client.receive_cross_shard_msg(round);
        match msg {
            RemoteTxnWriteMsg(txn_commit_msg) => {
                let (state_key, write_op) = txn_commit_msg.take();
                
                // ADDED: Validate state_key is expected
                if !cross_shard_state_view.is_expected_key(&state_key) {
                    error!("Received unexpected cross-shard write for key: {:?}", state_key);
                    continue; // Skip instead of panic
                }
                
                // ADDED: Verify message signature (pseudocode)
                // if !verify_message_signature(&txn_commit_msg, sender_shard_id) {
                //     error!("Invalid message signature from shard {}", sender_shard_id);
                //     continue;
                // }
                
                cross_shard_state_view.set_value(&state_key, write_op.and_then(|w| w.as_state_value()));
            },
            CrossShardMsg::StopMsg => {
                break;
            },
        }
    }
}
```

## Proof of Concept

```rust
// PoC demonstrating the DoS vulnerability
#[test]
fn test_cross_shard_dos_attack() {
    use aptos_types::state_store::state_key::StateKey;
    use aptos_vm::sharded_block_executor::messages::{CrossShardMsg, RemoteTxnWrite};
    
    // Setup: Create CrossShardStateView with expected keys for Account A
    let expected_key = StateKey::raw(b"account_a");
    let mut expected_keys = HashSet::new();
    expected_keys.insert(expected_key.clone());
    
    let cross_shard_state_view = Arc::new(CrossShardStateView::new(expected_keys, &EmptyView));
    
    // Attack: Compromised shard sends message with UNEXPECTED key
    let malicious_key = StateKey::raw(b"validator_config"); // System resource
    let malicious_msg = RemoteTxnWrite::new(malicious_key, None);
    
    // This will PANIC and crash the receiver, causing DoS
    // cross_shard_state_view.set_value(&malicious_key, None);
    // Expected: Panic at cross_shard_state_view.rs:52 with "called `Option::unwrap()` on a `None` value"
    
    // Demonstration that panic occurs:
    let result = std::panic::catch_unwind(|| {
        cross_shard_state_view.set_value(
            &StateKey::raw(b"unexpected_key"),
            None
        );
    });
    
    assert!(result.is_err(), "Should panic on unexpected key");
}

// PoC demonstrating state corruption vulnerability  
#[test]
fn test_cross_shard_state_corruption() {
    // Setup: Transaction T2 in Shard B expects to read account balance from Shard A
    let account_key = StateKey::raw(b"account_balance");
    let mut expected_keys = HashSet::new();
    expected_keys.insert(account_key.clone());
    
    let cross_shard_state_view = Arc::new(CrossShardStateView::new(expected_keys, &EmptyView));
    
    // Attack: Compromised Shard A sends MALICIOUS balance value
    let legitimate_balance = 1000u64;
    let malicious_balance = 999999999u64; // Inflated balance
    
    let malicious_value = StateValue::from(bcs::to_bytes(&malicious_balance).unwrap());
    
    // This is accepted without validation!
    cross_shard_state_view.set_value(&account_key, Some(malicious_value));
    
    // T2 will read the malicious balance and make incorrect decisions
    let corrupted_value = cross_shard_state_view.get_state_value(&account_key).unwrap();
    let read_balance: u64 = bcs::from_bytes(corrupted_value.unwrap().bytes()).unwrap();
    
    assert_eq!(read_balance, malicious_balance); // Corruption succeeded
    assert_ne!(read_balance, legitimate_balance); // Legitimate value bypassed
}
```

## Notes

This vulnerability violates multiple critical invariants:
- **Deterministic Execution**: Different validators may get different cross-shard values if shards are compromised differently
- **State Consistency**: Cross-shard state can be corrupted without detection
- **Access Control**: Future expansion to arbitrary transactions enables bypass of Move's access control

The vulnerability is exacerbated by the TODO comments indicating planned support for arbitrary transactions, which would transform this from a state consistency issue into a complete access control bypass allowing writes to validator configurations, governance state, and other system-protected resources.

### Citations

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L55-66)
```rust
    fn send_cross_shard_msg(&self, shard_id: ShardId, round: RoundId, msg: CrossShardMsg) {
        let input_message = bcs::to_bytes(&msg).unwrap();
        let tx = self.message_txs[shard_id][round].lock().unwrap();
        tx.send(Message::new(input_message)).unwrap();
    }

    fn receive_cross_shard_msg(&self, current_round: RoundId) -> CrossShardMsg {
        let rx = self.message_rxs[current_round].lock().unwrap();
        let message = rx.recv().unwrap();
        let msg: CrossShardMsg = bcs::from_bytes(&message.to_bytes()).unwrap();
        msg
    }
```

**File:** secure/net/src/grpc_network_service/mod.rs (L92-116)
```rust
impl NetworkMessageService for GRPCNetworkMessageServiceServerWrapper {
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
}
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L25-46)
```rust
impl CrossShardCommitReceiver {
    pub fn start<S: StateView + Sync + Send>(
        cross_shard_state_view: Arc<CrossShardStateView<S>>,
        cross_shard_client: Arc<dyn CrossShardClient>,
        round: RoundId,
    ) {
        loop {
            let msg = cross_shard_client.receive_cross_shard_msg(round);
            match msg {
                RemoteTxnWriteMsg(txn_commit_msg) => {
                    let (state_key, write_op) = txn_commit_msg.take();
                    cross_shard_state_view
                        .set_value(&state_key, write_op.and_then(|w| w.as_state_value()));
                },
                CrossShardMsg::StopMsg => {
                    trace!("Cross shard commit receiver stopped for round {}", round);
                    break;
                },
            }
        }
    }
}
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_state_view.rs (L49-56)
```rust
    pub fn set_value(&self, state_key: &StateKey, state_value: Option<StateValue>) {
        self.cross_shard_data
            .get(state_key)
            .unwrap()
            .set_value(state_value);
        // uncomment the following line to debug waiting count
        // trace!("waiting count for shard id {} is {}", self.shard_id, self.waiting_count());
    }
```

**File:** types/src/transaction/analyzed_transaction.rs (L213-220)
```rust
    let read_hints = vec![
        current_ts_location(),
        features_location(),
        aptos_coin_info_location(),
        chain_id_location(),
        transaction_fee_burn_cap_location(),
    ];
    (read_hints, write_hints)
```

**File:** types/src/transaction/analyzed_transaction.rs (L266-269)
```rust
                _ => todo!(
                    "Only coin transfer and create account transactions are supported for now"
                ),
            }
```
