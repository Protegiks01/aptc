# Audit Report

## Title
Byzantine Validators Can Cause Validator Slowdown via Timeout Certificates with Excessive Signatures

## Summary
Byzantine validators can create timeout certificates containing signatures from all N validators instead of the minimum required 2f+1, forcing honest validators to perform expensive O(N) BLS aggregate signature verification on every sync info message, causing significant performance degradation.

## Finding Description
The `TwoChainTimeoutCertificate::verify()` function lacks validation to limit the number of signatures in a timeout certificate to the minimum quorum requirement (2f+1). While the code checks that voting power meets the quorum threshold and that signatures don't exceed the total validator count N, it does not reject certificates with excessive signatures beyond what is necessary for consensus. [1](#0-0) 

The verification process extracts all voters and their corresponding rounds, constructs a timeout message for each signature, and then performs BLS aggregate signature verification on all of them: [2](#0-1) 

The underlying `ValidatorVerifier::verify_aggregate_signatures()` only validates that signatures don't exceed N and voting power meets quorum, but permits any number of signatures between these bounds: [3](#0-2) 

When honest validators receive a `SyncInfo` message containing such a timeout certificate, they must verify it during sync operations: [4](#0-3) [5](#0-4) 

**Attack Path:**
1. Byzantine validator collects timeout votes from all N validators during normal protocol operation
2. Instead of creating a timeout certificate with minimum 2f+1 signatures, Byzantine validator aggregates all N signatures
3. Byzantine validator embeds this bloated timeout certificate in `SyncInfo` messages
4. Byzantine validator broadcasts these messages to all honest validators
5. Each honest validator receiving the message must verify all N signatures via expensive BLS aggregate verification (O(N) cost)
6. Byzantine validator can repeatedly send such messages to cause sustained performance degradation

## Impact Explanation
This vulnerability falls under **High Severity** per the Aptos bug bounty program, specifically "Validator node slowdowns." 

BLS aggregate signature verification has O(N) computational cost where N is the number of signatures. For a validator set of 100 nodes:
- Minimum required verification: 67 signatures (2f+1 where f=33)
- Maximum possible with exploit: 100 signatures
- Performance overhead: ~50% increase in verification time

This impacts the consensus critical path because `SyncInfo` verification occurs during:
- Processing proposal messages with embedded sync info
- Handling explicit sync info messages from peers
- Round synchronization operations

The attack can be sustained by repeatedly broadcasting malicious sync info messages, causing continuous validator slowdown that degrades network performance and increases round times.

## Likelihood Explanation
**Likelihood: Medium to High**

The attack is straightforward to execute:
- Byzantine validators naturally collect timeout votes during consensus
- No special permissions or collusion required beyond normal Byzantine validator capabilities
- Simple to implement by modifying local aggregation logic to wait for maximum signatures
- Can be triggered repeatedly with minimal effort

The only prerequisite is being a validator in the network, which is publicly achievable through staking. The attack does not require timing precision, cryptographic breaks, or exploitation of race conditions.

## Recommendation
Add a validation check in `TwoChainTimeoutCertificate::verify()` to reject timeout certificates with more signatures than necessary for quorum. The fix should enforce that the number of signatures does not significantly exceed 2f+1:

```rust
pub fn verify(&self, validators: &ValidatorVerifier) -> anyhow::Result<()> {
    let hqc_round = self.timeout.hqc_round();
    
    // NEW: Reject timeout certificates with excessive signatures
    let num_signatures = self.signatures_with_rounds.sig().get_num_voters();
    let max_reasonable_signatures = (validators.len() * 3 + 2) / 4; // ~75% of validators
    ensure!(
        num_signatures <= max_reasonable_signatures,
        "Timeout certificate has {} signatures, maximum reasonable is {}",
        num_signatures,
        max_reasonable_signatures
    );
    
    // Existing verification logic...
    let (timeout_result, sig_result) = rayon::join(
        || self.timeout.verify(validators),
        || {
            // ... rest of existing code
        },
    );
    // ... rest remains the same
}
```

Alternatively, implement an early rejection in `ValidatorVerifier::verify_aggregate_signatures()` that can be configured per use case to reject signatures beyond a specified multiplier of quorum.

## Proof of Concept

```rust
#[cfg(test)]
mod exploit_test {
    use super::*;
    use aptos_types::validator_verifier::random_validator_verifier;
    use aptos_consensus_types::{
        timeout_2chain::{TwoChainTimeout, TwoChainTimeoutWithPartialSignatures},
        quorum_cert::QuorumCert,
        vote_data::VoteData,
    };
    use aptos_types::block_info::BlockInfo;
    use std::time::Instant;

    #[test]
    fn test_excessive_signatures_slowdown() {
        // Setup 100 validators
        let num_validators = 100;
        let (signers, validators) = random_validator_verifier(num_validators, None, false);
        
        // Create a valid QC for timeout
        let vote_data = VoteData::new(BlockInfo::random(1), BlockInfo::random(0));
        let mut qc_sigs = PartialSignatures::empty();
        for signer in &signers[0..67] {  // 2f+1 = 67
            let li = LedgerInfo::new(BlockInfo::empty(), vote_data.hash());
            let sig = signer.sign(&li).unwrap();
            qc_sigs.add_signature(signer.author(), sig);
        }
        let qc = QuorumCert::new(vote_data, validators.aggregate_signatures(qc_sigs.signatures_iter()).unwrap());
        
        // Create timeout with MINIMUM signatures (2f+1 = 67)
        let timeout = TwoChainTimeout::new(1, 5, qc.clone());
        let mut tc_minimal = TwoChainTimeoutWithPartialSignatures::new(timeout.clone());
        for signer in &signers[0..67] {
            let sig = timeout.sign(signer).unwrap();
            tc_minimal.add(signer.author(), timeout.clone(), sig);
        }
        let tc_minimal_agg = tc_minimal.aggregate_signatures(&validators).unwrap();
        
        // Create timeout with MAXIMUM signatures (all 100)
        let mut tc_maximal = TwoChainTimeoutWithPartialSignatures::new(timeout.clone());
        for signer in &signers {
            let sig = timeout.sign(signer).unwrap();
            tc_maximal.add(signer.author(), timeout.clone(), sig);
        }
        let tc_maximal_agg = tc_maximal.aggregate_signatures(&validators).unwrap();
        
        // Benchmark minimal vs maximal verification
        let start = Instant::now();
        for _ in 0..10 {
            tc_minimal_agg.verify(&validators).unwrap();
        }
        let minimal_time = start.elapsed();
        
        let start = Instant::now();
        for _ in 0..10 {
            tc_maximal_agg.verify(&validators).unwrap();
        }
        let maximal_time = start.elapsed();
        
        println!("Minimal signatures (67): {:?}", minimal_time);
        println!("Maximal signatures (100): {:?}", maximal_time);
        println!("Slowdown: {:.2}x", maximal_time.as_micros() as f64 / minimal_time.as_micros() as f64);
        
        // Demonstrate that excessive signatures cause measurable slowdown
        assert!(maximal_time > minimal_time * 130 / 100); // At least 30% slower
    }
}
```

## Notes

This vulnerability specifically targets the resource limits invariant: "All operations must respect gas, storage, and computational limits." The lack of an upper bound check on signature count allows Byzantine validators to force honest nodes to perform unnecessary computation during consensus operations.

The fix should balance security with protocol flexibility. Setting the limit too low (exactly 2f+1) might cause issues if validators continue collecting signatures after quorum is reached locally. A reasonable upper bound of 75% of total validators provides safety margin while preventing abuse.

### Citations

**File:** consensus/consensus-types/src/timeout_2chain.rs (L141-183)
```rust
    pub fn verify(&self, validators: &ValidatorVerifier) -> anyhow::Result<()> {
        let hqc_round = self.timeout.hqc_round();
        // Verify the highest timeout validity.
        let (timeout_result, sig_result) = rayon::join(
            || self.timeout.verify(validators),
            || {
                let timeout_messages: Vec<_> = self
                    .signatures_with_rounds
                    .get_voters_and_rounds(
                        &validators
                            .get_ordered_account_addresses_iter()
                            .collect_vec(),
                    )
                    .into_iter()
                    .map(|(_, round)| TimeoutSigningRepr {
                        epoch: self.timeout.epoch(),
                        round: self.timeout.round(),
                        hqc_round: round,
                    })
                    .collect();
                let timeout_messages_ref: Vec<_> = timeout_messages.iter().collect();
                validators.verify_aggregate_signatures(
                    &timeout_messages_ref,
                    self.signatures_with_rounds.sig(),
                )
            },
        );
        timeout_result?;
        sig_result?;
        let signed_hqc = self
            .signatures_with_rounds
            .rounds()
            .iter()
            .max()
            .ok_or_else(|| anyhow::anyhow!("Empty rounds"))?;
        ensure!(
            hqc_round == *signed_hqc,
            "Inconsistent hqc round, qc has round {}, highest signed round {}",
            hqc_round,
            *signed_hqc
        );
        Ok(())
    }
```

**File:** types/src/validator_verifier.rs (L388-417)
```rust
    pub fn verify_aggregate_signatures<T: CryptoHash + Serialize>(
        &self,
        messages: &[&T],
        aggregated_signature: &AggregateSignature,
    ) -> std::result::Result<(), VerifyError> {
        // Verify the number of signature is not greater than expected.
        Self::check_num_of_voters(self.len() as u16, aggregated_signature.get_signers_bitvec())?;
        let mut pub_keys = vec![];
        let mut authors = vec![];
        for index in aggregated_signature.get_signers_bitvec().iter_ones() {
            let validator = self
                .validator_infos
                .get(index)
                .ok_or(VerifyError::UnknownAuthor)?;
            authors.push(validator.address);
            pub_keys.push(validator.public_key());
        }
        // Verify the quorum voting power of the authors
        self.check_voting_power(authors.iter(), true)?;
        // Verify empty aggregated signature
        let aggregated_sig = aggregated_signature
            .sig()
            .as_ref()
            .ok_or(VerifyError::EmptySignature)?;

        aggregated_sig
            .verify_aggregate(messages, &pub_keys)
            .map_err(|_| VerifyError::InvalidAggregatedSignature)?;
        Ok(())
    }
```

**File:** consensus/src/round_manager.rs (L878-896)
```rust
    async fn sync_up(&mut self, sync_info: &SyncInfo, author: Author) -> anyhow::Result<()> {
        let local_sync_info = self.block_store.sync_info();
        if sync_info.has_newer_certificates(&local_sync_info) {
            info!(
                self.new_log(LogEvent::ReceiveNewCertificate)
                    .remote_peer(author),
                "Local state {},\n remote state {}", local_sync_info, sync_info
            );
            // Some information in SyncInfo is ahead of what we have locally.
            // First verify the SyncInfo (didn't verify it in the yet).
            sync_info.verify(&self.epoch_state.verifier).map_err(|e| {
                error!(
                    SecurityEvent::InvalidSyncInfoMsg,
                    sync_info = sync_info,
                    remote_peer = author,
                    error = ?e,
                );
                VerifyError::from(e)
            })?;
```

**File:** consensus/consensus-types/src/sync_info.rs (L204-209)
```rust
            .and_then(|_| {
                if let Some(tc) = &self.highest_2chain_timeout_cert {
                    tc.verify(validator)?;
                }
                Ok(())
            })
```
