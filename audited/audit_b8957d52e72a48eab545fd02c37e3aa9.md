# Audit Report

## Title
Insufficient Error Context in Optimistic Fetch Overflow Errors Enables Log-Based Attack Obfuscation

## Summary
The `get_storage_request_for_missing_data()` function in the optimistic fetch handler contains three arithmetic overflow checks that produce generic error messages without including critical debugging context. Attackers can deliberately trigger these errors by sending crafted requests with extreme `known_version` values, flooding logs with uninformative error messages that obscure other malicious activities and impede incident response. [1](#0-0) [2](#0-1) [3](#0-2) 

## Finding Description

When processing optimistic fetch requests, the system extracts the `known_version` field directly from peer-supplied request data without upper-bound validation. [4](#0-3) [5](#0-4) 

The validation logic for optimistic fetch requests only checks timestamp lag, not the validity of version numbers: [6](#0-5) [7](#0-6) 

When overflow errors occur, the logging lacks essential forensic information: [8](#0-7) 

The log entry omits the `peer_network_id` and original `request` fields that are available in scope but not included. The error messages themselves contain no values - just static strings. [9](#0-8) 

**Attack Path:**
1. Attacker sends `NewTransactionOutputsWithProofRequest` with `known_version = u64::MAX`
2. Request passes `can_service_optimistic_request()` validation (only checks timestamp lag)
3. Request stored as `OptimisticFetchRequest` via handler
4. When new data arrives, `get_storage_request_for_missing_data()` processes the request
5. Line 92: `known_version.checked_add(1)` returns `None` (overflow)
6. Error logged as: `"Unexpected error encountered: Start version has overflown!"`
7. No peer identity, request details, or actual version values logged
8. Attacker repeats to flood logs, obscuring concurrent exploit attempts

## Impact Explanation

This qualifies as **Low Severity** per the Aptos bug bounty criteria: "Non-critical implementation bugs."

While not directly exploitable for funds theft or consensus violations, this issue:
- **Degrades incident response capability**: Operators cannot identify attack sources from logs
- **Enables attack obfuscation**: Malicious peers can inject log noise to hide other exploitation attempts
- **Hinders debugging**: Legitimate overflow scenarios (bugs) become impossible to diagnose without peer identity and version values
- **Violates security observability principles**: Critical error paths lack forensic-quality logging

The `RequestModerator` provides limited protection by eventually ignoring peers with many invalid requests, but only for public network peers, and only after reaching the threshold. [10](#0-9) 

## Likelihood Explanation

**High likelihood** of exploitation:
- Zero authentication required - any network peer can send optimistic fetch requests
- No input validation on `known_version` before overflow-prone operations
- Trivial to craft: standard request with `known_version = u64::MAX` or `u64::MAX - 1`
- No rate limiting specific to these error conditions
- Public network peers can send up to `max_invalid_requests_per_peer` (configurable) before being ignored

## Recommendation

**Immediate fixes:**

1. **Add comprehensive logging context** in `optimistic_fetch.rs` at line 328:

```rust
if let Err(error) = result {
    warn!(LogSchema::new(LogEntry::OptimisticFetchResponse)
        .error(&Error::UnexpectedErrorEncountered(error.to_string()))
        .peer_network_id(&peer_network_id)
        .request(&optimistic_fetch_request));
}
```

2. **Include actual values in error messages** at lines 79, 92, 97:

```rust
// Line 79
Error::UnexpectedErrorEncountered(format!(
    "Number of versions to fetch has overflown! target_version={}, known_version={}",
    target_version, known_version
))

// Line 92
Error::UnexpectedErrorEncountered(format!(
    "Start version has overflown! known_version={}", known_version
))

// Line 97
Error::UnexpectedErrorEncountered(format!(
    "End version has overflown! known_version={}, num_versions_to_fetch={}",
    known_version, num_versions_to_fetch
))
```

3. **Add input validation** - Reject requests where `known_version` exceeds reasonable bounds (e.g., current synced version + maximum permitted lag).

## Proof of Concept

```rust
// Test demonstrating exploitability
#[tokio::test]
async fn test_overflow_attack_via_malicious_known_version() {
    use aptos_storage_service_types::requests::{
        NewTransactionOutputsWithProofRequest, DataRequest, StorageServiceRequest
    };
    use aptos_types::ledger_info::LedgerInfoWithSignatures;
    
    // Create malicious request with known_version near u64::MAX
    let malicious_request = StorageServiceRequest::new(
        DataRequest::GetNewTransactionOutputsWithProof(
            NewTransactionOutputsWithProofRequest {
                known_version: u64::MAX,  // Attacker-controlled value
                known_epoch: 0,
            }
        ),
        false,
    );
    
    // Create optimistic fetch with malicious request
    let time_service = TimeService::mock();
    let (response_sender, _) = ResponseSender::new();
    let optimistic_fetch = OptimisticFetchRequest::new(
        malicious_request,
        response_sender,
        time_service,
    );
    
    // Create target ledger info at any version
    let target_ledger_info = LedgerInfoWithSignatures::new(/* ... */);
    
    // Attempt to get storage request - will trigger overflow at line 92
    let config = StorageServiceConfig::default();
    let result = optimistic_fetch.get_storage_request_for_missing_data(
        config,
        &target_ledger_info,
    );
    
    // Verify overflow error occurs
    assert!(result.is_err());
    let error = result.unwrap_err();
    
    // Demonstrate insufficient logging: error message lacks peer_network_id,
    // request details, and actual version values
    assert!(matches!(error, Error::UnexpectedErrorEncountered(_)));
    // In production, this gets logged without peer identity, making
    // it impossible to identify attacker or debug root cause
}
```

## Notes

The issue is compounded by the fact that optimistic fetch requests bypass normal request validation since they represent "future" data requests. The `highest_known_version()` method extracts values from four different request types, all of which are peer-controlled and unvalidated for upper bounds. [11](#0-10) 

The `LogSchema` struct supports `.peer_network_id()` and `.request()` methods but they are not utilized in the error path, despite being available in the execution context. [12](#0-11)

### Citations

**File:** state-sync/storage-service/server/src/optimistic_fetch.rs (L78-82)
```rust
            target_version.checked_sub(known_version).ok_or_else(|| {
                Error::UnexpectedErrorEncountered(
                    "Number of versions to fetch has overflown!".into(),
                )
            })?;
```

**File:** state-sync/storage-service/server/src/optimistic_fetch.rs (L91-93)
```rust
        let start_version = known_version.checked_add(1).ok_or_else(|| {
            Error::UnexpectedErrorEncountered("Start version has overflown!".into())
        })?;
```

**File:** state-sync/storage-service/server/src/optimistic_fetch.rs (L94-98)
```rust
        let end_version = known_version
            .checked_add(num_versions_to_fetch)
            .ok_or_else(|| {
                Error::UnexpectedErrorEncountered("End version has overflown!".into())
            })?;
```

**File:** state-sync/storage-service/server/src/optimistic_fetch.rs (L145-153)
```rust
    fn highest_known_version(&self) -> u64 {
        match &self.request.data_request {
            DataRequest::GetNewTransactionOutputsWithProof(request) => request.known_version,
            DataRequest::GetNewTransactionsWithProof(request) => request.known_version,
            DataRequest::GetNewTransactionsOrOutputsWithProof(request) => request.known_version,
            DataRequest::GetNewTransactionDataWithProof(request) => request.known_version,
            request => unreachable!("Unexpected optimistic fetch request: {:?}", request),
        }
    }
```

**File:** state-sync/storage-service/server/src/optimistic_fetch.rs (L327-330)
```rust
                if let Err(error) = result {
                    warn!(LogSchema::new(LogEntry::OptimisticFetchResponse)
                        .error(&Error::UnexpectedErrorEncountered(error.to_string())));
                }
```

**File:** state-sync/storage-service/types/src/requests.rs (L327-330)
```rust
pub struct NewTransactionOutputsWithProofRequest {
    pub known_version: u64, // The highest known output version
    pub known_epoch: u64,   // The highest known epoch
}
```

**File:** state-sync/storage-service/types/src/responses.rs (L708-712)
```rust
            GetNewTransactionOutputsWithProof(_) => can_service_optimistic_request(
                aptos_data_client_config,
                time_service,
                self.synced_ledger_info.as_ref(),
            ),
```

**File:** state-sync/storage-service/types/src/responses.rs (L894-901)
```rust
fn can_service_optimistic_request(
    aptos_data_client_config: &AptosDataClientConfig,
    time_service: TimeService,
    synced_ledger_info: Option<&LedgerInfoWithSignatures>,
) -> bool {
    let max_lag_secs = aptos_data_client_config.max_optimistic_fetch_lag_secs;
    check_synced_ledger_lag(synced_ledger_info, time_service, max_lag_secs)
}
```

**File:** state-sync/storage-service/server/src/error.rs (L15-16)
```rust
    #[error("Unexpected error encountered: {0}")]
    UnexpectedErrorEncountered(String),
```

**File:** state-sync/storage-service/server/src/moderator.rs (L50-68)
```rust
    pub fn increment_invalid_request_count(&mut self, peer_network_id: &PeerNetworkId) {
        // Increment the invalid request count
        self.invalid_request_count += 1;

        // If the peer is a PFN and has sent too many invalid requests, start ignoring it
        if self.ignore_start_time.is_none()
            && peer_network_id.network_id().is_public_network()
            && self.invalid_request_count >= self.max_invalid_requests
        {
            // TODO: at some point we'll want to terminate the connection entirely

            // Start ignoring the peer
            self.ignore_start_time = Some(self.time_service.now());

            // Log the fact that we're now ignoring the peer
            warn!(LogSchema::new(LogEntry::RequestModeratorIgnoredPeer)
                .peer_network_id(peer_network_id)
                .message("Ignoring peer due to too many invalid requests!"));
        }
```

**File:** state-sync/storage-service/server/src/handler.rs (L119-123)
```rust
        // Handle any optimistic fetch requests
        if request.data_request.is_optimistic_fetch() {
            self.handle_optimistic_fetch_request(peer_network_id, request, response_sender);
            return;
        }
```

**File:** state-sync/storage-service/server/src/logging.rs (L10-19)
```rust
#[derive(Schema)]
pub struct LogSchema<'a> {
    name: LogEntry,
    error: Option<&'a Error>,
    message: Option<&'a str>,
    optimistic_fetch_related: Option<bool>,
    peer_network_id: Option<&'a PeerNetworkId>,
    response: Option<&'a str>,
    request: Option<&'a StorageServiceRequest>,
}
```
