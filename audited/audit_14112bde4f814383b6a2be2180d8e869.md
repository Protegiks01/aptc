# Audit Report

## Title
VFN Network Cross-Owner Connection Bypass: Test Enforces Owner Validation That Production Code Ignores

## Summary
The test framework enforces that VFN network connections only occur between nodes with matching owner accounts, but the production handshake code does not validate owner matching. This allows a malicious Validator Full Node (VFN) operated by one validator to connect to another validator's VFN network port, bypassing the intended trust boundary encoded in the test utilities.

## Finding Description

The security issue exists due to a critical mismatch between test assumptions and production behavior regarding VFN network access control.

**Test Code Enforces Same-Owner Restriction:** [1](#0-0) 

The test framework explicitly skips VFN network connections when owner accounts don't match, encoding an assumption that VFN networks should only connect same-owner nodes.

**Production Code Does NOT Enforce This:** [2](#0-1) 

When a validator receives an inbound connection on the VFN network in `MaybeMutual` authentication mode, it infers the peer role as `ValidatorFullNode` without validating that the connecting VFN's owner account (peer_id) matches the validator's owner account.

**VFN Network Uses MaybeMutual Mode by Default:** [3](#0-2) 

The VFN network defaults to non-mutual authentication (only the validator network uses mutual auth), allowing inbound connections from peers not in the trusted set.

**VFN Addresses Are Discoverable On-Chain:** [4](#0-3) 

VFN network addresses are published in the on-chain ValidatorSet and can be queried by any actor, making them discoverable rather than private.

**Attack Scenario:**
1. Attacker queries the on-chain ValidatorSet to discover target validator's VFN network address
2. Attacker configures their own VFN with a different owner account
3. Attacker's VFN connects to victim validator's VFN network port
4. Victim validator accepts the connection because:
   - VFN network uses `MaybeMutual` auth mode
   - Handshake only validates peer_id is correctly derived from public key
   - No validation that connecting VFN's owner matches validator's owner
5. Cross-owner VFN connection is established, bypassing the trust boundary

**Configuration Evidence:** [5](#0-4) 

Validators configure VFN networks with `peer_id_name: "owner_account"`, intending the network identity to be tied to the owner account. [6](#0-5) 

The comment "the private 'vfn' identity will allow it to connect to the validator node" indicates VFNs should connect to their specific validator, not arbitrary validators.

## Impact Explanation

This qualifies as **Medium severity** based on the following impacts:

**Information Disclosure:** A malicious VFN from Validator A can receive state synchronization data, mempool transactions, peer monitoring information, and other network messages intended only for Validator B's legitimate VFNs. While blockchain data is eventually public, early access to mempool transactions or validator operational data could provide unfair advantages.

**Trust Boundary Violation:** The test code explicitly encodes same-owner validation as a security requirement. The production code's failure to enforce this violates the intended network isolation model where each validator's VFN network should be private to that validator operator.

**Resource Consumption:** Multiple malicious VFNs from different operators could connect to a target validator's VFN network port, consuming connection slots and network bandwidth. While this doesn't rise to DoS severity (which is out of scope), it represents unintended resource allocation.

**Protocol Confusion:** Network protocols may make assumptions about peer trustworthiness on the VFN network that are violated when cross-owner connections occur. This could lead to unexpected behavior in consensus observer, state sync, or mempool protocols.

The impact is Medium rather than High because:
- No direct consensus safety violation occurs (validators don't run consensus on VFN network)
- No funds are directly at risk
- Validators remain operational despite unauthorized VFN connections
- The validator network (used for consensus) has proper mutual authentication

## Likelihood Explanation

**Likelihood: High**

The attack is highly likely to occur because:

1. **Low Technical Barrier:** VFN addresses are public on-chain and easily discoverable. Any validator operator running a VFN can query the ValidatorSet and obtain target addresses.

2. **No Authentication Barrier:** The production code accepts any correctly-formed VFN connection without owner validation. An attacker only needs to generate valid cryptographic keys.

3. **Clear Incentive:** Validator operators have economic incentives to gain early access to mempool transactions, monitor competitor operations, or gather network intelligence.

4. **Operational Ease:** The attack requires only standard VFN configuration changes to point at a different validator's VFN address.

5. **No Detection:** The victim validator may not realize cross-owner VFNs are connected, as they appear as legitimate ValidatorFullNode peers.

## Recommendation

**Enforce owner validation in production handshake code:**

Add validation in the `upgrade_inbound` function to verify that VFN connections on the VFN network come from peers with matching owner accounts:

```rust
// In network/framework/src/noise/handshake.rs, around line 407
if self.network_context.role().is_validator() {
    if network_id.is_vfn_network() {
        // VFN network requires same-owner validation
        let validator_owner = self.network_context.peer_id(); // Validator's owner account
        if remote_peer_id != validator_owner {
            // VFN's peer_id should match validator's owner for same-owner connections
            // Or check against a configured allowlist of owned VFN peer_ids
            return Err(NoiseHandshakeError::CrossOwnerVfnConnectionAttempt(
                remote_peer_short,
                remote_peer_id,
                validator_owner,
            ));
        }
        Ok(PeerRole::ValidatorFullNode)
    } else {
        Ok(PeerRole::Unknown)
    }
}
```

**Alternative: Enable mutual authentication for VFN network:**

Configure VFN networks to use `mutual_authentication: true` by default, and ensure trusted peers for the VFN network only include same-owner VFNs:

```yaml
# In validator.yaml
full_node_networks:
    - listen_address: "/ip4/0.0.0.0/tcp/6181"
      mutual_authentication: true  # Add this
      network_id:
          private: "vfn"
```

**Additional safeguards:**
- Log warnings when VFN connections from unexpected peer_ids are detected
- Add metrics to track cross-owner connection attempts
- Document the intended VFN network security model clearly

## Proof of Concept

```rust
// Reproduction steps:
// 
// 1. Deploy two validators (Validator A and Validator B) with different owner accounts
// 2. Query on-chain ValidatorSet to get Validator B's VFN network address
// 3. Configure a VFN owned by Validator A's operator
// 4. Modify the VFN's seed configuration to point to Validator B's VFN address
// 5. Start the VFN and observe successful connection to Validator B
//
// Expected (secure) behavior: Connection rejected due to owner mismatch
// Actual (vulnerable) behavior: Connection accepted, cross-owner VFN connected
//
// Verification:
// - Check Validator B's peer list - it will show a VFN with Validator A's owner account
// - The VFN will receive state sync, mempool, and other data from Validator B
// - No errors or warnings are logged about the owner mismatch

#[test]
fn test_cross_owner_vfn_connection_vulnerability() {
    // Setup validator A with owner_account_a
    let validator_a_owner = AccountAddress::random();
    let validator_a_config = create_validator_config(validator_a_owner);
    
    // Setup validator B with different owner_account_b
    let validator_b_owner = AccountAddress::random();
    let validator_b_config = create_validator_config(validator_b_owner);
    
    // Setup VFN owned by validator A's operator
    let vfn_a_peer_id = validator_a_owner; // VFN uses owner account as peer_id
    let vfn_config = create_vfn_config(vfn_a_peer_id);
    
    // Attempt to connect VFN-A to Validator-B's VFN network port
    let connection_result = attempt_vfn_connection(
        vfn_config,
        validator_b_config.vfn_network_address,
        validator_b_config.vfn_network_pubkey,
    );
    
    // VULNERABILITY: Connection succeeds despite owner mismatch
    assert!(connection_result.is_ok(), "Cross-owner VFN connection was accepted");
    
    // The test framework prevents this (builder.rs:122-125)
    // But production code allows it (handshake.rs:407-410)
}
```

## Notes

This vulnerability represents a test-to-production gap where security assumptions encoded in test utilities are not enforced in production code. The test framework's explicit same-owner restriction indicates this was an intended security boundary, but the implementation oversight left validators vulnerable to cross-owner VFN connection attempts.

The issue is exacerbated by VFN addresses being published on-chain, making the attack surface easily discoverable. While the immediate impact is limited to information disclosure and resource consumption, it violates the network isolation model and could enable more sophisticated attacks if combined with other vulnerabilities.

### Citations

**File:** network/framework/src/testutils/builder.rs (L122-125)
```rust
                // The VFN network only goes between the same owner, skip it if it doesn't match
                if network_id == NetworkId::Vfn && owner != other_node_id.owner {
                    continue;
                }
```

**File:** network/framework/src/noise/handshake.rs (L407-410)
```rust
                            if self.network_context.role().is_validator() {
                                if network_id.is_vfn_network() {
                                    // Inbound connections to validators on the VFN network must be VFNs
                                    Ok(PeerRole::ValidatorFullNode)
```

**File:** config/src/config/network_config.rs (L136-142)
```rust
        let mutual_authentication = network_id.is_validator_network();
        let mut config = Self {
            discovery_method: DiscoveryMethod::None,
            discovery_methods: Vec::new(),
            identity: Identity::None,
            listen_address: "/ip4/0.0.0.0/tcp/6180".parse().unwrap(),
            mutual_authentication,
```

**File:** network/discovery/src/validator_set.rs (L121-129)
```rust
            let addrs = if is_validator {
                config
                    .validator_network_addresses()
                    .map_err(anyhow::Error::from)
            } else {
                config
                    .fullnode_network_addresses()
                    .map_err(anyhow::Error::from)
            }
```

**File:** config/src/config/test_data/validator.yaml (L24-38)
```yaml
full_node_networks:
    - listen_address: "/ip4/0.0.0.0/tcp/6181"
      max_outbound_connections: 0
      identity:
          type: "from_storage"
          key_name: "fullnode_network"
          peer_id_name: "owner_account"
          backend:
              type: "vault"
              server: "https://127.0.0.1:8200"
              ca_certificate: "/full/path/to/certificate"
              token:
                  from_disk: "/full/path/to/token"
      network_id:
          private: "vfn"
```

**File:** config/src/config/test_data/validator_full_node.yaml (L15-40)
```yaml
# For validator fullnode we setup two network ids, the private "vfn" identity will allow it to connect to the validator node,
# and the public identity will allow it to connects to other fullnodes onchain.

full_node_networks:
    - listen_address: "/ip4/0.0.0.0/tcp/6180"
      discovery_method: "onchain"
      identity:
          type: "from_storage"
          key_name: "fullnode_network"
          peer_id_name: "owner_account"
          backend:
              type: "vault"
              server: "https://127.0.0.1:8200"
              ca_certificate: "/full/path/to/certificate"
              token:
                  from_disk: "/full/path/to/token"
      network_id: "public"
    - listen_address: "/ip4/0.0.0.0/tcp/6181"
      max_outbound_connections: 1
      network_id:
          private: "vfn"
      seeds:
        00000000000000000000000000000000d58bc7bb154b38039bc9096ce04e1237:
          addresses:
          - "/ip4/127.0.0.1/tcp/6181/noise-ik/f0274c2774519281a8332d0bb9d8101bd58bc7bb154b38039bc9096ce04e1237/handshake/0"
          role: "Validator"
```
