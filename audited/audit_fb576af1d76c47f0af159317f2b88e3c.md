# Audit Report

## Title
Unbounded BTreeMap Memory Growth in Module Dependency Traversal Before Gas Limit Enforcement

## Summary
The `TraversalContext` struct in the Move VM runtime allows the `visited` BTreeMap to grow to sizes far exceeding the enforced 768-module dependency limit. This occurs because module dependencies are added to the BTreeMap before gas limit checks, enabling an attacker to cause significant memory allocation and validator slowdowns.

## Finding Description

The vulnerability exists in the interaction between module dependency traversal and gas limit enforcement. When traversing module dependencies, the system adds all immediate dependencies of a module to the `visited` BTreeMap before checking if the gas limit has been exceeded. [1](#0-0) 

The traversal process in `check_dependencies_and_charge_gas` follows this order: [2](#0-1) 

The critical issue is that `push_next_ids_to_visit` adds modules to the `visited` BTreeMap (line 104) BEFORE the gas meter's `count_dependency` check (lines 82-89) validates the limit: [3](#0-2) 

The gas limit enforcement happens in the gas meter's `count_dependency` method: [4](#0-3) 

**Attack Sequence:**
1. Attacker publishes N modules (M1, M2, ..., MN) where each module has many immediate dependencies
2. The Move binary format allows up to 65,535 module handles per module: [5](#0-4) 

3. When a transaction loads module M1:
   - M1 is popped from stack and charged (count=1)
   - M1's immediate dependencies (e.g., 10,000 modules) are all added to `visited` via `push_next_ids_to_visit`
   - BTreeMap now contains 10,001 entries, but only 1 has been charged
   
4. Process continues for modules M2, M3, etc.
5. After charging 768 modules, `DEPENDENCY_LIMIT_REACHED` error occurs
6. But `visited` BTreeMap has grown to contain hundreds of thousands or millions of entries

**Worst Case Calculation:**
- If 768 modules each have 10,000 immediate dependencies (realistic for deliberately crafted attack modules)
- BTreeMap could grow to ~768 × 10,000 = 7.68 million entries
- Memory per entry: ~48-64 bytes (reference pointers + BTreeMap node overhead)
- Total memory: 7.68M × 60 bytes ≈ **460 MB** per transaction

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program's "Validator node slowdowns" category.

**Impact:**
1. **Memory Exhaustion**: Validators must allocate hundreds of megabytes of memory per malicious transaction
2. **Processing Slowdown**: BTreeMap operations (insertion, lookup) become slower with millions of entries
3. **Denial of Service**: Multiple concurrent malicious transactions could collectively exhaust validator memory or cause significant performance degradation
4. **Consensus Impact**: Validator slowdowns can affect block production times and network liveness

The vulnerability breaks the **"Move VM Safety: Bytecode execution must respect gas limits and memory constraints"** invariant, as memory allocation happens before proper limit enforcement.

## Likelihood Explanation

**Likelihood: Medium-High**

**Attacker Requirements:**
1. Publish thousands of modules with carefully crafted dependency graphs (expensive upfront cost)
2. Each module stays within the 64KB transaction size limit
3. Modules must pass bytecode verification

**Cost Analysis:**
- Publishing 10,000 modules requires 10,000 transactions
- Gas cost per module publish varies but is non-trivial
- However, once modules are published, the attack can be triggered repeatedly with low-cost transactions

**Feasibility:**
- A well-funded attacker could publish the required modules over time
- The attack is repeatable and can target any validator processing the malicious transaction
- No special privileges required - any account can publish modules and execute transactions

## Recommendation

Implement early limit checking before adding modules to the `visited` BTreeMap. The fix should enforce the dependency count limit **before** allocating memory for additional dependencies.

**Proposed Fix:**

In `dependencies_gas_charging.rs`, modify `check_dependencies_and_charge_gas` to track the count and check limits before calling `push_next_ids_to_visit`:

```rust
pub fn check_dependencies_and_charge_gas<'a, I>(
    module_storage: &impl ModuleStorage,
    gas_meter: &mut impl DependencyGasMeter,
    traversal_context: &mut TraversalContext<'a>,
    ids: I,
) -> VMResult<()>
where
    I: IntoIterator<Item = (&'a AccountAddress, &'a IdentStr)>,
    I::IntoIter: DoubleEndedIterator,
{
    let _timer = VM_TIMER.timer_with_label("check_dependencies_and_charge_gas");
    let mut stack = Vec::with_capacity(512);
    traversal_context.push_next_ids_to_visit(&mut stack, ids);

    while let Some((addr, name)) = stack.pop() {
        let size = module_storage.unmetered_get_existing_module_size(addr, name)?;
        
        // Charge BEFORE loading the module to enforce limits early
        gas_meter
            .charge_dependency(DependencyKind::Existing, addr, name, NumBytes::new(size as u64))
            .map_err(|err| err.finish(Location::Module(ModuleId::new(*addr, name.to_owned()))))?;

        let compiled_module = module_storage.unmetered_get_existing_deserialized_module(addr, name)?;
        let compiled_module = traversal_context.referenced_modules.alloc(compiled_module);

        // Pre-check: Ensure we won't exceed limits with immediate dependencies
        let imm_deps_and_friends: Vec<_> = compiled_module
            .immediate_dependencies_iter()
            .chain(compiled_module.immediate_friends_iter())
            .collect();
        
        // Check if adding these dependencies would exceed limits
        // This prevents unbounded growth before allocation
        let potential_new_count = imm_deps_and_friends.iter()
            .filter(|(addr, name)| !addr.is_special() && !traversal_context.visited.contains_key(&(*addr, *name)))
            .count();
        
        // Perform a lookahead check (requires access to gas meter internals or additional method)
        // This is a conceptual fix - actual implementation would need gas meter API changes
        
        traversal_context.push_next_ids_to_visit(&mut stack, imm_deps_and_friends.into_iter());
    }

    Ok(())
}
```

**Alternative Fix**: Add a hard limit on the `visited` BTreeMap size directly in `TraversalContext::push_next_ids_to_visit` to prevent unbounded growth regardless of gas checks.

## Proof of Concept

```rust
// Conceptual PoC - Would need to be integrated into Move test framework

// Step 1: Publish attack modules
// Create 10 modules, each depending on 1000 other small modules
for i in 0..10 {
    let module_code = create_module_with_n_dependencies(i, 1000);
    publish_module(attacker_account, module_code);
}

// Publish the 1000 dependency modules
for i in 0..1000 {
    let small_module = create_minimal_module(i);
    publish_module(attacker_account, small_module);
}

// Step 2: Trigger the attack
// Execute a transaction that loads one of the attack modules
let result = run_entry_function(
    attacker_account,
    "attack_module::trigger",
    vec![],
    vec![]
);

// Observe: Transaction fails with DEPENDENCY_LIMIT_REACHED after charging 768 modules
// But TraversalContext.visited BTreeMap has grown to ~10,000 entries
// Memory allocated: ~600 KB per attack module × 10 modules before failure = ~6 MB
// With 768 such modules: ~460 MB memory allocated before failure
```

## Notes

The vulnerability is exacerbated by the large MODULE_HANDLE_INDEX_MAX limit (65,535) which allows modules to declare tens of thousands of dependencies. While publishing such modules is expensive, once published they enable efficient repeated attacks. The core issue is the timing mismatch between memory allocation (during BTreeMap insertion) and limit enforcement (during gas charging).

### Citations

**File:** third_party/move/move-vm/runtime/src/module_traversal.rs (L23-30)
```rust
pub struct TraversalContext<'a> {
    visited: BTreeMap<(&'a AccountAddress, &'a IdentStr), ()>,

    pub referenced_scripts: &'a Arena<Arc<CompiledScript>>,
    pub referenced_modules: &'a Arena<Arc<CompiledModule>>,
    pub referenced_module_ids: &'a Arena<ModuleId>,
    pub referenced_module_bundles: &'a Arena<Vec<CompiledModule>>,
}
```

**File:** third_party/move/move-vm/runtime/src/module_traversal.rs (L122-138)
```rust
    /// If address-name pairs are not special and have not been visited, visits them and pushes
    /// them to the provided stack.
    pub(crate) fn push_next_ids_to_visit<I>(
        &mut self,
        stack: &mut Vec<(&'a AccountAddress, &'a IdentStr)>,
        ids: I,
    ) where
        I: IntoIterator<Item = (&'a AccountAddress, &'a IdentStr)>,
        I::IntoIter: DoubleEndedIterator,
    {
        for (addr, name) in ids.into_iter().rev() {
            if self.visit_if_not_special_address(addr, name) {
                stack.push((addr, name));
            }
        }
    }
}
```

**File:** third_party/move/move-vm/runtime/src/storage/dependencies_gas_charging.rs (L72-108)
```rust
    let _timer = VM_TIMER.timer_with_label("check_dependencies_and_charge_gas");

    // Initialize the work list (stack) and the map of visited modules.
    //
    // TODO: Determine the reserved capacity based on the max number of dependencies allowed.
    let mut stack = Vec::with_capacity(512);
    traversal_context.push_next_ids_to_visit(&mut stack, ids);

    while let Some((addr, name)) = stack.pop() {
        let size = module_storage.unmetered_get_existing_module_size(addr, name)?;
        gas_meter
            .charge_dependency(
                DependencyKind::Existing,
                addr,
                name,
                NumBytes::new(size as u64),
            )
            .map_err(|err| err.finish(Location::Module(ModuleId::new(*addr, name.to_owned()))))?;

        // Extend the lifetime of the module to the remainder of the function body
        // by storing it in an arena.
        //
        // This is needed because we need to store references derived from it in the
        // work list.
        let compiled_module =
            module_storage.unmetered_get_existing_deserialized_module(addr, name)?;
        let compiled_module = traversal_context.referenced_modules.alloc(compiled_module);

        // Explore all dependencies and friends that have been visited yet.
        let imm_deps_and_friends = compiled_module
            .immediate_dependencies_iter()
            .chain(compiled_module.immediate_friends_iter());
        traversal_context.push_next_ids_to_visit(&mut stack, imm_deps_and_friends);
    }

    Ok(())
}
```

**File:** aptos-move/aptos-gas-meter/src/algebra.rs (L300-313)
```rust
    fn count_dependency(&mut self, size: NumBytes) -> PartialVMResult<()> {
        if self.feature_version >= 15 {
            self.num_dependencies += 1.into();
            self.total_dependency_size += size;

            if self.num_dependencies > self.vm_gas_params.txn.max_num_dependencies {
                return Err(PartialVMError::new(StatusCode::DEPENDENCY_LIMIT_REACHED));
            }
            if self.total_dependency_size > self.vm_gas_params.txn.max_total_dependency_size {
                return Err(PartialVMError::new(StatusCode::DEPENDENCY_LIMIT_REACHED));
            }
        }
        Ok(())
    }
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L43-47)
```rust
pub const TABLE_INDEX_MAX: u64 = 65535;
pub const SIGNATURE_INDEX_MAX: u64 = TABLE_INDEX_MAX;
pub const ADDRESS_INDEX_MAX: u64 = TABLE_INDEX_MAX;
pub const IDENTIFIER_INDEX_MAX: u64 = TABLE_INDEX_MAX;
pub const MODULE_HANDLE_INDEX_MAX: u64 = TABLE_INDEX_MAX;
```
