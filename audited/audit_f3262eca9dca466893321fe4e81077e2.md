# Audit Report

## Title
Missing Per-Transaction Event Count Limit Enables Resource Exhaustion Attack on Indexers and Storage

## Summary
The Aptos event emission system lacks an explicit per-transaction event count limit, relying solely on byte-size limits (10MB total) and gas costs. This allows an attacker to emit tens of thousands of tiny events per transaction, causing disproportionate burden on event indexers, API services, and storage systems relative to the gas cost paid.

## Finding Description

The event emission validation in `ChangeSetConfigs::check_change_set()` only enforces byte-size limits without checking the number of events: [1](#0-0) 

An attacker can craft a transaction that emits a large number of minimal-size events (e.g., structs with single boolean fields) that stay within the 10MB total event size limit but create thousands of individual event records. 

The gas charging for events consists of two components:

1. **Execution gas** charged during `native_write_to_event_store()`: [2](#0-1) 

2. **IO gas** charged later based on serialized event size: [3](#0-2) 

For minimal events (~80 abstract value units, ~10 bytes serialized):
- Execution gas: 20,006 + 61 × 80 = 24,886 per event
- IO gas: 89 × 10 = 890 per event
- With max_execution_gas of 920,000,000, an attacker can emit approximately **36,971 events per transaction** [4](#0-3) 

The transaction size limit configuration shows only byte-based limits: [5](#0-4) 

Each event must be individually indexed, queried, and stored by validators and API services. The per-event processing overhead for indexers is not reflected in the gas price, creating an economic imbalance where the attacker's cost (gas fees) is significantly lower than the defender's cost (storage, indexing, query processing).

## Impact Explanation

This qualifies as **Medium Severity** under Aptos bug bounty criteria for the following reasons:

1. **State inconsistencies requiring intervention**: Excessive event emission can cause indexer databases to bloat, leading to degraded query performance requiring manual intervention (pruning, re-indexing)

2. **Validator node slowdowns** (approaching High): Event accumulation affects validator storage growth rates and can degrade node performance over time

The attack does not directly cause consensus failures or fund loss, but creates operational burden disproportionate to the economic cost paid by the attacker. By submitting multiple transactions, each with ~37K events, an attacker can force the network to store and index millions of events for a relatively modest gas expenditure.

## Likelihood Explanation

**Likelihood: High**

- Exploitable by any unprivileged transaction sender
- No special permissions or validator access required  
- Attack is economically viable if gas costs are lower than operational costs imposed on defenders
- Can be executed repeatedly across multiple transactions
- No detection or rate-limiting mechanisms exist beyond gas costs

The attack becomes more likely if:
- Event indexing/storage costs scale per-event rather than per-byte
- Indexer query performance degrades with event count regardless of total size
- Network operators bear costs not reflected in gas prices

## Recommendation

Add an explicit per-transaction event count limit to `ChangeSetConfigs`:

```rust
// In ChangeSetConfigs struct
pub struct ChangeSetConfigs {
    // ... existing fields ...
    max_events_per_transaction: u64,
}

// In check_change_set method
pub fn check_change_set(&self, change_set: &impl ChangeSetInterface) -> Result<(), VMStatus> {
    // ... existing write ops checks ...
    
    let mut event_count = 0;
    let mut total_event_size = 0;
    for event in change_set.events_iter() {
        event_count += 1;
        if event_count > self.max_events_per_transaction {
            return storage_write_limit_reached(Some("Too many events."));
        }
        
        let size = event.event_data().len() as u64;
        if size > self.max_bytes_per_event {
            return storage_write_limit_reached(None);
        }
        total_event_size += size;
        if total_event_size > self.max_bytes_all_events_per_transaction {
            return storage_write_limit_reached(None);
        }
    }
    
    Ok(())
}
```

Recommended limit: 1,000-5,000 events per transaction based on operational testing.

## Proof of Concept

```move
module attacker::event_flood {
    use std::signer;
    use aptos_framework::event;
    
    struct TinyEvent has drop, store {
        value: bool,
    }
    
    public entry fun flood_events(sender: &signer) {
        let i = 0;
        // Emit as many events as gas allows (~36,971 with current limits)
        while (i < 40000) {
            event::emit(TinyEvent { value: true });
            i = i + 1;
        };
    }
}
```

This module, when executed with sufficient gas, will emit tens of thousands of minimal events, demonstrating the lack of event count enforcement and the disproportionate burden on indexing systems.

**Notes:**

The vulnerability exists because the abstraction of "cost" through gas pricing may not accurately reflect the true operational cost of event storage and indexing. While gas provides economic constraints, the per-event overhead in off-chain systems (indexers, explorers) is not proportionally represented in the per-byte gas model.

### Citations

**File:** aptos-move/aptos-vm-types/src/storage/change_set_configs.rs (L115-125)
```rust
        let mut total_event_size = 0;
        for event in change_set.events_iter() {
            let size = event.event_data().len() as u64;
            if size > self.max_bytes_per_event {
                return storage_write_limit_reached(None);
            }
            total_event_size += size;
            if total_event_size > self.max_bytes_all_events_per_transaction {
                return storage_write_limit_reached(None);
            }
        }
```

**File:** aptos-move/framework/src/natives/event.rs (L258-261)
```rust
    context.charge(
        EVENT_WRITE_TO_EVENT_STORE_BASE
            + EVENT_WRITE_TO_EVENT_STORE_PER_ABSTRACT_VALUE_UNIT * context.abs_val_size(&msg)?,
    )?;
```

**File:** aptos-move/aptos-vm-types/src/storage/io_pricing.rs (L296-301)
```rust
    pub fn io_gas_per_event(
        &self,
        event: &ContractEvent,
    ) -> impl GasExpression<VMGasParameters, Unit = InternalGasUnit> + use<> {
        STORAGE_IO_PER_EVENT_BYTE_WRITE * NumBytes::new(event.size() as u64)
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L164-172)
```rust
            max_bytes_per_event: NumBytes,
            { 5.. => "max_bytes_per_event" },
            1 << 20, // a single event is 1MB max
        ],
        [
            max_bytes_all_events_per_transaction: NumBytes,
            { 5.. => "max_bytes_all_events_per_transaction"},
            10 << 20, // all events from a single transaction are 10MB max
        ],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L211-214)
```rust
            max_execution_gas: InternalGas,
            { 7.. => "max_execution_gas" },
            920_000_000, // 92ms of execution at 10k gas per ms
        ],
```
