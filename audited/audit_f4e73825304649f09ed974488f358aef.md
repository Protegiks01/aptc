# Audit Report

## Title
Validator Node Denial of Service via Malformed Sigma Protocol Proof in DKG Transcript

## Summary
An attacker can craft a DKG transcript containing a sigma protocol proof with an invalid `FirstProofItem::Challenge` variant that deserializes successfully but causes a panic during verification, leading to validator node crashes and denial of service.

## Finding Description
The sigma protocol proof verification code in [1](#0-0)  contains a pattern match that panics when encountering a `Challenge` variant instead of the expected `Commitment` variant. 

However, the deserialization implementation [2](#0-1)  permits both variants to be deserialized successfully, with no validation preventing the `Challenge` variant (discriminant tag = 1) from being used.

When a DKG transcript is submitted and processed through [3](#0-2) , the transcript deserializes successfully via BCS, then enters verification through [4](#0-3) . This eventually calls the sigma protocol's verify method, which invokes `msm_terms_for_verify` and encounters the panic.

The attack path:
1. Attacker crafts a DKG transcript with `sharing_proof.SoK.first_proof_item = FirstProofItem::Challenge(arbitrary_field_element)`
2. Serializes the transcript using BCS with arkworks serialization
3. Submits the transcript through the DKG process
4. The transcript deserializes successfully (both Commitment and Challenge are valid enum variants)
5. During verification, the code hits the panic and the validator node crashes

## Impact Explanation
This is a **High Severity** vulnerability per Aptos bug bounty criteria. It enables an unprivileged attacker to crash validator nodes, causing denial of service. While it doesn't directly compromise funds or consensus safety, it can:
- Crash multiple validator nodes if they process the malicious transcript
- Reduce network availability and liveness
- Potentially be used to disrupt epoch transitions or DKG processes
- Force validator operators to manually restart nodes

The impact qualifies as "Validator node slowdowns" and "API crashes" under High Severity, and could escalate to availability issues if multiple validators are affected simultaneously.

## Likelihood Explanation
This vulnerability is **highly likely** to be exploitable because:
- The attack requires no special privileges or validator access
- DKG transcripts can be submitted through the normal transaction flow
- Crafting a malicious transcript is straightforward - simply set the enum discriminant to 1 (Challenge) instead of 0 (Commitment)
- Deserialization succeeds without any validation checks
- The panic is guaranteed to trigger during verification
- No input sanitization or validation prevents this attack vector

## Recommendation
Implement one of the following fixes:

**Option 1: Return error instead of panic**
Replace the panic with an error return in [5](#0-4) :
```rust
FirstProofItem::Challenge(_) => {
    return Err(anyhow!("Invalid proof format: Challenge variant not supported in verification"));
}
```

**Option 2: Add deserialization validation**
Implement a `Valid` trait for `Proof` that checks the `first_proof_item` variant, or add validation in the deserialization path to reject Challenge variants when they're not expected.

**Option 3: Complete the implementation**
If Challenge variants are intended to be supported (for batch verification scenarios), complete the implementation instead of panicking.

## Proof of Concept
```rust
use aptos_dkg::sigma_protocol::{Proof, FirstProofItem};
use ark_bls12_381::Bls12_381;

// Create a malicious proof with Challenge variant
let malicious_proof = Proof {
    first_proof_item: FirstProofItem::Challenge(Fr::from(42u64)), // Use Challenge instead of Commitment
    z: /* valid witness data */,
};

// Serialize the proof
let serialized = bcs::to_bytes(&malicious_proof).unwrap();

// When a validator deserializes and verifies this proof:
// 1. Deserialization succeeds
// 2. Verification calls msm_terms_for_verify
// 3. Pattern match hits the panic at line 116
// Result: Validator node crashes
```

## Notes
The vulnerability exists because the code assumes `FirstProofItem::Commitment` but permits `FirstProofItem::Challenge` to deserialize. The comment at line 116 indicates this is unimplemented functionality ("Missing implementation"), suggesting this was a known gap that was never completed. The arkworks `Validate::Yes` parameter used in deserialization [6](#0-5)  validates cryptographic elements (curve points, field elements) but does not prevent semantically invalid enum variants from being accepted.

### Citations

**File:** crates/aptos-dkg/src/sigma_protocol/traits.rs (L113-118)
```rust
        let prover_first_message = match &proof.first_proof_item {
            FirstProofItem::Commitment(A) => A,
            FirstProofItem::Challenge(_) => {
                panic!("Missing implementation - expected commitment, not challenge")
            },
        };
```

**File:** crates/aptos-dkg/src/sigma_protocol/traits.rs (L308-340)
```rust
impl<F: PrimeField, H: homomorphism::Trait> CanonicalDeserialize for FirstProofItem<F, H>
where
    H::Domain: Witness<F>,
    H::Codomain: Statement + CanonicalDeserialize + Valid,
{
    fn deserialize_with_mode<R: Read>(
        mut reader: R,
        compress: Compress,
        validate: Validate,
    ) -> Result<Self, SerializationError> {
        // Read the discriminant tag
        let tag = u8::deserialize_with_mode(&mut reader, compress, validate)?;

        let item = match tag {
            0 => {
                let c = H::Codomain::deserialize_with_mode(reader, compress, validate)?;
                FirstProofItem::Commitment(c)
            },
            1 => {
                let f = F::deserialize_with_mode(reader, compress, validate)?;
                FirstProofItem::Challenge(f)
            },
            _ => return Err(SerializationError::InvalidData),
        };

        // Run validity check if requested
        if validate == Validate::Yes {
            item.check()?;
        }

        Ok(item)
    }
}
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L104-112)
```rust
        // Deserialize transcript and verify it.
        let pub_params = DefaultDKG::new_public_params(&in_progress_session_state.metadata);
        let transcript = bcs::from_bytes::<<DefaultDKG as DKGTrait>::Transcript>(
            dkg_node.transcript_bytes.as_slice(),
        )
        .map_err(|_| Expected(TranscriptDeserializationFailed))?;

        DefaultDKG::verify_transcript(&pub_params, &transcript)
            .map_err(|_| Expected(TranscriptVerificationFailed))?;
```

**File:** types/src/dkg/real_dkg/mod.rs (L368-374)
```rust
        trx.main.verify(
            &params.pvss_config.wconfig,
            &params.pvss_config.pp,
            &spks,
            &all_eks,
            &aux,
        )?;
```
