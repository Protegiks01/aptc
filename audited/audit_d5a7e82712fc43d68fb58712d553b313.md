# Audit Report

## Title
Split-Brain Database Writes in FastSyncStorageWrapper Due to Non-Atomic Status Checks

## Summary
The `FastSyncStorageWrapper` contains a critical race condition where the two-phase commit protocol (`pre_commit_ledger` and `commit_ledger`) can be split across two different databases (`temporary_db_with_genesis` and `db_for_fast_sync`) if the `fast_sync_status` transitions from `UNKNOWN` to `STARTED` between these operations. This violates atomicity guarantees and can cause state corruption.

## Finding Description
The `FastSyncStorageWrapper` manages two databases during fast sync initialization:
- `temporary_db_with_genesis`: Used for genesis data storage when status is `UNKNOWN`
- `db_for_fast_sync`: Used for fast sync snapshot and subsequent operations when status is `STARTED` or `FINISHED`

The vulnerability exists because `pre_commit_ledger` and `commit_ledger` independently call `get_aptos_db_write_ref()` to determine the target database: [1](#0-0) [2](#0-1) [3](#0-2) 

The status transition occurs in `get_state_snapshot_receiver`: [4](#0-3) 

The critical issue is that `save_transactions` (used by state sync) calls both operations sequentially without atomicity: [5](#0-4) 

**Attack Scenario:**
1. Thread A calls `save_transactions()` with status=`UNKNOWN`
2. Thread A executes `pre_commit_ledger()` → writes to `temporary_db_with_genesis`
3. Thread B calls `get_state_snapshot_receiver()` → status changes to `STARTED`
4. Thread A continues and executes `commit_ledger()` → writes to `db_for_fast_sync`
5. **Result**: Pre-commit data in `temporary_db_with_genesis`, commit in `db_for_fast_sync` = split-brain state

This breaks the fundamental invariant that state transitions must be atomic and consistent.

## Impact Explanation
This qualifies as **Critical Severity** under Aptos bug bounty criteria due to:

1. **Consensus Safety Violation**: Split-brain writes can cause validators to have inconsistent state, leading to different state roots and potential chain splits
2. **Data Loss**: Pre-committed data in `temporary_db_with_genesis` is never properly committed and becomes inaccessible
3. **State Corruption**: The `db_for_fast_sync` receives commits without corresponding pre-commit data, violating the two-phase commit protocol
4. **Non-Recoverable State**: A node in this corrupted state would likely require a full resync or hardfork to recover

The vulnerability directly violates the "State Consistency: State transitions must be atomic and verifiable via Merkle proofs" invariant.

## Likelihood Explanation
While the race condition exists in the code structure, triggering it in practice requires very specific timing:

- The vulnerability window exists only during the transition from `UNKNOWN` to `STARTED` status
- Multiple concurrent threads must be performing write operations during initialization
- State sync initialization (`get_state_snapshot_receiver`) must occur precisely between `pre_commit_ledger` and `commit_ledger` calls

The likelihood is **Low to Medium** because:
- The bootstrapper generally serializes operations during initialization
- Consensus is blocked until bootstrapping completes per the driver checks
- Most write paths during initialization bypass the wrapper

However, edge cases involving error recovery, concurrent initialization paths, or future code changes could increase the likelihood.

## Recommendation
Implement atomic database selection for the entire two-phase commit sequence:

```rust
pub(crate) fn get_aptos_db_write_ref_atomic(&self) -> &AptosDB {
    // Return the database based on current status, ensuring both
    // pre_commit and commit use the same instance
    if self.is_fast_sync_bootstrap_started() || self.is_fast_sync_bootstrap_finished() {
        self.db_for_fast_sync.as_ref()
    } else {
        self.temporary_db_with_genesis.as_ref()
    }
}

fn pre_commit_ledger(&self, chunk: ChunkToCommit, sync_commit: bool) -> Result<()> {
    let target_db = self.get_aptos_db_write_ref_atomic();
    target_db.pre_commit_ledger(chunk, sync_commit)
}

fn commit_ledger(
    &self,
    version: Version,
    ledger_info_with_sigs: Option<&LedgerInfoWithSignatures>,
    chunk_opt: Option<ChunkToCommit>,
) -> Result<()> {
    let target_db = self.get_aptos_db_write_ref_atomic();
    target_db.commit_ledger(version, ledger_info_with_sigs, chunk_opt)
}
```

**Better solution**: Acquire a read lock on `fast_sync_status` at the start of write operations and hold it until both `pre_commit_ledger` and `commit_ledger` complete, ensuring the status cannot change mid-operation.

## Proof of Concept
```rust
// Conceptual PoC demonstrating the race condition
// This would need to be adapted to actual test infrastructure

use std::sync::{Arc, Barrier};
use std::thread;

#[test]
fn test_split_brain_race_condition() {
    // Setup: Create FastSyncStorageWrapper with status UNKNOWN
    let wrapper = setup_fast_sync_wrapper();
    let barrier = Arc::new(Barrier::new(2));
    
    let wrapper1 = wrapper.clone();
    let barrier1 = barrier.clone();
    
    // Thread A: Perform write operation
    let handle1 = thread::spawn(move || {
        // Start pre_commit_ledger (status = UNKNOWN, writes to temporary_db)
        wrapper1.pre_commit_ledger(chunk, false).unwrap();
        
        // Wait for status transition
        barrier1.wait();
        
        // Continue with commit_ledger (status now STARTED, writes to db_for_fast_sync)
        wrapper1.commit_ledger(version, Some(&ledger_info), Some(chunk)).unwrap();
    });
    
    let wrapper2 = wrapper.clone();
    let barrier2 = barrier.clone();
    
    // Thread B: Trigger status transition
    let handle2 = thread::spawn(move || {
        barrier2.wait();
        
        // Change status from UNKNOWN to STARTED
        wrapper2.get_state_snapshot_receiver(version, root_hash).unwrap();
    });
    
    handle1.join().unwrap();
    handle2.join().unwrap();
    
    // Verify: Check that pre_commit went to temporary_db but commit went to db_for_fast_sync
    // This would demonstrate the split-brain condition
}
```

**Notes:**
- The actual PoC would require proper setup of the storage infrastructure
- Timing-dependent race conditions are notoriously difficult to reproduce reliably
- A deterministic test would require instrumentation or mocking of the status transition

### Citations

**File:** storage/aptosdb/src/fast_sync_storage_wrapper.rs (L134-140)
```rust
    pub(crate) fn get_aptos_db_write_ref(&self) -> &AptosDB {
        if self.is_fast_sync_bootstrap_started() || self.is_fast_sync_bootstrap_finished() {
            self.db_for_fast_sync.as_ref()
        } else {
            self.temporary_db_with_genesis.as_ref()
        }
    }
```

**File:** storage/aptosdb/src/fast_sync_storage_wrapper.rs (L144-152)
```rust
    fn get_state_snapshot_receiver(
        &self,
        version: Version,
        expected_root_hash: HashValue,
    ) -> Result<Box<dyn StateSnapshotReceiver<StateKey, StateValue>>> {
        *self.fast_sync_status.write() = FastSyncStatus::STARTED;
        self.get_aptos_db_write_ref()
            .get_state_snapshot_receiver(version, expected_root_hash)
    }
```

**File:** storage/aptosdb/src/fast_sync_storage_wrapper.rs (L172-175)
```rust
    fn pre_commit_ledger(&self, chunk: ChunkToCommit, sync_commit: bool) -> Result<()> {
        self.get_aptos_db_write_ref()
            .pre_commit_ledger(chunk, sync_commit)
    }
```

**File:** storage/aptosdb/src/fast_sync_storage_wrapper.rs (L177-185)
```rust
    fn commit_ledger(
        &self,
        version: Version,
        ledger_info_with_sigs: Option<&LedgerInfoWithSignatures>,
        chunk_opt: Option<ChunkToCommit>,
    ) -> Result<()> {
        self.get_aptos_db_write_ref()
            .commit_ledger(version, ledger_info_with_sigs, chunk_opt)
    }
```

**File:** storage/storage-interface/src/lib.rs (L608-628)
```rust
    fn save_transactions(
        &self,
        chunk: ChunkToCommit,
        ledger_info_with_sigs: Option<&LedgerInfoWithSignatures>,
        sync_commit: bool,
    ) -> Result<()> {
        // For reconfig suffix.
        if ledger_info_with_sigs.is_none() && chunk.is_empty() {
            return Ok(());
        }

        if !chunk.is_empty() {
            self.pre_commit_ledger(chunk.clone(), sync_commit)?;
        }
        let version_to_commit = if let Some(ledger_info_with_sigs) = ledger_info_with_sigs {
            ledger_info_with_sigs.ledger_info().version()
        } else {
            chunk.expect_last_version()
        };
        self.commit_ledger(version_to_commit, ledger_info_with_sigs, Some(chunk))
    }
```
