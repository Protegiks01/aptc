# Audit Report

## Title
Container Reuse Attack in Local Testnet: Unverified Container Deletion Leading to Denial of Service

## Summary
The `delete_container()` function called in `pre_run()` methods of local testnet services does not verify container ownership before deletion. This allows containers with hardcoded names like `"local-testnet-postgres"` and `"local-testnet-indexer-api"` to be forcefully removed regardless of whether they belong to the current localnet instance, potentially causing denial of service to unrelated services using the same container names on shared Docker daemons.

## Finding Description

The vulnerability exists in the container cleanup logic used by local testnet services. When initializing services like the indexer API or Postgres database, the code calls `delete_container()` with hardcoded container names without verifying ownership. [1](#0-0) [2](#0-1) 

The `delete_container()` function implementation blindly removes any container matching the provided name with `force: true`, without checking labels, metadata, or any ownership information: [3](#0-2) 

The same pattern exists for Postgres containers: [4](#0-3) [5](#0-4) 

**Attack Path:**
1. User A runs a service using Docker container named `"local-testnet-postgres"` or `"local-testnet-indexer-api"` (for any purpose, unrelated to Aptos)
2. User B (or User A in a different terminal) executes `aptos node run-local-testnet`
3. During `pre_run()`, the code calls `delete_container()` with the hardcoded name
4. User A's container is forcefully removed (`force: true`) without verification
5. User A's service experiences unexpected downtime and potential data loss

The container configuration does not include any labels or identifying metadata to distinguish between different localnet instances or verify ownership: [6](#0-5) 

Compare this to the workspace server implementation which uses unique instance IDs to avoid collisions: [7](#0-6) 

## Impact Explanation

**Severity: Low** (downgraded from the question's suggested "Medium")

While this is a genuine container isolation bug, it does not meet the Aptos bug bounty's Medium severity criteria because:

1. **Not a blockchain protocol vulnerability**: This affects only local development tooling, not the production blockchain infrastructure, consensus mechanisms, or validator operations.

2. **No impact on critical invariants**: None of the 10 documented critical invariants (deterministic execution, consensus safety, Move VM safety, state consistency, etc.) are violated by this issue.

3. **Limited scope**: The vulnerability is confined to local development environments running on shared Docker daemons. It does not affect:
   - Validator node operations
   - Production blockchain APIs
   - Mainnet/testnet consensus
   - On-chain funds or state

4. **Out of bug bounty scope**: The valid impact categories focus on blockchain operations (funds loss, consensus violations, validator node issues). Development tool usability issues are not explicitly covered.

This should be classified as a **usability/design flaw** rather than a security vulnerability under the bug bounty program criteria.

## Likelihood Explanation

**Likelihood: Low**

The attack requires specific conditions:
- Multiple users or instances sharing the same Docker daemon
- Coincidental use of hardcoded container names (`"local-testnet-postgres"`, `"local-testnet-indexer-api"`)
- Timing overlap where one user starts a localnet while another has a running container with the same name

On single-user developer machines (the primary use case for local testnets), this scenario is unlikely to occur naturally. On shared development servers with rootless Docker or shared Docker daemons, the likelihood increases but remains limited by the specific naming collision requirement.

## Recommendation

Add ownership verification using Docker labels to distinguish between different localnet instances:

1. **Add unique instance identifier to container labels:**
```rust
use uuid::Uuid;

// Generate at localnet startup
let instance_id = Uuid::new_v4();

let config = Config {
    image: Some(HASURA_IMAGE.to_string()),
    labels: Some(hashmap! {
        "aptos.localnet.instance".to_string() => instance_id.to_string(),
        "aptos.localnet.service".to_string() => "indexer-api".to_string(),
    }),
    // ... rest of config
};
```

2. **Verify ownership before deletion:**
```rust
pub async fn delete_container_if_owned(
    container_name: &str,
    instance_id: &Uuid,
) -> Result<()> {
    let docker = get_docker().await?;
    
    // Inspect container first
    match docker.inspect_container(container_name, None).await {
        Ok(container_info) => {
            // Check if container belongs to this instance
            if let Some(labels) = container_info.config.and_then(|c| c.labels) {
                if let Some(owner_id) = labels.get("aptos.localnet.instance") {
                    if owner_id == &instance_id.to_string() {
                        // Safe to delete - it's ours
                        return delete_container(container_name).await;
                    }
                }
            }
            // Container exists but doesn't belong to us - skip deletion
            warn!("Container {} exists but doesn't belong to this instance", container_name);
            Ok(())
        },
        Err(_) => Ok(()), // Container doesn't exist, nothing to do
    }
}
```

3. **Alternative: Use unique container names like workspace server does:**
Follow the pattern in `aptos-workspace-server` which includes instance IDs in container names.

## Proof of Concept

**Prerequisites:** Docker installed and running

**Step 1:** Create a container with the conflicting name:
```bash
# Simulate an unrelated service using the same container name
docker run -d --name local-testnet-postgres \
  -e POSTGRES_PASSWORD=mysecret \
  postgres:14.11

# Verify it's running
docker ps | grep local-testnet-postgres
```

**Step 2:** Run Aptos local testnet:
```bash
# This will delete the container from Step 1 without verification
aptos node run-local-testnet --with-indexer-api
```

**Expected Result:** The container from Step 1 is forcefully removed during `pre_run()`, even though it doesn't belong to the Aptos localnet instance.

**Verification:**
```bash
# The original container is gone
docker ps -a | grep local-testnet-postgres
# Shows only the new Aptos-created container (if any)
```

---

**Notes:**
- This vulnerability is limited to local development environments and does not affect production blockchain operations
- The issue exists in development tooling (`crates/aptos/src/node/local_testnet/`), not in consensus, execution, storage, or other core blockchain components
- While technically exploitable, the impact is confined to DoS of local development services with no blockchain protocol implications
- The bug bounty program's focus on blockchain security (funds, consensus, validator operations) suggests this falls below the minimum severity threshold for a valid report

### Citations

**File:** crates/aptos/src/node/local_testnet/indexer_api.rs (L29-29)
```rust
const INDEXER_API_CONTAINER_NAME: &str = "local-testnet-indexer-api";
```

**File:** crates/aptos/src/node/local_testnet/indexer_api.rs (L117-118)
```rust
        // Delete any existing indexer API container we find.
        delete_container(INDEXER_API_CONTAINER_NAME).await?;
```

**File:** crates/aptos/src/node/local_testnet/indexer_api.rs (L222-242)
```rust
        let config = Config {
            image: Some(HASURA_IMAGE.to_string()),
            tty: Some(true),
            exposed_ports,
            host_config: Some(host_config),
            env: Some(vec![
                format!("PG_DATABASE_URL={}", postgres_connection_string),
                format!(
                    "HASURA_GRAPHQL_METADATA_DATABASE_URL={}",
                    postgres_connection_string
                ),
                format!("INDEXER_V2_POSTGRES_URL={}", postgres_connection_string),
                "HASURA_GRAPHQL_DEV_MODE=true".to_string(),
                "HASURA_GRAPHQL_ENABLE_CONSOLE=true".to_string(),
                // See the docs for the image, this is a magic path inside the
                // container where they have already bundled in the UI assets.
                "HASURA_GRAPHQL_CONSOLE_ASSETS_DIR=/srv/console-assets".to_string(),
                format!("HASURA_GRAPHQL_SERVER_PORT={}", self.indexer_api_port),
            ]),
            ..Default::default()
        };
```

**File:** crates/aptos/src/node/local_testnet/docker.rs (L22-46)
```rust
pub async fn delete_container(container_name: &str) -> Result<()> {
    info!(
        "Removing container with name {} (if it exists)",
        container_name
    );

    let docker = get_docker().await?;

    let options = Some(RemoveContainerOptions {
        force: true,
        ..Default::default()
    });

    // Ignore any error, it'll be because the container doesn't exist.
    let result = docker.remove_container(container_name, options).await;

    match result {
        Ok(_) => info!("Successfully removed container {}", container_name),
        Err(err) => warn!(
            "Failed to remove container {}: {:#} (it probably didn't exist)",
            container_name, err
        ),
    }

    Ok(())
```

**File:** crates/aptos/src/node/local_testnet/postgres.rs (L26-26)
```rust
pub const POSTGRES_CONTAINER_NAME: &str = "local-testnet-postgres";
```

**File:** crates/aptos/src/node/local_testnet/postgres.rs (L193-194)
```rust
            // Kill any existing container we find.
            delete_container(POSTGRES_CONTAINER_NAME).await?;
```

**File:** aptos-move/aptos-workspace-server/src/services/indexer_api.rs (L102-105)
```rust
    let options = CreateContainerOptions {
        name: format!("aptos-workspace-{}-indexer-api", instance_id),
        ..Default::default()
    };
```
