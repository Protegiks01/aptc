# Audit Report

## Title
Validator Fingerprinting via Exposed Configuration Endpoint Enables Targeted Attacks

## Summary
The Aptos inspection service's `/configuration` endpoint exposes complete node configuration including hardware specifications, storage paths, and performance settings without authentication or IP restrictions. While mainnet validators are protected by a config sanitizer, non-mainnet validators auto-enable this endpoint, and the sanitizer can be bypassed via the `skip_config_sanitizer` flag. This enables attackers to uniquely fingerprint validators and launch targeted attacks.

## Finding Description

The `handle_configuration_request()` function exposes the entire `NodeConfig` struct via Debug formatting when `expose_configuration` is enabled: [1](#0-0) 

This configuration includes uniquely identifying information across multiple sub-configs:

**Hardware Specifications:**
- Execution concurrency level (auto-calculated from CPU cores)
- Proof reading thread counts
- RocksDB cache sizes and background thread counts [2](#0-1) [3](#0-2) 

**Storage Paths:**
- Base data directory and working directory
- Database path overrides for individual shards [4](#0-3) 

**Performance Settings:**
- Consensus timeouts and backpressure configurations
- Block size limits and transaction filtering thresholds
- Network channel buffer sizes [5](#0-4) 

The inspection service binds to all interfaces by default and has no authentication: [6](#0-5) [7](#0-6) 

**Critical Security Gap:** While a sanitizer prevents mainnet validators from exposing configuration, it auto-enables for non-mainnet nodes and can be bypassed: [8](#0-7) [9](#0-8) 

The sanitizer can be completely bypassed via the `skip_config_sanitizer` flag: [10](#0-9) 

**Attack Scenario:**
1. Attacker scans for validators with exposed inspection services (default port 9101)
2. Queries `/configuration` endpoint to extract hardware and performance fingerprints
3. Identifies high-value validators through unique configuration signatures (custom paths, high-end hardware specs, non-default settings)
4. Launches targeted attacks: DoS at capacity limits, exploiting specific hardware/software configurations, or social engineering validator operators

## Impact Explanation

**High Severity** - This vulnerability enables significant protocol violations and targeted attacks on validators:

1. **Validator Identification**: Attackers can uniquely fingerprint validators through configuration signatures, violating validator anonymity assumptions
2. **Targeted DoS Attacks**: Knowledge of exact hardware specs (thread counts, cache sizes) and performance limits allows precision-targeted resource exhaustion
3. **Infrastructure Mapping**: Storage paths reveal deployment patterns, enabling targeted attacks on specific validator infrastructure
4. **Social Engineering**: Configuration details provide intelligence for targeted phishing/compromise attempts against high-stake validator operators

This falls under "Validator node slowdowns" and "Significant protocol violations" per the Aptos bug bounty High severity criteria. While not directly causing consensus failure, it enables attacks that could degrade validator performance or enable more sophisticated multi-stage attacks.

## Likelihood Explanation

**High Likelihood:**

1. **Auto-enabled for non-mainnet**: All testnet/devnet validators automatically expose this endpoint unless explicitly disabled
2. **Default binding to 0.0.0.0**: The service listens on all interfaces by default
3. **No authentication required**: Any network peer can access the endpoint
4. **Bypass mechanism exists**: Mainnet validators can accidentally expose configuration by setting `skip_config_sanitizer: true` for debugging
5. **Real-world exposure**: Validators often expose management ports during debugging or misconfiguration

The attack requires no privileged access and can be executed by any network observer with HTTP access to the inspection service port.

## Recommendation

Implement defense-in-depth protections:

1. **Add IP Whitelisting**: Restrict inspection service access to trusted IP ranges
2. **Add Authentication**: Require API tokens or mutual TLS for sensitive endpoints
3. **Disable by Default**: Change auto-enablement behavior for non-mainnet validators
4. **Remove Sanitizer Bypass**: Eliminate or strictly control `skip_config_sanitizer` flag
5. **Redact Sensitive Fields**: Even when enabled, redact uniquely identifying information

**Recommended Code Fix:**

```rust
// In inspection_service_config.rs
pub struct InspectionServiceConfig {
    pub address: String,
    pub port: u16,
    pub expose_configuration: bool,
    pub expose_identity_information: bool,
    pub expose_peer_information: bool,
    pub expose_system_information: bool,
    // NEW: Add IP whitelist
    pub allowed_ips: Vec<IpAddr>,
    // NEW: Add authentication
    pub require_auth_token: bool,
    pub auth_tokens: Vec<String>,
}

// In configuration.rs
pub fn handle_configuration_request(
    node_config: &NodeConfig,
    client_ip: IpAddr,
    auth_token: Option<String>,
) -> (StatusCode, Body, String) {
    // Check IP whitelist
    if !node_config.inspection_service.allowed_ips.is_empty()
        && !node_config.inspection_service.allowed_ips.contains(&client_ip) {
        return (
            StatusCode::FORBIDDEN,
            Body::from("IP not whitelisted"),
            CONTENT_TYPE_TEXT.into(),
        );
    }
    
    // Check authentication
    if node_config.inspection_service.require_auth_token {
        if let Some(token) = auth_token {
            if !node_config.inspection_service.auth_tokens.contains(&token) {
                return (
                    StatusCode::UNAUTHORIZED,
                    Body::from("Invalid auth token"),
                    CONTENT_TYPE_TEXT.into(),
                );
            }
        } else {
            return (
                StatusCode::UNAUTHORIZED,
                Body::from("Auth token required"),
                CONTENT_TYPE_TEXT.into(),
            );
        }
    }
    
    // Existing logic...
}
```

## Proof of Concept

```rust
// PoC demonstrating information extraction
use aptos_config::config::NodeConfig;
use hyper::{Client, Uri};

#[tokio::test]
async fn test_validator_fingerprinting() {
    // Simulate scanning a validator's inspection service
    let target_validators = vec![
        "http://validator1.example.com:9101",
        "http://validator2.example.com:9101",
    ];
    
    let client = Client::new();
    
    for validator_url in target_validators {
        let uri: Uri = format!("{}/configuration", validator_url).parse().unwrap();
        
        // No authentication required - direct access
        if let Ok(response) = client.get(uri).await {
            if response.status().is_success() {
                let body = hyper::body::to_bytes(response.into_body()).await.unwrap();
                let config_text = String::from_utf8(body.to_vec()).unwrap();
                
                // Extract fingerprinting information
                let fingerprint = extract_fingerprint(&config_text);
                
                println!("Validator: {}", validator_url);
                println!("Hardware: {} cores, {}GB cache", 
                    fingerprint.cpu_cores, 
                    fingerprint.cache_size_gb);
                println!("Storage: {}", fingerprint.data_dir);
                println!("Performance: {} max block txns", fingerprint.max_block_txns);
                
                // Use fingerprint to identify high-value validators
                if fingerprint.cache_size_gb > 32 && fingerprint.cpu_cores > 16 {
                    println!("HIGH-VALUE TARGET IDENTIFIED");
                }
            }
        }
    }
}

struct ValidatorFingerprint {
    cpu_cores: u16,
    cache_size_gb: usize,
    data_dir: String,
    max_block_txns: u64,
}

fn extract_fingerprint(config: &str) -> ValidatorFingerprint {
    // Parse configuration to extract uniquely identifying features
    // Real implementation would use regex or proper parsing
    ValidatorFingerprint {
        cpu_cores: extract_concurrency_level(config),
        cache_size_gb: extract_cache_size(config),
        data_dir: extract_data_dir(config),
        max_block_txns: extract_max_block_txns(config),
    }
}
```

## Notes

This vulnerability is particularly concerning because:

1. The sanitizer protection only applies to mainnet validators - testnet validators with real stake are vulnerable
2. The default configuration (0.0.0.0 binding, auto-enable on non-mainnet) maximizes exposure
3. No runtime warnings are issued when the endpoint is publicly accessible
4. The `skip_config_sanitizer` bypass mechanism weakens the mainnet protection
5. Infrastructure-as-code deployments may inadvertently expose this port to the internet

While the immediate impact is information disclosure, this enables more sophisticated targeted attacks against validator infrastructure, making it a High severity issue per the bug bounty criteria.

### Citations

**File:** crates/aptos-inspection-service/src/server/configuration.rs (L13-29)
```rust
pub fn handle_configuration_request(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    // Only return configuration if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_configuration {
        // We format the configuration using debug formatting. This is important to
        // prevent secret/private keys from being serialized and leaked (i.e.,
        // all secret keys are marked with SilentDisplay and SilentDebug).
        let encoded_configuration = format!("{:?}", node_config);
        (StatusCode::OK, Body::from(encoded_configuration))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(CONFIGURATION_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}
```

**File:** config/src/config/execution_config.rs (L30-60)
```rust
#[derive(Clone, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct ExecutionConfig {
    #[serde(skip)]
    /// For testing purposes, the ability to add a genesis transaction directly
    pub genesis: Option<Transaction>,
    /// Location of the genesis file
    pub genesis_file_location: PathBuf,
    /// Number of threads to run execution.
    /// If 0, we use min of (num of cores/2, DEFAULT_CONCURRENCY_LEVEL) as default concurrency level
    pub concurrency_level: u16,
    /// Number of threads to read proofs
    pub num_proof_reading_threads: u16,
    /// Enables paranoid mode for types, which adds extra runtime VM checks
    pub paranoid_type_verification: bool,
    /// Enabled discarding blocks that fail execution due to BlockSTM/VM issue.
    pub discard_failed_blocks: bool,
    /// Enables paranoid mode for hot potatoes, which adds extra runtime VM checks
    pub paranoid_hot_potato_verification: bool,
    /// Enables enhanced metrics around processed transactions
    pub processed_transactions_detailed_counters: bool,
    /// Used during DB bootstrapping
    pub genesis_waypoint: Option<WaypointConfig>,
    /// Whether to use BlockSTMv2 for parallel execution.
    pub blockstm_v2_enabled: bool,
    /// Enables long-living concurrent caches for Move type layouts.
    pub layout_caches_enabled: bool,
    /// If enabled, runtime checks like paranoid type checks may be performed in parallel in post
    /// commit hook in Block-STM.
    pub async_runtime_checks: bool,
}
```

**File:** config/src/config/storage_config.rs (L194-208)
```rust
#[derive(Clone, Copy, Debug, Deserialize, PartialEq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct RocksdbConfigs {
    // TODO(grao): Add RocksdbConfig for individual ledger DBs when necessary.
    pub ledger_db_config: RocksdbConfig,
    pub state_merkle_db_config: RocksdbConfig,
    pub state_kv_db_config: RocksdbConfig,
    pub index_db_config: RocksdbConfig,
    #[serde(default = "default_to_true")]
    pub enable_storage_sharding: bool,
    pub high_priority_background_threads: i32,
    pub low_priority_background_threads: i32,
    /// The size of the single block cache shared by all the DB instances in `AptosDB`.
    pub shared_block_cache_size: usize,
}
```

**File:** config/src/config/base_config.rs (L15-23)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct BaseConfig {
    pub data_dir: PathBuf,
    pub working_dir: Option<PathBuf>,
    pub role: RoleType,
    pub waypoint: WaypointConfig,
}

```

**File:** config/src/config/consensus_config.rs (L30-104)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct ConsensusConfig {
    // length of inbound queue of messages
    pub max_network_channel_size: usize,
    pub max_sending_block_txns: u64,
    pub max_sending_block_txns_after_filtering: u64,
    pub max_sending_opt_block_txns_after_filtering: u64,
    pub max_sending_block_bytes: u64,
    pub max_sending_inline_txns: u64,
    pub max_sending_inline_bytes: u64,
    pub max_receiving_block_txns: u64,
    pub max_receiving_block_bytes: u64,
    pub max_pruned_blocks_in_mem: usize,
    // Timeout for consensus to get an ack from mempool for executed transactions (in milliseconds)
    pub mempool_executed_txn_timeout_ms: u64,
    // Timeout for consensus to pull transactions from mempool and get a response (in milliseconds)
    pub mempool_txn_pull_timeout_ms: u64,
    pub round_initial_timeout_ms: u64,
    pub round_timeout_backoff_exponent_base: f64,
    pub round_timeout_backoff_max_exponent: usize,
    pub safety_rules: SafetyRulesConfig,
    // Only sync committed transactions but not vote for any pending blocks. This is useful when
    // validators coordinate on the latest version to apply a manual transaction.
    pub sync_only: bool,
    // The size of the round/recovery manager and proposal buffer channels.
    pub internal_per_key_channel_size: usize,
    pub quorum_store_pull_timeout_ms: u64,
    // Decides how long the leader waits before proposing empty block if there's no txns in mempool
    pub quorum_store_poll_time_ms: u64,
    // Whether to create partial blocks when few transactions exist, or empty blocks when there is
    // pending ordering, or to wait for quorum_store_poll_count * 30ms to collect transactions for a block
    //
    // It is more efficient to execute larger blocks, as it creates less overhead. On the other hand
    // waiting increases latency (unless we are under high load that added waiting latency
    // is compensated by faster execution time). So we want to balance the two, by waiting only
    // when we are saturating the execution pipeline:
    // - if there are more pending blocks then usual in the execution pipeline,
    //   block is going to wait there anyways, so we can wait to create a bigger/more efificent block
    // - in case our node is faster than others, and we don't have many pending blocks,
    //   but we still see very large recent (pending) blocks, we know that there is demand
    //   and others are creating large blocks, so we can wait as well.
    pub wait_for_full_blocks_above_pending_blocks: usize,
    pub wait_for_full_blocks_above_recent_fill_threshold: f32,
    pub intra_consensus_channel_buffer_size: usize,
    pub quorum_store: QuorumStoreConfig,
    pub vote_back_pressure_limit: u64,
    /// If backpressure target block size is below it, update `max_txns_to_execute` instead.
    /// Applied to execution, pipeline and chain health backpressure.
    /// Needed as we cannot subsplit QS batches.
    pub min_max_txns_in_block_after_filtering_from_backpressure: u64,
    pub execution_backpressure: Option<ExecutionBackpressureConfig>,
    pub pipeline_backpressure: Vec<PipelineBackpressureValues>,
    // Used to decide if backoff is needed.
    // must match one of the CHAIN_HEALTH_WINDOW_SIZES values.
    pub window_for_chain_health: usize,
    pub chain_health_backoff: Vec<ChainHealthBackoffValues>,
    // Deprecated
    pub qc_aggregator_type: QcAggregatorType,
    // Max blocks allowed for block retrieval requests
    pub max_blocks_per_sending_request: u64,
    pub max_blocks_per_sending_request_quorum_store_override: u64,
    pub max_blocks_per_receiving_request: u64,
    pub max_blocks_per_receiving_request_quorum_store_override: u64,
    pub broadcast_vote: bool,
    pub proof_cache_capacity: u64,
    pub rand_rb_config: ReliableBroadcastConfig,
    pub num_bounded_executor_tasks: u64,
    pub enable_pre_commit: bool,
    pub max_pending_rounds_in_commit_vote_cache: u64,
    pub optimistic_sig_verification: bool,
    pub enable_round_timeout_msg: bool,
    pub enable_optimistic_proposal_rx: bool,
    pub enable_optimistic_proposal_tx: bool,
}
```

**File:** config/src/config/inspection_service_config.rs (L26-37)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
}
```

**File:** config/src/config/inspection_service_config.rs (L45-69)
```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
        }

        Ok(())
    }
}
```

**File:** config/src/config/inspection_service_config.rs (L71-108)
```rust
impl ConfigOptimizer for InspectionServiceConfig {
    fn optimize(
        node_config: &mut NodeConfig,
        local_config_yaml: &Value,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<bool, Error> {
        let inspection_service_config = &mut node_config.inspection_service;
        let local_inspection_config_yaml = &local_config_yaml["inspection_service"];

        // Enable all endpoints for non-mainnet nodes (to aid debugging)
        let mut modified_config = false;
        if let Some(chain_id) = chain_id {
            if !chain_id.is_mainnet() {
                if local_inspection_config_yaml["expose_configuration"].is_null() {
                    inspection_service_config.expose_configuration = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_identity_information"].is_null() {
                    inspection_service_config.expose_identity_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_peer_information"].is_null() {
                    inspection_service_config.expose_peer_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_system_information"].is_null() {
                    inspection_service_config.expose_system_information = true;
                    modified_config = true;
                }
            }
        }

        Ok(modified_config)
    }
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L103-116)
```rust
/// A simple helper function that handles each endpoint request
async fn serve_requests(
    req: Request<Body>,
    node_config: NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> Result<Response<Body>, hyper::Error> {
    // Process the request and get the response components
    let (status_code, body, content_type) = match req.uri().path() {
        CONFIGURATION_PATH => {
            // /configuration
            // Exposes the node configuration
            configuration::handle_configuration_request(&node_config)
        },
```

**File:** config/src/config/config_sanitizer.rs (L39-48)
```rust
impl ConfigSanitizer for NodeConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        // If config sanitization is disabled, don't do anything!
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }
```
