# Audit Report

## Title
TOCTOU Race Condition in Consensus Observer Payload Verification Causes Legitimate Blocks to Be Dropped

## Summary
A Time-of-Check Time-of-Use (TOCTOU) race condition exists between the `all_payloads_exist()` check and the `verify_payloads_against_ordered_block()` call in the consensus observer's ordered block processing flow. While the verification function correctly rejects incomplete payloads, concurrent commit callbacks can remove payloads between the check and verification steps, causing legitimate ordered blocks to be incorrectly dropped and potentially degrading node liveness.

## Finding Description

The `process_ordered_block()` function assumes that once `all_payloads_exist()` returns true, the payloads will remain available for the subsequent `verify_payloads_against_ordered_block()` call. However, these are two separate lock acquisitions on `observer_block_data`: [1](#0-0) 

The check at line 706 acquires the lock, verifies all payloads are `AvailableAndVerified`, then releases the lock: [2](#0-1) 

Later in `process_ordered_block()`, verification is attempted with a separate lock acquisition: [3](#0-2) 

Between these two operations, the execution pipeline can invoke commit callbacks that remove payloads: [4](#0-3) [5](#0-4) 

The `verify_payloads_against_ordered_block()` implementation correctly rejects missing or unverified payloads: [6](#0-5) 

However, when payloads are removed during the race window, the verification fails and the ordered block is dropped, even though it was valid when initially checked.

**Attack Scenario:**
1. Consensus observer receives ordered block B for (epoch 10, round 101)
2. Payloads exist in verified state; `all_payloads_exist()` returns true
3. Concurrently, block at round 100 commits; callback removes payloads up to round 100
4. If round 101's payloads are removed or become inaccessible due to storage operations
5. `verify_payloads_against_ordered_block()` fails with "Missing block payload"
6. Legitimate block B is dropped with invalid message counter incremented

## Impact Explanation

**To directly answer the security question:** No, `verify_payloads_against_ordered_block()` **cannot** pass with incomplete payloads. The function correctly validates payload completeness and rejects any block with missing or unverified payloads.

However, the TOCTOU race condition represents a **High Severity** liveness issue:

- **Validator node slowdowns**: Nodes may repeatedly drop legitimate blocks, requiring retransmission and state sync operations
- **Significant protocol violations**: The assumption documented at line 716-717 ("This assumes...all payloads exist") can be violated by the race condition
- Observer nodes may experience degraded performance and increased state sync overhead
- Under high load, this could affect network-wide consensus observer reliability

This does not qualify as Critical severity because:
- No consensus safety violation (no double-spend or chain splits)
- No funds loss or theft
- No permanent network partition [7](#0-6) 

## Likelihood Explanation

**Medium-to-High likelihood** in production environments:

1. The race window exists on every ordered block processing
2. Commit callbacks fire asynchronously from the execution pipeline
3. In high-throughput scenarios with rapid block execution, the timing overlap becomes probable
4. The issue is more likely with pending blocks that wait for payloads (line 436 processing path)
5. Not directly exploitable by external attackers but occurs naturally under load

The comment at line 202 acknowledging "this should never happen" suggests the developers did not anticipate this race condition: [8](#0-7) 

## Recommendation

Implement atomic check-and-verify by holding the lock across both operations:

```rust
async fn process_ordered_block(
    &mut self,
    pending_block_with_metadata: Arc<PendingBlockWithMetadata>,
) {
    let (peer_network_id, message_received_time, observed_ordered_block) =
        pending_block_with_metadata.unpack();
    let ordered_block = observed_ordered_block.ordered_block().clone();

    let epoch_state = self.get_epoch_state();
    if ordered_block.proof_block_info().epoch() == epoch_state.epoch {
        if let Err(error) = ordered_block.verify_ordered_proof(&epoch_state) {
            error!(/* ... */);
            return;
        }
    } else {
        error!(/* ... */);
        return;
    }

    // FIXED: Hold lock during both payload existence check and verification
    let verification_result = {
        let mut block_data = self.observer_block_data.lock();
        
        // Check existence first
        if !block_data.all_payloads_exist(ordered_block.blocks()) {
            return; // Payloads don't exist yet
        }
        
        // Verify atomically while holding the same lock
        block_data.verify_payloads_against_ordered_block(&ordered_block)
    };

    if let Err(error) = verification_result {
        error!(/* ... */);
        increment_invalid_message_counter(&peer_network_id, metrics::ORDERED_BLOCK_LABEL);
        return;
    }

    // Continue with processing...
}
```

Additionally, make `all_payloads_exist()` a private method only called within the same lock scope as verification to prevent future TOCTOU issues.

## Proof of Concept

The race condition can be demonstrated with a Rust integration test simulating concurrent operations:

```rust
#[tokio::test]
async fn test_toctou_payload_verification_race() {
    // Setup: Create observer with block data
    let observer_block_data = Arc::new(Mutex::new(ObserverBlockData::new(/* ... */)));
    
    // Insert verified payloads for epoch 10, round 100
    let blocks = create_test_blocks(10, 100, 1);
    {
        let mut data = observer_block_data.lock();
        for block in &blocks {
            data.insert_block_payload(create_payload_for_block(block), true);
        }
    }
    
    // Thread 1: Check payloads exist
    let check_result = {
        let data = observer_block_data.lock();
        data.all_payloads_exist(&blocks)
    };
    assert!(check_result); // Check passes
    
    // Thread 2: Simulate commit callback removing payloads
    let observer_block_data_clone = observer_block_data.clone();
    tokio::spawn(async move {
        let commit_info = create_ledger_info(10, 100);
        observer_block_data_clone.lock().handle_committed_blocks(commit_info);
    }).await.unwrap();
    
    // Thread 1: Attempt verification
    let verify_result = {
        let mut data = observer_block_data.lock();
        data.verify_payloads_against_ordered_block(&create_ordered_block(&blocks))
    };
    
    // Verification fails even though check passed - TOCTOU race demonstrated
    assert!(verify_result.is_err());
    assert!(verify_result.unwrap_err().to_string().contains("Missing block payload"));
}
```

This demonstrates that legitimate blocks can be incorrectly rejected due to the race condition, violating the documented assumption and potentially causing node performance degradation.

## Notes

**Direct answer to the security question:** `verify_payloads_against_ordered_block()` correctly handles partial payload availability by explicitly rejecting incomplete payloads. It cannot pass with incomplete payloads.

The TOCTOU race condition is a separate robustness issue where the preliminary check can pass, but verification later fails due to concurrent payload removal. This is a liveness/performance issue rather than a consensus safety violation.

### Citations

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L157-165)
```rust
    fn all_payloads_exist(&self, blocks: &[Arc<PipelinedBlock>]) -> bool {
        // If quorum store is disabled, all payloads exist (they're already in the blocks)
        if !self.observer_epoch_state.is_quorum_store_enabled() {
            return true;
        }

        // Otherwise, check if all the payloads exist in the payload store
        self.observer_block_data.lock().all_payloads_exist(blocks)
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L704-713)
```rust
        // If all payloads exist, process the block. Otherwise, store it
        // in the pending block store and wait for the payloads to arrive.
        if self.all_payloads_exist(pending_block_with_metadata.ordered_block().blocks()) {
            self.process_ordered_block(pending_block_with_metadata)
                .await;
        } else {
            self.observer_block_data
                .lock()
                .insert_pending_block(pending_block_with_metadata);
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L716-717)
```rust
    /// Processes the ordered block. This assumes the ordered block
    /// has been sanity checked and that all payloads exist.
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L754-771)
```rust
        // Verify the block payloads against the ordered block
        if let Err(error) = self
            .observer_block_data
            .lock()
            .verify_payloads_against_ordered_block(&ordered_block)
        {
            // Log the error and update the invalid message counter
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to verify block payloads against ordered block! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                    ordered_block.proof_block_info(),
                    peer_network_id,
                    error
                ))
            );
            increment_invalid_message_counter(&peer_network_id, metrics::ORDERED_BLOCK_LABEL);
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L182-189)
```rust
    fn handle_committed_blocks(&mut self, ledger_info: LedgerInfoWithSignatures) {
        // Remove the committed blocks from the payload and ordered block stores
        self.block_payload_store.remove_blocks_for_epoch_round(
            ledger_info.commit_info().epoch(),
            ledger_info.commit_info().round(),
        );
        self.ordered_block_store
            .remove_blocks_for_commit(&ledger_info);
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L325-333)
```rust
pub fn create_commit_callback(
    observer_block_data: Arc<Mutex<ObserverBlockData>>,
) -> Box<dyn FnOnce(WrappedLedgerInfo, LedgerInfoWithSignatures) + Send + Sync> {
    Box::new(move |_, ledger_info: LedgerInfoWithSignatures| {
        observer_block_data
            .lock()
            .handle_committed_blocks(ledger_info);
    })
}
```

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L201-208)
```rust
                Entry::Vacant(_) => {
                    // The payload is missing (this should never happen)
                    return Err(Error::InvalidMessageError(format!(
                        "Payload verification failed! Missing block payload for epoch: {:?} and round: {:?}",
                        ordered_block.epoch(),
                        ordered_block.round()
                    )));
                },
```
