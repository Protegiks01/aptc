# Audit Report

## Title
Unvalidated User-Provided Currency Metadata Causes Panic in Account Balance Endpoint

## Summary
The account module in the Aptos Rosetta API fails to validate user-provided currency metadata before parsing fungible asset addresses. This allows unauthenticated attackers to trigger panics in the `/account/balance` endpoint by submitting malformed `fa_address` values, causing denial of service for affected requests and bypassing module isolation guarantees.

## Finding Description

The vulnerability exists in the `get_base_balances` function within the account module. When processing user-provided currencies from an `AccountBalanceRequest`, the code directly calls `AccountAddress::from_str().unwrap()` on the `fa_address` field without prior validation. [1](#0-0) 

The attack flow proceeds as follows:

1. An attacker crafts an `AccountBalanceRequest` with a malicious currency containing an invalid `fa_address` in the metadata
2. The request is deserialized successfully since `fa_address` is just a `String` type
3. The request reaches `account_balance()` which calls `get_balances()`
4. For base accounts, `get_base_balances()` is invoked with the user-provided currencies
5. The code iterates through currencies and matches on FA-only currency types
6. At line 335, `AccountAddress::from_str(fa_address).unwrap()` is called on the malformed address
7. The `from_str` call returns an error, and `unwrap()` triggers a panic

The Currency struct definition shows that `fa_address` is an unvalidated string: [2](#0-1) 

The request structure confirms that currencies are optional and user-controllable: [3](#0-2) 

This vulnerability bypasses module isolation because the account module accepts untrusted input without validation and propagates panics up through the routes integration in lib.rs: [4](#0-3) 

While warp's error recovery can catch rejections, Rust panics in async tasks are caught by tokio but still result in failed requests and error logs, degrading service availability.

## Impact Explanation

This vulnerability qualifies as **Medium severity** under the Aptos bug bounty program for the following reasons:

1. **API Availability Impact**: Although individual request panics don't crash the entire server (tokio isolates task failures), repeated exploitation can degrade the Rosetta API's availability and reliability

2. **No Authentication Required**: Any unauthenticated attacker can trigger this vulnerability by sending crafted HTTP requests

3. **Isolation Bypass**: The vulnerability demonstrates how insufficient input validation in the account module allows errors to propagate beyond intended module boundaries, violating isolation principles

4. **Service Disruption**: While not as severe as consensus violations or fund loss, this represents a concrete attack vector against infrastructure that blockchain explorers and integrators depend on

The impact is limited to the Rosetta API service and does not affect the underlying Aptos blockchain consensus or validator operations.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to be exploited because:

1. **Trivial Exploitation**: An attacker only needs to send a single malformed HTTP POST request - no specialized knowledge or tools required
2. **Public Endpoint**: The `/account/balance` endpoint is publicly accessible with no authentication
3. **Clear Attack Pattern**: The attack vector is straightforward and easily automatable
4. **No Rate Limiting Mentioned**: There's no evidence of input validation or rate limiting that would prevent exploitation

The vulnerability will occur deterministically whenever a user provides a currency with an invalid `fa_address` format in their request.

## Recommendation

Implement proper validation for user-provided currency metadata before attempting to parse addresses. Replace the `unwrap()` calls with proper error handling:

```rust
Currency {
    metadata:
        Some(CurrencyMetadata {
            move_type: None,
            fa_address: Some(ref fa_address),
        }),
    ..
} => {
    // Validate the fa_address before parsing
    let fa_addr = match AccountAddress::from_str(fa_address) {
        Ok(addr) => addr,
        Err(_) => {
            // Skip invalid currencies or return an error
            continue; // or return Err(ApiError::InvalidInput(...))
        }
    };
    
    let response = view::<Vec<u64>>(
        rest_client,
        version,
        AccountAddress::ONE,
        ident_str!(PRIMARY_FUNGIBLE_STORE_MODULE),
        ident_str!(BALANCE_FUNCTION),
        vec![TypeTag::Struct(Box::new(StructTag {
            address: AccountAddress::ONE,
            module: ident_str!(OBJECT_MODULE).into(),
            name: ident_str!(OBJECT_CORE_RESOURCE).into(),
            type_args: vec![],
        }))],
        vec![
            bcs::to_bytes(&owner_address)?,
            bcs::to_bytes(&fa_addr)?,
        ],
    )
    .await?;
    // ... rest of logic
}
```

Additionally, add validation at the request deserialization layer or implement a validation function for Currency objects before they are used in business logic.

## Proof of Concept

```bash
# Send a malicious request with invalid fa_address to the Rosetta API
curl -X POST http://localhost:8080/account/balance \
  -H "Content-Type: application/json" \
  -d '{
    "network_identifier": {
      "blockchain": "aptos",
      "network": "testnet"
    },
    "account_identifier": {
      "address": "0x1"
    },
    "currencies": [{
      "symbol": "MALICIOUS",
      "decimals": 8,
      "metadata": {
        "fa_address": "NOT_A_VALID_ADDRESS_FORMAT"
      }
    }]
  }'

# Expected: Panic at account.rs:335 with error:
# thread 'tokio-runtime-worker' panicked at 'called `Result::unwrap()` on an `Err` value'

# The request will fail and the panic will be logged, demonstrating the vulnerability
```

## Notes

This vulnerability specifically affects the Aptos Rosetta API service and does not impact the core blockchain consensus, validator operations, or on-chain security. However, it represents a concrete isolation bypass where insufficient input validation in the account module allows panics to propagate through the routes integration, violating defensive programming principles and degrading service reliability.

### Citations

**File:** crates/aptos-rosetta/src/account.rs (L313-343)
```rust
            Currency {
                metadata:
                    Some(CurrencyMetadata {
                        move_type: None,
                        fa_address: Some(ref fa_address),
                    }),
                ..
            } => {
                let response = view::<Vec<u64>>(
                    rest_client,
                    version,
                    AccountAddress::ONE,
                    ident_str!(PRIMARY_FUNGIBLE_STORE_MODULE),
                    ident_str!(BALANCE_FUNCTION),
                    vec![TypeTag::Struct(Box::new(StructTag {
                        address: AccountAddress::ONE,
                        module: ident_str!(OBJECT_MODULE).into(),
                        name: ident_str!(OBJECT_CORE_RESOURCE).into(),
                        type_args: vec![],
                    }))],
                    vec![
                        bcs::to_bytes(&owner_address).unwrap(),
                        bcs::to_bytes(&AccountAddress::from_str(fa_address).unwrap()).unwrap(),
                    ],
                )
                .await?;
                let fa_balance = response.first().copied().unwrap_or(0);
                balances.push(Amount {
                    value: fa_balance.to_string(),
                    currency: currency.clone(),
                })
```

**File:** crates/aptos-rosetta/src/types/objects.rs (L177-185)
```rust
#[derive(Clone, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub struct CurrencyMetadata {
    /// Move coin type e.g. 0x1::aptos_coin::AptosCoin
    #[serde(skip_serializing_if = "Option::is_none")]
    pub move_type: Option<String>,
    /// Fungible Asset Address e.g. 0xA
    #[serde(skip_serializing_if = "Option::is_none")]
    pub fa_address: Option<String>,
}
```

**File:** crates/aptos-rosetta/src/types/requests.rs (L26-38)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct AccountBalanceRequest {
    /// Network identifier describing the blockchain and the chain id
    pub network_identifier: NetworkIdentifier,
    /// Account identifier describing the account address
    pub account_identifier: AccountIdentifier,
    /// For historical balance lookups by either hash or version
    #[serde(skip_serializing_if = "Option::is_none")]
    pub block_identifier: Option<PartialBlockIdentifier>,
    /// For filtering which currencies to show
    #[serde(skip_serializing_if = "Option::is_none")]
    pub currencies: Option<Vec<Currency>>,
}
```

**File:** crates/aptos-rosetta/src/lib.rs (L164-189)
```rust
pub fn routes(
    context: RosettaContext,
) -> impl Filter<Extract = (impl Reply,), Error = Infallible> + Clone {
    account::routes(context.clone())
        .or(block::block_route(context.clone()))
        .or(construction::combine_route(context.clone()))
        .or(construction::derive_route(context.clone()))
        .or(construction::hash_route(context.clone()))
        .or(construction::metadata_route(context.clone()))
        .or(construction::parse_route(context.clone()))
        .or(construction::payloads_route(context.clone()))
        .or(construction::preprocess_route(context.clone()))
        .or(construction::submit_route(context.clone()))
        .or(network::list_route(context.clone()))
        .or(network::options_route(context.clone()))
        .or(network::status_route(context.clone()))
        .or(health_check_route(context))
        .with(
            warp::cors()
                .allow_any_origin()
                .allow_methods(vec![Method::GET, Method::POST])
                .allow_headers(vec![warp::http::header::CONTENT_TYPE]),
        )
        .with(logger())
        .recover(handle_rejection)
}
```
