# Audit Report

## Title
Inconsistent BlockTransactionFilterConfig Across Validators Due to Local Configuration Management

## Summary
The `BlockTransactionFilterConfig` is a local, off-chain configuration that is read once at node startup and never synchronized across validators. This can lead to inconsistent transaction filtering behavior across the validator set if different validators have different configuration files or restart at different times after configuration updates.

## Finding Description

The `BlockTransactionFilterConfig` used for consensus transaction filtering violates the principle of deterministic validation rules across all validators. The configuration flow is:

1. **Initialization**: Config is read from local YAML file at node startup [1](#0-0) 

2. **Storage**: Config is stored as an immutable field in `EpochManager` [2](#0-1) 

3. **Per-Epoch Cloning**: Each new `RoundManager` receives a clone of this config [3](#0-2) 

4. **Proposal Validation**: The config is used to check and reject proposals containing denied transactions [4](#0-3) 

The critical issue is that `TransactionFiltersConfig` is a **local node configuration**, not an on-chain configuration: [5](#0-4) 

Unlike critical consensus parameters that implement the `OnChainConfig` trait and are synchronized across all validators through reconfiguration events, `BlockTransactionFilterConfig` has no synchronization mechanism.

**Attack Scenario:**
1. Validators start with different `BlockTransactionFilterConfig` values (due to different config files)
2. OR a validator restarts mid-epoch with a modified configuration file
3. A block proposer creates a block with inline transactions
4. Validators with restrictive filters reject the proposal and don't vote [6](#0-5) 
5. Validators with permissive filters vote for the proposal
6. If >1/3 validators have restrictive filters, blocks fail to achieve quorum certificates
7. Network liveness degrades as proposals are inconsistently rejected

## Impact Explanation

**Assessment: High Severity**

This issue meets the **High Severity** criteria as it causes "Significant protocol violations":

- **Liveness Degradation**: If >1/3 of validators have different/restrictive filter configurations, legitimate block proposals may fail to achieve the 2f+1 vote threshold required for quorum certificates, causing rounds to timeout and reducing network throughput.

- **Non-Deterministic Block Acceptance**: The same block proposal may be accepted or rejected depending on the specific mix of validator configurations in the active set, violating the expectation that all validators apply identical validation rules.

- **Validator Synchronization Issues**: Validators that restart with different configs mid-epoch will diverge in their voting behavior from peers, creating unpredictable consensus dynamics.

This does NOT reach Critical severity because:
- BFT safety is maintained (no consensus splits if <1/3 Byzantine)
- No direct loss of funds
- Network can recover through configuration synchronization

## Likelihood Explanation

**Likelihood: Medium to High**

This issue has moderate to high likelihood because:

1. **No Synchronization Mechanism**: There is no code that validates or enforces consistency of `BlockTransactionFilterConfig` across validators [7](#0-6) 

2. **Operational Reality**: In production deployments, different validators are managed by different operators who may:
   - Deploy with different initial configurations
   - Update configurations at different times
   - Make configuration errors

3. **No Runtime Detection**: The system has no mechanism to detect when validators have divergent configurations until blocks start failing to achieve QCs

4. **Mid-Epoch Restart Vulnerability**: Any validator restart with a modified config file immediately causes divergence from other validators in the same epoch

## Recommendation

**Solution: Move to On-Chain Configuration**

The `BlockTransactionFilterConfig` should be moved to an on-chain configuration that implements the `OnChainConfig` trait, similar to `OnChainConsensusConfig`. This ensures:
- All validators read the same configuration from blockchain state
- Configuration changes go through governance and trigger epoch transitions
- Validators automatically synchronize during reconfiguration events

**Alternative Solution: Epoch-Start Validation**

If on-chain configuration is not immediately feasible, add validation at epoch start:
1. Each validator signs a hash of their `BlockTransactionFilterConfig`
2. Include this hash in the validator's epoch-start message
3. Reject epoch participation if >1/3 validators have non-matching hashes
4. Log warnings when configuration mismatches are detected

This would at least provide visibility and prevent silent divergence.

## Proof of Concept

The existing test demonstrates the vulnerability: [8](#0-7) 

**PoC Steps:**
1. Deploy a validator network with 4 validators
2. Configure validators 0-1 with `filter_enabled: false`
3. Configure validators 2-3 with a restrictive filter denying specific transaction senders
4. Submit a block proposal containing transactions from the denied sender
5. Observe that validators 2-3 reject the proposal (no vote)
6. Observe that validators 0-1 accept the proposal (vote)
7. Block fails to achieve 2f+1 = 3 votes, causing round timeout
8. Network liveness degrades as subsequent rounds face the same issue

**Notes**

While this vulnerability has significant impact on network behavior, it requires either:
1. Operational misconfiguration (different initial configs across validators)
2. Operator access to modify configuration files and restart nodes

It is NOT directly exploitable by external unprivileged attackers without compromising validator infrastructure. However, it represents a critical design flaw where essential consensus validation rules are not synchronized across the validator set, violating the fundamental BFT assumption that all honest validators follow identical protocols.

The issue is particularly concerning because:
- There is no documentation warning operators about this limitation
- The configuration appears to be a "safe" local setting but has consensus-wide implications
- Silent divergence can occur with no error messages until blocks fail

### Citations

**File:** consensus/src/epoch_manager.rs (L182-182)
```rust
    consensus_txn_filter_config: BlockTransactionFilterConfig,
```

**File:** consensus/src/epoch_manager.rs (L211-211)
```rust
        let consensus_txn_filter_config = node_config.transaction_filters.consensus_filter.clone();
```

**File:** consensus/src/epoch_manager.rs (L982-982)
```rust
            self.consensus_txn_filter_config.clone(),
```

**File:** consensus/src/round_manager.rs (L1204-1214)
```rust
        if let Err(error) = self
            .block_store
            .check_denied_inline_transactions(&proposal, &self.block_txn_filter_config)
        {
            counters::REJECTED_PROPOSAL_DENY_TXN_COUNT.inc();
            bail!(
                "[RoundManager] Proposal for block {} contains denied inline transactions: {}. Dropping proposal!",
                proposal.id(),
                error
            );
        }
```

**File:** config/src/config/node_config.rs (L87-87)
```rust
    pub transaction_filters: TransactionFiltersConfig,
```

**File:** consensus/src/round_manager_tests/txn_filter_proposal_test.rs (L31-89)
```rust
// Verify that the round manager will not vote if a block
// proposal contains any denied inline transactions.
#[test]
fn test_no_vote_on_denied_inline_transactions() {
    // Test both direct mempool and quorum store payloads
    for use_quorum_store_payloads in [false, true] {
        // Create test transactions
        let transactions = create_test_transactions();

        // Create a block filter config that denies the first transaction sender
        let block_txn_filter = BlockTransactionFilter::empty()
            .add_multiple_matchers_filter(false, vec![BlockTransactionMatcher::Transaction(
                TransactionMatcher::Sender(transactions[0].sender()),
            )])
            .add_all_filter(true);
        let block_txn_filter_config = BlockTransactionFilterConfig::new(true, block_txn_filter);

        // Create a new network playground
        let runtime = consensus_runtime();
        let mut playground = NetworkPlayground::new(runtime.handle().clone());

        // Create a new consensus node. Note: To observe the votes we're
        // going to check proposal processing on the non-proposer node
        // (which will send the votes to the proposer).
        let mut nodes = NodeSetup::create_nodes(
            &mut playground,
            runtime.handle().clone(),
            1,
            None,
            None,
            Some(block_txn_filter_config),
            None,
            None,
            None,
            use_quorum_store_payloads,
        );
        let node = &mut nodes[0];

        // Create a block proposal with inline transactions that will be denied
        let payload = create_payload(transactions, use_quorum_store_payloads);
        let denied_block = Block::new_proposal(
            payload,
            1,
            1,
            certificate_for_genesis(),
            &node.signer,
            Vec::new(),
        )
        .unwrap();

        // Verify that the node does not vote on a block with denied inline transactions
        timed_block_on(&runtime, async {
            assert!(node
                .round_manager
                .process_proposal(denied_block)
                .await
                .is_err());
        });
    }
```

**File:** config/src/config/transaction_filters_config.rs (L90-123)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct BlockTransactionFilterConfig {
    filter_enabled: bool, // Whether the filter is enabled
    block_transaction_filter: BlockTransactionFilter, // The block transaction filter to apply
}

impl BlockTransactionFilterConfig {
    pub fn new(filter_enabled: bool, block_transaction_filter: BlockTransactionFilter) -> Self {
        Self {
            filter_enabled,
            block_transaction_filter,
        }
    }

    /// Returns true iff the filter is enabled and not empty
    pub fn is_enabled(&self) -> bool {
        self.filter_enabled && !self.block_transaction_filter.is_empty()
    }

    /// Returns a reference to the block transaction filter
    pub fn block_transaction_filter(&self) -> &BlockTransactionFilter {
        &self.block_transaction_filter
    }
}

impl Default for BlockTransactionFilterConfig {
    fn default() -> Self {
        Self {
            filter_enabled: false,                                     // Disable the filter
            block_transaction_filter: BlockTransactionFilter::empty(), // Use an empty filter
        }
    }
}
```
