# Audit Report

## Title
Randomness Share Generation Without Metadata Validation Allows Extraction of Shares for Non-Consensus Metadata

## Summary
The `get_self_share()` function in `RandStore` does not verify that requested metadata corresponds to previously stored consensus-derived metadata before generating and returning shares. This allows attackers to extract cryptographically valid randomness shares for arbitrary metadata values by sending `RequestShare` messages, violating the integrity of the randomness generation system.

## Finding Description

The randomness generation system is designed to produce deterministic, unpredictable randomness for each consensus block. When a block is processed through consensus, its metadata (epoch and round) is extracted and used to generate randomness shares. [1](#0-0) 

However, when handling incoming `RequestShare` messages, the code fails to verify that the requested metadata matches metadata that was previously derived from consensus blocks. The vulnerability manifests through the following execution path:

1. **Minimal RequestShare verification**: The `verify()` method for `RequestShare` messages only validates that the epoch matches the current epoch state, performing no additional validation of the metadata's authenticity or consensus derivation. [2](#0-1) 

2. **Metadata filtering without rejection**: The `get_self_share()` function attempts to retrieve shares by round and then filters by metadata equality. When no matching share exists, it returns `None` without distinguishing whether the metadata was never consensus-derived or simply doesn't match existing shares. [3](#0-2) 

3. **Unconditional share generation for unvalidated metadata**: When `get_self_share()` returns `None`, the request handler unconditionally generates a new cryptographic share using the attacker-provided metadata via `S::generate()`, which creates a cryptographically valid WVUF share using the validator's secret key. The comment states "reproduce previous share if not found" but provides no validation that the share ever existed. [4](#0-3) 

4. **State pollution**: The newly generated share is added to the validator's `rand_store` and persists there. [5](#0-4) 

**Attack Scenario:**

1. Attacker monitors the blockchain to determine validators' `highest_known_round` values by observing their participation in consensus
2. Attacker crafts `RequestShare` messages with metadata `(epoch=E, round=R)` where `R ≤ highest_known_round` but the specific metadata was never processed through consensus on the target validator (e.g., validator was offline, or metadata values are fabricated)
3. The validator's `get_self_share()` returns `None` because no share exists for that exact metadata
4. A new cryptographic WVUF share is generated using the validator's secret key for the attacker's arbitrary metadata
5. The share is added to `rand_store` and returned to the attacker
6. Attacker repeats this process across multiple validators and different metadata values

## Impact Explanation

This is a **High Severity** vulnerability under the "Validator Node Slowdowns" and "Limited Protocol Violations" categories because:

1. **Protocol Integrity Violation**: The randomness generation protocol requires that shares only be generated for metadata derived from consensus-validated blocks. This vulnerability allows validators to generate and store cryptographic commitments for metadata that was never part of consensus, directly violating this fundamental invariant.

2. **State Pollution**: The `rand_store` becomes polluted with shares for arbitrary metadata values. While these shares cannot be directly injected into consensus due to metadata mismatch validation in `RandItem::add_share`, [6](#0-5)  their presence represents state corruption that persists throughout the validator's operation.

3. **Resource Exhaustion**: Attackers can force validators to perform expensive WVUF share generation operations. The `Share::generate()` function calls `WVUF::create_share()` which performs cryptographic operations on the validator's secret key. [7](#0-6)  While network-level RPC limits provide some protection, an attacker can still cause significant computational overhead by targeting multiple validators and requesting shares for different metadata combinations within the constraint of `round ≤ highest_known_round`.

4. **Cryptographic Material Extraction**: Attackers can extract valid WVUF shares signed with validators' secret keys for arbitrary inputs. While these shares cannot directly compromise consensus, this extraction of cryptographic material from validator nodes for attacker-chosen inputs represents a significant security boundary violation.

## Likelihood Explanation

**Likelihood: High**

- **Attack Complexity**: Low - requires only sending standard network RPC messages through the consensus P2P protocol
- **Attacker Requirements**: Standard network connectivity to validator nodes (available to any P2P network participant)
- **Detection Difficulty**: Difficult - requests appear as legitimate share requests in validator logs and are indistinguishable from normal protocol operation
- **Preconditions**: Minimal - the only constraint is that `metadata.round ≤ highest_known_round` [8](#0-7) , which is easily satisfied by requesting shares for past or current rounds that attackers can observe on-chain

The attack can target any validator at any time, with the only practical limitation being that validators may have already processed certain rounds through legitimate consensus, making those specific metadata values unavailable for exploitation.

## Recommendation

Add validation in the `RequestShare` handler to verify that requested metadata corresponds to consensus-derived blocks before generating shares:

```rust
// In rand_manager.rs, modify the RequestShare handler:
RandMessage::RequestShare(request) => {
    let result = self.rand_store.lock().get_self_share(request.rand_metadata());
    match result {
        Ok(Some(share)) => {
            // Share exists, return it
            self.process_response(protocol, response_sender, RandMessage::Share(share));
        },
        Ok(None) => {
            // Share not found - verify this is a legitimate request
            // Only regenerate if we have confirmed metadata for this round
            let has_metadata = self.rand_store.lock()
                .has_consensus_metadata(request.rand_metadata());
            
            if has_metadata {
                // Legitimate request for a round we processed - regenerate
                let share = S::generate(&self.config, request.rand_metadata().clone());
                self.rand_store.lock().add_share(share.clone(), PathType::Slow)
                    .expect("Add self share should succeed");
                self.process_response(protocol, response_sender, RandMessage::Share(share));
            } else {
                // No consensus metadata exists - reject request
                warn!("[RandManager] Rejected share request for non-consensus metadata: {:?}", 
                      request.rand_metadata());
            }
        },
        Err(e) => {
            warn!("[RandManager] Failed to get share: {}", e);
        }
    }
}
```

Additionally, add a method to `RandStore` to check if consensus metadata exists for a given round:

```rust
pub fn has_consensus_metadata(&self, metadata: &RandMetadata) -> bool {
    if let Some(item) = self.rand_map.get(&metadata.round) {
        match item {
            RandItem::PendingDecision { metadata: block_metadata, .. } |
            RandItem::Decided { .. } => {
                // Verify metadata matches
                block_metadata.metadata == *metadata
            },
            RandItem::PendingMetadata(_) => false,
        }
    } else {
        false
    }
}
```

## Proof of Concept

The vulnerability can be demonstrated through network simulation testing:

1. Set up a test validator with `highest_known_round = 100`
2. Send a `RequestShare` message with metadata `(epoch=current, round=50)` where round 50 was never processed through consensus
3. Observe that the validator generates a new share and adds it to `rand_store`
4. Verify the generated share is cryptographically valid and signed with the validator's secret key
5. Repeat with different metadata values to demonstrate arbitrary share extraction

A full Rust integration test would require access to the consensus test framework to simulate the network message flow and validator state.

## Notes

- The vulnerability is constrained by the requirement that `metadata.round ≤ highest_known_round`, which limits exploitation to past or current rounds
- The extracted shares cannot be directly used to compromise consensus due to metadata validation in `RandItem::add_share`
- The primary security impact is protocol violation, state pollution, and resource exhaustion rather than direct consensus compromise
- Network-level RPC limits (100 concurrent inbound RPCs) provide partial mitigation but do not prevent the vulnerability
- The vulnerability is most exploitable against validators that have been offline during certain rounds or are newly joined to the network

### Citations

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L145-169)
```rust
    fn process_incoming_metadata(&self, metadata: FullRandMetadata) -> DropGuard {
        let self_share = S::generate(&self.config, metadata.metadata.clone());
        info!(LogSchema::new(LogEvent::BroadcastRandShare)
            .epoch(self.epoch_state.epoch)
            .author(self.author)
            .round(metadata.round()));
        let mut rand_store = self.rand_store.lock();
        rand_store.update_highest_known_round(metadata.round());
        rand_store
            .add_share(self_share.clone(), PathType::Slow)
            .expect("Add self share should succeed");

        if let Some(fast_config) = &self.fast_config {
            let self_fast_share =
                FastShare::new(S::generate(fast_config, metadata.metadata.clone()));
            rand_store
                .add_share(self_fast_share.rand_share(), PathType::Fast)
                .expect("Add self share for fast path should succeed");
        }

        rand_store.add_rand_metadata(metadata.clone());
        self.network_sender
            .broadcast_without_self(RandMessage::<S, D>::Share(self_share).into_network_message());
        self.spawn_aggregate_shares_task(metadata.metadata)
    }
```

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L397-412)
```rust
                        RandMessage::RequestShare(request) => {
                            let result = self.rand_store.lock().get_self_share(request.rand_metadata());
                            match result {
                                Ok(maybe_share) => {
                                    let share = maybe_share.unwrap_or_else(|| {
                                        // reproduce previous share if not found
                                        let share = S::generate(&self.config, request.rand_metadata().clone());
                                        self.rand_store.lock().add_share(share.clone(), PathType::Slow).expect("Add self share should succeed");
                                        share
                                    });
                                    self.process_response(protocol, response_sender, RandMessage::Share(share));
                                },
                                Err(e) => {
                                    warn!("[RandManager] Failed to get share: {}", e);
                                }
                            }
```

**File:** consensus/src/rand/rand_gen/network_messages.rs (L44-45)
```rust
        match self {
            RandMessage::RequestShare(_) => Ok(()),
```

**File:** consensus/src/rand/rand_gen/rand_store.rs (L150-154)
```rust
                ensure!(
                    &metadata.metadata == share.metadata(),
                    "[RandStore] RandShare metadata from {} mismatch with block metadata!",
                    share.author(),
                );
```

**File:** consensus/src/rand/rand_gen/rand_store.rs (L323-338)
```rust
    pub fn get_self_share(
        &mut self,
        metadata: &RandMetadata,
    ) -> anyhow::Result<Option<RandShare<S>>> {
        ensure!(
            metadata.round <= self.highest_known_round,
            "Request share from future round {}, highest known round {}",
            metadata.round,
            self.highest_known_round
        );
        Ok(self
            .rand_map
            .get(&metadata.round)
            .and_then(|item| item.get_self_share())
            .filter(|share| share.metadata() == metadata))
    }
```

**File:** consensus/src/rand/rand_gen/types.rs (L84-95)
```rust
    fn generate(rand_config: &RandConfig, rand_metadata: RandMetadata) -> RandShare<Self>
    where
        Self: Sized,
    {
        let share = Share {
            share: WVUF::create_share(
                &rand_config.keys.ask,
                bcs::to_bytes(&rand_metadata).unwrap().as_slice(),
            ),
        };
        RandShare::new(rand_config.author(), rand_metadata, share)
    }
```
