# Audit Report

## Title
Non-Deterministic Hash Computation in Multi-Step Governance Proposals Due to Compiler Version Defaults

## Summary
The `get_execution_hash()` function uses compile-time constants for compiler and language versions, causing identical Move scripts to produce different execution hashes when compiled with different versions of the aptos-release-builder binary. This breaks proposal verification and can cause governance deadlock for multi-step proposals.

## Finding Description

The `get_execution_hash()` function generates execution hashes for governance proposals by compiling Move scripts and hashing the resulting bytecode. [1](#0-0) 

The function creates a `GenerateExecutionHash` instance which internally uses `CompileScriptFunction::default()` to compile the script. [2](#0-1) 

The critical issue is that `CompileScriptFunction` has default values for `compiler_version` and `language_version` that are set to compile-time string constants: [3](#0-2) 

These constants are defined as: [4](#0-3) 

When proposals are verified, the on-chain governance system checks that the script hash matches exactly: [5](#0-4) 

**The Attack Scenario:**
1. A multi-step governance proposal is created using binary A compiled when `LATEST_STABLE_COMPILER_VERSION = "2.0"`
2. The proposal's execution hash H1 is stored on-chain
3. The Aptos codebase is updated to bump `LATEST_STABLE_COMPILER_VERSION = "2.1"`
4. Participants rebuild their binaries with the new constant
5. When trying to execute the next step of the multi-step proposal, the script compiles with version 2.1, producing hash H2
6. On-chain verification fails: `transaction_context::get_script_hash() != proposal.execution_hash`
7. The proposal cannot be executed, causing governance deadlock

For multi-step proposals, this is catastrophic because each step's hash is chained to the next step during proposal creation. [6](#0-5) 

## Impact Explanation

This qualifies as **High Severity** under "Significant protocol violations" because:

1. **Governance Integrity Violation**: Multi-step proposals are critical for framework upgrades and protocol changes. If these proposals fail mid-execution due to hash mismatches, governance becomes dysfunctional.

2. **Non-Recoverable State**: Once a proposal's hash is committed on-chain, it cannot be changed. If compiler constants change before all steps execute, the proposal is permanently bricked.

3. **Systemic Risk**: This affects ALL governance participants simultaneously when compiler versions change, not just individual nodes. The entire governance system must coordinate version updates.

4. **Framework Upgrade Blockage**: Framework upgrades rely on multi-step proposals. A hash mismatch during a critical framework upgrade could prevent urgent security patches from being deployed.

While not directly causing fund loss or consensus breaks, breaking the governance mechanism is a **significant protocol violation** that can prevent the network from upgrading or adapting to security issues.

## Likelihood Explanation

**Likelihood: Medium to High**

This WILL occur whenever:
1. The `LATEST_STABLE_COMPILER_VERSION` or `LATEST_STABLE_LANGUAGE_VERSION` constants are updated in the codebase (happens during normal development)
2. A multi-step governance proposal is in progress during the update
3. Different participants compile their binaries at different times

The compilation constants are designed to evolve as the Move compiler matures. The codebase shows they've already changed multiple times (V2_0, V2_1, V2_2, V2_3 versions exist). Without explicit coordination, this WILL cause hash mismatches.

## Recommendation

**Fix 1: Embed Compiler Version in Proposal Metadata**

When creating proposals, explicitly specify and store the compiler/language versions used:

```rust
pub fn get_execution_hash(result: &[(String, String)]) -> Option<HashValue> {
    if result.is_empty() {
        None
    } else {
        let temp_script_path = TempPath::new();
        temp_script_path.create_as_file().unwrap();
        let mut move_script_path = temp_script_path.path().to_path_buf();
        move_script_path.set_extension("move");
        std::fs::write(move_script_path.as_path(), result.last().unwrap().1.clone())
            .unwrap();

        // FIXED: Use explicit stable versions instead of compile-time defaults
        let (_, hash) = GenerateExecutionHash {
            script_path: Option::from(move_script_path),
            framework_local_dir: Some(aptos_framework_path()),
        }
        .generate_hash_with_versions(
            Some(CompilerVersion::V2_0), // Explicitly pin version
            Some(LanguageVersion::V2_3),  // Explicitly pin version
        )
        .unwrap();
        Some(hash)
    }
}
```

**Fix 2: Document Required Versions in Proposal Metadata**

Store the compiler/language versions in proposal metadata so verifiers know which versions to use.

**Fix 3: Version Compatibility Layer**

Implement a compatibility layer that can compile with multiple versions and validate against any of them for backwards compatibility.

## Proof of Concept

```rust
// Reproduction steps:

// Step 1: Create a proposal with CompilerVersion::V2_0
let script_v2_0 = CompileScriptFunction {
    script_path: Some(PathBuf::from("test_script.move")),
    compiler_version: Some(CompilerVersion::V2_0),
    language_version: Some(LanguageVersion::V2_3),
    ..CompileScriptFunction::default()
}.compile("test", PromptOptions::yes())?;
let hash_v2_0 = HashValue::sha3_256_of(&script_v2_0.0);

// Step 2: Compile same script with CompilerVersion::V2_1
let script_v2_1 = CompileScriptFunction {
    script_path: Some(PathBuf::from("test_script.move")),
    compiler_version: Some(CompilerVersion::V2_1),
    language_version: Some(LanguageVersion::V2_3),
    ..CompileScriptFunction::default()
}.compile("test", PromptOptions::yes())?;
let hash_v2_1 = HashValue::sha3_256_of(&script_v2_1.0);

// Step 3: Verify hashes differ for identical source
assert_ne!(hash_v2_0, hash_v2_1, "VULNERABILITY: Same source code produces different hashes!");

// Step 4: On-chain verification fails
// When proposal.execution_hash = hash_v2_0 but 
// transaction_context::get_script_hash() = hash_v2_1
// The assertion in voting.move line 448 fails with EPROPOSAL_EXECUTION_HASH_NOT_MATCHING
```

## Notes

While users CAN specify compiler versions explicitly via CLI flags (`--compiler-version` and `--language-version`), the default behavior is broken. Most users rely on defaults and won't know which versions were used for existing proposals. The documentation does not warn about this issue, and there's no mechanism to query which versions were used for a given proposal.

This is particularly critical for multi-step proposals where the hash chain must remain consistent across all steps, but participants may rebuild their binaries between steps as development continues.

### Citations

**File:** aptos-move/aptos-release-builder/src/components/mod.rs (L233-239)
```rust
                        is_testnet,
                        if is_multi_step {
                            get_execution_hash(result)
                        } else {
                            None
                        },
                        is_multi_step,
```

**File:** aptos-move/aptos-release-builder/src/components/mod.rs (L816-841)
```rust
pub fn get_execution_hash(result: &[(String, String)]) -> Option<HashValue> {
    if result.is_empty() {
        None
    } else {
        let temp_script_path = TempPath::new();
        temp_script_path.create_as_file().unwrap();
        let mut move_script_path = temp_script_path.path().to_path_buf();
        move_script_path.set_extension("move");
        std::fs::write(move_script_path.as_path(), result.last().unwrap().1.clone())
            .map_err(|err| {
                anyhow!(
                    "Failed to get execution hash: failed to write to file: {:?}",
                    err
                )
            })
            .unwrap();

        let (_, hash) = GenerateExecutionHash {
            script_path: Option::from(move_script_path),
            framework_local_dir: Some(aptos_framework_path()),
        }
        .generate_hash()
        .unwrap();
        Some(hash)
    }
}
```

**File:** crates/aptos/src/governance/mod.rs (L902-929)
```rust
#[derive(Parser, Default)]
pub struct CompileScriptFunction {
    /// Path to the Move script for the proposal
    #[clap(long, group = "script", value_parser)]
    pub script_path: Option<PathBuf>,

    /// Path to the Move script for the proposal
    #[clap(long, group = "script", value_parser)]
    pub compiled_script_path: Option<PathBuf>,

    #[clap(flatten)]
    pub framework_package_args: FrameworkPackageArgs,

    #[clap(long)]
    pub bytecode_version: Option<u32>,

    /// Specify the version of the compiler.
    /// Defaults to the latest stable compiler version (at least 2)
    #[clap(long, value_parser = clap::value_parser!(CompilerVersion),
           default_value = LATEST_STABLE_COMPILER_VERSION,)]
    pub compiler_version: Option<CompilerVersion>,

    /// Specify the language version to be supported.
    /// Defaults to the latest stable language version (at least 2)
    #[clap(long, value_parser = clap::value_parser!(LanguageVersion),
           default_value = LATEST_STABLE_LANGUAGE_VERSION,)]
    pub language_version: Option<LanguageVersion>,
}
```

**File:** crates/aptos/src/governance/mod.rs (L1066-1097)
```rust
impl GenerateExecutionHash {
    pub fn generate_hash(&self) -> CliTypedResult<(Vec<u8>, HashValue)> {
        let framework_local_dir = if self.framework_local_dir.is_some() {
            self.framework_local_dir.clone()
        } else {
            Option::from({
                let mut path = PathBuf::from(env!("CARGO_MANIFEST_DIR"));
                path.pop();
                path.pop();
                path.join("aptos-move")
                    .join("framework")
                    .join("aptos-framework")
                    .canonicalize()
                    .map_err(|err| {
                        CliError::IO(
                            format!("Failed to canonicalize aptos framework path: {:?}", path),
                            err,
                        )
                    })?
            })
        };
        CompileScriptFunction {
            script_path: self.script_path.clone(),
            framework_package_args: FrameworkPackageArgs {
                framework_local_dir,
                ..FrameworkPackageArgs::default()
            },
            ..CompileScriptFunction::default()
        }
        .compile("execution_hash", PromptOptions::yes())
    }
}
```

**File:** third_party/move/move-model/src/metadata.rs (L20-24)
```rust
pub const LATEST_STABLE_LANGUAGE_VERSION_VALUE: LanguageVersion = LanguageVersion::V2_3;
pub const LATEST_STABLE_LANGUAGE_VERSION: &str = LATEST_STABLE_LANGUAGE_VERSION_VALUE.to_str();

pub const LATEST_STABLE_COMPILER_VERSION_VALUE: CompilerVersion = CompilerVersion::V2_0;
pub const LATEST_STABLE_COMPILER_VERSION: &str = LATEST_STABLE_COMPILER_VERSION_VALUE.to_str();
```

**File:** aptos-move/framework/aptos-framework/sources/voting.move (L447-450)
```text
        assert!(
            transaction_context::get_script_hash() == proposal.execution_hash,
            error::invalid_argument(EPROPOSAL_EXECUTION_HASH_NOT_MATCHING),
        );
```
