# Audit Report

## Title
Referer Blocklist Bypass via Invalid UTF-8 Header Encoding

## Summary
The `RefererBlocklistChecker` in the Aptos faucet service contains a security bypass vulnerability. The `.to_str().ok()` conversion on line 36 silently fails when processing non-UTF-8 referer values, returning `None` and allowing the request to proceed even if the referer would otherwise be blocklisted. This enables attackers to bypass referer-based access controls by sending binary or invalid UTF-8 data in the Referer header. [1](#0-0) 

## Finding Description

The `RefererBlocklistChecker::check()` function is designed to reject requests whose Referer header matches entries in a configured blocklist. However, the implementation uses a "fail-open" pattern that allows bypass through malformed headers.

The vulnerable code path:
1. The checker extracts the `REFERER` header from the request
2. Calls `.to_str()` which attempts to convert `HeaderValue` to `&str` (requires valid UTF-8)
3. If the header contains invalid UTF-8 bytes, `to_str()` returns `Err(ToStrError)`
4. The `.ok()` method converts the error to `None`
5. When `None` is matched, the function returns `Ok(vec![])` - an empty rejection vector
6. In the request preprocessing logic, an empty rejection vector means the request is **allowed** [2](#0-1) 

This breaks the security invariant that blocklisted referers should be rejected. An attacker can craft HTTP requests with the Referer header containing the blocklisted domain encoded with invalid UTF-8 bytes (e.g., `"https://mysite.com\xFF\xFE"`) to bypass the check entirely.

The blocklist checking logic only operates on valid UTF-8 strings, but HTTP headers can contain arbitrary byte sequences. When UTF-8 validation fails, the security control is silently disabled rather than defaulting to rejection. [3](#0-2) 

## Impact Explanation

**Severity Assessment: Medium (per Aptos Bug Bounty)**

While the security question marks this as "High" severity, the actual impact is limited to the faucet service, which is an auxiliary testnet/devnet component, not part of the core blockchain consensus, execution, or state management systems. [4](#0-3) 

The faucet mints test tokens with no real-world value. However, bypassing the referer blocklist enables:
- **Resource exhaustion**: Attackers from blocked domains can continue draining faucet resources
- **DoS for legitimate users**: Abusive actors can exhaust rate limits
- **Circumvention of abuse controls**: Domains explicitly blocked for malicious behavior can continue operations

This does not meet "High" severity criteria (validator node impact, critical API crashes, protocol violations) but exceeds "Low" severity as it represents a significant security control bypass affecting service availability.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is trivially exploitable:
- No authentication or special privileges required
- Attack vector is a single malformed HTTP header
- Standard HTTP libraries support setting arbitrary header bytes
- No rate limiting or detection mechanisms for malformed headers
- The vulnerability is always present once the RefererBlocklistChecker is enabled

The attacker only needs to:
1. Identify they are being blocked by the referer checker (HTTP 403 with `RefererBlocklisted` reason)
2. Add invalid UTF-8 bytes to their Referer header
3. Retry the request - it will succeed

## Recommendation

Replace the "fail-open" pattern with "fail-closed" behavior. When UTF-8 conversion fails, treat it as a potential bypass attempt and check against the blocklist using byte-level comparison or reject the request outright.

**Recommended Fix:**

```rust
async fn check(
    &self,
    data: CheckerData,
    _dry_run: bool,
) -> Result<Vec<RejectionReason>, AptosTapError> {
    let referer_header = match data.headers.get(REFERER) {
        Some(header) => header,
        None => return Ok(vec![]),
    };
    
    // Attempt UTF-8 conversion
    let referer = match referer_header.to_str() {
        Ok(s) => s,
        Err(_) => {
            // Invalid UTF-8 in Referer header - reject as suspicious
            return Ok(vec![RejectionReason::new(
                "Referer header contains invalid UTF-8 encoding".to_string(),
                RejectionReasonCode::RefererBlocklisted,
            )]);
        }
    };
    
    if self.manager.contains(referer) {
        Ok(vec![RejectionReason::new(
            format!(
                "The provided referer is not allowed by the server: {}",
                referer
            ),
            RejectionReasonCode::RefererBlocklisted,
        )])
    } else {
        Ok(vec![])
    }
}
```

Alternatively, use `.as_bytes()` and compare against blocklist entries as bytes, though this is more complex.

## Proof of Concept

```rust
use poem::http::{HeaderMap, HeaderValue};
use std::sync::Arc;

#[tokio::test]
async fn test_referer_blocklist_utf8_bypass() {
    use aptos_faucet_core::checkers::{CheckerData, CheckerTrait, referer_blocklist::RefererBlocklistChecker};
    use aptos_faucet_core::common::ListManagerConfig;
    use std::io::Write;
    use tempfile::NamedTempFile;
    
    // Create blocklist file with "https://blocked-domain.com"
    let mut blocklist_file = NamedTempFile::new().unwrap();
    writeln!(blocklist_file, "https://blocked-domain.com").unwrap();
    blocklist_file.flush().unwrap();
    
    let config = ListManagerConfig {
        file: blocklist_file.path().to_path_buf(),
    };
    
    let checker = RefererBlocklistChecker::new(config).unwrap();
    
    // Test 1: Valid UTF-8 blocked referer - should be rejected
    let mut headers = HeaderMap::new();
    headers.insert("referer", HeaderValue::from_static("https://blocked-domain.com"));
    
    let checker_data = CheckerData {
        time_request_received_secs: 0,
        receiver: aptos_sdk::types::account_address::AccountAddress::ZERO,
        source_ip: "127.0.0.1".parse().unwrap(),
        headers: Arc::new(headers),
    };
    
    let result = checker.check(checker_data, false).await.unwrap();
    assert!(!result.is_empty(), "Valid UTF-8 blocked referer should be rejected");
    
    // Test 2: Invalid UTF-8 with blocked domain - BYPASSES CHECK
    let mut headers = HeaderMap::new();
    // Create header with invalid UTF-8: "https://blocked-domain.com" + invalid bytes
    let mut invalid_bytes = b"https://blocked-domain.com".to_vec();
    invalid_bytes.extend_from_slice(&[0xFF, 0xFE]); // Invalid UTF-8 sequences
    headers.insert("referer", HeaderValue::from_bytes(&invalid_bytes).unwrap());
    
    let checker_data = CheckerData {
        time_request_received_secs: 0,
        receiver: aptos_sdk::types::account_address::AccountAddress::ZERO,
        source_ip: "127.0.0.1".parse().unwrap(),
        headers: Arc::new(headers),
    };
    
    let result = checker.check(checker_data, false).await.unwrap();
    assert!(result.is_empty(), "Invalid UTF-8 should bypass blocklist - VULNERABILITY!");
}
```

## Notes

**Important Context:**
- This vulnerability affects the **Aptos Faucet service** (testnet/devnet token distribution), not core blockchain consensus or execution components
- The faucet mints test tokens with no real-world monetary value
- Impact is limited to service availability and abuse control bypass
- This is NOT a consensus, state management, or Move VM vulnerability
- The vulnerability is real and exploitable, but scope is limited to auxiliary infrastructure

The security control bypass is genuine, but operators should understand this affects testnet/devnet faucet operations rather than mainnet or core protocol security.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/referer_blocklist.rs (L36-39)
```rust
        let referer = match data.headers.get(REFERER).and_then(|v| v.to_str().ok()) {
            Some(referer) => referer,
            None => return Ok(vec![]),
        };
```

**File:** crates/aptos-faucet/core/src/checkers/referer_blocklist.rs (L40-50)
```rust
        if self.manager.contains(referer) {
            Ok(vec![RejectionReason::new(
                format!(
                    "The provided referer is not allowed by the server: {}",
                    referer
                ),
                RejectionReasonCode::RefererBlocklisted,
            )])
        } else {
            Ok(vec![])
        }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L261-278)
```rust
        // Ensure request passes checkers.
        let mut rejection_reasons = Vec::new();
        for checker in &self.checkers {
            rejection_reasons.extend(checker.check(checker_data.clone(), dry_run).await.map_err(
                |e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError),
            )?);
            if !rejection_reasons.is_empty() && self.return_rejections_early {
                break;
            }
        }

        if !rejection_reasons.is_empty() {
            return Err(AptosTapError::new(
                format!("Request rejected by {} checkers", rejection_reasons.len()),
                AptosTapErrorCode::Rejected,
            )
            .rejection_reasons(rejection_reasons));
        }
```

**File:** crates/aptos-faucet/README.md (L1-3)
```markdown
# Aptos Faucet

The Aptos Faucet is a service that runs alongside a test network and mints coins for users to test and develop on Aptos.
```
