# Audit Report

## Title
Compiler Version V1 Bypass: Missing Runtime Validation Allows Deployment of Deprecated Compiler Bytecode

## Summary
The Aptos VM validates compiler versions at compilation time but fails to enforce this validation at deployment/runtime. While Compiler V1 is explicitly rejected during compilation, modules compiled with V1 using legacy toolchains can still be deployed to mainnet because the runtime check `reject_unstable_bytecode` only validates the `unstable` flag, not the specific compiler version. Since V1 is marked as stable (`unstable() = false`), such modules bypass runtime validation. [1](#0-0) 

## Finding Description

The vulnerability exists in a **Time-Of-Check-Time-Of-Use (TOCTOU)** gap between compilation and deployment:

**Compilation-Time Check:**
The compiler explicitly rejects V1 at compilation through `check_language_support`: [2](#0-1) 

And during the build process: [3](#0-2) 

**Runtime Validation Gap:**
At deployment time, `validate_publish_request` calls `reject_unstable_bytecode`: [4](#0-3) 

However, `reject_unstable_bytecode` only checks the `unstable` flag in metadata: [5](#0-4) 

**The Exploit Path:**
1. Attacker obtains legacy Move compiler toolchain (pre-V1 deprecation)
2. Compiles Move modules with `--compiler-version 1`
3. Resulting bytecode contains `CompilationMetadata` with:
   - `compiler_version: "1"`
   - `unstable: false` (because `V1.unstable()` returns false) [6](#0-5) 

4. Deploys module to mainnet via standard transaction
5. Runtime check passes because `metadata.unstable == false`
6. If V1 compiler had security bugs (bytecode generation errors, type system bypasses as stated in the security question), these bugs are now exploitable on mainnet

This breaks the **Deterministic Execution** invariant: if V1 generates bytecode differently than V2 compilers, validators may produce different state roots for identical blocks, causing consensus splits.

## Impact Explanation

**Critical Severity** - This vulnerability qualifies for the highest severity tier because:

1. **Consensus Safety Violations**: If V1 compiler had bugs causing non-deterministic bytecode generation or different execution semantics, this could lead to:
   - State root mismatches across validators
   - Chain splits requiring hard fork to resolve
   - Violation of the AptosBFT safety guarantee

2. **Move VM Safety Violations**: Type system bypasses or bytecode verification errors in V1 could:
   - Allow access to protected resources
   - Bypass gas metering
   - Violate memory safety constraints
   - Enable arbitrary code execution within the VM

3. **Network-Wide Impact**: Once deployed, malicious bytecode affects all validators when executing transactions that invoke the compromised module.

The impact categorization aligns with Aptos Bug Bounty **Critical Severity** criteria:
- "Consensus/Safety violations"
- "Non-recoverable network partition (requires hardfork)"

## Likelihood Explanation

**Medium-High Likelihood** with the following considerations:

**Feasibility:**
- Attacker requires access to legacy V1 compiler toolchain (archived versions exist in Git history)
- Module deployment is permissionless - anyone can submit transactions
- No special privileges required beyond standard account creation

**Barriers:**
- Must obtain and compile with deprecated tooling
- Requires knowledge that V1 is accepted at runtime despite compile-time rejection
- Depends on V1 having actual exploitable bugs (explicitly assumed in the security question)

**Detection:**
- No monitoring alerts for V1 compiler usage
- Compilation metadata is embedded but not actively scanned pre-deployment
- Post-deployment, malicious behavior may manifest gradually

The likelihood increases if:
- Historical vulnerabilities in V1 become publicly documented
- Attack tools/guides for using legacy compilers emerge
- Economic incentives for exploiting the bug are high

## Recommendation

Add explicit runtime validation to reject Compiler V1 during module publishing. Modify `reject_unstable_bytecode` or add a separate check:

```rust
fn reject_deprecated_compiler_versions(&self, modules: &[CompiledModule]) -> VMResult<()> {
    for module in modules {
        if let Some(metadata) = get_compilation_metadata(module) {
            if let Ok(compiler_version) = CompilerVersion::from_str(&metadata.compiler_version) {
                if compiler_version == CompilerVersion::V1 {
                    return Err(PartialVMError::new(StatusCode::CONSTRAINT_NOT_SATISFIED)
                        .with_message("Compiler v1 is no longer supported for deployment".to_string())
                        .finish(Location::Module(module.self_id())));
                }
            }
        }
    }
    Ok(())
}
```

Call this function in `validate_publish_request`: [7](#0-6) 

Insert the check immediately after line 1689:
```rust
self.reject_deprecated_compiler_versions(modules)?;
```

Additionally, apply the same check for scripts: [8](#0-7) 

## Proof of Concept

**Prerequisite:** Obtain legacy Move compiler (pre-2024 version supporting V1)

**Step 1: Compile Module with V1**
```bash
# Using legacy move-cli with V1 support
move package build --compiler-version 1 --skip-fetch-latest-git-deps
```

**Step 2: Extract Bytecode**
```rust
// Extract compiled bytecode from build artifacts
let bytecode = std::fs::read("build/MyPackage/bytecode_modules/MyModule.mv")?;
let module = CompiledModule::deserialize(&bytecode)?;

// Verify metadata shows V1
let metadata = get_compilation_metadata(&module).unwrap();
assert_eq!(metadata.compiler_version, "1");
assert_eq!(metadata.unstable, false);  // V1 is marked stable
```

**Step 3: Deploy via Transaction**
```rust
// Create transaction to publish module
let txn = Transaction::UserTransaction(
    create_signed_transaction(
        TransactionPayload::ModuleBundle(ModuleBundle::new(vec![module])),
        sender_account,
        sequence_number,
    )
);

// Submit to blockchain - runtime validation will PASS
// because reject_unstable_bytecode only checks unstable flag
```

**Expected Result:** Module is successfully published to mainnet despite using deprecated V1 compiler.

**Verification:** Query deployed module metadata on-chain to confirm compiler_version field shows "1".

## Notes

This vulnerability represents a **defense-in-depth failure** where compile-time restrictions are not enforced at runtime. While modern tooling prevents V1 usage, the blockchain protocol itself does not reject V1-compiled bytecode, creating a trust boundary violation. The security model assumes all bytecode passing runtime validation is safe, but this assumption breaks when deprecated compiler versions with potential bugs can bypass validation.

### Citations

**File:** third_party/move/move-model/src/metadata.rs (L64-71)
```rust
impl CompilationMetadata {
    pub fn new(compiler_version: CompilerVersion, language_version: LanguageVersion) -> Self {
        Self {
            compiler_version: compiler_version.to_string(),
            language_version: language_version.to_string(),
            unstable: compiler_version.unstable() || language_version.unstable(),
        }
    }
```

**File:** third_party/move/move-model/src/metadata.rs (L151-157)
```rust
    pub fn unstable(self) -> bool {
        match self {
            CompilerVersion::V1 => false,
            CompilerVersion::V2_0 => false,
            CompilerVersion::V2_1 => true,
        }
    }
```

**File:** third_party/move/move-model/src/metadata.rs (L171-178)
```rust
    pub fn check_language_support(self, _version: LanguageVersion) -> anyhow::Result<()> {
        match self {
            CompilerVersion::V1 => {
                bail!("compiler v1 is no longer supported")
            },
            _ => Ok(()),
        }
    }
```

**File:** third_party/move/tools/move-package/src/compilation/compiled_package.rs (L609-616)
```rust
        let effective_compiler_version = config.compiler_version.unwrap_or_default();
        let effective_language_version = config.language_version.unwrap_or_default();
        effective_compiler_version.check_language_support(effective_language_version)?;

        let (file_map, all_compiled_units, model) =
            match config.compiler_version.unwrap_or_default() {
                CompilerVersion::V1 => anyhow::bail!("Compiler v1 is no longer supported"),
                version @ CompilerVersion::V2_0 | version @ CompilerVersion::V2_1 => {
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L917-920)
```rust
            // Check that unstable bytecode cannot be executed on mainnet and verify events.
            let script = func.owner_as_script()?;
            self.reject_unstable_bytecode_for_script(script)?;
            event_validation::verify_no_event_emission_in_compiled_script(script)?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1680-1690)
```rust
    fn validate_publish_request(
        &self,
        module_storage: &impl AptosModuleStorage,
        traversal_context: &mut TraversalContext,
        gas_meter: &mut impl GasMeter,
        modules: &[CompiledModule],
        mut expected_modules: BTreeSet<String>,
        allowed_deps: Option<BTreeMap<AccountAddress, BTreeSet<String>>>,
    ) -> VMResult<()> {
        self.reject_unstable_bytecode(modules)?;
        native_validation::validate_module_natives(modules)?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1742-1757)
```rust
    fn reject_unstable_bytecode(&self, modules: &[CompiledModule]) -> VMResult<()> {
        if self.chain_id().is_mainnet() {
            for module in modules {
                if let Some(metadata) = get_compilation_metadata(module) {
                    if metadata.unstable {
                        return Err(PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                            .with_message(
                                "code marked unstable is not published on mainnet".to_string(),
                            )
                            .finish(Location::Undefined));
                    }
                }
            }
        }
        Ok(())
    }
```
