# Audit Report

## Title
Employee Beneficiary Validation Missing in Genesis Vesting Pool Creation Causes Distribution Lockup

## Summary
Employee beneficiary addresses (shareholders) are not validated before vesting pool creation during genesis setup. Invalid employee addresses that cannot receive APT coins cause the `distribute()` function to fail, permanently locking all vested funds for all shareholders in the pool.

## Finding Description

The vulnerability exists across three components in the genesis vesting pool creation flow:

**1. No Validation in Pool Address Generation Tool** [1](#0-0) 

The `execute()` function generates vesting pool addresses directly from `employee_vesting_accounts` without validating that employee accounts (shareholders) are valid or can receive APT. Pool addresses are computed only from validator owner/operator addresses, ignoring the actual employee beneficiary addresses.

**2. No Validation in Genesis Contract Creation** [2](#0-1) 

During genesis, employee accounts are withdrawn from and added as shareholders to the vesting contract without any validation that these addresses can later receive distributions.

**3. Missing Shareholder Validation in Vesting Contract** [3](#0-2) 

The `create_vesting_contract` function validates that the withdrawal address is registered for APT but does NOT validate that shareholders are registered for APT or can receive coins. [4](#0-3) 

**4. Distribution Failure Blocks All Shareholders** [5](#0-4) 

When `distribute()` is called, it iterates through all shareholders and deposits coins via `aptos_account::deposit_coins()`. If any shareholder cannot receive coins (not registered for APT, has direct transfers disabled, or is a reserved address), the entire transaction reverts, blocking ALL shareholders from receiving their vested funds. [6](#0-5) 

The `deposit_coins` function fails if the recipient has `allow_arbitrary_coin_transfers` set to false or cannot be registered for APT.

**5. Developers Aware of Risk But Only for Beneficiaries** [7](#0-6) 

The comment in `set_beneficiary` explicitly acknowledges the risk: "This is a requirement so distribute() wouldn't fail and block all other accounts from receiving APT if one beneficiary is not registered." However, this validation only applies when setting beneficiaries AFTER creation, not for initial shareholders.

## Impact Explanation

**Severity: HIGH** (per Aptos Bug Bounty criteria: "Significant protocol violations" and "Limited funds loss or manipulation")

Impact on stakeholders:
- **All shareholders in affected vesting pool**: Cannot receive any vested funds until admin intervention
- **Protocol integrity**: Vesting contracts become non-functional, violating the staking security invariant
- **Recovery complexity**: Requires admin to manually call `set_beneficiary` for each problematic shareholder before any distribution can succeed

This qualifies as HIGH severity because:
1. Funds are locked but recoverable via admin intervention (not permanent)
2. Affects critical genesis functionality for employee vesting
3. Could impact mainnet genesis if invalid addresses are used
4. No automatic safeguards prevent the issue

## Likelihood Explanation

**Likelihood: MEDIUM**

The vulnerability can occur when:
1. Genesis configuration files contain employee addresses that:
   - Are not registered for APT (newly created accounts without coin store)
   - Have `allow_arbitrary_coin_transfers` explicitly disabled
   - Are reserved system addresses (@0x1 through @0xa)
   - Have other constraints preventing coin receipt

2. Configuration error propagation:
   - Tools.rs generates pool addresses without validation
   - Genesis succeeds (shareholders exist and have coins to withdraw)
   - Issue only manifests on first `distribute()` call

The likelihood is MEDIUM because:
- Requires configuration mistakes in genesis setup
- Most employee accounts would be properly set up
- However, no validation catches these errors early
- First distribution attempt reveals the problem after vesting has begun

## Recommendation

Add validation of shareholder addresses in multiple layers:

**1. Add validation in tools.rs before pool address generation:**
```rust
// In crates/aptos/src/genesis/tools.rs, execute() function
for employee_pool in employee_vesting_accounts.inner.iter() {
    // Validate employee accounts
    for employee_account in &employee_pool.accounts {
        // Check not reserved address
        // Check account format is valid
        // Emit warning if account doesn't exist in genesis
    }
    // ... existing code ...
}
```

**2. Add validation in vesting.move create_vesting_contract:**
```move
// In create_vesting_contract function, after line 567
vector::for_each_ref(shareholders, |shareholder| {
    let shareholder: address = *shareholder;
    assert_account_is_registered_for_apt(shareholder);
});
```

This ensures all shareholders can receive distributions, preventing lockup at creation time rather than at first distribution.

**3. Add validation in genesis.move:**
```move
// In create_employee_validators, before creating vesting contract
let j = 0;
while (j < num_employees_in_group) {
    let account = vector::borrow(&employee_group.accounts, j);
    assert_account_is_registered_for_apt(*account);
    j = j + 1;
};
```

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework)]
#[expected_failure(abort_code = 0x50003, location = aptos_framework::aptos_account)]
fun test_vesting_lockup_with_invalid_beneficiary(aptos_framework: &signer) {
    use aptos_framework::vesting;
    use aptos_framework::aptos_account;
    use aptos_framework::coin;
    use aptos_framework::aptos_coin::AptosCoin;
    use std::vector;
    
    // Setup framework
    vesting::setup(aptos_framework, &vector[@0x100, @0x200, @0x300]);
    
    let admin = @0x100;
    let operator = @0x200;
    let voter = @0x300;
    
    // Create shareholder that cannot receive coins
    let problematic_shareholder = @0x400;
    aptos_account::create_account(problematic_shareholder);
    // Explicitly disable direct coin transfers
    aptos_account::set_allow_direct_coin_transfers(
        &create_signer(problematic_shareholder), 
        false
    );
    
    // Fund shareholders
    let shareholders = vector[@0x500, problematic_shareholder];
    coin::register<AptosCoin>(&create_signer(@0x500));
    aptos_coin::mint(aptos_framework, @0x500, 1000000000000);
    aptos_coin::mint(aptos_framework, problematic_shareholder, 1000000000000);
    
    // Create vesting contract (succeeds - no validation)
    let buy_ins = simple_map::create();
    simple_map::add(&mut buy_ins, @0x500, 
        coin::withdraw<AptosCoin>(&create_signer(@0x500), 1000000000000));
    simple_map::add(&mut buy_ins, problematic_shareholder,
        coin::withdraw<AptosCoin>(&create_signer(problematic_shareholder), 1000000000000));
    
    let vesting_schedule = vesting::create_vesting_schedule(
        vector[fixed_point32::create_from_rational(1, 4)],
        timestamp::now_seconds() + 100,
        2592000
    );
    
    let contract_addr = vesting::create_vesting_contract(
        &create_signer(admin),
        &shareholders,
        buy_ins,
        vesting_schedule,
        admin,
        operator,
        voter,
        10,
        x""
    );
    
    // Fast forward past vesting start
    timestamp::fast_forward_seconds(2592100);
    
    // Vest tokens
    vesting::vest(contract_addr);
    
    // Try to distribute - FAILS because problematic_shareholder cannot receive coins
    // This blocks @0x500 from receiving their share too!
    vesting::distribute(contract_addr); 
    // Expected failure: EACCOUNT_DOES_NOT_ACCEPT_DIRECT_COIN_TRANSFERS
}
```

## Notes

This vulnerability demonstrates a gap between validation of beneficiaries (enforced when calling `set_beneficiary`) and validation of initial shareholders during contract creation. The Aptos developers were aware of the distribution lockup risk for beneficiaries but did not apply the same safeguard to the initial shareholder list during genesis vesting pool creation.

### Citations

**File:** crates/aptos/src/genesis/tools.rs (L70-82)
```rust
        for employee_pool in employee_vesting_accounts.inner.iter() {
            let stake_pool_address = create_vesting_pool_address(
                employee_pool.validator.owner_account_address.into(),
                employee_pool.validator.operator_account_address.into(),
                0,
                &[],
            );

            employee_address_to_pool.insert(
                employee_pool.validator.owner_account_address.into(),
                stake_pool_address,
            );
        }
```

**File:** aptos-move/framework/aptos-framework/sources/genesis.move (L224-237)
```text
                let account = vector::borrow(&employee_group.accounts, j);
                assert!(
                    !vector::contains(&unique_accounts, account),
                    error::already_exists(EDUPLICATE_ACCOUNT),
                );
                vector::push_back(&mut unique_accounts, *account);

                let employee = create_signer(*account);
                let total = coin::balance<AptosCoin>(*account);
                let coins = coin::withdraw<AptosCoin>(&employee, total);
                simple_map::add(&mut buy_ins, *account, coins);

                j = j + 1;
            };
```

**File:** aptos-move/framework/aptos-framework/sources/vesting.move (L545-567)
```text
    public fun create_vesting_contract(
        admin: &signer,
        shareholders: &vector<address>,
        buy_ins: SimpleMap<address, Coin<AptosCoin>>,
        vesting_schedule: VestingSchedule,
        withdrawal_address: address,
        operator: address,
        voter: address,
        commission_percentage: u64,
        // Optional seed used when creating the staking contract account.
        contract_creation_seed: vector<u8>,
    ): address acquires AdminStore {
        check_vest_permission(admin);
        assert!(
            !system_addresses::is_reserved_address(withdrawal_address),
            error::invalid_argument(EINVALID_WITHDRAWAL_ADDRESS),
        );
        assert_account_is_registered_for_apt(withdrawal_address);
        assert!(vector::length(shareholders) > 0, error::invalid_argument(ENO_SHAREHOLDERS));
        assert!(
            simple_map::length(&buy_ins) == vector::length(shareholders),
            error::invalid_argument(ESHARES_LENGTH_MISMATCH),
        );
```

**File:** aptos-move/framework/aptos-framework/sources/vesting.move (L770-777)
```text
        vector::for_each_ref(shareholders, |shareholder| {
            let shareholder = *shareholder;
            let shares = pool_u64::shares(grant_pool, shareholder);
            let amount = pool_u64::shares_to_amount_with_total_coins(grant_pool, shares, total_distribution_amount);
            let share_of_coins = coin::extract(&mut coins, amount);
            let recipient_address = get_beneficiary(vesting_contract, shareholder);
            aptos_account::deposit_coins(recipient_address, share_of_coins);
        });
```

**File:** aptos-move/framework/aptos-framework/sources/vesting.move (L1029-1031)
```text
        // Verify that the beneficiary account is set up to receive APT. This is a requirement so distribute() wouldn't
        // fail and block all other accounts from receiving APT if one beneficiary is not registered.
        assert_account_is_registered_for_apt(new_beneficiary);
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L128-148)
```text
    public fun deposit_coins<CoinType>(
        to: address, coins: Coin<CoinType>
    ) acquires DirectTransferConfig {
        if (!account::exists_at(to)) {
            create_account(to);
            spec {
                // TODO(fa_migration)
                // assert coin::spec_is_account_registered<AptosCoin>(to);
                // assume aptos_std::type_info::type_of<CoinType>() == aptos_std::type_info::type_of<AptosCoin>() ==>
                //     coin::spec_is_account_registered<CoinType>(to);
            };
        };
        if (!coin::is_account_registered<CoinType>(to)) {
            assert!(
                can_receive_direct_coin_transfers(to),
                error::permission_denied(EACCOUNT_DOES_NOT_ACCEPT_DIRECT_COIN_TRANSFERS)
            );
            coin::register<CoinType>(&create_signer(to));
        };
        coin::deposit<CoinType>(to, coins)
    }
```
