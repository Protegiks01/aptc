# Audit Report

## Title
Unsalted SHA256 Password Hashing in Admin Service Authentication Enables Rainbow Table Attacks

## Summary

The `PasscodeSha256` authentication mechanism in the Aptos Admin Service uses unsalted SHA256 hashes for passcode verification, making it vulnerable to rainbow table and dictionary attacks if configuration files containing the hashed passcodes are leaked. This allows unauthorized access to sensitive validator debugging endpoints that expose consensus state, pending transactions, and internal node operations. [1](#0-0) 

## Finding Description

The Admin Service authentication configuration stores password hashes using raw SHA256 without any salt or key derivation function. When a request arrives, the server hashes the provided plaintext passcode and compares it against the stored hash: [2](#0-1) 

This implementation violates the **Cryptographic Correctness** invariant which requires that "hash operations must be secure." The absence of a salt means:

1. **Rainbow Table Vulnerability**: Pre-computed hash tables for common passwords can instantly crack weak passcodes
2. **Dictionary Attack Efficiency**: Attackers can hash entire dictionaries offline and compare against the leaked hash
3. **No Computational Barrier**: Unlike proper password hashing (bcrypt, Argon2, PBKDF2), there's no iteration count to slow down brute-force attempts

**Attack Scenario:**

1. Attacker obtains the node's configuration file through:
   - Backup system leaks
   - Misconfigured file permissions
   - File disclosure vulnerabilities
   - Compromised adjacent systems
   - Log file exposure

2. Attacker extracts the SHA256 hash from `authentication_configs`

3. For weak passwords (e.g., "admin123", "validator2024"), attacker uses rainbow tables or dictionary attacks to instantly recover the plaintext

4. Attacker authenticates to the admin service and accesses sensitive endpoints: [3](#0-2) 

5. Attacker can now dump:
   - **Consensus database**: Last votes, timeout certificates, blocks, quorum certificates [4](#0-3) 
   
   - **Transaction data from blocks**: All pending and recent transactions [5](#0-4) 
   
   - **Mempool parking lot**: Addresses and transactions being held
   - **CPU profiling and thread dumps**: Attack surface analysis data

On mainnet, this authentication is **mandatory** (empty configs are rejected): [6](#0-5) 

This means all mainnet validators using weak passwords are vulnerable if their config files leak.

## Impact Explanation

**Severity: HIGH** per Aptos Bug Bounty criteria

This vulnerability enables:

1. **Validator Node Slowdowns**: Attacker can abuse profiling endpoints or analyze performance data to plan DoS attacks

2. **Significant Protocol Violations**: Unauthorized access to consensus state violates access control principles

3. **Information Disclosure**: Exposure of:
   - Consensus voting patterns and validator behavior
   - Pending transactions enabling MEV/front-running opportunities
   - Block structure and timing information
   - Internal node state for attack planning

4. **Potential for Follow-on Attacks**: Armed with consensus data and profiling information, attackers can:
   - Identify timing attack vectors
   - Plan targeted consensus disruption
   - Extract pending high-value transactions
   - Profile validator performance characteristics

While this doesn't directly cause consensus safety violations or fund loss, it compromises validator security defenses and exposes sensitive operational data that should remain confidential.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

**Factors Increasing Likelihood:**
- Configuration files are frequently leaked through backups, logs, or misconfigurations
- Weak passwords are common in production deployments
- Rainbow tables for SHA256 are widely available
- No rate limiting on authentication attempts (offline attack once hash is obtained)
- Mandatory on mainnet means all validators are potential targets

**Factors Decreasing Likelihood:**
- Requires initial file system access to obtain config
- Well-secured validators may have proper file permissions
- Strong randomly-generated passwords would resist rainbow tables

However, the cryptographic weakness guarantees that any weak password will be cracked if the config file leaks, making this a realistic attack vector.

## Recommendation

Replace unsalted SHA256 with a proper password hashing function:

```rust
// In Cargo.toml, add:
// argon2 = "0.5"

use argon2::{
    password_hash::{PasswordHash, PasswordHasher, PasswordVerifier, SaltString},
    Argon2
};
use rand_core::OsRng;

#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(rename_all = "snake_case")]
pub enum AuthenticationConfig {
    // Store Argon2 password hash instead of SHA256
    // Format: $argon2id$v=19$m=19456,t=2,p=1$...
    PasscodeArgon2(String),
}

// In server/mod.rs, replace SHA256 verification with:
AuthenticationConfig::PasscodeArgon2(password_hash_str) => {
    let query = req.uri().query().unwrap_or("");
    let query_pairs: HashMap<_, _> =
        url::form_urlencoded::parse(query.as_bytes()).collect();
    let passcode: Option<String> =
        query_pairs.get("passcode").map(|p| p.to_string());
    
    if let Some(passcode) = passcode {
        if let Ok(parsed_hash) = PasswordHash::new(password_hash_str) {
            if Argon2::default()
                .verify_password(passcode.as_bytes(), &parsed_hash)
                .is_ok()
            {
                authenticated = true;
            }
        }
    }
}

// To generate hash for config:
// let salt = SaltString::generate(&mut OsRng);
// let argon2 = Argon2::default();
// let password_hash = argon2.hash_password(b"password", &salt)
//     .unwrap().to_string();
```

**Additional Hardening:**
1. Add password complexity requirements in config validation
2. Document password generation best practices
3. Consider mutual TLS as an alternative authentication method
4. Implement rate limiting on admin endpoints
5. Add audit logging for all admin service access

## Proof of Concept

```rust
// File: test_rainbow_attack.rs
// Demonstrates the vulnerability

use sha256;
use std::collections::HashMap;

fn main() {
    // Simulated leaked config file hash
    let leaked_hash = "ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad";
    
    // Common password dictionary (in real attacks, millions of entries)
    let common_passwords = vec![
        "abc", "password", "admin", "validator", "12345678",
        "aptos123", "node2024", "mainnet", "testnet"
    ];
    
    // Rainbow table attack - instant crack for weak passwords
    for password in common_passwords {
        let hash = sha256::digest(password);
        if hash == leaked_hash {
            println!("ðŸš¨ PASSWORD CRACKED: '{}'", password);
            println!("Attack time: < 1 second");
            println!("Attacker can now access:");
            println!("  - /debug/consensus/consensusdb");
            println!("  - /debug/consensus/block");
            println!("  - /debug/mempool/parking-lot/addresses");
            return;
        }
    }
    
    println!("Password not in dictionary (may be strong)");
}

// Expected output if password is "abc":
// ðŸš¨ PASSWORD CRACKED: 'abc'
// Attack time: < 1 second
// Attacker can now access:
//   - /debug/consensus/consensusdb
//   - /debug/consensus/block
//   - /debug/mempool/parking-lot/addresses
```

**Steps to Reproduce:**
1. Deploy validator with weak admin service password (e.g., "abc")
2. Generate SHA256 hash: `printf "abc" | sha256sum` â†’ `ba7816bf...`
3. Configure in node YAML: `authentication_configs: [passcode_sha256: "ba7816bf..."]`
4. Simulate config file leak (backup exposure, log leak, etc.)
5. Run rainbow table attack against leaked hash
6. Use cracked password to access: `curl "http://validator:9102/debug/consensus/consensusdb?passcode=abc"`
7. Successfully dumps sensitive consensus data

**Notes**

- This vulnerability affects **all mainnet validators** using the admin service (which is mandatory for authentication on mainnet)
- The cryptographic weakness is inherent to unsalted SHA256 - no matter how the password is chosen, if it's in any precomputed table or dictionary, it will be cracked instantly upon config file disclosure
- While strong randomly-generated passwords (32+ characters) would resist rainbow tables, the lack of salt means there's no defense-in-depth for common/weak passwords
- The admin service provides legitimate debugging functionality but its compromise could enable serious follow-on attacks against validator operations

### Citations

**File:** config/src/config/admin_service_config.rs (L26-39)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(rename_all = "snake_case")]
pub enum AuthenticationConfig {
    // This will allow authentication through query parameter.
    // e.g. `/profilez?passcode=abc`.
    //
    // To calculate sha256, use sha256sum tool, or other online tools.
    //
    // e.g.
    //
    // printf abc |sha256sum
    PasscodeSha256(String),
    // TODO(grao): Add SSL support if necessary.
}
```

**File:** config/src/config/admin_service_config.rs (L67-77)
```rust
        if node_config.admin_service.enabled == Some(true) {
            if let Some(chain_id) = chain_id {
                if chain_id.is_mainnet()
                    && node_config.admin_service.authentication_configs.is_empty()
                {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Must enable authentication for AdminService on mainnet.".into(),
                    ));
                }
            }
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L160-171)
```rust
                    AuthenticationConfig::PasscodeSha256(passcode_sha256) => {
                        let query = req.uri().query().unwrap_or("");
                        let query_pairs: HashMap<_, _> =
                            url::form_urlencoded::parse(query.as_bytes()).collect();
                        let passcode: Option<String> =
                            query_pairs.get("passcode").map(|p| p.to_string());
                        if let Some(passcode) = passcode {
                            if sha256::digest(passcode) == *passcode_sha256 {
                                authenticated = true;
                            }
                        }
                    },
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L183-242)
```rust
        match (req.method().clone(), req.uri().path()) {
            #[cfg(target_os = "linux")]
            (hyper::Method::GET, "/profilez") => handle_cpu_profiling_request(req).await,
            #[cfg(target_os = "linux")]
            (hyper::Method::GET, "/threadz") => handle_thread_dump_request(req).await,
            #[cfg(unix)]
            (hyper::Method::GET, "/malloc/stats") => {
                malloc::handle_malloc_stats_request(context.config.malloc_stats_max_len)
            },
            #[cfg(unix)]
            (hyper::Method::GET, "/malloc/dump_profile") => malloc::handle_dump_profile_request(),
            (hyper::Method::GET, "/debug/consensus/consensusdb") => {
                let consensus_db = context.consensus_db.read().clone();
                if let Some(consensus_db) = consensus_db {
                    consensus::handle_dump_consensus_db_request(req, consensus_db).await
                } else {
                    Ok(reply_with_status(
                        StatusCode::NOT_FOUND,
                        "Consensus db is not available.",
                    ))
                }
            },
            (hyper::Method::GET, "/debug/consensus/quorumstoredb") => {
                let quorum_store_db = context.quorum_store_db.read().clone();
                if let Some(quorum_store_db) = quorum_store_db {
                    consensus::handle_dump_quorum_store_db_request(req, quorum_store_db).await
                } else {
                    Ok(reply_with_status(
                        StatusCode::NOT_FOUND,
                        "Quorum store db is not available.",
                    ))
                }
            },
            (hyper::Method::GET, "/debug/consensus/block") => {
                let consensus_db = context.consensus_db.read().clone();
                let quorum_store_db = context.quorum_store_db.read().clone();
                if let Some(consensus_db) = consensus_db
                    && let Some(quorum_store_db) = quorum_store_db
                {
                    consensus::handle_dump_block_request(req, consensus_db, quorum_store_db).await
                } else {
                    Ok(reply_with_status(
                        StatusCode::NOT_FOUND,
                        "Consensus db and/or quorum store db is not available.",
                    ))
                }
            },
            (hyper::Method::GET, "/debug/mempool/parking-lot/addresses") => {
                let mempool_client_sender = context.mempool_client_sender.read().clone();
                if let Some(mempool_client_sender) = mempool_client_sender {
                    mempool::mempool_handle_parking_lot_address_request(req, mempool_client_sender)
                        .await
                } else {
                    Ok(reply_with_status(
                        StatusCode::NOT_FOUND,
                        "Mempool parking lot is not available.",
                    ))
                }
            },
            _ => Ok(reply_with_status(StatusCode::NOT_FOUND, "Not found.")),
```

**File:** crates/aptos-admin-service/src/server/consensus/mod.rs (L130-156)
```rust
fn dump_consensus_db(consensus_db: &dyn PersistentLivenessStorage) -> anyhow::Result<String> {
    let mut body = String::new();

    let (last_vote, highest_tc, consensus_blocks, consensus_qcs) =
        consensus_db.consensus_db().get_data()?;

    body.push_str(&format!("Last vote: \n{last_vote:?}\n\n"));
    body.push_str(&format!("Highest tc: \n{highest_tc:?}\n\n"));
    body.push_str("Blocks: \n");
    for block in consensus_blocks {
        body.push_str(&format!(
            "[id: {:?}, author: {:?}, epoch: {}, round: {:02}, parent_id: {:?}, timestamp: {}, payload: {:?}]\n\n",
            block.id(),
            block.author(),
            block.epoch(),
            block.round(),
            block.parent_id(),
            block.timestamp_usecs(),
            block.payload(),
        ));
    }
    body.push_str("QCs: \n");
    for qc in consensus_qcs {
        body.push_str(&format!("{qc:?}\n\n"));
    }
    Ok(body)
}
```

**File:** crates/aptos-admin-service/src/server/consensus/mod.rs (L217-240)
```rust
fn dump_blocks_bcs(
    consensus_db: &dyn PersistentLivenessStorage,
    quorum_store_db: &dyn QuorumStoreStorage,
    block_id: Option<HashValue>,
) -> anyhow::Result<Vec<u8>> {
    let all_batches = quorum_store_db.get_all_batches()?;

    let (_, _, blocks, _) = consensus_db.consensus_db().get_data()?;

    let mut all_txns = Vec::new();
    for block in blocks {
        let id = block.id();
        if block_id.is_none() || id == block_id.unwrap() {
            match extract_txns_from_block(&block, &all_batches) {
                Ok(txns) => {
                    all_txns.extend(txns.into_iter().cloned().map(Transaction::UserTransaction));
                },
                Err(e) => bail!("Failed to extract txns from block ({id:?}): {e:?}."),
            };
        }
    }

    bcs::to_bytes(&all_txns).map_err(Error::msg)
}
```
