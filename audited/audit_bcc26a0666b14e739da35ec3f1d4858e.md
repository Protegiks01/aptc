# Audit Report

## Title
Data Stream Denial of Service via Undetected Task Panics

## Summary
The `spawn_request_task()` function in the data streaming service spawns async tasks to fetch data from the network but never awaits their `JoinHandle`s. If a spawned task panics, the panic is silently ignored, causing the data stream to block indefinitely while waiting for a response that will never arrive.

## Finding Description
The data streaming service spawns tasks to handle data client requests asynchronously. [1](#0-0) 

When a task is spawned, its `JoinHandle` is stored in the `spawned_tasks` vector [2](#0-1)  but these handles are **never awaited**. Verification confirms no await operations exist on these handles.

If a spawned task panics before setting the response in `pending_response.lock().client_response`, the response remains `None` permanently. The stream processing logic checks for completed responses by verifying if `client_response.is_some()` [3](#0-2) , which will perpetually return `None` for the panicked task, causing the request to never be popped from the queue.

The codebase uses `aptos_infallible::Mutex` which explicitly panics on poisoned locks [4](#0-3) , meaning any panic while holding the mutex will cause subsequent lock attempts to panic as well.

## Impact Explanation
This is a **Low Severity** operational resilience issue:
- **Scope**: Affects individual data streams, not the entire node or consensus
- **Impact**: Single stream becomes permanently blocked, preventing state synchronization on that stream
- **Recovery**: Requires stream or node restart
- **Not a Protocol Violation**: Does not affect consensus safety, deterministic execution, or other critical invariants

Per the Aptos bug bounty criteria, this falls under "Low Severity" as it's a non-critical implementation bug that could cause localized availability issues but doesn't threaten funds, consensus, or network-wide operations.

## Likelihood Explanation
**Very Low Likelihood**:
- The code paths in spawned tasks use async/await with `Result` types, not panic-prone operations
- No obvious attacker-controlled panic triggers exist
- Would require a bug in underlying data client methods or unexpected edge cases
- Normal operation should never trigger panics

However, the codebase elsewhere demonstrates proper panic handling patterns [5](#0-4)  that are not followed here.

## Recommendation
Implement panic detection by awaiting JoinHandles. The spawned tasks should be monitored for panics, and appropriate error handling should be added:

**Option 1**: Await handles periodically and restart failed tasks
**Option 2**: Use `tokio::select!` pattern to monitor task completion
**Option 3**: Wrap task execution with explicit panic catching and error reporting

The codebase shows established patterns for this in other components that should be followed.

## Proof of Concept
Since there is no attacker-controlled panic trigger in the current implementation, a PoC would require artificially injecting a panic via code modification or exploiting an undiscovered bug in the data client methods. The vulnerability is theoretical rather than practically exploitable.

---

**Notes**

This issue represents a **code quality and operational resilience gap** rather than a high-severity security vulnerability. While task panics are properly isolated (one task's panic doesn't crash other tasks), the lack of panic detection creates a failure mode where streams can become permanently stuck. However, this does not meet the Critical/High/Medium severity criteria for the bug bounty program as it:
- Requires unlikely panic conditions with no clear exploit path
- Affects only individual streams, not consensus or network-wide state
- Does not enable funds theft, state corruption, or protocol violations

The issue is accurately classified as **Low** severity per the original question designation.

### Citations

**File:** state-sync/data-streaming-service/src/data_stream.rs (L381-389)
```rust
        let join_handle = spawn_request_task(
            self.data_stream_id,
            data_client_request,
            self.aptos_data_client.clone(),
            pending_client_response.clone(),
            request_timeout_ms,
            self.stream_update_notifier.clone(),
        );
        self.spawned_tasks.push(join_handle);
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L680-693)
```rust
    fn pop_pending_response_queue(&mut self) -> Result<Option<PendingClientResponse>, Error> {
        let sent_data_requests = self.get_sent_data_requests()?;
        let pending_client_response = if let Some(data_request) = sent_data_requests.front() {
            if data_request.lock().client_response.is_some() {
                // We've received a response! Pop the requests off the queue.
                sent_data_requests.pop_front()
            } else {
                None
            }
        } else {
            None
        };
        Ok(pending_client_response)
    }
```

**File:** state-sync/data-streaming-service/src/data_stream.rs (L1397-1507)
```rust
fn spawn_request_task<T: AptosDataClientInterface + Send + Clone + 'static>(
    data_stream_id: DataStreamId,
    data_client_request: DataClientRequest,
    aptos_data_client: T,
    pending_response: PendingClientResponse,
    request_timeout_ms: u64,
    stream_update_notifier: aptos_channel::Sender<(), StreamUpdateNotification>,
) -> JoinHandle<()> {
    // Update the requests sent counter
    increment_counter(
        &metrics::SENT_DATA_REQUESTS,
        data_client_request.get_label(),
    );

    // Spawn the request
    tokio::spawn(async move {
        // Time the request (the timer will stop when it's dropped)
        let _timer = start_timer(
            &metrics::DATA_REQUEST_PROCESSING_LATENCY,
            data_client_request.get_label().into(),
        );

        // Fetch the client response
        let client_response = match data_client_request {
            DataClientRequest::EpochEndingLedgerInfos(request) => {
                get_epoch_ending_ledger_infos(aptos_data_client, request, request_timeout_ms).await
            },
            DataClientRequest::NewTransactionsWithProof(request) => {
                get_new_transactions_with_proof(aptos_data_client, request, request_timeout_ms)
                    .await
            },
            DataClientRequest::NewTransactionOutputsWithProof(request) => {
                get_new_transaction_outputs_with_proof(
                    aptos_data_client,
                    request,
                    request_timeout_ms,
                )
                .await
            },
            DataClientRequest::NewTransactionsOrOutputsWithProof(request) => {
                get_new_transactions_or_outputs_with_proof(
                    aptos_data_client,
                    request,
                    request_timeout_ms,
                )
                .await
            },
            DataClientRequest::NumberOfStates(request) => {
                get_number_of_states(aptos_data_client, request, request_timeout_ms).await
            },
            DataClientRequest::StateValuesWithProof(request) => {
                get_states_values_with_proof(aptos_data_client, request, request_timeout_ms).await
            },
            DataClientRequest::SubscribeTransactionsWithProof(request) => {
                subscribe_to_transactions_with_proof(aptos_data_client, request, request_timeout_ms)
                    .await
            },
            DataClientRequest::SubscribeTransactionOutputsWithProof(request) => {
                subscribe_to_transaction_outputs_with_proof(
                    aptos_data_client,
                    request,
                    request_timeout_ms,
                )
                .await
            },
            DataClientRequest::SubscribeTransactionsOrOutputsWithProof(request) => {
                subscribe_to_transactions_or_outputs_with_proof(
                    aptos_data_client,
                    request,
                    request_timeout_ms,
                )
                .await
            },
            DataClientRequest::TransactionOutputsWithProof(request) => {
                get_transaction_outputs_with_proof(aptos_data_client, request, request_timeout_ms)
                    .await
            },
            DataClientRequest::TransactionsWithProof(request) => {
                get_transactions_with_proof(aptos_data_client, request, request_timeout_ms).await
            },
            DataClientRequest::TransactionsOrOutputsWithProof(request) => {
                get_transactions_or_outputs_with_proof(
                    aptos_data_client,
                    request,
                    request_timeout_ms,
                )
                .await
            },
        };

        // Increment the appropriate counter depending on the response
        match &client_response {
            Ok(response) => {
                increment_counter(
                    &metrics::RECEIVED_DATA_RESPONSE,
                    response.payload.get_label(),
                );
            },
            Err(error) => {
                increment_counter(&metrics::RECEIVED_RESPONSE_ERROR, error.get_label());
            },
        }

        // Save the response
        pending_response.lock().client_response = Some(client_response);

        // Send a notification via the stream update notifier
        let stream_update_notification = StreamUpdateNotification::new(data_stream_id);
        let _ = stream_update_notifier.push((), stream_update_notification);
    })
}
```

**File:** crates/aptos-infallible/src/mutex.rs (L19-23)
```rust
    pub fn lock(&self) -> MutexGuard<'_, T> {
        self.0
            .lock()
            .expect("Cannot currently handle a poisoned lock")
    }
```

**File:** crates/indexer/src/indexer/tailer.rs (L291-303)
```rust
pub async fn await_tasks<T: Debug>(tasks: Vec<JoinHandle<T>>) -> Vec<T> {
    let mut results = vec![];
    for task in tasks {
        let result = task.await;
        match result {
            Ok(_) => results.push(result.unwrap()),
            Err(err) => {
                panic!("Error joining task: {:?}", err);
            },
        }
    }
    results
}
```
