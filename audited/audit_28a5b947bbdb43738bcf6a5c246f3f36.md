# Audit Report

## Title
Critical Backward Compatibility Failure in TransactionPayload::ModuleBundle BCS Deserialization

## Summary
The `TransactionPayload::ModuleBundle` enum variant was changed from containing a `ModuleBundle` struct to a `DeprecatedPayload` struct, creating a BCS serialization format incompatibility that prevents correct deserialization of any historical ModuleBundle transactions stored in AptosDB.

## Finding Description

The `TransactionPayload` enum's `ModuleBundle` variant underwent a breaking change in its internal type structure: [1](#0-0) 

The variant now contains `DeprecatedPayload` instead of the original `ModuleBundle` type: [2](#0-1) 

However, the original `ModuleBundle` struct still exists with its `Vec<Module>` field: [3](#0-2) 

**BCS Format Incompatibility:**

The old `ModuleBundle` serializes as: enum_variant(01) + ULEB128(vec_length) + [ULEB128(code_length) + bytes...]

The new `DeprecatedPayload` serializes as: enum_variant(01) + 8_bytes(u64)

These formats are **completely incompatible**. When the storage layer deserializes a historical transaction, it uses BCS: [4](#0-3) 

Transactions are stored and retrieved from the database using this schema: [5](#0-4) 

When attempting to deserialize an old ModuleBundle transaction (e.g., test vector showing format): [6](#0-5) 

The BCS deserializer will try to read the ULEB128 vector length and module bytecode as an 8-byte u64, producing either garbage data or a deserialization error.

This breaks the **State Consistency** and **Deterministic Execution** invariants - nodes cannot correctly retrieve their own historical transaction data.

## Impact Explanation

**Critical Severity** - This issue causes:

1. **State Sync Failures**: New validators syncing historical blocks containing ModuleBundle transactions will encounter deserialization errors, preventing network participation
2. **Backup/Restore Corruption**: Database backups cannot be correctly restored if they contain ModuleBundle transactions  
3. **API Service Disruption**: Historical transaction queries will fail with deserialization errors
4. **Block Replay Impossibility**: Any debugging, verification, or audit requiring replay of historical blocks will fail
5. **Non-Deterministic Behavior**: Different nodes may handle deserialization failures differently, potentially causing consensus divergence

## Likelihood Explanation

**MEDIUM-to-HIGH** likelihood depending on mainnet state:

- ModuleBundle was a supported transaction type before deprecation
- Test vectors demonstrate the format was actively used
- No migration path or format versioning is implemented in the deserialization logic
- Any operation touching historical data (state sync, API queries, backups) will trigger the incompatibility
- The serialization format specification explicitly documents ModuleBundle as variant 1: [7](#0-6) 

## Recommendation

**Immediate Fix**: Implement backward-compatible deserialization using an untagged enum or custom deserializer:

```rust
// In types/src/transaction/mod.rs
#[derive(Clone, Debug, Hash, Eq, PartialEq)]
pub enum ModuleBundleCompat {
    Legacy(ModuleBundle),  // For old transactions
    Deprecated(DeprecatedPayload),  // For new format
}

// Implement custom Deserialize that tries ModuleBundle first,
// falls back to DeprecatedPayload if that fails
```

Alternatively, revert the TransactionPayload enum to use the original ModuleBundle type until a proper migration is implemented.

**Long-term**: Implement transaction format versioning at the storage layer to handle format evolution safely.

## Proof of Concept

```rust
// Demonstrates the incompatibility
use bcs;
use aptos_types::transaction::{TransactionPayload, Module, ModuleBundle};

#[test]
fn test_module_bundle_backward_compatibility() {
    // Create an old-format ModuleBundle transaction
    let module = Module::new(vec![0xa1, 0xb2, 0xc3, 0xd4]);
    let bundle = ModuleBundle::singleton(vec![0xa1, 0xb2, 0xc3, 0xd4]);
    let old_payload = TransactionPayload::ModuleBundle(bundle);
    
    // Serialize with old format
    let serialized = bcs::to_bytes(&old_payload).unwrap();
    
    // Attempt to deserialize with new code expecting DeprecatedPayload
    // This will either:
    // 1. Fail with BCS error "unexpected end of input" or "invalid length"
    // 2. Succeed but interpret Vec bytes as garbage u64
    let result: Result<TransactionPayload, _> = bcs::from_bytes(&serialized);
    
    // Deserialization will fail or produce incorrect data
    assert!(result.is_err() || result.unwrap() != old_payload);
}
```

**Notes:**
- The vulnerability is confirmed by examining BCS format specifications and serialization code
- Impact is severe if ModuleBundle transactions exist in mainnet history
- The issue affects all storage retrieval paths including state sync, APIs, and backups
- No migration or versioning strategy is evident in the codebase

### Citations

**File:** types/src/transaction/mod.rs (L680-686)
```rust
/// Marks payload as deprecated. We need to use it to ensure serialization or
/// deserialization is not broken.
#[derive(Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct DeprecatedPayload {
    // Used because 'analyze_serde_formats' complains with "Please avoid 0-sized containers".
    dummy_value: u64,
}
```

**File:** types/src/transaction/mod.rs (L688-706)
```rust
/// Different kinds of transactions.
#[derive(Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub enum TransactionPayload {
    /// A transaction that executes code.
    Script(Script),
    /// Deprecated.
    ModuleBundle(DeprecatedPayload),
    /// A transaction that executes an existing entry function published on-chain.
    EntryFunction(EntryFunction),
    /// A multisig transaction that allows an owner of a multisig account to execute a pre-approved
    /// transaction as the multisig account.
    Multisig(Multisig),
    /// A new transaction payload format with support for versioning.
    /// Contains an executable (script/entry function) along with extra configuration.
    /// Once this new format is fully rolled out, above payload variants will be deprecated.
    Payload(TransactionPayloadInner),
    /// Represents an encrypted transaction payload
    EncryptedPayload(EncryptedPayload),
}
```

**File:** types/src/transaction/module.rs (L36-39)
```rust
#[derive(Clone, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct ModuleBundle {
    codes: Vec<Module>,
}
```

**File:** storage/aptosdb/src/schema/transaction/mod.rs (L38-46)
```rust
impl ValueCodec<TransactionSchema> for Transaction {
    fn encode_value(&self) -> Result<Vec<u8>> {
        bcs::to_bytes(self).map_err(Into::into)
    }

    fn decode_value(data: &[u8]) -> Result<Self> {
        bcs::from_bytes(data).map_err(Into::into)
    }
}
```

**File:** storage/aptosdb/src/ledger_db/transaction_db.rs (L55-60)
```rust
    /// Returns signed transaction given its `version`.
    pub(crate) fn get_transaction(&self, version: Version) -> Result<Transaction> {
        self.db
            .get::<TransactionSchema>(&version)?
            .ok_or_else(|| AptosDbError::NotFound(format!("Txn {version}")))
    }
```

**File:** api/goldens/aptos_api__tests__transaction_vector_test__test_module_payload.json (L1-21)
```json
[
  {
    "raw_txn": {
      "sender": "d55b6ed3089b0eb2a641c30fabd04488fb4743febc3dfd95de69faea7aa5b41e",
      "sequence_number": "11722517697329774649",
      "payload": {
        "ModuleBundle": {
          "codes": [
            {
              "code": "d14669faf5d7bcc3e0ef6f2b5fbf4e"
            }
          ]
        }
      },
      "max_gas_amount": "14057401883609972008",
      "gas_unit_price": "4814525683344330979",
      "expiration_timestamp_secs": "9122460542287889699",
      "chain_id": 163
    },
    "signed_txn_bcs": "d55b6ed3089b0eb2a641c30fabd04488fb4743febc3dfd95de69faea7aa5b41e394092b6bcbfaea201010fd14669faf5d7bcc3e0ef6f2b5fbf4e28bd7aa988ec15c3e3d0bbbd99a1d042234596c4877d997ea3002020fdbac9b10b7587bba7b5bc163bce69e796d71e4ed44c10fcb4488689f7a144404ca3f1b7885a13ae41590c5122e24d5aa83bcd0f789c8179e2e2466bb40f3af6b10540b094aff0f05f27bee59fc636c1c6d8ca0567694005b0dc259503c47f0f",
    "private_key": "76b8e0ada0f13d90405d6ae55386bd28bdd219b8a08ded1aa836efcc8b770dc7"
```

**File:** testsuite/generate-format/tests/staged/aptos.yaml (L804-829)
```yaml
TransactionPayload:
  ENUM:
    0:
      Script:
        NEWTYPE:
          TYPENAME: Script
    1:
      ModuleBundle:
        NEWTYPE:
          TYPENAME: DeprecatedPayload
    2:
      EntryFunction:
        NEWTYPE:
          TYPENAME: EntryFunction
    3:
      Multisig:
        NEWTYPE:
          TYPENAME: Multisig
    4:
      Payload:
        NEWTYPE:
          TYPENAME: TransactionPayloadInner
    5:
      EncryptedPayload:
        NEWTYPE:
          TYPENAME: EncryptedPayload
```
