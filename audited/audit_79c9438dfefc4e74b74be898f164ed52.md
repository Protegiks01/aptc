# Audit Report

## Title
EntryFunctionFilter Validation Bypass Allows Unrestricted Transaction Data Access in Indexer-gRPC Service

## Summary
The `EntryFunctionFilter` struct can be instantiated with all three fields (`address`, `module`, `function`) set to `None`, bypassing intended validation and matching all entry function transactions indiscriminately. This occurs because validation is never enforced when filters are constructed from protobuf messages, allowing unauthorized data access and potential service degradation in the indexer-gRPC system.

## Finding Description

The `EntryFunctionFilter` implements validation logic to ensure at least one field is set: [1](#0-0) 

However, this validation is **never enforced** during filter construction from protobuf. The `BooleanTransactionFilter::new_from_proto()` method, which is the entry point for creating filters from client requests, does not call validation: [2](#0-1) 

The `From` implementation for `EntryFunctionFilter` from protobuf also bypasses validation: [3](#0-2) 

When all three fields are `None`, the `matches()` method returns `true` for all entry functions due to the `Option<T>` trait implementation where `None` matches anything: [4](#0-3) 

The matching logic in `EntryFunctionFilter` then evaluates as follows: [5](#0-4) 

With all fields `None`: line 192 passes (`None` matches anything), line 196 evaluates to `false` (both checks fail), and line 210 returns `true` unconditionally.

**Attack Path:**
1. Attacker constructs a gRPC `GetTransactionsRequest` with an `EntryFunctionFilter` where all fields are omitted/None
2. The filter is parsed via `parse_transaction_filter`: [6](#0-5) 

3. No validation is performed during construction
4. The filter is used directly in the data service: [7](#0-6) 

5. The malformed filter matches **all** entry function transactions, allowing unrestricted data access

**Secondary Bug:** Line 196 contains a logic error - it checks `self.function.is_some()` twice instead of checking `self.module.is_some()`, causing filters with only `module` set to also match all transactions.

## Impact Explanation

**Severity: Medium**

This vulnerability meets the Medium severity criteria per Aptos bug bounty guidelines:

1. **Information Disclosure**: Clients can access transaction data beyond their intended filter scope, potentially exposing sensitive entry function calls they should not see
2. **Resource Exhaustion**: Attackers can request all transactions using a malformed all-None filter, causing excessive bandwidth consumption and indexer service degradation
3. **Service Availability**: The indexer-gRPC service could experience performance degradation or crashes from processing overly broad filter requests

**Important Note:** This vulnerability is limited to the **indexer-gRPC service** only. It does NOT affect:
- Consensus layer or blockchain safety
- Validator nodes
- On-chain state or fund security
- Core blockchain operations

The indexer-gRPC is an auxiliary off-chain data service that provides filtered transaction streams to clients. While this is a legitimate security issue, it does not compromise the blockchain's core integrity.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is trivial to exploit:
- No authentication or special privileges required beyond normal gRPC client access
- Attack requires only omitting fields in a protobuf message
- The protobuf schema allows all fields to be optional: [8](#0-7) 

- No rate limiting or anomaly detection prevents abuse
- The bug is structural (missing validation enforcement) rather than edge-case behavior

## Recommendation

**Immediate Fix:** Enforce validation in `BooleanTransactionFilter::new_from_proto()`:

```rust
pub fn new_from_proto(
    proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
    max_filter_size: Option<usize>,
) -> Result<Self> {
    if let Some(max_filter_size) = max_filter_size {
        ensure!(
            proto_filter.encoded_len() <= max_filter_size,
            format!(
                "Filter is too complicated. Max size: {} bytes, Actual size: {} bytes",
                max_filter_size,
                proto_filter.encoded_len()
            )
        );
    }
    let filter = match proto_filter
        .filter
        .ok_or(anyhow!("Oneof is not set in BooleanTransactionFilter."))?
    {
        // ... existing match arms ...
    };
    
    // ADD THIS VALIDATION
    filter.is_valid().map_err(|e| anyhow!("Invalid filter: {}", e))?;
    
    Ok(filter)
}
```

**Secondary Fix:** Correct the logic bug at line 196:

```rust
// Change from:
if self.address.is_some() || self.function.is_some() {
// To:
if self.address.is_some() || self.module.is_some() {
```

## Proof of Concept

```rust
#[cfg(test)]
mod exploit_test {
    use super::*;
    use aptos_protos::indexer::v1::{
        ApiFilter, BooleanTransactionFilter as ProtoBooleanTransactionFilter,
        EntryFunctionFilter as ProtoEntryFunctionFilter,
        UserTransactionFilter as ProtoUserTransactionFilter,
        UserTransactionPayloadFilter as ProtoUserTransactionPayloadFilter,
        boolean_transaction_filter, api_filter,
    };
    use aptos_transaction_filter::BooleanTransactionFilter;

    #[test]
    fn test_all_none_filter_bypass() {
        // Construct a protobuf EntryFunctionFilter with all fields None
        let proto_entry_filter = ProtoEntryFunctionFilter {
            address: None,
            module_name: None,
            function: None,
        };
        
        let proto_payload_filter = ProtoUserTransactionPayloadFilter {
            entry_function_filter: Some(proto_entry_filter),
        };
        
        let proto_user_filter = ProtoUserTransactionFilter {
            sender: None,
            payload_filter: Some(proto_payload_filter),
        };
        
        let proto_api_filter = ApiFilter {
            filter: Some(api_filter::Filter::UserTransactionFilter(proto_user_filter)),
        };
        
        let proto_boolean_filter = ProtoBooleanTransactionFilter {
            filter: Some(boolean_transaction_filter::Filter::ApiFilter(proto_api_filter)),
        };
        
        // This should fail validation but doesn't!
        let filter = BooleanTransactionFilter::new_from_proto(proto_boolean_filter, None);
        assert!(filter.is_ok(), "Filter was created despite all fields being None");
        
        // The filter will now match ALL entry functions
        // Demonstrating the security bypass
        let created_filter = filter.unwrap();
        
        // Attempting to validate AFTER creation reveals the issue
        let validation_result = created_filter.is_valid();
        assert!(validation_result.is_err(), "Validation should fail but filter was already created");
    }
}
```

**Notes**

This vulnerability is specific to the indexer-gRPC service infrastructure and does not affect Aptos blockchain consensus, state integrity, or validator operations. While the security impact is real (unauthorized data access and service degradation), it is confined to the off-chain indexing layer. The fix is straightforward: enforce validation at filter construction time rather than relying on optional post-construction validation.

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L155-168)
```rust
impl From<aptos_protos::indexer::v1::EntryFunctionFilter> for EntryFunctionFilter {
    fn from(proto_filter: aptos_protos::indexer::v1::EntryFunctionFilter) -> Self {
        Self {
            standardized_address: OnceCell::with_value(
                proto_filter
                    .address
                    .as_ref()
                    .map(|address| standardize_address(address)),
            ),
            address: proto_filter.address,
            module: proto_filter.module_name,
            function: proto_filter.function,
        }
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L183-188)
```rust
    fn validate_state(&self) -> Result<(), FilterError> {
        if self.address.is_none() && self.module.is_none() && self.function.is_none() {
            return Err(anyhow!("At least one of address, name or function must be set").into());
        };
        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L191-211)
```rust
    fn matches(&self, module_id: &EntryFunctionId) -> bool {
        if !self.function.matches(&module_id.name) {
            return false;
        }

        if self.address.is_some() || self.function.is_some() {
            if let Some(module) = &module_id.module.as_ref() {
                if !(self
                    .get_standardized_address()
                    .matches(&standardize_address(&module.address))
                    && self.module.matches(&module.name))
                {
                    return false;
                }
            } else {
                return false;
            }
        }

        true
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L94-127)
```rust
    pub fn new_from_proto(
        proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
        max_filter_size: Option<usize>,
    ) -> Result<Self> {
        if let Some(max_filter_size) = max_filter_size {
            ensure!(
                proto_filter.encoded_len() <= max_filter_size,
                format!(
                    "Filter is too complicated. Max size: {} bytes, Actual size: {} bytes",
                    max_filter_size,
                    proto_filter.encoded_len()
                )
            );
        }
        Ok(
            match proto_filter
                .filter
                .ok_or(anyhow!("Oneof is not set in BooleanTransactionFilter."))?
            {
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::ApiFilter(
                    api_filter,
                ) => TryInto::<APIFilter>::try_into(api_filter)?.into(),
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::LogicalAnd(
                    logical_and,
                ) => BooleanTransactionFilter::And(logical_and.try_into()?),
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::LogicalOr(
                    logical_or,
                ) => BooleanTransactionFilter::Or(logical_or.try_into()?),
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::LogicalNot(
                    logical_not,
                ) => BooleanTransactionFilter::Not(logical_not.try_into()?),
            },
        )
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/traits.rs (L108-121)
```rust
impl Filterable<String> for Option<String> {
    #[inline]
    fn validate_state(&self) -> Result<(), FilterError> {
        Ok(())
    }

    #[inline]
    fn matches(&self, item: &String) -> bool {
        match self {
            Some(filter) => filter == item,
            None => true,
        }
    }
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs (L9-15)
```rust
pub fn parse_transaction_filter(
    proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
    max_filter_size_bytes: usize,
) -> Result<BooleanTransactionFilter, Status> {
    BooleanTransactionFilter::new_from_proto(proto_filter, Some(max_filter_size_bytes))
        .map_err(|e| Status::invalid_argument(format!("Invalid transaction_filter: {e:?}.")))
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/in_memory_cache.rs (L88-94)
```rust
                if let Some(transaction) = data_manager.get_data(version).as_ref() {
                    // NOTE: We allow 1 more txn beyond the size limit here, for simplicity.
                    if filter.is_none() || filter.as_ref().unwrap().matches(transaction) {
                        total_bytes += transaction.encoded_len();
                        result.push(transaction.as_ref().clone());
                    }
                    version += 1;
```

**File:** protos/proto/aptos/indexer/v1/filter.proto (L23-27)
```text
message EntryFunctionFilter {
  optional string address = 1;
  optional string module_name  = 2;
  optional string function = 3;
}
```
