# Audit Report

## Title
BlockSTMv1 Resource Group Write Missing Value Change Detection Causing Consensus Safety Violations

## Summary
The `write()` function in `versioned_group_data.rs` fails to detect when resource group values change between transaction incarnations if the tags and size remain unchanged. This causes dependent transactions to avoid re-validation, leading to state inconsistency and potential consensus splits. [1](#0-0) 

## Finding Description

The vulnerability exists in BlockSTMv1's resource group write logic. The `write()` function determines whether suffix re-validation is required by checking only two conditions:

1. **New tags written**: Detected at line 640 via `ret_v1 |= !prev_tags.remove(&tag)` [2](#0-1) 

2. **Size changed**: Detected in the size comparison block [3](#0-2) 

**Critical Missing Check**: The function does NOT verify if the VALUES for existing tags have changed. This is in stark contrast to BlockSTMv2's approach, which compares values using `compare_values_and_layouts()`: [4](#0-3) 

**Attack Scenario:**

1. Transaction T10 executes incarnation 0, writes resource group G with tags {A, B}, values {V1_A, V1_B}, size S1
2. `write()` returns true (new tags), `needs_suffix_validation` is set
3. Transaction T5 re-executes, reads G.A from T10 incarnation 0 (value V1_A), validates successfully
4. Transaction T10 re-executes incarnation 1 due to upstream dependency change
5. T10 writes tags {A, B} with DIFFERENT values {V2_A, V2_B}, SAME size S1
6. `write()` is called with `prev_tags = {A, B}` (from incarnation 0's write set) [5](#0-4) 

7. Line 640: `ret_v1` stays false (all tags in `prev_tags`)
8. Size comparison: S1 == S1 (no change)
9. `write()` returns FALSE
10. `needs_suffix_validation` remains false, `decrease_validation_idx()` is NOT called [6](#0-5) 

11. T5 is NOT scheduled for re-validation (validation_idx not decreased) [7](#0-6) 

12. T5 commits with stale value V1_A (from incarnation 0)
13. T10 commits with incarnation 1 (values V2_A, V2_B)
14. **STATE INCONSISTENCY**: T5 executed with V1_A but final committed state has V2_A

This violates the **Deterministic Execution** invariant: different validators executing transactions in different orders may observe different intermediate states, leading to different final state roots and consensus splits.

## Impact Explanation

**Severity: CRITICAL** - Consensus/Safety Violation

This vulnerability directly breaks consensus safety by allowing non-deterministic execution:

1. **Consensus Splits**: Validators with different execution orderings will produce different state roots for the same block, causing chain forks
2. **State Inconsistency**: Committed transactions may observe incorrect intermediate state values
3. **Determinism Violation**: The fundamental BlockSTM guarantee that identical blocks produce identical state is broken

The impact qualifies as **Critical** per Aptos Bug Bounty criteria:
- "Consensus/Safety violations" (up to $1,000,000)
- Requires no validator privileges or collusion
- Affects all nodes running BlockSTMv1
- Can cause non-recoverable consensus divergence requiring manual intervention

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability will occur whenever:
1. BlockSTMv1 is enabled (still actively used per configuration) [8](#0-7) 

2. A transaction writes to a resource group multiple times across different incarnations
3. The values change but the tags and size remain constant
4. Another transaction has read from an earlier incarnation and already validated

This is a common scenario in parallel execution:
- Transactions frequently re-execute due to dependency changes
- Resource groups often maintain the same structure (tags/size) while updating values
- Parallel validation means reads and writes can be interleaved

No special attacker capabilities required - normal transaction execution patterns trigger this.

## Recommendation

**Solution**: Check for value changes in addition to tag and size changes.

The `write()` function should compare the new values against previously written values (similar to BlockSTMv2's approach) and return true if any value has changed. This can be done by:

1. **Option 1** (Conservative): Always return true when incarnation > 0 and prev_tags is non-empty, forcing re-validation on any re-execution
2. **Option 2** (Precise): Compare new values against the previous incarnation's values in the multi-version map before returning

Recommended fix (Option 1 - simpler and safer):

```rust
pub fn write(
    &self,
    group_key: K,
    txn_idx: TxnIndex,
    incarnation: Incarnation,
    values: impl IntoIterator<Item = (T, (V, Option<Arc<MoveTypeLayout>>))>,
    size: ResourceGroupSize,
    prev_tags: HashSet<T>,
) -> Result<bool, PanicError> {
    // ... existing code ...
    
    let (mut ret, _) = self.data_write_impl::<false>(
        &group_key,
        txn_idx,
        incarnation,
        values,
        prev_tags.iter().collect(),
    )?;
    
    // NEW: If this is a re-execution with existing tags, force re-validation
    // since values may have changed even if tags and size haven't
    if incarnation > 0 && !prev_tags.is_empty() {
        ret = true;
    }
    
    // ... rest of existing code ...
}
```

**Long-term**: Migrate to BlockSTMv2 which properly handles value comparison via push-validation.

## Proof of Concept

```rust
#[test]
fn test_value_change_without_tag_or_size_change() {
    use aptos_move::mvhashmap::{
        versioned_group_data::VersionedGroupData,
        types::test::{KeyType, TestValue},
    };
    use aptos_vm_types::resolver::ResourceGroupSize;
    use std::collections::HashSet;
    
    let group_key = KeyType(b"/group/test".to_vec());
    let map = VersionedGroupData::<KeyType<Vec<u8>>, usize, TestValue>::empty();
    
    // Initialize group
    map.set_raw_base_values(group_key.clone(), vec![]).unwrap();
    
    let tag_a = 0usize;
    let tag_b = 1usize;
    let tags_set: HashSet<usize> = vec![tag_a, tag_b].into_iter().collect();
    let size = ResourceGroupSize::Combined {
        num_tagged_resources: 2,
        all_tagged_resources_size: 20,
    };
    
    // Transaction 10, incarnation 0: Write values V1
    let write_ret_inc0 = map.write(
        group_key.clone(),
        10,
        0,
        vec![
            (tag_a, (TestValue::creation_with_len(10), None)),
            (tag_b, (TestValue::creation_with_len(10), None)),
        ],
        size,
        HashSet::new(),
    ).unwrap();
    assert!(write_ret_inc0, "First write should return true");
    
    // Transaction 5 reads from T10 incarnation 0
    let (version, value) = map.fetch_tagged_data_no_record(&group_key, &tag_a, 5).unwrap();
    assert_eq!(version, Ok((10, 0)));
    
    // Transaction 10, incarnation 1: Write DIFFERENT values V2, SAME size
    let write_ret_inc1 = map.write(
        group_key.clone(),
        10,
        1,
        vec![
            (tag_a, (TestValue::creation_with_len(20), None)), // Different value!
            (tag_b, (TestValue::creation_with_len(20), None)), // Different value!
        ],
        size, // Same size
        tags_set.clone(), // All tags from previous incarnation
    ).unwrap();
    
    // VULNERABILITY: write() returns FALSE even though values changed!
    assert_eq!(write_ret_inc1, false, "BUG: write() returns false despite value change");
    
    // Transaction 5 would not be re-validated, commits with stale data
    // Final state has V2 values but T5 executed with V1 values
    // This is a STATE INCONSISTENCY
}
```

## Notes

This vulnerability only affects BlockSTMv1. BlockSTMv2 uses a different validation mechanism (`write_v2`) that properly compares values via `split_off_affected_read_dependencies()` and `compare_values_and_layouts()`. Organizations should prioritize migration to BlockSTMv2 or apply the recommended fix to BlockSTMv1's `write()` function.

### Citations

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L206-259)
```rust
    pub fn write(
        &self,
        group_key: K,
        txn_idx: TxnIndex,
        incarnation: Incarnation,
        values: impl IntoIterator<Item = (T, (V, Option<Arc<MoveTypeLayout>>))>,
        size: ResourceGroupSize,
        prev_tags: HashSet<T>,
    ) -> Result<bool, PanicError> {
        let mut group_sizes = self.group_sizes.get_mut(&group_key).ok_or_else(|| {
            // Due to read-before-write.
            code_invariant_error("Group (sizes) must be initialized to write to")
        })?;
        let (mut ret, _) = self.data_write_impl::<false>(
            &group_key,
            txn_idx,
            incarnation,
            values,
            prev_tags.iter().collect(),
        )?;

        if !(group_sizes.size_has_changed && ret) {
            let (size_changed, update_flag) = Self::get_latest_entry(
                &group_sizes.size_entries,
                txn_idx,
                ReadPosition::AfterCurrentTxn,
            )
            .ok_or_else(|| {
                code_invariant_error("Initialized group sizes must contain storage version")
            })
            .map(|(idx, prev_size)| {
                (
                    prev_size.value.size != size,
                    // Update the size_has_changed flag if the entry isn't the base value
                    // (which may be non-existent) or if the incarnation > 0.
                    *idx != ShiftedTxnIndex::zero_idx() || incarnation > 0,
                )
            })?;

            if size_changed {
                ret = true;
                if update_flag {
                    group_sizes.size_has_changed = true;
                }
            }
        }

        group_sizes.size_entries.insert(
            ShiftedTxnIndex::new(txn_idx),
            SizeEntry::new(SizeAndDependencies::from_size(size)),
        );

        Ok(ret)
    }
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L635-641)
```rust
            for (tag, (value, layout)) in values.into_iter() {
                if !superset_tags.contains(&tag) {
                    tags_to_write.push(tag.clone());
                }

                ret_v1 |= !prev_tags.remove(&tag);

```

**File:** aptos-move/mvhashmap/src/versioned_data.rs (L382-404)
```rust
fn compare_values_and_layouts<
    const ONLY_COMPARE_METADATA: bool,
    V: TransactionWrite + PartialEq,
>(
    prev_value: &V,
    new_value: &V,
    prev_maybe_layout: Option<&Arc<MoveTypeLayout>>,
    new_maybe_layout: Option<&Arc<MoveTypeLayout>>,
) -> bool {
    // ONLY_COMPARE_METADATA is a const static flag that indicates that these entries are
    // versioning metadata only, and not the actual value (Currently, only used for versioning
    // resource group metadata). Hence, validation is only performed on the metadata.
    if ONLY_COMPARE_METADATA {
        prev_value.as_state_value_metadata() == new_value.as_state_value_metadata()
    } else {
        // Layouts pass validation only if they are both None. Otherwise, validation pessimistically
        // fails. This is a simple logic that avoids potentially costly layout comparisons.
        prev_maybe_layout.is_none() && new_maybe_layout.is_none() && prev_value == new_value
    }
    // TODO(BlockSTMv2): optimize layout validation (potentially based on size, or by having
    // a more efficient representation. Optimizing value validation by having a configurable
    // size threshold above which validation can automatically pessimistically fail.
}
```

**File:** aptos-move/block-executor/src/executor.rs (L612-618)
```rust
                let prev_tags = prev_modified_group_keys
                    .remove(&group_key)
                    .unwrap_or_else(|| {
                        // Previously no write to the group at all.
                        needs_suffix_validation = true;
                        HashSet::new()
                    });
```

**File:** aptos-move/block-executor/src/executor.rs (L629-638)
```rust
                if versioned_cache.group_data().write(
                    group_key,
                    idx_to_execute,
                    incarnation,
                    group_ops.into_iter(),
                    group_size,
                    prev_tags,
                )? {
                    needs_suffix_validation = true;
                }
```

**File:** aptos-move/block-executor/src/scheduler.rs (L576-583)
```rust
            if revalidate_suffix {
                // The transaction execution required revalidating all higher txns (not
                // only itself), currently happens when incarnation writes to a new path
                // (w.r.t. the write-set of its previous completed incarnation).
                if let Some(wave) = self.decrease_validation_idx(txn_idx + 1) {
                    cur_wave = wave;
                };
            }
```

**File:** types/src/block_executor/config.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use crate::on_chain_config::BlockGasLimitType;
use serde::{Deserialize, Serialize};

const DEFAULT_GAS_PRICE_TO_BURN: u64 = 90;

/// Local, per-node configurations for module cache. While caches can be persisted across multiple
/// block executions, these configurations allow to specify cache sizes, etc.
#[derive(Clone, Debug)]
pub struct BlockExecutorModuleCacheLocalConfig {
    /// If true, when global caches are empty, Aptos framework is prefetched into module cache.
    pub prefetch_framework_code: bool,
    /// The maximum size of module cache (the sum of serialized sizes of all cached modules in
    /// bytes).
    pub max_module_cache_size_in_bytes: usize,
    /// The maximum size (in terms of entries) of struct name re-indexing map stored in the runtime
    /// environment.
    pub max_struct_name_index_map_num_entries: usize,
    /// The maximum number of types to intern.
    pub max_interned_tys: usize,
    /// The maximum number of type vectors to intern.
    pub max_interned_ty_vecs: usize,
    /// The maximum number of layout entries.
    pub max_layout_cache_size: usize,
    /// The maximum number of module IDs to intern.
    pub max_interned_module_ids: usize,
}

impl Default for BlockExecutorModuleCacheLocalConfig {
    fn default() -> Self {
        Self {
            prefetch_framework_code: true,
            // Use 1Gb for now, should be large enough to cache all mainnet modules (at the time
            // of writing this comment, 13.11.24).
            max_module_cache_size_in_bytes: 1024 * 1024 * 1024,
            max_struct_name_index_map_num_entries: 1_000_000,
            // Each entry is 4 + 2 * 8 = 20 bytes. This allows ~200 Mb of distinct types.
            max_interned_tys: 10 * 1024 * 1024,
            // Use slightly less for vectors of types.
            max_interned_ty_vecs: 4 * 1024 * 1024,
            // Maximum number of cached layouts.
            max_layout_cache_size: 4_000_000,
            // Maximum number of module IDs to intern.
            max_interned_module_ids: 100_000,
        }
    }
}

```
