# Audit Report

## Title
Unbounded Growth of ApprovedExecutionHashes Enables Governance Denial of Service

## Summary
An attacker with sufficient governance stake can create multiple successful proposals and intentionally leave them unresolved, causing the `ApprovedExecutionHashes` map to grow unbounded. This leads to O(N) performance degradation on every transaction validation and can eventually make adding new approved hashes prohibitively expensive, effectively blocking legitimate governance proposals from being executed.

## Finding Description

The `ApprovedExecutionHashes` resource uses a `SimpleMap<u64, vector<u8>>` to track execution hashes of successful governance proposals. [1](#0-0) 

When a proposal reaches the `PROPOSAL_STATE_SUCCEEDED` state, its execution hash is automatically added to this map. [2](#0-1) 

The critical vulnerability exists because:

1. **No size limit on ApprovedExecutionHashes**: The `SimpleMap` data structure has no maximum capacity constraint, allowing unbounded growth.

2. **Entries only removed on resolution**: Hashes are removed only when proposals are explicitly resolved via `remove_approved_hash`. [3](#0-2) 

3. **No cleanup mechanism**: There is no automatic expiration or cleanup for old successful proposals that remain unresolved.

4. **O(N) overhead on every transaction**: The VM checks all entries during transaction validation. [4](#0-3) 

5. **O(N) cost for adding new entries**: SimpleMap's `add` operation performs a linear scan to check for duplicates. [5](#0-4) 

**Attack Execution Path:**

1. Attacker creates a governance proposal with sufficient `required_proposer_stake`
2. Attacker votes (or coordinates votes) to reach `min_voting_threshold`, making the proposal succeed
3. `add_approved_script_hash` is automatically called, adding an entry to `ApprovedExecutionHashes` [6](#0-5) 
4. Attacker never calls `resolve()` or `resolve_multi_step_proposal()`, leaving the entry permanently
5. Attacker repeats this process hundreds or thousands of times
6. Eventually, the gas cost of `simple_map::add()` (which calls O(N) `find()`) exceeds transaction gas limits
7. Legitimate proposals cannot be added to `ApprovedExecutionHashes`, blocking governance execution

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

## Impact Explanation

**Medium Severity** - This qualifies as "State inconsistencies requiring intervention" per the bug bounty criteria:

- **Performance Degradation**: Every transaction validation incurs O(N) cost checking approved hashes, slowing the entire network proportional to attack magnitude
- **Governance Blocking**: Once the map grows sufficiently large, the O(N) `find()` operation in `SimpleMap::add()` can exceed maximum gas limits, preventing new proposals from being approved
- **Resource Exhaustion**: Storage costs increase unboundedly, and transaction processing becomes progressively more expensive
- **Requires Manual Intervention**: Resolving this attack would require either a governance vote to clear old entries or a network upgrade to implement size limits

The attack does NOT:
- Directly steal funds
- Violate consensus safety
- Completely halt the network (only degrades performance)
- Require validator-level access

## Likelihood Explanation

**Medium Likelihood**:

**Requirements:**
- Attacker needs stake meeting `required_proposer_stake` (configurable but typically significant)
- Attacker needs voting power to reach `min_voting_threshold` on proposals
- This could require substantial resources OR coordination with other governance participants

**Feasibility:**
- Each spam proposal consumes resources (gas, storage costs)
- However, if the attacker's goal is network disruption, the economic cost may be acceptable
- The attacker could space out proposals over time to reduce per-transaction costs
- Once deployed, the attack has lasting impact as entries persist indefinitely

**Mitigation Factors:**
- Requires active governance participation (not zero-cost attack)
- Community could potentially coordinate to resolve old proposals
- However, no automated defense mechanism exists in the protocol

## Recommendation

Implement a maximum size limit on `ApprovedExecutionHashes` and/or add automatic cleanup:

**Option 1: Size Limit**
```move
struct ApprovedExecutionHashes has key {
    hashes: SimpleMap<u64, vector<u8>>,
    max_entries: u64,  // e.g., 1000
}

public fun add_approved_script_hash(proposal_id: u64) acquires ApprovedExecutionHashes {
    let approved_hashes = borrow_global_mut<ApprovedExecutionHashes>(@aptos_framework);
    
    // Check size limit
    assert!(
        simple_map::length(&approved_hashes.hashes) < approved_hashes.max_entries,
        error::resource_exhausted(EAPPROVED_HASHES_LIMIT_REACHED)
    );
    
    // ... rest of function
}
```

**Option 2: Time-based Expiration**
Add expiration timestamps to entries and implement periodic cleanup of expired unresolved proposals.

**Option 3: Use OrderedMap or SmartTable**
Replace `SimpleMap` with `OrderedMap` or `SmartTable` for O(log N) operations instead of O(N), as `SimpleMap` is deprecated. [7](#0-6) 

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework, attacker = @0x123, voter = @0x234)]
public entry fun test_hash_squatting_dos(
    aptos_framework: signer,
    attacker: signer,
    voter: signer,
) acquires ApprovedExecutionHashes, GovernanceConfig, GovernanceResponsbility, VotingRecords, VotingRecordsV2, GovernanceEvents {
    // Setup governance
    setup_partial_voting(&aptos_framework, &attacker, &voter, &voter);
    
    // Attacker creates multiple spam proposals
    let i = 0;
    while (i < 100) {  // In practice, could be thousands
        create_proposal_for_test(&attacker, false);
        
        // Vote to make it succeed
        vote(&attacker, signer::address_of(&attacker), i, true);
        
        // Advance time to make proposal resolvable
        timestamp::fast_forward_seconds(1001);
        
        // Add to approved hashes but DON'T resolve
        add_approved_script_hash(i);
        
        i = i + 1;
    };
    
    // Verify ApprovedExecutionHashes has grown
    let approved_hashes = borrow_global<ApprovedExecutionHashes>(@aptos_framework);
    assert!(simple_map::length(&approved_hashes.hashes) == 100, 0);
    
    // Now legitimate proposals face O(N) overhead on every operation
    // Eventually, adding new entries becomes prohibitively expensive
}
```

**Notes:**

The vulnerability is real but exploitation requires significant economic resources (stake and voting power). The attack is not prevented by any current protocol mechanisms - there are no limits on `ApprovedExecutionHashes` size, no automatic cleanup, and no expiration for unresolved successful proposals. The use of deprecated `SimpleMap` with O(N) operations exacerbates the impact, as every transaction validation and every new proposal addition becomes progressively more expensive as the attack progresses.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L108-112)
```text
    /// Used to track which execution script hashes have been approved by governance.
    /// This is required to bypass cases where the execution scripts exceed the size limit imposed by mempool.
    struct ApprovedExecutionHashes has key {
        hashes: SimpleMap<u64, vector<u8>>,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L600-603)
```text
        let proposal_state = voting::get_proposal_state<GovernanceProposal>(@aptos_framework, proposal_id);
        if (proposal_state == PROPOSAL_STATE_SUCCEEDED) {
            add_approved_script_hash(proposal_id);
        }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L613-629)
```text
    public fun add_approved_script_hash(proposal_id: u64) acquires ApprovedExecutionHashes {
        let approved_hashes = borrow_global_mut<ApprovedExecutionHashes>(@aptos_framework);

        // Ensure the proposal can be resolved.
        let proposal_state = voting::get_proposal_state<GovernanceProposal>(@aptos_framework, proposal_id);
        assert!(proposal_state == PROPOSAL_STATE_SUCCEEDED, error::invalid_argument(EPROPOSAL_NOT_RESOLVABLE_YET));

        let execution_hash = voting::get_execution_hash<GovernanceProposal>(@aptos_framework, proposal_id);

        // If this is a multi-step proposal, the proposal id will already exist in the ApprovedExecutionHashes map.
        // We will update execution hash in ApprovedExecutionHashes to be the next_execution_hash.
        if (simple_map::contains_key(&approved_hashes.hashes, &proposal_id)) {
            let current_execution_hash = simple_map::borrow_mut(&mut approved_hashes.hashes, &proposal_id);
            *current_execution_hash = execution_hash;
        } else {
            simple_map::add(&mut approved_hashes.hashes, proposal_id, execution_hash);
        }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L664-674)
```text
    public fun remove_approved_hash(proposal_id: u64) acquires ApprovedExecutionHashes {
        assert!(
            voting::is_resolved<GovernanceProposal>(@aptos_framework, proposal_id),
            error::invalid_argument(EPROPOSAL_NOT_RESOLVED_YET),
        );

        let approved_hashes = &mut borrow_global_mut<ApprovedExecutionHashes>(@aptos_framework).hashes;
        if (simple_map::contains_key(approved_hashes, &proposal_id)) {
            simple_map::remove(approved_hashes, &proposal_id);
        };
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L286-302)
```rust
fn is_approved_gov_script(
    resolver: &impl ConfigStorage,
    txn: &SignedTransaction,
    txn_metadata: &TransactionMetadata,
) -> bool {
    if let Ok(TransactionExecutableRef::Script(_script)) = txn.payload().executable_ref() {
        match ApprovedExecutionHashes::fetch_config(resolver) {
            Some(approved_execution_hashes) => approved_execution_hashes
                .entries
                .iter()
                .any(|(_, hash)| hash == &txn_metadata.script_hash),
            None => false,
        }
    } else {
        false
    }
}
```

**File:** aptos-move/framework/aptos-stdlib/sources/simple_map.move (L1-9)
```text
/// This module provides a solution for unsorted maps, that is it has the properties that
/// 1) Keys point to Values
/// 2) Each Key must be unique
/// 3) A Key can be found within O(N) time
/// 4) The keys are unsorted.
/// 5) Adds and removals take O(N) time
///
/// DEPRECATED: since it's implementation is inneficient, it
/// has been deprecated in favor of `ordered_map.move`.
```

**File:** aptos-move/framework/aptos-stdlib/sources/simple_map.move (L93-102)
```text
    public fun add<Key: store, Value: store>(
        self: &mut SimpleMap<Key, Value>,
        key: Key,
        value: Value,
    ) {
        let maybe_idx = self.find(&key);
        assert!(maybe_idx.is_none(), error::invalid_argument(EKEY_ALREADY_EXISTS));

        self.data.push_back(Element { key, value });
    }
```
