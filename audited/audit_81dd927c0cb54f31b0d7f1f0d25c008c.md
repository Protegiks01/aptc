# Audit Report

## Title
Status Tracking Gap During ProcessorStatus to ProcessorStatusV2 Migration

## Summary
During the migration from `ProcessorStatus` to `ProcessorStatusV2`, a critical gap in status tracking occurs when processors running different code versions write to and read from separate database tables. New processors read exclusively from the V2 table while old processors write only to the deprecated table, causing the system to lose visibility into actual processing progress.

## Finding Description

The Aptos indexer uses two database tables to track transaction processing status:

1. **Old table**: `processor_statuses` (plural) - tracks per-version status with columns `(name, version, success, details, last_updated)`
2. **New table**: `processor_status` (singular) - tracks only latest success version with columns `(processor, last_success_version, last_updated)` [1](#0-0) 

The vulnerability manifests through a split write/read pattern:

**Write Operations:**
- Old code writes to `processor_statuses` via `TransactionProcessor::apply_processor_status()` [2](#0-1) 
- New code writes to BOTH tables: old table via `apply_processor_status()` and new table via `Tailer::update_last_processed_version()` [3](#0-2) 

**Read Operations:**
- New code reads EXCLUSIVELY from V2 table via `Tailer::get_start_version()` [4](#0-3) 
- This is called during processor initialization to determine where to resume indexing [5](#0-4) 

**Attack Scenario:**
1. Processor A runs old code, writes status to `processor_statuses` table only
2. Processor A successfully processes versions 1000-2000
3. Processor B (new code) starts up and calls `get_start_version()` 
4. `get_start_version()` queries `processor_status` (V2) table, finds no record (returns `None`)
5. Processor B defaults to version 0, re-indexing from the beginning [6](#0-5) 
6. System loses track that versions 1000-2000 were already processed, causing duplicate work and state inconsistencies

**Additional Issue:**
No SQL migration exists to create the `processor_status` V2 table. The only migration creates `processor_statuses` (plural). [7](#0-6) 

Fresh deployments will fail when attempting to write to the non-existent V2 table, causing panic. [8](#0-7) 

## Impact Explanation

This vulnerability qualifies as **Medium Severity** under the Aptos Bug Bounty program criteria for "State inconsistencies requiring intervention":

1. **Data Integrity Impact**: The indexer loses track of actual processing progress, potentially causing duplicate data insertion or missed transactions
2. **Resource Waste**: Re-indexing from version 0 wastes computational resources and database storage
3. **Operational Impact**: Requires manual intervention to resolve status tracking discrepancies between tables
4. **Not Critical**: Does not affect consensus, validator operations, or on-chain state - limited to indexer subsystem

The impact is contained to the indexer component and does not compromise blockchain security or user funds.

## Likelihood Explanation

**Likelihood: High** during migration periods

This vulnerability will occur in these scenarios:
1. **Rolling Updates**: When operators perform rolling updates, old and new versions run simultaneously
2. **Partial Deployments**: If some indexer instances are updated while others remain on old code
3. **Fresh Deployments**: New deployments will immediately fail due to missing V2 table migration
4. **Configuration Drift**: If different deployment environments have different migration states

The vulnerability requires no attacker action - it occurs naturally during normal upgrade procedures. The comment explicitly marking `ProcessorStatus` as deprecated confirms this transition period was intended. [9](#0-8) 

## Recommendation

**Immediate Actions:**

1. **Create Missing Migration**: Add SQL migration to create `processor_status` V2 table:
```sql
    -- New migration file: YYYY-MM-DD-HHMMSS_add_processor_status_v2/up.sql
CREATE TABLE IF NOT EXISTS processor_status (
  processor VARCHAR(50) PRIMARY KEY NOT NULL,
  last_success_version BIGINT NOT NULL,
  last_updated TIMESTAMP NOT NULL DEFAULT NOW()
);
CREATE INDEX IF NOT EXISTS ps_v2_lastup_index ON processor_status (last_updated);
```

2. **Add Dual-Read Fallback**: Modify `get_start_version()` to fall back to reading from old table if V2 returns None:
```rust
pub fn get_start_version(&self, processor_name: &String) -> Result<Option<i64>> {
    let mut conn = self.connection_pool.get()?;
    
    // Try V2 table first
    match ProcessorStatusV2Query::get_by_processor(processor_name, &mut conn)? {
        Some(status) => Ok(Some(status.last_success_version + 1)),
        None => {
            // Fallback: check old table for backward compatibility
            self.get_start_version_from_old_table(processor_name)
        }
    }
}
```

3. **Add Data Migration**: Create script to populate V2 table from old table for existing processors:
```sql
INSERT INTO processor_status (processor, last_success_version, last_updated)
SELECT name, MAX(version), MAX(last_updated)
FROM processor_statuses
WHERE success = TRUE
GROUP BY name
ON CONFLICT (processor) DO UPDATE SET
  last_success_version = GREATEST(processor_status.last_success_version, EXCLUDED.last_success_version),
  last_updated = GREATEST(processor_status.last_updated, EXCLUDED.last_updated);
```

4. **Deprecation Path**: After all processors migrate to V2, remove writes to old table and eventually drop the `processor_statuses` table.

## Proof of Concept

**Scenario: Mixed Version Deployment**

```rust
// Simulation demonstrating the vulnerability

// Step 1: Old processor writes to deprecated table
let old_processor_status = ProcessorStatus::new("default_processor", 2000, true, None);
// Writes to processor_statuses table only
apply_processor_status(&[old_processor_status]);

// Step 2: New processor starts and checks last processed version
let tailer = Tailer::new(/* ... */);
let start_version = tailer.get_start_version(&"default_processor".to_string())?;

// Step 3: get_start_version() queries processor_status (V2) table
// Returns None because old processor never wrote to V2 table
assert_eq!(start_version, None);

// Step 4: System defaults to version 0
let actual_start = start_version.unwrap_or(0);
assert_eq!(actual_start, 0); // Should be 2001, but returns 0!

// Step 5: New processor re-processes versions 0-2000
// This causes duplicate work and potential data inconsistencies
```

**Fresh Deployment Failure:**

```bash
# 1. Clone repository and run migrations
diesel migration run

# 2. Start indexer
cargo run --bin aptos-indexer

# 3. Indexer processes first batch successfully
# 4. Attempts to call update_last_processed_version()
# 5. Diesel tries INSERT into non-existent processor_status table
# 6. ERROR: relation "processor_status" does not exist
# 7. Panic: "Failed to update last processed version"
```

The vulnerability is reproducible by deploying the indexer with migrations and attempting to process transactions. The system will either crash (fresh deployment) or lose track of progress (mixed versions).

---

**Notes:**
- This vulnerability is specific to the indexer subsystem and does not affect consensus or blockchain state
- The missing migration file indicates this V2 table may have been created manually in production, creating deployment inconsistencies
- The comment deprecating `ProcessorStatus` confirms the migration was intentional but incomplete

### Citations

**File:** crates/indexer/src/schema.rs (L607-624)
```rust
    processor_status (processor) {
        #[max_length = 50]
        processor -> Varchar,
        last_success_version -> Int8,
        last_updated -> Timestamp,
    }
}

diesel::table! {
    processor_statuses (name, version) {
        #[max_length = 50]
        name -> Varchar,
        version -> Int8,
        success -> Bool,
        details -> Nullable<Text>,
        last_updated -> Timestamp,
    }
}
```

**File:** crates/indexer/src/indexer/transaction_processor.rs (L145-165)
```rust
    /// Actually performs the write for a `ProcessorStatusModel` changeset
    fn apply_processor_status(&self, psms: &[ProcessorStatusModel]) {
        let mut conn = self.get_conn();
        let chunks = get_chunks(psms.len(), ProcessorStatusModel::field_count());
        for (start_ind, end_ind) in chunks {
            execute_with_better_error(
                &mut conn,
                diesel::insert_into(processor_statuses::table)
                    .values(&psms[start_ind..end_ind])
                    .on_conflict((dsl::name, dsl::version))
                    .do_update()
                    .set((
                        dsl::success.eq(excluded(dsl::success)),
                        dsl::details.eq(excluded(dsl::details)),
                        dsl::last_updated.eq(excluded(dsl::last_updated)),
                    )),
                None,
            )
            .expect("Error updating Processor Status!");
        }
    }
```

**File:** crates/indexer/src/indexer/tailer.rs (L170-191)
```rust
    pub fn update_last_processed_version(&self, processor_name: &str, version: u64) -> Result<()> {
        let mut conn = self.connection_pool.get()?;

        let status = ProcessorStatusV2 {
            processor: processor_name.to_owned(),
            last_success_version: version as i64,
        };
        execute_with_better_error(
            &mut conn,
            diesel::insert_into(processor_status::table)
                .values(&status)
                .on_conflict(processor_status::processor)
                .do_update()
                .set((
                    processor_status::last_success_version
                        .eq(excluded(processor_status::last_success_version)),
                    processor_status::last_updated.eq(excluded(processor_status::last_updated)),
                )),
            Some(" WHERE processor_status.last_success_version <= EXCLUDED.last_success_version "),
        )?;
        Ok(())
    }
```

**File:** crates/indexer/src/indexer/tailer.rs (L194-201)
```rust
    pub fn get_start_version(&self, processor_name: &String) -> Result<Option<i64>> {
        let mut conn = self.connection_pool.get()?;

        match ProcessorStatusV2Query::get_by_processor(processor_name, &mut conn)? {
            Some(status) => Ok(Some(status.last_success_version + 1)),
            None => Ok(None),
        }
    }
```

**File:** crates/indexer/src/runtime.rs (L163-172)
```rust
    let starting_version_from_db_short = tailer
        .get_start_version(&processor_name)
        .unwrap_or_else(|e| panic!("Failed to get starting version: {:?}", e))
        .unwrap_or_else(|| {
            info!(
                processor_name = processor_name,
                "No starting version from db so starting from version 0"
            );
            0
        }) as u64;
```

**File:** crates/indexer/src/runtime.rs (L251-261)
```rust
        tailer
            .update_last_processed_version(&processor_name, batch_end_version)
            .unwrap_or_else(|e| {
                error!(
                    processor_name = processor_name,
                    end_version = batch_end_version,
                    error = format!("{:?}", e),
                    "Failed to update last processed version!"
                );
                panic!("Failed to update last processed version: {:?}", e);
            });
```

**File:** crates/indexer/migrations/2022-08-08-043603_core_tables/up.sql (L306-317)
```sql
CREATE TABLE processor_statuses (
  name VARCHAR(50) NOT NULL,
  version BIGINT NOT NULL,
  success BOOLEAN NOT NULL,
  details TEXT,
  last_updated TIMESTAMP NOT NULL DEFAULT NOW(),
  -- Constraints
  PRIMARY KEY (name, version)
);
CREATE INDEX ps_succ_ver_index ON processor_statuses (success, version ASC);
CREATE INDEX ps_ver_index ON processor_statuses (version ASC);
CREATE INDEX ps_lastup_index ON processor_statuses (last_updated);
```

**File:** crates/indexer/src/models/processor_statuses.rs (L10-10)
```rust
/// We are deprecating this in favor of ProcessorStatusV2
```
