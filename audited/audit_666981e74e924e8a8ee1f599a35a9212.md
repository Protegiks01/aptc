# Audit Report

## Title
Double-Execution Vulnerability in Rosetta API Client via Sequence Number Auto-Increment on Retry

## Summary
The `submit_operations()` function in the Aptos Rosetta client allows sequence numbers to be automatically fetched from the blockchain when not explicitly provided (`sequence_number = None`). When operations are retried after a network failure, the function fetches an updated sequence number from the blockchain, creating a new transaction that re-executes the same operations, leading to double-transfers and double-execution of staking operations.

## Finding Description

The vulnerability exists in the interaction between `submit_operations()` [1](#0-0)  and the `construction_metadata` endpoint [2](#0-1) .

**Vulnerable Flow:**

When `sequence_number = None` is passed to operations like `transfer()`, `create_account()`, or any staking operation, the following occurs:

1. The client calls `metadata_for_ops()` which passes `sequence_number: None` in the preprocessing metadata [3](#0-2) 

2. The server's `construction_metadata` function checks if a sequence number was provided. When `None`, it fetches the current on-chain sequence number via `get_account()` [4](#0-3) 

3. This fetched sequence number is used to build the transaction [5](#0-4) 

4. If the transaction succeeds but the client doesn't receive confirmation (network timeout, API error), the on-chain sequence number has incremented

5. When the client retries with `sequence_number = None` again, the server fetches the NEW incremented sequence number

6. A completely different transaction is created (different hash due to different sequence number) [6](#0-5) 

7. This new transaction executes the same operations again

**Why Existing Protections Fail:**

The consensus-layer transaction deduplication uses `(txn_hash, authenticator)` pairs to prevent duplicates. However, these are two DIFFERENT transactions with different sequence numbers, therefore different hashes and different signatures. The deduplication mechanism correctly treats them as distinct transactions and allows both to execute.

**Affected Operations:**

All client functions that accept `sequence_number: Option<u64>` are vulnerable:
- `transfer()` - leads to double-spending
- `create_account()` - could create accounts with duplicate payments  
- `set_operator()`, `set_voter()`, `reset_lockup()` - staking operation re-execution
- `update_commission()`, `unlock_stake()` - financial staking operation duplication
- `create_stake_pool()`, `add_delegated_stake()` - duplicate stake pool operations
- `unlock_delegated_stake()`, `withdraw_undelegated_stake()` - duplicate withdrawals [7](#0-6) 

## Impact Explanation

**Severity: MEDIUM**

This qualifies as Medium severity per the Aptos Bug Bounty criteria: "Limited funds loss or manipulation" and "State inconsistencies requiring intervention."

**Financial Impact:**
- Users transferring 500 APT could inadvertently transfer 1000 APT if retry occurs
- Staking operations could be executed twice, locking double the intended stake
- Delegation operations could transfer double the intended delegation amount

**State Inconsistency:**
- Account balances become inconsistent with user intent
- Staking pool states may reflect double operations
- Transaction history shows duplicate logical operations with different sequence numbers

**Scope:**
- Affects any user or application using the Rosetta client with automatic sequence number management
- The Rosetta CLI allows users to omit sequence numbers, exposing them to this risk [8](#0-7) 
- Production systems using the Rosetta API for transaction construction are vulnerable

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

This vulnerability is likely to occur in production because:

1. **Common Retry Pattern**: Network timeouts and API failures are common in distributed systems. Applications naturally implement retry logic for failed operations.

2. **Default Behavior**: The Rosetta API documentation describes that sequence numbers can be automatically fetched when not provided [9](#0-8) 

3. **No Warnings**: There is no documentation warning users about this behavior or recommending explicit sequence number management for idempotency.

4. **Ambiguous Failure**: When a transaction succeeds but the client doesn't receive confirmation (network partition, timeout), the client has no way to distinguish this from a genuine failure without explicitly tracking sequence numbers.

5. **Production Usage**: The Rosetta API is intended for exchange integrations and production systems where retry logic is standard practice for reliability.

## Recommendation

**Solution 1: Return and Cache Sequence Number (Recommended)**

Modify the client to return the actual sequence number used in the transaction, allowing callers to implement proper retry logic:

```rust
async fn submit_operations(
    ...
    sequence_number: Option<u64>,
    ...
) -> anyhow::Result<(TransactionIdentifier, u64)> {
    let (metadata, public_keys) = self
        .metadata_for_ops(...)
        .await?;
    
    let used_sequence_number = metadata.metadata.sequence_number.0;
    
    // ... rest of function ...
    
    Ok((transaction_identifier, used_sequence_number))
}
```

Then modify all calling functions to return the sequence number used, enabling callers to retry with the same sequence number if needed.

**Solution 2: Transaction Idempotency Key**

Add an optional idempotency key parameter that's separate from the sequence number. Store submitted transactions with their idempotency keys and return cached results for duplicate keys rather than resubmitting.

**Solution 3: Documentation and Warning**

At minimum, add clear documentation warning users that:
- Retrying with `sequence_number = None` will create new transactions
- Users must explicitly track and reuse sequence numbers for idempotent retries
- Or users must track transaction hashes and check transaction status before retrying

## Proof of Concept

**Integration Test Scenario:**

```rust
#[tokio::test]
async fn test_double_transfer_on_retry_with_none_sequence_number() {
    // Setup: Create sender with 1000 APT, receiver with 0 APT
    let (client, network, sender_key, sender_addr) = setup_test_client().await;
    let receiver = AccountAddress::random();
    
    // Initial balances
    assert_eq!(get_balance(&client, sender_addr).await, 1000_00000000);
    assert_eq!(get_balance(&client, receiver).await, 0);
    
    // First transfer attempt with sequence_number = None
    // This will fetch sequence_number = 5 from blockchain
    let result1 = client.transfer(
        &network,
        &sender_key,
        receiver,
        500_00000000, // 500 APT
        expiry_time(),
        None, // ← sequence_number not provided
        None,
        None,
        native_coin(),
    ).await;
    
    // Transaction succeeds but assume client doesn't receive confirmation
    assert!(result1.is_ok());
    let txn_hash_1 = result1.unwrap().hash;
    
    // On-chain state has updated: sender now has 500 APT, receiver has 500 APT
    // Sender's sequence_number is now 6
    
    // Client retries thinking it failed, again with sequence_number = None
    // This will fetch NEW sequence_number = 6 from blockchain
    let result2 = client.transfer(
        &network,
        &sender_key,
        receiver,
        500_00000000, // Same 500 APT transfer
        expiry_time(),
        None, // ← sequence_number still not provided
        None,
        None,
        native_coin(),
    ).await;
    
    assert!(result2.is_ok());
    let txn_hash_2 = result2.unwrap().hash;
    
    // Verify: Two DIFFERENT transaction hashes
    assert_ne!(txn_hash_1, txn_hash_2);
    
    // Final balances show DOUBLE transfer occurred
    assert_eq!(get_balance(&client, sender_addr).await, 0); // Lost 1000 APT
    assert_eq!(get_balance(&client, receiver).await, 1000_00000000); // Received 1000 APT
    
    // Verify: Both transactions exist on-chain with different sequence numbers
    let txn1_seq = get_transaction_sequence_number(&client, txn_hash_1).await;
    let txn2_seq = get_transaction_sequence_number(&client, txn_hash_2).await;
    assert_eq!(txn1_seq, 5);
    assert_eq!(txn2_seq, 6);
}
```

This demonstrates that the same logical operation (transfer 500 APT) executes twice due to automatic sequence number increment on retry, resulting in actual loss of 1000 APT instead of the intended 500 APT.

## Notes

The vulnerability is specific to the Rosetta API client implementation and does not affect core Aptos consensus or the underlying blockchain protocol. The issue lies in the API layer's handling of idempotency for transaction construction. Users who explicitly provide sequence numbers and implement proper retry logic with the same sequence number are not affected by this issue.

### Citations

**File:** crates/aptos-rosetta/src/client.rs (L184-232)
```rust
    pub async fn transfer(
        &self,
        network_identifier: &NetworkIdentifier,
        private_key: &Ed25519PrivateKey,
        receiver: AccountAddress,
        amount: u64,
        expiry_time_secs: u64,
        sequence_number: Option<u64>,
        max_gas: Option<u64>,
        gas_unit_price: Option<u64>,
        currency: Currency,
    ) -> anyhow::Result<TransactionIdentifier> {
        let sender = self
            .get_account_address(network_identifier.clone(), private_key)
            .await?;
        let mut keys = HashMap::new();
        keys.insert(sender, private_key);

        // A transfer operation is made up of a withdraw and a deposit
        let operations = vec![
            Operation::withdraw(
                0,
                None,
                AccountIdentifier::base_account(sender),
                currency.clone(),
                amount,
            ),
            Operation::deposit(
                1,
                None,
                AccountIdentifier::base_account(receiver),
                currency,
                amount,
            ),
        ];

        self.submit_operations(
            sender,
            network_identifier.clone(),
            &keys,
            operations,
            expiry_time_secs,
            sequence_number,
            max_gas,
            gas_unit_price,
            false,
        )
        .await
    }
```

**File:** crates/aptos-rosetta/src/client.rs (L646-658)
```rust
    async fn submit_operations(
        &self,
        sender: AccountAddress,
        network_identifier: NetworkIdentifier,
        keys: &HashMap<AccountAddress, &Ed25519PrivateKey>,
        operations: Vec<Operation>,
        expiry_time_secs: u64,
        sequence_number: Option<u64>,
        max_gas: Option<u64>,
        gas_unit_price: Option<u64>,
        // Parsed operations won't match given operations
        parse_not_same: bool,
    ) -> anyhow::Result<TransactionIdentifier> {
```

**File:** crates/aptos-rosetta/src/client.rs (L725-743)
```rust
    async fn metadata_for_ops(
        &self,
        sender: AccountAddress,
        network_identifier: NetworkIdentifier,
        operations: Vec<Operation>,
        max_gas: Option<u64>,
        gas_unit_price: Option<u64>,
        expiry_time_secs: u64,
        sequence_number: Option<u64>,
        keys: &HashMap<AccountAddress, &Ed25519PrivateKey>,
    ) -> anyhow::Result<(ConstructionMetadataResponse, Vec<PublicKey>)> {
        // Request the given operation with the given gas constraints
        let preprocess_response = self
            .preprocess(&ConstructionPreprocessRequest {
                network_identifier: network_identifier.clone(),
                operations,
                metadata: Some(PreprocessMetadata {
                    expiry_time_secs: Some(expiry_time_secs.into()),
                    sequence_number: sequence_number.map(|inner| inner.into()),
```

**File:** crates/aptos-rosetta/src/construction.rs (L361-361)
```rust
        .sequence_number(sequence_number)
```

**File:** crates/aptos-rosetta/src/construction.rs (L449-470)
```rust
async fn construction_metadata(
    request: ConstructionMetadataRequest,
    server_context: RosettaContext,
) -> ApiResult<ConstructionMetadataResponse> {
    debug!("/construction/metadata {:?}", request);
    check_network(request.network_identifier, &server_context)?;

    let rest_client = server_context.rest_client()?;
    let address = request.options.internal_operation.sender();
    let response = get_account(&rest_client, address).await?;

    // Ensure this network really is the one we expect it to be
    if server_context.chain_id.id() != response.state().chain_id {
        return Err(ApiError::ChainIdMismatch);
    }

    // Retrieve the sequence number from the rest server if one wasn't provided
    let sequence_number = if let Some(sequence_number) = request.options.sequence_number {
        sequence_number.0
    } else {
        response.inner().sequence_number
    };
```

**File:** types/src/transaction/mod.rs (L175-185)
```rust
/// RawTransaction is the portion of a transaction that a client signs.
#[derive(
    Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash,
)]
pub struct RawTransaction {
    /// Sender's address.
    sender: AccountAddress,

    /// Sequence number of this transaction. This must match the sequence number
    /// stored in the sender's account at the time the transaction executes.
    sequence_number: u64,
```

**File:** crates/aptos-rosetta-cli/src/construction.rs (L175-186)
```rust
            .transfer(
                &network_identifier,
                &private_key,
                self.receiver,
                self.amount,
                self.txn_args.expiry_time()?,
                self.txn_args.sequence_number,
                self.txn_args.max_gas,
                self.txn_args.gas_price,
                self.currency,
            )
            .await
```

**File:** crates/aptos-rosetta/README.md (L54-56)
```markdown
All inputs to the API must be done in the `ConstructionPreprocessRequest`.  This allows you to set
the sequence number, expiry time, gas parameters, and the public keys to sign the transaction.

```
