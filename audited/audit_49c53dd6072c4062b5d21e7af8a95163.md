# Audit Report

## Title
Insecure File Permissions on Windows Expose Validator Private Keys to Unauthorized Local Users

## Summary
The `write_to_user_only_file()` function in `crates/aptos/src/common/utils.rs` only sets restrictive file permissions (mode 0600) on Unix systems using conditional compilation. On Windows systems, the function creates files with default permissions inherited from the parent directory, which can allow unauthorized local users to read sensitive validator private keys, consensus keys, and account credentials.

## Finding Description

The `write_to_user_only_file()` function is designed to write sensitive cryptographic material with user-only read/write permissions. However, the implementation only enforces this on Unix platforms: [1](#0-0) 

On Unix systems, `opts.mode(0o600)` sets the file to user-only permissions. However, the `#[cfg(unix)]` conditional compilation directive means this code is **completely omitted** on Windows builds. On Windows, files are created with default permissions inherited from the parent directory, which commonly includes read access for:
- The SYSTEM account
- The Administrators group  
- Other users with access to the parent directory (in shared environments)

This function is used to write extremely sensitive cryptographic material throughout the codebase:

**1. Validator Genesis Keys** - Writing all validator private keys to disk: [2](#0-1) 

These files contain the `PrivateIdentity` structure which includes: [3](#0-2) 

**2. User Account Configuration** - Writing user private keys: [4](#0-3) 

The `ProfileConfig` structure includes: [5](#0-4) 

**3. Global Configuration** - Writing global config with potential secrets: [6](#0-5) 

**Attack Scenario:**

1. A validator operator runs `aptos genesis generate-keys` on a Windows machine (development, testing, or key generation environment)
2. The command writes `private-keys.yaml`, `validator-identity.yaml`, and `validator-full-node-identity.yaml` to disk
3. Due to the missing Windows permissions, these files are created with default ACLs
4. A malicious local user on the same Windows system (or via compromised account with directory access) reads these files
5. The attacker now possesses:
   - `account_private_key` - Can drain validator stake and transfer funds
   - `consensus_private_key` - Can sign blocks and votes, participating in consensus as the validator
   - `validator_network_private_key` - Can impersonate the validator on the P2P network
   - `full_node_network_private_key` - Can impersonate the full node

This breaks the **Access Control** invariant (private keys must be protected from unauthorized access) and enables **Consensus Safety** violations (attacker can participate in Byzantine behavior using stolen consensus keys).

## Impact Explanation

This is a **HIGH severity** vulnerability per the Aptos bug bounty program criteria:

**Primary Impacts:**
- **Consensus Safety Violation**: With access to `consensus_private_key` (BLS12381), an attacker can sign quorum certificates, blocks, and votes as the compromised validator, enabling Byzantine attacks including double-signing and equivocation
- **Loss of Funds**: With access to `account_private_key`, the attacker can drain the validator's staked funds through unauthorized transfers
- **Network Security Compromise**: With access to network private keys, the attacker can conduct man-in-the-middle attacks and impersonate the validator on the P2P network

**Affected Components:**
- Validator consensus participation (AptosBFT protocol)
- Validator staking and fund security
- P2P network authentication and encryption
- On-chain governance voting (if validator participates)

**Why Not Critical:**
While the impact of key compromise is severe, this vulnerability requires:
- Windows deployment (most production validators use Linux)
- Local system access or weak directory ACLs
- Multi-user environment or compromised account on the same machine

The limited attack surface (platform and configuration specific) prevents this from reaching Critical severity, but the potential for complete validator compromise justifies High severity classification.

## Likelihood Explanation

**Likelihood: LOW to MEDIUM**

**Factors Increasing Likelihood:**
- Aptos CLI is cross-platform and officially supports Windows
- Developers and operators may generate keys on Windows workstations before transferring to production
- Windows Server deployments in corporate environments may have multiple administrator accounts
- Default Windows installations often have overly permissive directory ACLs
- Users unfamiliar with Windows ACLs may not realize files are readable by others

**Factors Decreasing Likelihood:**
- Most production validators run on Linux where this vulnerability doesn't apply
- Best practices recommend generating keys on the same system where the validator runs
- Single-user Windows machines with proper ACLs are not vulnerable
- Security-conscious operators likely use Linux for all validator operations

**Realistic Attack Scenarios:**
1. **Corporate Environment**: Validator key generation on shared Windows server with multiple administrator accounts
2. **Development Setup**: Developer generates test validator keys on Windows workstation that is later compromised
3. **Cloud Windows Instance**: Multi-tenant Windows VM where directory ACLs are misconfigured
4. **Compromised Account**: Attacker gains access to any local account on a Windows system where validator keys were generated

## Recommendation

Implement Windows-specific file permission restrictions using the Windows API. Rust's standard library doesn't provide cross-platform permission abstractions, so platform-specific code is required.

**Recommended Fix:**

```rust
pub fn write_to_user_only_file(path: &Path, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    let mut opts = OpenOptions::new();
    
    #[cfg(unix)]
    {
        use std::os::unix::fs::OpenOptionsExt;
        opts.mode(0o600);
    }
    
    #[cfg(windows)]
    {
        use std::os::windows::fs::OpenOptionsExt;
        // FILE_ATTRIBUTE_ENCRYPTED | FILE_ATTRIBUTE_HIDDEN could also be considered
        // But more importantly, we should set ACLs after file creation
    }
    
    write_to_file_with_opts(path, name, bytes, &mut opts)?;
    
    // On Windows, set restrictive ACLs after file creation
    #[cfg(windows)]
    {
        set_windows_user_only_permissions(path)?;
    }
    
    Ok(())
}

#[cfg(windows)]
fn set_windows_user_only_permissions(path: &Path) -> CliTypedResult<()> {
    use std::os::windows::io::AsRawHandle;
    use windows::Win32::Security::*;
    use windows::Win32::Storage::FileSystem::*;
    
    // Implementation would:
    // 1. Get current user SID
    // 2. Create a new DACL granting only the current user Full Control
    // 3. Apply the DACL to the file using SetNamedSecurityInfo
    // 
    // This requires the windows crate dependency
    // See: https://docs.rs/windows/latest/windows/Win32/Security/fn.SetNamedSecurityInfoW.html
    
    // Pseudo-code (requires proper Windows API calls):
    // - Get current user token
    // - Build ACL with single ACE for current user
    // - Remove inherited permissions
    // - Apply ACL to file
    
    Err(CliError::UnexpectedError(
        "Windows ACL implementation required".to_string()
    ))
}
```

**Alternative Approach:**

Display a clear warning on Windows when generating keys:

```rust
#[cfg(windows)]
eprintln!("WARNING: On Windows, file permissions may not be restrictive. 
Ensure this directory is secured against unauthorized access.
Consider generating keys on a Linux system for production use.");
```

**Long-term Solution:**

Add a dependency on the `windows` crate and implement proper DACL manipulation to ensure Windows files have equivalent security to Unix mode 0600.

## Proof of Concept

**Demonstration Steps (Windows):**

```powershell
# Step 1: Create a test Windows user
net user testattacker Password123! /add

# Step 2: Generate validator keys as regular user
aptos genesis generate-keys --output-dir ./validator-keys

# Step 3: Check file permissions
icacls validator-keys\private-keys.yaml

# Expected (vulnerable) output shows inheritance:
# validator-keys\private-keys.yaml BUILTIN\Administrators:(I)(F)
#                                  NT AUTHORITY\SYSTEM:(I)(F)
#                                  BUILTIN\Users:(I)(RX)
#                                  [Current User]:(I)(F)

# Step 4: As testattacker user, attempt to read the file
runas /user:testattacker "type C:\path\to\validator-keys\private-keys.yaml"

# If successful, the attacker can read all private keys
```

**Rust Test (Conceptual):**

```rust
#[cfg(all(test, windows))]
mod windows_permission_tests {
    use super::*;
    use std::fs;
    use std::os::windows::fs::MetadataExt;

    #[test]
    fn test_private_key_file_permissions_windows() {
        let temp_dir = tempfile::tempdir().unwrap();
        let key_file = temp_dir.path().join("test-private-key.yaml");
        
        // Write a test private key
        write_to_user_only_file(
            &key_file,
            "test-key",
            b"sensitive_key_data"
        ).unwrap();
        
        // On Windows, check if file has proper ACLs
        // This test would FAIL with current implementation
        // because no Windows-specific ACLs are set
        
        let metadata = fs::metadata(&key_file).unwrap();
        // TODO: Implement Windows ACL checking
        // assert!(has_restrictive_acls(&metadata));
    }
}
```

## Notes

**Additional Affected Functions:**

The same pattern exists in `save_to_file_confidential()` in `crates/aptos/src/common/types.rs`: [7](#0-6) 

**Mitigating Factors:**
- Linux is the recommended and most common platform for validators
- Windows deployments are likely rare in production
- Single-user Windows machines with proper ACLs are not vulnerable

**Severity Justification:**
Despite the platform-specific nature, this qualifies as High severity because:
1. The CLI officially supports Windows as a first-class platform
2. Complete validator compromise is possible if exploited
3. Users may not realize Windows file permissions work differently than Unix
4. The fix is straightforward but currently missing

### Citations

**File:** crates/aptos/src/common/utils.rs (L224-229)
```rust
pub fn write_to_user_only_file(path: &Path, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    let mut opts = OpenOptions::new();
    #[cfg(unix)]
    opts.mode(0o600);
    write_to_file_with_opts(path, name, bytes, &mut opts)
}
```

**File:** crates/aptos/src/genesis/keys.rs (L82-97)
```rust
        write_to_user_only_file(
            private_keys_file.as_path(),
            PRIVATE_KEYS_FILE,
            to_yaml(&private_identity)?.as_bytes(),
        )?;
        write_to_user_only_file(
            public_keys_file.as_path(),
            PUBLIC_KEYS_FILE,
            to_yaml(&public_identity)?.as_bytes(),
        )?;
        write_to_user_only_file(
            validator_file.as_path(),
            VALIDATOR_FILE,
            to_yaml(&validator_blob)?.as_bytes(),
        )?;
        write_to_user_only_file(vfn_file.as_path(), VFN_FILE, to_yaml(&vfn_blob)?.as_bytes())?;
```

**File:** crates/aptos-genesis/src/keys.rs (L15-22)
```rust
#[derive(Deserialize, Serialize)]
pub struct PrivateIdentity {
    pub account_address: AccountAddress,
    pub account_private_key: Ed25519PrivateKey,
    pub consensus_private_key: bls12381::PrivateKey,
    pub full_node_network_private_key: x25519::PrivateKey,
    pub validator_network_private_key: x25519::PrivateKey,
}
```

**File:** crates/aptos/src/common/types.rs (L275-282)
```rust
    /// Private key for commands.
    #[serde(
        skip_serializing_if = "Option::is_none",
        default,
        serialize_with = "serialize_material_with_prefix",
        deserialize_with = "deserialize_material_with_prefix"
    )]
    pub private_key: Option<Ed25519PrivateKey>,
```

**File:** crates/aptos/src/common/types.rs (L445-445)
```rust
        write_to_user_only_file(&config_file, CONFIG_FILE, config_bytes.as_bytes())?;
```

**File:** crates/aptos/src/common/types.rs (L1084-1089)
```rust
    pub fn save_to_file_confidential(&self, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
        let mut opts = OpenOptions::new();
        #[cfg(unix)]
        opts.mode(0o600);
        write_to_file_with_opts(self.output_file.as_path(), name, bytes, &mut opts)
    }
```

**File:** crates/aptos/src/config/mod.rs (L369-373)
```rust
        write_to_user_only_file(
            global_folder.join(GLOBAL_CONFIG_FILE).as_path(),
            "Global Config",
            &to_yaml(&self)?.into_bytes(),
        )?;
```
