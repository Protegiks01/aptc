# Audit Report

## Title
Governance Attack: Unvalidated `max_exp_horizon_secs` Update Enables Complete Keyless Account Denial of Service

## Summary
A malicious or compromised governance proposal can set `max_exp_horizon_secs` to 1 (or any unreasonably low value), causing immediate and complete denial of service for all keyless account users by making all keyless signatures fail validation.

## Finding Description

The keyless account system relies on the `max_exp_horizon_secs` parameter in the `Configuration` struct to validate the expiration horizon of ephemeral public keys. This parameter controls how far into the future (from the JWT's issued-at time) an ephemeral key can be set to expire.

**Vulnerability Flow:**

The `update_max_exp_horizon_for_next_epoch` function allows governance to update this value without any validation: [1](#0-0) 

This function directly assigns the provided value with no bounds checking at line 315, accepting any u64 value including 1 or even 0.

**Critical Validation Points:**

Every keyless transaction must pass validation that checks `exp_horizon_secs` against the on-chain `max_exp_horizon_secs`:

For ZeroKnowledgeSig signatures: [2](#0-1) 

For OpenIdSig signatures: [3](#0-2) 

These validations occur during transaction validation for every keyless transaction: [4](#0-3) 

**Attack Scenario:**

1. Malicious/compromised governance proposal calls `update_max_exp_horizon_for_next_epoch(fx, 1)`
2. Change takes effect at next epoch reconfiguration via `on_new_epoch`
3. All subsequent keyless transactions are rejected because:
   - For existing signatures: Their `exp_horizon_secs` values (typically 10,000,000+ seconds = ~115 days) exceed the new limit of 1 second
   - For new signatures: It's physically impossible to create a JWT, generate a ZK proof, and submit a transaction within 1 second of the JWT's `iat` timestamp
4. Result: Complete lockout of all keyless account users

The codebase acknowledges this risk but provides no mitigation: [5](#0-4) 

## Impact Explanation

This vulnerability meets **Critical Severity** criteria per the Aptos bug bounty program for the following reasons:

- **Total loss of liveness**: All keyless account users would be unable to submit transactions, effectively freezing their accounts
- **Affects entire user segment**: Unlike single-user exploits, this impacts ALL keyless account users simultaneously
- **Requires governance intervention to recover**: A second governance proposal would be needed to restore service, but this may be difficult if many governance participants use keyless accounts
- **No user-side workaround**: Users cannot migrate to non-keyless authentication or access their funds until the parameter is restored

The default value is 10,000,000 seconds (~115 days) as shown in: [6](#0-5) 

Setting this to 1 second makes the keyless system completely unusable.

## Likelihood Explanation

**Likelihood: Medium-to-High**

While this requires a governance proposal to pass, the likelihood is elevated because:

1. **No technical barriers**: The code accepts any value without validation
2. **Governance compromise scenarios**: 
   - Malicious proposal disguised among other changes
   - Compromised governance participant accounts
   - Social engineering of governance voters
   - Accidental misconfiguration (typo: 1 instead of 10000000)

3. **Immediate and total impact**: Unlike gradual attacks, this takes effect at next epoch and affects all users instantly

4. **Acknowledged but unmitigated risk**: The WARNING comment shows developers are aware of the danger, but no protective measures were implemented

## Recommendation

Implement minimum value validation for `max_exp_horizon_secs` to prevent unreasonably low values:

```move
public fun update_max_exp_horizon_for_next_epoch(fx: &signer, max_exp_horizon_secs: u64) acquires Configuration {
    system_addresses::assert_aptos_framework(fx);
    
    // Validate minimum horizon: at least 1 hour (3600 seconds)
    // This allows time for JWT issuance + ZK proof generation + transaction submission
    assert!(max_exp_horizon_secs >= 3600, E_INVALID_MAX_EXP_HORIZON);
    
    // Validate maximum horizon: prevent excessively long horizons (e.g., 1 year)
    assert!(max_exp_horizon_secs <= 31536000, E_INVALID_MAX_EXP_HORIZON);

    let config = if (config_buffer::does_exist<Configuration>()) {
        config_buffer::extract_v2<Configuration>()
    } else {
        *borrow_global<Configuration>(signer::address_of(fx))
    };

    config.max_exp_horizon_secs = max_exp_horizon_secs;

    set_configuration_for_next_epoch(fx, config);
}
```

Additionally, add the error constant:
```move
const E_INVALID_MAX_EXP_HORIZON: u64 = 4;
```

Apply similar validation to `set_configuration_for_next_epoch` and `new_configuration` functions.

## Proof of Concept

Based on the existing test pattern: [7](#0-6) 

```move
script {
    use aptos_framework::keyless_account;
    use aptos_framework::aptos_governance;
    
    fun exploit_max_exp_horizon_dos(core_resources: &signer) {
        let framework_signer = aptos_governance::get_signer_testnet_only(
            core_resources, 
            @0x1
        );
        
        // Malicious governance proposal sets max_exp_horizon_secs to 1
        keyless_account::update_max_exp_horizon_for_next_epoch(&framework_signer, 1);
        
        // Force epoch end to apply changes
        aptos_governance::force_end_epoch(&framework_signer);
        
        // At this point, all keyless transactions will fail validation with:
        // "The expiration horizon is too long" (for ZeroKnowledgeSig)
        // "The ephemeral public key's expiration date is too far into the future" (for OpenIdSig)
    }
}
```

After this executes, any keyless transaction with `exp_horizon_secs > 1` (which is virtually all of them) will be rejected during validation, causing complete denial of service for all keyless account users.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L269-277)
```text
    /// Queues up a change to the keyless configuration. The change will only be effective after reconfiguration. Only
    /// callable via governance proposal.
    ///
    /// WARNING: A malicious `Configuration` could lead to DoS attacks, create liveness issues, or enable a malicious
    /// recovery service provider to phish users' accounts.
    public fun set_configuration_for_next_epoch(fx: &signer, config: Configuration) {
        system_addresses::assert_aptos_framework(fx);
        config_buffer::upsert<Configuration>(config);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L306-318)
```text
    public fun update_max_exp_horizon_for_next_epoch(fx: &signer, max_exp_horizon_secs: u64) acquires Configuration {
        system_addresses::assert_aptos_framework(fx);

        let config = if (config_buffer::does_exist<Configuration>()) {
            config_buffer::extract_v2<Configuration>()
        } else {
            *borrow_global<Configuration>(signer::address_of(fx))
        };

        config.max_exp_horizon_secs = max_exp_horizon_secs;

        set_configuration_for_next_epoch(fx, config);
    }
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L294-297)
```rust
                if zksig.exp_horizon_secs > config.max_exp_horizon_secs {
                    // println!("[aptos-vm][groth16] Expiration horizon is too long");
                    return Err(invalid_signature!("The expiration horizon is too long"));
                }
```

**File:** types/src/keyless/openid_sig.rs (L64-78)
```rust
        let max_expiration_date = seconds_from_epoch(
            claims
                .oidc_claims
                .iat
                .checked_add(config.max_exp_horizon_secs)
                .ok_or_else(|| {
                    anyhow::anyhow!("Overflow when adding iat and max_exp_horizon_secs")
                })?,
        )?;
        let expiration_date = seconds_from_epoch(exp_timestamp_secs)?;

        ensure!(
            expiration_date < max_expiration_date,
            "The ephemeral public key's expiration date is too far into the future"
        );
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1798-1810)
```rust
        let keyless_authenticators = aptos_types::keyless::get_authenticators(transaction)
            .map_err(|_| VMStatus::error(StatusCode::INVALID_SIGNATURE, None))?;

        // If there are keyless TXN authenticators, validate them all.
        if !keyless_authenticators.is_empty() && !self.is_simulation {
            keyless_validation::validate_authenticators(
                self.environment().keyless_pvk(),
                self.environment().keyless_configuration(),
                &keyless_authenticators,
                self.features(),
                session.resolver,
                module_storage,
            )?;
```

**File:** types/src/keyless/configuration.rs (L62-73)
```rust
    pub fn new_for_devnet() -> Configuration {
        Configuration {
            override_aud_vals: vec![Self::OVERRIDE_AUD_FOR_TESTING.to_owned()],
            max_signatures_per_txn: 3,
            max_exp_horizon_secs: 10_000_000, // ~115.74 days
            training_wheels_pubkey: None,
            max_commited_epk_bytes: circuit_constants::MAX_COMMITED_EPK_BYTES,
            max_iss_val_bytes: circuit_constants::MAX_ISS_VAL_BYTES,
            max_extra_field_bytes: circuit_constants::MAX_EXTRA_FIELD_BYTES,
            max_jwt_header_b64_bytes: circuit_constants::MAX_JWT_HEADER_B64_BYTES,
        }
    }
```

**File:** testsuite/smoke-test/src/keyless.rs (L933-971)
```rust
    let script = format!(
        r#"
script {{
use aptos_framework::jwks;
use aptos_framework::{};
use aptos_framework::aptos_governance;
use std::string::utf8;
use std::option;
fun main(core_resources: &signer) {{
    let framework_signer = aptos_governance::get_signer_testnet_only(core_resources, @0000000000000000000000000000000000000000000000000000000000000001);
    let jwk_0 = jwks::new_rsa_jwk(
        utf8(b"{}"),
        utf8(b"{}"),
        utf8(b"{}"),
        utf8(b"{}")
    );
    let patches = vector[
        jwks::new_patch_remove_all(),
        jwks::new_patch_upsert_jwk(b"{}", jwk_0),
    ];
    jwks::set_patches(&framework_signer, patches);

    {}::update_max_exp_horizon_for_next_epoch(&framework_signer, {});
    {}::update_training_wheels_for_next_epoch(&framework_signer, option::some(x"{}"));
    aptos_governance::force_end_epoch(&framework_signer);
}}
}}
"#,
        KEYLESS_ACCOUNT_MODULE_NAME,
        jwk.kid,
        jwk.alg,
        jwk.e,
        jwk.n,
        iss,
        KEYLESS_ACCOUNT_MODULE_NAME,
        max_exp_horizon_secs,
        KEYLESS_ACCOUNT_MODULE_NAME,
        hex::encode(training_wheels_pk.to_bytes())
    );
```
