# Audit Report

## Title
Gas Parameter Increases Via Governance Invalidate Pending Mempool Transactions Without Re-validation

## Summary
When governance increases gas parameters (such as `min_transaction_gas_units` or `intrinsic_gas_per_byte`), pending transactions in mempool that were validated against the old gas schedule are not re-validated. These transactions will fail during execution if their `max_gas_amount` is now insufficient under the new gas schedule, causing mass transaction failures and sequence number loss.

## Finding Description

The vulnerability exists in the mempool transaction validation lifecycle when gas schedules are updated via governance:

**Gas Schedule Update Flow:** [1](#0-0) 

When governance calls `set_for_next_epoch()`, the new gas schedule is buffered and applied at the next epoch via `on_new_epoch()`: [2](#0-1) 

**Mempool Validator Restart (No Re-validation):** [3](#0-2) 

The validator restart only updates the state view but does **not** re-validate existing transactions in mempool: [4](#0-3) 

**Transaction Validation Against New Gas Schedule:**

When transactions are later executed, they are checked against the **current** gas schedule: [5](#0-4) 

The intrinsic gas calculation uses the current gas parameters: [6](#0-5) 

**The Problem:**
1. User submits transaction with `max_gas_amount = 1000` when intrinsic gas = 800 (passes validation)
2. Transaction enters mempool
3. Governance increases `min_transaction_gas_units` from 2,760,000 to 5,000,000 (or increases `intrinsic_gas_per_byte`)
4. Mempool validator restarts but transactions remain in mempool without re-validation
5. When consensus executes the transaction, `check_gas()` calculates new intrinsic gas = 1500
6. Transaction fails with `MAX_GAS_UNITS_BELOW_MIN_TRANSACTION_GAS_UNITS`
7. User loses sequence number and must resubmit

## Impact Explanation

**Medium Severity** per Aptos bug bounty criteria:

1. **State Inconsistencies Requiring Intervention**: Mass transaction failures after gas schedule upgrades require manual intervention from users to resubmit transactions with higher gas amounts. This disrupts normal network operation.

2. **Limited Funds Loss**: Time-sensitive transactions (DEX trades, liquidations, auction bids, time-locked operations) that fail due to insufficient gas can result in financial losses for users. Users cannot protect against this as they submitted transactions with adequate gas under the then-current parameters.

3. **Sequence Number Loss**: Failed transactions consume sequence numbers, forcing users to track failures and adjust subsequent transaction sequences.

4. **Network Disruption**: A significant gas parameter increase could invalidate thousands of pending transactions simultaneously, causing widespread service degradation.

## Likelihood Explanation

**High Likelihood** of occurrence:

1. **Governance Upgrades Are Common**: Gas parameter adjustments are a normal part of network maintenance and economic policy. The system explicitly supports this via `set_for_next_epoch()`.

2. **No Protection Mechanism**: There is no code path that re-validates mempool transactions after gas schedule updates. The vulnerability is guaranteed to manifest if:
   - Governance increases gas parameters
   - Mempool contains transactions with `max_gas_amount` values calculated under old parameters

3. **User Cannot Prevent**: Users calculate `max_gas_amount` based on current gas schedule. They have no way to predict future governance changes or protect their transactions.

4. **Already Deployed**: This is production code behavior, not a theoretical edge case.

## Recommendation

**Solution 1: Re-validate Mempool Transactions After Gas Schedule Updates**

Add a re-validation step in the mempool reconfiguration handler: [3](#0-2) 

Modify to include mempool transaction re-validation:

```rust
pub(crate) async fn process_config_update<V, P>(
    config_update: OnChainConfigPayload<P>,
    validator: Arc<RwLock<V>>,
    mempool: Arc<Mutex<CoreMempool>>,  // Add mempool reference
    broadcast_within_validator_network: Arc<RwLock<bool>>,
) where
    V: TransactionValidation,
    P: OnChainConfigProvider,
{
    info!(LogSchema::event_log(
        LogEntry::ReconfigUpdate,
        LogEvent::Process
    ));

    if let Err(e) = validator.write().restart() {
        counters::VM_RECONFIG_UPDATE_FAIL_COUNT.inc();
        error!(LogSchema::event_log(LogEntry::ReconfigUpdate, LogEvent::VMUpdateFail).error(&e));
    }
    
    // Re-validate all mempool transactions against new gas schedule
    mempool.lock().gc_by_gas_schedule_update(&validator);
    
    // ... rest of function
}
```

Add to CoreMempool:

```rust
pub fn gc_by_gas_schedule_update<V: TransactionValidation>(
    &mut self,
    validator: &Arc<RwLock<V>>,
) {
    let mut invalid_txns = Vec::new();
    
    // Iterate through all transactions
    for (address, account_txns) in self.transactions.iter() {
        for txn in account_txns {
            // Re-validate against current gas schedule
            match validator.read().validate_transaction(txn.clone()) {
                Err(_) | Ok(result) if result.status().is_some() => {
                    invalid_txns.push(txn.committed_hash());
                },
                Ok(_) => continue,
            }
        }
    }
    
    // Remove invalidated transactions
    for txn_hash in invalid_txns {
        self.remove_transaction(&txn_hash);
    }
}
```

**Solution 2: Grace Period for Gas Increases**

Implement a grace period during which both old and new gas schedules are accepted:

- Store previous gas schedule alongside current one
- During prologue, accept transactions if they meet either old OR new minimum gas requirements
- Grace period expires after N blocks or time duration

**Solution 3: Gas Schedule Versioning**

Include gas schedule version in transaction metadata so transactions are validated against the schedule version they were created for.

## Proof of Concept

```rust
#[test]
fn test_gas_schedule_upgrade_invalidates_pending_transactions() {
    // Setup: Create mempool with initial gas schedule
    let (mut mempool, validator) = setup_mempool_with_gas_schedule(/* initial params */);
    
    // Step 1: Create transaction with max_gas_amount based on current intrinsic gas
    let current_intrinsic = 2_760_000; // min_transaction_gas_units
    let txn = create_signed_transaction(
        max_gas_amount: 3_000_000, // Slightly above current intrinsic
        transaction_size: 500,
    );
    
    // Step 2: Validate and add to mempool (should succeed)
    let validation_result = validator.read().validate_transaction(txn.clone());
    assert!(validation_result.is_ok());
    mempool.add_txn(txn.clone(), /* ... */);
    
    // Step 3: Simulate governance gas schedule update
    // Double min_transaction_gas_units: 2_760_000 -> 5_520_000
    update_gas_schedule_via_governance(new_min_transaction_gas_units: 5_520_000);
    
    // Step 4: Restart validator (simulating epoch change)
    validator.write().restart().unwrap();
    
    // Step 5: Transaction remains in mempool (no re-validation occurs)
    assert!(mempool.contains_transaction(&txn.committed_hash()));
    
    // Step 6: When consensus picks transaction for execution, it fails
    let execution_result = execute_transaction_from_consensus(&txn, &validator);
    
    // Step 7: Verify transaction fails with gas error
    assert!(matches!(
        execution_result,
        Err(VMStatus { status_code: StatusCode::MAX_GAS_UNITS_BELOW_MIN_TRANSACTION_GAS_UNITS, .. })
    ));
    
    // Step 8: Transaction is removed from mempool, sequence number lost
    assert!(!mempool.contains_transaction(&txn.committed_hash()));
}
```

## Notes

This vulnerability represents a backward compatibility issue in the gas schedule upgrade mechanism. While not a traditional "attack" requiring malicious intent, it causes real security harm:

- **Financial Loss**: Users lose money on time-sensitive failed transactions
- **Service Disruption**: Mass transaction failures degrade network usability  
- **No User Protection**: Users cannot predict or prevent this issue

The fix requires adding re-validation logic to the mempool reconfiguration handler to ensure all pending transactions remain valid under updated gas parameters, or implementing a grace period/versioning mechanism to maintain backward compatibility.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L135-145)
```text
    public(friend) fun on_new_epoch(framework: &signer) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(framework);
        if (config_buffer::does_exist<GasScheduleV2>()) {
            let new_gas_schedule = config_buffer::extract_v2<GasScheduleV2>();
            if (exists<GasScheduleV2>(@aptos_framework)) {
                *borrow_global_mut<GasScheduleV2>(@aptos_framework) = new_gas_schedule;
            } else {
                move_to(framework, new_gas_schedule);
            }
        }
    }
```

**File:** mempool/src/shared_mempool/tasks.rs (L762-778)
```rust
pub(crate) async fn process_config_update<V, P>(
    config_update: OnChainConfigPayload<P>,
    validator: Arc<RwLock<V>>,
    broadcast_within_validator_network: Arc<RwLock<bool>>,
) where
    V: TransactionValidation,
    P: OnChainConfigProvider,
{
    info!(LogSchema::event_log(
        LogEntry::ReconfigUpdate,
        LogEvent::Process
    ));

    if let Err(e) = validator.write().restart() {
        counters::VM_RECONFIG_UPDATE_FAIL_COUNT.inc();
        error!(LogSchema::event_log(LogEntry::ReconfigUpdate, LogEvent::VMUpdateFail).error(&e));
    }
```

**File:** vm-validator/src/vm_validator.rs (L70-74)
```rust
    fn restart(&mut self) -> Result<()> {
        let db_state_view = self.db_state_view();
        self.state.reset_all(db_state_view.into());
        Ok(())
    }
```

**File:** aptos-move/aptos-vm/src/gas.rs (L154-172)
```rust
    let intrinsic_gas = txn_gas_params
        .calculate_intrinsic_gas(raw_bytes_len)
        .evaluate(gas_feature_version, &gas_params.vm);
    let total_rounded: Gas =
        (intrinsic_gas + keyless + slh_dsa_sha2_128s).to_unit_round_up_with_params(txn_gas_params);
    if txn_metadata.max_gas_amount() < total_rounded {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; min {}, submitted {}",
                total_rounded,
                txn_metadata.max_gas_amount()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::MAX_GAS_UNITS_BELOW_MIN_TRANSACTION_GAS_UNITS,
            None,
        ));
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L300-310)
```rust
    /// Calculate the intrinsic gas for the transaction based upon its size in bytes.
    pub fn calculate_intrinsic_gas(
        &self,
        transaction_size: NumBytes,
    ) -> impl GasExpression<VMGasParameters, Unit = InternalGasUnit> + use<> {
        let excess = transaction_size
            .checked_sub(self.large_transaction_cutoff)
            .unwrap_or_else(|| 0.into());

        MIN_TRANSACTION_GAS_UNITS + INTRINSIC_GAS_PER_BYTE * excess
    }
```
