# Audit Report

## Title
State Sync Path Allows Overwriting Epoch-Ending Ledger Info Without Consistency Validation

## Summary
The storage layer has two distinct paths for storing epoch-ending ledger infos: the consensus path with validation, and the state-sync/restore path without equivalent validation. The state-sync path can overwrite existing epoch-ending ledger infos for the same epoch with different state commitments, creating irrecoverable state forks if conflicting but validly-signed epoch-ending ledger infos exist due to consensus bugs or Byzantine behavior.

## Finding Description

The `LedgerInfoSchema` uses epoch number as the database key, allowing only one ledger info per epoch: [1](#0-0) 

When storing ledger infos, there are two code paths:

**Path 1: Consensus Commit Path** - Uses `check_and_put_ledger_info` which validates: [2](#0-1) 

This path includes critical validations:
- Epoch continuity check preventing out-of-order commits [3](#0-2) 
- Transaction accumulator hash matching local pre-committed state [4](#0-3) 
- State snapshot existence validation for epoch boundaries [5](#0-4) 

**Path 2: State Sync/Restore Path** - Uses `finalize_state_snapshot` which calls `save_ledger_infos`: [6](#0-5) 

The `save_ledger_infos` function performs minimal validation: [7](#0-6) 

It directly calls `put_ledger_info` which unconditionally writes to the database using epoch as key, **overwriting any existing ledger info for that epoch**: [8](#0-7) 

**The Vulnerability**: When epoch-ending ledger infos are stored via the state-sync path, there is **no validation** that:
1. An existing ledger info for this epoch has the same transaction accumulator hash
2. The new ledger info is consistent with previously committed state
3. The overwrite is safe and won't cause state divergence

**Attack Scenario**:
1. Due to a consensus safety violation (>1/3 Byzantine validators or consensus bug), conflicting but validly-signed epoch-ending ledger infos exist for epoch N
2. Different nodes commit different versions: Node set A has LedgerInfo_A with state root X, Node set B has LedgerInfo_B with state root Y
3. A node from set A later performs state synchronization with peers from set B
4. During `finalize_state_snapshot`, LedgerInfo_B is provided and verified by signature [9](#0-8) 
5. LedgerInfo_B is stored via `save_ledger_infos`, **overwriting** the node's existing LedgerInfo_A for epoch N
6. The node now has a different view of blockchain state at the epoch boundary, causing state fork

## Impact Explanation

**Critical Severity** - This meets the "Non-recoverable network partition (requires hardfork)" category from the Aptos bug bounty program.

Once nodes have different epoch-ending ledger infos with different state roots for the same epoch:
- They compute different state merkle roots going forward
- Validator set for next epoch may differ if next_epoch_state differs
- Consensus cannot proceed across the fork boundary
- Manual intervention and hard fork required to resolve

This breaks the **State Consistency** invariant: "State transitions must be atomic and verifiable via Merkle proofs." Nodes with different epoch-ending ledger infos will produce different merkle proofs for the same state queries.

The state checkpoint hash is stored in TransactionInfo and committed by the transaction accumulator: [10](#0-9) 

Different transaction accumulator hashes in competing epoch-ending ledger infos mean different state commitments, leading to permanent divergence.

## Likelihood Explanation

**Moderate-High Likelihood** in the presence of consensus bugs:

**Prerequisites**:
1. A consensus safety violation allows conflicting validly-signed epoch-ending ledger infos to exist
2. Network has nodes with different versions of epoch-ending ledger info
3. State synchronization occurs between divergent nodes

While BFT consensus should prevent conflicting ledger infos under <1/3 Byzantine validators, historical consensus bugs in production blockchains demonstrate this is not theoretical. Once conflicting ledger infos exist, the storage layer provides no defense.

**Amplification Factor**: Even if a consensus bug is quickly patched, nodes that synced during the vulnerable window can have mismatched epoch-ending ledger infos. Subsequent state sync operations can propagate the inconsistency, turning a transient consensus glitch into a persistent state fork.

## Recommendation

Add consistency validation to the state-sync storage path. Before storing epoch-ending ledger infos via `save_ledger_infos`, verify they don't conflict with existing data:

```rust
fn save_ledger_infos_impl(
    ledger_metadata_db: &LedgerMetadataDb,
    ledger_infos: &[LedgerInfoWithSignatures],
    batch: &mut SchemaBatch,
) -> Result<()> {
    for li in ledger_infos.iter() {
        let epoch = li.ledger_info().epoch();
        
        // Check if ledger info already exists for this epoch
        if let Ok(existing_li) = ledger_metadata_db.db().get::<LedgerInfoSchema>(&epoch)? {
            // Verify consistency - transaction accumulator hash must match
            ensure!(
                existing_li.ledger_info().transaction_accumulator_hash() 
                    == li.ledger_info().transaction_accumulator_hash(),
                "Attempting to overwrite epoch {} ledger info with different state commitment. \
                 Existing hash: {}, new hash: {}",
                epoch,
                existing_li.ledger_info().transaction_accumulator_hash(),
                li.ledger_info().transaction_accumulator_hash()
            )?;
            
            // Skip storing if identical to avoid unnecessary writes
            if &existing_li == li {
                continue;
            }
        }
        
        ledger_metadata_db.put_ledger_info(li, batch)?;
    }
    Ok(())
}
```

This ensures:
1. Existing epoch-ending ledger infos cannot be silently overwritten with different state commitments
2. State sync fails fast if inconsistency is detected
3. Manual intervention is required before proceeding, preventing automatic fork propagation

## Proof of Concept

While a full PoC requires complex consensus-layer setup to create conflicting ledger infos, the vulnerability can be demonstrated by:

```rust
#[test]
fn test_epoch_ending_ledger_info_overwrite_vulnerability() {
    // Setup: Create two different epoch-ending ledger infos for the same epoch
    // with different transaction accumulator hashes (representing different states)
    
    let epoch = 5;
    let version = 1000;
    
    // Create first ledger info with state root X
    let block_info_a = BlockInfo::new(
        epoch, 0, HashValue::random(),
        HashValue::sha3_256_of(b"state_root_X"), // Different state
        version, 0, Some(epoch_state_1.clone())
    );
    let ledger_info_a = LedgerInfo::new(block_info_a, HashValue::zero());
    let ledger_info_with_sigs_a = create_signed_ledger_info(ledger_info_a, &validators);
    
    // Create second ledger info with state root Y  
    let block_info_b = BlockInfo::new(
        epoch, 0, HashValue::random(),
        HashValue::sha3_256_of(b"state_root_Y"), // Different state
        version, 0, Some(epoch_state_2.clone())
    );
    let ledger_info_b = LedgerInfo::new(block_info_b, HashValue::zero());
    let ledger_info_with_sigs_b = create_signed_ledger_info(ledger_info_b, &validators);
    
    // Store first ledger info via state sync path
    restore_utils::save_ledger_infos(
        &db.ledger_db().metadata_db(),
        &[ledger_info_with_sigs_a.clone()],
        None
    ).unwrap();
    
    // Retrieve and verify first ledger info is stored
    let stored = db.ledger_db().metadata_db()
        .get_latest_ledger_info_in_epoch(epoch).unwrap();
    assert_eq!(stored.ledger_info().transaction_accumulator_hash(),
               ledger_info_a.transaction_accumulator_hash());
    
    // VULNERABILITY: Store second ledger info with different state root
    // This should fail but currently succeeds, overwriting the first
    restore_utils::save_ledger_infos(
        &db.ledger_db().metadata_db(),
        &[ledger_info_with_sigs_b.clone()],
        None
    ).unwrap(); // Currently succeeds!
    
    // Verify the overwrite occurred - state fork created
    let stored_after = db.ledger_db().metadata_db()
        .get_latest_ledger_info_in_epoch(epoch).unwrap();
    assert_eq!(stored_after.ledger_info().transaction_accumulator_hash(),
               ledger_info_b.transaction_accumulator_hash());
    assert_ne!(stored.ledger_info().transaction_accumulator_hash(),
               stored_after.ledger_info().transaction_accumulator_hash());
    // Node now has different epoch-ending state - FORK CONDITION
}
```

This demonstrates that the storage layer accepts and overwrites epoch-ending ledger infos with different state commitments without validation, creating the state fork condition described.

### Citations

**File:** storage/aptosdb/src/schema/ledger_info/mod.rs (L26-31)
```rust
define_schema!(
    LedgerInfoSchema,
    u64, /* epoch num */
    LedgerInfoWithSignatures,
    LEDGER_INFO_CF_NAME
);
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L200-205)
```rust
            // Save the epoch ending ledger infos
            restore_utils::save_ledger_infos(
                self.ledger_db.metadata_db(),
                ledger_infos,
                Some(&mut ledger_db_batch.ledger_metadata_db_batches),
            )?;
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L540-601)
```rust
    fn check_and_put_ledger_info(
        &self,
        version: Version,
        ledger_info_with_sig: &LedgerInfoWithSignatures,
        ledger_batch: &mut SchemaBatch,
    ) -> Result<(), AptosDbError> {
        let ledger_info = ledger_info_with_sig.ledger_info();

        // Verify the version.
        ensure!(
            ledger_info.version() == version,
            "Version in LedgerInfo doesn't match last version. {:?} vs {:?}",
            ledger_info.version(),
            version,
        );

        // Verify the root hash.
        let db_root_hash = self
            .ledger_db
            .transaction_accumulator_db()
            .get_root_hash(version)?;
        let li_root_hash = ledger_info_with_sig
            .ledger_info()
            .transaction_accumulator_hash();
        ensure!(
            db_root_hash == li_root_hash,
            "Root hash pre-committed doesn't match LedgerInfo. pre-commited: {:?} vs in LedgerInfo: {:?}",
            db_root_hash,
            li_root_hash,
        );

        // Verify epoch continuity.
        let current_epoch = self
            .ledger_db
            .metadata_db()
            .get_latest_ledger_info_option()
            .map_or(0, |li| li.ledger_info().next_block_epoch());
        ensure!(
            ledger_info_with_sig.ledger_info().epoch() == current_epoch,
            "Gap in epoch history. Trying to put in LedgerInfo in epoch: {}, current epoch: {}",
            ledger_info_with_sig.ledger_info().epoch(),
            current_epoch,
        );

        // Ensure that state tree at the end of the epoch is persisted.
        if ledger_info_with_sig.ledger_info().ends_epoch() {
            let state_snapshot = self.state_store.get_state_snapshot_before(version + 1)?;
            ensure!(
                state_snapshot.is_some() && state_snapshot.as_ref().unwrap().0 == version,
                "State checkpoint not persisted at the end of the epoch, version {}, next_epoch {}, snapshot in db: {:?}",
                version,
                ledger_info_with_sig.ledger_info().next_block_epoch(),
                state_snapshot,
            );
        }

        // Put write to batch.
        self.ledger_db
            .metadata_db()
            .put_ledger_info(ledger_info_with_sig, ledger_batch)?;
        Ok(())
    }
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L179-190)
```rust
fn save_ledger_infos_impl(
    ledger_metadata_db: &LedgerMetadataDb,
    ledger_infos: &[LedgerInfoWithSignatures],
    batch: &mut SchemaBatch,
) -> Result<()> {
    ledger_infos
        .iter()
        .map(|li| ledger_metadata_db.put_ledger_info(li, batch))
        .collect::<Result<Vec<_>>>()?;

    Ok(())
}
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L186-198)
```rust
    pub(crate) fn put_ledger_info(
        &self,
        ledger_info_with_sigs: &LedgerInfoWithSignatures,
        batch: &mut SchemaBatch,
    ) -> Result<()> {
        let ledger_info = ledger_info_with_sigs.ledger_info();

        if ledger_info.ends_epoch() {
            // This is the last version of the current epoch, update the epoch by version index.
            batch.put::<EpochByVersionSchema>(&ledger_info.version(), &ledger_info.epoch())?;
        }
        batch.put::<LedgerInfoSchema>(&ledger_info.epoch(), ledger_info_with_sigs)
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L98-129)
```rust
    pub fn update_verified_epoch_states(
        &mut self,
        epoch_ending_ledger_info: &LedgerInfoWithSignatures,
        waypoint: &Waypoint,
    ) -> Result<(), Error> {
        // Verify the ledger info against the latest epoch state
        self.latest_epoch_state
            .verify(epoch_ending_ledger_info)
            .map_err(|error| {
                Error::VerificationError(format!("Ledger info failed verification: {:?}", error))
            })?;

        // Update the latest epoch state with the next epoch
        if let Some(next_epoch_state) = epoch_ending_ledger_info.ledger_info().next_epoch_state() {
            self.highest_fetched_epoch_ending_version =
                epoch_ending_ledger_info.ledger_info().version();
            self.latest_epoch_state = next_epoch_state.clone();
            self.insert_new_epoch_ending_ledger_info(epoch_ending_ledger_info.clone())?;

            trace!(LogSchema::new(LogEntry::Bootstrapper).message(&format!(
                "Updated the latest epoch state to epoch: {:?}",
                self.latest_epoch_state.epoch
            )));
        } else {
            return Err(Error::VerificationError(
                "The ledger info was not epoch ending!".into(),
            ));
        }

        // Check if the ledger info corresponds to the trusted waypoint
        self.verify_waypoint(epoch_ending_ledger_info, waypoint)
    }
```

**File:** types/src/transaction/mod.rs (L2044-2047)
```rust
    /// The root hash of the Sparse Merkle Tree describing the world state at the end of this
    /// transaction. Depending on the protocol configuration, this can be generated periodical
    /// only, like per block.
    state_checkpoint_hash: Option<HashValue>,
```
