# Audit Report

## Title
Unbounded Memory Consumption in REST Client's `get_account_resources()` Leading to OOM Crash

## Summary
The `get_account_resources()` function in the Aptos REST client accumulates paginated responses without any limit on total size or number of pages, allowing a malicious REST API endpoint to cause Out-Of-Memory conditions by returning unlimited paginated data.

## Finding Description
The Aptos REST client's `get_account_resources()` function calls `paginate_with_cursor()` which implements pagination by continuously fetching data from the server and accumulating results in a `Vec<T>` without any bounds checking. [1](#0-0) 

The vulnerable pagination implementation creates an unbounded vector and loops indefinitely as long as the server returns a cursor in the response. [2](#0-1) 

Each iteration makes an HTTP GET request, deserializes the response, and extends the result vector without checking:
1. Total accumulated data size
2. Total number of pagination iterations
3. Maximum operation timeout
4. Cursor validity or authenticity

A malicious REST API endpoint can exploit this by:
1. Returning the maximum page size (9999 resources per page) in each response [3](#0-2) 
2. Including a cursor field in every response to trigger the next pagination request
3. Returning arbitrarily large resource data within each resource object
4. Continuing this pattern indefinitely until the client runs out of memory

The client blindly trusts the cursor returned by the server and has no mechanism to validate its authenticity or limit total data accumulation.

## Impact Explanation
This is a **High severity** vulnerability per the Aptos bug bounty criteria because it causes **API crashes** and client application crashes through resource exhaustion. 

When a client application (such as CLI tools, wallets, indexers, or monitoring systems) connects to a malicious or compromised REST API endpoint and calls `get_account_resources()`, the unbounded memory accumulation will eventually exhaust all available memory, causing the application to crash with an OOM error.

Impact scenarios:
- **Wallets**: Users connecting to a malicious node could have their wallet applications crash
- **Indexers**: Blockchain indexers fetching account data could be crashed, disrupting services
- **Monitoring tools**: DevOps tools querying account state could be taken down
- **CLI utilities**: Command-line tools used by developers could be exploited

This breaks the **Resource Limits** invariant (#9: "All operations must respect gas, storage, and computational limits") by allowing unbounded memory consumption on the client side.

## Likelihood Explanation
Likelihood is **MEDIUM-HIGH** because:

**Attack feasibility:**
- No special privileges required - any attacker can set up a malicious REST API endpoint
- Attack is straightforward - simply return valid-looking paginated responses with cursors
- No cryptographic bypasses needed
- Attack works against any client using the official REST client library

**Real-world scenarios:**
- Users might be tricked into connecting to malicious endpoints via phishing
- Compromised nodes could be exploited to attack connected clients
- Man-in-the-middle attacks could inject malicious responses
- Load-balanced endpoint pools might include compromised nodes

The main limiting factor is that users must explicitly connect to or be redirected to a malicious endpoint, but this is a common attack vector in blockchain ecosystems.

## Recommendation
Implement multiple defensive measures in the `paginate_with_cursor()` function:

1. **Add maximum total result size limit:**
```rust
const MAX_TOTAL_RESULT_SIZE: usize = 100_000_000; // 100MB limit
```

2. **Add maximum pagination iteration limit:**
```rust
const MAX_PAGINATION_ITERATIONS: usize = 1000;
```

3. **Add operation timeout:**
```rust
const MAX_PAGINATION_TIMEOUT: Duration = Duration::from_secs(300);
```

4. **Track accumulated size and iterations:**
```rust
pub async fn paginate_with_cursor<T: for<'a> Deserialize<'a>>(
    &self,
    base_path: &str,
    limit_per_request: u64,
    ledger_version: Option<u64>,
) -> AptosResult<Response<Vec<T>>> {
    let mut result = Vec::new();
    let mut cursor: Option<String> = None;
    let mut iterations = 0;
    let mut total_size_estimate = 0;
    let start_time = Instant::now();

    loop {
        if iterations >= MAX_PAGINATION_ITERATIONS {
            return Err(anyhow!("Exceeded maximum pagination iterations").into());
        }
        if start_time.elapsed() > MAX_PAGINATION_TIMEOUT {
            return Err(anyhow!("Pagination timeout exceeded").into());
        }
        
        let url = self.build_url_for_pagination(...)?;
        let raw_response = self.inner.get(url).send().await?;
        let response: Response<Vec<T>> = self.json(raw_response).await?;
        
        let page_size = response.inner().len();
        total_size_estimate += page_size * std::mem::size_of::<T>();
        
        if total_size_estimate > MAX_TOTAL_RESULT_SIZE {
            return Err(anyhow!("Exceeded maximum total result size").into());
        }
        
        cursor.clone_from(&response.state().cursor);
        iterations += 1;
        
        if cursor.is_none() {
            break Ok(response.map(|mut v| {
                result.append(&mut v);
                result
            }));
        } else {
            result.extend(response.into_inner());
        }
    }
}
```

5. **Add warnings to documentation** about connecting only to trusted endpoints and the risks of malicious servers.

## Proof of Concept

```rust
// Mock malicious server that returns unlimited pages
use tokio;
use axum::{Router, Json, routing::get, extract::Query};
use serde::{Deserialize, Serialize};
use std::collections::HashMap;

#[derive(Deserialize)]
struct Params {
    limit: Option<u64>,
    start: Option<String>,
}

#[derive(Serialize)]
struct Resource {
    #[serde(rename = "type")]
    resource_type: String,
    data: Vec<u8>, // Arbitrarily large data
}

#[derive(Serialize)]
struct PaginatedResponse {
    data: Vec<Resource>,
    #[serde(skip_serializing_if = "Option::is_none")]
    cursor: Option<String>,
}

async fn malicious_resources_endpoint(Query(params): Query<Params>) -> Json<PaginatedResponse> {
    let limit = params.limit.unwrap_or(9999);
    
    // Always return full page of resources with large data
    let resources: Vec<Resource> = (0..limit)
        .map(|i| Resource {
            resource_type: format!("0x1::malicious::Resource{}", i),
            data: vec![0u8; 1024 * 1024], // 1MB per resource
        })
        .collect();
    
    // Always return a cursor to trigger next page
    Json(PaginatedResponse {
        data: resources,
        cursor: Some("next_page".to_string()),
    })
}

#[tokio::main]
async fn main() {
    // Start malicious server
    let app = Router::new()
        .route("/v1/accounts/:address/resources", get(malicious_resources_endpoint));
    
    // Client will crash when calling get_account_resources()
    // as it accumulates: 9999 resources × 1MB × unlimited pages = OOM
}
```

**To test:**
1. Run the malicious server above
2. Configure the Aptos REST client to connect to it
3. Call `get_account_resources()` for any address
4. Observe memory consumption grow unbounded until crash

**Notes**

This vulnerability is specific to the REST client library when connecting to untrusted or compromised endpoints. The official Aptos REST API servers have proper pagination limits [4](#0-3)  and would not exploit this, but the client should still defend against malicious endpoints to ensure robust security posture.

The referenced example file `aptos-core/crates/aptos-rest-client/examples/account/main.rs` does not exist in this repository, but the core vulnerability exists in the `get_account_resources()` function itself within the REST client library.

### Citations

**File:** crates/aptos-rest-client/src/lib.rs (L64-64)
```rust
const RESOURCES_PER_CALL_PAGINATION: u64 = 9999;
```

**File:** crates/aptos-rest-client/src/lib.rs (L1118-1128)
```rust
    pub async fn get_account_resources(
        &self,
        address: AccountAddress,
    ) -> AptosResult<Response<Vec<Resource>>> {
        self.paginate_with_cursor(
            &format!("accounts/{}/resources", address.to_hex()),
            RESOURCES_PER_CALL_PAGINATION,
            None,
        )
        .await
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L1858-1886)
```rust
    pub async fn paginate_with_cursor<T: for<'a> Deserialize<'a>>(
        &self,
        base_path: &str,
        limit_per_request: u64,
        ledger_version: Option<u64>,
    ) -> AptosResult<Response<Vec<T>>> {
        let mut result = Vec::new();
        let mut cursor: Option<String> = None;

        loop {
            let url = self.build_url_for_pagination(
                base_path,
                limit_per_request,
                ledger_version,
                &cursor,
            )?;
            let raw_response = self.inner.get(url).send().await?;
            let response: Response<Vec<T>> = self.json(raw_response).await?;
            cursor.clone_from(&response.state().cursor);
            if cursor.is_none() {
                break Ok(response.map(|mut v| {
                    result.append(&mut v);
                    result
                }));
            } else {
                result.extend(response.into_inner());
            }
        }
    }
```

**File:** config/src/config/api_config.rs (L100-100)
```rust
const DEFAULT_MAX_ACCOUNT_RESOURCES_PAGE_SIZE: u16 = 9999;
```
