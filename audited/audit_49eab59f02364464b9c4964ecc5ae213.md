# Audit Report

## Title
Identifier Length Validation Discrepancy Between Transaction Payloads and Module Bytecode

## Summary
The `EntryFunctionPayload` struct in transaction processing lacks explicit identifier length validation, creating a discrepancy with compiled modules which enforce strict limits (255 or 65535 bytes). While transaction size limits provide an upper bound, identifiers can be significantly larger than what would be accepted in published modules, potentially causing resource consumption through repeated string allocations.

## Finding Description

The Aptos codebase enforces different identifier length constraints depending on the context:

**Module Bytecode**: When deserializing compiled Move modules, identifiers are strictly limited: [1](#0-0) 

These limits are enforced during module deserialization: [2](#0-1) 

**Transaction Payloads**: The `EntryFunctionPayload` struct stores identifiers as unbounded Rust `String` types: [3](#0-2) 

Transaction validation only checks for `"::"` characters, not length: [4](#0-3) 

During transaction processing, when `EntryFunction` is converted to `EntryFunctionPayload`, identifiers are converted to strings without length validation: [5](#0-4) 

The payload is cloned when accessed: [6](#0-5) 

And accessed during native function execution: [7](#0-6) 

## Impact Explanation

This issue represents a **validation gap** rather than a critical vulnerability. The impact is limited to **Low severity** because:

1. **Transaction size limits** cap total payload at 64KB [8](#0-7) 

2. **Gas charging** is proportional to string length [9](#0-8) 

3. **Economic disincentives**: Attackers pay fees for transactions that will inevitably fail when the VM cannot resolve the oversized identifiers

4. **No consensus impact**: This cannot cause state divergence or safety violations since all nodes process identifiers identically

While an attacker could craft transactions with identifiers approaching 64KB (much larger than the 255-byte module limit), the actual security harm is negligible due to existing resource controls.

## Likelihood Explanation

An attacker could easily exploit this validation gap (high likelihood of execution), but the attack provides minimal benefit:

- Attacker pays transaction fees for each submission
- Mempool limits constrain submission rate
- Transactions fail during execution, consuming attacker's gas
- No state changes or fund theft occurs
- Resource consumption is bounded by transaction size limits

The validation inconsistency exists and is exploitable, but lacks meaningful security impact beyond inefficient resource usage.

## Recommendation

Add explicit identifier length validation during transaction submission to match module constraints:

```rust
// In api/types/src/move_types.rs
pub fn verify_module_identifier(module: &str) -> anyhow::Result<()> {
    if module.len() > IDENTIFIER_SIZE_MAX as usize {
        return Err(format_err!("Module identifier exceeds maximum length: {}", module.len()));
    }
    verify_identifier(module).map_err(|_| format_err!("invalid Move module name: {}", module))
}

pub fn verify_function_identifier(function: &str) -> anyhow::Result<()> {
    if function.len() > IDENTIFIER_SIZE_MAX as usize {
        return Err(format_err!("Function identifier exceeds maximum length: {}", function.len()));
    }
    verify_identifier(function).map_err(|_| format_err!("invalid Move function name: {}", function))
}
```

This aligns transaction validation with module bytecode constraints, preventing unnecessary resource consumption from oversized identifiers.

## Proof of Concept

```rust
// Test demonstrating oversized identifier acceptance
#[test]
fn test_oversized_identifier_in_transaction() {
    use aptos_types::transaction::{EntryFunction, ModuleId};
    use move_core_types::{account_address::AccountAddress, identifier::Identifier};
    
    // Create identifier exceeding module limit (255 bytes) but within transaction limit
    let oversized_name = "a".repeat(1000);
    
    // This bypasses validation using JSON deserialization (as shown in tests)
    #[derive(serde::Serialize)]
    struct HackStruct(pub Box<str>);
    
    let module_id: Identifier = serde_json::from_str(
        &serde_json::to_string(&HackStruct(oversized_name.clone().into())).unwrap()
    ).unwrap();
    
    // EntryFunction can be created with oversized identifiers
    let entry_fn = EntryFunction::new(
        ModuleId::new(AccountAddress::ONE, module_id.clone()),
        module_id,
        vec![],
        vec![],
    );
    
    // Convert to payload - no length validation occurs
    let payload = entry_fn.as_entry_function_payload();
    assert!(payload.module_name.len() > 255);
    
    // This would be accepted by API validation (only checks for "::")
    // but would fail during execution when VM cannot resolve the function
}
```

---

**Note**: While this report documents a genuine validation discrepancy, the security impact does not meet the **Medium severity threshold** required by the bug bounty program. The issue is more appropriately classified as a **Low severity** implementation inconsistency due to comprehensive existing mitigations (transaction size limits, gas charging, economic disincentives, and mempool controls).

### Citations

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L66-67)
```rust
pub const LEGACY_IDENTIFIER_SIZE_MAX: u64 = 65535;
pub const IDENTIFIER_SIZE_MAX: u64 = 255;
```

**File:** third_party/move/move-binary-format/src/deserializer.rs (L46-48)
```rust
    pub fn deserialize(binary: &[u8]) -> BinaryLoaderResult<Self> {
        let config = DeserializerConfig::new(VERSION_MAX, IDENTIFIER_SIZE_MAX);
        Self::deserialize_with_config(binary, &config)
```

**File:** types/src/transaction/user_transaction_context.rs (L84-86)
```rust
    pub fn entry_function_payload(&self) -> Option<EntryFunctionPayload> {
        self.entry_function_payload.clone()
    }
```

**File:** types/src/transaction/user_transaction_context.rs (L98-104)
```rust
pub struct EntryFunctionPayload {
    pub account_address: AccountAddress,
    pub module_name: String,
    pub function_name: String,
    pub ty_arg_names: Vec<String>,
    pub args: Vec<Vec<u8>>,
}
```

**File:** api/types/src/move_types.rs (L1457-1477)
```rust
pub fn verify_function_identifier(function: &str) -> anyhow::Result<()> {
    verify_identifier(function).map_err(|_| format_err!("invalid Move function name: {}", function))
}
pub fn verify_module_identifier(module: &str) -> anyhow::Result<()> {
    verify_identifier(module).map_err(|_| format_err!("invalid Move module name: {}", module))
}

pub fn verify_field_identifier(field: &str) -> anyhow::Result<()> {
    verify_identifier(field).map_err(|_| format_err!("invalid Move field name: {}", field))
}

pub fn verify_identifier(identifier: &str) -> anyhow::Result<()> {
    if identifier.contains("::") {
        Err(format_err!(
            "Identifier should not contain '::' {}",
            identifier
        ))
    } else {
        Ok(())
    }
}
```

**File:** types/src/transaction/script.rs (L152-163)
```rust
    pub fn as_entry_function_payload(&self) -> EntryFunctionPayload {
        EntryFunctionPayload::new(
            self.module.address,
            self.module.name().to_string(),
            self.function.to_string(),
            self.ty_args
                .iter()
                .map(|ty| ty.to_canonical_string())
                .collect(),
            self.args.clone(),
        )
    }
```

**File:** aptos-move/framework/src/natives/transaction_context.rs (L402-416)
```rust
fn num_bytes_from_entry_function_payload(entry_function_payload: &EntryFunctionPayload) -> usize {
    entry_function_payload.account_address.len()
        + entry_function_payload.module_name.len()
        + entry_function_payload.function_name.len()
        + entry_function_payload
            .ty_arg_names
            .iter()
            .map(|s| s.len())
            .sum::<usize>()
        + entry_function_payload
            .args
            .iter()
            .map(|v| v.len())
            .sum::<usize>()
}
```

**File:** aptos-move/framework/src/natives/transaction_context.rs (L453-459)
```rust
        if let Some(entry_function_payload) = transaction_context.entry_function_payload() {
            let num_bytes = num_bytes_from_entry_function_payload(&entry_function_payload);
            context.charge(
                TRANSACTION_CONTEXT_ENTRY_FUNCTION_PAYLOAD_PER_BYTE_IN_STR
                    * NumBytes::new(num_bytes as u64),
            )?;
            let payload = create_entry_function_payload(entry_function_payload)?;
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L73-76)
```rust
            max_transaction_size_in_bytes: NumBytes,
            "max_transaction_size_in_bytes",
            64 * 1024
        ],
```
