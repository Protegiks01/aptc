# Audit Report

## Title
State Corruption via Missing Layout in V0 Resource Group Processing with Delayed Fields

## Summary
When resource groups are processed using the V0 path, individual resource layouts are discarded during merge operations. If resource group members contain delayed fields (Aggregators, Snapshots, or DerivedStrings), the merged resource group write will have a `None` layout, causing it to bypass delayed field materialization and resulting in state corruption with ephemeral DelayedFieldIDs persisted to storage.

## Finding Description

The vulnerability occurs in the V0 resource group processing path where layouts are systematically discarded: [1](#0-0) 

In the `populate_v0_resource_group_change_set` function, when individual resource group members are processed, their layouts are explicitly discarded. The final merged resource group operation is created with `None` layout, regardless of whether member resources contain delayed fields.

This breaks the delayed field tracking invariant because:

1. **Layout Detection**: When resources contain delayed fields, layouts are correctly computed and attached: [2](#0-1) 

2. **Layout Conversion**: The `from_resource_write_with_maybe_layout` function creates either `WriteWithDelayedFields` (if layout exists) or simple `Write` (if layout is None): [3](#0-2) 

3. **Materialization Filtering**: The `resource_writes_to_materialize` macro only processes writes that have layouts: [4](#0-3) 

When V0 resource groups contain delayed fields, the DelayedFieldIDs are never materialized into actual values, causing the ephemeral identifiers to be persisted to storage. This breaks the **Deterministic Execution** and **State Consistency** invariants, as different nodes may have different DelayedFieldID values for the same transaction, leading to state divergence.

## Impact Explanation

This is a **Critical Severity** vulnerability under the Aptos bug bounty criteria for the following reasons:

1. **Consensus/Safety Violation**: Different validators will produce different state roots for identical blocks due to unmaterialized DelayedFieldIDs being serialized with transaction-specific ephemeral values.

2. **State Consistency Break**: Resources with unmaterialized DelayedFieldIDs become unreadable or produce incorrect values on subsequent reads, breaking the atomic state transition guarantee.

3. **Permanent State Corruption**: Once corrupted DelayedFieldIDs are written to storage and committed in a block, they become part of the permanent chain state, potentially requiring a hard fork to recover.

The vulnerability affects all validators processing transactions that modify resource groups containing delayed fields via the V0 path.

## Likelihood Explanation

The likelihood depends on whether the V0 resource group path is actively used. The V0 path is triggered when `maybe_resource_group_cache.is_some()`: [5](#0-4) 

If V0 resource groups are still supported for backward compatibility or specific use cases, and if resource group members can contain delayed fields (Aggregators, Snapshots), then this vulnerability is **highly likely** to manifest during normal operation.

The likelihood is reduced if:
- V0 resource groups are deprecated and no longer used in production
- Resource group members are restricted from containing delayed field types
- The feature flag for delayed field optimization is disabled by default (as indicated in the config) [6](#0-5) 

## Recommendation

The fix should preserve layouts when merging V0 resource groups. Two approaches:

**Approach 1 (Preferred)**: Deprecate V0 resource groups entirely and migrate all resource groups to V1 format, which properly handles layouts: [7](#0-6) 

**Approach 2**: If V0 must be maintained, compute a combined layout for the merged resource group that accounts for all member layouts. This would require:
- Collecting all member layouts during the merge
- Creating a combined layout that represents the entire resource group structure
- Checking for delayed fields in any member and propagating that information to the merged write

Additionally, add validation to reject resource group members containing delayed fields if V0 processing cannot handle them properly.

## Proof of Concept

```rust
// Conceptual PoC - would require full test harness setup

// 1. Create a resource group containing a member with an Aggregator delayed field
module 0x1::test_resource_group {
    use aptos_framework::aggregator_v2::Aggregator;
    
    #[resource_group_member(group = 0x1::resource_group::TestGroup)]
    struct MemberWithAggregator has key {
        agg: Aggregator<u64>,
        value: u64,
    }
}

// 2. Execute a transaction that:
//    - Forces V0 resource group processing (by setting up the resolver with resource_group_cache)
//    - Modifies the MemberWithAggregator resource
//    - Contains delayed field changes to the aggregator

// 3. Observe that:
//    - The individual resource has a layout with contains_delayed_fields=true
//    - During populate_v0_resource_group_change_set, the layout is discarded
//    - The merged write has layout=None
//    - from_resource_write_with_maybe_layout creates a simple Write
//    - resource_writes_to_materialize skips it (no layout)
//    - DelayedFieldID is persisted unmaterialized to storage
//    - Subsequent reads fail or produce corrupted data
```

## Notes

The validation requires verification that:
1. V0 resource groups are still actively used in production Aptos validators
2. Resource group members can contain delayed field types (Aggregator, Snapshot, DerivedString)
3. The delayed field optimization is enabled during block execution (it is, per the block executor code)

If V0 resource groups are completely deprecated or if resource group members are prohibited from containing delayed fields through other validation layers, this vulnerability may not be exploitable in practice.

### Citations

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/mod.rs (L173-203)
```rust
        let resource_converter = |value: Value,
                                  layout: TriompheArc<MoveTypeLayout>,
                                  has_aggregator_lifting: bool|
         -> PartialVMResult<BytesWithResourceLayout> {
            let serialization_result = if has_aggregator_lifting {
                // We allow serialization of native values here because we want to
                // temporarily store native values (via encoding to ensure deterministic
                // gas charging) in block storage.
                ValueSerDeContext::new(function_extension.max_value_nest_depth())
                    .with_delayed_fields_serde()
                    .with_func_args_deserialization(&function_extension)
                    .serialize(&value, &layout)?
                    .map(|bytes| (bytes.into(), Some(layout)))
            } else {
                // Otherwise, there should be no native values so ensure
                // serialization fails here if there are any.
                ValueSerDeContext::new(function_extension.max_value_nest_depth())
                    .with_func_args_deserialization(&function_extension)
                    .serialize(&value, &layout)?
                    .map(|bytes| (bytes.into(), None))
            };
            serialization_result.ok_or_else(|| {
                let status_code = if is_1_38_release {
                    StatusCode::VALUE_SERIALIZATION_ERROR
                } else {
                    StatusCode::INTERNAL_TYPE_ERROR
                };
                PartialVMError::new(status_code)
                    .with_message(format!("Error when serializing resource {}.", value))
            })
        };
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/mod.rs (L261-311)
```rust
    fn populate_v0_resource_group_change_set(
        change_set: &mut BTreeMap<StateKey, MoveStorageOp<BytesWithResourceLayout>>,
        state_key: StateKey,
        mut source_data: BTreeMap<StructTag, Bytes>,
        resources: BTreeMap<StructTag, MoveStorageOp<BytesWithResourceLayout>>,
    ) -> PartialVMResult<()> {
        let common_error = || {
            PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                .with_message("populate v0 resource group change set error".to_string())
        };

        let create = source_data.is_empty();

        for (struct_tag, current_op) in resources {
            match current_op {
                MoveStorageOp::Delete => {
                    source_data.remove(&struct_tag).ok_or_else(common_error)?;
                },
                MoveStorageOp::Modify((new_data, _)) => {
                    let data = source_data.get_mut(&struct_tag).ok_or_else(common_error)?;
                    *data = new_data;
                },
                MoveStorageOp::New((data, _)) => {
                    let data = source_data.insert(struct_tag, data);
                    if data.is_some() {
                        return Err(common_error());
                    }
                },
            }
        }

        let op = if source_data.is_empty() {
            MoveStorageOp::Delete
        } else if create {
            MoveStorageOp::New((
                bcs::to_bytes(&source_data)
                    .map_err(|_| common_error())?
                    .into(),
                None,
            ))
        } else {
            MoveStorageOp::Modify((
                bcs::to_bytes(&source_data)
                    .map_err(|_| common_error())?
                    .into(),
                None,
            ))
        };
        change_set.insert(state_key, op);
        Ok(())
    }
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/mod.rs (L347-356)
```rust
        let mut maybe_resource_group_cache = resolver.release_resource_group_cache().map(|v| {
            v.into_iter()
                .map(|(k, v)| (k, v.into_iter().collect::<BTreeMap<_, _>>()))
                .collect::<BTreeMap<_, _>>()
        });
        let mut resource_group_change_set = if maybe_resource_group_cache.is_some() {
            ResourceGroupChangeSet::V0(BTreeMap::new())
        } else {
            ResourceGroupChangeSet::V1(BTreeMap::new())
        };
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/mod.rs (L414-426)
```rust
                    ResourceGroupChangeSet::V1(v1_changes) => {
                        // Maintain the behavior of failing the transaction on resource
                        // group member existence invariants.
                        for (struct_tag, current_op) in resources.iter() {
                            let exists =
                                resolver.resource_exists_in_group(&state_key, struct_tag)?;
                            if matches!(current_op, MoveStorageOp::New(_)) == exists {
                                // Deletion and Modification require resource to exist,
                                // while creation requires the resource to not exist.
                                return Err(common_error());
                            }
                        }
                        v1_changes.insert(state_key, resources);
```

**File:** aptos-move/aptos-vm-types/src/abstract_write_op.rs (L130-145)
```rust
    pub fn from_resource_write_with_maybe_layout(
        write_op: WriteOp,
        maybe_layout: Option<TriompheArc<MoveTypeLayout>>,
    ) -> Self {
        match maybe_layout {
            Some(layout) => {
                let materialized_size = write_op.write_op_size().write_len();
                Self::WriteWithDelayedFields(WriteWithDelayedFieldsOp {
                    write_op,
                    layout,
                    materialized_size,
                })
            },
            None => Self::Write(write_op),
        }
    }
```

**File:** aptos-move/block-executor/src/executor_utilities.rs (L74-78)
```rust
	        $writes.into_iter().filter_map(|(key, (value, maybe_layout))| {
		        maybe_layout.map(|layout| {
                    (!value.is_deletion()).then_some(Ok((key, value, layout)))
                }).flatten()
            })
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L250-252)
```rust
        // By default, do not use delayed field optimization. Instead, clients should enable it
        // manually where applicable.
        delayed_field_optimization_enabled: false,
```
