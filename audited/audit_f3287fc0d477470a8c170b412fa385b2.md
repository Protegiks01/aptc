# Audit Report

## Title
Legacy Storage Slots Bypass V2 Storage Fee Increases Through Same-Size Modification Loophole

## Summary
The V2 storage pricing logic contains a bypass that allows holders of legacy state slots (created under V1 pricing with `bytes_deposit = 0`) to avoid storage fee charges when modifying their slots at the same size, even as storage pricing increases through governance. This creates a permanent economic advantage for legacy slot holders and violates the principle of uniform storage pricing.

## Finding Description

The vulnerability exists in the V2 storage pricing implementation where state slots created under the V1 pricing model (before gas_feature_version 13) have their `bytes_deposit` field set to zero. [1](#0-0) 

When the network upgraded to V2 pricing, all existing slots were converted with `bytes_deposit = 0`, creating "legacy slots." The V2 modification logic only charges for storage when the write size increases: [2](#0-1) 

The critical condition at line 191 requires **both** `write_len > op.prev_size` AND `target_bytes_deposit > old_bytes_deposit` to trigger a charge. For same-size modifications (`write_len == op.prev_size`), no charge is applied regardless of pricing changes: [3](#0-2) 

**Attack Scenario:**

1. **Pre-V2**: Attacker creates state slots under V1 pricing (e.g., 100 bytes of NFT metadata)
   - Metadata stored: `bytes_deposit = 0`, `slot_deposit = X`

2. **V2 Activation**: Network upgrades to V2 pricing (gas_feature_version >= 13)

3. **Pricing Increase**: Governance increases `storage_fee_per_state_byte` from 40 to 400 (10x increase) to combat state bloat
   - New users must pay: `slot_deposit + (key_size + 100) * 400`
   - Legacy slots maintain: `bytes_deposit = 0`

4. **Bypass Exploitation**: Attacker repeatedly modifies legacy slots at exactly 100 bytes
   - Condition `write_len > op.prev_size` evaluates to FALSE (100 == 100)
   - `state_bytes_charge = 0` (no charge applied)
   - Attacker pays **nothing** for storage that new users pay 10x for

5. **Permanent Advantage**: As long as modifications stay at the same size, the attacker never pays increased storage fees

The test suite explicitly confirms this behavior: [4](#0-3) 

This breaks **Invariant #9 (Resource Limits)**: All operations must respect storage limits uniformly. Different users pay dramatically different amounts for identical storage usage.

## Impact Explanation

**Severity: Medium** (per Aptos Bug Bounty criteria)

This vulnerability falls under "Limited funds loss or manipulation" and "State inconsistencies requiring intervention":

1. **Economic Bypass**: Legacy slot holders avoid storage fee increases entirely by keeping modifications at the same size, creating unfair pricing across the network

2. **Storage Fee Loss**: The protocol loses storage fee revenue from legacy slots. If storage pricing increases 10x and 1% of state consists of legacy slots modified at the same size, the network loses 9% of expected storage fees from that subset

3. **Fairness Violation**: New users pay current market rates while legacy users pay zero for byte storage, violating the economic security model

4. **Governance Effectiveness**: Storage pricing governance decisions (intended to control state bloat) are partially bypassed, reducing the effectiveness of economic security controls

5. **Limited Scale**: While exploitable, the impact is bounded by:
   - Only affects slots created before V2 activation
   - Requires keeping exact same size (limits flexibility)
   - Slot deposit is still charged on creation
   - Pricing can be adjusted for new slots

The vulnerability does not affect consensus safety, validator operations, or network availability, limiting it to Medium severity.

## Likelihood Explanation

**Likelihood: High**

The vulnerability is highly likely to be exploited because:

1. **No Special Requirements**: Any user who owns legacy state slots can exploit this by simply modifying data at the same size

2. **Persistent Advantage**: The bypass is permanent - legacy slots maintain their advantage indefinitely

3. **Economic Incentive**: As storage pricing increases (which governance may do to combat state bloat), the economic incentive to exploit this grows proportionally

4. **Simple Execution**: Exploitation requires no special knowledge - just normal state modification transactions keeping size constant

5. **Already Deployed**: Legacy slots already exist on mainnet from before V2 activation, making this immediately exploitable

6. **Testable Behavior**: The test suite confirms this is working-as-coded behavior: [5](#0-4) 

The primary barrier to exploitation is awareness - once known, rational actors will exploit this to minimize storage costs.

## Recommendation

Implement a "catch-up" mechanism that charges legacy slots for the pricing differential when modified, even at the same size:

```rust
Modification { write_len } => {
    let old_bytes_deposit = op.metadata_mut.bytes_deposit();
    let state_bytes_charge = if write_len > op.prev_size && target_bytes_deposit > old_bytes_deposit {
        // Existing logic for size increases
        let charge_by_increase: u64 = (write_len - op.prev_size)
            * u64::from(params.storage_fee_per_state_byte);
        let gap_from_target = target_bytes_deposit - old_bytes_deposit;
        std::cmp::min(charge_by_increase, gap_from_target)
    } else if target_bytes_deposit > old_bytes_deposit {
        // NEW: Charge for pricing increases even at same size
        // This gradually brings legacy slots up to current pricing
        target_bytes_deposit - old_bytes_deposit
    } else {
        0
    };
    
    op.metadata_mut.maybe_upgrade();
    op.metadata_mut.set_bytes_deposit(old_bytes_deposit + state_bytes_charge);
    
    ChargeAndRefund {
        charge: state_bytes_charge.into(),
        refund: 0.into(),
    }
}
```

**Alternative (Gentler Approach)**: Implement a gradual catch-up that charges a fraction of the pricing gap on each modification to avoid shocking legacy users:

```rust
} else if target_bytes_deposit > old_bytes_deposit {
    // Charge 10% of the pricing gap per modification
    ((target_bytes_deposit - old_bytes_deposit) * 10) / 100
}
```

This preserves the refundability benefits of V2 while ensuring fair pricing across all users.

## Proof of Concept

The existing test suite already demonstrates the vulnerability. Here's an extended PoC showing the pricing increase scenario:

```rust
#[test]
fn test_legacy_slot_pricing_bypass() {
    let pricing = DiskSpacePricing::V2;
    let mut params = TransactionGasParameters::random();
    
    // Initial V2 pricing
    params.storage_fee_per_state_byte = 40.into();
    params.storage_fee_per_state_slot = 1000.into();
    
    let key = StateKey::raw(&[1, 2, 3]);
    let ts = CurrentTimeMicroseconds { microseconds: 0 };
    let mut legacy_meta = StateValueMetadata::new(1000, 0, &ts); // Legacy slot: bytes_deposit = 0
    
    // Scenario: Storage pricing increases 10x (from 40 to 400)
    params.storage_fee_per_state_byte = 400.into();
    
    // Legacy slot modification at same size (100 bytes)
    let ChargeAndRefund { charge: legacy_charge, .. } = 
        pricing.charge_refund_write_op(&params, WriteOpInfo {
            key: &key,
            op_size: WriteOpSize::Modification { write_len: 100 },
            prev_size: 100,
            metadata_mut: &mut legacy_meta,
        });
    
    // Legacy slot pays NOTHING
    assert_eq!(legacy_charge, 0.into());
    assert_eq!(legacy_meta.bytes_deposit(), 0);
    
    // New slot at same size pays full current pricing
    let mut new_meta = StateValueMetadata::new(0, 0, &ts);
    let ChargeAndRefund { charge: new_charge, .. } = 
        pricing.charge_refund_write_op(&params, WriteOpInfo {
            key: &key,
            op_size: WriteOpSize::Creation { write_len: 100 },
            prev_size: 0,
            metadata_mut: &mut new_meta,
        });
    
    // New slot pays: slot_deposit (1000) + bytes_deposit ((3+100)*400 = 41200) = 42200
    assert_eq!(new_charge, 42200.into());
    
    // VULNERABILITY: Legacy slot holder has permanent 42200 gas unit advantage
    // for the same 100 bytes of storage, simply by keeping size constant
}
```

---

## Notes

This vulnerability represents an **intentional design choice** that creates unintended economic consequences. The comments in the code explicitly acknowledge the behavior ("If slot doesn't change in size on modification, no charging even if pricing changes"), suggesting the developers were aware of this policy. However, the security impact of creating a permanent pricing bypass for legacy slot holders appears not to have been fully considered, particularly as storage pricing may need to increase significantly over time to combat state bloat.

### Citations

**File:** types/src/state_store/state_value.rs (L31-43)
```rust
    pub fn into_in_mem_form(self) -> StateValueMetadata {
        match self {
            PersistedStateValueMetadata::V0 {
                deposit,
                creation_time_usecs,
            } => StateValueMetadata::new_impl(deposit, 0, creation_time_usecs),
            PersistedStateValueMetadata::V1 {
                slot_deposit,
                bytes_deposit,
                creation_time_usecs,
            } => StateValueMetadata::new_impl(slot_deposit, bytes_deposit, creation_time_usecs),
        }
    }
```

**File:** aptos-move/aptos-vm-types/src/storage/space_pricing.rs (L154-162)
```rust
    /// n.b. logcic for bytes fee:
    /// * When slot increase in size on modification, charge additionally into the deposit.
    ///     * legacy slots that didn't pay bytes deposits won't get charged for the bytes allocated for free.
    ///     * Considering pricing change, charge only to the point where the total deposit for bytes don't go
    ///       beyond `current_price_per_byte * num_current_bytes`
    /// * When slot decrease in size, don't refund, to simplify implementation.
    /// * If slot doesn't change in size on modification, no charging even if pricing changes.
    /// * Refund only on deletion.
    /// * There's no longer non-refundable penalty when a slot larger than 1KB gets touched.
```

**File:** aptos-move/aptos-vm-types/src/storage/space_pricing.rs (L187-207)
```rust
            Modification { write_len } => {
                // Change of slot size or per byte price can result in a charge or refund of the bytes fee.
                let old_bytes_deposit = op.metadata_mut.bytes_deposit();
                let state_bytes_charge =
                    if write_len > op.prev_size && target_bytes_deposit > old_bytes_deposit {
                        let charge_by_increase: u64 = (write_len - op.prev_size)
                            * u64::from(params.storage_fee_per_state_byte);
                        let gap_from_target = target_bytes_deposit - old_bytes_deposit;
                        std::cmp::min(charge_by_increase, gap_from_target)
                    } else {
                        0
                    };
                op.metadata_mut.maybe_upgrade();
                op.metadata_mut
                    .set_bytes_deposit(old_bytes_deposit + state_bytes_charge);

                ChargeAndRefund {
                    charge: state_bytes_charge.into(),
                    refund: 0.into(),
                }
            },
```

**File:** aptos-move/aptos-vm-types/src/storage/space_pricing.rs (L283-307)
```rust
        // legacy slots without bytes deposit recorded doesn't get charged if size doesn't increase
        meta.set_bytes_deposit(0); // marks it paid 0 bytes deposit
        let ChargeAndRefund { charge, refund } =
            pricing.charge_refund_write_op(&params, WriteOpInfo {
                key: &key,
                op_size: WriteOpSize::Modification { write_len: 2 },
                prev_size: 2,
                metadata_mut: &mut meta,
            });
        assert_eq!(charge, 0.into());
        assert_eq!(refund, 0.into());
        assert_eq!(meta.bytes_deposit(), 0);

        // but if it does increase in size, new bytes gets charged, at the latest rate
        params.storage_fee_per_state_byte = 20.into();
        let ChargeAndRefund { charge, refund } =
            pricing.charge_refund_write_op(&params, WriteOpInfo {
                key: &key,
                op_size: WriteOpSize::Modification { write_len: 4 },
                prev_size: 2,
                metadata_mut: &mut meta,
            });
        assert_eq!(charge, 40.into());
        assert_eq!(refund, 0.into());
        assert_eq!(meta.bytes_deposit(), 40);
```
