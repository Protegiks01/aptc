# Audit Report

## Title
Gas Calculation Implementation Change Causes False Negatives in Historical Transaction Replay Verification

## Summary
The `replay_on_archive` tool performs exact gas matching during transaction replay verification, but the ristretto255 native function gas calculation implementation was changed from floating-point to integer-based arithmetic. This causes legitimate historical transactions to fail verification when replayed, creating false negatives.

## Finding Description

The `execute_and_verify()` function in `replay_on_archive.rs` uses strict equality checking for gas consumption when verifying replayed transactions. [1](#0-0) 

The verification calls `ensure_match_transaction_info()` which performs exact equality checks on gas used: [2](#0-1) 

The ristretto255 multi-scalar multiplication native function was upgraded from a floating-point based gas calculation to an integer-based implementation: [3](#0-2) 

The old implementation used: `(size as f64 / f64::log2(size as f64)).ceil() as u64` [4](#0-3) 

The new implementation uses: `num / log2_floor(num + 1).unwrap()` with integer arithmetic. These formulas produce different gas values for certain input sizes (e.g., size=64: old=11, new=10; size=128: old=19, new=18).

When replaying historical transactions:
1. The tool fetches historical state including gas schedule parameters [5](#0-4) 
2. But uses the CURRENT Rust implementation of native functions
3. Historical transactions executed with old gas calculation have different gas values recorded
4. Replay with new calculation produces different gas values
5. Exact equality check fails, flagging valid transactions as failed

The current native function registration only includes the new implementation: [6](#0-5) 

There is no version-gating or compatibility mode to handle this discrepancy, unlike the separate `replay-benchmark` tool which has override capabilities.

## Impact Explanation

This qualifies as **Medium severity** under "State inconsistencies requiring intervention" because:

1. **Operational Impact**: Node operators running database verification will see false failures, potentially triggering unnecessary recovery procedures or causing panic about database corruption
2. **Trust Degradation**: Undermines confidence in database verification tools and historical transaction integrity
3. **Resource Waste**: May cause operators to unnecessarily re-sync from genesis or discard valid historical data
4. **No Direct Security Harm**: Does not affect live consensus, steal funds, or compromise validator operations

The issue is limited to the verification tool and doesn't impact the live network's deterministic execution guarantees, which is why it's Medium rather than Critical/High.

## Likelihood Explanation

**Likelihood: Medium to High**

This will occur whenever:
1. Historical transactions used ristretto255 multi-scalar multiplication before the implementation change
2. The `replay_on_archive` tool is run to verify these transactions
3. The bulletproofs feature was enabled during that historical period

The likelihood depends on:
- Whether the old floating-point implementation was deployed on mainnet (comment "upgrades" suggests it was)
- How many transactions used ristretto255 operations
- How frequently operators use the replay tool for verification

## Recommendation

Implement version-aware replay verification:

1. **Add gas feature version tracking**: Store which gas calculation implementation was active at each version
2. **Implement compatibility mode**: Register both old and new implementations with version gates
3. **Conditional native function selection**: Choose implementation based on transaction version being replayed
4. **Alternative: Relaxed matching**: Instead of exact equality, allow small tolerance in gas values (though this reduces verification strength)

Example fix structure:
```rust
// In native function registration
if gas_feature_version < RISTRETTO255_GAS_FIX_VERSION {
    register_old_floating_point_implementation();
} else {
    register_new_integer_implementation();
}
```

Or add override capabilities to `replay_on_archive` similar to the `replay-benchmark` tool's `OverrideConfig`.

## Proof of Concept

Mathematical proof of gas difference:

For `num = 64`:
- Old: `ceil(64.0 / log2(64.0)) = ceil(64.0 / 6.0) = ceil(10.666...) = 11`
- New: `64 / log2_floor(65) = 64 / 6 = 10`

For `num = 128`:
- Old: `ceil(128.0 / log2(128.0)) = ceil(128.0 / 7.0) = ceil(18.285...) = 19`
- New: `128 / log2_floor(129) = 128 / 7 = 18`

Reproduction steps:
1. Identify historical transaction using ristretto255 multi-scalar multiplication with size=64 or 128
2. Run `replay_on_archive` tool on that transaction's version range
3. Observe verification failure despite transaction being legitimately executed
4. Check error message showing gas mismatch

## Notes

- The issue specifically affects the `replay_on_archive` database verification tool, not live transaction execution
- WriteSet and event ordering use deterministic structures (BTreeMap, ordered accumulator) so those aspects are not vulnerable
- The execution config has backwards compatibility considerations documented, but native function implementations lack versioning: [7](#0-6) 
- This represents a gap between versioned on-chain configs (gas parameters) and unversioned off-chain implementation (Rust code)

### Citations

**File:** storage/db-tool/src/replay_on_archive.rs (L378-380)
```rust
                &self
                    .arc_db
                    .state_view_at_version(current_version.checked_sub(1))?,
```

**File:** storage/db-tool/src/replay_on_archive.rs (L394-399)
```rust
            if let Err(err) = executed_outputs[idx].ensure_match_transaction_info(
                version,
                &expected_txn_infos[idx],
                Some(&expected_writesets[idx]),
                Some(&expected_events[idx]),
            ) {
```

**File:** types/src/transaction/mod.rs (L1889-1896)
```rust
        ensure!(
            self.gas_used() == txn_info.gas_used(),
            "{}: version:{}, gas_used:{:?}, expected:{:?}",
            ERR_MSG,
            version,
            self.gas_used(),
            txn_info.gas_used(),
        );
```

**File:** aptos-move/framework/src/natives/cryptography/ristretto255_point.rs (L588-614)
```rust
/// This upgrades 'native_multi_scalar_mul' in two ways:
/// 1. It is a "safe" native that uses `SafeNativeContext::charge` to prevent DoS attacks.
/// 2. It no longer uses floating-point arithmetic to compute the gas costs.
///
/// Pre-conditions: The # of scalars & points are both > 0. This is ensured by the Move calling
/// function.
pub(crate) fn safe_native_multi_scalar_mul_no_floating_point(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    safely_assert_eq!(args.len(), 2);

    let scalars_ref = safely_pop_arg!(args, VectorRef);
    let points_ref = safely_pop_arg!(args, VectorRef);

    // Invariant (enforced by caller): num > 0 and # of scalars = # of points
    let num = scalars_ref.len()?.value_as::<u64>()? as usize;

    // Invariant: log2_floor(num + 1) > 0. This is because num >= 1, thanks to the invariant we enforce on
    // the caller of this native. Therefore, num + 1 >= 2, which implies log2_floor(num + 1) >= 1.
    // So we never divide by zero.
    context.charge(
        RISTRETTO255_POINT_PARSE_ARG * NumArgs::new(num as u64)
            + RISTRETTO255_SCALAR_PARSE_ARG * NumArgs::new(num as u64)
            + RISTRETTO255_POINT_MUL * NumArgs::new((num / log2_floor(num + 1).unwrap()) as u64),
    )?;
```

**File:** aptos-move/framework/src/natives/cryptography/ristretto255.rs (L30-34)
```rust
pub fn multi_scalar_mul_gas(
    size: usize,
) -> impl GasExpression<NativeGasParameters, Unit = InternalGasUnit> {
    RISTRETTO255_POINT_MUL * NumArgs::new((size as f64 / f64::log2(size as f64)).ceil() as u64)
}
```

**File:** aptos-move/framework/src/natives/cryptography/ristretto255.rs (L98-101)
```rust
        (
            "multi_scalar_mul_internal",
            ristretto255_point::safe_native_multi_scalar_mul_no_floating_point,
        ),
```

**File:** types/src/on_chain_config/execution_config.rs (L16-17)
```rust
    /// To maintain backwards compatibility on replay, we must ensure that any new features resolve
    /// to previous behavior (before OnChainExecutionConfig was registered) in case of Missing.
```
