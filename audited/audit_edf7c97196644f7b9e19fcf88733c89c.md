# Audit Report

## Title
Consensus Public Key Uniqueness Not Enforced Post-Genesis - Allowing Validator Impersonation and Consensus Disruption

## Summary
The Aptos staking system fails to enforce uniqueness of BLS12-381 consensus public keys after genesis. While genesis validation checks for duplicate keys, post-genesis operations (`initialize_validator`, `rotate_consensus_key`, `join_validator_set`) do not verify key uniqueness. Additionally, proof-of-possession (PoP) values are publicly visible in transaction parameters and can be reused by any validator to register a duplicate consensus public key, violating the critical invariant that each validator has a unique consensus identity.

## Finding Description
The vulnerability exists in the validator registration and key rotation logic. When a validator registers or rotates their consensus public key, the system validates the proof-of-possession but does not check if the public key is already in use by another validator. [1](#0-0) 

The `initialize_validator` function validates the PoP but has no uniqueness check for the consensus public key. [2](#0-1) 

Similarly, `rotate_consensus_key` validates the new key's PoP but does not verify uniqueness.

The critical flaw is that PoP values are just BLS signatures on public key bytes and are publicly visible in transaction parameters: [3](#0-2) 

Once Validator A broadcasts their registration transaction with `consensus_pubkey=PK_A` and `proof_of_possession=PoP_A`, any other validator can extract these values and reuse them:

1. Validator B observes Validator A's transaction on-chain
2. Validator B calls `rotate_consensus_key(operator, pool_address, PK_A, PoP_A)`
3. The PoP verification passes because `PoP_A` is a valid signature on `PK_A`
4. Both validators now have identical consensus public keys

This violates the uniqueness assumption in the consensus protocol: [4](#0-3) 

The `verify_multi_signatures` function aggregates public keys from the validator set. When duplicate keys exist, it computes `PK + PK = 2*PK`, but only Validator A (who has the private key) can produce valid signatures. This causes verification failures and consensus disruption.

Importantly, genesis validation DOES enforce uniqueness: [5](#0-4) 

However, this check is only performed during genesis initialization, not during runtime validator operations.

## Impact Explanation
This is a **High Severity** vulnerability per the Aptos bug bounty criteria because it constitutes a significant protocol violation that can disrupt consensus operation.

**Attack Vectors:**
1. **Consensus Liveness Attack**: A malicious validator can register their consensus key to match an honest validator's key, causing signature verification failures when both validators are expected to participate in quorum formation.

2. **Validator Slot Denial of Service**: An attacker controlling multiple validator slots can register all of them with the same public key as a target validator, wasting voting power and reducing the effective validator set size.

3. **Epoch Transition Disruption**: During `on_new_epoch` processing, duplicate keys in the active validator set violate consensus protocol assumptions: [6](#0-5) 

The validator set activation logic assumes unique public keys per validator address.

While this does NOT allow signature forgery (the attacker lacks the private key), it breaks the **Cryptographic Correctness** invariant and can cause consensus failures, reduced liveness, or undefined behavior in the BLS signature aggregation logic.

## Likelihood Explanation
**Likelihood: High**

- **Low Barrier to Entry**: Any validator can execute this attack by simply observing on-chain transactions and reusing publicly visible PoP values
- **No Special Privileges Required**: Does not require validator majority, governance control, or insider access
- **Easy to Execute**: Single transaction call to `rotate_consensus_key` with extracted parameters
- **Difficult to Detect**: The duplicate key only becomes apparent during signature verification failures, which may be misattributed to network issues
- **Realistic Motivation**: A malicious validator could use this to disrupt consensus for competitors or conduct targeted attacks on specific validators

## Recommendation
Implement a runtime uniqueness check for consensus public keys in the staking module:

```move
// In stake.move, add a helper function:
fun assert_consensus_key_unique(new_consensus_pubkey: vector<u8>, pool_address: address) acquires ValidatorSet {
    let validator_set = borrow_global<ValidatorSet>(@aptos_framework);
    
    // Check active validators
    let i = 0;
    while (i < vector::length(&validator_set.active_validators)) {
        let validator = vector::borrow(&validator_set.active_validators, i);
        assert!(
            validator.config.consensus_pubkey != new_consensus_pubkey || validator.addr == pool_address,
            error::invalid_argument(EDUPLICATE_CONSENSUS_KEY)
        );
        i = i + 1;
    };
    
    // Check pending_active validators
    i = 0;
    while (i < vector::length(&validator_set.pending_active)) {
        let validator = vector::borrow(&validator_set.pending_active, i);
        assert!(
            validator.config.consensus_pubkey != new_consensus_pubkey || validator.addr == pool_address,
            error::invalid_argument(EDUPLICATE_CONSENSUS_KEY)
        );
        i = i + 1;
    };
}
```

Then call this function in both `initialize_validator` and `rotate_consensus_key`:

```move
public entry fun rotate_consensus_key(...) {
    // ... existing validation ...
    assert_consensus_key_unique(new_consensus_pubkey, pool_address);
    validator_info.consensus_pubkey = new_consensus_pubkey;
    // ...
}
```

Add error constant:
```move
const EDUPLICATE_CONSENSUS_KEY: u64 = 30;
```

## Proof of Concept

```move
#[test_only]
module test_address::duplicate_key_attack {
    use aptos_framework::stake;
    use aptos_framework::account;
    use std::vector;
    use aptos_std::bls12381;
    
    #[test(aptos_framework = @aptos_framework, validator_a = @0xA, validator_b = @0xB)]
    public fun test_duplicate_consensus_key_vulnerability(
        aptos_framework: &signer,
        validator_a: &signer,
        validator_b: &signer
    ) {
        // Setup: Initialize genesis and validators
        // ... (genesis initialization code) ...
        
        // Validator A registers with their consensus key
        let pk_a = x"...";  // BLS public key bytes
        let pop_a = x"..."; // Proof of possession bytes
        
        stake::initialize_validator(
            validator_a,
            pk_a,
            pop_a,
            vector::empty(),
            vector::empty()
        );
        
        // Validator B observes the transaction and extracts pk_a and pop_a
        // Validator B rotates their key to match Validator A's key
        stake::rotate_consensus_key(
            validator_b,
            signer::address_of(validator_b),
            pk_a,      // SAME public key as validator A
            pop_a      // REUSED proof of possession
        );
        
        // VULNERABILITY: Both validators now have identical consensus public keys
        // This will cause consensus verification failures and protocol violations
        
        // The PoP verification passes because pop_a is a valid signature on pk_a
        // But there's no check that pk_a is already in use by another validator
    }
}
```

**Notes:**
- The vulnerability requires being a registered validator to exploit, but this is not a high barrier (anyone can stake and become a validator)
- The attack breaks the fundamental assumption that each validator has a unique cryptographic identity in the consensus protocol
- Genesis validation prevents this issue initially, but runtime operations lack the same protection
- The fix is straightforward: add uniqueness validation to match the genesis-time checks

### Citations

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L670-692)
```text
    public entry fun initialize_validator(
        account: &signer,
        consensus_pubkey: vector<u8>,
        proof_of_possession: vector<u8>,
        network_addresses: vector<u8>,
        fullnode_addresses: vector<u8>,
    ) acquires AllowedValidators {
        check_stake_permission(account);
        // Checks the public key has a valid proof-of-possession to prevent rogue-key attacks.
        let pubkey_from_pop = &bls12381::public_key_from_bytes_with_pop(
            consensus_pubkey,
            &proof_of_possession_from_bytes(proof_of_possession)
        );
        assert!(option::is_some(pubkey_from_pop), error::invalid_argument(EINVALID_PUBLIC_KEY));

        initialize_owner(account);
        move_to(account, ValidatorConfig {
            consensus_pubkey,
            network_addresses,
            fullnode_addresses,
            validator_index: 0,
        });
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L910-952)
```text
    public entry fun rotate_consensus_key(
        operator: &signer,
        pool_address: address,
        new_consensus_pubkey: vector<u8>,
        proof_of_possession: vector<u8>,
    ) acquires StakePool, ValidatorConfig {
        check_stake_permission(operator);
        assert_reconfig_not_in_progress();
        assert_stake_pool_exists(pool_address);

        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        assert!(signer::address_of(operator) == stake_pool.operator_address, error::unauthenticated(ENOT_OPERATOR));

        assert!(exists<ValidatorConfig>(pool_address), error::not_found(EVALIDATOR_CONFIG));
        let validator_info = borrow_global_mut<ValidatorConfig>(pool_address);
        let old_consensus_pubkey = validator_info.consensus_pubkey;
        // Checks the public key has a valid proof-of-possession to prevent rogue-key attacks.
        let pubkey_from_pop = &bls12381::public_key_from_bytes_with_pop(
            new_consensus_pubkey,
            &proof_of_possession_from_bytes(proof_of_possession)
        );
        assert!(option::is_some(pubkey_from_pop), error::invalid_argument(EINVALID_PUBLIC_KEY));
        validator_info.consensus_pubkey = new_consensus_pubkey;

        if (std::features::module_event_migration_enabled()) {
            event::emit(
                RotateConsensusKey {
                    pool_address,
                    old_consensus_pubkey,
                    new_consensus_pubkey,
                },
            );
        } else {
            event::emit_event(
                &mut stake_pool.rotate_consensus_key_events,
                RotateConsensusKeyEvent {
                    pool_address,
                    old_consensus_pubkey,
                    new_consensus_pubkey,
                },
            );
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1363-1364)
```text
        // Activate currently pending_active validators.
        append(&mut validator_set.active_validators, &mut validator_set.pending_active);
```

**File:** crates/aptos-crypto/src/bls12381/bls12381_pop.rs (L94-102)
```rust
    pub fn create_with_pubkey(sk: &PrivateKey, pk: &PublicKey) -> ProofOfPossession {
        // CRYPTONOTE(Alin): The standard does not detail how the PK should be serialized for hashing purposes; we just do the obvious.
        let pk_bytes = pk.to_bytes();

        // CRYPTONOTE(Alin): We hash with DST_BLS_POP_IN_G2 as per https://datatracker.ietf.org/doc/html/draft-irtf-cfrg-bls-signature#section-4.2.3
        ProofOfPossession {
            pop: sk.privkey.sign(&pk_bytes, DST_BLS_POP_IN_G2, &[]),
        }
    }
```

**File:** types/src/validator_verifier.rs (L345-386)
```rust
    pub fn verify_multi_signatures<T: CryptoHash + Serialize>(
        &self,
        message: &T,
        multi_signature: &AggregateSignature,
    ) -> std::result::Result<(), VerifyError> {
        // Verify the number of signature is not greater than expected.
        Self::check_num_of_voters(self.len() as u16, multi_signature.get_signers_bitvec())?;
        let mut pub_keys = vec![];
        let mut authors = vec![];
        for index in multi_signature.get_signers_bitvec().iter_ones() {
            let validator = self
                .validator_infos
                .get(index)
                .ok_or(VerifyError::UnknownAuthor)?;
            authors.push(validator.address);
            pub_keys.push(validator.public_key());
        }
        // Verify the quorum voting power of the authors
        self.check_voting_power(authors.iter(), true)?;
        #[cfg(any(test, feature = "fuzzing"))]
        {
            if self.quorum_voting_power == 0 {
                // This should happen only in case of tests.
                // TODO(skedia): Clean up the test behaviors to not rely on empty signature
                // verification
                return Ok(());
            }
        }
        // Verify empty multi signature
        let multi_sig = multi_signature
            .sig()
            .as_ref()
            .ok_or(VerifyError::EmptySignature)?;
        // Verify the optimistically aggregated signature.
        let aggregated_key =
            PublicKey::aggregate(pub_keys).map_err(|_| VerifyError::FailedToAggregatePubKey)?;

        multi_sig
            .verify(message, &aggregated_key)
            .map_err(|_| VerifyError::InvalidMultiSignature)?;
        Ok(())
    }
```

**File:** crates/aptos/src/genesis/mod.rs (L750-758)
```rust
            if !unique_consensus_keys
                .insert(validator.consensus_public_key.as_ref().unwrap().clone())
            {
                errors.push(CliError::UnexpectedError(format!(
                    "Validator {} has a repeated a consensus public key {}",
                    name,
                    validator.consensus_public_key.as_ref().unwrap()
                )));
            }
```
