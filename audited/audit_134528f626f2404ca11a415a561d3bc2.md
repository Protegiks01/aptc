# Audit Report

## Title
DKG Broadcast Amplification Attack via Unlimited DKGTranscriptRequest Handling

## Summary
A malicious validator can exploit the lack of rate limiting and request deduplication in the DKG transcript request handling to launch a bandwidth amplification attack. By repeatedly sending small `DKGTranscriptRequest` messages to honest validators, the attacker receives large `DKGTranscript` responses, achieving an amplification factor of up to ~8,800x. This can exhaust egress bandwidth on honest validators and prevent legitimate DKG message delivery, potentially causing DKG session failures.

## Finding Description

The DKG (Distributed Key Generation) system uses the `RBMessage` trait to enable reliable broadcast of messages between validators. When a validator enters the `InProgress` or `Finished` state during DKG, it automatically responds to any `DKGTranscriptRequest` with its full transcript, regardless of how many times the same peer has requested it. [1](#0-0) 

The vulnerability exists because:

1. **No request deduplication**: The system does not track which peers have already received transcripts
2. **No per-peer rate limiting**: Beyond the general network layer's 100 concurrent RPC limit, there is no DKG-specific throttling
3. **Automatic response**: Any valid `DKGTranscriptRequest` for the current epoch triggers a full transcript response
4. **Large response size**: DKG transcripts are substantial, with sizes growing linearly with validator set size

For a typical production validator set of 1000 validators, a `DKGTranscript` serializes to approximately 141 KB:
- Formula: `G2_PROJ_NUM_BYTES + (n + 1) * (G2_PROJ_NUM_BYTES + G1_PROJ_NUM_BYTES)`
- With n=1000: `96 + 1001 * (96 + 48) = 144,240 bytes â‰ˆ 141 KB` [2](#0-1) 

In contrast, a `DKGTranscriptRequest` contains only an epoch number (u64), serializing to approximately 8-16 bytes: [3](#0-2) 

**Attack Scenario:**
1. Malicious validator M repeatedly sends `DKGTranscriptRequest` messages to honest validator V
2. V responds to each request with its full ~141 KB transcript
3. With the network layer's 100 concurrent inbound RPC limit and 1-second RPC timeout: [4](#0-3) [5](#0-4) 
4. If responses complete in ~100ms, M can sustain ~1,000 requests/second per victim
5. This generates ~141 MB/s egress bandwidth from V to M alone
6. M can simultaneously target multiple honest validators, multiplying the impact
7. Multiple malicious validators can coordinate to amplify the attack further

This amplification attack (ratio of ~8,800:1) can:
- Exhaust egress bandwidth on honest validators
- Trigger infrastructure-level bandwidth limits (HAProxy: 25-50 MB/s)
- Create network congestion preventing legitimate DKG message delivery
- Cause DKG session failures if quorum cannot be reached due to bandwidth exhaustion

The `ReliableBroadcast` system requires quorum responses to complete aggregation: [6](#0-5) 

If attackers can prevent enough honest validators from communicating effectively, DKG sessions may fail to reach quorum, breaking the randomness generation subsystem.

## Impact Explanation

This vulnerability qualifies as **Medium Severity** per the Aptos bug bounty criteria:
- **"State inconsistencies requiring intervention"**: Failed DKG sessions prevent proper randomness beacon operation, requiring operator intervention to diagnose and mitigate the bandwidth attack
- **Protocol disruption**: While not a permanent consensus break, systematic DKG failures could affect systems depending on on-chain randomness
- **Limited funds impact**: No direct fund loss, but affects protocol functionality

The attack requires a malicious validator (insider threat), which limits severity. However, the question explicitly explores this threat model, and a single compromised validator can significantly disrupt DKG operations across the network.

## Likelihood Explanation

**Likelihood: Medium to High**

Required conditions:
- Attacker controls at least one validator node (has validator credentials)
- DKG session is active (validators are in `InProgress` or `Finished` state)
- Attacker has sufficient network bandwidth to sustain the attack

Execution complexity: **Low**
- Attack is straightforward: repeatedly send small RPC requests
- No cryptographic sophistication required
- Standard network flooding techniques apply

Detection difficulty: **Medium**
- Unusual bandwidth patterns would be visible in monitoring
- However, requests appear legitimate (valid epoch, valid validator signature)
- Distinguishing malicious from legitimate high-frequency requests requires additional context

## Recommendation

Implement multi-layered rate limiting and request tracking:

1. **Request deduplication per peer per epoch**: Track which validators have already received transcripts and limit responses
2. **Per-peer request rate limiting**: Add DKG-specific rate limits (e.g., maximum 10 requests per peer per minute)
3. **Response size awareness**: Apply stricter limits for large responses
4. **Circuit breaker pattern**: Temporarily block peers exhibiting abusive patterns

**Code fix for `dkg_manager/mod.rs`:**

```rust
pub struct DKGManager<DKG: DKGTrait> {
    // ... existing fields ...
    
    // Add request tracking
    transcript_requests_served: HashMap<AccountAddress, (u64, Instant)>, // (count, last_reset_time)
    max_requests_per_peer_per_minute: u64,
}

async fn process_peer_rpc_msg(&mut self, req: IncomingRpcRequest) -> Result<()> {
    let IncomingRpcRequest {
        msg,
        sender,
        mut response_sender,
    } = req;
    
    ensure!(
        msg.epoch() == self.epoch_state.epoch,
        "[DKG] msg not for current epoch"
    );
    
    // Rate limiting check
    if let DKGMessage::TranscriptRequest(_) = &msg {
        let now = Instant::now();
        let entry = self.transcript_requests_served
            .entry(sender)
            .or_insert((0, now));
        
        // Reset counter every minute
        if now.duration_since(entry.1) > Duration::from_secs(60) {
            entry.0 = 0;
            entry.1 = now;
        }
        
        entry.0 += 1;
        
        if entry.0 > self.max_requests_per_peer_per_minute {
            return Err(anyhow!(
                "[DKG] Rate limit exceeded for peer {} ({} requests in last minute)",
                sender, entry.0
            ));
        }
    }
    
    let response = match (&self.state, &msg) {
        // ... existing match logic ...
    };
    
    response_sender.send(response);
    Ok(())
}
```

Additionally, consider implementing a global bandwidth budget for DKG responses to prevent collective exhaustion even with per-peer limits.

## Proof of Concept

```rust
#[tokio::test]
async fn test_dkg_amplification_attack() {
    // Setup: Create a DKG session with 100 validators
    let validator_set_size = 100;
    let (mut victim_manager, victim_addr, epoch_state) = setup_dkg_manager(validator_set_size).await;
    
    // Attacker sends small requests
    let attacker_addr = AccountAddress::random();
    let request = DKGMessage::TranscriptRequest(DKGTranscriptRequest::new(epoch_state.epoch));
    let request_size = bcs::to_bytes(&request).unwrap().len();
    println!("Request size: {} bytes", request_size);
    
    // Simulate 1000 requests
    let num_requests = 1000;
    let mut total_response_bytes = 0u64;
    
    for i in 0..num_requests {
        let (response_tx, response_rx) = oneshot::channel();
        let rpc_request = IncomingRpcRequest {
            msg: request.clone(),
            sender: attacker_addr,
            response_sender: Box::new(TestResponseSender::new(response_tx)),
        };
        
        // Process request
        victim_manager.process_peer_rpc_msg(rpc_request).await.unwrap();
        
        // Measure response size
        if let Ok(response) = response_rx.await {
            if let DKGMessage::TranscriptResponse(transcript) = response {
                let response_size = bcs::to_bytes(&transcript).unwrap().len();
                total_response_bytes += response_size as u64;
                
                if i == 0 {
                    println!("Response size: {} bytes", response_size);
                    println!("Amplification factor: {}x", response_size / request_size);
                }
            }
        }
    }
    
    let avg_response_size = total_response_bytes / num_requests;
    let amplification = avg_response_size / request_size as u64;
    
    println!("\n=== Attack Results ===");
    println!("Total requests: {}", num_requests);
    println!("Total response bandwidth: {} MB", total_response_bytes / 1_000_000);
    println!("Average amplification: {}x", amplification);
    println!("Bandwidth exhausted: {} MB/s (assuming 1 req/ms)", 
             total_response_bytes / 1_000_000);
    
    // Verify amplification is significant
    assert!(amplification > 1000, 
            "Amplification factor should exceed 1000x for 100 validators");
}
```

**Notes:**
- The vulnerability stems from the automatic, unlimited response behavior without request tracking
- While network-layer concurrent RPC limits (100 per peer) provide some protection, they don't prevent sustained bandwidth amplification attacks
- The attack is particularly effective because it exploits legitimate protocol functionality rather than a bug in the broadcast mechanism itself
- Multiple malicious validators can coordinate to amplify the attack's impact across the network simultaneously

### Citations

**File:** dkg/src/dkg_manager/mod.rs (L453-478)
```rust
    /// Process an RPC request from DKG peers.
    async fn process_peer_rpc_msg(&mut self, req: IncomingRpcRequest) -> Result<()> {
        let IncomingRpcRequest {
            msg,
            mut response_sender,
            ..
        } = req;
        ensure!(
            msg.epoch() == self.epoch_state.epoch,
            "[DKG] msg not for current epoch"
        );
        let response = match (&self.state, &msg) {
            (InnerState::Finished { my_transcript, .. }, DKGMessage::TranscriptRequest(_))
            | (InnerState::InProgress { my_transcript, .. }, DKGMessage::TranscriptRequest(_)) => {
                Ok(DKGMessage::TranscriptResponse(my_transcript.clone()))
            },
            _ => Err(anyhow!(
                "[DKG] msg {:?} unexpected in state {:?}",
                msg.name(),
                self.state.variant_name()
            )),
        };

        response_sender.send(response);
        Ok(())
    }
```

**File:** crates/aptos-dkg/tests/pvss.rs (L405-413)
```rust
fn expected_transcript_size<T: Transcript<SecretSharingConfig = ThresholdConfigBlstrs>>(
    sc: &ThresholdConfigBlstrs,
) -> usize {
    if T::scheme_name() == unweighted_protocol::DAS_SK_IN_G1 {
        G2_PROJ_NUM_BYTES
            + (sc.get_total_num_players() + 1) * (G2_PROJ_NUM_BYTES + G1_PROJ_NUM_BYTES)
    } else {
        panic!("Did not implement support for '{}' yet", T::scheme_name())
    }
```

**File:** dkg/src/types.rs (L10-22)
```rust
/// Once DKG starts, a validator should send this message to peers in order to collect DKG transcripts from peers.
#[derive(Clone, Serialize, Deserialize, CryptoHasher, Debug, PartialEq)]
pub struct DKGTranscriptRequest {
    dealer_epoch: u64,
}

impl DKGTranscriptRequest {
    pub fn new(epoch: u64) -> Self {
        Self {
            dealer_epoch: epoch,
        }
    }
}
```

**File:** config/src/config/dag_consensus_config.rs (L112-122)
```rust
impl Default for ReliableBroadcastConfig {
    fn default() -> Self {
        Self {
            // A backoff policy that starts at 100ms and doubles each iteration up to 3secs.
            backoff_policy_base_ms: 2,
            backoff_policy_factor: 50,
            backoff_policy_max_delay_ms: 3000,

            rpc_timeout_ms: 1000,
        }
    }
```

**File:** network/framework/src/constants.rs (L14-15)
```rust
/// Limit on concurrent Inbound RPC requests before backpressure is applied
pub const MAX_CONCURRENT_INBOUND_RPCS: u32 = 100;
```

**File:** dkg/src/transcript_aggregation/mod.rs (L122-134)
```rust
        let threshold = self.epoch_state.verifier.quorum_voting_power();
        let power_check_result = self
            .epoch_state
            .verifier
            .check_voting_power(trx_aggregator.contributors.iter(), true);
        let new_total_power = match &power_check_result {
            Ok(x) => Some(*x),
            Err(VerifyError::TooLittleVotingPower { voting_power, .. }) => Some(*voting_power),
            _ => None,
        };
        let maybe_aggregated = power_check_result
            .ok()
            .map(|_| trx_aggregator.trx.clone().unwrap());
```
