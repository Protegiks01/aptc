# Audit Report

## Title
Incomplete Transaction Index Cleanup During Manual Database Truncation Leads to Stale Index Entries and Transaction Mismatches

## Summary
The manual database truncation command (`db_debugger truncate`) has a critical flaw where it only processes up to 2,000,000 transactions when deleting transaction index entries. For large truncations exceeding this limit, stale entries in `OrderedTransactionByAccountSchema` remain, causing subsequent queries by account address and sequence number to return incorrect transactions after the blockchain reaches the same version numbers with different content.

## Finding Description

The vulnerability exists in the transaction index cleanup logic during database truncation. When a node operator performs a manual truncation (disaster recovery scenario), the system must delete all transaction index entries for rolled-back transactions to maintain storage consistency. [1](#0-0) 

The `delete_transaction_index_data` function only loads up to `MAX_COMMIT_PROGRESS_DIFFERENCE * 2` transactions (2,000,000 transactions) starting from the truncation point. [2](#0-1) 

**Attack Scenario:**

1. **Initial State**: Blockchain at version 5,000,000. Account X has a transaction with sequence number 10 at version 3,500,000.
   - Index entry: `OrderedTransactionByAccountSchema[(X, 10)] = 3,500,000`

2. **Truncation**: Operator truncates database to version 100 using the manual debugger command. [3](#0-2) 
   
   The truncation processes versions [101, 2,000,101), but version 3,500,000 is beyond this range, so its index entry is NOT deleted.

3. **Blockchain Resumes**: Chain continues from version 101 and eventually reaches version 3,500,000 again, but now with completely different transaction content (from account Y, for example).

4. **Transaction Mismatch**: A client queries for account X's transaction with sequence number 10: [4](#0-3) 
   
   The function returns version 3,500,000 from the stale index entry.

5. **Wrong Transaction Returned**: The API retrieves the transaction at version 3,500,000: [5](#0-4) 
   
   No validation occurs to verify that the transaction at this version actually belongs to account X with sequence number 10. The wrong transaction (from account Y) is returned.

The `OrderedTransactionByAccountSchema` maps `(AccountAddress, SequenceNumber) -> Version` without any validation when retrieving transactions: [6](#0-5) 

## Impact Explanation

**Severity: Critical/High**

This vulnerability breaks the **State Consistency** invariant. The impact includes:

1. **Transaction Mismatch**: APIs return completely wrong transactions when queried by account and sequence number, violating fundamental correctness guarantees.

2. **Consensus Risk**: If validators perform truncations independently and have different stale index states, they may serve inconsistent views of transaction history, potentially causing consensus divergence.

3. **State Corruption**: The storage layer provides incorrect data to all higher-level components (APIs, wallets, explorers), breaking trust in the system.

4. **Non-Recoverable Without Intervention**: The stale index entries persist indefinitely until manually cleaned or overwritten, requiring operator intervention.

This qualifies as **Critical severity** under the Aptos bug bounty program as it represents a "Significant protocol violation" and "State inconsistencies requiring intervention."

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability requires:
1. Operator performing manual truncation with `crash_if_difference_is_too_large=false` (explicitly allowed in the debugger command)
2. Truncation depth > 2,000,000 versions (realistic for major disaster recovery)
3. Blockchain reaching the same version numbers after recovery

While not triggered during normal operation, large-scale truncations are legitimate disaster recovery procedures. The 2,000,000 version limit was likely chosen assuming automatic crash recovery (which enforces `MAX_COMMIT_PROGRESS_DIFFERENCE`), but the manual command bypasses this protection. As blockchains grow and operate for years, truncations exceeding 2M versions become increasingly plausible.

## Recommendation

**Fix 1: Process all transactions during truncation**

Modify `delete_transaction_index_data` to process transactions in batches until all rolled-back transactions are handled:

```rust
fn delete_transaction_index_data(
    ledger_db: &LedgerDb,
    transaction_store: &TransactionStore,
    start_version: Version,
    batch: &mut SchemaBatch,
) -> Result<()> {
    let batch_size = MAX_COMMIT_PROGRESS_DIFFERENCE as usize * 2;
    let mut current_start = start_version;
    
    loop {
        let transactions = ledger_db
            .transaction_db()
            .get_transaction_iter(current_start, batch_size)?
            .collect::<Result<Vec<_>>>()?;
        
        if transactions.is_empty() {
            break;
        }
        
        let num_txns = transactions.len();
        info!(
            start_version = current_start,
            latest_version = current_start + num_txns as u64 - 1,
            "Truncate transaction index data batch."
        );
        
        ledger_db
            .transaction_db()
            .prune_transaction_by_hash_indices(transactions.iter().map(|txn| txn.hash()), batch)?;

        let transactions = (current_start..=current_start + num_txns as u64 - 1)
            .zip(transactions)
            .collect::<Vec<_>>();
        transaction_store.prune_transaction_by_account(&transactions, batch)?;
        transaction_store.prune_transaction_summaries_by_account(&transactions, batch)?;
        
        if (num_txns as usize) < batch_size {
            break;
        }
        current_start += num_txns as u64;
    }
    
    Ok(())
}
```

**Fix 2: Add validation in get_account_ordered_transaction**

Add a safety check to verify the transaction at the returned version matches the expected account and sequence number before returning it to the caller.

**Fix 3: Enforce limits in manual truncate command**

Add validation in the truncate command to prevent truncations that exceed the safe processing limit unless explicitly overridden with warning.

## Proof of Concept

```rust
#[test]
fn test_incomplete_truncation_stale_index() {
    use aptos_temppath::TempPath;
    use aptos_config::config::DEFAULT_MAX_NUM_NODES_PER_LRU_CACHE_SHARD;
    use aptos_types::account_address::AccountAddress;
    
    // Setup: Create DB and commit 5M transactions
    let tmp_dir = TempPath::new();
    let db = AptosDB::new_for_test(&tmp_dir);
    
    let account_x = AccountAddress::random();
    let seq_num = 10u64;
    let target_version = 3_500_000u64;
    
    // Commit transactions up to version 5M
    // At version 3.5M, account X sends transaction with seq# 10
    // (Implementation details omitted for brevity)
    
    // Verify index exists
    let version = db.get_account_ordered_transaction_version(
        account_x, seq_num, target_version
    ).unwrap();
    assert_eq!(version, Some(target_version));
    
    drop(db);
    
    // Perform manual truncation to version 100
    let cmd = Cmd {
        db_dir: tmp_dir.path().to_path_buf(),
        target_version: 100,
        opt_out_backup_checkpoint: true,
        backup_checkpoint_dir: None,
        sharding_config: Default::default(),
    };
    cmd.run().unwrap();
    
    // Reopen DB and commit new transactions
    let db = AptosDB::new_for_test(&tmp_dir);
    
    // Commit new transactions from version 101 onwards
    // Eventually reach version 3.5M again with DIFFERENT transaction
    // (from account Y, not account X)
    
    // BUG: Query for account X seq# 10 still returns version 3.5M
    let stale_version = db.get_account_ordered_transaction_version(
        account_x, seq_num, target_version
    ).unwrap();
    
    // This should be None (transaction doesn't exist after truncation)
    // But returns Some(3_500_000) due to stale index
    assert_eq!(stale_version, Some(target_version)); // BUG TRIGGERED
    
    // Retrieve transaction at that version
    let txn = db.get_transaction(target_version).unwrap();
    
    // BUG: Transaction is from account Y, not account X
    // Transaction mismatch!
}
```

## Notes

The automatic crash recovery path in `sync_commit_progress` has protection via `MAX_COMMIT_PROGRESS_DIFFERENCE` enforcement [7](#0-6) , but the manual debugger truncate command explicitly disables this check. [8](#0-7) 

The vulnerability affects both `OrderedTransactionByAccountSchema` [9](#0-8)  and `TransactionSummariesByAccountSchema` cleanup, though the former is more critical as it's used for direct transaction lookups by sequence number.

### Citations

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L363-392)
```rust
fn delete_transaction_index_data(
    ledger_db: &LedgerDb,
    transaction_store: &TransactionStore,
    start_version: Version,
    batch: &mut SchemaBatch,
) -> Result<()> {
    let transactions = ledger_db
        .transaction_db()
        .get_transaction_iter(start_version, MAX_COMMIT_PROGRESS_DIFFERENCE as usize * 2)?
        .collect::<Result<Vec<_>>>()?;
    let num_txns = transactions.len();
    if num_txns > 0 {
        info!(
            start_version = start_version,
            latest_version = start_version + num_txns as u64 - 1,
            "Truncate transaction index data."
        );
        ledger_db
            .transaction_db()
            .prune_transaction_by_hash_indices(transactions.iter().map(|txn| txn.hash()), batch)?;

        let transactions = (start_version..=start_version + transactions.len() as u64 - 1)
            .zip(transactions)
            .collect::<Vec<_>>();
        transaction_store.prune_transaction_by_account(&transactions, batch)?;
        transaction_store.prune_transaction_summaries_by_account(&transactions, batch)?;
    }

    Ok(())
}
```

**File:** storage/aptosdb/src/state_store/mod.rs (L107-107)
```rust
pub const MAX_COMMIT_PROGRESS_DIFFERENCE: u64 = 1_000_000;
```

**File:** storage/aptosdb/src/state_store/mod.rs (L444-449)
```rust
            let difference = ledger_commit_progress - overall_commit_progress;
            if crash_if_difference_is_too_large {
                assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
            }
            truncate_ledger_db(ledger_db.clone(), overall_commit_progress)
                .expect("Failed to truncate ledger db.");
```

**File:** storage/aptosdb/src/db_debugger/truncate/mod.rs (L137-142)
```rust
        StateStore::sync_commit_progress(
            Arc::clone(&ledger_db),
            Arc::clone(&state_kv_db),
            Arc::clone(&state_merkle_db),
            /*crash_if_difference_is_too_large=*/ false,
        );
```

**File:** storage/aptosdb/src/transaction_store/mod.rs (L36-52)
```rust
    pub fn get_account_ordered_transaction_version(
        &self,
        address: AccountAddress,
        sequence_number: u64,
        ledger_version: Version,
    ) -> Result<Option<Version>> {
        if let Some(version) =
            self.ledger_db
                .transaction_db_raw()
                .get::<OrderedTransactionByAccountSchema>(&(address, sequence_number))?
        {
            if version <= ledger_version {
                return Ok(Some(version));
            }
        }
        Ok(None)
    }
```

**File:** storage/aptosdb/src/transaction_store/mod.rs (L143-157)
```rust
    pub fn prune_transaction_by_account(
        &self,
        transactions: &[(Version, Transaction)],
        db_batch: &mut SchemaBatch,
    ) -> Result<()> {
        for (_, transaction) in transactions {
            if let Some(txn) = transaction.try_as_signed_user_txn() {
                if let ReplayProtector::SequenceNumber(seq_num) = txn.replay_protector() {
                    db_batch
                        .delete::<OrderedTransactionByAccountSchema>(&(txn.sender(), seq_num))?;
                }
            }
        }
        Ok(())
    }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L143-162)
```rust
    fn get_account_ordered_transaction(
        &self,
        address: AccountAddress,
        seq_num: u64,
        include_events: bool,
        ledger_version: Version,
    ) -> Result<Option<TransactionWithProof>> {
        gauged_api("get_account_transaction", || {
            ensure!(
                !self.state_kv_db.enabled_sharding(),
                "This API is not supported with sharded DB"
            );
            self.transaction_store
                .get_account_ordered_transaction_version(address, seq_num, ledger_version)?
                .map(|txn_version| {
                    self.get_transaction_with_proof(txn_version, ledger_version, include_events)
                })
                .transpose()
        })
    }
```

**File:** storage/indexer_schemas/src/schema/ordered_transaction_by_account/mod.rs (L1-28)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

//! This module defines physical storage schema for a transaction index via which the version of a
//! transaction sent by `account_address` with `sequence_number` can be found. With the version one
//! can resort to `TransactionSchema` for the transaction content.
//!
//! ```text
//! |<-------key------->|<-value->|
//! | address | seq_num | txn_ver |
//! ```

use crate::{schema::ORDERED_TRANSACTION_BY_ACCOUNT_CF_NAME, utils::ensure_slice_len_eq};
use anyhow::Result;
use aptos_schemadb::{
    define_pub_schema,
    schema::{KeyCodec, ValueCodec},
};
use aptos_types::{account_address::AccountAddress, transaction::Version};
use byteorder::{BigEndian, ReadBytesExt, WriteBytesExt};
use std::{convert::TryFrom, mem::size_of};

define_pub_schema!(
    OrderedTransactionByAccountSchema,
    Key,
    Version,
    ORDERED_TRANSACTION_BY_ACCOUNT_CF_NAME
);
```
