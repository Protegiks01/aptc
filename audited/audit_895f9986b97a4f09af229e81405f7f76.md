# Audit Report

## Title
Incomplete Gas Schedule Parameters Can Cause Network-Wide VM Startup Failure and Total Loss of Liveness

## Summary
The `aptos-gas-schedule-updator` tool allows generation of on-chain gas schedules with incomplete parameters for a specified feature version. When combined with missing on-chain validation, this enables governance proposals that update the gas schedule with a feature version that lacks required parameters, causing all validators to experience `VM_STARTUP_FAILURE` and complete network halt.

## Finding Description

The vulnerability exists in the gas schedule update proposal generation and validation flow:

**1. Proposal Generation Logic:**

The `current_gas_schedule()` function creates gas schedules by filtering parameters based on version-specific key bindings: [1](#0-0) 

This function accepts an arbitrary `feature_version` parameter and uses it to filter `AptosGasParameters::initial()`. The critical issue is that `initial()` returns parameters from the **current binary**, not necessarily all parameters required for the specified `feature_version`.

**2. Version-Specific Parameter Filtering:**

Gas parameters are defined with version-specific key bindings. For example: [2](#0-1) 

The `to_on_chain_gas_schedule()` method only includes parameters that have key bindings for the requested version: [3](#0-2) 

**3. Missing On-Chain Validation:**

The on-chain validation only checks that the new feature version is not older than the current one, with explicit TODO comments indicating missing consistency checks: [4](#0-3) 

**4. Strict Loading Requirements:**

When validators load the gas schedule, `from_on_chain_gas_schedule()` REQUIRES all version-specific parameters to exist: [5](#0-4) 

Missing parameters cause errors that propagate as `VM_STARTUP_FAILURE`: [6](#0-5) 

**Attack Scenario:**

1. Network operates at `feature_version=12` with RELEASE_V1_12 (value 17)
2. New release introduces `feature_version=13` (RELEASE_V1_13, value 18) with new parameters like `max_transaction_size_in_bytes_gov`
3. Operator uses an **old binary** (compiled before v13 was added) to generate gas schedule update
4. Operator runs: `aptos-gas-schedule-updator --gas-feature-version 13 --output proposal/`
5. Old binary's `AptosGasParameters::initial()` lacks v13 parameters
6. `to_on_chain_gas_schedule(13)` generates incomplete schedule with `feature_version: 13`
7. Governance proposal submitted and approved (passes validation since 13 >= 12)
8. On-chain gas schedule updated with `feature_version=13` but missing required v13 parameters
9. Validators upgrade to new binary and restart
10. During initialization, validators call `AptosGasParameters::from_on_chain_gas_schedule(&map, 13)`
11. Code expects `max_transaction_size_in_bytes_gov` for v13 but it doesn't exist in map
12. Error: "Gas parameter txn.max_transaction_size_in_bytes.gov does not exist. Feature version: 13."
13. All validators experience `VM_STARTUP_FAILURE` on every transaction
14. **Complete network halt - total loss of liveness**

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under the Aptos bug bounty program:

- **Total loss of liveness/network availability**: All validators fail to execute ANY transactions due to `VM_STARTUP_FAILURE`, causing complete network halt
- **Non-recoverable without hardfork**: Requires emergency on-chain fix or rollback, potentially necessitating a hardfork if governance is non-functional
- **Breaks Deterministic Execution invariant**: All validators uniformly fail but produce no state progression
- **Requires emergency intervention**: Network operators must coordinate emergency response

The impact is network-wide and affects all validators simultaneously. Unlike typical liveness issues that might affect subsets of nodes, this creates a complete deadlock where no transactions can be processed.

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability can occur through several realistic scenarios:

1. **Operational Error**: During major releases with gas parameter changes, operators might use mismatched binary versions for proposal generation
2. **Tooling Confusion**: The `--gas-feature-version` flag accepts arbitrary values without validation against the binary's capabilities
3. **Distributed Teams**: Different team members using different binary versions during release coordination
4. **Incomplete Parameter Additions**: Developers adding new version-gated parameters but making mistakes in key bindings

The attack requires:
- Governance proposal approval (high barrier but normal governance process)
- No privileged validator access
- Simple binary version mismatch or manual flag override

The lack of on-chain validation (explicitly marked with TODO comments) significantly increases likelihood.

## Recommendation

Implement multi-layered validation to prevent incomplete gas schedules:

**1. Add Binary-Side Validation:**

Modify `current_gas_schedule()` to validate completeness:

```rust
pub fn current_gas_schedule(feature_version: u64) -> Result<GasScheduleV2, String> {
    let params = AptosGasParameters::initial();
    let entries = params.to_on_chain_gas_schedule(feature_version);
    
    // Validate: try to load back what we just generated
    let map: BTreeMap<String, u64> = entries.iter()
        .map(|(k, v)| (k.clone(), *v))
        .collect();
    
    AptosGasParameters::from_on_chain_gas_schedule(&map, feature_version)?;
    
    Ok(GasScheduleV2 {
        feature_version,
        entries,
    })
}
```

**2. Implement On-Chain Consistency Check:**

Replace the TODO comments in `gas_schedule.move` with actual validation by calling a native function that attempts to deserialize and validate the gas schedule against the current feature version before accepting it.

**3. Add Version Bounds Check:**

Validate that `--gas-feature-version` is within the binary's known range:

```rust
let feature_version = args.gas_feature_version.unwrap_or(LATEST_GAS_FEATURE_VERSION);
if feature_version > LATEST_GAS_FEATURE_VERSION {
    return Err(anyhow::anyhow!(
        "Requested feature version {} exceeds binary's maximum {}",
        feature_version,
        LATEST_GAS_FEATURE_VERSION
    ));
}
```

**4. Add Roundtrip Test:**

```rust
#[test]
fn test_gas_schedule_roundtrip() {
    for ver in 0..=LATEST_GAS_FEATURE_VERSION {
        let schedule = current_gas_schedule(ver).expect("should generate");
        let map = schedule.entries.into_iter().collect();
        AptosGasParameters::from_on_chain_gas_schedule(&map, ver)
            .expect("should roundtrip successfully");
    }
}
```

## Proof of Concept

**Scenario Reproduction Steps:**

1. **Setup**: Build binary at RELEASE_V1_12 (feature_version=17)
2. **Generate Invalid Proposal**:
```bash
# Using old binary but specifying newer version
cargo run --bin aptos-gas-schedule-updator -- \
    --gas-feature-version 18 \
    --output ./malicious_proposal/
```

3. **Submit Proposal**: The generated Move script passes on-chain validation since 18 >= 17

4. **Execute Proposal**: Governance approves and executes via `gas_schedule::set_for_next_epoch()`

5. **Upgrade Validators**: Validators upgrade to RELEASE_V1_13 binary (feature_version=18)

6. **Observe Failure**: All validators attempt to load gas schedule:
```rust
// In aptos-vm-environment/src/gas.rs:get_gas_config_from_storage()
let (gas_schedule, bytes) = GasScheduleV2::fetch_config_and_bytes(state_view);
let feature_version = gas_schedule.feature_version; // Returns 18
let map = gas_schedule.into_btree_map();

// This fails because v18 parameters don't exist in map
AptosGasParameters::from_on_chain_gas_schedule(&map, 18)
// Error: "Gas parameter txn.max_transaction_size_in_bytes.gov does not exist. Feature version: 18."
```

7. **Result**: All transaction execution returns `VM_STARTUP_FAILURE`, network halted

**Validation Test:**

```rust
#[test]
fn test_incomplete_gas_schedule_causes_vm_failure() {
    // Simulate v13 schedule missing v13-specific parameters
    let mut incomplete_entries = vec![
        ("txn.min_transaction_gas_units".to_string(), 2_760_000),
        // Missing: max_transaction_size_in_bytes_gov which requires v13+
    ];
    
    let incomplete_schedule = GasScheduleV2 {
        feature_version: 18, // RELEASE_V1_13
        entries: incomplete_entries,
    };
    
    let map: BTreeMap<_, _> = incomplete_schedule.entries.into_iter().collect();
    
    // This should fail
    let result = AptosGasParameters::from_on_chain_gas_schedule(&map, 18);
    assert!(result.is_err());
    assert!(result.unwrap_err().contains("does not exist"));
}
```

### Citations

**File:** aptos-move/aptos-gas-schedule-updator/src/lib.rs (L116-121)
```rust
pub fn current_gas_schedule(feature_version: u64) -> GasScheduleV2 {
    GasScheduleV2 {
        feature_version,
        entries: AptosGasParameters::initial().to_on_chain_gas_schedule(feature_version),
    }
}
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L77-81)
```rust
        [
            max_transaction_size_in_bytes_gov: NumBytes,
            { RELEASE_V1_13.. => "max_transaction_size_in_bytes.gov" },
            1024 * 1024
        ],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L32-46)
```rust
        impl $crate::traits::FromOnChainGasSchedule for $params_name {
            #[allow(unused)]
            fn from_on_chain_gas_schedule(gas_schedule: &std::collections::BTreeMap<String, u64>, feature_version: u64) -> Result<Self, String> {
                let mut params = $params_name::zeros();

                $(
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        let name = format!("{}.{}", $prefix, key);
                        params.$name = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?.into();
                    }
                )*

                Ok(params)
            }
        }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L48-61)
```rust
        impl $crate::traits::ToOnChainGasSchedule for $params_name {
            #[allow(unused)]
            fn to_on_chain_gas_schedule(&self, feature_version: u64) -> Vec<(String, u64)> {
                let mut output = vec![];

                $(
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        output.push((format!("{}.{}", $prefix, key), self.$name.into()))
                    }
                )*

                output
            }
        }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L273-282)
```rust
pub(crate) fn get_or_vm_startup_failure<'a, T>(
    gas_params: &'a Result<T, String>,
    log_context: &AdapterLogSchema,
) -> Result<&'a T, VMStatus> {
    gas_params.as_ref().map_err(|err| {
        let msg = format!("VM Startup Failed. {}", err);
        speculative_error!(log_context, msg.clone());
        VMStatus::error(StatusCode::VM_STARTUP_FAILURE, Some(msg))
    })
}
```
