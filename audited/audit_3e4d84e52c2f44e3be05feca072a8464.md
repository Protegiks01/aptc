# Audit Report

## Title
Block Timestamp Manipulation Enables Premature Transaction Garbage Collection in Mempool

## Summary
A malicious validator can manipulate block timestamps to cause premature garbage collection of valid transactions in the mempool. By setting their system clock up to 5 minutes into the future, a proposer can create blocks with future timestamps that pass consensus validation but trigger early removal of transactions that haven't actually expired yet.

## Finding Description

The vulnerability exists in the interaction between consensus block timestamp validation and mempool garbage collection logic. The attack flow is:

**1. Block Timestamp Source**: When a validator proposes a block, the timestamp comes from their local system time: [1](#0-0) 

This timestamp originates from the proposer's system clock, which they fully control.

**2. Insufficient Timestamp Validation**: While there is validation that blocks cannot be more than 5 minutes in the future, this check compares against the *validator's own local time*, not a global reference: [2](#0-1) 

A malicious validator can set their system clock forward by up to 5 minutes. When they propose a block, it will contain a timestamp up to 5 minutes in the future. When other honest validators verify this block, they check `block.timestamp <= their_local_time + 5_minutes`, which passes since the manipulated timestamp is within the 5-minute window.

**3. Timestamp Propagation to Mempool**: Once the block with the manipulated future timestamp is committed through consensus, state sync extracts this timestamp and sends it to mempool: [3](#0-2) 

**4. Premature Garbage Collection**: The mempool then uses this future timestamp to garbage collect transactions: [4](#0-3) 

The `gc_by_expiration_time()` function compares transaction expiration times against this manipulated future timestamp: [5](#0-4) [6](#0-5) 

All transactions with `expiration_timestamp_secs < manipulated_future_time` are removed, even though they haven't actually expired according to real wall-clock time.

**Attack Scenario**: 
- Malicious validator sets system clock to `real_time + 5_minutes`
- When selected as proposer, creates block with timestamp = `real_time + 5_minutes`
- Block passes validation and gets committed
- All nodes' mempools remove transactions expiring in the next 5 minutes
- Victims must resubmit transactions with extended expiration times

This breaks the critical invariant that **transactions should only be garbage collected after their client-specified expiration time has actually elapsed**.

## Impact Explanation

**High Severity** - This vulnerability enables:

1. **Transaction Censorship**: A malicious validator can systematically purge specific transactions from all mempools by timing their proposals to coincide with target transactions' expiration windows.

2. **Network-Wide Impact**: Since the manipulated timestamp is embedded in committed blocks, all nodes in the network will perform premature GC, not just the malicious validator.

3. **Denial of Service**: Users whose transactions are prematurely removed must detect the removal, create new transactions with extended expiration times, and resubmit - degrading user experience and potentially causing transaction failures for time-sensitive operations.

4. **Repeated Exploitation**: The attack can be executed every time the malicious validator is selected as proposer (which happens regularly in validator rotation), creating persistent disruption.

This qualifies as **High Severity** per the Aptos bug bounty criteria: "Validator node slowdowns" and "Significant protocol violations". While it doesn't directly cause fund loss, it represents a significant protocol violation that degrades network functionality and enables targeted transaction censorship.

## Likelihood Explanation

**High Likelihood**:
- **Single Actor**: Requires only one malicious validator, no collusion needed
- **Simple Execution**: Simply set system clock forward by 5 minutes
- **Regular Opportunity**: Validator is periodically selected as proposer through normal rotation
- **No Detection**: The manipulated timestamp is within valid bounds (< 5 minutes future), making it hard to detect as malicious
- **Immediate Effect**: Premature GC happens automatically upon block commitment

The attack is trivial to execute and provides a predictable outcome.

## Recommendation

Implement **consensus-based block timestamp validation** rather than relying solely on local time checks:

1. **Record median timestamp from vote messages**: Have each validator include their local timestamp when voting on a block. The block can only be committed if the proposer's timestamp is within reasonable bounds of the median voter timestamp.

2. **Strengthen mempool GC logic**: Add a safety margin when using block timestamps for GC. For example:
   ```rust
   pub(crate) fn gc_by_expiration_time(&mut self, block_time: Duration) {
       // Add safety margin to avoid premature GC from clock skew
       let gc_time_with_margin = block_time.saturating_sub(Duration::from_secs(60));
       self.gc(self.eager_expire_time(gc_time_with_margin), false);
   }
   ```

3. **Use system TTL for primary GC**: The mempool already has a system TTL index that uses each node's local time. Rely more heavily on this for GC, using block timestamps only as a secondary mechanism: [7](#0-6) 

4. **Add timestamp sanity checks**: Before using block timestamp for GC, verify it's not more than a small delta ahead of local time:
   ```rust
   if block_timestamp_usecs > 0 {
       let local_time = aptos_infallible::duration_since_epoch();
       let block_time = Duration::from_micros(block_timestamp_usecs);
       // Only use block time if it's not suspiciously far in the future
       if block_time <= local_time + Duration::from_secs(60) {
           pool.gc_by_expiration_time(block_time);
       }
   }
   ```

## Proof of Concept

The following demonstrates the vulnerability conceptually:

```rust
// Simulated test showing premature GC
#[test]
fn test_block_timestamp_manipulation_causes_premature_gc() {
    // Setup: Create mempool with transactions expiring in 3 minutes
    let mut mempool = create_test_mempool();
    let current_time = duration_since_epoch();
    let expiration_time = current_time + Duration::from_secs(180); // 3 minutes
    
    // Add transaction to mempool
    let txn = create_transaction_with_expiration(expiration_time.as_secs());
    mempool.add_txn(txn, ...);
    
    // Malicious validator creates block with timestamp 5 minutes in future
    let malicious_timestamp = current_time + Duration::from_secs(300); // 5 minutes
    
    // This timestamp passes consensus validation because:
    // verify_well_formed checks: timestamp <= current_time + TIMEBOUND(300s)
    // 300s <= 0s + 300s âœ“ (passes on honest validator's machine)
    
    // Block gets committed with this timestamp
    // State sync notifies mempool with block_timestamp_usecs
    
    // Mempool performs GC with the future timestamp
    mempool.gc_by_expiration_time(malicious_timestamp);
    
    // Transaction is prematurely removed even though it hasn't actually expired
    // According to real time: current_time + 0s < expiration_time (180s away)
    // But GC compares: expiration_time (current + 180s) < malicious_timestamp (current + 300s)
    // Result: Transaction is garbage collected 3 minutes early!
    
    assert!(mempool.get_transaction(txn.hash()).is_none()); // Transaction removed!
}
```

To reproduce in a real environment:
1. Set up a test network with a malicious validator
2. On the malicious validator, set system clock forward: `date -s "+5 minutes"`
3. Wait for malicious validator to be selected as proposer
4. Submit transactions with expiration times in the next 5 minutes to other nodes
5. Observe that after the malicious validator's block is committed, these transactions disappear from all mempools despite not having reached their expiration time according to real wall-clock time

The attack succeeds because block timestamp validation only checks against local time + offset, not global synchronized time, and mempool GC trusts the committed block timestamp without additional validation.

### Citations

**File:** consensus/src/util/time_service.rs (L127-129)
```rust
    fn get_current_timestamp(&self) -> Duration {
        aptos_infallible::duration_since_epoch()
    }
```

**File:** consensus/consensus-types/src/block.rs (L532-539)
```rust
            let current_ts = duration_since_epoch();

            // we can say that too far is 5 minutes in the future
            const TIMEBOUND: u64 = 300_000_000;
            ensure!(
                self.timestamp_usecs() <= (current_ts.as_micros() as u64).saturating_add(TIMEBOUND),
                "Blocks must not be too far in the future"
            );
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L88-103)
```rust
        let blockchain_timestamp_usecs = latest_synced_ledger_info.ledger_info().timestamp_usecs();
        debug!(
            LogSchema::new(LogEntry::NotificationHandler).message(&format!(
                "Notifying the storage service, mempool and the event subscription service of version: {:?} and timestamp: {:?}.",
                latest_synced_version, blockchain_timestamp_usecs
            ))
        );

        // Notify the storage service of the committed transactions
        storage_service_notification_handler
            .notify_storage_service_of_committed_transactions(latest_synced_version)
            .await?;

        // Notify mempool of the committed transactions
        mempool_notification_handler
            .notify_mempool_of_committed_transactions(transactions, blockchain_timestamp_usecs)
```

**File:** mempool/src/shared_mempool/tasks.rs (L740-742)
```rust
    if block_timestamp_usecs > 0 {
        pool.gc_by_expiration_time(block_timestamp);
    }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L119-121)
```rust
            expiration_time_index: TTLIndex::new(Box::new(|t: &MempoolTransaction| {
                Duration::from_secs(t.txn.expiration_timestamp_secs())
            })),
```

**File:** mempool/src/core_mempool/index.rs (L247-260)
```rust
    pub(crate) fn gc(&mut self, now: Duration) -> Vec<TTLOrderingKey> {
        // Ideally, we should garbage collect all transactions with expiration time < now.
        let max_expiration_time = now.saturating_sub(Duration::from_micros(1));
        let ttl_key = TTLOrderingKey {
            expiration_time: max_expiration_time,
            address: AccountAddress::ZERO,
            replay_protector: ReplayProtector::Nonce(0),
        };

        let mut active = self.data.split_off(&ttl_key);
        let ttl_transactions = self.data.iter().cloned().collect();
        self.data.clear();
        self.data.append(&mut active);
        ttl_transactions
```

**File:** mempool/src/core_mempool/mempool.rs (L590-593)
```rust
    pub(crate) fn gc(&mut self) {
        let now = aptos_infallible::duration_since_epoch();
        self.transactions.gc_by_system_ttl(now);
    }
```
