# Audit Report

## Title
TOCTOU Race Condition Allows Double-Funding of Accounts in Aptos Faucet

## Summary
A Time-Of-Check Time-Of-Use (TOCTOU) race condition in `TransferFunder::fund()` allows attackers to bypass the faucet's single-funding guarantee. Concurrent requests for the same non-existing account can both pass validation checks and successfully fund the account multiple times, draining faucet funds beyond intended limits.

## Finding Description

The vulnerability exists in the account existence validation flow within the TransferFunder faucet implementation. The code performs a critical security check to ensure accounts receive funding only once, but this check is not atomic with the actual funding transaction. [1](#0-0) 

The comment claims that "the transaction we submit ensures that the account doesn't exist already," which is factually incorrect.

**The Race Condition Window:**

1. **Check Phase (Lines 284-297):** The faucet calls `update_sequence_numbers()` which fetches the receiver's sequence number from the blockchain API. [2](#0-1) 

2. **Validation (Line 297):** If `receiver_seq_num.is_some()`, the request is rejected as the account already exists. [3](#0-2) 

3. **Use Phase (Lines 314-320):** The transaction is submitted using `aptos_stdlib::aptos_account_transfer`. [4](#0-3) 

**The Critical Flaw:** The Move function `aptos_account::transfer` does NOT enforce that the account must not exist. It explicitly handles both cases: [5](#0-4) 

The function creates the account if it doesn't exist (line 83-85), but then ALWAYS transfers funds regardless of whether the account existed beforehand. This means the second transaction in a race will still succeed and transfer funds to an already-existing account.

**Attack Scenario:**

1. Attacker identifies a non-existing address
2. Attacker sends 2+ concurrent requests to the faucet for the same address
3. Request A fetches sequence numbers → receiver doesn't exist (None)
4. Request B fetches sequence numbers → receiver doesn't exist (None)
5. Request A passes validation check (line 297), submits transaction with funder sequence N
6. Request B passes validation check (line 297) with stale data, submits transaction with funder sequence N+1
7. Request A's transaction executes: creates account + transfers funds
8. Request B's transaction executes: account exists, but still transfers funds
9. Result: Account receives double (or N-times) the intended funding amount

**Why the Queue Mechanism Fails to Prevent This:**

The `outstanding_requests` queue in `update_sequence_numbers` only ensures serial assignment of funder sequence numbers. The receiver's sequence number is fetched BEFORE the queue processing begins, so both requests use stale receiver state data. [6](#0-5) 

## Impact Explanation

**Severity: HIGH** (per Aptos Bug Bounty: "Limited funds loss or manipulation")

This vulnerability allows unauthorized fund distribution and potential complete drainage of the faucet account:

1. **Direct Financial Impact:** Each successful attack doubles (or multiplies) the intended funding amount
2. **Faucet Drainage:** Repeated exploitation can drain the entire faucet balance
3. **Service Disruption:** Rapid depletion triggers the faucet's low-balance health check, causing service unavailability
4. **Unfair Distribution:** Legitimate users cannot access faucet funds while attackers hoard resources

The impact qualifies as HIGH severity because it represents a clear bypass of resource limits - a critical invariant for faucet operations. While this doesn't directly affect consensus or validator operations, it compromises the integrity of the testnet/devnet funding mechanism.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability has high exploitability because:

1. **No Special Permissions Required:** Any user can send HTTP requests to the public faucet endpoint
2. **Simple Exploitation:** Requires only concurrent HTTP requests with identical parameters
3. **Reliable Timing:** Modern async HTTP libraries make concurrent requests trivial
4. **Detectable Success:** Attacker can verify success by checking on-chain balance
5. **Repeatable:** Attack can be executed multiple times with different addresses
6. **Current Production Code:** The vulnerable code is actively deployed in testnet/devnet faucets

The attack complexity is LOW - a simple script with 2 concurrent HTTP requests is sufficient. No special infrastructure or timing precision is needed.

## Recommendation

**Fix: Re-fetch receiver sequence number immediately before validation, or use atomic check-and-set semantics.**

**Option 1: Re-fetch receiver state after queue processing (Recommended)**

Modify `update_sequence_numbers` to re-fetch the receiver's sequence number after completing the queue logic but before returning:

```rust
// In update_sequence_numbers, after line 264:
// Re-fetch receiver sequence number to prevent TOCTOU
let (_, fresh_receiver_seq) = 
    get_sequence_numbers(client, funder_account, receiver_address).await?;
Ok((funder_seq, fresh_receiver_seq))
```

**Option 2: Use Move-level enforcement**

Create a dedicated faucet Move function that atomically checks account non-existence and fails the entire transaction if the account exists:

```move
public entry fun faucet_fund(faucet: &signer, to: address, amount: u64) {
    // This will fail the transaction if account exists
    assert!(!account::exists_at(to), EACCOUNT_ALREADY_EXISTS);
    create_account(to);
    coin::transfer<AptosCoin>(faucet, to, amount);
}
```

**Option 3: Implement request deduplication**

Add a cache/bloom filter that tracks recent funding requests by address with TTL, rejecting duplicates within the time window.

## Proof of Concept

```rust
// Concurrent Faucet Request PoC
// This demonstrates the race condition exploitation

use std::sync::Arc;
use tokio::task::JoinSet;
use reqwest::Client;

#[tokio::test]
async fn test_faucet_double_funding_race() {
    // Setup: Generate a new non-existing address
    let new_address = "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef";
    let faucet_url = "https://faucet.testnet.aptoslabs.com/mint";
    
    let client = Arc::new(Client::new());
    let mut tasks = JoinSet::new();
    
    // Launch 2 concurrent funding requests for the same address
    for _ in 0..2 {
        let client_clone = client.clone();
        let address = new_address.to_string();
        
        tasks.spawn(async move {
            client_clone
                .post(faucet_url)
                .json(&serde_json::json!({
                    "address": address,
                    "amount": 100_000_000 // 1 APT in octas
                }))
                .send()
                .await
        });
    }
    
    // Wait for both requests to complete
    let mut success_count = 0;
    while let Some(result) = tasks.join_next().await {
        if let Ok(Ok(response)) = result {
            if response.status().is_success() {
                success_count += 1;
            }
        }
    }
    
    // Vulnerability: Both requests succeed
    assert_eq!(success_count, 2, "Race condition allowed double funding");
    
    // Verify on-chain balance is 2 APT instead of 1 APT
    // (requires additional API call to check balance)
}
```

**Move Test Alternative:**

```move
#[test(faucet = @0xcafe, user = @0x42)]
fun test_transfer_to_existing_account_succeeds(faucet: &signer, user: &signer) {
    // This test proves aptos_account::transfer doesn't prevent funding existing accounts
    let (burn_cap, mint_cap) = aptos_coin::initialize_for_test(faucet);
    
    // First transfer - creates account
    transfer(faucet, signer::address_of(user), 100);
    assert!(coin::balance<AptosCoin>(signer::address_of(user)) == 100, 0);
    
    // Second transfer to SAME existing account - SHOULD FAIL but DOESN'T
    transfer(faucet, signer::address_of(user), 100);
    assert!(coin::balance<AptosCoin>(signer::address_of(user)) == 200, 1);
    // BUG: Account received funding twice!
    
    coin::destroy_burn_cap(burn_cap);
    coin::destroy_mint_cap(mint_cap);
}
```

## Notes

The code comment explicitly states the transaction provides the security guarantee, but analysis of the `aptos_account::transfer` Move function reveals this is false. The function is designed as a "convenient" wrapper that handles both existing and non-existing accounts, making it unsuitable for enforcing single-funding semantics at the Move level.

The vulnerability is exacerbated by the fact that the sequence number fetch happens early in `update_sequence_numbers`, and the queue mechanism only prevents funder sequence number conflicts, not stale receiver state issues.

### Citations

**File:** crates/aptos-faucet/core/src/funder/transfer.rs (L253-260)
```rust
    /// Before actually initiating the fund transaction, we do a set of checks,
    /// such as ensuring that the funder has sufficient funds and that the
    /// receiver account does not yet exist. These are not meant to completely
    /// verify these preconditions, as there could be races between the checks
    /// and the transaction submission between requests, but it reduces the
    /// prevalence of transaction failure. The transaction we submit ensures
    /// that the account doesn't exist already, so that's our real guarantee,
    /// the prior checks are just to avoid paying gas if we don't need to.
```

**File:** crates/aptos-faucet/core/src/funder/transfer.rs (L297-306)
```rust
        if receiver_seq_num.is_some() {
            return Err(AptosTapError::new(
                "Account ineligible".to_string(),
                AptosTapErrorCode::Rejected,
            )
            .rejection_reasons(vec![RejectionReason::new(
                format!("Account {} already exists", receiver_address),
                RejectionReasonCode::AccountAlreadyExists,
            )]));
        }
```

**File:** crates/aptos-faucet/core/src/funder/transfer.rs (L314-320)
```rust
            let txn = self
                .execute_transaction(
                    &client,
                    aptos_stdlib::aptos_account_transfer(receiver_address, amount),
                    &receiver_address,
                )
                .await?;
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L213-224)
```rust
    let (mut funder_seq, mut receiver_seq) =
        get_sequence_numbers(client, funder_account, receiver_address).await?;
    let our_funder_seq = {
        let funder_account = funder_account.write().await;

        // If the onchain sequence_number is greater than what we have, update our
        // sequence_numbers
        if funder_seq > funder_account.sequence_number() {
            funder_account.set_sequence_number(funder_seq);
        }
        funder_account.sequence_number()
    };
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L311-339)
```rust
async fn get_sequence_numbers(
    client: &Client,
    funder_account: &RwLock<LocalAccount>,
    receiver_address: AccountAddress,
) -> Result<(u64, Option<u64>), AptosTapError> {
    let funder_address = funder_account.read().await.address();
    let f_request = client.get_account(funder_address);
    let r_request = client.get_account(receiver_address);
    let mut responses = futures::future::join_all([f_request, r_request]).await;

    let receiver_seq_num = responses
        .remove(1)
        .as_ref()
        .ok()
        .map(|account| account.inner().sequence_number);

    let funder_seq_num = responses
        .remove(0)
        .map_err(|e| {
            AptosTapError::new(
                format!("funder account {} not found: {:#}", funder_address, e),
                AptosTapErrorCode::AccountDoesNotExist,
            )
        })?
        .inner()
        .sequence_number;

    Ok((funder_seq_num, receiver_seq_num))
}
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L82-97)
```text
    public entry fun transfer(source: &signer, to: address, amount: u64) {
        if (!account::exists_at(to)) {
            create_account(to)
        };

        if (features::operations_default_to_fa_apt_store_enabled()) {
            fungible_transfer_only(source, to, amount)
        } else {
            // Resource accounts can be created without registering them to receive APT.
            // This conveniently does the registration if necessary.
            if (!coin::is_account_registered<AptosCoin>(to)) {
                coin::register<AptosCoin>(&create_signer(to));
            };
            coin::transfer<AptosCoin>(source, to, amount)
        }
    }
```
