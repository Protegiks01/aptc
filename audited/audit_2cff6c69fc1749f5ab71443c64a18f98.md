# Audit Report

## Title
BLS Signature Bypass in Fast-Forward Sync Allows Unverified Quorum Certificates in Block Tree

## Summary
The `insert_single_quorum_cert()` function does not verify BLS signature aggregation in QuorumCerts. During fast-forward sync, blocks retrieved from peers contain embedded QuorumCerts that are extracted and saved to storage without signature verification, violating the Cryptographic Correctness invariant and allowing malformed QCs into the consensus state.

## Finding Description

The vulnerability exists across three critical code paths:

**1. Missing Verification in insert_single_quorum_cert()** [1](#0-0) 

The function only validates block existence and consistency but never calls `qc.verify(validator)` to verify BLS signature aggregation.

**2. Unverified QC Extraction During Fast-Forward Sync** [2](#0-1) 

During `fast_forward_sync()`, QuorumCerts are extracted from blocks retrieved from peers without signature verification.

**3. Unverified Storage Persistence** [3](#0-2) 

These unverified QCs are saved directly to storage via `save_tree()`.

**4. Unverified Recovery Loading** [4](#0-3) 

On node restart, QCs are loaded from storage without verification. [5](#0-4) 

These loaded QCs are inserted via `insert_single_quorum_cert()` during BlockStore rebuild, again without verification.

**Attack Path:**

1. Victim node falls behind and requires sync
2. Attacker peer sends valid `SyncInfo` with properly signed `highest_quorum_cert`
3. SyncInfo passes verification in `RoundManager::sync_up()`: [6](#0-5) 

4. Victim calls `fast_forward_sync()` to retrieve intermediate blocks from attacker
5. Attacker responds with blocks containing **malformed QCs with invalid BLS signatures**
6. Blocks are retrieved without calling `Block::validate_signature()`: [7](#0-6) 

7. Malformed QCs are extracted and persisted to ConsensusDB
8. On restart, malformed QCs are loaded and inserted into block tree without verification

## Impact Explanation

**Critical Severity** - This breaks multiple consensus invariants:

- **Cryptographic Correctness (Invariant #10)**: BLS signature verification is bypassed, allowing invalid quorum certificates
- **Consensus Safety (Invariant #2)**: Nodes can be tricked into building on blocks certified by invalid QCs, potentially causing forks
- **State Consistency (Invariant #4)**: Block tree contains cryptographically invalid certification data

A compromised node will:
- Make incorrect voting decisions based on invalid QCs
- Propagate invalid QCs to other nodes
- Potentially accept blocks that lack true quorum support

While other honest nodes will reject signatures from the compromised node, the compromised node itself loses consensus participation capability and may contribute to liveness failures.

## Likelihood Explanation

**High Likelihood**: 
- Requires attacker to be selected as sync peer (common during normal operations)
- No validator insider access required - any network peer can attempt this
- Attack triggers during routine fast-forward sync operations
- No cryptographic breaks needed - simply omit signature verification
- Victim node will accept malformed data without detection

## Recommendation

Add signature verification before persisting QuorumCerts during fast-forward sync:

```rust
// In fast_forward_sync() after line 411, before line 503:
for qc in &quorum_certs {
    qc.verify(retriever.validator_verifier())
        .context("Failed to verify retrieved QC during fast-forward sync")?;
}
```

Additionally, add verification in `insert_single_quorum_cert()`:

```rust
pub fn insert_single_quorum_cert(&self, qc: QuorumCert) -> anyhow::Result<()> {
    // Add verification before processing
    qc.verify(&self.epoch_state.verifier)?;
    
    // ... existing code
}
```

**Note**: The `ValidatorVerifier` should be available in the context where these functions are called.

## Proof of Concept

```rust
// Attacker peer implementation
struct MaliciousBlockRetriever;

impl MaliciousBlockRetriever {
    fn create_block_with_invalid_qc() -> Block {
        let mut block = Block::new_proposal(...);
        
        // Create QC with invalid BLS signature
        let malformed_sig = AggregateSignature::empty(); 
        let invalid_qc = QuorumCert::new(
            vote_data,
            LedgerInfoWithSignatures::new(ledger_info, malformed_sig)
        );
        
        // Block embeds this invalid QC but appears structurally valid
        block.set_quorum_cert(invalid_qc);
        block
    }
    
    async fn respond_to_block_retrieval(&self, request: BlockRetrievalRequest) 
        -> BlockRetrievalResponse {
        let blocks = vec![
            self.create_block_with_invalid_qc(),
            // More blocks with invalid QCs
        ];
        
        // These blocks pass structural checks but have invalid signatures
        BlockRetrievalResponse::new(BlockRetrievalStatus::Succeeded, blocks)
    }
}

// Victim node will:
// 1. Call fast_forward_sync()
// 2. Retrieve these blocks
// 3. Extract QCs WITHOUT verification (sync_manager.rs:410)
// 4. Save to storage WITHOUT verification (sync_manager.rs:503)
// 5. On restart, load and insert WITHOUT verification (block_store.rs:301)
```

## Notes

The vulnerability relies on the assumption that blocks retrieved during sync don't need verification because the triggering `highest_quorum_cert` was verified. However, intermediate QCs extracted from retrieved blocks are never verified, creating a bypass vector. While the QuorumCert verification method exists and is properly implemented [8](#0-7) , it's simply never called in these critical code paths.

### Citations

**File:** consensus/src/block_storage/block_store.rs (L299-305)
```rust
        for qc in quorum_certs {
            block_store
                .insert_single_quorum_cert(qc)
                .unwrap_or_else(|e| {
                    panic!("[BlockStore] failed to insert quorum during build{:?}", e)
                });
        }
```

**File:** consensus/src/block_storage/block_store.rs (L519-556)
```rust
    pub fn insert_single_quorum_cert(&self, qc: QuorumCert) -> anyhow::Result<()> {
        // If the parent block is not the root block (i.e not None), ensure the executed state
        // of a block is consistent with its QuorumCert, otherwise persist the QuorumCert's
        // state and on restart, a new execution will agree with it.  A new execution will match
        // the QuorumCert's state on the next restart will work if there is a memory
        // corruption, for example.
        match self.get_block(qc.certified_block().id()) {
            Some(pipelined_block) => {
                ensure!(
                    // decoupled execution allows dummy block infos
                    pipelined_block
                        .block_info()
                        .match_ordered_only(qc.certified_block()),
                    "QC for block {} has different {:?} than local {:?}",
                    qc.certified_block().id(),
                    qc.certified_block(),
                    pipelined_block.block_info()
                );
                observe_block(
                    pipelined_block.block().timestamp_usecs(),
                    BlockStage::QC_ADDED,
                );
                if pipelined_block.block().is_opt_block() {
                    observe_block(
                        pipelined_block.block().timestamp_usecs(),
                        BlockStage::QC_ADDED_OPT_BLOCK,
                    );
                }
                pipelined_block.set_qc(Arc::new(qc.clone()));
            },
            None => bail!("Insert {} without having the block in store first", qc),
        };

        self.storage
            .save_tree(vec![], vec![qc.clone()])
            .context("Insert block failed when saving quorum")?;
        self.inner.write().insert_quorum_cert(qc)
    }
```

**File:** consensus/src/block_storage/sync_manager.rs (L405-411)
```rust
        let mut quorum_certs = vec![highest_quorum_cert.clone()];
        quorum_certs.extend(
            blocks
                .iter()
                .take(blocks.len() - 1)
                .map(|block| block.quorum_cert().clone()),
        );
```

**File:** consensus/src/block_storage/sync_manager.rs (L503-503)
```rust
        storage.save_tree(blocks.clone(), quorum_certs.clone())?;
```

**File:** consensus/src/persistent_liveness_storage.rs (L533-534)
```rust
        let blocks = raw_data.2;
        let quorum_certs: Vec<_> = raw_data.3;
```

**File:** consensus/src/round_manager.rs (L888-896)
```rust
            sync_info.verify(&self.epoch_state.verifier).map_err(|e| {
                error!(
                    SecurityEvent::InvalidSyncInfoMsg,
                    sync_info = sync_info,
                    remote_peer = author,
                    error = ?e,
                );
                VerifyError::from(e)
            })?;
```

**File:** consensus/consensus-types/src/block.rs (L425-440)
```rust
    pub fn validate_signature(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        match self.block_data.block_type() {
            BlockType::Genesis => bail!("We should not accept genesis from others"),
            BlockType::NilBlock { .. } => self.quorum_cert().verify(validator),
            BlockType::Proposal { author, .. } => {
                let signature = self
                    .signature
                    .as_ref()
                    .ok_or_else(|| format_err!("Missing signature in Proposal"))?;
                let (res1, res2) = rayon::join(
                    || validator.verify(*author, &self.block_data, signature),
                    || self.quorum_cert().verify(validator),
                );
                res1?;
                res2
            },
```

**File:** consensus/consensus-types/src/quorum_cert.rs (L119-148)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        let vote_hash = self.vote_data.hash();
        ensure!(
            self.ledger_info().ledger_info().consensus_data_hash() == vote_hash,
            "Quorum Cert's hash mismatch LedgerInfo"
        );
        // Genesis's QC is implicitly agreed upon, it doesn't have real signatures.
        // If someone sends us a QC on a fake genesis, it'll fail to insert into BlockStore
        // because of the round constraint.
        if self.certified_block().round() == 0 {
            ensure!(
                self.parent_block() == self.certified_block(),
                "Genesis QC has inconsistent parent block with certified block"
            );
            ensure!(
                self.certified_block() == self.ledger_info().ledger_info().commit_info(),
                "Genesis QC has inconsistent commit block with certified block"
            );
            ensure!(
                self.ledger_info().get_num_voters() == 0,
                "Genesis QC should not carry signatures"
            );
            return Ok(());
        }
        self.ledger_info()
            .verify_signatures(validator)
            .context("Fail to verify QuorumCert")?;
        self.vote_data.verify()?;
        Ok(())
    }
```
