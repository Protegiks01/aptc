# Audit Report

## Title
Non-Atomic State Database Queries Enable Cryptographic Verification Bypass

## Summary
The `DbStateView::get()` function executes two separate database queries that are not atomic: `get_state_value_with_proof_by_version` (reading from StateMerkleDb) and `get_state_value_with_version_by_version` (reading from StateKvDb). Due to asynchronous commit architecture, StateKvDb can be ahead of StateMerkleDb, creating a window where proof verification silently fails and unverified data is returned.

## Finding Description

The vulnerability exists in the dual-query pattern used by `DbStateView::get()`: [1](#0-0) 

This function performs two sequential database queries that are fundamentally non-atomic because they read from different databases with different commit timings:

**First Query Path (Proof Verification):** [2](#0-1) 

This reads from StateMerkleDb, which is committed **asynchronously** via background threads.

**Second Query Path (Value Retrieval):** [3](#0-2) 

This reads from StateKvDb, which is committed **synchronously** during transaction processing.

**The Critical Non-Atomicity:**

The commit ordering creates a race window: [4](#0-3) 

StateKvDb commits happen synchronously (line 307), while StateMerkleDb commits are enqueued asynchronously via BufferedState: [5](#0-4) [6](#0-5) 

When `sync_commit` is false, the merkle commit is enqueued but not awaited, creating a temporal inconsistency window.

**Exploitation Scenario:**

1. Transaction at version V commits: StateKvDb receives version V immediately, but StateMerkleDb commit is queued asynchronously
2. Attacker creates a `verified_state_view_at_version` during this window: [7](#0-6) 

3. When querying a key, the first query attempts to fetch proof from StateMerkleDb at version V, but the root node doesn't exist yet: [8](#0-7) 

   JellyfishMerkleTree returns `MissingRootError` when the version is not committed.

4. Due to the `if let Ok(...)` pattern in DbStateView::get(), the verification is silently bypassed, and the second query returns unverified data from StateKvDb.

## Impact Explanation

**Severity: High** - Cryptographic Verification Bypass

This vulnerability breaks **Critical Invariant #4**: "State transitions must be atomic and verifiable via Merkle proofs"

When verification is explicitly requested via `verified_state_view_at_version`, the system promises cryptographically verified state reads. This vulnerability allows that verification to be silently bypassed, returning unverified data when verification was explicitly required.

While current production usage appears limited (primarily test code), the security guarantee itself is fundamentally broken. Any future production code relying on verified state views would be vulnerable.

## Likelihood Explanation

**Likelihood: Medium to High** during normal operation

The vulnerability occurs naturally during transaction processing:
- Every non-reconfig transaction creates the race window (when `sync_commit = false`)
- The window duration depends on async commit latency (typically milliseconds)
- No attacker coordination requiredâ€”simply querying during normal operation can trigger it
- Probabilistic but frequent due to continuous transaction flow

## Recommendation

**Option 1: Enforce Atomic Reads (Preferred)**
Ensure StateMerkleDb and StateKvDb are at the same version before serving verified reads. Add a version consistency check:

```rust
fn get(&self, key: &StateKey) -> StateViewResult<Option<(Version, StateValue)>> {
    if let Some(version) = self.version {
        if let Some(root_hash) = self.maybe_verify_against_state_root_hash {
            // Ensure both DBs have the version before proceeding
            let (value, proof) = self.db
                .get_state_value_with_proof_by_version(key, version)?; // Propagate error
            proof.verify(root_hash, *key.crypto_hash_ref(), value.as_ref())?;
        }
        Ok(self.db.get_state_value_with_version_by_version(key, version)?)
    } else {
        Ok(None)
    }
}
```

**Option 2: Synchronous Merkle Commits**
Always wait for StateMerkleDb commits when verification is required: [9](#0-8) 

Modify the commit path to enforce `sync_commit = true` when creating verified state views, or add a version readiness check before serving verified reads.

**Option 3: Explicit Error on Verification Failure**
Remove the silent failure pattern and propagate errors when proof retrieval fails, forcing callers to handle inconsistent state explicitly.

## Proof of Concept

```rust
// Reproduction scenario (requires actual node setup)
// 
// 1. Start Aptos node
// 2. Submit transaction that updates state key K at version V
// 3. Immediately after StateKvDb commit but before StateMerkleDb async commit completes:
//    a. Create verified state view at version V
//    b. Query key K
//    c. Observe: proof query fails with MissingRootError
//    d. Observe: verification is silently bypassed
//    e. Observe: unverified value is returned from StateKvDb
//
// Expected: Either verified data or explicit error
// Actual: Unverified data returned without verification

// Test code demonstrating the non-atomic behavior:
use aptos_storage_interface::DbReader;
use aptos_types::state_store::state_key::StateKey;

fn test_non_atomic_reads(db: Arc<dyn DbReader>, key: StateKey, version: Version) {
    // Create verified state view (expects cryptographic verification)
    let ledger_info = db.get_latest_ledger_info().unwrap();
    let verified_view = db.verified_state_view_at_version(Some(version), &ledger_info).unwrap();
    
    // Query during the race window
    match verified_view.get_state_slot(&key) {
        Ok(slot) => {
            // SUCCESS - but was verification actually performed?
            // The proof query may have failed silently
            println!("WARNING: Received data, but verification may have been bypassed");
        }
        Err(e) => {
            println!("Error: {:?}", e);
        }
    }
}
```

**Notes:**
- The TODOs in the codebase acknowledge this limitation: [10](#0-9) 
- This indicates awareness but not resolution of the issue
- The security impact depends on production adoption of verified state views

### Citations

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L27-46)
```rust
    fn get(&self, key: &StateKey) -> StateViewResult<Option<(Version, StateValue)>> {
        if let Some(version) = self.version {
            if let Some(root_hash) = self.maybe_verify_against_state_root_hash {
                // TODO(aldenhu): sample-verify proof inside DB
                // DB doesn't support returning proofs for buffered state, so only optionally
                // verify proof.
                // TODO: support returning state proof for buffered state.
                if let Ok((value, proof)) =
                    self.db.get_state_value_with_proof_by_version(key, version)
                {
                    proof.verify(root_hash, *key.crypto_hash_ref(), value.as_ref())?;
                }
            }
            Ok(self
                .db
                .get_state_value_with_version_by_version(key, version)?)
        } else {
            Ok(None)
        }
    }
```

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L116-138)
```rust
    fn verified_state_view_at_version(
        &self,
        version: Option<Version>,
        ledger_info: &LedgerInfo,
    ) -> StateViewResult<DbStateView> {
        let db = self.clone();

        if let Some(version) = version {
            let txn_with_proof =
                db.get_transaction_by_version(version, ledger_info.version(), false)?;
            txn_with_proof.verify(ledger_info)?;

            let state_root_hash = txn_with_proof
                .proof
                .transaction_info
                .state_checkpoint_hash()
                .ok_or_else(|| StateViewError::NotFound("state_checkpoint_hash".to_string()))?;

            Ok(DbStateView {
                db,
                version: Some(version),
                maybe_verify_against_state_root_hash: Some(state_root_hash),
            })
```

**File:** storage/aptosdb/src/state_store/mod.rs (L209-236)
```rust
    fn get_state_value_with_proof_by_version_ext(
        &self,
        key_hash: &HashValue,
        version: Version,
        root_depth: usize,
        use_hot_state: bool,
    ) -> Result<(Option<StateValue>, SparseMerkleProofExt)> {
        let db = if use_hot_state {
            if self.state_merkle_db.sharding_enabled() {
                self.hot_state_merkle_db
                    .as_ref()
                    .ok_or(AptosDbError::HotStateError)?
            } else {
                // Unsharded unit tests still rely on this.
                &self.state_merkle_db
            }
        } else {
            &self.state_merkle_db
        };
        let (leaf_data, proof) = db.get_with_proof_ext(key_hash, version, root_depth)?;
        Ok((
            match leaf_data {
                Some((_val_hash, (key, ver))) => Some(self.expect_value_by_version(&key, ver)?),
                None => None,
            },
            proof,
        ))
    }
```

**File:** storage/aptosdb/src/state_kv_db.rs (L374-402)
```rust
    pub(crate) fn get_state_value_with_version_by_version(
        &self,
        state_key: &StateKey,
        version: Version,
    ) -> Result<Option<(Version, StateValue)>> {
        let mut read_opts = ReadOptions::default();

        // We want `None` if the state_key changes in iteration.
        read_opts.set_prefix_same_as_start(true);
        if !self.enabled_sharding() {
            let mut iter = self
                .db_shard(state_key.get_shard_id())
                .iter_with_opts::<StateValueSchema>(read_opts)?;
            iter.seek(&(state_key.clone(), version))?;
            Ok(iter
                .next()
                .transpose()?
                .and_then(|((_, version), value_opt)| value_opt.map(|value| (version, value))))
        } else {
            let mut iter = self
                .db_shard(state_key.get_shard_id())
                .iter_with_opts::<StateValueByKeyHashSchema>(read_opts)?;
            iter.seek(&(state_key.hash(), version))?;
            Ok(iter
                .next()
                .transpose()?
                .and_then(|((_, version), value_opt)| value_opt.map(|value| (version, value))))
        }
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L263-322)
```rust
    fn calculate_and_commit_ledger_and_state_kv(
        &self,
        chunk: &ChunkToCommit,
        skip_index_and_usage: bool,
    ) -> Result<HashValue> {
        let _timer = OTHER_TIMERS_SECONDS.timer_with(&["save_transactions__work"]);

        let mut new_root_hash = HashValue::zero();
        THREAD_MANAGER.get_non_exe_cpu_pool().scope(|s| {
            // TODO(grao): Write progress for each of the following databases, and handle the
            // inconsistency at the startup time.
            //
            // TODO(grao): Consider propagating the error instead of panic, if necessary.
            s.spawn(|_| {
                self.commit_events(
                    chunk.first_version,
                    chunk.transaction_outputs,
                    skip_index_and_usage,
                )
                .unwrap()
            });
            s.spawn(|_| {
                self.ledger_db
                    .write_set_db()
                    .commit_write_sets(chunk.first_version, chunk.transaction_outputs)
                    .unwrap()
            });
            s.spawn(|_| {
                self.ledger_db
                    .transaction_db()
                    .commit_transactions(
                        chunk.first_version,
                        chunk.transactions,
                        skip_index_and_usage,
                    )
                    .unwrap()
            });
            s.spawn(|_| {
                self.ledger_db
                    .persisted_auxiliary_info_db()
                    .commit_auxiliary_info(chunk.first_version, chunk.persisted_auxiliary_infos)
                    .unwrap()
            });
            s.spawn(|_| {
                self.commit_state_kv_and_ledger_metadata(chunk, skip_index_and_usage)
                    .unwrap()
            });
            s.spawn(|_| {
                self.commit_transaction_infos(chunk.first_version, chunk.transaction_infos)
                    .unwrap()
            });
            s.spawn(|_| {
                new_root_hash = self
                    .commit_transaction_accumulator(chunk.first_version, chunk.transaction_infos)
                    .unwrap()
            });
        });

        Ok(new_root_hash)
    }
```

**File:** storage/aptosdb/src/state_store/buffered_state.rs (L96-113)
```rust
    /// This method checks whether a commit is needed based on the target_items value and the number of items in state_until_checkpoint.
    /// If a commit is needed, it sends a CommitMessage::Data message to the StateSnapshotCommitter thread to commit the data.
    /// If sync_commit is true, it also sends a CommitMessage::Sync message to ensure that the commit is completed before returning.
    fn maybe_commit(&mut self, checkpoint: Option<StateWithSummary>, sync_commit: bool) {
        if let Some(checkpoint) = checkpoint {
            if !checkpoint.is_the_same(&self.last_snapshot)
                && (sync_commit
                    || self.estimated_items >= self.target_items
                    || self.buffered_versions() >= TARGET_SNAPSHOT_INTERVAL_IN_VERSION)
            {
                self.enqueue_commit(checkpoint);
            }
        }

        if sync_commit {
            self.drain_commits();
        }
    }
```

**File:** storage/aptosdb/src/state_store/buffered_state.rs (L123-134)
```rust
    fn enqueue_commit(&mut self, checkpoint: StateWithSummary) {
        let _timer = OTHER_TIMERS_SECONDS.timer_with(&["buffered_state___enqueue_commit"]);

        self.state_commit_sender
            .send(CommitMessage::Data(checkpoint.clone()))
            .unwrap();
        // n.b. if the latest state is not a (the latest) checkpoint, the items between them are
        // not counted towards the next commit. If this becomes a concern we can count the items
        // instead of putting it 0 here.
        self.estimated_items = 0;
        self.last_snapshot = checkpoint;
    }
```

**File:** storage/aptosdb/src/state_store/buffered_state.rs (L156-179)
```rust
    pub fn update(
        &mut self,
        new_state: LedgerStateWithSummary,
        estimated_new_items: usize,
        sync_commit: bool,
    ) -> Result<()> {
        let _timer = OTHER_TIMERS_SECONDS.timer_with(&["buffered_state___update"]);

        let old_state = self.current_state_locked().clone();
        assert!(new_state.is_descendant_of(&old_state));

        self.estimated_items += estimated_new_items;
        let version = new_state.last_checkpoint().version();

        let last_checkpoint = new_state.last_checkpoint().clone();
        // Commit state only if there is a new checkpoint, eases testing and make estimated
        // buffer size a tad more realistic.
        let checkpoint_to_commit_opt =
            (old_state.next_version() < last_checkpoint.next_version()).then_some(last_checkpoint);
        *self.current_state_locked() = new_state;
        self.maybe_commit(checkpoint_to_commit_opt, sync_commit);
        Self::report_last_checkpoint_version(version);
        Ok(())
    }
```

**File:** storage/aptosdb/src/state_merkle_db.rs (L278-288)
```rust
    pub fn get_with_proof_ext(
        &self,
        key: &HashValue,
        version: Version,
        root_depth: usize,
    ) -> Result<(
        Option<(HashValue, (StateKey, Version))>,
        SparseMerkleProofExt,
    )> {
        JellyfishMerkleTree::new(self).get_with_proof_ext(key, version, root_depth)
    }
```
