# Audit Report

## Title
EventSchema Lacks Tamper Detection on Read Path - Events Can Be Modified in Database Without Detection

## Summary
The EventSchema storage system stores blockchain events without cryptographic integrity verification on the read path. While TransactionInfo contains an `event_root_hash` field designed to verify event integrity, this hash is never validated when events are retrieved through normal API queries or database read operations. An attacker with direct database access can modify event data without detection, compromising data integrity for all downstream clients.

## Finding Description

The Aptos blockchain stores events in two separate locations:

1. **EventSchema** - Stores raw event data keyed by `(version, index)` [1](#0-0) 

2. **TransactionInfo** - Contains `event_root_hash`, a Merkle accumulator root of all event hashes for integrity verification [2](#0-1) 

**The Critical Gap:**

When events are read from the database, the system performs NO validation against the `event_root_hash`. The entire read path bypasses integrity checks:

- **EventDb.get_events_by_version()** directly reads from EventSchema without validation [3](#0-2) 

- **API endpoints** (`/accounts/{address}/events/...`) retrieve events without verifying `event_root_hash` [4](#0-3) 

- **EventSchema decode** simply deserializes BCS bytes with no integrity check [5](#0-4) 

**Where Validation EXISTS But Isn't Used:**

The `ensure_match_transaction_info()` method correctly verifies events against `event_root_hash` by computing event hashes and comparing with TransactionInfo [6](#0-5) 

However, this validation only occurs during:
- Re-execution verification in chunk executor [7](#0-6) 
- Backup/restore operations
- Explicit proof verification flows

**Attack Scenario:**

1. Attacker gains direct database access (compromised node, backup access, insider)
2. Attacker modifies `event_data` bytes in EventSchema for target events (e.g., transfer events, governance votes)
3. TransactionInfo with `event_root_hash` remains unchanged in the database
4. Normal API queries return tampered events to clients
5. Wallets, explorers, analytics tools consume and display false data
6. Tampering remains undetected indefinitely unless:
   - Manual re-execution verification is triggered
   - The specific transaction is queried with proof verification

**Invariant Violation:**

This breaks the documented invariant: "**State Consistency**: State transitions must be atomic and verifiable via Merkle proofs." While the Merkle proof mechanism exists (`event_root_hash`), it is not enforced on the read path, rendering it ineffective for detecting tampering.

## Impact Explanation

**Severity: HIGH** - Meets "Significant protocol violations" criteria.

**Concrete Impacts:**

1. **Data Integrity Compromise**: Events are the primary mechanism for observing blockchain activity (transfers, staking rewards, governance votes, contract emissions). Falsified events mislead all ecosystem participants.

2. **Widespread Client Impact**: All clients consuming event data are affected:
   - Wallets showing false transaction history
   - Block explorers displaying incorrect activity
   - Analytics platforms with corrupted data
   - DApps making decisions based on false events

3. **Undetectable Until Manual Intervention**: Unlike consensus violations that self-correct, this tampering persists until someone manually triggers re-execution verification or restoration from a clean backup.

4. **Trust Model Violation**: The system advertises cryptographic integrity through `event_root_hash` but fails to enforce it, violating user expectations of blockchain immutability.

5. **Compliance/Legal Risk**: For financial applications, falsified event logs could violate regulatory requirements for audit trails.

While this is not a direct consensus break or fund theft, it represents a **significant protocol violation** where the advertised security properties (verifiable event integrity) are not enforced in practice.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH** in realistic threat models.

**Attack Prerequisites:**
- Direct database access (file system or database admin privileges)
- Knowledge of RocksDB/SchemaDB structure
- Ability to identify target events by version and index

**Realistic Attack Vectors:**

1. **Compromised Node**: Attacker gains root access to validator or full node
2. **Backup Infrastructure Breach**: Attacker accesses database backups
3. **Insider Threat**: Malicious database administrator
4. **Cloud Storage Misconfiguration**: Exposed database snapshots
5. **Supply Chain Attack**: Compromised node operator infrastructure

**Ease of Exploitation:**
- Once database access is obtained, modification is trivial (direct byte manipulation)
- No cryptographic operations required
- No need to maintain consistency across distributed nodes (single node attack)
- Attack leaves no network-visible traces

**Detection Difficulty:**
- No automated detection mechanisms in production
- Requires manual re-execution verification
- May go unnoticed for extended periods

Given that database security is a common attack surface and the exploitation is trivial once access is gained, this vulnerability has meaningful likelihood in real-world deployments.

## Recommendation

**Implement mandatory event integrity verification on the read path:**

```rust
// In EventDb::get_events_by_version()
pub(crate) fn get_events_by_version(
    &self, 
    version: Version,
    verify_integrity: bool,  // Add flag for backward compatibility
    txn_info: Option<&TransactionInfo>  // Optional for verification
) -> Result<Vec<ContractEvent>> {
    let mut events = vec![];
    
    let mut iter = self.db.iter::<EventSchema>()?;
    iter.seek(&version)?;
    while let Some(((ver, _index), event)) = iter.next().transpose()? {
        if ver != version {
            break;
        }
        events.push(event);
    }
    
    // NEW: Verify event integrity if requested
    if verify_integrity {
        if let Some(info) = txn_info {
            let event_hashes: Vec<HashValue> = events
                .iter()
                .map(CryptoHash::hash)
                .collect();
            let computed_root = InMemoryEventAccumulator::from_leaves(&event_hashes).root_hash;
            
            ensure!(
                computed_root == info.event_root_hash(),
                "Event integrity check failed: computed {}, expected {}",
                computed_root,
                info.event_root_hash()
            );
        }
    }
    
    Ok(events)
}
```

**Additional Mitigations:**

1. **Enable verification by default in API endpoints** with opt-out for performance-critical paths
2. **Add periodic background verification job** that samples random transactions and verifies event integrity
3. **Include event_root_hash in API responses** so clients can perform their own verification
4. **Log verification failures** to monitoring systems for immediate alerting
5. **Add database-level integrity checks** (checksums, signed backups) as defense-in-depth

## Proof of Concept

```rust
// Test demonstrating undetected event tampering
#[cfg(test)]
mod event_tampering_test {
    use super::*;
    use aptos_types::{
        contract_event::{ContractEvent, ContractEventV2},
        transaction::Version,
    };
    use move_core_types::{
        language_storage::TypeTag,
    };
    
    #[test]
    fn test_event_tampering_undetected() {
        // Setup: Create test database and store legitimate events
        let tmpdir = tempfile::tempdir().unwrap();
        let db = AptosDB::new_for_test(&tmpdir);
        
        let version: Version = 100;
        let original_event = ContractEvent::new_v2(
            TypeTag::Bool,  // Simplified for test
            b"original_data".to_vec(),
        ).unwrap();
        
        // Store original event
        let mut batch = SchemaBatch::new();
        db.ledger_db
            .event_db()
            .put_events(version, &[original_event.clone()], false, &mut batch)
            .unwrap();
        db.ledger_db.event_db().write_schemas(batch).unwrap();
        
        // ATTACK: Directly modify event_data in database
        let tampered_event = ContractEvent::new_v2(
            TypeTag::Bool,
            b"TAMPERED_DATA_ATTACK".to_vec(),  // Malicious modification
        ).unwrap();
        
        let mut tamper_batch = SchemaBatch::new();
        tamper_batch.put::<EventSchema>(
            &(version, 0),
            &tampered_event
        ).unwrap();
        db.ledger_db.event_db().write_schemas(tamper_batch).unwrap();
        
        // VERIFY ATTACK SUCCESS: Read returns tampered data without detection
        let read_events = db.ledger_db
            .event_db()
            .get_events_by_version(version)
            .unwrap();
        
        assert_eq!(read_events.len(), 1);
        let read_event = &read_events[0];
        
        // CRITICAL: Tampered data is returned without any error or warning
        assert_eq!(
            read_event.event_data(),
            b"TAMPERED_DATA_ATTACK",
            "Tampered data returned successfully - no integrity check performed!"
        );
        
        assert_ne!(
            read_event.event_data(),
            original_event.event_data(),
            "Original data has been replaced"
        );
        
        // DEMONSTRATION: If integrity check WAS performed (not currently done):
        // let txn_info = db.ledger_db.transaction_info_db()
        //     .get_transaction_info(version).unwrap();
        // let event_hashes: Vec<_> = read_events.iter()
        //     .map(CryptoHash::hash).collect();
        // let computed_root = InMemoryEventAccumulator::from_leaves(&event_hashes).root_hash;
        // assert_ne!(computed_root, txn_info.event_root_hash(), 
        //     "Integrity check WOULD have detected tampering");
        
        println!("âœ— Event tampering attack successful - no detection occurred");
        println!("  Original: {:?}", std::str::from_utf8(original_event.event_data()));
        println!("  Returned: {:?}", std::str::from_utf8(read_event.event_data()));
    }
}
```

**Notes:**
- This vulnerability requires direct database access, which is in scope per the security question's explicit premise: "tampered with **directly in the database**"
- The protection mechanism exists (`event_root_hash` in TransactionInfo) but is not enforced on normal read paths
- Impact is significant: all clients consuming event data receive tampered information without warning
- Fix is straightforward: add verification call on read path using existing `ensure_match_transaction_info()` logic

### Citations

**File:** storage/aptosdb/src/schema/event/mod.rs (L23-27)
```rust
define_schema!(EventSchema, Key, ContractEvent, EVENT_CF_NAME);

type Index = u64;
type Key = (Version, Index);

```

**File:** storage/aptosdb/src/schema/event/mod.rs (L53-56)
```rust

    fn decode_value(data: &[u8]) -> Result<Self> {
        bcs::from_bytes(data).map_err(Into::into)
    }
```

**File:** types/src/transaction/mod.rs (L1910-1925)
```rust
        let event_hashes = self
            .events()
            .iter()
            .map(CryptoHash::hash)
            .collect::<Vec<_>>();
        let event_root_hash = InMemoryEventAccumulator::from_leaves(&event_hashes).root_hash;
        ensure!(
            event_root_hash == txn_info.event_root_hash(),
            "{}: version:{}, event_root_hash:{:?}, expected:{:?}, events: {:?}, expected(if known): {:?}",
            ERR_MSG,
            version,
            event_root_hash,
            txn_info.event_root_hash(),
            self.events(),
            expected_events,
        );
```

**File:** types/src/transaction/mod.rs (L2037-2038)
```rust
    /// The root hash of Merkle Accumulator storing all events emitted during this transaction.
    event_root_hash: HashValue,
```

**File:** storage/aptosdb/src/ledger_db/event_db.rs (L67-81)
```rust
    pub(crate) fn get_events_by_version(&self, version: Version) -> Result<Vec<ContractEvent>> {
        let mut events = vec![];

        let mut iter = self.db.iter::<EventSchema>()?;
        // Grab the first event and then iterate until we get all events for this version.
        iter.seek(&version)?;
        while let Some(((ver, _index), event)) = iter.next().transpose()? {
            if ver != version {
                break;
            }
            events.push(event);
        }

        Ok(events)
    }
```

**File:** api/src/context.rs (L1084-1111)
```rust
    pub fn get_events(
        &self,
        event_key: &EventKey,
        start: Option<u64>,
        limit: u16,
        ledger_version: u64,
    ) -> Result<Vec<EventWithVersion>> {
        let (start, order) = if let Some(start) = start {
            (start, Order::Ascending)
        } else {
            (u64::MAX, Order::Descending)
        };
        let mut res = if !db_sharding_enabled(&self.node_config) {
            self.db
                .get_events(event_key, start, order, limit as u64, ledger_version)?
        } else {
            self.indexer_reader
                .as_ref()
                .ok_or_else(|| anyhow!("Internal indexer reader doesn't exist"))?
                .get_events(event_key, start, order, limit as u64, ledger_version)?
        };
        if order == Order::Descending {
            res.reverse();
            Ok(res)
        } else {
            Ok(res)
        }
    }
```

**File:** execution/executor/src/chunk_executor/mod.rs (L636-641)
```rust
            if let Err(err) = txn_out.ensure_match_transaction_info(
                version,
                txn_info,
                Some(write_set),
                Some(events),
            ) {
```
