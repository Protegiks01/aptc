# Audit Report

## Title
Validator Node Panic Due to Partial State in ledger_update() Retry Scenario

## Summary
The `ledger_update()` function in BlockExecutor sets `state_checkpoint_output` and `ledger_update_output` sequentially within a closure. If `DoLedgerUpdate::run()` fails after `DoStateCheckpoint::run()` succeeds, the block remains in memory with partial state. A subsequent retry attempt triggers a panic when trying to set the already-set `state_checkpoint_output`, causing validator node crash.

## Finding Description
In the executor's block processing pipeline, `PartialStateComputeResult` contains two `OnceCell` fields that must both be set for a complete result: [1](#0-0) 

The `get_complete_result()` function returns `Option<StateComputeResult>`, returning `None` when `ledger_update_output` is not set: [2](#0-1) 

The critical issue occurs in `ledger_update()` where outputs are set sequentially: [3](#0-2) 

If any error occurs after line 320 (after `set_state_checkpoint_output()` succeeds) but before line 328 (before `set_ledger_update_output()` completes), the block is left with:
- `state_checkpoint_output`: SET
- `ledger_update_output`: NOT SET

The retry check at line 291 uses `get_complete_result()` which returns `None` in this partial state (since `ledger_update_output` is not set), so it doesn't return early: [4](#0-3) 

When the retry reaches line 315-320 again, `set_state_checkpoint_output()` is called on an already-set `OnceCell`, triggering this panic: [5](#0-4) 

## Impact Explanation
**Medium Severity**: This causes validator node crashes, resulting in temporary liveness loss for affected validators. While this doesn't compromise consensus safety (2/3+ honest validators can continue), it reduces network resilience. The impact aligns with Medium severity per bug bounty criteria: "State inconsistencies requiring intervention" and node availability issues.

The code includes a TODO comment acknowledging retry scenarios may exist: [6](#0-5) 

## Likelihood Explanation
**Low-Medium likelihood**: The vulnerability requires specific conditions:
1. `DoStateCheckpoint::run()` must succeed
2. `DoLedgerUpdate::run()` or subsequent operations must fail
3. Consensus retry logic must re-invoke `ledger_update()` on the same block

While `DoLedgerUpdate::run()` is mostly deterministic, potential failure points include:
- The `.expect("Already sorted.")` panic if transaction status invariant is violated
- Resource exhaustion (thread pool, memory)
- Future code modifications introducing error paths

The fail-point infrastructure indicates error injection is anticipated: [7](#0-6) 

## Recommendation
Adopt the safe pattern used in `ApplyExecutionOutput::run()`, which computes both outputs before setting either: [8](#0-7) 

**Fixed code pattern for `ledger_update()`:**
```rust
// Compute BOTH outputs first (store in local variables)
let state_checkpoint_output = DoStateCheckpoint::run(
    &output.execution_output,
    parent_block.output.ensure_result_state_summary()?,
    &ProvableStateSummary::new_persisted(self.db.reader.as_ref())?,
    None,
)?;

let ledger_update_output = DoLedgerUpdate::run(
    &output.execution_output,
    &state_checkpoint_output,
    parent_out.ensure_ledger_update_output()?.transaction_accumulator.clone(),
)?;

// THEN set both atomically
output.set_state_checkpoint_output(state_checkpoint_output);
output.set_ledger_update_output(ledger_update_output);
```

Additionally, improve the retry check to detect and handle partial state explicitly.

## Proof of Concept
```rust
// Reproduction scenario (requires fail-point or manual error injection)
#[test]
fn test_ledger_update_partial_state_panic() {
    // Setup: Create executor with block tree containing a block
    let executor = create_test_executor();
    let block_id = create_test_block();
    
    // Step 1: First ledger_update call
    // Inject failure after DoStateCheckpoint but before DoLedgerUpdate
    fail::cfg("executor::do_ledger_update", "return").unwrap();
    
    let result1 = executor.ledger_update(block_id, parent_id);
    assert!(result1.is_err()); // First call fails
    
    // At this point: state_checkpoint_output IS set, ledger_update_output IS NOT
    let block = executor.block_tree.get_block(block_id).unwrap();
    assert!(block.output.state_checkpoint_output.get().is_some());
    assert!(block.output.ledger_update_output.get().is_none());
    assert!(block.output.get_complete_result().is_none());
    
    // Step 2: Retry ledger_update (simulating consensus retry)
    fail::cfg("executor::do_ledger_update", "off").unwrap();
    
    // This should panic with "StateCheckpointOutput already set"
    let result2 = executor.ledger_update(block_id, parent_id);
    // PANIC occurs at line 78 of partial_state_compute_result.rs
}
```

## Notes
The vulnerability is inherent in the sequential output-setting pattern. While current consensus flow may prevent retries, the code's defensive check at line 291 and the TODO comment indicate retry scenarios were considered. The unsafe pattern creates technical debt and potential for future exploitation if retry logic is introduced or edge cases emerge. The fix aligns with the safe pattern already used in `ApplyExecutionOutput::run()`.

### Citations

**File:** execution/executor/src/types/partial_state_compute_result.rs (L18-22)
```rust
pub struct PartialStateComputeResult {
    pub execution_output: ExecutionOutput,
    pub state_checkpoint_output: OnceCell<StateCheckpointOutput>,
    pub ledger_update_output: OnceCell<LedgerUpdateOutput>,
}
```

**File:** execution/executor/src/types/partial_state_compute_result.rs (L76-80)
```rust
    pub fn set_state_checkpoint_output(&self, state_checkpoint_output: StateCheckpointOutput) {
        self.state_checkpoint_output
            .set(state_checkpoint_output)
            .expect("StateCheckpointOutput already set");
    }
```

**File:** execution/executor/src/types/partial_state_compute_result.rs (L94-105)
```rust
    pub fn get_complete_result(&self) -> Option<StateComputeResult> {
        self.ledger_update_output.get().map(|ledger_update_output| {
            StateComputeResult::new(
                self.execution_output.clone(),
                // ledger_update_output is set in a later stage, so it's safe to `expect` here.
                self.ensure_state_checkpoint_output()
                    .expect("StateCheckpointOutput missing.")
                    .clone(),
                ledger_update_output.clone(),
            )
        })
    }
```

**File:** execution/executor/src/block_executor/mod.rs (L290-294)
```rust
        // TODO(aldenhu): remove, assuming no retries.
        if let Some(complete_result) = block.output.get_complete_result() {
            info!(block_id = block_id, "ledger_update already done.");
            return Ok(complete_result);
        }
```

**File:** execution/executor/src/block_executor/mod.rs (L310-330)
```rust
            THREAD_MANAGER.get_non_exe_cpu_pool().install(|| {
                // TODO(aldenhu): remove? no known strategy to recover from this failure
                fail_point!("executor::block_state_checkpoint", |_| {
                    Err(anyhow::anyhow!("Injected error in block state checkpoint."))
                });
                output.set_state_checkpoint_output(DoStateCheckpoint::run(
                    &output.execution_output,
                    parent_block.output.ensure_result_state_summary()?,
                    &ProvableStateSummary::new_persisted(self.db.reader.as_ref())?,
                    None,
                )?);
                output.set_ledger_update_output(DoLedgerUpdate::run(
                    &output.execution_output,
                    output.ensure_state_checkpoint_output()?,
                    parent_out
                        .ensure_ledger_update_output()?
                        .transaction_accumulator
                        .clone(),
                )?);
                Result::<_>::Ok(())
            })?;
```

**File:** execution/executor/src/workflow/mod.rs (L22-43)
```rust
    pub fn run(
        execution_output: ExecutionOutput,
        base_view: LedgerSummary,
        reader: &(dyn DbReader + Sync),
    ) -> Result<PartialStateComputeResult> {
        let state_checkpoint_output = DoStateCheckpoint::run(
            &execution_output,
            &base_view.state_summary,
            &ProvableStateSummary::new_persisted(reader)?,
            None,
        )?;
        let ledger_update_output = DoLedgerUpdate::run(
            &execution_output,
            &state_checkpoint_output,
            base_view.transaction_accumulator,
        )?;
        let output = PartialStateComputeResult::new(execution_output);
        output.set_state_checkpoint_output(state_checkpoint_output);
        output.set_ledger_update_output(ledger_update_output);

        Ok(output)
    }
```
