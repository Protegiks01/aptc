# Audit Report

## Title
Non-Deterministic Layout Validation Causes Consensus Divergence in Block Execution

## Summary
The `fetch_exchanged_data()` function returns `MoveTypeLayout` objects without validating their compatibility with VM expectations. Layout validation is performed via `randomly_check_layout_matches()` which uses non-deterministic randomness (`rand::thread_rng()`), causing different validators to make different execution decisions. This breaks consensus safety by allowing validators to diverge on transaction outcomes when incompatible layouts are encountered.

## Finding Description

The vulnerability spans two critical components:

**1. Lack of Layout Validation in `fetch_exchanged_data()`:** [1](#0-0) 

This function returns whatever layout was previously stored in the `Exchanged` variant without any validation that it matches the expected type layout from the VM. The layout could be stale or incorrect if:
- A module was upgraded, changing struct field layouts
- The resource was initially stored with one layout but is now being read with different type expectations
- The layout was incorrectly associated during value patching operations

**2. Non-Deterministic Layout Validation:** [2](#0-1) 

The `randomly_check_layout_matches()` function uses `rand::thread_rng()` to decide whether to validate layouts. This is a **non-deterministic** random number generator that produces different values across validator nodes. When incompatible layouts exist:
- ~1% of validators will check and detect the mismatch, aborting transaction execution
- ~99% of validators will skip validation and continue with potentially incompatible layouts
- Different validators produce different transaction outputs and state roots

**Execution Flow:**

1. VM generates a layout from a type using `type_to_type_layout_with_delayed_fields`: [3](#0-2) 

2. Layout is passed to resource resolver which stores it in the MVHashMap/UnsyncMap as `Exchanged`: [4](#0-3) 

3. When materializing resource writes for delayed field exchange, `fetch_exchanged_data()` retrieves the stored layout: [5](#0-4) 

4. The non-deterministic check occurs: [6](#0-5) 

**Attack Scenario:**

1. Attacker deploys module `M` with struct `S { field1: u64 }`
2. Attacker creates resource of type `S` at some address
3. Resource is cached in MVHashMap with layout for the original `S`
4. Attacker upgrades module `M` to change `S` to `S { field1: u64, field2: u128 }`
5. Transaction reads the old resource with new type expectations
6. `fetch_exchanged_data()` returns the old layout
7. Validator A (random check triggered): Detects mismatch, aborts transaction
8. Validator B (random check skipped): Continues with incompatible layout
9. **Consensus divergence**: Different state roots for the same block

## Impact Explanation

This is **Critical Severity** per Aptos Bug Bounty criteria as it constitutes a **Consensus/Safety violation**:

- **Breaks Fundamental Invariant**: Violates "All validators must produce identical state roots for identical blocks"
- **Consensus Split Risk**: Network can fork into multiple chains as validators disagree on transaction outcomes
- **Non-Recoverable**: Once validators diverge, the network requires manual intervention or hard fork to recover
- **Affects All Validators**: Any validator executing blocks with incompatible layouts is at risk
- **Exploitable by Unprivileged Users**: Any user who can deploy and upgrade modules can trigger this

The non-deterministic nature of `rand::thread_rng()` guarantees that with enough transactions involving layout checks, validators will eventually diverge. This is not a theoretical risk—module upgrades that change struct layouts are a normal operation in Move development.

## Likelihood Explanation

**High Likelihood:**

- Module upgrades are common operations in blockchain development
- Struct layout changes (adding/removing/reordering fields) occur during upgrades
- The 1% probability means that in a network of 100+ validators, divergence is statistically certain
- No special privileges required—any user can deploy/upgrade modules
- The vulnerability is triggered automatically during normal block execution
- Delayed field optimization (enabled by default) increases exposure by requiring layout checks

The combination of high probability of occurrence and ease of exploitation makes this a high-likelihood, high-impact vulnerability.

## Recommendation

**Immediate Fix: Replace Non-Deterministic Validation with Deterministic Checks**

1. **Remove randomization from layout validation:**

```rust
pub fn check_layout_matches(
    layout_1: Option<&MoveTypeLayout>,
    layout_2: Option<&MoveTypeLayout>,
) -> Result<(), PanicError> {
    if layout_1.is_some() != layout_2.is_some() {
        return Err(code_invariant_error(format!(
            "Layouts don't match when they are expected to: {:?} and {:?}",
            layout_1, layout_2
        )));
    }
    if layout_1.is_some() && layout_1 != layout_2 {
        return Err(code_invariant_error(format!(
            "Layouts don't match when they are expected to: {:?} and {:?}",
            layout_1, layout_2
        )));
    }
    Ok(())
}
```

2. **Add deterministic layout validation in `fetch_exchanged_data()`:**

```rust
pub fn fetch_exchanged_data(
    &self,
    key: &K,
    expected_layout: Option<&MoveTypeLayout>,
) -> Result<(TriompheArc<V>, TriompheArc<MoveTypeLayout>), PanicError> {
    let data = self.fetch_data(key);
    if let Some(ValueWithLayout::Exchanged(value, Some(layout))) = data {
        // Validate layout matches expectations
        if let Some(expected) = expected_layout {
            if layout.as_ref() != expected {
                return Err(code_invariant_error(format!(
                    "Layout mismatch: stored {:?} vs expected {:?}",
                    layout, expected
                )));
            }
        }
        Ok((value, layout))
    } else {
        Err(code_invariant_error(format!(
            "Read value needing exchange {:?} does not exist or not in Exchanged format",
            data
        )))
    }
}
```

3. **For performance optimization (if needed), use deterministic caching:**
   - Compute layout hash during storage
   - Compare hashes instead of full layout equality
   - Ensure hash computation is deterministic across all nodes

## Proof of Concept

```rust
// Simplified PoC demonstrating the non-determinism

use rand::{thread_rng, Rng};

fn randomly_check_layout_matches(
    layout_1: Option<u64>, // Simplified as u64 for demonstration
    layout_2: Option<u64>,
) -> Result<(), String> {
    if layout_1.is_some() != layout_2.is_some() {
        return Err("Layout presence mismatch".to_string());
    }
    if layout_1.is_some() {
        let mut rng = thread_rng(); // NON-DETERMINISTIC
        let random_number: u32 = rng.gen_range(0, 100);
        if random_number == 1 && layout_1 != layout_2 {
            return Err(format!(
                "Layouts don't match: {:?} vs {:?}",
                layout_1, layout_2
            ));
        }
    }
    Ok(())
}

fn simulate_validator_execution(old_layout: u64, new_layout: u64) -> bool {
    // Returns true if validator successfully executes, false if aborts
    randomly_check_layout_matches(Some(old_layout), Some(new_layout)).is_ok()
}

fn main() {
    // Simulate incompatible layouts after module upgrade
    let old_layout = 1; // Original struct layout
    let new_layout = 2; // Upgraded struct layout (incompatible)
    
    let mut successful_validators = 0;
    let mut failed_validators = 0;
    
    // Simulate 100 validators
    for validator_id in 0..100 {
        if simulate_validator_execution(old_layout, new_layout) {
            successful_validators += 1;
        } else {
            failed_validators += 1;
        }
    }
    
    println!("Validators that succeeded: {}", successful_validators);
    println!("Validators that failed: {}", failed_validators);
    
    if successful_validators > 0 && failed_validators > 0 {
        println!("\n❌ CONSENSUS DIVERGENCE DETECTED!");
        println!("Network has split into multiple chains.");
    }
}

// Expected output (approximately):
// Validators that succeeded: 99
// Validators that failed: 1
// ❌ CONSENSUS DIVERGENCE DETECTED!
```

**To demonstrate in Aptos Core:**

1. Deploy a module with a struct containing delayed fields
2. Create resources of that type
3. Upgrade the module to change the struct layout
4. Execute transactions that read these resources across multiple validator nodes
5. Observe different execution results due to random layout checking
6. Verify state root divergence across validators

## Notes

The vulnerability exists in both parallel execution (`UnsyncMap` used in sequential execution within block executor) and the broader VM session handling. The non-deterministic behavior fundamentally violates blockchain consensus requirements where all nodes must execute identically. The use of `rand::thread_rng()` is appropriate for optimization hints in single-node scenarios but catastrophic in distributed consensus systems.

### Citations

**File:** aptos-move/mvhashmap/src/unsync_map.rs (L285-298)
```rust
    pub fn fetch_exchanged_data(
        &self,
        key: &K,
    ) -> Result<(TriompheArc<V>, TriompheArc<MoveTypeLayout>), PanicError> {
        let data = self.fetch_data(key);
        if let Some(ValueWithLayout::Exchanged(value, Some(layout))) = data {
            Ok((value, layout))
        } else {
            Err(code_invariant_error(format!(
                "Read value needing exchange {:?} does not exist or not in Exchanged format",
                data
            )))
        }
    }
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L49-74)
```rust
pub fn randomly_check_layout_matches(
    layout_1: Option<&MoveTypeLayout>,
    layout_2: Option<&MoveTypeLayout>,
) -> Result<(), PanicError> {
    if layout_1.is_some() != layout_2.is_some() {
        return Err(code_invariant_error(format!(
            "Layouts don't match when they are expected to: {:?} and {:?}",
            layout_1, layout_2
        )));
    }
    if layout_1.is_some() {
        // Checking if 2 layouts are equal is a recursive operation and is expensive.
        // We generally call this `randomly_check_layout_matches` function when we know
        // that the layouts are supposed to match. As an optimization, we only randomly
        // check if the layouts are matching.
        let mut rng = rand::thread_rng();
        let random_number: u32 = rng.gen_range(0, 100);
        if random_number == 1 && layout_1 != layout_2 {
            return Err(code_invariant_error(format!(
                "Layouts don't match when they are expected to: {:?} and {:?}",
                layout_1, layout_2
            )));
        }
    }
    Ok(())
}
```

**File:** third_party/move/move-vm/runtime/src/data_cache.rs (L273-278)
```rust
        let layout_with_delayed_fields = layout_converter.type_to_type_layout_with_delayed_fields(
            gas_meter,
            traversal_context,
            ty,
            false,
        )?;
```

**File:** aptos-move/block-executor/src/view.rs (L643-654)
```rust
                    if let UnknownOrLayout::Known(layout) = layout {
                        if let ValueWithLayout::RawFromStorage(v) = value {
                            assert_eq!(version, Err(StorageVersion), "Fetched resource has unknown layout but the version is not Err(StorageVersion)");
                            match patch_base_value(v.as_ref(), layout) {
                                Ok(patched_value) => {
                                    self.versioned_map.data().set_base_value(
                                        key.clone(),
                                        ValueWithLayout::Exchanged(
                                            TriompheArc::new(patched_value),
                                            layout.cloned().map(TriompheArc::new),
                                        ),
                                    );
```

**File:** aptos-move/block-executor/src/executor_utilities.rs (L59-72)
```rust
	$outputs
        .reads_needing_delayed_field_exchange($($txn_idx),*)
        .into_iter()
	    .map(|(key, metadata, layout)| -> Result<_, PanicError> {
	        let (value, existing_layout) = $data_source.fetch_exchanged_data(&key, $($txn_idx),*)?;
            randomly_check_layout_matches(Some(&existing_layout), Some(layout.as_ref()))?;
            let new_value = TriompheArc::new(TransactionWrite::from_state_value(Some(
                StateValue::new_with_metadata(
                    value.bytes().cloned().unwrap_or_else(Bytes::new),
                    metadata,
                ))
            ));
            Ok((key, new_value, layout))
        })
```
