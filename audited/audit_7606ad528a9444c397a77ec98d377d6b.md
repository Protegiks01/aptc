# Audit Report

## Title
Network-Wide Liveness Failure Due to Unvalidated Gas Schedule Updates and Silent API Fallback to Incompatible Versions

## Summary
The gas schedule update mechanism lacks validation, allowing malformed `GasScheduleV2` configurations to be set on-chain via governance proposals. When a malformed gas schedule is deployed, the VM fails to parse it and enters `VM_STARTUP_FAILURE` state, halting all transaction execution network-wide. Simultaneously, the API layer silently falls back to legacy `GasSchedule` V1 with `feature_version=0`, creating a dangerous inconsistency where the API provides gas estimates based on incompatible parameters while the network is completely non-functional.

## Finding Description

The vulnerability exists across three interconnected components:

**1. Missing Validation in Move Framework**

The gas schedule update functions in the Move framework contain unimplemented validation checks: [1](#0-0) [2](#0-1) [3](#0-2) 

These TODO comments indicate that gas schedule consistency checks are not implemented, allowing governance proposals to set incomplete or malformed `GasScheduleV2` configurations.

**2. Critical Failure in VM Gas Parameter Parsing**

The gas parameter parsing macro requires all version-specific parameters to exist: [4](#0-3) 

If a required parameter is missing for the specified `feature_version`, parsing fails with an error. Gas parameters have version-dependent naming and requirements: [5](#0-4) [6](#0-5) 

**3. Silent Fallback in API Layer**

The API layer implements a problematic fallback mechanism: [7](#0-6) 

The `.ok()` call on line 1513 silently converts parsing errors to `None`, triggering a fallback to legacy `GasSchedule` V1 with `feature_version=0`, even when `GasScheduleV2` exists with a higher version number but is malformed.

**4. Contrasting VM Behavior**

The VM environment layer does NOT implement this silent fallback: [8](#0-7) 

When `GasScheduleV2` parsing fails in the VM, the error propagates directly, resulting in `VM_STARTUP_FAILURE` for all transactions.

**Attack Scenario:**

1. A governance proposal sets `GasScheduleV2` with `feature_version=14` but omits a critical parameter required for version 14 (e.g., `"txn.storage_fee_per_state_slot"`)
2. The Move code accepts it due to missing validation
3. All validator nodes attempt to parse the gas schedule:
   - **VM Layer**: Parsing fails → `VM_STARTUP_FAILURE` → All transactions rejected
   - **API Layer**: Parsing fails → Silent fallback to `GasSchedule` V1 with `feature_version=0` → Wrong gas estimates
4. Network becomes completely non-functional while API falsely reports operational status with incorrect parameters

## Impact Explanation

**Critical Severity - Total Loss of Network Liveness**

This vulnerability meets the **Critical** severity criteria from the Aptos Bug Bounty program:

- **"Total loss of liveness/network availability"**: All transactions fail with `VM_STARTUP_FAILURE`, rendering the network completely non-functional
- **"Non-recoverable network partition (requires hardfork)"**: Since transactions cannot execute, governance cannot pass a corrective proposal through normal mechanisms, requiring a hard fork to restore network operation

The test suite confirms this behavior: [9](#0-8) 

**Invariants Broken:**

1. **Move VM Safety**: Gas limit enforcement fails due to inability to load gas parameters
2. **Resource Limits**: Cannot enforce gas, storage, or computational limits without valid gas parameters
3. **Deterministic Execution**: Network cannot execute any transactions deterministically when VM fails to start

## Likelihood Explanation

**Medium-to-High Likelihood**

While this requires a governance proposal to trigger:

1. **Accidental Trigger**: Governance proposal generation tools could have bugs that produce incomplete gas schedules. The lack of validation makes this easy to accidentally trigger.

2. **No Safety Net**: The Move framework provides no validation, making it trivial for malformed data to reach production

3. **Version Complexity**: The complex version-dependent parameter system (shown in transaction.rs with parameters existing only in specific version ranges) increases the chance of errors

4. **Historical Precedent**: The presence of multiple TODO comments and a dedicated test case for missing parameters suggests this is a known risk area

## Recommendation

**Immediate Fixes Required:**

1. **Implement Gas Schedule Validation in Move**

Add validation in `gas_schedule.move` to verify completeness:

```move
public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    // ADD: Validate gas schedule completeness
    assert!(validate_gas_schedule_completeness(&new_gas_schedule), 
            error::invalid_argument(EINVALID_GAS_SCHEDULE));
    
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    config_buffer::upsert(new_gas_schedule);
}
```

2. **Remove Silent Fallback in API**

Modify `api/src/context.rs` to fail loudly instead of silently falling back:

```rust
let gas_schedule_params = {
    let may_be_params = GasScheduleV2::fetch_config(&state_view)
        .and_then(|gas_schedule| {
            let feature_version = gas_schedule.feature_version;
            let gas_schedule = gas_schedule.into_btree_map();
            AptosGasParameters::from_on_chain_gas_schedule(&gas_schedule, feature_version).ok()
        });
    
    match may_be_params {
        Some(gas_schedule) => Ok(gas_schedule),
        None => {
            // REMOVE the fallback to GasSchedule V1
            // Return error instead of silently using wrong version
            Err(E::internal_with_code(
                "Failed to parse GasScheduleV2 - gas schedule may be malformed",
                AptosErrorCode::InternalError,
                ledger_info,
            ))
        }
    }?
};
```

3. **Add Pre-Deployment Validation**

Create a governance proposal validation tool that parses the proposed gas schedule before submission to catch errors early.

## Proof of Concept

The existing test demonstrates the vulnerability: [10](#0-9) 

**Extended PoC to demonstrate API divergence:**

```rust
#[test]
fn api_fallback_creates_version_mismatch() {
    let mut h = MoveHarness::new();
    
    // Create malformed GasScheduleV2 with feature_version=14 but missing v14 parameters
    h.modify_gas_schedule_v2(|gas_schedule| {
        gas_schedule.feature_version = 14;
        // Remove a parameter required for v14
        let idx = gas_schedule.entries.iter()
            .position(|(key, _)| key == "txn.storage_fee_per_state_slot")
            .unwrap();
        gas_schedule.entries.remove(idx);
    });
    
    // VM fails to execute transactions
    let acc = h.new_account_at(AccountAddress::from_hex_literal("0xbeef").unwrap());
    let txn_status = h.publish_package(&acc, &common::test_dir_path("simple_package"));
    assert!(matches!(txn_status, TransactionStatus::Discard(StatusCode::VM_STARTUP_FAILURE)));
    
    // But API context can still retrieve gas schedule via fallback (if GasSchedule V1 exists)
    // This creates dangerous inconsistency between API and VM behavior
}
```

This vulnerability represents a critical systemic weakness in the gas schedule update mechanism that can result in complete network failure requiring hard fork recovery.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L47-47)
```text
        // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L67-67)
```text
            // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L75-75)
```text
            // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L38-42)
```rust
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        let name = format!("{}.{}", $prefix, key);
                        params.$name = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?.into();
                    }
                )*
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L88-96)
```rust
        [
            storage_io_per_state_slot_read: InternalGasPerArg,
            { 0..=9 => "load_data.base", 10.. => "storage_io_per_state_slot_read"},
            // At the current mainnet scale, we should assume most levels of the (hexary) JMT nodes
            // in cache, hence target charging 1-2 4k-sized pages for each read. Notice the cost
            // of seeking for the leaf node is covered by the first page of the "value size fee"
            // (storage_io_per_state_byte_read) defined below.
            302_385,
        ],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L184-199)
```rust
            storage_fee_per_state_slot: FeePerSlot,
            { 14.. => "storage_fee_per_state_slot" },
            // 0.8 million APT for 2 billion state slots
            40_000,
        ],
        [
            legacy_storage_fee_per_excess_state_byte: FeePerByte,
            { 7..=13 => "storage_fee_per_excess_state_byte", 14.. => "legacy_storage_fee_per_excess_state_byte" },
            50,
        ],
        [
            storage_fee_per_state_byte: FeePerByte,
            { 14.. => "storage_fee_per_state_byte" },
            // 0.8 million APT for 2 TB state bytes
            40,
        ],
```

**File:** api/src/context.rs (L1504-1530)
```rust
            let gas_schedule_params = {
                let may_be_params =
                    GasScheduleV2::fetch_config(&state_view).and_then(|gas_schedule| {
                        let feature_version = gas_schedule.feature_version;
                        let gas_schedule = gas_schedule.into_btree_map();
                        AptosGasParameters::from_on_chain_gas_schedule(
                            &gas_schedule,
                            feature_version,
                        )
                        .ok()
                    });
                match may_be_params {
                    Some(gas_schedule) => Ok(gas_schedule),
                    None => GasSchedule::fetch_config(&state_view)
                        .and_then(|gas_schedule| {
                            let gas_schedule = gas_schedule.into_btree_map();
                            AptosGasParameters::from_on_chain_gas_schedule(&gas_schedule, 0).ok()
                        })
                        .ok_or_else(|| {
                            E::internal_with_code(
                                "Failed to retrieve gas schedule",
                                AptosErrorCode::InternalError,
                                ledger_info,
                            )
                        }),
                }?
            };
```

**File:** aptos-move/aptos-vm-environment/src/gas.rs (L27-45)
```rust
    match GasScheduleV2::fetch_config_and_bytes(state_view) {
        Some((gas_schedule, bytes)) => {
            sha3_256.update(&bytes);
            let feature_version = gas_schedule.feature_version;
            let map = gas_schedule.into_btree_map();
            (
                AptosGasParameters::from_on_chain_gas_schedule(&map, feature_version),
                feature_version,
            )
        },
        None => match GasSchedule::fetch_config_and_bytes(state_view) {
            Some((gas_schedule, bytes)) => {
                sha3_256.update(&bytes);
                let map = gas_schedule.into_btree_map();
                (AptosGasParameters::from_on_chain_gas_schedule(&map, 0), 0)
            },
            None => (Err("Neither gas schedule v2 nor v1 exists.".to_string()), 0),
        },
    }
```

**File:** aptos-move/e2e-move-tests/src/tests/missing_gas_parameter.rs (L1-28)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use crate::{tests::common, MoveHarness};
use aptos_types::{account_address::AccountAddress, transaction::TransactionStatus};
use move_core_types::vm_status::StatusCode;

#[test]
fn missing_gas_parameter() {
    let mut h = MoveHarness::new();

    h.modify_gas_schedule_raw(|gas_schedule| {
        let idx = gas_schedule
            .entries
            .iter()
            .position(|(key, _val)| key == "instr.add")
            .unwrap();
        gas_schedule.entries.remove(idx);
    });

    // Load the code
    let acc = h.new_account_with_balance_at(AccountAddress::from_hex_literal("0xbeef").unwrap(), 0);
    let txn_status = h.publish_package(&acc, &common::test_dir_path("common.data/do_nothing"));
    assert!(matches!(
        txn_status,
        TransactionStatus::Discard(StatusCode::VM_STARTUP_FAILURE)
    ))
}
```
