Audit Report

## Title
Transaction Replay Underflow During KV Restore Can Cause Node Crash

## Summary
An unsigned integer underflow can occur in `replay_kv()` during backup restore if no transactions are available to replay, resulting in a crash or incorrect telemetry during restore operations.

## Finding Description
In the function `replay_kv()` in `storage/backup/backup-cli/src/backup_types/transaction/restore.rs`, when replaying transactions for state restore, the following calculation is performed:

`let total_replayed = version - first_version;`

If the stream of transactions is empty (which can occur due to previous drain operations in `save_before_replay_version`), `version` will be set to `first_version - 1`. Since `Version` is a `u64`, `version - first_version` underflows, resulting in `u64::MAX` as the total number of replayed transactions. This can lead to a panic in debug builds or incorrect metrics/logging in release. The scenario can be triggered when manifest/chunk boundaries and CLI parameters result in zero transactions to replay.

## Impact Explanation
This is a Medium severity bug. While it does not directly affect consensus or funds, it can crash restoring nodes or produce faulty state and metrics during restore operations. Such issues may disrupt recovery procedures, delay liveness, or require manual operator intervention.

## Likelihood Explanation
Moderate likelihood: An operator using restore flags incorrectly or manipulating manifests/chunk boundaries can hit this path. No attacker privileges are required beyond restore access and input control, but exploitation requires restoring state with certain (potentially invalid or partially restored) manifest/parameter combinations.

## Recommendation
Add an explicit check to handle the `version < first_version` case and return zero or error, preventing underflow. For example:

```rust
let total_replayed = version.saturating_sub(first_version);
```
Or, error out if `version < first_version`.

## Proof of Concept

1. Prepare a manifest/chunk such that all transactions are filtered out by `save_before_replay_version`.
2. Run restore with KV replay; observe that the `total_replayed` becomes u64::MAX if underflow occurs.
3. In debug builds, this will panic; in release builds, metric/logs will show a huge number.

----

Citations: [1](#0-0) [2](#0-1) [3](#0-2)

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L460-551)
```rust
        let mut txns_to_execute_stream = loaded_chunk_stream
            .and_then(move |chunk| {
                let restore_handler = restore_handler_clone.clone();
                future::ok(async move {
                    let mut first_version = chunk.manifest.first_version;
                    let mut last_version = chunk.manifest.last_version;
                    let (
                        mut txns,
                        mut persisted_aux_info,
                        mut txn_infos,
                        mut event_vecs,
                        mut write_sets,
                    ) = chunk.unpack();

                    // remove the txns that exceeds the target_version to be restored
                    if target_version < last_version {
                        let num_to_keep = (target_version - first_version + 1) as usize;
                        txns.drain(num_to_keep..);
                        persisted_aux_info.drain(num_to_keep..);
                        txn_infos.drain(num_to_keep..);
                        event_vecs.drain(num_to_keep..);
                        write_sets.drain(num_to_keep..);
                        last_version = target_version;
                    }

                    // remove the txns that are before the global_first_version
                    if global_first_version > first_version {
                        let num_to_remove = (global_first_version - first_version) as usize;

                        txns.drain(..num_to_remove);
                        persisted_aux_info.drain(..num_to_remove);
                        txn_infos.drain(..num_to_remove);
                        event_vecs.drain(..num_to_remove);
                        write_sets.drain(..num_to_remove);
                        first_version = global_first_version;
                    }

                    // identify txns to be saved before the first_to_replay version
                    if first_version < first_to_replay {
                        let num_to_save =
                            (min(first_to_replay, last_version + 1) - first_version) as usize;
                        let txns_to_save: Vec<_> = txns.drain(..num_to_save).collect();
                        let persisted_aux_info_to_save: Vec<_> =
                            persisted_aux_info.drain(..num_to_save).collect();
                        let txn_infos_to_save: Vec<_> = txn_infos.drain(..num_to_save).collect();
                        let event_vecs_to_save: Vec<_> = event_vecs.drain(..num_to_save).collect();
                        let write_sets_to_save = write_sets.drain(..num_to_save).collect();
                        tokio::task::spawn_blocking(move || {
                            restore_handler.save_transactions(
                                first_version,
                                &txns_to_save,
                                &persisted_aux_info_to_save,
                                &txn_infos_to_save,
                                &event_vecs_to_save,
                                write_sets_to_save,
                            )
                        })
                        .await??;
                        let last_saved = first_version + num_to_save as u64 - 1;
                        TRANSACTION_SAVE_VERSION.set(last_saved as i64);
                        info!(
                            version = last_saved,
                            accumulative_tps = ((last_saved - global_first_version + 1) as f64
                                / start.elapsed().as_secs_f64())
                                as u64,
                            "Transactions saved."
                        );
                    }

                    // create iterator of txn and its outputs to be replayed after the snapshot.
                    Ok(stream::iter(
                        izip!(txns, persisted_aux_info, txn_infos, write_sets, event_vecs)
                            .map(Result::<_>::Ok),
                    ))
                })
            })
            .try_buffered_x(self.global_opt.concurrent_downloads, 1)
            .try_flatten()
            .peekable();

        // Finish saving transactions that are not to be replayed.
        let first_txn_to_replay = {
            Pin::new(&mut txns_to_execute_stream)
                .peek()
                .await
                .map(|res| res.as_ref().map_err(|e| anyhow!("Error: {}", e)))
                .transpose()?
                .map(|_| ())
        };

        Ok(first_txn_to_replay.map(|_| txns_to_execute_stream))
    }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L567-637)
```rust
        let (first_version, _) = self.replay_from_version.unwrap();
        restore_handler.force_state_version_for_kv_restore(first_version.checked_sub(1))?;

        let mut base_version = first_version;
        let mut offset = 0u64;
        let replay_start = Instant::now();
        let arc_restore_handler = Arc::new(restore_handler.clone());

        let db_commit_stream = txns_to_execute_stream
            .try_chunks(BATCH_SIZE)
            .err_into::<anyhow::Error>()
            .map_ok(|chunk| {
                let (txns, persisted_aux_info, txn_infos, write_sets, events): (
                    Vec<_>,
                    Vec<_>,
                    Vec<_>,
                    Vec<_>,
                    Vec<_>,
                ) = chunk.into_iter().multiunzip();
                let handler = arc_restore_handler.clone();
                base_version += offset;
                offset = txns.len() as u64;
                async move {
                    let _timer = OTHER_TIMERS_SECONDS.timer_with(&["replay_txn_chunk_kv_only"]);
                    tokio::task::spawn_blocking(move || {
                        // we directly save transaction and kvs to DB without involving chunk executor
                        handler.save_transactions_and_replay_kv(
                            base_version,
                            &txns,
                            &persisted_aux_info,
                            &txn_infos,
                            &events,
                            write_sets,
                        )?;
                        // return the last version after the replaying
                        Ok(base_version + offset - 1)
                    })
                    .err_into::<anyhow::Error>()
                    .await
                }
            })
            .try_buffered_x(self.global_opt.concurrent_downloads, 1)
            .and_then(future::ready);

        let total_replayed = db_commit_stream
            .and_then(|version| async move {
                let _timer = OTHER_TIMERS_SECONDS.timer_with(&["commit_txn_chunk_kv_only"]);
                tokio::task::spawn_blocking(move || {
                    // version is the latest version finishing the KV replaying
                    let total_replayed = version - first_version;
                    TRANSACTION_REPLAY_VERSION.set(version as i64);
                    info!(
                        version = version,
                        accumulative_tps =
                            (total_replayed as f64 / replay_start.elapsed().as_secs_f64()) as u64,
                        "KV replayed."
                    );
                    Ok(version)
                })
                .await?
            })
            .try_fold(0, |_total, total| future::ok(total))
            .await?;
        info!(
            total_replayed = total_replayed,
            accumulative_tps =
                (total_replayed as f64 / replay_start.elapsed().as_secs_f64()) as u64,
            "KV Replay finished."
        );
        Ok(())
    }
```

**File:** types/src/transaction/mod.rs (L98-98)
```rust
pub type Version = u64; // Height - also used for MVCC in StateDB
```
