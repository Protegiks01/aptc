# Audit Report

## Title
Source Digest Verification Does Not Validate Bytecode Integrity - Supply Chain Attack Vector

## Summary
The Move package system's source digest verification mechanism fails to cryptographically bind published bytecode to the declared source code. An attacker can publish malicious bytecode with legitimate source digest metadata, bypassing verification and enabling supply chain attacks against dependent packages.

## Finding Description

The vulnerability exists in the architectural separation between package metadata and bytecode during publishing, with no validation mechanism to ensure they correspond.

**Attack Execution Path:**

1. **Publishing Entry Point**: The `publish_package_txn` entry function accepts metadata and bytecode as independent parameters: [1](#0-0) 

An attacker can serialize arbitrary `PackageMetadata` (containing any `source_digest`) and provide mismatched bytecode. These parameters are not cryptographically bound.

2. **Metadata Storage Without Binding**: The package metadata (including `source_digest`) is stored in `PackageRegistry`: [2](#0-1) 

The `source_digest` field is defined as a string in the metadata structure: [3](#0-2) 

3. **Native Publishing Without Validation**: The bytecode is passed to the native function separately: [4](#0-3) 

The native function creates a `PublishRequest` with the bytecode bundle but never validates it against the `source_digest` in metadata.

4. **VM Validation Gap**: The `validate_publish_request` function performs structural checks but does NOT validate bytecode matches source: [5](#0-4) 

This validation checks module structure, dependencies, and metadata format, but there is no code that computes a hash of the bytecode and compares it to `source_digest`.

5. **Verification Bypass**: The `VerifyPackage` command only compares metadata fields: [6](#0-5) 

The `verify()` method compares metadata to metadata, not bytecode to source: [7](#0-6) 

Specifically, it compares the `source_digest` strings but never validates that the on-chain bytecode corresponds to that digest: [8](#0-7) 

**Exploitation Scenario:**
- Attacker compiles legitimate source → obtains `source_digest_A`
- Attacker crafts malicious bytecode with matching module names/signatures
- Attacker calls `publish_package_txn` with malicious bytecode + metadata containing `source_digest_A`
- Bytecode passes structural validation but executes malicious logic
- Victim compiles the legitimate source (matching `source_digest_A`) and runs `VerifyPackage`
- Verification succeeds because metadata matches, despite bytecode mismatch
- Victim's dependent contracts execute the malicious on-chain bytecode

## Impact Explanation

**Critical Severity** - This vulnerability enables supply chain attacks that break the fundamental trust model of package dependencies.

**Direct Impacts:**
1. **Loss of Funds**: Malicious bytecode can steal assets when invoked by victim contracts through standard Move function calls
2. **State Manipulation**: Backdoored modules in critical infrastructure (governance, staking) can corrupt chain state
3. **Supply Chain Compromise**: A single malicious package can compromise entire ecosystems of dependent contracts

This qualifies as **Critical** under Aptos bug bounty criteria because it enables:
- Direct theft of funds through malicious Move code execution (Critical Impact #1)
- The vulnerability affects core Move package infrastructure used network-wide
- Exploitation requires no validator compromise or consensus violations
- The false sense of security amplifies the impact as developers trust "verified" packages

The `source_digest` mechanism exists specifically to provide reproducible build verification, but the implementation fails to validate the critical invariant: "published bytecode matches the declared source."

## Likelihood Explanation

**Likelihood: Medium-High**

**Factors Increasing Likelihood:**
- Entry function is publicly accessible - any address can call `publish_package_txn`
- Package source code is optional in metadata: [9](#0-8) 
- Developers commonly trust "verified" packages without independent auditing
- Move bytecode format is well-documented, making manual crafting feasible
- No runtime detection exists for bytecode-source mismatch
- Attack requires only moderate skill (bytecode crafting with correct structure)

**Factors Decreasing Likelihood:**
- Bytecode must pass comprehensive structural verification
- Manual bytecode crafting requires expertise in Move bytecode format
- Suspicious packages (no source in metadata, unknown publishers) may be avoided by cautious developers
- Community review may detect obvious malicious behavior in popular packages

However, the high-value targets (governance modules, DeFi protocols) and the supply chain multiplier effect make exploitation attractive despite moderate complexity.

## Recommendation

Implement cryptographic binding between bytecode and source digest during publishing:

1. **At Publish Time**: Compute a hash of the published bytecode bundle and store it alongside `source_digest` in `PackageMetadata`

2. **Add Bytecode Hash Field** to `PackageMetadata` structure in `code.move`:
```move
struct PackageMetadata has copy, drop, store {
    name: String,
    upgrade_policy: UpgradePolicy,
    upgrade_number: u64,
    source_digest: String,
    bytecode_digest: String,  // NEW: SHA256 hash of bytecode bundle
    manifest: vector<u8>,
    modules: vector<ModuleMetadata>,
    deps: vector<PackageDep>,
    extension: Option<Any>
}
```

3. **Validation in `validate_publish_request`**: Compute the bytecode hash and validate it matches the declared `bytecode_digest` in metadata

4. **Enhanced Verification**: Update `VerifyPackage` to:
   - Compile source locally to get both source_digest and bytecode
   - Compute hash of locally compiled bytecode
   - Compare against on-chain bytecode_digest
   - Download and compare actual on-chain bytecode if hashes match

5. **Deprecation Path**: Support both old packages (without bytecode_digest) and new packages, with clear warnings for packages lacking bytecode verification.

## Proof of Concept

```move
// Malicious Actor's Attack Flow (Conceptual PoC)

// Step 1: Compile legitimate source to get source_digest
// Legitimate source produces: source_digest = "ABCD1234..."

// Step 2: Craft malicious bytecode with same module names/signatures
// module 0x1234::token {
//   public fun transfer(to: address, amount: u64) {
//     // Malicious: send to attacker instead of 'to'
//     real_transfer(ATTACKER_ADDRESS, amount)
//   }
// }

// Step 3: Create metadata with legitimate source_digest
let metadata = PackageMetadata {
    name: string::utf8(b"MyToken"),
    source_digest: string::utf8(b"ABCD1234..."),  // From legitimate source
    // ... other fields
};

// Step 4: Publish mismatched bytecode + metadata
aptos_framework::code::publish_package_txn(
    &signer,
    bcs::to_bytes(&metadata),  // Metadata with legitimate source_digest
    malicious_bytecode_bundle   // Malicious bytecode
);

// Result: Package published successfully
// Verification: Users compile legitimate source → get "ABCD1234..." → VerifyPackage succeeds
// Exploitation: On-chain bytecode executes malicious logic
```

**Test Scenario**: An attacker can construct a transaction calling `publish_package_txn` with serialized metadata containing a specific `source_digest` value, while providing bytecode that was NOT compiled from the corresponding source. The transaction will succeed if the bytecode passes structural validation, and subsequent `VerifyPackage` calls will incorrectly report success.

## Notes

This vulnerability represents a critical gap in the package verification trust model. The `source_digest` mechanism provides reproducible build verification but lacks the enforcement layer to ensure published bytecode integrity. The architectural decision to accept metadata and bytecode as separate, unbound parameters creates the vulnerability surface. The issue is exacerbated by the `VerifyPackage` command's messaging ("Successfully verified source of package") which implies stronger guarantees than actually provided, leading developers to false confidence in package integrity.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/code.move (L30-49)
```text
    struct PackageMetadata has copy, drop, store {
        /// Name of this package.
        name: String,
        /// The upgrade policy of this package.
        upgrade_policy: UpgradePolicy,
        /// The numbers of times this module has been upgraded. Also serves as the on-chain version.
        /// This field will be automatically assigned on successful upgrade.
        upgrade_number: u64,
        /// The source digest of the sources in the package. This is constructed by first building the
        /// sha256 of each individual source, than sorting them alphabetically, and sha256 them again.
        source_digest: String,
        /// The package manifest, in the Move.toml format. Gzipped text.
        manifest: vector<u8>,
        /// The list of modules installed by this package.
        modules: vector<ModuleMetadata>,
        /// Holds PackageDeps.
        deps: vector<PackageDep>,
        /// For future extension
        extension: Option<Any>
    }
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L58-67)
```text
    struct ModuleMetadata has copy, drop, store {
        /// Name of the module.
        name: String,
        /// Source text, gzipped String. Empty if not provided.
        source: vector<u8>,
        /// Source map, in compressed BCS. Empty if not provided.
        source_map: vector<u8>,
        /// For future extensions.
        extension: Option<Any>,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L207-214)
```text
        let packages = &mut borrow_global_mut<PackageRegistry>(addr).packages;
        // Update registry
        let policy = pack.upgrade_policy;
        if (index < len) {
            *vector::borrow_mut(packages, index) = pack
        } else {
            vector::push_back(packages, pack)
        };
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L256-259)
```text
    public entry fun publish_package_txn(owner: &signer, metadata_serialized: vector<u8>, code: vector<vector<u8>>)
    acquires PackageRegistry {
        publish_package(owner, util::from_bytes<PackageMetadata>(metadata_serialized), code)
    }
```

**File:** aptos-move/framework/src/natives/code.rs (L353-359)
```rust
    code_context.requested_module_bundle = Some(PublishRequest {
        destination,
        bundle: ModuleBundle::new(code),
        expected_modules,
        allowed_deps,
        check_compat: policy != ARBITRARY_POLICY,
    });
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1680-1738)
```rust
    fn validate_publish_request(
        &self,
        module_storage: &impl AptosModuleStorage,
        traversal_context: &mut TraversalContext,
        gas_meter: &mut impl GasMeter,
        modules: &[CompiledModule],
        mut expected_modules: BTreeSet<String>,
        allowed_deps: Option<BTreeMap<AccountAddress, BTreeSet<String>>>,
    ) -> VMResult<()> {
        self.reject_unstable_bytecode(modules)?;
        native_validation::validate_module_natives(modules)?;

        for m in modules {
            if !expected_modules.remove(m.self_id().name().as_str()) {
                return Err(Self::metadata_validation_error(&format!(
                    "unregistered module: '{}'",
                    m.self_id().name()
                )));
            }
            if let Some(allowed) = &allowed_deps {
                for dep in m.immediate_dependencies() {
                    if !allowed
                        .get(dep.address())
                        .map(|modules| {
                            modules.contains("") || modules.contains(dep.name().as_str())
                        })
                        .unwrap_or(false)
                    {
                        return Err(Self::metadata_validation_error(&format!(
                            "unregistered dependency: '{}'",
                            dep
                        )));
                    }
                }
            }
            verify_module_metadata_for_module_publishing(m, self.features())
                .map_err(|err| Self::metadata_validation_error(&err.to_string()))?;
        }

        resource_groups::validate_resource_groups(
            self.features(),
            module_storage,
            traversal_context,
            gas_meter,
            modules,
        )?;
        event_validation::validate_module_events(
            self.features(),
            module_storage,
            traversal_context,
            modules,
        )?;

        if !expected_modules.is_empty() {
            return Err(Self::metadata_validation_error(
                "not all registered modules published",
            ));
        }
        Ok(())
```

**File:** crates/aptos/src/move_tool/mod.rs (L2048-2083)
```rust
    async fn execute(self) -> CliTypedResult<&'static str> {
        // First build the package locally to get the package metadata
        let build_options = BuildOptions {
            install_dir: self.move_options.output_dir.clone(),
            bytecode_version: fix_bytecode_version(
                self.move_options.bytecode_version,
                self.move_options.language_version,
            ),
            ..self.included_artifacts.build_options(&self.move_options)?
        };
        let pack = BuiltPackage::build(self.move_options.get_package_path()?, build_options)
            .map_err(|e| CliError::MoveCompilationError(format!("{:#}", e)))?;
        let compiled_metadata = pack.extract_metadata()?;

        // Now pull the compiled package
        let url = self.rest_options.url(&self.profile_options)?;
        let registry = CachedPackageRegistry::create(url, self.account, false).await?;
        let package = registry
            .get_package(pack.name())
            .await
            .map_err(|s| CliError::CommandArgumentError(s.to_string()))?;

        // We can't check the arbitrary, because it could change on us
        if package.upgrade_policy() == UpgradePolicy::arbitrary() {
            return Err(CliError::CommandArgumentError(
                "A package with upgrade policy `arbitrary` cannot be downloaded \
                since it is not safe to depend on such packages."
                    .to_owned(),
            ));
        }

        // Verify that the source digest matches
        package.verify(&compiled_metadata)?;

        Ok("Successfully verified source of package")
    }
```

**File:** crates/aptos/src/move_tool/stored_package.rs (L195-243)
```rust
    pub fn verify(&self, package_metadata: &PackageMetadata) -> anyhow::Result<()> {
        let self_metadata = self.metadata;

        if self_metadata.name != package_metadata.name {
            bail!(
                "Package name doesn't match {} : {}",
                package_metadata.name,
                self_metadata.name
            )
        } else if self_metadata.deps != package_metadata.deps {
            bail!(
                "Dependencies don't match {:?} : {:?}",
                package_metadata.deps,
                self_metadata.deps
            )
        } else if self_metadata.modules != package_metadata.modules {
            bail!(
                "Modules don't match {:?} : {:?}",
                package_metadata.modules,
                self_metadata.modules
            )
        } else if self_metadata.manifest != package_metadata.manifest {
            bail!(
                "Manifest doesn't match {:?} : {:?}",
                package_metadata.manifest,
                self_metadata.manifest
            )
        } else if self_metadata.upgrade_policy != package_metadata.upgrade_policy {
            bail!(
                "Upgrade policy doesn't match {:?} : {:?}",
                package_metadata.upgrade_policy,
                self_metadata.upgrade_policy
            )
        } else if self_metadata.extension != package_metadata.extension {
            bail!(
                "Extensions doesn't match {:?} : {:?}",
                package_metadata.extension,
                self_metadata.extension
            )
        } else if self_metadata.source_digest != package_metadata.source_digest {
            bail!(
                "Source digests doesn't match {:?} : {:?}",
                package_metadata.source_digest,
                self_metadata.source_digest
            )
        }

        Ok(())
    }
```
