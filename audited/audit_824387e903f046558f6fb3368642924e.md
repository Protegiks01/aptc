# Audit Report

## Title
Inconsistent Feature Flag Fallback Handling Creates Consensus Disagreement Risk During JWK Consensus Migration

## Summary
During the JWK consensus migration period, when `OnChainJWKConsensusConfig` is not yet initialized and the `Features` config fails to load, two critical components handle this failure inconsistently. The consensus round manager defaults JWK consensus to "Off" while the JWK manager component assumes it's "On", causing affected validators to reject valid proposals containing `ObservedJWKUpdate` validator transactions.

## Finding Description

The codebase implements a migration mechanism to transition from the deprecated `Features` flag-based JWK consensus configuration to the new `OnChainJWKConsensusConfig` resource. During this migration period, both components must fall back to reading the legacy `Features` flag when the new config is unavailable.

**Inconsistent Error Handling:**

In `consensus/src/epoch_manager.rs`, the fallback function uses `.ok()` to silently convert `Features` loading errors to `None`: [1](#0-0) 

This triggers the `From` trait implementation that defaults to `Off` when `features` is `None`: [2](#0-1) 

However, in `crates/aptos-jwk-consensus/src/epoch_manager.rs`, the fallback uses `unwrap_or_default()`: [3](#0-2) 

This creates a `Features::default()` instance that includes `JWK_CONSENSUS` enabled: [4](#0-3) [5](#0-4) 

**Critical Consequence:**

When proposals containing `ObservedJWKUpdate` validator transactions arrive, the round manager validates them using `is_vtxn_expected()`: [6](#0-5) [7](#0-6) 

If `jwk_consensus_config` is incorrectly set to `Off` due to Features loading failure, the node will reject valid proposals with "unexpected validator txn" error, preventing it from voting and participating in consensus.

## Impact Explanation

This qualifies as **High Severity** per Aptos bug bounty criteria under "Validator Node Slowdowns":

1. **Consensus Participation Failure**: Affected validators cannot vote on valid proposals, reducing effective validator set size and slowing consensus progress
2. **Deterministic Execution Violation**: Validators with identical blocks produce different decisions based on whether `Features` loaded successfully, breaking a fundamental consensus invariant
3. **Network Partition Risk**: If multiple validators experience `Features` loading failures simultaneously (during software upgrades or migration rollouts), a significant portion of the validator set could become unable to participate
4. **No Manual Recovery**: Affected nodes remain unable to participate until the next epoch transition or manual intervention

The issue creates consensus disagreement where some nodes accept valid proposals while others reject them, violating the safety property that honest validators should agree on block validity.

## Likelihood Explanation

**Likelihood: Low to Medium**

The vulnerability requires two conditions:
1. Migration period where `OnChainJWKConsensusConfig` is not yet initialized on-chain
2. `Features` config loading failure (deserialization error, storage corruption, I/O failure)

While `Features` loading failures are uncommon in normal operation, they can realistically occur during:
- Software upgrades with on-chain config schema changes
- State sync issues causing incomplete configuration data
- Storage corruption or hardware failures affecting database reads
- Race conditions during epoch transitions
- Phased migration deployments where `OnChainJWKConsensusConfig` rollout is incomplete across the network

The inconsistency is deterministic once triggeredâ€”it will reliably cause the affected validator to reject proposals until the condition is resolved.

## Recommendation

Standardize the error handling across both components to use the same default behavior. The safest approach is to default to `Off` in both paths when `Features` fails to load:

In `crates/aptos-jwk-consensus/src/epoch_manager.rs`, change line 172 from:
```rust
let features = payload.get::<Features>().unwrap_or_default();
```

To:
```rust
let features = payload.get::<Features>().ok();
```

Then update the fallback logic at lines 177-195 to handle `None` by defaulting to disabled:
```rust
let (jwk_manager_should_run, oidc_providers) = match jwk_consensus_config {
    Ok(config) => {
        let should_run = config.jwk_consensus_enabled() && onchain_consensus_config.is_vtxn_enabled();
        let providers = config.oidc_providers_cloned().into_iter()
            .map(jwks::OIDCProvider::from).collect();
        (should_run, Some(SupportedOIDCProviders { providers }))
    },
    Err(_) => {
        let should_run = features
            .map(|f| f.is_enabled(FeatureFlag::JWK_CONSENSUS))
            .unwrap_or(false) // Default to disabled when Features unavailable
            && onchain_consensus_config.is_vtxn_enabled();
        let providers = payload.get::<SupportedOIDCProviders>().ok();
        (should_run, providers)
    },
};
```

This ensures both components consistently default to JWK consensus disabled when `Features` cannot be loaded, maintaining consensus invariants during migration.

## Proof of Concept

While a full runnable PoC would require simulating storage failures during epoch transitions, the vulnerability is demonstrated through code path analysis:

1. Deploy network in migration state (OnChainJWKConsensusConfig not initialized, Features flag enabled)
2. Introduce storage corruption or deserialization error affecting Features resource
3. Trigger epoch transition
4. Observe: Round manager receives JWK config = Off, JWK manager receives JWK enabled = true
5. When proposal with ObservedJWKUpdate arrives, round manager rejects it while other validators accept it
6. Result: Affected validator cannot participate in consensus

The deterministic nature of this bug and clear inconsistency in error handling paths constitutes sufficient evidence of the vulnerability without requiring a destructive test harness.

### Citations

**File:** consensus/src/epoch_manager.rs (L1963-1969)
```rust
    fn equivalent_jwk_consensus_config_from_deprecated_resources(
        payload: &OnChainConfigPayload<P>,
    ) -> OnChainJWKConsensusConfig {
        let features = payload.get::<Features>().ok();
        let oidc_providers = payload.get::<SupportedOIDCProviders>().ok();
        OnChainJWKConsensusConfig::from((features, oidc_providers))
    }
```

**File:** types/src/on_chain_config/jwk_consensus_config.rs (L112-131)
```rust
impl From<(Option<Features>, Option<SupportedOIDCProviders>)> for OnChainJWKConsensusConfig {
    fn from(
        (features, supported_oidc_providers): (Option<Features>, Option<SupportedOIDCProviders>),
    ) -> Self {
        if let Some(features) = features {
            if features.is_enabled(FeatureFlag::JWK_CONSENSUS) {
                let oidc_providers = supported_oidc_providers
                    .unwrap_or_default()
                    .providers
                    .into_iter()
                    .filter_map(|deprecated| OIDCProvider::try_from(deprecated).ok())
                    .collect();
                OnChainJWKConsensusConfig::V1(ConfigV1 { oidc_providers })
            } else {
                OnChainJWKConsensusConfig::Off
            }
        } else {
            OnChainJWKConsensusConfig::Off
        }
    }
```

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L172-194)
```rust
        let features = payload.get::<Features>().unwrap_or_default();
        let jwk_consensus_config = payload.get::<OnChainJWKConsensusConfig>();
        let onchain_observed_jwks = payload.get::<ObservedJWKs>().ok();
        let onchain_consensus_config = payload.get::<OnChainConsensusConfig>().unwrap_or_default();

        let (jwk_manager_should_run, oidc_providers) = match jwk_consensus_config {
            Ok(config) => {
                let should_run =
                    config.jwk_consensus_enabled() && onchain_consensus_config.is_vtxn_enabled();
                let providers = config
                    .oidc_providers_cloned()
                    .into_iter()
                    .map(jwks::OIDCProvider::from)
                    .collect();
                (should_run, Some(SupportedOIDCProviders { providers }))
            },
            Err(_) => {
                //TODO: remove this case once the framework change of this commit is published.
                let should_run = features.is_enabled(FeatureFlag::JWK_CONSENSUS)
                    && onchain_consensus_config.is_vtxn_enabled();
                let providers = payload.get::<SupportedOIDCProviders>().ok();
                (should_run, providers)
            },
```

**File:** types/src/on_chain_config/aptos_features.rs (L221-221)
```rust
            FeatureFlag::JWK_CONSENSUS,
```

**File:** types/src/on_chain_config/aptos_features.rs (L287-297)
```rust
impl Default for Features {
    fn default() -> Self {
        let mut features = Features {
            features: vec![0; 5],
        };

        for feature in FeatureFlag::default_features() {
            features.enable(feature);
        }
        features
    }
```

**File:** consensus/src/round_manager.rs (L1126-1136)
```rust
        if let Some(vtxns) = proposal.validator_txns() {
            for vtxn in vtxns {
                let vtxn_type_name = vtxn.type_name();
                ensure!(
                    is_vtxn_expected(&self.randomness_config, &self.jwk_consensus_config, vtxn),
                    "unexpected validator txn: {:?}",
                    vtxn_type_name
                );
                vtxn.verify(self.epoch_state.verifier.as_ref())
                    .context(format!("{} verify failed", vtxn_type_name))?;
            }
```

**File:** consensus/src/util/mod.rs (L15-24)
```rust
pub fn is_vtxn_expected(
    randomness_config: &OnChainRandomnessConfig,
    jwk_consensus_config: &OnChainJWKConsensusConfig,
    vtxn: &ValidatorTransaction,
) -> bool {
    match vtxn {
        ValidatorTransaction::DKGResult(_) => randomness_config.randomness_enabled(),
        ValidatorTransaction::ObservedJWKUpdate(_) => jwk_consensus_config.jwk_consensus_enabled(),
    }
}
```
