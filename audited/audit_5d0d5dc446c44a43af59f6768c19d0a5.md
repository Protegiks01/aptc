# Audit Report

## Title
Network Frame Size Mismatch Causes Connection Failures Between Validators

## Summary
The Aptos network layer allows each node to independently configure `max_frame_size` without negotiation during handshake, enabling a sender with a larger frame size to send messages that a receiver with a smaller frame size will reject, causing connection termination and potential network partitioning.

## Finding Description

The network messaging protocol has a critical design flaw where `max_frame_size` is not negotiated during the handshake phase. Each node independently configures this value in their `NetworkConfig`, and senders make streaming decisions based solely on their own `max_frame_size` without knowledge of the receiver's limit. [1](#0-0) 

The handshake message does not include `max_frame_size`, only negotiating protocol versions and application protocols. [2](#0-1) 

Each node configures `max_frame_size` independently in their configuration. [3](#0-2) 

Both the reader (stream) and writer (sink) are initialized with the same local `max_frame_size` value. [4](#0-3) 

The critical flaw: the sender's `OutboundStream` uses its own `max_frame_size` to decide whether to stream a message. If the message fits within the sender's limit but exceeds the receiver's limit, it will be sent as a single frame. [5](#0-4) 

**Attack Scenario:**
1. Validator A configures `max_frame_size: 4 MiB` (default)
2. Validator B configures `max_frame_size: 2 MiB` (custom configuration)
3. Validator A sends a 3 MiB consensus message to Validator B
4. Validator A's logic: `3 MiB < 4 MiB` → send as single frame (no streaming)
5. Validator B's `LengthDelimitedCodec` receives frame header indicating 3 MiB
6. Validator B's codec rejects: `3 MiB > 2 MiB` → returns `IoError`
7. Validator B's peer handler treats this as an unrecoverable error [6](#0-5) 

The connection is terminated with `DisconnectReason::InputOutputError`. [7](#0-6) 

The existing test explicitly demonstrates this vulnerability.

## Impact Explanation

This vulnerability qualifies as **HIGH Severity** under the Aptos bug bounty program for the following reasons:

1. **Validator Node Slowdowns**: Affected validators repeatedly disconnect and reconnect, causing performance degradation.

2. **Significant Protocol Violations**: Legitimate messages are rejected due to configuration mismatch, violating the expectation that all validators can communicate.

3. **Consensus Liveness Risk**: If multiple validators have mismatched configurations, consensus messages (proposals, votes, sync requests) may fail to propagate, potentially causing:
   - Delayed block production
   - Increased round timeouts
   - Temporary loss of consensus progress

4. **Network Partitioning**: In a heterogeneous validator set where some nodes use custom configurations, the network could fragment into incompatible groups.

5. **Availability Impact**: Critical state synchronization and consensus observer messages could be rejected, preventing nodes from catching up or participating in consensus.

The impact does not reach Critical severity because:
- It requires non-default configuration (deliberate or accidental)
- It doesn't directly cause consensus safety violations (no double-spend or forks)
- It doesn't result in fund loss
- Recovery is possible through reconfiguration

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability has moderate to high likelihood of occurrence because:

1. **No Warning or Validation**: The system provides no warning when peers have mismatched `max_frame_size` values. Operators receive no indication that their configuration will cause connection failures.

2. **Legitimate Use Cases**: Operators may legitimately want to configure smaller frame sizes to:
   - Reduce memory usage
   - Implement custom rate limiting
   - Optimize for specific network conditions

3. **Configuration Drift**: In a decentralized network, different validators may use different configuration templates, leading to heterogeneous frame size settings.

4. **Silent Failures**: The connection simply drops with an `IoError`, which appears identical to network issues, making diagnosis difficult.

5. **Large Message Scenarios**: Consensus messages can legitimately approach or exceed default frame sizes during:
   - State synchronization with large chunks
   - Consensus observer synchronization
   - Block proposals with many transactions

The only mitigating factor reducing likelihood is that the default `max_frame_size` of 4 MiB is consistent across nodes unless explicitly changed.

## Recommendation

Implement `max_frame_size` negotiation during the handshake phase to ensure both peers agree on a common maximum frame size.

**Recommended Fix:**

1. **Extend HandshakeMsg** to include `max_frame_size`: [1](#0-0) 

Add a `max_frame_size: usize` field to the `HandshakeMsg` struct.

2. **Negotiate minimum value** in `perform_handshake`: [8](#0-7) 

After successful protocol negotiation, compute and return the minimum of both peers' `max_frame_size` values:
```rust
let negotiated_frame_size = std::cmp::min(self.max_frame_size, other.max_frame_size);
```

3. **Use negotiated value** when creating stream/sink: [3](#0-2) 

Replace `self.max_frame_size` with the negotiated value from handshake result.

**Alternative Fix (Backward Compatible):**

If protocol changes are undesirable, implement sender-side validation:
- Before sending, serialize the message and check its size
- If it exceeds a conservative threshold (e.g., 2 MiB to account for common configurations), force streaming
- Log warnings when messages approach frame size limits

## Proof of Concept

The vulnerability is already demonstrated in the existing test suite: [7](#0-6) 

**To reproduce in a live network:**

1. Configure Validator A with default settings (`max_frame_size: 4194304`)
2. Configure Validator B with custom settings (`max_frame_size: 2097152`)
3. Generate a consensus message larger than 2 MiB but smaller than 4 MiB
4. Send from Validator A to Validator B
5. Observe connection termination in Validator B's logs:
   ```
   Error in handling inbound message from peer: <peer_id>, error: IoError(...)
   Peer actor terminated with reason: InputOutputError
   ```

**Steps to verify the fix:**

1. Add `max_frame_size` to `HandshakeMsg`
2. Modify `perform_handshake` to return negotiated minimum
3. Run the existing test `recv_fails_when_larger_than_frame_limit()` with negotiation enabled
4. Verify that messages are now automatically streamed when they exceed the negotiated limit

---

**Notes:**

This vulnerability represents a protocol design oversight rather than an implementation bug. The streaming mechanism exists to handle large messages, but the sender-side decision logic doesn't account for heterogeneous receiver configurations. The fix requires a protocol change to negotiate frame sizes during connection establishment, ensuring both peers operate with compatible limits.

### Citations

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L400-408)
```rust
/// The HandshakeMsg contains a mapping from [`MessagingProtocolVersion`]
/// suppported by the node to a bit-vector specifying application-level protocols
/// supported over that version.
#[derive(Clone, Deserialize, Serialize, Default)]
pub struct HandshakeMsg {
    pub supported_protocols: BTreeMap<MessagingProtocolVersion, ProtocolIdSet>,
    pub chain_id: ChainId,
    pub network_id: NetworkId,
}
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L428-465)
```rust
    /// This function:
    /// 1. verifies that both HandshakeMsg are compatible and
    /// 2. finds out the intersection of protocols that is supported
    pub fn perform_handshake(
        &self,
        other: &HandshakeMsg,
    ) -> Result<(MessagingProtocolVersion, ProtocolIdSet), HandshakeError> {
        // verify that both peers are on the same chain
        if self.chain_id != other.chain_id {
            return Err(HandshakeError::InvalidChainId(
                other.chain_id,
                self.chain_id,
            ));
        }

        // verify that both peers are on the same network
        if self.network_id != other.network_id {
            return Err(HandshakeError::InvalidNetworkId(
                other.network_id,
                self.network_id,
            ));
        }

        // find the greatest common MessagingProtocolVersion where we both support
        // at least one common ProtocolId.
        for (our_handshake_version, our_protocols) in self.supported_protocols.iter().rev() {
            if let Some(their_protocols) = other.supported_protocols.get(our_handshake_version) {
                let common_protocols = our_protocols.intersect(their_protocols);

                if !common_protocols.is_empty() {
                    return Ok((*our_handshake_version, common_protocols));
                }
            }
        }

        // no intersection found
        Err(HandshakeError::NoCommonProtocols)
    }
```

**File:** config/src/config/network_config.rs (L102-103)
```rust
    /// The maximum size of an inbound or outbound request frame
    pub max_frame_size: usize,
```

**File:** network/framework/src/peer/mod.rs (L216-218)
```rust
        let mut reader =
            MultiplexMessageStream::new(read_socket.compat(), self.max_frame_size).fuse();
        let writer = MultiplexMessageSink::new(write_socket.compat_write(), self.max_frame_size);
```

**File:** network/framework/src/peer/mod.rs (L419-430)
```rust
        let multiplex_task = async move {
            let mut outbound_stream =
                OutboundStream::new(max_frame_size, max_message_size, stream_msg_tx);
            while let Some(message) = write_reqs_rx.next().await {
                // either channel full would block the other one
                let result = if outbound_stream.should_stream(&message) {
                    outbound_stream.stream_message(message).await
                } else {
                    msg_tx
                        .send(MultiplexMessage::Message(message))
                        .await
                        .map_err(|_| anyhow::anyhow!("Writer task ended"))
```

**File:** network/framework/src/peer/mod.rs (L588-591)
```rust
                ReadError::IoError(_) => {
                    // IoErrors are mostly unrecoverable so just close the connection.
                    self.shutdown(DisconnectReason::InputOutputError);
                    return Err(err.into());
```

**File:** network/framework/src/protocols/stream/mod.rs (L253-256)
```rust
    /// Returns true if the message should be streamed
    pub fn should_stream(&self, message: &NetworkMessage) -> bool {
        message.data_len() > self.max_frame_size
    }
```

**File:** network/framework/src/protocols/wire/messaging/v1/test.rs (L135-152)
```rust
#[test]
fn recv_fails_when_larger_than_frame_limit() {
    let (memsocket_tx, memsocket_rx) = MemorySocket::new_pair();
    // sender won't error b/c their max frame size is larger
    let mut message_tx = MultiplexMessageSink::new(memsocket_tx, 128);
    // receiver will reject the message b/c the frame size is > 64 bytes max
    let mut message_rx = MultiplexMessageStream::new(memsocket_rx, 64);

    let message = MultiplexMessage::Message(NetworkMessage::DirectSendMsg(DirectSendMsg {
        protocol_id: ProtocolId::ConsensusRpcBcs,
        priority: 0,
        raw_msg: vec![0; 80],
    }));
    let f_send = message_tx.send(&message);
    let f_recv = message_rx.next();

    let (_, res_message) = block_on(future::join(f_send, f_recv));
    res_message.unwrap().unwrap_err();
```
