> Searching codebase... [1](#0-0) [2](#0-1) [3](#0-2)

### Citations

**File:** aptos-move/script-composer/src/builder.rs (L217-345)
```rust
        &mut self,
        module: String,
        function: String,
        ty_args: Vec<String>,
        args: Vec<CallArgument>,
    ) -> anyhow::Result<Vec<CallArgument>> {
        let ty_args = ty_args
            .iter()
            .map(|s| TypeTag::from_str(s))
            .collect::<anyhow::Result<Vec<_>>>()?;
        let module = ModuleId::from_str(&module)?;
        let function = Identifier::new(function)?;
        let call_idx = LOADED_MODULES.with(|modules| match modules.borrow().get(&module) {
            Some(module_ref) => self
                .builder
                .import_call_by_name(function.as_ident_str(), module_ref)
                .map_err(|err| anyhow!("Cannot import module {}: {:?}", module, err)),
            None => Err(anyhow!("Module {} is not yet loaded", module)),
        })?;

        let type_arguments = LOADED_MODULES.with(|modules| {
            ty_args
                .iter()
                .map(|ty| import_type_tag(&mut self.builder, ty, &modules.borrow()))
                .collect::<PartialVMResult<Vec<_>>>()
        })?;

        let mut arguments = vec![];
        let expected_args_ty = {
            let script = self.builder.as_script();
            let func = script.function_handle_at(call_idx);
            if script.signature_at(func.parameters).0.len() != args.len() {
                bail!(
                    "Function {}::{} argument call size mismatch",
                    module,
                    function
                );
            }
            script
                .signature_at(func.parameters)
                .0
                .iter()
                .map(|ty| ty.instantiate(&type_arguments))
                .collect::<Vec<_>>()
        };

        for (arg, ty) in args.into_iter().zip(expected_args_ty) {
            match arg {
                CallArgument::PreviousResult(r) => {
                    let argument = AllocatedLocal {
                        op_type: r.operation_type,
                        is_parameter: false,
                        local_idx: self.calls[r.call_idx as usize].returns[r.return_idx as usize],
                    };
                    self.check_argument_compatibility(&argument, &ty)?;
                    arguments.push(argument)
                },
                CallArgument::Signer(i) => arguments.push(AllocatedLocal {
                    op_type: ArgumentOperation::Copy,
                    is_parameter: true,
                    local_idx: i,
                }),
                CallArgument::Raw(bytes) => {
                    let new_local_idx = self.parameters_ty.len() as u16;
                    self.parameters_ty.push(ty);
                    self.parameters.push(bytes);
                    arguments.push(AllocatedLocal {
                        op_type: ArgumentOperation::Move,
                        is_parameter: true,
                        local_idx: new_local_idx,
                    })
                },
            }
        }

        let mut returns = vec![];

        let expected_returns_ty = {
            let func = self.builder.as_script().function_handle_at(call_idx);
            self.builder
                .as_script()
                .signature_at(func.return_)
                .0
                .iter()
                .map(|ty| ty.instantiate(&type_arguments))
                .collect::<Vec<_>>()
        };

        let mut returned_arguments = vec![];
        let num_of_calls = self.calls.len() as u16;

        for (idx, return_ty) in expected_returns_ty.into_iter().enumerate() {
            let ability = BinaryIndexedView::Script(self.builder.as_script())
                .abilities(&return_ty, &[])
                .map_err(|_| anyhow!("Failed to calculate ability for type"))?;

            let local_idx = self.locals_ty.len() as u16;
            self.locals_ty.push(return_ty);
            self.locals_availability.push(true);
            returns.push(local_idx);

            // For values that has drop and copy ability, use copy by default to avoid calling copy manually
            // on the client side.
            returned_arguments.push(CallArgument::PreviousResult(PreviousResult {
                operation_type: if ability.has_drop() && ability.has_copy() {
                    ArgumentOperation::Copy
                } else {
                    ArgumentOperation::Move
                },
                call_idx: num_of_calls,
                return_idx: idx as u16,
            }));
        }

        if self.parameters.len() + self.locals_ty.len() > u8::MAX as usize {
            bail!("Too many locals being allocated, please truncate the transaction");
        }

        self.calls.push(BuilderCall {
            type_args: type_arguments,
            call_idx,
            arguments,
            returns: returns.clone(),
            #[cfg(test)]
            type_tags: ty_args,
        });

        Ok(returned_arguments)
    }
```

**File:** aptos-move/script-composer/src/builder.rs (L360-430)
```rust
    }

    fn generate_batched_calls_impl(self, with_metadata: bool) -> anyhow::Result<Vec<u8>> {
        self.check_drop_at_end()?;
        let parameters_count = self.parameters_ty.len() as u16;
        let mut script = self.builder.into_script();
        let mut instantiations = HashMap::new();
        for call in self.calls {
            for arg in call.arguments {
                script.code.code.push(arg.to_instruction(parameters_count)?);
            }

            // Calls
            if call.type_args.is_empty() {
                script.code.code.push(Bytecode::Call(call.call_idx));
            } else {
                if script.function_instantiations.len() >= TableIndex::MAX as usize {
                    bail!("Too many function instantiations");
                }
                let type_parameters = import_signature(&mut script, Signature(call.type_args))?;

                let inst = FunctionInstantiation {
                    handle: call.call_idx,
                    type_parameters,
                };
                if let Some(idx) = instantiations.get(&inst) {
                    script.code.code.push(Bytecode::CallGeneric(*idx));
                } else {
                    let fi_idx =
                        FunctionInstantiationIndex(script.function_instantiations.len() as u16);
                    script.function_instantiations.push(inst.clone());
                    instantiations.insert(inst, fi_idx);
                    script.code.code.push(Bytecode::CallGeneric(fi_idx));
                }
            }

            // Storing return values
            for arg in call.returns.iter().rev() {
                script
                    .code
                    .code
                    .push(Bytecode::StLoc((*arg + parameters_count) as u8));
            }
        }
        script.code.code.push(Bytecode::Ret);
        script.parameters = import_signature(&mut script, Signature(self.parameters_ty))?;
        script.code.locals = import_signature(&mut script, Signature(self.locals_ty))?;

        move_bytecode_verifier::verify_script(&script).map_err(|err| anyhow!("{:?}", err))?;
        if with_metadata {
            script.metadata.push(Metadata {
                key: APTOS_SCRIPT_COMPOSER_KEY.to_owned(),
                value: bcs::to_bytes(&ComposerVersion::V1).unwrap(),
            });
        }
        let mut bytes = vec![];
        script
            .serialize(&mut bytes)
            .map_err(|err| anyhow!("Failed to serialize script: {:?}", err))?;

        Ok(bcs::to_bytes(&Script {
            code: bytes,
            ty_args: vec![],
            args: self
                .parameters
                .into_iter()
                .map(TransactionArgument::Serialized)
                .collect(),
        })
        .unwrap())
    }
```

**File:** third_party/move/move-binary-format/src/check_bounds.rs (L467-529)
```rust
    fn check_code(
        &self,
        code_unit: &CodeUnit,
        type_parameters: &[AbilitySet],
        parameters: &Signature,
        index: usize,
    ) -> PartialVMResult<()> {
        check_bounds_impl(self.view.signatures(), code_unit.locals)?;

        let locals = self.get_locals(code_unit)?;
        // Use saturating add for stability
        let locals_count = locals.len().saturating_add(parameters.len());

        if locals_count > LocalIndex::MAX as usize {
            return Err(verification_error(
                StatusCode::TOO_MANY_LOCALS,
                IndexKind::FunctionDefinition,
                index as TableIndex,
            ));
        }

        // if there are locals check that the type parameters in local signature are in bounds.
        let type_param_count = type_parameters.len();
        self.check_type_parameters_in_signature(code_unit.locals, type_param_count)?;

        // check bytecodes
        let code_len = code_unit.code.len();
        for (bytecode_offset, bytecode) in code_unit.code.iter().enumerate() {
            use self::Bytecode::*;

            match bytecode {
                LdConst(idx) => self.check_code_unit_bounds_impl(
                    self.view.constant_pool(),
                    *idx,
                    bytecode_offset,
                )?,
                MutBorrowField(idx) | ImmBorrowField(idx) => self.check_code_unit_bounds_impl_opt(
                    &self.view.field_handles(),
                    *idx,
                    bytecode_offset,
                )?,
                MutBorrowVariantField(idx) | ImmBorrowVariantField(idx) => self
                    .check_code_unit_bounds_impl_opt(
                        &self.view.variant_field_handles(),
                        *idx,
                        bytecode_offset,
                    )?,
                MutBorrowFieldGeneric(idx) | ImmBorrowFieldGeneric(idx) => {
                    self.check_code_unit_bounds_impl_opt(
                        &self.view.field_instantiations(),
                        *idx,
                        bytecode_offset,
                    )?;
                    if let Some(field_inst) = self
                        .view
                        .field_instantiations()
                        .and_then(|f| f.get(idx.into_index()))
                    {
                        self.check_type_parameters_in_signature(
                            field_inst.type_parameters,
                            type_param_count,
                        )?;
                    }
```
