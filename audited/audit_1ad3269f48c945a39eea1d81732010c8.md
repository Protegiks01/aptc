# Audit Report

## Title
Orderless Account Abstraction Transactions Bypass Account Existence Validation

## Summary
Orderless transactions with account abstraction (AA) bypass the critical account existence check that regular transactions must pass, while simultaneously being excluded from sponsored automatic account creation. This allows transactions for non-existent accounts to pass prologue validation but fail during execution, consuming nonces and charging gas without productive outcome.

## Finding Description

The vulnerability exists in the transaction validation prologue where orderless AA transactions follow a different validation path than regular transactions.

**For Regular Transactions with Sequence Numbers:**
The `check_for_replay_protection_regular_txn()` function enforces account existence validation. [1](#0-0) 

This function explicitly checks `account::exists_at(sender_address)` (with limited exceptions for sponsored account creation at sequence number 0).

**For Orderless Transactions with Nonces:**
The `check_for_replay_protection_orderless_txn()` function completely omits the account existence check. [2](#0-1) 

This function only validates nonce uniqueness and expiration time constraints, but never verifies that the sender account exists.

**For Derivable Account Abstraction:**
The `allow_missing_txn_authentication_key()` function permits AA transactions to skip authentication key checks. [3](#0-2) 

When derivable AA is enabled, transactions can proceed without authentication key validation, relying solely on the nonce check for orderless transactions.

**Sponsored Account Creation Limitation:**
The `should_create_account_resource()` function explicitly requires `SequenceNumber(0)` to trigger automatic account creation. [4](#0-3) 

This means orderless transactions (which use `ReplayProtector::Nonce(nonce)`) cannot benefit from sponsored automatic account creation, even when the feature flag is enabled.

**Exploitation Path:**

1. **Address Computation:** For derivable AA, addresses are deterministically derived from `function_info` and `abstract_public_key`. [5](#0-4) 

2. **Transaction Submission:** An attacker (or legitimate user by mistake) creates an orderless AA transaction for a non-existent account using `sign_aa_transaction_with_transaction_builder()`. [6](#0-5) 

When `builder.has_nonce()` returns true, the sequence number is set to `u64::MAX` and the transaction becomes orderless.

3. **Prologue Validation:** The transaction passes through `prologue_common()` which routes to `check_for_replay_protection_orderless_txn()`. [7](#0-6) 

The orderless path (line 178-184) only checks nonce validity, not account existence.

4. **Nonce Consumption:** The nonce is inserted into the global `NonceHistory` resource. [8](#0-7) 

5. **Execution Failure:** During execution, operations on the non-existent account fail, but the nonce remains consumed and gas is charged.

## Impact Explanation

This vulnerability represents a **High Severity** issue according to Aptos bug bounty criteria as it constitutes a **significant protocol violation**:

1. **Broken Invariant:** Violates Transaction Validation Invariant #7 ("Prologue/epilogue checks must enforce all invariants"), specifically the account existence requirement that regular transactions must satisfy.

2. **Resource Wastage:** Legitimate users can inadvertently waste gas and consume nonces by submitting orderless transactions for non-yet-created accounts, expecting the same sponsored account creation behavior as regular transactions.

3. **Nonce Exhaustion Attack:** Malicious actors can compute derivable AA addresses for victims and submit orderless transactions to consume nonces before the legitimate account is created, though the large nonce space (2^64) and 100-second expiration limit the practical impact.

4. **Protocol Inconsistency:** Creates an asymmetry where regular transactions with `sequence_number=0` can trigger account creation but orderless transactions cannot, violating user expectations of feature parity.

5. **Deterministic Execution Risk:** Different validator nodes could potentially reach inconsistent states if some have the account created through other means while processing these transactions.

## Likelihood Explanation

**High Likelihood** of occurrence because:

1. **Legitimate Use Case:** Users may naturally attempt to use orderless AA transactions for account creation, expecting the same behavior as regular transactions with sponsored account creation.

2. **Derivable AA Design:** The deterministic address derivation for derivable AA encourages computing addresses before account creation, making this scenario common.

3. **Documentation Gap:** No explicit warning exists that orderless transactions cannot benefit from sponsored account creation.

4. **Easy to Trigger:** Requires no special privilegesâ€”any user can create and submit orderless AA transactions through the standard SDK.

## Recommendation

**Fix 1: Add Account Existence Check for Orderless Transactions**

Modify `check_for_replay_protection_orderless_txn()` to include account existence validation:

```move
fun check_for_replay_protection_orderless_txn(
    sender: address,
    nonce: u64,
    txn_expiration_time: u64,
) {
    // Add account existence check for orderless transactions
    // Allow exception only for sponsored account creation with fee payer
    assert!(
        account::exists_at(sender) || features::sponsored_automatic_account_creation_enabled(),
        error::invalid_argument(PROLOGUE_EACCOUNT_DOES_NOT_EXIST)
    );
    
    assert!(
        txn_expiration_time <= timestamp::now_seconds() + MAX_EXP_TIME_SECONDS_FOR_ORDERLESS_TXNS,
        error::invalid_argument(PROLOGUE_ETRANSACTION_EXPIRATION_TOO_FAR_IN_FUTURE),
    );
    assert!(nonce_validation::check_and_insert_nonce(sender, nonce, txn_expiration_time), error::invalid_argument(PROLOGUE_ENONCE_ALREADY_USED));
}
```

**Fix 2: Extend Sponsored Account Creation to Orderless Transactions**

Modify `should_create_account_resource()` to support orderless transactions:

```rust
pub(crate) fn should_create_account_resource(
    txn_data: &TransactionMetadata,
    features: &Features,
    resolver: &impl AptosMoveResolver,
    module_storage: &impl ModuleStorage,
) -> VMResult<bool> {
    let should_check = if features.is_enabled(FeatureFlag::DEFAULT_ACCOUNT_RESOURCE) {
        true
    } else if features.is_enabled(FeatureFlag::SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION)
        && txn_data.fee_payer.is_some()
    {
        // Allow both sequence number 0 and orderless transactions for sponsored creation
        match txn_data.replay_protector {
            ReplayProtector::SequenceNumber(0) => true,
            ReplayProtector::Nonce(_) => true, // Add support for orderless
            _ => false,
        }
    } else {
        false
    };

    if should_check {
        // ... rest of function unchanged
    }
    Ok(false)
}
```

## Proof of Concept

```move
#[test(framework = @aptos_framework, user = @0x123)]
fun test_orderless_aa_nonexistent_account_bypass(framework: &signer, user: &signer) {
    use aptos_framework::timestamp;
    use aptos_framework::transaction_validation;
    use aptos_framework::nonce_validation;
    use aptos_framework::account_abstraction;
    use std::features;
    
    // Setup
    timestamp::set_time_has_started_for_testing(framework);
    nonce_validation::initialize_nonce_table(framework);
    features::change_feature_flags_for_testing(framework, 
        vector[features::get_derivable_account_abstraction_feature()], 
        vector[]
    );
    
    // Compute derivable AA address for non-existent account
    let function_info = function_info::new_function_info_from_address(
        @aptos_framework,
        string::utf8(b"test_module"),
        string::utf8(b"test_function")
    );
    let abstract_pubkey = vector[0x01, 0x02, 0x03];
    let aa_address = account_abstraction::derive_account_address(function_info, &abstract_pubkey);
    
    // Verify account does NOT exist
    assert!(!account::exists_at(aa_address), 0);
    
    // Create orderless transaction for non-existent account
    let nonce = 12345u64;
    let expiration_time = timestamp::now_seconds() + 50;
    
    // This should FAIL but currently PASSES - demonstrating the vulnerability
    let result = nonce_validation::check_and_insert_nonce(aa_address, nonce, expiration_time);
    
    // Nonce gets inserted for non-existent account!
    assert!(result == true, 1);
    
    // Account still doesn't exist but nonce is consumed
    assert!(!account::exists_at(aa_address), 2);
    
    // Attempting to use the same nonce again fails (nonce consumed)
    let result2 = nonce_validation::check_and_insert_nonce(aa_address, nonce, expiration_time + 1);
    assert!(result2 == false, 3); // Nonce already used!
}
```

## Notes

This vulnerability demonstrates a fundamental inconsistency in how Aptos handles orderless versus regular transactions in the account creation flow. The security impact is heightened for derivable AA accounts where addresses can be computed deterministically before account creation, making this scenario particularly common. The fix should either enforce account existence checks for orderless transactions or extend sponsored account creation support to include orderless transactions, ensuring feature parity across both transaction types.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L120-124)
```text
    inline fun allow_missing_txn_authentication_key(transaction_sender: address): bool {
        // aa verifies authentication itself
        features::is_derivable_account_abstraction_enabled()
            || (features::is_account_abstraction_enabled() && account_abstraction::using_dispatchable_authenticator(transaction_sender))
    }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L126-213)
```text
    fun prologue_common(
        sender: &signer,
        gas_payer: &signer,
        replay_protector: ReplayProtector,
        txn_authentication_key: Option<vector<u8>>,
        txn_gas_price: u64,
        txn_max_gas_units: u64,
        txn_expiration_time: u64,
        chain_id: u8,
        is_simulation: bool,
    ) {
        let sender_address = signer::address_of(sender);
        let gas_payer_address = signer::address_of(gas_payer);
        assert!(
            timestamp::now_seconds() < txn_expiration_time,
            error::invalid_argument(PROLOGUE_ETRANSACTION_EXPIRED),
        );
        assert!(chain_id::get() == chain_id, error::invalid_argument(PROLOGUE_EBAD_CHAIN_ID));

        // TODO[Orderless]: Here, we are maintaining the same order of validation steps as before orderless txns were introduced.
        // Ideally, do the replay protection check in the end after the authentication key check and gas payment checks.

        // Check if the authentication key is valid
        if (!skip_auth_key_check(is_simulation, &txn_authentication_key)) {
            if (option::is_some(&txn_authentication_key)) {
                if (
                    sender_address == gas_payer_address ||
                    account::exists_at(sender_address) ||
                    !features::sponsored_automatic_account_creation_enabled()
                ) {
                    assert!(
                        txn_authentication_key == option::some(account::get_authentication_key(sender_address)),
                        error::invalid_argument(PROLOGUE_EINVALID_ACCOUNT_AUTH_KEY),
                    );
                };
            } else {
                assert!(
                    allow_missing_txn_authentication_key(sender_address),
                    error::invalid_argument(PROLOGUE_EINVALID_ACCOUNT_AUTH_KEY)
                );
            };
        };

        // Check for replay protection
        match (replay_protector) {
            SequenceNumber(txn_sequence_number) => {
                check_for_replay_protection_regular_txn(
                    sender_address,
                    gas_payer_address,
                    txn_sequence_number,
                );
            },
            Nonce(nonce) => {
                check_for_replay_protection_orderless_txn(
                    sender_address,
                    nonce,
                    txn_expiration_time,
                );
            }
        };

        // Check if the gas payer has enough balance to pay for the transaction
        let max_transaction_fee = txn_gas_price * txn_max_gas_units;
        if (!skip_gas_payment(
            is_simulation,
            gas_payer_address
        )) {
            assert!(
                permissioned_signer::check_permission_capacity_above(
                    gas_payer,
                    (max_transaction_fee as u256),
                    GasPermission {}
                ),
                error::permission_denied(PROLOGUE_PERMISSIONED_GAS_LIMIT_INSUFFICIENT)
            );
            if (features::operations_default_to_fa_apt_store_enabled()) {
                assert!(
                    aptos_account::is_fungible_balance_at_least(gas_payer_address, max_transaction_fee),
                    error::invalid_argument(PROLOGUE_ECANT_PAY_GAS_DEPOSIT)
                );
            } else {
                assert!(
                    coin::is_balance_at_least<AptosCoin>(gas_payer_address, max_transaction_fee),
                    error::invalid_argument(PROLOGUE_ECANT_PAY_GAS_DEPOSIT)
                );
            }
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L215-250)
```text
    fun check_for_replay_protection_regular_txn(
        sender_address: address,
        gas_payer_address: address,
        txn_sequence_number: u64,
    ) {
        if (
            sender_address == gas_payer_address
                || account::exists_at(sender_address)
                || !features::sponsored_automatic_account_creation_enabled()
                || txn_sequence_number > 0
        ) {
            assert!(account::exists_at(sender_address), error::invalid_argument(PROLOGUE_EACCOUNT_DOES_NOT_EXIST));
            let account_sequence_number = account::get_sequence_number(sender_address);
            assert!(
                txn_sequence_number < (1u64 << 63),
                error::out_of_range(PROLOGUE_ESEQUENCE_NUMBER_TOO_BIG)
            );

            assert!(
                txn_sequence_number >= account_sequence_number,
                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_OLD)
            );

            assert!(
                txn_sequence_number == account_sequence_number,
                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_NEW)
            );
        } else {
            // In this case, the transaction is sponsored and the account does not exist, so ensure
            // the default values match.
            assert!(
                txn_sequence_number == 0,
                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_NEW)
            );
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L252-263)
```text
    fun check_for_replay_protection_orderless_txn(
        sender: address,
        nonce: u64,
        txn_expiration_time: u64,
    ) {
        // prologue_common already checks that the current_time > txn_expiration_time
        assert!(
            txn_expiration_time <= timestamp::now_seconds() + MAX_EXP_TIME_SECONDS_FOR_ORDERLESS_TXNS,
            error::invalid_argument(PROLOGUE_ETRANSACTION_EXPIRATION_TOO_FAR_IN_FUTURE),
        );
        assert!(nonce_validation::check_and_insert_nonce(sender, nonce, txn_expiration_time), error::invalid_argument(PROLOGUE_ENONCE_ALREADY_USED));
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3451-3484)
```rust
pub(crate) fn should_create_account_resource(
    txn_data: &TransactionMetadata,
    features: &Features,
    resolver: &impl AptosMoveResolver,
    module_storage: &impl ModuleStorage,
) -> VMResult<bool> {
    if (features.is_enabled(FeatureFlag::DEFAULT_ACCOUNT_RESOURCE)
        || (features.is_enabled(FeatureFlag::SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION)
            && txn_data.fee_payer.is_some()))
        && txn_data.replay_protector == ReplayProtector::SequenceNumber(0)
    {
        let account_tag = AccountResource::struct_tag();

        // INVARIANT:
        //   Account lives at a special address, so we should not be charging for it and unmetered
        //   access is safe. There are tests that ensure that address is always special.
        assert!(account_tag.address.is_special());
        let module = module_storage.unmetered_get_existing_deserialized_module(
            &account_tag.address,
            &account_tag.module,
        )?;

        let (maybe_bytes, _) = resolver
            .get_resource_bytes_with_metadata_and_layout(
                &txn_data.sender(),
                &account_tag,
                &module.metadata,
                None,
            )
            .map_err(|e| e.finish(Location::Undefined))?;
        return Ok(maybe_bytes.is_none());
    }
    Ok(false)
}
```

**File:** aptos-move/framework/aptos-framework/sources/account/account_abstraction.move (L110-118)
```text
    public fun derive_account_address(derivable_func_info: FunctionInfo, abstract_public_key: &vector<u8>): address {
        // using bcs serialized structs here - this allows for no need for separators.
        // Alternative would've been to create unique string, we would need to convert derivable_func_info into string,
        // then authentication_key to hex, and then we need separators as well - like ::
        let bytes = bcs::to_bytes(&derivable_func_info);
        bytes.append(bcs::to_bytes(abstract_public_key));
        bytes.push_back(DERIVABLE_ABSTRACTION_DERIVED_SCHEME);
        from_bcs::to_address(hash::sha3_256(bytes))
    }
```

**File:** sdk/src/types.rs (L444-475)
```rust
    pub fn sign_aa_transaction_with_transaction_builder(
        &self,
        secondary_signers: Vec<&Self>,
        fee_payer_signer: Option<&Self>,
        builder: TransactionBuilder,
    ) -> SignedTransaction {
        let secondary_signer_addresses = secondary_signers
            .iter()
            .map(|signer| signer.address())
            .collect();
        let secondary_signer_auths = secondary_signers.iter().map(|a| a.auth()).collect();
        let raw_txn = if builder.has_nonce() {
            builder
                .sender(self.address())
                .sequence_number(u64::MAX)
                .build()
        } else {
            builder
                .sender(self.address())
                .sequence_number(self.increment_sequence_number())
                .build()
        };
        raw_txn
            .sign_aa_transaction(
                self.auth(),
                secondary_signer_addresses,
                secondary_signer_auths,
                fee_payer_signer.map(|fee_payer| (fee_payer.address(), fee_payer.auth())),
            )
            .expect("Signing aa txn failed")
            .into_inner()
    }
```

**File:** aptos-move/framework/aptos-framework/sources/nonce_validation.move (L129-204)
```text
    public(friend) fun check_and_insert_nonce(
        sender_address: address,
        nonce: u64,
        txn_expiration_time: u64,
    ): bool acquires NonceHistory {
        assert!(exists<NonceHistory>(@aptos_framework), error::invalid_state(E_NONCE_HISTORY_DOES_NOT_EXIST));
        // Check if the transaction expiration time is too far in the future.
        assert!(txn_expiration_time <= timestamp::now_seconds() + NONCE_REPLAY_PROTECTION_OVERLAP_INTERVAL_SECONDS, error::invalid_argument(ETRANSACTION_EXPIRATION_TOO_FAR_IN_FUTURE));
        let nonce_history = &mut NonceHistory[@aptos_framework];
        let nonce_key = NonceKey {
            sender_address,
            nonce,
        };
        let bucket_index = sip_hash_from_value(&nonce_key) % NUM_BUCKETS;
        let current_time = timestamp::now_seconds();
        if (!nonce_history.nonce_table.contains(bucket_index)) {
            nonce_history.nonce_table.add(
                bucket_index,
                empty_bucket(false)
            );
        };
        let bucket = table::borrow_mut(&mut nonce_history.nonce_table, bucket_index);

        let existing_exp_time = bucket.nonce_to_exp_time_map.get(&nonce_key);
        if (existing_exp_time.is_some()) {
            let existing_exp_time = existing_exp_time.extract();

            // If the existing (address, nonce) pair has not expired, return false.
            if (existing_exp_time >= current_time) {
                return false;
            };

            // We maintain an invariant that two transaction with the same (address, nonce) pair cannot be stored
            // in the nonce history if their transaction expiration times are less than `NONCE_REPLAY_PROTECTION_OVERLAP_INTERVAL_SECONDS`
            // seconds apart.
            if (txn_expiration_time <= existing_exp_time + NONCE_REPLAY_PROTECTION_OVERLAP_INTERVAL_SECONDS) {
                return false;
            };

            // If the existing (address, nonce) pair has expired, garbage collect it.
            bucket.nonce_to_exp_time_map.remove(&nonce_key);
            bucket.nonces_ordered_by_exp_time.remove(&NonceKeyWithExpTime {
                txn_expiration_time: existing_exp_time,
                sender_address,
                nonce,
            });
        };

        // Garbage collect upto MAX_ENTRIES_GARBAGE_COLLECTED_PER_CALL expired nonces in the bucket.
        let i = 0;
        while (i < MAX_ENTRIES_GARBAGE_COLLECTED_PER_CALL && !bucket.nonces_ordered_by_exp_time.is_empty()) {
            let (front_k, _) = bucket.nonces_ordered_by_exp_time.borrow_front();
            // We garbage collect a nonce after it has expired and the NONCE_REPLAY_PROTECTION_OVERLAP_INTERVAL_SECONDS
            // seconds have passed.
            if (front_k.txn_expiration_time + NONCE_REPLAY_PROTECTION_OVERLAP_INTERVAL_SECONDS < current_time) {
                bucket.nonces_ordered_by_exp_time.pop_front();
                bucket.nonce_to_exp_time_map.remove(&NonceKey {
                    sender_address: front_k.sender_address,
                    nonce: front_k.nonce,
                });
            } else {
                break;
            };
            i = i + 1;
        };

        // Insert the (address, nonce) pair in the bucket.
        let nonce_key_with_exp_time = NonceKeyWithExpTime {
            txn_expiration_time,
            sender_address,
            nonce,
        };
        bucket.nonces_ordered_by_exp_time.add(nonce_key_with_exp_time, true);
        bucket.nonce_to_exp_time_map.add(nonce_key, txn_expiration_time);
        true
    }
```
