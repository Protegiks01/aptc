# Audit Report

## Title
Race Condition in Speculative State Initialization Causes Epoch Verification Failures and Node Sync Liveness Issues

## Summary
The `initialize_active_data_stream()` function in `ContinuousSyncer` performs two non-atomic reads from storage to fetch `highest_synced_version` and `highest_epoch_state`. When storage is updated between these reads (especially during epoch transitions), `SpeculativeStreamState` is initialized with inconsistent values—a version from one epoch paired with the validator set from a different epoch. This causes subsequent ledger info verification to fail with epoch mismatch errors, forcing stream resets and preventing the node from making forward progress during epoch boundaries. [1](#0-0) 

## Finding Description
The vulnerability exists in how `SpeculativeStreamState` is initialized. The function makes two separate storage reads:

1. **First read** (via `get_highest_synced_version_and_epoch()`): Fetches `highest_synced_version` and `highest_synced_epoch` [2](#0-1) 

2. **Second read** (direct call to `fetch_latest_epoch_state()`): Fetches `highest_epoch_state` [3](#0-2) 

Between these reads, another component (storage synchronizer) can commit transactions that cross an epoch boundary. The `get_latest_epoch_state()` implementation returns the **next epoch's state** when the latest ledger info contains `next_epoch_state`: [4](#0-3) 

**Race Condition Scenario:**
- **T1**: `fetch_pre_committed_version()` returns version 999 (end of epoch 5)
- **T2**: Storage commits epoch-ending transaction at version 1000 (has `next_epoch_state` for epoch 6)
- **T3**: `fetch_latest_epoch_state()` now returns epoch 6's validator set
- **T4**: `SpeculativeStreamState::new()` is called with `synced_version=999` (epoch 5) and `epoch_state=epoch_6`

When data for version 1000 arrives, its ledger info has epoch 5, but verification uses epoch 6's validator set. The `EpochState::verify()` function strictly enforces epoch equality: [5](#0-4) 

The verification fails at the epoch check, causing the stream to reset with `PayloadProofFailed` feedback: [6](#0-5) 

The same vulnerability exists in the `Bootstrapper` component, which follows an identical pattern of fetching the version early and the epoch state later: [7](#0-6) [8](#0-7) 

## Impact Explanation
This is a **HIGH severity** vulnerability per Aptos bug bounty criteria for the following reasons:

1. **Validator Node Slowdowns**: Repeated stream resets and reinitializations during epoch transitions cause significant performance degradation
2. **Liveness Impact**: Nodes cannot make forward sync progress during epoch boundaries if the race condition occurs repeatedly
3. **Protocol Violation**: Legitimate ledger infos are rejected due to implementation bug, not malicious behavior

The impact is particularly severe because:
- Epoch transitions are critical synchronization points in Aptos
- All validators must successfully cross epoch boundaries to maintain consensus
- High transaction load increases the likelihood of this race condition
- No automatic recovery mechanism exists beyond retry (which can hit the same race)

## Likelihood Explanation
**Likelihood: Medium to High** during epoch transitions.

**Triggering Conditions:**
- Occurs naturally during epoch boundary transactions
- More likely under high transaction throughput when storage commits happen rapidly
- Affects both full nodes and validators attempting to sync
- No attacker interaction required—this is a timing bug in normal operation

**Frequency Factors:**
- Epoch transitions happen regularly (based on governance configuration)
- The race window is small but real (between two storage reads)
- Modern multi-core systems with concurrent storage operations increase probability
- Under load, storage synchronizer commits can occur at any time

## Recommendation
**Fix: Perform atomic read of version and epoch state, or add consistency validation.**

**Option 1 - Single Atomic Read (Preferred):**
Create a new storage method that atomically reads both the pre-committed version and corresponding epoch state in a single operation, ensuring consistency.

**Option 2 - Add Consistency Validation:**
After fetching both values, verify they are consistent by checking if the epoch state's epoch matches the expected epoch for the given version. If inconsistent, retry the reads.

**Option 3 - Use Same Storage Snapshot:**
Refactor to use a single call that returns both values from the same storage snapshot, eliminating the race window.

**Example Fix for Option 2:**
```rust
async fn initialize_active_data_stream(
    &mut self,
    consensus_sync_request: Arc<Mutex<Option<ConsensusSyncRequest>>>,
) -> Result<(), Error> {
    self.storage_synchronizer.reset_chunk_executor()?;

    // Loop to handle race conditions
    let (highest_synced_version, highest_epoch_state) = loop {
        let (version, epoch_num) = self.get_highest_synced_version_and_epoch()?;
        let epoch_state = utils::fetch_latest_epoch_state(self.storage.clone())?;
        
        // Verify consistency: re-read version to ensure epoch_state is still valid
        let (recheck_version, recheck_epoch) = self.get_highest_synced_version_and_epoch()?;
        
        // If version or epoch changed, retry
        if version == recheck_version && epoch_num == recheck_epoch {
            break (version, epoch_state);
        }
        // Otherwise loop and retry
    };

    // Rest of initialization...
}
```

## Proof of Concept
```rust
// Rust test demonstrating the race condition
#[tokio::test]
async fn test_epoch_state_race_condition() {
    // Setup: Create storage at version 999, end of epoch 5
    let storage = create_test_storage_at_epoch_boundary();
    let syncer = create_continuous_syncer(storage.clone());
    
    // Thread 1: Start initialization
    let handle1 = tokio::spawn(async move {
        // This will read version 999, epoch 5
        syncer.initialize_active_data_stream(empty_consensus_request()).await
    });
    
    // Thread 2: Commit epoch-ending transaction concurrently
    let handle2 = tokio::spawn(async move {
        // Commit version 1000 with next_epoch_state for epoch 6
        storage.save_transactions(
            create_epoch_ending_txn(version: 1000, next_epoch: 6),
            /* ... */
        ).await.unwrap();
    });
    
    // Wait for both
    handle2.await.unwrap();
    let result = handle1.await.unwrap();
    
    // Expected: SpeculativeStreamState has mismatched epoch
    // When version 1000 data arrives, verification will fail with:
    // "LedgerInfo has unexpected epoch 5, expected 6"
    
    // Verify the error occurs
    let next_data = create_ledger_info_for_version(1000, epoch: 5);
    let verify_result = syncer.verify_proof_ledger_info(next_data).await;
    
    assert!(verify_result.is_err());
    assert!(verify_result.unwrap_err().to_string().contains("unexpected epoch"));
}
```

**Notes:**
- This vulnerability breaks the **State Consistency** invariant by allowing inconsistent state initialization
- It impacts **node liveness** during epoch transitions, a critical blockchain operation
- The same pattern exists in both `ContinuousSyncer` and `Bootstrapper`, doubling the attack surface
- No malicious actor required—occurs naturally under concurrent operations during epoch changes
- Error message "LedgerInfo has unexpected epoch {}, expected {}" would appear in validator logs when this occurs

### Citations

**File:** state-sync/state-sync-driver/src/continuous_syncer.rs (L100-180)
```rust
    async fn initialize_active_data_stream(
        &mut self,
        consensus_sync_request: Arc<Mutex<Option<ConsensusSyncRequest>>>,
    ) -> Result<(), Error> {
        // Reset the chunk executor to flush any invalid state currently held in-memory
        self.storage_synchronizer.reset_chunk_executor()?;

        // Fetch the highest synced version and epoch (in storage)
        let (highest_synced_version, highest_synced_epoch) =
            self.get_highest_synced_version_and_epoch()?;

        // Fetch the highest epoch state (in storage)
        let highest_epoch_state = utils::fetch_latest_epoch_state(self.storage.clone())?;

        // Fetch the consensus sync request target (if there is one)
        let sync_request_target = consensus_sync_request
            .lock()
            .as_ref()
            .and_then(|sync_request| sync_request.get_sync_target());

        // Initialize a new active data stream
        let active_data_stream = match self.get_continuous_syncing_mode() {
            ContinuousSyncingMode::ApplyTransactionOutputs => {
                self.streaming_client
                    .continuously_stream_transaction_outputs(
                        highest_synced_version,
                        highest_synced_epoch,
                        sync_request_target,
                    )
                    .await?
            },
            ContinuousSyncingMode::ExecuteTransactions => {
                self.streaming_client
                    .continuously_stream_transactions(
                        highest_synced_version,
                        highest_synced_epoch,
                        false,
                        sync_request_target,
                    )
                    .await?
            },
            ContinuousSyncingMode::ExecuteTransactionsOrApplyOutputs => {
                if self.output_fallback_handler.in_fallback_mode() {
                    metrics::set_gauge(
                        &metrics::DRIVER_FALLBACK_MODE,
                        ExecutingComponent::ContinuousSyncer.get_label(),
                        1,
                    );
                    self.streaming_client
                        .continuously_stream_transaction_outputs(
                            highest_synced_version,
                            highest_synced_epoch,
                            sync_request_target,
                        )
                        .await?
                } else {
                    metrics::set_gauge(
                        &metrics::DRIVER_FALLBACK_MODE,
                        ExecutingComponent::ContinuousSyncer.get_label(),
                        0,
                    );
                    self.streaming_client
                        .continuously_stream_transactions_or_outputs(
                            highest_synced_version,
                            highest_synced_epoch,
                            false,
                            sync_request_target,
                        )
                        .await?
                }
            },
        };
        self.speculative_stream_state = Some(SpeculativeStreamState::new(
            highest_epoch_state,
            None,
            highest_synced_version,
        ));
        self.active_data_stream = Some(active_data_stream);

        Ok(())
    }
```

**File:** state-sync/state-sync-driver/src/continuous_syncer.rs (L452-462)
```rust
        // Verify the ledger info state and signatures
        if let Err(error) = self
            .get_speculative_stream_state()?
            .verify_ledger_info_with_signatures(ledger_info_with_signatures)
        {
            self.reset_active_stream(Some(NotificationAndFeedback::new(
                notification_id,
                NotificationFeedback::PayloadProofFailed,
            )))
            .await?;
            Err(error)
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L696-706)
```rust
    fn get_latest_epoch_state(&self) -> Result<EpochState> {
        gauged_api("get_latest_epoch_state", || {
            let latest_ledger_info = self.ledger_db.metadata_db().get_latest_ledger_info()?;
            match latest_ledger_info.ledger_info().next_epoch_state() {
                Some(epoch_state) => Ok(epoch_state.clone()),
                None => self
                    .ledger_db
                    .metadata_db()
                    .get_epoch_state(latest_ledger_info.ledger_info().epoch()),
            }
        })
```

**File:** types/src/epoch_state.rs (L41-50)
```rust
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> anyhow::Result<()> {
        ensure!(
            self.epoch == ledger_info.ledger_info().epoch(),
            "LedgerInfo has unexpected epoch {}, expected {}",
            ledger_info.ledger_info().epoch(),
            self.epoch
        );
        ledger_info.verify_signatures(&self.verifier)?;
        Ok(())
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L468-468)
```rust
        let highest_synced_version = utils::fetch_pre_committed_version(self.storage.clone())?;
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L802-806)
```rust
        self.speculative_stream_state = Some(SpeculativeStreamState::new(
            utils::fetch_latest_epoch_state(self.storage.clone())?,
            Some(highest_known_ledger_info),
            highest_synced_version,
        ));
```
