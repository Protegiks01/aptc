# Audit Report

## Title
Unhandled Panic in `choose_leader()` Causes Validator Initialization Failure During Fixed Proposer Election

## Summary

The `choose_leader()` function in `consensus/src/liveness/rotating_proposer_election.rs` panics with "No trusted peers found!" when provided an empty peers vector. This function is called during critical consensus initialization when `ProposerElectionType::FixedProposer` is configured. If the validator set is empty or becomes corrupted during epoch transition, the panic causes the validator node to fail initialization, resulting in loss of liveness for that validator.

## Finding Description

The vulnerability exists in the `choose_leader()` function which lacks input validation: [1](#0-0) 

This function is invoked during epoch initialization in the `create_proposer_election()` method when the on-chain consensus configuration specifies `ProposerElectionType::FixedProposer`: [2](#0-1) 

The proposers vector is populated from the epoch state's validator verifier: [3](#0-2) 

The `create_proposer_election()` function is called during `start_round_manager()`, which is part of the critical consensus initialization path: [4](#0-3) 

**Attack Vector:**

While an empty validator set is unlikely in normal operation, the codebase explicitly supports this edge case through `ValidatorSet::empty()` and `EpochState::empty()` functions: [5](#0-4) [6](#0-5) 

The `ValidatorVerifier` also handles empty validator lists by setting quorum to 0: [7](#0-6) 

This indicates the system should gracefully handle empty validator sets rather than panicking.

**Breaking Invariant:**

This vulnerability breaks the **Consensus Liveness** invariant - validators must be able to start and participate in consensus even in degraded or edge-case scenarios. The unhandled panic prevents graceful error handling and validator recovery.

## Impact Explanation

**Severity: High**

This qualifies as **High Severity** per Aptos bug bounty criteria:
- **Validator node crashes**: The panic during initialization causes complete validator failure to start
- **Significant protocol violations**: Inability to handle edge cases in proposer election violates robust consensus design

**Affected Scenarios:**
1. **Misconfiguration**: Genesis or epoch configuration with empty validator set
2. **State corruption**: Database or state sync issues leading to empty validator data
3. **Upgrade bugs**: Epoch transition logic errors that temporarily empty the validator set
4. **Cascading failures**: If multiple validators hit this condition, network liveness is compromised

Unlike typical panics that might crash during operation, this occurs during **initialization**, preventing the validator from ever becoming operational for the new epoch.

## Likelihood Explanation

**Likelihood: Low to Medium**

While an empty validator set is unlikely in normal production operation, several scenarios make this exploitable:

1. **Genesis misconfiguration**: During initial network setup or testnet deployments
2. **Epoch transition bugs**: Edge cases in validator set updates during epoch changes
3. **State synchronization failures**: Corruption or incomplete state sync leading to missing validator data
4. **On-chain configuration errors**: Malformed governance proposals that inadvertently clear the validator set

The existence of explicit `empty()` functions in the codebase suggests this is a recognized edge case that should be handled defensively rather than causing a panic.

## Recommendation

Add input validation to `choose_leader()` to return a proper error instead of panicking:

```rust
pub fn choose_leader(peers: Vec<Author>) -> Result<Author, anyhow::Error> {
    peers.into_iter().min()
        .ok_or_else(|| anyhow::anyhow!("No trusted peers found - validator set is empty"))
}
```

Update the call site in `create_proposer_election()` to handle the error gracefully:

```rust
ProposerElectionType::FixedProposer(contiguous_rounds) => {
    match choose_leader(proposers.clone()) {
        Ok(proposer) => Arc::new(RotatingProposer::new(vec![proposer], *contiguous_rounds)),
        Err(e) => {
            error!("Failed to choose fixed proposer: {:?}. Falling back to rotating proposer.", e);
            Arc::new(RotatingProposer::new(proposers, *contiguous_rounds))
        }
    }
}
```

Alternatively, add validation at the epoch initialization level to reject empty validator sets before reaching proposer election:

```rust
let proposers = epoch_state
    .verifier
    .get_ordered_account_addresses_iter()
    .collect::<Vec<_>>();

ensure!(
    !proposers.is_empty(),
    "Cannot initialize consensus with empty validator set for epoch {}",
    epoch_state.epoch
);
```

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "No trusted peers found!")]
fn test_choose_leader_panics_on_empty_peers() {
    use crate::liveness::rotating_proposer_election::choose_leader;
    
    // Empty peers vector
    let peers = vec![];
    
    // This will panic with "No trusted peers found!"
    let _leader = choose_leader(peers);
}

#[test]
fn test_epoch_initialization_with_empty_validator_set() {
    use aptos_types::epoch_state::EpochState;
    use aptos_types::on_chain_config::consensus_config::{OnChainConsensusConfig, ProposerElectionType};
    
    // Create empty epoch state (this is explicitly supported by the API)
    let epoch_state = EpochState::empty();
    
    // Create consensus config with FixedProposer election
    let mut consensus_config = OnChainConsensusConfig::default();
    // Set to FixedProposer (normally would be configured on-chain)
    // This would trigger choose_leader() with empty proposers
    
    // When create_proposer_election is called with this configuration:
    // 1. proposers = epoch_state.verifier.get_ordered_account_addresses_iter().collect()
    // 2. proposers will be empty
    // 3. choose_leader(proposers) will panic
    
    assert_eq!(epoch_state.verifier.len(), 0);
}
```

**Notes**

This vulnerability demonstrates a defensive programming gap where edge cases supported by the API (empty validator sets via `ValidatorSet::empty()` and `EpochState::empty()`) are not handled gracefully in the consensus initialization path. While unlikely in normal production operation, the unhandled panic violates robust error handling principles and could cause validator failures during misconfigurations, state corruption, or epoch transition edge cases. The fix should either validate against empty validator sets early in epoch initialization or handle the error gracefully in `choose_leader()` to prevent validator crashes.

### Citations

**File:** consensus/src/liveness/rotating_proposer_election.rs (L20-23)
```rust
pub fn choose_leader(peers: Vec<Author>) -> Author {
    // As it is just a tmp hack function, pick the min PeerId to be a proposer.
    peers.into_iter().min().expect("No trusted peers found!")
}
```

**File:** consensus/src/epoch_manager.rs (L292-304)
```rust
        let proposers = epoch_state
            .verifier
            .get_ordered_account_addresses_iter()
            .collect::<Vec<_>>();
        match &onchain_config.proposer_election_type() {
            ProposerElectionType::RotatingProposer(contiguous_rounds) => {
                Arc::new(RotatingProposer::new(proposers, *contiguous_rounds))
            },
            // We don't really have a fixed proposer!
            ProposerElectionType::FixedProposer(contiguous_rounds) => {
                let proposer = choose_leader(proposers);
                Arc::new(RotatingProposer::new(vec![proposer], *contiguous_rounds))
            },
```

**File:** consensus/src/epoch_manager.rs (L852-854)
```rust
        info!(epoch = epoch, "Create ProposerElection");
        let proposer_election =
            self.create_proposer_election(&epoch_state, &onchain_consensus_config);
```

**File:** types/src/on_chain_config/validator_set.rs (L63-65)
```rust
    pub fn empty() -> Self {
        ValidatorSet::new(Vec::new())
    }
```

**File:** types/src/epoch_state.rs (L32-37)
```rust
    pub fn empty() -> Self {
        Self {
            epoch: 0,
            verifier: Arc::new(ValidatorVerifier::new(vec![])),
        }
    }
```

**File:** types/src/validator_verifier.rs (L206-214)
```rust
    pub fn new(validator_infos: Vec<ValidatorConsensusInfo>) -> Self {
        let total_voting_power = sum_voting_power(&validator_infos);
        let quorum_voting_power = if validator_infos.is_empty() {
            0
        } else {
            total_voting_power * 2 / 3 + 1
        };
        Self::build_index(validator_infos, quorum_voting_power, total_voting_power)
    }
```
