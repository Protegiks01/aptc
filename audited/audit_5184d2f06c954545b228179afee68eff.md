# Audit Report

## Title
Missing Dependency Version Validation in Move Package Build System

## Summary
The Move package dependency resolution system fails to validate that the actual resolved dependency version matches the version declared in `Move.toml`. This allows packages to be built with different dependency versions than specified, potentially including vulnerable versions that bypass intended security patches.

## Finding Description

The Move package build system parses dependency version declarations from `Move.toml` but never validates them against the actual resolved package versions.

**Vulnerable Code Path:** [1](#0-0) 

The dependency version is parsed here but stored without validation. [2](#0-1) 

The `Dependency` struct contains an optional `version` field that represents the declared version. [3](#0-2) 

The `process_dependency` function resolves dependencies but only validates the package name (line 449) and optional digest (lines 456-472). **There is no validation that `dep.version` matches `dep_package.package.version`.**

**Attack Scenario:**

1. A developer declares: `MyDependency = { git = "...", rev = "v1.0.0", version = "2.0.0" }`
2. The git revision actually points to vulnerable version 1.0.0
3. The build system resolves to the vulnerable 1.0.0 code
4. No error occurs because version validation is missing
5. Vulnerable code is compiled and potentially deployed on-chain

## Impact Explanation

This vulnerability falls into the **Medium to Low** severity category as it is a **build-time supply chain issue** rather than a runtime blockchain protocol vulnerability. 

**Why Not Higher Severity:**
- Does NOT affect consensus, VM execution, or state management at runtime
- Does NOT break any of the 10 critical blockchain invariants
- Requires social engineering or developer error to exploit
- Cannot be exploited by transaction senders, validators, or network attackers
- The actual security impact depends on vulnerabilities in the older dependency version

**Actual Impact:**
- Enables accidental or malicious deployment of packages with outdated vulnerable dependencies
- Undermines security patch adoption in the Move ecosystem
- Creates supply chain risk through version mismatch scenarios

This does not meet the **High Severity** criteria which requires "Validator node slowdowns, API crashes, Significant protocol violations" that directly affect blockchain operation.

## Likelihood Explanation

**Likelihood: Low to Medium**

This vulnerability requires one of the following conditions:
1. **Developer Error**: Accidentally specifying wrong version/git revision combinations
2. **Supply Chain Attack**: Malicious dependency maintainer publishing misleading metadata
3. **Configuration Mistakes**: Copy-paste errors in Move.toml files

It cannot be exploited through normal blockchain operations (transactions, consensus, smart contracts). The on-chain deployment validation in `code.move` provides a secondary defense layer by checking upgrade policies, though not versions. [4](#0-3) 

## Recommendation

Add version validation in the `process_dependency` function:

```rust
// After line 448 in resolution_graph.rs
if let Some(declared_version) = &dep.version {
    let actual_version = &dep_package.package.version;
    if declared_version != actual_version {
        bail!(
            "Version mismatch for dependency '{}': declared version {:?} but resolved to version {:?}. \
            Update your Move.toml to match the actual dependency version or fix the git revision/path.",
            dep_name_in_pkg,
            declared_version,
            actual_version
        );
    }
}
```

## Proof of Concept

**Setup malicious scenario:**

```toml
# Move.toml for vulnerable package
[package]
name = "VulnerablePackage"
version = "1.0.0"

[dependencies]
# Declares secure version but points to vulnerable code
TrustedLib = { git = "https://github.com/example/lib", rev = "vulnerable-commit", version = "2.0.0" }
```

**Current Behavior:**
The package builds successfully without warning, using the vulnerable code from `vulnerable-commit` despite declaring version 2.0.0.

**Expected Behavior:**
Build should fail with error: "Version mismatch for dependency 'TrustedLib': declared version (2, 0, 0) but resolved to version (1, 0, 0)."

---

**Note:** While this is a legitimate security concern in the Move package build system, it is **NOT a critical blockchain runtime vulnerability**. It does not affect consensus safety, VM execution, state consistency, or any core blockchain operations. It is primarily a development workflow and supply chain security issue.

### Citations

**File:** third_party/move/tools/move-package/src/source_package/manifest_parser.rs (L329-329)
```rust
            let version = table.remove("version").map(parse_version).transpose()?;
```

**File:** third_party/move/tools/move-package/src/source_package/parsed_manifest.rs (L74-81)
```rust
pub struct Dependency {
    pub local: PathBuf,
    pub subst: Option<Substitution>,
    pub version: Option<Version>,
    pub digest: Option<PackageDigest>,
    pub git_info: Option<GitInfo>,
    pub node_info: Option<CustomDepInfo>,
}
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L419-478)
```rust
    fn process_dependency<W: Write>(
        &mut self,
        dep_name_in_pkg: PackageName,
        dep: Dependency,
        root_path: PathBuf,
        override_std: &Option<StdVersion>,
        writer: &mut W,
    ) -> Result<ResolvingTable> {
        if dep.subst.is_some() {
            bail!("Address substitution/renaming is no longer supported.")
        }

        Self::download_and_update_if_remote(
            dep_name_in_pkg,
            &dep,
            self.build_options.skip_fetch_latest_git_deps,
            writer,
        )?;
        let (dep_package, dep_package_dir) =
            Self::parse_package_manifest(&dep, &dep_name_in_pkg, root_path)
                .with_context(|| format!("While processing dependency '{}'", dep_name_in_pkg))?;
        self.build_resolution_graph(
            dep_package.clone(),
            dep_package_dir,
            false,
            override_std,
            writer,
        )
        .with_context(|| format!("Unable to resolve package dependency '{}'", dep_name_in_pkg))?;

        if dep_name_in_pkg != dep_package.package.name {
            bail!("Name of dependency declared in package '{}' does not match dependency's package name '{}'",
                dep_name_in_pkg,
                dep_package.package.name
            );
        }

        match dep.digest {
            None => (),
            Some(fixed_digest) => {
                let resolved_pkg = self
                    .package_table
                    .get(&dep_name_in_pkg)
                    .context("Unable to find resolved package by name")?;
                if fixed_digest != resolved_pkg.source_digest {
                    bail!(
                        "Source digest mismatch in dependency '{}'. Expected '{}' but got '{}'.",
                        dep_name_in_pkg,
                        fixed_digest,
                        resolved_pkg.source_digest
                    )
                }
            },
        }

        let resolving_dep = &self.package_table[&dep_name_in_pkg];
        let resolution_table = resolving_dep.resolution_table.clone();

        Ok(resolution_table)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L298-344)
```text
    fun check_dependencies(publish_address: address, pack: &PackageMetadata): vector<AllowedDep>
    acquires PackageRegistry {
        let allowed_module_deps = vector::empty();
        let deps = &pack.deps;
        vector::for_each_ref(deps, |dep| {
            let dep: &PackageDep = dep;
            assert!(exists<PackageRegistry>(dep.account), error::not_found(EPACKAGE_DEP_MISSING));
            if (is_policy_exempted_address(dep.account)) {
                // Allow all modules from this address, by using "" as a wildcard in the AllowedDep
                let account: address = dep.account;
                let module_name = string::utf8(b"");
                vector::push_back(&mut allowed_module_deps, AllowedDep { account, module_name });
            } else {
                let registry = borrow_global<PackageRegistry>(dep.account);
                let found = vector::any(&registry.packages, |dep_pack| {
                    let dep_pack: &PackageMetadata = dep_pack;
                    if (dep_pack.name == dep.package_name) {
                        // Check policy
                        assert!(
                            dep_pack.upgrade_policy.policy >= pack.upgrade_policy.policy,
                            error::invalid_argument(EDEP_WEAKER_POLICY)
                        );
                        if (dep_pack.upgrade_policy == upgrade_policy_arbitrary()) {
                            assert!(
                                dep.account == publish_address,
                                error::invalid_argument(EDEP_ARBITRARY_NOT_SAME_ADDRESS)
                            )
                        };
                        // Add allowed deps
                        let account = dep.account;
                        let k = 0;
                        let r = vector::length(&dep_pack.modules);
                        while (k < r) {
                            let module_name = vector::borrow(&dep_pack.modules, k).name;
                            vector::push_back(&mut allowed_module_deps, AllowedDep { account, module_name });
                            k = k + 1;
                        };
                        true
                    } else {
                        false
                    }
                });
                assert!(found, error::not_found(EPACKAGE_DEP_MISSING));
            };
        });
        allowed_module_deps
    }
```
