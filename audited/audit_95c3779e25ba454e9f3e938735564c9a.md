# Audit Report

## Title
WriteSet Validation Bypass During KV-Only Database Restore Enables State Corruption

## Summary
The database restore process with KV-only replay fails to validate that WriteSet hashes match the `state_change_hash` field in TransactionInfo objects. Combined with the use of `init_state_ignoring_summary()` which sets Merkle tree root hashes to `CORRUPTION_SENTINEL`, this allows an attacker who controls backup files to inject arbitrary state changes that bypass all cryptographic validation, leading to state corruption and potential consensus divergence.

## Finding Description

During database restoration with KV-only replay mode, the system bypasses two critical validation layers:

**First Bypass - WriteSet Hash Validation:**

The restore process reads transactions, transaction infos, and write sets from backup files. While it cryptographically verifies that transactions and transaction infos are authentic via accumulator proofs [1](#0-0) , the write sets are kept separate and never validated against the `state_change_hash` field in TransactionInfo.

During normal execution, this validation is mandatory [2](#0-1)  where the state_change_hash represents "the hash value summarizing all changes caused to the world state by this transaction, i.e. hash of the output write set."

However, in the restore flow, write sets are deserialized from backup [3](#0-2)  and passed directly to storage without hash validation. The verification only covers transactions and transaction infos [4](#0-3) , while write sets remain unverified.

**Second Bypass - State Summary Validation:**

The `force_state_version_for_kv_restore()` function calls `init_state_ignoring_summary()` [5](#0-4) , which initializes Sparse Merkle Trees with `CORRUPTION_SENTINEL` placeholder values instead of real root hashes [6](#0-5) .

This bypasses critical assertions in the normal state update flow that would detect corrupted state [7](#0-6) . The assertions explicitly check that root hashes are not `CORRUPTION_SENTINEL` and that version sequences are correct, but these checks are skipped when the state is initialized "ignoring summary."

During KV replay, write sets are applied to state [8](#0-7)  and the corrupted state is set via `set_state_ignoring_summary()`, permanently bypassing Merkle tree validation.

**Attack Scenario:**

1. Attacker compromises backup storage (S3, GCS, local filesystem) or tricks operator into using malicious backup location
2. Attacker modifies write sets in backup files while preserving valid transaction infos and proofs
3. Victim initiates restore with `--replay-from-version` and `--kv-only-replay` flags
4. System verifies transaction infos are authentic (accumulator proofs pass)
5. System applies UNVALIDATED write sets to state, allowing arbitrary state corruption
6. State Merkle tree validation is bypassed via `CORRUPTION_SENTINEL` mechanism
7. Restored node has corrupted state that doesn't match canonical blockchain state

**Broken Invariants:**
- **State Consistency**: "State transitions must be atomic and verifiable via Merkle proofs" - The write sets are applied without verifying their cryptographic commitment (state_change_hash)
- **Deterministic Execution**: "All validators must produce identical state roots for identical blocks" - Corrupted write sets produce different state roots
- **Cryptographic Correctness**: The state_change_hash cryptographic commitment is completely ignored

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under Aptos bug bounty criteria:

**Consensus/Safety Violations:** If multiple validators restore from corrupted backups, they will have divergent state, breaking AptosBFT safety guarantees. Different state roots for identical blocks violate the fundamental consensus requirement of deterministic state transitions.

**Loss of Funds:** Corrupted write sets can modify account balances, ownership records, and resource allocations. For example, changing `0x1::coin::CoinStore<AptosCoin>` resources to increase attacker balances or decrease victim balances.

**State Consistency Violations:** The corrupted state cannot be verified against the committed state_change_hash, permanently compromising the integrity of the Jellyfish Merkle Tree and all subsequent state proofs.

**Non-Recoverable Damage:** Once a node restores with corrupted state and participates in consensus, detecting and recovering from the corruption requires manual intervention and potentially a coordinated network halt, as the node's state root will diverge from honest nodes.

The attack requires only backup storage compromise, not validator key compromise or collusion, making it significantly more accessible than traditional Byzantine attacks.

## Likelihood Explanation

**High Likelihood** due to multiple attack vectors:

1. **Backup Storage Compromise:** Cloud storage misconfigurations, credential leaks, or insider access provide direct manipulation capabilities
2. **Supply Chain Attacks:** Compromised backup tooling or CI/CD pipelines could inject corrupted backups
3. **Social Engineering:** Operators could be tricked into restoring from attacker-controlled locations during disaster recovery
4. **Operational Necessity:** Database restoration is a routine operation for node operators during initial sync, disaster recovery, or hardware migration

The KV-only replay mode is specifically designed for performance optimization during restoration, making it a common operational choice that increases exposure to this vulnerability.

## Recommendation

Implement mandatory WriteSet hash validation during the restore process:

**Code Fix for `storage/backup/backup-cli/src/backup_types/transaction/restore.rs`:**

After loading and verifying the transaction list with proof, add validation that write set hashes match transaction info state change hashes:

```rust
// After line 167 (after txn_list_with_proof.verify())
// Add WriteSet validation
for (write_set, txn_info) in write_sets.iter().zip(txn_infos.iter()) {
    let write_set_hash = CryptoHash::hash(write_set);
    ensure!(
        write_set_hash == txn_info.state_change_hash(),
        "WriteSet hash mismatch at version {}. Expected: {:x}, Got: {:x}",
        manifest.first_version,
        txn_info.state_change_hash(),
        write_set_hash
    );
}
```

**Additional Recommendations:**

1. Remove or restrict the use of `init_state_ignoring_summary()` to only trusted internal contexts
2. Add integrity checks (HMAC/signatures) to backup files themselves
3. Log warnings when `CORRUPTION_SENTINEL` is used in production environments
4. Implement backup file provenance tracking and verification
5. Add monitoring to detect state root divergence across validators

## Proof of Concept

**Step 1: Create Malicious Backup File**

```rust
// Pseudocode for creating corrupted backup
use aptos_types::transaction::{Transaction, TransactionInfo, WriteSet};
use aptos_types::write_set::WriteSetMut;
use aptos_types::state_store::state_key::StateKey;
use aptos_types::state_store::state_value::StateValue;

// Load legitimate backup chunk
let (txns, aux_infos, txn_infos, events, mut write_sets) = 
    load_backup_chunk("legitimate_backup.chunk");

// Corrupt a write set (e.g., modify account balance)
let malicious_key = StateKey::access_path(/* attacker's coin store */);
let malicious_value = StateValue::new_legacy(/* inflated balance */);

write_sets[0] = WriteSetMut::new(vec![(malicious_key, malicious_value)])
    .freeze()
    .unwrap();

// Write corrupted backup (txn_infos remain valid, write_sets are corrupted)
save_backup_chunk("malicious_backup.chunk", 
    txns, aux_infos, txn_infos, events, write_sets);

// Keep the original proof file (it validates transaction_infos, not write_sets)
// The proof will pass verification since transaction_infos are unchanged
```

**Step 2: Restore from Corrupted Backup**

```bash
# Victim restores from attacker-controlled backup location
aptos-db-tool restore bootstrap-db \
    --target-db-dir /opt/aptos/data \
    --ledger-history-start-version 0 \
    --command-adapter-config backup_storage.yaml \
    --replay-from-version 1000000 \
    --kv-only-replay true
```

**Step 3: Verification of Corruption**

```rust
// After restore completes, query state and compare against expected values
let restored_db = AptosDB::open(db_path, false, pruner_config, rocksdb_config)?;
let state_value = restored_db.get_state_value_by_version(&attacker_coin_key, version)?;

// The state value will reflect the corrupted write_set, not the legitimate one
// The state_change_hash in TransactionInfo doesn't match the applied write_set
let expected_hash = txn_info.state_change_hash();
let actual_hash = CryptoHash::hash(&applied_write_set);
assert_ne!(expected_hash, actual_hash); // Demonstrates bypass
```

**Expected Result:** The restored database will contain corrupted state that passes all post-restore checks but diverges from the canonical blockchain state, as the write set hash validation was bypassed during restoration.

---

**Notes:**

This vulnerability exists because the restore optimization path prioritizes performance over security by skipping write set validation. The assumption that backup files are trusted is violated when backup storage is compromised. The combination of missing write set hash validation and Merkle tree summary bypass creates a complete validation failure that allows arbitrary state corruption.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L110-136)
```rust
        let mut write_sets = Vec::new();

        while let Some(record_bytes) = file.read_record_bytes().await? {
            let (txn, aux_info, txn_info, events, write_set): (
                _,
                PersistedAuxiliaryInfo,
                _,
                _,
                WriteSet,
            ) = match manifest.format {
                TransactionChunkFormat::V0 => {
                    let (txn, txn_info, events, write_set) = bcs::from_bytes(&record_bytes)?;
                    (
                        txn,
                        PersistedAuxiliaryInfo::None,
                        txn_info,
                        events,
                        write_set,
                    )
                },
                TransactionChunkFormat::V1 => bcs::from_bytes(&record_bytes)?,
            };
            txns.push(txn);
            persisted_aux_info.push(aux_info);
            txn_infos.push(txn_info);
            event_vecs.push(events);
            write_sets.push(write_set);
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L156-176)
```rust
        // make a `TransactionListWithProof` to reuse its verification code.
        let txn_list_with_proof =
            TransactionListWithProofV2::new(TransactionListWithAuxiliaryInfos::new(
                TransactionListWithProof::new(
                    txns,
                    Some(event_vecs),
                    Some(manifest.first_version),
                    TransactionInfoListWithProof::new(range_proof, txn_infos),
                ),
                persisted_aux_info,
            ));
        txn_list_with_proof.verify(ledger_info.ledger_info(), Some(manifest.first_version))?;
        // and disassemble it to get things back.
        let (txn_list_with_proof, persisted_aux_info) = txn_list_with_proof.into_parts();
        let txns = txn_list_with_proof.transactions;
        let range_proof = txn_list_with_proof
            .proof
            .ledger_info_to_transaction_infos_proof;
        let txn_infos = txn_list_with_proof.proof.transaction_infos;
        let event_vecs = txn_list_with_proof.events.expect("unknown to be Some.");

```

**File:** types/src/transaction/mod.rs (L2041-2042)
```rust
    /// i.e. hash of the output write set.
    state_change_hash: HashValue,
```

**File:** storage/aptosdb/src/backup/restore_handler.rs (L101-103)
```rust
    pub fn force_state_version_for_kv_restore(&self, version: Option<Version>) -> Result<()> {
        self.state_store.init_state_ignoring_summary(version)
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L1209-1210)
```rust
        let hot_smt = SparseMerkleTree::new(*CORRUPTION_SENTINEL);
        let smt = SparseMerkleTree::new(*CORRUPTION_SENTINEL);
```

**File:** storage/storage-interface/src/state_store/state_summary.rs (L92-98)
```rust
        assert_ne!(self.hot_state_summary.root_hash(), *CORRUPTION_SENTINEL);
        assert_ne!(self.global_state_summary.root_hash(), *CORRUPTION_SENTINEL);

        // Persisted must be before or at my version.
        assert!(persisted.next_version() <= self.next_version());
        // Updates must start at exactly my version.
        assert_eq!(updates.first_version(), self.next_version());
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L269-276)
```rust
    if kv_replay && first_version > 0 && state_store.get_usage(Some(first_version - 1)).is_ok() {
        let (ledger_state, _hot_state_updates) = state_store.calculate_state_and_put_updates(
            &StateUpdateRefs::index_write_sets(first_version, write_sets, write_sets.len(), vec![]),
            &mut ledger_db_batch.ledger_metadata_db_batches, // used for storing the storage usage
            state_kv_batches,
        )?;
        // n.b. ideally this is set after the batches are committed
        state_store.set_state_ignoring_summary(ledger_state);
```
