# Audit Report

## Title
Consensus Transaction Deduplication Bypass Enables Block Space Griefing via Gas Price Variants

## Summary

The consensus transaction deduplicator uses `(committed_hash, authenticator)` pairs for final duplicate detection, but `committed_hash` includes the `gas_unit_price` field. This allows multiple transactions with identical content but different gas prices to bypass deduplication, all consuming block space despite only one being executable. An attacker can exploit this to perform a block space griefing attack. [1](#0-0) 

## Finding Description

The `dedup()` function performs two-stage deduplication:

**Stage 1 (Possible Duplicate Detection):** Uses `(sender, replay_protector)` to identify transactions that might be duplicates. [2](#0-1) 

**Stage 2 (Final Deduplication):** Calculates `(committed_hash, authenticator)` for possible duplicates and filters based on unique pairs. [3](#0-2) 

The critical issue is that `committed_hash()` includes the entire `RawTransaction`, which contains `gas_unit_price`: [4](#0-3) [5](#0-4) 

When a `SignedTransaction` is wrapped in `Transaction::UserTransaction`, the hash is computed over all fields including `gas_unit_price`: [6](#0-5) 

**Attack Scenario:**

1. Attacker creates transaction T with `(sender=Alice, sequence_number=5, payload=transfer(Bob,100))`
2. Generates multiple variants: T1 (gas_price=100), T2 (gas_price=200), T3 (gas_price=300)
3. Signs each variant (different signatures since raw transaction hash changes with gas price)
4. Submits T1 to Node A's mempool, T2 to Node B's mempool, T3 to Node C's mempool
5. Each mempool accepts its version independently (no conflict within single mempool)
6. Different validators propose blocks containing different variants
7. During consensus, all three pass Stage 1 (same sender+sequence_number) but pass Stage 2 (different hashes)
8. Block includes [T1, T2, T3], consuming 3Ã— block space
9. During execution: T1 succeeds, T2 and T3 fail with `SEQUENCE_NUMBER_TOO_OLD`

While the mempool has gas price upgrade logic to handle this within a single node: [7](#0-6) 

This protection does NOT apply across multiple nodes in distributed consensus, where the deduplicator is the final defense: [8](#0-7) 

## Impact Explanation

**Severity: Medium**

This vulnerability enables a block space griefing attack with the following impacts:

1. **Resource Exhaustion:** An attacker can submit N variants of the same transaction, all consuming block space despite only one being executable. This wastes:
   - Block capacity (limited by size/gas limits)
   - Validator CPU (processing redundant transactions)
   - Network bandwidth (propagating redundant transactions)

2. **Transaction Censorship:** By filling blocks with self-inflicted failing transactions, the attacker can prevent legitimate users' transactions from being included, causing delays and degraded service.

3. **Unfair Resource Consumption:** The attacker pays gas for N transactions but denies block space for N transactions to other users, while achieving only 1 successful transaction. This violates the resource fairness invariant.

This maps to **Medium Severity** per Aptos bug bounty criteria: "State inconsistencies requiring intervention" and resource exhaustion attacks that degrade network service quality.

## Likelihood Explanation

**Likelihood: High**

This attack is highly feasible because:

1. **No Special Access Required:** Any user can submit transactions to multiple RPC endpoints
2. **Low Technical Complexity:** Creating gas price variants requires only parameter changes
3. **Economically Viable:** While the attacker pays gas for all variants, the cost to disrupt the network and censor other users' transactions may be acceptable for motivated attackers
4. **No Coordination Required:** Attacker operates independently without needing validator collusion
5. **Current Network Topology:** Aptos has multiple public RPC endpoints, making multi-node submission trivial

The only barrier is that the attacker must pay transaction fees, but the disproportionate impact on network resources makes this attack economically rational for griefing purposes.

## Recommendation

Modify the deduplication logic to use `(sender, replay_protector)` as the deduplication key after verifying that transactions are truly duplicates. When multiple transactions share the same `(sender, replay_protector)`, apply a deterministic selection policy such as:

**Option 1 (Preferred):** Keep only the transaction with the highest gas price (incentive-compatible)
**Option 2:** Keep only the first encountered transaction (prevents gaming)

```rust
// Modified dedup logic in txn_hash_and_authenticator_deduper.rs
pub fn dedup(&self, transactions: Vec<SignedTransaction>) -> Vec<SignedTransaction> {
    let mut seen = HashMap::new();
    let mut deduplicated = Vec::new();
    
    for txn in transactions {
        let key = (txn.sender(), txn.replay_protector());
        
        if let Some(existing_txn) = seen.get(&key) {
            // Keep the transaction with higher gas price
            if txn.gas_unit_price() > existing_txn.gas_unit_price() {
                seen.insert(key, txn);
            }
        } else {
            seen.insert(key, txn);
        }
    }
    
    deduplicated = seen.into_values().collect();
    deduplicated
}
```

Alternatively, verify signatures before deduplication to safely use only `(sender, replay_protector)` or `committed_hash` as the deduplication key.

## Proof of Concept

Add this test to `consensus/src/txn_hash_and_authenticator_deduper.rs`:

```rust
#[test]
fn test_same_content_different_gas_price_not_deduped() {
    let deduper = TxnHashAndAuthenticatorDeduper::new();
    
    let sender = Account::new();
    
    // Same sender, same sequence number, same payload
    // Only difference: gas price
    let txn_low_gas = empty_txn(sender.addr, 0, 100)
        .sign(&sender.privkey, sender.pubkey.clone())
        .unwrap()
        .into_inner();
    
    let txn_high_gas = empty_txn(sender.addr, 0, 200)
        .sign(&sender.privkey, sender.pubkey.clone())
        .unwrap()
        .into_inner();
    
    let txns = block(vec![&txn_low_gas, &txn_high_gas]);
    let deduped_txns = deduper.dedup(txns.clone());
    
    // VULNERABILITY: Both transactions pass deduplication
    // despite having identical content except gas price
    assert_eq!(2, deduped_txns.len()); // Both kept!
    assert_eq!(txns, deduped_txns);
    
    // In execution, only one would succeed, the other would fail
    // with SEQUENCE_NUMBER_TOO_OLD, wasting block space
}
```

**Expected Result:** Test passes, demonstrating both transactions bypass deduplication.

**Security Impact:** In production, this allows an attacker to fill blocks with gas price variants of the same transaction, with only one executing successfully while all consume block space.

### Citations

**File:** consensus/src/txn_hash_and_authenticator_deduper.rs (L39-59)
```rust
    fn dedup(&self, transactions: Vec<SignedTransaction>) -> Vec<SignedTransaction> {
        let _timer = TXN_DEDUP_SECONDS.start_timer();
        let mut seen = HashMap::new();
        let mut is_possible_duplicate = false;
        let mut possible_duplicates = vec![false; transactions.len()];
        for (i, txn) in transactions.iter().enumerate() {
            match seen.get(&(txn.sender(), txn.replay_protector())) {
                None => {
                    seen.insert((txn.sender(), txn.replay_protector()), i);
                },
                Some(first_index) => {
                    is_possible_duplicate = true;
                    possible_duplicates[*first_index] = true;
                    possible_duplicates[i] = true;
                },
            }
        }
        if !is_possible_duplicate {
            TXN_DEDUP_FILTERED.observe(0 as f64);
            return transactions;
        }
```

**File:** consensus/src/txn_hash_and_authenticator_deduper.rs (L63-90)
```rust
        let hash_and_authenticators: Vec<_> = possible_duplicates
            .into_par_iter()
            .zip(&transactions)
            .with_min_len(optimal_min_len(num_txns, 48))
            .map(|(need_hash, txn)| match need_hash {
                true => Some((txn.committed_hash(), txn.authenticator())),
                false => None,
            })
            .collect();

        // TODO: Possibly parallelize. See struct comment.
        let mut seen_hashes = HashSet::new();
        let mut num_duplicates: usize = 0;
        let filtered: Vec<_> = hash_and_authenticators
            .into_iter()
            .zip(transactions)
            .filter_map(|(maybe_hash, txn)| match maybe_hash {
                None => Some(txn),
                Some(hash_and_authenticator) => {
                    if seen_hashes.insert(hash_and_authenticator) {
                        Some(txn)
                    } else {
                        num_duplicates += 1;
                        None
                    }
                },
            })
            .collect();
```

**File:** types/src/transaction/mod.rs (L176-205)
```rust
#[derive(
    Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash,
)]
pub struct RawTransaction {
    /// Sender's address.
    sender: AccountAddress,

    /// Sequence number of this transaction. This must match the sequence number
    /// stored in the sender's account at the time the transaction executes.
    sequence_number: u64,

    /// The transaction payload, e.g., a script to execute.
    payload: TransactionPayload,

    /// Maximal total gas to spend for this transaction.
    max_gas_amount: u64,

    /// Price to be paid per gas unit.
    gas_unit_price: u64,

    /// Expiration timestamp for this transaction, represented
    /// as seconds from the Unix Epoch. If the current blockchain timestamp
    /// is greater than or equal to this time, then the transaction has
    /// expired and will be discarded. This can be set to a large value far
    /// in the future to indicate that a transaction does not expire.
    expiration_timestamp_secs: u64,

    /// Chain ID of the Aptos network this transaction is intended for.
    chain_id: ChainId,
}
```

**File:** types/src/transaction/mod.rs (L1334-1343)
```rust
    /// Returns the hash when the transaction is committed onchain.
    pub fn committed_hash(&self) -> HashValue {
        *self
            .committed_hash
            .get_or_init(|| Transaction::UserTransaction(self.clone()).hash())
    }

    pub fn replay_protector(&self) -> ReplayProtector {
        self.raw_txn.replay_protector()
    }
```

**File:** types/src/transaction/mod.rs (L2945-2951)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
pub enum Transaction {
    /// Transaction submitted by the user. e.g: P2P payment transaction, publishing module
    /// transaction, etc.
    /// TODO: We need to rename SignedTransaction to SignedUserTransaction, as well as all the other
    ///       transaction types we had in our codebase.
    UserTransaction(SignedTransaction),
```

**File:** mempool/src/core_mempool/transaction_store.rs (L256-293)
```rust
        if let Some(txns) = self.transactions.get_mut(&address) {
            if let Some(current_version) = txns.get_mut(&txn_replay_protector) {
                if current_version.txn.payload() != txn.txn.payload() {
                    return MempoolStatus::new(MempoolStatusCode::InvalidUpdate).with_message(
                        "Transaction already in mempool with a different payload".to_string(),
                    );
                } else if current_version.txn.expiration_timestamp_secs()
                    != txn.txn.expiration_timestamp_secs()
                {
                    return MempoolStatus::new(MempoolStatusCode::InvalidUpdate).with_message(
                        "Transaction already in mempool with a different expiration timestamp"
                            .to_string(),
                    );
                } else if current_version.txn.max_gas_amount() != txn.txn.max_gas_amount() {
                    return MempoolStatus::new(MempoolStatusCode::InvalidUpdate).with_message(
                        "Transaction already in mempool with a different max gas amount"
                            .to_string(),
                    );
                } else if current_version.get_gas_price() < txn.get_gas_price() {
                    // Update txn if gas unit price is a larger value than before
                    if let Some(txn) = txns.remove(&txn_replay_protector) {
                        self.index_remove(&txn);
                    };
                    counters::CORE_MEMPOOL_GAS_UPGRADED_TXNS.inc();
                } else if current_version.get_gas_price() > txn.get_gas_price() {
                    return MempoolStatus::new(MempoolStatusCode::InvalidUpdate).with_message(
                        "Transaction already in mempool with a higher gas price".to_string(),
                    );
                } else {
                    // If the transaction is the same, it's an idempotent call
                    // Updating signers is not supported, the previous submission must fail
                    counters::CORE_MEMPOOL_IDEMPOTENT_TXNS.inc();
                    if let Some(acc_seq_num) = account_sequence_number {
                        self.process_ready_seq_num_based_transactions(&address, acc_seq_num);
                    }
                    return MempoolStatus::new(MempoolStatusCode::Accepted);
                }
            }
```

**File:** consensus/src/block_preparer.rs (L90-104)
```rust
        let result = tokio::task::spawn_blocking(move || {
            let filtered_txns = filter_block_transactions(
                txn_filter_config,
                block_id,
                block_author,
                block_epoch,
                block_timestamp_usecs,
                txns,
            );
            let deduped_txns = txn_deduper.dedup(filtered_txns);
            let mut shuffled_txns = {
                let _timer = TXN_SHUFFLE_SECONDS.start_timer();

                txn_shuffler.shuffle(deduped_txns)
            };
```
