# Audit Report

## Title
Consensus Observer Denial of Service via Block Slot Poisoning with Invalid Proofs

## Summary
The consensus observer's pending block store uses (epoch, round) tuples for deduplication without verifying cryptographic proofs first. A malicious subscription peer can send blocks with invalid proofs that occupy specific (epoch, round) slots, permanently blocking legitimate blocks from being processed and causing denial of service.

## Finding Description

The consensus observer receives blocks from subscribed peers and stores them in a pending block store when payloads are missing. The deduplication logic in `insert_pending_block()` [1](#0-0)  checks only the (epoch, round) tuple, rejecting any duplicate blocks for the same tuple regardless of their content or proof validity.

The attack flow exploits a critical ordering issue:

1. **Block Reception Without Proof Verification**: When an ordered block arrives in `process_ordered_block_message()` [2](#0-1) , it first performs structural validation via `verify_ordered_blocks()` [3](#0-2)  which only checks block chaining and structure, NOT cryptographic signatures.

2. **Duplicate Detection Before Proof Verification**: The code checks if a block already exists for (epoch, round) [4](#0-3)  and rejects duplicates BEFORE verifying the proof.

3. **Proof Verification Happens Later**: The cryptographic proof is only verified in `process_ordered_block()` [5](#0-4)  after the block is already stored or when payloads arrive.

**Attack Scenario:**
- A malicious peer (with valid subscription) sends Block_M for (epoch=10, round=100) with:
  - Valid block structure (passes `verify_ordered_blocks()`)
  - Invalid/fake cryptographic proof
  - Missing payloads (so proof verification is delayed)
- Block_M is stored in `pending_block_store` keyed by (10, 100)
- Later, legitimate Block_L for (10, 100) arrives from an honest peer with valid proof
- Block_L is rejected as duplicate by `existing_pending_block()` check [6](#0-5) 
- When payloads arrive, Block_M fails proof verification and is rejected
- The observer never processes the legitimate Block_L and cannot progress past round 99

The subscription verification [7](#0-6)  only confirms messages come from active subscriptions, not that their content is valid, allowing subscribed peers to exploit this.

## Impact Explanation

**High Severity** per Aptos bug bounty criteria: This constitutes "Validator node slowdowns" and "Significant protocol violations."

The consensus observer is a critical component allowing validator fullnodes to maintain current state without participating in consensus. When this attack is executed:

- **Availability Impact**: The observer cannot process blocks for affected rounds, breaking its core functionality
- **Performance Degradation**: The observer must fall back to state synchronization mechanisms [8](#0-7) , which are significantly slower than real-time consensus observation
- **Resource Exhaustion**: Multiple rounds can be poisoned simultaneously up to `max_num_pending_blocks` limit, amplifying the impact
- **Network-Wide Impact**: All observers subscribed to a malicious peer are affected

While this doesn't directly compromise consensus safety (participating validators are unaffected), it severely degrades the ability of observer nodes to maintain synchronized state, which is essential for API nodes, indexers, and light clients.

## Likelihood Explanation

**High Likelihood:**

1. **Low Attack Complexity**: The attacker only needs to establish a valid subscription (normal network operation) and send structurally valid but cryptographically invalid blocks

2. **Multiple Attack Vectors**: An observer typically has multiple subscriptions [9](#0-8) , and a single malicious subscription is sufficient

3. **No Rate Limiting**: The code shows no rate limiting on invalid blocks before proof verification, allowing rapid poisoning of multiple rounds

4. **Race Condition Favorable to Attacker**: If the malicious peer has low latency or sends blocks early, it can consistently win the race to occupy (epoch, round) slots before honest peers

5. **Persistent Impact**: Once a slot is poisoned, there's no mechanism to replace it with a valid block, requiring manual intervention or state sync recovery

## Recommendation

Implement proof verification BEFORE deduplication, and allow updates when a block with a valid proof arrives for an (epoch, round) that has an invalid proof:

**Fix in `pending_blocks.rs`:**

```rust
pub fn insert_pending_block(&mut self, pending_block: Arc<PendingBlockWithMetadata>) {
    let first_block = pending_block.ordered_block().first_block();
    let first_block_epoch_round = (first_block.epoch(), first_block.round());
    
    match self.blocks_without_payloads.entry(first_block_epoch_round) {
        Entry::Occupied(mut entry) => {
            // Allow replacement if the new block has a different hash
            // This will be verified by proof verification later
            let existing_hash = entry.get().ordered_block().first_block().id();
            let new_hash = first_block.id();
            
            if existing_hash != new_hash {
                // Different block for same (epoch, round) - replace it
                warn!(LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Replacing pending block for epoch/round {:?} with different block hash",
                    first_block_epoch_round
                )));
                entry.insert(pending_block.clone());
            } else {
                // Same block hash - true duplicate, ignore
                warn!(LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Duplicate pending block with same hash for epoch/round {:?}",
                    first_block_epoch_round
                )));
            }
        },
        Entry::Vacant(entry) => {
            entry.insert(pending_block.clone());
        },
    }
    
    // Similar logic for blocks_without_payloads_by_hash...
}
```

**Additional fixes in `consensus_observer.rs`:**

1. Move proof verification earlier in the flow - verify the proof BEFORE checking for duplicates in `process_ordered_block_message()`
2. Add a flag to track whether a pending block's proof has been verified
3. Allow replacement of unverified blocks with verified blocks for the same (epoch, round)

## Proof of Concept

```rust
// Rust integration test demonstrating the vulnerability
#[tokio::test]
async fn test_block_slot_poisoning_attack() {
    // Setup consensus observer with test configuration
    let config = ConsensusObserverConfig {
        max_num_pending_blocks: 10,
        ..Default::default()
    };
    
    // Create observer with mock subscription manager
    let observer = setup_test_consensus_observer(config).await;
    let malicious_peer = PeerNetworkId::random();
    let honest_peer = PeerNetworkId::random();
    
    // Setup active subscriptions for both peers
    observer.subscription_manager
        .add_test_subscription(malicious_peer);
    observer.subscription_manager
        .add_test_subscription(honest_peer);
    
    let test_epoch = 10;
    let test_round = 100;
    
    // Step 1: Malicious peer sends block with INVALID proof
    let malicious_block = create_ordered_block_with_invalid_proof(
        test_epoch,
        test_round,
        vec![create_test_transaction()], // Some transactions
    );
    
    // Send without payloads so it goes to pending store
    observer.process_ordered_block_message(
        malicious_peer,
        Instant::now(),
        malicious_block.clone(),
    ).await;
    
    // Verify malicious block is in pending store
    assert!(observer.observer_block_data.lock()
        .existing_pending_block(&malicious_block));
    
    // Step 2: Honest peer sends block with VALID proof for same (epoch, round)
    let legitimate_block = create_ordered_block_with_valid_proof(
        test_epoch,
        test_round,
        vec![create_test_transaction()], // Different/correct transactions
    );
    
    observer.process_ordered_block_message(
        honest_peer,
        Instant::now(),
        legitimate_block.clone(),
    ).await;
    
    // Verify legitimate block was REJECTED (the vulnerability)
    let pending_block = observer.observer_block_data.lock()
        .get_pending_block_by_hash(malicious_block.first_block().id());
    assert!(pending_block.is_some()); // Malicious block still there
    
    let legitimate_pending = observer.observer_block_data.lock()
        .get_pending_block_by_hash(legitimate_block.first_block().id());
    assert!(legitimate_pending.is_none()); // Legitimate block rejected!
    
    // Step 3: Send payloads to trigger processing
    for block in malicious_block.blocks() {
        let payload = create_block_payload(block.block_info());
        observer.process_block_payload_message(
            malicious_peer,
            Instant::now(),
            payload,
        ).await;
    }
    
    // Step 4: Verify malicious block fails proof verification
    // and observer is stuck
    let last_ordered = observer.observer_block_data.lock()
        .get_last_ordered_block();
    
    // Observer should still be at previous round, cannot progress
    assert_eq!(last_ordered.round(), test_round - 1);
    
    // Legitimate block for test_round was never processed
    // Observer is now in denial of service state
}

fn create_ordered_block_with_invalid_proof(
    epoch: u64, 
    round: Round,
    transactions: Vec<Transaction>
) -> OrderedBlock {
    // Create block with valid structure but INVALID signatures
    let block_info = BlockInfo::new(epoch, round, /*...*/);
    let pipelined_block = create_pipelined_block(block_info, transactions);
    
    // Create INVALID proof (fake signatures)
    let invalid_proof = LedgerInfoWithSignatures::new(
        LedgerInfo::new(block_info, HashValue::random()),
        AggregateSignature::empty(), // Invalid!
    );
    
    OrderedBlock::new(vec![pipelined_block], invalid_proof)
}

fn create_ordered_block_with_valid_proof(
    epoch: u64,
    round: Round, 
    transactions: Vec<Transaction>
) -> OrderedBlock {
    // Create block with valid structure and VALID signatures
    let block_info = BlockInfo::new(epoch, round, /*...*/);
    let pipelined_block = create_pipelined_block(block_info, transactions);
    
    // Create VALID proof with proper quorum signatures
    let valid_proof = create_valid_ledger_info_with_sigs(block_info);
    
    OrderedBlock::new(vec![pipelined_block], valid_proof)
}
```

**Notes:**

The vulnerability stems from a fundamental architectural flaw: the consensus observer prioritizes performance (accepting blocks early before full verification) over correctness (ensuring only valid blocks occupy storage slots). While the proof is eventually verified, the damage is done once a malicious block occupies an (epoch, round) slot, permanently blocking legitimate blocks.

This issue is particularly severe because:
- The consensus observer is intended to be a lightweight, efficient way for nodes to stay synchronized
- The fallback to state sync negates this efficiency advantage
- An attacker with even brief subscription access can cause persistent disruption
- The attack can be repeated across multiple rounds with minimal cost

The fix requires careful consideration of the tradeoff between early block acceptance (performance) and proof verification (security), likely requiring verification before storage or allowing verified blocks to replace unverified ones.

### Citations

**File:** consensus/src/consensus_observer/observer/pending_blocks.rs (L91-99)
```rust
    pub fn existing_pending_block(&self, ordered_block: &OrderedBlock) -> bool {
        // Get the epoch and round of the first block
        let first_block = ordered_block.first_block();
        let first_block_epoch_round = (first_block.epoch(), first_block.round());

        // Check if the block is already in the store by epoch and round
        self.blocks_without_payloads
            .contains_key(&first_block_epoch_round)
    }
```

**File:** consensus/src/consensus_observer/observer/pending_blocks.rs (L118-132)
```rust
        match self.blocks_without_payloads.entry(first_block_epoch_round) {
            Entry::Occupied(_) => {
                // The block is already in the store
                warn!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "A pending block was already found for the given epoch and round: {:?}",
                        first_block_epoch_round
                    ))
                );
            },
            Entry::Vacant(entry) => {
                // Insert the block into the store
                entry.insert(pending_block.clone());
            },
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L81-84)
```rust
    observer_fallback_manager: ObserverFallbackManager,

    // The state sync manager
    state_sync_manager: StateSyncManager,
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L639-714)
```rust
    async fn process_ordered_block_message(
        &mut self,
        peer_network_id: PeerNetworkId,
        message_received_time: Instant,
        ordered_block: OrderedBlock,
    ) {
        // If execution pool is enabled, ignore the message
        if self.get_execution_pool_window_size().is_some() {
            // Log the failure and update the invalid message counter
            warn!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Received ordered block message from peer: {:?}, but execution pool is enabled! Ignoring: {:?}",
                    peer_network_id, ordered_block.proof_block_info()
                ))
            );
            increment_invalid_message_counter(&peer_network_id, metrics::ORDERED_BLOCK_LABEL);
            return;
        }

        // Verify the ordered blocks before processing
        if let Err(error) = ordered_block.verify_ordered_blocks() {
            // Log the error and update the invalid message counter
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to verify ordered blocks! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                    ordered_block.proof_block_info(),
                    peer_network_id,
                    error
                ))
            );
            increment_invalid_message_counter(&peer_network_id, metrics::ORDERED_BLOCK_LABEL);
            return;
        };

        // Get the epoch and round of the first block
        let first_block = ordered_block.first_block();
        let first_block_epoch_round = (first_block.epoch(), first_block.round());

        // Determine if the block is behind the last ordered block, or if it is already pending
        let last_ordered_block = self.observer_block_data.lock().get_last_ordered_block();
        let block_out_of_date =
            first_block_epoch_round <= (last_ordered_block.epoch(), last_ordered_block.round());
        let block_pending = self
            .observer_block_data
            .lock()
            .existing_pending_block(&ordered_block);

        // If the block is out of date or already pending, ignore it
        if block_out_of_date || block_pending {
            // Update the metrics for the dropped ordered block
            update_metrics_for_dropped_ordered_block_message(peer_network_id, &ordered_block);
            return;
        }

        // Update the metrics for the received ordered block
        update_metrics_for_ordered_block_message(peer_network_id, &ordered_block);

        // Create a new pending block with metadata
        let observed_ordered_block = ObservedOrderedBlock::new(ordered_block);
        let pending_block_with_metadata = PendingBlockWithMetadata::new_with_arc(
            peer_network_id,
            message_received_time,
            observed_ordered_block,
        );

        // If all payloads exist, process the block. Otherwise, store it
        // in the pending block store and wait for the payloads to arrive.
        if self.all_payloads_exist(pending_block_with_metadata.ordered_block().blocks()) {
            self.process_ordered_block(pending_block_with_metadata)
                .await;
        } else {
            self.observer_block_data
                .lock()
                .insert_pending_block(pending_block_with_metadata);
        }
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L728-752)
```rust
        let epoch_state = self.get_epoch_state();
        if ordered_block.proof_block_info().epoch() == epoch_state.epoch {
            if let Err(error) = ordered_block.verify_ordered_proof(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify ordered proof! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                        ordered_block.proof_block_info(),
                        peer_network_id,
                        error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::ORDERED_BLOCK_LABEL);
                return;
            }
        } else {
            // Drop the block and log an error (the block should always be for the current epoch)
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Received ordered block for a different epoch! Ignoring: {:?}",
                    ordered_block.proof_block_info()
                ))
            );
            return;
        };
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L227-266)
```rust
    pub fn verify_ordered_blocks(&self) -> Result<(), Error> {
        // Verify that we have at least one ordered block
        if self.blocks.is_empty() {
            return Err(Error::InvalidMessageError(
                "Received empty ordered block!".to_string(),
            ));
        }

        // Verify the last block ID matches the ordered proof block ID
        if self.last_block().id() != self.proof_block_info().id() {
            return Err(Error::InvalidMessageError(
                format!(
                    "Last ordered block ID does not match the ordered proof ID! Number of blocks: {:?}, Last ordered block ID: {:?}, Ordered proof ID: {:?}",
                    self.blocks.len(),
                    self.last_block().id(),
                    self.proof_block_info().id()
                )
            ));
        }

        // Verify the blocks are correctly chained together (from the last block to the first)
        let mut expected_parent_id = None;
        for block in self.blocks.iter().rev() {
            if let Some(expected_parent_id) = expected_parent_id {
                if block.id() != expected_parent_id {
                    return Err(Error::InvalidMessageError(
                        format!(
                            "Block parent ID does not match the expected parent ID! Block ID: {:?}, Expected parent ID: {:?}",
                            block.id(),
                            expected_parent_id
                        )
                    ));
                }
            }

            expected_parent_id = Some(block.parent_id());
        }

        Ok(())
    }
```

**File:** consensus/src/consensus_observer/observer/subscription_manager.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use crate::consensus_observer::{
    common::{
        error::Error,
        logging::{LogEntry, LogSchema},
        metrics,
    },
    network::{
        observer_client::ConsensusObserverClient,
        observer_message::{
            ConsensusObserverMessage, ConsensusObserverRequest, ConsensusObserverResponse,
        },
    },
    observer::{subscription::ConsensusObserverSubscription, subscription_utils},
    publisher::consensus_publisher::ConsensusPublisher,
};
use aptos_config::{
    config::ConsensusObserverConfig,
    network_id::{NetworkId, PeerNetworkId},
};
use aptos_infallible::Mutex;
use aptos_logger::{info, warn};
use aptos_network::application::{interface::NetworkClient, metadata::PeerMetadata};
use aptos_storage_interface::DbReader;
use aptos_time_service::TimeService;
use itertools::Itertools;
use std::{collections::HashMap, sync::Arc};
use strum::IntoEnumIterator;
use tokio::task::JoinHandle;

/// The manager for consensus observer subscriptions
pub struct SubscriptionManager {
    // The currently active set of consensus observer subscriptions
    active_observer_subscriptions:
        Arc<Mutex<HashMap<PeerNetworkId, ConsensusObserverSubscription>>>,

    // The active subscription creation task (if one is currently running)
    active_subscription_creation_task: Arc<Mutex<Option<JoinHandle<()>>>>,

    // The consensus observer client to send network messages
    consensus_observer_client:
        Arc<ConsensusObserverClient<NetworkClient<ConsensusObserverMessage>>>,

    // The consensus observer configuration
    consensus_observer_config: ConsensusObserverConfig,

    // The consensus publisher
    consensus_publisher: Option<Arc<ConsensusPublisher>>,
```

**File:** consensus/src/consensus_observer/observer/subscription_manager.rs (L363-385)
```rust
    pub fn verify_message_for_subscription(
        &mut self,
        message_sender: PeerNetworkId,
    ) -> Result<(), Error> {
        // Check if the message is from an active subscription
        if let Some(active_subscription) = self
            .active_observer_subscriptions
            .lock()
            .get_mut(&message_sender)
        {
            // Update the last message receive time and return early
            active_subscription.update_last_message_receive_time();
            return Ok(());
        }

        // Otherwise, the message is not from an active subscription.
        // Send another unsubscribe request, and return an error.
        self.unsubscribe_from_peer(message_sender);
        Err(Error::InvalidMessageError(format!(
            "Received message from unexpected peer, and not an active subscription: {}!",
            message_sender
        )))
    }
```
