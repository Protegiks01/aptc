# Audit Report

## Title
REST API Response Injection Vulnerability Enables Authorization Bypass in Telemetry Service

## Summary
The REST client's `Resource` type accepts arbitrary JSON data without cryptographic verification, enabling an attacker who compromises the REST API to inject malicious addresses into the telemetry service's authorization allowlist, bypassing on-chain authentication controls.

## Finding Description

The `Resource` type definition blindly trusts API responses by storing the resource data as raw `serde_json::Value` without any validation or cryptographic proof verification. [1](#0-0) 

When the REST client fetches account resources, it deserializes the API response directly into this `Resource` type, extracting the unvalidated `data` field for use in security-critical operations. [2](#0-1) 

The telemetry service uses this REST client to fetch on-chain allowlists for custom contract authentication. It periodically calls `fetch_addresses_via_resource()` which retrieves a `Resource` and extracts addresses from the raw JSON `data` field. [3](#0-2) 

These extracted addresses are then cached and used for authorization decisions when clients attempt to authenticate to the telemetry service. [4](#0-3) 

The authorization check directly uses this cached data without any additional verification. [5](#0-4) 

**Attack Scenario:**

1. Attacker compromises the REST API endpoint OR performs a MITM attack
2. When `AllowlistCacheUpdater` fetches the allowlist resource, the compromised API returns malicious JSON containing the attacker's address
3. The REST client deserializes this into the `Resource.data` field without validation
4. The telemetry service extracts addresses from this malicious JSON
5. Attacker's address is added to the authorization cache
6. Attacker can now successfully authenticate to the telemetry service using their private key

This breaks the security guarantee that "State Consistency: State transitions must be atomic and verifiable via Merkle proofs" - the REST client provides no cryptographic verification that the returned data actually matches on-chain state.

## Impact Explanation

This vulnerability qualifies as **HIGH severity** per Aptos bug bounty criteria:

1. **Significant Protocol Violation**: The system claims to enforce on-chain allowlist authentication but can be completely bypassed through API compromise
2. **Authorization Bypass**: Attackers gain unauthorized access to the telemetry service infrastructure
3. **Data Integrity Risk**: Malicious actors can inject false telemetry data that could affect operational decisions
4. **No Cryptographic Defense**: Unlike BCS-based endpoints that could verify state proofs, the JSON endpoint has zero cryptographic verification

While this doesn't directly affect consensus or validator operations (which use direct storage access, not REST clients), it represents a critical failure in the authentication infrastructure for production services.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

Attack Prerequisites:
- Compromise of REST API endpoint (through vulnerability, misconfiguration, or insider threat)
- OR successful MITM attack (if TLS validation is bypassed)

Factors Increasing Likelihood:
- REST APIs are common attack targets
- No defense-in-depth: single point of failure
- The vulnerability is in production code actively used by telemetry infrastructure
- Multiple REST API endpoints exist (mainnet, testnet, custom deployments)

Factors Decreasing Likelihood:
- Requires external system compromise (not pure protocol bug)
- TLS provides some protection against MITM (unless misconfigured)

## Recommendation

**Immediate Fix**: Implement cryptographic state proof verification for all security-critical REST API calls.

**Option 1 - Use BCS Endpoint with State Proofs:**
Switch the telemetry service to use the BCS endpoint (`get_account_resource_bcs`) which can be extended to verify state proofs against the blockchain's Merkle tree root.

**Option 2 - Add JSON Response Validation:**
If JSON endpoint must be used, implement additional validation:
- Verify response includes a state proof
- Validate the state proof against a known trusted ledger version/state root
- Cross-verify critical data with multiple independent API endpoints
- Implement request signing from the API server

**Option 3 - Type-Level Validation:**
Add validation traits to the `Resource` type that enforce schema validation for the JSON data field before it can be used in security-critical operations.

**Recommended Implementation:**
```rust
// Add state proof verification to REST client
pub struct VerifiedResource {
    pub resource_type: StructTag,
    pub data: serde_json::Value,
    // State proof fields
    state_proof: StateProof,
    verified_at_version: u64,
}

impl VerifiedResource {
    pub fn verify(resource: Resource, state_proof: StateProof, trusted_root: HashValue) -> Result<Self> {
        // Cryptographically verify the resource data against the state proof
        state_proof.verify(&resource, trusted_root)?;
        Ok(Self { /* ... */ })
    }
}
```

## Proof of Concept

```rust
// PoC demonstrating the vulnerability
// File: crates/aptos-telemetry-service/tests/auth_bypass_poc.rs

use aptos_rest_client::Client;
use aptos_telemetry_service::allowlist_cache::AllowlistCache;
use aptos_types::account_address::AccountAddress;
use mockito::Server;
use serde_json::json;

#[tokio::test]
async fn test_malicious_api_response_bypass() {
    // Setup: Create a mock REST API server
    let mut server = Server::new_async().await;
    
    // Attacker's address that should NOT be in allowlist
    let attacker_address = AccountAddress::from_hex_literal("0xdeadbeef").unwrap();
    
    // Mock endpoint returns malicious JSON with attacker's address
    let mock = server.mock("GET", "/v1/accounts/0x1/resource/0x1::allowlist::AllowedAddresses")
        .with_status(200)
        .with_header("content-type", "application/json")
        .with_body(json!({
            "type": "0x1::allowlist::AllowedAddresses",
            "data": {
                "addresses": [
                    attacker_address.to_hex_literal()
                ]
            }
        }).to_string())
        .create_async()
        .await;
    
    // Create REST client pointing to malicious server
    let client = Client::new(server.url().parse().unwrap());
    
    // Fetch the "on-chain" resource (actually from malicious server)
    let resource = client
        .get_account_resource(
            AccountAddress::ONE,
            "0x1::allowlist::AllowedAddresses"
        )
        .await
        .unwrap()
        .into_inner()
        .unwrap();
    
    // Extract addresses from malicious JSON - NO VALIDATION OCCURS
    let addresses_json = resource.data.get("addresses").unwrap();
    let addresses: Vec<AccountAddress> = addresses_json
        .as_array()
        .unwrap()
        .iter()
        .map(|v| AccountAddress::from_hex_literal(v.as_str().unwrap()).unwrap())
        .collect();
    
    // VULNERABILITY: Attacker's address is now in the "verified" allowlist
    assert!(addresses.contains(&attacker_address));
    
    // If this data is cached for authorization, attacker can now authenticate
    let cache = AllowlistCache::new();
    cache.update("test_contract", &aptos_types::chain_id::ChainId::new(1), addresses);
    
    // Authorization check succeeds for attacker!
    assert_eq!(
        cache.check_address("test_contract", &aptos_types::chain_id::ChainId::new(1), &attacker_address),
        Some(true)
    );
    
    mock.assert_async().await;
    
    println!("âœ— VULNERABILITY CONFIRMED: Attacker bypassed authorization via malicious API response");
}
```

**Notes**

This vulnerability specifically affects the **telemetry service authentication system**, not core blockchain consensus or validator operations. However, it represents a significant security flaw in production infrastructure:

1. The REST client used throughout the codebase lacks cryptographic verification of API responses
2. While consensus nodes use direct storage access (not REST APIs), off-chain infrastructure components rely on REST clients for operational data
3. The BCS-based endpoints (`get_account_resource_bcs`) could potentially be hardened with state proof verification, but the JSON endpoints have no such mechanism
4. This is a systemic issue affecting any security-critical operation that relies on REST API data without independent verification

The vulnerability is particularly concerning because it undermines the stated security model where "on-chain allowlists" are trusted as the source of truth for authorization decisions, when in reality these decisions depend on unverified API responses.

### Citations

**File:** crates/aptos-rest-client/src/types.rs (L11-16)
```rust
#[derive(Clone, Debug, PartialEq, Eq, Deserialize)]
pub struct Resource {
    #[serde(rename = "type", deserialize_with = "deserialize_resource_type")]
    pub resource_type: StructTag,
    pub data: serde_json::Value,
}
```

**File:** crates/aptos-rest-client/src/lib.rs (L1168-1187)
```rust
    pub async fn get_resource<T: DeserializeOwned>(
        &self,
        address: AccountAddress,
        resource_type: &str,
    ) -> AptosResult<Response<T>> {
        let resp = self.get_account_resource(address, resource_type).await?;
        resp.and_then(|conf| {
            if let Some(res) = conf {
                serde_json::from_value(res.data)
                    .map_err(|e| anyhow!("deserialize {} failed: {}", resource_type, e).into())
            } else {
                Err(anyhow!(
                    "could not find resource {} in account {}",
                    resource_type,
                    address
                )
                .into())
            }
        })
    }
```

**File:** crates/aptos-telemetry-service/src/custom_contract_auth.rs (L407-482)
```rust
pub(crate) async fn fetch_addresses_via_resource(
    rest_url: &reqwest::Url,
    resource_path: &str,
    address_field: &str,
) -> Result<Vec<AccountAddress>> {
    // Parse resource path: "0x123::module::Resource"
    let parts: Vec<&str> = resource_path.split("::").collect();
    if parts.len() != 3 {
        return Err(anyhow!(
            "invalid resource path format, expected '0xADDRESS::module::Resource', got '{}'",
            resource_path
        ));
    }

    let resource_address = AccountAddress::from_hex_literal(parts[0])
        .map_err(|e| anyhow!("invalid address in resource path '{}': {}", parts[0], e))?;
    let resource_type = format!(
        "{}::{}::{}",
        resource_address.to_hex_literal(),
        parts[1],
        parts[2]
    );

    let client = RestClient::new(rest_url.clone());

    // Fetch the resource from on-chain
    let response = client
        .get_account_resource(resource_address, &resource_type)
        .await
        .map_err(|e| {
            // Provide user-friendly error messages for common failures
            let error_msg = format!("{}", e);
            if error_msg.contains("404") || error_msg.contains("not found") {
                anyhow!(
                    "resource '{}' does not exist at address {} or account not found on chain",
                    resource_type,
                    resource_address
                )
            } else if error_msg.contains("403") || error_msg.contains("Forbidden") {
                anyhow!(
                    "access denied when fetching resource '{}' - check API credentials",
                    resource_type
                )
            } else if error_msg.contains("500") || error_msg.contains("Internal Server Error") {
                anyhow!(
                    "blockchain node error when fetching resource '{}': {}",
                    resource_type,
                    error_msg
                )
            } else {
                anyhow!(
                    "failed to fetch resource '{}': {}",
                    resource_type,
                    error_msg
                )
            }
        })?;

    let resource = response
        .into_inner()
        .ok_or_else(|| {
            anyhow!(
                "resource '{}' not found at address {} - the resource type may not exist or account may not have this resource",
                resource_type, resource_address
            )
        })?;

    // Extract the address list from the specified field path
    extract_address_list(&resource.data, address_field)
        .map_err(|e| {
            anyhow!(
                "failed to extract addresses from resource '{}' using field path '{}': {} - check that the field exists and contains valid address data",
                resource_type, address_field, e
            )
        })
}
```

**File:** crates/aptos-telemetry-service/src/allowlist_cache.rs (L64-96)
```rust
    /// Check if an address is in the cached allowlist.
    /// Returns `Some(true)` if address is allowed, `Some(false)` if not allowed,
    /// or `None` if no cache entry exists.
    pub fn check_address(
        &self,
        contract_name: &str,
        chain_id: &ChainId,
        address: &AccountAddress,
    ) -> Option<bool> {
        let key = CacheKey {
            contract_name: contract_name.to_string(),
            chain_id: *chain_id,
        };

        let chain_id_str = chain_id.to_string();
        let cache = self.cache.read();
        if let Some(cached) = cache.get(&key) {
            let is_allowed = cached.contains(address);
            ALLOWLIST_CACHE_OPERATIONS
                .with_label_values(&[contract_name, &chain_id_str, AllowlistCacheOp::Hit.as_str()])
                .inc();
            Some(is_allowed)
        } else {
            ALLOWLIST_CACHE_OPERATIONS
                .with_label_values(&[
                    contract_name,
                    &chain_id_str,
                    AllowlistCacheOp::Miss.as_str(),
                ])
                .inc();
            None
        }
    }
```

**File:** crates/aptos-telemetry-service/src/allowlist_cache.rs (L219-262)
```rust
    /// Update allowlist for a single contract
    async fn update_contract(
        &self,
        contract: &CustomContractConfig,
    ) -> Result<usize, AllowlistUpdateError> {
        let config = &contract.on_chain_auth;
        let chain_id = ChainId::new(config.chain_id);

        // Resolve the resource/function path (with env var substitution)
        let path = config
            .resolve_resource_path()
            .map_err(AllowlistUpdateError::ConfigError)?;

        // Resolve view function arguments (with env var substitution)
        let view_args = config
            .resolve_view_function_args()
            .map_err(AllowlistUpdateError::ConfigError)?;

        // Get REST URL
        let rest_url = config.rest_api_url.clone().ok_or_else(|| {
            AllowlistUpdateError::ConfigError("No REST URL configured".to_string())
        })?;

        // Fetch address list based on method
        let addresses = match config.method {
            OnChainAuthMethod::ViewFunction => fetch_addresses_via_view_function(
                &rest_url,
                &path,
                &view_args,
                &config.address_list_field,
            )
            .await
            .map_err(|e| AllowlistUpdateError::FetchError(e.to_string()))?,
            OnChainAuthMethod::Resource => {
                fetch_addresses_via_resource(&rest_url, &path, &config.address_list_field)
                    .await
                    .map_err(|e| AllowlistUpdateError::FetchError(e.to_string()))?
            },
        };

        let count = addresses.len();
        self.cache.update(&contract.name, &chain_id, addresses);
        Ok(count)
    }
```
