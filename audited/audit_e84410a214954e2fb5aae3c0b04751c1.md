# Audit Report

## Title
Indiscriminate Error Handling in Crypto Derive Macros Enables Malleability and Small Subgroup Attack Bypass

## Summary
The `impl_enum_tryfrom` function in the crypto-derive macro implementation fails to distinguish between recoverable type mismatch errors and fatal cryptographic security violations. This allows attackers to bypass critical security checks (canonical representation, small subgroup validation, curve point validation) through retry attacks when deserializing cryptographic material into enum types.

## Finding Description

The derive macro implementation generates `TryFrom<&[u8]>` code that treats ALL errors as recoverable by using `.or_else(|_err| ...)` to chain variant attempts. [1](#0-0) 

The `CryptoMaterialError` enum defines multiple error types with different security implications: [2](#0-1) 

Critical security checks that return FATAL errors include:
- **CanonicalRepresentationError**: Prevents signature malleability attacks
- **SmallSubgroupError**: Prevents small subgroup cryptographic attacks  
- **PointNotOnCurveError**: Prevents invalid curve point attacks
- **ValidationError**: General security policy violations

For example, Ed25519 signature deserialization performs mandatory malleability checking: [3](#0-2) 

The malleability check is a critical security control: [4](#0-3) 

**Attack Scenario:**

When an enum like this is defined:
```rust
#[derive(Signature)]
enum Sig {
    Ed(Ed25519Signature),
    MultiEd(MultiEd25519Signature),
}
```

The generated code becomes:
1. Try `Ed25519Signature::try_from(bytes)` → Fails with `CanonicalRepresentationError` (non-canonical signature)
2. `.or_else(|_err| ...)` **discards the fatal security error**
3. Try `MultiEd25519Signature::try_from(bytes)` → May succeed
4. Attacker bypassed the malleability check

The same vulnerability exists in the active Aptos implementation: [5](#0-4) 

## Impact Explanation

**Severity: Medium**

This breaks the **Cryptographic Correctness** invariant. The impact depends on production usage:

1. **Signature Malleability**: Attackers can create multiple valid-looking enum variants from the same malicious bytes, potentially causing:
   - Consensus disagreements if different nodes parse differently
   - Replay protection bypasses
   - Double-spend scenarios through signature reuse

2. **Small Subgroup Attacks**: Bypassing small subgroup checks on public keys can enable cryptographic attacks that recover private keys or forge signatures

3. **State Inconsistency**: Different nodes may deserialize the same bytes into different enum variants, violating deterministic execution

The vulnerability is present in both the diem-framework example code and the production Aptos crypto-derive implementation. However, I could not locate production enum types in consensus-critical paths that use these derive macros - the main `AnyPublicKey` and `AnySignature` types manually implement `TryFrom` using BCS deserialization.

## Likelihood Explanation

**Likelihood: Low to Medium**

The vulnerability requires:
1. Production code using `#[derive(ValidCryptoMaterial/Signature)]` on multi-variant enums
2. An attacker providing malicious crypto material that fails security checks in one variant but parses in another
3. The validation bypass must be exploitable in the application context

I identified test examples using these derives, but test code is out of scope. Without concrete production usage in consensus/execution paths, the practical exploitability cannot be fully assessed.

## Recommendation

Modify `impl_enum_tryfrom` to distinguish fatal security errors from recoverable type mismatches:

```rust
pub fn impl_enum_tryfrom(name: &Ident, variants: &DataEnum) -> proc_macro2::TokenStream {
    let mut try_iter = variants.variants.iter();
    let first_variant = try_iter.next().expect("...");
    let first_variant_ident = &first_variant.ident;
    let first_variant_arg = &first_variant.fields.iter().next().expect("...").ty;

    let mut try_chain = quote! {
        #first_variant_arg::try_from(bytes).and_then(|key| Ok(#name::#first_variant_ident(key)))
    };
    
    for variant in try_iter {
        let variant_ident = &variant.ident;
        let variant_arg = &variant.fields.iter().next().expect("...").ty;
        
        // Only retry on DeserializationError and WrongLengthError
        // NEVER retry on security violations
        try_chain.extend(quote!{
            .or_else(|err| {
                match err {
                    diem_crypto::CryptoMaterialError::DeserializationError |
                    diem_crypto::CryptoMaterialError::WrongLengthError => {
                        #variant_arg::try_from(bytes).and_then(|key| Ok(#name::#variant_ident(key)))
                    },
                    // Fatal security errors must propagate immediately
                    _ => Err(err)
                }
            })
        })
    }
    // ... rest of implementation
}
```

Apply the same fix to `crates/aptos-crypto-derive/src/unions.rs`.

## Proof of Concept

```rust
use diem_crypto::{
    ed25519::{Ed25519Signature, Ed25519PublicKey},
    multi_ed25519::MultiEd25519Signature,
    traits::*,
};
use diem_crypto_derive::Signature;

#[derive(Signature)]
#[PublicKeyType = "TestPublicKey"]  
#[PrivateKeyType = "TestPrivateKey"]
enum TestSignature {
    Ed(Ed25519Signature),
    MultiEd(MultiEd25519Signature),
}

fn main() {
    // Create a non-canonical Ed25519 signature (S component >= L)
    let mut malicious_bytes = [0u8; 64];
    // Set S component to be non-canonical (>= curve order)
    malicious_bytes[32..].copy_from_slice(&[0xFF; 32]);
    
    // This should FAIL with CanonicalRepresentationError
    let ed_result = Ed25519Signature::try_from(&malicious_bytes[..]);
    assert!(matches!(ed_result, Err(CryptoMaterialError::CanonicalRepresentationError)));
    
    // But the enum TRY succeeds by trying MultiEd25519
    // This is the vulnerability - fatal error was ignored
    let enum_result = TestSignature::try_from(&malicious_bytes[..]);
    println!("Enum parsing result: {:?}", enum_result);
    // May succeed as TestSignature::MultiEd variant, bypassing security check
}
```

## Notes

While this vulnerability exists in the codebase, I could not definitively locate production consensus-critical code using these vulnerable derive macros on enum types. The main Aptos authenticator types (`AnyPublicKey`, `AnySignature`) use manual BCS deserialization rather than these derives. However, the vulnerability pattern affects both the diem-framework example code and the active Aptos crypto-derive implementation, posing a risk if such enums are introduced in future updates to consensus, transaction validation, or state management code paths.

### Citations

**File:** third_party/move/move-examples/diem-framework/crates/crypto-derive/src/unions.rs (L46-60)
```rust
    let mut try_chain = quote! {
        #first_variant_arg::try_from(bytes).and_then(|key| Ok(#name::#first_variant_ident(key)))
    };
    for variant in try_iter {
        let variant_ident = &variant.ident;
        let variant_arg = &variant
            .fields
            .iter()
            .next()
            .expect("Unrecognized enum for key types")
            .ty;
        try_chain.extend(quote!{
            .or_else(|_err| #variant_arg::try_from(bytes).and_then(|key| Ok(#name::#variant_ident(key))))
        })
    }
```

**File:** third_party/move/move-examples/diem-framework/crates/crypto/src/traits.rs (L18-44)
```rust
/// An error type for key and signature validation issues, see [`ValidCryptoMaterial`][ValidCryptoMaterial].
///
/// This enum reflects there are two interesting causes of validation
/// failure for the ingestion of key or signature material: deserialization errors
/// (often, due to mangled material or curve equation failure for ECC) and
/// validation errors (material recognizable but unacceptable for use,
/// e.g. unsafe).
#[derive(Clone, Debug, PartialEq, Eq, Error)]
#[error("{:?}", self)]
pub enum CryptoMaterialError {
    /// Struct to be signed does not serialize correctly.
    SerializationError,
    /// Key or signature material does not deserialize correctly.
    DeserializationError,
    /// Key or signature material deserializes, but is otherwise not valid.
    ValidationError,
    /// Key, threshold or signature material does not have the expected size.
    WrongLengthError,
    /// Part of the signature or key is not canonical resulting to malleability issues.
    CanonicalRepresentationError,
    /// A curve point (i.e., a public key) lies on a small group.
    SmallSubgroupError,
    /// A curve point (i.e., a public key) does not satisfy the curve equation.
    PointNotOnCurveError,
    /// BitVec errors in accountable multi-sig schemes.
    BitVecError(String),
}
```

**File:** third_party/move/move-examples/diem-framework/crates/crypto/src/ed25519.rs (L214-222)
```rust
    pub fn check_malleability(bytes: &[u8]) -> std::result::Result<(), CryptoMaterialError> {
        if bytes.len() != ED25519_SIGNATURE_LENGTH {
            return Err(CryptoMaterialError::WrongLengthError);
        }
        if !check_s_lt_l(&bytes[32..]) {
            return Err(CryptoMaterialError::CanonicalRepresentationError);
        }
        Ok(())
    }
```

**File:** third_party/move/move-examples/diem-framework/crates/crypto/src/ed25519.rs (L492-499)
```rust
impl TryFrom<&[u8]> for Ed25519Signature {
    type Error = CryptoMaterialError;

    fn try_from(bytes: &[u8]) -> std::result::Result<Ed25519Signature, CryptoMaterialError> {
        Ed25519Signature::check_malleability(bytes)?;
        Ed25519Signature::from_bytes_unchecked(bytes)
    }
}
```

**File:** crates/aptos-crypto-derive/src/unions.rs (L56-58)
```rust
        try_chain.extend(quote!{
            .or_else(|_err| #variant_arg::try_from(bytes).and_then(|key| Ok(#name::#variant_ident(key))))
        })
```
