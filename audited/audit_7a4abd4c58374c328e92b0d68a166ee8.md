# Audit Report

## Title
Lost Pruner Metadata Causes Incorrect min_readable_version Initialization Leading to Query Failures

## Summary
When `LedgerPrunerProgress` metadata is lost or corrupted, the `LedgerPrunerManager::new()` function initializes `min_readable_version` to 0 instead of recovering the actual minimum readable version from the database. This causes queries to either fail with incorrect error messages (NotFound instead of "pruned") or incorrectly reject queries for data that actually exists, depending on the pruning window configuration.

## Finding Description

The vulnerability exists in the initialization path of `LedgerPrunerManager`. When the node starts, it reads the ledger pruner progress from the database metadata to determine `min_readable_version`: [1](#0-0) 

This calls `get_ledger_pruner_progress()` which uses `.unwrap_or(0)` as a fallback: [2](#0-1) 

The underlying `get_pruner_progress()` returns an error when metadata is not found: [3](#0-2) 

**The Critical Issue:** When metadata is lost (due to corruption, partial database restore, or other failures), the fallback value of 0 is used, which is incorrect if the database has already been pruned.

**Why Recovery Logic Doesn't Help:** The `LedgerPruner` itself has recovery logic in `LedgerMetadataPruner::new()` that scans the database to find the first available version: [4](#0-3) 

However, this recovered value is internal to the `LedgerPruner` object created by `init_pruner()` and is never communicated back to `LedgerPrunerManager`, which uses its own separate call to `get_ledger_pruner_progress()`.

**Two Failure Modes:**

**Mode 1: Underestimated min_readable_version** (when calculated < actual)
- Actual state: Data from versions 0-999 has been pruned (min_readable_version should be 1000)
- Node initializes: min_readable_version = 0
- Query for version 500 passes the pruning check: [5](#0-4) 

- But when trying to fetch the transaction, it returns NotFound: [6](#0-5) 

**Mode 2: Overestimated min_readable_version** (when recalculated > actual)
- During node startup, `maybe_set_pruner_target_db_version()` is called, which recalculates `min_readable_version` as `latest_version - prune_window`: [7](#0-6) 

- If this calculation results in a value greater than the actual min_readable_version, queries for available data will be incorrectly rejected as "pruned"

## Impact Explanation

This is **HIGH severity** per Aptos bug bounty criteria for the following reasons:

1. **API Failures**: Clients receive incorrect error messages, unable to distinguish between "transaction never existed" vs "transaction was pruned"

2. **Data Availability Issues**: In Mode 2, the node refuses to serve data that actually exists in the database, causing artificial data unavailability

3. **State Sync Problems**: Nodes advertise incorrect data availability ranges to peers, breaking state synchronization

4. **Node Operational Failures**: If other code paths assume NotFound means "version doesn't exist yet" rather than "pruned", incorrect decisions may be made

5. **No Self-Recovery**: The incorrect `min_readable_version` persists until the node performs new pruning operations, which may never happen if the node is caught up and not actively pruning

This qualifies as "Significant protocol violations" and "API crashes" under the High severity category.

## Likelihood Explanation

**Likelihood: MEDIUM**

The vulnerability requires specific conditions but can occur in realistic scenarios:

**Trigger Conditions:**
- Database has been partially pruned (common in production nodes)
- `LedgerPrunerProgress` metadata is lost or corrupted

**Realistic Scenarios:**
1. **Partial database restore**: Operator restores data files but metadata is missing or from different snapshot
2. **Database corruption**: Hardware failure or software bug corrupts the metadata portion
3. **Manual intervention**: Operator manually deletes or modifies database files incorrectly
4. **Database migration issues**: Errors during database upgrades or migrations

While metadata loss is not an everyday occurrence, it's a realistic operational scenario that nodes must handle correctly. The severity is amplified because there's no automatic recovery mechanism.

## Recommendation

Implement proper recovery logic in `get_ledger_pruner_progress()` similar to what exists in `LedgerMetadataPruner::new()`. Instead of defaulting to 0, scan the database to find the actual first available version:

```rust
pub(crate) fn get_ledger_pruner_progress(ledger_db: &LedgerDb) -> Result<Version> {
    // Try to get progress from metadata
    if let Ok(progress) = ledger_db.metadata_db().get_pruner_progress() {
        return Ok(progress);
    }
    
    // Metadata not found - attempt recovery by scanning database
    warn!("LedgerPrunerProgress metadata not found, attempting recovery");
    
    // Scan VersionDataSchema to find first available version
    let mut iter = ledger_db.metadata_db().db().iter::<VersionDataSchema>()?;
    iter.seek_to_first();
    
    let recovered_version = match iter.next().transpose()? {
        Some((version, _)) => {
            warn!("Recovered min_readable_version: {}", version);
            version
        },
        None => {
            // No data found, default to 0
            0
        }
    };
    
    // Write recovered progress back to database
    ledger_db.metadata_db().write_pruner_progress(recovered_version)?;
    
    Ok(recovered_version)
}
```

Alternatively, use the progress from the `LedgerPruner` instance instead of querying the database separately:

```rust
pub fn new(
    ledger_db: Arc<LedgerDb>,
    ledger_pruner_config: LedgerPrunerConfig,
    internal_indexer_db: Option<InternalIndexerDB>,
) -> Self {
    let (pruner_worker, min_readable_version) = if ledger_pruner_config.enable {
        let worker = Self::init_pruner(
            Arc::clone(&ledger_db),
            ledger_pruner_config,
            internal_indexer_db,
        );
        let progress = worker.inner.pruner.progress(); // Get actual progress from pruner
        (Some(worker), progress)
    } else {
        let progress = pruner_utils::get_ledger_pruner_progress(&ledger_db)
            .expect("Must succeed.");
        (None, progress)
    };
    
    // ... rest of initialization using min_readable_version
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_temppath::TempPath;
    
    #[test]
    fn test_lost_metadata_recovery() {
        // Setup: Create a database and prune it
        let tmpdir = TempPath::new();
        let db = AptosDB::new_for_test(&tmpdir);
        
        // Write transactions 0-1999
        for version in 0..2000 {
            // Write transaction data
            db.save_transactions(..., version, ...);
        }
        
        // Prune versions 0-999
        let ledger_pruner = LedgerPruner::new(db.ledger_db(), None).unwrap();
        ledger_pruner.set_target_version(1000);
        ledger_pruner.prune(1000).unwrap();
        
        // Verify progress metadata exists
        assert_eq!(
            db.ledger_db().metadata_db().get_pruner_progress().unwrap(),
            1000
        );
        
        // Simulate metadata loss by deleting it
        db.ledger_db()
            .metadata_db()
            .db()
            .delete::<DbMetadataSchema>(&DbMetadataKey::LedgerPrunerProgress)
            .unwrap();
        
        // Close and reopen database
        drop(db);
        let db = AptosDB::open(&tmpdir, false, NO_OP_STORAGE_PRUNER_CONFIG, RocksdbConfigs::default(), false, 10000).unwrap();
        
        // BUG: min_readable_version is now 0, not 1000
        let min_readable = db.ledger_pruner.get_min_readable_version();
        assert_eq!(min_readable, 0); // WRONG! Should be 1000
        
        // Query for pruned version 500 passes check but fails with NotFound
        let result = db.get_transaction_by_version(500, 1999, false);
        
        // BUG: Returns NotFound instead of proper "pruned" error
        match result {
            Err(e) => {
                let error_msg = format!("{:?}", e);
                assert!(error_msg.contains("NotFound")); // WRONG ERROR!
                // Should be: "Transaction at version 500 is pruned, min available version is 1000"
            },
            Ok(_) => panic!("Should have failed"),
        }
    }
}
```

**Notes**

The vulnerability stems from a disconnect between two initialization paths: one that has recovery logic (`LedgerMetadataPruner`) and one that doesn't (`LedgerPrunerManager`). The fix requires either implementing recovery in the fallback path or using the recovered value from the pruner instance. This is a data integrity issue that violates the assumption that metadata accurately reflects database state, causing operational failures and incorrect API behavior.

### Citations

**File:** storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs (L123-124)
```rust
        let min_readable_version =
            pruner_utils::get_ledger_pruner_progress(&ledger_db).expect("Must succeed.");
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs (L162-176)
```rust
    fn set_pruner_target_db_version(&self, latest_version: Version) {
        assert!(self.pruner_worker.is_some());
        let min_readable_version = latest_version.saturating_sub(self.prune_window);
        self.min_readable_version
            .store(min_readable_version, Ordering::SeqCst);

        PRUNER_VERSIONS
            .with_label_values(&["ledger_pruner", "min_readable"])
            .set(min_readable_version as i64);

        self.pruner_worker
            .as_ref()
            .unwrap()
            .set_target_db_version(min_readable_version);
    }
```

**File:** storage/aptosdb/src/pruner/pruner_utils.rs (L19-21)
```rust
pub(crate) fn get_ledger_pruner_progress(ledger_db: &LedgerDb) -> Result<Version> {
    Ok(ledger_db.metadata_db().get_pruner_progress().unwrap_or(0))
}
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L85-88)
```rust
    pub(crate) fn get_pruner_progress(&self) -> Result<Version> {
        get_progress(&self.db, &DbMetadataKey::LedgerPrunerProgress)?
            .ok_or_else(|| AptosDbError::NotFound("No LedgerPrunerProgress in db.".to_string()))
    }
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/ledger_metadata_pruner.rs (L20-37)
```rust
        if let Some(v) =
            ledger_metadata_db.get::<DbMetadataSchema>(&DbMetadataKey::LedgerPrunerProgress)?
        {
            v.expect_version();
        } else {
            // NOTE: I **think** all db should have the LedgerPrunerProgress. Have a fallback path
            // here in case the database was super old before we introducing this progress counter.
            let mut iter = ledger_metadata_db.iter::<VersionDataSchema>()?;
            iter.seek_to_first();
            let version = match iter.next().transpose()? {
                Some((version, _)) => version,
                None => 0,
            };
            ledger_metadata_db.put::<DbMetadataSchema>(
                &DbMetadataKey::LedgerPrunerProgress,
                &DbMetadataValue::Version(version),
            )?;
        }
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L261-271)
```rust
    pub(super) fn error_if_ledger_pruned(&self, data_type: &str, version: Version) -> Result<()> {
        let min_readable_version = self.ledger_pruner.get_min_readable_version();
        ensure!(
            version >= min_readable_version,
            "{} at version {} is pruned, min available version is {}.",
            data_type,
            version,
            min_readable_version
        );
        Ok(())
    }
```

**File:** storage/aptosdb/src/ledger_db/transaction_db.rs (L56-60)
```rust
    pub(crate) fn get_transaction(&self, version: Version) -> Result<Transaction> {
        self.db
            .get::<TransactionSchema>(&version)?
            .ok_or_else(|| AptosDbError::NotFound(format!("Txn {version}")))
    }
```
