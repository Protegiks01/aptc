# Audit Report

## Title
Byzantine Validators Can Crash Honest Nodes via Empty Weights HashMap in Secret Share Aggregation

## Summary
A Byzantine validator can crash any honest validator node by sending secret shares with matching metadata before the honest node processes its own self share. This triggers a panic in the `retain()` method due to an uninitialized weights HashMap, causing a denial-of-service attack that violates consensus liveness guarantees.

## Finding Description

The vulnerability exists in the secret sharing aggregation system used for consensus randomness. The core issue is that `SecretShareConfig.weights` is initialized as an empty HashMap and never populated, [1](#0-0)  but the code assumes this HashMap contains weight entries for all validators.

When an honest node processes its self-generated secret share, the following attack sequence occurs:

**Attack Flow:**

1. Byzantine validators send their secret shares with specific metadata (epoch, round, timestamp, block_id, digest) to target honest nodes
2. These shares pass cryptographic verification [2](#0-1)  and are added to the `SecretShareAggregator` in `PendingMetadata` state [3](#0-2) 
3. When the honest node processes its own self share via `add_self_share()`, it calls `add_share_with_metadata()` [4](#0-3) 
4. This invokes `retain()` with the self share's metadata and the empty weights HashMap from `get_peer_weights()` [5](#0-4) [6](#0-5) 
5. The `retain()` method filters shares to keep only those with matching metadata [7](#0-6) 
6. If Byzantine shares have matching metadata, they survive the filter
7. `retain()` then attempts to recalculate `total_weight` by looking up each author in the weights HashMap [8](#0-7) 
8. **PANIC**: The `expect("Author must exist for weight")` fails because the HashMap is empty [9](#0-8) 

This violates the invariant that AptosBFT must maintain liveness under < 1/3 Byzantine validators. The system should gracefully handle Byzantine shares without crashing honest nodes.

## Impact Explanation

**Severity: High** (per Aptos Bug Bounty: "Validator node slowdowns, API crashes, Significant protocol violations")

This vulnerability allows Byzantine validators to:
- **Crash honest validator nodes** by triggering unhandled panics
- **Cause consensus liveness failures** if enough honest validators crash simultaneously
- **Violate Byzantine fault tolerance guarantees** since the system should tolerate < 1/3 Byzantine behavior without crashes

The attack requires minimal resources:
- Byzantine validators can send shares with any valid metadata
- No cryptographic forgery is required (validators send their own valid shares)
- The attack can be repeated for every round/block to maintain denial-of-service

This breaks **Critical Invariant #2**: "Consensus Safety: AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine" - while this is primarily a liveness failure, it can lead to safety issues if the network cannot maintain sufficient honest validator participation.

## Likelihood Explanation

**Likelihood: High**

The attack is highly likely to occur because:
1. **Easy to execute**: Any Byzantine validator can send shares with matching metadata
2. **Low attacker requirements**: Only requires validator status, no cryptographic attacks needed
3. **Deterministic trigger**: The panic occurs reliably when Byzantine shares with matching metadata exist before self share processing
4. **No detection mechanism**: The code has no checks to prevent this scenario
5. **Timing window**: Byzantine validators can observe block proposals and send shares preemptively

The vulnerability is present in the production code path - the `add_self_share()` method is called for every block in `process_incoming_block()` [10](#0-9) , making this a critical consensus path.

## Recommendation

**Immediate Fix**: Populate the `weights` HashMap in `SecretShareConfig` during initialization:

```rust
// In SecretShareConfig::new()
pub fn new(
    author: Author,
    epoch: u64,
    validator: Arc<ValidatorVerifier>,
    digest_key: DigestKey,
    msk_share: MasterSecretKeyShare,
    verification_keys: Vec<VerificationKey>,
    config: <FPTXWeighted as BatchThresholdEncryption>::ThresholdConfig,
    encryption_key: EncryptionKey,
) -> Self {
    // Initialize weights for all validators
    let weights: HashMap<Author, u64> = validator
        .get_ordered_account_addresses_iter()
        .map(|addr| (addr, 1u64))  // Use weight of 1 or actual voting weight
        .collect();
    
    Self {
        _author: author,
        _epoch: epoch,
        validator,
        digest_key,
        msk_share,
        verification_keys,
        config,
        encryption_key,
        weights,  // Populated HashMap
    }
}
```

**Defense-in-depth**: Add validation in `retain()` to handle missing weights gracefully:

```rust
fn retain(&mut self, metadata: &SecretShareMetadata, weights: &HashMap<Author, u64>) {
    self.shares.retain(|_, share| share.metadata == *metadata);
    self.total_weight = self
        .shares
        .keys()
        .filter_map(|author| weights.get(author).copied())  // Use filter_map instead of expect
        .sum();
    // Log warning if any weights were missing
}
```

## Proof of Concept

The vulnerability can be demonstrated with the following scenario:

**Setup**:
- Network with 4 validators: V1 (honest), V2 (Byzantine), V3, V4
- Block proposed for round R with specific metadata M

**Attack Steps**:
```
1. V2 (Byzantine) computes valid secret share for metadata M
2. V2 sends share to V1 before V1 completes self share derivation
3. V1 receives V2's share:
   - Passes verification (cryptographically valid)
   - Added to aggregator in PendingMetadata state
   - V1.shares now contains {V2: share_v2}

4. V1 completes self share derivation and calls add_self_share():
   - Calls add_share_with_metadata(self_share, peer_weights)
   - peer_weights = get_peer_weights() returns empty HashMap
   - Calls retain(self_share.metadata(), peer_weights)
   
5. In retain():
   - Filter: self.shares.retain(|_, share| share.metadata == M)
   - V2's share has matching metadata, remains in shares
   - Recalculate: shares.keys() = {V2}
   - Try: weights.get(V2).expect(...) 
   - HashMap is empty â†’ PANIC!

6. V1 crashes with: "thread panicked at 'Author must exist for weight'"
```

**Result**: Byzantine validator V2 successfully crashed honest validator V1, violating consensus liveness guarantees.

## Notes

While the security question specifically asked about the `expect()` in `try_aggregate()` [11](#0-10) , the actual exploitable panic occurs earlier in the call chain within `retain()` [9](#0-8) . Both panics are related to improper handling of the weights HashMap, but the `retain()` panic is reachable through Byzantine behavior while the `try_aggregate()` panic appears unreachable if the code reaches that point (since the self share would necessarily be present after successful `add_share_with_metadata()` execution). The vulnerability is in the same function chain and file as specified in the security question, and represents a critical Byzantine-exploitable denial-of-service attack on consensus validators.

### Citations

**File:** types/src/secret_sharing.rs (L168-168)
```rust
            weights: HashMap::new(),
```

**File:** types/src/secret_sharing.rs (L200-202)
```rust
    pub fn get_peer_weights(&self) -> &HashMap<Author, u64> {
        &self.weights
    }
```

**File:** consensus/src/rand/secret_sharing/network_messages.rs (L28-38)
```rust
    pub fn verify(
        &self,
        epoch_state: &EpochState,
        config: &SecretShareConfig,
    ) -> anyhow::Result<()> {
        ensure!(self.epoch() == epoch_state.epoch);
        match self {
            SecretShareMessage::RequestShare(_) => Ok(()),
            SecretShareMessage::Share(share) => share.verify(config),
        }
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L52-54)
```rust
        let self_share = self
            .get_self_share()
            .expect("Aggregated item should have self share");
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L75-75)
```rust
        self.shares.retain(|_, share| share.metadata == *metadata);
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L76-80)
```rust
        self.total_weight = self
            .shares
            .keys()
            .map(|author| weights.get(author).expect("Author must exist for weight"))
            .sum();
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L108-113)
```rust
    fn add_share(&mut self, share: SecretShare, share_weight: u64) -> anyhow::Result<()> {
        match self {
            SecretShareItem::PendingMetadata(aggr) => {
                aggr.add_share(share, share_weight);
                Ok(())
            },
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L168-168)
```rust
                share_aggregator.retain(share.metadata(), share_weights);
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L254-254)
```rust
        item.add_share_with_metadata(share, peer_weights)?;
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L145-147)
```rust
            secret_share_store
                .add_self_share(self_secret_share.clone())
                .expect("Add self dec share should succeed");
```
