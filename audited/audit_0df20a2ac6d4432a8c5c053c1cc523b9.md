# Audit Report

## Title
Secret Share Aggregation Threshold Mismatch Causes Impossible-to-Meet Threshold with Weighted Validators

## Summary
The secret share aggregation logic in `SecretShareStore` compares the number of received shares (counted with weight=1 per share) against a threshold value expressed in weight units from a weighted threshold configuration. When validators have non-uniform stake weights, this mismatch can make the reconstruction threshold mathematically impossible to achieve, breaking randomness generation liveness even when all honest validators (>2/3 stake) participate.

## Finding Description
The vulnerability exists in how `SecretShareConfig` and `SecretShareAggregator` handle weighted validator configurations: [1](#0-0) 

The `threshold()` method returns the threshold value `t` from the underlying `WeightedConfigArkworks`, which represents the minimum weight (not count) needed for reconstruction. However, `get_peer_weight()` is hardcoded to return `1`, completely ignoring the actual validator weights stored in the weighted configuration. [2](#0-1) 

When shares are added, each validator contributes `weight=1` to `total_weight` regardless of their actual stake weight. The aggregation check compares this count-based `total_weight` against the weight-based `threshold()`, creating a unit mismatch.

**Attack Scenario:**
1. DKG rounding produces a weighted configuration based on validator stakes
2. Example: 10 validators with equal stake, total weight 100, reconstruction threshold 67 (for 2/3 safety)
3. Each validator contributes 1 share with `get_peer_weight()` returning 1
4. Maximum achievable `total_weight` = 10 (number of validators)
5. Required `threshold()` = 67 (weight units)
6. Condition `total_weight < threshold()` is always true: 10 < 67
7. Aggregation never triggers, randomness cannot be generated

Byzantine validators don't need to actively attack—the system breaks automatically when validator weights are non-uniform and the total weight exceeds the validator count. This violates the consensus liveness invariant.

## Impact Explanation
This is a **Critical Severity** vulnerability under the Aptos bug bounty criteria:

- **Total loss of liveness/network availability**: When the weighted threshold exceeds the number of validators, secret share reconstruction becomes impossible, preventing randomness generation
- **Consensus disruption**: Randomness is critical for leader election and other consensus mechanisms; its failure can halt block production
- **Non-recoverable without intervention**: The system cannot self-heal; requires coordinator intervention or hardfork to adjust weights [3](#0-2) 

The DKG rounding system intentionally creates weighted configurations where weights are proportional to validator stakes. This is the expected design for weighted secret sharing, but the aggregation logic fails to respect these weights.

## Likelihood Explanation
**High likelihood** of occurrence:

1. The system is designed to support weighted validators based on stake
2. The DKG rounding algorithm actively creates non-uniform weight distributions
3. The bug triggers automatically without requiring Byzantine behavior
4. The comment "This is temporary and meant to change in future PRs" suggests this is a known incomplete implementation [4](#0-3) 

The vulnerability affects any deployment using weighted validators with total weight > validator count, which is the expected configuration for stake-weighted systems.

## Recommendation
Fix `SecretShareConfig.get_peer_weight()` to return actual validator weights from the weighted configuration:

```rust
pub fn get_peer_weight(&self, peer: &Author) -> u64 {
    let player = Player {
        id: self.get_id(peer),
    };
    self.config.get_player_weight(&player) as u64
}
```

Also populate the `weights` HashMap during initialization by extracting weights from the `WeightedConfigArkworks` configuration. Alternatively, follow the pattern used in `RandConfig`: [5](#0-4) 

The `RandConfig` correctly retrieves weights from `wconfig`, which should be the model for `SecretShareConfig`.

## Proof of Concept
```rust
// Demonstration of the threshold mismatch
use aptos_crypto::weighted_config::WeightedConfigArkworks;
use aptos_crypto::traits::ThresholdConfig;

#[test]
fn test_threshold_mismatch() {
    // Create weighted config: 10 validators, each with weight 10
    // Total weight = 100, threshold = 67 (for 2/3 reconstruction)
    let weights = vec![10usize; 10];
    let config = WeightedConfigArkworks::new(67, weights).unwrap();
    
    // Threshold from config is in weight units
    assert_eq!(config.get_threshold_weight(), 67);
    
    // Number of validators
    let num_validators = 10;
    
    // In SecretShareAggregator, total_weight accumulates as:
    // total_weight = num_shares * 1 (because get_peer_weight returns 1)
    let max_total_weight = num_validators; // = 10
    
    // The check: total_weight < threshold()
    // 10 < 67 → always true, aggregation never happens!
    assert!(max_total_weight < config.get_threshold_weight());
    
    // This proves the threshold is impossible to meet
    println!("Maximum achievable weight: {}", max_total_weight);
    println!("Required threshold: {}", config.get_threshold_weight());
    println!("Threshold is impossible to meet!");
}
```

## Notes
The vulnerability stems from an incomplete implementation where `SecretShareConfig` stores a weighted threshold configuration but doesn't use its weight information during aggregation. This creates a critical mismatch between threshold units (weights) and accumulated units (validator counts), breaking the secret sharing protocol's ability to reconstruct secrets when weights are non-uniform.

### Citations

**File:** types/src/secret_sharing.rs (L134-135)
```rust
/// This is temporary and meant to change in future PRs
#[derive(Clone)]
```

**File:** types/src/secret_sharing.rs (L188-198)
```rust
    pub fn threshold(&self) -> u64 {
        self.config.get_threshold_config().t as u64
    }

    pub fn number_of_validators(&self) -> u64 {
        self.config.get_threshold_config().n as u64
    }

    pub fn get_peer_weight(&self, _peer: &Author) -> u64 {
        1
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L32-46)
```rust
    pub fn add_share(&mut self, share: SecretShare, weight: u64) {
        if self.shares.insert(share.author, share).is_none() {
            self.total_weight += weight;
        }
    }

    pub fn try_aggregate(
        self,
        secret_share_config: &SecretShareConfig,
        metadata: SecretShareMetadata,
        decision_tx: Sender<SecretSharedKey>,
    ) -> Either<Self, SecretShare> {
        if self.total_weight < secret_share_config.threshold() {
            return Either::Left(self);
        }
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L98-106)
```rust
        let wconfig = WeightedConfigBlstrs::new(
            profile.reconstruct_threshold_in_weights as usize,
            profile
                .validator_weights
                .iter()
                .map(|w| *w as usize)
                .collect(),
        )
        .unwrap();
```

**File:** consensus/src/rand/rand_gen/types.rs (L676-685)
```rust
    pub fn get_peer_weight(&self, peer: &Author) -> u64 {
        let player = Player {
            id: self.get_id(peer),
        };
        self.wconfig.get_player_weight(&player) as u64
    }

    pub fn threshold(&self) -> u64 {
        self.wconfig.get_threshold_weight() as u64
    }
```
