# Audit Report

## Title
Script Cache Poisoning via Dependency Version Mismatch in Parallel Execution

## Summary
The script cache in BlockSTM parallel execution lacks versioning and dependency validation, allowing speculative transaction executions to poison the cache with scripts verified against modules that are later invalidated. This causes subsequent honest transactions to fail unexpectedly with FUNCTION_RESOLUTION_FAILURE errors.

## Finding Description

The vulnerability exists in how the Move VM caches compiled scripts during parallel block execution. Unlike the module cache which tracks versions using `Option<TxnIndex>`, the script cache has no versioning mechanism and never invalidates entries. [1](#0-0) 

When a script is verified and cached, it's verified against the module dependencies visible at that moment. However, if those dependencies are later invalidated (due to transaction abort or re-execution), the cached script persists: [2](#0-1) 

The critical flaw is at line 111 where cached verified scripts are returned immediately without dependency validation: [3](#0-2) 

**Attack Scenario:**
1. Transaction T1 publishes module M version v2 (speculatively)
2. Transaction T2 executes script S that imports M, loads M_v2 from T1's speculative write, verifies S against M_v2, and caches Verified(S) with hash H
3. T1 aborts or fails validation, M_v2 is rolled back
4. Transaction T3 (honest user) submits the same script S bytecode
5. T3 computes hash H, finds cached Verified(S), uses it
6. At runtime, S attempts to call functions in M, but sees baseline M_v1 (or no M at all)
7. Function resolution fails with FUNCTION_RESOLUTION_FAILURE, causing T3 to abort

The ScriptCache trait provides no invalidation mechanism: [4](#0-3) 

This breaks the **Deterministic Execution** invariant - honest transactions fail unpredictably based on cache state from invalidated speculative executions.

## Impact Explanation

**Severity: Medium** (up to $10,000)

This qualifies as "State inconsistencies requiring intervention" because:

1. **Transaction Failures**: Legitimate user transactions fail with FUNCTION_RESOLUTION_FAILURE despite submitting valid script bytecode
2. **Block-Scoped DoS**: All transactions in the affected block using the poisoned script will fail
3. **Non-Deterministic Behavior**: Transaction success depends on execution order and cache state, not just transaction content
4. **Availability Impact**: Users cannot execute legitimate scripts during the affected block

While not Critical severity (no fund loss, no consensus break since it's block-scoped), it causes user-facing failures and requires block-level intervention (cache clearing between blocks prevents cross-block persistence).

## Likelihood Explanation

**Likelihood: Medium-High**

The attack is feasible because:

1. **No Special Privileges Required**: Any user can submit module publishes and scripts
2. **Natural Occurrence**: Can happen accidentally during normal parallel execution without malicious intent
3. **Parallel Execution Default**: BlockSTM runs by default with concurrency_level > 1
4. **Common Pattern**: Scripts depending on newly published modules is a legitimate use case

An attacker can deliberately trigger this by:
- Publishing a module in T1 with low gas (likely to fail/abort)
- Submitting a script depending on that module in T2
- Causing T1 to abort (insufficient gas, dependency conflict)
- Observing T3 fail when using the same script

## Recommendation

Add versioning or dependency tracking to the script cache similar to the module cache. Specifically:

1. **Track Dependencies**: Record which module versions were used during script verification
2. **Validate on Cache Hit**: Before returning a cached script, verify its dependencies haven't changed
3. **Add Version Parameter**: Extend ScriptCache to track versions like ModuleCache does

**Proposed Fix:**

```rust
// Extend the script cache entry to include dependency hashes
pub struct VersionedScript {
    script: Script,
    dependency_hashes: Vec<([u8; 32], Option<TxnIndex>)>, // (module_hash, version)
}

// In unmetered_verify_and_cache_script:
fn unmetered_verify_and_cache_script(&self, serialized_script: &[u8]) -> VMResult<Arc<Script>> {
    let hash = sha3_256(serialized_script);
    
    // Check if cached script's dependencies are still valid
    if let Some(Verified(cached)) = self.module_storage.get_script(&hash) {
        if self.validate_script_dependencies(&cached) {
            return Ok(cached);
        }
        // Dependencies changed - need to re-verify
    }
    
    // ... rest of verification logic
}
```

Alternatively, invalidate the entire script cache when any module in the per-block cache is updated or removed.

## Proof of Concept

```rust
// Conceptual PoC (would need full test harness to run):

// Block with 3 transactions
let block = vec![
    // T1: Publish module M_v2 (will abort due to low gas)
    Transaction::ModuleBundle {
        code: compile_module("module 0x1::M { public fun new_func(): u64 { 42 } }"),
        gas_limit: 100, // Insufficient - will abort
    },
    
    // T2: Execute script S depending on M::new_func
    Transaction::Script {
        code: compile_script("script { use 0x1::M; fun main() { M::new_func(); } }"),
        gas_limit: 1000000,
    },
    
    // T3: Same script as T2 (honest user)
    Transaction::Script {
        code: compile_script("script { use 0x1::M; fun main() { M::new_func(); } }"),
        gas_limit: 1000000,
    },
];

// Execute in parallel
let results = block_executor.execute_block(block);

// Expected: T1 fails (out of gas), T2 and T3 should succeed (or both fail)
// Actual: T1 fails, T2 may succeed/fail, T3 FAILS with FUNCTION_RESOLUTION_FAILURE
// because it uses cached script verified against non-existent M_v2

assert_eq!(results[2].status(), ExecutionStatus::MiscellaneousError);
assert!(results[2].error_message().contains("FUNCTION_RESOLUTION_FAILURE"));
```

## Notes

The vulnerability is confirmed by the absence of any invalidation mechanism in the ScriptCache trait and the lack of dependency validation when returning cached scripts. Module reads ARE captured for validation purposes, but the script cache itself is never cleared when those reads are invalidated, creating a cache coherency issue.

### Citations

**File:** aptos-move/mvhashmap/src/lib.rs (L46-48)
```rust
    module_cache:
        SyncModuleCache<ModuleId, CompiledModule, Module, AptosModuleExtension, Option<TxnIndex>>,
    script_cache: SyncScriptCache<[u8; 32], CompiledScript, Script>,
```

**File:** third_party/move/move-vm/runtime/src/storage/loader/eager.rs (L106-138)
```rust
    fn unmetered_verify_and_cache_script(&self, serialized_script: &[u8]) -> VMResult<Arc<Script>> {
        use Code::*;

        let hash = sha3_256(serialized_script);
        let deserialized_script = match self.module_storage.get_script(&hash) {
            Some(Verified(script)) => return Ok(script),
            Some(Deserialized(deserialized_script)) => deserialized_script,
            None => self
                .runtime_environment()
                .deserialize_into_script(serialized_script)
                .map(Arc::new)?,
        };

        let locally_verified_script = self
            .runtime_environment()
            .build_locally_verified_script(deserialized_script)?;

        let immediate_dependencies = locally_verified_script
            .immediate_dependencies_iter()
            .map(|(addr, name)| {
                self.module_storage
                    .unmetered_get_existing_eagerly_verified_module(addr, name)
            })
            .collect::<VMResult<Vec<_>>>()?;

        let verified_script = self
            .runtime_environment()
            .build_verified_script(locally_verified_script, &immediate_dependencies)?;

        Ok(self
            .module_storage
            .insert_verified_script(hash, verified_script))
    }
```

**File:** third_party/move/move-vm/types/src/code/cache/script_cache.rs (L11-41)
```rust
/// Interface used by any script cache implementation.
#[delegatable_trait]
pub trait ScriptCache {
    type Key: Eq + Hash + Clone;
    type Deserialized;
    type Verified;

    /// If the entry associated with the key is vacant, inserts the script and returns its copy.
    /// Otherwise, there is no insertion and the copy of existing entry is returned.
    fn insert_deserialized_script(
        &self,
        key: Self::Key,
        deserialized_script: Self::Deserialized,
    ) -> Arc<Self::Deserialized>;

    /// If the entry associated with the key is vacant, inserts the script and returns its copy.
    /// If the entry associated with the key is occupied, but the entry is not verified, inserts
    /// the script returning the copy. Otherwise, there is no insertion and the copy of existing
    /// (verified) entry is returned.
    fn insert_verified_script(
        &self,
        key: Self::Key,
        verified_script: Self::Verified,
    ) -> Arc<Self::Verified>;

    /// Returns the script if it has been cached before, or [None] otherwise.
    fn get_script(&self, key: &Self::Key) -> Option<Code<Self::Deserialized, Self::Verified>>;

    /// Returns the number of scripts stored in cache.
    fn num_scripts(&self) -> usize;
}
```
