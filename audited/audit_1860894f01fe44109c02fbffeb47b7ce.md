# Audit Report

## Title
Resource Group Metadata Validation Bypass Allows Type Parameter Injection Leading to State Inconsistency

## Summary
The `validate_resource_groups` function fails to validate that resource group member attributes specify resource groups without type parameters, allowing attackers to publish modules that reference the same resource group with different type arguments, causing resources to be stored at different StateKeys and breaking state consistency invariants.

## Finding Description

The resource group validation in [1](#0-0)  only validates the resource group by name lookup, not by the full StructTag including type parameters.

When a resource group member attribute is parsed in [2](#0-1) , it successfully parses StructTags that include type parameters. However, the validation logic [3](#0-2)  only checks:
1. That a group with the given NAME exists (line 91)
2. That the scope is compatible (line 97)

It does NOT validate that the StructTag's `type_args` field is empty, even though resource groups themselves cannot have type parameters as enforced in [4](#0-3) .

At runtime, when resources are stored, the StateKey is computed using the full StructTag including type parameters in [5](#0-4) . This means:
- Resources with `#[resource_group_member(group = 0x1::foo::Bar)]` → stored at StateKey(Bar, type_args=[])  
- Resources with `#[resource_group_member(group = 0x1::foo::Bar<u64>)]` → stored at StateKey(Bar, type_args=[u64])

These are DIFFERENT storage locations, violating the invariant that all members of a resource group are stored together.

**Attack Path:**
1. Legitimate Module A publishes struct `Bar` as `#[resource_group(scope = global)]` (no type parameters, as required)
2. Malicious Module B publishes struct `Foo` with `#[resource_group_member(group = 0x1::A::Bar<u64>)]`
3. Validation parses the StructTag successfully and finds "Bar" in the groups map, passing validation
4. At runtime in [6](#0-5) , the resource group tag with type parameters is used to create the StateKey
5. Foo resources are stored separately from other Bar group members, breaking state consistency

## Impact Explanation

**High Severity** - This vulnerability causes:

1. **State Consistency Violation**: Resources that should be in the same group are fragmented across multiple storage locations, breaking the fundamental guarantee of resource groups.

2. **Gas Calculation Errors**: Resource group size is computed incorrectly as shown in [7](#0-6) , leading to incorrect gas charges.

3. **Deterministic Execution Risk**: Different validators might handle malformed metadata inconsistently, potentially causing consensus divergence.

4. **Storage Corruption**: The invariant checking in [8](#0-7)  may fail unpredictably when the same resource appears to exist in multiple groups.

This qualifies as "Significant protocol violations" under High Severity ($50,000) and potentially "State inconsistencies requiring intervention" under Medium Severity.

## Likelihood Explanation

**High Likelihood** - The attack requires only:
1. Ability to publish a Move module (available to any user)
2. Knowledge of an existing resource group's StructTag
3. Adding type parameters to the group reference in the attribute

No special permissions, validator access, or complex setup is required. The validation gap is deterministic and always allows this bypass.

## Recommendation

Add validation in `validate_resource_groups` to ensure that resource group StructTags in member attributes have empty type parameters:

```rust
// In aptos-move/aptos-vm/src/verifier/resource_groups.rs, after line 92
if !group_tag.type_args.is_empty() {
    return Err(metadata_validation_error(
        "resource_group reference cannot have type parameters"
    ));
}
```

Additionally, validate that the full StructTag (not just the name) matches the group definition:

```rust
// After extracting the group scope, validate the complete StructTag
let expected_group_tag = StructTag {
    address: group_module_id.address().clone(),
    module: group_module_id.name().to_owned(),
    name: group_tag.name.clone(),
    type_args: vec![], // Resource groups cannot have type params
};

if group_tag != &expected_group_tag {
    return Err(metadata_validation_error(
        "resource_group_member attribute must reference group without type parameters"
    ));
}
```

## Proof of Concept

```move
// Module A (legitimate resource group)
module 0x1::group_module {
    #[resource_group(scope = global)]
    struct MyGroup has key {
        dummy: u64
    }
}

// Module B (malicious - exploits validation gap)
module 0x2::exploit_module {
    use 0x1::group_module::MyGroup;
    
    // This should be rejected but passes validation!
    // Specifies MyGroup<u64> even though MyGroup has no type parameters
    #[resource_group_member(group = 0x1::group_module::MyGroup<u64>)]
    struct MaliciousResource has key {
        value: u64
    }
    
    public fun create(account: &signer) {
        move_to(account, MaliciousResource { value: 42 });
    }
}

// Result: MaliciousResource is stored at StateKey for MyGroup<u64>
// instead of StateKey for MyGroup, fragmenting the resource group
```

The validation will pass because it only checks that "MyGroup" exists by name, but at runtime the resource will be stored at a different StateKey due to the type parameter, violating state consistency.

---

**Notes:**

This vulnerability demonstrates a critical gap between compile-time validation and runtime behavior. The resource group system assumes that all members of a group are co-located for gas efficiency and atomic operations, but malicious metadata can silently fragment this storage. The fix requires strengthening the validation to reject any type parameters in resource group references, matching the restriction already enforced on resource group definitions themselves.

### Citations

**File:** aptos-move/aptos-vm/src/verifier/resource_groups.rs (L57-100)
```rust
    for (module_id, inner_members) in members {
        for group_tag in inner_members.values() {
            let group_module_id = group_tag.module_id();
            if !groups.contains_key(&group_module_id) {
                // Note: module must exist for the group member to refer to it! Also, we need to
                // charge gas because this module is not in a bundle.
                if features.is_lazy_loading_enabled()
                    && traversal_context.visit_if_not_special_module_id(&group_module_id)
                {
                    let size = module_storage.unmetered_get_existing_module_size(
                        group_module_id.address(),
                        group_module_id.name(),
                    )?;
                    gas_meter
                        .charge_dependency(
                            DependencyKind::Existing,
                            group_module_id.address(),
                            group_module_id.name(),
                            NumBytes::new(size as u64),
                        )
                        .map_err(|err| err.finish(Location::Undefined))?;
                }
                let old_module = module_storage.unmetered_get_existing_deserialized_module(
                    group_module_id.address(),
                    group_module_id.name(),
                )?;

                let (inner_groups, _, _) =
                    extract_resource_group_metadata_from_module(&old_module)?;
                groups.insert(group_tag.module_id(), inner_groups);
            }

            let scope = if let Some(inner_group) = groups.get(&group_module_id) {
                inner_group
                    .get(group_tag.name.as_ident_str().as_str())
                    .ok_or_else(|| metadata_validation_error("Invalid resource_group attribute"))?
            } else {
                return Err(metadata_validation_error("No such resource_group"));
            };

            if !scope.are_equal_module_ids(&module_id, &group_module_id) {
                metadata_validation_err("Scope mismatch")?;
            }
        }
```

**File:** types/src/vm/module_metadata.rs (L138-144)
```rust
    pub fn get_resource_group_member(&self) -> Option<StructTag> {
        if self.kind == KnownAttributeKind::ResourceGroupMember as u8 {
            self.args.first()?.parse().ok()
        } else {
            None
        }
    }
```

**File:** types/src/vm/module_metadata.rs (L408-410)
```rust
            if struct_handle.abilities == AbilitySet::EMPTY
                && struct_handle.type_parameters.is_empty()
                && num_fields == 1
```

**File:** types/src/access_path.rs (L125-136)
```rust
    pub fn resource_group_path_vec(tag: StructTag) -> Vec<u8> {
        bcs::to_bytes(&Path::ResourceGroup(tag)).expect("Unexpected serialization error")
    }

    /// Convert Accesses into a byte offset which would be used by the storage layer to resolve
    /// where fields are stored.
    pub fn resource_group_access_path(address: AccountAddress, type_: StructTag) -> AccessPath {
        AccessPath {
            address,
            path: AccessPath::resource_group_path_vec(type_),
        }
    }
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/mod.rs (L366-399)
```rust
                let resource_group_tag = {
                    // INVARIANT:
                    //   We do not need to meter metadata access here. If this resource is in data
                    //   cache, we must have already fetched metadata for its tag.
                    let module = module_storage
                        .unmetered_get_existing_deserialized_module(
                            &struct_tag.address,
                            &struct_tag.module,
                        )
                        .map_err(|e| e.to_partial())?;

                    get_resource_group_member_from_metadata(&struct_tag, &module.metadata)
                };

                if let Some(resource_group_tag) = resource_group_tag {
                    if resource_groups
                        .entry(resource_group_tag)
                        .or_default()
                        .insert(struct_tag, blob_op)
                        .is_some()
                    {
                        return Err(common_error());
                    }
                } else {
                    resources_filtered.insert(struct_tag, blob_op);
                }
            }

            change_set_filtered
                .add_account_changeset(addr, AccountChangeSet::from_resources(resources_filtered))
                .map_err(|_| common_error())?;

            for (resource_group_tag, resources) in resource_groups {
                let state_key = StateKey::resource_group(&addr, &resource_group_tag);
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/mod.rs (L417-424)
```rust
                        for (struct_tag, current_op) in resources.iter() {
                            let exists =
                                resolver.resource_exists_in_group(&state_key, struct_tag)?;
                            if matches!(current_op, MoveStorageOp::New(_)) == exists {
                                // Deletion and Modification require resource to exist,
                                // while creation requires the resource to not exist.
                                return Err(common_error());
                            }
```

**File:** aptos-move/aptos-vm/src/data_cache.rs (L112-120)
```rust
            let first_access = self.accessed_groups.borrow_mut().insert(key.clone());
            let group_size = if first_access {
                self.resource_group_view.resource_group_size(&key)?.get()
            } else {
                0
            };

            let buf_size = resource_size(&buf);
            Ok((buf, buf_size + group_size as usize))
```
