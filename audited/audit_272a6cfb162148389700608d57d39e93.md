# Audit Report

## Title
Inconsistent Event Emission in Collection Mutations Due to Incomplete Feature Flag Migration

## Summary
The `collection.move` module exhibits inconsistent event emission behavior when multiple collection fields are mutated within a single transaction. The `set_name()` function always emits v2 `Mutation` events with complete mutation details, while `set_description()` and `set_uri()` conditionally emit events based on the `module_event_migration_enabled()` feature flag. When this flag is disabled, description and URI mutations emit v1 `MutationEvent` events that lack critical fields (old_value, new_value, collection reference), creating incomplete and inconsistent mutation history in event logs. [1](#0-0) [2](#0-1) [3](#0-2) 

## Finding Description

The vulnerability stems from an incomplete migration to the v2 event system in the collection mutation functions. The v2 `Mutation` event structure includes complete mutation information: [4](#0-3) 

While the v1 `MutationEvent` structure only contains the field name: [5](#0-4) 

The `set_name()` function unconditionally emits v2 events, bypassing the feature flag check entirely. In contrast, `set_description()` and `set_uri()` respect the `module_event_migration_enabled()` feature flag: [6](#0-5) 

**Exploitation Scenario:**

When `module_event_migration_enabled()` returns false (which occurs when feature flag 57 is not enabled on the network), a transaction that performs multiple collection mutations will emit:
1. Complete v2 `Mutation` event for `set_name()` with collection, old_value, and new_value
2. Incomplete v1 `MutationEvent` for `set_description()` with only the field name
3. Incomplete v1 `MutationEvent` for `set_uri()` with only the field name

This breaks the **event log integrity invariant** where all mutations of the same type should provide consistent historical information.

## Impact Explanation

**Severity: Medium**

This vulnerability qualifies as Medium severity under "State inconsistencies requiring intervention" because:

1. **Incomplete Audit Trail**: Event logs serve as the authoritative historical record for on-chain state changes. Indexers, marketplaces, and auditing tools rely on complete event data to reconstruct mutation history. Missing old/new values prevent proper tracking of collection metadata evolution.

2. **Indexer Corruption**: Off-chain systems that aggregate event data will have partial records, making it impossible to:
   - Verify the complete mutation timeline
   - Detect unauthorized or suspicious changes
   - Provide accurate historical views to end users

3. **Marketplace Impact**: NFT marketplaces and analytics platforms that display collection history based on events will show incomplete information, potentially affecting:
   - Collection authenticity verification
   - Value assessments based on mutation patterns
   - Fraud detection systems

4. **Intervention Required**: While on-chain state remains consistent, the event log inconsistency requires manual intervention to:
   - Query on-chain state directly to fill gaps
   - Implement workarounds in indexer logic
   - Potentially re-index from scratch with custom logic

The issue does not affect consensus or on-chain state correctness but compromises the integrity of the event system, which is a critical component for off-chain infrastructure.

## Likelihood Explanation

**Likelihood: High**

This issue will occur deterministically whenever:
1. The `MODULE_EVENT_MIGRATION` feature flag (value 57) is disabled on the network
2. A collection owner performs multiple field mutations in a single transaction

The feature flag is described as "transient" in the codebase, meaning it's intended for gradual rollout and may not always be enabled. Any collection with a `MutatorRef` can trigger this inconsistency through normal mutation operations.

## Recommendation

Standardize event emission across all collection mutation functions to use the same conditional logic. Either:

**Option 1 (Recommended)**: Make `set_name()` respect the feature flag like the other functions:

```move
public fun set_name(mutator_ref: &MutatorRef, name: String) acquires Collection {
    assert!(name.length() <= MAX_COLLECTION_NAME_LENGTH, error::out_of_range(ECOLLECTION_NAME_TOO_LONG));
    let collection = borrow_mut(mutator_ref);
    if (std::features::module_event_migration_enabled()) {
        event::emit(Mutation {
            mutated_field_name: string::utf8(b"name"),
            collection: object::address_to_object(mutator_ref.self),
            old_value: collection.name,
            new_value: name,
        });
    } else {
        event::emit_event(
            &mut collection.mutation_events,
            MutationEvent { mutated_field_name: string::utf8(b"name") },
        );
    };
    collection.name = name;
}
```

**Option 2**: Remove conditional logic from all functions and always emit v2 events, but only after ensuring the feature flag is permanently enabled network-wide.

## Proof of Concept

```move
#[test(creator = @0x123, aptos_framework = @std)]
fun test_inconsistent_mutation_events(creator: &signer, aptos_framework: &signer) acquires Collection {
    use std::features;
    
    // Ensure MODULE_EVENT_MIGRATION is disabled
    features::change_feature_flags_for_testing(
        aptos_framework, 
        vector[], 
        vector[features::get_module_event_migration_feature()]
    );
    
    let collection_name = string::utf8(b"Test Collection");
    let constructor_ref = create_collection_helper(creator, collection_name);
    let mutator_ref = generate_mutator_ref(&constructor_ref);
    let collection_addr = create_collection_address(&signer::address_of(creator), &collection_name);
    
    // Perform multiple mutations in one transaction
    set_name(&mutator_ref, string::utf8(b"New Name"));
    set_description(&mutator_ref, string::utf8(b"New Description"));
    set_uri(&mutator_ref, string::utf8(b"https://new-uri.com"));
    
    // Verify inconsistent events:
    // - set_name emits v2 Mutation event with old_value and new_value
    // - set_description emits v1 MutationEvent with only field name
    // - set_uri emits v1 MutationEvent with only field name
    
    let mutation_events = event::emitted_events<Mutation>();
    assert!(mutation_events.length() == 1, 0); // Only name mutation emitted v2 event
    
    // v1 events for description and uri cannot be verified via event::emitted_events
    // as they use the old event handle system, demonstrating the inconsistency
}
```

## Notes

The root cause is likely that `set_name()` was added or updated after the initial implementation of `set_description()` and `set_uri()`, and the developer inadvertently omitted the feature flag conditional logic. This created an unintended inconsistency in event emission behavior that violates the principle of uniform mutation event handling across all collection fields.

### Citations

**File:** aptos-move/framework/aptos-token-objects/sources/collection.move (L85-87)
```text
    struct MutationEvent has drop, store {
        mutated_field_name: String,
    }
```

**File:** aptos-move/framework/aptos-token-objects/sources/collection.move (L89-97)
```text
    #[event]
    /// Contains the mutated fields name. This makes the life of indexers easier, so that they can
    /// directly understand the behavior in a writeset.
    struct Mutation has drop, store {
        mutated_field_name: String,
        collection: Object<Collection>,
        old_value: String,
        new_value: String,
    }
```

**File:** aptos-move/framework/aptos-token-objects/sources/collection.move (L659-669)
```text
    public fun set_name(mutator_ref: &MutatorRef, name: String) acquires Collection {
        assert!(name.length() <= MAX_COLLECTION_NAME_LENGTH, error::out_of_range(ECOLLECTION_NAME_TOO_LONG));
        let collection = borrow_mut(mutator_ref);
        event::emit(Mutation {
            mutated_field_name: string::utf8(b"name") ,
            collection: object::address_to_object(mutator_ref.self),
            old_value: collection.name,
            new_value: name,
        });
        collection.name = name;
    }
```

**File:** aptos-move/framework/aptos-token-objects/sources/collection.move (L671-688)
```text
    public fun set_description(mutator_ref: &MutatorRef, description: String) acquires Collection {
        assert!(description.length() <= MAX_DESCRIPTION_LENGTH, error::out_of_range(EDESCRIPTION_TOO_LONG));
        let collection = borrow_mut(mutator_ref);
        if (std::features::module_event_migration_enabled()) {
            event::emit(Mutation {
                mutated_field_name: string::utf8(b"description"),
                collection: object::address_to_object(mutator_ref.self),
                old_value: collection.description,
                new_value: description,
            });
        } else {
            event::emit_event(
                &mut collection.mutation_events,
                MutationEvent { mutated_field_name: string::utf8(b"description") },
            );
        };
        collection.description = description;
    }
```

**File:** aptos-move/framework/aptos-token-objects/sources/collection.move (L690-707)
```text
    public fun set_uri(mutator_ref: &MutatorRef, uri: String) acquires Collection {
        assert!(uri.length() <= MAX_URI_LENGTH, error::out_of_range(EURI_TOO_LONG));
        let collection = borrow_mut(mutator_ref);
        if (std::features::module_event_migration_enabled()) {
            event::emit(Mutation {
                mutated_field_name: string::utf8(b"uri"),
                collection: object::address_to_object(mutator_ref.self),
                old_value: collection.uri,
                new_value: uri,
            });
        } else {
            event::emit_event(
                &mut collection.mutation_events,
                MutationEvent { mutated_field_name: string::utf8(b"uri") },
            );
        };
        collection.uri = uri;
    }
```

**File:** aptos-move/framework/move-stdlib/sources/configs/features.move (L465-474)
```text
    /// Whether aptos_framwork enables the behavior of module event migration.
    ///
    /// Lifetime: transient
    const MODULE_EVENT_MIGRATION: u64 = 57;

    public fun get_module_event_migration_feature(): u64 { MODULE_EVENT_MIGRATION }

    public fun module_event_migration_enabled(): bool acquires Features {
        is_enabled(MODULE_EVENT_MIGRATION)
    }
```
