# Audit Report

## Title
Database Connection Pool Corruption via Failed Transaction Rollback in Indexer Processors

## Summary
The indexer's database connection pool can become corrupted when transaction rollbacks fail, allowing invalid PostgreSQL connections to be reused by subsequent processors. This occurs because the connection pool lacks health validation (`test_on_check_out`), and the error handling in `insert_to_db()` discards critical error information that could indicate connection corruption.

## Finding Description

The vulnerability exists in the transaction retry logic used by all indexer processors (DefaultTransactionProcessor, CoinTransactionProcessor, StakeTransactionProcessor, TokenTransactionProcessor). [1](#0-0) 

When the first transaction fails, the error is caught with `Err(_)` and immediately discarded without examining the error type. The code then attempts a second transaction on the same connection: [2](#0-1) 

**Attack Scenario:**

1. A database transaction begins with `BEGIN` command
2. During `insert_to_db_impl()` execution, an error occurs (constraint violation, network issue, etc.)
3. Diesel attempts automatic `ROLLBACK` via Drop trait implementation
4. The `ROLLBACK` itself fails (network interruption, database crash, connection timeout)
5. PostgreSQL connection enters "transaction aborted" state
6. Error is caught and discarded at line 150 without determining if connection is corrupted
7. Second transaction attempt calls `build_transaction()` on the corrupted connection
8. PostgreSQL rejects with "current transaction is aborted, commands ignored until end of transaction block"
9. Connection is returned to the pool without validation
10. Subsequent processor retrieves this corrupted connection from the pool
11. All database operations fail with transaction abort errors

The root cause is that the connection pool is created without any health validation: [3](#0-2) 

There is no `test_on_check_out` configuration or `connection_customizer` that would validate connection state before reuse. Additionally, there is no explicit connection health checking anywhere in the codebase (confirmed by searching for `test_on_check_out`, `connection_customizer`, `is_broken`, and related patterns).

## Impact Explanation

This vulnerability qualifies as **Medium severity** under the Aptos bug bounty program criteria for "State inconsistencies requiring intervention."

**Specific impacts:**

1. **Cascading Processor Failures**: A single corrupted connection causes all subsequent processors that receive it to fail their database operations
2. **Indexer Availability**: Multiple processors failing simultaneously degrades indexer service availability
3. **State Inconsistencies**: Failed database commits can result in incomplete or inconsistent indexed state
4. **No Automatic Recovery**: Corrupted connections remain in the pool indefinitely until manual intervention (service restart)
5. **Silent Failures**: Error messages ("current transaction is aborted") don't indicate the root cause is a pooled connection issue

While this doesn't directly affect blockchain consensus (the indexer is separate from the validator node's core consensus operations), it severely impacts the indexer's ability to maintain consistent on-chain state views, which applications depend on.

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability requires specific conditions but is realistic:

**Triggering Conditions:**
- Transaction must fail during execution (constraint violations, data issues - relatively common)
- The `ROLLBACK` command must fail (network interruption, database unavailability - less common but realistic)
- No connection validation is configured (currently true in production code)

**Realistic Scenarios:**
1. Database maintenance or restart during active indexing
2. Network instability between indexer and database
3. Database resource exhaustion (connection limits, disk space)
4. PostgreSQL crashes mid-transaction

**Exploitation Complexity:**
- No attacker action required - this is a system reliability issue
- Occurs naturally under adverse conditions
- More likely in high-load or unstable environments

The same vulnerability pattern exists in all four processors, multiplying the attack surface: [4](#0-3) [5](#0-4) [6](#0-5) 

## Recommendation

**Fix 1: Enable Connection Health Validation**

Modify the connection pool configuration to validate connections before checkout:

```rust
// In crates/indexer/src/database.rs
pub fn new_db_pool(database_url: &str) -> Result<PgDbPool, PoolError> {
    let manager = ConnectionManager::<PgConnection>::new(database_url);
    PgPool::builder()
        .test_on_check_out(true)  // Validate connection health before reuse
        .connection_customizer(Box::new(ConnectionCustomizer))
        .build(manager)
        .map(Arc::new)
}

// Add connection customizer to reset state
struct ConnectionCustomizer;

impl diesel::r2d2::CustomizeConnection<PgConnection, diesel::r2d2::Error> 
    for ConnectionCustomizer 
{
    fn on_acquire(&self, conn: &mut PgConnection) -> Result<(), diesel::r2d2::Error> {
        // Ensure connection is not in a transaction
        conn.execute("ROLLBACK").ok(); // Best-effort cleanup
        Ok(())
    }
}
```

**Fix 2: Explicit Connection State Validation Between Transaction Attempts**

In all processor `insert_to_db()` functions, add explicit connection validation:

```rust
fn insert_to_db(
    conn: &mut PgPoolConnection,
    // ... parameters
) -> Result<(), diesel::result::Error> {
    // First attempt
    match conn.build_transaction().read_write().run(|pg_conn| {
        insert_to_db_impl(pg_conn, /* ... */)
    }) {
        Ok(_) => Ok(()),
        Err(e) => {
            // Log the specific error instead of discarding
            aptos_logger::warn!("First transaction attempt failed: {:?}", e);
            
            // Validate connection state before retry
            match conn.execute("SELECT 1") {
                Err(_) => {
                    // Connection is broken, return error to discard it
                    return Err(diesel::result::Error::BrokenTransactionManager);
                },
                Ok(_) => {
                    // Connection is valid, safe to retry with cleaned data
                    let cleaned_data = /* clean data */;
                    conn.build_transaction().read_write().run(|pg_conn| {
                        insert_to_db_impl(pg_conn, /* cleaned data */)
                    })
                }
            }
        },
    }
}
```

**Fix 3: Preserve Error Information**

Change `Err(_) =>` to `Err(e) =>` and log/inspect the error to determine if it indicates connection corruption vs. data issues.

## Proof of Concept

```rust
// Reproduction test for connection state corruption
#[cfg(test)]
mod connection_corruption_test {
    use super::*;
    use diesel::prelude::*;
    
    #[test]
    fn test_failed_rollback_corrupts_connection_pool() {
        // Setup: Create a connection pool
        let pool = new_db_pool("postgresql://localhost/test_db").unwrap();
        
        // Step 1: Get a connection and start a transaction
        let mut conn = pool.get().unwrap();
        
        // Step 2: Simulate a transaction that fails after BEGIN
        let result = conn.build_transaction().read_write().run::<_, diesel::result::Error, _>(|pg_conn| {
            // Intentionally cause an error that leaves transaction in bad state
            pg_conn.execute("INSERT INTO nonexistent_table VALUES (1)")?;
            Ok(())
        });
        assert!(result.is_err());
        
        // Step 3: Simulate failed ROLLBACK by closing connection abruptly
        // (In real scenario, this would be network error during ROLLBACK)
        std::mem::drop(conn);
        
        // Step 4: Get "same" connection from pool (simulating reuse)
        let mut conn2 = pool.get().unwrap();
        
        // Step 5: Try to use the connection - should fail if corrupted
        let result2 = conn2.build_transaction().read_write().run::<_, diesel::result::Error, _>(|pg_conn| {
            pg_conn.execute("SELECT 1")?;
            Ok(())
        });
        
        // Without test_on_check_out, this will fail with "current transaction is aborted"
        // With test_on_check_out, the corrupted connection would be discarded
        println!("Second transaction result: {:?}", result2);
    }
}
```

## Notes

This vulnerability affects the **indexer component** of Aptos Core, which is separate from the core consensus and execution layer. While it doesn't directly compromise blockchain consensus safety, it impacts the reliability and consistency of indexed blockchain data that external applications depend on.

The issue is systematic across all indexer processors due to the shared connection pool configuration and error handling pattern. A production fix should address both the pool configuration (enable health checks) and the error handling logic (validate connections between retry attempts).

### Citations

**File:** crates/indexer/src/processors/default_processor.rs (L125-150)
```rust
    match conn
        .build_transaction()
        .read_write()
        .run::<_, Error, _>(|pg_conn| {
            insert_to_db_impl(
                pg_conn,
                &txns,
                (
                    &user_transactions,
                    &signatures,
                    &block_metadata_transactions,
                ),
                &events,
                &wscs,
                (
                    &move_modules,
                    &move_resources,
                    &table_items,
                    &current_table_items,
                    &table_metadata,
                ),
                (&objects, &current_objects),
            )
        }) {
        Ok(_) => Ok(()),
        Err(_) => {
```

**File:** crates/indexer/src/processors/default_processor.rs (L165-187)
```rust
            conn.build_transaction()
                .read_write()
                .run::<_, Error, _>(|pg_conn| {
                    insert_to_db_impl(
                        pg_conn,
                        &txns,
                        (
                            &user_transactions,
                            &signatures,
                            &block_metadata_transactions,
                        ),
                        &events,
                        &wscs,
                        (
                            &move_modules,
                            &move_resources,
                            &table_items,
                            &current_table_items,
                            &table_metadata,
                        ),
                        (&objects, &current_objects),
                    )
                })
```

**File:** crates/indexer/src/database.rs (L59-62)
```rust
pub fn new_db_pool(database_url: &str) -> Result<PgDbPool, PoolError> {
    let manager = ConnectionManager::<PgConnection>::new(database_url);
    PgPool::builder().build(manager).map(Arc::new)
}
```

**File:** crates/indexer/src/processors/coin_processor.rs (L86-101)
```rust
    match conn
        .build_transaction()
        .read_write()
        .run::<_, Error, _>(|pg_conn| {
            insert_to_db_impl(
                pg_conn,
                &coin_activities,
                &coin_infos,
                &coin_balances,
                &current_coin_balances,
                &coin_supply,
                &account_transactions,
            )
        }) {
        Ok(_) => Ok(()),
        Err(_) => conn
```

**File:** crates/indexer/src/processors/stake_processor.rs (L90-106)
```rust
    match conn
        .build_transaction()
        .read_write()
        .run::<_, Error, _>(|pg_conn| {
            insert_to_db_impl(
                pg_conn,
                &current_stake_pool_voters,
                &proposal_votes,
                &delegator_actvities,
                &delegator_balances,
                &delegator_pools,
                &delegator_pool_balances,
                &current_delegator_pool_balances,
            )
        }) {
        Ok(_) => Ok(()),
        Err(_) => conn
```

**File:** crates/indexer/src/processors/token_processor.rs (L200-229)
```rust
    match conn
        .build_transaction()
        .read_write()
        .run::<_, Error, _>(|pg_conn| {
            insert_to_db_impl(
                pg_conn,
                (&tokens, &token_ownerships, &token_datas, &collection_datas),
                (
                    &current_token_ownerships,
                    &current_token_datas,
                    &current_collection_datas,
                ),
                &token_activities,
                &current_token_claims,
                &current_ans_lookups,
                &nft_points,
                (
                    &collections_v2,
                    &token_datas_v2,
                    &token_ownerships_v2,
                    &current_collections_v2,
                    &current_token_datas_v2,
                    &current_token_ownerships_v2,
                    &token_activities_v2,
                    &current_token_v2_metadata,
                ),
            )
        }) {
        Ok(_) => Ok(()),
        Err(_) => conn
```
