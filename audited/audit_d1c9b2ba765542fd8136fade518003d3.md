# Audit Report

## Title
Quorum Store Enable Race Condition Causes Consensus Safety Violation During Epoch Transitions

## Summary
A critical race condition exists in `epoch_manager.rs` where validators can have different `quorum_store_enabled` values during epoch transitions due to silent fallback to default configuration when reading on-chain consensus config fails. This causes validators to disagree on valid proposal payload types, leading to consensus safety violations and potential network partition.

## Finding Description

The vulnerability exists in the `start_new_epoch()` function where on-chain consensus configuration is read: [1](#0-0) 

When `payload.get::<OnChainConsensusConfig>()` fails (returning `Err`), the code silently falls back to `OnChainConsensusConfig::default()` via `.unwrap_or_default()`. 

The default configuration has `quorum_store_enabled: true`: [2](#0-1) [3](#0-2) 

This creates a race condition where:
1. Validator A successfully reads the on-chain config (e.g., `quorum_store_enabled=false`)
2. Validator B fails to read the config due to database sync lag, I/O errors, or deserialization failures
3. Validator B falls back to default (`quorum_store_enabled=true`)
4. Both validators proceed with different quorum store configurations

The divergence manifests in `initialize_shared_component()`: [4](#0-3) 

Validators then build different payload provider types based on their `quorum_store_enabled` value: [5](#0-4) 

When validators with different configurations receive proposals, the `Payload::verify()` method enforces strict type matching: [6](#0-5) 

The verification fails at the catch-all case (line 626-630), rejecting proposals with mismatched payload types. This causes:
- Validator A (quorum_store=true) proposes with `Payload::InQuorumStore`
- Validator B (quorum_store=false) rejects it as "Wrong payload type"
- Validator B (quorum_store=false) proposes with `Payload::DirectMempool`
- Validator A (quorum_store=true) rejects it as "Wrong payload type"
- Consensus cannot progress - validators cannot agree on any proposals

## Impact Explanation

**Severity: CRITICAL** (Consensus/Safety violation - up to $1,000,000)

This vulnerability breaks the fundamental **Consensus Safety** invariant: "AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine". It causes:

1. **Consensus Deadlock**: Validators cannot agree on valid proposals, causing total liveness failure
2. **Network Partition**: The network effectively splits into two groups with incompatible consensus rules
3. **Non-Recoverable State**: Requires manual intervention or hardfork to resolve, as validators have fundamentally different views of valid blocks
4. **Deterministic Execution Violation**: Different validators produce different execution outcomes for the same epoch

This matches the Critical Severity criteria: "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

This can occur in several realistic scenarios:

1. **State Sync Lag**: During epoch transitions, some validators may not have synced to the reconfiguration version when reading configs
2. **Database I/O Failures**: Transient disk errors during config reads
3. **Version Mismatch**: Schema changes in config serialization causing deserialization failures on some nodes
4. **Race During Upgrades**: When on-chain config format changes, validators with different code versions may have different deserialization success rates

The test suite includes `quorum_store_onchain_enable_test.rs` showing that toggling this configuration on-chain is an expected operation: [7](#0-6) 

However, the test assumes all validators successfully read the new config - it doesn't test the failure path.

## Recommendation

**Fix 1: Fail-Fast on Config Read Error**

Change the error handling to panic or halt the validator if critical config cannot be read:

```rust
let consensus_config = onchain_consensus_config
    .expect("FATAL: Failed to read on-chain consensus config during epoch transition");
```

This prevents validators from proceeding with incorrect default values.

**Fix 2: Add Explicit Config Version Checking**

Include a version field in the on-chain config and verify all validators see the same version:

```rust
if let Err(error) = &onchain_consensus_config {
    error!("CRITICAL: Failed to read on-chain consensus config: {}", error);
    // Signal to recovery mode or halt validator
    panic!("Cannot proceed with epoch transition without valid consensus config");
}
```

**Fix 3: Add Config Hash to Epoch State**

Include a hash of the consensus config in the `EpochState` so validators can detect mismatches:

```rust
let consensus_config = onchain_consensus_config
    .context("Failed to read on-chain consensus config")?;
let config_hash = consensus_config.hash();
// Validators exchange config hashes and detect mismatches before proceeding
```

**Recommended Approach**: Implement Fix 1 immediately as it prevents the safety violation. Then add Fix 3 for defense-in-depth.

## Proof of Concept

To reproduce this vulnerability:

1. Set up a test network with 4 validators
2. Configure on-chain consensus config with `quorum_store_enabled=false`
3. Inject a fault point to make `DbBackedOnChainConfig.get()` fail on 2 validators:

```rust
// In state-sync/inter-component/event-notifications/src/lib.rs
impl OnChainConfigProvider for DbBackedOnChainConfig {
    fn get<T: OnChainConfig>(&self) -> Result<T> {
        fail_point!("consensus::read_config::fail", |_| {
            Err(anyhow!("Injected config read failure"))
        });
        // ... existing code
    }
}
```

4. Trigger an epoch transition
5. Observe that:
   - 2 validators initialize with `quorum_store_enabled=false` (from on-chain)
   - 2 validators initialize with `quorum_store_enabled=true` (from default)
   - Proposals from one group are rejected by the other group
   - Consensus cannot make progress

**Expected outcome**: Validators with different quorum store settings reject each other's proposals, causing consensus deadlock.

**Log evidence**:
- Validator A: `"Building QuorumStore"` + proposals with `Payload::InQuorumStore`
- Validator B: `"Building DirectMempool"` + proposals with `Payload::DirectMempool`
- Validator A receiving B's proposal: `"Wrong payload type. Expected Payload::InQuorumStore true got DirectMempool txns: N"`
- Validator B receiving A's proposal: `"Wrong payload type. Expected Payload::InQuorumStore false got InQuorumStore proofs: N"`

This demonstrates a clear consensus safety violation exploitable through realistic infrastructure failures.

### Citations

**File:** consensus/src/epoch_manager.rs (L737-763)
```rust
        let mut quorum_store_builder = if self.quorum_store_enabled {
            info!("Building QuorumStore");
            QuorumStoreBuilder::QuorumStore(InnerBuilder::new(
                self.epoch(),
                self.author,
                epoch_state.verifier.len() as u64,
                quorum_store_config,
                self.quorum_store_txn_filter_config.clone(),
                consensus_to_quorum_store_rx,
                self.quorum_store_to_mempool_sender.clone(),
                self.config.mempool_txn_pull_timeout_ms,
                self.storage.aptos_db().clone(),
                network_sender,
                epoch_state.verifier.clone(),
                self.proof_cache.clone(),
                self.quorum_store_storage.clone(),
                !consensus_config.is_dag_enabled(),
                consensus_key,
            ))
        } else {
            info!("Building DirectMempool");
            QuorumStoreBuilder::DirectMempool(DirectMempoolInnerBuilder::new(
                consensus_to_quorum_store_rx,
                self.quorum_store_to_mempool_sender.clone(),
                self.config.mempool_txn_pull_timeout_ms,
            ))
        };
```

**File:** consensus/src/epoch_manager.rs (L1178-1201)
```rust
        let onchain_consensus_config: anyhow::Result<OnChainConsensusConfig> = payload.get();
        let onchain_execution_config: anyhow::Result<OnChainExecutionConfig> = payload.get();
        let onchain_randomness_config_seq_num: anyhow::Result<RandomnessConfigSeqNum> =
            payload.get();
        let randomness_config_move_struct: anyhow::Result<RandomnessConfigMoveStruct> =
            payload.get();
        let onchain_jwk_consensus_config: anyhow::Result<OnChainJWKConsensusConfig> = payload.get();
        let dkg_state = payload.get::<DKGState>();

        if let Err(error) = &onchain_consensus_config {
            warn!("Failed to read on-chain consensus config {}", error);
        }

        if let Err(error) = &onchain_execution_config {
            warn!("Failed to read on-chain execution config {}", error);
        }

        if let Err(error) = &randomness_config_move_struct {
            warn!("Failed to read on-chain randomness config {}", error);
        }

        self.epoch_state = Some(epoch_state.clone());

        let consensus_config = onchain_consensus_config.unwrap_or_default();
```

**File:** consensus/src/epoch_manager.rs (L1331-1365)
```rust
    async fn initialize_shared_component(
        &mut self,
        epoch_state: &EpochState,
        consensus_config: &OnChainConsensusConfig,
        consensus_key: Arc<PrivateKey>,
    ) -> (
        NetworkSender,
        Arc<dyn PayloadClient>,
        Arc<dyn TPayloadManager>,
    ) {
        self.set_epoch_start_metrics(epoch_state);
        self.quorum_store_enabled = self.enable_quorum_store(consensus_config);
        let network_sender = self.create_network_sender(epoch_state);
        let (payload_manager, quorum_store_client, quorum_store_builder) = self
            .init_payload_provider(
                epoch_state,
                network_sender.clone(),
                consensus_config,
                consensus_key,
            )
            .await;
        let effective_vtxn_config = consensus_config.effective_validator_txn_config();
        debug!("effective_vtxn_config={:?}", effective_vtxn_config);
        let mixed_payload_client = MixedPayloadClient::new(
            effective_vtxn_config,
            Arc::new(self.vtxn_pool.clone()),
            Arc::new(quorum_store_client),
        );
        self.start_quorum_store(quorum_store_builder);
        (
            network_sender,
            Arc::new(mixed_payload_client),
            payload_manager,
        )
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L46-52)
```rust
    pub fn default_if_missing() -> Self {
        Self::JolteonV2 {
            main: ConsensusConfigV1::default(),
            quorum_store_enabled: true,
            order_vote_enabled: false,
        }
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L443-450)
```rust
impl Default for OnChainConsensusConfig {
    fn default() -> Self {
        OnChainConsensusConfig::V4 {
            alg: ConsensusAlgorithmConfig::default_if_missing(),
            vtxn: ValidatorTxnConfig::default_if_missing(),
            window_size: DEFAULT_WINDOW_SIZE,
        }
    }
```

**File:** consensus/consensus-types/src/common.rs (L574-632)
```rust
    pub fn verify(
        &self,
        verifier: &ValidatorVerifier,
        proof_cache: &ProofCache,
        quorum_store_enabled: bool,
    ) -> anyhow::Result<()> {
        match (quorum_store_enabled, self) {
            (false, Payload::DirectMempool(_)) => Ok(()),
            (true, Payload::InQuorumStore(proof_with_status)) => {
                Self::verify_with_cache(&proof_with_status.proofs, verifier, proof_cache)
            },
            (true, Payload::InQuorumStoreWithLimit(proof_with_status)) => Self::verify_with_cache(
                &proof_with_status.proof_with_data.proofs,
                verifier,
                proof_cache,
            ),
            (true, Payload::QuorumStoreInlineHybrid(inline_batches, proof_with_data, _))
            | (true, Payload::QuorumStoreInlineHybridV2(inline_batches, proof_with_data, _)) => {
                Self::verify_with_cache(&proof_with_data.proofs, verifier, proof_cache)?;
                Self::verify_inline_batches(
                    inline_batches.iter().map(|(info, txns)| (info, txns)),
                )?;
                Ok(())
            },
            (true, Payload::OptQuorumStore(OptQuorumStorePayload::V1(p))) => {
                let proof_with_data = p.proof_with_data();
                Self::verify_with_cache(&proof_with_data.batch_summary, verifier, proof_cache)?;
                Self::verify_inline_batches(
                    p.inline_batches()
                        .iter()
                        .map(|batch| (batch.info(), batch.transactions())),
                )?;
                Self::verify_opt_batches(verifier, p.opt_batches())?;
                Ok(())
            },
            (true, Payload::OptQuorumStore(OptQuorumStorePayload::V2(p))) => {
                if true {
                    bail!("OptQuorumStorePayload::V2 cannot be accepted yet");
                }
                #[allow(unreachable_code)]
                {
                    let proof_with_data = p.proof_with_data();
                    Self::verify_with_cache(&proof_with_data.batch_summary, verifier, proof_cache)?;
                    Self::verify_inline_batches(
                        p.inline_batches()
                            .iter()
                            .map(|batch| (batch.info(), batch.transactions())),
                    )?;
                    Self::verify_opt_batches(verifier, p.opt_batches())?;
                    Ok(())
                }
            },
            (_, _) => Err(anyhow::anyhow!(
                "Wrong payload type. Expected Payload::InQuorumStore {} got {} ",
                quorum_store_enabled,
                self
            )),
        }
    }
```

**File:** testsuite/testcases/src/quorum_store_onchain_enable_test.rs (L60-98)
```rust
        let current_consensus_config: OnChainConsensusConfig = bcs::from_bytes(
            &rest_client
                .get_account_resource_bcs::<Vec<u8>>(
                    CORE_CODE_ADDRESS,
                    "0x1::consensus_config::ConsensusConfig",
                )
                .await
                .unwrap()
                .into_inner(),
        )
        .unwrap();

        let inner = match current_consensus_config {
            OnChainConsensusConfig::V1(inner) => inner,
            OnChainConsensusConfig::V2(_) => panic!("Unexpected V2 config"),
            _ => unimplemented!(),
        };

        // Change to V2
        let new_consensus_config = OnChainConsensusConfig::V2(ConsensusConfigV1 { ..inner });

        let update_consensus_config_script = format!(
            r#"
    script {{
        use aptos_framework::aptos_governance;
        use aptos_framework::consensus_config;
        fun main(core_resources: &signer) {{
            let framework_signer = aptos_governance::get_signer_testnet_only(core_resources, @0000000000000000000000000000000000000000000000000000000000000001);
            let config_bytes = {};
            consensus_config::set(&framework_signer, config_bytes);
        }}
    }}
    "#,
            generate_onchain_config_blob(&bcs::to_bytes(&new_consensus_config).unwrap())
        );

        cli.run_script_with_default_framework(root_cli_index, &update_consensus_config_script)
            .await?;

```
