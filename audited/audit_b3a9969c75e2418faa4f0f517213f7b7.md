# Audit Report

## Title
Error Information Loss in View Function Validation Leading to Misrepresentation of Move Aborts

## Summary
The `validate_view_function()` function strips critical error context when converting `VMStatus` errors from `construct_args()` to `PartialVMError`, causing Move aborts to be misrepresented as generic errors and losing sub-status codes, error messages, and location information.

## Finding Description

In the view function validation flow, when argument construction fails, rich error information is unnecessarily discarded. [1](#0-0) 

The problematic line converts `VMStatus` (which can contain sub_status, message, and location) to a bare `PartialVMError` with only the status code preserved.

When `construct_args()` returns errors with detailed context, such as: [2](#0-1) 

This creates a `VMStatus::MoveAbort` with abort code 1 and module location. However, when converted via `.status_code()`: [3](#0-2) 

The `MoveAbort` variant returns `StatusCode::ABORTED`, losing the abort code. The recreated `PartialVMError` with only `StatusCode::ABORTED` (no sub_status) later becomes: [4](#0-3) 

This converts to `VMStatus::Error` instead of the original `VMStatus::MoveAbort`, causing incorrect error path selection: [5](#0-4) 

The condition checks for `MoveAbort` variant (which no longer matches), causing the error to skip abort info injection and return via the generic error path instead of the specialized Move abort path.

## Impact Explanation

This issue does **not** meet Medium severity criteria per Aptos bug bounty standards:

- No funds are at risk
- No state corruption occurs  
- No consensus violations
- Validation still fails correctly

The impact is limited to:
1. Loss of debugging information (sub_status, error messages, code offsets)
2. Move aborts misrepresented as generic errors
3. Inconsistent error reporting compared to entry functions
4. Potential difficulty in diagnosing issues

This is primarily a **code quality and usability issue** rather than a security vulnerability. It falls under "Non-critical implementation bugs" at best.

## Likelihood Explanation

While trivially triggerable by any user submitting malformed arguments to view functions, the actual security impact is minimal since both error paths correctly reject invalid inputs.

## Recommendation

Preserve full error context by passing through the original VMStatus:

```rust
result.map_err(|e| {
    // Convert VMStatus to PartialVMError while preserving all context
    let vm_status = e.clone();
    match vm_status {
        VMStatus::Error { status_code, sub_status, message } => {
            let mut err = PartialVMError::new(status_code);
            if let Some(sub) = sub_status {
                err = err.with_sub_status(sub);
            }
            if let Some(msg) = message {
                err = err.with_message(msg);
            }
            err
        },
        VMStatus::MoveAbort { location, code, message } => {
            let mut err = PartialVMError::new(StatusCode::ABORTED)
                .with_sub_status(code);
            if let Some(msg) = message {
                err = err.with_message(msg);
            }
            err
        },
        // Handle other variants...
        _ => PartialVMError::new(vm_status.status_code())
    }
})
```

## Proof of Concept

**Note**: This demonstrates the bug but does NOT constitute a security vulnerability.

```rust
// In a test environment, call a view function with malformed UTF-8 string
// when struct constructors feature is enabled
let malformed_utf8 = vec![0xF0, 0x28, 0x8C, 0xBC]; // Invalid UTF-8 sequence
let arg = bcs::to_bytes(&malformed_utf8).unwrap();

// This will trigger the error path, but the Move abort from string::utf8
// will be converted to a generic error instead of a proper MoveAbort
```

---

**Final Assessment**: While this is a legitimate implementation bug affecting error handling quality, it does **not** meet the security vulnerability threshold for Medium severity as defined by the Aptos bug bounty program. Validation still functions correctly, no security guarantees are violated, and no assets are at risk. This should be filed as a code quality improvement rather than a security issue.

### Citations

**File:** aptos-move/aptos-vm/src/verifier/view_function.rs (L91-91)
```rust
    result.map_err(|e| PartialVMError::new(e.status_code()))
```

**File:** aptos-move/aptos-vm/src/verifier/transaction_arg_validation.rs (L440-447)
```rust
                PartialVMError::new(StatusCode::ABORTED)
                    .with_sub_status(1)
                    .at_code_offset(FunctionDefinitionIndex::new(0), 0)
                    .finish(Location::Module(constructor.module_id.clone()))
                    .into_vm_status()
            } else {
                VMStatus::error(StatusCode::FAILED_TO_DESERIALIZE_ARGUMENT, None)
            }
```

**File:** third_party/move/move-core/types/src/vm_status.rs (L153-167)
```rust
    pub fn status_code(&self) -> StatusCode {
        match self {
            Self::Executed => StatusCode::EXECUTED,
            Self::MoveAbort { .. } => StatusCode::ABORTED,
            Self::ExecutionFailure { status_code, .. } => *status_code,
            Self::Error {
                status_code: code, ..
            } => {
                let code = *code;
                debug_assert!(code != StatusCode::EXECUTED);
                debug_assert!(code != StatusCode::ABORTED);
                code
            },
        }
    }
```

**File:** third_party/move/move-binary-format/src/errors.rs (L118-129)
```rust
            (StatusCode::ABORTED, sub_status, location) => {
                debug_assert!(
                    false,
                    "Expected a code and module/script location with ABORTED, but got {:?} and {}",
                    sub_status, location
                );
                VMStatus::Error {
                    status_code: StatusCode::ABORTED,
                    sub_status,
                    message,
                }
            },
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2694-2706)
```rust
                match vm_status {
                    VMStatus::MoveAbort { .. } => {},
                    _ => {
                        let message = e
                            .message()
                            .map(|m| m.to_string())
                            .unwrap_or_else(|| e.to_string());
                        return ViewFunctionOutput::new_error_message(
                            message,
                            Some(vm_status.status_code()),
                            gas_used,
                        );
                    },
```
