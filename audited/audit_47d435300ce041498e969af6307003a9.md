# Audit Report

## Title
DKG Weight Calculation Overflow via Malicious Randomness Configuration Causes Network-Wide Validator Crash

## Summary
A malicious governance proposal can set randomness configuration thresholds to nearly identical values, causing integer overflow in DKG (Distributed Key Generation) weight calculations. This triggers panics in multiple locations during validator operations, leading to a complete network halt as all validators crash when attempting to generate randomness for the new epoch.

## Finding Description

The vulnerability exists in the interaction between on-chain randomness configuration (controlled by governance) and the DKG rounding algorithm used by validators. The attack proceeds as follows:

**Step 1: Malicious Governance Configuration**

The Move module `randomness_config.move` allows governance to set arbitrary threshold values without validation: [1](#0-0) 

No validation exists to ensure the thresholds are sufficiently separated.

**Step 2: Minimal Threshold Enforcement in Rust**

When validators initialize DKG, the Rust code only enforces a minimal separation of `U64F64::DELTA` (approximately 1/2^64): [2](#0-1) 

**Step 3: Overflow in Weight Upper Bound Calculation**

With nearly identical thresholds, the denominator becomes extremely small (≈ DELTA), causing `total_weight_upper_bound()` to calculate a massive value: [3](#0-2) 

For n=100 validators with denominator = DELTA, the result is approximately `(50 + 2) / (1/2^64) = 52 * 2^64 ≈ 9.59 × 10^20`, far exceeding `usize::MAX`.

**Step 4: Overflow in Weight Sum Calculation**

Even if the `to_num::<usize>()` conversion somehow succeeds (via saturation), the subsequent weight calculations produce individual validator weights that are enormous. The sum calculation will overflow: [4](#0-3) 

With overflow checks enabled in release builds: [5](#0-4) 

This overflow causes a **panic**, crashing the validator node.

**Step 5: Alternative Panic in Vec::with_capacity**

If the overflow doesn't occur earlier, when the weight sum (W) is passed to `random_scalars()`, it attempts to allocate an enormous vector: [6](#0-5) 

With W near `usize::MAX`, `Vec::with_capacity(n)` will panic due to:
- Capacity calculation overflow (n * 32 bytes for Scalar)
- Exceeding `isize::MAX` bytes allocation limit
- Memory exhaustion

**Attack Execution:**

1. Attacker creates governance proposal calling:
   ```move
   randomness_config::set_for_next_epoch(
       &framework_signer,
       randomness_config::new_v1(
           fixed_point64::create_from_rational(1, 2),  // secrecy = 0.5
           fixed_point64::create_from_rational(1, 2)   // reconstruct = 0.5
       )
   )
   ```

2. Proposal passes through on-chain governance voting

3. At next epoch transition, all validators attempt DKG initialization

4. All validators panic simultaneously at one of the overflow points

5. Network halts completely with no validators producing blocks

## Impact Explanation

**Severity: Critical** (Network Liveness Failure)

This vulnerability causes:
- **Total loss of liveness**: All validators crash simultaneously, halting block production
- **Non-recoverable without hard fork**: Requires emergency patch and coordinated restart
- **Deterministic execution violation**: Validator nodes cannot complete epoch transition

This maps to Critical severity under Aptos bug bounty categories:
- "Total loss of liveness/network availability"
- "Non-recoverable network partition (requires hardfork)"

The impact is more severe than "High Severity" validator crashes because it affects **all** validators simultaneously and cannot be recovered without manual intervention.

## Likelihood Explanation

**Likelihood: Medium-High**

**Attack Requirements:**
- Control sufficient governance voting power to pass a proposal (achievable through stake accumulation or coordination)
- Knowledge of the vulnerability (now public)
- Ability to submit governance proposal (permissionless on Aptos)

**Mitigating Factors:**
- Requires governance approval (not instant)
- Governance participants may review proposals
- May be detected during testing if validators run pre-production networks

**Aggravating Factors:**
- No validation prevents malicious configuration
- Attack affects entire network simultaneously
- Could be disguised as "optimization" or "tuning" of randomness parameters

## Recommendation

**Immediate Fix:** Add validation in Move code to enforce minimum threshold separation:

```move
// In randomness_config.move, add validation function:
const EINSUFFICIENT_THRESHOLD_SEPARATION: u64 = 2;
const MINIMUM_THRESHOLD_GAP_BPS: u64 = 100; // 1% minimum gap

fun validate_thresholds(
    secrecy_threshold: FixedPoint64,
    reconstruction_threshold: FixedPoint64
) {
    use aptos_std::fixed_point64;
    
    // Ensure reconstruction > secrecy by at least 1%
    let gap = fixed_point64::sub(reconstruction_threshold, secrecy_threshold);
    let min_gap = fixed_point64::create_from_rational(MINIMUM_THRESHOLD_GAP_BPS, 10000);
    
    assert!(
        fixed_point64::greater_or_equal(gap, min_gap),
        error::invalid_argument(EINSUFFICIENT_THRESHOLD_SEPARATION)
    );
}

// Update new_v1() and new_v2() to call validation:
public fun new_v1(
    secrecy_threshold: FixedPoint64,
    reconstruction_threshold: FixedPoint64
): RandomnessConfig {
    validate_thresholds(secrecy_threshold, reconstruction_threshold);
    RandomnessConfig {
        variant: copyable_any::pack(ConfigV1 {
            secrecy_threshold,
            reconstruction_threshold
        })
    }
}
```

**Additional Rust-Level Safeguards:**

Add checked overflow protection in `total_weight_upper_bound()`:

```rust
pub fn total_weight_upper_bound(
    validator_stakes: &[u64],
    mut reconstruct_threshold_in_stake_ratio: U64F64,
    secrecy_threshold_in_stake_ratio: U64F64,
) -> usize {
    // Enforce minimum threshold separation
    const MIN_THRESHOLD_GAP: U64F64 = U64F64::from_bits(184467440737095516); // 0.01 = 1%
    
    reconstruct_threshold_in_stake_ratio = max(
        reconstruct_threshold_in_stake_ratio,
        secrecy_threshold_in_stake_ratio + MIN_THRESHOLD_GAP,
    );
    
    // ... rest of function with safe upper bound
    const MAX_REASONABLE_WEIGHT: usize = 1_000_000; // Reasonable upper limit
    
    let calculated = ((n / two + two) / (reconstruct_threshold_in_stake_ratio - secrecy_threshold_in_stake_ratio))
        .ceil()
        .to_num::<usize>();
    
    min(calculated, MAX_REASONABLE_WEIGHT)
}
```

## Proof of Concept

**Move Test (in randomness_config.move test section):**

```move
#[test(framework = @0x1)]
#[expected_failure(abort_code = 0x10002)] // EINSUFFICIENT_THRESHOLD_SEPARATION
fun test_insufficient_threshold_gap_rejected(framework: signer) {
    initialize_for_testing(&framework);
    
    // Attempt to set identical thresholds - should abort
    let malicious_config = new_v1(
        fixed_point64::create_from_rational(1, 2),  // 50%
        fixed_point64::create_from_rational(1, 2)   // 50% - same value!
    );
    
    set_for_next_epoch(&framework, malicious_config);
}
```

**Rust Reproduction (simulated scenario):**

```rust
#[test]
#[should_panic(expected = "overflow")]
fn test_dkg_rounding_overflow_with_malicious_config() {
    use fixed::types::U64F64;
    
    let validator_stakes = vec![1_000_000_u64; 100]; // 100 validators
    
    // Malicious config: identical thresholds
    let secrecy = U64F64::from_num(1) / U64F64::from_num(2);
    let reconstruct = U64F64::from_num(1) / U64F64::from_num(2);
    
    // This will panic due to overflow in weight calculation
    let _rounding = DKGRounding::new(
        &validator_stakes,
        secrecy,
        reconstruct,
        None
    );
}
```

**Notes:**
- The vulnerability requires governance control but is deterministic once activated
- All validators are affected simultaneously, making this a network-wide liveness failure
- The fix requires both Move-level validation (first line of defense) and Rust-level bounds checking (defense in depth)
- Current default values (50% secrecy, 66.67% reconstruction) are safe, but no enforcement prevents future misconfiguration

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/randomness_config.move (L93-99)
```text
    public fun new_v1(secrecy_threshold: FixedPoint64, reconstruction_threshold: FixedPoint64): RandomnessConfig {
        RandomnessConfig {
            variant: copyable_any::pack( ConfigV1 {
                secrecy_threshold,
                reconstruction_threshold
            } )
        }
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L34-48)
```rust
pub fn total_weight_upper_bound(
    validator_stakes: &[u64],
    mut reconstruct_threshold_in_stake_ratio: U64F64,
    secrecy_threshold_in_stake_ratio: U64F64,
) -> usize {
    reconstruct_threshold_in_stake_ratio = max(
        reconstruct_threshold_in_stake_ratio,
        secrecy_threshold_in_stake_ratio + U64F64::DELTA,
    );
    let two = U64F64::from_num(2);
    let n = U64F64::from_num(validator_stakes.len());
    ((n / two + two) / (reconstruct_threshold_in_stake_ratio - secrecy_threshold_in_stake_ratio))
        .ceil()
        .to_num::<usize>()
}
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L67-70)
```rust
        reconstruct_threshold_in_stake_ratio = max(
            reconstruct_threshold_in_stake_ratio,
            secrecy_threshold_in_stake_ratio + U64F64::DELTA,
        );
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L322-322)
```rust
    let weight_total: u64 = validator_weights.clone().into_iter().sum();
```

**File:** Cargo.toml (L921-923)
```text
[profile.release]
debug = true
overflow-checks = true
```

**File:** crates/aptos-crypto/src/blstrs/random.rs (L107-120)
```rust
pub fn random_scalars<R>(n: usize, rng: &mut R) -> Vec<Scalar>
where
    R: rand_core::RngCore + rand::Rng + rand_core::CryptoRng + rand::CryptoRng,
{
    let mut v = Vec::with_capacity(n);

    for _ in 0..n {
        v.push(crate::blstrs::random_scalar(rng));
    }

    debug_assert_eq!(v.len(), n);

    v
}
```
