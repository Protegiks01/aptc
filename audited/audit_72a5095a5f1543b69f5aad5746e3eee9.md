# Audit Report

## Title
Cryptographic Key Recovery via Exposed Seed Peer Public Keys in Test Configurations

## Summary
When validator nodes are initialized using test configuration generation functions (`validator_swarm_for_testing` or `NodeConfig::generate_random_config`) and the inspection service's `expose_configuration` is enabled, an attacker can recover validator private keys by accessing the `/configuration` endpoint, extracting exposed x25519 public keys from seed peer configurations, and reconstructing the private keys using known test seeds.

## Finding Description

The vulnerability chain involves three components:

1. **Deterministic Key Generation with Predictable Seeds**: Test configuration generation uses hardcoded, predictable seeds to generate cryptographic keys. [1](#0-0) [2](#0-1) 

2. **Public Key Exposure in Seed Peer Configuration**: When validator swarms are generated, the first validator's x25519 public key is stored in every validator's `seeds` configuration as a seed peer. [3](#0-2) [4](#0-3) 

The `Peer` struct explicitly stores public keys: [5](#0-4) 

3. **Configuration Endpoint Exposure**: When `expose_configuration` is enabled, the `/configuration` endpoint exposes the entire `NodeConfig` using Debug formatting, which includes the x25519 public keys. [6](#0-5) 

The x25519::PublicKey Debug implementation outputs the full hex-encoded public key: [7](#0-6) 

4. **Automatic Exposure for Non-Mainnet**: The config optimizer automatically enables `expose_configuration` for non-mainnet chains: [8](#0-7) 

**Attack Path**:
1. Testnet/devnet validators are initialized using `validator_swarm_for_testing(n)` which uses seed `[1u8; 32]`
2. Config optimizer automatically enables `expose_configuration: true` for non-mainnet
3. Attacker accesses `http://validator:9101/configuration` endpoint
4. Attacker extracts x25519 public keys from the `seeds` field in NetworkConfig
5. Attacker reconstructs private keys by iterating through known test seeds (`[0u8; 32]`, `[1u8; 32]`, etc.)
6. For each seed, generate keys in the same sequence and compare public keys
7. When match found, attacker has recovered the private key

The key generation sequence is deterministic: [9](#0-8) 

## Impact Explanation

**Severity: High** (up to $50,000 per Aptos Bug Bounty)

This vulnerability allows complete compromise of testnet/devnet validator nodes:
- **Private Key Recovery**: Attackers gain access to validator network identity keys (x25519) and consensus keys (BLS12-381)
- **Node Impersonation**: Attackers can impersonate validators in the network
- **Consensus Manipulation**: Compromised consensus keys enable malicious block proposals and votes
- **Network Disruption**: Attackers can disrupt testnet/devnet operations

While mainnet is protected by sanitization checks that prevent `expose_configuration` on validators and disallow test configs, testnet/devnet deployments are critical infrastructure for development and testing, making this a significant protocol violation.

## Likelihood Explanation

**Likelihood: Medium**

The attack requires:
1. ✓ **Common**: Testnet/devnet using test configuration generation (likely for quick setup)
2. ✓ **Automatic**: `expose_configuration` auto-enabled for non-mainnet chains
3. ✓ **Easy**: Attacker can access exposed endpoint (no authentication required)
4. ✓ **Trivial**: Known test seeds are hardcoded in public repository

The main limiting factor is that production mainnet validators are protected by sanitization. However, many testnets and development networks likely use these convenience functions, and the config optimizer automatically exposes configuration for debugging purposes on non-mainnet chains.

## Recommendation

1. **Immediate**: Add warnings to test configuration generation functions:
```rust
/// WARNING: This function uses a PREDICTABLE SEED for testing only.
/// NEVER use this for any network accessible to untrusted parties.
/// Private keys generated with this function can be recovered by anyone
/// who can access the node configuration.
pub fn validator_swarm_for_testing(nodes: usize) -> ValidatorSwarm {
    let config = NodeConfig::default();
    validator_swarm(&config, nodes, [1u8; 32], true)
}
```

2. **Sanitize seed peer public keys**: Prevent exposure of x25519 public keys in Debug formatting when `expose_configuration` is enabled, or require explicit opt-in for sensitive fields.

3. **Enhance sanitization**: Extend sanitization to prevent test configurations (`SafetyRulesTestConfig`) on any publicly accessible network, not just mainnet.

4. **Secure defaults**: Disable `expose_configuration` by default even for testnets, requiring explicit operator action to enable.

## Proof of Concept

```rust
use aptos_config::config::NodeConfig;
use aptos_crypto::{x25519, Uniform};
use rand::{rngs::StdRng, SeedableRng};

fn recover_private_key(exposed_pubkey: x25519::PublicKey) -> Option<x25519::PrivateKey> {
    // Try common test seeds
    let test_seeds = vec![
        [0u8; 32],
        [1u8; 32],
        [2u8; 32],
    ];
    
    for seed in test_seeds {
        let mut rng = StdRng::from_seed(seed);
        
        // Simulate the key generation sequence from validator_swarm
        let candidate_privkey = x25519::PrivateKey::generate(&mut rng);
        let candidate_pubkey = candidate_privkey.public_key();
        
        if candidate_pubkey == exposed_pubkey {
            println!("Found matching key with seed: {:?}", seed);
            return Some(candidate_privkey);
        }
    }
    
    None
}

#[test]
fn test_key_recovery_attack() {
    // Simulate test validator generation
    let mut rng = StdRng::from_seed([1u8; 32]);
    let original_privkey = x25519::PrivateKey::generate(&mut rng);
    let exposed_pubkey = original_privkey.public_key();
    
    // Attacker recovers private key from exposed public key
    let recovered_privkey = recover_private_key(exposed_pubkey);
    
    assert!(recovered_privkey.is_some(), "Failed to recover private key");
    assert_eq!(
        recovered_privkey.unwrap().public_key(),
        original_privkey.public_key(),
        "Recovered key does not match original"
    );
}
```

**Notes**

- This vulnerability only affects nodes using test configuration generation functions with predictable seeds
- Mainnet is protected by explicit sanitization checks
- Testnet/devnet deployments are still vulnerable and represent critical infrastructure
- The config optimizer automatically enables `expose_configuration` for non-mainnet chains, increasing exposure
- Private keys themselves are properly protected by `SilentDebug`, but derived public keys in seed peer configurations are exposed
- The vulnerability demonstrates that seemingly safe "test-only" utilities can create security issues when used in semi-production environments

### Citations

**File:** config/src/generator.rs (L44-50)
```rust
    // set the first validator as every validators' initial configured seed peer.
    let seed_config = &nodes[0].validator_network.as_ref().unwrap();
    let seeds = build_seed_for_network(seed_config, PeerRole::Validator);
    for node in &mut nodes {
        let network = node.validator_network.as_mut().unwrap();
        network.seeds.clone_from(&seeds);
    }
```

**File:** config/src/generator.rs (L61-64)
```rust
pub fn validator_swarm_for_testing(nodes: usize) -> ValidatorSwarm {
    let config = NodeConfig::default();
    validator_swarm(&config, nodes, [1u8; 32], true)
}
```

**File:** config/src/generator.rs (L69-83)
```rust
pub fn build_seed_for_network(seed_config: &NetworkConfig, seed_role: PeerRole) -> PeerSet {
    let seed_pubkey = aptos_crypto::PrivateKey::public_key(&seed_config.identity_key());
    let seed_addr = seed_config
        .listen_address
        .clone()
        .append_prod_protos(seed_pubkey, HANDSHAKE_VERSION);

    let mut keys = HashSet::new();
    keys.insert(seed_pubkey);
    let mut seeds = HashMap::default();
    seeds.insert(
        seed_config.peer_id(),
        Peer::new(vec![seed_addr], keys, seed_role),
    );
    seeds
```

**File:** config/src/config/node_config.rs (L202-204)
```rust
    pub fn generate_random_config() -> Self {
        let mut rng = StdRng::from_seed([0u8; 32]);
        Self::generate_random_config_with_template(&NodeConfig::default(), &mut rng)
```

**File:** config/src/config/network_config.rs (L294-304)
```rust
    pub fn random_with_peer_id(&mut self, rng: &mut StdRng, peer_id: Option<PeerId>) {
        let identity_key = x25519::PrivateKey::generate(rng);
        let peer_id = if let Some(peer_id) = peer_id {
            peer_id
        } else {
            AuthenticationKey::try_from(identity_key.public_key().as_slice())
                .unwrap()
                .account_address()
        };
        self.identity = Identity::from_config(identity_key, peer_id);
    }
```

**File:** config/src/config/network_config.rs (L458-464)
```rust
#[derive(Clone, Debug, Default, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default)]
pub struct Peer {
    pub addresses: Vec<NetworkAddress>,
    pub keys: HashSet<x25519::PublicKey>,
    pub role: PeerRole,
}
```

**File:** crates/aptos-inspection-service/src/server/configuration.rs (L13-20)
```rust
pub fn handle_configuration_request(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    // Only return configuration if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_configuration {
        // We format the configuration using debug formatting. This is important to
        // prevent secret/private keys from being serialized and leaked (i.e.,
        // all secret keys are marked with SilentDisplay and SilentDebug).
        let encoded_configuration = format!("{:?}", node_config);
        (StatusCode::OK, Body::from(encoded_configuration))
```

**File:** crates/aptos-crypto/src/x25519.rs (L257-260)
```rust
impl std::fmt::Debug for PublicKey {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        write!(f, "x25519::PublicKey({})", self)
    }
```

**File:** config/src/config/inspection_service_config.rs (L81-88)
```rust
        // Enable all endpoints for non-mainnet nodes (to aid debugging)
        let mut modified_config = false;
        if let Some(chain_id) = chain_id {
            if !chain_id.is_mainnet() {
                if local_inspection_config_yaml["expose_configuration"].is_null() {
                    inspection_service_config.expose_configuration = true;
                    modified_config = true;
                }
```
