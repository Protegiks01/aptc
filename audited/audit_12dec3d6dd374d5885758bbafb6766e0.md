# Audit Report

## Title
Memory Limit Bypass via Timed Feature Flag in Table Native Functions

## Summary
The `use_heap_memory()` function bypasses memory tracking entirely when the `FixMemoryUsageTracking` timed feature flag is disabled, allowing attackers to exhaust validator node memory through unbounded table operations before the flag activation dates (March 7, 2025 for testnet, March 11, 2025 for mainnet).

## Finding Description

The vulnerability exists in the `use_heap_memory()` function which is responsible for tracking and enforcing heap memory limits during native function execution. [1](#0-0) 

When `TimedFeatureFlag::FixMemoryUsageTracking` is **disabled**, the function immediately returns `Ok(())` without:
1. Tracking any memory usage in `legacy_heap_memory_usage`
2. Calling the gas meter's memory enforcement
3. Enforcing the configured `memory_quota` limit

The timed feature flag activation times show this is intentionally delayed: [2](#0-1) 

**Critical Native Functions Affected:**

All table native functions rely on `use_heap_memory()` for memory enforcement: [3](#0-2) [4](#0-3) [5](#0-4) [6](#0-5) 

**Exploitation Path:**

1. Attacker creates tables containing deeply nested structures or large values
2. Attacker repeatedly calls `add_box`, `borrow_box`, `contains_box`, or `remove_box` operations
3. Each operation calculates the memory usage via `abstract_heap_size()` and calls `use_heap_memory()`
4. Due to the disabled feature flag, `use_heap_memory()` returns success without tracking
5. The `legacy_heap_memory_usage` remains 0, so the builder charges 0 bytes: [7](#0-6) 

6. Memory quota enforcement is completely bypassed, allowing unbounded allocation
7. Validator node memory is exhausted, causing crashes or severe performance degradation

**Proof from Test Suite:**

The codebase includes an explicit test demonstrating this vulnerability: [8](#0-7) 

The test shows that before flag activation, loading deeply nested table entries **succeeds** despite exceeding the 10MB memory quota. After activation (simulated by `h.new_epoch()` which forwards time by 2 hours), the identical operation **fails** with `MEMORY_LIMIT_EXCEEDED`.

## Impact Explanation

**Severity: HIGH** (aligns with "Validator node slowdowns" and "Significant protocol violations")

This vulnerability breaks the critical invariant: **"Move VM Safety: Bytecode execution must respect gas limits and memory constraints"**

**Impact Scope:**
- Any validator node processing attacker transactions before March 2025 activation dates
- Network-wide impact if multiple validators are targeted simultaneously
- Can cause validator crashes through memory exhaustion
- Degrades network liveness and transaction processing capacity

**Why HIGH not CRITICAL:**
- Does not directly cause loss of funds
- Does not permanently break consensus (recoverable via node restart)
- Does not require hard fork to resolve (auto-fixes on flag activation)
- Limited to availability/performance impact rather than safety violations

## Likelihood Explanation

**Likelihood: HIGH**

**Factors increasing likelihood:**
1. **Trivial to exploit**: Any user can create tables and call native operations
2. **No special privileges required**: Standard transaction submission suffices
3. **Currently active**: Vulnerability exists on all chains until March 2025
4. **Known to developers**: Test explicitly demonstrates the issue, making it discoverable
5. **Easy to automate**: Simple transaction loops can trigger the vulnerability
6. **High-value target**: Validator node disruption has significant network impact

**Attacker requirements:**
- Ability to submit transactions (minimal gas fees)
- Basic understanding of table operations
- No insider access or validator privileges needed

## Recommendation

**Immediate Fix**: The feature flag should be enabled immediately via governance rather than waiting for the timed activation, or the memory tracking code should be refactored to work independently of the flag.

**Proper Implementation**: The `use_heap_memory()` function should unconditionally track memory usage regardless of feature flags. Feature flags should only control whether double-counting is fixed, not whether tracking happens at all.

**Code Fix:**

```rust
pub fn use_heap_memory(&mut self, amount: u64) -> SafeNativeResult<()> {
    // Always track memory, regardless of feature flags
    if self.has_direct_gas_meter_access_in_native_context() {
        self.gas_meter()
            .use_heap_memory_in_native_context(amount)
            .map_err(LimitExceededError::from_err)?;
    } else {
        self.legacy_heap_memory_usage =
            self.legacy_heap_memory_usage.saturating_add(amount);
    }
    Ok(())
}
```

The `FixMemoryUsageTracking` flag should only control the double-counting fix in table natives: [9](#0-8) 

## Proof of Concept

The existing test in the codebase serves as a proof of concept: [10](#0-9) 

**To reproduce:**

1. Deploy the test module from `aptos-move/e2e-move-tests/tests/memory_quota.data/nested_struct/`
2. Set `memory_quota` to 10,000,000 bytes in VM parameters
3. Call `add()` function 5 times with depth parameter 2000 to create deeply nested table entries
4. Call `read_all()` function - it will **succeed** despite exceeding memory quota
5. After March 2025 flag activation, the same `read_all()` operation will **fail** with `MEMORY_LIMIT_EXCEEDED`

This demonstrates that memory limits are not enforced before flag activation, allowing unbounded memory allocation that can exhaust validator node resources.

## Notes

The vulnerability stems from an implementation choice to gate the entire memory tracking mechanism behind a timed feature flag, rather than just gating the specific bug fix. This creates a window of exploitation from chain genesis until March 2025 where memory limits can be bypassed through table operations. The test suite explicitly validates both the vulnerable (pre-activation) and fixed (post-activation) behaviors, confirming this is a known implementation decision with security implications.

### Citations

**File:** aptos-move/aptos-native-interface/src/context.rs (L205-217)
```rust
    pub fn use_heap_memory(&mut self, amount: u64) -> SafeNativeResult<()> {
        if self.timed_feature_enabled(TimedFeatureFlag::FixMemoryUsageTracking) {
            if self.has_direct_gas_meter_access_in_native_context() {
                self.gas_meter()
                    .use_heap_memory_in_native_context(amount)
                    .map_err(LimitExceededError::from_err)?;
            } else {
                self.legacy_heap_memory_usage =
                    self.legacy_heap_memory_usage.saturating_add(amount);
            }
        }
        Ok(())
    }
```

**File:** types/src/on_chain_config/timed_features.rs (L101-109)
```rust
            (FixMemoryUsageTracking, TESTING) => Utc.with_ymd_and_hms(1970, 1, 1, 1, 0, 0).unwrap(),
            (FixMemoryUsageTracking, TESTNET) => Los_Angeles
                .with_ymd_and_hms(2025, 3, 7, 12, 0, 0)
                .unwrap()
                .with_timezone(&Utc),
            (FixMemoryUsageTracking, MAINNET) => Los_Angeles
                .with_ymd_and_hms(2025, 3, 11, 17, 0, 0)
                .unwrap()
                .with_timezone(&Utc),
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L416-426)
```rust
    let mem_usage = if !fix_memory_double_counting || loaded.is_some() {
        gv.view()
            .map(|val| {
                abs_val_gas_params
                    .abstract_heap_size(&val, gas_feature_version)
                    .map(u64::from)
            })
            .transpose()?
    } else {
        None
    };
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L439-441)
```rust
    if let Some(amount) = mem_usage {
        context.use_heap_memory(amount)?;
    }
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L499-501)
```rust
    if let Some(amount) = mem_usage {
        context.use_heap_memory(amount)?;
    }
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L553-555)
```rust
    if let Some(amount) = mem_usage {
        context.use_heap_memory(amount)?;
    }
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L613-615)
```rust
    if let Some(amount) = mem_usage {
        context.use_heap_memory(amount)?;
    }
```

**File:** aptos-move/aptos-native-interface/src/builder.rs (L121-129)
```rust
            let legacy_heap_memory_usage = context.legacy_heap_memory_usage;
            if context.has_direct_gas_meter_access_in_native_context() {
                assert_eq!(context.legacy_gas_used, 0.into());
                assert_eq!(legacy_heap_memory_usage, 0);
            }
            context
                .inner
                .gas_meter()
                .use_heap_memory_in_native_context(legacy_heap_memory_usage)?;
```

**File:** aptos-move/e2e-move-tests/src/tests/memory_quota.rs (L47-107)
```rust
#[test]
fn deeply_nested_structs() {
    let mut h = MoveHarness::new();

    h.modify_gas_schedule(|gas_params| {
        gas_params.vm.txn.memory_quota = 10_000_000.into();
        gas_params.vm.txn.max_execution_gas = 100_000_000_000.into();
    });

    // Publish the code
    let acc = h.new_account_at(AccountAddress::from_hex_literal("0xbeef").unwrap());
    assert_success!(h.publish_package(
        &acc,
        &common::test_dir_path("memory_quota.data/nested_struct"),
    ));

    // Initialize
    let result = h.run_entry_function(
        &acc,
        str::parse("0xbeef::very_nested_structure::init").unwrap(),
        vec![],
        vec![],
    );
    assert_success!(result);

    // Create nested structs as table entries
    for _i in 0..5 {
        let result = h.run_entry_function(
            &acc,
            str::parse("0xbeef::very_nested_structure::add").unwrap(),
            vec![],
            vec![MoveValue::U64(2000).simple_serialize().unwrap()],
        );
        assert_success!(result);
    }

    // Try to load the whole table -- this should succeed
    let result = h.run_entry_function(
        &acc,
        str::parse("0xbeef::very_nested_structure::read_all").unwrap(),
        vec![],
        vec![],
    );
    assert_success!(result);

    // Forward 2 hours to activate TimedFeatureFlag::FixMemoryUsageTracking
    // Now attempting to load the whole table shall result in an execution failure (memory limit hit)
    h.new_epoch();
    let result = h.run_entry_function(
        &acc,
        str::parse("0xbeef::very_nested_structure::read_all").unwrap(),
        vec![],
        vec![],
    );
    assert!(matches!(
        result,
        TransactionStatus::Keep(ExecutionStatus::MiscellaneousError(Some(
            StatusCode::MEMORY_LIMIT_EXCEEDED
        )))
    ));
}
```
