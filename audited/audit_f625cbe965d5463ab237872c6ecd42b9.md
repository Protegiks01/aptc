# Audit Report

## Title
ConsensusState Fails to Validate Corrupted SafetyData and Waypoint from Persistent Storage Leading to Consensus Safety Violations and Denial of Service

## Summary
The `ConsensusState::new()` constructor and `guarded_consensus_state()` method do not validate the integrity and consistency of `SafetyData` and `Waypoint` values retrieved from persistent storage before using them in consensus safety-critical decisions. Corrupted storage data with invalid epoch, round values, or invariant violations can cause validator nodes to either halt (denial of service) or make unsafe consensus decisions (potential safety violation).

## Finding Description

The `ConsensusState` struct in `consensus/safety-rules/src/consensus_state.rs` serves as the critical data structure holding consensus safety state. [1](#0-0) 

When constructing a `ConsensusState`, the `new()` method accepts `SafetyData` and `Waypoint` parameters without any validation of their internal consistency or validity: [2](#0-1) 

The `guarded_consensus_state()` method in `SafetyRules` reads these values directly from persistent storage and constructs `ConsensusState` without validation: [3](#0-2) 

The `SafetyData` structure contains critical consensus state fields that must maintain specific invariants: [4](#0-3) 

**Critical Invariants That Should Be Validated:**

1. **Epoch validity**: `epoch` should be ≥ 1 (initialization sets it to 1)
2. **Round consistency**: `preferred_round` ≤ `one_chain_round` (parent round ≤ child round per QC structure)
3. **Round progression**: `last_voted_round` should be reasonable relative to other rounds
4. **Waypoint-SafetyData consistency**: The epoch embedded in the waypoint hash should align with SafetyData epoch

**Exploitation Scenarios:**

If persistent storage becomes corrupted (due to storage bugs, hardware failures, or malicious storage backend compromise), the following corrupted values cause critical failures:

1. **`one_chain_round = u64::MAX`**: The `safe_to_timeout` check will always fail, preventing the validator from signing any timeouts: [5](#0-4) 

2. **`one_chain_round = 0`** (when it should be higher): The `safe_to_timeout` check becomes trivial to pass, potentially allowing the validator to sign unsafe timeouts that violate consensus safety rules.

3. **`last_voted_round = u64::MAX`**: The `verify_and_update_last_vote_round` check will always fail, preventing any votes: [6](#0-5) 

4. **`epoch = 0`**: All proposals will be rejected by `verify_epoch`: [7](#0-6) 

5. **`preferred_round > one_chain_round`**: Violates the parent-child invariant maintained by `observe_qc`, causing incorrect proposal rejections: [8](#0-7) 

The corrupted values are used directly in safety-critical voting and timeout logic: [9](#0-8) 

## Impact Explanation

**Critical Severity** - This vulnerability has two potential impact vectors:

1. **Denial of Service (Liveness Violation)**: Corrupted values like `epoch=0`, `last_voted_round=MAX_U64`, or `one_chain_round=MAX_U64` would cause a validator node to reject all proposals and timeouts, effectively removing it from consensus participation. If multiple validators are affected simultaneously (e.g., through a storage backend vulnerability), this could degrade network liveness or cause full consensus halt if it affects >1/3 of validators.

2. **Consensus Safety Violation**: Corrupted values like `one_chain_round=0` (when it should reflect actual consensus progress) could cause a validator to sign votes/timeouts that violate consensus safety rules, potentially enabling equivocation or chain forks if the validator's signatures are used maliciously.

This meets **Critical Severity** criteria per Aptos bug bounty: "Consensus/Safety violations" and "Total loss of liveness/network availability".

## Likelihood Explanation

**Likelihood: Medium**

While storage corruption requires specific conditions, several realistic scenarios exist:

1. **Storage System Bugs**: Bugs in the underlying storage layer (Vault, OnDiskStorage, InMemoryStorage) could return corrupted data during serialization/deserialization failures.

2. **Hardware Failures**: Bit flips, disk corruption, or memory errors could corrupt persisted SafetyData.

3. **Malicious Storage Backend**: If using remote storage (Vault, cloud KMS), a compromised backend could return manipulated data.

4. **Operator Error**: Incorrect storage migration or backup restoration could introduce invalid data.

The lack of validation means that ANY corruption—even single-bit flips—could trigger the vulnerability. Robust systems should validate data integrity at trust boundaries, and persistent storage is a critical trust boundary.

## Recommendation

Implement comprehensive validation in `ConsensusState::new()` to verify SafetyData and Waypoint integrity:

```rust
impl ConsensusState {
    pub fn new(safety_data: SafetyData, waypoint: Waypoint, in_validator_set: bool) -> Result<Self, Error> {
        // Validate epoch
        if safety_data.epoch == 0 {
            return Err(Error::InternalError("Invalid SafetyData: epoch cannot be 0".into()));
        }
        
        // Validate round consistency: preferred_round should be <= one_chain_round
        // (parent round <= child round per QC structure)
        if safety_data.preferred_round > safety_data.one_chain_round {
            return Err(Error::InternalError(format!(
                "Invalid SafetyData: preferred_round ({}) > one_chain_round ({})",
                safety_data.preferred_round, safety_data.one_chain_round
            )));
        }
        
        // Validate round progression: last_voted_round should not exceed current progress
        if safety_data.last_voted_round > safety_data.one_chain_round && 
           safety_data.last_voted_round > safety_data.preferred_round {
            return Err(Error::InternalError(format!(
                "Invalid SafetyData: last_voted_round ({}) exceeds both one_chain_round ({}) and preferred_round ({})",
                safety_data.last_voted_round, safety_data.one_chain_round, safety_data.preferred_round
            )));
        }
        
        // Validate highest_timeout_round consistency
        if safety_data.highest_timeout_round > safety_data.last_voted_round && 
           safety_data.highest_timeout_round > safety_data.one_chain_round {
            return Err(Error::InternalError(format!(
                "Invalid SafetyData: highest_timeout_round ({}) exceeds reasonable bounds",
                safety_data.highest_timeout_round
            )));
        }
        
        // Validate waypoint version is not suspiciously high
        if waypoint.version() > u64::MAX / 2 {
            return Err(Error::InternalError(format!(
                "Invalid Waypoint: version ({}) is suspiciously high",
                waypoint.version()
            )));
        }
        
        Ok(Self {
            safety_data,
            waypoint,
            in_validator_set,
        })
    }
}
```

Additionally, add error handling in `guarded_consensus_state()`:

```rust
fn guarded_consensus_state(&mut self) -> Result<ConsensusState, Error> {
    let waypoint = self.persistent_storage.waypoint()?;
    let safety_data = self.persistent_storage.safety_data()?;
    
    // Validate before use
    let consensus_state = ConsensusState::new(safety_data, waypoint, self.signer().is_ok())?;
    
    trace!(SafetyLogSchema::new(LogEntry::State, LogEvent::Update)
        .author(self.persistent_storage.author()?)
        .epoch(consensus_state.epoch())
        .last_voted_round(consensus_state.last_voted_round())
        .preferred_round(consensus_state.preferred_round())
        .waypoint(consensus_state.waypoint()));
    
    Ok(consensus_state)
}
```

Add a new error variant to `consensus/safety-rules/src/error.rs`:
```rust
#[error("Invalid safety data from storage: {0}")]
InvalidSafetyData(String),
```

## Proof of Concept

```rust
#[cfg(test)]
mod corruption_tests {
    use super::*;
    use aptos_consensus_types::safety_data::SafetyData;
    use aptos_types::waypoint::Waypoint;
    
    #[test]
    #[should_panic(expected = "preferred_round (1000) > one_chain_round (100)")]
    fn test_corrupted_safety_data_invariant_violation() {
        // Corrupted: preferred_round > one_chain_round violates invariant
        let corrupted_safety_data = SafetyData::new(
            1,      // epoch
            50,     // last_voted_round
            1000,   // preferred_round (CORRUPTED: should be <= one_chain_round)
            100,    // one_chain_round
            None,   // last_vote
            0,      // highest_timeout_round
        );
        
        let waypoint = Waypoint::default();
        
        // This should fail with validation error, but currently succeeds
        let _state = ConsensusState::new(corrupted_safety_data, waypoint, true);
    }
    
    #[test]
    #[should_panic(expected = "epoch cannot be 0")]
    fn test_corrupted_safety_data_zero_epoch() {
        // Corrupted: epoch = 0 is invalid (should be >= 1)
        let corrupted_safety_data = SafetyData::new(
            0,      // epoch (CORRUPTED)
            0,      // last_voted_round
            0,      // preferred_round
            0,      // one_chain_round
            None,   // last_vote
            0,      // highest_timeout_round
        );
        
        let waypoint = Waypoint::default();
        
        // This should fail with validation error
        let _state = ConsensusState::new(corrupted_safety_data, waypoint, true);
    }
    
    #[test]
    #[should_panic(expected = "last_voted_round")]
    fn test_corrupted_safety_data_max_last_voted_round() {
        // Corrupted: last_voted_round = MAX causes DoS
        let corrupted_safety_data = SafetyData::new(
            1,           // epoch
            u64::MAX,    // last_voted_round (CORRUPTED: causes DoS)
            100,         // preferred_round
            100,         // one_chain_round
            None,        // last_vote
            0,           // highest_timeout_round
        );
        
        let waypoint = Waypoint::default();
        
        // This should fail with validation error
        let _state = ConsensusState::new(corrupted_safety_data, waypoint, true);
    }
}
```

**Note**: The current implementation would allow these corrupted states to be created and used, leading to the described vulnerabilities. The PoC demonstrates that validation is missing.

### Citations

**File:** consensus/safety-rules/src/consensus_state.rs (L13-17)
```rust
pub struct ConsensusState {
    safety_data: SafetyData,
    waypoint: Waypoint,
    in_validator_set: bool,
}
```

**File:** consensus/safety-rules/src/consensus_state.rs (L40-46)
```rust
    pub fn new(safety_data: SafetyData, waypoint: Waypoint, in_validator_set: bool) -> Self {
        Self {
            safety_data,
            waypoint,
            in_validator_set,
        }
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L135-156)
```rust
    pub(crate) fn observe_qc(&self, qc: &QuorumCert, safety_data: &mut SafetyData) -> bool {
        let mut updated = false;
        let one_chain = qc.certified_block().round();
        let two_chain = qc.parent_block().round();
        if one_chain > safety_data.one_chain_round {
            safety_data.one_chain_round = one_chain;
            trace!(
                SafetyLogSchema::new(LogEntry::OneChainRound, LogEvent::Update)
                    .preferred_round(safety_data.one_chain_round)
            );
            updated = true;
        }
        if two_chain > safety_data.preferred_round {
            safety_data.preferred_round = two_chain;
            trace!(
                SafetyLogSchema::new(LogEntry::PreferredRound, LogEvent::Update)
                    .preferred_round(safety_data.preferred_round)
            );
            updated = true;
        }
        updated
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L204-210)
```rust
    pub(crate) fn verify_epoch(&self, epoch: u64, safety_data: &SafetyData) -> Result<(), Error> {
        if epoch != safety_data.epoch {
            return Err(Error::IncorrectEpoch(epoch, safety_data.epoch));
        }

        Ok(())
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L213-232)
```rust
    pub(crate) fn verify_and_update_last_vote_round(
        &self,
        round: Round,
        safety_data: &mut SafetyData,
    ) -> Result<(), Error> {
        if round <= safety_data.last_voted_round {
            return Err(Error::IncorrectLastVotedRound(
                round,
                safety_data.last_voted_round,
            ));
        }

        safety_data.last_voted_round = round;
        trace!(
            SafetyLogSchema::new(LogEntry::LastVotedRound, LogEvent::Update)
                .last_voted_round(safety_data.last_voted_round)
        );

        Ok(())
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L247-263)
```rust
    fn guarded_consensus_state(&mut self) -> Result<ConsensusState, Error> {
        let waypoint = self.persistent_storage.waypoint()?;
        let safety_data = self.persistent_storage.safety_data()?;

        trace!(SafetyLogSchema::new(LogEntry::State, LogEvent::Update)
            .author(self.persistent_storage.author()?)
            .epoch(safety_data.epoch)
            .last_voted_round(safety_data.last_voted_round)
            .preferred_round(safety_data.preferred_round)
            .waypoint(waypoint));

        Ok(ConsensusState::new(
            self.persistent_storage.safety_data()?,
            self.persistent_storage.waypoint()?,
            self.signer().is_ok(),
        ))
    }
```

**File:** consensus/consensus-types/src/safety_data.rs (L9-21)
```rust
#[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L53-95)
```rust
    pub(crate) fn guarded_construct_and_sign_vote_two_chain(
        &mut self,
        vote_proposal: &VoteProposal,
        timeout_cert: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<Vote, Error> {
        // Exit early if we cannot sign
        self.signer()?;

        let vote_data = self.verify_proposal(vote_proposal)?;
        if let Some(tc) = timeout_cert {
            self.verify_tc(tc)?;
        }
        let proposed_block = vote_proposal.block();
        let mut safety_data = self.persistent_storage.safety_data()?;

        // if already voted on this round, send back the previous vote
        // note: this needs to happen after verifying the epoch as we just check the round here
        if let Some(vote) = safety_data.last_vote.clone() {
            if vote.vote_data().proposed().round() == proposed_block.round() {
                return Ok(vote);
            }
        }

        // Two voting rules
        self.verify_and_update_last_vote_round(
            proposed_block.block_data().round(),
            &mut safety_data,
        )?;
        self.safe_to_vote(proposed_block, timeout_cert)?;

        // Record 1-chain data
        self.observe_qc(proposed_block.quorum_cert(), &mut safety_data);
        // Construct and sign vote
        let author = self.signer()?.author();
        let ledger_info = self.construct_ledger_info_2chain(proposed_block, vote_data.hash())?;
        let signature = self.sign(&ledger_info)?;
        let vote = Vote::new_with_signature(vote_data, author, ledger_info, signature);

        safety_data.last_vote = Some(vote.clone());
        self.persistent_storage.set_safety_data(safety_data)?;

        Ok(vote)
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L124-145)
```rust
    fn safe_to_timeout(
        &self,
        timeout: &TwoChainTimeout,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
        safety_data: &SafetyData,
    ) -> Result<(), Error> {
        let round = timeout.round();
        let qc_round = timeout.hqc_round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        if (round == next_round(qc_round)? || round == next_round(tc_round)?)
            && qc_round >= safety_data.one_chain_round
        {
            Ok(())
        } else {
            Err(Error::NotSafeToTimeout(
                round,
                qc_round,
                tc_round,
                safety_data.one_chain_round,
            ))
        }
    }
```
