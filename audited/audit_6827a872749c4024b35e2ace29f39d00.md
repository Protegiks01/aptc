# Audit Report

## Title
Client-Side Denial of Service via Missing Content-Type Validation in Faucet Client

## Summary
The `FaucetClient` in `crates/aptos-rest-client/src/faucet.rs` does not validate the HTTP response Content-Type header before parsing responses as hex-encoded BCS data. This allows an attacker with network-level access (MITM) or control over misconfigured infrastructure to cause prolonged client hangs by returning crafted responses with far-future transaction expiration timestamps.

## Finding Description
The vulnerability exists in both `create_account()` and `fund()` methods of the `FaucetClient` struct. The code flow is: [1](#0-0) 

The client performs the following operations:
1. Sends HTTP request to faucet endpoint
2. Reads the response body as text without checking Content-Type header
3. Checks if HTTP status code is successful (2xx)
4. Attempts to hex-decode the body
5. Attempts to BCS-deserialize the result as `Vec<SignedTransaction>`

**Attack Scenario:**
An attacker performing a man-in-the-middle attack or exploiting misconfigured infrastructure (reverse proxy, CDN, load balancer) can return HTTP 200 OK with a crafted payload:
- Body contains hex-encoded BCS serialization of `Vec<SignedTransaction>`
- The transaction has `expiration_timestamp_secs` set to far in the future (e.g., current_time + 365 days)
- Any transaction hash (doesn't need to exist on-chain)

The client successfully parses this fake transaction data and calls `wait_for_signed_transaction()`: [2](#0-1) 

The wait function extracts the expiration timestamp and polls until it expires: [3](#0-2) 

The timeout logic only triggers after the expiration time plus 60 seconds: [4](#0-3) 

Since there is no absolute timeout (timeout_from_call is None), the client will poll every 500ms until the crafted expiration time is reached, potentially hanging for days, weeks, or months.

## Impact Explanation
This vulnerability causes:

1. **Client-Side Denial of Service**: Applications using `FaucetClient` become unresponsive for arbitrary durations
2. **Resource Exhaustion**: Continuous polling (every 500ms) wastes network bandwidth and computational resources
3. **Operational Disruption**: Development tools, CI/CD pipelines, test suites, and onboarding flows that depend on the faucet client will hang

**Severity Assessment**: While this issue does not affect consensus, validator nodes, or on-chain state, it impacts critical ecosystem infrastructure. Under the Aptos bug bounty criteria, this would be classified as **Medium Severity** due to operational disruption and resource exhaustion, rather than High severity, since it:
- Does not affect validator nodes or consensus
- Does not cause API server crashes (only client hangs)
- Does not violate core blockchain protocol invariants

## Likelihood Explanation
**Likelihood: Medium**

The attack requires:
1. Man-in-the-middle position OR control over infrastructure (reverse proxy, CDN, load balancer)
2. Ability to craft valid hex-encoded BCS payloads (straightforward with Aptos SDK tools)
3. Knowledge of the vulnerability (now disclosed)

Realistic scenarios:
- Misconfigured load balancers returning HTTP 200 with error pages
- Compromised reverse proxies in development environments
- Malicious network infrastructure in untrusted environments

## Recommendation
Implement Content-Type validation before parsing responses:

```rust
pub async fn create_account(&self, address: AccountAddress) -> Result<()> {
    let mut url = self.faucet_url.clone();
    url.set_path("mint");
    let query = format!("auth_key={}&amount=0&return_txns=true", address);
    url.set_query(Some(&query));

    let response = self.build_and_submit_request(url).await?;
    let status_code = response.status();
    
    // Validate Content-Type header
    let content_type = response.headers()
        .get(reqwest::header::CONTENT_TYPE)
        .and_then(|v| v.to_str().ok())
        .unwrap_or("");
    
    if !content_type.starts_with("text/plain") && !content_type.is_empty() {
        return Err(anyhow::anyhow!(
            "Unexpected Content-Type: {}. Expected text/plain", 
            content_type
        ));
    }
    
    let body = response.text().await.map_err(FaucetClientError::decode)?;
    if !status_code.is_success() {
        return Err(anyhow::anyhow!("body: {}", body));
    }

    let bytes = hex::decode(body).map_err(FaucetClientError::decode)?;
    let txns: Vec<SignedTransaction> =
        bcs::from_bytes(&bytes).map_err(FaucetClientError::decode)?;

    self.rest_client
        .wait_for_signed_transaction(&txns[0])
        .await
        .map_err(FaucetClientError::unknown)?;

    Ok(())
}
```

Additionally, add an absolute timeout to `wait_for_signed_transaction`:

```rust
pub async fn wait_for_signed_transaction(
    &self,
    transaction: &SignedTransaction,
) -> AptosResult<Response<Transaction>> {
    let expiration_timestamp = transaction.expiration_timestamp_secs();
    self.wait_for_transaction_by_hash(
        transaction.committed_hash(),
        expiration_timestamp,
        Some(DEFAULT_MAX_SERVER_LAG_WAIT_DURATION),
        Some(Duration::from_secs(300)), // 5-minute absolute timeout
    )
    .await
}
```

## Proof of Concept

```rust
use aptos_rest_client::FaucetClient;
use aptos_types::transaction::{RawTransaction, SignedTransaction, TransactionPayload};
use aptos_sdk::types::{AccountAddress, chain_id::ChainId};
use aptos_crypto::{ed25519::Ed25519PrivateKey, PrivateKey, Uniform};
use std::time::{SystemTime, UNIX_EPOCH};

// This PoC demonstrates crafting a malicious response that causes client hang
#[tokio::test]
async fn test_faucet_content_type_exploit() {
    // Create a fake transaction with far-future expiration
    let current_time = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs();
    let far_future_expiration = current_time + (365 * 24 * 60 * 60); // 1 year from now
    
    let private_key = Ed25519PrivateKey::generate_for_testing();
    let public_key = private_key.public_key();
    
    let raw_txn = RawTransaction::new(
        AccountAddress::random(),
        0,
        TransactionPayload::Script(aptos_types::transaction::Script::new(vec![], vec![], vec![])),
        1000000,
        1,
        far_future_expiration,
        ChainId::test(),
    );
    
    let signed_txn = SignedTransaction::new(
        raw_txn,
        public_key,
        private_key.sign(&vec![]).unwrap(),
    );
    
    // Serialize to BCS and encode as hex (this is what attacker would return)
    let bcs_bytes = bcs::to_bytes(&vec![signed_txn]).unwrap();
    let malicious_payload = hex::encode(bcs_bytes);
    
    // In a real attack, this payload would be returned with HTTP 200
    // The client would parse it successfully and hang waiting for the transaction
    // until far_future_expiration + 60 seconds (1 year + 60 seconds from now)
    
    println!("Malicious payload length: {}", malicious_payload.len());
    println!("Client would hang until: {}", far_future_expiration);
}
```

## Notes
- This vulnerability requires network-level access or misconfigured infrastructure, which reduces likelihood but doesn't eliminate the risk
- The same vulnerability exists in the `fund()` method [5](#0-4) 
- The faucet server correctly sets Content-Type to text/plain via `PlainText<String>` response type [6](#0-5) , but the client doesn't validate it
- While this doesn't affect core blockchain consensus or validator operations, it impacts ecosystem tooling and developer experience

### Citations

**File:** crates/aptos-rest-client/src/faucet.rs (L64-73)
```rust
        let response = self.build_and_submit_request(url).await?;
        let status_code = response.status();
        let body = response.text().await.map_err(FaucetClientError::decode)?;
        if !status_code.is_success() {
            return Err(anyhow::anyhow!("body: {}", body));
        }

        let bytes = hex::decode(body).map_err(FaucetClientError::decode)?;
        let txns: Vec<SignedTransaction> =
            bcs::from_bytes(&bytes).map_err(FaucetClientError::decode)?;
```

**File:** crates/aptos-rest-client/src/faucet.rs (L75-78)
```rust
        self.rest_client
            .wait_for_signed_transaction(&txns[0])
            .await
            .map_err(FaucetClientError::unknown)?;
```

**File:** crates/aptos-rest-client/src/faucet.rs (L92-101)
```rust
        let response = self.build_and_submit_request(url).await?;
        let status_code = response.status();
        let body = response.text().await.map_err(FaucetClientError::decode)?;
        if !status_code.is_success() {
            return Err(FaucetClientError::status(status_code.as_u16()).into());
        }

        let bytes = hex::decode(body).map_err(FaucetClientError::decode)?;
        let txns: Vec<SignedTransaction> =
            bcs::from_bytes(&bytes).map_err(FaucetClientError::decode)?;
```

**File:** crates/aptos-rest-client/src/lib.rs (L711-723)
```rust
    pub async fn wait_for_signed_transaction(
        &self,
        transaction: &SignedTransaction,
    ) -> AptosResult<Response<Transaction>> {
        let expiration_timestamp = transaction.expiration_timestamp_secs();
        self.wait_for_transaction_by_hash(
            transaction.committed_hash(),
            expiration_timestamp,
            Some(DEFAULT_MAX_SERVER_LAG_WAIT_DURATION),
            None,
        )
        .await
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L824-833)
```rust
            if let Some(max_server_lag_wait_duration) = max_server_lag_wait {
                if aptos_infallible::duration_since_epoch().as_secs()
                    > expiration_timestamp_secs + max_server_lag_wait_duration.as_secs()
                {
                    return Err(anyhow!(
                        "Ledger on endpoint ({}) is more than {}s behind current time, timing out waiting for the transaction. Warning, transaction ({}) might still succeed.",
                        self.path_prefix_string(),
                        max_server_lag_wait_duration.as_secs(),
                        hash,
                    ).into());
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L374-374)
```rust
    SubmittedTxns(PlainText<String>),
```
