# Audit Report

## Title
Zero-Length Encrypted Frames Bypass Detection and Cause Premature Connection Closure

## Summary
The NoiseStream implementation in `network/framework/src/noise/stream.rs` fails to completely reject zero-length messages. While the code explicitly checks for and rejects frames with `frame_len == 0`, it does not detect zero-length encrypted frames (16 bytes containing only an AES-GCM authentication tag). When such frames are received and successfully decrypted, the stream returns `Ok(0)` from `read()`, which violates the AsyncRead contract by signaling EOF on an active connection, causing premature connection closure. The fuzzer in `network/framework/src/noise/fuzzing.rs` skips testing with empty input, missing this edge case.

## Finding Description

The Noise protocol implementation intends to reject zero-length messages, as evidenced by the comment at line 114. [1](#0-0) 

However, the check only validates `frame_len == 0` and does not account for zero-length encrypted frames. In the Noise protocol with AES-GCM, encrypting a zero-length plaintext produces a 16-byte authentication tag. [2](#0-1) 

The `write_message_in_place` function successfully encrypts zero-length messages and returns a 16-byte authentication tag. [3](#0-2) 

This is demonstrated in the test suite where an empty message is encrypted. [4](#0-3) 

When a frame with `frame_len == 16` is received:
1. The frame length check at line 113 passes (16 â‰  0)
2. The frame is read and decrypted successfully to 0 bytes of plaintext
3. The `CopyDecryptedFrame` state is entered with `decrypted_len == 0`
4. The state copies 0 bytes and returns `Poll::Ready(Ok(0))` [5](#0-4) 

According to the AsyncRead trait contract, returning `Ok(0)` signals EOF (end-of-file), indicating the stream has been closed by the remote peer. This causes the `LengthDelimitedCodec` layer to interpret it as stream termination, which propagates up to the peer connection handler. [6](#0-5) 

**Attack Path:**
1. Malicious peer completes Noise handshake with target validator
2. Attacker crafts a Noise frame: 2-byte length prefix `[0x00, 0x10]` + 16-byte valid AES-GCM tag for empty plaintext at current nonce
3. Victim's NoiseStream reads frame_len = 16, reads and decrypts successfully
4. `read()` returns `Ok(0)`, signaling EOF
5. Connection is closed and logged as `ConnectionClosed`
6. Validator must re-establish connection, causing disruption

The fuzzer skips this scenario by returning early when `data.is_empty()`. [7](#0-6) 

This prevents discovery of vulnerabilities related to minimal-length frames (like the 18-byte zero-length encrypted frame scenario).

## Impact Explanation

This vulnerability allows any authenticated peer to force connection closure on demand, causing:

1. **Network Disruption**: Validators experiencing repeated forced disconnections must continuously re-establish connections, consuming resources and potentially causing message delays
2. **Consensus Impact**: During critical consensus phases, forced disconnections could delay block proposals or votes, affecting network liveness
3. **Resource Exhaustion**: Connection re-establishment overhead (handshake, state sync) multiplied across many forced disconnections

This qualifies as **Medium Severity** per the Aptos bug bounty program because it enables validator node disruption and could cause state inconsistencies if connections are severed during critical state synchronization operations. While not causing permanent damage or funds loss, it represents a significant protocol violation (zero-length messages should be rejected) and can degrade network performance.

## Likelihood Explanation

**Likelihood: Medium to High**

- **Attacker Requirements**: Must be an authenticated peer (completed Noise handshake). In Aptos P2P network, any node can connect to validators, making this accessible to attackers
- **Technical Complexity**: Low - attacker only needs to craft a 18-byte packet with valid AES-GCM tag, which they can compute using shared session keys from the handshake
- **Detection**: Connection closures appear legitimate ("ConnectionClosed"), making attacks hard to distinguish from normal network behavior
- **Scale**: Attacker can target multiple validators simultaneously

## Recommendation

Add validation to reject zero-length decrypted messages, consistent with the protocol's intent:

In `network/framework/src/noise/stream.rs`, after successful decryption in the `ReadFrame` state, check if the decrypted length is zero:

```rust
ReadState::ReadFrame {
    frame_len,
    ref mut offset,
} => {
    match ready!(poll_read_exact(
        context,
        Pin::new(&mut self.socket),
        &mut self.buffers.read_buffer[..(frame_len as usize)],
        offset
    )) {
        Ok(()) => {
            match self.session.read_message_in_place(
                &mut self.buffers.read_buffer[..(frame_len as usize)],
            ) {
                Ok(decrypted) => {
                    // Reject zero-length decrypted messages
                    if decrypted.len() == 0 {
                        error!("Received zero-length encrypted message");
                        self.read_state = ReadState::Eof(Err(()));
                    } else {
                        self.read_state = ReadState::CopyDecryptedFrame {
                            decrypted_len: decrypted.len(),
                            offset: 0,
                        };
                    }
                },
                Err(e) => {
                    error!(error = %e, "Decryption Error: {}", e);
                    self.read_state = ReadState::DecryptionError(e);
                },
            }
        },
        // ... rest of error handling
    }
}
```

Additionally, remove the early return in the fuzzer to test edge cases:

```rust
pub fn fuzz_post_handshake(data: &[u8]) {
    // Remove the early return to test all inputs including empty/minimal
    
    // setup fake socket
    let mut fake_socket = ReadOnlyTestSocket::new(data);
    fake_socket.set_trailing();
    
    // ... rest of fuzzer
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use crate::noise::{stream::NoiseStream, AntiReplayTimestamps};
    use crate::testutils::fake_socket::ReadOnlyTestSocket;
    use aptos_crypto::noise::NoiseSession;
    use futures::io::AsyncReadExt;
    use futures::executor::block_on;

    #[test]
    fn test_zero_length_encrypted_frame_causes_eof() {
        // Create a NoiseSession for testing
        let mut noise_session = NoiseSession::new_for_testing();
        
        // Encrypt an empty message to get the auth tag
        let mut empty_message = vec![];
        let auth_tag = noise_session
            .write_message_in_place(&mut empty_message)
            .expect("Should encrypt empty message");
        
        // Construct a frame: 2-byte length (16 = 0x0010) + 16-byte auth tag
        let mut frame_data = vec![0x00, 0x10];  // frame_len = 16
        frame_data.extend_from_slice(&auth_tag);
        
        // Create fake socket with this frame
        let fake_socket = ReadOnlyTestSocket::new(&frame_data);
        
        // Create NoiseStream with a fresh session (matching encryption session)
        let noise_session_read = NoiseSession::new_for_testing();
        let mut stream = NoiseStream::new(fake_socket, noise_session_read);
        
        // Try to read - should return Ok(0) indicating EOF
        let result = block_on(async {
            let mut buffer = [0u8; 128];
            stream.read(&mut buffer).await
        });
        
        // Verify that read returns Ok(0), which signals EOF
        assert_eq!(result.unwrap(), 0, 
            "Zero-length encrypted frame should cause Ok(0) EOF, causing connection closure");
    }
}
```

**Notes:**
This vulnerability specifically affects the network layer's handling of Noise-encrypted frames. While zero-length messages at the application layer (MultiplexMessage) are unlikely due to protocol structure, the lower-level Noise framing layer must still properly reject them to maintain protocol integrity. The incomplete validation allows authenticated peers to exploit this oversight for denial-of-service attacks against validator connections.

### Citations

**File:** network/framework/src/noise/stream.rs (L113-115)
```rust
                            if frame_len == 0 {
                                // 0-length messages are not expected
                                self.read_state = ReadState::Eof(Err(()));
```

**File:** network/framework/src/noise/stream.rs (L168-185)
```rust
                ReadState::CopyDecryptedFrame {
                    decrypted_len,
                    ref mut offset,
                } => {
                    let bytes_to_copy = ::std::cmp::min(decrypted_len - *offset, buf.len());
                    buf[..bytes_to_copy].copy_from_slice(
                        &self.buffers.read_buffer[*offset..(*offset + bytes_to_copy)],
                    );
                    trace!(
                        "CopyDecryptedFrame: copied {}/{} bytes",
                        *offset + bytes_to_copy,
                        decrypted_len
                    );
                    *offset += bytes_to_copy;
                    if *offset == decrypted_len {
                        self.read_state = ReadState::Init;
                    }
                    return Poll::Ready(Ok(bytes_to_copy));
```

**File:** crates/aptos-crypto/src/noise.rs (L83-83)
```rust
pub const AES_GCM_TAGLEN: usize = 16;
```

**File:** crates/aptos-crypto/src/noise.rs (L628-659)
```rust
    pub fn write_message_in_place(&mut self, message: &mut [u8]) -> Result<Vec<u8>, NoiseError> {
        // checks
        if !self.valid {
            return Err(NoiseError::SessionClosed);
        }
        if message.len() > MAX_SIZE_NOISE_MSG - AES_GCM_TAGLEN {
            return Err(NoiseError::PayloadTooLarge);
        }

        // encrypt in place
        let write_key = aes_key(&self.write_key[..]);

        let mut nonce = [0u8; 4].to_vec();
        nonce.extend_from_slice(&self.write_nonce.to_be_bytes());
        assert_eq!(nonce.len(), 12);
        let nonce = aead::Nonce::assume_unique_for_key(
            nonce.try_into().expect("Incorrect AES256-GCM nonce length"),
        );

        let authentication_tag = write_key
            .seal_in_place_separate_tag(nonce, aead::Aad::empty(), message)
            .map_err(|_| NoiseError::Encrypt)?;

        // increment nonce
        self.write_nonce = self
            .write_nonce
            .checked_add(1)
            .ok_or(NoiseError::NonceOverflow)?;

        // return a subslice without the authentication tag
        Ok(authentication_tag.as_ref().into())
    }
```

**File:** crates/aptos-crypto/src/unit_tests/noise_test.rs (L517-521)
```rust
        let mut message = b"".to_vec();

        let auth_tag = initiator_session
            .write_message_in_place(&mut message)
            .expect("should work");
```

**File:** network/framework/src/peer/mod.rs (L267-269)
```rust
                        // The socket was gracefully closed by the remote peer.
                        None => self.shutdown(DisconnectReason::ConnectionClosed),
                    }
```

**File:** network/framework/src/noise/fuzzing.rs (L184-188)
```rust
pub fn fuzz_post_handshake(data: &[u8]) {
    if data.is_empty() {
        return;
    }

```
