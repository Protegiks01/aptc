# Audit Report

## Title
Token Renewal State Machine Failure Leading to Validator Node Liveness Failure

## Summary
The VaultStorage token renewal state machine in `secure/storage/src/vault.rs` fails to update the `next_renewal` timestamp when token renewal fails, causing the state machine to enter an invalid state where `next_renewal` remains in the past. This triggers continuous renewal attempts on every storage operation, and if renewal continues failing until the token expires, the validator node crashes via panic and cannot recover without manual restart.

## Finding Description

The `client()` method implements automatic token renewal logic: [1](#0-0) 

The critical bug occurs when `renew_token_self()` returns an error. The code only logs the error but **does not update** `next_renewal`. This causes the state machine to remain in an invalid state where:

1. `next_renewal` stays at its previous value (initially 0, or a past timestamp after the first successful renewal)
2. Every subsequent call checks `now >= next_renewal`, which remains TRUE forever
3. Every storage operation attempts token renewal, creating a thundering herd of failed network requests
4. If renewal failures persist beyond the token's TTL, the token expires
5. Expired tokens cannot be renewed, creating a permanent failure state
6. All subsequent storage operations fail with `PermissionDenied`

The SafetyRules component catches `PermissionDenied` errors and panics: [2](#0-1) 

**Attack Scenario:**
While an external attacker cannot directly trigger this (it requires Vault infrastructure issues), the bug creates a critical operational vulnerability:

1. Validator configured with `renew_ttl_secs = 3600` (1 hour)
2. Initial renewal succeeds at T=100, setting `next_renewal = 1900` (100 + 3600/2)
3. At T=1900, Vault experiences transient issues (network blip, load spike, maintenance)
4. Renewal fails, `next_renewal` remains at 1900
5. From T=1901 onwards, **every single storage operation** attempts renewal:
   - `get()` calls `client()` → renewal attempt → fails
   - `set()` calls `client()` → renewal attempt → fails  
   - `sign()` calls `client()` → renewal attempt → fails
6. At T=3700 (100 + 3600), original token expires
7. All operations now fail with `PermissionDenied`
8. Node panics with "Maybe the storage token needs to be renewed?"
9. **No automatic recovery possible** - requires operator to manually restart with new token

This breaks the **availability invariant** - validator nodes should handle transient failures gracefully without requiring manual intervention.

## Impact Explanation

**Medium Severity** - "State inconsistencies requiring intervention"

While this is not directly exploitable by external attackers, it represents a critical operational security flaw:

- **Liveness Failure**: Validator node becomes unavailable, affecting network consensus capacity
- **Manual Intervention Required**: Automated systems cannot recover, requiring operator action
- **Amplification Effect**: Single transient Vault failure escalates to node crash
- **Thundering Herd**: Continuous retry attempts may overload Vault infrastructure, affecting other validators

This does not reach Critical severity because:
- No consensus safety violations (node crashes, doesn't vote incorrectly)
- No fund loss or theft
- Network continues with remaining validators (assuming < 1/3 affected)

However, if multiple validators experience this simultaneously during a Vault outage, it could approach the threshold for "Total loss of liveness/network availability" (Critical).

## Likelihood Explanation

**Medium Likelihood** in production environments:

**Triggering Conditions:**
- Transient Vault infrastructure issues (network latency spikes, service restarts, rate limiting)
- Vault maintenance windows overlapping with renewal attempts
- Certificate expiration or rotation issues
- Network partition between validator and Vault

**Frequency Factors:**
- Renewal window is TTL/2 (e.g., every 30 minutes for 1-hour tokens)
- Single failure during any renewal window triggers the cascade
- Production environments often experience transient infrastructure issues
- No circuit breaker or backoff mechanism to prevent escalation

**Real-World Scenarios:**
- Cloud provider network issues affecting Vault connectivity
- Vault cluster rolling updates during peak load
- TLS certificate rotation causing brief auth failures
- Rate limiting under high validator count

## Recommendation

Implement robust error handling in the renewal state machine:

1. **Update next_renewal on failure with exponential backoff:**
   ```rust
   fn client(&self) -> &Client {
       if self.renew_ttl_secs.is_some() {
           let now = self.time_service.now_secs();
           let next_renewal = self.next_renewal.load(Ordering::Relaxed);
           if now >= next_renewal {
               let result = self.client.renew_token_self(self.renew_ttl_secs);
               if let Ok(ttl) = result {
                   let next_renewal = now + (ttl as u64) / 2;
                   self.next_renewal.store(next_renewal, Ordering::Relaxed);
               } else if let Err(e) = result {
                   aptos_logger::error!("Unable to renew lease: {}", e.to_string());
                   // CRITICAL FIX: Set next renewal in future with exponential backoff
                   let backoff_secs = calculate_backoff(self.renewal_failures.fetch_add(1, Ordering::Relaxed));
                   let next_renewal = now + backoff_secs;
                   self.next_renewal.store(next_renewal, Ordering::Relaxed);
               }
           }
       }
       &self.client
   }
   ```

2. **Add renewal failure counter and circuit breaker** to prevent thundering herd

3. **Implement pre-expiration alerts** to warn operators before token expires

4. **Add graceful degradation** instead of immediate panic on PermissionDenied

5. **Consider token refresh before expiration** (e.g., at 75% of TTL, not 50%)

## Proof of Concept

```rust
#[cfg(test)]
mod test_renewal_failure {
    use super::*;
    use aptos_time_service::MockTimeService;
    use std::sync::Arc;
    
    #[test]
    fn test_renewal_failure_causes_continuous_retries() {
        // Create VaultStorage with mock that fails renewal
        let mut mock_vault = setup_mock_vault_with_failing_renewal();
        let time_service = MockTimeService::new();
        
        let storage = VaultStorage {
            client: mock_vault,
            time_service: Arc::new(time_service),
            renew_ttl_secs: Some(3600),
            next_renewal: AtomicU64::new(0),
            use_cas: false,
            secret_versions: RwLock::new(HashMap::new()),
        };
        
        // First call triggers renewal
        time_service.advance_secs(100);
        let _ = storage.client(); // Renewal fails, next_renewal stays at 0
        
        // Verify next_renewal is still 0 (bug!)
        assert_eq!(storage.next_renewal.load(Ordering::Relaxed), 0);
        
        // Every subsequent call retries renewal
        let mut retry_count = 0;
        for _ in 0..100 {
            time_service.advance_secs(1);
            let _ = storage.client();
            retry_count += 1;
        }
        
        // Verify 100+ renewal attempts occurred (thundering herd)
        assert_eq!(mock_vault.renewal_attempt_count(), retry_count);
        
        // Advance to token expiration
        time_service.advance_secs(3600);
        
        // All operations now fail
        let result = storage.get::<String>("test_key");
        assert!(matches!(result, Err(Error::PermissionDenied)));
        
        // SafetyRules would panic here (verified in error.rs:87-90)
    }
}
```

**Note:** This vulnerability requires infrastructure-level reproduction with actual Vault instances to fully demonstrate, as it depends on external system failure modes.

### Citations

**File:** secure/storage/src/vault.rs (L69-84)
```rust
    fn client(&self) -> &Client {
        if self.renew_ttl_secs.is_some() {
            let now = self.time_service.now_secs();
            let next_renewal = self.next_renewal.load(Ordering::Relaxed);
            if now >= next_renewal {
                let result = self.client.renew_token_self(self.renew_ttl_secs);
                if let Ok(ttl) = result {
                    let next_renewal = now + (ttl as u64) / 2;
                    self.next_renewal.store(next_renewal, Ordering::Relaxed);
                } else if let Err(e) = result {
                    aptos_logger::error!("Unable to renew lease: {}", e.to_string());
                }
            }
        }
        &self.client
    }
```

**File:** consensus/safety-rules/src/error.rs (L81-90)
```rust
            aptos_secure_storage::Error::PermissionDenied => {
                // If a storage error is thrown that indicates a permission failure, we
                // want to panic immediately to alert an operator that something has gone
                // wrong. For example, this error is thrown when a storage (e.g., vault)
                // token has expired, so it makes sense to fail fast and require a token
                // renewal!
                panic!(
                    "A permission error was thrown: {:?}. Maybe the storage token needs to be renewed?",
                    error
                );
```
