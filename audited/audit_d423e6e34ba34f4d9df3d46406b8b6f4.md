# Audit Report

## Title
Gas Bypass in Type Layout Construction Allows Disproportionate Resource Consumption

## Summary
The type layout converter charges gas only for unique module loads, not for the actual computational work of constructing layouts. An attacker can craft types that require extensive layout construction (up to 512 nodes) while paying gas for only a single module load, enabling resource exhaustion attacks on validators.

## Finding Description

The vulnerability exists in the gas charging mechanism for type layout construction. When converting runtime types to type layouts, the system performs significant computational work including:

1. Recursive traversal of type structures
2. Type parameter substitution for generics
3. Creation of `MoveTypeLayout` objects
4. Depth and size limit checks

However, gas is only charged for **unique module loads**, not for the layout construction work itself. [1](#0-0) 

The core issue is that `type_to_type_layout_impl` performs extensive recursive work but never directly charges gas. It only increments counters and checks limits: [2](#0-1) 

Gas is charged only when loading struct definitions from modules: [3](#0-2) 

The module charging mechanism in `LazyLoader` only charges once per unique module per transaction: [4](#0-3) 

The gas charged is based solely on module size: [5](#0-4) 

With costs defined as: [6](#0-5) 

The `DefiningModules` structure tracks only **unique** modules, not usage count: [7](#0-6) 

**Attack Scenario:**

1. Attacker publishes a Move module containing a struct with 511 fields (just under the `layout_max_size` limit of 512)
2. All fields use types from the same module (or a small number of modules)
3. Attacker calls a native function that triggers layout construction (e.g., emitting events, table operations, BCS serialization)
4. The VM constructs the layout by:
   - Traversing all 511 fields recursively
   - Creating 512 `MoveTypeLayout` nodes
   - Performing type substitutions if generics are involved
   - Executing 512 depth/count checks
5. Gas charged: Only **74,460 + 42 Ã— module_size** internal gas units for the single module load
6. Actual work: 500+ recursive function calls, memory allocations, and CPU operations

This breaks **Invariant #9: "All operations must respect gas, storage, and computational limits"** - the gas charge is not proportional to the computational work performed.

## Impact Explanation

This vulnerability qualifies as **HIGH severity** under the Aptos Bug Bounty program criteria:

- **Validator node slowdowns**: Attackers can submit transactions that consume excessive CPU resources during layout construction while paying minimal gas. Multiple such transactions could significantly degrade validator performance.

- **Resource exhaustion**: With the limits set to 512 nodes and 128 depth, each layout construction can perform hundreds of operations but only pay for module loading. An attacker could spam such transactions to exhaust validator CPU resources.

- **Consensus impact**: If validators have different performance characteristics, they might process these expensive layouts at different speeds, potentially causing timeout issues or block proposal delays.

The impact does not reach CRITICAL severity because:
- The limits (512 nodes, 128 depth) prevent unbounded resource consumption
- It does not directly cause loss of funds or consensus safety violations
- Recovery does not require a hardfork

However, it is clearly more severe than MEDIUM as it can cause measurable validator performance degradation network-wide.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to be exploited because:

1. **Low barrier to entry**: Any user can publish Move modules and call native functions that trigger layout construction
2. **Multiple attack vectors**: Layout construction is triggered by:
   - Event emission natives
   - Table operation natives
   - BCS serialization operations
   - Any native function that requires type layouts
3. **Easily discoverable**: The gas parameters and limits are publicly documented
4. **Significant cost-benefit ratio**: For ~100K-200K gas units (module load), an attacker can force 500+ CPU-intensive operations
5. **Repeatable**: The attack can be executed in every transaction, multiplying the effect

The attack requires minimal sophistication - simply creating a struct with many fields and calling a native function that uses it.

## Recommendation

Implement per-node gas charging for layout construction. The fix should:

1. **Charge gas per layout node created**: Add a new gas parameter (e.g., `LAYOUT_NODE_CREATION`) and charge it for each node in `check_depth_and_increment_count`:

```rust
fn check_depth_and_increment_count(
    &self,
    gas_meter: &mut impl GasMeter, // Change to GasMeter trait
    node_count: &mut u64,
    depth: u64,
) -> PartialVMResult<()> {
    let max_count = self.vm_config().layout_max_size;
    if *node_count > max_count || *node_count == max_count && self.is_lazy_loading_enabled() {
        return Err(
            PartialVMError::new(StatusCode::TOO_MANY_TYPE_NODES).with_message(format!(
                "Number of type nodes when constructing type layout exceeded the maximum of {}",
                max_count
            )),
        );
    }
    *node_count += 1;
    
    // NEW: Charge gas for layout node creation
    gas_meter.charge_layout_node_creation()?;

    if depth > self.vm_config().layout_max_depth {
        return Err(
            PartialVMError::new(StatusCode::VM_MAX_VALUE_DEPTH_REACHED).with_message(format!(
                "Depth of a layout exceeded the maximum of {} during construction",
                self.vm_config().layout_max_depth
            )),
        );
    }
    Ok(())
}
```

2. **Add gas parameter for type substitution**: Charge additional gas when applying type substitutions in `apply_subst_for_field_tys`.

3. **Ensure cache hits charge appropriately**: The current cache implementation already re-charges for modules, but should also charge for the layout node access.

4. **Update gas schedule**: Add appropriate gas costs that reflect the CPU work of layout construction (suggested: 50-100 internal gas units per node).

This ensures gas charges are proportional to the actual computational work performed, restoring the gas metering invariant.

## Proof of Concept

```move
module 0x1::gas_bypass_attack {
    use std::event;
    
    // Struct with maximum allowed fields (limited by layout_max_size)
    struct LargeStruct has copy, drop, store {
        f1: u64, f2: u64, f3: u64, f4: u64, f5: u64,
        f6: u64, f7: u64, f8: u64, f9: u64, f10: u64,
        f11: u64, f12: u64, f13: u64, f14: u64, f15: u64,
        // ... continue up to 500+ fields to approach the 512 node limit
        f500: u64,
    }
    
    struct AttackEvent has drop, store {
        data: LargeStruct,
    }
    
    public entry fun exploit_gas_bypass(account: &signer) {
        // Create an instance with all fields
        let large = LargeStruct {
            f1: 1, f2: 2, f3: 3, f4: 4, f5: 5,
            f6: 6, f7: 7, f8: 8, f9: 9, f10: 10,
            // ... initialize all fields
            f500: 500,
        };
        
        // Emit event - this triggers type layout construction
        // Gas charged: ~100K-200K for module load
        // Work performed: 500+ layout node creations and traversals
        event::emit(AttackEvent { data: large });
        
        // Can repeat this multiple times in the same transaction
        // Each emit only pays for the event emission, not the repeated
        // layout construction work (which is cached but still requires
        // traversal of cached modules)
    }
}
```

**Exploitation steps:**
1. Deploy the module with `LargeStruct` containing 500+ fields
2. Call `exploit_gas_bypass` entry function
3. Observe that transaction gas cost is disproportionately low compared to validator CPU usage during layout construction
4. Spam such transactions to degrade validator performance

The attack can be verified by comparing gas consumed vs CPU profiling metrics on validator nodes during layout construction for large vs small structs.

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/ty_layout_converter.rs (L197-222)
```rust
    fn check_depth_and_increment_count(
        &self,
        node_count: &mut u64,
        depth: u64,
    ) -> PartialVMResult<()> {
        let max_count = self.vm_config().layout_max_size;
        if *node_count > max_count || *node_count == max_count && self.is_lazy_loading_enabled() {
            return Err(
                PartialVMError::new(StatusCode::TOO_MANY_TYPE_NODES).with_message(format!(
                    "Number of type nodes when constructing type layout exceeded the maximum of {}",
                    max_count
                )),
            );
        }
        *node_count += 1;

        if depth > self.vm_config().layout_max_depth {
            return Err(
                PartialVMError::new(StatusCode::VM_MAX_VALUE_DEPTH_REACHED).with_message(format!(
                    "Depth of a layout exceeded the maximum of {} during construction",
                    self.vm_config().layout_max_depth
                )),
            );
        }
        Ok(())
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_layout_converter.rs (L254-325)
```rust
    fn type_to_type_layout_impl<const ANNOTATED: bool>(
        &self,
        gas_meter: &mut impl DependencyGasMeter,
        traversal_context: &mut TraversalContext,
        modules: &mut DefiningModules,
        ty: &Type,
        count: &mut u64,
        depth: u64,
        check_option_type: bool,
    ) -> PartialVMResult<(MoveTypeLayout, bool)> {
        self.check_depth_and_increment_count(count, depth)?;

        Ok(match ty {
            Type::Bool => (MoveTypeLayout::Bool, false),
            Type::U8 => (MoveTypeLayout::U8, false),
            Type::U16 => (MoveTypeLayout::U16, false),
            Type::U32 => (MoveTypeLayout::U32, false),
            Type::U64 => (MoveTypeLayout::U64, false),
            Type::U128 => (MoveTypeLayout::U128, false),
            Type::U256 => (MoveTypeLayout::U256, false),
            Type::I8 => (MoveTypeLayout::I8, false),
            Type::I16 => (MoveTypeLayout::I16, false),
            Type::I32 => (MoveTypeLayout::I32, false),
            Type::I64 => (MoveTypeLayout::I64, false),
            Type::I128 => (MoveTypeLayout::I128, false),
            Type::I256 => (MoveTypeLayout::I256, false),
            Type::Address => (MoveTypeLayout::Address, false),
            Type::Signer => (MoveTypeLayout::Signer, false),
            Type::Function { .. } => (MoveTypeLayout::Function, false),
            Type::Vector(ty) => self
                .type_to_type_layout_impl::<ANNOTATED>(
                    gas_meter,
                    traversal_context,
                    modules,
                    ty,
                    count,
                    depth + 1,
                    check_option_type,
                )
                .map(|(elem_layout, contains_delayed_fields)| {
                    let vec_layout = MoveTypeLayout::Vector(Box::new(elem_layout));
                    (vec_layout, contains_delayed_fields)
                })?,
            Type::Struct { idx, .. } => self.struct_to_type_layout::<ANNOTATED>(
                gas_meter,
                traversal_context,
                modules,
                idx,
                &[],
                count,
                depth + 1,
                check_option_type,
            )?,
            Type::StructInstantiation { idx, ty_args, .. } => self
                .struct_to_type_layout::<ANNOTATED>(
                    gas_meter,
                    traversal_context,
                    modules,
                    idx,
                    ty_args,
                    count,
                    depth + 1,
                    check_option_type,
                )?,
            Type::Reference(_) | Type::MutableReference(_) | Type::TyParam(_) => {
                return Err(
                    PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                        .with_message(format!("No type layout for {:?}", ty)),
                );
            },
        })
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_layout_converter.rs (L379-383)
```rust
        let struct_definition = self.struct_definition_loader.load_struct_definition(
            gas_meter,
            traversal_context,
            idx,
        )?;
```

**File:** third_party/move/move-vm/runtime/src/storage/loader/lazy.rs (L55-77)
```rust
    fn charge_module(
        &self,
        gas_meter: &mut impl DependencyGasMeter,
        traversal_context: &mut TraversalContext,
        module_id: &ModuleId,
    ) -> PartialVMResult<()> {
        if traversal_context.visit_if_not_special_module_id(module_id) {
            let addr = module_id.address();
            let name = module_id.name();

            let size = self
                .module_storage
                .unmetered_get_existing_module_size(addr, name)
                .map_err(|err| err.to_partial())?;
            gas_meter.charge_dependency(
                DependencyKind::Existing,
                addr,
                name,
                NumBytes::new(size as u64),
            )?;
        }
        Ok(())
    }
```

**File:** aptos-move/aptos-gas-meter/src/meter.rs (L57-76)
```rust
    fn charge_dependency(
        &mut self,
        _kind: DependencyKind,
        addr: &AccountAddress,
        _name: &IdentStr,
        size: NumBytes,
    ) -> PartialVMResult<()> {
        // Modules under special addresses are considered system modules that should always
        // be loaded, and are therefore excluded from gas charging.
        //
        // TODO: 0xA550C18 is a legacy system address we used, but it is currently not covered by
        //       `.is_special()`. We should double check if this address still needs special
        //       treatment.
        if self.feature_version() >= 15 && !addr.is_special() {
            self.algebra
                .charge_execution(DEPENDENCY_PER_MODULE + DEPENDENCY_PER_BYTE * size)?;
            self.algebra.count_dependency(size)?;
        }
        Ok(())
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L241-249)
```rust
            dependency_per_module: InternalGas,
            { RELEASE_V1_10.. => "dependency_per_module" },
            74460,
        ],
        [
            dependency_per_byte: InternalGasPerByte,
            { RELEASE_V1_10.. => "dependency_per_byte" },
            42,
        ],
```

**File:** third_party/move/move-vm/runtime/src/storage/layout_cache.rs (L30-56)
```rust
pub struct DefiningModules {
    modules: HashSet<ModuleId>,
    seen_modules: Vec<ModuleId>,
}

impl DefiningModules {
    /// Returns a new empty set of modules.
    pub fn new() -> Self {
        Self {
            modules: HashSet::new(),
            seen_modules: vec![],
        }
    }

    /// If module is not in the set, adds it.
    pub fn insert(&mut self, module_id: &ModuleId) {
        if !self.modules.contains(module_id) {
            self.modules.insert(module_id.clone());
            // Preserve the visited order: later traversal over the module set is deterministic.
            self.seen_modules.push(module_id.clone())
        }
    }

    /// Returns an iterator over modules in their insertion order.
    pub fn iter(&self) -> impl Iterator<Item = &ModuleId> {
        self.seen_modules.iter()
    }
```
