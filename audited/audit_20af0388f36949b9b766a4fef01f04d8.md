# Audit Report

## Title
Byzantine Validators Can Hide Malicious Timeout Behavior Through TwoChainTimeoutCertificate Reason Masking

## Summary
The `process_certificates()` function defaults to `RoundTimeoutReason::Unknown` when processing timeout certificates received via `sync_info` without local timeout votes. This masks genuine Byzantine timeout behavior (specifically `PayloadUnavailable` attacks) from the `ExponentialWindowFailureTracker`, preventing malicious validators from being excluded from future Optimistic Quorum Store (OptQS) proposals and compromising network liveness.

## Finding Description

When a validator advances to a new round via a timeout certificate (TC), the system attempts to determine the timeout reason to track malicious behavior. The vulnerability exists in the interaction between three components:

**1. Missing Timeout Reason in TwoChainTimeoutCertificate**

The `TwoChainTimeoutCertificate` structure does not store the aggregated timeout reason: [1](#0-0) 

Individual timeout votes contain reasons, but they are lost during aggregation: [2](#0-1) 

**2. Default to Unknown When No Local Votes Exist**

In `process_certificates()`, when a node receives a TC via `sync_info` but didn't participate in local timeout voting, the timeout reason defaults to `Unknown`: [3](#0-2) 

This occurs because `prev_round_timeout_votes` is `None` when the node didn't collect local timeout votes, causing `prev_round_timeout_reason` to be `None` after the `unzip()` operation.

**3. ExponentialWindowFailureTracker Treats Unknown as Success**

The failure tracker only considers `PayloadUnavailable` as a failure, treating all other reasons (including `Unknown`) as success: [4](#0-3) 

Byzantine validators causing `PayloadUnavailable` timeouts are only excluded when the reason is properly identified: [5](#0-4) 

**Attack Scenario:**

1. Byzantine validator V withholds payload data during a round, causing legitimate timeout with reason `PayloadUnavailable{missing_authors: [V]}`
2. Validators H1, H2, H3 that participated timeout locally with this reason and form a TC with 2f+1 votes
3. The TC propagates via `sync_info` to validator H4, who was temporarily lagging or disconnected
4. H4 receives the TC but has no `prev_round_timeout_votes` (didn't participate locally)
5. H4's `process_certificates()` defaults to `RoundTimeoutReason::Unknown` at line 274
6. H4's `ExponentialWindowFailureTracker` treats this as success, not identifying V as malicious
7. H4 continues including V in OptQS proposals via `get_params()`
8. V can repeat the attack against H4's proposals, causing liveness degradation [6](#0-5) 

The timeout reason is also used for metrics tracking in the round manager: [7](#0-6) 

When masked as `Unknown`, malicious validators are not tracked in the `AGGREGATED_ROUND_TIMEOUT_REASON_MISSING_AUTHORS` metric.

## Impact Explanation

**Severity: Medium**

This vulnerability enables Byzantine validators to conduct persistent liveness attacks while evading detection and mitigation mechanisms:

1. **Liveness Degradation**: Byzantine validators can repeatedly cause `PayloadUnavailable` timeouts without being excluded from proposals by validators that receive TCs via sync (not local timeout participation)

2. **Monitoring Blind Spots**: Network operators cannot identify malicious timeout patterns since the reason is masked as `Unknown` in logs and metrics, preventing incident response

3. **State Inconsistency**: Different validators maintain inconsistent views of which peers are malicious, with some excluding Byzantine validators (those with local timeout votes) while others continue including them (those receiving TCs via sync)

4. **OptQS Attack Surface**: The Optimistic Quorum Store mechanism is designed to exclude unreliable validators, but this vulnerability allows Byzantine actors to bypass this protection

The impact aligns with **Medium Severity** per Aptos bug bounty criteria: "State inconsistencies requiring intervention" and degraded network performance requiring manual intervention to identify and exclude malicious validators.

## Likelihood Explanation

**Likelihood: High**

This vulnerability will occur naturally in normal network operation:

1. **Common Scenario**: Validators frequently receive TCs via `sync_info` when catching up from temporary disconnections, network delays, or when joining mid-epoch
2. **No Special Privileges Required**: Byzantine validators need only withhold payload data, a basic attack requiring no special access
3. **Automatic Triggering**: The default behavior automatically masks the timeout reason whenever a TC is received without local timeout participation
4. **Persistent Effect**: Once a validator receives a masked TC, it will continue including malicious validators in proposals indefinitely until manually intervened

## Recommendation

**Solution 1: Store Aggregated Timeout Reason in TwoChainTimeoutCertificate**

Extend `TwoChainTimeoutCertificate` to include the aggregated timeout reason computed during certificate formation:

```rust
#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq)]
pub struct TwoChainTimeoutCertificate {
    timeout: TwoChainTimeout,
    signatures_with_rounds: AggregateSignatureWithRounds,
    aggregated_reason: RoundTimeoutReason,  // Add this field
}
```

Modify the aggregation logic to include the reason: [8](#0-7) 

Update certificate creation to store the aggregated reason: [9](#0-8) 

Then in `process_certificates()`, extract the reason from the TC if available:

```rust
let prev_round_timeout_reason = prev_round_timeout_reason
    .or_else(|| {
        sync_info.highest_2chain_timeout_cert()
            .map(|tc| tc.aggregated_reason().clone())
    })
    .unwrap_or(RoundTimeoutReason::Unknown);
```

**Solution 2: Conservative Fallback**

If modifying the certificate structure is not feasible, use a conservative approach when the reason is unknown for timeout-triggered rounds:

```rust
let prev_round_timeout_reason = prev_round_timeout_reason.unwrap_or_else(|| {
    // If we moved to new round via timeout but don't have local timeout votes,
    // treat as potential payload unavailability to be conservative
    if sync_info.highest_certified_round() + 1 != new_round {
        RoundTimeoutReason::PayloadUnavailable {
            missing_authors: BitVec::with_num_bits(verifier.len() as u16)
        }
    } else {
        RoundTimeoutReason::Unknown
    }
});
```

**Recommendation**: Implement Solution 1 as it preserves the actual timeout reason and enables proper monitoring and Byzantine detection.

## Proof of Concept

```rust
#[test]
fn test_timeout_reason_masking_attack() {
    use aptos_consensus_types::{
        round_timeout::{RoundTimeout, RoundTimeoutReason},
        sync_info::SyncInfo,
        timeout_2chain::TwoChainTimeout,
    };
    use aptos_types::validator_verifier::random_validator_verifier;
    use aptos_bitvec::BitVec;
    
    // Setup: 4 validators, validator[3] is Byzantine
    let (signers, validator_verifier) = random_validator_verifier(4, None, false);
    let byzantine_idx = 3;
    
    // Step 1: Byzantine validator withholds payload, causing timeout
    let mut missing_authors = BitVec::with_num_bits(4);
    missing_authors.set(byzantine_idx as u16);
    let malicious_reason = RoundTimeoutReason::PayloadUnavailable { missing_authors };
    
    // Step 2: Honest validators H1, H2, H3 form TC with correct reason
    let mut pending_votes = PendingVotes::new();
    let timeout = TwoChainTimeout::new(1, 5, certificate_for_genesis());
    
    for i in 0..3 {
        let round_timeout = RoundTimeout::new(
            timeout.clone(),
            signers[i].author(),
            malicious_reason.clone(),
            timeout.sign(&signers[i]).unwrap()
        );
        pending_votes.insert_round_timeout(&round_timeout, &validator_verifier);
    }
    
    // Step 3: Form TC and propagate via sync_info
    let (_, timeout_votes) = pending_votes.drain_votes();
    let (partial_tc, aggregated_reason) = timeout_votes.unwrap().unpack_aggregate(&validator_verifier);
    let tc = partial_tc.aggregate_signatures(&validator_verifier).unwrap();
    
    // Verify aggregated reason correctly identifies Byzantine validator
    assert!(matches!(aggregated_reason, RoundTimeoutReason::PayloadUnavailable { .. }));
    
    // Step 4: Validator H4 receives TC via sync_info WITHOUT local timeout votes
    let sync_info = SyncInfo::new(
        QuorumCert::new(...),
        WrappedLedgerInfo::new(...),
        Some(tc)
    );
    
    let mut round_state = RoundState::new(...);
    let new_round_event = round_state.process_certificates(sync_info, &validator_verifier).unwrap();
    
    // VULNERABILITY: H4 records reason as Unknown, not PayloadUnavailable
    match new_round_event.reason {
        NewRoundReason::Timeout(reason) => {
            // This assertion fails - reason is Unknown instead of PayloadUnavailable
            assert!(matches!(reason, RoundTimeoutReason::PayloadUnavailable { .. }));
        },
        _ => panic!("Expected timeout reason"),
    }
    
    // IMPACT: Byzantine validator not excluded from H4's OptQS proposals
    // H4 will continue including the malicious validator in future proposals
}
```

## Notes

This vulnerability represents a critical gap in Byzantine fault detection. The design assumes validators always have local timeout votes when processing timeout-triggered rounds, but this assumption breaks in normal network operation when validators catch up via sync. The missing timeout reason in `TwoChainTimeoutCertificate` is the root cause, and fixing it requires either extending the certificate structure or implementing conservative fallback logic.

### Citations

**File:** consensus/consensus-types/src/timeout_2chain.rs (L108-112)
```rust
#[derive(Debug, Clone, Serialize, Deserialize, Eq, PartialEq)]
pub struct TwoChainTimeoutCertificate {
    timeout: TwoChainTimeout,
    signatures_with_rounds: AggregateSignatureWithRounds,
}
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L265-282)
```rust
    /// Aggregates the partial signature into `TwoChainTimeoutCertificate`. This is done when we
    /// have quorum voting power in the partial signature.
    pub fn aggregate_signatures(
        &self,
        verifier: &ValidatorVerifier,
    ) -> Result<TwoChainTimeoutCertificate, VerifyError> {
        let (partial_sig, ordered_rounds) = self
            .signatures
            .get_partial_sig_with_rounds(verifier.address_to_validator_index());
        let aggregated_sig = verifier.aggregate_signatures(partial_sig.signatures_iter())?;
        Ok(TwoChainTimeoutCertificate {
            timeout: self.timeout.clone(),
            signatures_with_rounds: AggregateSignatureWithRounds::new(
                aggregated_sig,
                ordered_rounds,
            ),
        })
    }
```

**File:** consensus/src/pending_votes.rs (L65-76)
```rust
pub(super) struct TwoChainTimeoutVotes {
    timeout_reason: HashMap<Author, RoundTimeoutReason>,
    partial_2chain_tc: TwoChainTimeoutWithPartialSignatures,
}

impl TwoChainTimeoutVotes {
    pub(super) fn new(timeout: TwoChainTimeout) -> Self {
        Self {
            partial_2chain_tc: TwoChainTimeoutWithPartialSignatures::new(timeout.clone()),
            timeout_reason: HashMap::new(),
        }
    }
```

**File:** consensus/src/pending_votes.rs (L155-161)
```rust
    pub(crate) fn unpack_aggregate(
        self,
        verifier: &ValidatorVerifier,
    ) -> (TwoChainTimeoutWithPartialSignatures, RoundTimeoutReason) {
        let aggregated_reason = self.aggregated_timeout_reason(verifier);
        (self.partial_2chain_tc, aggregated_reason)
    }
```

**File:** consensus/src/liveness/round_state.rs (L264-276)
```rust
            let (prev_round_timeout_votes, prev_round_timeout_reason) = prev_round_timeout_votes
                .map(|votes| votes.unpack_aggregate(verifier))
                .unzip();

            // The new round reason is QCReady in case both QC.round + 1 == new_round, otherwise
            // it's Timeout and TC.round + 1 == new_round.
            let new_round_reason = if sync_info.highest_certified_round() + 1 == new_round {
                NewRoundReason::QCReady
            } else {
                let prev_round_timeout_reason =
                    prev_round_timeout_reason.unwrap_or(RoundTimeoutReason::Unknown);
                NewRoundReason::Timeout(prev_round_timeout_reason)
            };
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L66-77)
```rust
        self.last_consecutive_success_count = self.last_consecutive_statuses_matching(|reason| {
            !matches!(
                reason,
                NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable { .. })
            )
        });
        if self.last_consecutive_success_count == 0 {
            self.window *= 2;
            self.window = self.window.min(self.max_window);
        } else if self.last_consecutive_success_count == self.past_round_statuses.len() {
            self.window = 2;
        }
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L80-98)
```rust
    fn get_exclude_authors(&self) -> HashSet<Author> {
        let mut exclude_authors = HashSet::new();

        let limit = self.window;
        for round_reason in self.past_round_statuses.iter().rev().take(limit) {
            if let NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable {
                missing_authors,
            }) = round_reason
            {
                for author_idx in missing_authors.iter_ones() {
                    if let Some(author) = self.ordered_authors.get(author_idx) {
                        exclude_authors.insert(*author);
                    }
                }
            }
        }

        exclude_authors
    }
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L127-160)
```rust
impl TOptQSPullParamsProvider for OptQSPullParamsProvider {
    fn get_params(&self) -> Option<OptQSPayloadPullParams> {
        if !self.enable_opt_qs {
            return None;
        }

        let tracker = self.failure_tracker.lock();

        counters::OPTQS_LAST_CONSECUTIVE_SUCCESS_COUNT
            .observe(tracker.last_consecutive_success_count as f64);
        if tracker.last_consecutive_success_count < tracker.window {
            warn!(
                "Skipping OptQS: (last_consecutive_successes) {} < {} (window)",
                tracker.last_consecutive_success_count, tracker.window
            );
            return None;
        }

        let exclude_authors = tracker.get_exclude_authors();
        if !exclude_authors.is_empty() {
            let exclude_authors_str: Vec<_> =
                exclude_authors.iter().map(|a| a.short_str()).collect();
            for author in &exclude_authors_str {
                counters::OPTQS_EXCLUDE_AUTHORS_COUNT
                    .with_label_values(&[author.as_str()])
                    .inc();
            }
            warn!("OptQS exclude authors: {:?}", exclude_authors_str);
        }
        Some(OptQSPayloadPullParams {
            exclude_authors,
            minimum_batch_age_usecs: self.minimum_batch_age_usecs,
        })
    }
```

**File:** consensus/src/round_manager.rs (L438-459)
```rust
            NewRoundReason::Timeout(ref reason) => {
                counters::TIMEOUT_ROUNDS_COUNT.inc();
                counters::AGGREGATED_ROUND_TIMEOUT_REASON
                    .with_label_values(&[
                        &reason.to_string(),
                        prev_proposer.short_str().as_str(),
                        &is_current_proposer.to_string(),
                    ])
                    .inc();
                if is_current_proposer {
                    if let RoundTimeoutReason::PayloadUnavailable { missing_authors } = reason {
                        let ordered_peers =
                            self.epoch_state.verifier.get_ordered_account_addresses();
                        for idx in missing_authors.iter_ones() {
                            if let Some(author) = ordered_peers.get(idx) {
                                counters::AGGREGATED_ROUND_TIMEOUT_REASON_MISSING_AUTHORS
                                    .with_label_values(&[author.short_str().as_str()])
                                    .inc();
                            }
                        }
                    }
                }
```
