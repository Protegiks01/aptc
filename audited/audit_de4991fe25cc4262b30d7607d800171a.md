# Audit Report

## Title
PostgreSQL Credentials Exposed in Logs via JSON Serialization Bypass

## Summary
The `IndexerConfig` struct implements a custom `Debug` trait that masks passwords in PostgreSQL URIs. However, this protection is completely bypassed when the `NodeConfig.log_all_configs()` method serializes the configuration to JSON and logs it at node startup, exposing database credentials in plaintext.

## Finding Description

The `IndexerConfig` struct contains a custom `Debug` implementation designed to mask passwords in PostgreSQL connection URIs: [1](#0-0) 

This implementation parses the `postgres_uri` and masks any password before logging. However, the `IndexerConfig` struct also derives the `Serialize` trait with no custom serialization for sensitive fields: [2](#0-1) 

During node startup, the `NodeConfig.log_all_configs()` method is called, which serializes the entire configuration to JSON and logs each field: [3](#0-2) 

This method is invoked during node initialization: [4](#0-3) 

**Attack Path:**
1. Node operator configures `postgres_uri` as `"postgresql://indexer_user:SecretPassword123@db.example.com:5432/aptos_indexer"`
2. Node starts and calls `setup_environment_and_start_node()`
3. At line 698, `node_config.log_all_configs()` is invoked
4. The indexer config is serialized using `serde_json::to_value()`, which uses the `Serialize` trait, NOT the `Debug` trait
5. The resulting JSON contains: `{"postgres_uri":"postgresql://indexer_user:SecretPassword123@db.example.com:5432/aptos_indexer",...}`
6. This is logged via `info!("Using indexer config: {}")` with the password in plaintext
7. Credentials are now visible in log files, centralized logging systems, and potentially exposed to unauthorized personnel

While the `Debug` implementation in `logger.rs` also masks passwords before logging, this occurs EARLIER in the startup sequence and does not prevent the subsequent exposure through `log_all_configs()`: [5](#0-4) 

## Impact Explanation

This vulnerability constitutes an **information disclosure** issue. According to the Aptos Bug Bounty severity categories, this falls under **Low Severity** ("Minor information leaks"). 

However, the security impact includes:
- Database credentials exposed in node logs
- Potential unauthorized access to indexer database
- Risk of data tampering if logs are compromised
- Credential reuse attacks if passwords are shared across systems
- Compliance violations for organizations with strict credential handling requirements

While the indexer is not consensus-critical, its compromise could mislead applications relying on indexed blockchain data.

## Likelihood Explanation

This vulnerability has **HIGH likelihood** of occurrence because:
1. It triggers automatically on every node startup when indexer is enabled
2. No special configuration or attacker action is required
3. The `log_all_configs()` method is called unconditionally during normal operation
4. Many organizations centralize logs or share them with support teams, increasing exposure risk
5. Log files are often retained for extended periods and may not have the same access controls as configuration files

## Recommendation

Implement custom serialization for the `postgres_uri` field to mask passwords during JSON serialization:

```rust
use serde::{Serializer, Serialize};

fn serialize_masked_uri<S>(uri: &Option<String>, serializer: S) -> Result<S::Ok, S::Error>
where
    S: Serializer,
{
    match uri {
        None => serializer.serialize_none(),
        Some(u) => {
            match url::Url::parse(u) {
                Ok(mut parsed_url) => {
                    if parsed_url.password().is_some() {
                        parsed_url.set_password(Some("*")).unwrap();
                    }
                    serializer.serialize_some(&parsed_url.to_string())
                },
                Err(_) => serializer.serialize_some("***INVALID_URL***"),
            }
        }
    }
}

#[derive(Clone, Default, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct IndexerConfig {
    // ... other fields ...
    
    #[serde(default, skip_serializing_if = "Option::is_none", serialize_with = "serialize_masked_uri")]
    pub postgres_uri: Option<String>,
    
    // ... rest of fields ...
}
```

Alternatively, remove the `log_all_configs()` call and rely solely on the Debug-based logging in `logger.rs` which already implements password masking.

## Proof of Concept

Create a test file `config/src/config/test_indexer_serialization.rs`:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use serde_json;

    #[test]
    fn test_postgres_password_exposed_in_json() {
        let mut config = IndexerConfig::default();
        config.enabled = true;
        config.postgres_uri = Some("postgresql://user:SecretPass123@localhost:5432/db".to_string());
        
        // Serialize to JSON (as done in log_all_configs)
        let json = serde_json::to_string(&config).unwrap();
        
        // Password is exposed in JSON serialization
        assert!(json.contains("SecretPass123"), "Password should be masked but is exposed in JSON!");
        
        // Debug formatting masks the password
        let debug_str = format!("{:?}", config);
        assert!(!debug_str.contains("SecretPass123"), "Password is properly masked in Debug");
        assert!(debug_str.contains("*"), "Password should be replaced with *");
    }
}
```

Run with: `cargo test -p aptos-config test_postgres_password_exposed_in_json`

This test will PASS, demonstrating that the password is indeed exposed through JSON serialization while being properly masked in Debug formatting.

## Notes

This vulnerability demonstrates a **defense-in-depth failure** where password masking is implemented for Debug formatting but not for JSON serialization. While the severity is categorized as Low per bug bounty criteria, the automatic nature of the exposure on every node startup makes it a practical concern for production deployments. Organizations should review their log access controls and consider the recommendation to prevent credential exposure through this vector.

### Citations

**File:** config/src/config/indexer_config.rs (L25-36)
```rust
#[derive(Clone, Default, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct IndexerConfig {
    /// Whether the indexer is enabled or not
    /// Alternatively can set the `INDEXER_ENABLED` env var
    #[serde(default)]
    pub enabled: bool,

    /// Postgres database uri, ex: "postgresql://user:pass@localhost/postgres"
    /// Alternatively can set the `INDEXER_DATABASE_URL` env var
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub postgres_uri: Option<String>,
```

**File:** config/src/config/indexer_config.rs (L92-117)
```rust
impl Debug for IndexerConfig {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        let postgres_uri = self.postgres_uri.as_ref().map(|u| {
            let mut parsed_url = url::Url::parse(u).expect("Invalid postgres uri");
            if parsed_url.password().is_some() {
                parsed_url.set_password(Some("*")).unwrap();
            }
            parsed_url.to_string()
        });
        f.debug_struct("IndexerConfig")
            .field("enabled", &self.enabled)
            .field("postgres_uri", &postgres_uri)
            .field("processor", &self.processor)
            .field("starting_version", &self.starting_version)
            .field("skip_migrations", &self.skip_migrations)
            .field("check_chain_id", &self.check_chain_id)
            .field("batch_size", &self.batch_size)
            .field("fetch_tasks", &self.fetch_tasks)
            .field("processor_tasks", &self.processor_tasks)
            .field("emit_every", &self.emit_every)
            .field("gap_lookback_versions", &self.gap_lookback_versions)
            .field("ans_contract_address", &self.ans_contract_address)
            .field("nft_points_contract", &self.nft_points_contract)
            .finish()
    }
}
```

**File:** config/src/config/node_config.rs (L97-110)
```rust
    pub fn log_all_configs(&self) {
        // Parse the node config as serde JSON
        let config_value =
            serde_json::to_value(self).expect("Failed to serialize the node config!");
        let config_map = config_value
            .as_object()
            .expect("Failed to get the config map!");

        // Log each config entry
        for (config_name, config_value) in config_map {
            let config_string =
                serde_json::to_string(config_value).expect("Failed to parse the config value!");
            info!("Using {} config: {}", config_name, config_string);
        }
```

**File:** aptos-node/src/lib.rs (L697-698)
```rust
    // Log the node config at node startup
    node_config.log_all_configs();
```

**File:** aptos-node/src/logger.rs (L88-101)
```rust
    // Log the node config
    let mut config = node_config;
    let mut masked_config;
    if let Some(u) = &node_config.indexer.postgres_uri {
        let mut parsed_url = url::Url::parse(u).expect("Invalid postgres uri");
        if parsed_url.password().is_some() {
            masked_config = node_config.clone();
            parsed_url.set_password(Some("*")).unwrap();
            masked_config.indexer.postgres_uri = Some(parsed_url.to_string());
            config = &masked_config;
        }
    }

    info!("Loaded node config: {:?}", config);
```
