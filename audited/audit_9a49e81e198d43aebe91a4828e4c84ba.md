# Audit Report

## Title
Missing Final State Root Verification Against Trusted Checkpoint in Replay-Verify Process

## Summary
After snapshot restoration and transaction replay in `ReplayVerifyCoordinator`, the final state root is not compared against any trusted checkpoint (waypoint). The system only validates internal consistency of the backup data but accepts incorrect state if the backup itself is compromised or corrupted, despite accepting `--trust-waypoint` parameters.

## Finding Description

The `ReplayVerifyCoordinator` orchestrates backup verification by restoring a state snapshot and replaying transactions, but critically fails to verify the final state root against any trusted external checkpoint.

**The Security Guarantee Broken:**
The system should verify that restored state matches a trusted checkpoint to detect compromised or corrupted backups. Users can provide trusted waypoints via `--trust-waypoint` flags, creating the expectation of external verification.

**How the Attack Propagates:**

1. Attacker provides a compromised backup containing:
   - State snapshot at version V with incorrect state root
   - Transaction backups with matching (but incorrect) `TransactionInfo` records

2. `ReplayVerifyCoordinator::run_impl()` restores the snapshot and replays transactions: [1](#0-0) 

3. During replay, `ReplayChunkVerifier` is used, which only validates internal consistency: [2](#0-1) 

4. `ReplayChunkVerifier::maybe_select_chunk_ending_ledger_info()` returns `Ok(None)` without any external verification: [3](#0-2) 

5. After replay completes, only execution errors are checked, not state root validity: [4](#0-3) 

6. The `trusted_waypoints` parameter is accepted but explicitly NOT used for transaction restore verification: [5](#0-4) 

**Contrast with State Sync:**
`StateSyncChunkVerifier` properly verifies against a trusted ledger info, checking the transaction accumulator hash at the target version: [6](#0-5) 

The replay path lacks equivalent verification.

## Impact Explanation

**Critical Severity** - This vulnerability breaks the fundamental "State Consistency" invariant. An attacker who compromises the backup storage can:

1. **Inject Incorrect State**: Nodes restoring from backup accept completely fabricated blockchain state
2. **Break Consensus Safety**: Restored nodes diverge from the canonical chain with no detection
3. **Enable State Manipulation Attacks**: Arbitrary account balances, governance state, or validator sets could be modified

This meets **Critical Severity** criteria:
- Consensus/Safety violations (nodes accept divergent state)
- State inconsistencies that could require hardfork to recover
- Complete bypass of state verification mechanisms

All nodes using backup restoration are affected. The issue is particularly severe because users providing `--trust-waypoint` flags expect verification but receive none.

## Likelihood Explanation

**Medium-to-High Likelihood:**

**Attack Requirements:**
- Attacker must compromise or control the backup storage source
- Backup data must be internally consistent (matching TransactionInfo hashes)

**Feasibility:**
- Backup storage is often external (cloud storage, S3, etc.) with separate security boundaries
- Many organizations use third-party backup services
- Insider threats (compromised backup operators) can trivially exploit this
- No cryptographic verification protects backup integrity

**Real-World Scenarios:**
1. Compromised cloud storage credentials
2. Malicious backup service provider
3. Man-in-the-middle during backup download
4. Insider attack by backup infrastructure operator

The likelihood increases because users explicitly provide `--trust-waypoint` expecting verification, creating a false sense of security.

## Recommendation

**Add Final State Root Verification:**

After transaction replay completes in `ReplayVerifyCoordinator::run_impl()`, verify the final state root against a trusted waypoint at the target version:

```rust
// After line 205 in replay_verify.rs, before checking seen_error()
if let Some(waypoint) = self.trusted_waypoints_opt.trust_waypoint
    .iter()
    .find(|w| w.version() == self.end_version) 
{
    let final_state_root = restore_handler
        .get_state_checkpoint_hash_at_version(self.end_version)?;
    
    ensure!(
        Some(final_state_root) == waypoint.state_root_hash(),
        "Final state root {:?} does not match trusted waypoint {:?} at version {}",
        final_state_root,
        waypoint,
        self.end_version
    );
    
    info!(
        version = self.end_version,
        state_root = %final_state_root,
        "Verified final state root against trusted waypoint"
    );
}
```

**Alternative Approach:**
Require a verified target `LedgerInfo` at `end_version` and use `StateSyncChunkVerifier` instead of `ReplayChunkVerifier` for the final chunk, ensuring transaction accumulator verification: [7](#0-6) 

## Proof of Concept

**Reproduction Steps:**

1. **Setup Compromised Backup:**
```bash
# Create a legitimate backup
aptos-db-tool backup oneshot --backup-service-address http://backup-storage

# Modify the state snapshot to inject incorrect state
# (e.g., change account balances in the state KV backup)

# Keep TransactionInfo records consistent with the modified state
```

2. **Attempt Replay-Verify with Waypoint:**
```bash
aptos-db-tool replay-verify \
    --target-db-dir /tmp/restored \
    --metadata-cache-dir /tmp/cache \
    --start-version 0 \
    --end-version 1000000 \
    --trust-waypoint "0:2b8a...f4e" \  # Correct waypoint at version 1000000
    --concurrent-downloads 4
```

3. **Observe Silent Acceptance:**
The tool will complete successfully with "ReplayVerify coordinator exiting with success" despite the state root not matching the trusted waypoint. No verification error is raised.

4. **Verify State Divergence:**
```bash
# Check the restored state differs from canonical chain
aptos-db-tool print-db --db-path /tmp/restored | grep "state_root"
# Compare against known good state root at version 1000000
```

The restored database will contain incorrect state that passed all internal consistency checks but diverges from the trusted checkpoint, demonstrating the vulnerability.

**Expected Behavior:**
The replay-verify should fail with an error: "Final state root does not match trusted waypoint at version 1000000"

**Actual Behavior:**
The replay-verify completes successfully, silently accepting the incorrect state.

### Citations

**File:** storage/backup/backup-cli/src/coordinators/replay_verify.rs (L173-205)
```rust
        if !skip_snapshot {
            if let Some(backup) = state_snapshot {
                StateSnapshotRestoreController::new(
                    StateSnapshotRestoreOpt {
                        manifest_handle: backup.manifest,
                        version: backup.version,
                        validate_modules: self.validate_modules,
                        restore_mode: Default::default(),
                    },
                    global_opt.clone(),
                    Arc::clone(&self.storage),
                    None, /* epoch_history */
                )
                .run()
                .await?;
            }
        }

        TransactionRestoreBatchController::new(
            global_opt,
            self.storage,
            transactions
                .into_iter()
                .map(|t| t.manifest)
                .collect::<Vec<_>>(),
            save_start_version,
            Some((next_txn_version, false)), /* replay_from_version */
            None,                            /* epoch_history */
            self.verify_execution_mode.clone(),
            None,
        )
        .run()
        .await?;
```

**File:** storage/backup/backup-cli/src/coordinators/replay_verify.rs (L207-211)
```rust
        if self.verify_execution_mode.seen_error() {
            Err(ReplayError::TxnMismatch)
        } else {
            Ok(())
        }
```

**File:** execution/executor/src/chunk_executor/mod.rs (L696-699)
```rust
        let chunk_verifier = Arc::new(ReplayChunkVerifier {
            transaction_infos: txn_infos,
        });
        self.enqueue_chunk(chunk, chunk_verifier, "replay")?;
```

**File:** execution/executor/src/chunk_executor/chunk_result_verifier.rs (L72-88)
```rust
    fn maybe_select_chunk_ending_ledger_info(
        &self,
        ledger_update_output: &LedgerUpdateOutput,
        next_epoch_state: Option<&EpochState>,
    ) -> Result<Option<LedgerInfoWithSignatures>> {
        let li = self.verified_target_li.ledger_info();
        let txn_accumulator = &ledger_update_output.transaction_accumulator;

        if li.version() + 1 == txn_accumulator.num_leaves() {
            // If the chunk corresponds to the target LI, the target LI can be added to storage.
            ensure!(
                li.transaction_accumulator_hash() == txn_accumulator.root_hash(),
                "Root hash in target ledger info does not match local computation. {:?} != {:?}",
                li,
                txn_accumulator,
            );
            Ok(Some(self.verified_target_li.clone()))
```

**File:** execution/executor/src/chunk_executor/chunk_result_verifier.rs (L146-152)
```rust
    fn maybe_select_chunk_ending_ledger_info(
        &self,
        _ledger_update_output: &LedgerUpdateOutput,
        _next_epoch_state: Option<&EpochState>,
    ) -> Result<Option<LedgerInfoWithSignatures>> {
        Ok(None)
    }
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L331-346)
```rust
#[derive(Clone, Default, Parser)]
pub struct TrustedWaypointOpt {
    #[clap(
        long,
        help = "(multiple) When provided, an epoch ending LedgerInfo at the waypoint version will be \
        checked against the hash in the waypoint, but signatures on it are NOT checked. \
        Use this for two purposes: \
        1. set the genesis or the latest waypoint to confirm the backup is compatible. \
        2. set waypoints at versions where writeset transactions were used to overwrite the \
        validator set, so that the signature check is skipped. \
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
    )]
    pub trust_waypoint: Vec<Waypoint>,
}
```
