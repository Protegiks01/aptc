# Audit Report

## Title
Indexer Data Loss: Batch Voting from Multiple Stake Pools Silently Drops Vote Records

## Summary
The `insert_proposal_votes()` function in the indexer uses an incorrect primary key for conflict resolution, causing vote records from multiple stake pools by the same voter in a single transaction to be silently dropped. Only the first vote is recorded while subsequent votes from different stake pools are lost due to the `do_nothing()` conflict handler. [1](#0-0) 

## Finding Description

The indexer's `proposal_votes` table uses a composite primary key of `(transaction_version, proposal_id, voter_address)`, but critically excludes `staking_pool_address`. [2](#0-1) 

The on-chain governance allows a single voter to control multiple stake pools and vote on the same proposal from each pool in a single transaction using `batch_vote()` or `batch_partial_vote()`. [3](#0-2) 

When such a transaction executes, multiple `VoteEvent`s are emitted - one per stake pool. [4](#0-3) 

The indexer processes each event and creates a `ProposalVote` record. [5](#0-4) 

However, when inserting these records, the conflict resolution only checks `(transaction_version, proposal_id, voter_address)`. Since all votes from the same voter in the same transaction share these values, the second and subsequent votes trigger the conflict handler's `do_nothing()`, silently dropping legitimate vote data.

**Attack Scenario:**
1. Voter Alice controls stake pools PoolA (1000 voting power) and PoolB (500 voting power)
2. Alice calls `batch_vote([PoolA, PoolB], proposal_id=1, should_pass=true)` in transaction T
3. On-chain: Both votes are correctly processed and recorded in `VotingRecordsV2`
4. Two `VoteEvent`s are emitted with different `stake_pool` addresses but same `voter`, `proposal_id`, and `transaction_version`
5. Indexer inserts first event (PoolA) successfully
6. Indexer attempts to insert second event (PoolB), detects primary key conflict, executes `do_nothing()`
7. Result: PoolB's 500 voting power is lost from indexer database

## Impact Explanation

**Severity: Medium** per Aptos bug bounty criteria - "State inconsistencies requiring intervention"

This vulnerability causes data integrity violations in the indexer:
- Governance vote tallies shown via indexer API are incorrect
- UIs/applications querying the indexer display incomplete voting information
- Governance participants may be misled about proposal voting status
- Historical voting records are permanently incomplete

While the on-chain state remains correct (the blockchain accurately records both votes), the indexer serves as the primary query interface for governance data. Applications relying on this data will show incorrect information, potentially affecting governance decisions.

This does NOT affect consensus, blockchain state, or on-chain governance execution, which limits the severity to Medium rather than Critical or High.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability triggers whenever:
1. A voter controls multiple stake pools (common - validators often manage multiple pools)
2. The voter uses `batch_vote()` or `batch_partial_vote()` (documented feature explicitly tested in the codebase) [6](#0-5) 
3. Multiple governance proposals exist

The Aptos governance design explicitly supports voters controlling multiple stake pools and provides batch voting functions for efficiency. [7](#0-6) 

Every time this legitimate use case occurs, data loss happens silently in the indexer.

## Recommendation

Modify the primary key to include `staking_pool_address`: [8](#0-7) 

Change the Diesel model annotation from:
```
#[diesel(primary_key(transaction_version, proposal_id, voter_address))]
```

To:
```
#[diesel(primary_key(transaction_version, proposal_id, voter_address, staking_pool_address))]
```

Update the conflict resolution accordingly:
```rust
.on_conflict((transaction_version, proposal_id, voter_address, staking_pool_address))
.do_nothing()
```

This ensures each vote from each stake pool is uniquely identified and recorded, preventing data loss while still handling genuine duplicate events within the same transaction.

## Proof of Concept

**Move Test Scenario:**

```move
#[test(aptos_framework = @aptos_framework, voter = @0x123, pool1_owner = @0x234, pool2_owner = @0x345)]
public entry fun test_indexer_data_loss_batch_vote(
    aptos_framework: signer,
    voter: signer,
    pool1_owner: signer,
    pool2_owner: signer,
) {
    // Setup: Create two stake pools with same delegated voter
    setup_governance(&aptos_framework);
    let voter_addr = signer::address_of(&voter);
    let pool1 = create_stake_pool(&pool1_owner, 1000);
    let pool2 = create_stake_pool(&pool2_owner, 500);
    
    stake::set_delegated_voter(&pool1_owner, voter_addr);
    stake::set_delegated_voter(&pool2_owner, voter_addr);
    
    // Create a governance proposal
    let proposal_id = create_test_proposal();
    
    // Execute batch vote - this emits TWO VoteEvents in one transaction
    aptos_governance::batch_vote(&voter, vector[pool1, pool2], proposal_id, true);
    
    // On-chain verification: Both votes recorded correctly
    assert!(aptos_governance::get_remaining_voting_power(pool1, proposal_id) == 0, 1);
    assert!(aptos_governance::get_remaining_voting_power(pool2, proposal_id) == 0, 2);
    
    // Indexer bug: Only first vote (pool1) would be in proposal_votes table
    // Second vote (pool2) silently dropped due to do_nothing() on primary key conflict
}
```

**Verification Steps:**
1. Deploy two stake pools with 1000 and 500 voting power respectively
2. Set both pools' delegated voter to the same address
3. Create a governance proposal
4. Call `batch_vote([pool1, pool2], proposal_id, true)`
5. Query on-chain state: Both pools show 0 remaining voting power (correct)
6. Query indexer database: Only one record in `proposal_votes` table (bug)
7. Expected: Two records with different `staking_pool_address` values
8. Actual: One record, second vote data lost

## Notes

The security question asks about "different transactions" but the actual vulnerability occurs within a **single transaction**. Votes in different transactions do not conflict because `transaction_version` is part of the primary key and differs between transactions.

The on-chain governance explicitly allows and supports voters voting multiple times on the same proposal (partial voting feature), so this is not an "error" to mask at the blockchain level. However, the indexer should accurately reflect all on-chain events, and the current implementation fails to do so when batch voting occurs.

### Citations

**File:** crates/indexer/src/processors/stake_processor.rs (L162-180)
```rust
fn insert_proposal_votes(
    conn: &mut PgConnection,
    item_to_insert: &[ProposalVote],
) -> Result<(), diesel::result::Error> {
    use schema::proposal_votes::dsl::*;

    let chunks = get_chunks(item_to_insert.len(), ProposalVote::field_count());
    for (start_ind, end_ind) in chunks {
        execute_with_better_error(
            conn,
            diesel::insert_into(schema::proposal_votes::table)
                .values(&item_to_insert[start_ind..end_ind])
                .on_conflict((transaction_version, proposal_id, voter_address))
                .do_nothing(),
            None,
        )?;
    }
    Ok(())
}
```

**File:** crates/indexer/src/schema.rs (L627-639)
```rust
    proposal_votes (transaction_version, proposal_id, voter_address) {
        transaction_version -> Int8,
        proposal_id -> Int8,
        #[max_length = 66]
        voter_address -> Varchar,
        #[max_length = 66]
        staking_pool_address -> Varchar,
        num_votes -> Numeric,
        should_pass -> Bool,
        transaction_timestamp -> Timestamp,
        inserted_at -> Timestamp,
    }
}
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L10-11)
```text
/// 2. Voters can vote on a proposal. Their voting power is derived from the backing stake pool. A stake pool can vote
/// on a proposal multiple times as long as the total voting power of these votes doesn't exceed its total voting power.
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L490-512)
```text
    public entry fun batch_vote(
        voter: &signer,
        stake_pools: vector<address>,
        proposal_id: u64,
        should_pass: bool,
    ) acquires ApprovedExecutionHashes, VotingRecords, VotingRecordsV2, GovernanceEvents {
        vector::for_each(stake_pools, |stake_pool| {
            vote_internal(voter, stake_pool, proposal_id, MAX_U64, should_pass);
        });
    }

    /// Batch vote on proposal with proposal_id and specified voting power from multiple stake_pools.
    public entry fun batch_partial_vote(
        voter: &signer,
        stake_pools: vector<address>,
        proposal_id: u64,
        voting_power: u64,
        should_pass: bool,
    ) acquires ApprovedExecutionHashes, VotingRecords, VotingRecordsV2, GovernanceEvents {
        vector::for_each(stake_pools, |stake_pool| {
            vote_internal(voter, stake_pool, proposal_id, voting_power, should_pass);
        });
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L576-598)
```text
        if (std::features::module_event_migration_enabled()) {
            event::emit(
                Vote {
                    proposal_id,
                    voter: voter_address,
                    stake_pool,
                    num_votes: voting_power,
                    should_pass,
                },
            );
        } else {
            let events = &mut GovernanceEvents[@aptos_framework];
            event::emit_event(
                &mut events.vote_events,
                VoteEvent {
                    proposal_id,
                    voter: voter_address,
                    stake_pool,
                    num_votes: voting_power,
                    should_pass,
                },
            );
        };
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L1126-1141)
```text
    public entry fun test_batch_vote(
        aptos_framework: signer,
        proposer: signer,
        voter_1: signer,
        voter_2: signer,
    ) acquires ApprovedExecutionHashes, GovernanceConfig, GovernanceResponsbility, VotingRecords, VotingRecordsV2, GovernanceEvents {
        features::change_feature_flags_for_testing(&aptos_framework, vector[features::get_coin_to_fungible_asset_migration_feature()], vector[]);
        setup_partial_voting(&aptos_framework, &proposer, &voter_1, &voter_2);
        let execution_hash = vector[1];
        let voter_1_addr = signer::address_of(&voter_1);
        let voter_2_addr = signer::address_of(&voter_2);
        stake::set_delegated_voter(&voter_2, voter_1_addr);
        create_proposal_for_test(&proposer, true);
        batch_vote(&voter_1, vector[voter_1_addr, voter_2_addr], 0, true);
        test_resolving_proposal_generic(aptos_framework, true, execution_hash);
    }
```

**File:** crates/indexer/src/models/stake_models/proposal_votes.rs (L17-28)
```rust
#[derive(Debug, Deserialize, FieldCount, Identifiable, Insertable, Serialize)]
#[diesel(primary_key(transaction_version, proposal_id, voter_address))]
#[diesel(table_name = proposal_votes)]
pub struct ProposalVote {
    pub transaction_version: i64,
    pub proposal_id: i64,
    pub voter_address: String,
    pub staking_pool_address: String,
    pub num_votes: BigDecimal,
    pub should_pass: bool,
    pub transaction_timestamp: chrono::NaiveDateTime,
}
```

**File:** crates/indexer/src/models/stake_models/proposal_votes.rs (L30-54)
```rust
impl ProposalVote {
    pub fn from_transaction(transaction: &APITransaction) -> anyhow::Result<Vec<Self>> {
        let mut proposal_votes = vec![];
        if let APITransaction::UserTransaction(user_txn) = transaction {
            for event in &user_txn.events {
                let txn_version = user_txn.info.version.0 as i64;
                let event_type = event.typ.to_string();
                if let Some(StakeEvent::GovernanceVoteEvent(ev)) =
                    StakeEvent::from_event(event_type.as_str(), &event.data, txn_version)?
                {
                    proposal_votes.push(Self {
                        transaction_version: txn_version,
                        proposal_id: ev.proposal_id as i64,
                        voter_address: standardize_address(&ev.voter),
                        staking_pool_address: standardize_address(&ev.stake_pool),
                        num_votes: ev.num_votes.clone(),
                        should_pass: ev.should_pass,
                        transaction_timestamp: parse_timestamp(user_txn.timestamp.0, txn_version),
                    });
                }
            }
        }
        Ok(proposal_votes)
    }
}
```
