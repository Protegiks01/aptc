# Audit Report

## Title
Governance-Controlled Gas Accounting Bypass via Unvalidated `gas_unit_scaling_factor` and Overflow Masking

## Summary
The `gas_unit_scaling_factor` parameter, which controls conversion between external and internal gas units, lacks validation when set through governance. Combined with overflow masking in `apply_ratio_round_down/up` (lines 258-262) and `saturating_mul` operations, a malicious governance proposal can set extreme scaling factors that break gas accounting, allowing transactions to consume orders of magnitude more computational resources than paid for. [1](#0-0) 

## Finding Description

The vulnerability chain consists of three components:

**1. Missing Validation in Governance**

The `gas_schedule.move` module allows governance to update gas parameters including `gas_unit_scaling_factor` with no value range validation: [2](#0-1) 

The code contains explicit TODO comments acknowledging this missing validation: [3](#0-2) 

**2. Overflow Masking in Unit Conversion**

When converting external Gas to internal InternalGas, `saturating_mul` caps at `u64::MAX`: [4](#0-3) 

When converting back from InternalGas to Gas, `apply_ratio_round_down` and `apply_ratio_round_up` cap at `u64::MAX`: [5](#0-4) [6](#0-5) 

**3. Gas Initialization and Reporting**

The gas meter initializes balance by converting external to internal gas: [7](#0-6) 

And reports remaining balance by converting back: [8](#0-7) 

**Attack Scenario:**

1. Attacker submits governance proposal to set `gas_unit_scaling_factor = 2^40` (approximately 1.1 trillion)
2. Normal value is 1,000,000, so this is 1 million times larger
3. User submits transaction with `max_gas_amount = 2,000,000` (maximum allowed)
4. Conversion to InternalGas: `2,000,000 * 2^40 ≈ 2.2 * 10^18`, which saturates to `u64::MAX`
5. Transaction executes with `u64::MAX` internal gas (essentially unlimited)
6. Normal allocation would be: `2,000,000 * 1,000,000 = 2 * 10^12` internal gas
7. User gets `9.2 * 10^6` times more gas than they should
8. When reporting gas used, the overflow is masked again, showing artificially low usage

The "double masking" (saturation on conversion in, capping on conversion out) hides the true overflow, breaking the invariant that gas charged must equal gas consumed.

## Impact Explanation

**Critical Severity** - This vulnerability enables:

1. **Resource Exhaustion**: Attackers can execute computationally expensive transactions at a fraction of the cost, enabling DoS attacks against the network

2. **Economic Attack**: Breaks the fundamental gas payment mechanism, allowing users to perform massive computations/storage operations while paying minimal fees

3. **Consensus Risk**: If the governance proposal is applied mid-epoch or inconsistently across validators, different nodes could have different gas accounting, leading to state divergence and consensus failures

4. **Deterministic Execution Violation**: Different validators processing the same transaction with different `gas_unit_scaling_factor` values would compute different gas consumption, violating the critical invariant that "all validators must produce identical state roots for identical blocks" [9](#0-8) [10](#0-9) 

## Likelihood Explanation

**Medium Likelihood:**

- **Attack Requirements**: Requires passing a malicious governance proposal, which needs convincing stakeholders or exploiting governance vulnerabilities
- **Detection Difficulty**: Extreme scaling factor values would be obvious, but moderately inflated values (e.g., 2-10x normal) could slip through without careful review
- **Existing Gap**: The TODO comments indicate developers are aware validation is missing, suggesting it's a known technical debt that hasn't been prioritized
- **Defense Gaps**: No runtime bounds checking, no alert systems for parameter changes, no formal verification of gas parameter constraints

## Recommendation

Implement strict validation for `gas_unit_scaling_factor` in the governance update path:

```rust
// In gas_schedule.move
public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    // ADD VALIDATION HERE
    validate_gas_schedule_consistency(&new_gas_schedule);
    
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    config_buffer::upsert(new_gas_schedule);
}

// New validation function
fun validate_gas_schedule_consistency(schedule: &GasScheduleV2) {
    // Validate gas_unit_scaling_factor is within safe bounds
    let scaling_factor = get_entry(schedule, "txn.gas_unit_scaling_factor");
    assert!(
        scaling_factor >= MIN_SCALING_FACTOR && scaling_factor <= MAX_SCALING_FACTOR,
        error::invalid_argument(EINVALID_GAS_SCHEDULE)
    );
    // Example: MIN_SCALING_FACTOR = 100_000, MAX_SCALING_FACTOR = 10_000_000
}
```

Additionally, add overflow detection instead of silent capping:

```rust
// In gas_algebra.rs apply_ratio_round_down
fn apply_ratio_round_down(val: u64, nominator: u64, denominator: u64) -> u64 {
    assert_ne!(nominator, 0);
    assert_ne!(denominator, 0);

    let res = val as u128 * nominator as u128 / denominator as u128;
    if res > u64::MAX as u128 {
        // FAIL instead of capping - this indicates a configuration error
        panic!("Gas unit conversion overflow - invalid scaling factor");
    } else {
        res as u64
    }
}
```

## Proof of Concept

```move
#[test_only]
module aptos_framework::gas_schedule_exploit_test {
    use aptos_framework::gas_schedule;
    use std::bcs;

    #[test(fx = @aptos_framework)]
    fun test_extreme_scaling_factor_attack(fx: signer) {
        // Create a gas schedule with extreme scaling_factor
        let malicious_schedule = gas_schedule::GasScheduleV2 {
            feature_version: 1,
            entries: vector[
                gas_schedule::GasEntry {
                    key: string::utf8(b"txn.gas_unit_scaling_factor"),
                    val: 1_099_511_627_776, // 2^40 - extreme value
                },
                // ... other entries
            ],
        };
        
        let blob = bcs::to_bytes(&malicious_schedule);
        
        // This should fail with validation, but currently passes
        gas_schedule::set_for_next_epoch(&fx, blob);
        
        // Now transactions with max_gas_amount will get saturated 
        // to u64::MAX internal gas units instead of the expected
        // max_gas_amount * 1_000_000
        
        // User pays for 2M gas but gets ~18.4 quintillion internal gas
    }
}
```

## Notes

The vulnerability exists at the intersection of:
1. Governance parameter update mechanisms (on-chain)
2. Gas algebra conversion logic (off-chain Rust)  
3. Gas meter initialization (VM runtime)

This creates a **governance → VM** attack vector where malicious on-chain parameters can break VM gas metering guarantees. The capping to `u64::MAX` in lines 258-262 does hide real overflow errors - specifically, it hides when the scaling factor causes impossible gas conversions, which should cause transaction rejection or at minimum, system alerts.

### Citations

**File:** third_party/move/move-core/types/src/gas_algebra.rs (L253-263)
```rust
fn apply_ratio_round_down(val: u64, nominator: u64, denominator: u64) -> u64 {
    assert_ne!(nominator, 0);
    assert_ne!(denominator, 0);

    let res = val as u128 * nominator as u128 / denominator as u128;
    if res > u64::MAX as u128 {
        u64::MAX
    } else {
        res as u64
    }
}
```

**File:** third_party/move/move-core/types/src/gas_algebra.rs (L266-279)
```rust
fn apply_ratio_round_up(val: u64, nominator: u64, denominator: u64) -> u64 {
    assert_ne!(nominator, 0);
    assert_ne!(denominator, 0);

    let n = val as u128 * nominator as u128;
    let d = denominator as u128;

    let res = n / d + if n.is_multiple_of(d) { 0 } else { 1 };
    if res > u64::MAX as u128 {
        u64::MAX
    } else {
        res as u64
    }
}
```

**File:** third_party/move/move-core/types/src/gas_algebra.rs (L389-396)
```rust
    pub fn to_unit_with_params<P, T>(self, params: &P) -> GasQuantity<T>
    where
        U: ToUnitWithParams<P, T>,
    {
        let multiplier = <U as ToUnitWithParams<P, T>>::multiplier(params);
        assert_ne!(multiplier, 0);
        GasQuantity::new(self.val.saturating_mul(multiplier))
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L47-48)
```text
        // TODO(Gas): check if gas schedule is consistent
        let gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/aptos-gas-meter/src/algebra.rs (L71-71)
```rust
        let balance = balance.into().to_unit_with_params(&vm_gas_params.txn);
```

**File:** aptos-move/aptos-gas-meter/src/traits.rs (L240-244)
```rust
    fn balance(&self) -> Gas {
        self.algebra()
            .balance_internal()
            .to_unit_round_down_with_params(&self.vm_gas_params().txn)
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L22-22)
```rust
const GAS_SCALING_FACTOR: u64 = 1_000_000;
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L313-317)
```rust
impl ToUnitWithParams<TransactionGasParameters, InternalGasUnit> for GasUnit {
    fn multiplier(params: &TransactionGasParameters) -> u64 {
        params.scaling_factor().into()
    }
}
```
