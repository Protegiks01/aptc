# Audit Report

## Title
Validator Node Crash via Unhandled Noise Protocol Handshake Errors in Telemetry Authentication

## Summary
The `authenticate()` function in the telemetry sender uses `unwrap()` on Noise protocol cryptographic handshake operations that can fail when receiving malformed messages. Combined with Aptos' global panic handler that terminates the process on any panic, this creates a denial-of-service vulnerability where malformed telemetry service responses crash validator nodes.

## Finding Description

The vulnerability exists in the telemetry authentication flow: [1](#0-0) [2](#0-1) 

The Noise protocol's `finalize_connection()` method can legitimately fail when processing the server's handshake response: [3](#0-2) 

Key failure scenarios include:
- **NoiseError::Decrypt** (line 392): AEAD decryption failure on malformed/tampered handshake
- **NoiseError::MsgTooShort** (line 372): Truncated handshake message
- **NoiseError::ReceivedMsgTooLarge** (line 357): Oversized message

The critical issue is that Aptos installs a global panic handler that terminates the entire process: [4](#0-3) 

When the `unwrap()` panics, this handler calls `process::exit(12)`, crashing the validator node. The telemetry service is enabled by default and runs every 15 seconds: [5](#0-4) [6](#0-5) 

**Attack Scenarios:**

1. **DNS Poisoning**: Redirect `telemetry.aptoslabs.com` to attacker-controlled server returning malformed handshakes
2. **BGP Hijacking**: Route telemetry traffic through attacker infrastructure
3. **Compromised Telemetry Service**: If the legitimate service is compromised or has a bug
4. **Network Partition**: If the telemetry service becomes unreachable and returns corrupt data due to network issues

## Impact Explanation

This is a **High Severity** vulnerability potentially escalating to **Critical**:

**High Severity ($50,000)**: Individual validator crashes qualify as "Validator node slowdowns/crashes" per the bug bounty criteria. A single malformed response crashes one validator.

**Critical Severity ($1,000,000)**: If an attacker can coordinate attacks against multiple validators simultaneously (e.g., via DNS poisoning affecting many nodes), this could cause "Total loss of liveness/network availability" requiring emergency intervention. With >1/3 of validators crashed, the network loses BFT consensus liveness.

The vulnerability violates the availability invariant - validator nodes must remain operational to participate in consensus.

## Likelihood Explanation

**Likelihood: Medium**

While the attack requires network-layer capabilities (DNS poisoning, BGP hijacking, or service compromise), these attacks are:
- **Documented and realistic**: DNS poisoning and BGP hijacking are well-known attack vectors
- **High impact targets**: Validators are critical infrastructure worth sophisticated attacks
- **Broad attack surface**: All validators contact the same telemetry endpoints
- **Recurring exposure**: Authentication happens every 15 seconds, providing multiple opportunities

The vulnerability becomes more likely if:
- The telemetry service itself has bugs causing malformed responses
- Network instability causes partial message corruption
- Multiple validators share network infrastructure susceptible to the same attack

## Recommendation

Replace `unwrap()` with proper error handling that logs errors and gracefully degrades telemetry functionality:

```rust
pub async fn authenticate(&self) -> Result<String, anyhow::Error> {
    let noise_config = match &self.auth_context.noise_config {
        Some(config) => config,
        None => return Err(anyhow!("Cannot send telemetry without private key")),
    };
    let server_public_key = self.server_public_key().await?;

    let mut client_noise_msg = vec![0; noise::handshake_init_msg_len(0)];
    let mut prologue = [0; PROLOGUE_SIZE];
    prologue[..CHAIN_ID_LENGTH].copy_from_slice(&[self.chain_id.id()]);
    prologue[CHAIN_ID_LENGTH..ID_SIZE].copy_from_slice(self.peer_id.as_ref());
    prologue[ID_SIZE..PROLOGUE_SIZE].copy_from_slice(server_public_key.as_slice());

    let mut rng = rand::rngs::OsRng;

    // FIXED: Handle errors instead of unwrap()
    let initiator_state = noise_config
        .initiate_connection(
            &mut rng,
            &prologue,
            server_public_key,
            None,
            &mut client_noise_msg,
        )
        .map_err(|e| anyhow!("Failed to initiate Noise handshake: {:?}", e))?;

    let auth_request = AuthRequest {
        chain_id: self.chain_id,
        peer_id: self.peer_id,
        role_type: self.role_type,
        server_public_key,
        handshake_msg: client_noise_msg,
        run_uuid: self.uuid,
    };

    let response = self
        .client
        .post(self.build_path("auth")?)
        .json::<AuthRequest>(&auth_request)
        .send()
        .await?;

    let resp = match error_for_status_with_body(response).await {
        Ok(response) => Ok(response.json::<AuthResponse>().await?),
        Err(err) => {
            debug!(
                "[telemetry-client] Error sending authentication request: {}",
                err,
            );
            Err(anyhow!("error {}", err))
        },
    }?;

    // FIXED: Handle errors instead of unwrap()
    let (response_payload, _) = noise_config
        .finalize_connection(initiator_state, resp.handshake_msg.as_slice())
        .map_err(|e| anyhow!("Failed to finalize Noise handshake: {:?}. This may indicate a MITM attack or corrupted response.", e))?;

    let jwt = String::from_utf8(response_payload)?;
    Ok(jwt)
}
```

**Additional Hardening:**
1. Add exponential backoff on authentication failures
2. Implement circuit breaker to disable telemetry after repeated failures
3. Add metrics for authentication failures to detect attacks
4. Consider certificate pinning for the telemetry service

## Proof of Concept

```rust
// Test demonstrating the panic behavior
#[tokio::test]
#[should_panic(expected = "called `Result::unwrap()` on an `Err` value")]
async fn test_malformed_handshake_causes_panic() {
    use aptos_crypto::{noise::NoiseConfig, x25519, Uniform};
    use httpmock::MockServer;
    use aptos_telemetry_service::types::auth::AuthResponse;
    
    // Setup mock telemetry server
    let server = MockServer::start();
    let mut rng = rand::thread_rng();
    let server_key = x25519::PrivateKey::generate(&mut rng);
    
    // Mock the public key endpoint
    server.mock(|when, then| {
        when.method("GET").path("/api/v1/");
        then.status(200).json_body_obj(&IndexResponse {
            public_key: server_key.public_key(),
        });
    });
    
    // Mock auth endpoint with MALFORMED handshake response
    server.mock(|when, then| {
        when.method("POST").path("/api/v1/auth");
        then.status(200).json_body_obj(&AuthResponse {
            // Invalid handshake message (too short, will fail decryption)
            handshake_msg: vec![0u8; 10],
        });
    });
    
    let mut node_config = NodeConfig::default();
    // Ensure the node has a private key
    let private_key = x25519::PrivateKey::generate(&mut rng);
    node_config.consensus.safety_rules.initial_safety_rules_config = 
        InitialSafetyRulesConfig::test();
    
    let client = TelemetrySender::new(
        Url::parse(&server.base_url()).unwrap(),
        ChainId::test(),
        &node_config,
    );
    
    // This will panic when finalize_connection().unwrap() fails
    // In production with the crash handler, this terminates the validator
    client.authenticate().await.unwrap();
}
```

## Notes

This vulnerability demonstrates a critical failure mode where non-critical observability infrastructure (telemetry) can crash critical consensus infrastructure (validators). The root cause is improper error handling combined with a process-terminating panic handler. The attack surface extends to all validators since they contact the same telemetry endpoints by default.

### Citations

**File:** crates/aptos-telemetry/src/sender.rs (L309-317)
```rust
        let initiator_state = noise_config
            .initiate_connection(
                &mut rng,
                &prologue,
                server_public_key,
                None,
                &mut client_noise_msg,
            )
            .unwrap();
```

**File:** crates/aptos-telemetry/src/sender.rs (L346-348)
```rust
        let (response_payload, _) = noise_config
            .finalize_connection(initiator_state, resp.handshake_msg.as_slice())
            .unwrap();
```

**File:** crates/aptos-crypto/src/noise.rs (L350-400)
```rust
    pub fn finalize_connection(
        &self,
        handshake_state: InitiatorHandshakeState,
        received_message: &[u8],
    ) -> Result<(Vec<u8>, NoiseSession), NoiseError> {
        // checks
        if received_message.len() > MAX_SIZE_NOISE_MSG {
            return Err(NoiseError::ReceivedMsgTooLarge);
        }
        // retrieve handshake state
        let InitiatorHandshakeState {
            mut h,
            mut ck,
            e,
            rs,
        } = handshake_state;

        // <- e
        let mut re = [0u8; x25519::PUBLIC_KEY_SIZE];
        let mut cursor = Cursor::new(received_message);
        cursor
            .read_exact(&mut re)
            .map_err(|_| NoiseError::MsgTooShort)?;
        mix_hash(&mut h, &re);
        let re = x25519::PublicKey::from(re);

        // <- ee
        let dh_output = e.diffie_hellman(&re);
        mix_key(&mut ck, &dh_output)?;

        // <- se
        let dh_output = self.private_key.diffie_hellman(&re);
        let k = mix_key(&mut ck, &dh_output)?;

        // <- payload
        let offset = cursor.position() as usize;

        let aead = aes_key(&k[..]);
        let mut in_out = cursor.into_inner()[offset..].to_vec();
        let nonce = aead::Nonce::assume_unique_for_key([0u8; AES_NONCE_SIZE]);
        let plaintext = aead
            .open_in_place(nonce, Aad::from(&h), &mut in_out)
            .map_err(|_| NoiseError::Decrypt)?;

        // split
        let (k1, k2) = hkdf(&ck, None)?;
        let session = NoiseSession::new(k1, k2, rs);

        //
        Ok((plaintext.to_vec(), session))
    }
```

**File:** crates/crash-handler/src/lib.rs (L26-57)
```rust
pub fn setup_panic_handler() {
    panic::set_hook(Box::new(move |pi: &PanicHookInfo<'_>| {
        handle_panic(pi);
    }));
}

// Formats and logs panic information
fn handle_panic(panic_info: &PanicHookInfo<'_>) {
    // The Display formatter for a PanicHookInfo contains the message, payload and location.
    let details = format!("{}", panic_info);
    let backtrace = format!("{:#?}", Backtrace::new());

    let info = CrashInfo { details, backtrace };
    let crash_info = toml::to_string_pretty(&info).unwrap();
    error!("{}", crash_info);
    // TODO / HACK ALARM: Write crash info synchronously via eprintln! to ensure it is written before the process exits which error! doesn't guarantee.
    // This is a workaround until https://github.com/aptos-labs/aptos-core/issues/2038 is resolved.
    eprintln!("{}", crash_info);

    // Wait till the logs have been flushed
    aptos_logger::flush();

    // Do not kill the process if the panics happened at move-bytecode-verifier.
    // This is safe because the `state::get_state()` uses a thread_local for storing states. Thus the state can only be mutated to VERIFIER by the thread that's running the bytecode verifier.
    //
    // TODO: once `can_unwind` is stable, we should assert it. See https://github.com/rust-lang/rust/issues/92988.
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
```

**File:** crates/aptos-telemetry/src/service.rs (L259-270)
```rust
fn try_spawn_metrics_sender(telemetry_sender: TelemetrySender) {
    if enable_prometheus_push_metrics() {
        tokio::spawn(async move {
            // Periodically send ALL prometheus metrics (This replaces the previous core and network metrics implementation)
            let mut interval =
                time::interval(Duration::from_secs(PROMETHEUS_PUSH_METRICS_FREQ_SECS));
            loop {
                interval.tick().await;
                telemetry_sender.try_push_prometheus_metrics().await;
            }
        });
    }
```

**File:** crates/aptos-telemetry/src/constants.rs (L42-42)
```rust
pub(crate) const PROMETHEUS_PUSH_METRICS_FREQ_SECS: u64 = 15; // 15 seconds
```
