# Audit Report

## Title
Validator Network Topology Information Disclosure via Peer Monitoring Service

## Summary
The peer monitoring service server exposes all connected peers across all networks without access control or filtering based on the requesting peer's network. If a validator has a public network interface configured, any public peer can request network information and receive details about all the validator's connections, including private validator network peers. Additionally, the client-side validation logic has a gap for validators at distance >= 2 from the validator set, failing to validate network and role consistency.

## Finding Description

The vulnerability consists of three interconnected issues:

**1. Server-Side Lack of Access Control:**
The `get_network_information()` function in the peer monitoring service server returns all connected peers across all networks without filtering based on the requesting peer's network_id. [1](#0-0) 

The function calls `get_connected_peers_and_metadata()` which iterates through ALL networks and returns ALL connected peers: [2](#0-1) 

The `network_id` parameter in the handler is only used for metrics, not for access control: [3](#0-2) 

**2. Configuration Gap:**
The configuration sanitizer does not explicitly forbid validators from having public networks in their `full_node_networks`. It only forbids `NetworkId::Validator`: [4](#0-3) 

**3. Client-Side Validation Gap:**
The validation logic in `handle_monitoring_service_response()` only performs strict network and role validation for peers at distance 0 and 1 from validators. For distance >= 2, it only checks if the distance is within bounds without validating network_id or peer role consistency: [5](#0-4) 

**Attack Scenario:**
1. A validator misconfigures or intentionally configures a public network interface (allowed by config sanitizer)
2. A malicious public peer connects to the validator's public network
3. The public peer sends a `GetNetworkInformation` request
4. The validator's server responds with ALL connected peers, including:
   - Other validators on the private `validator_network`
   - PeerIds of all connected validators
   - Network addresses (IP:port) of validator nodes
   - Peer roles (PeerRole::Validator)
5. The response includes `distance_from_validators: 0` since the validator has validator peers
6. On the client side, if the validator reported accurately, the validation would fail (peer on public network claiming distance 0)
7. However, the information has already been transmitted and can be captured

The `NetworkInformationResponse` structure exposes sensitive metadata: [6](#0-5) 

## Impact Explanation

This is a **LOW severity** information disclosure vulnerability as categorized in the Aptos bug bounty program under "Minor information leaks" (up to $1,000).

**Impact:**
- **Information Leakage**: Exposes validator network topology, including PeerIds and network addresses of validators on the private validator_network
- **Network Reconnaissance**: Enables attackers to map the validator network for targeted attacks
- **Privacy Violation**: Leaks information about which validators are connected to each other

**Why Not Higher Severity:**
- Does not directly compromise consensus, funds, or availability
- Requires validator misconfiguration (public network interface)
- Only leaks network topology information, not cryptographic keys or authentication credentials
- Does not enable direct attacks on consensus protocol or state integrity

## Likelihood Explanation

**Likelihood: LOW to MEDIUM**

**Factors Increasing Likelihood:**
- No explicit prohibition in config sanitizer against validators having public networks
- Default examples show validators with `full_node_networks` configured
- Misconfiguration is possible during setup

**Factors Decreasing Likelihood:**
- Best practices suggest validators should only use VFN networks (`NetworkId::Vfn`) for fullnode connections
- Properly configured validators typically don't expose public network interfaces
- Validator operators are expected to follow security guidelines

**Attacker Requirements:**
- Ability to connect to a validator's public network (if misconfigured)
- No special privileges required
- Simple RPC request to peer monitoring service

## Recommendation

**1. Add Server-Side Access Control:**
Implement network-based filtering in `get_network_information()` to only return peers from the same or less privileged networks:

```rust
fn get_network_information(
    &self,
    requesting_network_id: NetworkId,  // Pass this through from handler
) -> Result<PeerMonitoringServiceResponse, Error> {
    let connected_peers_and_metadata =
        self.peers_and_metadata.get_connected_peers_and_metadata()?;
    
    // Filter peers based on requesting network
    let filtered_peers = connected_peers_and_metadata
        .into_iter()
        .filter(|(peer_network_id, _)| {
            // Only return peers from same network or public network
            peer_network_id.network_id() == requesting_network_id 
                || peer_network_id.network_id().is_public_network()
        })
        .map(|(peer, metadata)| {
            // Map to ConnectionMetadata
        })
        .collect();
    
    // Calculate distance and return response
}
```

**2. Enhance Configuration Validation:**
Add explicit check in config sanitizer to forbid or warn about validators with public networks:

```rust
fn sanitize_fullnode_network_configs(
    node_config: &NodeConfig,
    node_type: NodeType,
    _chain_id: Option<ChainId>,
) -> Result<(), Error> {
    // ... existing checks ...
    
    // For validators, only allow VFN networks
    if node_type.is_validator() {
        for fullnode_network_config in fullnode_networks {
            if fullnode_network_config.network_id.is_public_network() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Validators should not have public networks configured!".into(),
                ));
            }
        }
    }
    
    Ok(())
}
```

**3. Improve Client-Side Validation:**
Enhance validation for distance >= 2 to check network and role consistency:

```rust
distance_from_validators => {
    // For distance >= 2, also validate network consistency
    let is_valid_distance = distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS;
    let is_valid_network = !network_id.is_validator_network(); // Shouldn't be on validator network
    let is_not_validator = !peer_metadata.get_connection_metadata().role.is_validator();
    
    is_valid_distance && is_valid_network && is_not_validator
}
```

## Proof of Concept

Due to the complexity of setting up a full network test environment, here's a conceptual Rust test demonstrating the vulnerability:

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_config::{
        config::{NodeConfig, NetworkConfig, PeerRole, RoleType},
        network_id::{NetworkId, PeerNetworkId},
    };
    
    #[test]
    fn test_validator_public_network_information_leak() {
        // 1. Create a validator node config with BOTH validator and public networks
        let mut validator_config = NodeConfig::default();
        validator_config.base.role = RoleType::Validator;
        
        // Validator network (private)
        validator_config.validator_network = Some(NetworkConfig {
            network_id: NetworkId::Validator,
            // ... other config
        });
        
        // Public network (misconfigured)
        validator_config.full_node_networks.push(NetworkConfig {
            network_id: NetworkId::Public,
            // ... other config
        });
        
        // 2. Simulate validator having connections on BOTH networks
        let validator_peer_id = PeerId::random();
        let public_peer_id = PeerId::random();
        
        // Validator has other validators connected on validator_network
        let validator_peer = PeerNetworkId::new(NetworkId::Validator, validator_peer_id);
        
        // Public peer connects to validator's public network
        let public_peer = PeerNetworkId::new(NetworkId::Public, public_peer_id);
        
        // 3. Public peer requests GetNetworkInformation
        let request = PeerMonitoringServiceRequest::GetNetworkInformation;
        
        // 4. Server responds with ALL connected peers
        // This would include validator_peer details (PeerId, address, role)
        // even though request came from public network
        
        // Assert: Response contains validator network topology
        // This demonstrates the information leak
    }
}
```

## Notes

This vulnerability represents a **defense-in-depth** issue where multiple layers of protection are missing:
1. Configuration allows validators on public networks
2. Server doesn't filter responses by network
3. Client validation has gaps

While the impact is limited to information disclosure (LOW severity), it violates the principle that validator network topology should remain private. The combination of all three issues creates an exploitable attack surface for network reconnaissance.

The fix requires addressing all three layers to properly segregate network information based on the requesting peer's privilege level.

### Citations

**File:** peer-monitoring-service/server/src/lib.rs (L155-182)
```rust
    pub fn call(
        &self,
        network_id: NetworkId,
        request: PeerMonitoringServiceRequest,
    ) -> Result<PeerMonitoringServiceResponse> {
        // Update the request count
        increment_counter(
            &metrics::PEER_MONITORING_REQUESTS_RECEIVED,
            network_id,
            request.get_label(),
        );

        // Time the request processing (the timer will stop when it's dropped)
        let _timer = start_timer(
            &metrics::PEER_MONITORING_REQUEST_PROCESSING_LATENCY,
            network_id,
            request.get_label(),
        );

        // Process the request
        let response = match &request {
            PeerMonitoringServiceRequest::GetNetworkInformation => self.get_network_information(),
            PeerMonitoringServiceRequest::GetServerProtocolVersion => {
                self.get_server_protocol_version()
            },
            PeerMonitoringServiceRequest::GetNodeInformation => self.get_node_information(),
            PeerMonitoringServiceRequest::LatencyPing(request) => self.handle_latency_ping(request),
        };
```

**File:** peer-monitoring-service/server/src/lib.rs (L217-248)
```rust
    fn get_network_information(&self) -> Result<PeerMonitoringServiceResponse, Error> {
        // Get the connected peers
        let connected_peers_and_metadata =
            self.peers_and_metadata.get_connected_peers_and_metadata()?;
        let connected_peers = connected_peers_and_metadata
            .into_iter()
            .map(|(peer, metadata)| {
                let connection_metadata = metadata.get_connection_metadata();
                (
                    peer,
                    ConnectionMetadata::new(
                        connection_metadata.addr,
                        connection_metadata.remote_peer_id,
                        connection_metadata.role,
                    ),
                )
            })
            .collect();

        // Get the distance from the validators
        let distance_from_validators =
            get_distance_from_validators(&self.base_config, self.peers_and_metadata.clone());

        // Create and return the response
        let network_information_response = NetworkInformationResponse {
            connected_peers,
            distance_from_validators,
        };
        Ok(PeerMonitoringServiceResponse::NetworkInformation(
            network_information_response,
        ))
    }
```

**File:** network/framework/src/application/storage.rs (L107-125)
```rust
    /// Returns metadata for all peers currently connected to the node
    pub fn get_connected_peers_and_metadata(
        &self,
    ) -> Result<HashMap<PeerNetworkId, PeerMetadata>, Error> {
        // Get the cached peers and metadata
        let cached_peers_and_metadata = self.cached_peers_and_metadata.load();

        // Collect all connected peers
        let mut connected_peers_and_metadata = HashMap::new();
        for (network_id, peers_and_metadata) in cached_peers_and_metadata.iter() {
            for (peer_id, peer_metadata) in peers_and_metadata.iter() {
                if peer_metadata.is_connected() {
                    let peer_network_id = PeerNetworkId::new(*network_id, *peer_id);
                    connected_peers_and_metadata.insert(peer_network_id, peer_metadata.clone());
                }
            }
        }
        Ok(connected_peers_and_metadata)
    }
```

**File:** config/src/config/config_sanitizer.rs (L128-139)
```rust
    // Check each fullnode network config and ensure uniqueness
    let mut fullnode_network_ids = HashSet::new();
    for fullnode_network_config in fullnode_networks {
        let network_id = fullnode_network_config.network_id;

        // Verify that the fullnode network config is not a validator network config
        if network_id.is_validator_network() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Fullnode network configs cannot include a validator network!".into(),
            ));
        }
```

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L116-154)
```rust
        // Sanity check the response depth from the peer metadata
        let network_id = peer_network_id.network_id();
        let is_valid_depth = match network_info_response.distance_from_validators {
            0 => {
                // Verify the peer is a validator and has the correct network id
                let peer_is_validator = peer_metadata.get_connection_metadata().role.is_validator();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_validator_network(), // We're a validator
                    RoleType::FullNode => network_id.is_vfn_network(),        // We're a VFN
                };
                peer_is_validator && peer_has_correct_network
            },
            1 => {
                // Verify the peer is a VFN and has the correct network id
                let peer_is_vfn = peer_metadata.get_connection_metadata().role.is_vfn();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_vfn_network(), // We're a validator
                    RoleType::FullNode => network_id.is_public_network(), // We're a VFN or PFN
                };
                peer_is_vfn && peer_has_correct_network
            },
            distance_from_validators => {
                // The distance must be less than or equal to the max
                distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS
            },
        };

        // If the depth did not pass our sanity checks, handle a failure
        if !is_valid_depth {
            warn!(LogSchema::new(LogEntry::NetworkInfoRequest)
                .event(LogEvent::InvalidResponse)
                .peer(peer_network_id)
                .message(&format!(
                    "Peer returned invalid depth from validators: {}",
                    network_info_response.distance_from_validators
                )));
            self.handle_request_failure();
            return;
        }
```

**File:** peer-monitoring-service/types/src/response.rs (L50-76)
```rust
/// A response for the network information request
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct NetworkInformationResponse {
    pub connected_peers: BTreeMap<PeerNetworkId, ConnectionMetadata>, // Connected peers
    pub distance_from_validators: u64, // The distance of the peer from the validator set
}

// Display formatting provides a high-level summary of the response
impl Display for NetworkInformationResponse {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{{ num_connected_peers: {:?}, distance_from_validators: {:?} }}",
            self.connected_peers.len(),
            self.distance_from_validators,
        )
    }
}

/// Simple connection metadata associated with each peer
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct ConnectionMetadata {
    pub network_address: NetworkAddress,
    pub peer_id: PeerId,
    pub peer_role: PeerRole,
}

```
