# Audit Report

## Title
Gas Limit Inconsistency Causes Non-Deterministic Block Execution When `enable_payload_v2` Flag Differs Between Validators

## Summary
When validators have different `enable_payload_v2` configuration values, they produce incompatible `BlockTransactionPayload` types for the same consensus block, leading to different gas limit enforcement during execution. This causes validators to execute different numbers of transactions from identical blocks, violating deterministic execution and breaking consensus safety.

## Finding Description

The vulnerability occurs in the payload processing pipeline where the `enable_payload_v2` flag controls how `BlockTransactionPayload` objects are created from consensus `Payload` data. [1](#0-0) 

**Attack Flow:**

1. **Block Creation**: A leader validator with `enable_payload_v2=true` creates a block containing `Payload::QuorumStoreInlineHybridV2` with both transaction limits and gas limits. [2](#0-1) 

2. **Consensus Voting**: All validators accept and vote on this block since both payload variants pass validation. [3](#0-2) 

3. **Execution Divergence**: When processing the block for execution via `get_transactions()`, validators with different `enable_payload_v2` settings create different `BlockTransactionPayload` variants: [4](#0-3) 

4. **Gas Limit Loss**: The critical issue occurs in `get_transactions_quorum_store_inline_hybrid()` which creates `BlockTransactionPayload` using the local `enable_payload_v2` flag: [5](#0-4) 

5. **Different Return Values**: When `BlockTransactionPayload::gas_limit()` is called, V1 payloads ALWAYS return `None` even if gas limit data exists: [6](#0-5) 

6. **Execution Results**: The returned gas limits are passed to block execution: [7](#0-6) 

**Result**: 
- Validator A (enable_payload_v2=true): executes with gas_limit=Some(X), may halt early due to gas
- Validator B (enable_payload_v2=false): executes with gas_limit=None, processes all transactions without gas limits
- Different execution results → Different state roots → **Consensus safety violation**

## Impact Explanation

This is a **Critical Severity** vulnerability qualifying for the highest bug bounty tier because it causes a **Consensus Safety Violation**:

1. **Broken Invariant**: Violates the "Deterministic Execution" invariant - validators must produce identical state roots for identical blocks. [8](#0-7) 

2. **Chain Split Risk**: Validators with different configurations will commit different states, potentially causing an unrecoverable network partition requiring a hard fork.

3. **Impact Scope**: Affects ALL validators with mismatched configuration, not just a subset.

4. **No Attack Required**: This happens naturally through configuration drift, not requiring any malicious action.

## Likelihood Explanation

**Likelihood: HIGH**

1. **Configuration Drift**: The `enable_payload_v2` flag is a per-validator configuration that can easily differ across the network during rollout periods or due to operator error.

2. **No Warning System**: There's no mechanism to detect or warn about configuration mismatches between validators.

3. **Silent Failure**: The issue doesn't cause immediate errors - validators continue operating but produce divergent state, making detection difficult.

4. **Practical Scenario**: During a feature rollout where some validators upgrade and enable V2 payloads while others haven't yet, this vulnerability will trigger automatically.

## Recommendation

**Fix**: Ensure the `BlockTransactionPayload` type preserves all execution limit data regardless of the `enable_payload_v2` flag. The payload variant should be determined by the consensus block's payload type, not by local configuration.

**Solution 1** (Recommended): Modify `BlockTransactionPayload::new_quorum_store_inline_hybrid()` to always create V2 payloads when gas_limit is provided:

```rust
pub fn new_quorum_store_inline_hybrid(
    transactions: Vec<SignedTransaction>,
    proofs: Vec<ProofOfStore<BatchInfo>>,
    transaction_limit: Option<u64>,
    gas_limit: Option<u64>,
    inline_batches: Vec<BatchInfo>,
    enable_payload_v2: bool,  // Deprecate this parameter
) -> Self {
    let payload_with_proof = PayloadWithProof::new(transactions, proofs);
    // Always use V2 if gas_limit is provided
    if gas_limit.is_some() {
        let proof_with_limits = TransactionsWithProof::TransactionsWithProofAndLimits(
            TransactionsWithProofAndLimits::new(payload_with_proof, transaction_limit, gas_limit),
        );
        Self::QuorumStoreInlineHybridV2(proof_with_limits, inline_batches)
    } else {
        let proof_with_limit = PayloadWithProofAndLimit::new(payload_with_proof, transaction_limit);
        Self::QuorumStoreInlineHybrid(proof_with_limit, inline_batches)
    }
}
```

**Solution 2**: Make `enable_payload_v2` an on-chain consensus parameter rather than a per-validator configuration, ensuring all validators use the same value.

## Proof of Concept

```rust
#[tokio::test]
async fn test_payload_v2_inconsistency() {
    // Setup: Two validators with different enable_payload_v2 settings
    let batch_reader = Arc::new(MockBatchReader::new());
    let commit_notifier = Box::new(MockCommitNotifier::new());
    
    // Validator A: enable_payload_v2 = true
    let payload_manager_a = QuorumStorePayloadManager::new(
        batch_reader.clone(),
        commit_notifier.clone(),
        None,
        ordered_authors.clone(),
        address_to_validator_index.clone(),
        true,  // enable_payload_v2
    );
    
    // Validator B: enable_payload_v2 = false
    let payload_manager_b = QuorumStorePayloadManager::new(
        batch_reader.clone(),
        commit_notifier,
        None,
        ordered_authors,
        address_to_validator_index,
        false,  // enable_payload_v2
    );
    
    // Create a block with QuorumStoreInlineHybridV2 payload (includes gas limit)
    let payload = Payload::QuorumStoreInlineHybridV2(
        vec![],  // inline_batches
        ProofWithData::new(vec![]),
        PayloadExecutionLimit::TxnAndGasLimits(TxnAndGasLimits {
            transaction_limit: Some(100),
            gas_limit: Some(1_000_000),  // Gas limit set
        }),
    );
    let block = create_test_block_with_payload(payload);
    
    // Both validators process the same block
    let (txns_a, limit_a, gas_a) = payload_manager_a.get_transactions(&block, None).await.unwrap();
    let (txns_b, limit_b, gas_b) = payload_manager_b.get_transactions(&block, None).await.unwrap();
    
    // VULNERABILITY: Different gas limits returned!
    assert_eq!(gas_a, Some(1_000_000));  // Validator A gets gas limit
    assert_eq!(gas_b, None);              // Validator B loses gas limit!
    
    // This leads to different execution behavior and state divergence
}
```

**Notes**
This vulnerability is particularly dangerous because:
1. It's configuration-dependent, not code-dependent
2. It causes silent failures without obvious errors
3. It affects core consensus safety, not just peripheral features
4. It can occur during normal operations without any attack

The fix should ensure execution determinism is maintained regardless of local validator configuration by deriving all execution parameters from the consensus-agreed block payload structure.

### Citations

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L71-87)
```rust
    pub fn new(
        batch_reader: Arc<dyn BatchReader>,
        commit_notifier: Box<dyn TQuorumStoreCommitNotifier>,
        maybe_consensus_publisher: Option<Arc<ConsensusPublisher>>,
        ordered_authors: Vec<PeerId>,
        address_to_validator_index: HashMap<PeerId, usize>,
        enable_payload_v2: bool,
    ) -> Self {
        Self {
            batch_reader,
            commit_notifier,
            maybe_consensus_publisher,
            ordered_authors,
            address_to_validator_index,
            enable_payload_v2,
        }
    }
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L155-162)
```rust
        Ok(BlockTransactionPayload::new_quorum_store_inline_hybrid(
            all_transactions,
            proof_with_data.proofs.clone(),
            *max_txns_to_execute,
            *block_gas_limit_override,
            inline_batches,
            self.enable_payload_v2,
        ))
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L497-510)
```rust
            Payload::QuorumStoreInlineHybridV2(
                inline_batches,
                proof_with_data,
                execution_limits,
            ) => {
                self.get_transactions_quorum_store_inline_hybrid(
                    block,
                    inline_batches,
                    proof_with_data,
                    &execution_limits.max_txns_to_execute(),
                    &execution_limits.block_gas_limit(),
                )
                .await?
            },
```

**File:** consensus/src/quorum_store/proof_manager.rs (L222-234)
```rust
            if self.enable_payload_v2 {
                Payload::QuorumStoreInlineHybridV2(
                    inline_block,
                    ProofWithData::new(proof_block),
                    PayloadExecutionLimit::None,
                )
            } else {
                Payload::QuorumStoreInlineHybrid(
                    inline_block,
                    ProofWithData::new(proof_block),
                    None,
                )
            }
```

**File:** consensus/consensus-types/src/common.rs (L590-596)
```rust
            (true, Payload::QuorumStoreInlineHybrid(inline_batches, proof_with_data, _))
            | (true, Payload::QuorumStoreInlineHybridV2(inline_batches, proof_with_data, _)) => {
                Self::verify_with_cache(&proof_with_data.proofs, verifier, proof_cache)?;
                Self::verify_inline_batches(
                    inline_batches.iter().map(|(info, txns)| (info, txns)),
                )?;
                Ok(())
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L604-613)
```rust
    /// Returns the block gas limit of the payload
    pub fn gas_limit(&self) -> Option<u64> {
        match self {
            BlockTransactionPayload::DeprecatedInQuorumStore(_)
            | BlockTransactionPayload::DeprecatedInQuorumStoreWithLimit(_)
            | BlockTransactionPayload::QuorumStoreInlineHybrid(_, _) => None,
            BlockTransactionPayload::QuorumStoreInlineHybridV2(payload, _)
            | BlockTransactionPayload::OptQuorumStore(payload, _) => payload.gas_limit(),
        }
    }
```

**File:** consensus/src/block_preparer.rs (L54-68)
```rust
        let (txns, max_txns_from_block_to_execute, block_gas_limit) = tokio::select! {
                // Poll the block qc future until a QC is received. Ignore None outcomes.
                Some(qc) = block_qc_fut => {
                    let block_voters = Some(qc.ledger_info().get_voters_bitvec().clone());
                    self.payload_manager.get_transactions(block, block_voters).await
                },
                result = self.payload_manager.get_transactions(block, None) => {
                   result
                }
        }?;
        TXNS_IN_BLOCK
            .with_label_values(&["before_filter"])
            .observe(txns.len() as f64);

        Ok((txns, max_txns_from_block_to_execute, block_gas_limit))
```

**File:** consensus/consensus-types/src/block_data.rs (L105-133)
```rust
impl CryptoHash for BlockData {
    type Hasher = BlockDataHasher;

    fn hash(&self) -> HashValue {
        let mut state = Self::Hasher::default();
        if self.is_opt_block() {
            #[derive(Serialize)]
            struct OptBlockDataForHash<'a> {
                epoch: u64,
                round: Round,
                timestamp_usecs: u64,
                quorum_cert_vote_data: &'a VoteData,
                block_type: &'a BlockType,
            }

            let opt_block_data_for_hash = OptBlockDataForHash {
                epoch: self.epoch,
                round: self.round,
                timestamp_usecs: self.timestamp_usecs,
                quorum_cert_vote_data: self.quorum_cert.vote_data(),
                block_type: &self.block_type,
            };
            bcs::serialize_into(&mut state, &opt_block_data_for_hash)
                .expect("OptBlockDataForHash must be serializable");
        } else {
            bcs::serialize_into(&mut state, &self).expect("BlockData must be serializable");
        }
        state.finish()
    }
```
