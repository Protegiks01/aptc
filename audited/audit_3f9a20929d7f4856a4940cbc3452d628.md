# Audit Report

## Title
Division by Zero in RotatingProposer Leading to Total Network Liveness Failure

## Summary
The `RotatingProposer::get_valid_proposer()` function performs an unchecked division operation using `contiguous_rounds` without validating that this value is non-zero. A governance proposal can set `contiguous_rounds=0` in the on-chain consensus configuration, causing all validator nodes to panic during proposer election, resulting in complete network halt requiring a hard fork to recover.

## Finding Description

The vulnerability exists in the consensus proposer election mechanism. The `RotatingProposer` struct uses a `contiguous_rounds` parameter to determine how many consecutive rounds each proposer should lead. This value comes from the on-chain governance-controlled consensus configuration. [1](#0-0) 

The division operation `round / u64::from(self.contiguous_rounds)` will panic if `contiguous_rounds` is zero. This is a direct integer division in Rust, not a checked operation.

**Attack/Misconfiguration Path:**

1. The `contiguous_rounds` value originates from `OnChainConsensusConfig` which contains `ProposerElectionType::RotatingProposer(u32)`: [2](#0-1) 

2. On-chain configuration is set via governance proposals through the Move module with NO content validation: [3](#0-2) 

The only validation is that the config vector is non-empty, with no checks on the actual parameter values.

3. During proposal generation, only the blob size is validated: [4](#0-3) 

4. Configuration deserialization performs no validation: [5](#0-4) 

5. The `RotatingProposer` constructor accepts any `u32` value without validation: [6](#0-5) 

6. When consensus creates the proposer election during epoch initialization: [7](#0-6) 

7. The RoundManager calls `get_valid_proposer()` during critical consensus operations: [8](#0-7) 

When this function executes with `contiguous_rounds=0`, the panic kills the consensus task, which is spawned via tokio: [9](#0-8) 

## Impact Explanation

This vulnerability causes **Total loss of liveness/network availability**, qualifying for **Critical Severity** under the Aptos bug bounty program (up to $1,000,000).

**Impact:**
- **All validator nodes simultaneously panic** when attempting to determine the proposer for any round
- **Consensus completely halts** - no blocks can be produced
- **Non-recoverable without hard fork** - the malicious configuration is stored on-chain and will be reloaded on every restart
- **Affects entire network** - all validators use the same on-chain configuration

This breaks the fundamental consensus liveness invariant that the system must make progress under honest majority conditions.

## Likelihood Explanation

**Likelihood: Medium to High**

**Via Malicious Governance Proposal:**
- Requires sufficient stake to create and pass a governance proposal
- Governance participants may not recognize that `contiguous_rounds=0` causes a panic
- No validation warnings or errors are presented during proposal creation

**Via Accidental Misconfiguration:**
- Legitimate governance participants could accidentally set this value to 0
- No developer tooling validates this constraint
- The relationship between the config value and division operation is not obvious

**Ease of Exploitation:**
- Single governance proposal can trigger the vulnerability
- No complex timing or race conditions required
- Deterministic outcome affecting all validators simultaneously
- The parameter space is small (u32), making `0` an obvious edge case someone might try

The lack of ANY validation at ANY layer makes this highly exploitable. The vulnerability persists across restarts and requires coordinated hard fork intervention to resolve.

## Recommendation

Add validation at multiple layers to ensure `contiguous_rounds > 0`:

**1. Add validation in RotatingProposer constructor:**

```rust
impl RotatingProposer {
    pub fn new(proposers: Vec<Author>, contiguous_rounds: u32) -> Self {
        assert!(
            contiguous_rounds > 0,
            "contiguous_rounds must be greater than 0"
        );
        assert!(
            !proposers.is_empty(),
            "proposers list cannot be empty"
        );
        Self {
            proposers,
            contiguous_rounds,
        }
    }
}
```

**2. Add validation in the Move module:**

```move
public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
    system_addresses::assert_aptos_framework(account);
    assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
    // Add native function to validate config contents
    assert!(validator_config_is_valid(config), error::invalid_argument(EINVALID_CONFIG));
    std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
}
```

**3. Add validation in proposal generation:**

```rust
pub fn generate_consensus_upgrade_proposal(
    consensus_config: &OnChainConsensusConfig,
    // ...
) -> Result<Vec<(String, String)>> {
    // Validate config before generating proposal
    validate_consensus_config(consensus_config)?;
    // ... rest of function
}

fn validate_consensus_config(config: &OnChainConsensusConfig) -> Result<()> {
    match config.proposer_election_type() {
        ProposerElectionType::RotatingProposer(rounds) 
        | ProposerElectionType::FixedProposer(rounds) => {
            anyhow::ensure!(*rounds > 0, "contiguous_rounds must be greater than 0");
        },
        _ => {}
    }
    Ok(())
}
```

## Proof of Concept

**Rust Test Demonstrating the Panic:**

```rust
#[test]
#[should_panic(expected = "attempt to divide by zero")]
fn test_rotating_proposer_division_by_zero() {
    use crate::liveness::{
        proposer_election::ProposerElection,
        rotating_proposer_election::RotatingProposer,
    };
    use aptos_types::account_address::AccountAddress;

    let proposers = vec![
        AccountAddress::random(),
        AccountAddress::random(),
    ];
    
    // Create RotatingProposer with contiguous_rounds=0
    let pe = RotatingProposer::new(proposers, 0);
    
    // This call will panic with division by zero
    pe.get_valid_proposer(1);
}
```

**Governance Proposal Attack Scenario:**

```rust
// In a governance proposal generation tool:
use aptos_types::on_chain_config::{
    OnChainConsensusConfig, ConsensusConfigV1, 
    ProposerElectionType, ConsensusAlgorithmConfig,
};

// Create malicious config with contiguous_rounds=0
let malicious_config = OnChainConsensusConfig::V5 {
    alg: ConsensusAlgorithmConfig::JolteonV2 {
        main: ConsensusConfigV1 {
            proposer_election_type: ProposerElectionType::RotatingProposer(0), // Malicious value
            // ... other fields
        },
        quorum_store_enabled: true,
        order_vote_enabled: true,
    },
    // ... other fields
};

// This config can be serialized and submitted via governance
let config_bytes = bcs::to_bytes(&malicious_config).unwrap();
// consensus_config::set_for_next_epoch(&framework_signer, config_bytes);
// All validators will panic on next epoch when get_valid_proposer() is called
```

## Notes

This vulnerability demonstrates a critical failure in defense-in-depth. The absence of validation at the Move layer, Rust deserialization layer, and constructor layer creates a single point of failure that can be triggered through governance. While governance requires stake and voting, the lack of technical safeguards means both malicious actors and accidental misconfigurations can cause catastrophic network failure.

The fix requires validation at the earliest possible point (constructor) and ideally at all layers to prevent this class of configuration errors from reaching production code.

### Citations

**File:** consensus/src/liveness/rotating_proposer_election.rs (L27-32)
```rust
    pub fn new(proposers: Vec<Author>, contiguous_rounds: u32) -> Self {
        Self {
            proposers,
            contiguous_rounds,
        }
    }
```

**File:** consensus/src/liveness/rotating_proposer_election.rs (L36-39)
```rust
    fn get_valid_proposer(&self, round: Round) -> Author {
        self.proposers
            [((round / u64::from(self.contiguous_rounds)) % self.proposers.len() as u64) as usize]
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L464-468)
```rust
    fn deserialize_into_config(bytes: &[u8]) -> Result<Self> {
        let raw_bytes: Vec<u8> = bcs::from_bytes(bytes)?;
        bcs::from_bytes(&raw_bytes)
            .map_err(|e| format_err!("[on-chain config] Failed to deserialize into config: {}", e))
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L510-523)
```rust
pub enum ProposerElectionType {
    // Choose the smallest PeerId as the proposer
    // with specified param contiguous_rounds
    FixedProposer(u32),
    // Round robin rotation of proposers
    // with specified param contiguous_rounds
    RotatingProposer(u32),
    // Committed history based proposer election
    LeaderReputation(LeaderReputationType),
    // Pre-specified proposers for each round,
    // or default proposer if round proposer not
    // specified
    RoundProposer(HashMap<Round, AccountAddress>),
}
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```

**File:** aptos-move/aptos-release-builder/src/components/consensus_config.rs (L33-34)
```rust
            let consensus_config_blob = bcs::to_bytes(consensus_config).unwrap();
            assert!(consensus_config_blob.len() < 65536);
```

**File:** consensus/src/epoch_manager.rs (L296-299)
```rust
        match &onchain_config.proposer_election_type() {
            ProposerElectionType::RotatingProposer(contiguous_rounds) => {
                Arc::new(RotatingProposer::new(proposers, *contiguous_rounds))
            },
```

**File:** consensus/src/epoch_manager.rs (L995-1000)
```rust
        tokio::spawn(round_manager.start(
            round_manager_rx,
            buffered_proposal_rx,
            opt_proposal_loopback_rx,
            close_rx,
        ));
```

**File:** consensus/src/round_manager.rs (L428-430)
```rust
        let prev_proposer = self
            .proposer_election
            .get_valid_proposer(new_round.saturating_sub(1));
```
