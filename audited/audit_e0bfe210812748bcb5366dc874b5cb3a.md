# Audit Report

## Title
Division-by-Zero Network Halt via Unvalidated Consensus Config Weights in ReleaseConfig::parse()

## Summary
`ReleaseConfig::parse()` performs no semantic validation of consensus configuration parameters, allowing malformed governance proposals with zero-valued leader reputation weights to pass validation and trigger a division-by-zero panic across all validator nodes during leader election, causing total network halt.

## Finding Description

The `ReleaseConfig::parse()` function performs only YAML deserialization without validating the semantic correctness of proposal configurations. [1](#0-0) 

Specifically, when parsing `OnChainConsensusConfig` containing `ProposerAndVoterConfig`, there is no validation that the three weight parameters (`active_weight`, `inactive_weight`, `failed_weight`) are non-zero. [2](#0-1) 

**Attack Path:**

1. **Malicious Config Creation**: Attacker creates a release config YAML with `ProposerAndVoterConfig` where all three weights are set to 0:
   ```yaml
   active_weight: 0
   inactive_weight: 0  
   failed_weight: 0
   ```

2. **Parse Bypass**: `ReleaseConfig::parse()` successfully deserializes this config without validation, as it only uses `serde_yaml::from_str()`. [1](#0-0) 

3. **Proposal Generation**: The release builder generates a governance proposal calling `consensus_config::set_for_next_epoch()` with the malformed config bytes. [3](#0-2) 

4. **Move Validation Bypass**: The on-chain Move code only validates that config bytes are non-empty, not their semantic correctness. [4](#0-3) 

5. **Config Application**: After governance approval, the config is applied at the next epoch transition.

6. **Leader Election Failure**: When validators attempt to elect the next block proposer, `ProposerAndVoterHeuristic::get_weights()` assigns weight 0 to all validators. [5](#0-4) 

7. **Weight Multiplication**: Even with positive voting powers, multiplication by zero weights results in all `stake_weights` being 0. [6](#0-5) 

8. **Division-by-Zero Panic**: `choose_index()` computes `total_weight = 0` and calls `next_in_range(state, 0)`, which executes `u128 % 0`, causing a panic. [7](#0-6) 

9. **Network Halt**: All validator nodes crash simultaneously when trying to propose the next block. The network cannot produce blocks and requires a hard fork to recover.

## Impact Explanation

**Critical Severity** - This vulnerability causes **Total loss of liveness/network availability**, explicitly listed in the Aptos Bug Bounty program as Critical severity (up to $1,000,000).

All validator nodes will crash with a division-by-zero panic during leader election, making it impossible to produce new blocks. The network becomes completely non-functional and requires:
- Emergency hard fork to apply fixed consensus config
- Coordinated validator restart
- Potential loss of user confidence

This breaks the **Consensus Safety** invariant: the network must maintain liveness to process transactions and produce blocks under normal BFT assumptions.

## Likelihood Explanation

**Medium-High Likelihood**:

**Required conditions:**
- Malicious or negligent governance proposer creates config with zero weights
- Governance approval (2/3+ voting power) - but config appears syntactically valid in YAML, may pass cursory review
- No runtime validation exists to prevent execution

**Why likely:**
- The attack requires only standard governance processes, not validator collusion
- Config syntax is valid, making it difficult to detect during review
- Zero validation exists at parse-time, Move execution-time, or consensus runtime
- No defensive checks in the critical path

**Mitigation factors:**
- Requires governance approval (but not impossible with social engineering or mistakes)
- One-time attack (can be fixed via emergency hard fork, but with significant disruption)

## Recommendation

**Immediate Fix - Add validation to `ReleaseConfig::parse()`:**

Add a validation method that checks all consensus config parameters:

```rust
// In aptos-move/aptos-release-builder/src/components/mod.rs

impl ReleaseConfig {
    pub fn parse(serialized: &str) -> Result<Self> {
        let config: ReleaseConfig = serde_yaml::from_str(serialized)
            .map_err(|e| anyhow!("Failed to parse the config: {:?}", e))?;
        config.validate()?;
        Ok(config)
    }
    
    fn validate(&self) -> Result<()> {
        for proposal in &self.proposals {
            for entry in &proposal.update_sequence {
                entry.validate()?;
            }
        }
        Ok(())
    }
}

impl ReleaseEntry {
    fn validate(&self) -> Result<()> {
        match self {
            ReleaseEntry::Consensus(config) => {
                validate_consensus_config(config)?;
            },
            // ... validate other entry types
            _ => {},
        }
        Ok(())
    }
}

fn validate_consensus_config(config: &OnChainConsensusConfig) -> Result<()> {
    match config {
        OnChainConsensusConfig::V5 { alg, .. } 
        | OnChainConsensusConfig::V4 { alg, .. }
        | OnChainConsensusConfig::V3 { alg, .. } => {
            if let Some(reputation_config) = get_proposer_and_voter_config(alg) {
                ensure!(
                    reputation_config.active_weight > 0,
                    "active_weight must be > 0, got {}",
                    reputation_config.active_weight
                );
                ensure!(
                    reputation_config.inactive_weight > 0,
                    "inactive_weight must be > 0, got {}",
                    reputation_config.inactive_weight
                );
                ensure!(
                    reputation_config.failed_weight > 0,
                    "failed_weight must be > 0, got {}",
                    reputation_config.failed_weight
                );
                ensure!(
                    reputation_config.failure_threshold_percent <= 100,
                    "failure_threshold_percent must be <= 100, got {}",
                    reputation_config.failure_threshold_percent
                );
            }
        },
        _ => {},
    }
    Ok(())
}
```

**Additional Defense - Add runtime check in `choose_index()`:**

Add defensive validation in the critical path:

```rust
// In consensus/src/liveness/proposer_election.rs

pub(crate) fn choose_index(mut weights: Vec<u128>, state: Vec<u8>) -> usize {
    assert!(!weights.is_empty(), "Weights vector cannot be empty");
    
    let mut total_weight = 0;
    for w in &mut weights {
        total_weight = total_weight
            .checked_add(w)
            .expect("Total stake shouldn't exceed u128::MAX");
        *w = total_weight;
    }
    
    assert!(total_weight > 0, "Total weight must be > 0 for leader election");
    
    let chosen_weight = next_in_range(state, total_weight);
    // ... rest of function
}
```

## Proof of Concept

**PoC - Rust Unit Test:**

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_types::on_chain_config::{
        ConsensusAlgorithmConfig, ConsensusConfigV1, OnChainConsensusConfig,
        ProposerAndVoterConfig, ProposerElectionType, LeaderReputationType,
        ValidatorTxnConfig,
    };
    
    #[test]
    #[should_panic(expected = "division by zero")]
    fn test_zero_weights_cause_panic() {
        // Create malformed config with all zero weights
        let malformed_config = ProposerAndVoterConfig {
            active_weight: 0,  // MALICIOUS: set to 0
            inactive_weight: 0,  // MALICIOUS: set to 0
            failed_weight: 0,  // MALICIOUS: set to 0
            failure_threshold_percent: 10,
            proposer_window_num_validators_multiplier: 10,
            voter_window_num_validators_multiplier: 1,
            weight_by_voting_power: true,
            use_history_from_previous_epoch_max_count: 5,
        };
        
        let consensus_config = OnChainConsensusConfig::V5 {
            alg: ConsensusAlgorithmConfig::JolteonV2 {
                main: ConsensusConfigV1 {
                    decoupled_execution: true,
                    back_pressure_limit: 10,
                    exclude_round: 40,
                    max_failed_authors_to_store: 10,
                    proposer_election_type: ProposerElectionType::LeaderReputation(
                        LeaderReputationType::ProposerAndVoterV2(malformed_config)
                    ),
                },
                quorum_store_enabled: true,
                order_vote_enabled: true,
            },
            vtxn: ValidatorTxnConfig::default_enabled(),
            window_size: None,
            rand_check_enabled: true,
        };
        
        // Serialize to YAML as would happen in release config
        let yaml = serde_yaml::to_string(&consensus_config).unwrap();
        
        // Parse via ReleaseConfig::parse() - NO VALIDATION HAPPENS
        let release_config_yaml = format!(
            r#"
name: "malicious_config"
remote_endpoint: null
proposals:
  - name: "consensus_attack"
    execution_mode: MultiStep
    metadata:
      title: "Innocent looking update"
      description: "Updates consensus config"
      source_code_url: "https://github.com/aptos-labs/aptos-core"
      discussion_url: "https://github.com/aptos-labs/aptos-core"
    update_sequence:
      - Consensus: {}
"#,
            yaml
        );
        
        // This parses successfully despite zero weights
        let parsed = ReleaseConfig::parse(&release_config_yaml).unwrap();
        
        // Simulate what happens during leader election
        // All validators get weight 0, even with positive voting power
        let weights = vec![0u128, 0u128, 0u128];  // All zero
        let state = vec![1u8, 2u8, 3u8];
        
        // THIS PANICS with division by zero
        choose_index(weights, state);
    }
}
```

This test demonstrates that:
1. Malformed configs parse successfully through `ReleaseConfig::parse()`
2. When used in leader election, they cause division-by-zero panic
3. All validators would crash simultaneously, halting the network

**Notes**

The vulnerability exists due to the design assumption that YAML deserialization is sufficient validation. However, semantic constraints on consensus parameters are critical for network liveness and must be enforced at parse-time, not discovered at runtime when it's too late to prevent network-wide crashes.

### Citations

**File:** aptos-move/aptos-release-builder/src/components/mod.rs (L751-753)
```rust
    pub fn parse(serialized: &str) -> Result<Self> {
        serde_yaml::from_str(serialized).map_err(|e| anyhow!("Failed to parse the config: {:?}", e))
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L552-575)
```rust
#[derive(Clone, Copy, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct ProposerAndVoterConfig {
    // Selection weight for active validators with proposer failures below threshold
    pub active_weight: u64,
    // Selection weight for inactive validators with proposer failures below threshold
    pub inactive_weight: u64,
    // Selection weight for validators with proposer failures above threshold
    pub failed_weight: u64,
    // Thresholed of failures in the rounds validator was selected to be proposer
    // integer values representing percentages, i.e. 12 is 12%.
    pub failure_threshold_percent: u32,
    // Window into history considered for proposer statistics, multiplier
    // on top of number of validators
    pub proposer_window_num_validators_multiplier: usize,
    // Window into history considered for votre statistics, multiplier
    // on top of number of validators
    pub voter_window_num_validators_multiplier: usize,
    // Flag whether to use voting power as multiplier to the weights
    pub weight_by_voting_power: bool,
    // Flag whether to use history from previous epoch (0 if not),
    // representing a number of historical epochs (beyond the current one)
    // to consider.
    pub use_history_from_previous_epoch_max_count: u32,
}
```

**File:** aptos-move/aptos-release-builder/src/components/consensus_config.rs (L33-45)
```rust
            let consensus_config_blob = bcs::to_bytes(consensus_config).unwrap();
            assert!(consensus_config_blob.len() < 65536);

            emit!(writer, "let consensus_blob: vector<u8> = ");
            generate_blob_as_hex_string(writer, &consensus_config_blob);
            emitln!(writer, ";\n");

            emitln!(
                writer,
                "consensus_config::set_for_next_epoch({}, consensus_blob);",
                signer_arg
            );
            emitln!(writer, "aptos_governance::reconfigure({});", signer_arg);
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```

**File:** consensus/src/liveness/leader_reputation.rs (L522-552)
```rust
    fn get_weights(
        &self,
        epoch: u64,
        epoch_to_candidates: &HashMap<u64, Vec<Author>>,
        history: &[NewBlockEvent],
    ) -> Vec<u64> {
        assert!(epoch_to_candidates.contains_key(&epoch));

        let (votes, proposals, failed_proposals) =
            self.aggregation
                .get_aggregated_metrics(epoch_to_candidates, history, &self.author);

        epoch_to_candidates[&epoch]
            .iter()
            .map(|author| {
                let cur_votes = *votes.get(author).unwrap_or(&0);
                let cur_proposals = *proposals.get(author).unwrap_or(&0);
                let cur_failed_proposals = *failed_proposals.get(author).unwrap_or(&0);

                if cur_failed_proposals * 100
                    > (cur_proposals + cur_failed_proposals) * self.failure_threshold_percent
                {
                    self.failed_weight
                } else if cur_proposals > 0 || cur_votes > 0 {
                    self.active_weight
                } else {
                    self.inactive_weight
                }
            })
            .collect()
    }
```

**File:** consensus/src/liveness/leader_reputation.rs (L710-715)
```rust
        // Multiply weights by voting power:
        let stake_weights: Vec<u128> = weights
            .iter_mut()
            .enumerate()
            .map(|(i, w)| *w as u128 * self.voting_powers[i] as u128)
            .collect();
```

**File:** consensus/src/liveness/proposer_election.rs (L49-59)
```rust
pub(crate) fn choose_index(mut weights: Vec<u128>, state: Vec<u8>) -> usize {
    let mut total_weight = 0;
    // Create cumulative weights vector
    // Since we own the vector, we can safely modify it in place
    for w in &mut weights {
        total_weight = total_weight
            .checked_add(w)
            .expect("Total stake shouldn't exceed u128::MAX");
        *w = total_weight;
    }
    let chosen_weight = next_in_range(state, total_weight);
```
