# Audit Report

## Title
Path Traversal Vulnerability in Dependency Documentation Path Construction

## Summary
The `build_with_external_checks()` function constructs documentation paths (`dep_paths`) from dependency source paths without sanitization, allowing path traversal attacks via `..` components. This can lead to information disclosure and potential arbitrary file operations during documentation generation.

## Finding Description

The vulnerability exists in the path construction logic at lines 352-365 of `built_package.rs`: [1](#0-0) 

The `dep_paths` variable is constructed by taking `source_path` from dependency compiled units, navigating to parent directories via `.parent().unwrap()` calls, and appending `"doc"`. Critically, there is **no path sanitization or canonicalization** performed on these paths.

The root cause traces back to the dependency resolution system where local dependency paths are accepted without validation: [2](#0-1) 

When a local dependency path is specified in `Move.toml`, it's converted directly to a `PathBuf` without checking for traversal sequences. This unsanitized path is then used to construct the dependency's package path: [3](#0-2) 

The `root_path.push(&dep.local)` operation at line 504 concatenates paths without normalization, preserving `..` components. These paths propagate through source file discovery and eventually reach `dep_paths` in the documentation generation code.

The constructed paths are then passed to the documentation generator: [4](#0-3) 

Within the Move docgen system, these paths are used to locate existing documentation files: [5](#0-4) 

**Attack Scenario:**
1. Attacker creates or influences a dependency specification in `Move.toml` with a path like `local = "../../../sensitive/path"`
2. When the package is built with `--with-docs`, the resolution system constructs paths containing unresolved `..` components
3. The operating system resolves these during filesystem operations, causing access outside intended directories
4. Documentation generation can read from or potentially write to arbitrary locations on the filesystem

## Impact Explanation

This vulnerability falls under **Medium** severity per the Aptos bug bounty criteria as it constitutes an **information leak** and potential build-time security issue:

- **Information Disclosure**: Attackers can probe for file existence and potentially read documentation files from arbitrary filesystem locations
- **Build-Time Attack Surface**: While not affecting blockchain runtime consensus or state, it compromises developer build environments
- **Limited Scope**: Requires `--with-docs` flag and specific dependency configurations

This does NOT meet Critical or High severity because:
- No runtime blockchain impact (consensus, state, transactions remain unaffected)
- No loss of funds or validator compromise
- Requires victim interaction (building with specific flags and dependencies)

## Likelihood Explanation

**Likelihood: Low to Medium**

The vulnerability requires specific conditions:
1. Victim must include a dependency with a malicious path specification OR
2. An attacker must control a dependency used by the victim
3. Victim must build with the `--with-docs` flag (not default for production deployments)
4. The traversed path must contain usable information or allow meaningful file operations

However, supply chain attacks on dependency specifications are increasingly common, and developers routinely build packages with documentation enabled during development.

## Recommendation

Implement path sanitization at multiple defense layers:

**1. Immediate Fix - Canonicalize paths in manifest parser:**
```rust
// In manifest_parser.rs around line 346
let local_path = PathBuf::from(local_str);
let canonical = local_path.canonicalize()
    .map_err(|_| format_err!("Invalid local dependency path"))?;
```

**2. Defense in Depth - Sanitize in built_package.rs:**
```rust
// In built_package.rs around line 352
let dep_paths = package
    .deps_compiled_units
    .iter()
    .filter_map(|(_, u)| {
        u.source_path
            .canonicalize()
            .ok()
            .and_then(|p| p.parent())
            .and_then(|p| p.parent())
            .map(|p| p.join("doc").display().to_string())
    })
    .unique()
    .collect::<Vec<_>>();
```

**3. Validation - Reject paths with traversal components:**
```rust
// Add to dependency validation
fn validate_dependency_path(path: &Path) -> Result<()> {
    if path.components().any(|c| matches!(c, std::path::Component::ParentDir)) {
        bail!("Dependency paths cannot contain '..' components");
    }
    Ok(())
}
```

## Proof of Concept

Create a malicious Move package structure:

```bash
# Setup malicious dependency structure
mkdir -p /tmp/test_project/malicious_dep
cd /tmp/test_project

# Create victim project
mkdir victim_project
cd victim_project

# Victim's Move.toml with traversal path
cat > Move.toml << 'EOF'
[package]
name = "Victim"
version = "1.0.0"

[dependencies]
MaliciousDep = { local = "../malicious_dep/../../../etc" }
EOF

# If /etc contains readable files, building with --with-docs
# will cause dep_paths to include /etc/doc or similar traversed paths
aptos move compile --with-docs
```

The above demonstrates that unsanitized paths from `Move.toml` flow through to documentation generation, enabling filesystem traversal outside the intended project directory structure.

## Notes

While this vulnerability has limited direct blockchain impact, it represents a genuine security flaw in the build tooling that could be exploited in supply chain attacks or to compromise developer environments. The fix should be implemented as part of defensive programming best practices, even though it doesn't affect runtime blockchain consensus or state.

### Citations

**File:** aptos-move/framework/src/built_package.rs (L352-366)
```rust
                let dep_paths = package
                    .deps_compiled_units
                    .iter()
                    .map(|(_, u)| {
                        u.source_path
                            .parent()
                            .unwrap()
                            .parent()
                            .unwrap()
                            .join("doc")
                            .display()
                            .to_string()
                    })
                    .unique()
                    .collect::<Vec<_>>();
```

**File:** third_party/move/tools/move-package/src/source_package/manifest_parser.rs (L342-354)
```rust
                (Some(local), None, None) => {
                    let local_str = local
                        .as_str()
                        .ok_or_else(|| format_err!("Local source path not a string"))?;
                    let local_path = PathBuf::from(local_str);
                    Ok(PM::Dependency {
                        subst,
                        version,
                        digest,
                        local: local_path,
                        git_info,
                        node_info,
                    })
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L499-517)
```rust
    fn parse_package_manifest(
        dep: &Dependency,
        dep_name: &PackageName,
        mut root_path: PathBuf,
    ) -> Result<(SourceManifest, PathBuf)> {
        root_path.push(&dep.local);
        match fs::read_to_string(root_path.join(SourcePackageLayout::Manifest.path())) {
            Ok(contents) => {
                let source_package: SourceManifest =
                    parse_move_manifest_string(contents).and_then(parse_source_manifest)?;
                Ok((source_package, root_path))
            },
            Err(_) => Err(anyhow::format_err!(
                "Unable to find package manifest for '{}' at {:?}",
                dep_name,
                SourcePackageLayout::Manifest.path().join(root_path),
            )),
        }
    }
```

**File:** aptos-move/framework/src/docgen.rs (L59-82)
```rust
    pub fn run(
        &self,
        package_path: String,
        doc_path: Vec<String>,
        model: &GlobalEnv,
    ) -> anyhow::Result<()> {
        // To get relative paths right, we need to run docgen with relative paths. To this
        // end we need to set the current directory of the process. This in turn is not thread
        // safe, so we need to make a critical section out of the entire generation process.
        // TODO: fix this in docgen
        static MUTEX: Mutex<u8> = Mutex::new(0);
        let _lock = MUTEX.lock();
        let current_dir = std::env::current_dir()?.canonicalize()?;
        std::env::set_current_dir(&package_path)?;
        let output_directory = PathBuf::from("doc");
        let doc_path = doc_path
            .into_iter()
            .filter_map(|s| {
                PathBuf::from(s)
                    .strip_prefix(&package_path)
                    .map(|p| p.display().to_string())
                    .ok()
            })
            .collect();
```

**File:** third_party/move/move-prover/move-docgen/src/docgen.rs (L514-523)
```rust
            // Try to locate the file in the provided search path.
            self.options.doc_path.iter().find_map(|dir| {
                let mut path = PathBuf::from(dir);
                path.push(&file_name);
                if path.exists() {
                    Some(self.path_to_string(self.path_relative_to(&path, &output_path).as_path()))
                } else {
                    None
                }
            })
```
