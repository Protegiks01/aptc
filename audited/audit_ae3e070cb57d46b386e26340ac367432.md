# Audit Report

## Title
Missing Voter Address Validation Allows Role Conflicts and Voting Power Accumulation in Genesis Configuration

## Summary
The genesis configuration validation in `crates/aptos/src/genesis/mod.rs` fails to validate voter addresses for uniqueness or check them against employee accounts. This allows employee accounts to serve as voter addresses and permits a single voter address to be assigned to multiple validators, enabling governance manipulation through voting power accumulation.

## Finding Description

The genesis validation logic validates owner and operator addresses for uniqueness but completely omits voter address validation. [1](#0-0) 

The validation checks `unique_accounts` for owner and operator addresses but never checks or adds voter addresses. Meanwhile, employee accounts are added to this same set: [2](#0-1) 

This creates two distinct vulnerabilities:

**Vulnerability 1: Employee-Voter Role Conflict**
An employee account can be designated as a voter address without triggering any validation error. During genesis:
- The employee account receives initial balance
- `create_employee_validators` withdraws all funds into the vesting contract
- The same account is set as voter for a validator's stake pool [3](#0-2) [4](#0-3) 

**Vulnerability 2: Voter Address Reuse Across Multiple Validators**
The same voter address can be assigned to multiple validators (employee pools and/or regular validators). The governance voting mechanism allows each stake pool to vote independently: [5](#0-4) 

Since voting power is calculated per stake pool and votes are recorded per `(stake_pool, proposal_id)` pair: [6](#0-5) 

A single voter address delegated to multiple stake pools can vote multiple times on the same proposal, accumulating voting power from all controlled pools.

## Impact Explanation

**High Severity** - This constitutes a significant protocol violation affecting governance integrity:

1. **Governance Power Manipulation**: A single entity controlling one voter key can accumulate voting power from multiple stake pools, enabling:
   - Disproportionate influence over governance proposals
   - Potential to reach voting thresholds through centralized control
   - Circumvention of intended decentralization guarantees

2. **Role Conflict Security Risks**: Employee accounts with vesting restrictions serving as voters create:
   - Economic interest misalignment (vested funds vs immediate voting power)
   - Increased attack surface if employee account key is compromised
   - Confusion about accountability and ownership

3. **Centralization Risk**: Multiple validators sharing a voter creates single points of failure where one compromised key affects multiple validators' governance participation.

This breaks the **Governance Integrity** invariant that "Voting power must be correctly calculated from stake" by allowing artificial accumulation across pools under single control.

## Likelihood Explanation

**High Likelihood**: This vulnerability can occur through:

1. **Unintentional Configuration Error**: Genesis operators may unknowingly reuse voter addresses across validators or use employee accounts as voters, especially given the lack of validation feedback.

2. **Intentional Exploitation**: Malicious genesis participants could deliberately configure overlapping voter addresses to concentrate governance power.

3. **No Technical Barriers**: The configuration is set during genesis through YAML files with no validation preventing this pattern.

The issue affects mainnet genesis configuration where these assignments become permanent and cannot be easily changed without coordination.

## Recommendation

Add voter address validation to the `validate_validators` function to ensure:
1. Voter addresses are unique across all validators
2. Voter addresses don't overlap with employee accounts
3. Voter addresses don't overlap with owner/operator addresses

**Recommended Fix** in `crates/aptos/src/genesis/mod.rs`:

```rust
// After line 691, add voter address validation:
if unique_accounts.contains(&validator.voter_account_address.into()) {
    errors.push(CliError::UnexpectedError(format!(
        "Voter '{}' in validator {} has already been seen elsewhere",
        validator.voter_account_address, name
    )));
}
unique_accounts.insert(validator.voter_account_address.into());
```

Additionally, add validation in `validate_employee_accounts` to check that employee pool validator addresses (owner/operator/voter) don't overlap with employee accounts:

```rust
// In validate_employee_accounts, after line 927:
for account in pool.accounts.iter() {
    if *account == pool.validator.validator.owner_address 
        || *account == pool.validator.validator.operator_address
        || *account == pool.validator.validator.voter_address {
        return Err(CliError::UnexpectedError(format!(
            "Employee account {} in pool #{} cannot also be a validator owner/operator/voter",
            account, i
        )));
    }
}
```

## Proof of Concept

Create two genesis configuration files demonstrating the vulnerability:

**employee_vesting_accounts.yaml:**
```yaml
- accounts: ["0xEMPLOYEE1", "0xEMPLOYEE2"]
  validator:
    owner_account_address: "0xOWNER1"
    operator_account_address: "0xOPERATOR1"
    voter_account_address: "0xEMPLOYEE1"  # Employee as voter
    stake_amount: 1000000000000
    commission_percentage: 10
    join_during_genesis: true
  vesting_schedule_numerators: [25, 25, 25, 25]
  vesting_schedule_denominator: 100
  beneficiary_resetter: "0xRESETTER"
```

**validators.yaml (user configurations):**
```yaml
- owner_account_address: "0xVALIDATOR_OWNER"
  operator_account_address: "0xVALIDATOR_OPERATOR"
  voter_account_address: "0xEMPLOYEE1"  # Same voter as employee pool
  stake_amount: 5000000000000
  commission_percentage: 10
  join_during_genesis: true
```

With this configuration:
1. Account `0xEMPLOYEE1` is both an employee and a voter for two different stake pools
2. Genesis validation passes without errors
3. After genesis, `0xEMPLOYEE1` can vote on governance proposals with combined voting power from both stake pools (6,000 APT voting power from a single account)
4. This violates governance integrity by allowing voting power accumulation

**Notes**

The vulnerability exists because voter address validation was omitted from the uniqueness checks that properly validate owner and operator addresses. This is a genesis-time configuration vulnerability that creates permanent governance centralization risks. The fix requires adding voter addresses to the same validation logic that already exists for owners and operators.

### Citations

**File:** crates/aptos/src/genesis/mod.rs (L677-691)
```rust
        if unique_accounts.contains(&validator.owner_account_address.into()) {
            errors.push(CliError::UnexpectedError(format!(
                "Owner '{}' in validator {} has already been seen elsewhere",
                validator.owner_account_address, name
            )));
        }
        unique_accounts.insert(validator.owner_account_address.into());

        if unique_accounts.contains(&validator.operator_account_address.into()) {
            errors.push(CliError::UnexpectedError(format!(
                "Operator '{}' in validator {} has already been seen elsewhere",
                validator.operator_account_address, name
            )));
        }
        unique_accounts.insert(validator.operator_account_address.into());
```

**File:** crates/aptos/src/genesis/mod.rs (L892-898)
```rust
            if unique_accounts.contains(account) {
                return Err(CliError::UnexpectedError(format!(
                    "Account #{} '{}' in employee pool #{} has already been seen elsewhere",
                    j, account, i
                )));
            }
            unique_accounts.insert(*account);
```

**File:** aptos-move/framework/aptos-framework/sources/genesis.move (L231-234)
```text
                let employee = create_signer(*account);
                let total = coin::balance<AptosCoin>(*account);
                let coins = coin::withdraw<AptosCoin>(&employee, total);
                simple_map::add(&mut buy_ins, *account, coins);
```

**File:** aptos-move/framework/aptos-framework/sources/genesis.move (L257-266)
```text
            let admin = employee_group.validator.validator_config.owner_address;
            let admin_signer = &create_signer(admin);
            let contract_address = vesting::create_vesting_contract(
                admin_signer,
                &employee_group.accounts,
                buy_ins,
                vesting_schedule,
                admin,
                employee_group.validator.validator_config.operator_address,
                employee_group.validator.validator_config.voter_address,
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L539-558)
```text
    fun vote_internal(
        voter: &signer,
        stake_pool: address,
        proposal_id: u64,
        voting_power: u64,
        should_pass: bool,
    ) acquires ApprovedExecutionHashes, VotingRecords, VotingRecordsV2, GovernanceEvents {
        permissioned_signer::assert_master_signer(voter);
        let voter_address = signer::address_of(voter);
        assert!(stake::get_delegated_voter(stake_pool) == voter_address, error::invalid_argument(ENOT_DELEGATED_VOTER));

        assert_proposal_expiration(stake_pool, proposal_id);

        // If a stake pool has already voted on a proposal before partial governance voting is enabled,
        // `get_remaining_voting_power` returns 0.
        let staking_pool_voting_power = get_remaining_voting_power(stake_pool, proposal_id);
        voting_power = min(voting_power, staking_pool_voting_power);

        // Short-circuit if the voter has no voting power.
        assert!(voting_power > 0, error::invalid_argument(ENO_VOTING_POWER));
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L568-574)
```text
        let record_key = RecordKey {
            stake_pool,
            proposal_id,
        };
        let used_voting_power = VotingRecordsV2[@aptos_framework].votes.borrow_mut_with_default(record_key, 0);
        // This calculation should never overflow because the used voting cannot exceed the total voting power of this stake pool.
        *used_voting_power += voting_power;
```
