# Audit Report

## Title
Consensus Observer Bypasses Signature Verification for Future-Epoch CommitDecisions Enabling Critical State Corruption

## Summary
The consensus observer component accepts `CommitDecision` messages from subscribed peers and skips signature verification when the epoch doesn't match the current epoch. These unverified commit decisions are then used to corrupt critical node state including the execution client's logical time and buffer manager's committed round tracking, leading to permanent node dysfunction.

## Finding Description

The vulnerability exists in how the consensus observer processes `CommitDecision` messages. When a `CommitDecision` is received: [1](#0-0) 

The `CommitDecision` struct derives `Deserialize`, allowing it to be deserialized directly from network messages without any validation. The struct has a `verify()` method that checks signatures: [2](#0-1) 

However, in the consensus observer's message processing flow, verification is conditionally skipped: [3](#0-2) 

When `commit_epoch != epoch_state.epoch` (lines 468-470), the verification at line 470 is skipped entirely. However, the unverified `CommitDecision` is still used: [4](#0-3) 

At line 526, the unverified `commit_decision` is passed to `sync_to_commit()`, which triggers state sync with this malicious data. This leads to state corruption in multiple ways:

1. **Buffer Manager Reset with Unverified Round**: [5](#0-4) 

At lines 688 and 701, `target.commit_info().round()` extracts the round from the UNVERIFIED target and uses it to reset the buffer manager: [6](#0-5) 

Lines 586-587 set `highest_committed_round` and `latest_round` to the attacker-controlled value without any validation.

2. **Logical Time Corruption**: [7](#0-6) 

At line 181, the unverified target's epoch and round are used to construct `target_logical_time`, and at line 222, the node's `latest_logical_time` is updated to these malicious values.

3. **Unverified Block Data Updates**: [8](#0-7) 

At line 282, the observer's root ledger info is updated with the unverified commit proof, corrupting the baseline state reference.

**Attack Scenario:**
1. Attacker runs a node that connects to a VFN observer (on public network or as compromised VFN)
2. Attacker's node advertises support for consensus observer protocol
3. VFN observer subscribes to attacker's node (based on peer selection)
4. Attacker sends `CommitDecision` with:
   - `epoch = current_epoch + 1` (bypasses verification check)
   - `round = u64::MAX - 100` 
   - `version = u64::MAX - 100`
   - Invalid or missing signatures
5. Observer skips verification (different epoch)
6. Observer's buffer manager committed rounds set to `u64::MAX - 100`
7. Observer's logical time set to `(current_epoch + 1, u64::MAX - 100)`
8. State sync triggered to unreachable version
9. Observer node state is permanently corrupted and cannot process legitimate blocks

## Impact Explanation

This vulnerability has **High Severity** impact:

1. **VFN Observer Node Dysfunction**: The corrupted logical time and buffer manager state prevent the node from processing any legitimate consensus messages, as they would all have lower logical time values than the corrupted state.

2. **API Service Disruption**: VFN observers serve API requests for applications. When corrupted, they cannot provide accurate blockchain state, causing "API crashes" per the High severity criteria.

3. **Back Pressure Logic Corruption**: The buffer manager's `need_back_pressure()` function uses `highest_committed_round` in arithmetic that could underflow/overflow with malicious values.

This meets the **High Severity** criteria: "Validator node slowdowns" and "API crashes" as VFN observers become non-functional and cannot serve their role in the network.

## Likelihood Explanation

**Likelihood: Medium**

The attack requires:
- Attacker to operate a node that can connect to target VFN observers
- Attacker's node to be selected as a subscription peer (competitive with other available peers)
- Knowledge of the current epoch to craft future-epoch messages

However, exploitation is **feasible** because:
- VFN observers by default enable both observer and publisher features
- Peer selection is based on distance/latency metrics, not strict trust requirements
- Public fullnodes can potentially be subscription candidates
- A compromised VFN could act as the attack vector

## Recommendation

**Fix 1: Always Verify Signatures Before Any Use**

Modify the consensus observer to verify all `CommitDecision` messages regardless of epoch:

```rust
// In consensus_observer.rs, process_commit_decision_message()
pub fn process_commit_decision_message(
    &mut self,
    peer_network_id: PeerNetworkId,
    message_received_time: Instant,
    commit_decision: CommitDecision,
) {
    let commit_epoch = commit_decision.epoch();
    let commit_round = commit_decision.round();
    
    // Get the epoch state for verification
    let epoch_state = self.get_epoch_state();
    
    // ALWAYS verify commit decision before any use
    // For future epochs, verify against the validator set if available,
    // or reject if we don't have the epoch state
    let verification_result = if commit_epoch == epoch_state.epoch {
        commit_decision.verify_commit_proof(&epoch_state)
    } else if commit_epoch > epoch_state.epoch {
        // For future epochs, we cannot verify yet - reject
        Err(Error::InvalidMessageError(format!(
            "Cannot verify commit decision for future epoch {}, current epoch: {}",
            commit_epoch, epoch_state.epoch
        )))
    } else {
        // For past epochs, reject as stale
        Err(Error::InvalidMessageError(format!(
            "Received commit decision for past epoch {}",
            commit_epoch
        )))
    };
    
    if let Err(error) = verification_result {
        error!(
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Failed to verify commit decision! Ignoring: {:?}. Error: {:?}",
                commit_decision.proof_block_info(),
                error
            ))
        );
        increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
        return;
    }
    
    // ... rest of processing only if verification passed
}
```

**Fix 2: Add Validation in State Sync Target Acceptance**

Add validation in `execution_client.rs` before accepting sync targets:

```rust
async fn sync_to_target(&self, target: LedgerInfoWithSignatures) -> Result<(), StateSyncError> {
    // Validate target version is reasonable
    let latest_version = self.storage.get_latest_version()?;
    ensure!(
        target.ledger_info().version() > latest_version,
        "Sync target version {} must be greater than current version {}",
        target.ledger_info().version(),
        latest_version
    );
    
    // Validate target is not unreasonably far in the future
    const MAX_VERSION_JUMP: u64 = 1_000_000; // configurable threshold
    ensure!(
        target.ledger_info().version() - latest_version < MAX_VERSION_JUMP,
        "Sync target version {} is too far ahead of current version {}",
        target.ledger_info().version(),
        latest_version
    );
    
    // ... rest of sync_to_target logic
}
```

## Proof of Concept

```rust
// Proof of Concept test demonstrating the vulnerability
// Place in consensus/src/consensus_observer/observer/consensus_observer_test.rs

#[tokio::test]
async fn test_unverified_future_epoch_commit_decision_corruption() {
    // Setup: Create a consensus observer with current epoch = 5
    let (mut observer, _network_rx) = create_test_consensus_observer(5).await;
    
    // Create a malicious CommitDecision with future epoch
    let malicious_epoch = 6; // Future epoch bypasses verification
    let malicious_round = u64::MAX - 100;
    let malicious_version = u64::MAX - 100;
    
    let malicious_commit_info = BlockInfo::new(
        malicious_epoch,
        malicious_round,
        HashValue::random(),
        HashValue::random(),
        malicious_version,
        0, // timestamp
        None, // epoch_state
    );
    
    let malicious_ledger_info = LedgerInfo::new(
        malicious_commit_info,
        HashValue::zero(),
    );
    
    // Create LedgerInfoWithSignatures with INVALID/EMPTY signatures
    let malicious_ledger_info_with_sigs = LedgerInfoWithSignatures::new(
        malicious_ledger_info,
        AggregateSignature::empty(), // Invalid signature!
    );
    
    let malicious_commit_decision = CommitDecision::new(
        malicious_ledger_info_with_sigs
    );
    
    // Get buffer manager state before attack
    let buffer_manager_state_before = observer.get_buffer_manager_state();
    let logical_time_before = observer.get_logical_time();
    
    // Send malicious commit decision to observer
    let peer_network_id = PeerNetworkId::random();
    observer.process_commit_decision_message(
        peer_network_id,
        Instant::now(),
        malicious_commit_decision,
    );
    
    // Verify state corruption
    let buffer_manager_state_after = observer.get_buffer_manager_state();
    let logical_time_after = observer.get_logical_time();
    
    // ASSERTION: Buffer manager's committed round is corrupted
    assert_eq!(
        buffer_manager_state_after.highest_committed_round,
        malicious_round,
        "Buffer manager highest_committed_round should be corrupted to malicious value"
    );
    
    // ASSERTION: Logical time is corrupted
    assert_eq!(
        logical_time_after.epoch(),
        malicious_epoch,
        "Logical time epoch should be corrupted to malicious value"
    );
    assert_eq!(
        logical_time_after.round(),
        malicious_round,
        "Logical time round should be corrupted to malicious value"
    );
    
    // ASSERTION: Observer can no longer process legitimate blocks
    let legitimate_block = create_test_block(5, 100); // Current epoch, reasonable round
    let result = observer.process_ordered_block(legitimate_block).await;
    assert!(
        result.is_err(),
        "Observer should reject legitimate blocks after state corruption"
    );
}
```

## Notes

1. The vulnerability specifically affects the **consensus observer component**, which is enabled by default on VFN (Validator Full Node) nodes. It does not directly affect validator consensus.

2. The main consensus path (non-observer) has better protection: while `epoch()` is accessed before full verification in `epoch_manager.rs`, the actual processing only happens after verification in the buffer manager's verification task.

3. The consensus observer's design assumes subscribed peers are trusted, but the peer selection mechanism doesn't enforce sufficient trust guarantees - any peer supporting the protocol can potentially be selected.

4. This vulnerability demonstrates a classic "use-before-verify" pattern where deserialized data from an untrusted source is used to make critical state updates before cryptographic verification occurs.

### Citations

**File:** consensus/consensus-types/src/pipeline/commit_decision.rs (L10-13)
```rust
#[derive(Deserialize, Serialize, Clone, PartialEq, Eq)]
pub struct CommitDecision {
    ledger_info: LedgerInfoWithSignatures,
}
```

**File:** consensus/consensus-types/src/pipeline/commit_decision.rs (L49-59)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        ensure!(
            !self.ledger_info.commit_info().is_ordered_only(),
            "Unexpected ordered only commit info"
        );
        // We do not need to check the author because as long as the signature tree
        // is valid, the message should be valid.
        self.ledger_info
            .verify_signatures(validator)
            .context("Failed to verify Commit Decision")
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L448-470)
```rust
        // Get the commit decision epoch and round
        let commit_epoch = commit_decision.epoch();
        let commit_round = commit_decision.round();

        // If the commit message is behind our highest committed block, ignore it
        let get_highest_committed_epoch_round = self
            .observer_block_data
            .lock()
            .get_highest_committed_epoch_round();
        if (commit_epoch, commit_round) <= get_highest_committed_epoch_round {
            // Update the metrics for the dropped commit decision
            update_metrics_for_dropped_commit_decision_message(peer_network_id, &commit_decision);
            return;
        }

        // Update the metrics for the received commit decision
        update_metrics_for_commit_decision_message(peer_network_id, &commit_decision);

        // If the commit decision is for the current epoch, verify and process it
        let epoch_state = self.get_epoch_state();
        if commit_epoch == epoch_state.epoch {
            // Verify the commit decision
            if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L500-527)
```rust
        // Otherwise, we failed to process the commit decision. If the commit
        // is for a future epoch or round, we need to state sync.
        let last_block = self.observer_block_data.lock().get_last_ordered_block();
        let epoch_changed = commit_epoch > last_block.epoch();
        if epoch_changed || commit_round > last_block.round() {
            // If we're waiting for state sync to transition into a new epoch,
            // we should just wait and not issue a new state sync request.
            if self.state_sync_manager.is_syncing_through_epoch() {
                info!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Already waiting for state sync to reach new epoch: {:?}. Dropping commit decision: {:?}!",
                        self.observer_block_data.lock().root().commit_info(),
                        commit_decision.proof_block_info()
                    ))
                );
                return;
            }

            // Otherwise, we should start the state sync process for the commit.
            // Update the block data (to the commit decision).
            self.observer_block_data
                .lock()
                .update_blocks_for_state_sync_commit(&commit_decision);

            // Start state syncing to the commit decision
            self.state_sync_manager
                .sync_to_commit(commit_decision, epoch_changed);
        }
```

**File:** consensus/src/pipeline/execution_client.rs (L674-709)
```rust
    async fn reset(&self, target: &LedgerInfoWithSignatures) -> Result<()> {
        let (reset_tx_to_rand_manager, reset_tx_to_buffer_manager) = {
            let handle = self.handle.read();
            (
                handle.reset_tx_to_rand_manager.clone(),
                handle.reset_tx_to_buffer_manager.clone(),
            )
        };

        if let Some(mut reset_tx) = reset_tx_to_rand_manager {
            let (ack_tx, ack_rx) = oneshot::channel::<ResetAck>();
            reset_tx
                .send(ResetRequest {
                    tx: ack_tx,
                    signal: ResetSignal::TargetRound(target.commit_info().round()),
                })
                .await
                .map_err(|_| Error::RandResetDropped)?;
            ack_rx.await.map_err(|_| Error::RandResetDropped)?;
        }

        if let Some(mut reset_tx) = reset_tx_to_buffer_manager {
            // reset execution phase and commit phase
            let (tx, rx) = oneshot::channel::<ResetAck>();
            reset_tx
                .send(ResetRequest {
                    tx,
                    signal: ResetSignal::TargetRound(target.commit_info().round()),
                })
                .await
                .map_err(|_| Error::ResetDropped)?;
            rx.await.map_err(|_| Error::ResetDropped)?;
        }

        Ok(())
    }
```

**File:** consensus/src/pipeline/buffer_manager.rs (L583-591)
```rust
        match signal {
            ResetSignal::Stop => self.stop = true,
            ResetSignal::TargetRound(round) => {
                self.highest_committed_round = round;
                self.latest_round = round;

                let _ = self.drain_pending_commit_proof_till(round);
            },
        }
```

**File:** consensus/src/state_computer.rs (L177-222)
```rust
    async fn sync_to_target(&self, target: LedgerInfoWithSignatures) -> Result<(), StateSyncError> {
        // Grab the logical time lock and calculate the target logical time
        let mut latest_logical_time = self.write_mutex.lock().await;
        let target_logical_time =
            LogicalTime::new(target.ledger_info().epoch(), target.ledger_info().round());

        // Before state synchronization, we have to call finish() to free the
        // in-memory SMT held by BlockExecutor to prevent a memory leak.
        self.executor.finish();

        // The pipeline phase already committed beyond the target block timestamp, just return.
        if *latest_logical_time >= target_logical_time {
            warn!(
                "State sync target {:?} is lower than already committed logical time {:?}",
                target_logical_time, *latest_logical_time
            );
            return Ok(());
        }

        // This is to update QuorumStore with the latest known commit in the system,
        // so it can set batches expiration accordingly.
        // Might be none if called in the recovery path, or between epoch stop and start.
        if let Some(inner) = self.state.read().as_ref() {
            let block_timestamp = target.commit_info().timestamp_usecs();
            inner
                .payload_manager
                .notify_commit(block_timestamp, Vec::new());
        }

        // Inject an error for fail point testing
        fail_point!("consensus::sync_to_target", |_| {
            Err(anyhow::anyhow!("Injected error in sync_to_target").into())
        });

        // Invoke state sync to synchronize to the specified target. Here, the
        // ChunkExecutor will process chunks and commit to storage. However, after
        // block execution and commits, the internal state of the ChunkExecutor may
        // not be up to date. So, it is required to reset the cache of the
        // ChunkExecutor in state sync when requested to sync.
        let result = monitor!(
            "sync_to_target",
            self.state_sync_notifier.sync_to_target(target).await
        );

        // Update the latest logical time
        *latest_logical_time = target_logical_time;
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L275-291)
```rust
    pub fn update_blocks_for_state_sync_commit(&mut self, commit_decision: &CommitDecision) {
        // Get the commit proof, epoch and round
        let commit_proof = commit_decision.commit_proof();
        let commit_epoch = commit_decision.epoch();
        let commit_round = commit_decision.round();

        // Update the root
        self.update_root(commit_proof.clone());

        // Update the block payload store
        self.block_payload_store
            .remove_blocks_for_epoch_round(commit_epoch, commit_round);

        // Update the ordered block store
        self.ordered_block_store
            .remove_blocks_for_commit(commit_proof);
    }
```
