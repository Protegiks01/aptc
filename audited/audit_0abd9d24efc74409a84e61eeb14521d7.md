# Audit Report

## Title
Consensus Non-Determinism via Storage Error Misinterpretation in On-Chain Config Fetching

## Summary
The `ConfigStorage` implementation for `StateView` silently converts all storage errors (I/O failures, pruning errors, database corruption) into `None`, treating them identically to legitimately missing configuration keys. This causes validators experiencing transient or persistent storage errors to fall back to default configuration values while other validators use the actual on-chain configs, leading to non-deterministic transaction execution and consensus divergence.

## Finding Description

The vulnerability exists in the `ConfigStorage` trait implementation for `StateView`: [1](#0-0) 

The problematic line uses `.ok()?` which converts `Result<Option<StateValue>, StateViewError>` to `Option<Option<StateValue>>`, collapsing all error cases into `None`:

- `Ok(Some(value))` → continues to return `Some(bytes)`
- `Ok(None)` → returns `None` (config doesn't exist - **expected**)
- `Err(StateViewError)` → returns `None` (I/O error - **incorrectly treated as missing config**)

**Storage errors can originate from:**

1. **RocksDB I/O failures** during iterator operations: [2](#0-1) 

2. **Pruning errors** when requested versions have been pruned: [3](#0-2) [4](#0-3) 

3. **State proof verification failures** in DbStateView: [5](#0-4) 

**The error type definition confirms multiple failure modes:** [6](#0-5) 

**Critical Impact on VM Execution:**

During block execution, `AptosEnvironment::new()` fetches consensus-critical configs using `fetch_config_and_update_hash()`: [7](#0-6) 

The function uses `.unwrap_or_default()` for `Features` config and `.unwrap_or_else()` for others: [8](#0-7) 

**Concrete Consensus Divergence Scenario:**

1. Validator A experiences a transient disk I/O error when reading the `Features` on-chain config at block N
2. The error propagates: `RocksDB error` → `StateViewError::Other` → `.ok()?` → `None` → `Features::default()`
3. Validator B reads successfully and gets the actual on-chain `Features` config
4. The on-chain `Features` has `AGGREGATOR_V2_DELAYED_FIELDS` enabled (not in default): [9](#0-8) 

5. Validator A uses default features (without `AGGREGATOR_V2_DELAYED_FIELDS`)
6. Validator B uses actual features (with `AGGREGATOR_V2_DELAYED_FIELDS`)
7. They execute transactions differently, produce different state roots, and **fail to reach consensus**

**The same issue affects:**
- `GasScheduleV2` - different gas metering behavior
- `ExecutionConfig` - different transaction execution parameters  
- `ConsensusConfig` - different consensus behavior
- `ChainId` - affects signature verification

Similar issues occur in consensus observer: [10](#0-9) 

## Impact Explanation

**CRITICAL SEVERITY - Consensus Safety Violation**

This vulnerability breaks the **Deterministic Execution** invariant: "All validators must produce identical state roots for identical blocks."

When validators experience different storage errors at different times, they will:
1. Execute the same transactions with different VM configurations
2. Produce different state roots for identical block contents
3. Be unable to reach 2/3+ agreement on the block
4. Cause consensus liveness failures or chain splits

This meets the **Critical Severity** category per Aptos bug bounty:
- **Consensus/Safety violations** - Different validators execute blocks non-deterministically
- **Potential network partition** - Could require manual intervention or coordination

The impact is **NOT limited** to a single validator - any validator experiencing storage issues will diverge from the network, and if 1/3+ validators have issues simultaneously, consensus completely fails.

## Likelihood Explanation

**Likelihood: MEDIUM**

While individual I/O errors are relatively rare, the conditions for this bug to cause consensus divergence are realistic:

**Factors increasing likelihood:**
1. **Disk failures occur naturally** in production environments
2. **Transient I/O errors** from overloaded storage systems
3. **Pruning configuration differences** between validators can cause pruning errors
4. **Database corruption** from power failures or hardware issues
5. **Multiple validators** increase probability that at least one experiences issues
6. **No monitoring/alerting** for this specific error condition

**Factors decreasing likelihood:**
1. Most validators run on reliable infrastructure
2. Storage errors are typically caught and logged elsewhere
3. Database implementations are generally robust

However, the **severity is so high** that even a low-probability consensus divergence is unacceptable.

## Recommendation

**Fix 1: Propagate errors properly instead of converting to `None`**

Change the `ConfigStorage` implementation to distinguish between missing configs and storage errors:

```rust
impl<S: StateView> ConfigStorage for S {
    fn fetch_config_bytes(&self, state_key: &StateKey) -> Option<Bytes> {
        // CHANGED: Use ? to propagate errors, only convert Ok(None) to None
        self.get_state_value(state_key)
            .expect("Storage error when fetching on-chain config - this should halt the validator")
            .map(|s| s.bytes().clone())
    }
}
```

However, this changes the return type semantics. Better approach:

**Fix 2: Change `ConfigStorage` trait to return `Result`**

```rust
pub trait ConfigStorage {
    fn fetch_config_bytes(&self, state_key: &StateKey) -> Result<Option<Bytes>, StateViewError>;
}

impl<S: StateView> ConfigStorage for S {
    fn fetch_config_bytes(&self, state_key: &StateKey) -> Result<Option<Bytes>, StateViewError> {
        Ok(self.get_state_value(state_key)?.map(|s| s.bytes().clone()))
    }
}
```

Then update all callers to handle errors explicitly:

```rust
fn fetch_config_and_update_hash<T: OnChainConfig>(
    sha3_256: &mut Sha3_256,
    state_view: &impl StateView,
) -> Result<Option<T>> {
    let state_key = StateKey::on_chain_config::<T>()?;
    let bytes = state_view.fetch_config_bytes(&state_key)?
        .ok_or_else(|| anyhow!("Required config {} not found", T::CONFIG_ID))?;
    sha3_256.update(&bytes);
    Ok(Some(T::deserialize_into_config(&bytes)?))
}
```

**Fix 3: Add explicit error handling in VM initialization**

In `AptosEnvironment::new()`, fail-fast on storage errors instead of silently using defaults:

```rust
let features = fetch_config_and_update_hash::<Features>(&mut sha3_256, state_view)
    .expect("CRITICAL: Storage error fetching Features config - halting validator")
    .unwrap_or_default();
```

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_types::{
        on_chain_config::{Features, OnChainConfig},
        state_store::{
            state_key::StateKey, 
            state_value::StateValue,
            StateViewError, StateViewResult, TStateView,
        },
    };
    use std::collections::HashMap;

    // Mock StateView that simulates I/O errors
    struct ErrorStateView {
        should_error: bool,
        data: HashMap<StateKey, StateValue>,
    }

    impl TStateView for ErrorStateView {
        type Key = StateKey;

        fn get_state_value(&self, key: &StateKey) -> StateViewResult<Option<StateValue>> {
            if self.should_error {
                // Simulate I/O error
                Err(StateViewError::Other("Simulated disk I/O error".to_string()))
            } else {
                Ok(self.data.get(key).cloned())
            }
        }

        fn get_usage(&self) -> StateViewResult<aptos_types::state_store::state_storage_usage::StateStorageUsage> {
            unimplemented!()
        }
    }

    #[test]
    fn test_io_error_misinterpreted_as_missing_config() {
        // Setup: Create actual Features config with specific features enabled
        let mut features = Features::default();
        features.enable(FeatureFlag::AGGREGATOR_V2_DELAYED_FIELDS);
        
        let state_key = StateKey::on_chain_config::<Features>().unwrap();
        let bytes = bcs::to_bytes(&features).unwrap();
        let state_value = StateValue::new_legacy(bytes.into());
        
        let mut data = HashMap::new();
        data.insert(state_key.clone(), state_value);

        // Scenario 1: Normal operation - config is fetched correctly
        let view_ok = ErrorStateView { should_error: false, data: data.clone() };
        let fetched = Features::fetch_config(&view_ok);
        assert!(fetched.is_some());
        assert!(fetched.unwrap().is_enabled(FeatureFlag::AGGREGATOR_V2_DELAYED_FIELDS));

        // Scenario 2: I/O error occurs - BUG: treated as missing config
        let view_error = ErrorStateView { should_error: true, data: data.clone() };
        let fetched_with_error = Features::fetch_config(&view_error);
        
        // BUG: This returns None even though the config exists!
        assert!(fetched_with_error.is_none());
        
        // This causes different validators to use different configs:
        // Validator A (I/O error): Uses Features::default()
        // Validator B (no error): Uses actual on-chain Features
        
        let default_features = Features::default();
        assert!(!default_features.is_enabled(FeatureFlag::AGGREGATOR_V2_DELAYED_FIELDS));
        
        // Result: Non-deterministic execution and consensus divergence!
        println!("VULNERABILITY CONFIRMED:");
        println!("Validator with I/O error uses default config (AGGREGATOR_V2_DELAYED_FIELDS=false)");
        println!("Validator without error uses actual config (AGGREGATOR_V2_DELAYED_FIELDS=true)");
        println!("This causes different transaction execution and consensus divergence!");
    }
}
```

## Notes

This vulnerability represents a **critical failure** in error handling that violates consensus safety. While not directly "exploitable" by an external attacker (requires environmental conditions like hardware failures), it represents a severe protocol bug that can cause consensus failures under realistic operational conditions. The Aptos bug bounty program explicitly lists "Consensus/Safety violations" as Critical severity, which this clearly qualifies for, regardless of whether it requires malicious input.

The fix requires updating the `ConfigStorage` trait to properly propagate errors as `Result` types rather than collapsing them into `None`, and ensuring all callers handle storage errors explicitly rather than silently falling back to defaults.

### Citations

**File:** types/src/on_chain_config/mod.rs (L204-210)
```rust
impl<S: StateView> ConfigStorage for S {
    fn fetch_config_bytes(&self, state_key: &StateKey) -> Option<Bytes> {
        self.get_state_value(state_key)
            .ok()?
            .map(|s| s.bytes().clone())
    }
}
```

**File:** storage/aptosdb/src/state_kv_db.rs (L374-402)
```rust
    pub(crate) fn get_state_value_with_version_by_version(
        &self,
        state_key: &StateKey,
        version: Version,
    ) -> Result<Option<(Version, StateValue)>> {
        let mut read_opts = ReadOptions::default();

        // We want `None` if the state_key changes in iteration.
        read_opts.set_prefix_same_as_start(true);
        if !self.enabled_sharding() {
            let mut iter = self
                .db_shard(state_key.get_shard_id())
                .iter_with_opts::<StateValueSchema>(read_opts)?;
            iter.seek(&(state_key.clone(), version))?;
            Ok(iter
                .next()
                .transpose()?
                .and_then(|((_, version), value_opt)| value_opt.map(|value| (version, value))))
        } else {
            let mut iter = self
                .db_shard(state_key.get_shard_id())
                .iter_with_opts::<StateValueByKeyHashSchema>(read_opts)?;
            iter.seek(&(state_key.hash(), version))?;
            Ok(iter
                .next()
                .transpose()?
                .and_then(|((_, version), value_opt)| value_opt.map(|value| (version, value))))
        }
    }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L644-655)
```rust
    fn get_state_value_with_version_by_version(
        &self,
        state_key: &StateKey,
        version: Version,
    ) -> Result<Option<(Version, StateValue)>> {
        gauged_api("get_state_value_with_version_by_version", || {
            self.error_if_state_kv_pruned("StateValue", version)?;

            self.state_store
                .get_state_value_with_version_by_version(state_key, version)
        })
    }
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L305-315)
```rust
    pub(super) fn error_if_state_kv_pruned(&self, data_type: &str, version: Version) -> Result<()> {
        let min_readable_version = self.state_store.state_kv_pruner.get_min_readable_version();
        ensure!(
            version >= min_readable_version,
            "{} at version {} is pruned, min available version is {}.",
            data_type,
            version,
            min_readable_version
        );
        Ok(())
    }
```

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L27-46)
```rust
    fn get(&self, key: &StateKey) -> StateViewResult<Option<(Version, StateValue)>> {
        if let Some(version) = self.version {
            if let Some(root_hash) = self.maybe_verify_against_state_root_hash {
                // TODO(aldenhu): sample-verify proof inside DB
                // DB doesn't support returning proofs for buffered state, so only optionally
                // verify proof.
                // TODO: support returning state proof for buffered state.
                if let Ok((value, proof)) =
                    self.db.get_state_value_with_proof_by_version(key, version)
                {
                    proof.verify(root_hash, *key.crypto_hash_ref(), value.as_ref())?;
                }
            }
            Ok(self
                .db
                .get_state_value_with_version_by_version(key, version)?)
        } else {
            Ok(None)
        }
    }
```

**File:** types/src/state_store/errors.rs (L6-21)
```rust
#[derive(Debug, Error)]
pub enum StateViewError {
    #[error("{0} not found.")]
    NotFound(String),
    /// Other non-classified error.
    #[error("{0}")]
    Other(String),
    #[error(transparent)]
    BcsError(#[from] bcs::Error),
}

impl From<anyhow::Error> for StateViewError {
    fn from(error: anyhow::Error) -> Self {
        Self::Other(format!("{}", error))
    }
}
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L220-228)
```rust
            fetch_config_and_update_hash::<Features>(&mut sha3_256, state_view).unwrap_or_default();

        // If no chain ID is in storage, we assume we are in a testing environment.
        let chain_id = fetch_config_and_update_hash::<ChainId>(&mut sha3_256, state_view)
            .unwrap_or_else(ChainId::test);
        let timestamp_micros =
            fetch_config_and_update_hash::<ConfigurationResource>(&mut sha3_256, state_view)
                .map(|config| config.last_reconfiguration_time_micros())
                .unwrap_or(0);
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L329-336)
```rust
fn fetch_config_and_update_hash<T: OnChainConfig>(
    sha3_256: &mut Sha3_256,
    state_view: &impl StateView,
) -> Option<T> {
    let (config, bytes) = T::fetch_config_and_bytes(state_view)?;
    sha3_256.update(&bytes);
    Some(config)
}
```

**File:** types/src/on_chain_config/aptos_features.rs (L171-195)
```rust
    pub fn default_features() -> Vec<Self> {
        vec![
            FeatureFlag::CODE_DEPENDENCY_CHECK,
            FeatureFlag::TREAT_FRIEND_AS_PRIVATE,
            FeatureFlag::SHA_512_AND_RIPEMD_160_NATIVES,
            FeatureFlag::APTOS_STD_CHAIN_ID_NATIVES,
            // Feature flag V6 is used to enable metadata v1 format and needs to stay on, even
            // if we enable a higher version.
            FeatureFlag::VM_BINARY_FORMAT_V6,
            FeatureFlag::VM_BINARY_FORMAT_V7,
            FeatureFlag::MULTI_ED25519_PK_VALIDATE_V2_NATIVES,
            FeatureFlag::BLAKE2B_256_NATIVE,
            FeatureFlag::RESOURCE_GROUPS,
            FeatureFlag::MULTISIG_ACCOUNTS,
            FeatureFlag::DELEGATION_POOLS,
            FeatureFlag::CRYPTOGRAPHY_ALGEBRA_NATIVES,
            FeatureFlag::BLS12_381_STRUCTURES,
            FeatureFlag::ED25519_PUBKEY_VALIDATE_RETURN_FALSE_WRONG_LENGTH,
            FeatureFlag::STRUCT_CONSTRUCTORS,
            FeatureFlag::PERIODICAL_REWARD_RATE_DECREASE,
            FeatureFlag::PARTIAL_GOVERNANCE_VOTING,
            FeatureFlag::_SIGNATURE_CHECKER_V2,
            FeatureFlag::STORAGE_SLOT_METADATA,
            FeatureFlag::CHARGE_INVARIANT_VIOLATION,
            FeatureFlag::DELEGATION_POOL_PARTIAL_GOVERNANCE_VOTING,
```

**File:** consensus/src/consensus_observer/observer/epoch_state.rs (L157-179)
```rust
    let onchain_consensus_config: anyhow::Result<OnChainConsensusConfig> = on_chain_configs.get();
    if let Err(error) = &onchain_consensus_config {
        error!(
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Failed to read on-chain consensus config! Error: {:?}",
                error
            ))
        );
    }
    let consensus_config = onchain_consensus_config.unwrap_or_default();

    // Extract the execution config (or use the default if it's missing)
    let onchain_execution_config: anyhow::Result<OnChainExecutionConfig> = on_chain_configs.get();
    if let Err(error) = &onchain_execution_config {
        error!(
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Failed to read on-chain execution config! Error: {:?}",
                error
            ))
        );
    }
    let execution_config =
        onchain_execution_config.unwrap_or_else(|_| OnChainExecutionConfig::default_if_missing());
```
