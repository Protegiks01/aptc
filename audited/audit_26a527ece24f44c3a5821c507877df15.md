# Audit Report

## Title
OptQS Denial-of-Service via Strategic Payload Withholding and Window Manipulation

## Summary
Validators with less than 1/3 stake can strategically withhold payload batches when serving as leaders to exponentially grow the OptQS failure window, forcing all honest validators to disable the Optimized Quorum Store (OptQS) feature indefinitely. This degrades network throughput and latency for the entire validator set.

## Finding Description

The `ExponentialWindowFailureTracker` in the OptQS system uses an exponential backoff mechanism to disable OptQS when payload unavailability occurs. The vulnerability lies in the interaction between three components:

1. **Window Growth**: When a `PayloadUnavailable` timeout occurs, the window doubles exponentially. [1](#0-0) 

2. **Author Exclusion Window**: The exclusion mechanism only examines the last `window` rounds, not all historical failures. [2](#0-1) 

3. **Window Reset Condition**: The window only resets to 2 when ALL entries in `past_round_statuses` are successful. [3](#0-2) 

**Attack Execution:**

1. A malicious validator M with < 1/3 stake becomes the round leader
2. M creates an OptQS proposal including M's own batches in `opt_batches`
3. M intentionally does not broadcast these batches to the network
4. When honest validators receive the proposal, they check payload availability [4](#0-3) 

5. All honest validators (> 2/3 stake) find M's batches missing and timeout with `PayloadUnavailable` [5](#0-4) 

6. The timeout reasons are aggregated, and since > f+1 validators report M as missing, the aggregated reason is `PayloadUnavailable(M)` [6](#0-5) 

7. All validators' trackers process this failure, doubling the window and excluding M
8. OptQS is disabled until `last_consecutive_success_count >= window` [7](#0-6) 

9. After `window` rounds, M rotates out of the exclusion window (line 83: only last `window` rounds checked)
10. M or another colluding validator repeats the attack, growing the window to `max_window`

Once the window reaches `max_window` (typically 100), OptQS requires 100 consecutive successful rounds to re-enable. The attackers can maintain this state indefinitely by causing a single `PayloadUnavailable` failure every ~99 rounds, preventing the window from ever resetting.

## Impact Explanation

This vulnerability achieves **High Severity** per Aptos bug bounty criteria:

- **Validator node slowdowns**: OptQS is a critical performance optimization that reduces consensus latency by allowing validators to include batches without full quorum store proofs. Disabling OptQS forces all validators to use the slower regular quorum store path, degrading network throughput and increasing transaction confirmation times.

- **Significant protocol violations**: The attack violates the liveness and performance guarantees of the consensus protocol by preventing validators from using an intended optimization feature.

The impact affects ALL honest validators network-wide, not just the attacker. While this doesn't compromise consensus safety (blocks are still valid), it significantly degrades user experience through:
- Increased transaction latency
- Reduced network throughput
- Higher resource consumption on validator nodes

## Likelihood Explanation

**Likelihood: HIGH**

The attack has low barriers to execution:

1. **Minimal stake requirement**: Any validator with stake (even far below 1/3) can execute this attack
2. **Natural leader selection**: Attackers will naturally be selected as leaders proportional to their stake
3. **Simple execution**: The attack requires only withholding data, not sophisticated cryptographic manipulation
4. **Evasion of detection**: The attacker can rotate through multiple validator identities or time attacks to avoid immediate detection
5. **No synchronization required**: A single malicious validator can degrade performance for the entire network

The attack is economically rational for validators seeking to:
- Degrade competitors' performance
- Reduce network efficiency to drive users to alternative chains
- Extract value through subsequent proposals when OptQS is disabled

## Recommendation

Implement a **persistent exclusion mechanism** that tracks long-term payload availability patterns rather than a sliding window:

```rust
pub struct PersistentFailureTracker {
    window: usize,
    max_window: usize,
    past_round_statuses: BoundedVecDeque<NewRoundReason>,
    last_consecutive_success_count: usize,
    ordered_authors: Vec<Author>,
    // NEW: Track cumulative failures per author across epochs
    author_failure_counts: HashMap<Author, FailureRecord>,
}

struct FailureRecord {
    failure_count: u64,
    last_failure_round: Round,
    // Decay failures over time to allow recovery
    epoch_start: u64,
}

impl PersistentFailureTracker {
    fn get_exclude_authors(&self) -> HashSet<Author> {
        let mut exclude_authors = HashSet::new();
        
        // Existing sliding window check
        for round_reason in self.past_round_statuses.iter().rev().take(self.window) {
            if let NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable { missing_authors }) = round_reason {
                for author_idx in missing_authors.iter_ones() {
                    if let Some(author) = self.ordered_authors.get(author_idx) {
                        exclude_authors.insert(*author);
                    }
                }
            }
        }
        
        // NEW: Add persistent exclusion for repeat offenders
        for (author, record) in &self.author_failure_counts {
            // Exclude authors with excessive failures (e.g., >5 in recent epoch)
            if record.failure_count > PERSISTENT_EXCLUSION_THRESHOLD {
                exclude_authors.insert(*author);
            }
        }
        
        exclude_authors
    }
    
    fn update_failure_counts(&mut self, missing_authors: &BitVec, current_round: Round) {
        for author_idx in missing_authors.iter_ones() {
            if let Some(author) = self.ordered_authors.get(author_idx) {
                let record = self.author_failure_counts
                    .entry(*author)
                    .or_insert(FailureRecord::new(current_round));
                record.failure_count += 1;
                record.last_failure_round = current_round;
            }
        }
    }
}
```

Additionally:
1. **Rate-limit window growth**: Cap window growth to prevent exponential escalation (e.g., max 2x growth per epoch)
2. **Reputation system**: Implement cross-epoch reputation tracking for payload reliability
3. **Alternative window reset**: Reset window when consecutive successes exceed a threshold, even if historical failures exist
4. **Monitoring alerts**: Add metrics to detect repeated payload unavailability patterns indicating potential attacks

## Proof of Concept

```rust
#[cfg(test)]
mod test_optqs_dos {
    use super::*;
    use aptos_bitvec::BitVec;
    use aptos_consensus_types::round_timeout::RoundTimeoutReason;
    use aptos_types::validator_verifier::random_validator_verifier;

    #[test]
    fn test_window_manipulation_attack() {
        // Setup: 4 validators, validator 0 is malicious
        let (_signers, verifier) = random_validator_verifier(4, None, false);
        let mut tracker = ExponentialWindowFailureTracker::new(
            100, // max_window
            verifier.get_ordered_account_addresses()
        );
        
        // Initial state
        assert_eq!(tracker.window, 2);
        
        // Round 1: Malicious validator causes PayloadUnavailable
        let mut missing_authors = BitVec::with_num_bits(4);
        missing_authors.set(0); // Validator 0 is malicious
        tracker.push(NewRoundReason::Timeout(
            RoundTimeoutReason::PayloadUnavailable { missing_authors: missing_authors.clone() }
        ));
        assert_eq!(tracker.window, 4); // Window doubles
        assert_eq!(tracker.last_consecutive_success_count, 0);
        
        // Rounds 2-5: Successful rounds (malicious validator excluded)
        for _ in 0..4 {
            tracker.push(NewRoundReason::QCReady);
        }
        assert_eq!(tracker.window, 4); // Window stays at 4
        assert_eq!(tracker.last_consecutive_success_count, 4);
        
        // Validator 0 is no longer in exclusion window after 4 rounds
        let excluded = tracker.get_exclude_authors();
        assert!(!excluded.contains(&verifier.get_ordered_account_addresses()[0]));
        
        // Round 6: Malicious validator attacks again
        tracker.push(NewRoundReason::Timeout(
            RoundTimeoutReason::PayloadUnavailable { missing_authors }
        ));
        assert_eq!(tracker.window, 8); // Window doubles again
        
        // Demonstrate attack can continue until max_window
        for i in 0..10 {
            // Attacker causes failure
            let mut missing = BitVec::with_num_bits(4);
            missing.set((i % 4) as u16); // Rotate through validators
            tracker.push(NewRoundReason::Timeout(
                RoundTimeoutReason::PayloadUnavailable { missing_authors: missing }
            ));
            
            // Some successful rounds
            for _ in 0..(tracker.window - 1) {
                tracker.push(NewRoundReason::QCReady);
            }
        }
        
        // Window reaches max_window and OptQS is effectively disabled
        assert_eq!(tracker.window, tracker.max_window);
        
        // Even with 99 consecutive successes, OptQS won't re-enable if 
        // past_round_statuses contains any failure
        assert!(tracker.last_consecutive_success_count < tracker.window 
                || tracker.past_round_statuses.len() > tracker.last_consecutive_success_count);
    }
}
```

## Notes

This vulnerability demonstrates a fundamental design flaw in the OptQS failure tracking mechanism: the exclusion window and reset conditions allow adversaries to maintain long-term degradation with minimal coordination. The attack is particularly concerning because:

1. **Cross-validator impact**: A single malicious validator can degrade performance for the entire network
2. **Difficult mitigation**: Network operators cannot easily identify or remove the attacker without off-chain coordination
3. **Economic incentives**: Validators may be economically motivated to execute this attack to gain competitive advantages
4. **Cascading effects**: Reduced OptQS usage increases load on the regular quorum store path, potentially causing additional performance issues

The fix requires rethinking the exclusion and reset logic to prevent manipulation while preserving the intended backoff behavior for legitimate network issues.

### Citations

**File:** consensus/src/liveness/proposal_status_tracker.rs (L65-78)
```rust
    fn compute_failure_window(&mut self) {
        self.last_consecutive_success_count = self.last_consecutive_statuses_matching(|reason| {
            !matches!(
                reason,
                NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable { .. })
            )
        });
        if self.last_consecutive_success_count == 0 {
            self.window *= 2;
            self.window = self.window.min(self.max_window);
        } else if self.last_consecutive_success_count == self.past_round_statuses.len() {
            self.window = 2;
        }
    }
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L80-98)
```rust
    fn get_exclude_authors(&self) -> HashSet<Author> {
        let mut exclude_authors = HashSet::new();

        let limit = self.window;
        for round_reason in self.past_round_statuses.iter().rev().take(limit) {
            if let NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable {
                missing_authors,
            }) = round_reason
            {
                for author_idx in missing_authors.iter_ones() {
                    if let Some(author) = self.ordered_authors.get(author_idx) {
                        exclude_authors.insert(*author);
                    }
                }
            }
        }

        exclude_authors
    }
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L137-143)
```rust
        if tracker.last_consecutive_success_count < tracker.window {
            warn!(
                "Skipping OptQS: (last_consecutive_successes) {} < {} (window)",
                tracker.last_consecutive_success_count, tracker.window
            );
            return None;
        }
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L409-424)
```rust
            Payload::OptQuorumStore(OptQuorumStorePayload::V1(p)) => {
                let mut missing_authors = BitVec::with_num_bits(self.ordered_authors.len() as u16);
                for batch in p.opt_batches().deref() {
                    if self.batch_reader.exists(batch.digest()).is_none() {
                        let index = *self
                            .address_to_validator_index
                            .get(&batch.author())
                            .expect("Payload author should have been verified");
                        missing_authors.set(index as u16);
                    }
                }
                if missing_authors.all_zeros() {
                    Ok(())
                } else {
                    Err(missing_authors)
                }
```

**File:** consensus/src/round_manager.rs (L968-983)
```rust
    fn compute_timeout_reason(&self, round: Round) -> RoundTimeoutReason {
        if self.round_state().vote_sent().is_some() {
            return RoundTimeoutReason::NoQC;
        }

        match self.block_store.get_block_for_round(round) {
            None => RoundTimeoutReason::ProposalNotReceived,
            Some(block) => {
                if let Err(missing_authors) = self.block_store.check_payload(block.block()) {
                    RoundTimeoutReason::PayloadUnavailable { missing_authors }
                } else {
                    RoundTimeoutReason::Unknown
                }
            },
        }
    }
```

**File:** consensus/src/pending_votes.rs (L93-153)
```rust
    fn aggregated_timeout_reason(&self, verifier: &ValidatorVerifier) -> RoundTimeoutReason {
        let mut reason_voting_power: HashMap<RoundTimeoutReason, u128> = HashMap::new();
        let mut missing_batch_authors: HashMap<usize, u128> = HashMap::new();
        // let ordered_authors = verifier.get_ordered_account_addresses();
        for (author, reason) in &self.timeout_reason {
            // To aggregate the reason, we only care about the variant type itself and
            // exclude any data within the variants.
            let reason_key = match reason {
                reason @ RoundTimeoutReason::Unknown
                | reason @ RoundTimeoutReason::ProposalNotReceived
                | reason @ RoundTimeoutReason::NoQC => reason.clone(),
                RoundTimeoutReason::PayloadUnavailable { missing_authors } => {
                    for missing_idx in missing_authors.iter_ones() {
                        *missing_batch_authors.entry(missing_idx).or_default() +=
                            verifier.get_voting_power(author).unwrap_or_default() as u128;
                    }
                    RoundTimeoutReason::PayloadUnavailable {
                        // Since we care only about the variant type, we replace the bitvec
                        // with a placeholder.
                        missing_authors: BitVec::with_num_bits(verifier.len() as u16),
                    }
                },
            };
            *reason_voting_power.entry(reason_key).or_default() +=
                verifier.get_voting_power(author).unwrap_or_default() as u128;
        }
        // The aggregated timeout reason is the reason with the most voting power received from
        // at least f+1 peers by voting power. If such voting power does not exist, then the
        // reason is unknown.

        reason_voting_power
            .into_iter()
            .max_by_key(|(_, voting_power)| *voting_power)
            .filter(|(_, voting_power)| {
                verifier
                    .check_aggregated_voting_power(*voting_power, false)
                    .is_ok()
            })
            .map(|(reason, _)| {
                // If the aggregated reason is due to unavailable payload, we will compute the
                // aggregated missing authors bitvec counting batch authors that have been reported
                // missing by minority peers.
                if matches!(reason, RoundTimeoutReason::PayloadUnavailable { .. }) {
                    let mut aggregated_bitvec = BitVec::with_num_bits(verifier.len() as u16);
                    for (author_idx, voting_power) in missing_batch_authors {
                        if verifier
                            .check_aggregated_voting_power(voting_power, false)
                            .is_ok()
                        {
                            aggregated_bitvec.set(author_idx as u16);
                        }
                    }
                    RoundTimeoutReason::PayloadUnavailable {
                        missing_authors: aggregated_bitvec,
                    }
                } else {
                    reason
                }
            })
            .unwrap_or(RoundTimeoutReason::Unknown)
    }
```
