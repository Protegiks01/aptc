# Audit Report

## Title
Path Traversal in Legacy Move Package System via Unvalidated Git Dependency Subdirectories

## Summary
The legacy Move package system (`move-package` crate) fails to validate the `subdir` field in git dependencies, allowing path traversal attacks. An attacker can craft a malicious manifest with a git dependency containing `..` components in the subdir field, enabling unauthorized file system access outside the intended package directory when the package is compiled.

## Finding Description

The vulnerability exists in how the legacy Move package system handles git dependency subdirectories. When a Move.toml manifest specifies a git dependency with a `subdir` field, the system does not validate that the subdir stays within the repository boundaries.

The attack flow:

1. **Manifest Parsing**: [1](#0-0) 
   The parser accepts any string value for `subdir` and directly joins it with the git cache path without validation.

2. **Path Construction**: [2](#0-1) 
   The unvalidated path from `dep.local` (containing the malicious subdir) is pushed to `root_path` and used to read the manifest file.

3. **File Access**: [3](#0-2) 
   When reading source files, the system joins `package_path` (containing the traversed path) with layout paths like "sources", enabling access to directories outside the intended package.

**Contrast with Fixed Implementation**: The newer `move-package-resolver` correctly validates subdirs: [4](#0-3) 

This validation prevents paths with leading `..` components, which the legacy system lacks.

## Impact Explanation

**Severity: Medium**

This vulnerability enables:

1. **Information Disclosure**: An attacker who controls a git repository can craft a manifest that reads Move source files from parent directories when a victim compiles packages depending on it. This could expose proprietary Move code or sensitive package structures.

2. **Potential State Inconsistencies**: If an attacker can place malicious Move.toml and .move files in accessible parent directories (e.g., other packages in the workspace), they could inject malicious code into the compilation process, potentially affecting the compiled bytecode.

The impact is limited because:
- The attacker cannot directly write to the file system, only read from accessible paths
- The victim must explicitly add the malicious dependency
- System-critical paths are typically protected by OS-level permissions

This meets **Medium Severity** criteria per the bug bounty program: "Limited information disclosure" and potential for "State inconsistencies requiring intervention."

## Likelihood Explanation

**Likelihood: Medium to High**

The vulnerability is likely to occur because:

1. **Active Usage**: The legacy Move package system is still used in Aptos, as evidenced by its usage in the CLI and test infrastructure
2. **Easy to Exploit**: Creating a malicious manifest with path traversal is trivial - just setting `subdir = "../../sensitive-package"` in a git dependency
3. **Limited Awareness**: Developers may not realize that adding git dependencies can lead to file system access outside the repository

However, likelihood is reduced by:
- Requires victim to add the malicious dependency
- The newer resolver (when adopted) has the fix
- Most developers work in controlled environments with limited sensitive files in parent directories

## Recommendation

**Immediate Fix**: Apply the same validation logic from the new resolver to the legacy system. In `manifest_parser.rs`, validate the subdir before creating the Dependency:

```rust
// After line 369 in manifest_parser.rs
let subdir = PathBuf::from(match table.remove("subdir") {
    None => "".to_string(),
    Some(path) => path
        .as_str()
        .ok_or_else(|| format_err!("'subdir' not a string"))?
        .to_string(),
});

// ADD VALIDATION:
if subdir.is_absolute() {
    bail!("subdir cannot be an absolute path: {}", subdir.display());
}
let normalized_subdir = NormalizedPath::new(&subdir);
if let Some(std::path::Component::ParentDir) = normalized_subdir.components().next() {
    bail!("subdir outside of repo root: {}", subdir.display());
}
```

**Long-term Fix**: Migrate all users to the new `move-package-resolver` which has proper validation built-in.

## Proof of Concept

Create a malicious Move.toml with path traversal:

```toml
[package]
name = "malicious-package"
version = "1.0.0"

[dependencies]
# Attempts to read from parent directories
victim-package = { git = "https://github.com/attacker/repo.git", rev = "main", subdir = "../../victim-workspace/private-package" }
```

When a victim compiles a package depending on this malicious package, the resolution system will attempt to read Move.toml and source files from `../../victim-workspace/private-package` relative to the git cache directory, potentially exposing sensitive code.

**Steps to reproduce:**
1. Create a git repository with the malicious Move.toml above
2. Create a victim package that depends on this repository
3. Run `aptos move compile` in the victim package
4. Observe file access attempts to parent directories in the error messages or via file system monitoring

## Notes

The vulnerability is confirmed to exist in the legacy `move-package` crate but has been addressed in the newer `move-package-resolver` crate. Organizations should prioritize migration to the newer resolver and audit their dependency chains for potentially malicious git dependencies with suspicious subdir values.

### Citations

**File:** third_party/move/tools/move-package/src/source_package/manifest_parser.rs (L369-387)
```rust
                    let subdir = PathBuf::from(match table.remove("subdir") {
                        None => "".to_string(),
                        Some(path) => path
                            .as_str()
                            .ok_or_else(|| format_err!("'subdir' not a string"))?
                            .to_string(),
                    });
                    git_info = Some(PM::GitInfo {
                        git_url: Symbol::from(git_url),
                        git_rev: rev_name,
                        subdir: subdir.clone(),
                        download_to: local_path.clone(),
                    });

                    Ok(PM::Dependency {
                        subst,
                        version,
                        digest,
                        local: local_path.join(subdir),
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L504-505)
```rust
        root_path.push(&dep.local);
        match fs::read_to_string(root_path.join(SourcePackageLayout::Manifest.path())) {
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L658-658)
```rust
            let path = package_path.join(layout_path.path());
```

**File:** third_party/move/tools/move-package-resolver/src/resolver.rs (L397-399)
```rust
            if let Some(std::path::Component::ParentDir) = normalized_subdir.components().next() {
                bail!("subdir outside of repo root: {}", subdir.display());
            }
```
