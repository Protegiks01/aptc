# Audit Report

## Title
Non-Canonical JSON Serialization in UnsupportedJWK Causing Consensus Divergence

## Summary
The `UnsupportedJWK::from(serde_json::Value)` implementation uses non-canonical JSON serialization via `json_value.to_string()`, causing validators to create divergent `UnsupportedJWK` objects when OIDC providers send semantically identical JSON with varying field orders. This breaks consensus for non-RSA JWK updates.

## Finding Description

The vulnerability exists in the conversion path from external OIDC provider JSON responses to consensus-critical `UnsupportedJWK` structures. The execution flow is as follows:

**Step 1: Independent JWK Fetching**
Validators independently fetch JWKs from OIDC providers via HTTP requests. [1](#0-0) 

**Step 2: Non-RSA Fallback Path**
When the JSON contains non-RSA keys (kty != "RSA"), the `RSA_JWK::try_from` fails [2](#0-1) , causing the system to fall back to creating an `UnsupportedJWK` [3](#0-2) .

**Step 3: Non-Canonical Serialization**
The critical vulnerability occurs here: `UnsupportedJWK::from` uses `json_value.to_string()` to serialize the JSON, which is explicitly acknowledged as non-canonical by the TODO comment. [4](#0-3) 

**Step 4: Consensus Divergence**
While the codebase uses `serde_json` with `preserve_order` feature [5](#0-4) , this only preserves **insertion order**, not a canonical alphabetical order. When different validators receive HTTP responses with different JSON field orders, they produce different string representations.

**Step 5: Signature Verification Failure**
During consensus aggregation, validators must agree on the exact `ProviderJWKs` structure. The system checks equality between local and peer views [6](#0-5) , then verifies BLS signatures [7](#0-6) .

**Step 6: BCS Serialization Dependency**
The signature verification uses BCS serialization over the message [8](#0-7)  via the `signing_message` function [9](#0-8) . Since `ProviderJWKs` derives `BCSCryptoHash` [10](#0-9) , different non-canonical JSON payloads result in different BCS serializations, different signatures, and consensus failure.

## Impact Explanation

**Critical Severity** - This vulnerability breaks **Consensus Safety (Category 2)** from the Aptos bug bounty program.

The impact includes:

1. **Consensus Failure**: Validators cannot reach 2f+1 agreement on non-RSA JWK updates because they sign over different BCS-serialized messages due to varying JSON field orders.

2. **Protocol Liveness Loss**: JWK updates cannot be quorum-certified when validators observe different representations of semantically identical keys, blocking the update mechanism entirely.

3. **DoS Vector**: An attacker controlling OIDC provider responses or performing MITM attacks can deliberately send different JSON field orders to different validators, guaranteeing consensus failure.

4. **Keyless Authentication Disruption**: The inability to update non-RSA JWKs breaks keyless authentication for affected OIDC providers, impacting users who rely on these providers.

This violates deterministic execution - semantically identical JWKs should produce identical state transitions regardless of JSON field ordering.

## Likelihood Explanation

**Medium-High Likelihood** due to:

**Natural Occurrence (High)**:
- EC (Elliptic Curve) keys are increasingly common in modern OIDC implementations (Google, Apple, Azure)
- HTTP/JSON specifications provide no guarantees about field ordering
- Different HTTP servers, JSON libraries, and proxy implementations may reorder fields
- The `preserve_order` feature only preserves insertion order, not canonical order

**Weaponized Attacks (Medium)**:
- Attacker controlling or compromising OIDC provider infrastructure can deliberately vary field orders
- MITM attackers can trivially reorder JSON fields in transit
- Low technical complexity to execute

**Current Partial Mitigation**:
Most major OIDC providers currently use RSA keys, which successfully parse via `RSA_JWK::try_from` and bypass the vulnerable `UnsupportedJWK` path. However, this is not a security guarantee as the industry increasingly adopts EC keys for improved security and performance.

## Recommendation

Implement canonical JSON serialization before creating the `UnsupportedJWK` payload:

```rust
impl From<serde_json::Value> for UnsupportedJWK {
    fn from(json_value: serde_json::Value) -> Self {
        // Serialize to canonical JSON (sorted keys)
        let payload = serde_json::to_vec(&canonical_json(&json_value))
            .expect("canonical JSON serialization should not fail")
            .into_bytes();
        Self {
            id: HashValue::sha3_256_of(payload.as_slice()).to_vec(),
            payload,
        }
    }
}

fn canonical_json(value: &serde_json::Value) -> serde_json::Value {
    match value {
        serde_json::Value::Object(map) => {
            let mut sorted: BTreeMap<String, serde_json::Value> = map
                .iter()
                .map(|(k, v)| (k.clone(), canonical_json(v)))
                .collect();
            serde_json::Value::Object(sorted.into_iter().collect())
        },
        serde_json::Value::Array(arr) => {
            serde_json::Value::Array(arr.iter().map(canonical_json).collect())
        },
        other => other.clone(),
    }
}
```

Alternatively, use a well-tested canonical JSON library like `canonical_json` crate.

## Proof of Concept

The vulnerability is demonstrated through code analysis. A complete PoC would require:

1. Deploy two validators
2. Configure an OIDC provider with EC keys (kty="EC")
3. Send JWK responses to different validators with different JSON field orders:
   - Validator A receives: `{"kty":"EC","crv":"P-256","x":"...","y":"...","kid":"key1"}`
   - Validator B receives: `{"kid":"key1","kty":"EC","x":"...","y":"...","crv":"P-256"}`
4. Observe that validators create different `UnsupportedJWK` payloads
5. Observe consensus failure when attempting to aggregate signatures

The TODO comment at line 53 of `types/src/jwks/unsupported/mod.rs` explicitly acknowledges this issue, confirming the vulnerability exists in the current codebase.

## Notes

This vulnerability demonstrates a critical flaw in handling external data during consensus. The use of non-canonical serialization for consensus-critical structures violates the fundamental requirement that semantically equivalent data must produce identical cryptographic commitments. The TODO comment indicates developer awareness, but the issue remains unfixed, posing a significant risk as OIDC providers increasingly adopt non-RSA cryptography.

### Citations

**File:** crates/jwk-utils/src/lib.rs (L25-36)
```rust
pub async fn fetch_jwks_from_jwks_uri(
    my_addr: Option<AccountAddress>,
    jwks_uri: &str,
) -> Result<Vec<JWK>> {
    let client = reqwest::Client::new();
    let mut request_builder = client.get(jwks_uri);
    if let Some(addr) = my_addr {
        request_builder = request_builder.header(COOKIE, addr.to_hex());
    }
    let JWKsResponse { keys } = request_builder.send().await?.json().await?;
    let jwks = keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
```

**File:** types/src/jwks/rsa/mod.rs (L143-146)
```rust
        ensure!(
            kty.as_str() == "RSA",
            "json to rsa jwk conversion failed with incorrect kty"
        );
```

**File:** types/src/jwks/jwk/mod.rs (L80-89)
```rust
impl From<serde_json::Value> for JWK {
    fn from(value: serde_json::Value) -> Self {
        match RSA_JWK::try_from(&value) {
            Ok(rsa) => Self::RSA(rsa),
            Err(_) => {
                let unsupported = UnsupportedJWK::from(value);
                Self::Unsupported(unsupported)
            },
        }
    }
```

**File:** types/src/jwks/unsupported/mod.rs (L51-58)
```rust
impl From<serde_json::Value> for UnsupportedJWK {
    fn from(json_value: serde_json::Value) -> Self {
        let payload = json_value.to_string().into_bytes(); //TODO: canonical to_string.
        Self {
            id: HashValue::sha3_256_of(payload.as_slice()).to_vec(),
            payload,
        }
    }
```

**File:** Cargo.toml (L1-100)
```text
[workspace]
resolver = "2"

members = [
    "api",
    "api/openapi-spec-generator",
    "api/test-context",
    "api/types",
    "aptos-move/aptos-abstract-gas-usage",
    "aptos-move/aptos-aggregator",
    "aptos-move/aptos-debugger",
    "aptos-move/aptos-e2e-comparison-testing",
    "aptos-move/aptos-gas-algebra",
    "aptos-move/aptos-gas-calibration",
    "aptos-move/aptos-gas-meter",
    "aptos-move/aptos-gas-profiling",
    "aptos-move/aptos-gas-schedule",
    "aptos-move/aptos-gas-schedule-updator",
    "aptos-move/aptos-memory-usage-tracker",
    "aptos-move/aptos-native-interface",
    "aptos-move/aptos-release-builder",
    "aptos-move/aptos-resource-viewer",
    "aptos-move/aptos-sdk-builder",
    "aptos-move/aptos-transaction-benchmarks",
    "aptos-move/aptos-transaction-simulation",
    "aptos-move/aptos-transaction-simulation-session",
    "aptos-move/aptos-transactional-test-harness",
    "aptos-move/aptos-validator-interface",
    "aptos-move/aptos-vm",
    "aptos-move/aptos-vm-benchmarks",
    "aptos-move/aptos-vm-environment",
    "aptos-move/aptos-vm-logging",
    "aptos-move/aptos-vm-profiling",
    "aptos-move/aptos-vm-types",
    "aptos-move/aptos-workspace-server",
    "aptos-move/block-executor",
    "aptos-move/e2e-benchmark",
    "aptos-move/e2e-move-tests",
    "aptos-move/e2e-tests",
    "aptos-move/e2e-testsuite",
    "aptos-move/framework",
    "aptos-move/framework/cached-packages",
    "aptos-move/framework/table-natives",
    "aptos-move/move-examples",
    "aptos-move/mvhashmap",
    "aptos-move/package-builder",
    "aptos-move/replay-benchmark",
    "aptos-move/script-composer",
    "aptos-move/vm-genesis",
    "aptos-node",
    "config",
    "config/global-constants",
    "consensus",
    "consensus/consensus-types",
    "consensus/safety-rules",
    "crates/aptos",
    "crates/aptos-admin-service",
    "crates/aptos-api-tester",
    "crates/aptos-batch-encryption",
    "crates/aptos-bcs-utils",
    "crates/aptos-bitvec",
    "crates/aptos-build-info",
    "crates/aptos-collections",
    "crates/aptos-compression",
    "crates/aptos-crypto",
    "crates/aptos-crypto-derive",
    "crates/aptos-debugger",
    "crates/aptos-dkg",
    "crates/aptos-drop-helper",
    "crates/aptos-enum-conversion-derive",
    "crates/aptos-faucet/cli",
    "crates/aptos-faucet/core",
    "crates/aptos-faucet/metrics-server",
    "crates/aptos-faucet/service",
    "crates/aptos-genesis",
    "crates/aptos-github-client",
    "crates/aptos-id-generator",
    "crates/aptos-in-memory-cache",
    "crates/aptos-infallible",
    "crates/aptos-inspection-service",
    "crates/aptos-jwk-consensus",
    "crates/aptos-keygen",
    "crates/aptos-ledger",
    "crates/aptos-localnet",
    "crates/aptos-log-derive",
    "crates/aptos-logger",
    "crates/aptos-metrics-core",
    "crates/aptos-network-checker",
    "crates/aptos-node-identity",
    "crates/aptos-openapi",
    "crates/aptos-profiler",
    "crates/aptos-proptest-helpers",
    "crates/aptos-push-metrics",
    "crates/aptos-rate-limiter",
    "crates/aptos-rest-client",
    "crates/aptos-retrier",
    "crates/aptos-rosetta",
    "crates/aptos-rosetta-cli",
    "crates/aptos-runtimes",
    "crates/aptos-speculative-state-helper",
```

**File:** crates/aptos-jwk-consensus/src/observation_aggregation/mod.rs (L81-84)
```rust
        ensure!(
            self.local_view == peer_view,
            "adding peer observation failed with mismatched view"
        );
```

**File:** crates/aptos-jwk-consensus/src/observation_aggregation/mod.rs (L86-89)
```rust
        // Verify peer signature.
        self.epoch_state
            .verifier
            .verify(sender, &peer_view, &signature)?;
```

**File:** types/src/validator_verifier.rs (L255-266)
```rust
    pub fn verify<T: Serialize + CryptoHash>(
        &self,
        author: AccountAddress,
        message: &T,
        signature: &bls12381::Signature,
    ) -> std::result::Result<(), VerifyError> {
        match self.get_public_key(&author) {
            Some(public_key) => public_key
                .verify_struct_signature(message, signature)
                .map_err(|_| VerifyError::InvalidMultiSignature),
            None => Err(VerifyError::UnknownAuthor),
        }
```

**File:** crates/aptos-crypto/src/traits/mod.rs (L170-177)
```rust
pub fn signing_message<T: CryptoHash + Serialize>(
    message: &T,
) -> Result<Vec<u8>, CryptoMaterialError> {
    let mut bytes = <T::Hasher as CryptoHasher>::seed().to_vec();
    bcs::serialize_into(&mut bytes, &message)
        .map_err(|_| CryptoMaterialError::SerializationError)?;
    Ok(bytes)
}
```

**File:** types/src/jwks/mod.rs (L122-128)
```rust
#[derive(Clone, Default, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
pub struct ProviderJWKs {
    #[serde(with = "serde_bytes")]
    pub issuer: Issuer,
    pub version: u64,
    pub jwks: Vec<JWKMoveStruct>,
}
```
