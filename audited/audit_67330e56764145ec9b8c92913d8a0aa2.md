# Audit Report

## Title
VaultConfig Namespace Path Traversal Allows Cross-Namespace Secret Access

## Summary
The `VaultConfig` struct accepts unvalidated namespace strings that are directly concatenated into Vault API paths, enabling path traversal attacks. A compromised validator or malicious insider with config file access can set `namespace` to values like `"../../other_validator"` to access secrets belonging to other validators sharing the same Vault instance.

## Finding Description

The vulnerability exists in the namespace handling for Vault-backed secure storage. The `VaultConfig` struct defines a namespace field as an `Option<String>` with no validation: [1](#0-0) 

When a namespace is provided, it's wrapped using the `Namespaced` struct, which performs simple string concatenation without any sanitization: [2](#0-1) 

The concatenated path is then used directly in Vault HTTP API calls. When retrieving secrets, the full namespaced key becomes part of the Vault URL path: [3](#0-2) [4](#0-3) 

**Attack Scenario:**
1. A malicious validator operator or attacker who has compromised a validator's configuration sets `namespace: "../../victim_validator"` in their YAML config
2. When their validator requests key `"consensus_key"`, the system constructs: `"../../victim_validator/consensus_key"`
3. This becomes the Vault URL: `https://vault/v1/secret/data/../../victim_validator/consensus_key`
4. If Vault doesn't normalize the path and the token has sufficient permissions, the attacker retrieves the victim validator's private keys

This breaks the namespace isolation guarantee that should prevent cross-validator secret access.

## Impact Explanation

**Severity: Critical** (up to $1,000,000)

This vulnerability falls under multiple critical impact categories:
- **Loss of Funds**: Stolen validator private keys enable the attacker to sign blocks on behalf of the victim, potentially double-signing and getting the victim slashed
- **Consensus/Safety violations**: Access to consensus keys allows equivocation attacks and potential chain splits

However, the exploitability is significantly constrained by the requirement for validator operator access or system compromise.

## Likelihood Explanation

**Likelihood: Low to Medium**

The vulnerability requires:
1. **Prerequisite Access**: Attacker must be a malicious validator operator OR have compromised a validator's configuration files (trusted role compromise)
2. **Shared Vault Deployment**: Multiple validators must share the same Vault instance with namespace-based isolation
3. **Permissive Vault Tokens**: The Vault token must have permissions across namespaces (not following least-privilege)

While the code bug is clear, exploitation requires compromising trusted infrastructure. In production deployments where each validator uses separate Vault instances or proper Vault policies enforce strict namespace isolation, the attack would fail.

## Recommendation

Add validation to reject namespace strings containing path traversal sequences, null bytes, or other dangerous characters. Implement a whitelist approach allowing only alphanumeric characters, hyphens, and underscores:

```rust
// In VaultConfig or when creating Namespaced wrapper
fn validate_namespace(namespace: &str) -> Result<(), Error> {
    // Reject path traversal attempts
    if namespace.contains("..") || namespace.contains('/') || namespace.contains('\\') {
        return Err(Error::InvalidInput("Namespace contains path traversal characters".into()));
    }
    
    // Reject null bytes
    if namespace.contains('\0') {
        return Err(Error::InvalidInput("Namespace contains null bytes".into()));
    }
    
    // Whitelist safe characters only
    if !namespace.chars().all(|c| c.is_alphanumeric() || c == '-' || c == '_') {
        return Err(Error::InvalidInput("Namespace contains invalid characters".into()));
    }
    
    Ok(())
}
```

Apply this validation in `Namespaced::new()`:

```rust
pub fn new<N: Into<String>>(namespace: N, inner: S) -> Result<Self, Error> {
    let namespace = namespace.into();
    validate_namespace(&namespace)?;
    Ok(Self { namespace, inner })
}
```

Additionally, enforce defense-in-depth:
- Document that each validator should use separate Vault instances
- Implement strict Vault policies with namespace-specific tokens
- Add monitoring for unusual cross-namespace access patterns

## Proof of Concept

```rust
#[cfg(test)]
mod path_traversal_test {
    use super::*;
    use crate::{VaultStorage, Namespaced, Storage};
    
    #[test]
    fn test_namespace_path_traversal() {
        // Setup: Create two namespaced storages simulating two validators
        let vault = create_test_vault();
        
        // Victim validator stores secret in their namespace
        let mut victim_storage = Namespaced::new(
            "victim_validator",
            Box::new(Storage::from(vault.clone()))
        );
        victim_storage.set("consensus_key", "victim_secret_key").unwrap();
        
        // Attacker creates storage with malicious namespace
        let malicious_namespace = "../../victim_validator";
        let attacker_storage = Namespaced::new(
            "attacker_validator", 
            Box::new(Storage::from(vault))
        );
        
        // Attacker attempts path traversal by manually constructing the namespaced path
        // This simulates what would happen if namespace field in config contained "../"
        let traversal_key = format!("{}{}{}",
            malicious_namespace, 
            NAMESPACE_SEPARATOR,
            "consensus_key"
        );
        
        // In vulnerable code, this would succeed in reading victim's secret
        // Expected behavior: Should fail with permission denied or not found
        let result = attacker_storage.inner().get::<String>(&traversal_key);
        
        // Currently VULNERABLE: This may succeed depending on Vault configuration
        // After fix: Should always fail
        assert!(result.is_err(), "Path traversal should be prevented!");
    }
}
```

**Note**: This PoC demonstrates the conceptual vulnerability. Actual exploitation depends on Vault server configuration and whether it normalizes paths. The fix should prevent the attack at the Aptos Core level regardless of Vault's behavior.

### Citations

**File:** config/src/config/secure_backend_config.rs (L53-74)
```rust
pub struct VaultConfig {
    /// Optional SSL Certificate for the vault host, this is expected to be a full path.
    pub ca_certificate: Option<PathBuf>,
    /// A namespace is an optional portion of the path to a key stored within Vault. For example,
    /// a secret, S, without a namespace would be available in secret/data/S, with a namespace, N, it
    /// would be in secret/data/N/S.
    pub namespace: Option<String>,
    /// Vault leverages leases on many tokens, specify this to automatically have your lease
    /// renewed up to that many seconds more. If this is not specified, the lease will not
    /// automatically be renewed.
    pub renew_ttl_secs: Option<u32>,
    /// Vault's URL, note: only HTTP is currently supported.
    pub server: String,
    /// The authorization token for accessing secrets
    pub token: Token,
    /// Disable check-and-set when writing secrets to Vault
    pub disable_cas: Option<bool>,
    /// Timeout for new vault socket connections, in milliseconds.
    pub connection_timeout_ms: Option<u64>,
    /// Timeout for generic vault operations (e.g., reads and writes), in milliseconds.
    pub response_timeout_ms: Option<u64>,
}
```

**File:** secure/storage/src/namespaced.rs (L45-47)
```rust
    fn namespaced(&self, name: &str) -> String {
        format!("{}{}{}", self.namespace, NAMESPACE_SEPARATOR, name)
    }
```

**File:** secure/storage/src/vault.rs (L155-165)
```rust
    fn get<T: DeserializeOwned>(&self, key: &str) -> Result<GetResponse<T>, Error> {
        let secret = key;
        let key = self.unnamespaced(key);
        let resp = self.client().read_secret(secret, key)?;
        let last_update = DateTime::parse_from_rfc3339(&resp.creation_time)?.timestamp() as u64;
        let value: T = serde_json::from_value(resp.value)?;
        self.secret_versions
            .write()
            .insert(key.to_string(), resp.version);
        Ok(GetResponse { last_update, value })
    }
```

**File:** secure/storage/vault/src/lib.rs (L255-262)
```rust
    pub fn read_secret(&self, secret: &str, key: &str) -> Result<ReadResponse<Value>, Error> {
        let request = self
            .agent
            .get(&format!("{}/v1/secret/data/{}", self.host, secret));
        let resp = self.upgrade_request(request).call();

        process_secret_read_response(secret, key, resp)
    }
```
