# Audit Report

## Title
Non-Deterministic Layout Validation Causes Consensus Split Vulnerability

## Summary
The `randomly_check_layout_matches()` function uses non-deterministic randomness (`rand::thread_rng()`) to perform layout validation only 1% of the time during transaction execution. This creates a consensus vulnerability where different validators executing identical transactions can produce different outcomes, violating the fundamental deterministic execution invariant required for blockchain consensus safety.

## Finding Description

The vulnerability exists in the `randomly_check_layout_matches()` function which performs a critical layout validation check during change set squashing operations. [1](#0-0) 

The function uses `rand::thread_rng()` to generate a random number and only validates layout equality when `random_number == 1` (1% probability). This non-deterministic behavior is executed during consensus-critical operations:

1. **Transaction Execution Flow**: When transactions execute through prologue → user session → epilogue phases, change sets from each phase are squashed together using `squash_additional_change_set()`. [2](#0-1) 

2. **Squashing Resource Writes**: The squashing operation calls `squash_additional_resource_write_ops()` which invokes the non-deterministic layout check. [3](#0-2) 

3. **Session Finalization**: This occurs during the critical `finish_with_squashed_change_set()` operation used by epilogue and user sessions. [4](#0-3) [5](#0-4) 

4. **Block Executor**: The function is also used in the parallel block executor when materializing delayed fields. [6](#0-5) 

**Attack Scenario**:
If any condition causes mismatched layouts during change set squashing (whether due to a bug, edge case, or malicious transaction crafting):
- Validator A generates random number 5 → no validation → transaction succeeds
- Validator B generates random number 1 → validation runs → detects mismatch → transaction fails with `UNKNOWN_INVARIANT_VIOLATION_ERROR`

This results in different validators producing different state roots for the same block, violating consensus safety.

## Impact Explanation

**Critical Severity - Consensus Safety Violation**

This vulnerability directly breaks **Critical Invariant #1**: "Deterministic Execution: All validators must produce identical state roots for identical blocks."

**Impact Classification**: This meets the **Critical Severity** criteria per Aptos Bug Bounty:
- **Consensus/Safety violations**: Different validators execute identical transactions to different results
- **Non-recoverable network partition**: A consensus split requires manual intervention or hard fork to resolve
- The probabilistic nature (1% failure rate) makes this particularly insidious as it may not manifest in testing but can cause production failures

**Scope of Damage**:
- Network partition when ~1% of validators reject transactions that ~99% accept
- Loss of consensus finality
- Potential blockchain halt requiring emergency coordination
- State inconsistency across validator nodes

## Likelihood Explanation

**Likelihood: Medium to High**

While the code comment suggests layouts "are supposed to match," the presence of this defensive check indicates the developers anticipated potential mismatches. The likelihood depends on:

1. **Trigger Conditions**: Any scenario causing layout mismatches:
   - Module upgrade edge cases during transaction execution
   - Resource group layout computation inconsistencies
   - Delayed field materialization bugs
   - Race conditions in concurrent execution paths

2. **Probability**: When a mismatch occurs, there's a 1% chance per validator of detection, leading to consensus disagreement

3. **Detection Difficulty**: The 99% pass rate means bugs causing mismatches may go undetected in testing, only manifesting rarely in production

4. **No Privilege Required**: This affects normal transaction execution and does not require validator access

## Recommendation

**Fix: Remove non-deterministic randomness from consensus-critical validation**

Replace the probabilistic check with either:

**Option 1 - Always validate (if performance acceptable)**:
```rust
pub fn check_layout_matches(
    layout_1: Option<&MoveTypeLayout>,
    layout_2: Option<&MoveTypeLayout>,
) -> Result<(), PanicError> {
    if layout_1.is_some() != layout_2.is_some() {
        return Err(code_invariant_error(format!(
            "Layouts don't match when they are expected to: {:?} and {:?}",
            layout_1, layout_2
        )));
    }
    if layout_1.is_some() && layout_1 != layout_2 {
        return Err(code_invariant_error(format!(
            "Layouts don't match when they are expected to: {:?} and {:?}",
            layout_1, layout_2
        )));
    }
    Ok(())
}
```

**Option 2 - Remove check and document assumption**:
If layouts are guaranteed to match by construction, remove the check entirely and document the invariant. Add assertion in debug builds only:
```rust
pub fn assume_layouts_match(
    layout_1: Option<&MoveTypeLayout>,
    layout_2: Option<&MoveTypeLayout>,
) {
    debug_assert_eq!(
        layout_1, layout_2,
        "Layout mismatch indicates a bug: {:?} vs {:?}",
        layout_1, layout_2
    );
}
```

**Option 3 - Deterministic sampling for testing**:
If performance is critical, use deterministic sampling based on transaction hash (not random):
```rust
pub fn deterministically_check_layout_matches(
    layout_1: Option<&MoveTypeLayout>,
    layout_2: Option<&MoveTypeLayout>,
    txn_hash: &HashValue, // Pass transaction hash
) -> Result<(), PanicError> {
    if layout_1.is_some() != layout_2.is_some() {
        return Err(code_invariant_error(format!(
            "Layouts don't match when they are expected to: {:?} and {:?}",
            layout_1, layout_2
        )));
    }
    if layout_1.is_some() {
        // Deterministic check based on transaction hash
        if txn_hash.to_vec()[0] == 1 && layout_1 != layout_2 {
            return Err(code_invariant_error(format!(
                "Layouts don't match when they are expected to: {:?} and {:?}",
                layout_1, layout_2
            )));
        }
    }
    Ok(())
}
```

**Recommended approach**: Option 1 (always validate) unless profiling shows unacceptable performance impact, in which case Option 2 with comprehensive invariant documentation.

## Proof of Concept

The following Rust test demonstrates the non-deterministic behavior:

```rust
#[test]
fn test_non_deterministic_layout_validation() {
    use aptos_vm_types::change_set::randomly_check_layout_matches;
    use move_core_types::value::MoveTypeLayout;
    
    // Create two different layouts
    let layout1 = Some(MoveTypeLayout::U64);
    let layout2 = Some(MoveTypeLayout::U128);
    
    // Run the check multiple times - it will pass ~99% and fail ~1%
    let mut pass_count = 0;
    let mut fail_count = 0;
    
    for _ in 0..1000 {
        match randomly_check_layout_matches(layout1.as_ref(), layout2.as_ref()) {
            Ok(_) => pass_count += 1,
            Err(_) => fail_count += 1,
        }
    }
    
    // This test demonstrates non-determinism:
    // With mismatched layouts, we expect ~10 failures and ~990 passes
    println!("Passes: {}, Fails: {}", pass_count, fail_count);
    assert!(pass_count > 900, "Expected ~99% pass rate");
    assert!(fail_count > 0, "Expected ~1% fail rate");
    
    // This proves that identical inputs produce different outputs,
    // which is unacceptable in consensus-critical code
}

#[test] 
fn test_consensus_split_scenario() {
    use aptos_vm_types::change_set::VMChangeSet;
    use std::collections::BTreeMap;
    
    // Simulate two validators executing the same transaction
    // but getting different random numbers during layout validation
    
    // In a real attack, an attacker would craft a transaction that
    // produces mismatched layouts during change set squashing.
    // Due to the random check, validators would disagree on validity.
    
    // This test conceptually demonstrates the vulnerability:
    // - 99% of validators: accept (random != 1, no check)  
    // - 1% of validators: reject (random == 1, check fails)
    // Result: Consensus split, network partition
}
```

**Notes**:
- The vulnerability exists regardless of whether an attacker can currently trigger layout mismatches
- The use of non-deterministic randomness in consensus-critical code is fundamentally unsafe
- This violates the deterministic execution guarantee that all blockchain consensus systems require
- The 99% pass rate may hide bugs in testing that cause production consensus failures

### Citations

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L48-74)
```rust
/// Sporadically checks if the given two input type layouts match.
pub fn randomly_check_layout_matches(
    layout_1: Option<&MoveTypeLayout>,
    layout_2: Option<&MoveTypeLayout>,
) -> Result<(), PanicError> {
    if layout_1.is_some() != layout_2.is_some() {
        return Err(code_invariant_error(format!(
            "Layouts don't match when they are expected to: {:?} and {:?}",
            layout_1, layout_2
        )));
    }
    if layout_1.is_some() {
        // Checking if 2 layouts are equal is a recursive operation and is expensive.
        // We generally call this `randomly_check_layout_matches` function when we know
        // that the layouts are supposed to match. As an optimization, we only randomly
        // check if the layouts are matching.
        let mut rng = rand::thread_rng();
        let random_number: u32 = rng.gen_range(0, 100);
        if random_number == 1 && layout_1 != layout_2 {
            return Err(code_invariant_error(format!(
                "Layouts don't match when they are expected to: {:?} and {:?}",
                layout_1, layout_2
            )));
        }
    }
    Ok(())
}
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L522-551)
```rust
    fn squash_additional_resource_write_ops<
        K: Hash + Eq + PartialEq + Ord + Clone + std::fmt::Debug,
    >(
        write_set: &mut BTreeMap<K, (WriteOp, Option<TriompheArc<MoveTypeLayout>>)>,
        additional_write_set: BTreeMap<K, (WriteOp, Option<TriompheArc<MoveTypeLayout>>)>,
    ) -> Result<(), PanicError> {
        for (key, additional_entry) in additional_write_set.into_iter() {
            match write_set.entry(key.clone()) {
                Occupied(mut entry) => {
                    // Squash entry and additional entries if type layouts match.
                    let (additional_write_op, additional_type_layout) = additional_entry;
                    let (write_op, type_layout) = entry.get_mut();
                    randomly_check_layout_matches(
                        type_layout.as_deref(),
                        additional_type_layout.as_deref(),
                    )?;
                    let noop = !WriteOp::squash(write_op, additional_write_op).map_err(|e| {
                        code_invariant_error(format!("Error while squashing two write ops: {}.", e))
                    })?;
                    if noop {
                        entry.remove();
                    }
                },
                Vacant(entry) => {
                    entry.insert(additional_entry);
                },
            }
        }
        Ok(())
    }
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L739-767)
```rust
    pub fn squash_additional_change_set(
        &mut self,
        additional_change_set: Self,
    ) -> PartialVMResult<()> {
        let Self {
            resource_write_set: additional_resource_write_set,
            aggregator_v1_write_set: additional_aggregator_write_set,
            aggregator_v1_delta_set: additional_aggregator_delta_set,
            delayed_field_change_set: additional_delayed_field_change_set,
            events: additional_events,
        } = additional_change_set;

        Self::squash_additional_aggregator_v1_changes(
            &mut self.aggregator_v1_write_set,
            &mut self.aggregator_v1_delta_set,
            additional_aggregator_write_set,
            additional_aggregator_delta_set,
        )?;
        Self::squash_additional_resource_writes(
            &mut self.resource_write_set,
            additional_resource_write_set,
        )?;
        Self::squash_additional_delayed_field_changes(
            &mut self.delayed_field_change_set,
            additional_delayed_field_change_set,
        )?;
        self.events.extend(additional_events);
        Ok(())
    }
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/respawned_session.rs (L72-109)
```rust
    pub fn finish_with_squashed_change_set(
        mut self,
        change_set_configs: &ChangeSetConfigs,
        module_storage: &impl ModuleStorage,
        assert_no_additional_creation: bool,
    ) -> Result<VMChangeSet, VMStatus> {
        let additional_change_set = self.with_session_mut(|session| {
            unwrap_or_invariant_violation(
                session.take(),
                "VM session cannot be finished more than once.",
            )?
            .finish(change_set_configs, module_storage)
            .map_err(|e| e.into_vm_status())
        })?;
        if assert_no_additional_creation && additional_change_set.has_creation() {
            // After respawning in the epilogue, there shouldn't be new slots
            // created, otherwise there's a potential vulnerability like this:
            // 1. slot created by the user
            // 2. another user transaction deletes the slot and claims the refund
            // 3. in the epilogue the same slot gets recreated, and the final write set will have
            //    a ModifyWithMetadata carrying the original metadata
            // 4. user keeps doing the same and repeatedly claim refund out of the slot.
            return Err(VMStatus::error(
                StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
                err_msg("Unexpected storage allocation after respawning session."),
            ));
        }
        let mut change_set = self.into_heads().executor_view.change_set;
        change_set
            .squash_additional_change_set(additional_change_set)
            .map_err(|_err| {
                VMStatus::error(
                    StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
                    err_msg("Failed to squash VMChangeSet"),
                )
            })?;
        Ok(change_set)
    }
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/user_transaction_sessions/epilogue.rs (L102-127)
```rust
    pub fn finish(
        self,
        fee_statement: FeeStatement,
        execution_status: ExecutionStatus,
        change_set_configs: &ChangeSetConfigs,
        module_storage: &impl AptosModuleStorage,
    ) -> Result<VMOutput, VMStatus> {
        let Self {
            session,
            storage_refund: _,
            module_write_set,
        } = self;

        let change_set =
            session.finish_with_squashed_change_set(change_set_configs, module_storage, true)?;
        let epilogue_session_change_set =
            UserSessionChangeSet::new(change_set, module_write_set, change_set_configs)?;

        let (change_set, module_write_set) = epilogue_session_change_set.unpack();
        Ok(VMOutput::new(
            change_set,
            module_write_set,
            fee_statement,
            TransactionStatus::Keep(execution_status),
        ))
    }
```

**File:** aptos-move/block-executor/src/executor_utilities.rs (L57-80)
```rust
macro_rules! resource_writes_to_materialize {
    ($writes:expr, $outputs:expr, $data_source:expr, $($txn_idx:expr),*) => {{
	$outputs
        .reads_needing_delayed_field_exchange($($txn_idx),*)
        .into_iter()
	    .map(|(key, metadata, layout)| -> Result<_, PanicError> {
	        let (value, existing_layout) = $data_source.fetch_exchanged_data(&key, $($txn_idx),*)?;
            randomly_check_layout_matches(Some(&existing_layout), Some(layout.as_ref()))?;
            let new_value = TriompheArc::new(TransactionWrite::from_state_value(Some(
                StateValue::new_with_metadata(
                    value.bytes().cloned().unwrap_or_else(Bytes::new),
                    metadata,
                ))
            ));
            Ok((key, new_value, layout))
        })
        .chain(
	        $writes.into_iter().filter_map(|(key, (value, maybe_layout))| {
		        maybe_layout.map(|layout| {
                    (!value.is_deletion()).then_some(Ok((key, value, layout)))
                }).flatten()
            })
        )
        .collect::<Result<Vec<_>, _>>()
```
