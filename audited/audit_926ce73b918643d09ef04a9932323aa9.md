# Audit Report

## Title
Event Sequence Number Corruption in Internal Indexer Due to Reading Future State During Event V2 Translation

## Summary
The internal indexer's event V2 translation engine incorrectly assigns sequence numbers to Offer (and other token transfer) events by reading the PendingClaims resource from the latest state checkpoint instead of the state at the version being indexed. This causes events to be indexed with incorrect sequence numbers, leading to out-of-order event presentation to external indexers and users viewing pending claims state.

## Finding Description
The vulnerability exists in the event translation pipeline where V2 events are converted to V1 events for indexing purposes. When the `OfferTranslator` processes an `Offer` event, it needs to determine the appropriate sequence number for the translated V1 event. [1](#0-0) 

The `get_state_value_bytes_for_resource` method uses `latest_state_checkpoint_view()` to read the PendingClaims resource, which returns state at the **latest committed version**, not the version being indexed. [2](#0-1) 

In the `OfferTranslator`, when the PendingClaims resource is not found in the persisted indexer DB or cache, it falls back to using `object_resource.offer_events().count()` as the default sequence number. This count reflects the state **after** all transactions up to the latest checkpoint, not the state at the version being indexed.

The vulnerability manifests when:
1. The internal indexer is processing version V (e.g., 100)
2. The main DB has advanced to version L (e.g., 200) 
3. Account A emitted their first Offer event at version 110
4. Account A emitted additional events at versions 150, 160, 170 (total count = 4 at version 200)
5. When indexing version 110, the translator reads PendingClaims from version 200 (count=4)
6. Since this is the first time indexing account A, cache and persisted DB are empty
7. The translator assigns sequence number 4 instead of 0 to the event at version 110
8. Subsequent events get sequence numbers 5, 6, 7 instead of 1, 2, 3 [3](#0-2) 

The `get_next_sequence_number` method correctly uses cached or persisted values when available, but when neither exists, it uses the `default` parameter which comes from the future state.

## Impact Explanation
This is a **Medium severity** vulnerability per the Aptos bug bounty criteria:
- **State inconsistencies requiring intervention**: The indexer produces incorrect event orderings that don't match the chronological transaction order
- **Limited manipulation**: While no funds are lost, users and external indexers viewing pending claims state will see events with incorrect sequence numbers, making it appear that events occurred in a different order than they actually did

The impact affects:
1. **External indexers** consuming event data from the internal indexer will see events with incorrect sequence numbers
2. **User-facing applications** displaying pending token offers/claims will show incorrect state
3. **Historical event queries** will return events in wrong order when sorted by sequence number
4. **Analytics and monitoring** tools relying on event sequencing will produce incorrect results

This breaks the state consistency invariant: indexed event data should accurately reflect the chronological order of on-chain events.

## Likelihood Explanation
**Likelihood: High**

This vulnerability occurs during normal operational conditions:
- The internal indexer commonly lags behind the main DB during initial sync, fast sync, or periods of high transaction volume
- No attacker action is required - it happens automatically when the indexer processes historical transactions while the chain continues advancing
- Affects all token transfer events (Offer, CancelOffer, Claim, and similar events for other resources)
- The issue is deterministic and reproducible whenever the indexer processes transactions from a version that is not the latest checkpoint

The only requirement is that the account being indexed has emitted events at versions between the version being indexed and the latest checkpoint, which is common during normal blockchain operation.

## Recommendation
The event translators should read state at the specific version being indexed, not the latest state checkpoint. The `DbStateView` already supports versioned state access: [4](#0-3) 

**Fix**: Modify `EventV2TranslationEngine` to accept and use a versioned state view:

```rust
// In event_v2_translator.rs
pub fn get_state_value_bytes_for_resource_at_version(
    &self,
    address: &AccountAddress,
    struct_tag: &StructTag,
    version: Version,
) -> Result<Option<Bytes>> {
    let state_view = self
        .main_db_reader
        .state_view_at_version(Some(version))
        .expect("Failed to get state view at version");
    let state_key = StateKey::resource(address, struct_tag)?;
    let maybe_state_value = state_view.get_state_value(&state_key)?;
    Ok(maybe_state_value.map(|state_value| state_value.bytes().clone()))
}
```

Update the `translate_event_v2_to_v1` signature to pass the version:

```rust
fn translate_event_v2_to_v1(
    &self,
    v2: &ContractEventV2,
    engine: &EventV2TranslationEngine,
    version: Version, // Add this parameter
) -> Result<ContractEventV1>;
``` [5](#0-4) 

Update the call site in `DBIndexer::translate_event_v2_to_v1` to pass the current version being indexed.

## Proof of Concept
```rust
#[test]
fn test_offer_event_sequence_number_corruption() {
    // Setup: Create test DB with transactions at versions 100-200
    let (db, indexer_db) = setup_test_dbs();
    
    // Version 100: Account A creates PendingClaims resource (count=0)
    execute_transaction_at_version(&db, 100, |txn| {
        // Initialize PendingClaims for account A
    });
    
    // Versions 110, 120, 130: Account A emits Offer events
    for version in [110, 120, 130] {
        execute_transaction_at_version(&db, version, |txn| {
            offer(&account_a, receiver, token_id, amount);
        });
    }
    
    // Main DB is now at version 200 (PendingClaims.offer_events.count() = 3)
    
    // Start indexer from version 100
    let indexer = DBIndexer::new(indexer_db, db.clone());
    
    // Index version 110 - should get sequence 0, but will get sequence 3
    indexer.process(110, 111);
    
    // Verify the bug: sequence number should be 0 but is actually 3
    let event = indexer_db.get_event_by_key(&event_key, 0, 1, 110);
    assert!(event.is_err(), "Should not find event at sequence 0");
    
    let event = indexer_db.get_event_by_key(&event_key, 3, 1, 110);
    assert!(event.is_ok(), "Event incorrectly assigned sequence 3 instead of 0");
    
    // This demonstrates the vulnerability: events get wrong sequence numbers
    // when indexer reads state from a future version
}
```

**Notes:**
- This vulnerability affects all event translators that read resource state to determine event handles and sequence numbers, including: CoinDepositTranslator, CoinWithdrawTranslator, OfferTranslator, CancelOfferTranslator, ClaimTranslator, and others
- The issue is exacerbated during initial sync or catch-up scenarios where the indexer processes large ranges of historical transactions
- External indexers consuming this data will see events with incorrect chronological ordering, leading to confusion about the actual sequence of pending claims operations

### Citations

**File:** storage/indexer/src/event_v2_translator.rs (L190-200)
```rust
    pub fn get_next_sequence_number(&self, event_key: &EventKey, default: u64) -> Result<u64> {
        if let Some(seq) = self.get_cached_sequence_number(event_key) {
            Ok(seq + 1)
        } else {
            let seq = self
                .internal_indexer_db
                .get::<EventSequenceNumberSchema>(event_key)?
                .map_or(default, |seq| seq + 1);
            Ok(seq)
        }
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L202-214)
```rust
    pub fn get_state_value_bytes_for_resource(
        &self,
        address: &AccountAddress,
        struct_tag: &StructTag,
    ) -> Result<Option<Bytes>> {
        let state_view = self
            .main_db_reader
            .latest_state_checkpoint_view()
            .expect("Failed to get state view");
        let state_key = StateKey::resource(address, struct_tag)?;
        let maybe_state_value = state_view.get_state_value(&state_key)?;
        Ok(maybe_state_value.map(|state_value| state_value.bytes().clone()))
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L878-914)
```rust
struct OfferTranslator;
impl EventV2Translator for OfferTranslator {
    fn translate_event_v2_to_v1(
        &self,
        v2: &ContractEventV2,
        engine: &EventV2TranslationEngine,
    ) -> Result<ContractEventV1> {
        let offer = Offer::try_from_bytes(v2.event_data())?;
        let struct_tag = StructTag::from_str("0x3::token_transfers::PendingClaims")?;
        let (key, sequence_number) = if let Some(state_value_bytes) =
            engine.get_state_value_bytes_for_resource(offer.account(), &struct_tag)?
        {
            let object_resource: PendingClaimsResource = bcs::from_bytes(&state_value_bytes)?;
            let key = *object_resource.offer_events().key();
            let sequence_number =
                engine.get_next_sequence_number(&key, object_resource.offer_events().count())?;
            (key, sequence_number)
        } else {
            // If the PendingClaims resource is not found, we skip the event translation to
            // avoid panic because the creation number cannot be decided.
            return Err(AptosDbError::from(anyhow::format_err!(
                "PendingClaims resource not found"
            )));
        };
        let offer_event = TokenOfferEvent::new(
            *offer.to_address(),
            offer.token_id().clone(),
            offer.amount(),
        );
        Ok(ContractEventV1::new(
            key,
            sequence_number,
            TOKEN_OFFER_EVENT_TYPE.clone(),
            bcs::to_bytes(&offer_event)?,
        )?)
    }
}
```

**File:** storage/storage-interface/src/state_store/state_view/db_state_view.rs (L93-105)
```rust
pub trait DbStateViewAtVersion {
    fn state_view_at_version(&self, version: Option<Version>) -> StateViewResult<DbStateView>;
}

impl DbStateViewAtVersion for Arc<dyn DbReader> {
    fn state_view_at_version(&self, version: Option<Version>) -> StateViewResult<DbStateView> {
        Ok(DbStateView {
            db: self.clone(),
            version,
            maybe_verify_against_state_root_hash: None,
        })
    }
}
```

**File:** storage/indexer/src/db_indexer.rs (L552-584)
```rust
    pub fn translate_event_v2_to_v1(
        &self,
        v2: &ContractEventV2,
    ) -> Result<Option<ContractEventV1>> {
        let _timer = TIMER.timer_with(&["translate_event_v2_to_v1"]);
        if let Some(translator) = self
            .event_v2_translation_engine
            .translators
            .get(v2.type_tag())
        {
            let result = translator.translate_event_v2_to_v1(v2, &self.event_v2_translation_engine);
            match result {
                Ok(v1) => Ok(Some(v1)),
                Err(e) => {
                    // If the token object collection uses ConcurrentSupply, skip the translation and ignore the error.
                    // This is expected, as the event handle won't be found in either FixedSupply or UnlimitedSupply.
                    let is_ignored_error = (v2.type_tag() == &*MINT_TYPE
                        || v2.type_tag() == &*BURN_TYPE)
                        && e.to_string().contains("resource not found");
                    if !is_ignored_error {
                        warn!(
                            "Failed to translate event: {:?}. Error: {}",
                            v2,
                            e.to_string()
                        );
                    }
                    Ok(None)
                },
            }
        } else {
            Ok(None)
        }
    }
```
