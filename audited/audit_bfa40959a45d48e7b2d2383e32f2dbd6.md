# Audit Report

## Title
Atomic State Transition Violation in User Transaction Success Path Error Handling

## Summary
When a user transaction executes successfully but subsequently fails during the success cleanup phase (in `success_transaction_cleanup`), the user session state changes are permanently lost while the transaction is still kept and committed with only partial changes (prologue + failure epilogue). This violates the atomic state transition guarantee that all validators must produce identical state roots for identical transactions.

## Finding Description

The vulnerability exists in the transaction execution flow within `execute_user_transaction_impl` and `execute_script_or_entry_function`. The issue manifests when:

1. A user transaction successfully completes prologue validation and main payload execution
2. The user session is finished, consuming all user-generated state changes into a `UserSessionChangeSet`
3. An `EpilogueSession` is created containing both prologue and user session changes
4. During `success_transaction_cleanup`, an error occurs (e.g., gas meter consistency check failure at line 840, or success epilogue execution failure at line 855)
5. The error causes the `EpilogueSession` to be dropped, permanently losing all user session changes
6. The error handler receives only the original `prologue_change_set` (without user changes)
7. If the `CHARGE_INVARIANT_VIOLATION` feature flag is enabled, the transaction is kept with a Keep status
8. The final `VMOutput` contains only prologue + failure epilogue changes, completely omitting the executed user session changes

**Critical Code Path:** [1](#0-0) 

The user session is finished and consumed into the epilogue session. If `success_transaction_cleanup` fails after this point, these changes are dropped. [2](#0-1) 

The gas meter consistency check can fail, returning an error that propagates to the error handler. [3](#0-2) 

The error handler receives only `prologue_change_set`, not the user session changes that were consumed into the dropped epilogue session. [4](#0-3) 

With `CHARGE_INVARIANT_VIOLATION` enabled, invariant violations result in Keep status, causing partial state to be committed.

## Impact Explanation

**Severity: Critical**

This vulnerability breaks the fundamental **State Consistency** invariant: "State transitions must be atomic and verifiable via Merkle proofs." It can lead to:

1. **Consensus Divergence**: If different validator nodes encounter this condition at different times (e.g., due to timing-dependent bugs in gas charging), they will commit different state roots for the same transaction, violating consensus safety.

2. **State Corruption**: User transactions that executed successfully have their state changes silently discarded, leading to inconsistent blockchain state where transaction effects are partially applied.

3. **Deterministic Execution Violation**: The same transaction input can produce different outputs depending on whether the success cleanup path fails, violating the guarantee that "all validators must produce identical state roots for identical blocks."

The impact is **Critical** because it directly threatens consensus safety and can cause non-recoverable network partitions requiring manual intervention or hard forks.

## Likelihood Explanation

The likelihood depends on two factors:

1. **Trigger Condition**: The gas meter consistency check failure or success epilogue failure requires an underlying bug in:
   - Gas charging logic (execution, IO, or storage fee calculations)
   - Move framework's success epilogue function
   - Change set squashing operations

2. **Feature Flag**: The `CHARGE_INVARIANT_VIOLATION` feature flag must be enabled for the transaction to be kept (as opposed to discarded).

While the trigger conditions require pre-existing bugs, the architectural flaw means that ANY bug in the success path amplifies into a state consistency violation. Given the complexity of the Move VM, gas metering, and native functions, the likelihood of encountering such bugs over time is **Medium to High**.

## Recommendation

The fix requires ensuring that user session changes are never lost once they've been finalized. There are two approaches:

**Option 1: Preserve user session changes for error recovery**

Store the `user_session_change_set` separately before creating the epilogue session, so it can be included in failure cleanup if needed.

**Option 2: Make success cleanup infallible**

Move the gas meter consistency check earlier (before finishing the user session), and ensure that once the user session is finished, the success path cannot fail. In the success cleanup: [2](#0-1) 

The consistency check should be moved to before line 1081 in `execute_script_or_entry_function`, before the user session is finished. If it fails at that point, the user session can be properly aborted and its changes discarded atomically.

Additionally, the success epilogue execution and finish operations should use defensive error handling that logs errors but doesn't fail the transaction once state changes have been committed to the epilogue session.

## Proof of Concept

```rust
// This PoC demonstrates the vulnerable code path
// In a real scenario, this would be triggered by a gas charging bug

#[test]
fn test_atomic_violation_gas_consistency_failure() {
    // Setup: Create a user transaction that executes successfully
    // 1. Transaction passes prologue
    // 2. User session executes and modifies state (e.g., transfers funds)
    // 3. User session is finished, changes consumed
    // 4. Epilogue session created with prologue + user changes
    
    // Trigger: Inject a gas meter consistency error
    // This would normally be caused by a bug in gas charging
    // For testing, we can use fail_point to simulate:
    // fail::cfg("aptos_vm::gas_meter::consistency_check", "return(err)");
    
    // Expected behavior: Transaction should either:
    // a) Succeed completely with all changes, OR
    // b) Fail and discard all changes
    
    // Actual behavior: Transaction is kept but user session changes are lost
    // Final state contains: prologue changes + failure epilogue
    // Missing: All user session state modifications
    
    // This can be verified by:
    // 1. Checking the VMOutput.change_set does not contain user modifications
    // 2. Comparing state roots - different nodes may have different roots
    // 3. Observing that user's intended transaction effects did not occur
}
```

**Notes:**

This vulnerability is a defensive programming failure that creates a pathway for state inconsistencies. While it requires an underlying bug to trigger, it transforms what would be a contained error (wrong gas charge) into a consensus-level failure (partial state commit). The fix should ensure that the transaction execution flow maintains atomic all-or-nothing semantics even when encountering unexpected errors in the success path.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L835-847)
```rust
        if self.gas_feature_version() >= 12 {
            // Check if the gas meter's internal counters are consistent.
            //
            // It's better to fail the transaction due to invariant violation than to allow
            // potentially bogus states to be committed.
            if let Err(err) = gas_meter.algebra().check_consistency() {
                println!(
                    "[aptos-vm][gas-meter][success-epilogue] {}",
                    err.message()
                        .unwrap_or("No message found -- this should not happen.")
                );
                return Err(err.finish(Location::Undefined).into());
            }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1081-1110)
```rust
        let user_session_change_set = self.resolve_pending_code_publish_and_finish_user_session(
            session,
            resolver,
            code_storage,
            gas_meter,
            traversal_context,
            change_set_configs,
        )?;

        let epilogue_session = self.charge_change_set_and_respawn_session(
            user_session_change_set,
            resolver,
            code_storage,
            gas_meter,
            txn_data,
        )?;

        // ============= Gas fee cannot change after this line =============

        self.success_transaction_cleanup(
            epilogue_session,
            code_storage,
            serialized_signers,
            gas_meter,
            txn_data,
            log_context,
            change_set_configs,
            traversal_context,
        )
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2105-2118)
```rust
        let (vm_status, mut output) = result.unwrap_or_else(|err| {
            self.on_user_transaction_execution_failure(
                prologue_change_set,
                err,
                resolver,
                code_storage,
                &serialized_signers,
                &txn_data,
                log_context,
                gas_meter,
                change_set_configs,
                &mut traversal_context,
            )
        });
```

**File:** types/src/transaction/mod.rs (L1640-1646)
```rust
                if code.status_type() == StatusType::InvariantViolation
                    && features.is_enabled(FeatureFlag::CHARGE_INVARIANT_VIOLATION)
                {
                    Self::Keep(ExecutionStatus::MiscellaneousError(Some(code)))
                } else {
                    Self::Discard(code)
                }
```
