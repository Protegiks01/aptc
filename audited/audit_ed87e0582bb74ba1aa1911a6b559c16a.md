# Audit Report

## Title
Inspection Service Exposes Validator IP Addresses Through Peer Information Endpoint

## Summary
The Aptos inspection service's `/peer_information` endpoint exposes connection metadata containing IP addresses of connected validators and peers. This endpoint is enabled by default and binds to all network interfaces (0.0.0.0), allowing any network client to correlate validator peer IDs with their IP addresses, compromising validator anonymity and enabling targeted attacks.

## Finding Description
The inspection service provides a `/peer_information` endpoint for debugging and monitoring purposes. When enabled, this endpoint returns detailed connection metadata for all connected peers, including their network addresses which contain IP addresses. [1](#0-0) 

The default configuration sets `expose_peer_information: true` and binds the service to `0.0.0.0:9101`, making it accessible from any network interface. [2](#0-1) 

The connection metadata includes the `addr` field of type `NetworkAddress`, which serializes to human-readable format containing IP addresses: [3](#0-2) 

When serialized to JSON (as done in the peer information handler), the `NetworkAddress` uses its `Display` implementation which formats addresses as `/ip4/1.2.3.4/tcp/6180/...`: [4](#0-3) [5](#0-4) 

**Attack Path:**
1. Attacker discovers a validator's inspection service at `http://<validator-ip>:9101`
2. Attacker queries `/peer_information` endpoint (no authentication required)
3. Attacker receives JSON response containing all connected peers' metadata
4. Attacker extracts peer IDs and corresponding IP addresses from the connection metadata
5. Attacker can now map the validator network topology and target specific validators

This violates validator privacy and the security principle of network-level anonymity that protects validators from targeted attacks.

## Impact Explanation
This qualifies as **Medium severity** information disclosure because:

1. **Enables Targeted Attacks**: Once validator IP addresses are known, attackers can launch targeted DDoS attacks against specific validators, potentially causing "validator node slowdowns" (High severity impact)

2. **Network Topology Mapping**: Adversaries can map the entire validator network, identifying critical nodes and attack vectors

3. **Privacy Violation**: Validators lose network-level anonymity, which is a critical security layer. If IP addresses can be linked to organizations/entities, it compromises operational security

4. **Default-Insecure Configuration**: The vulnerability exists by default without operator intervention, affecting all nodes that don't explicitly disable this endpoint or implement firewall rules

While this doesn't directly cause fund loss or consensus violations, it significantly weakens the network's defense-in-depth by removing the anonymity layer that protects validators from reconnaissance and targeted attacks.

## Likelihood Explanation
**High Likelihood** - This vulnerability is highly likely to be exploited because:

1. **Enabled by Default**: The endpoint is active on all nodes unless explicitly disabled
2. **No Authentication**: Any network client can access the endpoint
3. **Publicly Accessible**: Binds to 0.0.0.0 by default, exposing it to the internet unless firewalled
4. **Easy to Exploit**: Requires only a simple HTTP GET request
5. **High Value Target**: Validator network topology is valuable intelligence for adversaries

Many operators may not be aware of this exposure, especially since the endpoint is intended for debugging and monitoring.

## Recommendation

**Immediate Actions:**

1. **Change default configuration** to disable peer information exposure:
```rust
// In config/src/config/inspection_service_config.rs
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "127.0.0.1".to_string(), // Bind to localhost only
            port: 9101,
            expose_configuration: false,
            expose_identity_information: false,
            expose_peer_information: false, // Disable by default
            expose_system_information: false,
        }
    }
}
```

2. **Add authentication** to the inspection service endpoints for sensitive information

3. **Sanitize connection metadata** to remove IP addresses before exposing:
```rust
// In crates/aptos-inspection-service/src/server/peer_information.rs
// Before serializing connection_metadata, redact the IP address
let sanitized_metadata = ConnectionMetadataSanitized {
    remote_peer_id: connection_metadata.remote_peer_id,
    connection_id: connection_metadata.connection_id,
    // Omit addr field or replace with placeholder
    origin: connection_metadata.origin,
    messaging_protocol: connection_metadata.messaging_protocol,
    application_protocols: connection_metadata.application_protocols.clone(),
    role: connection_metadata.role,
};
```

4. **Documentation**: Add clear warnings in configuration documentation about the privacy implications of enabling this endpoint

5. **Network Policy**: Recommend firewall rules to restrict inspection service access to trusted networks only

## Proof of Concept

**Setup:**
1. Deploy a validator node with default configuration
2. Ensure inspection service is accessible (default: `0.0.0.0:9101`)

**Exploitation:**
```bash
# Query the peer information endpoint
curl http://<validator-ip>:9101/peer_information

# Response contains connection metadata like:
# Connection metadata for each peer:
#   - Peer: 0a1b2c..., connection state: Connected, 
#     connection metadata: {"remote_peer_id":"0a1b2c...","connection_id":123,
#     "addr":"/ip4/192.168.1.100/tcp/6180/noise-ik/...","origin":"Inbound",...}

# Extract IP addresses:
curl http://<validator-ip>:9101/peer_information | grep -oP 'ip4/\K[0-9.]+' | sort -u

# Result: List of all connected validator IP addresses
# 192.168.1.100
# 192.168.1.101
# 192.168.1.102
# ...
```

**Verification:**
```rust
// Test demonstrating the exposure
#[tokio::test]
async fn test_ip_exposure_via_peer_information() {
    let mut config = NodeConfig::get_default_validator_config();
    config.inspection_service.expose_peer_information = true;
    
    let response = send_get_request_to_path(&config, PEER_INFORMATION_PATH).await;
    let body = body::to_bytes(response.body_mut()).await.unwrap();
    let body_string = String::from_utf8(body.to_vec()).unwrap();
    
    // Verify that IP addresses are exposed in connection metadata
    assert!(body_string.contains("/ip4/") || body_string.contains("/ip6/"));
    // This proves that peer IP addresses are included in the response
}
```

## Notes

- This issue affects all Aptos nodes (validators, VFNs, PFNs) that run the inspection service with default configuration
- The `/identity_information` endpoint separately exposes the node's own peer ID, allowing attackers to correlate the local node's peer ID with its IP address
- For non-mainnet deployments, the config optimizer automatically enables this endpoint if not explicitly configured, increasing the attack surface
- Operators should immediately review their firewall rules and consider disabling this endpoint or binding it to localhost only for production deployments

### Citations

**File:** config/src/config/inspection_service_config.rs (L26-36)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L148-168)
```rust
/// Displays connection metadata for each peer
fn display_peer_connection_metadata(
    peer_information_output: &mut Vec<String>,
    all_peers: &Vec<PeerNetworkId>,
    peers_and_metadata: &PeersAndMetadata,
) {
    peer_information_output.push("Connection metadata for each peer:".into());

    // Fetch and display the connection metadata for each peer
    for peer in all_peers {
        if let Ok(peer_metadata) = peers_and_metadata.get_metadata_for_peer(*peer) {
            let connection_metadata = peer_metadata.get_connection_metadata();
            peer_information_output.push(format!(
                "\t- Peer: {}, connection state: {:?}, connection metadata: {}",
                peer,
                peer_metadata.get_connection_state(),
                serde_json::to_string(&connection_metadata).unwrap_or_default()
            ));
        }
    }
}
```

**File:** network/framework/src/transport/mod.rs (L98-108)
```rust
/// Metadata associated with an established and fully upgraded connection.
#[derive(Clone, Deserialize, Eq, PartialEq, Serialize)]
pub struct ConnectionMetadata {
    pub remote_peer_id: PeerId,
    pub connection_id: ConnectionId,
    pub addr: NetworkAddress,
    pub origin: ConnectionOrigin,
    pub messaging_protocol: MessagingProtocolVersion,
    pub application_protocols: ProtocolIdSet,
    pub role: PeerRole,
}
```

**File:** types/src/network_address/mod.rs (L529-545)
```rust
impl Serialize for NetworkAddress {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        if serializer.is_human_readable() {
            serializer.serialize_str(&self.to_string())
        } else {
            #[derive(Serialize)]
            #[serde(rename = "NetworkAddress")]
            struct Wrapper<'a>(#[serde(with = "serde_bytes")] &'a [u8]);

            bcs::to_bytes(&self.as_slice())
                .map_err(serde::ser::Error::custom)
                .and_then(|v| Wrapper(&v).serialize(serializer))
        }
    }
```

**File:** types/src/network_address/mod.rs (L598-618)
```rust
impl fmt::Display for Protocol {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        use self::Protocol::*;
        match self {
            Ip4(addr) => write!(f, "/ip4/{}", addr),
            Ip6(addr) => write!(f, "/ip6/{}", addr),
            Dns(domain) => write!(f, "/dns/{}", domain),
            Dns4(domain) => write!(f, "/dns4/{}", domain),
            Dns6(domain) => write!(f, "/dns6/{}", domain),
            Tcp(port) => write!(f, "/tcp/{}", port),
            Memory(port) => write!(f, "/memory/{}", port),
            NoiseIK(pubkey) => write!(
                f,
                "/noise-ik/{}",
                pubkey
                    .to_encoded_string()
                    .expect("ValidCryptoMaterialStringExt::to_encoded_string is infallible")
            ),
            Handshake(version) => write!(f, "/handshake/{}", version),
        }
    }
```
