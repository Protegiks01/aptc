# Audit Report

## Title
State KV Pruner Progress Regression Vulnerability: Missing Monotonicity Validation in write_pruner_progress()

## Summary
The `write_pruner_progress()` function in `state_kv_db.rs` lacks validation to ensure the pruner version is monotonically increasing. This allows the pruner progress to be regressed to earlier versions, creating inconsistencies between the recorded progress and actual pruned state, leading to incorrect error reporting and resource waste.

## Finding Description
The `write_pruner_progress()` function unconditionally writes any version value to the database without validating that it is greater than or equal to the current pruner progress. [1](#0-0) 

This function writes to `DbMetadataKey::StateKvPrunerProgress`, which is also written by the actual pruning process after deleting stale state values: [2](#0-1) 

The pruning process permanently deletes state data: [3](#0-2) 

**Attack Scenario:**
1. System operates normally, pruning state up to version 1000
2. All stale state values with `stale_since_version <= 1000` are permanently deleted
3. `StateKvPrunerProgress` is correctly set to 1000
4. A state sync operation or administrative call invokes `finalize_state_snapshot()` with version 500: [4](#0-3) 

5. This calls `save_min_readable_version(500)`, which calls `write_pruner_progress(500)` with no validation: [5](#0-4) 

6. The database progress is now regressed to 500, but versions 500-1000 are already deleted
7. The `min_readable_version` is also set to 500, which controls read validation: [6](#0-5) 

8. Clients requesting state values between versions 500-999 will pass the pruning check (line 308) but the data is already deleted, returning `None` instead of a proper "data is pruned" error

This breaks the **State Consistency** invariant that requires atomic and verifiable state transitions.

## Impact Explanation
This vulnerability qualifies as **Medium Severity** per Aptos bug bounty criteria because it causes "State inconsistencies requiring intervention":

1. **Incorrect Error Reporting**: Clients believe data exists when it's actually pruned, receiving `None` instead of proper error messages
2. **Resource Waste**: The pruner re-iterates over already-deleted ranges on subsequent runs
3. **Monitoring Confusion**: Metrics show regressed pruning progress, misleading operators
4. **Inconsistent State Between Components**: Metadata pruner progress regresses while shard pruner progresses remain high, creating synchronization issues

This does not rise to Critical/High severity because it does not:
- Directly cause loss of funds or consensus violations
- Permanently corrupt the blockchain state
- Require a hard fork to recover

However, it does require manual intervention to detect and correct the inconsistent state.

## Likelihood Explanation
The likelihood is **Medium** because:

**Triggering Conditions:**
- Requires a code path that calls `save_min_readable_version()` with a version lower than current progress
- Most commonly during state sync operations or snapshot restoration
- Could occur through implementation bugs in state sync logic or administrative errors

**Exploitability:**
- Not directly exploitable by external attackers without compromising node operations
- Could be triggered inadvertently through buggy state sync implementations
- Affects all nodes that experience this condition

The issue is realistic because state sync and snapshot operations are common, and edge cases in version handling could trigger this vulnerability.

## Recommendation
Add monotonicity validation in `write_pruner_progress()` to prevent regression:

```rust
pub(crate) fn write_pruner_progress(&self, version: Version) -> Result<()> {
    // Read current progress
    let current_progress = get_progress(
        &self.state_kv_metadata_db,
        &DbMetadataKey::StateKvPrunerProgress,
    )?
    .unwrap_or(0);
    
    // Validate monotonicity
    ensure!(
        version >= current_progress,
        "Attempted to regress StateKvPrunerProgress from {} to {}",
        current_progress,
        version
    );
    
    self.state_kv_metadata_db.put::<DbMetadataSchema>(
        &DbMetadataKey::StateKvPrunerProgress,
        &DbMetadataValue::Version(version),
    )
}
```

Additionally, add similar validation in `StateKvPrunerManager::save_min_readable_version()` to catch issues at the manager level.

## Proof of Concept
```rust
#[test]
fn test_pruner_progress_regression() {
    use aptos_temppath::TempPath;
    use aptos_config::config::RocksdbConfigs;
    
    // Setup test database
    let tmpdir = TempPath::new();
    let db_paths = StorageDirPaths::from_path(&tmpdir);
    let state_kv_db = Arc::new(StateKvDb::open_sharded(
        &db_paths,
        RocksdbConfig::default(),
        None,
        None,
        false,
    ).unwrap());
    
    // Simulate normal pruning up to version 1000
    state_kv_db.write_pruner_progress(1000).unwrap();
    
    // Verify progress is 1000
    let progress = get_progress(
        state_kv_db.metadata_db(),
        &DbMetadataKey::StateKvPrunerProgress
    ).unwrap().unwrap_or(0);
    assert_eq!(progress, 1000);
    
    // Attempt to regress to version 500 (should fail with fix, succeeds without)
    state_kv_db.write_pruner_progress(500).unwrap();
    
    // Progress is now regressed to 500 - VULNERABILITY CONFIRMED
    let regressed_progress = get_progress(
        state_kv_db.metadata_db(),
        &DbMetadataKey::StateKvPrunerProgress
    ).unwrap().unwrap_or(0);
    assert_eq!(regressed_progress, 500); // This should NOT be allowed!
}
```

## Notes
This vulnerability affects the integrity of the pruning subsystem and can lead to operational issues. While not immediately critical to consensus or fund security, it violates state consistency guarantees and requires careful handling of pruner progress updates across all code paths that interact with this functionality.

### Citations

**File:** storage/aptosdb/src/state_kv_db.rs (L217-222)
```rust
    pub(crate) fn write_pruner_progress(&self, version: Version) -> Result<()> {
        self.state_kv_metadata_db.put::<DbMetadataSchema>(
            &DbMetadataKey::StateKvPrunerProgress,
            &DbMetadataValue::Version(version),
        )
    }
```

**File:** storage/aptosdb/src/pruner/state_kv_pruner/state_kv_metadata_pruner.rs (L62-63)
```rust
                batch.delete::<StaleStateValueIndexSchema>(&index)?;
                batch.delete::<StateValueSchema>(&(index.state_key, index.version))?;
```

**File:** storage/aptosdb/src/pruner/state_kv_pruner/state_kv_metadata_pruner.rs (L67-70)
```rust
        batch.put::<DbMetadataSchema>(
            &DbMetadataKey::StateKvPrunerProgress,
            &DbMetadataValue::Version(target_version),
        )?;
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L225-234)
```rust
            self.ledger_pruner.save_min_readable_version(version)?;
            self.state_store
                .state_merkle_pruner
                .save_min_readable_version(version)?;
            self.state_store
                .epoch_snapshot_pruner
                .save_min_readable_version(version)?;
            self.state_store
                .state_kv_pruner
                .save_min_readable_version(version)?;
```

**File:** storage/aptosdb/src/pruner/state_kv_pruner/state_kv_pruner_manager.rs (L57-66)
```rust
    fn save_min_readable_version(&self, min_readable_version: Version) -> Result<()> {
        self.min_readable_version
            .store(min_readable_version, Ordering::SeqCst);

        PRUNER_VERSIONS
            .with_label_values(&["state_kv_pruner", "min_readable"])
            .set(min_readable_version as i64);

        self.state_kv_db.write_pruner_progress(min_readable_version)
    }
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L305-312)
```rust
    pub(super) fn error_if_state_kv_pruned(&self, data_type: &str, version: Version) -> Result<()> {
        let min_readable_version = self.state_store.state_kv_pruner.get_min_readable_version();
        ensure!(
            version >= min_readable_version,
            "{} at version {} is pruned, min available version is {}.",
            data_type,
            version,
            min_readable_version
```
