# Audit Report

## Title
State Cache Hot/Cold Classification Mismatch Causes Node Crash via Assertion Failure

## Summary
The `to_result_slot()` function always creates hot slots (HotOccupied/HotVacant) when populating the state cache during commit, violating an invariant assumption in the hot state promotion logic. This causes a deterministic assertion failure and node crash when processing MakeHot operations for keys that were previously written.

## Finding Description

The vulnerability exists in the interaction between two components:

1. **Cache Population During Commit**: When committing state updates, the function `put_stale_state_value_index_for_shard` populates the state cache by calling `to_result_slot()`, which always creates hot slots regardless of whether the data should be classified as cold. [1](#0-0) [2](#0-1) 

2. **Hot State Promotion Logic**: When applying MakeHot operations (generated for read-heavy keys), the `apply_one_update` function expects to find cold slots in the cache for keys not already in the hot state LRU. [3](#0-2) 

The code explicitly asserts that the slot retrieved from the cache must be cold before converting it to hot. This assumption is violated when the cache contains hot slots from previous commits. [4](#0-3) 

**Attack Path:**
1. Attacker submits transaction T1 in block N that writes to state key K (e.g., modifying a resource)
2. During block N commit, `to_result_slot()` creates a HotOccupied slot for K and inserts it into the state cache
3. In block N+1, attacker submits transaction T2 that reads key K without writing to it
4. The block executor generates a MakeHot operation for K (as it's read-only but frequently accessed)
5. During MakeHot processing, `apply_one_update` calls `expect_old_slot()` which retrieves K from the cache
6. The retrieved slot is hot (not cold), causing the assertion `assert!(slot.is_cold())` to fail
7. Node panics and crashes

**Invariant Broken:** This violates the **Deterministic Execution** invariant - nodes can crash due to internal state management bugs, causing availability issues and potential consensus disruption.

## Impact Explanation

**Severity: High** (per Aptos bug bounty: "Validator node slowdowns, API crashes")

- **Availability Impact**: Causes validator nodes to crash via assertion failure, disrupting network operation
- **Liveness Risk**: Multiple validators experiencing this crash simultaneously could threaten network liveness
- **Consensus Impact**: While not directly breaking consensus safety, widespread crashes could prevent the network from making progress
- **Reproducibility**: The crash is deterministic once the conditions are met, making it repeatedly exploitable

This meets the High Severity criteria as it causes "API crashes" and can lead to "significant protocol violations" through availability disruption.

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability can be triggered through normal blockchain operations:
- No special privileges required - any user can submit transactions
- The attacker doesn't need to directly control MakeHot generation; they only need to create access patterns that trigger it (write to a key in one block, read in the next)
- The block executor automatically generates MakeHot operations based on access patterns, making this exploitable through transaction crafting
- Common DeFi operations (write state in one transaction, read in follow-up transactions) could naturally trigger this

The TODO comments in the codebase indicate this is a known architectural issue: [5](#0-4) 

However, the presence of the assertion suggests the issue wasn't fully understood or addressed, allowing it to cause production crashes.

## Recommendation

**Immediate Fix**: Modify `to_result_slot()` to preserve or determine the correct hot/cold classification based on context, or remove the assertion and handle both hot and cold slots gracefully.

**Option 1 - Conditional Slot Creation**:
Modify `to_result_slot()` to accept a parameter indicating whether the slot should be hot or cold, and use it appropriately during cache population.

**Option 2 - Remove Assertion** (safer short-term fix):
In `apply_one_update`, check whether the slot is hot or cold and handle both cases instead of asserting:

```rust
let mut slot = Self::expect_old_slot(overlay, read_cache, key);
if slot.is_cold() {
    slot = slot.to_hot(update.version);
}
// slot is now guaranteed to be hot
```

**Option 3 - Separate Cache Classifications**:
Maintain separate caches for hot and cold state, ensuring `to_result_slot()` inserts into the appropriate cache based on the actual state classification.

The TODO comments suggest the team is working toward making hot and cold state exclusive, which would be the proper long-term solution.

## Proof of Concept

```rust
// Reproduction steps for validator node crash

// 1. Setup: Deploy a Move module with a resource
module attacker::crash_trigger {
    use std::signer;
    
    struct CrashState has key {
        value: u64
    }
    
    // Transaction T1: Write to key (block N)
    public entry fun write_state(account: &signer, val: u64) {
        move_to(account, CrashState { value: val });
    }
    
    // Transaction T2: Read-only access (block N+1)
    // This will trigger MakeHot generation
    public entry fun read_state(addr: address): u64 acquires CrashState {
        borrow_global<CrashState>(addr).value
    }
}

// Execution flow:
// Block N: Call write_state() 
//   → StateUpdateRef with Creation operation
//   → Commit calls to_result_slot() → HotOccupied inserted into cache
//
// Block N+1: Call read_state() multiple times (to trigger MakeHot)
//   → Block executor generates MakeHot for frequently read key
//   → apply_one_update reads from cache → gets HotOccupied
//   → assert!(slot.is_cold()) FAILS
//   → Node crashes with "Should not be called on hot slots" panic
```

The vulnerability can be demonstrated by:
1. Submitting a transaction that creates/modifies state
2. In subsequent blocks, repeatedly reading that state without modification
3. Observing the node crash when the block executor generates a MakeHot operation for the frequently-read key

## Notes

This vulnerability is particularly concerning because:
- It affects core state management logic used across all transaction executions
- The TODO comments indicate developer awareness of the architectural issue but the unsafe assertion was left in place
- The crash is deterministic and repeatable, enabling targeted DoS attacks
- It could be accidentally triggered by legitimate high-frequency DeFi protocols that exhibit write-then-read-heavy patterns

The hot/cold state classification system appears to be undergoing active development, but production safeguards (like removing unsafe assertions) should be prioritized to prevent node crashes.

### Citations

**File:** storage/storage-interface/src/state_store/versioned_state_value.rs (L19-35)
```rust
    pub fn to_result_slot(&self) -> Option<StateSlot> {
        match self.state_op.clone() {
            BaseStateOp::Creation(value) | BaseStateOp::Modification(value) => {
                Some(StateSlot::HotOccupied {
                    value_version: self.version,
                    value,
                    hot_since_version: self.version,
                    lru_info: LRUEntry::uninitialized(),
                })
            },
            BaseStateOp::Deletion(_) => Some(StateSlot::HotVacant {
                hot_since_version: self.version,
                lru_info: LRUEntry::uninitialized(),
            }),
            BaseStateOp::MakeHot => None,
        }
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L954-961)
```rust
                let old_entry = cache
                    // TODO(HotState): Revisit: assuming every write op results in a hot slot
                    .insert(
                        (*key).clone(),
                        update_to_cold
                            .to_result_slot()
                            .expect("hot state ops should have been filtered out above"),
                    )
```

**File:** storage/storage-interface/src/state_store/state.rs (L318-325)
```rust
        } else {
            let slot = Self::expect_old_slot(overlay, read_cache, key);
            assert!(slot.is_cold());
            let slot = slot.to_hot(update.version);
            let ret = HotStateValue::clone_from_slot(&slot);
            lru.insert((*key).clone(), slot);
            Some(ret)
        }
```

**File:** storage/storage-interface/src/state_store/state.rs (L370-385)
```rust
    fn expect_old_slot(
        overlay: &LayeredMap<StateKey, StateSlot>,
        cache: &StateCacheShard,
        key: &StateKey,
    ) -> StateSlot {
        if let Some(slot) = overlay.get(key) {
            return slot;
        }

        // TODO(aldenhu): avoid cloning the state value (by not using DashMap)
        cache
            .get(key)
            .unwrap_or_else(|| panic!("Key {:?} must exist in the cache.", key))
            .value()
            .clone()
    }
```
