# Audit Report

## Title
Indexer Panic Vulnerability via Missing Table Metadata Leading to Service Disruption

## Summary
The Aptos indexer contains an unchecked `.unwrap()` call when processing `WriteTableItem` objects with a `None` data field, causing the indexer process to panic and crash. This results in service disruption and loss of blockchain state availability.

## Finding Description

The vulnerability exists in the indexer's table item processing logic. When the API layer creates `WriteTableItem` objects, the `data` field is explicitly defined as `Optional<DecodedTableData>` and can legitimately be `None` when table metadata is unavailable. [1](#0-0) 

The API conversion logic returns `None` for the data field when table information cannot be found: [2](#0-1) 

The comment at line 565 states "if table item not found return None anyway to avoid crash," but this ironically causes a crash in the indexer.

The indexer unconditionally unwraps this optional field without checking if it's `None`: [3](#0-2) [4](#0-3) [5](#0-4) 

**Attack Flow:**
1. A transaction writes to a table on-chain
2. The table metadata is not available in the indexer reader (e.g., node started after table creation, sync lag, or indexer reader not configured)
3. The API layer creates a `WriteTableItem` with `data = None`
4. The indexer processes the write set changes via `WriteSetChangeModel::from_write_set_changes()`
5. This calls `TableItem::from_write_table_item()` or `TableMetadata::from_write_table_item()`
6. The `.unwrap()` call on line 66, 67, 74, 75, 127, or 128 panics
7. The indexer process crashes [6](#0-5) 

The table metadata is retrieved through the indexer reader, which can return `None`: [7](#0-6) 

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria because it causes:

1. **Indexer crashes**: The panic terminates the indexer process entirely
2. **Service disruption**: The indexer must be manually restarted and may repeatedly crash on the same block
3. **Loss of blockchain state availability**: While the indexer crashes, blockchain state cannot be queried via the indexer API
4. **Data integrity concerns**: Crashed indexer may leave the database in an inconsistent state

The vulnerability qualifies as "API crashes" and "Significant protocol violations" under High Severity criteria. While it doesn't affect consensus or validator nodes directly, it impacts critical infrastructure that applications rely on for querying blockchain state.

## Likelihood Explanation

This vulnerability has a **HIGH likelihood** of occurrence because:

1. **Legitimate scenarios exist** where table metadata is unavailable:
   - Node started after table creation (metadata not yet synced)
   - Indexer reader not properly configured
   - Database lag or sync issues
   - Tables created before indexer was enabled

2. **No attacker privilege required**: Any transaction that writes to a table can trigger this if metadata is missing

3. **Common operational scenario**: Indexers are frequently started on existing chains where historical table metadata may not be fully available

4. **Automatic triggering**: Once the condition exists, the crash happens automatically during normal transaction processing

## Recommendation

Replace all `.unwrap()` calls with proper error handling or default values. The code should gracefully handle missing table metadata:

```rust
pub fn from_write_table_item(
    write_table_item: &WriteTableItem,
    write_set_change_index: i64,
    transaction_version: i64,
    transaction_block_height: i64,
) -> Result<(Self, CurrentTableItem), anyhow::Error> {
    let data = write_table_item.data.as_ref()
        .ok_or_else(|| anyhow::anyhow!(
            "Missing decoded table data for table handle {} at version {}. \
             Table metadata may not be available.",
            write_table_item.handle,
            transaction_version
        ))?;
    
    Ok((
        Self {
            transaction_version,
            write_set_change_index,
            transaction_block_height,
            key: write_table_item.key.to_string(),
            table_handle: standardize_address(&write_table_item.handle.to_string()),
            decoded_key: data.key.clone(),
            decoded_value: Some(data.value.clone()),
            is_deleted: false,
        },
        CurrentTableItem {
            table_handle: standardize_address(&write_table_item.handle.to_string()),
            key_hash: hash_str(&write_table_item.key.to_string()),
            key: write_table_item.key.to_string(),
            decoded_key: data.key.clone(),
            decoded_value: Some(data.value.clone()),
            last_transaction_version: transaction_version,
            is_deleted: false,
        },
    ))
}
```

Similarly update `TableMetadata::from_write_table_item()` to return `Result<Self, anyhow::Error>` and handle the None case.

The calling code in `write_set_changes.rs` should skip processing table items when metadata is unavailable or log warnings instead of crashing.

## Proof of Concept

```rust
#[test]
fn test_panic_on_none_data() {
    use aptos_api_types::{WriteTableItem, HexEncodedBytes};
    
    // Create a WriteTableItem with None data field (simulating missing table metadata)
    let write_table_item = WriteTableItem {
        state_key_hash: "0x123".to_string(),
        handle: HexEncodedBytes(vec![0x01]),
        key: HexEncodedBytes(vec![0x02]),
        value: HexEncodedBytes(vec![0x03]),
        data: None, // This will cause the panic
    };
    
    // This will panic with "called `Option::unwrap()` on a `None` value"
    let result = std::panic::catch_unwind(|| {
        TableItem::from_write_table_item(
            &write_table_item,
            0,
            1,
            1
        )
    });
    
    assert!(result.is_err(), "Expected panic but function succeeded");
}
```

To demonstrate in a live environment:
1. Start an indexer node without proper indexer_reader configuration
2. Process transactions containing table writes
3. Observe the indexer panic and crash when it encounters a WriteTableItem with None data

### Citations

**File:** api/types/src/transaction.rs (L1178-1187)
```rust
pub struct WriteTableItem {
    pub state_key_hash: String,
    pub handle: HexEncodedBytes,
    pub key: HexEncodedBytes,
    pub value: HexEncodedBytes,
    // This is optional, and only possible to populate if the table indexer is enabled for this node
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub data: Option<DecodedTableData>,
}
```

**File:** api/types/src/convert.rs (L555-578)
```rust
    pub fn try_write_table_item_into_decoded_table_data(
        &self,
        handle: TableHandle,
        key: &[u8],
        value: &[u8],
    ) -> Result<Option<DecodedTableData>> {
        let table_info = match self.get_table_info(handle)? {
            Some(ti) => ti,
            None => {
                log_missing_table_info(handle);
                return Ok(None); // if table item not found return None anyway to avoid crash
            },
        };

        let key = self.try_into_move_value(&table_info.key_type, key)?;
        let value = self.try_into_move_value(&table_info.value_type, value)?;

        Ok(Some(DecodedTableData {
            key: key.json().unwrap(),
            key_type: table_info.key_type.to_canonical_string(),
            value: value.json().unwrap(),
            value_type: table_info.value_type.to_canonical_string(),
        }))
    }
```

**File:** api/types/src/convert.rs (L1060-1065)
```rust
    fn get_table_info(&self, handle: TableHandle) -> Result<Option<TableInfo>> {
        if let Some(indexer_reader) = self.indexer_reader.as_ref() {
            return Ok(indexer_reader.get_table_info(handle).unwrap_or(None));
        }
        Ok(None)
    }
```

**File:** crates/indexer/src/models/move_tables.rs (L66-67)
```rust
                decoded_key: write_table_item.data.as_ref().unwrap().key.clone(),
                decoded_value: Some(write_table_item.data.as_ref().unwrap().value.clone()),
```

**File:** crates/indexer/src/models/move_tables.rs (L74-75)
```rust
                decoded_key: write_table_item.data.as_ref().unwrap().key.clone(),
                decoded_value: Some(write_table_item.data.as_ref().unwrap().value.clone()),
```

**File:** crates/indexer/src/models/move_tables.rs (L127-128)
```rust
            key_type: table_item.data.as_ref().unwrap().key_type.clone(),
            value_type: table_item.data.as_ref().unwrap().value_type.clone(),
```

**File:** crates/indexer/src/models/write_set_changes.rs (L118-139)
```rust
            APIWriteSetChange::WriteTableItem(table_item) => {
                let (ti, cti) = TableItem::from_write_table_item(
                    table_item,
                    index,
                    transaction_version,
                    transaction_block_height,
                );
                (
                    Self {
                        transaction_version,
                        hash: table_item.state_key_hash.clone(),
                        transaction_block_height,
                        type_,
                        address: String::default(),
                        index,
                    },
                    WriteSetChangeDetail::Table(
                        ti,
                        cti,
                        Some(TableMetadata::from_write_table_item(table_item)),
                    ),
                )
```
