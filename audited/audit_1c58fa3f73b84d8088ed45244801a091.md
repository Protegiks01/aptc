# Audit Report

## Title
Integer Overflow in WeightedConfig Initialization Leading to Consensus-Critical Index Collisions

## Summary
The `WeightedConfig::new()` function in `crates/aptos-crypto/src/weighted_config.rs` lacks overflow protection when computing cumulative starting indices and total weight sums. If extremely large weights are provided, silent integer overflow could cause multiple validators to map to identical virtual player IDs, breaking the cryptographic secret sharing protocol used in consensus randomness generation. [1](#0-0) 

## Finding Description

The vulnerability exists in two stages:

**Stage 1: Initialization Overflow**
When `WeightedConfig::new()` builds the `starting_index` array, it iteratively sums weights without overflow checks: [2](#0-1) 

Additionally, the total weight sum at line 81 uses unchecked arithmetic: [3](#0-2) 

If weights are `[usize::MAX/2 + 1, usize::MAX/2 + 1, 10]`, then:
- `starting_index[0] = 0`
- `starting_index[1] = usize::MAX/2 + 1` 
- `starting_index[2] = (usize::MAX/2 + 1) + (usize::MAX/2 + 1) = OVERFLOW → wraps to 1`
- `W = sum overflows → wraps to 10`

**Stage 2: Usage Overflow**
The corrupted `starting_index` is then used in `get_share_index()`: [4](#0-3) 

With corrupted indices, `get_virtual_player()` returns colliding player IDs: [5](#0-4) 

**Consensus Impact**
`WeightedConfig` is used in DKG (Distributed Key Generation) for consensus randomness: [6](#0-5) 

The weighted configuration determines how validator shares are mapped during secret reconstruction. Index collisions would cause:
- Multiple validators to claim ownership of the same virtual shares
- Secret reconstruction to use incorrect share combinations  
- Different validators to reconstruct different randomness values
- **Consensus safety violation** - validators commit different random beacons

This breaks the "Deterministic Execution" and "Cryptographic Correctness" invariants.

## Impact Explanation

**Severity: Critical (Consensus Safety Violation)**

If triggered, this vulnerability causes:
1. **Consensus Failure**: Validators reconstruct different randomness values, preventing agreement
2. **Non-Deterministic State**: Different nodes compute different random seeds, causing state divergence
3. **Potential Chain Split**: Validators may commit conflicting blocks due to different leader elections
4. **Requires Hardfork**: Recovery would need coordinated validator restart with fixed code

Per Aptos bug bounty criteria, this qualifies as **Critical Severity** (up to $1,000,000) due to "Consensus/Safety violations" and potential "Non-recoverable network partition."

## Likelihood Explanation

**Likelihood: Very Low (Theoretical Only)**

While the code lacks overflow protection, exploitation in production is **not realistic** because:

1. **Bounded Input Source**: Validator weights are derived from on-chain stakes via `DKGRounding`: [7](#0-6) 

2. **Economic Constraints**: 
   - Total APT supply ≈ 1 billion APT = 10^17 OCTAS
   - Individual stakes are fractions of total supply
   - Sum of all stakes ≈ 10^17
   
3. **Overflow Threshold**:
   - On 64-bit systems: `usize::MAX = 2^64 - 1 ≈ 1.8 × 10^19`
   - Requires weights summing to >10^19
   - Current stake totals are ~100x too small to trigger overflow

4. **No Direct Attack Vector**: `WeightedConfig::new()` is only called via `DKGRounding`, which bounds weights appropriately.

**This vulnerability requires a prior bug** that allows artificially inflated stakes (100x beyond total supply), making it a defense-in-depth issue rather than a directly exploitable vulnerability.

## Recommendation

Add overflow protection using checked arithmetic:

```rust
pub fn new(threshold_weight: usize, weights: Vec<usize>) -> anyhow::Result<Self> {
    // ... existing validation ...
    
    // Check total weight with overflow protection
    let W = weights.iter().try_fold(0usize, |acc, &w| {
        acc.checked_add(w).ok_or_else(|| anyhow!("total weight overflow"))
    })?;
    
    // Build starting_index with overflow protection
    let mut starting_index = Vec::with_capacity(weights.len());
    starting_index.push(0);
    
    for w in weights.iter().take(n - 1) {
        let next_index = starting_index.last().unwrap()
            .checked_add(*w)
            .ok_or_else(|| anyhow!("starting_index overflow at position {}", starting_index.len()))?;
        starting_index.push(next_index);
    }
    
    // Also add check in get_share_index for defense-in-depth
    // ... rest of function ...
}

pub fn get_share_index(&self, i: usize, j: usize) -> Option<usize> {
    if j < self.weights[i] {
        self.starting_index[i].checked_add(j)
    } else {
        None
    }
}
```

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "overflow")]
fn test_weight_overflow_protection() {
    use aptos_crypto::WeightedConfigBlstrs;
    
    // Construct weights that would overflow
    let half_max = usize::MAX / 2;
    let weights = vec![half_max + 1, half_max + 1, 10];
    
    // This should fail with overflow error after fix
    let result = WeightedConfigBlstrs::new(5, weights);
    
    // Before fix: succeeds with corrupted starting_index
    // After fix: returns Err with "overflow" message
    assert!(result.is_err());
}

#[test]
fn test_index_collision_without_overflow_protection() {
    use aptos_crypto::{WeightedConfigBlstrs, player::Player};
    
    // Without overflow protection, this creates index collision
    let half_max = usize::MAX / 2;
    let weights = vec![half_max + 1, half_max + 1, 10];
    
    // Current code: succeeds but has corrupted state
    if let Ok(wconfig) = WeightedConfigBlstrs::new(5, weights) {
        let player0 = Player { id: 0 };
        let player2 = Player { id: 2 };
        
        // Player 2's first virtual player should have high ID
        // but due to overflow, it collides with player 0's range
        let vp2_0 = wconfig.get_virtual_player(&player2, 0);
        
        // This demonstrates the collision (if overflow occurred)
        assert!(vp2_0.id < 100, "Index collision detected: player 2 maps to low ID");
    }
}
```

## Notes

While this is a real code defect (lack of overflow protection in consensus-critical cryptographic code), it does **not meet the "realistic attack path" criterion** from the validation checklist. Exploitation requires validator stakes to exceed total token supply by ~100x, which is not possible without a separate critical vulnerability in the staking system.

This represents a **defense-in-depth** issue: the code should validate its invariants even when upstream guarantees exist. The fix is recommended to prevent potential exploitation if future code changes inadvertently allow larger weights, or if Aptos migrates to 32-bit systems where overflow thresholds are lower.

### Citations

**File:** crates/aptos-crypto/src/weighted_config.rs (L67-105)
```rust
    pub fn new(threshold_weight: usize, weights: Vec<usize>) -> anyhow::Result<Self> {
        if threshold_weight == 0 {
            return Err(anyhow!(
                "expected the minimum reconstruction weight to be > 0"
            ));
        }

        if weights.is_empty() {
            return Err(anyhow!("expected a non-empty vector of player weights"));
        }
        let max_weight = *weights.iter().max().unwrap();
        let min_weight = *weights.iter().min().unwrap();

        let n = weights.len();
        let W = weights.iter().sum();

        // e.g., Suppose the weights for players 0, 1 and 2 are [2, 4, 3]
        // Then, our PVSS transcript implementation will store a vector of 2 + 4 + 3 = 9 shares,
        // such that:
        //  - Player 0 will own the shares at indices [0..2), i.e.,starting index 0
        //  - Player 1 will own the shares at indices [2..2 + 4) = [2..6), i.e.,starting index 2
        //  - Player 2 will own the shares at indices [6, 6 + 3) = [6..9), i.e., starting index 6
        let mut starting_index = Vec::with_capacity(weights.len());
        starting_index.push(0);

        for w in weights.iter().take(n - 1) {
            starting_index.push(starting_index.last().unwrap() + w);
        }

        let tc = TC::new(threshold_weight, W)?;
        Ok(WeightedConfig {
            tc,
            num_players: n,
            weights,
            starting_index,
            max_weight,
            min_weight,
        })
    }
```

**File:** crates/aptos-crypto/src/weighted_config.rs (L177-184)
```rust
    pub fn get_virtual_player(&self, player: &Player, j: usize) -> Player {
        // println!("WeightedConfig::get_virtual_player({player}, {i})");
        assert_lt!(j, self.weights[player.id]);

        let id = self.get_share_index(player.id, j).unwrap();

        Player { id }
    }
```

**File:** crates/aptos-crypto/src/weighted_config.rs (L199-205)
```rust
    pub fn get_share_index(&self, i: usize, j: usize) -> Option<usize> {
        if j < self.weights[i] {
            Some(self.starting_index[i] + j)
        } else {
            None
        }
    }
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L61-106)
```rust
    pub fn new(
        validator_stakes: &Vec<u64>,
        secrecy_threshold_in_stake_ratio: U64F64,
        mut reconstruct_threshold_in_stake_ratio: U64F64,
        fast_secrecy_threshold_in_stake_ratio: Option<U64F64>,
    ) -> Self {
        reconstruct_threshold_in_stake_ratio = max(
            reconstruct_threshold_in_stake_ratio,
            secrecy_threshold_in_stake_ratio + U64F64::DELTA,
        );

        let total_weight_min = total_weight_lower_bound(validator_stakes);
        let total_weight_max = total_weight_upper_bound(
            validator_stakes,
            reconstruct_threshold_in_stake_ratio,
            secrecy_threshold_in_stake_ratio,
        );

        let (profile, rounding_error, rounding_method) = match DKGRoundingProfile::new(
            validator_stakes,
            total_weight_min,
            total_weight_max,
            secrecy_threshold_in_stake_ratio,
            reconstruct_threshold_in_stake_ratio,
            fast_secrecy_threshold_in_stake_ratio,
        ) {
            Ok(profile) => (profile, None, "binary_search".to_string()),
            Err(e) => {
                let profile = DKGRoundingProfile::infallible(
                    validator_stakes,
                    secrecy_threshold_in_stake_ratio,
                    reconstruct_threshold_in_stake_ratio,
                    fast_secrecy_threshold_in_stake_ratio,
                );
                (profile, Some(format!("{e}")), "infallible".to_string())
            },
        };
        let wconfig = WeightedConfigBlstrs::new(
            profile.reconstruct_threshold_in_weights as usize,
            profile
                .validator_weights
                .iter()
                .map(|w| *w as usize)
                .collect(),
        )
        .unwrap();
```
