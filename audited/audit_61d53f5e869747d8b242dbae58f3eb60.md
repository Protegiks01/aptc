# Audit Report

## Title
Unauthenticated Remote Transaction Execution via Missing Interceptor Implementation in Remote Executor Service

## Summary
The Remote Executor Service's gRPC endpoint accepts and executes arbitrary transactions from any network peer without authentication. Despite the availability of the `with_interceptor()` method for adding authentication, no interceptor is implemented in the actual service instantiation, creating a critical security vulnerability where attackers can remotely execute unauthorized transactions.

## Finding Description

The security question asks whether the interceptor added via `with_interceptor()` properly validates messages. The critical finding is that **no interceptor is added at all**, leaving the service completely unauthenticated.

The vulnerability spans multiple components:

1. **Missing Interceptor Implementation**: The gRPC server is instantiated without any interceptor, despite the `with_interceptor()` method being available. [1](#0-0) 

2. **Unauthenticated Message Processing**: The `simple_msg_exchange` method accepts `NetworkMessage` requests from any source without authentication or sender validation. [2](#0-1) 

3. **Direct Execution Command Acceptance**: The `RemoteCoordinatorClient` deserializes and processes execution commands without verifying the sender's identity or authorization. [3](#0-2) 

4. **Unconditional Transaction Execution**: The `ShardedExecutorService` executes transactions from received commands without any security checks. [4](#0-3) 

**Attack Flow:**

1. Attacker discovers the executor service endpoint (exposed on a network socket address passed via CLI arguments) [5](#0-4) 

2. Attacker connects to the service over plain HTTP (no TLS) [6](#0-5) 

3. Attacker crafts a malicious gRPC request containing:
   - `message_type` = `"execute_command_{target_shard_id}"`
   - `message` = BCS-serialized `RemoteExecutionRequest::ExecuteBlock` with arbitrary transactions [7](#0-6) 

4. Service accepts the request without authentication and routes it to the registered handler based solely on message_type

5. The handler deserializes the command and creates an `ExecutorShardCommand::ExecuteSubBlocks` with the attacker's transactions [8](#0-7) 

6. The executor service processes the command and executes the malicious transactions using the block executor [9](#0-8) 

7. Execution results are sent back to the attacker, potentially leaking sensitive state information [10](#0-9) 

This breaks the **Access Control** invariant (unauthorized access to critical execution infrastructure) and the **Transaction Validation** invariant (bypasses normal transaction validation and consensus flow).

## Impact Explanation

This vulnerability qualifies as **CRITICAL** severity under the Aptos Bug Bounty criteria for the following reasons:

1. **Remote Code Execution**: Attackers can execute arbitrary Move transactions on the executor service, potentially including malicious bytecode that could exploit VM vulnerabilities or consume excessive resources.

2. **Consensus Safety Violations**: Unauthorized transaction execution outside the normal consensus flow could lead to state inconsistencies between nodes, potentially causing consensus splits or state divergence.

3. **State Manipulation**: Execution results affect the blockchain state. While the normal state commitment flow may provide some protection, unauthorized execution could be used to probe for vulnerabilities or cause state-related DoS.

4. **Information Disclosure**: Execution results returned to the attacker could leak sensitive internal state information, transaction data, or implementation details useful for further attacks.

5. **Resource Exhaustion**: Attackers can submit resource-intensive transactions to cause validator node slowdowns or denial of service.

While this service may be intended for internal use within a trusted cluster, the lack of authentication violates defense-in-depth principles and creates exploitability vectors through network segmentation failures or misconfigurations.

## Likelihood Explanation

**Likelihood: Medium to High**

The exploitability depends on network exposure:

1. **If Exposed to Public Internet**: HIGH likelihood - Any attacker can directly exploit the vulnerability with minimal effort.

2. **If Internal Only**: MEDIUM likelihood - Requires network perimeter breach or misconfiguration, but once inside the network, exploitation is trivial.

**Attacker Requirements:**
- Network connectivity to the executor service endpoint
- Knowledge of the gRPC protocol and message format (publicly available in protobuf definitions)
- Ability to craft BCS-serialized `RemoteExecutionRequest` messages (standard Rust/BCS libraries)

**No Special Privileges Required:**
- No validator credentials needed
- No private keys required
- No authentication bypass necessary (because there's no authentication)

The vulnerability is straightforward to exploit and requires no advanced techniques or insider knowledge beyond the publicly available codebase.

## Recommendation

Implement proper authentication and authorization using tonic interceptors:

1. **Add Mutual TLS Authentication**: Configure the gRPC server to require client certificates for authentication.

2. **Implement Custom Interceptor**: Create an interceptor that validates authentication tokens or certificates before processing requests.

3. **Use the Existing `with_interceptor()` Method**: Modify the server instantiation to include authentication:

```rust
// In secure/net/src/grpc_network_service/mod.rs
// Instead of:
NetworkMessageServiceServer::new(self).max_decoding_message_size(MAX_MESSAGE_SIZE)

// Use:
NetworkMessageServiceServer::new(self)
    .with_interceptor(AuthenticationInterceptor::new(/* auth config */))
    .max_decoding_message_size(MAX_MESSAGE_SIZE)
```

4. **Implement Authorization Checks**: Even with authentication, verify that the authenticated peer is authorized to send execution commands to the specific shard.

5. **Add TLS/HTTPS**: Change from plain HTTP to HTTPS with proper certificate validation [11](#0-10) 

6. **Network Segmentation**: Ensure the remote executor service runs in an isolated network segment with strict firewall rules, even with authentication implemented (defense in depth).

7. **Add Request Signing**: Require all execution commands to be cryptographically signed by authorized coordinator nodes.

## Proof of Concept

```rust
// PoC: Unauthenticated remote execution exploit
// File: exploit.rs

use aptos_protos::remote_executor::v1::{
    network_message_service_client::NetworkMessageServiceClient,
    NetworkMessage,
};
use aptos_executor_service::{ExecuteBlockCommand, RemoteExecutionRequest};
use aptos_types::block_executor::partitioner::SubBlocksForShard;
use aptos_types::block_executor::config::BlockExecutorConfigFromOnchain;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 1. Connect to the remote executor service (no authentication required)
    let target_service = "http://executor-shard-0:port"; // Replace with actual endpoint
    let mut client = NetworkMessageServiceClient::connect(target_service).await?;
    
    // 2. Craft malicious execution command
    let malicious_command = ExecuteBlockCommand {
        sub_blocks: SubBlocksForShard::empty(0), // Could contain malicious transactions
        concurrency_level: 1,
        onchain_config: BlockExecutorConfigFromOnchain::default(),
    };
    
    let request = RemoteExecutionRequest::ExecuteBlock(malicious_command);
    
    // 3. Serialize the command
    let serialized = bcs::to_bytes(&request)?;
    
    // 4. Send the unauthenticated request
    let network_msg = NetworkMessage {
        message: serialized,
        message_type: "execute_command_0".to_string(), // Target shard 0
    };
    
    // 5. Execute - no authentication check will occur
    let response = client.simple_msg_exchange(network_msg).await?;
    
    println!("Successfully sent unauthenticated execution command!");
    println!("Response: {:?}", response);
    
    Ok(())
}
```

**Compilation and Execution:**
```bash
# Add dependencies to Cargo.toml:
# aptos-protos = { workspace = true }
# aptos-executor-service = { workspace = true }
# aptos-types = { workspace = true }
# bcs = { workspace = true }
# tonic = { workspace = true }
# tokio = { workspace = true, features = ["full"] }

cargo build --release
./target/release/exploit
```

This PoC demonstrates that any network peer can send execution commands to the remote executor service without any authentication, authorization, or validation.

## Notes

**Scope Clarification**: While the remote executor service appears designed for internal cluster communication between coordinator and executor shards, the complete absence of authentication creates a critical vulnerability. Even internal services should implement authentication following defense-in-depth principles, as network segmentation failures or misconfigurations can expose these services to attackers.

**Interceptor Design**: The tonic framework provides the `with_interceptor()` method specifically for implementing authentication and authorization middleware. The fact that this method is auto-generated but never utilized in the implementation represents a fundamental security oversight.

**Alternative Attack Vectors**: Beyond direct execution commands, the same unauthenticated channel could be exploited for cross-shard message injection [12](#0-11)  and remote key-value request manipulation [13](#0-12) , further expanding the attack surface.

### Citations

**File:** secure/net/src/grpc_network_service/mod.rs (L78-78)
```rust
                NetworkMessageServiceServer::new(self).max_decoding_message_size(MAX_MESSAGE_SIZE),
```

**File:** secure/net/src/grpc_network_service/mod.rs (L93-115)
```rust
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
```

**File:** secure/net/src/grpc_network_service/mod.rs (L128-137)
```rust
                .block_on(async { Self::get_channel(format!("http://{}", remote_addr)).await }),
        }
    }

    async fn get_channel(remote_addr: String) -> NetworkMessageServiceClient<Channel> {
        info!("Trying to connect to remote server at {:?}", remote_addr);
        let conn = tonic::transport::Endpoint::new(remote_addr)
            .unwrap()
            .connect_lazy();
        NetworkMessageServiceClient::new(conn).max_decoding_message_size(MAX_MESSAGE_SIZE)
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L80-113)
```rust
    fn receive_execute_command(&self) -> ExecutorShardCommand<RemoteStateViewClient> {
        match self.command_rx.recv() {
            Ok(message) => {
                let _rx_timer = REMOTE_EXECUTOR_TIMER
                    .with_label_values(&[&self.shard_id.to_string(), "cmd_rx"])
                    .start_timer();
                let bcs_deser_timer = REMOTE_EXECUTOR_TIMER
                    .with_label_values(&[&self.shard_id.to_string(), "cmd_rx_bcs_deser"])
                    .start_timer();
                let request: RemoteExecutionRequest = bcs::from_bytes(&message.data).unwrap();
                drop(bcs_deser_timer);

                match request {
                    RemoteExecutionRequest::ExecuteBlock(command) => {
                        let init_prefetch_timer = REMOTE_EXECUTOR_TIMER
                            .with_label_values(&[&self.shard_id.to_string(), "init_prefetch"])
                            .start_timer();
                        let state_keys = Self::extract_state_keys(&command);
                        self.state_view_client.init_for_block(state_keys);
                        drop(init_prefetch_timer);

                        let (sub_blocks, concurrency, onchain_config) = command.into();
                        ExecutorShardCommand::ExecuteSubBlocks(
                            self.state_view_client.clone(),
                            sub_blocks,
                            concurrency,
                            onchain_config,
                        )
                    },
                }
            },
            Err(_) => ExecutorShardCommand::Stop,
        }
    }
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L115-119)
```rust
    fn send_execution_result(&self, result: Result<Vec<Vec<TransactionOutput>>, VMStatus>) {
        let remote_execution_result = RemoteExecutionResult::new(result);
        let output_message = bcs::to_bytes(&remote_execution_result).unwrap();
        self.result_tx.send(Message::new(output_message)).unwrap();
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_executor_service.rs (L223-255)
```rust
            let command = self.coordinator_client.receive_execute_command();
            match command {
                ExecutorShardCommand::ExecuteSubBlocks(
                    state_view,
                    transactions,
                    concurrency_level_per_shard,
                    onchain_config,
                ) => {
                    num_txns += transactions.num_txns();
                    trace!(
                        "Shard {} received ExecuteBlock command of block size {} ",
                        self.shard_id,
                        num_txns
                    );
                    let exe_timer = SHARDED_EXECUTOR_SERVICE_SECONDS
                        .timer_with(&[&self.shard_id.to_string(), "execute_block"]);
                    let ret = self.execute_block(
                        transactions,
                        state_view.as_ref(),
                        BlockExecutorConfig {
                            local: BlockExecutorLocalConfig::default_with_concurrency_level(
                                concurrency_level_per_shard,
                            ),
                            onchain: onchain_config,
                        },
                    );
                    drop(state_view);
                    drop(exe_timer);

                    let _result_tx_timer = SHARDED_EXECUTOR_SERVICE_SECONDS
                        .timer_with(&[&self.shard_id.to_string(), "result_tx"]);
                    self.coordinator_client.send_execution_result(ret);
                },
```

**File:** execution/executor-service/src/main.rs (L20-24)
```rust
    #[clap(long, num_args = 1..)]
    pub remote_executor_addresses: Vec<SocketAddr>,

    #[clap(long)]
    pub coordinator_address: SocketAddr,
```

**File:** execution/executor-service/src/lib.rs (L43-53)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum RemoteExecutionRequest {
    ExecuteBlock(ExecuteBlockCommand),
}

#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ExecuteBlockCommand {
    pub(crate) sub_blocks: SubBlocksForShard<AnalyzedTransaction>,
    pub(crate) concurrency_level: usize,
    pub(crate) onchain_config: BlockExecutorConfigFromOnchain,
}
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L1-10)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE
use aptos_secure_net::network_controller::{Message, NetworkController};
use aptos_types::block_executor::partitioner::{RoundId, ShardId, MAX_ALLOWED_PARTITIONING_ROUNDS};
use aptos_vm::sharded_block_executor::{
    cross_shard_client::CrossShardClient, messages::CrossShardMsg,
};
use crossbeam_channel::{Receiver, Sender};
use std::{
    net::SocketAddr,
```

**File:** execution/executor-service/src/remote_state_view.rs (L1-10)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE
use crate::{RemoteKVRequest, RemoteKVResponse};
use aptos_secure_net::network_controller::{Message, NetworkController};
use aptos_types::state_store::state_key::StateKey;
use aptos_vm::sharded_block_executor::remote_state_value::RemoteStateValue;
use crossbeam_channel::{Receiver, Sender};
use std::{
    net::SocketAddr,
    sync::{Arc, RwLock},
```
