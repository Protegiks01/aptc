# Audit Report

## Title
Per-User Mempool Capacity Bypass via Dual Transaction Type Exploitation

## Summary
The mempool's `insert()` function checks per-user capacity limits separately for sequence number transactions and orderless (nonce-based) transactions, allowing a single user to submit up to 1100 transactions (100 sequence + 1000 nonce) instead of the intended 100 per-user limit, enabling efficient mempool resource exhaustion attacks.

## Finding Description

The mempool enforces per-user transaction limits to prevent individual accounts from monopolizing mempool resources. However, the capacity checks are implemented separately for the two transaction types: [1](#0-0) 

The code checks `seq_num_txns_len()` against `capacity_per_user` and `orderless_txns_len()` against `orderless_txn_capacity_per_user` independently. The underlying data structure stores these transaction types in separate maps: [2](#0-1) 

With default configuration values: [3](#0-2) [4](#0-3) 

**Attack Scenario:**
1. Attacker creates 100 sequence number transactions (reaching `capacity_per_user` limit)
2. Attacker creates 1000 nonce-based transactions (reaching `orderless_txn_capacity_per_user` limit)
3. Total transactions for single user: **1100** (11x the intended 100 limit)

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." The per-user capacity is designed to ensure fair resource distribution, but this bypass allows disproportionate consumption.

**Propagation:**
- With just 1000 malicious accounts, an attacker can fill 1,100,000 transactions
- This consumes over 50% of the default global capacity (2,000,000 transactions)
- Legitimate users' transactions are rejected with `MempoolIsFull` errors
- The global capacity check provides ultimate protection but doesn't prevent the per-user limit bypass: [5](#0-4) 

## Impact Explanation

**Medium Severity** per Aptos bug bounty criteria:

1. **State Inconsistencies Requiring Intervention**: The per-user limit enforcement is inconsistent with its intended design. Operators must manually adjust configurations or investigate anomalous mempool behavior.

2. **Resource Exhaustion (Non-Critical)**: While not causing total network unavailability, this enables efficient DoS attacks where small number of attackers consume disproportionate resources:
   - 1000 accounts × 1100 txns = 1,100,000 transactions (55% of global capacity)
   - Compare to properly enforced: 1000 accounts × 100 txns = 100,000 transactions (5% of global capacity)
   - **11x attack amplification factor**

3. **Validator Performance Degradation**: Bloated mempool with 11x more transactions per user affects:
   - Mempool garbage collection performance
   - Transaction broadcasting overhead
   - Memory consumption per account

This does not meet **Critical** or **High** severity because:
- No funds loss or consensus violations
- Global capacity check prevents complete mempool overflow
- No validator node crashes or permanent network damage

## Likelihood Explanation

**High Likelihood:**

1. **Easy to Execute**: Any user can create both transaction types without special privileges. Nonce-based transactions are a production feature: [6](#0-5) 

2. **Low Attack Cost**: Creating 1000 accounts is trivial, and the attacker benefits from 11x amplification

3. **No Special Detection**: The vulnerability is in core mempool logic with no warnings or monitoring for this bypass pattern

4. **Production Feature**: Orderless transactions are actively used and tested: [7](#0-6) 

## Recommendation

Enforce a combined per-user transaction limit across both transaction types. Modify the capacity check to validate total transactions:

```rust
// After line 319 in transaction_store.rs
self.transactions.entry(address).or_default();
if let Some(txns) = self.transactions.get_mut(&address) {
    // NEW: Combined capacity check
    let total_txns = txns.len();
    let max_total_capacity = self.capacity_per_user + self.orderless_txn_capacity_per_user;
    
    if total_txns >= max_total_capacity {
        return MempoolStatus::new(MempoolStatusCode::TooManyTransactions).with_message(
            format!(
                "Mempool over capacity for account. Total transactions: {} Max capacity: {}",
                total_txns,
                max_total_capacity
            ),
        );
    }
    
    // Existing separate checks (keep for backwards compatibility/specific limits)
    match txn_replay_protector {
        ReplayProtector::SequenceNumber(_) => { /* existing check */ },
        ReplayProtector::Nonce(_) => { /* existing check */ },
    }
    
    // ... rest of function
}
```

Alternatively, if separate limits are intended, update configuration documentation to clarify that per-user capacity is `capacity_per_user + orderless_txn_capacity_per_user` total.

## Proof of Concept

```rust
#[test]
fn test_per_user_capacity_bypass() {
    use crate::core_mempool::CoreMempool;
    use aptos_config::config::NodeConfig;
    use aptos_types::transaction::ReplayProtector;
    
    // Setup mempool with default config
    let config = NodeConfig::default();
    let mut mempool = CoreMempool::new(&config.mempool);
    
    let test_account = AccountAddress::random();
    
    // Step 1: Add 100 sequence number transactions (max capacity_per_user)
    for seq in 0..100 {
        let txn = TestTransaction::new_with_address(
            test_account,
            ReplayProtector::SequenceNumber(seq),
            1,
        ).make_signed_transaction();
        
        let status = mempool.add_txn(
            txn.clone(),
            txn.gas_unit_price(),
            Some(seq),
            TimelineState::NotReady,
            false,
            None,
            None,
        );
        assert_eq!(status.code, MempoolStatusCode::Accepted);
    }
    
    // Step 2: Try to add 101st sequence number transaction (should fail)
    let txn = TestTransaction::new_with_address(
        test_account,
        ReplayProtector::SequenceNumber(100),
        1,
    ).make_signed_transaction();
    
    let status = mempool.add_txn(
        txn.clone(),
        txn.gas_unit_price(),
        Some(100),
        TimelineState::NotReady,
        false,
        None,
        None,
    );
    assert_eq!(status.code, MempoolStatusCode::TooManyTransactions);
    
    // Step 3: Add 1000 nonce-based transactions (max orderless_txn_capacity_per_user)
    for nonce in 0..1000 {
        let txn = TestTransaction::new_with_address(
            test_account,
            ReplayProtector::Nonce(nonce),
            1,
        ).make_signed_transaction();
        
        let status = mempool.add_txn(
            txn.clone(),
            txn.gas_unit_price(),
            None,
            TimelineState::NotReady,
            false,
            None,
            None,
        );
        // VULNERABILITY: This succeeds, allowing 1100 total transactions
        assert_eq!(status.code, MempoolStatusCode::Accepted);
    }
    
    // Verify the bypass: user has 1100 transactions total
    let account_txns = mempool.get_transaction_store()
        .get_transactions()
        .get(&test_account)
        .unwrap();
    
    assert_eq!(account_txns.len(), 1100); // 100 seq + 1000 nonce
    assert_eq!(account_txns.seq_num_txns_len(), 100);
    assert_eq!(account_txns.orderless_txns_len(), 1000);
    
    // Expected behavior: should have rejected transactions after total exceeds intended limit
    // Actual behavior: accepts 11x more transactions than intended per-user limit
}
```

## Notes

The vulnerability is confirmed through code analysis. The separate capacity checks for sequence number and orderless transactions allow a single user to bypass the intended per-user resource limit by exploiting both transaction types simultaneously. While global mempool capacity provides ultimate protection, the 11x amplification factor significantly reduces the number of accounts needed for effective DoS attacks and violates the design intent of per-user fairness guarantees.

### Citations

**File:** mempool/src/core_mempool/transaction_store.rs (L311-317)
```rust
        if self.check_is_full_after_eviction(&txn, account_sequence_number) {
            return MempoolStatus::new(MempoolStatusCode::MempoolIsFull).with_message(format!(
                "Mempool is full. Mempool size: {}, Capacity: {}",
                self.system_ttl_index.size(),
                self.capacity,
            ));
        }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L322-345)
```rust
            match txn_replay_protector {
                ReplayProtector::SequenceNumber(_) => {
                    if txns.seq_num_txns_len() >= self.capacity_per_user {
                        return MempoolStatus::new(MempoolStatusCode::TooManyTransactions).with_message(
                            format!(
                                "Mempool over capacity for account. Number of seq number transactions from account: {} Capacity per account: {}",
                                txns.seq_num_txns_len() ,
                                self.capacity_per_user,
                            ),
                        );
                    }
                },
                ReplayProtector::Nonce(_) => {
                    if txns.orderless_txns_len() >= self.orderless_txn_capacity_per_user {
                        return MempoolStatus::new(MempoolStatusCode::TooManyTransactions).with_message(
                            format!(
                                "Mempool over capacity for account. Number of orderless transactions from account: {} Capacity per account: {}",
                                txns.orderless_txns_len(),
                                self.orderless_txn_capacity_per_user,
                            ),
                        );
                    }
                },
            }
```

**File:** mempool/src/core_mempool/index.rs (L26-30)
```rust
#[derive(Clone, Default)]
pub struct AccountTransactions {
    nonce_transactions: BTreeMap<u64 /* Nonce */, MempoolTransaction>,
    sequence_number_transactions: BTreeMap<u64 /* Sequence number */, MempoolTransaction>,
}
```

**File:** config/src/config/mempool_config.rs (L123-123)
```rust
            capacity_per_user: 100,
```

**File:** config/src/config/mempool_config.rs (L171-171)
```rust
            orderless_txn_capacity_per_user: 1000,
```

**File:** types/src/transaction/mod.rs (L112-116)
```rust
#[derive(Debug, Copy, Clone, Eq, PartialEq, PartialOrd, Ord, Hash, Serialize, Deserialize)]
pub enum ReplayProtector {
    Nonce(u64),
    SequenceNumber(u64),
}
```

**File:** mempool/src/tests/core_mempool_test.rs (L71-81)
```rust
fn test_transaction_ordering_seqnos_and_nonces() {
    let (mut mempool, mut consensus) = setup_mempool();

    // Default ordering: gas price
    add_txns_to_mempool(&mut mempool, vec![
        TestTransaction::new(0, ReplayProtector::Nonce(150), 3),
        TestTransaction::new(0, ReplayProtector::SequenceNumber(0), 3),
        TestTransaction::new(0, ReplayProtector::SequenceNumber(1), 5),
        TestTransaction::new(0, ReplayProtector::Nonce(100), 2),
        TestTransaction::new(0, ReplayProtector::Nonce(200), 7),
    ]);
```
