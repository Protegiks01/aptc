# Audit Report

## Title
Multisig Transaction Queue DoS via Empty Payload Hash

## Summary
A malicious multisig account owner can create unexecutable transactions by using `create_transaction_with_hash` with the SHA3-256 hash of an empty payload. When executed, these transactions pass validation but fail during deserialization, leaving the multisig account in a blocked state until the transaction is explicitly rejected.

## Finding Description

The Aptos multisig account module contains a validation gap between Move-level hash validation and Rust-level payload deserialization that allows creation of permanently unexecutable transactions.

**Attack Flow:**

1. Malicious owner calls `create_transaction_with_hash` with `payload_hash = sha3_256([]) = a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a` [1](#0-0) 

2. The function only validates that the hash is 32 bytes, allowing the empty payload hash to be stored

3. The transaction gets k-of-n approvals from other owners

4. When execution is attempted with `TransactionExecutableRef::Empty`, the prologue validates successfully because `sha3_256([])` matches the stored hash [2](#0-1) 

5. During execution, `get_next_transaction_payload` returns the empty payload [3](#0-2) 

6. Deserialization fails when trying to convert empty bytes to `MultisigTransactionPayload` [4](#0-3) 

7. The early return bypasses multisig cleanup functions, leaving the transaction pending and blocking all subsequent transactions

**Root Cause:** The inconsistency exists because `create_transaction` explicitly forbids empty payloads [5](#0-4) , but `create_transaction_with_hash` has no equivalent check.

## Impact Explanation

**Severity: Low to Medium**

While this creates a denial-of-service condition for the affected multisig account, the impact is limited:

- **Scope**: Single multisig account only (not network-wide)
- **Mitigation**: Built-in rejection mechanism allows owners to remove the blocking transaction [6](#0-5) 
- **No fund loss**: No assets are stolen or locked permanently
- **Temporary**: Can be resolved through normal multisig operations

This falls short of Medium severity ("State inconsistencies requiring intervention") because the intervention is a standard multisig operation, not an extraordinary recovery procedure.

## Likelihood Explanation

**Likelihood: Low**

This attack requires:
- Attacker must be a legitimate multisig owner (insider threat)
- Other owners must approve the malicious transaction (social engineering)
- Attack provides limited benefit (temporary griefing only)

## Recommendation

Add validation in `create_transaction_with_hash` to prevent the hash of an empty payload:

```move
public entry fun create_transaction_with_hash(
    owner: &signer,
    multisig_account: address,
    payload_hash: vector<u8>,
) acquires MultisigAccount {
    assert!(vector::length(&payload_hash) == 32, error::invalid_argument(EINVALID_PAYLOAD_HASH));
    
    // Add check to prevent empty payload hash
    let empty_hash = sha3_256(vector[]);
    assert!(payload_hash != empty_hash, error::invalid_argument(EPAYLOAD_CANNOT_BE_EMPTY));
    
    // ... rest of function
}
```

## Proof of Concept

```move
#[test(owner = @0x123)]
public entry fun test_empty_payload_hash_blocks_queue(owner: &signer) acquires MultisigAccount {
    setup();
    create_account(address_of(owner));
    create(owner, 1, vector[], vector[]);
    let multisig_account = get_next_multisig_account_address(address_of(owner));
    
    // Create transaction with hash of empty payload
    let empty_payload_hash = x"a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a";
    create_transaction_with_hash(owner, multisig_account, empty_payload_hash);
    
    // Transaction is created successfully but cannot be executed
    // Attempting to execute with empty payload will fail during deserialization
    // Transaction remains in queue, blocking all subsequent transactions
}
```

---

**Note**: SHA3-256 itself correctly handles empty input and produces a deterministic, valid 32-byte hash. The vulnerability is not in the cryptographic primitive but in the lack of validation for this specific edge case in multisig transaction creation.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L393-403)
```text
    public fun get_next_transaction_payload(
        multisig_account: address, provided_payload: vector<u8>): vector<u8> acquires MultisigAccount {
        let multisig_account_resource = borrow_global<MultisigAccount>(multisig_account);
        let sequence_number = multisig_account_resource.last_executed_sequence_number + 1;
        let transaction = table::borrow(&multisig_account_resource.transactions, sequence_number);

        if (option::is_some(&transaction.payload)) {
            *option::borrow(&transaction.payload)
        } else {
            provided_payload
        }
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L959-959)
```text
        assert!(vector::length(&payload) > 0, error::invalid_argument(EPAYLOAD_CANNOT_BE_EMPTY));
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L978-997)
```text
    public entry fun create_transaction_with_hash(
        owner: &signer,
        multisig_account: address,
        payload_hash: vector<u8>,
    ) acquires MultisigAccount {
        // Payload hash is a sha3-256 hash, so it must be exactly 32 bytes.
        assert!(vector::length(&payload_hash) == 32, error::invalid_argument(EINVALID_PAYLOAD_HASH));

        assert_multisig_account_exists(multisig_account);
        assert_is_owner(owner, multisig_account);

        let creator = address_of(owner);
        let transaction = MultisigTransaction {
            payload: option::none<vector<u8>>(),
            payload_hash: option::some(payload_hash),
            votes: simple_map::create<address, bool>(),
            creator,
            creation_time_secs: now_seconds(),
        };
        add_transaction(creator, multisig_account, transaction);
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L1075-1117)
```text
    public entry fun execute_rejected_transaction(
        owner: &signer,
        multisig_account: address,
    ) acquires MultisigAccount {
        assert_multisig_account_exists(multisig_account);
        assert_is_owner(owner, multisig_account);

        let sequence_number = last_resolved_sequence_number(multisig_account) + 1;
        let owner_addr = address_of(owner);
        if (features::multisig_v2_enhancement_feature_enabled()) {
            // Implicitly vote for rejection if the owner has not voted for rejection yet.
            if (!has_voted_for_rejection(multisig_account, sequence_number, owner_addr)) {
                reject_transaction(owner, multisig_account, sequence_number);
            }
        };

        let multisig_account_resource = borrow_global_mut<MultisigAccount>(multisig_account);
        let (_, num_rejections) = remove_executed_transaction(multisig_account_resource);
        assert!(
            num_rejections >= multisig_account_resource.num_signatures_required,
            error::invalid_state(ENOT_ENOUGH_REJECTIONS),
        );

        if (std::features::module_event_migration_enabled()) {
            emit(
                ExecuteRejectedTransaction {
                    multisig_account,
                    sequence_number,
                    num_rejections,
                    executor: address_of(owner),
                }
            );
        } else {
            emit_event(
                &mut multisig_account_resource.execute_rejected_transaction_events,
                ExecuteRejectedTransactionEvent {
                    sequence_number,
                    num_rejections,
                    executor: owner_addr,
                }
            );
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L1163-1169)
```text
        if (option::is_some(&transaction.payload_hash)) {
            let payload_hash = option::borrow(&transaction.payload_hash);
            assert!(
                sha3_256(payload) == *payload_hash,
                error::invalid_argument(EPAYLOAD_DOES_NOT_MATCH_HASH),
            );
        };
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1278-1281)
```rust
        let payload_bytes =
            bcs::from_bytes::<Vec<u8>>(payload_bytes).map_err(|_| deserialization_error())?;
        let payload = bcs::from_bytes::<MultisigTransactionPayload>(&payload_bytes)
            .map_err(|_| deserialization_error())?;
```
