# Audit Report

## Title
Case-Sensitive Address Standardization Causes Filter Mismatch for Special Addresses

## Summary
The `standardize_address` function in the transaction filter module preserves the case of uppercase hexadecimal characters when standardizing special addresses (0x0-0xf), but protobuf-serialized transaction addresses are always lowercase. This creates a filter mismatch where filters with uppercase hex characters fail to match transactions from the corresponding addresses, leading to indexing data loss.

## Finding Description

The `standardize_address` function implements AIP-40 address standardization but contains a case-sensitivity bug for special addresses. [1](#0-0) 

When a special address (0x0-0xf) is detected, the function returns it in short form by preserving the original case of the last hexadecimal character. However, transaction sender addresses in protobuf are always serialized using lowercase hex via the `to_string()` method. [2](#0-1) 

This delegates to the `Display` trait implementation which uses `to_hex_literal()`: [3](#0-2) 

Which in turn calls `short_str_lossless()` that uses `hex::encode()` producing lowercase hex: [4](#0-3) 

The filter matching logic performs case-sensitive string comparison: [5](#0-4) 

**Exploitation Path:**
1. User creates filter with `sender: "0xF"` (uppercase)
2. Filter standardizes to `"0xF"` (case preserved)
3. Transaction from address 0xF arrives, serialized as `"0xf"` (lowercase)
4. Filter standardizes transaction sender to `"0xf"`
5. String comparison: `"0xF" != "0xf"` → filter does not match
6. Transaction is incorrectly filtered out, causing data loss

The same issue affects `EntryFunctionFilter` when matching module addresses: [6](#0-5) 

## Impact Explanation

This vulnerability meets **Medium Severity** criteria per the Aptos bug bounty program: "State inconsistencies requiring intervention."

**Concrete Impact:**
- Indexers using filters with uppercase hex for special addresses will systematically miss all transactions from those addresses
- Data integrity compromised in indexing pipeline
- Silent data loss without error indication
- Affects all special addresses (0x0-0xf), including critical system addresses like 0x1 (aptos_framework)

This is NOT a consensus issue (indexer-grpc is off-chain infrastructure), does not affect funds, and does not impact validator operations. However, it creates verifiable state inconsistencies in the indexing layer that require manual intervention to detect and correct.

## Likelihood Explanation

**High Likelihood:**
- Hexadecimal notation is traditionally case-insensitive, so users naturally may use uppercase characters
- Special addresses (0x0-0xf) are frequently used in Aptos (e.g., 0x1 for framework modules)
- No validation or warning prevents uppercase hex in filter configuration
- The bug is silent—filters appear to work but silently miss data
- Test coverage only uses lowercase hex, missing this edge case: [7](#0-6) 

## Recommendation

The `standardize_address` function should normalize the input to lowercase before processing to ensure case-insensitive behavior, consistent with hexadecimal encoding standards.

**Fix:**
```rust
pub fn standardize_address(address: &str) -> String {
    // Remove "0x" prefix and normalize to lowercase
    let trimmed = address.strip_prefix("0x")
        .unwrap_or(address)
        .to_lowercase(); // <-- Add lowercase normalization
    
    // [rest of function unchanged]
    if let Some(last_char) = trimmed.chars().last() {
        if trimmed[..trimmed.len().saturating_sub(1)]
            .chars()
            .all(|c| c == '0')
            && last_char.is_ascii_hexdigit()
            && last_char <= 'f'
        {
            let mut result = String::with_capacity(3);
            result.push_str("0x");
            result.push(last_char);
            return result;
        }
    }
    
    let mut result = String::with_capacity(66);
    result.push_str("0x");
    result.push_str(&ZEROS[..64 - trimmed.len()]);
    result.push_str(&trimmed);
    result
}
```

## Proof of Concept

```rust
#[test]
fn test_uppercase_hex_special_address_mismatch() {
    // Simulate filter with uppercase hex
    let filter_address = "0xF";
    let filter_standardized = standardize_address(filter_address);
    
    // Simulate protobuf transaction sender (always lowercase)
    let transaction_sender = "0xf"; // hex::encode produces lowercase
    let transaction_standardized = standardize_address(transaction_sender);
    
    // BUG: These should match but don't due to case sensitivity
    assert_eq!(filter_standardized, transaction_standardized);
    // FAILS: "0xF" != "0xf"
}

#[test]
fn test_uppercase_hex_after_fix() {
    // After applying the fix with .to_lowercase()
    assert_eq!(standardize_address("0xF"), "0xf");
    assert_eq!(standardize_address("0xf"), "0xf");
    assert_eq!(standardize_address("0xA"), "0xa");
    assert_eq!(standardize_address("0xa"), "0xa");
    
    // Non-special addresses should also work
    assert_eq!(
        standardize_address("0x10"),
        standardize_address("0x10")
    );
}
```

**Notes**

This vulnerability is specific to the indexer-grpc transaction filtering system and does not affect core consensus or execution. The impact is limited to off-chain indexing infrastructure where filters may silently fail to capture transactions when uppercase hex is used for special addresses. The fix is straightforward—normalize all address strings to lowercase before standardization to ensure case-insensitive matching consistent with standard hexadecimal encoding conventions.

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/utils.rs (L10-36)
```rust
pub fn standardize_address(address: &str) -> String {
    // Remove "0x" prefix if it exists
    let trimmed = address.strip_prefix("0x").unwrap_or(address);

    // Check if the address is a special address by seeing if the first 31 bytes are zero and the last byte is smaller than 0b10000
    if let Some(last_char) = trimmed.chars().last() {
        if trimmed[..trimmed.len().saturating_sub(1)]
            .chars()
            .all(|c| c == '0')
            && last_char.is_ascii_hexdigit()
            && last_char <= 'f'
        {
            // Return special addresses in short format
            let mut result = String::with_capacity(3);
            result.push_str("0x");
            result.push(last_char);
            return result;
        }
    }

    // Return non-special addresses in long format
    let mut result = String::with_capacity(66);
    result.push_str("0x");
    result.push_str(&ZEROS[..64 - trimmed.len()]);
    result.push_str(trimmed);
    result
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/utils.rs (L43-49)
```rust
    fn test_standardize_special_address() {
        assert_eq!(standardize_address("0x1"), "0x1");
        assert_eq!(standardize_address("0x01"), "0x1");
        assert_eq!(standardize_address("0x001"), "0x1");
        assert_eq!(standardize_address("0x000000001"), "0x1");
        assert_eq!(standardize_address("0xf"), "0xf");
        assert_eq!(standardize_address("0x0f"), "0xf");
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/convert.rs (L860-862)
```rust
                request: Some(transaction::UserTransactionRequest {
                    sender: ut.request.sender.to_string(),
                    sequence_number: ut.request.sequence_number.0,
```

**File:** api/types/src/address.rs (L40-48)
```rust
impl fmt::Display for Address {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        // While the inner type, AccountAddress, has a Display impl already, we don't
        // use it. As part of the AIP-40 migration, the Display impl of the inner
        // AccountAddress was changed to conform to AIP-40, but doing that for the API
        // would constitute a breaking change. So we keep an explicit display impl
        // here that maintains the existing address formatting behavior.
        write!(f, "{}", self.0.to_hex_literal())
    }
```

**File:** third_party/move/move-core/types/src/account_address.rs (L138-145)
```rust
    pub fn short_str_lossless(&self) -> String {
        let hex_str = hex::encode(self.0).trim_start_matches('0').to_string();
        if hex_str.is_empty() {
            "0".to_string()
        } else {
            hex_str
        }
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L94-98)
```rust
        if let Some(sender_filter) = self.get_standardized_sender() {
            if &standardize_address(&user_request.sender) != sender_filter {
                return false;
            }
        }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L198-201)
```rust
                if !(self
                    .get_standardized_address()
                    .matches(&standardize_address(&module.address))
                    && self.module.matches(&module.name))
```
