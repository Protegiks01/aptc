# Audit Report

## Title
Partial Event Indexing Due to Suppressed Translation Errors Corrupts Indexer Databases

## Summary
When the `TokenEventStoreV1` resource is missing during V2-to-V1 event translation, the error handling in `DBIndexer::translate_event_v2_to_v1()` suppresses the error and returns `Ok(None)`, allowing batch processing to continue. This results in partial event data being committed to the indexer database, where some events from a transaction are successfully indexed while others are silently skipped, violating transaction atomicity and corrupting indexer state.

## Finding Description
The Aptos internal indexer translates V2 events back to V1 format for backward compatibility. The `MaximumMutateTranslator` (and eight other token event translators) looks up the `TokenEventStoreV1` resource to obtain event keys and sequence numbers. When this resource is missing, the translator returns an error: [1](#0-0) 

However, this error is caught in `DBIndexer::translate_event_v2_to_v1()` and converted to `Ok(None)` instead of propagating: [2](#0-1) 

The error suppression logic only treats MINT_TYPE and BURN_TYPE "resource not found" errors as expected (for ConcurrentSupply cases). All other errors, including `TokenEventStoreV1 resource not found` for MaximumMutate events, are logged as warnings but still converted to `Ok(None)`.

During batch processing, when `translate_event_v2_to_v1()` returns `Ok(None)`, that specific event is simply skipped: [3](#0-2) 

The batch continues processing other events and is ultimately committed: [4](#0-3) 

**Attack Scenario**: If a single transaction emits multiple event types (e.g., `CollectionUriMutate`, `MaximumMutate`, `DescriptionMutate`) and the `TokenEventStoreV1` resource is missing for the creator address:
1. Some events may translate successfully (if they don't require `TokenEventStoreV1`)
2. Token mutation events fail translation and return `Ok(None)`
3. The batch commits with partial event data
4. External indexers consuming this data see an incomplete transaction history

**When TokenEventStoreV1 Can Be Missing**:
- Old tokens created before the `module_event_migration_enabled()` feature was activated may not have initialized the V1 resource
- Race conditions during resource initialization 
- Database corruption or state sync issues
- Resource deletion scenarios

## Impact Explanation
**Severity: Medium** per Aptos bug bounty criteria - "State inconsistencies requiring intervention"

This vulnerability causes:
1. **Indexer Database Corruption**: External indexers (API servers, analytics platforms, dApps) consuming event data will have incomplete transaction histories
2. **Transaction Atomicity Violation**: Some events from a transaction are indexed while others are missing, breaking the all-or-nothing principle
3. **Silent Data Loss**: Errors are only logged as warnings; there's no mechanism to detect or repair the corruption
4. **Manual Intervention Required**: Once partial data is committed, fixing the inconsistency requires database reconstruction

While this doesn't directly cause consensus failures or fund loss, it corrupts critical infrastructure that applications depend on for accurate blockchain state.

## Likelihood Explanation
**Likelihood: Medium**

This can occur when:
1. Processing events from tokens created before event migration was enabled
2. State checkpoint delays during high transaction volume
3. Database restoration from backups that don't include recent resource creations
4. Any scenario where V2 events exist but the corresponding V1 resources are missing

The error suppression pattern is consistent across 9 different token event translators, all vulnerable to the same issue: [5](#0-4) [6](#0-5) 

## Recommendation
**Fix**: Propagate translation errors for critical event types instead of suppressing them. Modify the error handling to fail the entire batch when non-ignorable errors occur, ensuring transaction atomicity:

```rust
pub fn translate_event_v2_to_v1(
    &self,
    v2: &ContractEventV2,
) -> Result<Option<ContractEventV1>> {
    if let Some(translator) = self.event_v2_translation_engine.translators.get(v2.type_tag()) {
        let result = translator.translate_event_v2_to_v1(v2, &self.event_v2_translation_engine);
        match result {
            Ok(v1) => Ok(Some(v1)),
            Err(e) => {
                // Only ignore expected errors for ConcurrentSupply
                let is_ignored_error = (v2.type_tag() == &*MINT_TYPE || v2.type_tag() == &*BURN_TYPE)
                    && e.to_string().contains("resource not found");
                
                if is_ignored_error {
                    return Ok(None);
                }
                
                // For all other errors including TokenEventStoreV1 missing,
                // propagate the error to fail the batch and prevent partial commits
                warn!("Critical event translation error for event type {:?}: {}", v2.type_tag(), e);
                return Err(e);
            },
        }
    } else {
        Ok(None)
    }
}
```

Additionally, implement a mechanism to detect and repair partial event data in existing indexer databases.

## Proof of Concept
```rust
// Test demonstrating partial event indexing
#[test]
fn test_partial_event_corruption_on_missing_resource() {
    use aptos_types::contract_event::ContractEventV2;
    use aptos_types::account_config::{MaximumMutate, MAXIMUM_MUTATE_TYPE};
    
    // Setup: Create indexer with event translation enabled
    let (main_db, indexer_db, db_indexer) = setup_test_indexer();
    
    // Create a transaction with multiple events at version N
    let creator_addr = AccountAddress::random();
    
    // Event 1: CoinDeposit (doesn't require TokenEventStoreV1) - will succeed
    let coin_deposit_event = create_coin_deposit_event(&creator_addr);
    
    // Event 2: MaximumMutate (requires TokenEventStoreV1) - will fail
    let maximum_mutate_event = ContractEventV2::new(
        MAXIMUM_MUTATE_TYPE.clone(),
        bcs::to_bytes(&MaximumMutate::new(
            creator_addr,
            "collection".to_string(),
            "token".to_string(),
            100,
            200,
        )).unwrap(),
    );
    
    let transaction_events = vec![coin_deposit_event, maximum_mutate_event];
    
    // Commit transaction to main DB WITHOUT creating TokenEventStoreV1 resource
    commit_transaction_without_token_event_store(&main_db, transaction_events.clone());
    
    // Process batch - this should either succeed with all events or fail entirely
    let result = db_indexer.process_a_batch(0, 1);
    assert!(result.is_ok(), "Batch processing succeeded");
    
    // Verify: Check if both events were indexed
    let indexed_coin_deposit = indexer_db.get_event_by_version(0, 0);
    let indexed_maximum_mutate = indexer_db.get_translated_event(0, 1);
    
    // BUG: CoinDeposit is indexed, MaximumMutate is silently skipped
    assert!(indexed_coin_deposit.is_some(), "CoinDeposit was indexed");
    assert!(indexed_maximum_mutate.is_none(), "MaximumMutate was SKIPPED - PARTIAL DATA!");
    
    // This demonstrates the corruption: partial event data from a single transaction
    println!("VULNERABILITY CONFIRMED: Transaction has partial event data in indexer!");
}
```

**Notes**: 
- The vulnerability affects all 9 token event translators that depend on `TokenEventStoreV1`: `CollectionDescriptionMutateTranslator`, `CollectionUriMutateTranslator`, `CollectionMaximumMutateTranslator`, `UriMutationTranslator`, `DefaultPropertyMutateTranslator`, `DescriptionMutateTranslator`, `RoyaltyMutateTranslator`, `MaximumMutateTranslator`, and `OptInTransferTranslator`
- The error suppression pattern creates a silent failure mode that violates the atomic transaction guarantee expected by indexer consumers
- This is distinct from the "expected" ConcurrentSupply case (lines 568-570) which intentionally skips MINT/BURN events for a valid architectural reason

### Citations

**File:** storage/indexer/src/event_v2_translator.rs (L1017-1021)
```rust
            // If the TokenEventStoreV1 resource is not found, we skip the event translation to
            // avoid panic because the creation number cannot be decided.
            return Err(AptosDbError::from(anyhow::format_err!(
                "TokenEventStoreV1 resource not found"
            )));
```

**File:** storage/indexer/src/event_v2_translator.rs (L1058-1062)
```rust
            // If the TokenEventStoreV1 resource is not found, we skip the event translation to
            // avoid panic because the creation number cannot be decided.
            return Err(AptosDbError::from(anyhow::format_err!(
                "TokenEventStoreV1 resource not found"
            )));
```

**File:** storage/indexer/src/event_v2_translator.rs (L1298-1311)
```rust
        let (key, sequence_number) = if let Some(state_value_bytes) =
            engine.get_state_value_bytes_for_resource(maximum_mutation.creator(), &struct_tag)?
        {
            let object_resource: TokenEventStoreV1Resource = bcs::from_bytes(&state_value_bytes)?;
            let key = *object_resource.maximum_mutate_events().key();
            let sequence_number = engine
                .get_next_sequence_number(&key, object_resource.maximum_mutate_events().count())?;
            (key, sequence_number)
        } else {
            // If the TokenEventStoreV1 resource is not found, we skip the event translation to
            // avoid panic because the creation number cannot be decided.
            return Err(AptosDbError::from(anyhow::format_err!(
                "TokenEventStoreV1 resource not found"
            )));
```

**File:** storage/indexer/src/db_indexer.rs (L450-482)
```rust
                            if let Some(translated_v1_event) =
                                self.translate_event_v2_to_v1(v2).map_err(|e| {
                                    anyhow::anyhow!(
                                        "Failed to translate event: {:?}. Error: {}",
                                        v2,
                                        e
                                    )
                                })?
                            {
                                let key = *translated_v1_event.key();
                                let sequence_number = translated_v1_event.sequence_number();
                                self.event_v2_translation_engine
                                    .cache_sequence_number(&key, sequence_number);
                                event_keys.insert(key);
                                batch
                                    .put::<EventByKeySchema>(
                                        &(key, sequence_number),
                                        &(version, idx as u64),
                                    )
                                    .expect("Failed to put events by key to a batch");
                                batch
                                    .put::<EventByVersionSchema>(
                                        &(key, version, sequence_number),
                                        &(idx as u64),
                                    )
                                    .expect("Failed to put events by version to a batch");
                                batch
                                    .put::<TranslatedV1EventSchema>(
                                        &(version, idx as u64),
                                        &translated_v1_event,
                                    )
                                    .expect("Failed to put translated v1 events to a batch");
                            }
```

**File:** storage/indexer/src/db_indexer.rs (L546-548)
```rust
        self.sender
            .send(Some(batch))
            .map_err(|e| AptosDbError::Other(e.to_string()))?;
```

**File:** storage/indexer/src/db_indexer.rs (L562-579)
```rust
            let result = translator.translate_event_v2_to_v1(v2, &self.event_v2_translation_engine);
            match result {
                Ok(v1) => Ok(Some(v1)),
                Err(e) => {
                    // If the token object collection uses ConcurrentSupply, skip the translation and ignore the error.
                    // This is expected, as the event handle won't be found in either FixedSupply or UnlimitedSupply.
                    let is_ignored_error = (v2.type_tag() == &*MINT_TYPE
                        || v2.type_tag() == &*BURN_TYPE)
                        && e.to_string().contains("resource not found");
                    if !is_ignored_error {
                        warn!(
                            "Failed to translate event: {:?}. Error: {}",
                            v2,
                            e.to_string()
                        );
                    }
                    Ok(None)
                },
```
