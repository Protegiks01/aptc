# Audit Report

## Title
Dry Run Bypass in MagicHeaderChecker Enables Brute Force of Access Control Headers Without Rate Limiting

## Summary
The `MagicHeaderChecker.check()` function ignores the `_dry_run` parameter, allowing attackers to exploit the `/is_eligible` endpoint to brute force magic header values without triggering rate limits. This enables bypassing of access control mechanisms intended to restrict faucet access to authorized applications.

## Finding Description

The `MagicHeaderChecker` validates that incoming faucet requests contain a specific HTTP header with a specific value, acting as an access control mechanism. [1](#0-0) 

However, the `_dry_run` parameter at line 31 is unused (indicated by the underscore prefix). This is problematic because the `/is_eligible` endpoint calls all checkers with `dry_run=true` to check eligibility without side effects. [2](#0-1) 

Rate limiting checkers properly respect the `dry_run` flag by not incrementing counters when it's true: [3](#0-2) 

This creates an exploitable condition where:
1. An attacker calls `/is_eligible` repeatedly with different magic header values
2. `MagicHeaderChecker` validates each header value and returns clear error feedback
3. Rate limiters check but don't increment counters (due to `dry_run=true`)
4. The attacker discovers the correct header value through brute force
5. The correct header can then be used to bypass `MagicHeaderChecker` in actual `/fund` requests

The vulnerability is confirmed by the endpoint documentation showing different responses for valid vs. invalid requests: [4](#0-3) 

The error handling provides clear feedback through rejection reasons: [5](#0-4) 

## Impact Explanation

This vulnerability allows attackers to bypass access controls on the Aptos faucet service by discovering secret magic header values that are intended to restrict access to authorized wallet applications. While this affects the faucet service (which distributes test tokens on devnet/testnet rather than mainnet funds), it represents:

- **Access Control Bypass**: Unauthorized applications can gain access to faucet resources intended only for authorized wallets
- **Information Disclosure**: Secret header values used for authentication can be discovered through brute force
- **Rate Limit Bypass**: The attack circumvents the intended rate limiting protection

This qualifies as **Medium severity** per the bug bounty criteria as it enables limited manipulation of faucet resources and bypasses authentication mechanisms, though the impact is confined to test token distribution rather than mainnet funds.

## Likelihood Explanation

This vulnerability is **highly likely** to be exploited because:
- The `/is_eligible` endpoint is publicly accessible without authentication
- The attack requires only simple HTTP requests with varying header values
- The response clearly indicates success or failure for each header value tested
- No special privileges or infrastructure are required
- The attack leaves minimal forensic traces (only HTTP middleware logs, not detailed application logs)

## Recommendation

Implement rate limiting specifically for the `/is_eligible` endpoint to prevent brute force attacks, or modify the `MagicHeaderChecker` to avoid leaking information in dry run mode:

**Option 1**: Add separate rate limiting for `/is_eligible` calls that doesn't use `dry_run=true`

**Option 2**: Modify `MagicHeaderChecker` to return a generic error in dry run mode:

```rust
async fn check(
    &self,
    data: CheckerData,
    dry_run: bool,
) -> Result<Vec<RejectionReason>, AptosTapError> {
    if dry_run {
        // In dry run mode, don't reveal specific header validation results
        return Ok(vec![]);
    }
    
    // Existing validation logic...
}
```

**Option 3**: Remove `/is_eligible` endpoint or require it to go through the same rate limiting as `/fund`

## Proof of Concept

```rust
#[tokio::test]
async fn test_magic_header_brute_force_via_is_eligible() {
    // Setup faucet server with MagicHeaderChecker configured
    // with secret header: "X-Wallet-Auth: secret_value_123"
    
    let test_headers = vec![
        "wrong_value_1",
        "wrong_value_2",
        "secret_value_123",  // Correct value
        "wrong_value_3",
    ];
    
    for header_value in test_headers {
        // Call /is_eligible endpoint (dry_run=true internally)
        let response = reqwest::Client::new()
            .post("http://localhost:8080/is_eligible")
            .json(&json!({
                "address": "0x1234..."
            }))
            .header("X-Wallet-Auth", header_value)
            .send()
            .await
            .unwrap();
        
        if response.status().is_success() {
            println!("Found correct header value: {}", header_value);
            // Rate limit counter was NOT incremented due to dry_run=true
            break;
        }
        // Can repeat indefinitely without hitting rate limits
    }
    
    // Verify that rate limit counter remains at 0 despite multiple calls
    // because all is_eligible calls use dry_run=true
}
```

**Notes**

This vulnerability is specific to the faucet service auxiliary component rather than core blockchain consensus or execution layers. The magic header mechanism appears to be used for identifying and restricting access to specific wallet applications, as evidenced by test examples. [6](#0-5) 

The issue stems from an architectural design where stateless checkers (like `MagicHeaderChecker`) correctly ignore `dry_run` per the interface contract, but this enables information disclosure when combined with the rate-limit-exempt `/is_eligible` endpoint.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/magic_header.rs (L28-52)
```rust
    async fn check(
        &self,
        data: CheckerData,
        _dry_run: bool,
    ) -> Result<Vec<RejectionReason>, AptosTapError> {
        let header_value = match data.headers.get(&self.config.magic_header_key) {
            Some(header_value) => header_value,
            None => {
                return Ok(vec![RejectionReason::new(
                    format!("Magic header {} not found", self.config.magic_header_key),
                    RejectionReasonCode::MagicHeaderIncorrect,
                )])
            },
        };
        if header_value != &self.config.magic_header_value {
            return Ok(vec![RejectionReason::new(
                format!(
                    "Magic header value wrong {} not found",
                    self.config.magic_header_key
                ),
                RejectionReasonCode::MagicHeaderIncorrect,
            )]);
        }
        Ok(vec![])
    }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L121-126)
```rust
    /// Check whether a given requester is eligible to be funded
    ///
    /// This function runs only the various eligibility checks that we perform
    /// in `fund` without actually funding the account or writing anything to
    /// storage. If the request is valid it returns an empty 200. If it is invalid
    /// it returns a 400 or 403 with an explanation in the response body.
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L143-146)
```rust
        let (checker_data, bypass, _semaphore_permit) = self
            .components
            .preprocess_request(&fund_request.0, source_ip, header_map, true)
            .await?;
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L272-277)
```rust
        if !rejection_reasons.is_empty() {
            return Err(AptosTapError::new(
                format!("Request rejected by {} checkers", rejection_reasons.len()),
                AptosTapErrorCode::Rejected,
            )
            .rejection_reasons(rejection_reasons));
```

**File:** crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs (L86-88)
```rust
        } else if !dry_run {
            *requests_today += 1;
        }
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L604-604)
```rust
                .header("what_wallet_my_guy", "the_wallet_that_rocks")
```
