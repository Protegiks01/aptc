# Audit Report

## Title
DoS Attack via Premature NIL Block Proposal Verification - Expensive Cryptographic Operations Before Early Rejection

## Summary
The `ProposalMsg::verify()` function performs expensive cryptographic operations (BLS signature verification of QuorumCerts) before calling `verify_well_formed()`, which contains an early rejection check for NIL blocks. Since NIL blocks should never be sent as `ProposalMsg` over the network, an attacker can flood validators with malicious NIL block proposals, causing CPU exhaustion from unnecessary cryptographic verifications before these proposals are rejected.

## Finding Description

The vulnerability exists in the verification order of `ProposalMsg`. When a `ProposalMsg` arrives from the network, it undergoes verification in the following sequence: [1](#0-0) 

The `ProposalMsg::verify()` function is called, which performs operations in this order: [2](#0-1) 

The critical issue is at line 117: `verify_well_formed()` is called LAST, after expensive operations. This function contains the NIL block rejection check: [3](#0-2) 

However, before reaching this check, the system performs expensive cryptographic operations. For NIL blocks specifically, the signature validation involves QuorumCert verification: [4](#0-3) 

The QuorumCert verification performs BLS signature verification: [5](#0-4) 

NIL blocks are special consensus artifacts that should only be generated locally by validators during timeouts, never received as network proposals: [6](#0-5) [7](#0-6) 

**Attack Path:**
1. Attacker crafts malicious `ProposalMsg` with `BlockType::NilBlock`
2. Includes a valid `QuorumCert` (copied from any legitimate block in the chain)
3. Sends flood of such messages to validator nodes
4. Each validator performs expensive BLS signature verification on the QuorumCert (line 143-145 in quorum_cert.rs)
5. Only after cryptographic verification completes, the NIL block is rejected at line 35-38 in proposal_msg.rs
6. Attacker repeats at network rate limit, causing sustained CPU exhaustion

The `is_nil_block()` check itself is cheap (simple enum pattern match): [8](#0-7) 

But this cheap check happens too late in the verification pipeline.

## Impact Explanation

**Severity: High** (Validator node slowdowns - per Aptos Bug Bounty criteria)

This vulnerability enables a targeted DoS attack causing:
- **CPU Exhaustion**: Each malicious proposal forces validators to perform BLS aggregate signature verification before rejection
- **Validator Slowdown**: Sustained attack degrades consensus performance, increases round times, and delays block finalization
- **Resource Waste**: Computational resources spent on cryptographic operations for invalid proposals that should be rejected immediately
- **Amplification Effect**: Single malicious peer can impact all validators in the network by broadcasting invalid proposals

While network-level rate limiting exists, it does not prevent this attack—it only bounds the attack rate. At the configured rate limit, validators still waste significant CPU on unnecessary cryptographic operations.

## Likelihood Explanation

**Likelihood: High**

- **Low Attacker Requirements**: Any network peer can send consensus messages; no privileged access needed
- **Simple Attack Vector**: Attacker only needs to craft `ProposalMsg` with `BlockType::NilBlock` and a copied `QuorumCert`
- **No Evasion Needed**: The vulnerability is in the core verification path—no special conditions required
- **Sustainable Attack**: Attacker can maintain attack at network rate limit indefinitely
- **High Impact/Effort Ratio**: Minimal attacker resources required to cause significant validator CPU consumption

## Recommendation

**Fix: Reorder verification checks to reject NIL blocks before expensive cryptographic operations**

Move the NIL block check to the beginning of `ProposalMsg::verify()`:

```rust
pub fn verify(
    &self,
    sender: Author,
    validator: &ValidatorVerifier,
    proof_cache: &ProofCache,
    quorum_store_enabled: bool,
) -> Result<()> {
    // Early rejection: NIL blocks should never be sent as ProposalMsg
    ensure!(
        !self.proposal.is_nil_block(),
        "Proposal {} for a NIL block should not be sent over network",
        self.proposal
    );
    
    // Existing verification logic...
    if let Some(proposal_author) = self.proposal.author() {
        ensure!(
            proposal_author == sender,
            "Proposal author {:?} doesn't match sender {:?}",
            proposal_author,
            sender
        );
    }
    
    let (payload_result, sig_result) = rayon::join(
        || {
            self.proposal().payload().map_or(Ok(()), |p| {
                p.verify(validator, proof_cache, quorum_store_enabled)
            })
        },
        || {
            self.proposal()
                .validate_signature(validator)
                .map_err(|e| format_err!("{:?}", e))
        },
    );
    payload_result?;
    sig_result?;

    if let Some(tc) = self.sync_info.highest_2chain_timeout_cert() {
        tc.verify(validator).map_err(|e| format_err!("{:?}", e))?;
    }
    
    self.verify_well_formed()
}
```

This ensures the cheap `is_nil_block()` check (O(1) enum discriminant check) happens before any expensive cryptographic operations.

## Proof of Concept

```rust
#[cfg(test)]
mod dos_test {
    use super::*;
    use aptos_consensus_types::{
        block::Block,
        block_data::BlockData,
        quorum_cert::QuorumCert,
        proposal_msg::ProposalMsg,
        sync_info::SyncInfo,
    };
    use aptos_crypto::HashValue;
    use aptos_types::validator_verifier::ValidatorVerifier;
    use std::time::Instant;

    #[test]
    fn test_nil_block_proposal_dos() {
        // Setup validator verifier and other required components
        let validator_verifier = ValidatorVerifier::new(vec![]);
        
        // Create a legitimate QuorumCert (would be copied from chain)
        let qc = QuorumCert::dummy();
        
        // Create malicious NIL block
        let nil_block = Block::new_nil(
            1, // round
            qc.clone(),
            vec![], // failed_authors
        );
        
        // Create sync_info
        let sync_info = SyncInfo::new(
            qc.clone(),
            qc.clone(),
            None,
        );
        
        // Create malicious ProposalMsg with NIL block
        let malicious_proposal = ProposalMsg::new(nil_block, sync_info);
        
        // Measure time spent on verification before rejection
        let start = Instant::now();
        
        // This will perform expensive QC verification before rejecting
        let result = malicious_proposal.verify(
            aptos_types::account_address::AccountAddress::ZERO,
            &validator_verifier,
            &ProofCache::new(100),
            true,
        );
        
        let elapsed = start.elapsed();
        
        // Verify it was rejected
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("NIL block"));
        
        println!("Time spent on cryptographic verification before NIL rejection: {:?}", elapsed);
        
        // Demonstrate flooding attack
        println!("\nSimulating flood attack with 100 malicious NIL proposals:");
        let flood_start = Instant::now();
        let mut rejected_count = 0;
        
        for _ in 0..100 {
            let result = malicious_proposal.verify(
                aptos_types::account_address::AccountAddress::ZERO,
                &validator_verifier,
                &ProofCache::new(100),
                true,
            );
            if result.is_err() {
                rejected_count += 1;
            }
        }
        
        let flood_elapsed = flood_start.elapsed();
        println!("Total time for 100 verifications: {:?}", flood_elapsed);
        println!("Average time per verification: {:?}", flood_elapsed / 100);
        println!("All proposals rejected: {}/100", rejected_count);
    }
}
```

**Notes:**
- The vulnerability leverages the ordering of checks in the verification pipeline
- NIL blocks are legitimate consensus artifacts but should only be generated locally, never received over the network
- The fix is simple: reorder checks to perform cheap structural validation before expensive cryptographic operations
- This follows the defense-in-depth principle of "fail fast" on invalid inputs

### Citations

**File:** consensus/src/round_manager.rs (L120-128)
```rust
            UnverifiedEvent::ProposalMsg(p) => {
                if !self_message {
                    p.verify(peer_id, validator, proof_cache, quorum_store_enabled)?;
                    counters::VERIFY_MSG
                        .with_label_values(&["proposal"])
                        .observe(start_time.elapsed().as_secs_f64());
                }
                VerifiedEvent::ProposalMsg(p)
            },
```

**File:** consensus/consensus-types/src/proposal_msg.rs (L33-39)
```rust
    pub fn verify_well_formed(&self) -> Result<()> {
        ensure!(
            !self.proposal.is_nil_block(),
            "Proposal {} for a NIL block",
            self.proposal
        );
        self.proposal
```

**File:** consensus/consensus-types/src/proposal_msg.rs (L82-118)
```rust
    pub fn verify(
        &self,
        sender: Author,
        validator: &ValidatorVerifier,
        proof_cache: &ProofCache,
        quorum_store_enabled: bool,
    ) -> Result<()> {
        if let Some(proposal_author) = self.proposal.author() {
            ensure!(
                proposal_author == sender,
                "Proposal author {:?} doesn't match sender {:?}",
                proposal_author,
                sender
            );
        }
        let (payload_result, sig_result) = rayon::join(
            || {
                self.proposal().payload().map_or(Ok(()), |p| {
                    p.verify(validator, proof_cache, quorum_store_enabled)
                })
            },
            || {
                self.proposal()
                    .validate_signature(validator)
                    .map_err(|e| format_err!("{:?}", e))
            },
        );
        payload_result?;
        sig_result?;

        // if there is a timeout certificate, verify its signatures
        if let Some(tc) = self.sync_info.highest_2chain_timeout_cert() {
            tc.verify(validator).map_err(|e| format_err!("{:?}", e))?;
        }
        // Note that we postpone the verification of SyncInfo until it's being used.
        self.verify_well_formed()
    }
```

**File:** consensus/consensus-types/src/block.rs (L300-314)
```rust
    /// The NIL blocks are special: they're not carrying any real payload and are generated
    /// independently by different validators just to fill in the round with some QC.
    pub fn new_nil(
        round: Round,
        quorum_cert: QuorumCert,
        failed_authors: Vec<(Round, Author)>,
    ) -> Self {
        let block_data = BlockData::new_nil(round, quorum_cert, failed_authors);

        Block {
            id: block_data.hash(),
            block_data,
            signature: None,
        }
    }
```

**File:** consensus/consensus-types/src/block.rs (L425-428)
```rust
    pub fn validate_signature(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        match self.block_data.block_type() {
            BlockType::Genesis => bail!("We should not accept genesis from others"),
            BlockType::NilBlock { .. } => self.quorum_cert().verify(validator),
```

**File:** consensus/consensus-types/src/quorum_cert.rs (L119-148)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        let vote_hash = self.vote_data.hash();
        ensure!(
            self.ledger_info().ledger_info().consensus_data_hash() == vote_hash,
            "Quorum Cert's hash mismatch LedgerInfo"
        );
        // Genesis's QC is implicitly agreed upon, it doesn't have real signatures.
        // If someone sends us a QC on a fake genesis, it'll fail to insert into BlockStore
        // because of the round constraint.
        if self.certified_block().round() == 0 {
            ensure!(
                self.parent_block() == self.certified_block(),
                "Genesis QC has inconsistent parent block with certified block"
            );
            ensure!(
                self.certified_block() == self.ledger_info().ledger_info().commit_info(),
                "Genesis QC has inconsistent commit block with certified block"
            );
            ensure!(
                self.ledger_info().get_num_voters() == 0,
                "Genesis QC should not carry signatures"
            );
            return Ok(());
        }
        self.ledger_info()
            .verify_signatures(validator)
            .context("Fail to verify QuorumCert")?;
        self.vote_data.verify()?;
        Ok(())
    }
```

**File:** consensus/consensus-types/src/block_data.rs (L215-217)
```rust
    pub fn is_nil_block(&self) -> bool {
        matches!(self.block_type, BlockType::NilBlock { .. })
    }
```

**File:** consensus/consensus-types/src/block_data.rs (L304-321)
```rust
    pub fn new_nil(
        round: Round,
        quorum_cert: QuorumCert,
        failed_authors: Vec<(Round, Author)>,
    ) -> Self {
        // We want all the NIL blocks to agree on the timestamps even though they're generated
        // independently by different validators, hence we're using the timestamp of a parent + 1.
        assume!(quorum_cert.certified_block().timestamp_usecs() < u64::MAX); // unlikely to be false in this universe
        let timestamp_usecs = quorum_cert.certified_block().timestamp_usecs();

        Self {
            epoch: quorum_cert.certified_block().epoch(),
            round,
            timestamp_usecs,
            quorum_cert,
            block_type: BlockType::NilBlock { failed_authors },
        }
    }
```
