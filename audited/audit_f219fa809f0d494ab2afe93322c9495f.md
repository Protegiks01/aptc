# Audit Report

## Title
Indexer Metadata Inconsistency After Fast Sync Causes Silent Data Loss in Historical Queries

## Summary
During fast sync state snapshot restoration, the `StateStore::kv_finish()` method incorrectly sets the internal indexer metadata (`TransactionVersion` and `EventVersion`) to `snapshot_version - 1`, claiming that transactions and events have been indexed up to that version. However, no actual transaction or event indexing occurs during fast sync, leaving the indices completely empty for the entire snapshot range. This causes historical queries to pass metadata validation checks but return empty results, leading to silent data loss and API misbehavior.

## Finding Description

The vulnerability occurs in the interaction between fast sync state snapshot restoration and the internal indexer metadata management. The issue manifests in two key locations: [1](#0-0) 

During fast sync initialization, `db_main` is opened with the `internal_indexer_db` parameter, while `secondary_db` is opened with `None` for the indexer. This is correct design - the indexer should only be attached to the main database. [2](#0-1) 

The critical bug occurs in the `kv_finish()` method, which is called after state snapshot restoration completes. This method unconditionally sets the indexer metadata for all data types:
- `LatestVersion = version - 1`
- `StateVersion = version - 1` 
- `TransactionVersion = version - 1`
- `EventVersion = version - 1`

While setting `StateVersion` is correct (state keys ARE indexed during snapshot restoration via `write_kv_batch()`), setting `TransactionVersion` and `EventVersion` is incorrect because: [3](#0-2) 

During `finalize_state_snapshot()`, only ONE transaction (the checkpoint transaction at the snapshot version) is saved to the ledger database. All historical transactions from version 0 to snapshot_version-1 are intentionally skipped to achieve fast sync. [4](#0-3) 

Transaction and event indexing only occurs via the `indexer.index()` call in `post_commit()`, which is never invoked for the historical versions during fast sync.

**Attack Flow:**

1. Node performs fast sync to version 1,000,000
2. State snapshot restoration completes, only indexing state keys
3. `kv_finish()` sets `TransactionVersion = 999,999` and `EventVersion = 999,999`
4. Transaction/event indices remain empty for versions [0, 999,999]
5. User queries for events at version 500,000 [5](#0-4) 

6. `ensure_cover_ledger_version(500,000)` checks metadata, sees 999,999 â‰¥ 500,000, returns Ok()
7. Query proceeds to `lookup_events_by_key()` [6](#0-5) 

8. Iterator over `EventByKeySchema` finds no entries, returns empty Vec
9. User receives empty results despite metadata claiming data exists

This violates the **State Consistency** invariant - the indexer metadata falsely advertises coverage that doesn't exist.

## Impact Explanation

This is **HIGH severity** per the Aptos bug bounty criteria for the following reasons:

1. **API Misbehavior**: API nodes that fast sync will serve incorrect results for all historical transaction and event queries in the range [0, snapshot_version-1]. Applications relying on this data will malfunction.

2. **Silent Data Loss**: Unlike returning a proper "data not available" error, the system returns empty results, making the issue difficult to detect and debug.

3. **Widespread Impact**: Affects all validator nodes and API nodes that:
   - Use fast sync for initial synchronization (common practice)
   - Have the internal indexer enabled (standard configuration)
   - Serve historical query requests

4. **Permanent Inconsistency**: Once fast sync completes with incorrect metadata, there's no automatic recovery mechanism. The inconsistency persists indefinitely.

5. **Protocol Violation**: The indexer provides false guarantees about data availability, violating the fundamental contract between the storage layer and query layer.

This meets the "Significant protocol violations" and "API crashes" (or severe API misbehavior) categories under High Severity.

## Likelihood Explanation

**Likelihood: HIGH**

This bug triggers automatically whenever:
- A node uses fast sync mode (standard for new validators and API nodes)
- The internal indexer is enabled (default configuration)
- Any historical queries are made to the indexer

No malicious actor is required - this is a systematic bug in the fast sync + indexer integration. Given that fast sync is recommended for quick node bootstrapping and the internal indexer is widely used, this issue will affect most new node deployments.

The bug is deterministic and will occur 100% of the time under these conditions.

## Recommendation

Modify the `StateStore::kv_finish()` method to distinguish between normal transaction commits and state snapshot restoration. During snapshot restoration, only set the state-related metadata, not transaction/event metadata:

```rust
fn kv_finish(&self, version: Version, usage: StateStorageUsage, is_snapshot_restore: bool) -> Result<()> {
    self.ledger_db.metadata_db().put_usage(version, usage)?;
    if let Some(internal_indexer_db) = self.internal_indexer_db.as_ref() {
        if version > 0 {
            let mut batch = SchemaBatch::new();
            batch.put::<InternalIndexerMetadataSchema>(
                &MetadataKey::LatestVersion,
                &MetadataValue::Version(version - 1),
            )?;
            
            // Only set state version during snapshot restore
            if internal_indexer_db.statekeys_enabled() {
                batch.put::<InternalIndexerMetadataSchema>(
                    &MetadataKey::StateVersion,
                    &MetadataValue::Version(version - 1),
                )?;
            }
            
            // Do NOT set TransactionVersion or EventVersion during snapshot restore
            if !is_snapshot_restore {
                if internal_indexer_db.transaction_enabled() {
                    batch.put::<InternalIndexerMetadataSchema>(
                        &MetadataKey::TransactionVersion,
                        &MetadataValue::Version(version - 1),
                    )?;
                }
                if internal_indexer_db.event_enabled() {
                    batch.put::<InternalIndexerMetadataSchema>(
                        &MetadataKey::EventVersion,
                        &MetadataValue::Version(version - 1),
                    )?;
                }
            }
            
            internal_indexer_db
                .get_inner_db_ref()
                .write_schemas(batch)?;
        }
    }
    Ok(())
}
```

Update the `StateValueWriter` trait signature and all call sites to pass the `is_snapshot_restore` flag.

## Proof of Concept

**Reproduction Steps:**

1. Start an Aptos node with the following configuration:
   - Fast sync enabled: `bootstrapping_mode = "DownloadLatestStates"`
   - Internal indexer enabled: `enable_event = true`, `enable_transaction = true`

2. Wait for fast sync to complete (e.g., syncs to version 1,000,000)

3. Check indexer metadata:
```rust
let event_version = indexer_db.get_event_version()?; // Returns Some(999,999)
let transaction_version = indexer_db.get_transaction_version()?; // Returns Some(999,999)
```

4. Attempt to query events at version 500,000:
```rust
let events = db_indexer.get_events(&event_key, 0, Order::Ascending, 10, 500_000)?;
// Returns empty Vec despite metadata claiming coverage
```

5. Verify the main database only contains the checkpoint transaction:
```rust
let txn = main_db.get_transaction_by_version(100_000, 1_000_000, false);
// Returns NotFound error - transaction doesn't exist
```

**Expected Behavior:** Query should either:
- Return an error indicating data not available before snapshot version
- OR indexer should have indexed all historical transactions (defeats fast sync purpose)

**Actual Behavior:** Query returns empty results, falsely indicating no events exist at that version.

## Notes

This vulnerability specifically affects the internal indexer's transaction and event indices. State key indexing works correctly during fast sync. The issue arises from the `kv_finish()` method being reused for both normal commits (where setting all metadata is correct) and snapshot restoration (where only state metadata should be set).

The `InternalIndexerDBService` correctly starts indexing from the snapshot version onwards, so new transactions after fast sync are indexed properly. Only historical queries in the [0, snapshot_version-1] range are affected.

### Citations

**File:** storage/aptosdb/src/fast_sync_storage_wrapper.rs (L48-90)
```rust
        let mut db_main = AptosDB::open(
            config.storage.get_dir_paths(),
            /*readonly=*/ false,
            config.storage.storage_pruner_config,
            config.storage.rocksdb_configs,
            config.storage.enable_indexer,
            config.storage.buffered_state_target_items,
            config.storage.max_num_nodes_per_lru_cache_shard,
            internal_indexer_db,
            config.storage.hot_state_config,
        )
        .map_err(|err| anyhow!("fast sync DB failed to open {}", err))?;
        if let Some(sender) = update_sender {
            db_main.add_version_update_subscriber(sender)?;
        }

        let mut db_dir = config.storage.dir();
        // when the db is empty and configured to do fast sync, we will create a second DB
        if config
            .state_sync
            .state_sync_driver
            .bootstrapping_mode
            .is_fast_sync()
            && (db_main
                .ledger_db
                .metadata_db()
                .get_synced_version()?
                .map_or(0, |v| v)
                == 0)
        {
            db_dir.push(SECONDARY_DB_DIR);
            let secondary_db = AptosDB::open(
                StorageDirPaths::from_path(db_dir.as_path()),
                /*readonly=*/ false,
                config.storage.storage_pruner_config,
                config.storage.rocksdb_configs,
                config.storage.enable_indexer,
                config.storage.buffered_state_target_items,
                config.storage.max_num_nodes_per_lru_cache_shard,
                None,
                config.storage.hot_state_config,
            )
            .map_err(|err| anyhow!("Secondary DB failed to open {}", err))?;
```

**File:** storage/aptosdb/src/state_store/mod.rs (L1281-1314)
```rust
    fn kv_finish(&self, version: Version, usage: StateStorageUsage) -> Result<()> {
        self.ledger_db.metadata_db().put_usage(version, usage)?;
        if let Some(internal_indexer_db) = self.internal_indexer_db.as_ref() {
            if version > 0 {
                let mut batch = SchemaBatch::new();
                batch.put::<InternalIndexerMetadataSchema>(
                    &MetadataKey::LatestVersion,
                    &MetadataValue::Version(version - 1),
                )?;
                if internal_indexer_db.statekeys_enabled() {
                    batch.put::<InternalIndexerMetadataSchema>(
                        &MetadataKey::StateVersion,
                        &MetadataValue::Version(version - 1),
                    )?;
                }
                if internal_indexer_db.transaction_enabled() {
                    batch.put::<InternalIndexerMetadataSchema>(
                        &MetadataKey::TransactionVersion,
                        &MetadataValue::Version(version - 1),
                    )?;
                }
                if internal_indexer_db.event_enabled() {
                    batch.put::<InternalIndexerMetadataSchema>(
                        &MetadataKey::EventVersion,
                        &MetadataValue::Version(version - 1),
                    )?;
                }
                internal_indexer_db
                    .get_inner_db_ref()
                    .write_schemas(batch)?;
            }
        }

        Ok(())
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L133-145)
```rust
            // Ensure the output with proof only contains a single transaction output and info
            let num_transaction_outputs = output_with_proof.get_num_outputs();
            let num_transaction_infos = output_with_proof.proof.transaction_infos.len();
            ensure!(
                num_transaction_outputs == 1,
                "Number of transaction outputs should == 1, but got: {}",
                num_transaction_outputs
            );
            ensure!(
                num_transaction_infos == 1,
                "Number of transaction infos should == 1, but got: {}",
                num_transaction_infos
            );
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L636-658)
```rust
            if let Some(indexer) = &self.indexer {
                let _timer = OTHER_TIMERS_SECONDS.timer_with(&["indexer_index"]);
                // n.b. txns_to_commit can be partial, when the control was handed over from consensus to state sync
                // where state sync won't send the pre-committed part to the DB again.
                if let Some(chunk) = chunk_opt
                    && chunk.len() == num_txns as usize
                {
                    let write_sets = chunk
                        .transaction_outputs
                        .iter()
                        .map(|t| t.write_set())
                        .collect_vec();
                    indexer.index(self.state_store.clone(), first_version, &write_sets)?;
                } else {
                    let write_sets: Vec<_> = self
                        .ledger_db
                        .write_set_db()
                        .get_write_set_iter(first_version, num_txns as usize)?
                        .try_collect()?;
                    let write_set_refs = write_sets.iter().collect_vec();
                    indexer.index(self.state_store.clone(), first_version, &write_set_refs)?;
                };
            }
```

**File:** storage/indexer/src/db_indexer.rs (L163-172)
```rust
    pub fn ensure_cover_ledger_version(&self, ledger_version: Version) -> Result<()> {
        let indexer_latest_version = self.get_persisted_version()?;
        if let Some(indexer_latest_version) = indexer_latest_version {
            if indexer_latest_version >= ledger_version {
                return Ok(());
            }
        }

        bail!("ledger version too new")
    }
```

**File:** storage/indexer/src/db_indexer.rs (L222-244)
```rust
        let mut iter = self.db.iter::<EventByKeySchema>()?;
        iter.seek(&(*event_key, start_seq_num))?;

        let mut result = Vec::new();
        let mut cur_seq = start_seq_num;
        for res in iter.take(limit as usize) {
            let ((path, seq), (ver, idx)) = res?;
            if path != *event_key || ver > ledger_version {
                break;
            }
            if seq != cur_seq {
                let msg = if cur_seq == start_seq_num {
                    "First requested event is probably pruned."
                } else {
                    "DB corruption: Sequence number not continuous."
                };
                bail!("{} expected: {}, actual: {}", msg, cur_seq, seq);
            }
            result.push((seq, ver, idx));
            cur_seq += 1;
        }

        Ok(result)
```
