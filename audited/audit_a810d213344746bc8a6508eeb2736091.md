# Audit Report

## Title
Missing Security Test Coverage Exposes Cache Invalidation Vulnerability in Module Version Management

## Summary
The `CachedModuleView` implementation lacks critical security tests for version rollback scenarios, potentially allowing stale cached modules to cause denial of service when state versions regress. While the existing test suite validates cache consistency during normal operations, it does not verify robustness against malicious or corrupted state inputs.

## Finding Description

The test module in `module_view.rs` [1](#0-0)  tests cache consistency for version increases but omits critical security scenarios.

The vulnerability stems from the `get_module_or_build_with` implementation [2](#0-1)  which assumes module versions are monotonically increasing. When a cached module has version X but the state view presents version Y where Y < X, the code attempts to insert the lower version [3](#0-2) , triggering a `version_too_small_error!` from the underlying cache [4](#0-3) .

The `reset_state_view` method [5](#0-4)  updates the state view pointer without validating cached module versions remain valid. This is used in production paths: VM validator [6](#0-5)  and consensus pipeline [7](#0-6) .

**Attack Scenario:**
1. Database corruption or state sync anomaly causes module A's `value_version` in storage to be 3 while cache holds version 5
2. Global state version increases linearly (100→101), passing linear history checks [8](#0-7) 
3. `reset_state_view` updates state pointer without cache validation
4. Transaction validation attempts to access module A
5. Version mismatch triggers error, blocking all transactions using that module

## Impact Explanation

**Medium Severity** per Aptos bug bounty criteria: State inconsistencies requiring intervention.

While existing safeguards (linear history checks) prevent most attack scenarios, the lack of test coverage for edge cases means the system's resilience against state corruption is unverified. A validator experiencing this condition would require manual restart to clear the cache, potentially causing:
- Temporary denial of service for affected validator
- Transaction validation failures until cache cleared
- Potential consensus participation degradation

## Likelihood Explanation

**Low-Medium likelihood:**
- Requires database corruption, state sync anomaly, or byzantine state provider
- Linear history checks in production code prevent most scenarios
- Would require simultaneous: global version increase AND specific module version decrease
- Not exploitable by normal unprivileged attackers without system-level access

However, the **missing test coverage** itself represents a code quality and robustness gap that should be addressed regardless of current exploit difficulty.

## Recommendation

Add comprehensive security tests to the test module:

1. **Version Rollback Test:** Verify behavior when state presents lower module version than cached
2. **Cache Poisoning Test:** Validate handling of malformed/corrupted module bytes from state
3. **Deserialization Failure Test:** Ensure graceful error handling when `CompiledModule::deserialize_with_config` fails
4. **Concurrent Access Test:** Document thread-safety guarantees (currently uses `RefCell`, not thread-safe by design)

Additionally, enhance `reset_state_view` to validate cache consistency:
- Check that all cached module versions ≤ corresponding state versions
- If validation fails, automatically call `reset_all` to flush cache
- Log warnings when version mismatches detected

## Proof of Concept

```rust
#[test]
fn test_version_rollback_detection() {
    // Setup: Module A at version 5 in cache
    let module_a = empty_module_with_dependencies_and_friends("a", vec![], vec![])
        .set_default_version();
    
    let initial_state = MockStateView::new_with_state_slot(HashMap::from([(
        StateKey::module_id(&module_a.self_id()),
        StateSlot::from_db_get(Some((5, module_state_value(module_a.clone())))),
    )]));
    
    let mut state = CachedModuleView::new(initial_state);
    
    // Load module into cache at version 5
    state.unmetered_get_deserialized_module(
        module_a.self_addr(),
        module_a.self_name()
    ).unwrap();
    
    // Create new state with LOWER version (simulating rollback/corruption)
    let rollback_state = MockStateView::new_with_state_slot(HashMap::from([(
        StateKey::module_id(&module_a.self_id()),
        StateSlot::from_db_get(Some((3, module_state_value(module_a.clone())))),
    )]));
    
    // Reset state view (simulates linear history passing but module version regressing)
    state.reset_state_view(rollback_state);
    
    // Attempt to access module should detect version mismatch
    let result = state.unmetered_get_deserialized_module(
        module_a.self_addr(),
        module_a.self_name()
    );
    
    // Should either: return error, auto-flush cache, or handle gracefully
    // Current behavior: returns version_too_small_error!
    assert!(result.is_err() || result.unwrap().is_some());
}
```

**Notes:**
This audit identifies missing test coverage as a code quality issue that reduces system robustness. While current safeguards prevent easy exploitation, comprehensive security testing would validate the system's resilience against edge cases and state corruption scenarios.

### Citations

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L123-125)
```rust
    pub fn reset_state_view(&mut self, state_view: S) {
        self.state_view = state_view;
    }
```

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L199-263)
```rust
    fn get_module_or_build_with(
        &self,
        key: &Self::Key,
        builder: &dyn ModuleCodeBuilder<
            Key = Self::Key,
            Deserialized = Self::Deserialized,
            Verified = Self::Verified,
            Extension = Self::Extension,
        >,
    ) -> VMResult<
        Option<(
            Arc<ModuleCode<Self::Deserialized, Self::Verified, Self::Extension>>,
            Self::Version,
        )>,
    > {
        // Get the module that exists in cache.
        let (module, version) = match self.module_cache.get_module_or_build_with(key, builder)? {
            None => {
                return Ok(None);
            },
            Some(module_and_version) => module_and_version,
        };

        // Get the state value that exists in the actual state and compute the hash.
        let state_slot = self
            .state_view
            .get_state_slot(&StateKey::module_id(key))
            .map_err(|err| module_storage_error!(key.address(), key.name(), err))?;
        let (value_version, state_value) = match state_slot.into_state_value_and_version_opt() {
            Some((value_version, state_value)) => (value_version as usize, state_value),
            None => {
                return Err(
                    PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                        .with_message(format!(
                            "Module {}::{} cannot be found in storage, but exists in cache",
                            key.address(),
                            key.name()
                        ))
                        .finish(Location::Undefined),
                )
            },
        };
        // deserialize only relies on local config, so only need to detect changes on module bytes
        // if we want to support verified modules, we need
        // to detect changes on aptos environment too.
        Ok(if version == value_version {
            Some((module, version))
        } else {
            let (compiled_module, extension) = self
                .try_override_bytes_and_deserialized_into_compiled_module_with_ext(
                    state_value,
                    key.address(),
                    key.name(),
                )?;

            let new_version = value_version;
            let new_module_code = self.module_cache.insert_deserialized_module(
                key.clone(),
                compiled_module,
                extension,
                new_version,
            )?;
            Some((new_module_code, new_version))
        })
    }
```

**File:** aptos-move/aptos-resource-viewer/src/module_view.rs (L306-436)
```rust
mod tests {
    use super::*;
    use aptos_types::state_store::{state_slot::StateSlot, state_value::StateValue, MockStateView};
    use move_binary_format::file_format::empty_module_with_dependencies_and_friends;
    use move_core_types::ident_str;
    use move_vm_runtime::ModuleStorage;
    use std::collections::HashMap;

    fn module_state_value(module: CompiledModule) -> StateValue {
        let mut bytes = vec![];
        module.serialize(&mut bytes).unwrap();
        StateValue::new_legacy(bytes.into())
    }

    #[test]
    fn test_module_cache_consistency() {
        // Have 3 modules in the state.
        let a =
            empty_module_with_dependencies_and_friends("a", vec![], vec![]).set_default_version();
        let b =
            empty_module_with_dependencies_and_friends("b", vec![], vec![]).set_default_version();
        let c =
            empty_module_with_dependencies_and_friends("c", vec![], vec![]).set_default_version();

        let state_view = MockStateView::new(HashMap::from([
            (
                StateKey::module_id(&a.self_id()),
                module_state_value(a.clone()),
            ),
            (
                StateKey::module_id(&b.self_id()),
                module_state_value(b.clone()),
            ),
            (
                StateKey::module_id(&c.self_id()),
                module_state_value(c.clone()),
            ),
        ]));
        let mut state = CachedModuleView::new(state_view);
        assert_eq!(state.module_cache.num_modules(), 0);

        assert!(state
            .unmetered_get_deserialized_module(&AccountAddress::ZERO, ident_str!("d"))
            .unwrap()
            .is_none());
        assert_eq!(
            &a,
            state
                .unmetered_get_deserialized_module(a.self_addr(), a.self_name())
                .unwrap()
                .unwrap()
                .as_ref()
        );
        assert_eq!(
            &c,
            state
                .unmetered_get_deserialized_module(c.self_addr(), c.self_name())
                .unwrap()
                .unwrap()
                .as_ref()
        );

        assert_eq!(state.module_cache.num_modules(), 2);
        assert_eq!(state.module_cache.get_module_version(&a.self_id()), Some(0));
        assert_eq!(state.module_cache.get_module_version(&b.self_id()), None);
        assert_eq!(state.module_cache.get_module_version(&c.self_id()), Some(0));

        // Change module "a" by adding dependencies and also add a new module "d".
        let d =
            empty_module_with_dependencies_and_friends("d", vec![], vec![]).set_default_version();
        let a_new = empty_module_with_dependencies_and_friends("a", vec!["b", "c"], vec![])
            .set_default_version();
        assert_ne!(&a, &a_new);

        let new_state_view = MockStateView::new_with_state_slot(HashMap::from([
            // New code:
            (
                StateKey::module_id(&a_new.self_id()),
                StateSlot::from_db_get(Some((1, module_state_value(a_new.clone())))),
            ),
            (
                StateKey::module_id(&d.self_id()),
                StateSlot::from_db_get(Some((0, module_state_value(d.clone())))),
            ),
            // Old code:
            (
                StateKey::module_id(&b.self_id()),
                StateSlot::from_db_get(Some((0, module_state_value(b.clone())))),
            ),
            (
                StateKey::module_id(&c.self_id()),
                StateSlot::from_db_get(Some((0, module_state_value(c.clone())))),
            ),
        ]));
        state.reset_state_view(new_state_view);

        // New code version should be returned no
        assert_eq!(
            &a_new,
            state
                .unmetered_get_deserialized_module(a_new.self_addr(), a_new.self_name())
                .unwrap()
                .unwrap()
                .as_ref()
        );
        assert_eq!(
            &d,
            state
                .unmetered_get_deserialized_module(d.self_addr(), d.self_name())
                .unwrap()
                .unwrap()
                .as_ref()
        );

        assert_eq!(state.module_cache.num_modules(), 3);
        assert_eq!(state.module_cache.get_module_version(&a.self_id()), Some(1));
        assert_eq!(state.module_cache.get_module_version(&c.self_id()), Some(0));
        assert_eq!(state.module_cache.get_module_version(&d.self_id()), Some(0));

        // Get verified module, to load the transitive closure (modules "b" and "c") as well.
        assert!(state
            .unmetered_get_eagerly_verified_module(a_new.self_addr(), a_new.self_name())
            .unwrap()
            .is_some());
        assert_eq!(state.module_cache.num_modules(), 4);
        assert_eq!(state.module_cache.get_module_version(&a.self_id()), Some(1));
        assert_eq!(state.module_cache.get_module_version(&b.self_id()), Some(0));
        assert_eq!(state.module_cache.get_module_version(&c.self_id()), Some(0));
        assert_eq!(state.module_cache.get_module_version(&d.self_id()), Some(0));
    }
}
```

**File:** third_party/move/move-vm/types/src/code/cache/module_cache.rs (L265-266)
```rust
            Occupied(mut entry) => match version.cmp(&entry.get().version()) {
                Ordering::Less => Err(version_too_small_error!()),
```

**File:** vm-validator/src/vm_validator.rs (L76-99)
```rust
    fn notify_commit(&mut self) {
        let db_state_view = self.db_state_view();

        // On commit, we need to update the state view so that we can see the latest resources.
        let base_view_id = self.state.state_view_id();
        let new_view_id = db_state_view.id();
        match (base_view_id, new_view_id) {
            (
                StateViewId::TransactionValidation {
                    base_version: old_version,
                },
                StateViewId::TransactionValidation {
                    base_version: new_version,
                },
            ) => {
                // if the state view forms a linear history, just update the state view
                if old_version <= new_version {
                    self.state.reset_state_view(db_state_view.into());
                }
            },
            // if the version is incompatible, we flush the cache
            _ => self.state.reset_all(db_state_view.into()),
        }
    }
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L713-726)
```rust
                // flush the cache if the execution state view is not linear
                // in case of speculative executing a forked block
                let previous_state_view = cache_mut.state_view_id();
                let expected_state_view = StateViewId::BlockExecution {
                    block_id: grand_parent_id,
                };
                if previous_state_view == expected_state_view {
                    cache_mut.reset_state_view(parent_state_view);
                } else {
                    counters::RAND_BLOCK
                        .with_label_values(&["reset_cache"])
                        .inc();
                    cache_mut.reset_all(parent_state_view);
                }
```
