# Audit Report

## Title
WeightedConfig Consistency Weakness: Lack of Cryptographic Binding Enables Consensus Divergence Under Software Inconsistency

## Summary
The Aptos randomness generation system computes `WeightedConfigBlstrs` independently on each validator from on-chain metadata rather than storing it explicitly or cryptographically binding it to the DKG transcript. While the computation is deterministic under normal operation, there is no cryptographic enforcement ensuring all validators use identical configs, creating a theoretical path to consensus divergence if software inconsistencies occur.

## Finding Description

The `derive_eval()` function in the weighted VUF system uses `WeightedConfigBlstrs` to compute Lagrange interpolation points for deriving randomness evaluations: [1](#0-0) 

The critical dependency is in `collect_lagrange_coeffs_shares_and_rks()`, which uses player weights from the config to determine evaluation points: [2](#0-1) 

Each validator independently computes `WeightedConfigBlstrs` from on-chain `DKGSessionMetadata`: [3](#0-2) 

The config is derived through `DKGRounding::new()` which performs binary search to find optimal weights: [4](#0-3) 

**The Core Issue**: The DKG transcript stores only encrypted shares, not the `WeightedConfigBlstrs` used to create it: [5](#0-4) 

When decrypting shares, validators use their computed config to determine array indices: [6](#0-5) 

**Breaking the Invariant**: If validators have different `WeightedConfigBlstrs` (different weights/thresholds), they will:
1. Decrypt different shares from the transcript (wrong array indices)
2. Compute different virtual player IDs for Lagrange interpolation
3. Derive completely different randomness evaluations
4. Fail to reach consensus on the canonical randomness value

This violates the **Deterministic Execution** invariant: "All validators must produce identical state roots for identical blocks."

## Impact Explanation

**Critical Severity** - This could cause:
- **Non-recoverable network partition**: If validators split into groups using different configs, they would compute different randomness values and diverge on block execution, requiring a hard fork to resolve
- **Consensus safety violation**: Different nodes would commit different state for the same block height

The impact meets Critical severity criteria: "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**Low likelihood under current implementation** because:

1. The computation is deterministic using fixed-point arithmetic: [7](#0-6) 

2. All validators read the same committed on-chain `DKGSessionMetadata`: [8](#0-7) 

3. The on-chain data goes through consensus before finalization: [9](#0-8) 

**However, likelihood increases if**:
- Software upgrade introduces non-determinism in rounding algorithm
- Validators run inconsistent code versions during epoch transition
- Bug corrupts on-chain metadata (though this should be caught during DKG verification)

This is a **design weakness** rather than a directly exploitable vulnerability, as it requires either insider access (malicious validator operator) or operational failures (inconsistent upgrades).

## Recommendation

Add explicit cryptographic binding between the DKG transcript and the `WeightedConfigBlstrs`:

1. **Include config hash in transcript**: Modify the `Transcript` struct to include a commitment to the weights and thresholds used during dealing: [5](#0-4) 

Add a field like:
```rust
config_commitment: Scalar, // Hash of (threshold_weight, weights)
```

2. **Validate on decryption**: In `decrypt_own_share()`, verify the config matches: [10](#0-9) 

Add validation:
```rust
let computed_commitment = hash_wconfig(sc);
ensure!(self.config_commitment == computed_commitment, 
    "WeightedConfig mismatch with transcript");
```

3. **Store weights explicitly on-chain**: Include the computed weights in `DKGSessionState` for verification: [8](#0-7) 

## Proof of Concept

**Cannot provide executable PoC** because exploitation requires:
1. Multiple validators running different software versions, OR
2. Malicious validator operator modifying local code

Both scenarios require privileged access or operational failures outside the threat model ("Exploitable by unprivileged attacker").

**Theoretical demonstration**:
```rust
// Validator A computes config with correct rounding
let wconfig_a = WeightedConfigBlstrs::new(threshold, vec![100, 100, 100]).unwrap();

// Validator B (buggy version) computes different config  
let wconfig_b = WeightedConfigBlstrs::new(threshold, vec![99, 100, 101]).unwrap();

// Both decrypt from same transcript
let (sk_a, _) = transcript.decrypt_own_share(&wconfig_a, &player, &dk, &pp);
let (sk_b, _) = transcript.decrypt_own_share(&wconfig_b, &player, &dk, &pp);
// sk_a != sk_b (decrypted different shares)

// Both derive evaluations
let eval_a = WVUF::derive_eval(&wconfig_a, &pp, msg, apks, &proof, pool)?;
let eval_b = WVUF::derive_eval(&wconfig_b, &pp, msg, apks, &proof, pool)?;
// eval_a != eval_b â†’ Consensus divergence
```

---

## Notes

This represents a **design-level weakness** in the randomness system architecture rather than an immediately exploitable vulnerability. The system relies on social/operational guarantees (synchronized upgrades, honest validator operators) rather than cryptographic enforcement of config consistency. While current implementation makes divergence unlikely, adding explicit binding would provide defense-in-depth against future bugs or operational failures.

### Citations

**File:** crates/aptos-dkg/src/weighted_vuf/pinkas/mod.rs (L192-208)
```rust
    fn derive_eval(
        wc: &WeightedConfigBlstrs,
        _pp: &Self::PublicParameters,
        _msg: &[u8],
        apks: &[Option<Self::AugmentedPubKeyShare>],
        proof: &Self::Proof,
        thread_pool: &ThreadPool,
    ) -> anyhow::Result<Self::Evaluation> {
        let (rhs, rks, lagr, ranges) =
            Self::collect_lagrange_coeffs_shares_and_rks(wc, apks, proof)?;

        // Compute the RK multiexps in parallel
        let lhs = Self::rk_multiexps(proof, rks, &lagr, &ranges, thread_pool);

        // Interpolate the WVUF evaluation in parallel
        Ok(Self::multi_pairing(lhs, rhs, thread_pool))
    }
```

**File:** crates/aptos-dkg/src/weighted_vuf/pinkas/mod.rs (L273-314)
```rust
    pub fn collect_lagrange_coeffs_shares_and_rks<'a>(
        wc: &WeightedConfigBlstrs,
        apks: &'a [Option<(RandomizedPKs, Vec<DealtPubKeyShare>)>],
        proof: &'a Vec<(Player, <Self as WeightedVUF>::ProofShare)>,
    ) -> anyhow::Result<(
        Vec<&'a G2Projective>,
        Vec<&'a Vec<G1Projective>>,
        Vec<Scalar>,
        Vec<Range<usize>>,
    )> {
        // Collect all the evaluation points associated with each player's augmented pubkey sub shares.
        let mut sub_player_ids = Vec::with_capacity(wc.get_total_weight());
        // The G2 shares
        let mut shares = Vec::with_capacity(proof.len());
        // The RKs of each player
        let mut rks = Vec::with_capacity(proof.len());
        // The starting & ending index of each player in the `lagr` coefficients vector
        let mut ranges = Vec::with_capacity(proof.len());

        let mut k = 0;
        for (player, share) in proof {
            for j in 0..wc.get_player_weight(player) {
                sub_player_ids.push(wc.get_virtual_player(player, j).id);
            }

            let apk = apks[player.id]
                .as_ref()
                .ok_or_else(|| anyhow!("Missing APK for player {}", player.get_id()))?;

            rks.push(&apk.0.rks);
            shares.push(share);

            let w = wc.get_player_weight(player);
            ranges.push(k..k + w);
            k += w;
        }

        // Compute the Lagrange coefficients associated with those evaluation points
        let batch_dom = wc.get_batch_evaluation_domain();
        let lagr = lagrange_coefficients(batch_dom, &sub_player_ids[..], &Scalar::ZERO);
        Ok((shares, rks, lagr, ranges))
    }
```

**File:** types/src/dkg/real_dkg/mod.rs (L199-224)
```rust
    fn new_public_params(dkg_session_metadata: &DKGSessionMetadata) -> RealDKGPublicParams {
        let randomness_config = dkg_session_metadata
            .randomness_config_derived()
            .unwrap_or_else(OnChainRandomnessConfig::default_enabled);
        let secrecy_threshold = randomness_config
            .secrecy_threshold()
            .unwrap_or_else(|| *rounding::DEFAULT_SECRECY_THRESHOLD);
        let reconstruct_threshold = randomness_config
            .reconstruct_threshold()
            .unwrap_or_else(|| *rounding::DEFAULT_RECONSTRUCT_THRESHOLD);
        let maybe_fast_path_secrecy_threshold = randomness_config.fast_path_secrecy_threshold();

        let pvss_config = build_dkg_pvss_config(
            dkg_session_metadata.dealer_epoch,
            secrecy_threshold,
            reconstruct_threshold,
            maybe_fast_path_secrecy_threshold,
            &dkg_session_metadata.target_validator_consensus_infos_cloned(),
        );
        let verifier = ValidatorVerifier::new(dkg_session_metadata.dealer_consensus_infos_cloned());
        RealDKGPublicParams {
            session_metadata: dkg_session_metadata.clone(),
            pvss_config,
            verifier: verifier.into(),
        }
    }
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L61-129)
```rust
    pub fn new(
        validator_stakes: &Vec<u64>,
        secrecy_threshold_in_stake_ratio: U64F64,
        mut reconstruct_threshold_in_stake_ratio: U64F64,
        fast_secrecy_threshold_in_stake_ratio: Option<U64F64>,
    ) -> Self {
        reconstruct_threshold_in_stake_ratio = max(
            reconstruct_threshold_in_stake_ratio,
            secrecy_threshold_in_stake_ratio + U64F64::DELTA,
        );

        let total_weight_min = total_weight_lower_bound(validator_stakes);
        let total_weight_max = total_weight_upper_bound(
            validator_stakes,
            reconstruct_threshold_in_stake_ratio,
            secrecy_threshold_in_stake_ratio,
        );

        let (profile, rounding_error, rounding_method) = match DKGRoundingProfile::new(
            validator_stakes,
            total_weight_min,
            total_weight_max,
            secrecy_threshold_in_stake_ratio,
            reconstruct_threshold_in_stake_ratio,
            fast_secrecy_threshold_in_stake_ratio,
        ) {
            Ok(profile) => (profile, None, "binary_search".to_string()),
            Err(e) => {
                let profile = DKGRoundingProfile::infallible(
                    validator_stakes,
                    secrecy_threshold_in_stake_ratio,
                    reconstruct_threshold_in_stake_ratio,
                    fast_secrecy_threshold_in_stake_ratio,
                );
                (profile, Some(format!("{e}")), "infallible".to_string())
            },
        };
        let wconfig = WeightedConfigBlstrs::new(
            profile.reconstruct_threshold_in_weights as usize,
            profile
                .validator_weights
                .iter()
                .map(|w| *w as usize)
                .collect(),
        )
        .unwrap();

        let fast_wconfig = profile.fast_reconstruct_threshold_in_weights.map(
            |fast_reconstruct_threshold_in_weights| {
                WeightedConfigBlstrs::new(
                    fast_reconstruct_threshold_in_weights as usize,
                    profile
                        .validator_weights
                        .iter()
                        .map(|w| *w as usize)
                        .collect(),
                )
                .unwrap()
            },
        );

        Self {
            rounding_method,
            profile,
            wconfig,
            fast_wconfig,
            rounding_error,
        }
    }
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L48-72)
```rust
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq, BCSCryptoHash, CryptoHasher)]
#[allow(non_snake_case)]
pub struct Transcript {
    /// Proofs-of-knowledge (PoKs) for the dealt secret committed in $c = g_2^{p(0)}$.
    /// Since the transcript could have been aggregated from other transcripts with their own
    /// committed secrets in $c_i = g_2^{p_i(0)}$, this is a vector of PoKs for all these $c_i$'s
    /// such that $\prod_i c_i = c$.
    ///
    /// Also contains BLS signatures from each player $i$ on that player's contribution $c_i$, the
    /// player ID $i$ and auxiliary information `aux[i]` provided during dealing.
    soks: Vec<SoK<G1Projective>>,
    /// Commitment to encryption randomness $g_1^{r_j} \in G_1, \forall j \in [W]$
    R: Vec<G1Projective>,
    /// Same as $R$ except uses $g_2$.
    R_hat: Vec<G2Projective>,
    /// First $W$ elements are commitments to the evaluations of $p(X)$: $g_1^{p(\omega^i)}$,
    /// where $i \in [W]$. Last element is $g_1^{p(0)}$ (i.e., the dealt public key).
    V: Vec<G1Projective>,
    /// Same as $V$ except uses $g_2$.
    V_hat: Vec<G2Projective>,
    /// ElGamal encryption of the $j$th share of player $i$:
    /// i.e., $C[s_i+j-1] = h_1^{p(\omega^{s_i + j - 1})} ek_i^{r_j}, \forall i \in [n], j \in [w_i]$.
    /// We sometimes denote $C[s_i+j-1]$ by C_{i, j}.
    C: Vec<G1Projective>,
}
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L220-244)
```rust
    fn decrypt_own_share(
        &self,
        sc: &Self::SecretSharingConfig,
        player: &Player,
        dk: &Self::DecryptPrivKey,
        _pp: &Self::PublicParameters,
    ) -> (Self::DealtSecretKeyShare, Self::DealtPubKeyShare) {
        let weight = sc.get_player_weight(player);
        let mut sk_shares = Vec::with_capacity(weight);
        let pk_shares = self.get_public_key_share(sc, player);

        for j in 0..weight {
            let k = sc.get_share_index(player.id, j).unwrap();

            let ctxt = self.C[k]; // h_1^{f(s_i + j - 1)} \ek_i^{r_{s_i + j}}
            let ephemeral_key = self.R[k].mul(dk.dk); // (g_1^{r_{s_i + j}})
            let dealt_secret_key_share = ctxt.sub(ephemeral_key);

            sk_shares.push(pvss::dealt_secret_key_share::g1::DealtSecretKeyShare::new(
                Self::DealtSecretKey::new(dealt_secret_key_share),
            ));
        }

        (sk_shares, pk_shares)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/dkg.move (L33-37)
```text
    struct DKGSessionState has copy, store, drop {
        metadata: DKGSessionMetadata,
        start_time_us: u64,
        transcript: vector<u8>,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/dkg.move (L90-97)
```text
    public(friend) fun finish(transcript: vector<u8>) acquires DKGState {
        let dkg_state = borrow_global_mut<DKGState>(@aptos_framework);
        assert!(option::is_some(&dkg_state.in_progress), error::invalid_state(EDKG_NOT_IN_PROGRESS));
        let session = option::extract(&mut dkg_state.in_progress);
        session.transcript = transcript;
        dkg_state.last_completed = option::some(session);
        dkg_state.in_progress = option::none();
    }
```
