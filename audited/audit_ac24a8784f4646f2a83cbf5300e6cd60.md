# Audit Report

## Title
Inbound Stream Reassembly Allows Messages to Exceed max_message_size Limit

## Summary
The inbound stream reassembly logic fails to validate that the total size of reassembled messages does not exceed `max_message_size`. An attacker can send a `StreamHeader` with data and multiple fragments that, when reassembled, exceed the configured memory limit by approximately `max_frame_size` (4 MiB), causing memory exhaustion and potential denial of service.

## Finding Description

The network layer implements stream fragmentation to handle large messages that exceed `max_frame_size`. The decision to stream a message is made by the `should_stream()` function, which compares the message's raw data length against `max_frame_size`. [1](#0-0) 

On the outbound side, `stream_message()` validates that messages don't exceed `max_message_size` before streaming: [2](#0-1) 

However, on the inbound side, `InboundStream::new()` only validates that `num_fragments` doesn't exceed `max_fragments`: [3](#0-2) 

The calculation of `max_fragments` at the `Peer` initialization: [4](#0-3) 

The critical flaw is that there is **no validation** on:
1. The size of data in the `StreamHeader`'s `message` field
2. The size of each `StreamFragment`'s `raw_data` field

When fragments are appended during reassembly: [5](#0-4) 

With default configuration values: [6](#0-5) 

An attacker can exploit this by:
1. Sending a `StreamHeader` with `num_fragments = 16` (which equals `max_fragments = 64 MiB / 4 MiB = 16`)
2. The header's `message.raw_msg` contains ~4 MiB of data (near `max_frame_size` after accounting for BCS overhead)
3. Sending 16 `StreamFragment`s, each with `raw_data` containing ~4 MiB

**Total reassembled size**: ~4 MiB (header) + (16 Ã— ~4 MiB) (fragments) = ~68 MiB

This exceeds `MAX_MESSAGE_SIZE` of 64 MiB by approximately 4 MiB, violating the configured memory limit.

## Impact Explanation

This vulnerability represents a **Medium severity** issue per the Aptos bug bounty criteria for the following reasons:

1. **Resource Exhaustion**: Attackers can force nodes to allocate ~68 MiB per message instead of the configured 64 MiB limit, causing memory exhaustion
2. **Denial of Service**: Multiple concurrent malicious streams can amplify memory consumption, potentially crashing validator nodes or degrading performance
3. **Invariant Violation**: Breaks the "Resource Limits: All operations must respect gas, storage, and computational limits" invariant by exceeding `max_message_size`

While this doesn't directly cause loss of funds or consensus violations, it can impact network availability and validator performance, qualifying as "State inconsistencies requiring intervention" under Medium severity.

## Likelihood Explanation

The likelihood is **High** because:

1. **No Authentication Required**: Any network peer can send `StreamHeader` and `StreamFragment` messages without special privileges
2. **Simple Exploitation**: The attack requires only basic protocol knowledge - send a header with `num_fragments = max_fragments` and maximum-sized data in both header and fragments
3. **No Rate Limiting**: The validation only checks `num_fragments <= max_fragments`, which is satisfied by setting `num_fragments = max_fragments`
4. **Automatic Processing**: Nodes automatically process inbound streams without additional validation

The attack complexity is low and requires no validator access or sophisticated techniques.

## Recommendation

Add validation in `InboundStream::new()` and `InboundStream::append_fragment()` to track and enforce the total message size limit:

```rust
// In InboundStream struct, add:
max_message_size: usize,
current_total_size: usize,

// In InboundStream::new(), add:
fn new(header: StreamHeader, max_fragments: usize, max_message_size: usize) -> anyhow::Result<Self> {
    // ... existing validations ...
    
    // Validate header message size
    let header_data_len = header_message.data_len();
    ensure!(
        header_data_len <= max_message_size,
        "Header message size {} exceeds max message size {}!",
        header_data_len,
        max_message_size
    );
    
    Ok(Self {
        request_id: header.request_id,
        num_fragments: header_num_fragments,
        received_fragment_id: 0,
        message: header_message,
        max_message_size,
        current_total_size: header_data_len,
    })
}

// In append_fragment(), add:
fn append_fragment(&mut self, mut fragment: StreamFragment) -> anyhow::Result<bool> {
    // ... existing validations ...
    
    // Validate total size doesn't exceed limit
    let new_total_size = self.current_total_size
        .checked_add(fragment.raw_data.len())
        .ok_or_else(|| anyhow::anyhow!("Total message size overflow!"))?;
    
    ensure!(
        new_total_size <= self.max_message_size,
        "Total message size {} would exceed max message size {}!",
        new_total_size,
        self.max_message_size
    );
    
    self.current_total_size = new_total_size;
    
    // ... continue with existing append logic ...
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod exploit_test {
    use super::*;
    
    #[test]
    fn test_stream_size_overflow() {
        const MAX_FRAME_SIZE: usize = 4 * 1024 * 1024; // 4 MiB
        const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; // 64 MiB
        let max_fragments = MAX_MESSAGE_SIZE / MAX_FRAME_SIZE; // = 16
        
        // Create malicious header with maximum data
        let header_data_size = MAX_FRAME_SIZE - 100; // Account for BCS overhead
        let mut header_message = NetworkMessage::DirectSendMsg(DirectSendMsg {
            protocol_id: ProtocolId::ConsensusRpcBcs,
            priority: 0,
            raw_msg: vec![0u8; header_data_size],
        });
        
        let header = StreamHeader {
            request_id: 1,
            num_fragments: max_fragments as u8,
            message: header_message,
        };
        
        // Create inbound stream (passes validation)
        let mut inbound_stream = InboundStream::new(header, max_fragments).unwrap();
        
        // Send max_fragments fragments, each with maximum data
        let fragment_data_size = MAX_FRAME_SIZE - 100; // Account for BCS overhead
        for fragment_id in 1..=max_fragments {
            let fragment = StreamFragment {
                request_id: 1,
                fragment_id: fragment_id as u8,
                raw_data: vec![0u8; fragment_data_size],
            };
            
            let _ = inbound_stream.append_fragment(fragment).unwrap();
        }
        
        // Calculate total size
        let total_size = header_data_size + (max_fragments * fragment_data_size);
        
        // Verify violation: total_size exceeds MAX_MESSAGE_SIZE
        assert!(total_size > MAX_MESSAGE_SIZE, 
            "Total size {} should exceed MAX_MESSAGE_SIZE {}", 
            total_size, MAX_MESSAGE_SIZE);
        
        println!("Memory limit violated: {} bytes allocated vs {} bytes limit", 
            total_size, MAX_MESSAGE_SIZE);
        println!("Excess allocation: {} bytes", total_size - MAX_MESSAGE_SIZE);
    }
}
```

## Notes

The vulnerability exists because the inbound validation logic assumes that limiting `num_fragments` is sufficient to prevent oversized messages. However, since both the header message and individual fragments can contain near-`max_frame_size` amounts of data, the total can exceed `max_message_size` by approximately one frame size. This breaks the resource limit invariant and allows memory exhaustion attacks against validator nodes.

### Citations

**File:** network/framework/src/protocols/stream/mod.rs (L124-161)
```rust
    fn new(header: StreamHeader, max_fragments: usize) -> anyhow::Result<Self> {
        // Verify that max fragments is within reasonable bounds
        ensure!(
            max_fragments > 0,
            "Max fragments must be greater than zero!"
        );
        ensure!(
            max_fragments <= (u8::MAX as usize),
            "Max fragments exceeded the u8 limit: {} (max: {})!",
            max_fragments,
            u8::MAX
        );

        // Verify the header message type
        let header_message = header.message;
        ensure!(
            !matches!(header_message, NetworkMessage::Error(_)),
            "Error messages cannot be streamed!"
        );

        // Verify the number of fragments specified in the header
        let header_num_fragments = header.num_fragments;
        ensure!(
            header_num_fragments > 0,
            "Stream header must specify at least one fragment!"
        );
        ensure!(
            (header_num_fragments as usize) <= max_fragments,
            "Stream header exceeds max fragments limit!"
        );

        Ok(Self {
            request_id: header.request_id,
            num_fragments: header_num_fragments,
            received_fragment_id: 0,
            message: header_message,
        })
    }
```

**File:** network/framework/src/protocols/stream/mod.rs (L200-209)
```rust
        // Append the fragment data to the message
        let raw_data = &mut fragment.raw_data;
        match &mut self.message {
            NetworkMessage::Error(_) => {
                panic!("StreamHeader for NetworkMessage::Error(_) should be rejected!")
            },
            NetworkMessage::RpcRequest(request) => request.raw_request.append(raw_data),
            NetworkMessage::RpcResponse(response) => response.raw_response.append(raw_data),
            NetworkMessage::DirectSendMsg(message) => message.raw_msg.append(raw_data),
        }
```

**File:** network/framework/src/protocols/stream/mod.rs (L254-256)
```rust
    pub fn should_stream(&self, message: &NetworkMessage) -> bool {
        message.data_len() > self.max_frame_size
    }
```

**File:** network/framework/src/protocols/stream/mod.rs (L266-273)
```rust
        // Verify that the message size is within limits
        let message_data_len = message.data_len();
        ensure!(
            message_data_len <= self.max_message_size,
            "Message length {} exceeds max message size {}!",
            message_data_len,
            self.max_message_size,
        );
```

**File:** network/framework/src/peer/mod.rs (L168-168)
```rust
        let max_fragments = max_message_size / max_frame_size;
```

**File:** config/src/config/network_config.rs (L49-50)
```rust
pub const MAX_FRAME_SIZE: usize = 4 * 1024 * 1024; /* 4 MiB large messages will be chunked into multiple frames and streamed */
pub const MAX_MESSAGE_SIZE: usize = 64 * 1024 * 1024; /* 64 MiB */
```
