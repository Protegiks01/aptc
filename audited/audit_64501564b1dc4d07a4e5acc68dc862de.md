# Audit Report

## Title
Telemetry Replay Attack: Unauthenticated Event Resubmission Enabling Analytics Pollution

## Summary
The CLI telemetry system lacks anti-replay protections, allowing captured telemetry packets to be replayed to Google Analytics, polluting analytics data with duplicate events and skewing performance metrics.

## Finding Description

The `send_cli_telemetry_event()` function sends telemetry data to Google Analytics without any cryptographic signatures, nonces, or server-side deduplication mechanisms. [1](#0-0) 

The function generates a fresh random UUID for `user_id` on each call, then sends the event via `prepare_and_send_telemetry_event()`. [2](#0-1) 

This function adds a static `TELEMETRY_TOKEN` and forwards to `send_telemetry_event()`, which generates another random `client_id` and sends to Google Analytics. [3](#0-2) 

The request to Google Analytics is a plain HTTP POST with JSON payload, using hardcoded credentials. [4](#0-3) [5](#0-4) 

**Attack Path:**
1. Attacker intercepts telemetry HTTP POST to `https://www.google-analytics.com/mp/collect`
2. Packet contains: `TelemetryDump{client_id, user_id, timestamp_micros, events}`
3. Attacker replays identical packet multiple times
4. Google Analytics accepts all replays as distinct events (no server-side deduplication)
5. Analytics data becomes polluted with duplicate events

For node telemetry, similar issues exist. While JWT authentication is used, there's no timestamp freshness validation or deduplication. [6](#0-5) 

The timestamp is parsed but not validated for recency, and BigQuery insertion uses `None` for `insertId` (the deduplication key). [7](#0-6) 

## Impact Explanation

This meets **Low Severity** criteria per Aptos Bug Bounty:
- **Non-critical implementation bug**: Telemetry system lacks replay protection
- **Minor data integrity issue**: Analytics pollution affects observability but not consensus, funds, or chain state
- **No direct financial impact**: Does not affect validator operations or user funds
- **Monitoring degradation**: Skewed metrics could lead to incorrect operational decisions or false alerts

The vulnerability does NOT affect:
- Consensus safety or liveness
- Transaction validation or execution
- On-chain state or funds
- Validator node operation

## Likelihood Explanation

**Likelihood: Medium to High**
- Requires network-level packet capture (MITM or network access)
- No special privileges needed once packet is captured
- CLI telemetry packets are completely unauthenticated
- Attack is straightforward (simple HTTP replay)
- Google Analytics API credentials are public in the codebase

The attack is technically feasible for any attacker with network visibility to CLI users or validator nodes.

## Recommendation

Implement anti-replay protections:

### For CLI Telemetry:
1. **Add client-side request signatures**: Sign each telemetry payload with a rotating key
2. **Include monotonic sequence numbers**: Track per-session event sequence
3. **Use timestamp freshness windows**: Reject events with timestamps outside acceptable range

### For Node Telemetry:
1. **Add nonce/jti to JWT claims**: Ensure one-time token use
2. **Implement timestamp freshness validation**: Reject events with stale timestamps
3. **Enable BigQuery deduplication**: Use deterministic `insertId` based on `(peer_id, timestamp, event_hash)`

Example fix for node telemetry timestamp validation:

```rust
// In custom_event.rs::handle_custom_event()
let duration = Duration::from_micros(body.timestamp_micros.as_str().parse::<u64>()?);
let event_timestamp_secs = duration.as_secs();
let now_secs = SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs();

// Reject events older than 5 minutes or from the future
const MAX_TIMESTAMP_SKEW_SECS: u64 = 300;
if event_timestamp_secs < now_secs.saturating_sub(MAX_TIMESTAMP_SKEW_SECS) 
    || event_timestamp_secs > now_secs + MAX_TIMESTAMP_SKEW_SECS {
    return Err(reject::custom(ServiceError::bad_request(
        CustomEventIngestError::StaleTimestamp(body.timestamp_micros).into()
    )));
}

// Add deduplication via insertId
let insert_id = format!("{}-{}-{}", claims.peer_id, event_timestamp_secs, 
    hash_event(&telemetry_event));
insert_request.add_row(Some(insert_id), &row)?;
```

## Proof of Concept

### Step 1: Capture legitimate telemetry packet
```bash
# Intercept CLI telemetry traffic
tcpdump -i any -A 'host www.google-analytics.com and port 443' -w telemetry.pcap

# Or use proxy to capture HTTP POST
mitmproxy --mode transparent
```

### Step 2: Extract and replay packet
```bash
# Replay captured request multiple times
for i in {1..100}; do
  curl -X POST 'https://www.google-analytics.com/mp/collect?measurement_id=G-ZX4L6WPCFZ&api_secret=ArtslKPTTjeiMi1n-IR39g' \
    -H 'Content-Type: application/json' \
    -d '{
      "client_id": "CAPTURED_CLIENT_ID",
      "user_id": "CAPTURED_USER_ID", 
      "timestamp_micros": "CAPTURED_TIMESTAMP",
      "events": [CAPTURED_EVENTS]
    }'
done
```

### Step 3: Verify pollution
Check Google Analytics dashboard - the same event appears 100+ times with identical timestamps, demonstrating successful replay attack and analytics pollution.

## Notes

This vulnerability is limited to the telemetry subsystem and does not affect core blockchain security invariants (consensus, execution, storage, or funds). The primary impact is degraded observability and potentially misleading operational metrics. While marked as Low severity, it represents a real data integrity issue that should be addressed to maintain reliable telemetry infrastructure.

### Citations

**File:** crates/aptos-telemetry/src/cli_metrics.rs (L19-53)
```rust
pub async fn send_cli_telemetry_event(
    mut build_information: BTreeMap<String, String>,
    command: String,
    latency: Duration,
    success: bool,
    error: Option<&str>,
) {
    // Collection information about the cli command
    collect_cli_info(command, latency, success, error, &mut build_information);

    // Create a new telemetry event
    let telemetry_event = TelemetryEvent {
        name: APTOS_CLI_METRICS.into(),
        params: build_information,
    };

    // TODO(joshlind): can we find a better way of identifying each CLI user?
    let user_id = uuid::Uuid::new_v4().to_string();

    // Send the event (we block on the join handle to ensure the
    // event is processed before terminating the cli command).
    let join_handle = service::prepare_and_send_telemetry_event(
        user_id,
        "NO_CHAIN".into(),
        None,
        telemetry_event,
    )
    .await;
    if let Err(error) = join_handle.await {
        debug!(
            "Failed to send telemetry event with join error: {:?}",
            error
        );
    }
}
```

**File:** crates/aptos-telemetry/src/service.rs (L432-446)
```rust
pub(crate) async fn prepare_and_send_telemetry_event(
    peer_id: String,
    chain_id: String,
    telemetry_sender: Option<TelemetrySender>,
    telemetry_event: TelemetryEvent,
) -> JoinHandle<()> {
    // Update the telemetry event with the ip address and random token
    let TelemetryEvent { name, mut params } = telemetry_event;
    params.insert(TELEMETRY_TOKEN_KEY.to_string(), TELEMETRY_TOKEN.clone());
    params.insert(CHAIN_ID_KEY.into(), chain_id);
    let telemetry_event = TelemetryEvent { name, params };

    // Send the telemetry event
    send_telemetry_event(peer_id, telemetry_sender, telemetry_event).await
}
```

**File:** crates/aptos-telemetry/src/service.rs (L449-484)
```rust
async fn send_telemetry_event(
    peer_id: String,
    telemetry_sender: Option<TelemetrySender>,
    telemetry_event: TelemetryEvent,
) -> JoinHandle<()> {
    // Parse the Google analytics env variables
    let api_secret =
        env::var(ENV_GA_API_SECRET).unwrap_or_else(|_| APTOS_GA_API_SECRET.to_string());
    let measurement_id =
        env::var(ENV_GA_MEASUREMENT_ID).unwrap_or_else(|_| APTOS_GA_MEASUREMENT_ID.to_string());

    // Create and send the telemetry dump
    let event_name = telemetry_event.name.clone();
    let timestamp_micros = match SystemTime::now().duration_since(UNIX_EPOCH) {
        Ok(duration) => duration.as_micros().to_string(),
        Err(_) => UNKNOWN_METRIC_VALUE.into(),
    };
    let telemetry_dump = TelemetryDump {
        client_id: Uuid::new_v4().to_string(), // We generate a random client id for each request
        user_id: peer_id,
        timestamp_micros,
        events: vec![telemetry_event],
    };
    if telemetry_sender.is_none() {
        // telemetry_sender is None for Aptos CLI.
        spawn_event_sender_to_google_analytics(
            api_secret,
            measurement_id,
            event_name,
            telemetry_dump,
        )
    } else {
        // Aptos nodes send their metrics to aptos-telemetry-service crate.
        spawn_event_sender_to_telemetry_service(event_name, telemetry_sender, telemetry_dump)
    }
}
```

**File:** crates/aptos-telemetry/src/service.rs (L501-549)
```rust
fn spawn_event_sender_to_google_analytics(
    api_secret: String,
    measurement_id: String,
    event_name: String,
    telemetry_dump: TelemetryDump,
) -> JoinHandle<()> {
    tokio::spawn(async move {
        // Create a request client
        let client = reqwest::Client::new();

        // Send the request and wait for a response
        let send_result = client
            .post(format!(
                "{}?&measurement_id={}&api_secret={}",
                GA4_URL, measurement_id, api_secret
            ))
            .json::<TelemetryDump>(&telemetry_dump)
            .send()
            .await;

        // Process the response
        match send_result {
            Ok(response) => {
                let status_code = response.status();
                if status_code.is_success() {
                    debug!(
                        "Sent telemetry event {}, data: {:?}",
                        event_name, &telemetry_dump
                    );
                    metrics::increment_telemetry_successes(&event_name);
                } else {
                    debug!(
                        "Failed to send telemetry event! Status: {}, event: {}.",
                        response.status(),
                        event_name
                    );
                    debug!("Failed telemetry response: {:?}", response.text().await);
                    metrics::increment_telemetry_failures(&event_name);
                }
            },
            Err(error) => {
                debug!(
                    "Failed to send telemetry event: {}. Error: {:?}",
                    event_name, error
                );
                metrics::increment_telemetry_failures(&event_name);
            },
        }
    })
```

**File:** crates/aptos-telemetry/src/constants.rs (L24-30)
```rust
pub(crate) const APTOS_GA_MEASUREMENT_ID: &str = "G-ZX4L6WPCFZ";
pub(crate) const APTOS_GA_API_SECRET: &str = "ArtslKPTTjeiMi1n-IR39g";

// Useful URLS.
// Note: the measurement protocol requires HTTPS.
// See: https://developers.google.com/analytics/devguides/collection/protocol/v1/reference#transport
pub(crate) const GA4_URL: &str = "https://www.google-analytics.com/mp/collect";
```

**File:** crates/aptos-telemetry-service/src/custom_event.rs (L67-110)
```rust
pub(crate) async fn handle_custom_event(
    context: Context,
    claims: Claims,
    mut body: TelemetryDump,
    forwarded_for: Option<String>,
) -> anyhow::Result<impl Reply, Rejection> {
    validate_custom_event_body(&claims, &body)?;

    let mut insert_request = TableDataInsertAllRequest::new();

    let client_ip = forwarded_for
        .as_ref()
        .and_then(|xff| xff.split(',').next())
        .unwrap_or("UNKNOWN");

    let telemetry_event = &mut body.events[0];
    telemetry_event
        .params
        .insert(IP_ADDRESS_KEY.into(), client_ip.into());

    let event_params: Vec<serde_json::Value> = telemetry_event
        .params
        .iter()
        .map(|(k, v)| {
            json!({
                "key": k,
                "value": v
            })
        })
        .collect();

    let duration =
        Duration::from_micros(body.timestamp_micros.as_str().parse::<u64>().map_err(|_| {
            ServiceError::bad_request(
                CustomEventIngestError::InvalidTimestamp(body.timestamp_micros).into(),
            )
        })?);

    let row = BigQueryRow {
        event_identity: EventIdentity::from(claims),
        event_name: telemetry_event.name.clone(),
        event_timestamp: duration.as_secs(),
        event_params,
    };
```

**File:** crates/aptos-telemetry-service/src/custom_event.rs (L112-115)
```rust
    insert_request.add_row(None, &row).map_err(|e| {
        error!("unable to create row: {}", e);
        ServiceError::internal(CustomEventIngestError::from(e).into())
    })?;
```
