# Audit Report

## Title
Missing QC-TC Round Consistency Check in `safe_to_timeout()` Allows Validators to Sign Timeouts with Regressed Chain Views

## Summary
The `safe_to_timeout()` function in the 2-chain consensus protocol lacks a critical consistency check that exists in `safe_to_vote()`. When a timeout certificate (TC) is used to justify progressing to the next round, the function fails to verify that the timeout's QC round is at least as high as the TC's highest QC round. This allows validators to sign timeouts with regressed chain views, violating the monotonicity invariant of the consensus protocol.

## Finding Description
The 2-chain consensus protocol in Aptos uses two safety rules functions to validate voting and timeout behavior. In `safe_to_vote()`, when a block is proposed based on a timeout certificate, the function enforces: [1](#0-0) 

The key constraint is that when using the TC path (`round == tc_round + 1`), the block's QC must satisfy `qc_round >= hqc_round`, ensuring no regression in the chain view.

However, the corresponding `safe_to_timeout()` function lacks this check: [2](#0-1) 

The function only checks if `round == tc_round + 1` OR `round == qc_round + 1`, combined with `qc_round >= one_chain_round`, but **never validates** that `qc_round >= tc.highest_hqc_round()` when using the TC path.

**Attack Scenario:**

1. Network progresses to round 100 with QC at round 99
2. Validators form TC₁₀₀ with `highest_hqc_round = 99`
3. A validator experiences network partition and has only observed QC from round 50, so `safety_data.one_chain_round = 50`
4. The validator receives TC₁₀₀ but the system doesn't call `observe_qc()` on the TC's embedded QC: [3](#0-2) 

5. The validator signs timeout for round 101 with their stale QC from round 50
6. Safety check passes: `round=101 == tc_round+1=101` ✓ and `qc_round=50 >= one_chain_round=50` ✓
7. The validator creates `TimeoutSigningRepr{epoch, round: 101, hqc_round: 50}` despite TC₁₀₀ certifying the network had reached round 99

This violates the invariant that validators should maintain monotonically increasing chain views. The TC formation at round 100 certified that 2f+1 validators had seen at least round 99, but this validator can now sign a timeout at round 101 claiming they've only seen round 50.

## Impact Explanation
This is a **Medium severity** vulnerability per the Aptos bug bounty criteria, as it creates state inconsistencies that may require manual intervention:

1. **Consensus Inconsistency**: Validators can sign timeouts with regressed QC views, creating divergent chain state representations across the network
2. **Monotonicity Violation**: Breaks the fundamental invariant that validators' chain views should progress monotonically forward
3. **Potential Safety Impact**: If enough validators (up to f+1) experience similar network conditions, they could collectively form a TC with a regressed `highest_hqc_round`, potentially enabling conflicting blocks to be voted on

While this doesn't immediately lead to fund theft or network halt, it creates a consensus protocol violation that could require validator coordination to resolve. The inconsistency could manifest during network partitions or high-latency scenarios, which are realistic conditions in distributed systems.

## Likelihood Explanation
**Likelihood: Medium**

This vulnerability can occur under realistic network conditions:

- **Network partitions**: Common in distributed systems, especially across geographic regions
- **Delayed message delivery**: Can cause validators to have temporarily stale views
- **Validator restarts**: A validator rejoining after downtime might have a stale `one_chain_round`

The vulnerability doesn't require Byzantine behavior—it can manifest from normal network asynchrony. However, it requires specific timing where:
1. A validator has a significantly outdated `one_chain_round`
2. The validator receives a TC from a much later round
3. The validator attempts to sign a timeout using the TC to justify the round

The key enabler is that `observe_qc()` is not called when processing TCs, allowing validators to remain unaware of the chain's actual progress even after receiving evidence (the TC) that the network has advanced.

## Recommendation
Add a consistency check in `safe_to_timeout()` that mirrors the check in `safe_to_vote()`. When using the TC path to justify a timeout, verify that the timeout's QC round is at least as high as the TC's highest QC round:

```rust
fn safe_to_timeout(
    &self,
    timeout: &TwoChainTimeout,
    maybe_tc: Option<&TwoChainTimeoutCertificate>,
    safety_data: &SafetyData,
) -> Result<(), Error> {
    let round = timeout.round();
    let qc_round = timeout.hqc_round();
    let tc_round = maybe_tc.map_or(0, |tc| tc.round());
    let hqc_round = maybe_tc.map_or(0, |tc| tc.highest_hqc_round());
    
    // Check consistency: when using TC path, QC must not regress
    if round == next_round(qc_round)? {
        // Direct QC path - just check one_chain_round
        if qc_round >= safety_data.one_chain_round {
            return Ok(());
        }
    } else if round == next_round(tc_round)? {
        // TC path - must check both one_chain_round AND hqc_round
        if qc_round >= safety_data.one_chain_round && qc_round >= hqc_round {
            return Ok(());
        }
    }
    
    Err(Error::NotSafeToTimeout(
        round,
        qc_round,
        tc_round,
        safety_data.one_chain_round,
    ))
}
```

Additionally, consider calling `observe_qc()` on the TC's embedded highest QC when processing a TC, to ensure validators' `one_chain_round` stays current with network progress.

## Proof of Concept
Add this test to `consensus/safety-rules/src/tests/suite.rs`:

```rust
fn test_2chain_timeout_qc_tc_consistency(constructor: &Callback) {
    let (mut safety_rules, signer) = constructor();
    let (proof, genesis_qc) = test_utils::make_genesis(&signer);
    let genesis_round = genesis_qc.certified_block().round();
    let round = genesis_round;
    safety_rules.initialize(&proof).unwrap();
    
    // Build chain: genesis (r0) -> a1 (r1) -> ... -> a50 (r50)
    let mut proposals = vec![];
    let mut prev = test_utils::make_proposal_with_qc(round + 1, genesis_qc.clone(), &signer);
    proposals.push(prev.clone());
    
    for i in 2..=50 {
        let next = make_proposal_with_parent(round + i, &prev, None, &signer);
        proposals.push(next.clone());
        prev = next;
    }
    
    // Vote on a50 to update one_chain_round to 50
    safety_rules.construct_and_sign_vote_two_chain(&proposals[49], None).unwrap();
    assert_eq!(safety_rules.consensus_state().unwrap().one_chain_round(), 50);
    
    // Continue chain to round 99
    for i in 51..=99 {
        let next = make_proposal_with_parent(round + i, &prev, None, &signer);
        proposals.push(next.clone());
        prev = next;
    }
    
    // Create TC at round 100 with QC from round 99
    let tc_100 = make_timeout_cert(100, proposals[98].block().quorum_cert(), &signer);
    
    // Attempt to sign timeout at round 101 with stale QC from round 50
    // This SHOULD fail but currently passes due to missing check
    let result = safety_rules.sign_timeout_with_qc(
        &TwoChainTimeout::new(1, 101, proposals[49].block().quorum_cert().clone()),
        Some(&tc_100),
    );
    
    // Expected: Error because qc_round (50) < tc.highest_hqc_round (99)
    // Actual: Passes incorrectly
    assert!(result.is_err(), "Timeout with regressed QC should be rejected");
}
```

## Notes
This vulnerability highlights a subtle inconsistency between the voting and timeout safety rules in the 2-chain consensus protocol. The `safe_to_vote()` function correctly enforces QC-TC consistency, but `safe_to_timeout()` omits this critical check. The vulnerability can be triggered by network conditions common in production distributed systems, making it a genuine medium-severity issue that should be addressed to maintain consensus safety guarantees.

### Citations

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L19-51)
```rust
    pub(crate) fn guarded_sign_timeout_with_qc(
        &mut self,
        timeout: &TwoChainTimeout,
        timeout_cert: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;
        let mut safety_data = self.persistent_storage.safety_data()?;
        self.verify_epoch(timeout.epoch(), &safety_data)?;
        if !self.skip_sig_verify {
            timeout
                .verify(&self.epoch_state()?.verifier)
                .map_err(|e| Error::InvalidTimeout(e.to_string()))?;
        }
        if let Some(tc) = timeout_cert {
            self.verify_tc(tc)?;
        }

        self.safe_to_timeout(timeout, timeout_cert, &safety_data)?;
        if timeout.round() < safety_data.last_voted_round {
            return Err(Error::IncorrectLastVotedRound(
                timeout.round(),
                safety_data.last_voted_round,
            ));
        }
        if timeout.round() > safety_data.last_voted_round {
            self.verify_and_update_last_vote_round(timeout.round(), &mut safety_data)?;
        }
        self.update_highest_timeout_round(timeout, &mut safety_data);
        self.persistent_storage.set_safety_data(safety_data)?;

        let signature = self.sign(&timeout.signing_format())?;
        Ok(signature)
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L121-145)
```rust
    /// Core safety timeout rule for 2-chain protocol. Return success if 1 and 2 are true
    /// 1. round == timeout.qc.round + 1 || round == tc.round + 1
    /// 2. timeout.qc.round >= one_chain_round
    fn safe_to_timeout(
        &self,
        timeout: &TwoChainTimeout,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
        safety_data: &SafetyData,
    ) -> Result<(), Error> {
        let round = timeout.round();
        let qc_round = timeout.hqc_round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        if (round == next_round(qc_round)? || round == next_round(tc_round)?)
            && qc_round >= safety_data.one_chain_round
        {
            Ok(())
        } else {
            Err(Error::NotSafeToTimeout(
                round,
                qc_round,
                tc_round,
                safety_data.one_chain_round,
            ))
        }
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L147-166)
```rust
    /// Core safety voting rule for 2-chain protocol. Return success if 1 or 2 is true
    /// 1. block.round == block.qc.round + 1
    /// 2. block.round == tc.round + 1 && block.qc.round >= tc.highest_hqc.round
    fn safe_to_vote(
        &self,
        block: &Block,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<(), Error> {
        let round = block.round();
        let qc_round = block.quorum_cert().certified_block().round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        let hqc_round = maybe_tc.map_or(0, |tc| tc.highest_hqc_round());
        if round == next_round(qc_round)?
            || (round == next_round(tc_round)? && qc_round >= hqc_round)
        {
            Ok(())
        } else {
            Err(Error::NotSafeToVote(round, qc_round, tc_round, hqc_round))
        }
    }
```
