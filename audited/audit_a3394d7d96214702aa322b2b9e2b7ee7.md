# Audit Report

## Title
Missing File Permission Validation in IdentityBlob::from_file() Enables Validator Private Key Exposure

## Summary
The `IdentityBlob::from_file()` function does not validate file permissions before reading validator identity files containing consensus private keys, account private keys, and network private keys. If file permissions are misconfigured (e.g., world-readable 0644 instead of secure 0600), an unprivileged local user can read these files and extract validator private keys, enabling consensus attacks and validator impersonation.

## Finding Description

The `IdentityBlob::from_file()` function in `config/src/config/identity_config.rs` reads validator identity files without checking file permissions: [1](#0-0) 

This function deserializes a YAML file containing critical cryptographic material:
- `consensus_private_key` (BLS12-381): Used to sign consensus votes and block proposals
- `account_private_key` (Ed25519): Used for validator account operations  
- `network_private_key` (x25519): Used for secure P2P communication [2](#0-1) 

The identity files are used by validators at startup, loaded through the consensus safety rules configuration and network configuration: [3](#0-2) [4](#0-3) 

While the codebase correctly creates these files with secure permissions (mode 0600) during genesis using `write_to_user_only_file()`: [5](#0-4) [6](#0-5) 

There is no validation when **reading** these files to ensure permissions remain secure. This violates defense-in-depth security principles.

**Attack Scenario:**

1. Validator operator accidentally runs `chmod 644 validator-identity.yaml` or a configuration management tool sets incorrect permissions
2. File becomes world-readable (any local user can read it)
3. Attacker with local non-privileged access to the validator machine reads the file
4. Attacker extracts `consensus_private_key` from the YAML
5. With the consensus private key, attacker can:
   - Sign malicious consensus votes, enabling equivocation attacks
   - Sign conflicting block proposals at the same height
   - Violate AptosBFT safety guarantees (critical invariant #2: "Consensus Safety")
   - Impersonate the validator in the consensus protocol

The consensus private key is used by SafetyRules to sign all consensus messages. With this key compromised, the attacker can create Byzantine behavior that violates consensus safety assumptions.

## Impact Explanation

This is **HIGH severity** per Aptos bug bounty criteria:

- **Significant protocol violations**: Enables equivocation attacks that violate AptosBFT consensus safety
- **Validator node security compromise**: Exposes validator's cryptographic identity
- **Potential for consensus safety violations**: With consensus private key, attacker can sign conflicting votes

While not CRITICAL (requires local access, not remote exploitation), the impact of consensus key exposure is severe enough to warrant HIGH severity classification. It enables attacks on the consensus protocol's core safety guarantees.

## Likelihood Explanation

**Likelihood: MEDIUM**

Prerequisites:
1. File permission misconfiguration (realistic operational error)
2. Local filesystem access by unprivileged user (shared hosting, compromised service, insider)

Realistic scenarios where permissions could be misconfigured:
- Manual deployment errors (`chmod 644` instead of `chmod 600`)
- Configuration management tools (Ansible, Puppet, Terraform) with incorrect templates
- Docker volume mounts with wrong permissions
- Backup and restore operations
- File copies with different umask settings
- Container security context misconfiguration

The combination of operational error + local access makes this MEDIUM likelihood rather than HIGH.

## Recommendation

Implement file permission validation in `IdentityBlob::from_file()` to reject files with overly permissive permissions, similar to SSH's handling of private key files.

**Recommended Fix:**

```rust
pub fn from_file(path: &Path) -> anyhow::Result<IdentityBlob> {
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        let metadata = std::fs::metadata(path)?;
        let mode = metadata.permissions().mode();
        
        // Check that file is readable only by owner (mode 0o600 or stricter)
        if mode & 0o077 != 0 {
            anyhow::bail!(
                "Identity file {:?} has overly permissive permissions ({:o}). \
                 File must be readable only by owner (mode 0o600 or stricter). \
                 Run: chmod 600 {:?}",
                path,
                mode & 0o777,
                path
            );
        }
    }
    
    Ok(serde_yaml::from_str(&fs::read_to_string(path)?)?)
}
```

Also add validation to `Identity::load_identity()`: [7](#0-6) 

## Proof of Concept

**Demonstration Steps:**

1. Create a test identity file with world-readable permissions:

```bash
# Create identity file with validator keys
cat > /tmp/validator-identity.yaml <<EOF
account_address: "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
account_private_key: "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
consensus_private_key: "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
network_private_key: "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
EOF

# Make file world-readable (INSECURE)
chmod 644 /tmp/validator-identity.yaml

# Verify permissions are wrong
ls -la /tmp/validator-identity.yaml
# Output: -rw-r--r-- (world-readable!)
```

2. Current code will successfully read the insecure file:

```rust
use aptos_config::config::IdentityBlob;
use std::path::Path;

fn main() {
    let path = Path::new("/tmp/validator-identity.yaml");
    
    // This succeeds even though permissions are insecure!
    match IdentityBlob::from_file(path) {
        Ok(blob) => {
            println!("Successfully read identity file with insecure permissions!");
            println!("Consensus key exposed!");
        },
        Err(e) => println!("Error: {}", e),
    }
}
```

3. With the fix, the code would reject the insecure file:

```
Error: Identity file "/tmp/validator-identity.yaml" has overly permissive permissions (644).
File must be readable only by owner (mode 0o600 or stricter).
Run: chmod 600 "/tmp/validator-identity.yaml"
```

**Notes**

- This vulnerability requires defense-in-depth hardening rather than being a pure logic bug
- The codebase demonstrates awareness of permission security through `write_to_user_only_file()` and `save_to_file_confidential()` functions, but lacks corresponding read-time validation
- Similar security-critical tools (SSH with `~/.ssh/id_rsa`, GPG with private keys) enforce permission validation at read time as standard practice
- The fix is minimal (< 15 lines) and provides immediate security improvement with clear error messages to operators

### Citations

**File:** config/src/config/identity_config.rs (L24-37)
```rust
#[derive(Deserialize, Serialize)]
pub struct IdentityBlob {
    /// Optional account address. Used for validators and validator full nodes
    #[serde(skip_serializing_if = "Option::is_none")]
    pub account_address: Option<AccountAddress>,
    /// Optional account key. Only used for validators
    #[serde(skip_serializing_if = "Option::is_none")]
    pub account_private_key: Option<Ed25519PrivateKey>,
    /// Optional consensus key. Only used for validators
    #[serde(skip_serializing_if = "Option::is_none")]
    pub consensus_private_key: Option<bls12381::PrivateKey>,
    /// Network private key. Peer id is derived from this if account address is not present
    pub network_private_key: x25519::PrivateKey,
}
```

**File:** config/src/config/identity_config.rs (L40-42)
```rust
    pub fn from_file(path: &Path) -> anyhow::Result<IdentityBlob> {
        Ok(serde_yaml::from_str(&fs::read_to_string(path)?)?)
    }
```

**File:** config/src/config/identity_config.rs (L105-115)
```rust
    pub fn load_identity(path: &PathBuf) -> anyhow::Result<Option<Self>> {
        if path.exists() {
            let bytes = fs::read(path)?;
            let private_key_bytes: [u8; PRIVATE_KEY_SIZE] = bytes.as_slice().try_into()?;
            let private_key = x25519::PrivateKey::from(private_key_bytes);
            let peer_id = from_identity_public_key(private_key.public_key());
            Ok(Some(Identity::from_config(private_key, peer_id)))
        } else {
            Ok(None)
        }
    }
```

**File:** docker/compose/aptos-node/validator.yaml (L15-19)
```yaml
    initial_safety_rules_config:
      from_file:
        waypoint:
          from_file: /opt/aptos/genesis/waypoint.txt
        identity_blob_path: /opt/aptos/genesis/validator-identity.yaml
```

**File:** docker/compose/aptos-node/validator.yaml (L31-33)
```yaml
  identity:
    type: "from_file"
    path: /opt/aptos/genesis/validator-identity.yaml
```

**File:** crates/aptos/src/common/utils.rs (L224-229)
```rust
pub fn write_to_user_only_file(path: &Path, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    let mut opts = OpenOptions::new();
    #[cfg(unix)]
    opts.mode(0o600);
    write_to_file_with_opts(path, name, bytes, &mut opts)
}
```

**File:** crates/aptos/src/genesis/keys.rs (L92-97)
```rust
        write_to_user_only_file(
            validator_file.as_path(),
            VALIDATOR_FILE,
            to_yaml(&validator_blob)?.as_bytes(),
        )?;
        write_to_user_only_file(vfn_file.as_path(), VFN_FILE, to_yaml(&vfn_blob)?.as_bytes())?;
```
