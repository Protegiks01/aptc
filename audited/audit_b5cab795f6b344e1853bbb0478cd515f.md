# Audit Report

## Title
Missing Cryptographic Verification in State Snapshot Restore Allows Arbitrary State Injection

## Summary
When restoring state snapshots without epoch history verification (e.g., via db-tool), the system fails to validate BLS signatures on the LedgerInfoWithSignatures, allowing an attacker with backup storage access to inject arbitrary blockchain state that doesn't match the network's cryptographic commitment.

## Finding Description

The `StateSnapshotBackupMeta` struct lacks a state root hash field, storing only epoch, version, and manifest handle: [1](#0-0) 

While the root hash is stored in the actual manifest file and verified against a proof during restore, the critical vulnerability lies in the optional signature verification. During restore, the system loads the proof file and verifies mathematical consistency: [2](#0-1) 

However, cryptographic signature verification only occurs when epoch_history is provided: [3](#0-2) 

The `verify_ledger_info` method performs BLS signature verification using the validator set from previous epochs: [4](#0-3) 

**Critical Issue:** The db-tool explicitly passes `None` for epoch_history during one-off restores: [5](#0-4) 

**Attack Path:**
1. Attacker gains write access to backup storage (via compromise or insider access to storage infrastructure)
2. Attacker creates malicious backup files:
   - Manifest with arbitrary root_hash (e.g., state with inflated account balances)
   - Self-consistent TransactionInfoWithProof containing the fake root_hash
   - Fake LedgerInfoWithSignatures with no valid BLS signatures
   - State chunks matching the fake root_hash
3. Node operator uses db-tool to restore from compromised backup
4. The `TransactionInfoWithProof.verify()` only checks mathematical consistency with the (fake) LedgerInfo: [6](#0-5) 

5. Since epoch_history is None, BLS signature verification is skipped
6. The fake state is loaded into the database
7. Node operates with incorrect state that violates the blockchain's cryptographic commitment

**Broken Invariants:**
- **State Consistency**: "State transitions must be atomic and verifiable via Merkle proofs" - The restored state is not cryptographically verified
- **Deterministic Execution**: "All validators must produce identical state roots for identical blocks" - Validators with compromised restores will have different state
- **Cryptographic Correctness**: "BLS signatures, VRF, and hash operations must be secure" - BLS signature verification is bypassed

## Impact Explanation

**Critical Severity** - This vulnerability enables multiple critical attack vectors:

1. **Loss of Funds**: An attacker can create a backup with modified account balances, enabling theft or minting of arbitrary funds when the fake state is restored

2. **Consensus/Safety Violations**: If validator nodes restore from malicious backups, they will have incorrect state roots, causing:
   - Vote on different state hashes for the same transactions
   - Consensus deadlocks or chain splits
   - Network partition requiring manual intervention or hardfork

3. **State Integrity Compromise**: The fundamental blockchain guarantee that all state is cryptographically committed and verified is violated, undermining the entire security model

Per Aptos Bug Bounty criteria, this clearly meets **Critical Severity ($1,000,000)** as it enables "Loss of Funds (theft or minting)" and "Consensus/Safety violations."

## Likelihood Explanation

**Likelihood: Medium-High**

**Attacker Requirements:**
- Write access to backup storage infrastructure (cloud storage buckets, backup servers)
- Knowledge that target will use db-tool for restore
- Technical ability to construct self-consistent but fake backup files

**Realistic Scenarios:**
1. **Compromised Cloud Storage**: Backup storage (S3, GCS, etc.) is compromised through credential theft or misconfiguration
2. **Insider Threat**: Malicious operator with backup storage access
3. **Supply Chain Attack**: Compromised backup service provider
4. **Disaster Recovery**: Operators commonly use db-tool for initial node setup or disaster recovery

**Mitigating Factors:**
- Requires privileged access to backup storage (not arbitrary network attacker)
- Limited to one-off restores via db-tool (normal restore coordinator uses epoch_history)

**Aggravating Factors:**
- Backup storage is often less secured than validator infrastructure
- Attack is silent - operators may not realize they restored fake state until consensus failures occur
- Impact amplifies if multiple validators restore from same compromised backup

## Recommendation

**Fix 1: Require Epoch History for All Restores**

Modify db-tool to require epoch_history for state snapshot restores, removing the option to bypass signature verification:

```rust
// In storage/db-tool/src/restore.rs
Oneoff::StateSnapshot {
    storage,
    opt,
    global,
} => {
    // Load epoch history first
    let epoch_history = EpochHistoryRestoreController::new(/* ... */)
        .run()
        .await?;
    
    StateSnapshotRestoreController::new(
        opt,
        global.try_into()?,
        storage.init_storage().await?,
        Some(epoch_history), // Make this required
    )
    .run()
    .await?;
}
```

**Fix 2: Add State Root to Metadata (Defense in Depth)**

Add the state root hash to `StateSnapshotBackupMeta` for early validation:

```rust
// In storage/backup/backup-cli/src/metadata/mod.rs
#[derive(Clone, Debug, Deserialize, Serialize, Eq, PartialEq, Ord, PartialOrd)]
pub struct StateSnapshotBackupMeta {
    pub epoch: u64,
    pub version: Version,
    pub root_hash: HashValue,  // Add this field
    pub manifest: FileHandle,
}
```

Update backup creation to include root_hash:

```rust
// In storage/backup/backup-cli/src/backup_types/state_snapshot/backup.rs
let metadata = Metadata::new_state_snapshot_backup(
    self.epoch,
    self.version(),
    txn_info.transaction_info().ensure_state_checkpoint_hash()?,  // Add root hash
    manifest_handle.clone(),
);
```

**Fix 3: Fail-Safe - Reject Unverified Restores**

Make epoch_history mandatory or add explicit operator confirmation:

```rust
// In storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs
if self.epoch_history.is_none() {
    bail!(
        "State snapshot restore without epoch history verification is unsafe. \
         Please restore epoch history first or use --force-unverified-restore flag."
    );
}
```

## Proof of Concept

```rust
// Proof of concept demonstrating the vulnerability
// This would be added as a test in storage/backup/backup-cli/src/backup_types/state_snapshot/tests.rs

#[tokio::test]
async fn test_malicious_restore_without_epoch_history() {
    use aptos_crypto::HashValue;
    use aptos_types::transaction::TransactionInfo;
    
    // Step 1: Create a fake TransactionInfo with arbitrary state root
    let fake_state_root = HashValue::random();
    let fake_txn_info = TransactionInfo::new(
        HashValue::random(),
        fake_state_root,  // Arbitrary state root
        HashValue::random(),
        Some(fake_state_root),
        0,
        aptos_types::transaction::ExecutionStatus::Success,
    );
    
    // Step 2: Create a fake LedgerInfo (no valid signatures needed when epoch_history=None)
    let fake_ledger_info = LedgerInfo::new(
        BlockInfo::new(0, 0, HashValue::random(), fake_txn_info.hash(), 100, 0, None),
        HashValue::zero(),
    );
    
    // Step 3: Create fake proof that's mathematically consistent
    let fake_proof = TransactionAccumulatorProof::new(vec![]);
    let fake_txn_info_with_proof = TransactionInfoWithProof::new(
        fake_proof,
        fake_txn_info,
    );
    
    // Step 4: Create LedgerInfoWithSignatures with empty signatures
    let fake_li_with_sigs = LedgerInfoWithSignatures::new(
        fake_ledger_info,
        AggregateSignature::empty(),  // No valid signatures!
    );
    
    // Step 5: Verify that the fake proof passes verification when epoch_history=None
    // This should FAIL but currently succeeds
    let result = fake_txn_info_with_proof.verify(fake_li_with_sigs.ledger_info(), 100);
    assert!(result.is_ok());  // Mathematical consistency check passes
    
    // Step 6: Show that without epoch_history, there's no signature verification
    // In real restore, this fake state would be loaded into the database
    // demonstrating the vulnerability
    
    println!("VULNERABILITY: Fake state with root hash {} would be loaded!", fake_state_root);
}
```

## Notes

The vulnerability stems from the design decision to make epoch history verification optional. While `StateSnapshotBackupMeta` lacks the state root hash field, the root hash is properly stored in the manifest file and checked against the proof. However, the proof itself is never cryptographically verified when `epoch_history` is `None`.

The normal restore coordinator path (used during continuous operation) does provide epoch_history and performs signature verification. The vulnerability specifically affects:
- One-off restores via db-tool
- Test scenarios
- Replay verification without epoch history

This represents a gap between the security model (all state must be cryptographically verified) and the implementation (signature verification is optional).

### Citations

**File:** storage/backup/backup-cli/src/metadata/mod.rs (L184-189)
```rust
#[derive(Clone, Debug, Deserialize, Serialize, Eq, PartialEq, Ord, PartialOrd)]
pub struct StateSnapshotBackupMeta {
    pub epoch: u64,
    pub version: Version,
    pub manifest: FileHandle,
}
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L123-136)
```rust
        let manifest: StateSnapshotBackup =
            self.storage.load_json_file(&self.manifest_handle).await?;
        let (txn_info_with_proof, li): (TransactionInfoWithProof, LedgerInfoWithSignatures) =
            self.storage.load_bcs_file(&manifest.proof).await?;
        txn_info_with_proof.verify(li.ledger_info(), manifest.version)?;
        let state_root_hash = txn_info_with_proof
            .transaction_info()
            .ensure_state_checkpoint_hash()?;
        ensure!(
            state_root_hash == manifest.root_hash,
            "Root hash mismatch with that in proof. root hash: {}, expected: {}",
            manifest.root_hash,
            state_root_hash,
        );
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L137-139)
```rust
        if let Some(epoch_history) = self.epoch_history.as_ref() {
            epoch_history.verify_ledger_info(&li)?;
        }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L276-312)
```rust
    pub fn verify_ledger_info(&self, li_with_sigs: &LedgerInfoWithSignatures) -> Result<()> {
        let epoch = li_with_sigs.ledger_info().epoch();
        ensure!(!self.epoch_endings.is_empty(), "Empty epoch history.",);
        if epoch > self.epoch_endings.len() as u64 {
            // TODO(aldenhu): fix this from upper level
            warn!(
                epoch = epoch,
                epoch_history_until = self.epoch_endings.len(),
                "Epoch is too new and can't be verified. Previous chunks are verified and node \
                won't be able to start if this data is malicious."
            );
            return Ok(());
        }
        if epoch == 0 {
            ensure!(
                li_with_sigs.ledger_info() == &self.epoch_endings[0],
                "Genesis epoch LedgerInfo info doesn't match.",
            );
        } else if let Some(wp_trusted) = self
            .trusted_waypoints
            .get(&li_with_sigs.ledger_info().version())
        {
            let wp_li = Waypoint::new_any(li_with_sigs.ledger_info());
            ensure!(
                *wp_trusted == wp_li,
                "Waypoints don't match. In backup: {}, trusted: {}",
                wp_li,
                wp_trusted,
            );
        } else {
            self.epoch_endings[epoch as usize - 1]
                .next_epoch_state()
                .ok_or_else(|| anyhow!("Shouldn't contain non- epoch bumping LIs."))?
                .verify(li_with_sigs)?;
        };
        Ok(())
    }
```

**File:** storage/db-tool/src/restore.rs (L88-95)
```rust
                        StateSnapshotRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                            None, /* epoch_history */
                        )
                        .run()
                        .await?;
```

**File:** types/src/proof/mod.rs (L40-61)
```rust
fn verify_transaction_info(
    ledger_info: &LedgerInfo,
    transaction_version: Version,
    transaction_info: &TransactionInfo,
    ledger_info_to_transaction_info_proof: &TransactionAccumulatorProof,
) -> Result<()> {
    ensure!(
        transaction_version <= ledger_info.version(),
        "Transaction version {} is newer than LedgerInfo version {}.",
        transaction_version,
        ledger_info.version(),
    );

    let transaction_info_hash = transaction_info.hash();
    ledger_info_to_transaction_info_proof.verify(
        ledger_info.transaction_accumulator_hash(),
        transaction_info_hash,
        transaction_version,
    )?;

    Ok(())
}
```
