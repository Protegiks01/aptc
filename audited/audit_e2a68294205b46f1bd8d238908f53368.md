# Audit Report

## Title
Poisoned Lock DoS via Unchecked Future Round in Randomness Generation

## Summary
A Byzantine validator can crash any other validator by sending a malicious `RequestShare` RPC message with a far-future round number, causing a panic while holding a critical consensus lock, poisoning the lock, and forcing the entire validator process to terminate.

## Finding Description

The `aptos-infallible` crate wraps Rust's standard `Mutex` and `RwLock` types to automatically panic on poisoned locks rather than returning `Result` types. [1](#0-0) 

When a thread panics while holding one of these locks, the lock becomes poisoned. Any subsequent attempt to acquire the poisoned lock will panic due to the `.expect()` call in the wrapper. [1](#0-0) 

The crash handler is configured to terminate the entire validator process on any panic (except Move bytecode verifier panics). [2](#0-1) 

In the randomness generation subsystem, the `RandManager` handles `RequestShare` RPC messages from peers. When a request arrives for a share that doesn't exist locally, the node attempts to regenerate it. [3](#0-2) 

The critical vulnerability is at line 404, where `add_share()` is called with `.expect()` while holding the `rand_store` lock. [4](#0-3) 

The `add_share()` method validates that the share's round is not too far in the future. [5](#0-4) 

The validation allows rounds up to `highest_known_round + FUTURE_ROUNDS_TO_ACCEPT` where `FUTURE_ROUNDS_TO_ACCEPT = 200`. [6](#0-5) 

However, `RequestShare` messages only validate that the epoch matches during message verification - the round number is not checked. [7](#0-6) 

**Attack Execution Flow:**

1. Byzantine validator crafts `RequestShare` message with `epoch = current_epoch` and `round = current_round + 201`
2. Message passes verification because epoch matches and `RequestShare` has no additional validation
3. Victim validator processes message, calls `get_self_share()` which returns `Ok(None)`
4. Victim generates share using the malicious metadata: `S::generate(&self.config, request.rand_metadata().clone())`
5. Victim calls `self.rand_store.lock().add_share()` **acquiring the lock**
6. Inside `add_share()`, the future round check fails: `(current_round + 201) > (highest_known_round + 200)`
7. Returns `Err("Share from future round")` **while lock is held**
8. The `.expect("Add self share should succeed")` panics **while lock is held**
9. Lock becomes poisoned
10. Any other thread attempting `rand_store.lock()` panics on the poisoned lock
11. Crash handler calls `process::exit(12)`, terminating the validator

## Impact Explanation

This is a **High Severity** availability vulnerability per Aptos bug bounty criteria.

**Single Validator Impact:** A Byzantine validator can crash any peer validator with a single malicious RPC message, causing validator downtime until manual operator restart.

**Network-Wide Impact:** If the attacker is a validator, they can systematically crash all other validators in the network. If the attack is repeated immediately after each restart, validators cannot recover, leading to complete network liveness failure. This escalates to **Critical Severity** as it causes "Total loss of liveness/network availability."

The vulnerability violates the fundamental Byzantine Fault Tolerance guarantee that the system should remain available under < 1/3 Byzantine validators. A single Byzantine validator can currently take down the entire network.

## Likelihood Explanation

**Likelihood: High**

- **Attacker Requirements:** Must be a validator in the current epoch to send consensus RPC messages
- **Technical Complexity:** Trivial - requires crafting a single RPC message with epoch and round fields
- **Detection Difficulty:** Attack leaves minimal traces and appears as a normal panic/crash
- **Repeatability:** Fully repeatable - attacker can crash validators indefinitely
- **Defense Mechanisms:** None - no rate limiting, validation, or recovery for this code path

The attack is deterministic and requires minimal resources or expertise.

## Recommendation

**Immediate Fix:** Replace the `.expect()` with proper error handling:

```rust
// In consensus/src/rand/rand_gen/rand_manager.rs around line 404
let share = maybe_share.unwrap_or_else(|| {
    let share = S::generate(&self.config, request.rand_metadata().clone());
    if let Err(e) = self.rand_store.lock().add_share(share.clone(), PathType::Slow) {
        warn!("[RandManager] Failed to add self-generated share: {}", e);
        // Return share anyway for response, don't add to store
    }
    share
});
```

**Comprehensive Fix:**

1. **Validate round in `RequestShare` verification:**
```rust
// In consensus/src/rand/rand_gen/network_messages.rs
RandMessage::RequestShare(request) => {
    // Add round validation
    ensure!(
        request.rand_metadata().round <= highest_known_round + FUTURE_ROUNDS_TO_ACCEPT,
        "RequestShare from too far in future"
    );
    Ok(())
}
```

2. **Remove `.expect()` from all lock-held operations** - audit all uses of `.expect()` in consensus code paths that hold `aptos-infallible` locks

3. **Consider lock poisoning recovery:** Either:
   - Implement a custom lock wrapper that handles poisoning gracefully
   - Use `parking_lot::Mutex` which doesn't poison
   - Add panic recovery boundaries around lock-critical sections

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_types::randomness::RandMetadata;
    
    #[test]
    #[should_panic(expected = "Share from future round")]
    fn test_future_round_dos() {
        // Setup: Create RandManager with current round = 100
        let current_epoch = 1;
        let current_round = 100;
        let manager = create_test_rand_manager(current_epoch, current_round);
        
        // Attack: Create RequestShare with future round
        let malicious_round = current_round + 201; // Beyond FUTURE_ROUNDS_TO_ACCEPT
        let malicious_metadata = RandMetadata {
            epoch: current_epoch,
            round: malicious_round,
        };
        let malicious_request = RequestShare::new(malicious_metadata);
        
        // Simulate receiving malicious RPC
        let msg = RandMessage::RequestShare(malicious_request);
        
        // Verify message passes validation (only checks epoch)
        assert!(msg.verify(&epoch_state, &rand_config, &None, sender).is_ok());
        
        // Process message - this will panic while holding lock
        // In production, this crashes the entire validator process
        process_request_share(&manager, malicious_request);
        
        // After panic, any access to rand_store.lock() will panic again
        // demonstrating cascading failure from poisoned lock
    }
}
```

**Notes:**

The vulnerability exists because `aptos-infallible` enforces a design philosophy of treating lock poisoning as unrecoverable, but combines this with `.expect()` calls in consensus-critical paths that can fail due to validation errors from untrusted input. The randomness generation system trusts that `RequestShare` messages have been sufficiently validated, but the validation only checks epoch, not round bounds. This gap allows Byzantine validators to trigger lock poisoning and cascade the failure through the crash handler to full process termination.

### Citations

**File:** crates/aptos-infallible/src/mutex.rs (L19-23)
```rust
    pub fn lock(&self) -> MutexGuard<'_, T> {
        self.0
            .lock()
            .expect("Cannot currently handle a poisoned lock")
    }
```

**File:** crates/crash-handler/src/lib.rs (L26-58)
```rust
pub fn setup_panic_handler() {
    panic::set_hook(Box::new(move |pi: &PanicHookInfo<'_>| {
        handle_panic(pi);
    }));
}

// Formats and logs panic information
fn handle_panic(panic_info: &PanicHookInfo<'_>) {
    // The Display formatter for a PanicHookInfo contains the message, payload and location.
    let details = format!("{}", panic_info);
    let backtrace = format!("{:#?}", Backtrace::new());

    let info = CrashInfo { details, backtrace };
    let crash_info = toml::to_string_pretty(&info).unwrap();
    error!("{}", crash_info);
    // TODO / HACK ALARM: Write crash info synchronously via eprintln! to ensure it is written before the process exits which error! doesn't guarantee.
    // This is a workaround until https://github.com/aptos-labs/aptos-core/issues/2038 is resolved.
    eprintln!("{}", crash_info);

    // Wait till the logs have been flushed
    aptos_logger::flush();

    // Do not kill the process if the panics happened at move-bytecode-verifier.
    // This is safe because the `state::get_state()` uses a thread_local for storing states. Thus the state can only be mutated to VERIFIER by the thread that's running the bytecode verifier.
    //
    // TODO: once `can_unwind` is stable, we should assert it. See https://github.com/rust-lang/rust/issues/92988.
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
}
```

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L397-412)
```rust
                        RandMessage::RequestShare(request) => {
                            let result = self.rand_store.lock().get_self_share(request.rand_metadata());
                            match result {
                                Ok(maybe_share) => {
                                    let share = maybe_share.unwrap_or_else(|| {
                                        // reproduce previous share if not found
                                        let share = S::generate(&self.config, request.rand_metadata().clone());
                                        self.rand_store.lock().add_share(share.clone(), PathType::Slow).expect("Add self share should succeed");
                                        share
                                    });
                                    self.process_response(protocol, response_sender, RandMessage::Share(share));
                                },
                                Err(e) => {
                                    warn!("[RandManager] Failed to get share: {}", e);
                                }
                            }
```

**File:** consensus/src/rand/rand_gen/rand_store.rs (L285-288)
```rust
        ensure!(
            share.metadata().round <= self.highest_known_round + FUTURE_ROUNDS_TO_ACCEPT,
            "Share from future round"
        );
```

**File:** consensus/src/rand/rand_gen/types.rs (L26-26)
```rust
pub const FUTURE_ROUNDS_TO_ACCEPT: u64 = 200;
```

**File:** consensus/src/rand/rand_gen/network_messages.rs (L43-45)
```rust
        ensure!(self.epoch() == epoch_state.epoch);
        match self {
            RandMessage::RequestShare(_) => Ok(()),
```
