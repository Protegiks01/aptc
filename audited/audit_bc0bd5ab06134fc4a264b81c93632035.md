# Audit Report

## Title
OptQuorumStore Exclude Authors Bypass - Byzantine Leader Can Ignore Validator Exclusion Mechanism

## Summary
Byzantine leaders can bypass the `exclude_authors` exclusion mechanism when creating OptQuorumStore proposals, allowing them to include batches from validators that should be excluded due to past failures. The proposal verification process does not validate that the leader respected the `exclude_authors` constraint, enabling protocol violations and potential performance degradation.

## Finding Description

The OptQuorumStore (OptQS) protocol includes an exclusion mechanism to avoid including batches from validators who have recently caused payload availability failures. This mechanism works through the `exclude_authors` HashSet in `OptQSPayloadPullParams`. [1](#0-0) 

The exclusion set is populated by tracking `PayloadUnavailable` timeout failures through `ExponentialWindowFailureTracker`: [2](#0-1) 

When an honest leader creates an OptQS proposal, they retrieve the exclusion parameters and use them to filter batches: [3](#0-2) 

The `exclude_authors` set is then passed to the quorum store to filter which validators' batches are included: [4](#0-3) 

The filtering occurs in `pull_batches_internal`: [5](#0-4) 

**The Critical Flaw:** When validators receive and verify an OptQS proposal, the verification only checks that batch authors are valid validators, but does NOT verify that the proposal respected the `exclude_authors` constraint: [6](#0-5) 

This verification is called during OptProposalMsg verification: [7](#0-6) [8](#0-7) 

**Attack Scenario:**
1. Byzantine validator V_B has been causing problems (slow responses, intermittent failures)
2. Honest validators track this and include V_B in their local `exclude_authors` sets
3. V_B (or a colluding validator) becomes the leader for round R
4. When creating the OptQS proposal, V_B ignores its own failure tracker and includes batches from problematic validators (including itself)
5. Honest validators receive the proposal and verify it via `OptProposalMsg.verify()`
6. Verification only checks that authors are valid validators - passes âœ“
7. No check that the leader respected `exclude_authors` constraint
8. Proposal is accepted and problematic batches are executed

Additionally, the `exclude_authors` mechanism has a fundamental limitation: it only tracks validators with **availability** failures (`PayloadUnavailable`), not validators with **validity** issues. A Byzantine validator can provide batches that are available but contain resource-intensive or problematic transactions: [9](#0-8) 

If batches exist in storage, no `missing_authors` are tracked, and the validator won't be excluded.

## Impact Explanation

This vulnerability has **HIGH** severity impact:

1. **Validator Node Slowdowns**: Byzantine leaders can include batches with resource-intensive transactions, causing performance degradation across all validators executing the block

2. **Significant Protocol Violations**: The OptQS exclusion mechanism is designed as a critical defense against problematic validators. Bypassing it undermines the protocol's fault tolerance guarantees

3. **Resource Exhaustion**: Malicious batches can waste computational resources, network bandwidth, and execution time

4. **Potential Liveness Issues**: If problematic batches consistently cause failures or delays, they could impact the network's ability to make progress

While this doesn't directly break consensus safety (execution remains deterministic), it violates the protocol's intended defense mechanisms and enables Byzantine validators to degrade network performance even when honest validators have identified them as problematic.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

Required conditions:
- Byzantine validator (or colluding validator) must become leader (happens naturally through leader election rotation)
- Byzantine validator has been tracked as problematic by honest validators
- Byzantine validator has available batches to include

The attack is straightforward to execute once a Byzantine validator becomes leader. Given Aptos' rotating leader election, Byzantine validators will periodically have the opportunity to propose blocks. The lack of verification makes exploitation trivial for any Byzantine leader.

## Recommendation

Implement consensus-level enforcement of the `exclude_authors` constraint during proposal verification. Two approaches:

**Approach 1: Strict Verification (Recommended)**
Add verification in `OptProposalMsg::verify()` that checks opt_batches don't include excluded authors. However, this requires each validator to compute their own `exclude_authors` set and verify consistency, which adds complexity.

**Approach 2: Include Exclusion Set in Proposal**
Include the `exclude_authors` set (or a commitment to it) in the OptBlockData, and verify during proposal validation. This makes the exclusion constraint part of the consensus:

```rust
// In OptBlockData
pub struct OptBlockData {
    // ... existing fields ...
    excluded_authors: HashSet<Author>, // Add this field
}

// In verify_opt_batches
pub fn verify_opt_batches<T: TBatchInfo>(
    verifier: &ValidatorVerifier,
    opt_batches: &OptBatches<T>,
    excluded_authors: &HashSet<Author>, // Add parameter
) -> anyhow::Result<()> {
    let authors = verifier.address_to_validator_index();
    for batch in &opt_batches.batch_summary {
        ensure!(
            authors.contains_key(&batch.author()),
            "Invalid author {} for batch {}",
            batch.author(),
            batch.digest()
        );
        // Add exclusion check
        ensure!(
            !excluded_authors.contains(&batch.author()),
            "Batch author {} is in excluded set for batch {}",
            batch.author(),
            batch.digest()
        );
    }
    Ok(())
}
```

**Approach 3: Enhanced Failure Tracking**
Extend `ExponentialWindowFailureTracker` to track not just availability failures but also validity/execution failures, providing more comprehensive exclusion criteria.

## Proof of Concept

```rust
// Test case demonstrating the bypass
#[test]
fn test_byzantine_leader_bypasses_exclude_authors() {
    use aptos_types::validator_verifier::random_validator_verifier;
    use consensus_types::payload_pull_params::{OptQSPayloadPullParams};
    use std::collections::HashSet;
    
    // Setup: 4 validators, validator_0 is Byzantine
    let (signers, verifier) = random_validator_verifier(4, None, false);
    let byzantine_validator = signers[0].author();
    let ordered_authors: Vec<_> = verifier.get_ordered_account_addresses();
    
    // Honest validators track Byzantine validator as problematic
    let mut exclude_authors = HashSet::new();
    exclude_authors.insert(byzantine_validator);
    
    // Create OptQS params that should exclude Byzantine validator
    let honest_params = OptQSPayloadPullParams {
        exclude_authors: exclude_authors.clone(),
        minimum_batch_age_usecs: 0,
    };
    
    // Byzantine leader becomes proposer
    // When creating proposal, Byzantine leader ignores exclude_authors
    let byzantine_params = OptQSPayloadPullParams {
        exclude_authors: HashSet::new(), // BYPASS: Empty set
        minimum_batch_age_usecs: 0,
    };
    
    // Byzantine leader creates OptQS proposal with batches from Byzantine validator
    // These batches pass verification because:
    // 1. verify_opt_batches only checks author is valid validator
    // 2. No check that proposal respected exclude_authors constraint
    
    // Honest validators receive and verify proposal
    // Verification succeeds even though Byzantine batches should be excluded
    // This demonstrates the bypass vulnerability
    
    assert!(byzantine_params.exclude_authors.is_empty());
    assert!(!honest_params.exclude_authors.is_empty());
    // Byzantine leader can create proposal violating honest validators' exclusion intent
}
```

## Notes

**Two distinct issues identified:**

1. **Enforcement Gap**: No verification that proposals respect `exclude_authors` during validation - allows Byzantine leaders to bypass the exclusion mechanism

2. **Tracking Limitation**: `exclude_authors` only tracks availability failures, not validity failures - Byzantine validators can provide available but malicious batches that won't trigger exclusion

The first issue (enforcement gap) is the primary vulnerability. The second issue (tracking limitation) may be a design choice but compounds the problem by allowing Byzantine validators to avoid exclusion even when causing problems.

### Citations

**File:** consensus/consensus-types/src/payload_pull_params.rs (L10-14)
```rust
#[derive(Clone)]
pub struct OptQSPayloadPullParams {
    pub exclude_authors: HashSet<Author>,
    pub minimum_batch_age_usecs: u64,
}
```

**File:** consensus/src/liveness/proposal_status_tracker.rs (L80-98)
```rust
    fn get_exclude_authors(&self) -> HashSet<Author> {
        let mut exclude_authors = HashSet::new();

        let limit = self.window;
        for round_reason in self.past_round_statuses.iter().rev().take(limit) {
            if let NewRoundReason::Timeout(RoundTimeoutReason::PayloadUnavailable {
                missing_authors,
            }) = round_reason
            {
                for author_idx in missing_authors.iter_ones() {
                    if let Some(author) = self.ordered_authors.get(author_idx) {
                        exclude_authors.insert(*author);
                    }
                }
            }
        }

        exclude_authors
    }
```

**File:** consensus/src/liveness/proposal_generator.rs (L501-501)
```rust
        let maybe_optqs_payload_pull_params = self.opt_qs_payload_param_provider.get_params();
```

**File:** consensus/src/quorum_store/proof_manager.rs (L131-148)
```rust
            if let Some(ref params) = request.maybe_optqs_payload_pull_params {
                let max_opt_batch_txns_size = request.max_txns - txns_with_proof_size;
                let max_opt_batch_txns_after_filtering = request.max_txns_after_filtering - cur_unique_txns;
                let (opt_batches, opt_payload_size, _) =
                    self.batch_proof_queue.pull_batches(
                        &excluded_batches
                            .iter()
                            .cloned()
                            .chain(proof_block.iter().map(|proof| proof.info().clone()))
                            .collect(),
                        &params.exclude_authors,
                        max_opt_batch_txns_size,
                        max_opt_batch_txns_after_filtering,
                        request.soft_max_txns_after_filtering,
                        request.return_non_full,
                        request.block_timestamp,
                        Some(params.minimum_batch_age_usecs),
                    );
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L596-600)
```rust
        for (_, batches) in self
            .author_to_batches
            .iter()
            .filter(|(author, _)| !exclude_authors.contains(author))
        {
```

**File:** consensus/consensus-types/src/common.rs (L558-572)
```rust
    pub fn verify_opt_batches<T: TBatchInfo>(
        verifier: &ValidatorVerifier,
        opt_batches: &OptBatches<T>,
    ) -> anyhow::Result<()> {
        let authors = verifier.address_to_validator_index();
        for batch in &opt_batches.batch_summary {
            ensure!(
                authors.contains_key(&batch.author()),
                "Invalid author {} for batch {}",
                batch.author(),
                batch.digest()
            );
        }
        Ok(())
    }
```

**File:** consensus/consensus-types/src/opt_proposal_msg.rs (L96-123)
```rust
    pub fn verify(
        &self,
        sender: Author,
        validator: &ValidatorVerifier,
        proof_cache: &ProofCache,
        quorum_store_enabled: bool,
    ) -> Result<()> {
        ensure!(
            self.proposer() == sender,
            "OptProposal author {:?} doesn't match sender {:?}",
            self.proposer(),
            sender
        );

        let (payload_verify_result, qc_verify_result) = rayon::join(
            || {
                self.block_data()
                    .payload()
                    .verify(validator, proof_cache, quorum_store_enabled)
            },
            || self.block_data().grandparent_qc().verify(validator),
        );
        payload_verify_result?;
        qc_verify_result?;

        // Note that we postpone the verification of SyncInfo until it's being used.
        self.verify_well_formed()
    }
```

**File:** consensus/src/round_manager.rs (L129-136)
```rust
            UnverifiedEvent::OptProposalMsg(p) => {
                if !self_message {
                    p.verify(peer_id, validator, proof_cache, quorum_store_enabled)?;
                    counters::VERIFY_MSG
                        .with_label_values(&["opt_proposal"])
                        .observe(start_time.elapsed().as_secs_f64());
                }
                VerifiedEvent::OptProposalMsg(p)
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L409-424)
```rust
            Payload::OptQuorumStore(OptQuorumStorePayload::V1(p)) => {
                let mut missing_authors = BitVec::with_num_bits(self.ordered_authors.len() as u16);
                for batch in p.opt_batches().deref() {
                    if self.batch_reader.exists(batch.digest()).is_none() {
                        let index = *self
                            .address_to_validator_index
                            .get(&batch.author())
                            .expect("Payload author should have been verified");
                        missing_authors.set(index as u16);
                    }
                }
                if missing_authors.all_zeros() {
                    Ok(())
                } else {
                    Err(missing_authors)
                }
```
