# Audit Report

## Title
Trusted Waypoint Verification Silently Skipped When Target Version Precedes Waypoint Version

## Summary
The epoch ending restore process contains a critical vulnerability where trusted waypoints are silently skipped from verification if `target_version` is set to a value less than the waypoint's version. This bypasses a fundamental security control, allowing restoration from potentially malicious backups without the expected cryptographic verification.

## Finding Description

**Vulnerability Location:** [1](#0-0) 

**Root Cause:**

The `EpochEndingRestoreController::preheat_impl()` method processes ledger infos sequentially in a loop. The critical flaw occurs in the ordering of two checks:

1. **Version filtering** (lines 108-111): When a ledger info's version exceeds `target_version`, the loop immediately breaks via `break` statement
2. **Waypoint verification** (lines 129-135): Trusted waypoint verification happens AFTER the version check in the same loop iteration

This ordering creates a bypass: if a trusted waypoint exists at version V and `target_version` is set to V-1, when the loop encounters the ledger info at version V:
- The condition `li.ledger_info().version() > self.target_version` evaluates to true (V > V-1)
- The `break` statement executes immediately
- Waypoint verification code is never reached
- The restore operation completes successfully without any error or warning

**No Upfront Validation:**

The configuration validation in `GlobalRestoreOpt::try_from()` does not check for this mismatch: [2](#0-1) 

The `TrustedWaypointOpt::verify()` method only checks for duplicate waypoints, not version compatibility: [3](#0-2) 

**Security Invariant Violation:**

Waypoints serve as cryptographic trust anchors that verify the integrity of specific ledger states: [4](#0-3) 

When a user explicitly provides a trusted waypoint via `--trust-waypoint`, they expect it to be verified. The silent skip violates this trust assumption and the documented security model. The code even contains a comment acknowledging waypoint verification should occur during preheat: [5](#0-4) 

**Attack Scenario:**

1. Attacker provides a malicious backup containing corrupted state at version 1000
2. User configures restore with:
   - `--trust-waypoint <waypoint_at_version_1000>` (to verify integrity)
   - `--target-version 999` (to restore up to version 999)
3. The restore processes ledger infos up to version 999, then encounters version 1000
4. Instead of verifying the waypoint at version 1000, the code breaks out of the loop
5. Restore completes successfully with corrupted state at version 999
6. Node starts with invalid state, potentially causing consensus divergence

## Impact Explanation

**Severity: CRITICAL**

This vulnerability meets multiple Critical severity criteria from the Aptos bug bounty:

1. **Consensus/Safety Violations**: If multiple nodes restore with different waypoint configurations (some with mismatched versions, some without), they could end up with divergent state. This violates the fundamental consensus safety invariant that all honest nodes must agree on the ledger state.

2. **State Consistency Violation**: The vulnerability allows bypassing verification of state integrity at specific versions, violating the invariant that "state transitions must be atomic and verifiable via Merkle proofs." Waypoints are explicitly designed to provide off-chain verification of on-chain state.

3. **Non-recoverable State Corruption**: If a node restores from a malicious backup with skipped waypoint verification, it may require manual intervention or a hardfork to recover, especially if the corrupted state affects validator set transitions or governance operations.

4. **Trust Anchor Bypass**: Waypoints are fundamental security primitives in Aptos. Their silent bypass represents a complete failure of a critical security control, similar in severity to signature verification bypasses.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

This vulnerability has high likelihood of occurrence due to:

1. **Legitimate Use Cases**: Users commonly provide waypoints when restoring to specific versions. The scenario where `target_version < waypoint_version` can occur naturally when:
   - User wants to restore to version N but provides a waypoint at version N+100 for future verification
   - User copies waypoint configurations without adjusting target_version
   - Automated restore scripts use outdated target_version values

2. **No Warning or Error**: The operation completes silently without any indication that a trusted waypoint was ignored, giving users false confidence in their restore operation.

3. **No Test Coverage**: The test suite does not cover this scenario, indicating this edge case was not considered during development: [6](#0-5) 

4. **Production Tool**: This affects `aptos-db-tool restore`, a production tool used for disaster recovery and node bootstrapping.

## Recommendation

**Immediate Fix:** Add validation during `GlobalRestoreOpt` to `GlobalRestoreOptions` conversion to detect and reject configurations where any trusted waypoint version exceeds target_version:

```rust
impl TryFrom<GlobalRestoreOpt> for GlobalRestoreOptions {
    type Error = anyhow::Error;

    fn try_from(opt: GlobalRestoreOpt) -> anyhow::Result<Self> {
        let target_version = opt.target_version.unwrap_or(Version::MAX);
        let trusted_waypoints = opt.trusted_waypoints.verify()?;
        
        // NEW: Validate waypoint versions don't exceed target_version
        for (wp_version, waypoint) in &trusted_waypoints {
            if *wp_version > target_version {
                return Err(anyhow::anyhow!(
                    "Trusted waypoint at version {} exceeds target version {}. \
                    All trusted waypoints must be at or before the target version. \
                    Waypoint: {}",
                    wp_version,
                    target_version,
                    waypoint
                ));
            }
        }
        
        // ... rest of conversion logic
    }
}
```

**Alternative Approaches:**

1. **Verify After Target**: Modify the loop to verify waypoints even for ledger infos beyond target_version before breaking
2. **Warning Mode**: Allow the mismatch but emit a prominent warning log that waypoints were not verified
3. **Strict Mode Flag**: Add `--strict-waypoint-verification` flag to control behavior

**Recommended Approach**: The immediate fix (rejecting mismatched configurations) is safest as it enforces the security invariant that all provided waypoints must be verified.

## Proof of Concept

**Reproduction Steps:**

1. Create a backup with epoch ending ledger infos at versions 100, 200, 300, 400, 500
2. Generate waypoint at version 500
3. Execute restore command:

```bash
aptos-db-tool restore oneoff epoch-ending \
  --epoch-ending-manifest backup/epoch_ending_manifest.json \
  --local-fs-dir backup/ \
  --target-db-dir restore_db/ \
  --target-version 400 \
  --trust-waypoint "500:0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
```

**Expected Behavior:** Restore should fail with error: "Trusted waypoint at version 500 exceeds target version 400"

**Actual Behavior:** 
- Restore completes successfully
- Waypoint at version 500 is never verified
- No error or warning is emitted
- Database contains ledger infos up to version 400 without waypoint verification

**Verification:**

Add debug logging in `preheat_impl()` to confirm waypoint verification is skipped:

```rust
for li in lis {
    if li.ledger_info().version() > self.target_version {
        info!("Breaking at version {} (target: {})", 
              li.ledger_info().version(), self.target_version);
        past_target = true;
        break;
    }
    
    // ... existing code ...
    
    if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
        info!("Verifying waypoint at version {}", wp_li.version());
        ensure!(*wp_trusted == wp_li, ...);
    }
}
```

Running the PoC shows "Breaking at version 500" log but no "Verifying waypoint" log, confirming the bypass.

**Notes**

The vulnerability's severity is amplified by the fact that waypoint verification is a cornerstone of Aptos's state sync security model. The documentation explicitly states waypoints provide "an off-chain mechanism to verify the sync process," making their silent bypass a fundamental security failure rather than a minor edge case. This issue requires immediate patching before any production restore operations.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L107-147)
```rust
            for li in lis {
                if li.ledger_info().version() > self.target_version {
                    past_target = true;
                    break;
                }

                ensure!(
                    li.ledger_info().epoch() == next_epoch,
                    "LedgerInfo epoch not expected. Expected: {}, actual: {}.",
                    li.ledger_info().epoch(),
                    next_epoch,
                );
                let wp_manifest = waypoint_iter.next().ok_or_else(|| {
                    anyhow!("More LedgerInfo's found than waypoints in manifest.")
                })?;
                let wp_li = Waypoint::new_epoch_boundary(li.ledger_info())?;
                ensure!(
                    *wp_manifest == wp_li,
                    "Waypoints don't match. In manifest: {}, In chunk: {}",
                    wp_manifest,
                    wp_li,
                );
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
                }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L226-239)
```rust
            // Waypoint has been verified in preheat if it's trusted, otherwise try to check
            // the signatures.
            if self
                .controller
                .trusted_waypoints
                .get(&first_li.ledger_info().version())
                .is_none()
            {
                li.next_epoch_state()
                    .ok_or_else(|| {
                        anyhow!("Previous epoch ending LedgerInfo doesn't end an epoch")
                    })?
                    .verify(first_li)?;
            }
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L290-329)
```rust
impl TryFrom<GlobalRestoreOpt> for GlobalRestoreOptions {
    type Error = anyhow::Error;

    fn try_from(opt: GlobalRestoreOpt) -> anyhow::Result<Self> {
        let target_version = opt.target_version.unwrap_or(Version::MAX);
        let concurrent_downloads = opt.concurrent_downloads.get();
        let replay_concurrency_level = opt.replay_concurrency_level.get();
        let run_mode = if let Some(db_dir) = &opt.db_dir {
            // for restore, we can always start state store with empty buffered_state since we will restore
            // TODO(grao): Support path override here.
            let internal_indexer_db = if opt.enable_state_indices {
                InternalIndexerDBService::get_indexer_db_for_restore(db_dir.as_path())
            } else {
                None
            };
            let restore_handler = Arc::new(AptosDB::open_kv_only(
                StorageDirPaths::from_path(db_dir),
                false,                       /* read_only */
                NO_OP_STORAGE_PRUNER_CONFIG, /* pruner config */
                opt.rocksdb_opt.clone().into(),
                false, /* indexer */
                BUFFERED_STATE_TARGET_ITEMS,
                DEFAULT_MAX_NUM_NODES_PER_LRU_CACHE_SHARD,
                internal_indexer_db,
            )?)
            .get_restore_handler();

            RestoreRunMode::Restore { restore_handler }
        } else {
            RestoreRunMode::Verify
        };
        Ok(Self {
            target_version,
            trusted_waypoints: Arc::new(opt.trusted_waypoints.verify()?),
            run_mode: Arc::new(run_mode),
            concurrent_downloads,
            replay_concurrency_level,
        })
    }
}
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L348-363)
```rust
impl TrustedWaypointOpt {
    pub fn verify(self) -> Result<HashMap<Version, Waypoint>> {
        let mut trusted_waypoints = HashMap::new();
        for w in self.trust_waypoint {
            trusted_waypoints
                .insert(w.version(), w)
                .map_or(Ok(()), |w| {
                    Err(AptosDbError::Other(format!(
                        "Duplicated waypoints at version {}",
                        w.version()
                    )))
                })?;
        }
        Ok(trusted_waypoints)
    }
}
```

**File:** types/src/waypoint.rs (L24-35)
```rust
/// Waypoint keeps information about the LedgerInfo on a given version, which provides an
/// off-chain mechanism to verify the sync process right after the restart.
/// At high level, a trusted waypoint verifies the LedgerInfo for a certain epoch change.
/// For more information, please refer to the Waypoints documentation.
#[derive(Clone, Copy, Debug, Default, Eq, PartialEq)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct Waypoint {
    /// The version of the reconfiguration transaction that is being approved by this waypoint.
    version: Version,
    /// The hash of the chosen fields of LedgerInfo.
    value: HashValue,
}
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/tests.rs (L178-261)
```rust
async fn test_trusted_waypoints_impl(
    lis: Vec<LedgerInfoWithSignatures>,
    trusted_waypoints: Vec<Waypoint>,
    should_fail_without: bool,
) {
    let backup_dir = TempPath::new();
    backup_dir.create_as_dir().unwrap();
    let store: Arc<dyn BackupStorage> = Arc::new(LocalFs::new(backup_dir.path().to_path_buf()));
    let port = mock_backup_service_get_epoch_ending_lis(lis.clone()).await;
    let client = Arc::new(BackupServiceClient::new(format!(
        "http://localhost:{}",
        port
    )));

    let mut manifests = Vec::new();
    let mut start = 0;
    while start < lis.len() {
        let m = EpochEndingBackupController::new(
            EpochEndingBackupOpt {
                start_epoch: start as u64,
                end_epoch: std::cmp::min(start + 2, lis.len()) as u64,
            },
            GlobalBackupOpt {
                max_chunk_size: 1024,
                concurrent_data_requests: 2,
            },
            client.clone(),
            Arc::clone(&store),
        )
        .run()
        .await
        .unwrap();
        manifests.push(m);
        start += 2;
    }

    let res_without_waypoints = EpochHistoryRestoreController::new(
        manifests.clone(),
        GlobalRestoreOpt {
            db_dir: None,
            dry_run: true,
            target_version: None,
            trusted_waypoints: TrustedWaypointOpt::default(),
            rocksdb_opt: RocksdbOpt::default(),
            concurrent_downloads: ConcurrentDownloadsOpt::default(),
            replay_concurrency_level: ReplayConcurrencyLevelOpt::default(),
            enable_state_indices: false,
        }
        .try_into()
        .unwrap(),
        Arc::clone(&store),
    )
    .run()
    .await;
    assert_eq!(should_fail_without, res_without_waypoints.is_err());

    let restored = EpochHistoryRestoreController::new(
        manifests,
        GlobalRestoreOpt {
            db_dir: None,
            dry_run: true,
            target_version: None,
            trusted_waypoints: TrustedWaypointOpt {
                trust_waypoint: trusted_waypoints,
            },
            rocksdb_opt: RocksdbOpt::default(),
            concurrent_downloads: ConcurrentDownloadsOpt::default(),
            replay_concurrency_level: ReplayConcurrencyLevelOpt::default(),
            enable_state_indices: false,
        }
        .try_into()
        .unwrap(),
        Arc::clone(&store),
    )
    .run()
    .await
    .unwrap();
    assert_eq!(
        lis.into_iter()
            .map(|li| li.ledger_info().clone())
            .collect::<Vec<_>>(),
        restored.epoch_endings,
    );
}
```
