# Audit Report

## Title
Resource Group Member Deletion Information Loss in API Layer

## Summary
The API conversion layer loses critical information about individual resource deletions within resource groups. When a resource group member is deleted, the API only shows the remaining resources without indicating which resources were removed, causing state tracking inconsistencies for indexers and API consumers.

## Finding Description

The vulnerability exists in the API's handling of resource group updates in the `try_access_path_into_write_set_changes()` function. The issue manifests through an asymmetric conversion pattern:

**For Resource Group Writes:** [1](#0-0) 

When a resource group is modified, the API deserializes the BCS-encoded group and creates multiple `WriteResource` entries—one for each resource currently in the group.

**For Resource Group Deletions:** [2](#0-1) 

Both complete group deletion and individual resource deletion within a group produce a single `DeleteResource` entry, making them indistinguishable.

**The Core Problem:**

During VM execution, when individual resources are deleted from a group, the VM properly tracks these as deletion operations in the `GroupWrite.inner_ops`: [3](#0-2) 

However, when serializing the group for storage, only non-deleted resources are included in the final BTreeMap: [4](#0-3) 

The serialization process (line 145: "Deletions should already be applied") means deleted resources are omitted from the serialized group bytes. When the API receives this WriteSet:

1. For a group modification, it deserializes the bytes and creates `WriteResource` entries only for resources present in the BTreeMap
2. No `DeleteResource` entries are created for resources that were removed from the group
3. The deletion information is permanently lost at the API layer

**Concrete Attack Scenario:**

1. Transaction A creates a resource group at address 0x1 containing resources {TokenA, TokenB, TokenC}
   - Indexer sees: 3 `WriteResource` entries
   - Indexer records: TokenA, TokenB, TokenC all exist

2. Transaction B deletes TokenA from the group (using `move_from<TokenA>`)
   - VM correctly processes the deletion
   - Final serialized group contains only {TokenB, TokenC}
   - API sees: `WriteResource` for TokenB and TokenC
   - API shows: NO `DeleteResource` for TokenA

3. Indexer/API consumer state:
   - Indexer database still shows TokenA as existing (never saw deletion)
   - Queries return incorrect data
   - Monitoring systems miss the deletion event
   - Audit trails are incomplete

## Impact Explanation

This issue qualifies as **Medium Severity** under the Aptos bug bounty program criteria: "State inconsistencies requiring intervention."

While the on-chain state remains correct (consensus is not affected), the API layer and indexer databases will contain incorrect state information. This breaks the critical invariant that external systems can accurately track blockchain state through the API.

**Specific Impacts:**

1. **Indexer State Corruption**: The indexer creates `MoveResource` records for writes but won't mark deleted resources as deleted: [5](#0-4) 

2. **Application Decision-Making**: Off-chain applications relying on API/indexer data for access control, financial calculations, or governance decisions will operate on stale data

3. **Security Monitoring Blindness**: Systems monitoring for malicious resource deletions will miss events when resources are in groups

4. **Audit Trail Gaps**: Complete transaction histories cannot be reconstructed from API data alone

## Likelihood Explanation

**Likelihood: High**

Resource groups are a standard feature in Aptos for organizing related resources: [6](#0-5) 

Individual resource deletion from groups is a normal operation in Move smart contracts. Any contract using resource groups and deleting members will trigger this information loss. The issue occurs automatically without requiring special conditions or attacker sophistication.

## Recommendation

The API layer should track and report individual resource deletions within resource groups. This requires either:

**Option 1: Enhanced WriteSet Representation**
Store deletion metadata in the WriteSet to preserve information about which resources were removed from groups during serialization.

**Option 2: API Layer Change Tracking**
Modify the API conversion to compare previous and current group state to detect deletions:
- Fetch previous group state from storage
- Compare with current group state
- Generate `DeleteResource` entries for missing resources
- This requires access to historical state during conversion

**Option 3: Separate Deletion Events**
Create a new `DeleteResourceGroupMember` variant in `WriteSetChange` that explicitly indicates partial group updates:
```rust
pub enum WriteSetChange {
    // ... existing variants ...
    DeleteResourceGroupMember {
        address: Address,
        state_key_hash: String,
        group: MoveStructTag,
        deleted_resource: MoveStructTag,
    }
}
```

## Proof of Concept

```move
module 0x1::resource_group_test {
    use std::signer;
    
    #[resource_group(scope = global)]
    struct MyGroup {}
    
    #[resource_group_member(group = 0x1::resource_group_test::MyGroup)]
    struct TokenA has key { value: u64 }
    
    #[resource_group_member(group = 0x1::resource_group_test::MyGroup)]
    struct TokenB has key { value: u64 }
    
    public entry fun create_group(account: &signer) {
        move_to(account, TokenA { value: 100 });
        move_to(account, TokenB { value: 200 });
    }
    
    public entry fun delete_token_a(account: &signer) acquires TokenA {
        let TokenA { value: _ } = move_from<TokenA>(signer::address_of(account));
        // After this transaction, the API will show WriteResource for TokenB
        // but NO DeleteResource for TokenA
        // Indexer will incorrectly show TokenA as still existing
    }
}
```

**Verification Steps:**
1. Execute `create_group` - observe 2 `WriteResource` entries in transaction output
2. Execute `delete_token_a` - observe only 1 `WriteResource` entry (TokenB), no `DeleteResource` for TokenA
3. Query indexer for TokenA at the address - it will incorrectly show as existing

**Notes**

The on-chain state is always correct—validators execute transactions deterministically. The vulnerability is in the observability layer where API consumers and indexers cannot accurately track resource lifecycles for resources within groups. This creates an asymmetry where resource group writes are expanded into individual resource entries, but deletions are not, leading to systematic information loss that affects all downstream systems relying on transaction history.

### Citations

**File:** api/types/src/convert.rs (L486-490)
```rust
                Path::ResourceGroup(typ) => vec![WriteSetChange::DeleteResource(DeleteResource {
                    address: access_path.address.into(),
                    state_key_hash,
                    resource: typ.into(),
                })],
```

**File:** api/types/src/convert.rs (L503-513)
```rust
                Path::ResourceGroup(_) => self
                    .try_into_resources_from_resource_group(bytes)?
                    .into_iter()
                    .map(|data| {
                        WriteSetChange::WriteResource(WriteResource {
                            address: access_path.address.into(),
                            state_key_hash: state_key_hash.clone(),
                            data,
                        })
                    })
                    .collect::<Vec<_>>(),
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/write_op_converter.rs (L154-221)
```rust
    pub(crate) fn convert_resource_group_v1(
        &self,
        state_key: &StateKey,
        group_changes: BTreeMap<StructTag, MoveStorageOp<BytesWithResourceLayout>>,
    ) -> PartialVMResult<GroupWrite> {
        // Resource group metadata is stored at the group StateKey, and can be obtained via the
        // same interfaces at for a resource at a given StateKey.
        let state_value_metadata = self
            .remote
            .as_executor_view()
            .get_resource_state_value_metadata(state_key)?;
        // Currently, due to read-before-write and a gas charge on the first read that is based
        // on the group size, this should simply re-read a cached (speculative) group size.
        let pre_group_size = self.remote.resource_group_size(state_key)?;
        check_size_and_existence_match(&pre_group_size, state_value_metadata.is_some(), state_key)?;

        let mut inner_ops = BTreeMap::new();
        let mut post_group_size = pre_group_size;

        for (tag, current_op) in group_changes {
            // We take speculative group size prior to the transaction, and update it based on the change-set.
            // For each tagged resource in the change set, we subtract the previous size tagged resource size,
            // and then add new tagged resource size.
            //
            // The reason we do not instead get and add the sizes of the resources in the group,
            // but not in the change-set, is to avoid creating unnecessary R/W conflicts (the resources
            // in the change-set are already read, but the other resources are not).
            if !matches!(current_op, MoveStorageOp::New(_)) {
                let old_tagged_value_size = self.remote.resource_size_in_group(state_key, &tag)?;
                let old_size = group_tagged_resource_size(&tag, old_tagged_value_size)?;
                decrement_size_for_remove_tag(&mut post_group_size, old_size)?;
            }

            match &current_op {
                MoveStorageOp::Modify((data, _)) | MoveStorageOp::New((data, _)) => {
                    let new_size = group_tagged_resource_size(&tag, data.len())?;
                    increment_size_for_add_tag(&mut post_group_size, new_size)?;
                },
                MoveStorageOp::Delete => {},
            };

            let legacy_op = match current_op {
                MoveStorageOp::Delete => (WriteOp::legacy_deletion(), None),
                MoveStorageOp::Modify((data, maybe_layout)) => {
                    (WriteOp::legacy_modification(data), maybe_layout)
                },
                MoveStorageOp::New((data, maybe_layout)) => {
                    (WriteOp::legacy_creation(data), maybe_layout)
                },
            };
            inner_ops.insert(tag, legacy_op);
        }

        // Create an op to encode the proper kind for resource group operation.
        let metadata_op = if post_group_size.get() == 0 {
            MoveStorageOp::Delete
        } else if pre_group_size.get() == 0 {
            MoveStorageOp::New(Bytes::new())
        } else {
            MoveStorageOp::Modify(Bytes::new())
        };
        Ok(GroupWrite::new(
            self.convert(state_value_metadata, metadata_op, false)?,
            inner_ops,
            post_group_size,
            pre_group_size.get(),
        ))
    }
```

**File:** aptos-move/block-executor/src/executor_utilities.rs (L139-148)
```rust
            |(group_key, mut metadata_op, finalized_group, group_size)| {
                let btree: BTreeMap<T::Tag, Bytes> = finalized_group
                    .into_iter()
                    .map(|(resource_tag, arc_v)| {
                        let bytes = arc_v
                            .extract_raw_bytes()
                            .expect("Deletions should already be applied");
                        (resource_tag, bytes)
                    })
                    .collect();
```

**File:** crates/indexer/src/models/move_resources.rs (L58-78)
```rust
    pub fn from_delete_resource(
        delete_resource: &DeleteResource,
        write_set_change_index: i64,
        transaction_version: i64,
        transaction_block_height: i64,
    ) -> Self {
        let parsed_data = Self::convert_move_struct_tag(&delete_resource.resource);
        Self {
            transaction_version,
            transaction_block_height,
            write_set_change_index,
            type_: delete_resource.resource.to_string(),
            name: parsed_data.name.clone(),
            address: standardize_address(&delete_resource.address.to_string()),
            module: parsed_data.module.clone(),
            generic_type_params: parsed_data.generic_type_params,
            data: None,
            is_deleted: true,
            state_key_hash: standardize_address(delete_resource.state_key_hash.as_str()),
        }
    }
```

**File:** types/src/access_path.rs (L76-82)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Hash, Serialize, Deserialize, Ord, PartialOrd)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub enum Path {
    Code(ModuleId),
    Resource(StructTag),
    ResourceGroup(StructTag),
}
```
