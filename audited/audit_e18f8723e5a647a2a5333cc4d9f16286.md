# Audit Report

## Title
IP Address Spoofing in Faucet Bypasser Allows Complete Bypass of IP-Based Access Controls

## Summary
The Aptos Faucet's `IpAllowlistBypasser` is vulnerable to IP address spoofing. Attackers can bypass IP-based security controls by manipulating `X-Forwarded-For` or `X-Real-IP` HTTP headers, allowing them to circumvent rate limiting, gain unauthorized privileged access, and potentially drain faucet funds.

## Finding Description

The faucet service uses the poem framework's `RealIp` extractor to determine the client's source IP address. [1](#0-0) 

The code explicitly documents that `RealIp` processes headers like `X-Forwarded-For` and `X-Real-IP`. [2](#0-1) 

During request preprocessing, the IP address is extracted from `RealIp` and stored in `CheckerData`: [3](#0-2) 

The `IpAllowlistBypasser` then uses this `source_ip` to determine if the request should bypass all security checks: [4](#0-3) 

**The Critical Flaw**: The codebase contains NO configuration for trusted proxy IP addresses. A `grep` search for proxy configuration terms returns zero results, confirming the absence of any mechanism to validate that `X-Forwarded-For` or `X-Real-IP` headers originate from a trusted source.

**Attack Scenario**:
1. Faucet is configured with IP allowlist `10.0.0.0/8` to bypass rate limits for internal infrastructure
2. Attacker sends request with header: `X-Forwarded-For: 10.0.0.1`
3. poem's `RealIp` extracts `10.0.0.1` as the source IP (trusting the attacker-controlled header)
4. `CheckerData` is created with `source_ip = 10.0.0.1`
5. `IpAllowlistBypasser` checks if `10.0.0.1` is in allowlist â†’ returns `true`
6. Request bypasses ALL checkers and storage limitations
7. Attacker gains unlimited access, circumventing rate limits, IP blocklists, and other security controls

This breaks the **Access Control** invariant: IP-based security controls must correctly identify the true client source address to enforce intended restrictions.

## Impact Explanation

**Critical Severity** - This vulnerability enables multiple high-impact attack vectors:

1. **Complete Bypass of Rate Limiting**: Attackers can make unlimited faucet requests by spoofing allowlisted IPs, potentially draining all faucet funds. [5](#0-4) 

2. **Bypass of IP Blocklists**: Attackers on blocklisted IPs can spoof clean IPs to evade blocking mechanisms. The IP blocklist checker also relies on the same `source_ip` from `CheckerData`. [6](#0-5) 

3. **Privileged Access Exploitation**: If the allowlist grants higher funding limits via `maximum_amount_with_bypass`, attackers can request and receive larger amounts per transaction.

Per Aptos Bug Bounty criteria, this qualifies as **Critical** because it enables:
- **Loss of Funds**: Unlimited faucet draining through bypass of all rate limiting
- **Complete Access Control Bypass**: Total circumvention of IP-based security mechanisms

## Likelihood Explanation

**Likelihood: Very High**

1. **Trivial Exploitation**: The attack requires only adding a single HTTP header - no special tools, credentials, or technical expertise needed
2. **Zero Detection**: Without proper logging of header vs actual IP discrepancies, attacks are invisible
3. **Common Deployment Pattern**: Faucets are often deployed behind load balancers/proxies but without proper trusted proxy configuration
4. **Universal Applicability**: Every IP-based control (allowlist, blocklist, rate limiting) is compromised

The vulnerability is exploitable whenever:
- The faucet is exposed to the internet (not just internal networks)
- Any IP-based bypasser or checker is enabled
- No separate reverse proxy with IP validation is in place

## Recommendation

Implement trusted proxy configuration with strict validation:

```rust
// Add to ServerConfig
pub struct ServerConfig {
    pub listen_address: String,
    pub listen_port: u16,
    pub api_path_base: String,
    pub trusted_proxies: Option<Vec<IpAddr>>, // NEW: List of trusted proxy IPs
}

// In fund.rs, replace direct RealIp usage
fn extract_real_ip(
    remote_addr: SocketAddr,
    headers: &HeaderMap,
    trusted_proxies: &Option<Vec<IpAddr>>,
) -> IpAddr {
    // If no trusted proxies configured, use remote_addr only
    let Some(trusted) = trusted_proxies else {
        return remote_addr.ip();
    };
    
    // Only trust X-Forwarded-For if request comes from trusted proxy
    if !trusted.contains(&remote_addr.ip()) {
        return remote_addr.ip();
    }
    
    // Parse X-Forwarded-For, taking leftmost (client) IP
    if let Some(forwarded) = headers.get("X-Forwarded-For") {
        if let Ok(forwarded_str) = forwarded.to_str() {
            if let Some(client_ip) = forwarded_str.split(',').next() {
                if let Ok(ip) = client_ip.trim().parse::<IpAddr>() {
                    return ip;
                }
            }
        }
    }
    
    // Fallback to remote address
    remote_addr.ip()
}
```

**Alternative Solutions**:
1. Deploy faucet only behind HAProxy/nginx with proper IP forwarding validation
2. Use application-layer authentication instead of IP allowlisting
3. Implement mutual TLS for privileged access instead of IP-based controls

## Proof of Concept

```bash
# Assume faucet has IP allowlist with 10.0.0.0/8 configured
# Normal request from attacker IP 1.2.3.4 would be rate-limited

# Attack: Spoof IP to bypass rate limits
curl -X POST http://faucet.example.com/fund \
  -H "Content-Type: application/json" \
  -H "X-Forwarded-For: 10.0.0.1" \
  -d '{"address": "0x1234....", "amount": 100000000000}'

# Expected: Request bypasses all checkers due to spoofed allowlisted IP
# Actual behavior: CheckerData.source_ip = 10.0.0.1 (spoofed)
#                  IpAllowlistBypasser returns true
#                  All security checks bypassed
#                  Funds dispensed without rate limiting

# Attacker can repeat unlimited times by spoofing different allowlisted IPs
for i in {1..255}; do
  curl -X POST http://faucet.example.com/fund \
    -H "Content-Type: application/json" \
    -H "X-Forwarded-For: 10.0.0.$i" \
    -d "{\"address\": \"0xattacker$i\", \"amount\": 100000000000}"
done

# Result: Faucet drained through unlimited bypassed requests
```

**Rust Integration Test Reproduction**:
```rust
// Add to run.rs tests
#[tokio::test]
async fn test_ip_spoofing_vulnerability() -> Result<()> {
    make_ip_allowlist(&["10.0.0.0/8"])?;
    let config_content = include_str!("../../../configs/testing_bypassers.yaml");
    let (port, _handle) = start_server(config_content).await?;

    // Request should normally fail from non-allowlisted IP
    // But succeeds with spoofed X-Forwarded-For header
    let response = reqwest::Client::new()
        .post(get_fund_endpoint(port))
        .body(get_fund_request(Some(10)).to_json_string())
        .header("Content-Type", "application/json")
        .header("X-Forwarded-For", "10.0.0.1") // SPOOFED IP
        .send()
        .await?;

    // Vulnerability: Request succeeds despite coming from untrusted source
    assert_eq!(response.status(), reqwest::StatusCode::OK);
    // This should FAIL in a secure implementation
    
    Ok(())
}
```

## Notes

This vulnerability affects all deployments of the Aptos Faucet that:
1. Use `IpAllowlistBypasser` or any IP-based checker
2. Are exposed to the internet without a properly configured trusted reverse proxy
3. Rely on IP addresses for security decisions

The issue is architectural: poem's `RealIp` is designed for use behind trusted proxies, but the faucet code provides no mechanism to configure which proxies are trusted. This creates a dangerous default where all `X-Forwarded-For` headers are trusted unconditionally.

### Citations

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L102-111)
```rust
    async fn fund(
        &self,
        fund_request: Json<FundRequest>,
        asset: poem_openapi::param::Query<Option<String>>,
        // This automagically uses FromRequest to get this data from the request.
        // It takes into things like X-Forwarded-IP and X-Real-IP.
        source_ip: RealIp,
        // Same thing, this uses FromRequest.
        header_map: &HeaderMap,
    ) -> poem::Result<Json<FundResponse>, AptosTapErrorResponse> {
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L217-242)
```rust
        let source_ip = match source_ip.0 {
            Some(ip) => ip,
            None => {
                return Err(AptosTapError::new(
                    "No source IP found in the request".to_string(),
                    AptosTapErrorCode::SourceIpMissing,
                ))
            },
        };

        let receiver = match fund_request.receiver() {
            Some(receiver) => receiver,
            None => {
                return Err(AptosTapError::new(
                    "Account address, auth key, or pub key must be provided and valid".to_string(),
                    AptosTapErrorCode::InvalidRequest,
                ))
            },
        };

        let checker_data = CheckerData {
            receiver,
            source_ip,
            headers: Arc::new(header_map.clone()),
            time_request_received_secs: get_current_time_secs(),
        };
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L245-259)
```rust
        for bypasser in &self.bypassers {
            if bypasser
                .request_can_bypass(checker_data.clone())
                .await
                .map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::BypasserError)
                })?
            {
                info!(
                    "Allowing request from {} to bypass checks / storage",
                    source_ip
                );
                return Ok((checker_data, true, permit));
            }
        }
```

**File:** crates/aptos-faucet/core/src/bypasser/ip_allowlist.rs (L24-29)
```rust
#[async_trait]
impl BypasserTrait for IpAllowlistBypasser {
    async fn request_can_bypass(&self, data: CheckerData) -> Result<bool> {
        Ok(self.manager.contains_ip(&data.source_ip))
    }
}
```

**File:** crates/aptos-faucet/core/src/checkers/mod.rs (L147-153)
```rust
#[derive(Clone, Debug)]
pub struct CheckerData {
    pub time_request_received_secs: u64,
    pub receiver: AccountAddress,
    pub source_ip: IpAddr,
    pub headers: Arc<HeaderMap>,
}
```
