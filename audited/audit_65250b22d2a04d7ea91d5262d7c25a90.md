# Audit Report

## Title
Script Loading Bypasses Dependency Gas Charges Leading to Resource Undercharging

## Summary
Scripts do not pay dependency loading gas for themselves, only for their dependencies, while entry functions pay dependency gas for both their containing module and all dependencies. This inconsistency allows scripts to load for significantly less gas than equivalent entry functions, enabling resource exhaustion attacks and economic exploitation.

## Finding Description

The Move VM's eager loader treats scripts and entry functions inconsistently during the dependency gas charging phase.

**For Entry Functions**, the `load_instantiated_function` implementation charges dependency gas for the module containing the entry function itself: [1](#0-0) 

This ensures the module is charged using the formula: `DEPENDENCY_PER_MODULE + DEPENDENCY_PER_BYTE * module_size`.

**For Scripts**, the `load_script` implementation only charges for immediate dependencies, explicitly excluding the script itself as noted in the TODO comment: [2](#0-1) 

The dependency charging mechanism applies the formula per loaded module: [3](#0-2) 

With gas parameters defined as: [4](#0-3) 

**Economic Impact Calculation:**

For a maximum-sized script (64KB):
- **Unpaid dependency gas**: 74,460 + (42 Ã— 65,536) = 2,826,972 internal gas units
- This represents ~102% of `min_transaction_gas_units` (2,760,000)
- Scripts only pay intrinsic gas based on transaction size, which is much lower per byte (1,158 gas/byte after 600-byte cutoff)

**Attack Vector:**

1. Attacker submits large script transactions instead of entry function transactions
2. Scripts undergo full deserialization, verification, and loading (CPU/memory intensive)
3. Validators are compensated only via intrinsic gas, not dependency loading gas
4. At scale, this undercharges validators for their computational work
5. Can be used for resource exhaustion by repeatedly submitting large scripts

## Impact Explanation

This issue qualifies as **Medium Severity** per the Aptos bug bounty program criteria:

1. **Resource Exhaustion**: Enables attackers to undercharge for computational resources (deserialization, verification, loading) by using scripts instead of entry functions
2. **Economic Manipulation**: Creates price discrimination where identical code charges differently based on delivery mechanism
3. **Validator DoS Potential**: Large scripts can be repeatedly submitted to exhaust validator resources while paying insufficient gas compensation

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits" - scripts bypass proper gas accounting for their loading costs.

While not reaching Critical severity (no direct fund theft or consensus violation), it does represent a state inconsistency in gas accounting and enables limited resource manipulation attacks.

## Likelihood Explanation

**Likelihood: HIGH**

- **Ease of Exploitation**: Any user can submit script transactions; no special privileges required
- **Detection Difficulty**: The gas difference is subtle and may not be immediately noticed
- **Already Flagged**: The TODO comment indicates developers are aware this needs investigation
- **Configuration Enabled**: The `charge_for_dependencies` flag is enabled starting from gas feature version `RELEASE_V1_10`: [5](#0-4) 

## Recommendation

**Fix**: Include the script itself in dependency gas charging, not just its dependencies.

Modify the `load_script` implementation to charge for the script similarly to how `load_instantiated_function` charges for the containing module:

```rust
fn load_script(
    &self,
    config: &LegacyLoaderConfig,
    gas_meter: &mut impl DependencyGasMeter,
    traversal_context: &mut TraversalContext,
    serialized_script: &[u8],
    ty_args: &[TypeTag],
) -> VMResult<LoadedFunction> {
    if config.charge_for_dependencies {
        let compiled_script = self.unmetered_deserialize_and_cache_script(serialized_script)?;
        let compiled_script = traversal_context.referenced_scripts.alloc(compiled_script);

        // NEW: Charge for the script itself
        let script_size = serialized_script.len() as u64;
        gas_meter
            .charge_dependency(
                DependencyKind::Existing,
                &AccountAddress::ZERO, // Or appropriate address for scripts
                IdentStr::new("script").unwrap(),
                NumBytes::new(script_size),
            )
            .map_err(|err| err.finish(Location::Script))?;

        // Charge for dependencies
        check_dependencies_and_charge_gas(
            self.module_storage,
            gas_meter,
            traversal_context,
            compiled_script.immediate_dependencies_iter(),
        )?;
    }
    
    // ... rest of function
}
```

This ensures scripts pay the same `DEPENDENCY_PER_MODULE + DEPENDENCY_PER_BYTE * size` formula as entry function modules.

## Proof of Concept

**Test Setup**: Create two equivalent transactions - one as a script, one as an entry function - with the same bytecode size and measure gas consumption difference.

```rust
#[test]
fn test_script_vs_entry_function_gas_charging() {
    // Setup: Create a large script (e.g., 10KB of bytecode)
    let large_script_bytecode = create_large_script(10 * 1024);
    
    // Setup: Create equivalent entry function in a 10KB module
    let large_module_bytecode = create_large_module_with_entry(10 * 1024);
    
    // Test 1: Execute script transaction
    let mut script_gas_meter = StandardGasMeter::new(...);
    let script_txn = create_script_transaction(large_script_bytecode);
    execute_transaction(script_txn, &mut script_gas_meter);
    let script_gas_used = script_gas_meter.execution_gas_used();
    
    // Test 2: Execute entry function transaction
    let mut entry_gas_meter = StandardGasMeter::new(...);
    let entry_txn = create_entry_function_transaction(large_module_bytecode);
    execute_transaction(entry_txn, &mut entry_gas_meter);
    let entry_gas_used = entry_gas_meter.execution_gas_used();
    
    // Verify: Entry function should charge more due to module dependency gas
    let expected_difference = 74_460 + (42 * 10_240); // ~504K gas units
    assert!(
        entry_gas_used > script_gas_used + expected_difference * 0.9,
        "Entry function should charge significantly more than script for same code size"
    );
}
```

The test would demonstrate that scripts avoid the dependency loading gas charge that entry functions pay, confirming the vulnerability.

## Notes

This vulnerability stems from an architectural decision where scripts are treated as "transient" code that doesn't persist in storage, while modules are persistent. However, both require the same computational resources (deserialization, verification, loading) and should be charged proportionally. The TODO comment at line 337 explicitly questions this design choice, indicating it was left unresolved.

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/loader/eager.rs (L281-291)
```rust
        if config.charge_for_dependencies {
            // Charge gas for function code loading.
            let arena_id = traversal_context
                .referenced_module_ids
                .alloc(module_id.clone());
            check_dependencies_and_charge_gas(
                self.module_storage,
                gas_meter,
                traversal_context,
                [(arena_id.address(), arena_id.name())],
            )?;
```

**File:** third_party/move/move-vm/runtime/src/storage/loader/eager.rs (L333-344)
```rust
        if config.charge_for_dependencies {
            let compiled_script = self.unmetered_deserialize_and_cache_script(serialized_script)?;
            let compiled_script = traversal_context.referenced_scripts.alloc(compiled_script);

            // TODO(Gas): Should we charge dependency gas for the script itself?
            check_dependencies_and_charge_gas(
                self.module_storage,
                gas_meter,
                traversal_context,
                compiled_script.immediate_dependencies_iter(),
            )?;
        }
```

**File:** aptos-move/aptos-gas-meter/src/meter.rs (L57-76)
```rust
    fn charge_dependency(
        &mut self,
        _kind: DependencyKind,
        addr: &AccountAddress,
        _name: &IdentStr,
        size: NumBytes,
    ) -> PartialVMResult<()> {
        // Modules under special addresses are considered system modules that should always
        // be loaded, and are therefore excluded from gas charging.
        //
        // TODO: 0xA550C18 is a legacy system address we used, but it is currently not covered by
        //       `.is_special()`. We should double check if this address still needs special
        //       treatment.
        if self.feature_version() >= 15 && !addr.is_special() {
            self.algebra
                .charge_execution(DEPENDENCY_PER_MODULE + DEPENDENCY_PER_BYTE * size)?;
            self.algebra.count_dependency(size)?;
        }
        Ok(())
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L241-249)
```rust
            dependency_per_module: InternalGas,
            { RELEASE_V1_10.. => "dependency_per_module" },
            74460,
        ],
        [
            dependency_per_byte: InternalGasPerByte,
            { RELEASE_V1_10.. => "dependency_per_byte" },
            42,
        ],
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L905-908)
```rust
            let legacy_loader_config = LegacyLoaderConfig {
                charge_for_dependencies: self.gas_feature_version() >= RELEASE_V1_10,
                charge_for_ty_tag_dependencies: self.gas_feature_version() >= RELEASE_V1_27,
            };
```
