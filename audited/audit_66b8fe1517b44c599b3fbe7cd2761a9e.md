# Audit Report

## Title
Unbounded Exponential Backoff Leads to Effective Permanent Peer Banning in Storage Service Moderator

## Summary
The storage service request moderator implements an exponential backoff mechanism that doubles the ignore duration each time a peer is unblocked and subsequently misbehaves again. This backoff has no upper bound, allowing it to grow to astronomical values (years or centuries) after just 20-30 cycles, effectively creating a permanent ban for peers that repeatedly send invalid requests, even if they later become legitimate. Additionally, after approximately 63 doublings, the u64 value will overflow, causing unpredictable behavior.

## Finding Description
The `UnhealthyPeerState` struct in the storage service moderator tracks misbehaving peers and implements a time-based ignore mechanism with exponential backoff. When a peer on the public network sends too many invalid requests (controlled by `max_invalid_requests_per_peer`, default 500), they are temporarily ignored. [1](#0-0) 

After the ignore period elapses, the `refresh_peer_state()` method unblocks the peer but doubles the minimum ignore duration for the next offense: [2](#0-1) 

The critical issue is at line 90: the multiplication `self.min_time_to_ignore_secs *= 2` has **no upper bound check**. Starting from the default value of 300 seconds (5 minutes): [3](#0-2) 

The growth progression becomes:
- After 1st unblock: 600 seconds (10 minutes)
- After 10th unblock: 307,200 seconds (~3.5 days)
- After 15th unblock: 9,830,400 seconds (~113 days)
- After 20th unblock: 314,572,800 seconds (~10 years)
- After 30th unblock: 322,122,547,200 seconds (~10,211 years)
- After 63rd unblock: Integer overflow (u64::MAX exceeded)

**Attack/Bug Scenario:** A legitimate peer (PFN) experiences a software bug, misconfiguration, or state desynchronization that causes it to repeatedly send requests that fail the `can_service()` validation check: [4](#0-3) 

Each time the peer's requests fail validation, it accumulates invalid request counts. After crossing the threshold, it gets ignored. When unblocked, if the underlying issue persists (e.g., the peer's local state is still behind), it immediately accumulates invalid requests again, gets re-ignored with doubled duration, and this cycle repeats.

The moderator refresh runs periodically (default every 1 second): [5](#0-4) 

**Critical Flaw:** The only way to reset the exponentially growing backoff is for the peer to disconnect entirely, as disconnected peers are garbage collected from the unhealthy states map: [6](#0-5) 

If a peer remains connected but repeatedly triggers invalid requests due to a persistent bug or state mismatch, it will be effectively permanently banned within just 15-20 cycles.

## Impact Explanation
This vulnerability qualifies as **Medium Severity** under the Aptos bug bounty criteria for the following reasons:

1. **Availability Impact**: Legitimate peers experiencing temporary bugs or state synchronization issues can be permanently excluded from the storage service network, reducing the available peer set and potentially degrading network health.

2. **Network Partition Risk**: If multiple peers experience the same bug simultaneously (e.g., due to a software update or configuration change), they could all become permanently banned from each other, creating network partitions.

3. **State Inconsistency**: The system enters an inconsistent state where peers that should be able to reconnect and participate are effectively permanently banned without any administrative intervention capability.

4. **Integer Overflow**: After approximately 63 doublings from the initial 300 seconds, the u64 value overflows, causing wraparound behavior in release builds or panic in debug builds, leading to unpredictable system behavior.

This does not reach High or Critical severity because:
- It doesn't directly threaten consensus safety
- It doesn't enable fund theft or loss
- It affects peer connectivity rather than core blockchain operations
- It only impacts peers on public networks (not validators or VFNs)

## Likelihood Explanation
The likelihood of this issue manifesting is **Medium to High**:

**Realistic Trigger Conditions:**
1. A peer software bug causing repeated invalid requests
2. Persistent state desynchronization between peers
3. Configuration mismatches between peer versions
4. Network conditions causing state lag that repeatedly triggers `can_service()` failures

**Frequency:** Given the exponential growth rate, reaching impractical ban times (>1 year) requires only 20 cycles. If a peer experiences a persistent issue and gets unblocked/re-banned on average every few hours to days, reaching permanent ban territory could occur within weeks to months.

**Ease of Exploitation:** While not requiring active malicious intent, the conditions for triggering this are realistic in a distributed system environment where software bugs, version mismatches, and state desynchronization issues occur regularly.

## Recommendation

Implement the following safeguards to prevent unbounded backoff growth:

1. **Add Maximum Cap**: Implement a configurable maximum ignore duration (e.g., 7 days or 30 days)
2. **Add Decay Mechanism**: Reduce the backoff multiplier if a peer behaves correctly for an extended period
3. **Use Saturating Arithmetic**: Prevent integer overflow using `saturating_mul()`
4. **Add Manual Reset**: Provide an administrative mechanism to reset peer states

**Proposed Code Fix:**

```rust
// In StorageServiceConfig, add:
pub max_time_to_ignore_peers_secs: u64, // e.g., 604800 (7 days)

// In Default implementation:
max_time_to_ignore_peers_secs: 604800, // 7 days maximum

// In UnhealthyPeerState::new(), add:
max_time_to_ignore_secs: u64,

// In UnhealthyPeerState::refresh_peer_state(), replace line 90:
// Use saturating multiplication and cap at maximum
self.min_time_to_ignore_secs = self.min_time_to_ignore_secs
    .saturating_mul(2)
    .min(self.max_time_to_ignore_secs);
```

This ensures:
- Backoff cannot exceed a reasonable maximum (7 days)
- Integer overflow is prevented via `saturating_mul()`
- System behavior remains predictable and manageable

## Proof of Concept

```rust
#[cfg(test)]
mod unbounded_backoff_poc {
    use super::*;
    use aptos_types::PeerId;
    use aptos_time_service::TimeService;
    
    #[test]
    fn test_unbounded_exponential_backoff_reaches_astronomical_values() {
        // Create unhealthy peer state with default config values
        let max_invalid_requests = 500;
        let initial_min_time_to_ignore_secs = 300; // 5 minutes
        let time_service = TimeService::mock();
        let mut unhealthy_peer_state = UnhealthyPeerState::new(
            max_invalid_requests,
            initial_min_time_to_ignore_secs,
            time_service.clone(),
        );
        
        let peer_network_id = PeerNetworkId::new(NetworkId::Public, PeerId::random());
        let time_service_mock = time_service.into_mock();
        
        // Simulate 20 cycles of: ban -> wait -> unban -> re-ban
        for iteration in 0..20 {
            // Trigger ban by exceeding invalid requests
            for _ in 0..max_invalid_requests {
                unhealthy_peer_state.increment_invalid_request_count(&peer_network_id);
            }
            assert!(unhealthy_peer_state.is_ignored());
            
            let current_ignore_duration = unhealthy_peer_state.min_time_to_ignore_secs;
            println!("Iteration {}: Ignore duration = {} seconds ({} days)", 
                iteration, current_ignore_duration, current_ignore_duration / 86400);
            
            // Wait for the ignore period to elapse
            time_service_mock.advance(Duration::from_secs(current_ignore_duration));
            
            // Refresh (unban and double the duration)
            unhealthy_peer_state.refresh_peer_state(&peer_network_id);
            assert!(!unhealthy_peer_state.is_ignored());
        }
        
        // After 20 iterations, the ban time should be astronomical
        let final_duration = unhealthy_peer_state.min_time_to_ignore_secs;
        let expected_duration = initial_min_time_to_ignore_secs * 2_u64.pow(20);
        
        assert_eq!(final_duration, expected_duration);
        // 314,572,800 seconds = ~10 years
        assert_eq!(final_duration, 314_572_800);
        assert!(final_duration > 86400 * 365 * 9); // More than 9 years
        
        println!("\nFinal ban duration after 20 cycles: {} seconds", final_duration);
        println!("That's approximately {} years!", final_duration / (86400 * 365));
        println!("\nThis peer is effectively permanently banned!");
    }
    
    #[test]
    fn test_integer_overflow_at_63_iterations() {
        let initial_min_time_to_ignore_secs = 300_u64;
        
        // Simulate what happens after 63 doublings
        let mut current = initial_min_time_to_ignore_secs;
        
        for i in 0..63 {
            current = current.wrapping_mul(2);
            if i >= 60 {
                println!("Iteration {}: {}", i, current);
            }
        }
        
        // After 63 iterations, we've wrapped around due to overflow
        // The next multiplication will cause completely unpredictable behavior
        assert!(current != initial_min_time_to_ignore_secs * 2_u64.pow(63));
        println!("\nInteger overflow detected! Behavior becomes unpredictable.");
    }
}
```

**Expected Output:**
```
Iteration 0: Ignore duration = 300 seconds (0 days)
Iteration 1: Ignore duration = 600 seconds (0 days)
...
Iteration 10: Ignore duration = 307200 seconds (3 days)
Iteration 15: Ignore duration = 9830400 seconds (113 days)
Iteration 20: Ignore duration = 314572800 seconds (3641 days)

Final ban duration after 20 cycles: 314572800 seconds
That's approximately 9 years!

This peer is effectively permanently banned!
```

**Notes**

This vulnerability affects the state-sync storage service's ability to maintain a healthy peer network. While it doesn't directly compromise consensus or enable fund theft, it degrades network availability and could lead to operational issues requiring manual intervention. The lack of any upper bound on the exponential backoff, combined with no decay mechanism, creates a situation where peers can become irreversibly banned through software bugs or state inconsistencies rather than actual malicious behavior.

The fix is straightforward: add a maximum cap (using `saturating_mul()` and `min()`) to ensure the backoff never exceeds a reasonable duration like 7-30 days, and consider implementing a decay mechanism to reduce the multiplier for peers that demonstrate good behavior over time.

### Citations

**File:** state-sync/storage-service/server/src/moderator.rs (L47-69)
```rust
    /// Increments the invalid request count for the peer and marks
    /// the peer to be ignored if it has sent too many invalid requests.
    /// Note: we only ignore peers on the public network.
    pub fn increment_invalid_request_count(&mut self, peer_network_id: &PeerNetworkId) {
        // Increment the invalid request count
        self.invalid_request_count += 1;

        // If the peer is a PFN and has sent too many invalid requests, start ignoring it
        if self.ignore_start_time.is_none()
            && peer_network_id.network_id().is_public_network()
            && self.invalid_request_count >= self.max_invalid_requests
        {
            // TODO: at some point we'll want to terminate the connection entirely

            // Start ignoring the peer
            self.ignore_start_time = Some(self.time_service.now());

            // Log the fact that we're now ignoring the peer
            warn!(LogSchema::new(LogEntry::RequestModeratorIgnoredPeer)
                .peer_network_id(peer_network_id)
                .message("Ignoring peer due to too many invalid requests!"));
        }
    }
```

**File:** state-sync/storage-service/server/src/moderator.rs (L76-98)
```rust
    /// Refreshes the peer's state (if it has been ignored for long enough).
    /// Note: each time we unblock a peer, we double the min time to ignore the peer.
    /// This provides an exponential backoff for peers that are sending too many invalid requests.
    pub fn refresh_peer_state(&mut self, peer_network_id: &PeerNetworkId) {
        if let Some(ignore_start_time) = self.ignore_start_time {
            let ignored_duration = self.time_service.now().duration_since(ignore_start_time);
            if ignored_duration >= Duration::from_secs(self.min_time_to_ignore_secs) {
                // Reset the invalid request count
                self.invalid_request_count = 0;

                // Reset the ignore start time
                self.ignore_start_time = None;

                // Double the min time to ignore the peer
                self.min_time_to_ignore_secs *= 2;

                // Log the fact that we're no longer ignoring the peer
                warn!(LogSchema::new(LogEntry::RequestModeratorIgnoredPeer)
                    .peer_network_id(peer_network_id)
                    .message("No longer ignoring peer! Enough time has elapsed."));
            }
        }
    }
```

**File:** state-sync/storage-service/server/src/moderator.rs (L154-186)
```rust
            // Verify the request is serviceable using the current storage server summary
            if !storage_server_summary.can_service(
                &self.aptos_data_client_config,
                self.time_service.clone(),
                request,
            ) {
                // Increment the invalid request count for the peer
                let mut unhealthy_peer_state = self
                    .unhealthy_peer_states
                    .entry(*peer_network_id)
                    .or_insert_with(|| {
                        // Create a new unhealthy peer state (this is the first invalid request)
                        let max_invalid_requests =
                            self.storage_service_config.max_invalid_requests_per_peer;
                        let min_time_to_ignore_peers_secs =
                            self.storage_service_config.min_time_to_ignore_peers_secs;
                        let time_service = self.time_service.clone();

                        UnhealthyPeerState::new(
                            max_invalid_requests,
                            min_time_to_ignore_peers_secs,
                            time_service,
                        )
                    });
                unhealthy_peer_state.increment_invalid_request_count(peer_network_id);

                // Return the validation error
                return Err(Error::InvalidRequest(format!(
                    "The given request cannot be satisfied. Request: {:?}, storage summary: {:?}",
                    request, storage_server_summary
                )));
            }

```

**File:** state-sync/storage-service/server/src/moderator.rs (L213-228)
```rust
        self.unhealthy_peer_states
            .retain(|peer_network_id, unhealthy_peer_state| {
                if connected_peers_and_metadata.contains_key(peer_network_id) {
                    // Refresh the ignored peer state
                    unhealthy_peer_state.refresh_peer_state(peer_network_id);

                    // If the peer is ignored, increment the ignored peer count
                    if unhealthy_peer_state.is_ignored() {
                        num_ignored_peers += 1;
                    }

                    true // The peer is still connected, so we should keep it
                } else {
                    false // The peer is no longer connected, so we should remove it
                }
            });
```

**File:** config/src/config/state_sync_config.rs (L213-213)
```rust
            min_time_to_ignore_peers_secs: 300, // 5 minutes
```

**File:** state-sync/storage-service/server/src/lib.rs (L363-380)
```rust
        self.runtime.spawn(async move {
            // Create a ticker for the refresh interval
            let duration = Duration::from_millis(config.request_moderator_refresh_interval_ms);
            let ticker = time_service.interval(duration);
            futures::pin_mut!(ticker);

            // Periodically refresh the peer states
            loop {
                ticker.next().await;

                // Refresh the unhealthy peer states
                if let Err(error) = request_moderator.refresh_unhealthy_peer_states() {
                    error!(LogSchema::new(LogEntry::RequestModeratorRefresh)
                        .error(&error)
                        .message("Failed to refresh the request moderator!"));
                }
            }
        });
```
