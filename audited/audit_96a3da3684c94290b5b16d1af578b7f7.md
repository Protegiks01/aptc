# Audit Report

## Title
State Sync Driver Silent Failure Leading to Validator Liveness Loss

## Summary
The state sync driver task is spawned without monitoring its execution status, and critical sync operations lack timeout mechanisms. If the driver task panics or terminates unexpectedly, consensus operations will hang indefinitely, causing validator liveness failure.

## Finding Description

The state sync driver is spawned without storing or monitoring its `JoinHandle`: [1](#0-0) 

The driver runs an infinite event loop using `futures::select!` that handles various notifications: [2](#0-1) 

This loop uses `select_next_some()` on multiple streams. If any stream terminates unexpectedly, `select_next_some()` will panic with "SelectNextSome polled after terminated": [3](#0-2) 

When consensus needs to synchronize, it calls `sync_to_target()` or `sync_for_duration()` through the `ConsensusNotificationSender`: [4](#0-3) 

The critical vulnerability is that `sync_for_duration()` and `sync_to_target()` await responses **without any timeout**: [5](#0-4) [6](#0-5) 

Note that only `notify_new_commit()` has a timeout mechanism: [7](#0-6) 

**Attack Scenario:**
1. A bug or unexpected condition causes one of the driver's notification streams to close
2. The driver's `select_next_some()` panics on the next loop iteration
3. The driver task terminates silently (no JoinHandle monitoring)
4. Consensus calls `sync_to_target()` when it needs to catch up
5. Consensus awaits indefinitely for a response that will never come
6. The validator becomes stuck and unable to participate in consensus

## Impact Explanation

This qualifies as **High Severity** per the Aptos bug bounty criteria:
- **"Validator node slowdowns"** - The validator becomes completely unresponsive
- **"Significant protocol violations"** - Validator liveness invariant is violated

While not Critical severity (doesn't affect other validators), it causes complete liveness failure for the affected validator, requiring manual intervention and node restart.

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability requires a triggering condition (driver panic), but multiple scenarios can cause this:
1. Internal bugs in notification handlers
2. Stream termination due to component failures
3. Unexpected channel closures
4. Any uncaught panic in the driver loop

The lack of defensive programming (no JoinHandle monitoring, no timeouts) means any driver failure becomes a validator outage.

## Recommendation

**1. Monitor the driver task with JoinHandle:**

```rust
// In driver_factory.rs
let driver_handle = if let Some(driver_runtime) = &driver_runtime {
    driver_runtime.spawn(state_sync_driver.start_driver())
} else {
    tokio::spawn(state_sync_driver.start_driver())
};

// Spawn a monitoring task
tokio::spawn(async move {
    if let Err(e) = driver_handle.await {
        panic!("State sync driver task failed: {:?}. Node requires restart.", e);
    }
});
```

**2. Add timeouts to sync operations in ConsensusNotifier:**

```rust
// In consensus-notifications/src/lib.rs
async fn sync_for_duration(&self, duration: Duration) -> Result<LedgerInfoWithSignatures, Error> {
    // ... send notification ...
    
    // Add timeout (e.g., 5 minutes)
    let timeout_duration = Duration::from_secs(300);
    match timeout(timeout_duration, callback_receiver).await {
        Ok(Ok(response)) => { /* handle response */ },
        Ok(Err(error)) => Err(Error::UnexpectedErrorEncountered(format!("{:?}", error))),
        Err(_) => Err(Error::TimeoutWaitingForStateSync),
    }
}
```

**3. Use `select_next_some()` defensively with termination checks:**

```rust
// In driver.rs, check for stream termination before polling
if self.consensus_notification_handler.is_terminated() {
    panic!("Consensus notification stream terminated unexpectedly!");
}
```

## Proof of Concept

```rust
// Reproduction test demonstrating the hang scenario
#[tokio::test]
async fn test_consensus_hangs_on_driver_failure() {
    // 1. Create consensus notifier and listener pair
    let (consensus_notifier, mut consensus_listener) = 
        new_consensus_notifier_listener_pair(5000);
    
    // 2. Drop the listener to simulate driver failure
    drop(consensus_listener);
    
    // 3. Consensus tries to sync - this will hang forever
    let sync_handle = tokio::spawn(async move {
        consensus_notifier.sync_for_duration(Duration::from_secs(10)).await
    });
    
    // 4. Wait with timeout - sync never completes
    let result = tokio::time::timeout(Duration::from_secs(2), sync_handle).await;
    
    // Demonstrates that sync hangs indefinitely
    assert!(result.is_err(), "Sync should timeout, but it doesn't!");
}
```

## Notes

This vulnerability represents a defensive programming gap where component failures are not properly isolated. While it requires a triggering condition (driver panic), the lack of error handling transforms any driver bug into a validator outage. The fix should implement proper task monitoring and timeout mechanisms to maintain validator liveness even when internal components fail.

### Citations

**File:** state-sync/state-sync-driver/src/driver_factory.rs (L185-189)
```rust
        if let Some(driver_runtime) = &driver_runtime {
            driver_runtime.spawn(state_sync_driver.start_driver());
        } else {
            tokio::spawn(state_sync_driver.start_driver());
        }
```

**File:** state-sync/state-sync-driver/src/driver.rs (L212-240)
```rust
    pub async fn start_driver(mut self) {
        let mut progress_check_interval = IntervalStream::new(interval(Duration::from_millis(
            self.driver_configuration.config.progress_check_interval_ms,
        )))
        .fuse();

        // Start the driver
        info!(LogSchema::new(LogEntry::Driver).message("Started the state sync v2 driver!"));
        self.start_time = Some(self.time_service.now());
        loop {
            ::futures::select! {
                notification = self.client_notification_listener.select_next_some() => {
                    self.handle_client_notification(notification).await;
                },
                notification = self.commit_notification_listener.select_next_some() => {
                    self.handle_snapshot_commit_notification(notification).await;
                }
                notification = self.consensus_notification_handler.select_next_some() => {
                    self.handle_consensus_or_observer_notification(notification).await;
                }
                notification = self.error_notification_listener.select_next_some() => {
                    self.handle_error_notification(notification).await;
                }
                _ = progress_check_interval.select_next_some() => {
                    self.drive_progress().await;
                }
            }
        }
    }
```

**File:** state-sync/data-streaming-service/src/tests/streaming_service.rs (L1553-1554)
```rust
#[should_panic(expected = "SelectNextSome polled after terminated")]
async fn test_terminate_stream() {
```

**File:** consensus/src/state_computer.rs (L132-174)
```rust
    async fn sync_for_duration(
        &self,
        duration: Duration,
    ) -> Result<LedgerInfoWithSignatures, StateSyncError> {
        // Grab the logical time lock
        let mut latest_logical_time = self.write_mutex.lock().await;

        // Before state synchronization, we have to call finish() to free the
        // in-memory SMT held by the BlockExecutor to prevent a memory leak.
        self.executor.finish();

        // Inject an error for fail point testing
        fail_point!("consensus::sync_for_duration", |_| {
            Err(anyhow::anyhow!("Injected error in sync_for_duration").into())
        });

        // Invoke state sync to synchronize for the specified duration. Here, the
        // ChunkExecutor will process chunks and commit to storage. However, after
        // block execution and commits, the internal state of the ChunkExecutor may
        // not be up to date. So, it is required to reset the cache of the
        // ChunkExecutor in state sync when requested to sync.
        let result = monitor!(
            "sync_for_duration",
            self.state_sync_notifier.sync_for_duration(duration).await
        );

        // Update the latest logical time
        if let Ok(latest_synced_ledger_info) = &result {
            let ledger_info = latest_synced_ledger_info.ledger_info();
            let synced_logical_time = LogicalTime::new(ledger_info.epoch(), ledger_info.round());
            *latest_logical_time = synced_logical_time;
        }

        // Similarly, after state synchronization, we have to reset the cache of
        // the BlockExecutor to guarantee the latest committed state is up to date.
        self.executor.reset()?;

        // Return the result
        result.map_err(|error| {
            let anyhow_error: anyhow::Error = error.into();
            anyhow_error.into()
        })
    }
```

**File:** state-sync/inter-component/consensus-notifications/src/lib.rs (L122-137)
```rust
        if let Ok(response) = timeout(
            Duration::from_millis(self.commit_timeout_ms),
            callback_receiver,
        )
        .await
        {
            match response {
                Ok(consensus_notification_response) => consensus_notification_response.get_result(),
                Err(error) => Err(Error::UnexpectedErrorEncountered(format!(
                    "Consensus commit notification failure: {:?}",
                    error
                ))),
            }
        } else {
            Err(Error::TimeoutWaitingForStateSync)
        }
```

**File:** state-sync/inter-component/consensus-notifications/src/lib.rs (L140-179)
```rust
    async fn sync_for_duration(
        &self,
        duration: Duration,
    ) -> Result<LedgerInfoWithSignatures, Error> {
        // Create a consensus sync duration notification
        let (notification, callback_receiver) = ConsensusSyncDurationNotification::new(duration);
        let sync_duration_notification = ConsensusNotification::SyncForDuration(notification);

        // Send the notification to state sync
        if let Err(error) = self
            .notification_sender
            .clone()
            .send(sync_duration_notification)
            .await
        {
            return Err(Error::NotificationError(format!(
                "Failed to notify state sync of sync duration! Error: {:?}",
                error
            )));
        }

        // Process the response
        match callback_receiver.await {
            Ok(response) => match response.get_result() {
                Ok(_) => response.get_latest_synced_ledger_info().ok_or_else(|| {
                    Error::UnexpectedErrorEncountered(
                        "Sync for duration returned an empty latest synced ledger info!".into(),
                    )
                }),
                Err(error) => Err(Error::UnexpectedErrorEncountered(format!(
                    "Sync for duration returned an error: {:?}",
                    error
                ))),
            },
            Err(error) => Err(Error::UnexpectedErrorEncountered(format!(
                "Sync for duration failure: {:?}",
                error
            ))),
        }
    }
```

**File:** state-sync/inter-component/consensus-notifications/src/lib.rs (L181-207)
```rust
    async fn sync_to_target(&self, target: LedgerInfoWithSignatures) -> Result<(), Error> {
        // Create a consensus sync target notification
        let (notification, callback_receiver) = ConsensusSyncTargetNotification::new(target);
        let sync_target_notification = ConsensusNotification::SyncToTarget(notification);

        // Send the notification to state sync
        if let Err(error) = self
            .notification_sender
            .clone()
            .send(sync_target_notification)
            .await
        {
            return Err(Error::NotificationError(format!(
                "Failed to notify state sync of sync target! Error: {:?}",
                error
            )));
        }

        // Process the response
        match callback_receiver.await {
            Ok(response) => response.get_result(),
            Err(error) => Err(Error::UnexpectedErrorEncountered(format!(
                "Sync to target failure: {:?}",
                error
            ))),
        }
    }
```
