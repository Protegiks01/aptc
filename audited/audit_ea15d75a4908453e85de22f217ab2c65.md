# Audit Report

## Title
Missing KZG Evaluation Proof Verification in Batch Decryption - Cryptographic Best Practice Violation

## Summary
The `prepare_individual()` function in the batch encryption module uses KZG evaluation proofs without cryptographic verification, violating fundamental security principles for proof systems. While not directly exploitable in the current consensus implementation, this represents a critical defense-in-depth failure that could enable future attacks if eval_proofs are ever received from external sources.

## Finding Description

The `prepare_individual()` function accepts an `eval_proof` parameter that is supposed to prove the polynomial encoded in `digest` evaluates correctly at `id.x()`. This is a KZG commitment opening proof, which should ALWAYS be verified before use. However, the implementation directly uses the proof in pairing operations without verification. [1](#0-0) 

The eval_proof is used directly in cryptographic pairing at line 98 without any prior verification. Verification functions exist in the `DigestKey` implementation: [2](#0-1) 

However, these verification functions are never called in any production decryption code path. The function is used in consensus for decrypting encrypted transactions: [3](#0-2) 

In the current implementation, eval_proofs are computed locally by honest nodes, making direct exploitation unlikely. However, this violates the critical cryptographic principle that **all proofs must be verified before use**, regardless of their source.

## Impact Explanation

**Current Impact: Low to Medium** - While not directly exploitable in the current codebase (eval_proofs are computed locally), this represents a dangerous API design that:

1. Violates cryptographic best practices for proof verification
2. Creates future vulnerability potential if code paths change
3. Could enable consensus divergence if different nodes somehow process different eval_proofs
4. Fails defense-in-depth principles for critical cryptographic operations

**Potential Future Impact: Critical** - If future changes introduce scenarios where eval_proofs are received from external sources (e.g., distributed decryption protocols, cross-node verification, or API misuse), an attacker could:
- Provide malicious eval_proofs to corrupt pairing computations
- Manipulate symmetric key derivation in decryption
- Cause deterministic execution failures across validators
- Break consensus safety invariants

## Likelihood Explanation

**Current Likelihood: Low** - In the existing consensus implementation, eval_proofs are computed locally using trusted `DigestKey` parameters, making direct exploitation infeasible without validator compromise.

**Future Likelihood: Medium to High** - Any architectural changes that introduce:
- Network-received eval_proofs
- Multi-party decryption protocols  
- External API consumers of the batch encryption library
- Optimization attempts that cache or share eval_proofs

Would immediately elevate this to a critical, exploitable vulnerability.

## Recommendation

Add mandatory proof verification in `prepare_individual()` before using the eval_proof in any cryptographic operations:

```rust
fn prepare_individual(
    &self,
    digest: &Digest,
    eval_proof: &EvalProof,
    digest_key: &DigestKey, // Add digest_key parameter
) -> Result<PreparedBIBECiphertext> {
    // VERIFY THE PROOF BEFORE USE
    digest_key.verify_pf(digest, self.id, **eval_proof)?;
    
    let pairing_output = PairingSetting::pairing(digest.as_g1(), self.ct_g2[0])
        + PairingSetting::pairing(**eval_proof, self.ct_g2[1]);

    Ok(PreparedBIBECiphertext {
        pairing_output,
        ct_g2: self.ct_g2[2].into(),
        padded_key: self.padded_key.clone(),
        symmetric_ciphertext: self.symmetric_ciphertext.clone(),
    })
}
```

Update all callers to provide the `digest_key` parameter for verification. This enforces the cryptographic invariant that proofs must always be verified before use.

## Proof of Concept

The following test demonstrates that `prepare_individual` accepts and uses unverified (potentially malicious) eval_proofs:

```rust
#[test]
fn test_unverified_eval_proof_accepted() {
    use crate::shared::digest::EvalProof;
    use ark_std::rand::thread_rng;
    
    let mut rng = thread_rng();
    let tc = ShamirThresholdConfig::new(1, 1);
    let (ek, dk, _, msk_shares) = FPTX::setup_for_testing(rng.gen(), 8, 1, &tc).unwrap();
    
    let plaintext = String::from("test");
    let id = Id::new(Fr::zero());
    let ct = ek.bibe_encrypt(&mut rng, &plaintext, id).unwrap();
    
    let mut ids = IdSet::with_capacity(dk.capacity()).unwrap();
    ids.add(&id);
    ids.compute_poly_coeffs();
    let (digest, _) = dk.digest(&mut ids, 0).unwrap();
    
    // Create a MALICIOUS eval_proof (random, unverified)
    let malicious_proof = EvalProof::random();
    
    // prepare_individual ACCEPTS the malicious proof without verification!
    let result = ct.prepare_individual(&digest, &malicious_proof);
    
    // This succeeds even though the proof is invalid
    assert!(result.is_ok());
    
    // The malicious proof was used in cryptographic operations
    // This would fail decryption, but the proof was never verified
}
```

**Notes:**

While this vulnerability is not directly exploitable in the current consensus implementation (where eval_proofs are computed locally), it represents a **critical cryptographic design flaw**. The missing verification violates fundamental security principles and creates latent risk. Any future architectural changes that introduce external eval_proofs would immediately expose this as a critical consensus vulnerability.

The fix is straightforward: add proof verification before use, as shown in the recommendation. This is a standard requirement for all cryptographic proof systems and should be enforced regardless of current usage patterns.

### Citations

**File:** crates/aptos-batch-encryption/src/shared/ciphertext/bibe.rs (L92-106)
```rust
    fn prepare_individual(
        &self,
        digest: &Digest,
        eval_proof: &EvalProof,
    ) -> Result<PreparedBIBECiphertext> {
        let pairing_output = PairingSetting::pairing(digest.as_g1(), self.ct_g2[0])
            + PairingSetting::pairing(**eval_proof, self.ct_g2[1]);

        Ok(PreparedBIBECiphertext {
            pairing_output,
            ct_g2: self.ct_g2[2].into(),
            padded_key: self.padded_key.clone(),
            symmetric_ciphertext: self.symmetric_ciphertext.clone(),
        })
    }
```

**File:** crates/aptos-batch-encryption/src/shared/digest.rs (L138-157)
```rust
    fn verify_pf(&self, digest: &Digest, id: Id, pf: G1Affine) -> Result<()> {
        // TODO use multipairing here?
        Ok((PairingSetting::pairing(
            pf,
            self.tau_g2 - G2Projective::from(G2Affine::generator() * id.x()),
        ) == PairingSetting::pairing(digest.as_g1(), G2Affine::generator()))
        .then_some(())
        .ok_or(BatchEncryptionError::EvalProofVerifyError)?)
    }

    pub fn verify(&self, digest: &Digest, pfs: &EvalProofs, id: Id) -> Result<()> {
        let pf = pfs.computed_proofs[&id];
        self.verify_pf(digest, id, pf)
    }

    pub fn verify_all(&self, digest: &Digest, pfs: &EvalProofs) -> Result<()> {
        pfs.computed_proofs
            .iter()
            .try_for_each(|(id, pf)| self.verify_pf(digest, *id, *pf))
    }
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L121-148)
```rust
        let decrypted_txns = encrypted_txns
            .into_par_iter()
            .zip(txn_ciphertexts)
            .map(|(mut txn, ciphertext)| {
                let eval_proof = proofs.get(&ciphertext.id()).expect("must exist");
                if let Ok(payload) = FPTXWeighted::decrypt_individual::<DecryptedPayload>(
                    &decryption_key.key,
                    &ciphertext,
                    &digest,
                    &eval_proof,
                ) {
                    let (executable, nonce) = payload.unwrap();
                    txn.payload_mut()
                        .as_encrypted_payload_mut()
                        .map(|p| {
                            p.into_decrypted(eval_proof, executable, nonce)
                                .expect("must happen")
                        })
                        .expect("must exist");
                } else {
                    txn.payload_mut()
                        .as_encrypted_payload_mut()
                        .map(|p| p.into_failed_decryption(eval_proof).expect("must happen"))
                        .expect("must exist");
                }
                txn
            })
            .collect();
```
