# Audit Report

## Title
Missing Parameter Index Validation in Access Specifier Loader Allows Access Control Bypass

## Summary
The `load_address_specifier` function in the Move VM runtime does not validate that parameter indices in `AddressSpecifier::Parameter` refer to actual function parameters rather than local variables. This allows attackers to craft malicious bytecode that references local variables instead of parameters, bypassing intended access control restrictions.

## Finding Description

The security question asks whether parameter index 0 is valid. **Parameter index 0 is indeed valid and correct** - it refers to the first function parameter in Move VM's unified locals indexing scheme. [1](#0-0) 

However, investigation reveals a **different but related vulnerability**: there is no validation ensuring parameter indices in access specifiers actually reference parameters rather than local variables.

In Move VM's execution model, function parameters occupy indices 0 to (param_count - 1), while additional local variables occupy indices param_count onwards. [2](#0-1) 

The `load_address_specifier` function converts file format access specifiers to runtime representation but performs **no validation** on parameter indices: [3](#0-2) 

The function receives only the module view, signature table, and struct names - it lacks access to the function's parameter count needed for validation: [4](#0-3) 

At runtime, when access specifiers are specialized during function entry, the parameter index is used directly to extract values: [5](#0-4) 

The `copy_loc` operation succeeds for ANY valid local index: [6](#0-5) 

**Attack Path:**
1. Attacker hand-crafts Move bytecode with a function having N parameters
2. Access specifier specifies `Parameter(M)` where M >= N (referencing a local variable)
3. Bytecode verifier does not catch this - no validation exists for access specifier parameter bounds
4. At runtime, when function executes, access specifier extracts address from local variable M
5. Access control checks pass using attacker-controlled address from local variable
6. Function performs unauthorized resource operations at arbitrary addresses

## Impact Explanation

This is a **Medium Severity** vulnerability per Aptos bug bounty criteria:

- **Access Control Bypass**: Breaks invariant #8 (Access Control) - functions can access resources at addresses not authorized by their parameters
- **Limited Resource Manipulation**: Attacker can cause functions to read/write resources at addresses derived from local variables they control within the function logic
- **Requires Manual Bytecode Crafting**: Not exploitable through normal Move compiler, requires hand-crafted or modified bytecode
- **State Inconsistencies**: Could cause unauthorized state modifications requiring intervention

The vulnerability does not reach Critical severity because:
- No direct fund theft or minting capability
- Does not compromise consensus safety
- Limited to scope of individual function's resource access
- Requires deploying malicious module (subject to module deployment restrictions)

## Likelihood Explanation

**Moderate Likelihood:**

**Attacker Requirements:**
- Ability to deploy modules to the chain (may require gas/fees)
- Technical capability to hand-craft or modify Move bytecode
- Understanding of Move VM's locals indexing scheme

**Mitigating Factors:**
- Normal Move compiler generates correct parameter indices via `.position()`: [7](#0-6) 
- Requires bypassing standard compilation toolchain
- Malicious modules may be detected by other means (code review, dependency analysis)

**Aggravating Factors:**
- No bytecode verification exists for this case: [8](#0-7) 
- Easy to exploit once bytecode is crafted
- Could be combined with other vulnerabilities

## Recommendation

Add parameter index validation to the access specifier loading process:

1. **Pass parameter count to loader**: Modify `load_access_specifier` signature to receive the function's parameter count
2. **Add bounds checking**: Validate that parameter indices in `AddressSpecifier::Parameter` are less than the parameter count
3. **Return clear error**: Return `ACCESS_CONTROL_INVARIANT_VIOLATION` status when validation fails

Suggested fix location in `access_specifier_loader.rs`:

```rust
fn load_address_specifier(
    module: BinaryIndexedView,
    spec: &FF::AddressSpecifier,
    param_count: u8,  // ADD THIS PARAMETER
) -> PartialVMResult<AddressSpecifier> {
    use FF::AddressSpecifier::*;
    match spec {
        Any => Ok(AddressSpecifier::Any),
        Literal(idx) => Ok(AddressSpecifier::Literal(*access_table(
            module.address_identifiers(),
            idx.0,
        )?)),
        Parameter(param, fun) => {
            // ADD VALIDATION HERE
            if *param >= param_count {
                return Err(PartialVMError::new(
                    StatusCode::ACCESS_CONTROL_INVARIANT_VIOLATION
                ).with_message(format!(
                    "access specifier parameter index {} exceeds parameter count {}",
                    param, param_count
                )));
            }
            // ... rest of existing code
        },
    }
}
```

Update call site in `function.rs` to pass parameter count: [9](#0-8) 

## Proof of Concept

```rust
// Pseudo-code for crafting malicious bytecode
// This demonstrates the attack concept

module 0x1::exploit {
    use std::signer;
    
    // Legitimate function signature: 1 parameter (&signer)
    // But hand-crafted bytecode has additional locals
    public entry fun malicious_transfer(account: &signer) {
        // In legitimate bytecode, access specifier would be:
        // writes Resource(Parameter(0, Some(signer::address_of)))
        
        // Attacker modifies bytecode to:
        // writes Resource(Parameter(1, None))  // Index 1 = first LOCAL, not parameter
        
        // Local variable at index 1 is computed by attacker:
        let target_addr: address = @0xBADDCAFE;  // Store at local index 1
        
        // Now access control uses target_addr from local var
        // instead of signer address from parameter!
        // Function can write to resources at attacker-chosen address
    }
}
```

**To demonstrate:**
1. Compile normal Move module
2. Modify compiled bytecode to change parameter index in access specifier from 0 to 1
3. Deploy modified bytecode
4. Call function - observe it accesses resources at local variable address instead of parameter address

### Citations

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L948-962)
```rust
        let mut locals = Locals::new(num_locals);
        let num_param_tys = function.param_tys().len();
        // Whether the function making this frame performs checks.
        let should_check = RTTCheck::should_perform_checks(&current_frame.function.function);
        for i in (0..num_param_tys).rev() {
            let is_captured = mask.is_captured(i);
            let value = if is_captured {
                captured.pop().ok_or_else(|| {
                    PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                        .with_message("inconsistent closure mask".to_string())
                })?
            } else {
                self.operand_stack.pop()?
            };
            locals.store_loc(i, value)?;
```

**File:** third_party/move/move-binary-format/src/file_format.rs (L908-913)
```rust
    Parameter(
        /// The index of a parameter of the current function. If `modifier` is not given, the
        /// parameter must have address type. Otherwise `modifier` must be a function which takes
        /// a value (or reference) of the parameter type and delivers an address.
        #[cfg_attr(any(test, feature = "fuzzing"), proptest(strategy = "0u8..63"))]
        LocalIndex,
```

**File:** third_party/move/move-vm/runtime/src/loader/access_specifier_loader.rs (L89-110)
```rust
        Parameter(param, fun) => {
            let fun = if let Some(idx) = fun {
                let fun_inst = access_table(module.function_instantiations(), idx.0)?;
                let fun_handle = access_table(module.function_handles(), fun_inst.handle.0)?;
                let mod_handle = access_table(module.module_handles(), fun_handle.module.0)?;
                let mod_id = module
                    .safe_module_id_for_handle(mod_handle)
                    .ok_or_else(index_out_of_range)?;
                let mod_name = mod_id.short_str_lossless();
                let fun_name = access_table(module.identifiers(), fun_handle.name.0)?;
                AddressSpecifierFunction::parse(&mod_name, fun_name.as_str()).ok_or_else(|| {
                    PartialVMError::new(StatusCode::ACCESS_CONTROL_INVARIANT_VIOLATION)
                        .with_message(format!(
                            "function `{}::{}` not supported for address specifier",
                            mod_name, fun_name
                        ))
                })?
            } else {
                AddressSpecifierFunction::Identity
            };
            Ok(AddressSpecifier::Eval(fun, *param))
        },
```

**File:** third_party/move/move-vm/runtime/src/loader/function.rs (L675-682)
```rust
        let param_tys = signature_table[handle.parameters.0 as usize].clone();

        let access_specifier = load_access_specifier(
            BinaryIndexedView::Module(module),
            signature_table,
            struct_names,
            &handle.access_specifiers,
        )?;
```

**File:** third_party/move/move-vm/runtime/src/frame.rs (L80-86)
```rust
    fn eval_address_specifier_function(
        &self,
        fun: AddressSpecifierFunction,
        local: LocalIndex,
    ) -> PartialVMResult<AccountAddress> {
        fun.eval(self.locals.copy_loc(local as usize)?)
    }
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L2352-2361)
```rust
    pub fn copy_loc(&self, idx: usize) -> PartialVMResult<Value> {
        let locals = self.0.borrow();
        match locals.get(idx) {
            Some(Value::Invalid) => Err(PartialVMError::new(
                StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
            )
            .with_message(format!("cannot copy invalid value at index {}", idx))),
            Some(v) => Ok(v.copy_value(1, Some(DEFAULT_MAX_VM_VALUE_NESTED_DEPTH))?),
            None => Err(Self::local_index_out_of_bounds(idx, locals.len())),
        }
```

**File:** third_party/move/move-compiler-v2/src/file_format_generator/module_generator.rs (L1083-1088)
```rust
                    let param_index = fun_env
                        .get_parameters()
                        .iter()
                        .position(|Parameter(n, _ty, _)| n == name)
                        .expect("parameter defined") as u8;
                    FF::AddressSpecifier::Parameter(param_index, None)
```

**File:** third_party/move/move-bytecode-verifier/src/features.rs (L108-125)
```rust
    fn verify_function_handles(&self) -> PartialVMResult<()> {
        if !self.config.enable_resource_access_control || !self.config.enable_function_values {
            for (idx, function_handle) in self.code.function_handles().iter().enumerate() {
                if !self.config.enable_resource_access_control
                    && function_handle.access_specifiers.is_some()
                {
                    return Err(PartialVMError::new(StatusCode::FEATURE_NOT_ENABLED)
                        .at_index(IndexKind::FunctionHandle, idx as u16)
                        .with_message("resource access control feature not enabled".to_string()));
                }
                if !self.config.enable_function_values && !function_handle.attributes.is_empty() {
                    return Err(PartialVMError::new(StatusCode::FEATURE_NOT_ENABLED)
                        .at_index(IndexKind::FunctionDefinition, idx as u16)
                        .with_message("function value feature not enabled".to_string()));
                }
            }
        }
        Ok(())
```
