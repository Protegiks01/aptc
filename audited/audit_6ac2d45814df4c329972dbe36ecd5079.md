# Audit Report

## Title
Hex Encoding Case Inconsistency Causes Pepper Service Startup Failures

## Summary
The `encode_key()` function in `encoding_type.rs` uses uppercase hex encoding (`hex::encode_upper()`), while the pepper service's VUF public key serialization and pepper derivation use lowercase hex encoding (`hex::encode()`). This case mismatch causes string comparison failures during startup validation, resulting in service denial-of-service even when the underlying cryptographic key bytes are identical.

## Finding Description
The Aptos codebase contains two different hex encoding patterns that produce different case outputs:

1. **Uppercase encoding**: [1](#0-0) 

2. **Lowercase encoding for VUF public keys**: [2](#0-1) 

3. **Lowercase encoding for pepper derivation**: [3](#0-2) 

During pepper service startup, the code performs **case-sensitive string comparisons** to validate expected values:

- VUF public key validation: [4](#0-3) 

- Derived pepper validation: [5](#0-4) 

**Attack Scenario:**
1. An operator generates or extracts a VUF public key using Aptos CLI tools that utilize `SaveKey::save_key()`, which calls `encode_key()` producing uppercase hex
2. The operator provides this value via `--expected-vuf-pubkey-on-startup=UPPERCASE_HEX` command-line argument
3. The pepper service starts and computes its actual VUF public key using lowercase hex serialization
4. The string comparison at line 487 fails (`vuf_public_key != expected_vuf_public_key`)
5. The service panics and refuses to start: [6](#0-5) 

The same issue occurs with the `--expected-derived-pepper-on-startup` parameter.

## Impact Explanation
This vulnerability qualifies as **Medium Severity** under the Aptos bug bounty criteria: "State inconsistencies requiring intervention."

**Impact:**
- **Service Unavailability**: The pepper service fails to start, causing denial-of-service for keyless account operations
- **Operational Confusion**: Operators waste time debugging why a "correct" key is being rejected
- **Security Decision Errors**: May lead operators to believe their keys are compromised when they are actually valid
- **Supply Chain Attack Vector**: Malicious actors could provide tools or documentation that generate uppercase hex values, causing legitimate services to fail

While not a direct consensus violation or fund loss, this creates operational disruption and could be weaponized through social engineering or compromised documentation.

## Likelihood Explanation
**Likelihood: Medium-High**

This issue is likely to occur because:
1. The Aptos CLI's default encoding uses `EncodingType::Hex` which produces uppercase output
2. Operators naturally use official Aptos tools to generate and manage keys
3. The startup scripts show lowercase values [7](#0-6) , but documentation gaps could lead operators to use uppercase
4. No validation or normalization is performed before comparison

The case mismatch is a hidden trap that will trigger the first time an operator uses standard key generation tools instead of manually copying values from example scripts.

## Recommendation
Normalize hex string comparisons to be case-insensitive. Apply one of these fixes:

**Option 1 (Recommended)**: Normalize to lowercase before comparison
```rust
// In verify_expected_vuf_public_key
if vuf_public_key.to_lowercase() != expected_vuf_public_key.to_lowercase() {
    panic!(...);
}

// In verify_expected_derived_pepper
if derived_pepper.to_lowercase() != expected_derived_pepper.to_lowercase() {
    panic!(...);
}
```

**Option 2**: Standardize on lowercase encoding everywhere by changing `encode_key()`:
```rust
EncodingType::Hex => hex::encode(key.to_bytes()).into_bytes(),  // Remove _upper
```

**Option 3**: Decode and compare bytes instead of strings:
```rust
let expected_bytes = hex::decode(expected_vuf_public_key).expect("Invalid hex");
let actual_bytes = hex::decode(vuf_public_key).expect("Invalid hex");
if actual_bytes != expected_bytes {
    panic!(...);
}
```

Option 1 is the least disruptive and immediately fixes the issue.

## Proof of Concept

```rust
// File: test_hex_case_mismatch.rs
// Demonstrates the vulnerability

use hex;

fn main() {
    // Simulate key saved with encode_key() (uppercase)
    let key_bytes = vec![0xAB, 0xCD, 0xEF, 0x12];
    let saved_uppercase = hex::encode_upper(&key_bytes);
    println!("Saved (uppercase): {}", saved_uppercase);
    
    // Simulate service computing key (lowercase)
    let computed_lowercase = hex::encode(&key_bytes);
    println!("Computed (lowercase): {}", computed_lowercase);
    
    // String comparison fails!
    if saved_uppercase != computed_lowercase {
        println!("❌ COMPARISON FAILED - Service would panic!");
        println!("Even though bytes are identical: {:?}", key_bytes);
    }
    
    // But bytes are actually the same
    let decoded_upper = hex::decode(&saved_uppercase).unwrap();
    let decoded_lower = hex::decode(&computed_lowercase).unwrap();
    assert_eq!(decoded_upper, decoded_lower);
    println!("✓ Underlying bytes are identical");
}

// Output:
// Saved (uppercase): ABCDEF12
// Computed (lowercase): abcdef12
// ❌ COMPARISON FAILED - Service would panic!
// Even though bytes are identical: [171, 205, 239, 18]
// ✓ Underlying bytes are identical
```

**Reproduction Steps:**
1. Generate a VUF keypair and save the public key using `EncodingType::Hex.encode_key()` → produces uppercase
2. Start pepper service with `--expected-vuf-pubkey-on-startup=<UPPERCASE_HEX>`
3. Service computes actual public key using lowercase encoding
4. String comparison at line 487 fails
5. Service panics at startup

## Notes
- This affects both `--expected-vuf-pubkey-on-startup` and `--expected-derived-pepper-on-startup` parameters
- The `hex::decode()` function used in `from_encoded_string()` is case-insensitive [8](#0-7) , so key loading/decoding works correctly
- The vulnerability only manifests during string comparisons, not during cryptographic operations
- Current example scripts use lowercase values, but operators using CLI tools would naturally generate uppercase values

### Citations

**File:** crates/aptos-crypto/src/encoding_type.rs (L58-58)
```rust
            EncodingType::Hex => hex::encode_upper(key.to_bytes()).into_bytes(),
```

**File:** keyless/pepper/common/src/lib.rs (L16-16)
```rust
    let hex_string = hex::encode(bytes);
```

**File:** keyless/pepper/service/src/main.rs (L453-453)
```rust
    let derived_pepper = hex::encode(derived_pepper_bytes);
```

**File:** keyless/pepper/service/src/main.rs (L456-461)
```rust
    if derived_pepper != expected_derived_pepper {
        panic!(
            "The derived pepper does not match the expected value! Derived: {:?}, Expected: {:?}",
            derived_pepper, expected_derived_pepper
        );
    }
```

**File:** keyless/pepper/service/src/main.rs (L487-492)
```rust
    if vuf_public_key != expected_vuf_public_key {
        panic!(
            "The VUF public key does not match the expected value! Actual: {:?}, Expected: {:?}",
            vuf_public_key, expected_vuf_public_key
        );
    }
```

**File:** keyless/pepper/scripts/start-pepper-service.sh (L16-17)
```shellscript
EXPECTED_VUF_PUBKEY_ON_STARTUP=b601ec185c62da8f5c0402d4d4f987b63b06972c11f6f6f9d68464bda32fa502a5eac0adeda29917b6f8fa9bbe0f498209dcdb48d6a066c1f599c0502c5b4c24d4b057c758549e3e8a89ad861a82a789886d69876e6c6341f115c9ecc381eefd
EXPECTED_DERIVED_PEPPER_ON_STARTUP=72c147eb3457ec5ff32cc540e09ebe739a189b0b194fe269f18d29556dcc2f
```

**File:** crates/aptos-crypto/src/traits/mod.rs (L93-93)
```rust
        let bytes_out = ::hex::decode(str);
```
