# Audit Report

## Title
Malicious Peer Can Send Fabricated StorageServerSummary to Cause State Synchronization Denial of Service

## Summary
A malicious peer can send a `StorageServerSummary` with fabricated data ranges (transactions, outputs, states) while including a valid `LedgerInfoWithSignatures`. The client trusts these unverified ranges for peer selection, causing data requests to fail when the malicious peer cannot fulfill them. This creates a denial-of-service condition on state synchronization.

## Finding Description

The `StorageServerSummary` structure contains a `DataSummary` with claimed data ranges that are **not cryptographically bound** to the `LedgerInfoWithSignatures`. [1](#0-0) 

When clients poll peers for storage summaries, they receive and store these summaries **without any verification** of the claimed data ranges. [2](#0-1) 

The client then uses these unverified ranges to determine if a peer can service a request via the `can_service()` method. [3](#0-2) 

**Attack Flow:**
1. Malicious peer obtains a valid `LedgerInfoWithSignatures` (version 100) by syncing normally or querying other peers
2. Malicious peer constructs a fake `DataSummary` claiming:
   - `transactions: CompleteDataRange(0, 100000)`
   - `transaction_outputs: CompleteDataRange(0, 100000)`
   - `states: CompleteDataRange(0, 100000)`
   - But actually only has data for versions 0-100
3. Client's poller receives this fabricated summary and stores it directly without validation
4. Client needs transactions at versions 50000-60000 and selects the malicious peer based on its claimed ranges
5. Client sends `GetTransactionsWithProof` request to malicious peer
6. Malicious peer's storage layer returns `StorageErrorEncountered` because versions 50000-60000 don't exist in its database [4](#0-3) 
7. Client receives error, marks peer as `ErrorType::NotUseful`, and reduces peer score [5](#0-4) 
8. Request is retried with another peer, wasting time, bandwidth, and CPU resources

The malicious peer can maintain a sufficient score by occasionally serving valid requests for its actual data range (0-100), preventing complete exclusion from the peer set.

## Impact Explanation

This vulnerability qualifies as **HIGH severity** under the Aptos bug bounty criteria:

1. **Validator node slowdowns**: Multiple malicious peers coordinating this attack can significantly slow down state synchronization across the network, delaying validator nodes from catching up to the latest ledger state.

2. **Significant protocol violations**: The state-sync protocol's design assumption—that peers honestly advertise their data availability—is violated without any cryptographic enforcement.

3. **Denial of Service Impact**:
   - Failed requests waste network bandwidth (request + error response)
   - Wasted CPU cycles processing failed requests
   - Increased state synchronization latency for honest nodes
   - Can target specific version ranges to block critical historical data

4. **Attack Amplification**: If 50% of network peers are malicious and claim to have data they don't have, approximately half of all data requests will initially fail and require retry, effectively doubling synchronization time.

This does not reach Critical severity because:
- It does not directly violate consensus safety
- It does not cause permanent network partition (requests eventually succeed with honest peers)
- The peer scoring mechanism provides eventual mitigation
- No funds are at risk

## Likelihood Explanation

**Likelihood: HIGH**

1. **Low Attack Barrier**: Any network peer can send arbitrary `StorageServerSummary` messages. No special privileges, stake, or validator access required.

2. **Simple Exploitation**: The attacker only needs to:
   - Connect to the network as a regular peer
   - Obtain any valid `LedgerInfoWithSignatures` (trivial via normal sync)
   - Fabricate `CompleteDataRange` values in the `DataSummary`
   - Send the modified summary in response to `GetStorageServerSummary` requests

3. **Limited Detection**: The peer scoring mechanism only reduces scores gradually (`NOT_USEFUL_MULTIPLIER: 0.95`), and peers are only ignored when scores drop below 25.0. [6](#0-5) 

4. **Economic Incentive**: A malicious actor could use this to slow down competitors' synchronization, or simply disrupt the network without risk of slashing (since no stake is required).

5. **No Cryptographic Protection**: Unlike transaction data responses which include cryptographic proofs that are verified [7](#0-6) , the `StorageServerSummary` data ranges have no such protection.

## Recommendation

**Solution 1: Cryptographic Binding (Preferred)**
Add a cryptographic commitment to the data ranges in the ledger info or create a signed summary structure:

```rust
pub struct SignedStorageServerSummary {
    pub summary: StorageServerSummary,
    pub signature: bls12381::Signature, // Sign the entire summary
    pub signer_address: AccountAddress,
}
```

Validators could sign their summaries using their validator keys, and clients would only trust summaries from known validators with valid signatures.

**Solution 2: Optimistic Verification with Aggressive Penalties**
Implement immediate, severe score penalties for peers whose claimed ranges don't match reality:

```rust
// In peer_states.rs, when a request fails due to missing data:
const INVALID_SUMMARY_MULTIPLIER: f64 = 0.5; // Much more aggressive penalty

// In client.rs, when storage error received:
if error.is_storage_error_for_claimed_range() {
    self.notify_bad_response(id, peer, &request, ErrorType::InvalidSummary);
}
```

**Solution 3: Progressive Range Discovery**
Instead of trusting claimed ranges, implement a progressive verification mechanism:
- New peers start with "unverified" status
- Client makes small test requests to verify claimed ranges
- Only after successful verification are full ranges trusted

**Immediate Mitigation:**
Add sanity checks in the client to reject summaries with ranges that exceed the synced ledger info version:

```rust
// In peer_states.rs update_summary():
pub fn update_summary(&self, peer: PeerNetworkId, storage_summary: StorageServerSummary) {
    // Validate ranges don't exceed synced ledger info
    if let Some(synced_ledger_info) = &storage_summary.data_summary.synced_ledger_info {
        let synced_version = synced_ledger_info.ledger_info().version();
        
        // Reject if claimed ranges exceed synced version
        if storage_summary.data_summary.transactions.map(|r| r.highest() > synced_version).unwrap_or(false) {
            warn!("Peer {} claimed invalid transaction range", peer);
            return;
        }
        // Similar checks for outputs, states, etc.
    }
    
    // ... existing code
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod malicious_summary_test {
    use super::*;
    use aptos_config::config::AptosDataClientConfig;
    use aptos_storage_service_types::{
        requests::{DataRequest, StorageServiceRequest},
        responses::{CompleteDataRange, DataSummary, StorageServerSummary, ProtocolMetadata},
    };
    use aptos_types::ledger_info::LedgerInfoWithSignatures;
    
    #[tokio::test]
    async fn test_malicious_peer_fake_summary_causes_request_failure() {
        // Setup: Create a valid LedgerInfoWithSignatures at version 100
        let ledger_info = create_test_ledger_info(100);
        
        // Attack: Malicious peer creates fake summary claiming to have data up to version 100000
        let fake_summary = StorageServerSummary {
            protocol_metadata: ProtocolMetadata::default(),
            data_summary: DataSummary {
                synced_ledger_info: Some(ledger_info),
                transactions: Some(CompleteDataRange::new(0, 100000).unwrap()),
                transaction_outputs: Some(CompleteDataRange::new(0, 100000).unwrap()),
                states: Some(CompleteDataRange::new(0, 100000).unwrap()),
                epoch_ending_ledger_infos: None,
            },
        };
        
        // Client receives and trusts this summary
        let config = AptosDataClientConfig::default();
        let time_service = TimeService::mock();
        
        // Create a request for transactions at version 50000-60000
        let request = StorageServiceRequest::new(
            DataRequest::GetTransactionsWithProof(TransactionsWithProofRequest {
                start_version: 50000,
                end_version: 60000,
                proof_version: 60000,
                include_events: false,
            }),
            false,
        );
        
        // Verify: Client thinks peer can service this request based on fake ranges
        assert!(fake_summary.can_service(&config, time_service.clone(), &request));
        
        // But when request is made, peer's actual storage (which only has 0-100) will fail
        // This demonstrates the vulnerability: client wastes resources on failed requests
    }
}
```

## Notes

This vulnerability exploits the trust assumption in the state-sync protocol that peers honestly advertise their data availability. While the peer scoring mechanism provides gradual mitigation, it does not prevent the initial denial-of-service impact. The lack of cryptographic binding between the claimed data ranges and the `LedgerInfoWithSignatures` allows malicious peers to cause systematic request failures, degrading network synchronization performance.

The vulnerability is particularly concerning because:
1. It requires no stake or validator privileges to exploit
2. Multiple malicious peers can coordinate to amplify the attack
3. The attack is sustainable if malicious peers occasionally serve valid requests to maintain scores
4. It can target specific version ranges to block access to critical historical data

### Citations

**File:** state-sync/storage-service/types/src/responses.rs (L665-686)
```rust
/// A summary of the data actually held by the storage service instance.
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct DataSummary {
    /// The ledger info corresponding to the highest synced version in storage.
    /// This indicates the highest version and epoch that storage can prove.
    pub synced_ledger_info: Option<LedgerInfoWithSignatures>,
    /// The range of epoch ending ledger infos in storage, e.g., if the range
    /// is [(X,Y)], it means all epoch ending ledger infos for epochs X->Y
    /// (inclusive) are held.
    pub epoch_ending_ledger_infos: Option<CompleteDataRange<Epoch>>,
    /// The range of states held in storage, e.g., if the range is
    /// [(X,Y)], it means all states are held for every version X->Y
    /// (inclusive).
    pub states: Option<CompleteDataRange<Version>>,
    /// The range of transactions held in storage, e.g., if the range is
    /// [(X,Y)], it means all transactions for versions X->Y (inclusive) are held.
    pub transactions: Option<CompleteDataRange<Version>>,
    /// The range of transaction outputs held in storage, e.g., if the range
    /// is [(X,Y)], it means all transaction outputs for versions X->Y
    /// (inclusive) are held.
    pub transaction_outputs: Option<CompleteDataRange<Version>>,
}
```

**File:** state-sync/aptos-data-client/src/poller.rs (L436-439)
```rust
        // Update the summary for the peer
        data_summary_poller
            .data_client
            .update_peer_storage_summary(peer, storage_summary);
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L38-43)
```rust
/// Not necessarily a malicious response, but not super useful.
const NOT_USEFUL_MULTIPLIER: f64 = 0.95;
/// Likely to be a malicious response.
const MALICIOUS_MULTIPLIER: f64 = 0.8;
/// Ignore a peer when their score dips below this threshold.
const IGNORE_PEER_THRESHOLD: f64 = 25.0;
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L200-227)
```rust
    pub fn can_service_request(
        &self,
        peer: &PeerNetworkId,
        time_service: TimeService,
        request: &StorageServiceRequest,
    ) -> bool {
        // Storage services can always respond to data advertisement requests.
        // We need this outer check, since we need to be able to send data summary
        // requests to new peers (who don't have a peer state yet).
        if request.data_request.is_storage_summary_request()
            || request.data_request.is_protocol_version_request()
        {
            return true;
        }

        // Check if the peer can service the request
        if let Some(peer_state) = self.peer_to_state.get(peer) {
            return match peer_state.get_storage_summary_if_not_ignored() {
                Some(storage_summary) => {
                    storage_summary.can_service(&self.data_client_config, time_service, request)
                },
                None => false, // The peer is temporarily ignored
            };
        }

        // Otherwise, the request cannot be serviced
        false
    }
```

**File:** state-sync/storage-service/server/src/error.rs (L11-12)
```rust
    #[error("Storage error encountered: {0}")]
    StorageErrorEncountered(String),
```

**File:** state-sync/aptos-data-client/src/client.rs (L830-868)
```rust
            Err(error) => {
                // Convert network error and storage service error types into
                // data client errors. Also categorize the error type for scoring
                // purposes.
                let client_error = match error {
                    aptos_storage_service_client::Error::RpcError(rpc_error) => match rpc_error {
                        RpcError::NotConnected(_) => {
                            Error::DataIsUnavailable(rpc_error.to_string())
                        },
                        RpcError::TimedOut => {
                            Error::TimeoutWaitingForResponse(rpc_error.to_string())
                        },
                        _ => Error::UnexpectedErrorEncountered(rpc_error.to_string()),
                    },
                    aptos_storage_service_client::Error::StorageServiceError(err) => {
                        Error::UnexpectedErrorEncountered(err.to_string())
                    },
                    _ => Error::UnexpectedErrorEncountered(error.to_string()),
                };

                warn!(
                    (LogSchema::new(LogEntry::StorageServiceResponse)
                        .event(LogEvent::ResponseError)
                        .request_type(&request.get_label())
                        .request_id(id)
                        .peer(&peer)
                        .error(&client_error))
                );

                increment_request_counter(
                    &metrics::ERROR_RESPONSES,
                    client_error.get_label(),
                    peer,
                );

                self.notify_bad_response(id, peer, &request, ErrorType::NotUseful);
                Err(client_error)
            },
        }
```

**File:** types/src/transaction/mod.rs (L2295-2354)
```rust
    pub fn verify(
        &self,
        ledger_info: &LedgerInfo,
        first_transaction_version: Option<Version>,
    ) -> Result<()> {
        // Verify the first transaction versions match
        ensure!(
            self.get_first_transaction_version() == first_transaction_version,
            "First transaction version ({:?}) doesn't match given version ({:?}).",
            self.get_first_transaction_version(),
            first_transaction_version,
        );

        // Verify the lengths of the transactions and transaction infos match
        ensure!(
            self.proof.transaction_infos.len() == self.get_num_transactions(),
            "The number of TransactionInfo objects ({}) does not match the number of \
             transactions ({}).",
            self.proof.transaction_infos.len(),
            self.get_num_transactions(),
        );

        // Verify the transaction hashes match those of the transaction infos
        self.transactions
            .par_iter()
            .zip_eq(self.proof.transaction_infos.par_iter())
            .map(|(txn, txn_info)| {
                let txn_hash = CryptoHash::hash(txn);
                ensure!(
                    txn_hash == txn_info.transaction_hash(),
                    "The hash of transaction does not match the transaction info in proof. \
                     Transaction hash: {:x}. Transaction hash in txn_info: {:x}.",
                    txn_hash,
                    txn_info.transaction_hash(),
                );
                Ok(())
            })
            .collect::<Result<Vec<_>>>()?;

        // Verify the transaction infos are proven by the ledger info.
        self.proof
            .verify(ledger_info, self.get_first_transaction_version())?;

        // Verify the events if they exist.
        if let Some(event_lists) = &self.events {
            ensure!(
                event_lists.len() == self.get_num_transactions(),
                "The length of event_lists ({}) does not match the number of transactions ({}).",
                event_lists.len(),
                self.get_num_transactions(),
            );
            event_lists
                .into_par_iter()
                .zip_eq(self.proof.transaction_infos.par_iter())
                .map(|(events, txn_info)| verify_events_against_root_hash(events, txn_info))
                .collect::<Result<Vec<_>>>()?;
        }

        Ok(())
    }
```
