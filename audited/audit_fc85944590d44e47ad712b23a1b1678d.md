# Audit Report

## Title
Consensus Observer Accepts Unverified Commit Decisions for Future Epochs, Enabling Consensus Safety Violations

## Summary
The `update_commit_decision()` function at line 127 of `ordered_blocks.rs` does not perform signature verification, and its caller chain bypasses verification for commit decisions targeting future epochs. An attacker can send a `CommitDecision` message with forged or missing signatures for a future epoch, causing the node to update its root to an unverified state and attempt to sync to an invalid target. This breaks consensus safety and can cause network partitions.

## Finding Description
The consensus observer processes `CommitDecision` messages received from network peers. The critical vulnerability exists in the commit decision verification logic: [1](#0-0) 

The code only verifies signatures when `commit_epoch == epoch_state.epoch` (current epoch). For future epoch commits, verification is entirely skipped, and the code proceeds to: [2](#0-1) 

This calls `update_blocks_for_state_sync_commit` which updates the node's root without any signature verification: [3](#0-2) 

The root update happens unconditionally: [4](#0-3) 

The `update_commit_decision()` function itself performs no verification: [5](#0-4) 

While `CommitDecision` has a `verify_commit_proof()` method available: [6](#0-5) 

This verification is never invoked for future epoch commits. The code even acknowledges this gap: [7](#0-6) 

**Attack Scenario:**
1. Attacker crafts a `CommitDecision` with `epoch = current_epoch + 1`
2. Sets arbitrary block info and invalid/empty `LedgerInfoWithSignatures`
3. Sends to consensus observer nodes
4. Nodes accept the message, skip verification (future epoch path)
5. Nodes update their root to the forged commit
6. Nodes attempt state sync to non-existent/malicious target
7. Different nodes may accept different forged commits, causing chain split

This violates the **Consensus Safety** invariant (AptosBFT must prevent chain splits under < 1/3 Byzantine) and the **Cryptographic Correctness** invariant (BLS signatures must be verified).

## Impact Explanation
**Critical Severity** - This vulnerability enables:

1. **Consensus Safety Violation**: Different consensus observer nodes can be tricked into accepting different invalid commit decisions for future epochs, causing them to diverge in their view of the committed state.

2. **Network Partition**: Nodes will attempt to state sync to invalid targets, potentially causing non-recoverable network fragmentation requiring manual intervention or hard fork.

3. **State Inconsistency**: Node roots can be manipulated to point to arbitrary, unverified ledger infos, breaking the integrity of the consensus observer subsystem.

This meets the Critical severity criteria: "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation
**High Likelihood** - The attack requires:
- Network access to send messages to consensus observer nodes (standard P2P capability)
- No validator privileges or special credentials
- Trivial message construction (future epoch + forged signatures)

The vulnerability is in production code actively processing network messages. Any malicious peer can exploit this. The only barrier is message subscription verification, but once subscribed, malicious peers can send arbitrary commit decisions.

## Recommendation
Add signature verification for ALL commit decisions, regardless of epoch. Modify the code as follows:

**In `consensus/src/consensus_observer/observer/consensus_observer.rs`**, move verification outside the epoch check:

```rust
fn process_commit_decision_message(
    &mut self,
    peer_network_id: PeerNetworkId,
    message_received_time: Instant,
    commit_decision: CommitDecision,
) {
    // Get the commit decision epoch and round
    let commit_epoch = commit_decision.epoch();
    let commit_round = commit_decision.round();

    // If the commit message is behind our highest committed block, ignore it
    let get_highest_committed_epoch_round = self
        .observer_block_data
        .lock()
        .get_highest_committed_epoch_round();
    if (commit_epoch, commit_round) <= get_highest_committed_epoch_round {
        update_metrics_for_dropped_commit_decision_message(peer_network_id, &commit_decision);
        return;
    }

    // Update metrics
    update_metrics_for_commit_decision_message(peer_network_id, &commit_decision);

    // VERIFY COMMIT DECISION FOR ALL EPOCHS
    let epoch_state = if commit_epoch == self.get_epoch_state().epoch {
        self.get_epoch_state()
    } else {
        // For future epochs, we need the epoch state for that epoch
        // If unavailable, reject the commit decision
        error!(LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
            "Cannot verify commit decision for future epoch {:?}. Rejecting.",
            commit_epoch
        )));
        increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
        return;
    };

    // Verify the commit decision
    if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
        error!(LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
            "Failed to verify commit decision! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
            commit_decision.proof_block_info(),
            peer_network_id,
            error
        )));
        increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
        return;
    }

    // ... rest of processing
}
```

Alternatively, if future epoch commits need to be accepted for epoch transitions, cache the next epoch's validator set and verify against it. Never accept unverified commits.

## Proof of Concept

```rust
#[test]
fn test_unverified_future_epoch_commit_accepted() {
    // Setup: Create consensus observer with current epoch 10
    let current_epoch = 10;
    let mut observer = create_test_consensus_observer(current_epoch);
    
    // Create a forged commit decision for future epoch 11
    let future_epoch = 11;
    let forged_block_info = BlockInfo::new(
        future_epoch,
        100, // arbitrary round
        HashValue::random(),
        HashValue::random(),
        1000,
        1000,
        None,
    );
    
    // Create commit decision with EMPTY signature (invalid)
    let forged_commit = CommitDecision::new(LedgerInfoWithSignatures::new(
        LedgerInfo::new(forged_block_info, HashValue::random()),
        AggregateSignature::empty(), // NO VALID SIGNATURES
    ));
    
    // Send the forged commit decision
    let peer_network_id = PeerNetworkId::random();
    observer.process_commit_decision_message(
        peer_network_id,
        Instant::now(),
        forged_commit.clone(),
    );
    
    // VULNERABILITY: Node's root is updated to unverified commit
    let updated_root = observer.observer_block_data.lock().root();
    assert_eq!(updated_root.commit_info().epoch(), future_epoch);
    assert_eq!(updated_root.commit_info().round(), 100);
    
    // This should FAIL but currently PASSES - unverified commit was accepted
    // The node will now attempt to state sync to this invalid target
}
```

**Notes**

The vulnerability is particularly severe because:
1. The comment at line 497-498 explicitly acknowledges the missing verification for future epochs
2. No fallback verification occurs in state sync before accepting the target
3. The root update happens before any sync validation
4. Different nodes may receive different forged commits, causing permanent divergence

This represents a fundamental bypass of cryptographic verification in the consensus observer, enabling arbitrary state manipulation by any network peer.

### Citations

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L466-495)
```rust
        // If the commit decision is for the current epoch, verify and process it
        let epoch_state = self.get_epoch_state();
        if commit_epoch == epoch_state.epoch {
            // Verify the commit decision
            if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify commit decision! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                        commit_decision.proof_block_info(),
                        peer_network_id,
                        error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
                return;
            }

            // Update the latency metrics for commit processing
            update_message_processing_latency_metrics(
                message_received_time,
                &peer_network_id,
                metrics::COMMIT_DECISION_LABEL,
            );

            // Update the pending blocks with the commit decision
            if self.process_commit_decision_for_pending_block(&commit_decision) {
                return; // The commit decision was successfully processed
            }
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L497-498)
```rust
        // TODO: identify the best way to handle an invalid commit decision
        // for a future epoch. In such cases, we currently rely on state sync.
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L500-527)
```rust
        // Otherwise, we failed to process the commit decision. If the commit
        // is for a future epoch or round, we need to state sync.
        let last_block = self.observer_block_data.lock().get_last_ordered_block();
        let epoch_changed = commit_epoch > last_block.epoch();
        if epoch_changed || commit_round > last_block.round() {
            // If we're waiting for state sync to transition into a new epoch,
            // we should just wait and not issue a new state sync request.
            if self.state_sync_manager.is_syncing_through_epoch() {
                info!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Already waiting for state sync to reach new epoch: {:?}. Dropping commit decision: {:?}!",
                        self.observer_block_data.lock().root().commit_info(),
                        commit_decision.proof_block_info()
                    ))
                );
                return;
            }

            // Otherwise, we should start the state sync process for the commit.
            // Update the block data (to the commit decision).
            self.observer_block_data
                .lock()
                .update_blocks_for_state_sync_commit(&commit_decision);

            // Start state syncing to the commit decision
            self.state_sync_manager
                .sync_to_commit(commit_decision, epoch_changed);
        }
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L273-291)
```rust
    /// Updates the block data for the given commit decision
    /// that will be used by state sync to catch us up.
    pub fn update_blocks_for_state_sync_commit(&mut self, commit_decision: &CommitDecision) {
        // Get the commit proof, epoch and round
        let commit_proof = commit_decision.commit_proof();
        let commit_epoch = commit_decision.epoch();
        let commit_round = commit_decision.round();

        // Update the root
        self.update_root(commit_proof.clone());

        // Update the block payload store
        self.block_payload_store
            .remove_blocks_for_epoch_round(commit_epoch, commit_round);

        // Update the ordered block store
        self.ordered_block_store
            .remove_blocks_for_commit(commit_proof);
    }
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L299-302)
```rust
    /// Updates the root ledger info
    pub fn update_root(&mut self, new_root: LedgerInfoWithSignatures) {
        self.root = new_root;
    }
```

**File:** consensus/src/consensus_observer/observer/ordered_blocks.rs (L126-142)
```rust
    /// Updates the commit decision of the ordered block (if found)
    pub fn update_commit_decision(&mut self, commit_decision: &CommitDecision) {
        // Get the epoch and round of the commit decision
        let commit_decision_epoch = commit_decision.epoch();
        let commit_decision_round = commit_decision.round();

        // Update the commit decision for the ordered blocks
        if let Some((_, existing_commit_decision)) = self
            .ordered_blocks
            .get_mut(&(commit_decision_epoch, commit_decision_round))
        {
            *existing_commit_decision = Some(commit_decision.clone());
        }

        // Update the highest committed epoch and round
        self.update_highest_committed_epoch_round(commit_decision.commit_proof());
    }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L366-375)
```rust
    /// Verifies the commit proof and returns an error if the proof is invalid
    pub fn verify_commit_proof(&self, epoch_state: &EpochState) -> Result<(), Error> {
        epoch_state.verify(&self.commit_proof).map_err(|error| {
            Error::InvalidMessageError(format!(
                "Failed to verify commit proof ledger info: {:?}, Error: {:?}",
                self.proof_block_info(),
                error
            ))
        })
    }
```
