# Audit Report

## Title
State Snapshot Inconsistency Allows Waypoint Verification Against Non-Consensus-Committed State

## Summary
The database bootstrap tool verifies waypoints against pre-committed state that may include transactions never certified by consensus. This occurs due to a race condition between asynchronous state snapshot commits to `state_merkle_db` and consensus commit operations that update `synced_version` in `metadata_db`, allowing waypoint verification to pass with incorrect state.

## Finding Description

The Aptos storage layer implements a two-phase commit protocol:
1. **Pre-commit phase**: `pre_commit_ledger()` writes transaction data and updates the in-memory buffered state
2. **Commit phase**: `commit_ledger()` certifies the data with a `LedgerInfoWithSignatures` and updates `synced_version` [1](#0-0) 

The buffered state asynchronously commits snapshots through a multi-threaded pipeline (`StateSnapshotCommitter` → `StateMerkleBatchCommitter` → `state_merkle_db`). This creates a critical race condition: [2](#0-1) 

**Attack Scenario:**
1. Node pre-commits transactions at versions N+1 through N+k
2. Buffered state asynchronously flushes snapshots to `state_merkle_db` (including version N+k)
3. Node crashes before `commit_ledger()` updates `metadata_db.synced_version` (still at N)
4. Database now contains:
   - `state_merkle_db`: snapshots up to version N+k (pre-committed but not consensus-committed)
   - `metadata_db.synced_version`: version N (last consensus-committed)

When the database is reopened, the initialization logic loads the latest snapshot: [3](#0-2) 

The code checks if the snapshot is ahead of the committed version but only logs a warning: [4](#0-3) 

When the bootstrap tool calls `get_pre_committed_ledger_summary()`, it returns state from the pre-committed (but not consensus-committed) transactions: [5](#0-4) 

This ledger summary is then used to calculate and verify waypoints: [6](#0-5) 

The genesis transaction is executed on top of this incorrect state: [7](#0-6) 

## Impact Explanation

This vulnerability has **High Severity** impact:

1. **State Consistency Violation (Invariant #4)**: The bootstrap tool verifies waypoints against state that was never certified by consensus, violating the guarantee that "state transitions must be atomic and verifiable via Merkle proofs."

2. **Consensus Safety Risk**: If multiple nodes crash with different pre-committed states and bootstrap with mismatched waypoints, this could lead to network divergence requiring manual intervention.

3. **Trust Boundary Breach**: Waypoints are critical security anchors used for state sync and bootstrap verification. Accepting waypoints based on non-consensus-committed state undermines this security model.

This meets the **High Severity** criteria per Aptos bug bounty: "State inconsistencies requiring intervention" and "Significant protocol violations."

## Likelihood Explanation

The likelihood is **Medium to High** because:

1. **Natural Occurrence**: This can happen during normal operation without malicious intent - any node crash during the window between pre-commit and commit triggers the condition
2. **Asynchronous Nature**: The buffered state's asynchronous commit mechanism (with `ASYNC_COMMIT_CHANNEL_BUFFER_SIZE = 1`) means snapshots are continuously being flushed in the background
3. **Common Tool Usage**: The bootstrap tool is used during genesis setup and recovery scenarios, making this a real-world attack vector
4. **No Validation**: The code only logs a warning when detecting this condition, rather than erroring or recovering [8](#0-7) 

## Recommendation

**Immediate Fix**: Add strict validation in `create_buffered_state_from_latest_snapshot()` to error when the snapshot version exceeds the synced version:

```rust
// At line 610-617 in storage/aptosdb/src/state_store/mod.rs
let snapshot_next_version = latest_snapshot_version.map_or(0, |v| v + 1);

// Replace the info! log with an error
ensure!(
    snapshot_next_version <= num_transactions,
    "State snapshot version ({}) is ahead of synced version ({}). \
     Database may have crashed during commit. Cannot safely initialize.",
    snapshot_next_version.saturating_sub(1),
    num_transactions.saturating_sub(1),
);
```

**Long-term Fix**: Implement atomic commit coordination:
1. Track pending state snapshot commits in `metadata_db`
2. During initialization, rollback any snapshots beyond `synced_version`
3. Ensure `commit_ledger()` only succeeds after all async state commits for that version complete

**Alternative**: Make the bootstrap tool use `get_synced_version()` explicitly rather than `get_pre_committed_ledger_summary()`: [9](#0-8) 

## Proof of Concept

```rust
// Rust test to demonstrate the vulnerability
#[test]
fn test_waypoint_verification_with_uncommitted_state() {
    use aptos_db::AptosDB;
    use aptos_executor::db_bootstrapper::calculate_genesis;
    use aptos_storage_interface::{DbReaderWriter, DbWriter};
    use aptos_types::transaction::Transaction;
    use std::sync::Arc;
    
    // 1. Setup: Create DB and commit transaction at version 0
    let db = setup_test_db();
    let genesis_txn = create_genesis_transaction();
    
    // 2. Pre-commit transaction at version 1 (without consensus commit)
    let chunk = create_test_chunk_at_version(1);
    db.writer.pre_commit_ledger(chunk, false).unwrap();
    
    // 3. Wait for async state snapshot to flush to disk
    std::thread::sleep(std::time::Duration::from_secs(2));
    
    // 4. Simulate crash: Close and reopen DB WITHOUT calling commit_ledger
    drop(db);
    let db_reopened = reopen_test_db();
    
    // 5. Bootstrap tool gets pre-committed ledger summary
    let ledger_summary = db_reopened.reader
        .get_pre_committed_ledger_summary()
        .unwrap();
    
    // 6. Verify the summary includes the uncommitted transaction
    assert_eq!(ledger_summary.next_version(), 2); // Should be 1, but is 2!
    
    // 7. Calculate waypoint - this will be based on WRONG state
    let waypoint = calculate_genesis::<AptosVMBlockExecutor>(
        &db_reopened, 
        ledger_summary, 
        &genesis_txn
    ).unwrap().waypoint();
    
    // 8. Waypoint is now based on state that was never consensus-committed!
    println!("Generated waypoint from non-consensus state: {:?}", waypoint);
}
```

## Notes

The vulnerability stems from the fundamental design choice to separate pre-commit (optimistic execution) from consensus commit. While this improves performance, it creates a consistency window where the database can have partially-committed state. The bootstrap tool's reliance on `get_pre_committed_ledger_summary()` without validating against `synced_version` exposes this window to exploitation.

The issue is particularly severe because waypoints are security-critical primitives used throughout the Aptos ecosystem for state synchronization and verification. A waypoint generated from non-consensus-committed state could propagate through the network, potentially causing divergence or requiring a hard fork to resolve.

### Citations

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L44-76)
```rust
    fn pre_commit_ledger(&self, chunk: ChunkToCommit, sync_commit: bool) -> Result<()> {
        gauged_api("pre_commit_ledger", || {
            // Pre-committing and committing in concurrency is allowed but not pre-committing at the
            // same time from multiple threads, the same for committing.
            // Consensus and state sync must hand over to each other after all pending execution and
            // committing complete.
            let _lock = self
                .pre_commit_lock
                .try_lock()
                .expect("Concurrent committing detected.");
            let _timer = OTHER_TIMERS_SECONDS.timer_with(&["pre_commit_ledger"]);

            chunk
                .state_summary
                .latest()
                .global_state_summary
                .log_generation("db_save");

            self.pre_commit_validation(&chunk)?;
            let _new_root_hash =
                self.calculate_and_commit_ledger_and_state_kv(&chunk, self.skip_index_and_usage)?;

            let _timer = OTHER_TIMERS_SECONDS.timer_with(&["save_transactions__others"]);

            self.state_store.buffered_state().lock().update(
                chunk.result_ledger_state_with_summary(),
                chunk.estimated_total_state_updates(),
                sync_commit || chunk.is_reconfig,
            )?;

            Ok(())
        })
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L522-537)
```rust
    fn get_and_check_commit_range(&self, version_to_commit: Version) -> Result<Option<Version>> {
        let old_committed_ver = self.ledger_db.metadata_db().get_synced_version()?;
        let pre_committed_ver = self.state_store.current_state_locked().version();
        ensure!(
            old_committed_ver.is_none() || version_to_commit >= old_committed_ver.unwrap(),
            "Version too old to commit. Committed: {:?}; Trying to commit with LI: {}",
            old_committed_ver,
            version_to_commit,
        );
        ensure!(
            pre_committed_ver.is_some() && version_to_commit <= pre_committed_ver.unwrap(),
            "Version too new to commit. Pre-committed: {:?}, Trying to commit with LI: {}",
            pre_committed_ver,
            version_to_commit,
        );
        Ok(old_committed_ver)
```

**File:** storage/aptosdb/src/state_store/buffered_state.rs (L28-29)
```rust
pub(crate) const ASYNC_COMMIT_CHANNEL_BUFFER_SIZE: u64 = 1;
pub(crate) const TARGET_SNAPSHOT_INTERVAL_IN_VERSION: u64 = 100_000;
```

**File:** storage/aptosdb/src/state_store/buffered_state.rs (L31-46)
```rust
/// BufferedState manages a range of recent state checkpoints and asynchronously commits
/// the updates in batches.
#[derive(Debug)]
pub struct BufferedState {
    /// the current state and the last checkpoint. shared with outside world.
    current_state: Arc<Mutex<LedgerStateWithSummary>>,
    /// The most recent checkpoint sent for persistence, not guaranteed to have committed already.
    last_snapshot: StateWithSummary,
    /// channel to send a checkpoint for persistence asynchronously
    state_commit_sender: SyncSender<CommitMessage<StateWithSummary>>,
    /// Estimated number of items in the buffer.
    estimated_items: usize,
    /// The target number of items in the buffer between commits.
    target_items: usize,
    join_handle: Option<JoinHandle<()>>,
}
```

**File:** storage/aptosdb/src/state_store/mod.rs (L561-593)
```rust
        let num_transactions = state_db
            .ledger_db
            .metadata_db()
            .get_synced_version()?
            .map_or(0, |v| v + 1);

        let latest_snapshot_version = state_db
            .state_merkle_db
            .get_state_snapshot_version_before(Version::MAX)
            .expect("Failed to query latest node on initialization.");

        info!(
            num_transactions = num_transactions,
            latest_snapshot_version = latest_snapshot_version,
            "Initializing BufferedState."
        );
        // TODO(HotState): read hot root hash from DB.
        let latest_snapshot_root_hash = if let Some(version) = latest_snapshot_version {
            state_db
                .state_merkle_db
                .get_root_hash(version)
                .expect("Failed to query latest checkpoint root hash on initialization.")
        } else {
            *SPARSE_MERKLE_PLACEHOLDER_HASH
        };
        let usage = state_db.get_state_storage_usage(latest_snapshot_version)?;
        let state = StateWithSummary::new_at_version(
            latest_snapshot_version,
            *SPARSE_MERKLE_PLACEHOLDER_HASH, // TODO(HotState): for now hot state always starts from empty upon restart.
            latest_snapshot_root_hash,
            usage,
            hot_state_config,
        );
```

**File:** storage/aptosdb/src/state_store/mod.rs (L607-617)
```rust
        // Make sure the committed transactions is ahead of the latest snapshot.
        let snapshot_next_version = latest_snapshot_version.map_or(0, |v| v + 1);

        // For non-restore cases, always snapshot_next_version <= num_transactions.
        if snapshot_next_version > num_transactions {
            info!(
                snapshot_next_version = snapshot_next_version,
                num_transactions = num_transactions,
                "snapshot is after latest transaction version. It should only happen in restore mode",
            );
        }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L709-729)
```rust
    fn get_pre_committed_ledger_summary(&self) -> Result<LedgerSummary> {
        gauged_api("get_pre_committed_ledger_summary", || {
            let (state, state_summary) = self
                .state_store
                .current_state_locked()
                .to_state_and_summary();
            let num_txns = state.next_version();

            let frozen_subtrees = self
                .ledger_db
                .transaction_accumulator_db()
                .get_frozen_subtree_hashes(num_txns)?;
            let transaction_accumulator =
                Arc::new(InMemoryAccumulator::new(frozen_subtrees, num_txns)?);
            Ok(LedgerSummary {
                state,
                state_summary,
                transaction_accumulator,
            })
        })
    }
```

**File:** storage/db-tool/src/bootstrap.rs (L65-93)
```rust
        let ledger_summary = db
            .reader
            .get_pre_committed_ledger_summary()
            .with_context(|| format_err!("Failed to get latest tree state."))?;
        println!("Db has {} transactions", ledger_summary.next_version());
        if let Some(waypoint) = self.waypoint_to_verify {
            ensure!(
                waypoint.version() == ledger_summary.next_version(),
                "Trying to generate waypoint at version {}, but DB has {} transactions.",
                waypoint.version(),
                ledger_summary.next_version(),
            )
        }

        let committer =
            calculate_genesis::<AptosVMBlockExecutor>(&db, ledger_summary, &genesis_txn)
                .with_context(|| format_err!("Failed to calculate genesis."))?;
        println!(
            "Successfully calculated genesis. Got waypoint: {}",
            committer.waypoint()
        );

        if let Some(waypoint) = self.waypoint_to_verify {
            ensure!(
                waypoint == committer.waypoint(),
                "Waypoint verification failed. Expected {:?}, got {:?}.",
                waypoint,
                committer.waypoint(),
            );
```

**File:** execution/executor/src/db_bootstrapper/mod.rs (L115-146)
```rust
pub fn calculate_genesis<V: VMBlockExecutor>(
    db: &DbReaderWriter,
    ledger_summary: LedgerSummary,
    genesis_txn: &Transaction,
) -> Result<GenesisCommitter> {
    // DB bootstrapper works on either an empty transaction accumulator or an existing block chain.
    // In the very extreme and sad situation of losing quorum among validators, we refer to the
    // second use case said above.
    let genesis_version = ledger_summary.version().map_or(0, |v| v + 1);
    let base_state_view = CachedStateView::new(
        StateViewId::Miscellaneous,
        Arc::clone(&db.reader),
        ledger_summary.state.latest().clone(),
    )?;

    let epoch = if genesis_version == 0 {
        GENESIS_EPOCH
    } else {
        get_state_epoch(&base_state_view)?
    };

    let execution_output = DoGetExecutionOutput::by_transaction_execution::<V>(
        &V::new(),
        vec![genesis_txn.clone().into()].into(),
        // TODO(grao): Do we need any auxiliary info for hard fork? Not now, but maybe one day we
        // will need it.
        vec![AuxiliaryInfo::new_empty()],
        &ledger_summary.state,
        base_state_view,
        BlockExecutorConfigFromOnchain::new_no_block_limit(),
        TransactionSliceMetadata::unknown(),
    )?;
```
