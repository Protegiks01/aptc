# Audit Report

## Title
UserTransactionFilter Silently Matches Multisig Transactions with Empty Payloads, Bypassing Entry Function Filters

## Summary
The `UserTransactionFilter` in the indexer gRPC transaction filter system incorrectly matches multisig transactions with empty payloads (`transaction_payload = None`) when an entry function filter is specified. This causes unauthorized filter matches, leading to incorrect transaction stripping and data loss in the indexer data service.

## Finding Description

The vulnerability exists in the `UserTransactionFilter::matches()` implementation. When a filter specifies a payload filter to match specific entry functions, the code attempts to extract an entry function payload from the transaction. However, if extraction fails (returns `None`), the filter silently succeeds instead of failing the match. [1](#0-0) 

The problematic flow occurs at lines 100-114. When `entry_function_payload` is `None` (line 102-105), the `if let Some(payload)` condition at line 106 doesn't match, so the code skips the filter check entirely and returns `true` at line 114.

Multisig transactions in Aptos can legitimately have `transaction_payload = None` when executing pre-stored on-chain payloads: [2](#0-1) 

The entry function extraction logic correctly returns `None` for such transactions: [3](#0-2) 

At lines 281-289, when `ms_payload.transaction_payload` is `None`, the entire chain returns `None`.

This filter is used by the indexer gRPC data service to strip sensitive data (payloads, signatures, events, state changes) from matching transactions: [4](#0-3) 

**Attack Scenario:**
1. An indexer configures a `UserTransactionFilter` with a payload filter to strip transactions calling specific entry functions (e.g., `0x1::coin::transfer`)
2. An attacker submits a multisig transaction with `transaction_payload = None` (a valid transaction type)
3. The filter incorrectly matches this transaction even though it doesn't contain the targeted entry function
4. The transaction gets stripped (payload and signature removed), causing data loss for downstream consumers

## Impact Explanation

This is a **Medium severity** vulnerability per the Aptos bug bounty program criteria ("State inconsistencies requiring intervention"). The impact includes:

1. **Data Loss**: Transaction payloads and signatures are incorrectly removed from multisig transactions with empty payloads, even when they shouldn't match the filter criteria
2. **Security Policy Violation**: Filters intended to match specific entry functions will match unrelated multisig transactions, bypassing access control expectations
3. **Downstream Processing Errors**: Systems consuming filtered data will receive incomplete transaction information, potentially causing processing failures or incorrect business logic execution
4. **Operational Impact**: Requires manual intervention to fix incorrectly stripped transaction data

While this doesn't directly affect consensus or cause fund loss, it breaks the semantic contract of transaction filtering and can cause significant operational issues for indexer consumers.

## Likelihood Explanation

**Likelihood: High**

This vulnerability will trigger automatically whenever:
1. An indexer deploys a `UserTransactionFilter` with a payload filter (common use case for filtering specific dApp transactions)
2. Users submit multisig transactions with empty payloads (legitimate and documented transaction type used for executing pre-approved on-chain transactions)

Both conditions are common in production Aptos deployments. Multisig accounts frequently execute pre-stored transactions for efficiency and gas savings. The vulnerability requires no special attacker capabilitiesâ€”it occurs naturally during normal operations.

## Recommendation

Modify the `UserTransactionFilter::matches()` method to explicitly fail the match when a payload filter is specified but entry function extraction returns `None`:

```rust
if let Some(payload_filter) = &self.payload {
    // Get the entry_function_payload from both UserPayload and MultisigPayload
    let entry_function_payload = user_request
        .payload
        .as_ref()
        .and_then(get_entry_function_payload_from_transaction_payload);
    if let Some(payload) = entry_function_payload {
        // Here we have an actual EntryFunctionPayload
        if !payload_filter.matches(payload) {
            return false;
        }
    } else {
        // If we have a payload filter but can't extract an entry function payload,
        // the transaction should NOT match
        return false;
    }
}

true
```

This ensures that filters with payload specifications only match transactions that actually contain extractable entry function payloads.

## Proof of Concept

```rust
#[cfg(test)]
mod test_vulnerability {
    use super::*;
    use aptos_protos::transaction::v1::{
        transaction::{TransactionType, TxnData},
        multisig_transaction_payload, transaction_payload, EntryFunctionId, MoveModuleId,
        MultisigPayload, MultisigTransactionPayload, Transaction, TransactionInfo,
        TransactionPayload, UserTransaction, UserTransactionRequest,
    };

    #[test]
    fn test_multisig_empty_payload_incorrectly_matches_filter() {
        // Create a UserTransactionFilter that should only match coin::transfer
        let filter = UserTransactionFilterBuilder::default()
            .payload(
                UserTransactionPayloadFilterBuilder::default()
                    .function(
                        EntryFunctionFilterBuilder::default()
                            .address("0x1")
                            .module("coin")
                            .function("transfer")
                            .build()
                            .unwrap(),
                    )
                    .build()
                    .unwrap(),
            )
            .build()
            .unwrap();

        // Create a multisig transaction with NO transaction_payload (None)
        let multisig_txn = Transaction {
            timestamp: None,
            version: 1,
            info: Some(TransactionInfo::default()),
            epoch: 0,
            block_height: 0,
            type_: TransactionType::User as i32,
            txn_data: Some(TxnData::User(UserTransaction {
                request: Some(UserTransactionRequest {
                    sender: "0xdeadbeef".to_string(),
                    sequence_number: 1,
                    max_gas_amount: 1000,
                    gas_unit_price: 100,
                    expiration_timestamp_secs: None,
                    payload: Some(TransactionPayload {
                        r#type: transaction_payload::Type::MultisigPayload as i32,
                        payload: Some(transaction_payload::Payload::MultisigPayload(
                            MultisigPayload {
                                multisig_address: "0xmultisig".to_string(),
                                transaction_payload: None, // Empty payload!
                            },
                        )),
                    }),
                    signature: None,
                }),
                events: vec![],
            })),
            size_info: None,
        };

        // BUG: This should return false but returns true
        // The transaction has no entry function payload, so it shouldn't match
        // a filter looking for coin::transfer
        assert!(
            filter.matches(&multisig_txn),
            "VULNERABILITY CONFIRMED: Filter incorrectly matches multisig with empty payload"
        );

        // Expected behavior: should return false
        // assert!(!filter.matches(&multisig_txn));
    }

    #[test]
    fn test_multisig_with_different_entry_function_correctly_rejects() {
        // Create a filter for coin::transfer
        let filter = UserTransactionFilterBuilder::default()
            .payload(
                UserTransactionPayloadFilterBuilder::default()
                    .function(
                        EntryFunctionFilterBuilder::default()
                            .address("0x1")
                            .module("coin")
                            .function("transfer")
                            .build()
                            .unwrap(),
                    )
                    .build()
                    .unwrap(),
            )
            .build()
            .unwrap();

        // Create a multisig transaction WITH a different entry function
        let multisig_txn = Transaction {
            timestamp: None,
            version: 1,
            info: Some(TransactionInfo::default()),
            epoch: 0,
            block_height: 0,
            type_: TransactionType::User as i32,
            txn_data: Some(TxnData::User(UserTransaction {
                request: Some(UserTransactionRequest {
                    sender: "0xdeadbeef".to_string(),
                    sequence_number: 1,
                    max_gas_amount: 1000,
                    gas_unit_price: 100,
                    expiration_timestamp_secs: None,
                    payload: Some(TransactionPayload {
                        r#type: transaction_payload::Type::MultisigPayload as i32,
                        payload: Some(transaction_payload::Payload::MultisigPayload(
                            MultisigPayload {
                                multisig_address: "0xmultisig".to_string(),
                                transaction_payload: Some(MultisigTransactionPayload {
                                    r#type: multisig_transaction_payload::Type::EntryFunctionPayload
                                        as i32,
                                    payload: Some(
                                        multisig_transaction_payload::Payload::EntryFunctionPayload(
                                            aptos_protos::transaction::v1::EntryFunctionPayload {
                                                function: Some(EntryFunctionId {
                                                    module: Some(MoveModuleId {
                                                        address: "0x1".to_string(),
                                                        name: "account".to_string(), // Different module
                                                    }),
                                                    name: "create_account".to_string(), // Different function
                                                }),
                                                type_arguments: vec![],
                                                arguments: vec![],
                                                entry_function_id_str: "".to_string(),
                                            },
                                        ),
                                    ),
                                }),
                            },
                        )),
                    }),
                    signature: None,
                }),
                events: vec![],
            })),
            size_info: None,
        };

        // This correctly returns false (different entry function)
        assert!(!filter.matches(&multisig_txn));
    }
}
```

This PoC demonstrates that a `UserTransactionFilter` configured to match only `coin::transfer` transactions incorrectly matches multisig transactions with empty payloads, while correctly rejecting multisig transactions with different entry functions.

## Notes

The vulnerability is limited to the indexer gRPC system and does not affect consensus, execution, or validator operations. However, it represents a clear violation of filter semantics that can cause operational issues and data integrity problems for indexer consumers. The fix is straightforward and should be applied to ensure filters behave as documented and expected.

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L100-114)
```rust
        if let Some(payload_filter) = &self.payload {
            // Get the entry_function_payload from both UserPayload and MultisigPayload
            let entry_function_payload = user_request
                .payload
                .as_ref()
                .and_then(get_entry_function_payload_from_transaction_payload);
            if let Some(payload) = entry_function_payload {
                // Here we have an actual EntryFunctionPayload
                if !payload_filter.matches(payload) {
                    return false;
                }
            }
        }

        true
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L275-294)
```rust
fn get_entry_function_payload_from_transaction_payload(
    payload: &TransactionPayload,
) -> Option<&EntryFunctionPayload> {
    if let Some(payload) = &payload.payload {
        match payload {
            transaction_payload::Payload::EntryFunctionPayload(ef_payload) => Some(ef_payload),
            transaction_payload::Payload::MultisigPayload(ms_payload) => ms_payload
                .transaction_payload
                .as_ref()
                .and_then(|tp| tp.payload.as_ref())
                .map(|payload| match payload {
                    multisig_transaction_payload::Payload::EntryFunctionPayload(ef_payload) => {
                        ef_payload
                    },
                }),
            _ => None,
        }
    } else {
        None
    }
```

**File:** types/src/transaction/multisig.rs (L9-17)
```rust
/// A multisig transaction that allows an owner of a multisig account to execute a pre-approved
/// transaction as the multisig account.
#[derive(Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct Multisig {
    pub multisig_address: AccountAddress,

    // Transaction payload is optional if already stored on chain.
    pub transaction_payload: Option<MultisigTransactionPayload>,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs (L924-950)
```rust
fn strip_transactions(
    transactions: Vec<Transaction>,
    txns_to_strip_filter: &BooleanTransactionFilter,
) -> (Vec<Transaction>, usize) {
    let mut stripped_count = 0;

    let stripped_transactions: Vec<Transaction> = transactions
        .into_iter()
        .map(|mut txn| {
            // Note: `is_allowed` means the txn matches the filter, in which case
            // we strip it.
            if txns_to_strip_filter.matches(&txn) {
                stripped_count += 1;
                if let Some(info) = txn.info.as_mut() {
                    info.changes = vec![];
                }
                if let Some(TxnData::User(user_transaction)) = txn.txn_data.as_mut() {
                    user_transaction.events = vec![];
                    if let Some(utr) = user_transaction.request.as_mut() {
                        // Wipe the payload and signature.
                        utr.payload = None;
                        utr.signature = None;
                    }
                }
            }
            txn
        })
```
