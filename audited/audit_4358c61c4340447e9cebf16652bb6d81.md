# Audit Report

## Title
Gas Metering Bypass via Module Bundle Deserialization - Under-Priced Per-Module Computation

## Summary
The Aptos VM performs expensive per-module deserialization work before charging gas for the per-module overhead, allowing attackers to submit module bundles with many small modules to execute under-priced computation and cause validator node slowdowns.

## Finding Description

The vulnerability exists in the module publishing flow where gas charging occurs **after** expensive deserialization operations, breaking the invariant that "all operations must respect gas, storage, and computational limits."

**Attack Flow:**

1. `ModuleBundle::new()` creates a bundle structure without any validation on module count or pre-computation of gas requirements. [1](#0-0) 

2. The native function `native_request_publish` charges gas based only on a base fee plus per-byte charges, with **no per-module overhead**. It charges `CODE_REQUEST_PUBLISH_BASE` (1,838 units) once and `CODE_REQUEST_PUBLISH_PER_BYTE` (7 units) per byte of module code. [2](#0-1) 

3. The gas parameter values are defined as: [3](#0-2) 

4. Later, in `resolve_pending_code_publish_and_finish_user_session`, the VM deserializes **all modules in the bundle** via `deserialize_module_bundle()` **before** any per-module gas charging occurs: [4](#0-3) 

5. The deserialization function loops through each module, calling `CompiledModule::deserialize_with_config()` - an expensive operation involving binary format parsing, table reading, and bounds checking: [5](#0-4) 

6. **Only after** deserialization completes, the VM attempts to charge per-module dependency gas: [6](#0-5) 

7. This charges `DEPENDENCY_PER_MODULE` (74,460 units) + `DEPENDENCY_PER_BYTE` (42 units per byte) for each module: [7](#0-6) 

8. The gas charging implementation only checks balance when charging: [8](#0-7) 

**The Vulnerability:** Due to the 64KB transaction size limit, an attacker can submit a bundle with approximately 1,310 small modules (50 bytes each):
- Gas charged in native function: 1,838 + (65,500 × 7) = **460,338 units**
- Deserialization work performed: **1,310 × deserialization_cost_per_module** (expensive CPU work)
- Gas that should be charged after: 1,310 × (74,460 + 50 × 42) = **100,292,700 units**
- **Amplification factor: ~217x**

If the transaction has insufficient gas for the dependency charging phase, it aborts with `OUT_OF_GAS` - but the CPU-intensive deserialization work at line 1491 was **already executed** before the gas check.

## Impact Explanation

**Severity: High** - Validator node slowdowns due to under-priced computation.

This vulnerability allows attackers to:
1. Submit transactions that consume significant validator CPU resources during module deserialization
2. Pay minimal gas (only per-byte charges of ~460K units without per-module overhead of ~100M units)
3. Force **all validators** to perform expensive deserialization work before realizing insufficient gas was paid
4. Repeat attacks cheaply to sustain validator resource exhaustion

Each malicious transaction can deserialize over 1,000 modules (limited by the 64KB transaction size), each requiring binary format parsing, structure validation, and bounds checking - all happening **before** proper gas metering occurs.

According to the Aptos bug bounty criteria, this qualifies as **High Severity** because it enables "validator node slowdowns" through systematically under-priced computation. The 217x amplification factor means an attacker paying for 460K gas units can force validators to perform computation worth 100M gas units.

## Likelihood Explanation

**Likelihood: High**

The attack is:
- **Trivial to execute**: Any user can submit a transaction with a module bundle through standard transaction submission
- **Low cost**: Attacker only pays for bytes (~7 gas units per byte) instead of per-module overhead (~74,460 gas units per module)
- **High amplification**: A 64KB transaction (1,310 modules × 50 bytes) pays ~460K gas but causes work worth ~100M gas (217x amplification)
- **No special privileges required**: Standard transaction submission capability
- **Repeatable**: Attacker can submit multiple transactions to sustain the attack
- **Minimal module construction**: Valid minimal modules can be constructed using the `empty_module()` pattern [9](#0-8) 

## Recommendation

The fix should charge per-module gas **before** performing deserialization. Specifically:

1. In `native_request_publish`, add a per-module charge:
   ```rust
   for module in safely_pop_arg!(args, Vec<Value>) {
       let module_code = module.value_as::<Vec<u8>>()?;
       
       // Charge per-module overhead upfront
       context.charge(CODE_REQUEST_PUBLISH_PER_MODULE)?;
       
       context.charge(CODE_REQUEST_PUBLISH_PER_BYTE * NumBytes::new(module_code.len() as u64))?;
       code.push(module_code);
   }
   ```

2. Introduce a new gas parameter `CODE_REQUEST_PUBLISH_PER_MODULE` with a value matching or exceeding `DEPENDENCY_PER_MODULE` (74,460 units) to ensure upfront payment for per-module overhead.

3. Alternatively, add a module count validation limit to prevent excessively large bundles.

## Proof of Concept

```rust
// This PoC demonstrates the gas metering issue by showing the execution order:
// 1. Native function charges minimal gas (base + per-byte)
// 2. Deserialization happens (expensive)
// 3. Per-module gas charging attempts (may fail with OUT_OF_GAS)
// 4. But deserialization work was already performed

// To reproduce:
// 1. Create 1,310 minimal modules using empty_module() pattern
// 2. Serialize each to bytecode (~50 bytes each)
// 3. Submit transaction with gas limit of 500,000 units
// 4. Observe: native_request_publish succeeds (charges ~460K)
// 5. Observe: deserialize_module_bundle executes (1,310 deserializations)
// 6. Observe: charge_dependency fails (needs ~100M units)
// 7. Result: Transaction aborts but expensive CPU work was performed

// The attack can be repeated across multiple transactions to sustain
// validator CPU exhaustion with minimal cost to the attacker.
```

## Notes

The vulnerability is constrained by the `max_transaction_size_in_bytes` limit of 64KB, which limits the attack to approximately 1,310 modules per transaction (assuming 50 bytes per minimal module). However, this still provides a 217x amplification factor, making it a highly effective DoS vector against validator nodes.

### Citations

**File:** types/src/transaction/module.rs (L42-46)
```rust
    pub fn new(codes: Vec<Vec<u8>>) -> ModuleBundle {
        ModuleBundle {
            codes: codes.into_iter().map(Module::new).collect(),
        }
    }
```

**File:** aptos-move/framework/src/natives/code.rs (L292-301)
```rust
    context.charge(CODE_REQUEST_PUBLISH_BASE)?;

    let policy = safely_pop_arg!(args, u8);
    let mut code = vec![];
    for module in safely_pop_arg!(args, Vec<Value>) {
        let module_code = module.value_as::<Vec<u8>>()?;

        context.charge(CODE_REQUEST_PUBLISH_PER_BYTE * NumBytes::new(module_code.len() as u64))?;
        code.push(module_code);
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/aptos_framework.rs (L320-321)
```rust
        [code_request_publish_base: InternalGas, "code.request_publish.base", 1838],
        [code_request_publish_per_byte: InternalGasPerByte, "code.request_publish.per_byte", 7],
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1444-1461)
```rust
    fn deserialize_module_bundle(&self, modules: &ModuleBundle) -> VMResult<Vec<CompiledModule>> {
        let mut result = vec![];
        for module_blob in modules.iter() {
            match CompiledModule::deserialize_with_config(
                module_blob.code(),
                self.deserializer_config(),
            ) {
                Ok(module) => {
                    result.push(module);
                },
                Err(_err) => {
                    return Err(PartialVMError::new(StatusCode::CODE_DESERIALIZATION_ERROR)
                        .finish(Location::Undefined))
                },
            }
        }
        Ok(result)
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1491-1493)
```rust
        let modules = self.deserialize_module_bundle(&bundle)?;
        let modules: &Vec<CompiledModule> =
            traversal_context.referenced_module_bundles.alloc(modules);
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1526-1536)
```rust
            for (module, blob) in modules.iter().zip(bundle.iter()) {
                let addr = module.self_addr();
                let name = module.self_name();
                gas_meter
                    .charge_dependency(
                        DependencyKind::New,
                        addr,
                        name,
                        NumBytes::new(blob.code().len() as u64),
                    )
                    .map_err(|err| err.finish(Location::Undefined))?;
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L241-248)
```rust
            dependency_per_module: InternalGas,
            { RELEASE_V1_10.. => "dependency_per_module" },
            74460,
        ],
        [
            dependency_per_byte: InternalGasPerByte,
            { RELEASE_V1_10.. => "dependency_per_byte" },
            42,
```

**File:** aptos-move/aptos-gas-meter/src/meter.rs (L57-76)
```rust
    fn charge_dependency(
        &mut self,
        _kind: DependencyKind,
        addr: &AccountAddress,
        _name: &IdentStr,
        size: NumBytes,
    ) -> PartialVMResult<()> {
        // Modules under special addresses are considered system modules that should always
        // be loaded, and are therefore excluded from gas charging.
        //
        // TODO: 0xA550C18 is a legacy system address we used, but it is currently not covered by
        //       `.is_special()`. We should double check if this address still needs special
        //       treatment.
        if self.feature_version() >= 15 && !addr.is_special() {
            self.algebra
                .charge_execution(DEPENDENCY_PER_MODULE + DEPENDENCY_PER_BYTE * size)?;
            self.algebra.count_dependency(size)?;
        }
        Ok(())
    }
```

**File:** third_party/move/move-binary-format/src/file_format.rs (L3677-3704)
```rust
pub fn empty_module() -> CompiledModule {
    CompiledModule {
        version: file_format_common::VERSION_MAX,
        module_handles: vec![ModuleHandle {
            address: AddressIdentifierIndex(0),
            name: IdentifierIndex(0),
        }],
        self_module_handle_idx: ModuleHandleIndex(0),
        identifiers: vec![self_module_name().to_owned()],
        address_identifiers: vec![AccountAddress::ZERO],
        constant_pool: vec![],
        metadata: vec![],
        function_defs: vec![],
        struct_defs: vec![],
        struct_handles: vec![],
        function_handles: vec![],
        field_handles: vec![],
        friend_decls: vec![],
        struct_def_instantiations: vec![],
        function_instantiations: vec![],
        field_instantiations: vec![],
        signatures: vec![Signature(vec![])],
        struct_variant_handles: vec![],
        struct_variant_instantiations: vec![],
        variant_field_handles: vec![],
        variant_field_instantiations: vec![],
    }
}
```
