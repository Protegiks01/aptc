# Audit Report

## Title
Supply Chain Attack: Lack of Runtime Integrity Verification for Native Function Table

## Summary
The `aptos_debug_natives()` function and the broader native function registration system lack runtime integrity verification, allowing compromised dependencies to inject malicious native functions without detection. While `assert_no_test_natives()` validates a hardcoded exclusion list, it does not verify the completeness or integrity of the entire natives table, creating a supply chain vulnerability.

## Finding Description

The native function table in Aptos is constructed by chaining natives from three internal dependency crates: [1](#0-0) 

Each dependency (aptos-move-stdlib, aptos-framework, aptos-table-natives) exports an `all_natives()` or `table_natives()` function that registers its native functions. The function `aptos_debug_natives()` calls this chain with the testing feature enabled: [2](#0-1) 

The only runtime validation is `assert_no_test_natives()`, which checks for specific test-only function names: [3](#0-2) 

**The Vulnerability:**

1. **No Allowlist Validation**: There is no verification that the natives table contains only expected functions. The system accepts any natives registered by dependencies.

2. **No Integrity Checking**: The natives table is not hashed, signed, or verified against a known-good baseline at runtime.

3. **Limited Test Native Detection**: `assert_no_test_natives()` only checks for 9 specific function names, not the entire table's integrity.

4. **Supply Chain Attack Surface**: A compromised dependency (aptos-framework, aptos-move-stdlib, or aptos-table-natives) could:
   - Inject additional malicious natives under new names (bypassing the exclusion list)
   - Modify existing native implementations to include backdoors
   - Register natives that manipulate VM state, consensus, or cryptographic operations

The NativeFunctions constructor only checks for duplicate names, not malicious content: [4](#0-3) 

**Attack Scenario:**

An attacker compromises the aptos-framework crate (e.g., via compromised maintainer credentials, malicious CI/CD injection, or dependency confusion). The compromised version modifies its `all_natives()` function: [5](#0-4) 

The attacker adds a malicious native module that isn't in the test exclusion list, such as:
- `add_natives_from_module!("system_internal", malicious::make_all(builder));`

This injected native could:
- Leak private keys or sensitive state
- Manipulate consensus messages
- Cause deterministic execution violations (different validators produce different results)
- Bypass gas metering or resource limits

**Which Invariants Are Broken:**

1. **Deterministic Execution**: Malicious natives could behave non-deterministically or differently across nodes, breaking consensus.
2. **Move VM Safety**: Injected natives could bypass gas limits, memory constraints, or access control.
3. **Cryptographic Correctness**: Compromised cryptography natives could weaken signature verification or introduce backdoors.

## Impact Explanation

This qualifies as **MEDIUM severity** per Aptos bug bounty criteria:

- **State inconsistencies requiring intervention**: Malicious natives could cause subtle state corruption that diverges across validators, requiring manual intervention to resolve.
- **Limited funds loss or manipulation**: Depending on the native's capabilities, it could enable limited asset manipulation (though constrained by Rust's safety guarantees).

The impact is limited from Critical because:
- Requires compromising an internal Aptos crate (difficult but not impossible)
- Build-time protections exist (Cargo.lock checksums)
- Would likely be detected during code review of dependency updates
- Rust's safety features constrain what malicious code can do

However, the impact is significant because:
- Native functions have privileged VM access
- No runtime detection mechanism exists
- Could affect all nodes running the compromised version
- Cryptography and consensus-related natives have high security sensitivity

## Likelihood Explanation

**Likelihood: Low-to-Medium**

**Factors Increasing Likelihood:**
- Supply chain attacks on open-source dependencies are increasingly common
- Compromised maintainer accounts occur regularly in the ecosystem
- Dependency confusion attacks are a known threat vector
- No runtime detection would flag the malicious natives

**Factors Decreasing Likelihood:**
- Aptos dependencies are internal (maintained by the Aptos team)
- Cargo.lock provides build-time integrity checking
- Code review processes should catch obvious malicious changes
- Multi-signature release processes may be in place

**Realistic Attack Paths:**
1. Compromised crates.io maintainer account for aptos-framework
2. Malicious insider with commit access (though out of scope per trust model)
3. Compromised CI/CD pipeline injecting code during build
4. Dependency confusion with malicious lookalike crate

## Recommendation

Implement runtime integrity verification for the native function table:

**1. Create a manifest of expected natives:**
```rust
// In aptos-vm/src/natives.rs
const EXPECTED_NATIVES: &[(&str, &str, &str)] = &[
    ("0x1", "vector", "length"),
    ("0x1", "vector", "borrow"),
    // ... complete list of all expected natives
];
```

**2. Add integrity verification function:**
```rust
pub fn verify_natives_integrity(natives: &NativeFunctionTable) -> Result<(), String> {
    let mut found_natives: HashSet<(String, String, String)> = HashSet::new();
    
    for (addr, module, func, _) in natives {
        let entry = (addr.to_hex_literal(), module.to_string(), func.to_string());
        found_natives.insert(entry);
    }
    
    // Check for unexpected natives (not in allowlist)
    for (addr, module, func, _) in natives {
        let key = (addr.to_hex_literal(), module.to_string(), func.to_string());
        if !EXPECTED_NATIVES.contains(&(key.0.as_str(), key.1.as_str(), key.2.as_str())) {
            return Err(format!("Unexpected native function: {}::{}::{}", key.0, key.1, key.2));
        }
    }
    
    // Check for missing expected natives
    for expected in EXPECTED_NATIVES {
        let key = (expected.0.to_string(), expected.1.to_string(), expected.2.to_string());
        if !found_natives.contains(&key) {
            return Err(format!("Missing expected native: {}::{}::{}", key.0, key.1, key.2));
        }
    }
    
    Ok(())
}
```

**3. Call verification in production:** [6](#0-5) 

Add verification after the existing check:
```rust
fn main() {
    // Check that we are not including any Move test natives
    aptos_vm::natives::assert_no_test_natives(ERROR_MSG_BAD_FEATURE_FLAGS);
    
    // NEW: Verify natives table integrity
    let natives = aptos_vm::natives::aptos_natives(/*...*/);
    aptos_vm::natives::verify_natives_integrity(&natives)
        .expect("Native function table integrity check failed");
    
    // Start the node
    AptosNodeArgs::parse().run()
}
```

**4. Alternative/Additional: Hash-based verification:**
- Compute SHA-256 hash of the serialized natives table at build time
- Embed the hash in the binary as a constant
- Verify the runtime hash matches the build-time hash

**5. Dependency pinning and audit:**
- Use `cargo-deny` to enforce approved dependencies
- Implement automated dependency auditing in CI/CD
- Require code signing for internal crate releases
- Use Sigstore/cosign for crate integrity verification

## Proof of Concept

**Demonstrating the vulnerability requires modifying a dependency, which cannot be done in a single PoC file. However, here's a conceptual demonstration:**

**Step 1: Create malicious native module (in compromised aptos-framework):**

```rust
// In hypothetical aptos-move/framework/src/natives/backdoor.rs
use aptos_native_interface::{SafeNativeBuilder, SafeNativeContext, SafeNativeResult};
use move_vm_types::{loaded_data::runtime_types::Type, values::Value};
use smallvec::{smallvec, SmallVec};
use std::collections::VecDeque;

pub fn make_all(builder: &SafeNativeBuilder) -> impl Iterator<Item = (String, move_vm_runtime::native_functions::NativeFunction)> {
    builder.make_named_natives([
        ("leak_validator_keys", native_leak_keys as _),
    ])
}

fn native_leak_keys(
    _context: &mut SafeNativeContext,
    _ty_args: &[Type],
    _args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    // Malicious behavior: leak sensitive data, manipulate state, etc.
    // This would bypass all Move-level security
    eprintln!("BACKDOOR: Leaking validator keys...");
    Ok(smallvec![])
}
```

**Step 2: Register in all_natives() (in compromised aptos-framework/src/natives/mod.rs):**

```rust
// After line 103, add:
add_natives_from_module!("system", backdoor::make_all(builder));
```

**Step 3: Build and run - the malicious native passes all checks:**

The native "system::leak_validator_keys" is not in the test exclusion list, so `assert_no_test_natives()` passes. No other runtime verification exists.

**Verification that current checks are insufficient:**

Create a test that attempts to register an unexpected native and verify it passes:

```rust
#[test]
fn test_unexpected_native_not_detected() {
    use aptos_vm::natives::aptos_natives;
    
    let natives = aptos_natives(
        LATEST_GAS_FEATURE_VERSION,
        NativeGasParameters::zeros(),
        MiscGasParameters::zeros(),
        TimedFeaturesBuilder::enable_all().build(),
        Features::default()
    );
    
    // This should fail if proper integrity checking existed
    // but currently passes
    let has_unexpected = natives.iter().any(|(_, module, func, _)| {
        module.as_str() == "hypothetical_malicious_module"
    });
    
    // Currently: would not detect injected natives
    assert!(!has_unexpected, "Should not contain unexpected natives");
}
```

**Notes**

This vulnerability exists because the native function registration system trusts all internal dependencies implicitly without runtime verification. While build-time protections (Cargo.lock checksums) and code review provide some defense, they cannot detect a compromised published crate or sophisticated supply chain attack. The lack of an allowlist or integrity hash for the natives table means malicious natives that avoid the hardcoded test exclusion list would execute without detection.

The severity is MEDIUM rather than HIGH/CRITICAL because:
1. The attack requires compromising internal Aptos crates (difficult but possible)
2. Rust's safety guarantees limit the scope of malicious behavior
3. The vulnerability would likely be caught during code review of dependency updates

However, it represents a real architectural weakness that should be addressed to improve supply chain security, especially given the critical nature of native functions in the Move VM execution environment.

### Citations

**File:** aptos-move/aptos-vm-environment/src/natives.rs (L10-46)
```rust
pub fn aptos_natives_with_builder(
    builder: &mut SafeNativeBuilder,
    inject_create_signer_for_gov_sim: bool,
) -> NativeFunctionTable {
    let vector_bytecode_instruction_methods = HashSet::from([
        "empty",
        "length",
        "borrow",
        "borrow_mut",
        "push_back",
        "pop_back",
        "destroy_empty",
        "swap",
    ]);

    #[allow(unreachable_code)]
    aptos_move_stdlib::natives::all_natives(CORE_CODE_ADDRESS, builder)
        .into_iter()
        .filter(|(_, name, func_name, _)|
            if name.as_str() == "vector" && vector_bytecode_instruction_methods.contains(func_name.as_str()) {
                println!("ERROR: Tried to register as native a vector bytecode_instruction method {}, skipping.", func_name.as_str());
                false
            } else {
                true
            }
        )
        .chain(aptos_framework::natives::all_natives(
            CORE_CODE_ADDRESS,
            builder,
            inject_create_signer_for_gov_sim,
        ))
        .chain(aptos_table_natives::table_natives(
            CORE_CODE_ADDRESS,
            builder,
        ))
        .collect()
}
```

**File:** crates/aptos/src/move_tool/aptos_debug_natives.rs (L20-36)
```rust
pub fn aptos_debug_natives(
    native_gas_parameters: NativeGasParameters,
    misc_gas_params: MiscGasParameters,
) -> NativeFunctionTable {
    // As a side effect, also configure for unit testing
    natives::configure_for_unit_test();
    configure_extended_checks_for_unit_test();
    // Return all natives -- build with the 'testing' feature, therefore containing
    // debug related functions.
    natives::aptos_natives(
        LATEST_GAS_FEATURE_VERSION,
        native_gas_parameters,
        misc_gas_params,
        TimedFeaturesBuilder::enable_all().build(),
        Features::default(),
    )
}
```

**File:** aptos-move/aptos-vm/src/natives.rs (L161-191)
```rust
pub fn assert_no_test_natives(err_msg: &str) {
    assert!(
        aptos_natives(
            LATEST_GAS_FEATURE_VERSION,
            NativeGasParameters::zeros(),
            MiscGasParameters::zeros(),
            TimedFeaturesBuilder::enable_all().build(),
            Features::default()
        )
        .into_iter()
        .all(|(_, module_name, func_name, _)| {
            !(module_name.as_str() == "unit_test"
                && func_name.as_str() == "create_signers_for_testing"
                || module_name.as_str() == "ed25519"
                    && func_name.as_str() == "generate_keys_internal"
                || module_name.as_str() == "ed25519" && func_name.as_str() == "sign_internal"
                || module_name.as_str() == "multi_ed25519"
                    && func_name.as_str() == "generate_keys_internal"
                || module_name.as_str() == "multi_ed25519" && func_name.as_str() == "sign_internal"
                || module_name.as_str() == "bls12381"
                    && func_name.as_str() == "generate_keys_internal"
                || module_name.as_str() == "bls12381" && func_name.as_str() == "sign_internal"
                || module_name.as_str() == "bls12381"
                    && func_name.as_str() == "generate_proof_of_possession_internal"
                || module_name.as_str() == "event"
                    && func_name.as_str() == "emitted_events_internal")
        }),
        "{}",
        err_msg
    )
}
```

**File:** third_party/move/move-vm/runtime/src/native_functions.rs (L97-113)
```rust
    pub fn new<I>(natives: I) -> PartialVMResult<Self>
    where
        I: IntoIterator<Item = (AccountAddress, Identifier, Identifier, NativeFunction)>,
    {
        let mut map = HashMap::new();
        for (addr, module_name, func_name, func) in natives.into_iter() {
            let modules = map.entry(addr).or_insert_with(HashMap::new);
            let funcs = modules
                .entry(module_name.into_string())
                .or_insert_with(HashMap::new);

            if funcs.insert(func_name.into_string(), func).is_some() {
                return Err(PartialVMError::new(StatusCode::DUPLICATE_NATIVE_FUNCTION));
            }
        }
        Ok(Self(map))
    }
```

**File:** aptos-move/framework/src/natives/mod.rs (L41-116)
```rust
pub fn all_natives(
    framework_addr: AccountAddress,
    builder: &SafeNativeBuilder,
    inject_create_signer_for_gov_sim: bool,
) -> NativeFunctionTable {
    let mut natives = vec![];

    macro_rules! add_natives_from_module {
        ($module_name:expr, $natives:expr) => {
            natives.extend(
                $natives.map(|(func_name, func)| ($module_name.to_string(), func_name, func)),
            );
        };
    }

    add_natives_from_module!("account", account::make_all(builder));
    add_natives_from_module!("create_signer", create_signer::make_all(builder));
    add_natives_from_module!("ed25519", ed25519::make_all(builder));
    add_natives_from_module!("crypto_algebra", cryptography::algebra::make_all(builder));
    add_natives_from_module!("genesis", create_signer::make_all(builder));
    add_natives_from_module!("multi_ed25519", multi_ed25519::make_all(builder));
    add_natives_from_module!("bls12381", cryptography::bls12381::make_all(builder));
    add_natives_from_module!("secp256k1", cryptography::secp256k1::make_all(builder));
    add_natives_from_module!("aptos_hash", hash::make_all(builder));
    add_natives_from_module!(
        "ristretto255",
        cryptography::ristretto255::make_all(builder)
    );
    add_natives_from_module!("type_info", type_info::make_all(builder));
    add_natives_from_module!("util", util::make_all(builder));
    add_natives_from_module!("from_bcs", util::make_all(builder));
    add_natives_from_module!("randomness", randomness::make_all(builder));
    add_natives_from_module!(
        "ristretto255_bulletproofs",
        cryptography::bulletproofs::make_all(builder)
    );
    add_natives_from_module!(
        "transaction_context",
        transaction_context::make_all(builder)
    );
    add_natives_from_module!("code", code::make_all(builder));
    add_natives_from_module!("event", event::make_all(builder));
    add_natives_from_module!("state_storage", state_storage::make_all(builder));
    add_natives_from_module!("aggregator", aggregator::make_all(builder));
    add_natives_from_module!("aggregator_factory", aggregator_factory::make_all(builder));
    add_natives_from_module!("aggregator_v2", aggregator_v2::make_all(builder));
    add_natives_from_module!("object", object::make_all(builder));
    add_natives_from_module!("debug", debug::make_all(builder));
    add_natives_from_module!("string_utils", string_utils::make_all(builder));
    add_natives_from_module!("consensus_config", consensus_config::make_all(builder));
    add_natives_from_module!("function_info", function_info::make_all(builder));
    add_natives_from_module!(
        "dispatchable_fungible_asset",
        dispatchable_fungible_asset::make_all(builder)
    );
    add_natives_from_module!(
        "permissioned_signer",
        permissioned_signer::make_all(builder)
    );
    add_natives_from_module!(
        "account_abstraction",
        account_abstraction::make_all(builder)
    );

    if inject_create_signer_for_gov_sim {
        add_natives_from_module!(
            "aptos_governance",
            builder.make_named_natives([(
                "create_signer",
                create_signer::native_create_signer as RawSafeNative
            )])
        );
    }

    make_table_from_iter(framework_addr, natives)
}
```

**File:** aptos-node/src/main.rs (L21-27)
```rust
fn main() {
    // Check that we are not including any Move test natives
    aptos_vm::natives::assert_no_test_natives(ERROR_MSG_BAD_FEATURE_FLAGS);

    // Start the node
    AptosNodeArgs::parse().run()
}
```
