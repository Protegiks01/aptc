# Audit Report

## Title
Infinite Loop in Indexer Stream Coordinator When Processing Genesis Transaction (Version 0)

## Summary
The `IndexerStreamCoordinator` uses `0` as a sentinel value for an uninitialized `highest_known_version`, which creates an ambiguity with the legitimate genesis transaction at version 0. This causes an infinite loop in `ensure_highest_known_version()` when a client requests to stream from version 0 while the ledger is at genesis, resulting in a denial of service for the indexer gRPC API.

## Finding Description
The vulnerability exists in the initialization and validation logic of `IndexerStreamCoordinator`. The `highest_known_version` field is initialized to `0` to represent an uninitialized state [1](#0-0) , but `0` is also the valid version number for the genesis transaction in Aptos [2](#0-1) .

The `ensure_highest_known_version()` function contains a loop that continues while `highest_known_version == 0 || current_version > highest_known_version` [3](#0-2) . When a client requests to stream from version 0 and the blockchain is at genesis (version 0), the following occurs:

1. Client sends a gRPC request with `starting_version = Some(0)` [4](#0-3) 
2. `current_version` is set to `0` [5](#0-4) 
3. `highest_known_version` is initialized to `0` [1](#0-0) 
4. The loop executes and calls `set_highest_known_version()` which queries the ledger [6](#0-5) 
5. The ledger returns version `0` (genesis), so `highest_known_version` is set to `0`
6. The loop condition `highest_known_version == 0` evaluates to `true`, continuing the infinite loop
7. The indexer hangs indefinitely, unable to process any transactions

The root cause is the use of `0` as both a sentinel value ("not yet fetched") and a valid data value (genesis version), creating an indistinguishable state.

## Impact Explanation
This vulnerability causes a **denial of service** on the indexer gRPC API service, qualifying as **High Severity** under the Aptos bug bounty program's category of "API crashes" [7](#0-6) .

When triggered, the indexer service becomes completely unresponsive for that stream request, consuming CPU resources in a busy loop while providing no data to clients. Since the indexer is critical infrastructure for applications built on Aptos (enabling event queries, transaction history, and state tracking), this effectively breaks the data availability layer for the ecosystem during the critical genesis phase or in testing environments.

## Likelihood Explanation
**Likelihood: Low-Medium**

This issue occurs specifically when:
1. A client requests to stream from version 0 (genesis)
2. The blockchain is at genesis state (only version 0 exists)

This scenario is realistic in:
- **Test networks** during initialization
- **Local development environments** at startup  
- **New production chains** in the brief window immediately after genesis
- **Chain resets** or fresh deployments

While production mainnet chains quickly advance beyond genesis, development and testing environments frequently encounter this state. The same vulnerable pattern exists in another indexer component [8](#0-7) , indicating this is a systemic issue.

## Recommendation
Replace the sentinel value approach with an explicit initialization flag. Use `Option<u64>` for `highest_known_version` to distinguish between uninitialized and initialized states:

```rust
pub struct IndexerStreamCoordinator {
    // ... other fields ...
    pub highest_known_version: Option<u64>, // None = uninitialized, Some(v) = initialized to version v
    // ... other fields ...
}

impl IndexerStreamCoordinator {
    pub fn new(...) -> Self {
        Self {
            // ... other fields ...
            highest_known_version: None, // Explicitly uninitialized
            // ... other fields ...
        }
    }

    async fn ensure_highest_known_version(&mut self) -> bool {
        let mut empty_loops = 0;
        while self.highest_known_version.is_none() || 
              self.current_version > self.highest_known_version.unwrap_or(0) {
            // ... rest of loop logic ...
        }
        true
    }
}
```

This eliminates the ambiguity between "not yet fetched" and "version 0".

## Proof of Concept

**Rust Reproduction Steps:**

1. Initialize a fresh Aptos node at genesis (only version 0 exists)
2. Start the indexer-grpc-fullnode service
3. Send a gRPC `GetTransactionsFromNodeRequest` with `starting_version = Some(0)`
4. Observe the indexer thread spinning in `ensure_highest_known_version()` indefinitely
5. Monitor CPU usage - one core will be at 100% utilization
6. The client will never receive any transactions

**Expected Behavior:** The indexer should process version 0 and send it to the client.

**Actual Behavior:** Infinite loop, service hang, no data transmitted.

The issue can be verified by adding debug logging to the loop at line 552 and observing the loop counter incrementing indefinitely with `highest_known_version` remaining at `0`.

---

## Notes
This is a **sentinel value confusion** vulnerability where `0` serves dual purposes. While the indexer is not part of core consensus, it provides critical data infrastructure for the Aptos ecosystem. The bug prevents legitimate use of the indexer service during genesis, requiring manual intervention (service restart after blockchain advances past version 0) or code fixes to resolve.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L80-80)
```rust
            current_version: request_start_version,
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L85-85)
```rust
            highest_known_version: 0,
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L532-546)
```rust
    pub fn set_highest_known_version(&mut self) -> anyhow::Result<()> {
        let info = self.context.get_latest_ledger_info_wrapped()?;
        let latest_table_info_version = self
            .context
            .indexer_reader
            .as_ref()
            .expect("Table info reader not set")
            .get_latest_table_info_ledger_version()?
            .expect("Table info ledger version not set");

        self.highest_known_version =
            std::cmp::min(info.ledger_version.0, latest_table_info_version);

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L552-552)
```rust
        while self.highest_known_version == 0 || self.current_version > self.highest_known_version {
```

**File:** types/src/block_info.rs (L21-21)
```rust
pub const GENESIS_VERSION: Version = 0;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L56-58)
```rust
#[tonic::async_trait]
impl FullnodeData for FullnodeDataService {
    type GetTransactionsFromNodeStream = FullnodeResponseStream;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L73-78)
```rust
        let starting_version = match r.starting_version {
            Some(version) => version,
            // Live mode unavailable for FullnodeDataService
            // Enable use_data_service_interface in config to use LocalnetDataService instead
            None => return Err(Status::invalid_argument("Starting version must be set")),
        };
```

**File:** crates/indexer/src/indexer/fetcher.rs (L56-56)
```rust
        while self.highest_known_version == 0 || self.current_version > self.highest_known_version {
```
