# Audit Report

## Title
Missing Validator Signature Verification in State Snapshot Restoration Allows Arbitrary State Injection

## Summary
The state snapshot restore process in `StateSnapshotRestoreController::run_impl()` fails to verify validator signatures on `LedgerInfoWithSignatures` when `epoch_history` is `None`. This allows an attacker providing a malicious backup to inject arbitrary state into a node's database without proper cryptographic authentication.

## Finding Description

The vulnerability exists in the state snapshot restoration logic where signature verification is conditionally performed: [1](#0-0) 

The critical issue is that line 127's `verify()` call only validates the **mathematical correctness** of the Merkle accumulator proof, not the **authenticity** of the `LedgerInfoWithSignatures`: [2](#0-1) 

This delegates to: [3](#0-2) 

Which only verifies that:
1. The transaction version doesn't exceed the LedgerInfo version
2. The TransactionAccumulatorProof mathematically connects the TransactionInfo hash to the accumulator root

**Critically missing:** Verification that the LedgerInfo was actually signed by a quorum of validators.

Signature verification only occurs if `epoch_history` is provided: [4](#0-3) 

However, in one-shot state snapshot restores via db-tool, `epoch_history` is **hardcoded to `None`**: [5](#0-4) 

### Attack Scenario

An attacker can craft a malicious backup containing:

1. **Malicious TransactionInfo** with an arbitrary `state_checkpoint_hash` pointing to attacker-controlled state
2. **Self-signed LedgerInfo** with `transaction_accumulator_hash` matching an accumulator containing the malicious TransactionInfo
3. **Empty or fake signatures** in `LedgerInfoWithSignatures` (never verified)
4. **Valid TransactionAccumulatorProof** mathematically connecting items 1 and 2

The verification at line 127 passes because the Merkle proof is mathematically valid, but no validator signatures are checked. The attacker's malicious `state_root_hash` is extracted and trusted: [6](#0-5) 

This breaks the **State Consistency** invariant: state transitions must be verifiable via properly authenticated proofs, not just mathematically valid ones.

## Impact Explanation

**Severity: HIGH**

This vulnerability allows:
- **Database corruption** with arbitrary attacker-controlled state
- **Node compromise** if the corrupted state affects consensus or validation logic
- **Potential consensus failures** if a validator node restores from malicious backup
- **State inconsistency** requiring full database wipe and restore

Impact assessment:
- Meets **High Severity** criteria: "Significant protocol violations" and "State inconsistencies requiring intervention"
- Approaches **Medium Severity**: "State inconsistencies requiring intervention"
- Does NOT meet **Critical** because it requires victim to use an untrusted backup source

The attack doesn't directly enable fund theft but can cause significant operational damage and potential consensus issues.

## Likelihood Explanation

**Likelihood: MEDIUM**

The attack is realistic but has barriers:

**Attack Requirements:**
- Victim must use one-shot restore command: `aptos-db-tool restore one-off state-snapshot`
- Attacker must convince victim to use their malicious backup (via compromised storage, MITM, or fake backup service)
- No trusted waypoints configured (optional `--trust-waypoint` flag not used)

**Likelihood Factors:**
- Node operators do use db-tool for disaster recovery and debugging
- The tool provides no warnings that signature verification is skipped
- The production `BootstrapDB` flow is safe (restores epoch history first), but operators may use one-off commands
- Documentation mentions this behavior but security implications aren't prominent: [7](#0-6) 

## Recommendation

**Enforce signature verification or provide explicit warnings:**

**Option 1 - Mandatory Waypoint (Preferred):**
Require at least one trusted waypoint for state snapshot restores. Modify `StateSnapshotRestoreController::new()` to fail if neither `epoch_history` nor trusted waypoints are provided.

**Option 2 - Explicit Warning:**
If backward compatibility requires allowing unverified restores, add prominent warnings:

```rust
if self.epoch_history.is_none() {
    warn!(
        "⚠️  SECURITY WARNING: Restoring state snapshot WITHOUT validator signature verification. \
        Only use this with backups from trusted sources. For production use, restore epoch \
        history first or use --trust-waypoint flag."
    );
}
```

**Option 3 - Verify Against Waypoints:**
Even without epoch_history, verify the LedgerInfo against trusted waypoints if configured:

```rust
if let Some(epoch_history) = self.epoch_history.as_ref() {
    epoch_history.verify_ledger_info(&li)?;
} else if !self.trusted_waypoints.is_empty() {
    // Verify against trusted waypoints even without epoch history
    if let Some(trusted_wp) = self.trusted_waypoints.get(&li.ledger_info().version()) {
        let li_wp = Waypoint::new_any(li.ledger_info());
        ensure!(
            li_wp == *trusted_wp,
            "LedgerInfo doesn't match trusted waypoint at version {}", 
            li.ledger_info().version()
        );
    }
} else {
    warn!("Restoring without signature or waypoint verification - UNSAFE");
}
```

## Proof of Concept

**Setup:**
1. Create malicious backup files with crafted LedgerInfo containing arbitrary state_checkpoint_hash
2. Create mathematically valid but unsigned TransactionInfoWithProof
3. Package as state snapshot backup with manifest

**Execution:**
```bash
# Victim runs one-off restore without epoch history or waypoints
aptos-db-tool restore one-off state-snapshot \
  --state-manifest /attacker/malicious_manifest.json \
  --target-db-dir /victim/db \
  --concurrent-downloads 8
```

**Expected Result:**
- Restore succeeds despite fake signatures
- Database contains attacker-controlled state
- Node will fail to sync properly with honest peers

**Rust Test Outline:**
```rust
#[test]
fn test_state_restore_accepts_unsigned_ledger_info() {
    // Create TransactionInfo with arbitrary state_checkpoint_hash
    let malicious_state_root = HashValue::random();
    let txn_info = TransactionInfo::new(..., Some(malicious_state_root), ...);
    
    // Build valid accumulator with this TransactionInfo
    let accumulator = InMemoryTransactionAccumulator::new(...);
    let accumulator = accumulator.append(&[txn_info.hash()]);
    
    // Create LedgerInfo pointing to this accumulator (no real signatures)
    let ledger_info = LedgerInfo::new(..., accumulator.root_hash());
    let ledger_info_with_sigs = LedgerInfoWithSignatures::new(
        ledger_info,
        AggregateSignature::empty() // FAKE SIGNATURE
    );
    
    // Create valid proof
    let proof = accumulator.get_proof(0);
    let txn_info_with_proof = TransactionInfoWithProof::new(proof, txn_info);
    
    // Restore should FAIL but currently SUCCEEDS without epoch_history
    StateSnapshotRestoreController::new(..., None /* epoch_history */)
        .run()
        .await
        .expect("Restore succeeded with fake signatures!");
}
```

## Notes

This vulnerability demonstrates that "mathematically valid proof" ≠ "authenticated proof". While the Merkle accumulator verification is cryptographically sound, the absence of signature verification on the root of trust (LedgerInfo) creates a critical authentication bypass. The issue is particularly insidious because the mathematical proof verification provides false confidence in the data's authenticity.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L123-139)
```rust
        let manifest: StateSnapshotBackup =
            self.storage.load_json_file(&self.manifest_handle).await?;
        let (txn_info_with_proof, li): (TransactionInfoWithProof, LedgerInfoWithSignatures) =
            self.storage.load_bcs_file(&manifest.proof).await?;
        txn_info_with_proof.verify(li.ledger_info(), manifest.version)?;
        let state_root_hash = txn_info_with_proof
            .transaction_info()
            .ensure_state_checkpoint_hash()?;
        ensure!(
            state_root_hash == manifest.root_hash,
            "Root hash mismatch with that in proof. root hash: {}, expected: {}",
            manifest.root_hash,
            state_root_hash,
        );
        if let Some(epoch_history) = self.epoch_history.as_ref() {
            epoch_history.verify_ledger_info(&li)?;
        }
```

**File:** types/src/proof/definition.rs (L866-874)
```rust
    pub fn verify(&self, ledger_info: &LedgerInfo, transaction_version: Version) -> Result<()> {
        verify_transaction_info(
            ledger_info,
            transaction_version,
            &self.transaction_info,
            &self.ledger_info_to_transaction_info_proof,
        )?;
        Ok(())
    }
```

**File:** types/src/proof/mod.rs (L40-61)
```rust
fn verify_transaction_info(
    ledger_info: &LedgerInfo,
    transaction_version: Version,
    transaction_info: &TransactionInfo,
    ledger_info_to_transaction_info_proof: &TransactionAccumulatorProof,
) -> Result<()> {
    ensure!(
        transaction_version <= ledger_info.version(),
        "Transaction version {} is newer than LedgerInfo version {}.",
        transaction_version,
        ledger_info.version(),
    );

    let transaction_info_hash = transaction_info.hash();
    ledger_info_to_transaction_info_proof.verify(
        ledger_info.transaction_accumulator_hash(),
        transaction_info_hash,
        transaction_version,
    )?;

    Ok(())
}
```

**File:** storage/db-tool/src/restore.rs (L88-95)
```rust
                        StateSnapshotRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                            None, /* epoch_history */
                        )
                        .run()
                        .await?;
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L342-343)
```rust
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
```
