# Audit Report

## Title
State Inconsistency Between MemoryRatelimitChecker and RedisRatelimitChecker Due to Off-by-One Counter Initialization

## Summary
The `MemoryRatelimitChecker` and `RedisRatelimitChecker` implement rate limiting with incompatible counting logic, causing state inconsistency when both checkers are configured simultaneously. MemoryRatelimitChecker enforces a limit that is effectively one request lower than configured, while RedisRatelimitChecker correctly enforces the configured limit.

## Finding Description

When both `MemoryRatelimitChecker` and `RedisRatelimitChecker` are configured in the same faucet instance (which is supported by the `checker_configs: Vec<CheckerConfig>` design), they maintain inconsistent state due to two implementation differences:

**Difference 1: Initial Counter Value**

MemoryRatelimitChecker initializes request counters to 1 using `get_or_insert_mut(data.source_ip, || 1)`: [1](#0-0) 

RedisRatelimitChecker treats missing keys as 0 via `limit_value.unwrap_or(0)`: [2](#0-1) 

**Difference 2: Rejection Condition**

MemoryRatelimitChecker uses a `>=` comparison for rejection: [3](#0-2) 

RedisRatelimitChecker uses a `>` comparison for rejection: [2](#0-1) 

**Exploitation Path:**

1. Configure faucet with both checkers using identical `max_requests_per_day=3`
2. Checkers are sorted by cost (Memory=20, Redis=100), so Memory runs first: [4](#0-3) 
3. Request 1: Memory inserts 1, checks (1>=3? No), increments to 2. Redis increments 0→1. Both allow.
4. Request 2: Memory checks (2>=3? No), increments to 3. Redis increments 1→2. Both allow.
5. Request 3: Memory checks (3>=3? Yes), REJECTS. Redis never runs due to early termination: [5](#0-4) 

**Result:** With `max_requests_per_day=3`, MemoryRatelimitChecker allows only 2 successful requests while RedisRatelimitChecker would allow 3. The two checkers maintain divergent state counts for the same IP addresses.

## Impact Explanation

This qualifies as **Medium Severity** per the Aptos Bug Bounty criteria for the following reasons:

1. **State Inconsistency Requiring Intervention**: The checkers maintain contradictory state about the same entities (IP addresses), breaking the assumption that rate limiting is consistent and predictable.

2. **Audit/Monitoring Unreliability**: If Redis is used as the authoritative source for monitoring or auditing faucet usage, it will show fewer requests than actually occurred, leading to incorrect security analysis.

3. **Unpredictable Behavior on Configuration Changes**: If operators switch from using both checkers to only Redis, users would suddenly see their effective limits change (from 2 to 3 requests for max_requests_per_day=3), causing confusion and potential abuse.

4. **Unintended Restrictive Enforcement**: Users expecting to make N requests per day can only make N-1 requests, affecting faucet availability and user experience.

This does not qualify as Critical or High because:
- No funds are lost or stolen
- No consensus or safety violations occur
- The faucet remains available (just more restrictive than intended)

## Likelihood Explanation

**Likelihood: High**

This issue will occur deterministically whenever:
1. Both checkers are configured simultaneously (which is explicitly supported by the architecture)
2. The same `max_requests_per_day` value is used for both
3. Any user makes multiple requests approaching the limit

The configuration system explicitly allows multiple checkers via `Vec<CheckerConfig>`: [6](#0-5) 

The test suite even demonstrates configuring multiple checkers together: [7](#0-6) 

## Recommendation

**Fix Option 1: Align MemoryRatelimitChecker with Redis Semantics (Recommended)**

Modify MemoryRatelimitChecker to initialize counters to 0 and use `>` comparison:

```rust
// Line 77: Initialize to 0 instead of 1
let requests_today = ip_to_requests_today.get_or_insert_mut(data.source_ip, || 0);

// Line 78: Change >= to > for consistency with Redis
if *requests_today > self.max_requests_per_day {
    return Ok(vec![RejectionReason::new(...)]);
}

// Line 87: Increment before checking (move increment before the if)
if !dry_run {
    *requests_today += 1;
}
```

Also fix the `complete()` method to handle missing IPs correctly:
```rust
// Lines 93-102: Only decrement if IP exists
async fn complete(&self, data: CompleteData) -> Result<(), AptosTapError> {
    if data.response_is_500 {
        let mut cache = self.ip_to_requests_today.lock().await;
        if let Some(count) = cache.get_mut(&data.checker_data.source_ip) {
            *count = count.saturating_sub(1);
        }
    }
    Ok(())
}
```

**Fix Option 2: Document the Incompatibility**

If maintaining different semantics is intentional, add clear documentation warning operators not to configure both checkers simultaneously with the same limit values, and explain that Memory's effective limit is N-1 when configured with max_requests_per_day=N.

## Proof of Concept

```rust
#[cfg(test)]
mod test_checker_inconsistency {
    use super::*;
    use std::net::IpAddr;
    use std::sync::Arc;
    
    #[tokio::test]
    async fn test_memory_vs_redis_off_by_one() {
        // Configure both checkers with max_requests_per_day=3
        let memory_checker = MemoryRatelimitChecker::new(
            MemoryRatelimitCheckerConfig {
                max_requests_per_day: 3,
                max_entries_in_map: NonZeroUsize::new(1000).unwrap(),
            }
        );
        
        let test_ip: IpAddr = "1.2.3.4".parse().unwrap();
        let checker_data = CheckerData {
            source_ip: test_ip,
            receiver: AccountAddress::random(),
            headers: Arc::new(HeaderMap::new()),
            time_request_received_secs: get_current_time_secs(),
        };
        
        // Request 1: Should succeed
        let result1 = memory_checker.check(checker_data.clone(), false).await.unwrap();
        assert!(result1.is_empty(), "Request 1 should succeed");
        
        // Request 2: Should succeed  
        let result2 = memory_checker.check(checker_data.clone(), false).await.unwrap();
        assert!(result2.is_empty(), "Request 2 should succeed");
        
        // Request 3: Memory REJECTS but Redis would allow
        let result3 = memory_checker.check(checker_data.clone(), false).await.unwrap();
        assert!(!result3.is_empty(), "Request 3 should be REJECTED by Memory");
        
        // This proves Memory allows only 2 requests with max_requests_per_day=3
        // while Redis would allow 3 requests with the same configuration
    }
}
```

## Notes

The architecture explicitly supports multiple checkers running together, as evidenced by the checker sorting mechanism and the `return_rejections_early` configuration option that determines whether all checkers run or execution stops at the first rejection. The cost-based sorting ensures MemoryRatelimitChecker (cost=20) always runs before RedisRatelimitChecker (cost=100), making this inconsistency deterministic and unavoidable when both are configured.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs (L77-77)
```rust
        let requests_today = ip_to_requests_today.get_or_insert_mut(data.source_ip, || 1);
```

**File:** crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs (L78-78)
```rust
        if *requests_today >= self.max_requests_per_day {
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L207-207)
```rust
        if limit_value.unwrap_or(0) > self.args.max_requests_per_day as i64 {
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L66-67)
```rust
    /// Configs for any Checkers we might want to enable.
    checker_configs: Vec<CheckerConfig>,
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L141-143)
```rust
        // Sort Checkers by cost, where lower numbers is lower cost, and lower
        // cost Checkers are at the start of the vec.
        checkers.sort_by_key(|a| a.cost());
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L577-584)
```rust
    #[tokio::test(flavor = "multi_thread", worker_threads = 2)]
    async fn test_checkers() -> Result<()> {
        init();
        make_ip_blocklist(&[])?;
        make_auth_tokens_file(&["test_token"])?;
        make_referer_blocklist_file(&["https://mysite.com"])?;
        let config_content = include_str!("../../../configs/testing_checkers.yaml");
        let (port, _handle) = start_server(config_content).await?;
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L262-270)
```rust
        let mut rejection_reasons = Vec::new();
        for checker in &self.checkers {
            rejection_reasons.extend(checker.check(checker_data.clone(), dry_run).await.map_err(
                |e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError),
            )?);
            if !rejection_reasons.is_empty() && self.return_rejections_early {
                break;
            }
        }
```
