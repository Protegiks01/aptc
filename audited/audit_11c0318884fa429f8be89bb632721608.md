# Audit Report

## Title
Missing Authentication in Remote Executor Service Allows Unauthorized Execution Commands from Removed Validators

## Summary
The `simple_msg_exchange()` function in the gRPC network service lacks authentication and validator set verification, allowing removed validators or any external attacker to send malicious execution commands to remote executor shards, potentially interfering with consensus block execution.

## Finding Description

The remote executor service uses a gRPC-based network communication layer for distributed block execution across shards. When validators are configured to use remote execution (via `set_remote_addresses()`), block execution during consensus is delegated to remote executor shards. [1](#0-0) 

The `simple_msg_exchange()` function receives network messages but performs **no authentication or authorization checks**:
- No validation that the sender is authenticated
- No verification that the sender is in the current validator set  
- No check that the sender has been removed/kicked out
- Uses plain HTTP without TLS encryption [2](#0-1) 

During consensus block execution, if remote addresses are configured, the system uses the remote sharded block executor: [3](#0-2) 

This calls into the remote executor client which sends `ExecuteBlockCommand` messages over the insecure network: [4](#0-3) 

These messages are received by the coordinator client without any security validation: [5](#0-4) 

And executed by the sharded executor service: [6](#0-5) 

**Attack Scenario:**
1. A validator is removed from the validator set through governance
2. The removed validator still knows the network addresses of executor shards (typically static infrastructure)
3. The removed validator sends crafted `ExecuteBlockCommand` messages to the executor shards
4. Messages are accepted without authentication due to missing validation in `simple_msg_exchange()`
5. The shards execute the malicious commands, potentially causing:
   - Incorrect execution results leading to consensus divergence
   - Resource exhaustion and denial of service
   - Interference with legitimate block execution

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program because it enables:

1. **Validator Node Slowdowns**: Malicious execution commands can exhaust resources on executor shards, degrading performance of the entire validator node during consensus-critical operations.

2. **Significant Protocol Violations**: Breaks the **Deterministic Execution** invariant - if malicious commands cause different execution results across different validators, it violates the requirement that "all validators must produce identical state roots for identical blocks."

3. **Consensus Interference**: During consensus, if execution fails or produces divergent results due to malicious commands, it can cause consensus failures or liveness issues.

The lack of any authentication layer in a consensus-critical component represents a fundamental access control failure that could be exploited by any removed validator or external attacker who discovers the shard addresses.

## Likelihood Explanation

**Likelihood: Medium to High**

**Attacker Requirements:**
- Knowledge of executor shard network addresses (often static/configured infrastructure)
- For removed validators: Previously legitimate access provides knowledge of addresses
- For external attackers: Network reconnaissance or configuration leaks

**Complexity: Low**
- No cryptographic operations required
- Simple gRPC client can send malicious messages
- Plain HTTP makes interception and analysis trivial
- No authentication to bypass

**Triggering Conditions:**
- Remote executor must be configured (via `remote_executor_addresses` option)
- Used in benchmarking and potentially production deployments for performance [7](#0-6) 

The vulnerability is exploitable whenever remote execution is enabled, which may be common in high-performance validator setups.

## Recommendation

Implement multi-layered security for the remote executor service:

**1. Add Mutual TLS Authentication:**
```rust
// In GRPCNetworkMessageServiceServerWrapper::start_async
use tonic::transport::{Identity, ServerTlsConfig};

let identity = Identity::from_pem(cert_pem, key_pem);
let tls_config = ServerTlsConfig::new()
    .identity(identity)
    .client_ca_root(ca_cert_pem);

Server::builder()
    .tls_config(tls_config)?
    .timeout(std::time::Duration::from_millis(rpc_timeout_ms))
    // ... rest of server setup
```

**2. Add Validator Set Verification:**
```rust
// In simple_msg_exchange
async fn simple_msg_exchange(
    &self,
    request: Request<NetworkMessage>,
) -> Result<Response<Empty>, Status> {
    let remote_addr = request.remote_addr();
    
    // Extract peer identity from mTLS certificate
    let peer_identity = request
        .peer_certs()
        .and_then(|certs| extract_validator_id(certs))
        .ok_or_else(|| Status::unauthenticated("No peer certificate"))?;
    
    // Verify peer is in current validator set
    if !self.validator_verifier.is_active_validator(&peer_identity) {
        return Err(Status::permission_denied(
            "Sender not in current validator set"
        ));
    }
    
    // ... rest of processing
}
```

**3. Add Message Type Authorization:**
Implement per-message-type access control to ensure only authorized validators can send specific command types (e.g., `ExecuteBlockCommand` only from coordinator).

**4. Network Isolation:**
Deploy executor shards on private networks accessible only to authorized validator infrastructure, with firewall rules restricting access.

## Proof of Concept

```rust
// poc_unauthorized_executor_command.rs
// Demonstrates sending unauthorized execution commands to remote executor shard

use aptos_secure_net::network_controller::{Message, NetworkController};
use aptos_types::block_executor::partitioner::{SubBlocksForShard, SubBlock};
use std::net::{IpAddr, Ipv4Addr, SocketAddr};
use tokio::runtime::Runtime;

// Simulates a removed validator or external attacker
fn main() {
    let rt = Runtime::new().unwrap();
    
    // Target executor shard address (discovered through reconnaissance)
    let target_shard_addr = SocketAddr::new(
        IpAddr::V4(Ipv4Addr::new(192, 168, 1, 100)), 
        52200
    );
    
    // Attacker's address
    let attacker_addr = SocketAddr::new(
        IpAddr::V4(Ipv4Addr::LOCALHOST), 
        55000
    );
    
    // Create malicious execution command
    let malicious_command = create_malicious_execute_command();
    
    // Create network controller for sending
    let mut network_controller = NetworkController::new(
        "attacker".to_string(),
        attacker_addr,
        5000,
    );
    
    let message_tx = network_controller.create_outbound_channel(
        target_shard_addr,
        "execute_command_0".to_string(),
    );
    
    network_controller.start();
    
    // Send malicious command - NO AUTHENTICATION REQUIRED
    message_tx.send(Message::new(
        bcs::to_bytes(&malicious_command).unwrap()
    )).unwrap();
    
    println!("Malicious command sent to executor shard without authentication!");
    println!("Shard will execute the command as if from legitimate validator");
    
    // The shard will execute this command because simple_msg_exchange()
    // has no validator set verification
}

fn create_malicious_execute_command() -> RemoteExecutionRequest {
    // Create malformed or resource-exhausting execution request
    // that could cause execution failures or DoS
    // Details omitted for security
    unimplemented!("Malicious command construction")
}
```

**Notes:**
- The PoC demonstrates that any network client can send gRPC messages to executor shards
- The `simple_msg_exchange()` function will accept and process these messages without any authentication
- This violates the security assumption that only authorized validators should be able to send execution commands
- When remote execution is enabled in production validators, this creates a direct attack vector for removed validators or external attackers

### Citations

**File:** secure/net/src/grpc_network_service/mod.rs (L93-115)
```rust
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
```

**File:** secure/net/src/grpc_network_service/mod.rs (L124-138)
```rust
    pub fn new(rt: &Runtime, remote_addr: SocketAddr) -> Self {
        Self {
            remote_addr: remote_addr.to_string(),
            remote_channel: rt
                .block_on(async { Self::get_channel(format!("http://{}", remote_addr)).await }),
        }
    }

    async fn get_channel(remote_addr: String) -> NetworkMessageServiceClient<Channel> {
        info!("Trying to connect to remote server at {:?}", remote_addr);
        let conn = tonic::transport::Endpoint::new(remote_addr)
            .unwrap()
            .connect_lazy();
        NetworkMessageServiceClient::new(conn).max_decoding_message_size(MAX_MESSAGE_SIZE)
    }
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L256-275)
```rust
    fn execute_block_sharded<V: VMBlockExecutor>(
        partitioned_txns: PartitionedTransactions,
        state_view: Arc<CachedStateView>,
        onchain_config: BlockExecutorConfigFromOnchain,
    ) -> Result<Vec<TransactionOutput>> {
        if !get_remote_addresses().is_empty() {
            Ok(V::execute_block_sharded(
                &REMOTE_SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        } else {
            Ok(V::execute_block_sharded(
                &SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        }
```

**File:** execution/executor-service/src/remote_executor_client.rs (L180-206)
```rust
    fn execute_block(
        &self,
        state_view: Arc<S>,
        transactions: PartitionedTransactions,
        concurrency_level_per_shard: usize,
        onchain_config: BlockExecutorConfigFromOnchain,
    ) -> Result<ShardedExecutionOutput, VMStatus> {
        trace!("RemoteExecutorClient Sending block to shards");
        self.state_view_service.set_state_view(state_view);
        let (sub_blocks, global_txns) = transactions.into();
        if !global_txns.is_empty() {
            panic!("Global transactions are not supported yet");
        }
        for (shard_id, sub_blocks) in sub_blocks.into_iter().enumerate() {
            let senders = self.command_txs.clone();
            let execution_request = RemoteExecutionRequest::ExecuteBlock(ExecuteBlockCommand {
                sub_blocks,
                concurrency_level: concurrency_level_per_shard,
                onchain_config: onchain_config.clone(),
            });

            senders[shard_id]
                .lock()
                .unwrap()
                .send(Message::new(bcs::to_bytes(&execution_request).unwrap()))
                .unwrap();
        }
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L80-113)
```rust
    fn receive_execute_command(&self) -> ExecutorShardCommand<RemoteStateViewClient> {
        match self.command_rx.recv() {
            Ok(message) => {
                let _rx_timer = REMOTE_EXECUTOR_TIMER
                    .with_label_values(&[&self.shard_id.to_string(), "cmd_rx"])
                    .start_timer();
                let bcs_deser_timer = REMOTE_EXECUTOR_TIMER
                    .with_label_values(&[&self.shard_id.to_string(), "cmd_rx_bcs_deser"])
                    .start_timer();
                let request: RemoteExecutionRequest = bcs::from_bytes(&message.data).unwrap();
                drop(bcs_deser_timer);

                match request {
                    RemoteExecutionRequest::ExecuteBlock(command) => {
                        let init_prefetch_timer = REMOTE_EXECUTOR_TIMER
                            .with_label_values(&[&self.shard_id.to_string(), "init_prefetch"])
                            .start_timer();
                        let state_keys = Self::extract_state_keys(&command);
                        self.state_view_client.init_for_block(state_keys);
                        drop(init_prefetch_timer);

                        let (sub_blocks, concurrency, onchain_config) = command.into();
                        ExecutorShardCommand::ExecuteSubBlocks(
                            self.state_view_client.clone(),
                            sub_blocks,
                            concurrency,
                            onchain_config,
                        )
                    },
                }
            },
            Err(_) => ExecutorShardCommand::Stop,
        }
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_executor_service.rs (L215-260)
```rust
    pub fn start(&self) {
        trace!(
            "Shard starting, shard_id={}, num_shards={}.",
            self.shard_id,
            self.num_shards
        );
        let mut num_txns = 0;
        loop {
            let command = self.coordinator_client.receive_execute_command();
            match command {
                ExecutorShardCommand::ExecuteSubBlocks(
                    state_view,
                    transactions,
                    concurrency_level_per_shard,
                    onchain_config,
                ) => {
                    num_txns += transactions.num_txns();
                    trace!(
                        "Shard {} received ExecuteBlock command of block size {} ",
                        self.shard_id,
                        num_txns
                    );
                    let exe_timer = SHARDED_EXECUTOR_SERVICE_SECONDS
                        .timer_with(&[&self.shard_id.to_string(), "execute_block"]);
                    let ret = self.execute_block(
                        transactions,
                        state_view.as_ref(),
                        BlockExecutorConfig {
                            local: BlockExecutorLocalConfig::default_with_concurrency_level(
                                concurrency_level_per_shard,
                            ),
                            onchain: onchain_config,
                        },
                    );
                    drop(state_view);
                    drop(exe_timer);

                    let _result_tx_timer = SHARDED_EXECUTOR_SERVICE_SECONDS
                        .timer_with(&[&self.shard_id.to_string(), "result_tx"]);
                    self.coordinator_client.send_execution_result(ret);
                },
                ExecutorShardCommand::Stop => {
                    break;
                },
            }
        }
```

**File:** execution/executor-benchmark/src/main.rs (L626-648)
```rust
    if opt
        .pipeline_opt
        .sharding_opt
        .remote_executor_addresses
        .is_some()
    {
        remote_executor_client::set_remote_addresses(
            opt.pipeline_opt
                .sharding_opt
                .remote_executor_addresses
                .clone()
                .unwrap(),
        );
        assert_eq!(
            execution_shards,
            remote_executor_client::get_remote_addresses().len(),
            "Number of execution shards ({}) must be equal to the number of remote addresses ({}).",
            execution_shards,
            remote_executor_client::get_remote_addresses().len()
        );
        remote_executor_client::set_coordinator_address(
            opt.pipeline_opt.sharding_opt.coordinator_address.unwrap(),
        );
```
