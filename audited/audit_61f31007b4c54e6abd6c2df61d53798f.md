# Audit Report

## Title
JWK Consensus Memory Exhaustion via Unbounded Issuer/KID Fields in Session Keys

## Summary
The JWK consensus system stores session keys as `(Issuer, KID)` tuples in HashMaps without validating the size of these byte vectors. Byzantine validators with sufficient voting power can create QuorumCertifiedUpdate transactions containing extremely large issuer or kid fields (up to ~1MB each within the 2MB per-block limit), causing memory exhaustion when these unbounded vectors are cloned and stored as HashMap keys, leading to validator node crashes.

## Finding Description

The JWK consensus mechanism in Aptos uses a per-key consensus mode where session keys are derived from `(Issuer, KID)` tuples extracted from QuorumCertifiedUpdate transactions. These types are defined as unbounded byte vectors: [1](#0-0) 

The `session_key_from_qc()` function extracts these unbounded vectors from a QuorumCertifiedUpdate: [2](#0-1) 

These session keys are then stored as HashMap keys in the consensus manager's state: [3](#0-2) 

When a QuorumCertifiedUpdate is processed, the large `(Issuer, KID)` tuple is cloned multiple times and inserted into the HashMap: [4](#0-3) 

**Critical gap: No size validation exists anywhere in the validation pipeline.**

The VM-level validation performs epoch checks, voting power verification, and signature verification, but never validates field sizes: [5](#0-4) 

The Move-level upsert function similarly lacks size validation: [6](#0-5) 

**Attack path:**
1. Byzantine validators with >2/3 voting power create a malicious `ProviderJWKs` with issuer field = 500KB and jwks containing a JWK with kid = 500KB
2. They sign this to create a `QuorumCertifiedUpdate` (total size ~1MB, under the 2MB per-block limit)
3. The update passes signature verification since Byzantine majority signs it
4. When `session_key_from_qc()` is called, it extracts the 1MB `(Issuer, KID)` tuple
5. This tuple is cloned and stored as a HashMap key in `states_by_key`
6. The associated `ConsensusState` value contains additional clones of the same data in the `KeyLevelUpdate` structure
7. Multiple such updates with different kids for the same issuer, or different issuers, multiply the memory consumption
8. With 100 malicious JWKs (feasible within block limits across multiple blocks), this consumes 100MB+ of memory just for HashMap keys, plus additional memory for values
9. Memory exhaustion causes validator node crashes

The per-block validator transaction size limit provides no protection: [7](#0-6) 

At 2MB per block, each block could contain 2 malicious updates of ~1MB each, and over multiple blocks, memory accumulates faster than cleanup (which only happens when on-chain state updates).

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria:
- **Validator node slowdowns**: Memory pressure degrades validator performance
- **API crashes**: Out-of-memory conditions crash validator nodes
- **Significant protocol violations**: Breaks Invariant #9 ("Resource Limits: All operations must respect gas, storage, and computational limits")

Potential escalation to **Critical Severity** if sustained:
- Coordinated attack across multiple epochs could cause **Total loss of liveness/network availability** if enough validators crash simultaneously
- However, this requires sustained Byzantine majority control, which is already a severe compromise

The attack affects all validators in the network since they all process the same QuorumCertifiedUpdate transactions.

## Likelihood Explanation

**Likelihood: Medium-Low**

Requirements for exploitation:
1. Byzantine validators controlling >2/3 voting power (the fundamental AptosBFT assumption is <1/3 Byzantine)
2. Sustained attack across multiple blocks/epochs to accumulate sufficient malicious entries before cleanup
3. Coordination to create many distinct (issuer, kid) pairs to maximize memory consumption

While requiring Byzantine majority is a high bar, the complete absence of size validation means that IF such a compromise occurs (e.g., during initial network bootstrap, governance compromise, or coordinated validator collusion), the attack is trivial to execute with guaranteed impact.

Alternative attack vector with lower requirements:
- Malicious OIDC provider added via governance proposal (only requires governance vote, not validator compromise)
- Provider serves JWKs with very large kid values
- All honest validators observe and agree on these values
- Memory exhaustion occurs even with all honest validators

This alternative path increases likelihood significantly, though it still requires governance compromise.

## Recommendation

**Implement strict size limits on Issuer and KID fields at multiple validation layers:**

1. **Add constants for maximum sizes:**
```rust
// In types/src/jwks/mod.rs
pub const MAX_ISSUER_BYTES: usize = 256;  // Reasonable for URLs like "https://accounts.google.com"
pub const MAX_KID_BYTES: usize = 256;     // Reasonable for key IDs
```

2. **Validate in VM layer before processing:**
```rust
// In aptos-move/aptos-vm/src/validator_txns/jwk.rs, add to process_jwk_update_inner:
ensure!(
    observed.issuer.len() <= MAX_ISSUER_BYTES,
    "Issuer field exceeds maximum allowed size"
);
// Validate kid size by iterating through jwks
for jwk in &observed.jwks {
    let kid = JWK::try_from(jwk)?.id();
    ensure!(
        kid.len() <= MAX_KID_BYTES,
        "KID field exceeds maximum allowed size"
    );
}
```

3. **Validate in Move layer:**
```move
// In aptos-move/framework/aptos-framework/sources/jwks.move
const EISSUER_TOO_LARGE: u64 = 10;
const EKID_TOO_LARGE: u64 = 11;
const MAX_ISSUER_BYTES: u64 = 256;
const MAX_KID_BYTES: u64 = 256;

public fun upsert_into_observed_jwks(fx: &signer, provider_jwks_vec: vector<ProviderJWKs>) {
    // ... existing code ...
    vector::for_each_ref(&provider_jwks_vec, |provider_jwks| {
        assert!(
            vector::length(&provider_jwks.issuer) <= MAX_ISSUER_BYTES,
            error::invalid_argument(EISSUER_TOO_LARGE)
        );
        // Validate each JWK's kid size
    });
}
```

4. **Add validation when adding OIDC providers:**
```move
public fun upsert_oidc_provider_for_next_epoch(fx: &signer, name: vector<u8>, config_url: vector<u8>) {
    assert!(
        vector::length(&name) <= MAX_ISSUER_BYTES,
        error::invalid_argument(EISSUER_TOO_LARGE)
    );
    // ... rest of function
}
```

## Proof of Concept

```rust
#[test]
fn test_large_issuer_kid_memory_exhaustion() {
    use aptos_types::jwks::{ProviderJWKs, QuorumCertifiedUpdate, JWKMoveStruct, Issuer, KID};
    use aptos_types::aggregate_signature::AggregateSignature;
    use crate::mode::per_key::PerKeyMode;
    use crate::mode::TConsensusMode;
    
    // Create a QuorumCertifiedUpdate with extremely large issuer and kid
    let large_issuer: Issuer = vec![0xFF; 500_000]; // 500KB issuer
    let large_kid: KID = vec![0xAA; 500_000]; // 500KB kid
    
    // Create a malicious ProviderJWKs
    let malicious_provider_jwks = ProviderJWKs {
        issuer: large_issuer.clone(),
        version: 1,
        jwks: vec![create_jwk_with_large_kid(large_kid.clone())],
    };
    
    let qc = QuorumCertifiedUpdate {
        update: malicious_provider_jwks,
        multi_sig: AggregateSignature::empty(), // Would be valid in real attack
    };
    
    // This should fail with size validation, but currently succeeds
    let session_key = PerKeyMode::session_key_from_qc(&qc).unwrap();
    
    // Verify the session key contains the large vectors
    assert_eq!(session_key.0.len(), 500_000); // issuer
    assert_eq!(session_key.1.len(), 500_000); // kid
    
    // In a real scenario, this would be inserted into HashMap, consuming ~1MB just for the key
    // With 100 such entries, this causes 100MB+ memory consumption
    // Multiple validators processing this simultaneously leads to network-wide memory exhaustion
}
```

**Notes:**
- The vulnerability exists because Issuer and KID are defined as unbounded `Vec<u8>` types
- No validation layer checks the size of these fields before they're used as HashMap keys
- The 2MB per-block limit for validator transactions provides insufficient protection as it allows ~1MB per (issuer, kid) pair
- Byzantine validators can create multiple distinct pairs across blocks to multiply memory impact
- Even cleanup mechanisms (via `reset_with_on_chain_state`) don't prevent accumulation during the attack window
- This breaks the Resource Limits invariant by allowing unbounded memory allocation for consensus state

### Citations

**File:** types/src/jwks/mod.rs (L36-38)
```rust
pub type Issuer = Vec<u8>;
/// Type for JWK Key ID.
pub type KID = Vec<u8>;
```

**File:** crates/aptos-jwk-consensus/src/mode/per_key.rs (L59-64)
```rust
    fn session_key_from_qc(qc: &QuorumCertifiedUpdate) -> anyhow::Result<(Issuer, KID)> {
        let KeyLevelUpdate { issuer, kid, .. } =
            KeyLevelUpdate::try_from_issuer_level_repr(&qc.update)
                .context("session_key_from_qc failed with repr translation")?;
        Ok((issuer, kid))
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L59-59)
```rust
    states_by_key: HashMap<(Issuer, KID), ConsensusState<ObservedKeyLevelUpdate>>,
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L330-333)
```rust
        let state = self
            .states_by_key
            .entry((issuer.clone(), kid.clone()))
            .or_default();
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L127-142)
```rust
        // Check version.
        if on_chain.version + 1 != observed.version {
            return Err(Expected(IncorrectVersion));
        }

        let authors = multi_sig.get_signers_addresses(&verifier.get_ordered_account_addresses());

        // Check voting power.
        verifier
            .check_voting_power(authors.iter(), true)
            .map_err(|_| Expected(NotEnoughVotingPower))?;

        // Verify multi-sig.
        verifier
            .verify_multi_signatures(&observed, &multi_sig)
            .map_err(|_| Expected(MultiSigVerificationFailed))?;
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L462-478)
```text
    public fun upsert_into_observed_jwks(fx: &signer, provider_jwks_vec: vector<ProviderJWKs>) acquires ObservedJWKs, PatchedJWKs, Patches {
        system_addresses::assert_aptos_framework(fx);
        let observed_jwks = borrow_global_mut<ObservedJWKs>(@aptos_framework);

        if (features::is_jwk_consensus_per_key_mode_enabled()) {
            vector::for_each(provider_jwks_vec, |proposed_provider_jwks|{
                let maybe_cur_issuer_jwks = remove_issuer(&mut observed_jwks.jwks, proposed_provider_jwks.issuer);
                let cur_issuer_jwks = if (option::is_some(&maybe_cur_issuer_jwks)) {
                    option::extract(&mut maybe_cur_issuer_jwks)
                } else {
                    ProviderJWKs {
                        issuer: proposed_provider_jwks.issuer,
                        version: 0,
                        jwks: vector[],
                    }
                };
                assert!(cur_issuer_jwks.version + 1 == proposed_provider_jwks.version, error::invalid_argument(EUNEXPECTED_VERSION));
```

**File:** types/src/on_chain_config/consensus_config.rs (L126-126)
```rust
const VTXN_CONFIG_PER_BLOCK_LIMIT_TOTAL_BYTES_DEFAULT: u64 = 2097152; //2MB
```
