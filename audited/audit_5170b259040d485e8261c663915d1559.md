# Audit Report

## Title
Missing Input Validation in Block Partitioner Causes Node Crash via Division by Zero and Integer Underflow

## Summary
The `partition()` function in `PartitionerV2` and the pre-partitioning logic lack validation for the `num_executor_shards` parameter. When `num_executor_shards` is set to 0, the code triggers division by zero in `UniformPartitioner::process()` and integer underflow in `partition_to_matrix.rs`, causing immediate node crashes. When set to extremely large values, excessive memory allocation occurs, leading to out-of-memory conditions.

## Finding Description

The vulnerability exists across multiple files in the block partitioning subsystem:

**Division by Zero Location:** [1](#0-0) 

The `process()` function performs modulo and division operations with `num_chunks` (which equals `num_executor_shards`) without validating it's non-zero. When `num_executor_shards` is 0, both `num_txns % num_chunks` and `num_txns / num_chunks` trigger division by zero panics.

**Integer Underflow Location:** [2](#0-1) 

When `partition_last_round` is false, the code attempts to access `remaining_txns[state.num_executor_shards - 1]`. With `num_executor_shards = 0`, this causes integer underflow (panic in debug mode) or wraps to `usize::MAX` causing out-of-bounds access (panic in release mode).

**Excessive Memory Allocation Locations:** [3](#0-2) [4](#0-3) [5](#0-4) 

If `num_executor_shards` is set to an extremely large value (e.g., `usize::MAX / 2`), these allocations cause out-of-memory errors.

**Missing Validation:** [6](#0-5) 

The `partition()` function accepts `num_executor_shards` without any validation and passes it directly to `PartitionState::new()`. [7](#0-6) 

`PartitionState::new()` also lacks validation for the `num_executor_shards` parameter.

## Impact Explanation

**Severity: High** 

This vulnerability can cause validator node crashes through multiple attack vectors:

1. **Division by Zero Panic**: Immediate node termination when `num_executor_shards = 0`
2. **Out-of-Bounds Access**: Memory safety violation and crash when underflow wraps in release mode
3. **Out-of-Memory DoS**: Node becomes unresponsive with extremely large values

According to Aptos bug bounty criteria, this qualifies as **High Severity** because it causes "Validator node slowdowns" and "API crashes." While individual node crashes don't directly violate consensus safety (Byzantine fault tolerance handles < 1/3 failures), widespread misconfiguration affecting multiple validators could impact network liveness.

**Broken Invariants:**
- **Resource Limits** (Invariant #9): Operations must respect computational and memory limits - violated by unbounded memory allocation
- **Deterministic Execution** (Invariant #1): Validator crashes prevent deterministic block execution

## Likelihood Explanation

**Likelihood: Low to Medium**

While the bugs are definitively present in production code, exploitation requires configuration-level access:

1. **Configuration Control Required**: `num_executor_shards` is set via command-line parameters in `executor-benchmark` and `transaction-benchmarks`, requiring operator access
2. **Partial Defensive Checks**: Some callers like `BlockPreparationStage::new()` check if `num_shards == 0` and avoid creating the partitioner, but this is inconsistent
3. **Misconfiguration Scenario**: An operator could accidentally set `--num-executor-shards 0` or an unreasonably large value

The vulnerability is NOT directly exploitable by unprivileged external attackers (transaction senders, network peers) as they cannot control node configuration. However, it represents a significant operational risk and violates defense-in-depth principles.

## Recommendation

Add comprehensive input validation at the entry points of the partitioning system:

```rust
// In execution/block-partitioner/src/v2/mod.rs
impl BlockPartitioner for PartitionerV2 {
    fn partition(
        &self,
        txns: Vec<AnalyzedTransaction>,
        num_executor_shards: usize,
    ) -> PartitionedTransactions {
        // Validate num_executor_shards
        assert!(
            num_executor_shards > 0,
            "num_executor_shards must be greater than 0, got: {}",
            num_executor_shards
        );
        assert!(
            num_executor_shards <= 1024, // Reasonable upper limit
            "num_executor_shards exceeds maximum allowed (1024), got: {}",
            num_executor_shards
        );
        
        let _timer = BLOCK_PARTITIONING_SECONDS.start_timer();
        let mut state = PartitionState::new(
            // ... rest of implementation
```

Additionally, validate in `PartitionState::new()`:

```rust
// In execution/block-partitioner/src/v2/state.rs
pub fn new(
    thread_pool: Arc<ThreadPool>,
    dashmap_num_shards: usize,
    txns: Vec<AnalyzedTransaction>,
    num_executor_shards: ShardId,
    num_rounds_limit: usize,
    cross_shard_dep_avoid_threshold: f32,
    partition_last_round: bool,
) -> Self {
    assert!(num_executor_shards > 0, "num_executor_shards must be > 0");
    assert!(num_executor_shards <= 1024, "num_executor_shards too large");
    // ... rest of implementation
```

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "attempt to divide by zero")]
fn test_partition_with_zero_shards() {
    use aptos_block_partitioner::{
        v2::config::PartitionerV2Config,
        BlockPartitioner,
    };
    use aptos_types::transaction::analyzed_transaction::AnalyzedTransaction;
    
    // Create a simple partitioner
    let config = PartitionerV2Config::default();
    let partitioner = config.build();
    
    // Create dummy transactions
    let txns: Vec<AnalyzedTransaction> = vec![];
    
    // This should panic with division by zero
    let _result = partitioner.partition(txns, 0);
}

#[test]
#[should_panic]
fn test_partition_with_underflow() {
    use aptos_block_partitioner::{
        v2::config::PartitionerV2Config,
        BlockPartitioner,
    };
    use aptos_types::transaction::analyzed_transaction::AnalyzedTransaction;
    
    let config = PartitionerV2Config::default()
        .partition_last_round(false);
    let partitioner = config.build();
    
    let txns: Vec<AnalyzedTransaction> = vec![];
    
    // This triggers the underflow path at partition_to_matrix.rs:57
    let _result = partitioner.partition(txns, 0);
}
```

**Note:** This vulnerability requires operator-level access to exploit and does not meet the strict criteria for unprivileged attacker exploitation required by the bug bounty program's validation checklist. While the bugs exist and should be fixed for defense-in-depth, they represent operational/misconfiguration risks rather than direct security vulnerabilities exploitable by external attackers.

### Citations

**File:** execution/block-partitioner/src/pre_partition/uniform_partitioner/mod.rs (L21-24)
```rust
    fn process(&self, num_txns: usize, num_shards: usize) -> Vec<Vec<PrePartitionedTxnIdx>> {
        let num_chunks = num_shards;
        let num_big_chunks = num_txns % num_chunks;
        let small_chunk_size = num_txns / num_chunks;
```

**File:** execution/block-partitioner/src/v2/partition_to_matrix.rs (L52-58)
```rust
        if !state.partition_last_round {
            trace!("Merging txns after discarding stopped.");
            let last_round_txns: Vec<PrePartitionedTxnIdx> =
                remaining_txns.into_iter().flatten().collect();
            remaining_txns = vec![vec![]; state.num_executor_shards];
            remaining_txns[state.num_executor_shards - 1] = last_round_txns;
        }
```

**File:** execution/block-partitioner/src/v2/partition_to_matrix.rs (L183-183)
```rust
        state.start_index_matrix = vec![vec![0; state.num_executor_shards]; num_rounds];
```

**File:** execution/block-partitioner/src/v2/state.rs (L111-168)
```rust
    pub fn new(
        thread_pool: Arc<ThreadPool>,
        dashmap_num_shards: usize,
        txns: Vec<AnalyzedTransaction>,
        num_executor_shards: ShardId,
        num_rounds_limit: usize,
        cross_shard_dep_avoid_threshold: f32,
        partition_last_round: bool,
    ) -> Self {
        let _timer = MISC_TIMERS_SECONDS.timer_with(&["new"]);
        let num_txns = txns.len();
        let sender_counter = AtomicUsize::new(0);
        let key_counter = AtomicUsize::new(0);
        let mut senders: Vec<RwLock<Option<SenderIdx>>> = Vec::with_capacity(num_txns);
        let mut wsets: Vec<RwLock<HashSet<StorageKeyIdx>>> = Vec::with_capacity(num_txns);
        let mut rsets: Vec<RwLock<HashSet<StorageKeyIdx>>> = Vec::with_capacity(num_txns);
        let sender_idx_table: DashMap<Sender, SenderIdx> =
            DashMap::with_shard_amount(dashmap_num_shards);
        let key_idx_table: DashMap<StateKey, StorageKeyIdx> =
            DashMap::with_shard_amount(dashmap_num_shards);
        let trackers: DashMap<StorageKeyIdx, RwLock<ConflictingTxnTracker>> =
            DashMap::with_shard_amount(dashmap_num_shards);
        for txn in txns.iter() {
            senders.push(RwLock::new(None));
            wsets.push(RwLock::new(HashSet::with_capacity(txn.write_hints().len())));
            rsets.push(RwLock::new(HashSet::with_capacity(txn.read_hints().len())));
        }
        let takable_txns = thread_pool.install(|| {
            txns.into_par_iter()
                .map(|txn| RwLock::new(Some(txn)))
                .collect()
        });

        Self {
            dashmap_num_shards,
            partition_last_round,
            thread_pool,
            num_executor_shards,
            pre_partitioned: vec![],
            start_txn_idxs_by_shard: vec![0; num_executor_shards],
            sender_counter,
            storage_key_counter: key_counter,
            sender_idxs: senders,
            write_sets: wsets,
            read_sets: rsets,
            sender_idx_table,
            key_idx_table,
            trackers,
            cross_shard_dep_avoid_threshold,
            num_rounds_limit,
            finalized_txn_matrix: Vec::with_capacity(num_rounds_limit),
            final_idxs_by_pre_partitioned: vec![],
            start_index_matrix: vec![],
            txns: takable_txns,
            sub_block_matrix: vec![],
            ori_idxs_by_pre_partitioned: vec![0; num_txns],
        }
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/mod.rs (L100-100)
```rust
        let mut ordered_results = vec![vec![]; num_executor_shards * num_rounds];
```

**File:** execution/block-partitioner/src/v2/mod.rs (L133-148)
```rust
    fn partition(
        &self,
        txns: Vec<AnalyzedTransaction>,
        num_executor_shards: usize,
    ) -> PartitionedTransactions {
        let _timer = BLOCK_PARTITIONING_SECONDS.start_timer();

        let mut state = PartitionState::new(
            self.thread_pool.clone(),
            self.dashmap_num_shards,
            txns,
            num_executor_shards,
            self.max_partitioning_rounds,
            self.cross_shard_dep_avoid_threshold,
            self.partition_last_round,
        );
```
