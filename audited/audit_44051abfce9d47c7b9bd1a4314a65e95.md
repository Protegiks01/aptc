# Audit Report

## Title
Missing Gas Schedule Completeness Validation Enables Chain Halt via Governance

## Summary
The gas schedule update mechanism lacks validation to ensure all required gas parameters are present, allowing governance to accidentally or maliciously apply an incomplete gas schedule that permanently halts the blockchain by causing all transactions to fail with `VM_STARTUP_FAILURE`.

## Finding Description

The Aptos protocol allows gas schedules to be updated via on-chain governance to adapt to changing network conditions. However, the `set_for_next_epoch` function performs insufficient validation when accepting new gas schedules. [1](#0-0) 

The function only validates that the blob is non-empty and the feature version is not decreasing. The TODO comments at lines 47 and 67 explicitly acknowledge missing consistency checks: [2](#0-1) 

When gas parameters are loaded from the on-chain schedule, the parsing logic requires ALL expected parameters to exist: [3](#0-2) 

If any required parameter is missing, the VM fails to start: [4](#0-3) 

**Attack Scenario:**

1. Governance proposal submits a `GasScheduleV2` with missing critical parameters (e.g., omitting "txn.maximum_number_of_gas_units")
2. The proposal passes validation (only checks blob non-empty and feature version)
3. At epoch reconfiguration, the incomplete schedule is applied: [5](#0-4) 

4. Subsequent transactions attempt to load gas parameters and fail: [6](#0-5) 

5. All transactions (including governance transactions) are discarded with `VM_STARTUP_FAILURE`
6. The chain is completely halted with no governance-based recovery mechanism

The test suite explicitly demonstrates this failure mode: [7](#0-6) 

## Impact Explanation

**Severity: CRITICAL** (meets "Total loss of liveness/network availability" and "Non-recoverable network partition (requires hardfork)" criteria)

This vulnerability enables a complete chain halt where:
- **All transactions fail**: Every transaction execution results in `VM_STARTUP_FAILURE`
- **No governance recovery**: Even governance proposals to fix the issue cannot execute because they also fail with `VM_STARTUP_FAILURE`
- **Requires hard fork**: The only recovery mechanism is a coordinated hard fork by all validators to revert the bad gas schedule
- **Affects all validators**: The issue is deterministic across all nodes

While this requires governance access to trigger, it represents a critical safety gap in a privileged operation that could result from:
- Accidental misconfiguration by well-meaning governance participants
- Software bugs in gas schedule generation tools
- Supply chain attacks on governance tooling

## Likelihood Explanation

**Likelihood: LOW** (requires governance control but could occur accidentally)

The vulnerability requires:
- Control over governance (>50% voting power) OR
- Convincing the community to vote for a malformed proposal OR
- Accidental submission by legitimate governance participants

However, the risk is elevated because:
- No client-side validation prevents this
- Gas schedule generation tools could have bugs
- The complexity of gas schedules makes manual verification difficult
- The failure mode is catastrophic and non-recoverable

## Recommendation

Implement comprehensive gas schedule validation in `set_for_next_epoch` and `set_for_next_epoch_check_hash`:

1. **Validate completeness**: Ensure all required gas parameters exist by attempting to parse the schedule using `AptosGasParameters::from_on_chain_gas_schedule`

2. **Validate reasonableness**: Check that gas values are within acceptable ranges

3. **Add validation function**:

```move
/// Validates that a gas schedule contains all required parameters
public fun validate_gas_schedule(gas_schedule_blob: vector<u8>, feature_version: u64): bool {
    // In practice, this should call into Rust native function
    // that uses AptosGasParameters::from_on_chain_gas_schedule
    // to verify the schedule is complete and parseable
    true // placeholder
}

public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    // NEW: Validate completeness
    assert!(
        validate_gas_schedule(gas_schedule_blob, new_gas_schedule.feature_version),
        error::invalid_argument(EINVALID_GAS_SCHEDULE)
    );
    
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    config_buffer::upsert(new_gas_schedule);
}
```

4. **Add native function** to perform validation using existing Rust parsing logic

## Proof of Concept

```move
#[test_only]
module test_addr::incomplete_gas_schedule_halt {
    use aptos_framework::gas_schedule;
    use std::vector;
    
    #[test(aptos_framework = @aptos_framework)]
    #[expected_failure(abort_code = 0x10001)] // VM_STARTUP_FAILURE after epoch transition
    fun test_incomplete_gas_schedule_halts_chain(aptos_framework: &signer) {
        // Create an incomplete gas schedule with only a few parameters
        let incomplete_schedule = GasScheduleV2 {
            feature_version: 100,
            entries: vector[
                GasEntry { key: string::utf8(b"txn.min_transaction_gas_units"), val: 1000 },
                // Missing critical parameters like maximum_number_of_gas_units!
            ]
        };
        
        let blob = bcs::to_bytes(&incomplete_schedule);
        
        // This should fail but currently succeeds
        gas_schedule::set_for_next_epoch(aptos_framework, blob);
        
        // After epoch transition (simulated), any transaction would fail
        // with VM_STARTUP_FAILURE because gas parameters cannot be loaded
    }
}
```

**Validation**: This issue breaks the **Move VM Safety** invariant ("Bytecode execution must respect gas limits and memory constraints") and the **Resource Limits** invariant ("All operations must respect gas, storage, and computational limits") by preventing ANY operations from executing when gas parameters cannot be loaded.

## Notes

While the hardcoded gas constants in `config/global-constants/src/lib.rs` serve as initial values, they do NOT cause protocol ossification because the on-chain gas schedule can be updated via governance: [8](#0-7) 

The actual validation uses on-chain parameters, not hardcoded values: [9](#0-8) 

However, the governance update mechanism itself has a critical safety vulnerability that enables chain halt scenarios.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L47-47)
```text
        // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L135-145)
```text
    public(friend) fun on_new_epoch(framework: &signer) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(framework);
        if (config_buffer::does_exist<GasScheduleV2>()) {
            let new_gas_schedule = config_buffer::extract_v2<GasScheduleV2>();
            if (exists<GasScheduleV2>(@aptos_framework)) {
                *borrow_global_mut<GasScheduleV2>(@aptos_framework) = new_gas_schedule;
            } else {
                move_to(framework, new_gas_schedule);
            }
        }
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L38-42)
```rust
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        let name = format!("{}.{}", $prefix, key);
                        params.$name = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?.into();
                    }
                )*
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L273-282)
```rust
pub(crate) fn get_or_vm_startup_failure<'a, T>(
    gas_params: &'a Result<T, String>,
    log_context: &AdapterLogSchema,
) -> Result<&'a T, VMStatus> {
    gas_params.as_ref().map_err(|err| {
        let msg = format!("VM Startup Failed. {}", err);
        speculative_error!(log_context, msg.clone());
        VMStatus::error(StatusCode::VM_STARTUP_FAILURE, Some(msg))
    })
}
```

**File:** aptos-move/aptos-vm-environment/src/gas.rs (L23-46)
```rust
fn get_gas_config_from_storage(
    sha3_256: &mut Sha3_256,
    state_view: &impl StateView,
) -> (Result<AptosGasParameters, String>, u64) {
    match GasScheduleV2::fetch_config_and_bytes(state_view) {
        Some((gas_schedule, bytes)) => {
            sha3_256.update(&bytes);
            let feature_version = gas_schedule.feature_version;
            let map = gas_schedule.into_btree_map();
            (
                AptosGasParameters::from_on_chain_gas_schedule(&map, feature_version),
                feature_version,
            )
        },
        None => match GasSchedule::fetch_config_and_bytes(state_view) {
            Some((gas_schedule, bytes)) => {
                sha3_256.update(&bytes);
                let map = gas_schedule.into_btree_map();
                (AptosGasParameters::from_on_chain_gas_schedule(&map, 0), 0)
            },
            None => (Err("Neither gas schedule v2 nor v1 exists.".to_string()), 0),
        },
    }
}
```

**File:** aptos-move/e2e-move-tests/src/tests/missing_gas_parameter.rs (L8-28)
```rust
#[test]
fn missing_gas_parameter() {
    let mut h = MoveHarness::new();

    h.modify_gas_schedule_raw(|gas_schedule| {
        let idx = gas_schedule
            .entries
            .iter()
            .position(|(key, _val)| key == "instr.add")
            .unwrap();
        gas_schedule.entries.remove(idx);
    });

    // Load the code
    let acc = h.new_account_with_balance_at(AccountAddress::from_hex_literal("0xbeef").unwrap(), 0);
    let txn_status = h.publish_package(&acc, &common::test_dir_path("common.data/do_nothing"));
    assert!(matches!(
        txn_status,
        TransactionStatus::Discard(StatusCode::VM_STARTUP_FAILURE)
    ))
}
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L55-65)
```rust
            maximum_number_of_gas_units: Gas,
            "maximum_number_of_gas_units",
            aptos_global_constants::MAX_GAS_AMOUNT
        ],
        // The minimum gas price that a transaction can be submitted with.
        // TODO(Gas): should probably change this to something > 0
        [
            min_price_per_gas_unit: FeePerGasUnit,
            "min_price_per_gas_unit",
            aptos_global_constants::GAS_UNIT_PRICE
        ],
```

**File:** aptos-move/aptos-vm/src/gas.rs (L126-139)
```rust
    if txn_metadata.max_gas_amount() > txn_gas_params.maximum_number_of_gas_units {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; max {}, submitted {}",
                txn_gas_params.maximum_number_of_gas_units,
                txn_metadata.max_gas_amount()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::MAX_GAS_UNITS_EXCEEDS_MAX_GAS_UNITS_BOUND,
            None,
        ));
    }
```
