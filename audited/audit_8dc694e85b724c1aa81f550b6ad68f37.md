# Audit Report

## Title
Protocol Support Bypass: Malicious Peers Can Claim Protocol Support Without Implementation, Causing Silent Message Drops

## Summary
A malicious peer can advertise support for network protocols during the handshake phase without actually implementing handler logic for those protocols. When honest nodes send messages to this peer, the messages are silently dropped without error feedback. This bypasses the protocol filtering logic in `get_connected_supported_peers()` and violates the implicit trust assumption that peers advertising protocol support can process those messages.

## Finding Description

The vulnerability exists in the protocol negotiation and message handling flow:

**1. Protocol Negotiation (Handshake Phase):**

During connection establishment, peers exchange `HandshakeMsg` containing their supported protocols. The `perform_handshake()` function calculates the intersection of supported protocols: [1](#0-0) 

This negotiation is **purely declarative** - it only checks that both peers claim to support common protocols, but performs no validation that handlers are actually registered.

**2. Peer Metadata Storage:**

After successful handshake, the negotiated protocols are stored in `ConnectionMetadata.application_protocols`: [2](#0-1) 

**3. Peer Selection for Messaging:**

Applications use `get_connected_supported_peers()` to find peers that claim to support required protocols: [3](#0-2) 

This function trusts the `application_protocols` stored during handshake without runtime verification.

**4. Message Sending:**

When consensus or other applications send messages, they select a protocol the peer claims to support: [4](#0-3) 

**5. Silent Message Drop:**

When the malicious peer receives a message for a protocol it doesn't actually implement, the message is **silently dropped** with only a counter increment: [5](#0-4) 

For DirectSend messages (used extensively by consensus), there is no error feedback to the sender, as confirmed by the fire-and-forget semantics with no delivery guarantees.

**Attack Scenario:**

1. Malicious peer connects and advertises support for `ConsensusDirectSendCompressed` in its `HandshakeMsg.supported_protocols`
2. Handshake succeeds, peer is registered with this protocol in `ConnectionMetadata.application_protocols`
3. Consensus calls `get_connected_supported_peers([ConsensusDirectSendCompressed])` and receives the malicious peer
4. Consensus sends critical messages (proposals, votes, sync info) to the malicious peer using DirectSend
5. Malicious peer receives messages but has no handler registered in `upstream_handlers` for that protocol
6. Messages are silently dropped (lines 459-464), consensus never receives feedback
7. Targeted validator misses messages, causing timeouts, degraded performance, or falling behind

## Impact Explanation

**Severity: Medium**

This vulnerability enables targeted message delivery failures against specific validators without breaking consensus safety guarantees:

- **Not Critical**: Does not cause fund theft, consensus safety violations, or network partition. The 2/3 honest validator assumption still holds, so consensus continues operating.

- **Not High**: Does not cause complete validator failure or API crashes. Affected validators can still participate using other peers.

- **Medium**: Causes message delivery failures and performance degradation, matching the bug bounty category "state inconsistencies requiring intervention" if validators consistently fail to receive critical messages.

**Specific Impacts:**
- Consensus proposals/votes not delivered → increased round timeouts
- Mempool transaction broadcasts dropped → reduced propagation
- State sync messages lost → nodes falling behind
- Targeted attacks on specific validators to reduce their effectiveness
- No liveness failure (consensus continues with 2/3+ honest validators)

## Likelihood Explanation

**Likelihood: High**

This vulnerability is trivially exploitable by any network peer:

1. **No special privileges required**: Any node connecting to the network can modify its handshake message
2. **Simple implementation**: Attacker just needs to include protocol IDs in `HandshakeMsg.supported_protocols` without registering handlers
3. **No detection mechanism**: No runtime validation checks if claimed protocol support matches actual handler registration
4. **Silent failure**: Dropped messages generate no alerts or error responses
5. **Targeting flexibility**: Attacker can selectively drop messages from specific protocols or validators

The attack requires minimal effort and leaves no clear forensic evidence, making it attractive for adversaries seeking to degrade network performance without triggering obvious alarms.

## Recommendation

Implement runtime validation of protocol support through a handshake verification mechanism:

**Option 1: Protocol Support Verification Messages**

After handshake, send a lightweight verification message for each negotiated protocol to confirm the peer has active handlers. Disconnect peers that fail to respond correctly.

**Option 2: Error Responses for Unsupported Protocols**

Modify the inbound message handler to send explicit error responses when receiving messages for unsupported protocols:

```rust
// In handle_inbound_network_message()
match self.upstream_handlers.get(&direct.protocol_id) {
    None => {
        // Send error response instead of silent drop
        let error_code = ErrorCode::unsupported_protocol(direct.protocol_id);
        let message = NetworkMessage::Error(error_code);
        write_reqs_tx.push((), message)?;
        
        counters::direct_send_messages(&self.network_context, UNKNOWN_LABEL).inc();
        // Consider disconnecting repeat offenders
        self.track_protocol_violation(direct.protocol_id);
    },
    Some(handler) => { /* existing logic */ }
}
```

**Option 3: Periodic Capability Announcements**

Implement periodic re-announcement of supported protocols with heartbeat messages, allowing peers to detect capability changes and inconsistencies.

**Option 4: Bidirectional Handshake Validation**

During handshake, require both peers to prove they can handle messages for claimed protocols through challenge-response exchanges.

The most practical approach is **Option 2 + tracking**, which provides immediate feedback and enables reputation-based disconnection of misbehaving peers.

## Proof of Concept

```rust
// Malicious peer implementation that claims protocol support without handlers

use aptos_network::protocols::wire::handshake::v1::{HandshakeMsg, ProtocolId, ProtocolIdSet};
use aptos_types::chain_id::ChainId;
use aptos_config::network_id::NetworkId;
use std::collections::BTreeMap;

// Step 1: Create malicious handshake claiming support for consensus protocols
let mut supported_protocols = BTreeMap::new();
let mut malicious_protocol_set = ProtocolIdSet::empty();

// Claim support for consensus DirectSend protocols without implementing handlers
malicious_protocol_set.insert(ProtocolId::ConsensusDirectSendCompressed);
malicious_protocol_set.insert(ProtocolId::ConsensusDirectSendBcs);
malicious_protocol_set.insert(ProtocolId::MempoolDirectSend);

supported_protocols.insert(MessagingProtocolVersion::V1, malicious_protocol_set);

let malicious_handshake = HandshakeMsg {
    supported_protocols,
    chain_id: ChainId::mainnet(),
    network_id: NetworkId::Validator,
};

// Step 2: During connection, exchange this handshake
// honest_node.perform_handshake(&malicious_handshake) will succeed
// because it only checks intersection, not actual handler registration

// Step 3: When honest node sends DirectSend message:
// honest_node.send_to_peer(consensus_msg, malicious_peer_id)
// 
// Message reaches malicious peer's handle_inbound_network_message()
// upstream_handlers.get(&ConsensusDirectSendCompressed) returns None
// Message is silently dropped with only counter increment
// Honest node receives no error, believes message was delivered

// Expected behavior: Message delivery to capable peers
// Actual behavior: Silent message drop, no error feedback

// Test can be implemented by:
// 1. Creating two peer actors in network framework tests
// 2. Having one peer claim protocol support without registering handlers
// 3. Sending DirectSend messages from honest peer to malicious peer
// 4. Verifying messages are dropped without error response
// 5. Observing that get_connected_supported_peers() returns the malicious peer
```

## Notes

This vulnerability is particularly concerning for DirectSend-based protocols (consensus, mempool) where:
- No timeout mechanism exists for delivery confirmation
- Applications depend on `get_connected_supported_peers()` filtering for reliable peer selection
- Silent failures can persist undetected, causing gradual performance degradation

The issue represents a violation of the implicit protocol contract: advertising protocol support should guarantee message processing capability, not just willingness to receive bytes on the wire.

### Citations

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L431-465)
```rust
    pub fn perform_handshake(
        &self,
        other: &HandshakeMsg,
    ) -> Result<(MessagingProtocolVersion, ProtocolIdSet), HandshakeError> {
        // verify that both peers are on the same chain
        if self.chain_id != other.chain_id {
            return Err(HandshakeError::InvalidChainId(
                other.chain_id,
                self.chain_id,
            ));
        }

        // verify that both peers are on the same network
        if self.network_id != other.network_id {
            return Err(HandshakeError::InvalidNetworkId(
                other.network_id,
                self.network_id,
            ));
        }

        // find the greatest common MessagingProtocolVersion where we both support
        // at least one common ProtocolId.
        for (our_handshake_version, our_protocols) in self.supported_protocols.iter().rev() {
            if let Some(their_protocols) = other.supported_protocols.get(our_handshake_version) {
                let common_protocols = our_protocols.intersect(their_protocols);

                if !common_protocols.is_empty() {
                    return Ok((*our_handshake_version, common_protocols));
                }
            }
        }

        // no intersection found
        Err(HandshakeError::NoCommonProtocols)
    }
```

**File:** network/framework/src/transport/mod.rs (L308-318)
```rust
    let (messaging_protocol, application_protocols) = handshake_msg
        .perform_handshake(&remote_handshake)
        .map_err(|err| {
            let err = format!(
                "handshake negotiation with peer {} failed: {}",
                remote_peer_id.short_str(),
                err
            );
            add_pp_addr(proxy_protocol_enabled, io::Error::other(err), &addr)
        })?;

```

**File:** network/framework/src/application/storage.rs (L129-148)
```rust
    pub fn get_connected_supported_peers(
        &self,
        protocol_ids: &[ProtocolId],
    ) -> Result<Vec<PeerNetworkId>, Error> {
        // Get the cached peers and metadata
        let cached_peers_and_metadata = self.cached_peers_and_metadata.load();

        // Collect all connected peers that support at least one of the given protocols
        let mut connected_supported_peers = Vec::new();
        for (network_id, peers_and_metadata) in cached_peers_and_metadata.iter() {
            for (peer_id, peer_metadata) in peers_and_metadata.iter() {
                if peer_metadata.is_connected() && peer_metadata.supports_any_protocol(protocol_ids)
                {
                    let peer_network_id = PeerNetworkId::new(*network_id, *peer_id);
                    connected_supported_peers.push(peer_network_id);
                }
            }
        }
        Ok(connected_supported_peers)
    }
```

**File:** network/framework/src/application/interface.rs (L142-158)
```rust
    fn get_preferred_protocol_for_peer(
        &self,
        peer: &PeerNetworkId,
        preferred_protocols: &[ProtocolId],
    ) -> Result<ProtocolId, Error> {
        let protocols_supported_by_peer = self.get_supported_protocols(peer)?;
        for protocol in preferred_protocols {
            if protocols_supported_by_peer.contains(*protocol) {
                return Ok(*protocol);
            }
        }
        Err(Error::NetworkError(format!(
            "None of the preferred protocols are supported by this peer! \
            Peer: {:?}, supported protocols: {:?}",
            peer, protocols_supported_by_peer
        )))
    }
```

**File:** network/framework/src/peer/mod.rs (L452-492)
```rust
            NetworkMessage::DirectSendMsg(direct) => {
                let data_len = direct.raw_msg.len();
                network_application_inbound_traffic(
                    self.network_context,
                    direct.protocol_id,
                    data_len as u64,
                );
                match self.upstream_handlers.get(&direct.protocol_id) {
                    None => {
                        counters::direct_send_messages(&self.network_context, UNKNOWN_LABEL).inc();
                        counters::direct_send_bytes(&self.network_context, UNKNOWN_LABEL)
                            .inc_by(data_len as u64);
                    },
                    Some(handler) => {
                        let key = (self.connection_metadata.remote_peer_id, direct.protocol_id);
                        let sender = self.connection_metadata.remote_peer_id;
                        let network_id = self.network_context.network_id();
                        let sender = PeerNetworkId::new(network_id, sender);
                        match handler.push(key, ReceivedMessage::new(message, sender)) {
                            Err(_err) => {
                                // NOTE: aptos_channel never returns other than Ok(()), but we might switch to tokio::sync::mpsc and then this would work
                                counters::direct_send_messages(
                                    &self.network_context,
                                    DECLINED_LABEL,
                                )
                                .inc();
                                counters::direct_send_bytes(&self.network_context, DECLINED_LABEL)
                                    .inc_by(data_len as u64);
                            },
                            Ok(_) => {
                                counters::direct_send_messages(
                                    &self.network_context,
                                    RECEIVED_LABEL,
                                )
                                .inc();
                                counters::direct_send_bytes(&self.network_context, RECEIVED_LABEL)
                                    .inc_by(data_len as u64);
                            },
                        }
                    },
                }
```
