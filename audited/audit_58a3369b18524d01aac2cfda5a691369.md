# Audit Report

## Title
Test Poison Injection Bypass via Flags Misconfiguration in Model Compilation Mode

## Summary
The Move compiler's test filtering mechanism fails to inject the `unit_test_poison` function when compiling in test mode through the model builder path. This occurs because `Flags::model_compilation()` sets `test=false` while keeping `keep_testing_functions=true`, causing the poison injection check to be bypassed while test functions remain in compiled modules.

## Finding Description

The vulnerability exists in the interaction between multiple compilation flags and the test filtering logic. The security mechanism requires that modules compiled with test code include a "poison" function that calls a VM-only native function, preventing test-compiled modules from being published to production chains. [1](#0-0) 

The attack path proceeds as follows:

1. **User initiates test compilation** - When `aptos move test` is executed, `test_mode` is set to `true`: [2](#0-1) 

2. **Initial Flags creation** - The build system creates `Flags::testing()` which sets `test=true`: [3](#0-2) 

3. **compile_test_code flag propagation** - The `keep_testing_functions()` method returns `true`, which is used to set `compile_test_code`: [4](#0-3) 

4. **Model builder creates NEW Flags with test=false** - The critical flaw occurs here. The model builder creates a completely new `Flags` object using `model_compilation()`: [5](#0-4) [6](#0-5) 

This results in `test=false` and `keep_testing_functions=true`.

5. **Poison injection bypassed** - In `filter_map_module()`, the check uses `is_testing()` which returns `self.test`: [7](#0-6) [8](#0-7) 

Since `test=false`, the condition `!self.env.flags().is_testing()` evaluates to `true`, and the module is returned WITHOUT the poison function being injected (lines 52-54 are never reached).

6. **Test functions are retained** - Meanwhile, test functions are kept because `should_remove_node()` checks `keep_testing_functions()`: [9](#0-8) [10](#0-9) 

Since `keep_testing_functions()` returns `true`, test functions are NOT removed.

**Result**: Modules are compiled containing `#[test]` and `#[test_only]` annotated functions but WITHOUT the `unit_test_poison` function, allowing them to be published to production blockchains.

## Impact Explanation

**Severity: High** (up to $50,000 per Aptos Bug Bounty Program)

This represents a **significant protocol violation** as it bypasses a critical security mechanism. The impact includes:

1. **Test Code in Production**: Modules with test-only code can be deployed to mainnet. Test code often contains:
   - Debug functionality and logging that should not be in production
   - Simplified security checks for testing purposes
   - Unaudited or less rigorously reviewed code paths
   - Functions that may expose internal state or bypass access controls

2. **Security Assumption Violation**: Developers rely on the compiler's guarantee that test-compiled modules cannot run on production VMs. This broken guarantee could lead to:
   - Deployment of modules with weakened security properties
   - Exploitation of test-only functions that were never intended for production use
   - Potential loss of funds if test functions contain vulnerabilities

3. **Deterministic Execution Risk**: Different compilation paths (test vs. non-test) should produce bytecode that behaves identically or fails to link. This violation could theoretically lead to consensus issues if validators process modules differently.

## Likelihood Explanation

**Likelihood: High**

This vulnerability triggers automatically whenever Move code is compiled using the standard `aptos move test` or `move test` commands, which is the primary workflow for Move developers. The conditions are:

- No special attacker privileges required
- Occurs in normal development workflow
- Affects all Move packages compiled via the v2 compiler test path
- No manual flag manipulation needed - the bug is in the default compilation pipeline

The vulnerability is **actively occurring** in every test compilation, though exploitation requires an attacker to:
1. Compile a module in test mode (trivial)
2. Extract the compiled bytecode (straightforward)
3. Submit a publish transaction with this bytecode to mainnet (standard operation)

## Recommendation

**Fix**: Synchronize the `test` flag with `keep_testing_functions` in the model compilation path.

**Option 1** (Recommended): Modify `model_compilation()` to set `test=true` when test functions should be kept:

```rust
// In third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs
pub fn model_compilation() -> Self {
    Self {
        test: true,  // Changed from false to true
        verify: true,
        shadow: true,
        keep_testing_functions: true,
        lang_v2: true,
        ..Self::empty()
    }
}
```

**Option 2**: Modify `filter_map_module()` to check `keep_testing_functions()` instead of `is_testing()`:

```rust
// In filter_test_members.rs, line 48
if !self.env.flags().keep_testing_functions() {
    return Some(module_def);
}
```

**Option 3**: Add explicit poison injection when `keep_testing_functions()` is true:

```rust
if !self.env.flags().is_testing() && !self.env.flags().keep_testing_functions() {
    return Some(module_def);
}
```

**Validation**: After applying the fix, verify that:
1. Test-compiled modules always contain `unit_test_poison` function
2. Attempting to publish such modules to production chains fails at link time
3. Non-test compilations do not include test functions or poison

## Proof of Concept

```rust
// Create a test Move module
// File: sources/test_bypass.move
module 0x1::test_bypass {
    #[test_only]
    public fun dangerous_test_function(): u64 {
        // This function should NOT be in production bytecode
        999
    }
    
    #[test]
    fun test_example() {
        assert!(dangerous_test_function() == 999, 0);
    }
}

// Compilation steps:
// 1. Run: aptos move test
// 2. Examine compiled bytecode in build/TestBypass/bytecode_modules/
// 3. Verify that:
//    a) dangerous_test_function is present in bytecode
//    b) unit_test_poison function is ABSENT from bytecode
// 4. Attempt to publish this module to a non-test blockchain
// 5. Observe that linking succeeds (when it should fail)

// Verification command:
// aptos move disassemble --bytecode-path build/TestBypass/bytecode_modules/test_bypass.mv
// Expected vulnerability: unit_test_poison function will be missing
// Expected fix result: unit_test_poison function will be present
```

**Notes**

This vulnerability demonstrates a subtle but critical flaw in the compiler's multi-stage compilation pipeline. The root cause is the architectural decision to use different `Flags` configurations between the package build system and the model builder, combined with the semantic overloading of the `test` flag (used for poison injection) versus `keep_testing_functions` (used for filtering). The fix requires careful consideration of backward compatibility with existing code that may rely on the model builder's current behavior for verification tooling.

### Citations

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/unit_test/filter_test_members.rs (L48-50)
```rust
        if !self.env.flags().is_testing() {
            return Some(module_def);
        }
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/unit_test/filter_test_members.rs (L165-169)
```rust
/// If a module is being compiled in test mode, create a dummy function that calls a native
/// function `0x1::UnitTest::create_signers_for_testing` that only exists if the VM is being run
/// with the "unit_test" feature flag set. This will then cause the module to fail to link if
/// an attempt is made to publish a module that has been compiled in test mode on a VM that is not
/// running in test mode.
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/unit_test/filter_test_members.rs (L224-235)
```rust
fn should_remove_node(env: &CompilationEnv, attrs: &[P::Attributes], is_source_def: bool) -> bool {
    use known_attributes::TestingAttribute;
    let flattened_attrs: Vec<_> = attrs.iter().flat_map(test_attributes).collect();
    let is_test_only = flattened_attrs
        .iter()
        .any(|attr| matches!(attr.1, TestingAttribute::Test | TestingAttribute::TestOnly));
    is_test_only && !env.flags().keep_testing_functions()
        || (!is_source_def
            && flattened_attrs
                .iter()
                .any(|attr| attr.1 == TestingAttribute::Test))
}
```

**File:** third_party/move/tools/move-cli/src/base/test.rs (L182-182)
```rust
    build_config.test_mode = true;
```

**File:** third_party/move/tools/move-package/src/compilation/compiled_package.rs (L585-589)
```rust
        let mut flags = if resolution_graph.build_options.test_mode {
            Flags::testing()
        } else {
            Flags::empty()
        };
```

**File:** third_party/move/tools/move-package/src/compilation/compiled_package.rs (L664-664)
```rust
                        compile_test_code: flags.keep_testing_functions(),
```

**File:** third_party/move/move-model/src/lib.rs (L102-108)
```rust
        Flags::model_compilation()
            .set_warn_of_deprecation_use(warn_of_deprecation_use)
            .set_warn_of_deprecation_use_in_aptos_libs(warn_of_deprecation_use_in_aptos_libs)
            .set_skip_attribute_checks(skip_attribute_checks)
            .set_verify(compile_verify_code)
            .set_keep_testing_functions(compile_test_code)
            .set_language_version(language_version.into()),
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs (L438-446)
```rust
    pub fn model_compilation() -> Self {
        Self {
            test: false,
            verify: true,
            shadow: true, // allows overlapping between sources and deps
            keep_testing_functions: true,
            lang_v2: true,
            ..Self::empty()
        }
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs (L474-476)
```rust
    pub fn is_testing(&self) -> bool {
        self.test
    }
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/shared/mod.rs (L478-480)
```rust
    pub fn keep_testing_functions(&self) -> bool {
        self.test || self.keep_testing_functions
    }
```
