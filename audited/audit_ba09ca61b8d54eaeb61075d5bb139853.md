# Audit Report

## Title
API Transaction Size Limit Mismatch Enables Resource Exhaustion Attacks

## Summary
The API's `PostSizeLimit` middleware enforces an 8 MB content length limit, while the Move VM rejects transactions exceeding 64 KB (or 1 MB for governance transactions). This 125x gap allows attackers to submit oversized transactions that pass API validation but are rejected during VM validation, wasting validator resources.

## Finding Description

The vulnerability stems from a coordination failure between two size enforcement layers:

**API Layer**: The `PostSizeLimit` middleware checks HTTP Content-Length headers against a configurable limit defaulting to 8 MB. [1](#0-0) [2](#0-1) 

**VM Layer**: Transaction size validation occurs in `check_gas()`, enforcing 64 KB for regular transactions and 1 MB for governance transactions. [3](#0-2) [4](#0-3) 

**Exploitation Flow**:
1. Attacker submits BCS-encoded `SignedTransaction` with size between 64 KB and 8 MB
2. `PostSizeLimit` middleware accepts it (< 8 MB) [5](#0-4) 
3. API deserializes the transaction (CPU cost)
4. Transaction submitted to mempool via `context.submit_transaction()` [6](#0-5) 
5. Mempool validates via `VMValidator::validate_transaction()` [7](#0-6) 
6. VM calls `run_prologue_with_payload()` â†’ `check_gas()` and rejects with `EXCEEDED_MAX_TRANSACTION_SIZE` [8](#0-7) [9](#0-8) 

The API performs NO early size check against VM limits before expensive deserialization and mempool submission. [10](#0-9) 

## Impact Explanation

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." An attacker can repeatedly submit transactions sized 64 KB to 8 MB, causing:

- **CPU exhaustion**: BCS deserialization of multi-MB payloads
- **Memory pressure**: Temporary allocation for oversized transaction objects
- **Network bandwidth waste**: Full transaction transmitted before rejection
- **Mempool validation overhead**: VM prologue execution for doomed transactions

While categorized as Medium severity under "State inconsistencies requiring intervention," this enables **validator node slowdowns** (High severity criterion). However, the exclusions state "Network-level DoS attacks are out of scope," creating ambiguity about whether application-layer resource exhaustion qualifies.

## Likelihood Explanation

**Likelihood: High**. The attack requires:
- No authentication or privileged access
- Simple HTTP POST requests with oversized payloads
- Trivial automation (e.g., `curl` loop submitting 1 MB transactions)
- No rate limiting preventing submission of thousands of oversized transactions

The 125x gap (8 MB API limit vs 64 KB VM limit) provides ample attack surface.

## Recommendation

Add early size validation in `validate_signed_transaction_payload()` before mempool submission:

```rust
fn validate_signed_transaction_payload(
    &self,
    ledger_info: &LedgerInfo,
    signed_transaction: &SignedTransaction,
) -> Result<(), SubmitTransactionError> {
    // Add early size check against VM limits
    let txn_size = signed_transaction.raw_txn_bytes_len() as u64;
    let max_size = 64 * 1024; // Fetch from on-chain gas parameters if possible
    if txn_size > max_size {
        return Err(SubmitTransactionError::bad_request_with_code(
            format!("Transaction size {} exceeds maximum {} bytes", txn_size, max_size),
            AptosErrorCode::InvalidInput,
            ledger_info,
        ));
    }
    
    // Existing payload validation...
    match signed_transaction.payload() {
        // ...
    }
}
```

Alternatively, reduce `DEFAULT_REQUEST_CONTENT_LENGTH_LIMIT` to align with VM limits (e.g., 128 KB buffer above 64 KB VM limit).

## Proof of Concept

```rust
use aptos_types::transaction::{RawTransaction, SignedTransaction, TransactionPayload, Script};
use aptos_crypto::{ed25519::Ed25519PrivateKey, PrivateKey, Uniform};

#[test]
fn test_oversized_transaction_resource_waste() {
    let mut rng = rand::thread_rng();
    let private_key = Ed25519PrivateKey::generate(&mut rng);
    
    // Create transaction with 100 KB payload (exceeds 64 KB VM limit)
    let large_code = vec![0u8; 100 * 1024];
    let script = Script::new(large_code, vec![], vec![]);
    
    let raw_txn = RawTransaction::new_script(
        AccountAddress::random(),
        0,
        script,
        100_000,
        1,
        0,
        ChainId::test(),
    );
    
    let signed_txn = SignedTransaction::new(raw_txn, private_key.public_key(), 
                                            private_key.sign(&raw_txn).unwrap());
    
    // Serialize to BCS - this would be the HTTP POST body
    let txn_bytes = bcs::to_bytes(&signed_txn).unwrap();
    assert!(txn_bytes.len() > 64 * 1024); // > 64 KB
    assert!(txn_bytes.len() < 8 * 1024 * 1024); // < 8 MB API limit
    
    // API accepts it (PostSizeLimit checks HTTP Content-Length < 8 MB)
    // Transaction gets deserialized, submitted to mempool
    // VM validation rejects with EXCEEDED_MAX_TRANSACTION_SIZE
    // Resources wasted: deserialization CPU, mempool bandwidth, VM validation
}
```

**Notes**: Despite meeting technical criteria, this vulnerability's validity is questionable due to the "Network-level DoS attacks are out of scope" exclusion. The finding represents an application-layer inefficiency enabling resource exhaustion rather than a critical security flaw. Classification depends on whether resource exhaustion attacks are considered in-scope under the bug bounty's "validator node slowdowns" category.

### Citations

**File:** config/src/config/api_config.rs (L97-97)
```rust
const DEFAULT_REQUEST_CONTENT_LENGTH_LIMIT: u64 = 8 * 1024 * 1024; // 8 MB
```

**File:** api/src/check_size.rs (L43-58)
```rust
    async fn call(&self, req: Request) -> Result<Self::Output> {
        if req.method() != Method::POST {
            return self.inner.call(req).await;
        }

        let content_length = req
            .headers()
            .typed_get::<headers::ContentLength>()
            .ok_or(SizedLimitError::MissingContentLength)?;

        if content_length.0 > self.max_size {
            return Err(SizedLimitError::PayloadTooLarge.into());
        }

        self.inner.call(req).await
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L73-81)
```rust
            max_transaction_size_in_bytes: NumBytes,
            "max_transaction_size_in_bytes",
            64 * 1024
        ],
        [
            max_transaction_size_in_bytes_gov: NumBytes,
            { RELEASE_V1_13.. => "max_transaction_size_in_bytes.gov" },
            1024 * 1024
        ],
```

**File:** aptos-move/aptos-vm/src/gas.rs (L109-121)
```rust
    } else if txn_metadata.transaction_size > txn_gas_params.max_transaction_size_in_bytes {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Transaction size too big {} (max {})",
                txn_metadata.transaction_size, txn_gas_params.max_transaction_size_in_bytes
            ),
        );
        return Err(VMStatus::error(
            StatusCode::EXCEEDED_MAX_TRANSACTION_SIZE,
            None,
        ));
    }
```

**File:** api/src/runtime.rs (L255-255)
```rust
            .with(PostSizeLimit::new(size_limit))
```

**File:** api/src/context.rs (L217-225)
```rust
    pub async fn submit_transaction(&self, txn: SignedTransaction) -> Result<SubmissionStatus> {
        let (req_sender, callback) = oneshot::channel();
        self.mp_sender
            .clone()
            .send(MempoolClientRequest::SubmitTransaction(txn, req_sender))
            .await?;

        callback.await?
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1939-1949)
```rust
        self.run_prologue_with_payload(
            session,
            module_storage,
            &serialized_signers,
            executable,
            extra_config,
            transaction_data,
            log_context,
            is_approved_gov_script,
            traversal_context,
        )?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2805-2814)
```rust
        check_gas(
            self.gas_params(log_context)?,
            self.gas_feature_version(),
            session.resolver,
            module_storage,
            txn_data,
            self.features(),
            is_approved_gov_script,
            log_context,
        )?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3163-3168)
```rust
    fn validate_transaction(
        &self,
        transaction: SignedTransaction,
        state_view: &impl StateView,
        module_storage: &impl ModuleStorage,
    ) -> VMValidatorResult {
```

**File:** api/src/transactions.rs (L1256-1280)
```rust
    fn validate_signed_transaction_payload(
        &self,
        ledger_info: &LedgerInfo,
        signed_transaction: &SignedTransaction,
    ) -> Result<(), SubmitTransactionError> {
        match signed_transaction.payload() {
            TransactionPayload::EntryFunction(entry_function) => {
                TransactionsApi::validate_entry_function_payload_format(
                    ledger_info,
                    entry_function,
                )?;
            },
            TransactionPayload::Script(script) => {
                TransactionsApi::validate_script(ledger_info, script)?;
            },
            TransactionPayload::Multisig(multisig) => {
                if let Some(payload) = &multisig.transaction_payload {
                    match payload {
                        MultisigTransactionPayload::EntryFunction(entry_function) => {
                            TransactionsApi::validate_entry_function_payload_format(
                                ledger_info,
                                entry_function,
                            )?;
                        },
                    }
```
