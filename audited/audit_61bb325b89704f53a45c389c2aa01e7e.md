# Audit Report

## Title
Leaf Count Validation Bypass with Untracked State Storage Usage Leading to Database Integrity Violation and Validator Availability Issue

## Summary
The leaf_count assertion in `state_snapshot_committer.rs` can be bypassed when `StateStorageUsage` is `Untracked`, allowing state snapshots with incorrect usage metadata to be written to the database. This creates a database integrity violation and causes validator nodes to crash during subsequent consistency checks.

## Finding Description

The vulnerability exists in the state snapshot commit flow where usage tracking validation can be completely bypassed: [1](#0-0) 

When `skip_usage` is enabled (configured via `enable_storage_sharding`) and VersionData is missing from the database, the system returns `Untracked` usage: [2](#0-1) 

When `StateStorageUsage` is `Untracked`, the `items()` method returns 0: [3](#0-2) 

The critical issue occurs in the commit flow:

1. **Validation Bypass**: When usage is Untracked, the assertion comparing `leaf_count` (actual items in JMT) with `usage.items()` (tracked count) is completely skipped
2. **Incorrect Metadata Written**: The `put_usage()` function writes VersionData to the database with 0 items even when the Merkle tree contains N items: [4](#0-3) 

3. **Conversion to Incorrect VersionData**: When converting Untracked usage to VersionData, it returns 0 for items: [5](#0-4) 

4. **Later Check Fails**: The secondary consistency check detects the mismatch and crashes the node: [6](#0-5) 

This violates the **State Consistency** invariant: state metadata stored in the database must accurately reflect the actual state in the Merkle tree.

## Impact Explanation

**Severity: High** (up to $50,000 per Aptos Bug Bounty)

This vulnerability causes:

1. **Validator Node Crashes**: Nodes with `skip_usage=true` and missing VersionData will crash when the consistency check detects the mismatch between VersionData (0 items) and actual JMT leaf count
2. **Database Integrity Violation**: Incorrect VersionData is persisted to disk before the crash, corrupting the database metadata
3. **Availability Impact**: Affected validators become stuck in a crash loop, unable to participate in consensus
4. **Potential Network Partition**: If multiple validators are affected, this could lead to consensus liveness failures

While the state root calculation remains correct (maintaining consensus safety), the bypass of the immediate validation check and persistence of incorrect metadata represents a significant protocol violation affecting validator availability.

## Likelihood Explanation

**Likelihood: Medium**

This vulnerability can be triggered when:
- A node is configured with `enable_storage_sharding=true` (which sets `skip_usage=true`)
- VersionData entries are missing from the database due to:
  - Database corruption
  - Pruning edge cases
  - State restoration scenarios
  - Node synchronization issues

The configuration option `enable_storage_sharding` is a legitimate feature, and missing metadata can occur in production through various operational scenarios, making this exploitable under realistic conditions.

## Recommendation

The immediate validation check should not be bypassed even when usage is Untracked. Instead, the system should:

1. **Fail-Fast on Untracked Usage**: Reject commits with Untracked usage in production environments
2. **Always Validate Leaf Count**: Move the validation before checking if usage is tracked
3. **Reconstruct Usage from JMT**: If usage data is missing, reconstruct it from the Merkle tree rather than using Untracked

Recommended fix:

```rust
let usage = snapshot.state().usage();
// Always validate leaf count matches actual tree state
if usage.is_untracked() {
    // Reconstruct usage from JMT instead of bypassing validation
    ensure!(
        !usage.is_untracked() || base_version.is_none(),
        "Cannot commit state snapshot with untracked usage at version {}", 
        version
    );
}
assert_eq!(
    leaf_count,
    usage.items(),
    "Num of state items mismatch: jmt: {}, state: {}",
    leaf_count,
    usage.items(),
);
```

## Proof of Concept

```rust
#[test]
fn test_untracked_usage_bypasses_validation() {
    use aptos_types::state_store::state_storage_usage::StateStorageUsage;
    
    // Create state with Untracked usage (simulating skip_usage=true scenario)
    let untracked_usage = StateStorageUsage::new_untracked();
    assert!(untracked_usage.is_untracked());
    assert_eq!(untracked_usage.items(), 0); // Returns 0 even if JMT has items
    
    // The leaf_count assertion would be skipped:
    // if !untracked_usage.is_untracked() { assert_eq!(leaf_count, usage.items()); }
    // This allows Merkle tree with N items but usage showing 0 items
    
    // When converted to VersionData, incorrect metadata is written:
    let version_data: VersionData = untracked_usage.into();
    assert_eq!(version_data.state_items, 0); // Wrong! Should reflect actual count
    
    // This VersionData gets persisted to disk, violating database integrity
    // Later check_usage_consistency() will fail and crash the node
}
```

---

**Notes**

This vulnerability demonstrates a critical gap in the defense-in-depth validation strategy. While the secondary check in `state_merkle_batch_committer.rs` eventually catches the inconsistency, the immediate validation bypass allows incorrect database state to be persisted, causing validator crashes and potential network availability issues. The system should fail-fast on Untracked usage rather than bypassing validation and relying on later checks.

### Citations

**File:** storage/aptosdb/src/state_store/state_snapshot_committer.rs (L166-175)
```rust
                    let usage = snapshot.state().usage();
                    if !usage.is_untracked() {
                        assert_eq!(
                            leaf_count,
                            usage.items(),
                            "Num of state items mismatch: jmt: {}, state: {}",
                            leaf_count,
                            usage.items(),
                        );
                    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L238-248)
```rust
    fn get_state_storage_usage(&self, version: Option<Version>) -> Result<StateStorageUsage> {
        version.map_or(Ok(StateStorageUsage::zero()), |version| {
            Ok(match self.ledger_db.metadata_db().get_usage(version) {
                Ok(data) => data,
                _ => {
                    ensure!(self.skip_usage, "VersionData at {version} is missing.");
                    StateStorageUsage::new_untracked()
                },
            })
        })
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L1017-1028)
```rust
    fn put_usage(state: &State, batch: &mut SchemaBatch) -> Result<()> {
        if let Some(version) = state.version() {
            let usage = state.usage();
            info!("Write usage at version {version}, {usage:?}.");
            batch.put::<VersionDataSchema>(&version, &usage.into())?;
        } else {
            assert_eq!(state.usage().items(), 0);
            assert_eq!(state.usage().bytes(), 0);
        }

        Ok(())
    }
```

**File:** types/src/state_store/state_storage_usage.rs (L30-35)
```rust
    pub fn items(&self) -> usize {
        match self {
            Self::Tracked { items, .. } => *items,
            Self::Untracked => 0,
        }
    }
```

**File:** storage/aptosdb/src/schema/version_data/mod.rs (L36-43)
```rust
impl From<StateStorageUsage> for VersionData {
    fn from(usage: StateStorageUsage) -> Self {
        Self {
            state_items: usage.items(),
            total_state_bytes: usage.bytes(),
        }
    }
}
```

**File:** storage/aptosdb/src/state_store/state_merkle_batch_committer.rs (L136-168)
```rust
    fn check_usage_consistency(&self, state: &State) -> Result<()> {
        let version = state
            .version()
            .ok_or_else(|| anyhow!("Committing without version."))?;

        let usage_from_ledger_db = self.state_db.ledger_db.metadata_db().get_usage(version)?;
        let leaf_count_from_jmt = self
            .state_db
            .state_merkle_db
            .metadata_db()
            .get::<JellyfishMerkleNodeSchema>(&NodeKey::new_empty_path(version))?
            .ok_or_else(|| anyhow!("Root node missing at version {}", version))?
            .leaf_count();

        ensure!(
            usage_from_ledger_db.items() == leaf_count_from_jmt,
            "State item count inconsistent, {} from ledger db and {} from state tree.",
            usage_from_ledger_db.items(),
            leaf_count_from_jmt,
        );

        let usage_from_in_mem_state = state.usage();
        if !usage_from_in_mem_state.is_untracked() {
            ensure!(
                usage_from_in_mem_state == usage_from_ledger_db,
                "State storage usage info inconsistent. from smt: {:?}, from ledger_db: {:?}",
                usage_from_in_mem_state,
                usage_from_ledger_db,
            );
        }

        Ok(())
    }
```
