# Audit Report

## Title
Consensus Observer Payload Store Desynchronization During Epoch Transition Causes Legitimate Block Payloads to be Dropped

## Summary
During epoch transitions via the commit sync path, the consensus observer fails to clear stale block payloads from the previous epoch. These stale payloads remain in the `block_payloads` BTreeMap and count against the `max_num_pending_blocks` limit, causing new legitimate payloads for the current epoch to be silently dropped. This desynchronizes the observer's payload store with the actual network state and prevents correct block execution.

## Finding Description
The consensus observer maintains a shared `block_payloads` BTreeMap (indexed by `(epoch, round)`) that stores block transaction payloads. [1](#0-0) 

When inserting new payloads, the system enforces a strict limit (`max_num_pending_blocks`, default 150 blocks) and **silently drops** new payloads if the limit is exceeded: [2](#0-1) 

During epoch transitions, there are two code paths:

**Path 1 (Fallback Sync)**: Correctly clears the payload store [3](#0-2) 

**Path 2 (Commit Sync - VULNERABLE)**: Does NOT clear the payload store [4](#0-3) 

In the vulnerable commit sync path, when `wait_for_epoch_start()` is called, it passes the existing `block_payloads` reference (which still contains old epoch N payloads) to create the new epoch N+1 payload manager: [5](#0-4) 

The `wait_for_epoch_start()` function creates a new `ConsensusObserverPayloadManager` with the same BTreeMap reference: [6](#0-5) 

While `verify_payload_signatures()` is subsequently called, it only processes current-epoch payloads and **does not remove** old-epoch payloads: [7](#0-6) 

**Attack Scenario:**
1. Observer operates in epoch N, accumulating 140 block payloads (near the 150 limit)
2. State sync completes to a block in epoch N+1 (via commit decision)
3. Epoch transition occurs via commit sync path - old 140 payloads remain
4. New epoch N+1 blocks arrive with payloads
5. After 10 new payloads, the 150 limit is reached
6. All subsequent epoch N+1 payloads are **silently dropped**
7. Observer cannot execute blocks due to missing payloads
8. Observer falls back to state sync, causing performance degradation

This violates the invariant that the payload store should only contain payloads relevant to the current epoch.

## Impact Explanation
This is **HIGH severity** per Aptos bug bounty criteria:

- **Validator node slowdowns**: Observer nodes experience execution failures due to missing payloads, triggering repeated state sync fallbacks
- **Significant protocol violations**: The observer reports incorrect payload availability - it believes payloads don't exist when they were actually broadcast on the network
- **State inconsistencies**: The payload store becomes desynchronized with actual network state, containing stale epoch N payloads while operating in epoch N+1

This affects consensus observer nodes (validator fullnodes running as observers), degrading their ability to track consensus and serve as backup validators.

## Likelihood Explanation
**High likelihood** - This occurs naturally during normal epoch transitions:

1. **Common scenario**: Observers routinely accumulate payloads during normal operation
2. **Automatic trigger**: Any epoch change via the commit sync path (common during normal operation)
3. **No attacker required**: Natural network delays or high block production rates can cause payload accumulation
4. **Deterministic**: Once payloads accumulate near the limit before epoch change, the issue is guaranteed to occur

An attacker could also deliberately trigger this by:
- Delaying block propagation during epoch N to cause payload accumulation
- Then allowing the epoch transition to complete
- Resulting in dropped payloads for epoch N+1

## Recommendation
The `process_commit_sync_notification` function should clear stale payloads after epoch transition, similar to the fallback sync path. 

**Fix**: After calling `wait_for_epoch_start()` in the commit sync path, remove all payloads from the previous epoch before verifying new payloads:

```rust
// In process_commit_sync_notification, after line 1031:
self.execution_client.end_epoch().await;
self.wait_for_epoch_start().await;

// ADD THIS: Clear payloads from old epochs
let new_epoch_state = self.get_epoch_state();
self.observer_block_data
    .lock()
    .remove_blocks_before_epoch(new_epoch_state.epoch);

// Then proceed with verification
let verified_payload_rounds = self
    .observer_block_data
    .lock()
    .verify_payload_signatures(&new_epoch_state);
```

Additionally, add a method to `BlockPayloadStore`:
```rust
pub fn remove_blocks_before_epoch(&self, current_epoch: u64) {
    let mut block_payloads = self.block_payloads.lock();
    *block_payloads = block_payloads.split_off(&(current_epoch, 0));
}
```

## Proof of Concept

```rust
#[test]
fn test_epoch_transition_payload_desync() {
    use aptos_config::config::ConsensusObserverConfig;
    use consensus::consensus_observer::observer::payload_store::BlockPayloadStore;
    
    // Create payload store with small limit
    let config = ConsensusObserverConfig {
        max_num_pending_blocks: 10,
        ..Default::default()
    };
    let mut store = BlockPayloadStore::new(config);
    
    // Simulate epoch 10: Add 8 payloads (near limit)
    for round in 0..8 {
        let payload = create_test_block_payload(10, round);
        store.insert_block_payload(payload, true);
    }
    assert_eq!(store.get_block_payloads().lock().len(), 8);
    
    // EPOCH TRANSITION OCCURS via commit sync path
    // (Note: Old payloads are NOT cleared, simulating the bug)
    
    // Simulate epoch 11: Try to add 10 new payloads
    for round in 0..10 {
        let payload = create_test_block_payload(11, round);
        store.insert_block_payload(payload, true);
    }
    
    // BUG: Only 2 epoch-11 payloads were added (8+2=10 limit)
    // Remaining 8 epoch-11 payloads were DROPPED
    assert_eq!(store.get_block_payloads().lock().len(), 10);
    
    // Verify epoch-11 payloads 2-9 are MISSING (incorrectly dropped)
    let payloads = store.get_block_payloads();
    for round in 2..10 {
        assert!(!payloads.lock().contains_key(&(11, round)));
    }
    
    // Observer now cannot execute epoch-11 blocks due to missing payloads
    // This forces fallback to state sync, degrading performance
}
```

## Notes
This vulnerability specifically affects the **commit sync path** during epoch transitions. The fallback sync path correctly clears payloads via `clear_pending_block_state()`. The issue arises because the same `block_payloads` BTreeMap reference is passed to the new epoch's payload manager without cleanup, violating the assumption that the store should only contain current-epoch data. The silent dropping behavior (returning early with just a warning) means operators may not notice the issue until observers exhibit degraded performance or execution failures.

### Citations

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L33-36)
```rust
    // Block transaction payloads (indexed by epoch and round).
    // This is directly accessed by the payload manager.
    block_payloads: Arc<Mutex<BTreeMap<(u64, Round), BlockPayloadStatus>>>,
}
```

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L84-95)
```rust
        // Verify that the number of payloads doesn't exceed the maximum
        let max_num_pending_blocks = self.consensus_observer_config.max_num_pending_blocks as usize;
        if self.block_payloads.lock().len() >= max_num_pending_blocks {
            warn!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Exceeded the maximum number of payloads: {:?}. Dropping block: {:?}!",
                    max_num_pending_blocks,
                    block_payload.block(),
                ))
            );
            return; // Drop the block if we've exceeded the maximum
        }
```

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L227-231)
```rust
        for (epoch, round) in payload_epochs_and_rounds {
            // Check if we can break early (BtreeMaps are sorted by key)
            if epoch > current_epoch {
                break;
            }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L952-961)
```rust
        // If the epoch has changed, end the current epoch and start the latest one
        let current_epoch_state = self.get_epoch_state();
        if epoch > current_epoch_state.epoch {
            // Wait for the latest epoch to start
            self.execution_client.end_epoch().await;
            self.wait_for_epoch_start().await;
        };

        // Reset the pending block state
        self.clear_pending_block_state().await;
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L1025-1045)
```rust
        // Otherwise, the commit sync notification matches the block data root.
        // If the epoch has changed, end the current epoch and start the latest one.
        let current_epoch_state = self.get_epoch_state();
        if synced_epoch > current_epoch_state.epoch {
            // Wait for the latest epoch to start
            self.execution_client.end_epoch().await;
            self.wait_for_epoch_start().await;

            // Verify the block payloads for the new epoch
            let new_epoch_state = self.get_epoch_state();
            let verified_payload_rounds = self
                .observer_block_data
                .lock()
                .verify_payload_signatures(&new_epoch_state);

            // Order all the pending blocks that are now ready (these were buffered during state sync)
            for payload_round in verified_payload_rounds {
                self.order_ready_pending_block(new_epoch_state.epoch, payload_round)
                    .await;
            }
        };
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L1065-1071)
```rust
    async fn wait_for_epoch_start(&mut self) {
        // Wait for the epoch state to update
        let block_payloads = self.observer_block_data.lock().get_block_payloads();
        let (payload_manager, consensus_config, execution_config, randomness_config) = self
            .observer_epoch_state
            .wait_for_epoch_start(block_payloads)
            .await;
```

**File:** consensus/src/consensus_observer/observer/epoch_state.rs (L110-119)
```rust
        // Create the payload manager
        let payload_manager: Arc<dyn TPayloadManager> = if self.quorum_store_enabled {
            Arc::new(ConsensusObserverPayloadManager::new(
                block_payloads,
                self.consensus_publisher.clone(),
            ))
        } else {
            Arc::new(DirectMempoolPayloadManager {})
        };

```
