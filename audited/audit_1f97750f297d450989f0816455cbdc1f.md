# Audit Report

## Title
Identity Element Accepted as Valid ElGamal Public Key in Move Implementation

## Summary
The Move implementation of ElGamal encryption in `ristretto255_elgamal.move` does not validate that public keys are not the identity element, allowing attackers to register trivial public keys that break ElGamal semantic security. While the Rust implementation (`ElGamalCurve25519Aes256Gcm`) appears protected by `is_torsion_free()` checks, the Move cryptographic primitive lacks this critical validation.

## Finding Description

The `mul()` function in the Rust ElGamal implementation correctly handles zero scalar multiplication, producing the identity element: [1](#0-0) 

However, the critical vulnerability lies in how public keys are validated before use. The Rust implementation performs torsion-free validation: [2](#0-1) 

This check should reject the identity element since it's in the 8-torsion subgroup (order 1), as confirmed by the EIGHT_TORSION constant that includes the identity element: [3](#0-2) 

**The vulnerability is in the Move implementation**, where `new_pubkey_from_bytes()` only validates point decompression without checking for the identity element: [4](#0-3) 

The identity element in Ristretto255 is represented as 32 zero bytes: [5](#0-4) 

**Attack Scenario:**
1. Attacker calls `veiled_coin::register()` with identity element bytes (all zeros) as public key
2. The registration function accepts the identity element without validation: [6](#0-5) 

3. When someone encrypts to this public key, the ElGamal encryption formula becomes: `(v*G + r*O, r*G) = (v*G, r*G)` where O is the identity element
4. The left component directly reveals `v*G` without masking by the public key, completely breaking ElGamal semantic security

## Impact Explanation

**Severity: HIGH** 

This breaks the **Cryptographic Correctness** invariant (Invariant #10). The vulnerability allows:

1. **Confidentiality Breach**: ElGamal semantic security is violated. While discrete log still protects the exact value, the encryption structure is broken.

2. **Deterministic Encryption**: Ciphertexts become deterministic (modulo randomness), enabling pattern analysis and linkability attacks in the veiled coin system.

3. **Trivial Key Attacks**: Attackers can register accounts with sk=0, enabling trivial decryption by anyone who recognizes the identity public key.

4. **Protocol-Level Impact**: The veiled coin confidential transaction system relies on ElGamal for hiding balances. Accepting identity elements undermines the entire privacy model.

While the veiled_coin module is marked experimental, the vulnerable `ristretto255_elgamal` module is a general-purpose cryptographic primitive in aptos-stdlib that could be used by other applications.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

- **Ease of Exploitation**: Trivial - attacker simply passes 32 zero bytes as public key
- **Discoverability**: Moderate - requires understanding of elliptic curve cryptography
- **Current Deployment**: The veiled_coin module is experimental and explicitly warned against production use, limiting immediate impact
- **Future Risk**: HIGH - if the `ristretto255_elgamal` module is used in production features or by third-party Move contracts without proper validation, exploitation becomes trivial

The attack requires no special privileges and can be executed by any user with basic knowledge of elliptic curve identity elements.

## Recommendation

Add explicit validation in `new_pubkey_from_bytes()` to reject the identity element:

```move
public fun new_pubkey_from_bytes(bytes: vector<u8>): Option<CompressedPubkey> {
    let point = ristretto255::new_compressed_point_from_bytes(bytes);
    if (point.is_some()) {
        // Reject the identity element (all zeros)
        if (bytes == point_identity_compressed().data) {
            return std::option::none<CompressedPubkey>()
        };
        
        let pk = CompressedPubkey {
            point: point.extract()
        };
        std::option::some(pk)
    } else {
        std::option::none<CompressedPubkey>()
    }
}
```

Alternatively, add a native function to check if a point is the identity element and validate in the public key creation flow.

## Proof of Concept

```move
#[test]
fun test_identity_public_key_rejection() {
    use aptos_std::ristretto255;
    use aptos_std::ristretto255_elgamal as elgamal;
    
    // Identity element is 32 zero bytes
    let identity_bytes = x"0000000000000000000000000000000000000000000000000000000000000000";
    
    // This should return None but currently returns Some
    let malicious_pk = elgamal::new_pubkey_from_bytes(identity_bytes);
    
    // Current behavior: accepts identity element (VULNERABILITY)
    assert!(malicious_pk.is_some(), 1);
    
    // Expected behavior: should reject identity element
    // assert!(malicious_pk.is_none(), 2);
}
```

**Notes:**
- The Rust implementation appears protected by `is_torsion_free()` validation, though explicit test coverage would strengthen confidence
- The Move implementation's vulnerability affects the experimental veiled_coin system and any future uses of the `ristretto255_elgamal` cryptographic primitive
- Ristretto255 is a prime-order group, but the identity element still exists and must be explicitly rejected in cryptographic protocols
- This violates standard ElGamal security requirements that mandate public key validation

### Citations

**File:** crates/aptos-crypto/src/elgamal/curve25519.rs (L31-33)
```rust
    fn mul(a: &Self::Element, s: &Self::Scalar) -> Self::Element {
        s * a
    }
```

**File:** crates/aptos-crypto/src/asymmetric_encryption/elgamal_curve25519_aes256_gcm.rs (L59-62)
```rust
        ensure!(
            pk.is_torsion_free(),
            "ElGamalCurve25519Aes256Gcm enc failed with non-prime-order PK"
        );
```

**File:** crates/aptos-crypto/src/unit_tests/ed25519_test.rs (L514-547)
```rust
pub const EIGHT_TORSION: [[u8; 32]; 8] = [
    [
        1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0,
    ],
    [
        199, 23, 106, 112, 61, 77, 216, 79, 186, 60, 11, 118, 13, 16, 103, 15, 42, 32, 83, 250, 44,
        57, 204, 198, 78, 199, 253, 119, 146, 172, 3, 122,
    ],
    [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 128,
    ],
    [
        38, 232, 149, 143, 194, 178, 39, 176, 69, 195, 244, 137, 242, 239, 152, 240, 213, 223, 172,
        5, 211, 198, 51, 57, 177, 56, 2, 136, 109, 83, 252, 5,
    ],
    [
        236, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255,
        255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 127,
    ],
    [
        38, 232, 149, 143, 194, 178, 39, 176, 69, 195, 244, 137, 242, 239, 152, 240, 213, 223, 172,
        5, 211, 198, 51, 57, 177, 56, 2, 136, 109, 83, 252, 133,
    ],
    [
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        0, 0,
    ],
    [
        199, 23, 106, 112, 61, 77, 216, 79, 186, 60, 11, 118, 13, 16, 103, 15, 42, 32, 83, 250, 44,
        57, 204, 198, 78, 199, 253, 119, 146, 172, 3, 250,
    ],
];
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/ristretto255_elgamal.move (L42-52)
```text
    public fun new_pubkey_from_bytes(bytes: vector<u8>): Option<CompressedPubkey> {
        let point = ristretto255::new_compressed_point_from_bytes(bytes);
        if (point.is_some()) {
            let pk = CompressedPubkey {
                point: point.extract()
            };
            std::option::some(pk)
        } else {
            std::option::none<CompressedPubkey>()
        }
    }
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/ristretto255.move (L114-118)
```text
    public fun point_identity_compressed(): CompressedRistretto {
        CompressedRistretto {
            data: x"0000000000000000000000000000000000000000000000000000000000000000"
        }
    }
```

**File:** aptos-move/framework/aptos-experimental/sources/veiled_coin/veiled_coin.move (L268-271)
```text
    public entry fun register<CoinType>(user: &signer, pk: vector<u8>) {
        let pk = elgamal::new_pubkey_from_bytes(pk);
        register_internal<CoinType>(user, pk.extract());
    }
```
