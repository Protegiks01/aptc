# Audit Report

## Title
TOCTOU Race Condition in Consensus Observer Payload Verification Allows Consensus Bypass

## Summary
The consensus observer's payload verification system contains a critical Time-of-Check-Time-of-Use (TOCTOU) vulnerability. The verification of block payloads against ordered blocks and the subsequent execution are not atomic, allowing an attacker to replace verified payloads with malicious ones between verification and execution, completely bypassing consensus validation.

## Finding Description

The vulnerability exists in the consensus observer's block payload handling flow across multiple files. The core issue is that payload verification and payload usage occur at different times with non-atomic access to the shared payload store.

**The vulnerable flow:**

1. **Verification Phase** [1](#0-0)  - The ordered block's payloads are verified by locking `observer_block_data`, reading from the payload store, comparing against the ordered block, then releasing the lock.

2. **Lock Release Window** - After verification completes at line 758, the lock is released. The ordered block is not inserted until line 787, creating a gap.

3. **Ordered Block Insertion** [2](#0-1)  - The verified ordered block is inserted using a separate lock acquisition.

4. **Payload Store Access** [3](#0-2)  - During verification, the payload is read from a shared `BTreeMap` protected by a mutex.

5. **Concurrent Payload Insertion** [4](#0-3)  - The `process_block_payload_message` function has two separate lock acquisitions: one to check if a payload exists (line 370-373) and another to insert it (line 428-430). These are NOT atomic.

6. **Payload Overwrite** [5](#0-4)  - The `insert()` method on BTreeMap **overwrites** existing entries with the same key.

7. **Execution Usage** [6](#0-5)  - Much later during execution, `get_transactions_for_observer` reads from the same payload store, potentially retrieving a different (malicious) payload.

**Race Condition Attack Scenario:**

- **Thread 1** (processing ordered block for epoch E, round R):
  - T1: Acquires lock, verifies legitimate payload P1 against ordered block, releases lock
  - T3: Acquires lock, inserts ordered block (updates `last_ordered_block`), releases lock

- **Thread 2** (processing malicious payload P2 for same epoch E, round R):
  - T2 (between T1 and T3): Acquires lock, calls `get_last_ordered_block()` → returns OLD block, releases lock
  - T2.1: Acquires lock, calls `existing_payload_entry()` → may return false due to race, releases lock  
  - T2.2: Verifies malicious payload P2 (with valid signatures but different transactions)
  - T2.3: Acquires lock, inserts P2, **overwrites P1**, releases lock

- **Execution**: Reads P2 from store instead of verified P1, executing unverified transactions

The fundamental issue is that the check at line 373 (`existing_payload_entry`) and the insertion at line 430 (`insert_block_payload`) use separate mutex acquisitions, creating a classic check-then-act race condition.

## Impact Explanation

**Critical Severity - Consensus Safety Violation**

This vulnerability allows complete bypass of consensus validation:

1. **Consensus Safety Broken**: The verified payload (which passed consensus and was signed by validators) is not the same payload that gets executed. This violates the fundamental guarantee that "only consensus-approved transactions execute."

2. **Arbitrary Transaction Execution**: An attacker can craft malicious payloads with completely different transaction sets that were never part of consensus, yet still get executed on the blockchain.

3. **Deterministic Execution Broken**: Different observer nodes could execute different payloads for the same block if timing differs, breaking consensus across the network and causing state divergence.

4. **Network-Wide Impact**: All consensus observer nodes are vulnerable. This could cause validators to disagree on state, potentially requiring a hard fork to recover.

This meets the Critical severity criteria: "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**High Likelihood**

The vulnerability is highly exploitable:

1. **No Special Access Required**: Any peer can send `BlockPayload` messages to consensus observers through the network protocol.

2. **Race Window is Wide**: The gap between verification (line 758) and ordered block insertion (line 787) includes multiple operations and potential async points, providing a substantial window for the race.

3. **Concurrent Message Processing**: The consensus observer processes network messages concurrently, making race conditions natural and frequent.

4. **Repeatable Attack**: An attacker can repeatedly send malicious payloads with precise timing to maximize success probability. Network latency variations create natural timing opportunities.

5. **No Rate Limiting on Payloads**: The system accepts multiple payload messages, only dropping them if they're "out of date" based on `last_ordered_block`, which hasn't been updated during the race window.

## Recommendation

**Fix: Implement Atomic Verification and Protection**

The payload verification and ordered block insertion must be atomic. Additionally, payloads should be immutable once verified.

**Recommended changes:**

1. **Make verification and insertion atomic in `process_ordered_block`:**
```rust
// Hold the lock for the entire verification and insertion
let mut observer_block_data = self.observer_block_data.lock();

// Verify the block payloads against the ordered block
if let Err(error) = observer_block_data
    .verify_payloads_against_ordered_block(&ordered_block)
{
    // ... error handling
    return;
}

// Get last ordered block for parent check
let last_ordered_block = observer_block_data.get_last_ordered_block();
if last_ordered_block.id() == ordered_block.first_block().parent_id() {
    // Insert ordered block while still holding the lock
    observer_block_data.insert_ordered_block(observed_ordered_block.clone());
    
    // Mark payloads as locked/committed so they can't be overwritten
    observer_block_data.lock_payloads_for_block(&ordered_block);
}
drop(observer_block_data); // Explicitly release

// Now finalize outside the lock
if !self.state_sync_manager.is_syncing_to_commit() {
    self.finalize_ordered_block(ordered_block).await;
}
```

2. **Add payload immutability check in `insert_block_payload`:**
```rust
pub fn insert_block_payload(
    &mut self,
    block_payload: BlockPayload,
    verified_payload_signatures: bool,
) {
    let epoch_and_round = (block_payload.epoch(), block_payload.round());
    
    // Check if payload exists AND if it's already locked/verified
    if let Some(existing) = self.block_payloads.lock().get(&epoch_and_round) {
        if matches!(existing, BlockPayloadStatus::AvailableAndVerified(_)) {
            // Payload already verified and locked - reject silently
            return;
        }
    }
    
    // ... rest of insertion logic
}
```

3. **Make the `existing_payload_entry` check atomic with insertion in `process_block_payload_message`:**
```rust
// Acquire lock once and hold it for both check and insert
let mut observer_block_data = self.observer_block_data.lock();

// Check if payload exists while holding the lock
if observer_block_data.existing_payload_entry(&block_payload) {
    update_metrics_for_dropped_block_payload_message(peer_network_id, &block_payload);
    return;
}

// Insert while still holding the lock
observer_block_data.insert_block_payload(block_payload, verified_payload);
drop(observer_block_data);
```

## Proof of Concept

The following Rust test demonstrates the race condition:

```rust
#[tokio::test(flavor = "multi_thread", worker_threads = 4)]
async fn test_toctou_payload_race() {
    use std::sync::{Arc, atomic::{AtomicBool, Ordering}};
    use tokio::time::{sleep, Duration};
    
    // Setup consensus observer with shared block data
    let consensus_observer_config = ConsensusObserverConfig::default();
    let root = create_ledger_info(0, 0);
    let observer_block_data = Arc::new(Mutex::new(
        ObserverBlockData::new_with_root(consensus_observer_config, root)
    ));
    
    let epoch = 1;
    let round = 100;
    
    // Create legitimate payload P1
    let legitimate_transactions = vec![/* legit txns */];
    let payload_p1 = create_block_payload_with_txns(epoch, round, legitimate_transactions);
    
    // Create malicious payload P2 (different transactions, same epoch/round)
    let malicious_transactions = vec![/* malicious txns */];
    let payload_p2 = create_block_payload_with_txns(epoch, round, malicious_transactions);
    
    // Create ordered block referencing P1
    let ordered_block = create_ordered_block(epoch, round);
    
    let race_successful = Arc::new(AtomicBool::new(false));
    
    // Thread 1: Process ordered block (victim)
    let observer_data_t1 = observer_block_data.clone();
    let ordered_block_t1 = ordered_block.clone();
    let race_flag_t1 = race_successful.clone();
    
    let t1 = tokio::spawn(async move {
        // Insert P1 first
        observer_data_t1.lock().insert_block_payload(payload_p1, true);
        
        // Verify payloads (simulates line 758)
        let verify_result = observer_data_t1.lock()
            .verify_payloads_against_ordered_block(&ordered_block_t1);
        assert!(verify_result.is_ok(), "P1 should verify");
        
        // Small delay to let attacker thread run
        sleep(Duration::from_micros(100)).await;
        
        // Insert ordered block (simulates line 787)
        let observed = ObservedOrderedBlock::new_for_testing(ordered_block_t1);
        observer_data_t1.lock().insert_ordered_block(observed);
    });
    
    // Thread 2: Attacker inserting P2
    let observer_data_t2 = observer_block_data.clone();
    let race_flag_t2 = race_successful.clone();
    
    let t2 = tokio::spawn(async move {
        sleep(Duration::from_micros(50)).await; // Time the attack
        
        // Check if payload exists (simulates line 373)
        let exists = observer_data_t2.lock().existing_payload_entry(&payload_p2);
        
        // If we can race past the check, insert P2
        if !exists {
            sleep(Duration::from_micros(10)).await;
            observer_data_t2.lock().insert_block_payload(payload_p2.clone(), true);
            race_flag_t2.store(true, Ordering::SeqCst);
        }
    });
    
    t1.await.unwrap();
    t2.await.unwrap();
    
    // Check if race was successful (P2 overwrote P1)
    let final_payload = observer_block_data.lock()
        .get_block_payloads()
        .lock()
        .get(&(epoch, round))
        .cloned();
        
    if let Some(BlockPayloadStatus::AvailableAndVerified(payload)) = final_payload {
        // If race succeeded, the payload should be P2 (malicious), not P1 (verified)
        if race_successful.load(Ordering::SeqCst) {
            assert_ne!(payload.transaction_payload(), payload_p1.transaction_payload(),
                "VULNERABILITY: Malicious payload P2 overwrote verified payload P1!");
        }
    }
}
```

**Notes:**
- This is a timing-dependent race condition, so the PoC may need multiple runs to trigger
- In production, network delays and concurrent message processing make this highly likely
- The vulnerability allows consensus-bypassing transaction execution, a critical severity issue

### Citations

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L367-430)
```rust
        let last_ordered_block = self.observer_block_data.lock().get_last_ordered_block();
        let payload_out_of_date =
            (block_epoch, block_round) <= (last_ordered_block.epoch(), last_ordered_block.round());
        let payload_exists = self
            .observer_block_data
            .lock()
            .existing_payload_entry(&block_payload);

        // If the payload is out of date or already exists, ignore it
        if payload_out_of_date || payload_exists {
            // Update the metrics for the dropped block payload
            update_metrics_for_dropped_block_payload_message(peer_network_id, &block_payload);
            return;
        }

        // Update the metrics for the received block payload
        update_metrics_for_block_payload_message(peer_network_id, &block_payload);

        // Verify the block payload digests
        if let Err(error) = block_payload.verify_payload_digests() {
            // Log the error and update the invalid message counter
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to verify block payload digests! Ignoring block: {:?}, from peer: {:?}. Error: {:?}",
                    block_payload.block(), peer_network_id,
                    error
                ))
            );
            increment_invalid_message_counter(&peer_network_id, metrics::BLOCK_PAYLOAD_LABEL);
            return;
        }

        // If the payload is for the current epoch, verify the proof signatures
        let epoch_state = self.get_epoch_state();
        let verified_payload = if block_epoch == epoch_state.epoch {
            // Verify the block proof signatures
            if let Err(error) = block_payload.verify_payload_signatures(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify block payload signatures! Ignoring block: {:?}, from peer: {:?}. Error: {:?}",
                        block_payload.block(), peer_network_id, error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::BLOCK_PAYLOAD_LABEL);
                return;
            }

            true // We have successfully verified the signatures
        } else {
            false // We can't verify the signatures yet
        };

        // Update the latency metrics for block payload processing
        update_message_processing_latency_metrics(
            message_received_time,
            &peer_network_id,
            metrics::BLOCK_PAYLOAD_LABEL,
        );

        // Update the payload store with the payload
        self.observer_block_data
            .lock()
            .insert_block_payload(block_payload, verified_payload);
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L755-771)
```rust
        if let Err(error) = self
            .observer_block_data
            .lock()
            .verify_payloads_against_ordered_block(&ordered_block)
        {
            // Log the error and update the invalid message counter
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to verify block payloads against ordered block! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                    ordered_block.proof_block_info(),
                    peer_network_id,
                    error
                ))
            );
            increment_invalid_message_counter(&peer_network_id, metrics::ORDERED_BLOCK_LABEL);
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L785-787)
```rust
            self.observer_block_data
                .lock()
                .insert_ordered_block(observed_ordered_block.clone());
```

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L105-109)
```rust
        // Insert the new payload status
        self.block_payloads
            .lock()
            .insert(epoch_and_round, payload_status);
    }
```

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L156-213)
```rust
    /// Verifies all block payloads against the given ordered block.
    /// If verification fails, an error is returned.
    pub fn verify_payloads_against_ordered_block(
        &mut self,
        ordered_block: &OrderedBlock,
    ) -> Result<(), Error> {
        // Verify each of the blocks in the ordered block
        for ordered_block in ordered_block.blocks() {
            // Get the block epoch and round
            let block_epoch = ordered_block.epoch();
            let block_round = ordered_block.round();

            // Fetch the block payload
            match self.block_payloads.lock().entry((block_epoch, block_round)) {
                Entry::Occupied(entry) => {
                    // Get the block transaction payload
                    let transaction_payload = match entry.get() {
                        BlockPayloadStatus::AvailableAndVerified(block_payload) => {
                            block_payload.transaction_payload()
                        },
                        BlockPayloadStatus::AvailableAndUnverified(_) => {
                            // The payload should have already been verified
                            return Err(Error::InvalidMessageError(format!(
                                "Payload verification failed! Block payload for epoch: {:?} and round: {:?} is unverified.",
                                ordered_block.epoch(),
                                ordered_block.round()
                            )));
                        },
                    };

                    // Get the ordered block payload
                    let ordered_block_payload = match ordered_block.block().payload() {
                        Some(payload) => payload,
                        None => {
                            return Err(Error::InvalidMessageError(format!(
                                "Payload verification failed! Missing block payload for epoch: {:?} and round: {:?}",
                                ordered_block.epoch(),
                                ordered_block.round()
                            )));
                        },
                    };

                    // Verify the transaction payload against the ordered block payload
                    transaction_payload.verify_against_ordered_payload(ordered_block_payload)?;
                },
                Entry::Vacant(_) => {
                    // The payload is missing (this should never happen)
                    return Err(Error::InvalidMessageError(format!(
                        "Payload verification failed! Missing block payload for epoch: {:?} and round: {:?}",
                        ordered_block.epoch(),
                        ordered_block.round()
                    )));
                },
            }
        }

        Ok(())
    }
```

**File:** consensus/src/payload_manager/co_payload_manager.rs (L29-76)
```rust
async fn get_transactions_for_observer(
    block: &Block,
    block_payloads: &Arc<Mutex<BTreeMap<(u64, Round), BlockPayloadStatus>>>,
    consensus_publisher: &Option<Arc<ConsensusPublisher>>,
) -> ExecutorResult<(Vec<SignedTransaction>, Option<u64>, Option<u64>)> {
    // The data should already be available (as consensus observer will only ever
    // forward a block to the executor once the data has been received and verified).
    let block_payload = match block_payloads.lock().entry((block.epoch(), block.round())) {
        Entry::Occupied(mut value) => match value.get_mut() {
            BlockPayloadStatus::AvailableAndVerified(block_payload) => block_payload.clone(),
            BlockPayloadStatus::AvailableAndUnverified(_) => {
                // This shouldn't happen (the payload should already be verified)
                let error = format!(
                    "Payload data for block epoch {}, round {} is unverified!",
                    block.epoch(),
                    block.round()
                );
                return Err(InternalError { error });
            },
        },
        Entry::Vacant(_) => {
            // This shouldn't happen (the payload should already be present)
            let error = format!(
                "Missing payload data for block epoch {}, round {}!",
                block.epoch(),
                block.round()
            );
            return Err(InternalError { error });
        },
    };

    // If the payload is valid, publish it to any downstream observers
    let transaction_payload = block_payload.transaction_payload();
    if let Some(consensus_publisher) = consensus_publisher {
        let message = ConsensusObserverMessage::new_block_payload_message(
            block.gen_block_info(HashValue::zero(), 0, None),
            transaction_payload.clone(),
        );
        consensus_publisher.publish_message(message);
    }

    // Return the transactions and the transaction limit
    Ok((
        transaction_payload.transactions(),
        transaction_payload.transaction_limit(),
        transaction_payload.gas_limit(),
    ))
}
```
