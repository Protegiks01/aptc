# Audit Report

## Title
Resource Leak in Subscription Stream Replacement: Pending Requests Dropped Without Response

## Summary
When a subscription request arrives with a different stream ID than an existing stream for the same peer, the old subscription stream is replaced without sending error responses to pending requests. This causes client-side oneshot receivers to get cancellation errors and wastes server resources.

## Finding Description

In the `handle_subscription_request()` function, when a new subscription request arrives with a stream ID that differs from the existing stream for that peer, the entire old stream is replaced without cleanup: [1](#0-0) 

The `replace_entry()` call returns the old `SubscriptionStreamRequests` value but it is not captured and is immediately dropped. This old stream contains pending subscription requests with their response senders.

Each `SubscriptionStreamRequests` holds pending requests in a BTreeMap: [2](#0-1) 

Each `SubscriptionRequest` contains a `ResponseSender`: [3](#0-2) 

The `ResponseSender` wraps a `oneshot::Sender`: [4](#0-3) 

**When the old stream is dropped:**
1. All pending `SubscriptionRequest` objects are dropped
2. All `ResponseSender` objects containing `oneshot::Sender` channels are dropped without calling `send()`
3. Client-side `oneshot::Receiver` objects receive cancellation errors instead of proper responses
4. Server has wasted resources processing and storing these requests

**Attack Scenario:**
A peer can send up to 30 subscription requests (the configured maximum) with stream ID X, then send a new request with stream ID Y. All 29 pending requests from stream X are dropped without response, causing wasted work and protocol violations. [5](#0-4) 

**Evidence from tests:**
The test `test_subscription_overwrite_streams` demonstrates this behavior but does not verify what happens to dropped requests: [6](#0-5) 

Other cleanup functions like `remove_expired_subscriptions` also drop streams without responding to pending requests: [7](#0-6) 

## Impact Explanation

This is a **Low Severity** issue under the Aptos bug bounty criteria (up to $1,000) as a "non-critical implementation bug":

- **Not a memory leak**: Rust's RAII properly frees all heap allocations
- **Resource management bug**: Response channels are dropped without sending, violating protocol expectations
- **Limited scope**: Only affects the specific peer sending mismatched stream IDs
- **No critical system impact**: Does not affect consensus, state consistency, funds, or other peers
- **Minimal DoS potential**: An attacker can only disrupt their own subscription requests

The issue violates protocol correctness (requests should receive responses or errors) but has minimal security impact.

## Likelihood Explanation

**Moderate likelihood** of occurrence:
- Can happen during normal operations if clients restart with new stream IDs
- Can be triggered by buggy or malicious clients intentionally
- Rate limiting and per-peer subscription limits bound the impact
- Server will process and drop up to 30 requests per stream replacement

## Recommendation

Modify `handle_subscription_request()` to send error responses to all pending requests before dropping the old stream:

```rust
if existing_stream_id != request_stream_id {
    // Send error responses to all pending requests in the old stream
    if let Some(mut old_stream_entry) = occupied_entry.get_mut() {
        let pending_requests = old_stream_entry.get_pending_subscription_requests();
        for (_, pending_request) in pending_requests.drain() {
            self.send_response(
                pending_request.request.clone(),
                Err(StorageServiceError::InvalidRequest(
                    "Subscription stream replaced with new stream ID".into()
                )),
                pending_request.take_response_sender(),
            );
        }
    }
    
    // Create and replace with new subscription stream
    let subscription_stream = SubscriptionStreamRequests::new(
        subscription_request,
        self.time_service.clone(),
    );
    occupied_entry.replace_entry(subscription_stream);
    
    update_created_stream_metrics(&peer_network_id);
}
```

Apply similar cleanup logic to `remove_expired_subscriptions` and `remove_invalid_subscriptions`.

## Proof of Concept

```rust
#[tokio::test]
async fn test_pending_requests_cleanup_on_stream_replacement() {
    // Create storage service
    let (mut mock_client, service, _, _, _) = MockClient::new(None, None);
    let subscriptions = service.get_subscriptions();
    
    let peer_network_id = PeerNetworkId::random();
    let stream_id_1 = 100u64;
    let stream_id_2 = 200u64;
    
    // Send 5 subscription requests with stream_id_1
    let mut receivers = vec![];
    for i in 0..5 {
        let receiver = subscribe_to_outputs(
            &mut mock_client, 
            peer_network_id, 
            stream_id_1, 
            i
        ).await;
        receivers.push(receiver);
    }
    
    // Wait for requests to be active
    wait_for_active_stream_requests(subscriptions.clone(), peer_network_id, 5).await;
    
    // Send new request with stream_id_2 (triggers replacement)
    let new_receiver = subscribe_to_outputs(
        &mut mock_client,
        peer_network_id,
        stream_id_2,
        0
    ).await;
    
    // Verify old requests - they should receive error responses
    // but instead they get channel cancellation
    for receiver in receivers.iter_mut() {
        match receiver.try_recv() {
            Ok(response) => {
                // Should get an error response about stream replacement
                assert!(response.is_err(), "Expected error response");
            }
            Err(e) => {
                // BUG: Receivers get cancelled instead of error response
                println!("Channel cancelled: {:?}", e);
            }
        }
    }
}
```

---

## Notes

While this is a valid resource management bug that violates protocol correctness expectations, **it does not meet the severity threshold (Medium or above) required for the bug bounty program's security vulnerability reporting**. The impact is limited to protocol correctness without critical security implications (no consensus impact, no fund loss, no network-wide availability issues). This should be addressed as a code quality improvement rather than a security vulnerability.

### Citations

**File:** state-sync/storage-service/server/src/handler.rs (L308-322)
```rust
            Entry::Occupied(mut occupied_entry) => {
                // If the stream has a different ID than the request, replace the stream.
                // Otherwise, add the request to the existing stream.
                let existing_stream_id = occupied_entry.get().subscription_stream_id();
                if existing_stream_id != request_stream_id {
                    // Create a new subscription stream for the peer
                    let subscription_stream = SubscriptionStreamRequests::new(
                        subscription_request,
                        self.time_service.clone(),
                    );
                    occupied_entry.replace_entry(subscription_stream);

                    // Update the subscription metrics
                    update_created_stream_metrics(&peer_network_id);
                } else {
```

**File:** state-sync/storage-service/server/src/subscription.rs (L46-51)
```rust
/// A single subscription request that is part of a stream
pub struct SubscriptionRequest {
    request: StorageServiceRequest,  // The original request
    response_sender: ResponseSender, // The sender along which to send the response
    request_start_time: Instant,     // The time the request started (i.e., when it was received)
}
```

**File:** state-sync/storage-service/server/src/subscription.rs (L298-311)
```rust
/// A set of subscription requests that together form a stream
#[derive(Debug)]
pub struct SubscriptionStreamRequests {
    subscription_stream_metadata: SubscriptionStreamMetadata, // The metadata for the subscription stream (as specified by the client)

    highest_known_version: u64, // The highest version known by the peer (at this point in the stream)
    highest_known_epoch: u64,   // The highest epoch known by the peer (at this point in the stream)

    next_index_to_serve: u64, // The next subscription stream request index to serve
    pending_subscription_requests: BTreeMap<u64, SubscriptionRequest>, // The pending subscription requests by stream index

    last_stream_update_time: Instant, // The last time the stream was updated
    time_service: TimeService,        // The time service
}
```

**File:** state-sync/storage-service/server/src/subscription.rs (L985-999)
```rust
/// Removes the expired subscription streams from the active map
fn remove_expired_subscriptions(
    subscriptions: Arc<DashMap<PeerNetworkId, SubscriptionStreamRequests>>,
    peers_with_expired_subscriptions: Vec<PeerNetworkId>,
) {
    for peer_network_id in peers_with_expired_subscriptions {
        if subscriptions.remove(&peer_network_id).is_some() {
            increment_counter(
                &metrics::SUBSCRIPTION_EVENTS,
                peer_network_id.network_id(),
                SUBSCRIPTION_EXPIRE.into(),
            );
        }
    }
}
```

**File:** state-sync/storage-service/server/src/network.rs (L95-99)
```rust
/// A channel for fulfilling a pending StorageService RPC request.
/// Provides a more strongly typed interface around the raw RPC response channel.
pub struct ResponseSender {
    response_tx: oneshot::Sender<Result<Bytes, RpcError>>,
}
```

**File:** config/src/config/state_sync_config.rs (L206-206)
```rust
            max_num_active_subscriptions: 30,
```

**File:** state-sync/storage-service/server/src/tests/subscription.rs (L924-1052)
```rust
#[tokio::test(flavor = "multi_thread")]
async fn test_subscription_overwrite_streams() {
    // Test both v1 and v2 data requests
    for use_request_v2 in [false, true] {
        // Create test data
        let highest_version = 45576;
        let highest_epoch = 43;
        let lowest_version = 0;
        let peer_version = highest_version - 100;
        let highest_ledger_info =
            utils::create_test_ledger_info_with_sigs(highest_epoch, highest_version);
        let output_list_with_proof = utils::create_output_list_with_proof(
            peer_version + 1,
            highest_version,
            highest_version,
            use_request_v2,
        );
        let transaction_list_with_proof = utils::create_transaction_list_with_proof(
            peer_version + 1,
            highest_version,
            highest_version,
            false,
            use_request_v2,
        );

        // Create the mock db reader
        let mut db_reader =
            mock::create_mock_db_with_summary_updates(highest_ledger_info.clone(), lowest_version);
        utils::expect_get_transaction_outputs(
            &mut db_reader,
            peer_version + 1,
            highest_version - peer_version,
            highest_version,
            output_list_with_proof.clone(),
            false,
        );
        utils::expect_get_transactions(
            &mut db_reader,
            peer_version + 1,
            highest_version - peer_version,
            highest_version,
            false,
            transaction_list_with_proof.clone(),
            false,
        );

        // Create a storage service config
        let storage_config = utils::create_storage_config(use_request_v2, false);

        // Create the storage client and server
        let (mut mock_client, service, storage_service_notifier, mock_time, _) =
            MockClient::new(Some(db_reader), Some(storage_config));
        let active_subscriptions = service.get_subscriptions();
        tokio::spawn(service.start());

        // Create a peer network ID and stream ID
        let peer_network_id = PeerNetworkId::random();
        let stream_id = utils::get_random_u64();

        // Send multiple requests to subscribe to transaction outputs with the stream ID
        let num_stream_requests = 10;
        let mut response_receivers = utils::send_output_subscription_request_batch(
            &mut mock_client,
            peer_network_id,
            0,
            num_stream_requests - 1,
            stream_id,
            peer_version,
            highest_epoch,
            use_request_v2,
            storage_config.max_network_chunk_bytes_v2,
        )
        .await;

        // Wait until the stream requests are active
        utils::wait_for_active_stream_requests(
            active_subscriptions.clone(),
            peer_network_id,
            num_stream_requests as usize,
        )
        .await;

        // Verify no subscription response has been received yet
        utils::verify_no_subscription_responses(&mut response_receivers);

        // Force the subscription handler to work
        utils::force_subscription_handler_to_run(
            &mut mock_client,
            &mock_time,
            &storage_service_notifier,
        )
        .await;

        // Verify that the correct response is received (when it comes through)
        utils::verify_output_subscription_response(
            vec![output_list_with_proof.clone()],
            highest_ledger_info.clone(),
            &mut mock_client,
            &mut response_receivers,
            0,
            use_request_v2,
        )
        .await;

        // Send a request to subscribe to transactions with a new stream ID
        let new_stream_id = utils::get_random_u64();
        let response_receiver = utils::subscribe_to_transactions_for_peer(
            &mut mock_client,
            peer_version,
            highest_epoch,
            false,
            new_stream_id,
            0,
            Some(peer_network_id),
            use_request_v2,
            storage_config.max_network_chunk_bytes_v2,
        )
        .await;

        // Wait until the stream requests are active
        utils::wait_for_active_stream_requests(active_subscriptions.clone(), peer_network_id, 1)
            .await;

        // Verify the new stream ID has been used
        utils::verify_active_stream_id_for_peer(
            active_subscriptions.clone(),
            peer_network_id,
            new_stream_id,
        );
```
