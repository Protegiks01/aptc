# Audit Report

## Title
Unauthenticated Access to Backup Service Endpoints - Configuration Issue with Limited Security Impact

## Summary
The BackupServiceClient::new_with_opt() does not enforce mutual TLS or any authentication mechanism, allowing unauthenticated connections to the backup service. However, after thorough analysis, this constitutes a **configuration and operational concern** rather than a critical security vulnerability, as the exposed data is public blockchain information already accessible through other interfaces.

## Finding Description

The backup service implementation lacks authentication at multiple layers:

**Client Side - No Authentication Implementation:** [1](#0-0) 

The client creates a plain HTTP reqwest client with no TLS configuration or authentication headers.

**Server Side - No Authentication Middleware:** [2](#0-1) 

All routes are exposed via plain `warp::get()` without any authentication filters or middleware.

**Production Misconfiguration:** [3](#0-2) 

The default Helm configuration binds to `0.0.0.0:6186` instead of `127.0.0.1:6186`, exposing the service beyond localhost. [4](#0-3) 

Kubernetes Service explicitly exposes port 6186.

**Exposed Data:** [5](#0-4) 

The backup service exposes transaction data, events, write sets, and auxiliary information. [6](#0-5) 

It also provides complete state snapshots at any version.

## Impact Explanation

**Why This Does NOT Meet Critical/High Severity Criteria:**

1. **Public Data by Design**: All exposed data (transactions, state, events) is inherently public on a blockchain and already accessible via:
   - REST API endpoints
   - State synchronization protocols  
   - On-chain queries

2. **No Funds Impact**: Read-only access cannot steal, freeze, or mint funds.

3. **No Consensus Impact**: The service is read-only and cannot manipulate validator state or cause consensus violations.

4. **DoS Out of Scope**: Resource exhaustion through bulk downloads is explicitly excluded per bug bounty rules.

**Documentation Intent vs. Reality:** [7](#0-6) 

The documentation states the service should be "localhost only," but production configurations violate this assumption.

## Likelihood Explanation

**High Likelihood of Misconfiguration:**
- Default Helm charts bind to `0.0.0.0:6186`
- Kubernetes Service exposes the port
- No warnings about security implications

**Low Likelihood of Security Impact:**
- Data is already public
- No attack vector for funds/consensus
- Primarily an operational efficiency concern

## Recommendation

While not a critical vulnerability, the following improvements would align implementation with documented security intent:

1. **Add Authentication Option:**
```rust
// In BackupServiceClientOpt
pub struct BackupServiceClientOpt {
    pub address: String,
    #[clap(long)]
    pub api_key: Option<String>,
}

// In server handlers, add auth middleware
fn auth_filter(api_key: String) -> impl Filter<Extract = (), Error = warp::Rejection> + Clone {
    warp::header::optional("X-API-Key")
        .and_then(move |key: Option<String>| async move {
            if key == Some(api_key.clone()) {
                Ok(())
            } else {
                Err(warp::reject::reject())
            }
        })
}
```

2. **Update Default Configuration:** [8](#0-7) 

Keep the safe default of `127.0.0.1:6186` and add explicit warnings in Helm charts about binding to public interfaces.

3. **Add Documentation Warnings** about exposing backup service on public networks.

## Proof of Concept

This is not a traditional exploit PoC, but a demonstration of unauthenticated access:

```bash
# From any host with network access to the node
curl http://NODE_IP:6186/db_state

# Download transactions without credentials  
curl http://NODE_IP:6186/transactions/0/1000

# Access state snapshot
curl http://NODE_IP:6186/state_snapshot_chunk/1000000/0/100
```

**Result**: Successful data retrieval without authentication.

**Impact**: Access to public blockchain data through an unauthenticated interface - operational concern, not critical security vulnerability.

---

## Notes

After thorough investigation, while the lack of authentication on the backup service is a **real implementation gap** that contradicts documented security intent, it does **NOT** constitute a reportable vulnerability under the strict Aptos bug bounty criteria because:

- No private/confidential data is exposed (blockchain data is inherently public)
- No impact on funds, consensus, or network integrity
- No exploitable path to critical severity outcomes
- Falls into "operational misconfiguration" rather than "security vulnerability"

The issue should be addressed as a **security hardening improvement** rather than a critical vulnerability fix.

### Citations

**File:** storage/backup/backup-cli/src/utils/backup_service_client.rs (L45-53)
```rust
    pub fn new(address: String) -> Self {
        Self {
            address,
            client: reqwest::Client::builder()
                .no_proxy()
                .build()
                .expect("Http client should build."),
        }
    }
```

**File:** storage/backup/backup-service/src/handlers/mod.rs (L137-147)
```rust
    warp::get()
        .and(routes)
        .with(warp::log::custom(|info| {
            let endpoint = info.path().split('/').nth(1).unwrap_or("-");
            LATENCY_HISTOGRAM.observe_with(
                &[endpoint, info.status().as_str()],
                info.elapsed().as_secs_f64(),
            )
        }))
        .boxed()
}
```

**File:** terraform/helm/aptos-node/files/configs/fullnode-base.yaml (L16-16)
```yaml
  backup_service_address: "0.0.0.0:6186"
```

**File:** terraform/helm/fullnode/templates/service.yaml (L53-54)
```yaml
  - name: backup
    port: 6186
```

**File:** storage/aptosdb/src/backup/backup_handler.rs (L41-109)
```rust
    pub fn get_transaction_iter(
        &self,
        start_version: Version,
        num_transactions: usize,
    ) -> Result<
        impl Iterator<
                Item = Result<(
                    Transaction,
                    PersistedAuxiliaryInfo,
                    TransactionInfo,
                    Vec<ContractEvent>,
                    WriteSet,
                )>,
            > + '_,
    > {
        let txn_iter = self
            .ledger_db
            .transaction_db()
            .get_transaction_iter(start_version, num_transactions)?;
        let mut txn_info_iter = self
            .ledger_db
            .transaction_info_db()
            .get_transaction_info_iter(start_version, num_transactions)?;
        let mut event_vec_iter = self
            .ledger_db
            .event_db()
            .get_events_by_version_iter(start_version, num_transactions)?;
        let mut write_set_iter = self
            .ledger_db
            .write_set_db()
            .get_write_set_iter(start_version, num_transactions)?;
        let mut persisted_aux_info_iter = self
            .ledger_db
            .persisted_auxiliary_info_db()
            .get_persisted_auxiliary_info_iter(start_version, num_transactions)?;

        let zipped = txn_iter.enumerate().map(move |(idx, txn_res)| {
            let version = start_version + idx as u64; // overflow is impossible since it's check upon txn_iter construction.

            let txn = txn_res?;
            let txn_info = txn_info_iter.next().ok_or_else(|| {
                AptosDbError::NotFound(format!(
                    "TransactionInfo not found when Transaction exists, version {}",
                    version
                ))
            })??;
            let event_vec = event_vec_iter.next().ok_or_else(|| {
                AptosDbError::NotFound(format!(
                    "Events not found when Transaction exists., version {}",
                    version
                ))
            })??;
            let write_set = write_set_iter.next().ok_or_else(|| {
                AptosDbError::NotFound(format!(
                    "WriteSet not found when Transaction exists, version {}",
                    version
                ))
            })??;
            let persisted_aux_info = persisted_aux_info_iter.next().ok_or_else(|| {
                AptosDbError::NotFound(format!(
                    "PersistedAuxiliaryInfo not found when Transaction exists, version {}",
                    version
                ))
            })??;
            BACKUP_TXN_VERSION.set(version as i64);
            Ok((txn, persisted_aux_info, txn_info, event_vec, write_set))
        });
        Ok(zipped)
    }
```

**File:** storage/aptosdb/src/backup/backup_handler.rs (L145-162)
```rust
    pub fn get_state_item_iter(
        &self,
        version: Version,
        start_idx: usize,
        limit: usize,
    ) -> Result<impl Iterator<Item = Result<(StateKey, StateValue)>> + Send + use<>> {
        let iterator = self
            .state_store
            .get_state_key_and_value_iter(version, start_idx)?
            .take(limit)
            .enumerate()
            .map(move |(idx, res)| {
                BACKUP_STATE_SNAPSHOT_VERSION.set(version as i64);
                BACKUP_STATE_SNAPSHOT_LEAF_IDX.set((start_idx + idx) as i64);
                res
            });
        Ok(Box::new(iterator))
    }
```

**File:** storage/README.md (L64-66)
```markdown
  # Address the backup service listens on. By default the port is open to only
  # the localhost, so the backup cli tool can only access data in the same host.
  backup_service_address: "127.0.0.1:6186"
```

**File:** config/src/config/storage_config.rs (L436-436)
```rust
            backup_service_address: SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), 6186),
```
