# Audit Report

## Title
Stack Overflow DoS in Indexer Transaction Filter via Unbounded Recursive Depth

## Summary
The `BooleanTransactionFilter` in the indexer-grpc service lacks recursion depth validation, allowing attackers to craft deeply nested filters that bypass size checks and cause stack overflow during parsing, validation, or transaction matching operations, resulting in denial of service of the indexer API.

## Finding Description

The `BooleanTransactionFilter` implements a recursive data structure supporting nested logical operators (AND, OR, NOT). While the implementation includes a size check to prevent overly large filters, it completely lacks depth checking for recursion, creating multiple attack vectors.

**Attack Vector 1: Size Check Bypass in Nested Filters**

The size check only applies at the top-level protobuf message. When parsing nested filters, `None` is explicitly passed for `max_filter_size`, completely bypassing size validation: [1](#0-0) [2](#0-1) [3](#0-2) 

The top-level size check at lines 98-107 does not prevent deeply nested structures: [4](#0-3) 

**Attack Vector 2: Unbounded Recursion During Validation**

The `validate_state` function recursively validates nested filters without any depth limit: [5](#0-4) [6](#0-5) [7](#0-6) 

**Attack Vector 3: Unbounded Recursion During Transaction Matching**

The `matches` function is called for every transaction being streamed and recursively evaluates nested filters: [8](#0-7) [9](#0-8) 

**User-Controlled Input Vector**

The filter is user-provided via the `GetTransactionsRequest` gRPC message: [10](#0-9) [11](#0-10) 

**Protobuf Schema Allows Recursive Nesting**

The protobuf schema explicitly permits unbounded recursive nesting: [12](#0-11) 

**Attack Scenario:**

1. Attacker crafts a filter with extreme nesting: `NOT(NOT(NOT(...NOT(APIFilter)...)))`
2. With the default 10KB size limit, protobuf encoding allows ~3,000-4,000 nesting levels
3. Each recursion level consumes stack space; Rust's default 2MB stack typically overflows at 1,000-10,000 recursive calls depending on function complexity
4. Stack overflow triggers a panic, crashing the request handler thread
5. Attacker can repeatedly send such filters to continuously crash indexer threads

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria for "API crashes."

While this does not directly impact consensus, validator nodes, or on-chain state (the core blockchain continues operating normally), it enables:

1. **Denial of Service of Indexer API**: Attackers can repeatedly crash indexer-grpc service threads, preventing legitimate users from querying blockchain data
2. **Service Disruption**: Applications relying on the indexer for transaction history, event queries, and analytics would experience failures
3. **Resource Exhaustion**: Repeated exploitation could exhaust server resources through crash/restart cycles

The indexer-grpc service is a critical infrastructure component for the Aptos ecosystem, providing essential data access for dApps, wallets, and analytics platforms.

## Likelihood Explanation

**Likelihood: HIGH**

1. **Low Attack Complexity**: Crafting a deeply nested protobuf message is trivial using standard protobuf libraries
2. **No Authentication Barriers**: The attack works against any exposed indexer endpoint accepting user-provided filters
3. **Deterministic Exploitation**: Stack overflow is deterministic given sufficient nesting depth
4. **Easily Automated**: Attackers can script continuous exploitation
5. **Detectable but Difficult to Mitigate**: Rate limiting alone cannot prevent this without depth validation

The vulnerability is present in production deployments accepting user-provided transaction filters via the `GetTransactionsRequest` API.

## Recommendation

Implement recursion depth validation in `BooleanTransactionFilter::new_from_proto`:

```rust
pub fn new_from_proto(
    proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
    max_filter_size: Option<usize>,
    max_depth: Option<usize>, // Add depth parameter
) -> Result<Self> {
    // Check size limit
    if let Some(max_filter_size) = max_filter_size {
        ensure!(
            proto_filter.encoded_len() <= max_filter_size,
            format!("Filter is too complicated. Max size: {} bytes", max_filter_size)
        );
    }
    
    // Check depth limit
    if let Some(max_depth) = max_depth {
        ensure!(max_depth > 0, "Maximum recursion depth exceeded");
    }
    
    // Decrement depth for nested calls
    let nested_depth = max_depth.map(|d| d.saturating_sub(1));
    
    Ok(match proto_filter.filter.ok_or(anyhow!("Oneof is not set"))? {
        // Pass decremented depth to nested filters
        aptos_protos::indexer::v1::boolean_transaction_filter::Filter::LogicalAnd(
            logical_and,
        ) => BooleanTransactionFilter::And(logical_and.try_into_with_depth(nested_depth)?),
        // Similar for LogicalOr and LogicalNot
        // ...
    })
}
```

Add a reasonable depth limit (e.g., 100 levels) in the parsing function and propagate it through all nested filter constructions.

## Proof of Concept

A complete PoC would require:
1. Generating a deeply nested `BooleanTransactionFilter` protobuf message (3000+ levels of NOT operators)
2. Sending it via `GetTransactionsRequest` to an indexer-grpc endpoint
3. Observing the stack overflow panic in the service logs

Example protobuf structure (pseudocode):
```
filter = NOT(NOT(NOT(...[3000 times]...NOT(UserTransactionFilter{sender: "0x1"}))))
```

This can be constructed programmatically and will deterministically cause a stack overflow when processed.

## Notes

This is an application-level logic vulnerability (unbounded recursion), not a network-level DoS attack. It qualifies as "API crashes" under the High severity category of the Aptos bug bounty program. The vulnerability affects the indexer-grpc service which, while not part of core consensus, is a critical API infrastructure component for the Aptos ecosystem.

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L98-107)
```rust
        if let Some(max_filter_size) = max_filter_size {
            ensure!(
                proto_filter.encoded_len() <= max_filter_size,
                format!(
                    "Filter is too complicated. Max size: {} bytes, Actual size: {} bytes",
                    max_filter_size,
                    proto_filter.encoded_len()
                )
            );
        }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L241-248)
```rust
    fn validate_state(&self) -> Result<(), FilterError> {
        match self {
            BooleanTransactionFilter::And(and) => and.is_valid(),
            BooleanTransactionFilter::Or(or) => or.is_valid(),
            BooleanTransactionFilter::Not(not) => not.is_valid(),
            BooleanTransactionFilter::Filter(filter) => filter.is_valid(),
        }
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L250-258)
```rust
    fn matches(&self, item: &Transaction) -> bool {
        match self {
            BooleanTransactionFilter::And(and) => and.matches(item),
            BooleanTransactionFilter::Or(or) => or.matches(item),
            BooleanTransactionFilter::Not(not) => not.matches(item),
            BooleanTransactionFilter::Filter(filter) => filter.matches(item),
        }
    }
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L265-276)
```rust
impl TryFrom<aptos_protos::indexer::v1::LogicalAndFilters> for LogicalAnd {
    type Error = anyhow::Error;

    fn try_from(proto_filter: aptos_protos::indexer::v1::LogicalAndFilters) -> Result<Self> {
        Ok(Self {
            and: proto_filter
                .filters
                .into_iter()
                .map(|f| BooleanTransactionFilter::new_from_proto(f, None))
                .collect::<Result<_>>()?,
        })
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L287-293)
```rust
impl Filterable<Transaction> for LogicalAnd {
    fn validate_state(&self) -> Result<(), FilterError> {
        for filter in &self.and {
            filter.is_valid()?;
        }
        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L305-317)
```rust
impl TryFrom<aptos_protos::indexer::v1::LogicalOrFilters> for LogicalOr {
    type Error = anyhow::Error;

    fn try_from(proto_filter: aptos_protos::indexer::v1::LogicalOrFilters) -> Result<Self> {
        Ok(Self {
            or: proto_filter
                .filters
                .into_iter()
                .map(|f| BooleanTransactionFilter::new_from_proto(f, None))
                .collect::<Result<_>>()?,
        })
    }
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L327-333)
```rust
impl Filterable<Transaction> for LogicalOr {
    fn validate_state(&self) -> Result<(), FilterError> {
        for filter in &self.or {
            filter.is_valid()?;
        }
        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L345-358)
```rust
impl TryFrom<Box<aptos_protos::indexer::v1::BooleanTransactionFilter>> for LogicalNot {
    type Error = anyhow::Error;

    fn try_from(
        proto_filter: Box<aptos_protos::indexer::v1::BooleanTransactionFilter>,
    ) -> Result<Self> {
        Ok(Self {
            not: Box::new(BooleanTransactionFilter::new_from_proto(
                *proto_filter,
                None,
            )?),
        })
    }
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L175-179)
```rust
                let pb_txns = if let Some(ref filter) = filter {
                    pb_txns
                        .into_iter()
                        .filter(|txn| filter.matches(txn))
                        .collect::<Vec<_>>()
```

**File:** protos/proto/aptos/indexer/v1/raw_data.proto (L31-33)
```text
  // If provided, only transactions that match the filter will be included.
  optional BooleanTransactionFilter transaction_filter = 4;
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/localnet_data_service.rs (L63-71)
```rust
        // Parse transaction filter if present.
        let filter = if let Some(proto_filter) = r.transaction_filter {
            Some(parse_transaction_filter(
                proto_filter,
                self.service_context.max_transaction_filter_size_bytes,
            )?)
        } else {
            None
        };
```

**File:** protos/proto/aptos/indexer/v1/filter.proto (L58-65)
```text
message BooleanTransactionFilter {
  oneof filter {
      APIFilter api_filter = 1;
      LogicalAndFilters logical_and = 2;
      LogicalOrFilters logical_or = 3;
      BooleanTransactionFilter logical_not = 4;
  }
}
```
