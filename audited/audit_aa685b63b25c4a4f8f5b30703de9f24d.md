# Audit Report

## Title
Compilation Metadata Bypass Allows Unstable Bytecode Deployment on Mainnet

## Summary
The `reject_unstable_bytecode()` function fails to enforce the presence of compilation metadata, allowing attackers to bypass the unstable bytecode rejection mechanism by simply removing the `COMPILATION_METADATA_KEY` from compiled modules. This enables deployment of experimental/unstable compiler features on production mainnet.

## Finding Description

The security control designed to prevent unstable bytecode from being published on mainnet can be completely bypassed through metadata removal. The vulnerability exists in the interaction between two functions: [1](#0-0) 

The `get_compilation_metadata()` function returns `Option<CompilationMetadata>` - it returns `None` when no compilation metadata exists in the module. This is then consumed by: [2](#0-1) 

The critical flaw is that `reject_unstable_bytecode()` only rejects modules **if** compilation metadata exists **and** is marked unstable. When metadata is absent, the function returns `Ok(())` and allows publication.

The metadata format validation function also doesn't require compilation metadata presence: [3](#0-2) 

**Attack Execution Path:**

1. Attacker compiles Move code using unstable compiler (V2_1) or language version (V2_4/V2_5)
2. Compiler generates bytecode with `COMPILATION_METADATA_KEY` containing `unstable: true`
3. Attacker manually removes the `COMPILATION_METADATA_KEY` entry from the bytecode metadata section
4. Attacker submits transaction to publish module on mainnet
5. During validation in `validate_publish_request()`, the `reject_unstable_bytecode()` call at line 1689 executes
6. Since no metadata exists, `get_compilation_metadata()` returns `None`
7. The unstable check is skipped, returning `Ok(())`
8. Module is successfully published on mainnet with unstable features

The unstable flag definition confirms this is meant to restrict deployment: [4](#0-3) [5](#0-4) [6](#0-5) 

## Impact Explanation

This is a **Medium Severity** vulnerability per Aptos bug bounty criteria:

- **State inconsistencies requiring intervention**: Unstable bytecode features are explicitly marked experimental and may contain bugs that could cause state inconsistencies across validators
- **Security control bypass**: Directly circumvents an explicit mainnet safety mechanism
- **Potential consensus risk**: Different validator implementations or versions might interpret unstable features differently, risking consensus splits

While other validation layers (bytecode verifier, version checks, feature flags) still apply, the unstable flag serves as an additional safety layer specifically designed to prevent deployment of experimental features. Bypassing this control exposes the network to:

- Untested code paths with potential security vulnerabilities
- Features that may not be fully consensus-safe
- Breaking changes not yet ready for production use

The impact is limited to Medium (not Critical/High) because:
- No direct fund loss occurs
- Other validation mechanisms remain in place
- Actual harm depends on specific unstable features exploited

## Likelihood Explanation

**Likelihood: Medium-to-High**

- **Attacker capability required**: Low - any user can compile Move code and modify bytecode
- **Technical complexity**: Medium - requires understanding of BCS serialization and bytecode structure to remove metadata entries
- **Detection difficulty**: High - no monitoring exists for missing compilation metadata
- **Attack surface**: Any module publication on mainnet
- **Motivation**: Attackers wanting to use experimental features or exploit untested code paths

The attack is practical and doesn't require validator access or special privileges. Tools for bytecode manipulation are readily available, making this bypass accessible to moderately sophisticated attackers.

## Recommendation

**Fix: Enforce Compilation Metadata Presence**

Modify `reject_unstable_bytecode()` to require compilation metadata for all modules published on mainnet:

```rust
fn reject_unstable_bytecode(&self, modules: &[CompiledModule]) -> VMResult<()> {
    if self.chain_id().is_mainnet() {
        for module in modules {
            // Require compilation metadata to be present on mainnet
            let metadata = get_compilation_metadata(module)
                .ok_or_else(|| {
                    PartialVMError::new(StatusCode::CONSTRAINT_NOT_SATISFIED)
                        .with_message("compilation metadata required on mainnet".to_string())
                        .finish(Location::Undefined)
                })?;
            
            // Then check if it's unstable
            if metadata.unstable {
                return Err(PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                    .with_message("code marked unstable cannot be published on mainnet".to_string())
                    .finish(Location::Undefined));
            }
        }
    }
    Ok(())
}
```

Apply the same fix to `reject_unstable_bytecode_for_script()` at line 1760.

Additionally, update `check_metadata_format()` to enforce compilation metadata presence when resource groups are enabled.

## Proof of Concept

**Reproduction Steps:**

1. **Compile with unstable features:**
```bash
# Set compiler to use unstable version
aptos move compile --compiler-version 2.1 --package-dir ./test_module
```

2. **Extract and modify bytecode:**
```python
import bcs
from move_binary_format import CompiledModule

# Load compiled module
with open('build/TestModule/bytecode_modules/TestModule.mv', 'rb') as f:
    bytecode = f.read()

# Deserialize
module = CompiledModule.deserialize(bytecode)

# Remove COMPILATION_METADATA_KEY
COMPILATION_METADATA_KEY = b"compilation_metadata"
module.metadata = [m for m in module.metadata if m.key != COMPILATION_METADATA_KEY]

# Re-serialize
modified_bytecode = module.serialize()

# Save modified bytecode
with open('modified_module.mv', 'wb') as f:
    f.write(modified_bytecode)
```

3. **Publish on mainnet test:**
```bash
# Attempt to publish the modified module
aptos move publish --bytecode-path ./modified_module.mv --network mainnet
```

**Expected Result:** Module publishes successfully despite containing unstable features

**Actual Secure Behavior:** Should be rejected with "compilation metadata required on mainnet"

## Notes

The vulnerability exists because the metadata validation treats compilation metadata as optional documentation rather than a required security control. The fix must distinguish between legacy modules (which may legitimately lack compilation metadata) and new publications where it should be mandatory. Consider adding a feature flag to control this transition if backward compatibility is a concern.

### Citations

**File:** types/src/vm/module_metadata.rs (L253-283)
```rust
fn check_metadata_format(module: &CompiledModule) -> Result<(), MalformedError> {
    let mut exist = false;
    let mut compilation_key_exist = false;
    for data in module.metadata.iter() {
        if data.key == *APTOS_METADATA_KEY || data.key == *APTOS_METADATA_KEY_V1 {
            if exist {
                return Err(MalformedError::DuplicateKey);
            }
            exist = true;

            if data.key == *APTOS_METADATA_KEY {
                bcs::from_bytes::<RuntimeModuleMetadata>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            } else if data.key == *APTOS_METADATA_KEY_V1 {
                bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            }
        } else if data.key == *COMPILATION_METADATA_KEY {
            if compilation_key_exist {
                return Err(MalformedError::DuplicateKey);
            }
            compilation_key_exist = true;
            bcs::from_bytes::<CompilationMetadata>(&data.value)
                .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
        } else {
            return Err(MalformedError::UnknownKey(data.key.clone()));
        }
    }

    Ok(())
}
```

**File:** types/src/vm/module_metadata.rs (L311-317)
```rust
pub fn get_compilation_metadata(code: &impl CompiledCodeMetadata) -> Option<CompilationMetadata> {
    if let Some(data) = find_metadata(code.metadata(), COMPILATION_METADATA_KEY) {
        bcs::from_bytes::<CompilationMetadata>(&data.value).ok()
    } else {
        None
    }
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1742-1757)
```rust
    fn reject_unstable_bytecode(&self, modules: &[CompiledModule]) -> VMResult<()> {
        if self.chain_id().is_mainnet() {
            for module in modules {
                if let Some(metadata) = get_compilation_metadata(module) {
                    if metadata.unstable {
                        return Err(PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                            .with_message(
                                "code marked unstable is not published on mainnet".to_string(),
                            )
                            .finish(Location::Undefined));
                    }
                }
            }
        }
        Ok(())
    }
```

**File:** third_party/move/move-model/src/metadata.rs (L49-62)
```rust
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct CompilationMetadata {
    /// A flag indicating whether, at time of creation, the compilation
    /// result was considered as unstable. Unstable code may have restrictions
    /// for deployment on production networks. This flag is true if either the
    /// compiler or language versions are unstable.
    pub unstable: bool,
    /// The version of the compiler, as a string. See
    /// `CompilationVersion::from_str` for supported version strings.
    pub compiler_version: String,
    /// The version of the language, as a string. See
    /// `LanguageVersion::from_str` for supported version strings.
    pub language_version: String,
}
```

**File:** third_party/move/move-model/src/metadata.rs (L148-157)
```rust
impl CompilerVersion {
    /// Return true if this is a stable compiler version. A non-stable version
    /// should not be allowed on production networks.
    pub fn unstable(self) -> bool {
        match self {
            CompilerVersion::V1 => false,
            CompilerVersion::V2_0 => false,
            CompilerVersion::V2_1 => true,
        }
    }
```

**File:** third_party/move/move-model/src/metadata.rs (L286-294)
```rust
    /// Whether the language version is unstable. An unstable version
    /// should not be allowed on production networks.
    pub const fn unstable(self) -> bool {
        use LanguageVersion::*;
        match self {
            V1 | V2_0 | V2_1 | V2_2 | V2_3 => false,
            V2_4 | V2_5 => true,
        }
    }
```
