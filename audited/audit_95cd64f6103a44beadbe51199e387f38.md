# Audit Report

## Title
Database Truncation Incomplete: Multiple Schemas Not Truncated Leading to State Inconsistency

## Summary
The database truncation test in `test_truncation()` does not validate all version-indexed schemas that are written during normal operations. Multiple schemas that store version-related data are either: (1) truncated but not tested, or (2) written to the database but not truncated at all. This creates a testing gap where truncation bugs can go undetected, and in some cases, causes actual database corruption when the truncation tool is used.

## Finding Description

The `test_truncation()` function validates that database truncation correctly removes data for versions greater than the target version. [1](#0-0) 

However, investigation reveals multiple schemas with version-indexed keys that are **not** validated by this test:

**Schemas truncated but NOT tested:**
1. **EventSchema** - Key=(Version, Index), truncated via `delete_event_data()` [2](#0-1) 
2. **EventAccumulatorSchema** - Key=(Version, Position), truncated via `prune_event_indices()` [3](#0-2) 
3. **TransactionByHashSchema** - Value=Version, truncated via `prune_transaction_by_hash_indices()` [4](#0-3) 
4. **TransactionAccumulatorRootHashSchema** - Key=Version, truncated via `delete_per_version_data_impl()` [5](#0-4) 
5. **TransactionSummariesByAccountSchema** - Key=(AccountAddress, Version), truncated via `delete_transactions_and_transaction_summary_data()` [6](#0-5) 

**Schemas written but NOT truncated and NOT tested:**
6. **BlockByVersionSchema** - Key=Version, written during commits when `skip_index_and_usage=true` [7](#0-6)  but **never truncated** (confirmed absent from `truncation_helper.rs`)

This directly confirms the security question: **truncation bugs in new schemas CAN go undetected** because:
- If a schema is truncated but not tested, silent failures won't be caught
- If a schema is written but not truncated, it causes database inconsistency

The most severe case is **BlockByVersionSchema**, which maps transaction versions to block heights. It is actively written during normal operations but completely absent from truncation logic, meaning after truncation to version N, entries for versions > N will persist, creating database corruption.

This breaks the **State Consistency** invariant (Critical Invariant #4): "State transitions must be atomic and verifiable via Merkle proofs" - the truncation operation is not atomic across all schemas.

## Impact Explanation

**Severity: Low (as marked in the original question)**

While this causes state inconsistency, it does NOT meet the criteria for Medium or higher severity because:

1. **Not exploitable by unprivileged attackers**: Truncation is an administrative tool requiring node operator privileges [8](#0-7) 
2. **Requires legitimate admin action**: The bug only manifests when operators run the truncation command
3. **Testing gap, not attack vector**: This is primarily a test completeness issue

The impact is limited to scenarios where node operators legitimately use the truncation tool (e.g., for database recovery or testing), at which point the resulting database inconsistency could cause:
- Node divergence from network consensus
- Incorrect query results for block metadata
- State sync failures

This qualifies as **Low severity** per the bug bounty criteria: "Non-critical implementation bugs" combined with a testing gap.

## Likelihood Explanation

**Likelihood: Low-Medium**

The issue manifests only when:
1. Node operators run the truncation command (infrequent administrative operation)
2. AND the database contains entries in the missing schemas (BlockByVersionSchema is used when `skip_index_and_usage=true`)
3. AND subsequent queries access the orphaned data

The testing gap makes it likely that **future schemas** added without proper truncation support will go undetected until production use.

## Recommendation

**Fix 1: Complete the test coverage**
Add validation for all version-indexed schemas in `test_truncation()`:

```rust
// Add after line 352 in test_truncation()

// Validate EventSchema
let mut iter = ledger_db.event_db_raw().iter::<EventSchema>().unwrap();
iter.seek_to_last();
if let Some(((version, _), _)) = iter.next().transpose().unwrap() {
    prop_assert!(version <= target_version);
}

// Validate EventAccumulatorSchema  
let mut iter = ledger_db.event_db_raw().iter::<EventAccumulatorSchema>().unwrap();
iter.seek_to_last();
if let Some(((version, _), _)) = iter.next().transpose().unwrap() {
    prop_assert!(version <= target_version);
}

// Validate TransactionAccumulatorRootHashSchema
let mut iter = ledger_db.transaction_accumulator_db_raw().iter::<TransactionAccumulatorRootHashSchema>().unwrap();
iter.seek_to_last();
if let Some((version, _)) = iter.next().transpose().unwrap() {
    prop_assert!(version <= target_version);
}

// Validate BlockByVersionSchema
let mut iter = ledger_metadata_db.iter::<BlockByVersionSchema>().unwrap();
iter.seek_to_last();
if let Some((version, _)) = iter.next().transpose().unwrap() {
    prop_assert!(version <= target_version);
}
```

**Fix 2: Add truncation for BlockByVersionSchema**
In `truncation_helper.rs`, add to `delete_per_epoch_data()`:

```rust
// Add BlockByVersionSchema truncation
delete_per_version_data_impl::<BlockByVersionSchema>(
    ledger_db,
    start_version,
    batch,
)?;
```

**Fix 3: Create comprehensive schema registry**
Maintain a central registry of all version-indexed schemas that must be checked during truncation, making it impossible to add a new schema without considering truncation.

## Proof of Concept

```rust
// Add to storage/aptosdb/src/db_debugger/truncate/mod.rs test section
#[test]
fn test_block_by_version_schema_truncation_bug() {
    use crate::schema::block_by_version::BlockByVersionSchema;
    
    let tmp_dir = TempPath::new();
    let db = AptosDB::new_for_test(&tmp_dir);
    
    // Commit transactions with block events
    // ... (commit logic with NewBlockEvent)
    
    let initial_version = db.expect_synced_version();
    
    // Run truncation to version 50
    let cmd = Cmd {
        db_dir: tmp_dir.path().to_path_buf(),
        target_version: 50,
        opt_out_backup_checkpoint: true,
        // ... other params
    };
    cmd.run().unwrap();
    
    // BUG: BlockByVersionSchema still contains entries > 50
    let (ledger_db, _, _, _) = AptosDB::open_dbs(...);
    let mut iter = ledger_db.metadata_db().iter::<BlockByVersionSchema>().unwrap();
    iter.seek_to_last();
    
    if let Some((version, _)) = iter.next().transpose().unwrap() {
        // This assertion would FAIL, proving the bug
        assert!(version <= 50, "BlockByVersionSchema not truncated! Found version {}", version);
    }
}
```

## Notes

This finding validates the original security question: **Yes, truncation bugs in new schemas CAN go undetected** due to incomplete test coverage. The test only validates 12 schemas [9](#0-8)  while the codebase contains at least 25 schemas [10](#0-9) , with 5+ schemas being truncated but untested, and at least 1 schema (BlockByVersionSchema) being written but never truncated.

### Citations

**File:** storage/aptosdb/src/db_debugger/truncate/mod.rs (L47-63)
```rust
impl Cmd {
    pub fn run(self) -> Result<()> {
        if !self.opt_out_backup_checkpoint {
            let backup_checkpoint_dir = self.backup_checkpoint_dir.unwrap();
            ensure!(
                !backup_checkpoint_dir.exists(),
                "Backup dir already exists."
            );
            println!("Creating backup at: {:?}", &backup_checkpoint_dir);
            fs::create_dir_all(&backup_checkpoint_dir)?;
            AptosDB::create_checkpoint(
                &self.db_dir,
                backup_checkpoint_dir,
                self.sharding_config.enable_storage_sharding,
            )?;
            println!("Done!");
        } else {
```

**File:** storage/aptosdb/src/db_debugger/truncate/mod.rs (L194-194)
```rust
        fn test_truncation(input in arb_blocks_to_commit_with_block_nums(80, 120)) {
```

**File:** storage/aptosdb/src/db_debugger/truncate/mod.rs (L272-391)
```rust
            let mut iter = ledger_db.transaction_accumulator_db_raw().iter::<TransactionAccumulatorSchema>().unwrap();
            iter.seek_to_last();
            let position = iter.next().transpose().unwrap().unwrap().0;
            prop_assert_eq!(position.to_postorder_index() + 1, num_frozen_nodes);

            let mut iter = ledger_db.transaction_info_db_raw().iter::<TransactionInfoSchema>().unwrap();
            iter.seek_to_last();
            prop_assert_eq!(iter.next().transpose().unwrap().unwrap().0, target_version);

            let mut iter = ledger_db.transaction_db_raw().iter::<TransactionSchema>().unwrap();
            iter.seek_to_last();
            prop_assert_eq!(iter.next().transpose().unwrap().unwrap().0, target_version);

            let mut iter = ledger_metadata_db.iter::<VersionDataSchema>().unwrap();
            iter.seek_to_last();
            prop_assert!(iter.next().transpose().unwrap().unwrap().0 <= target_version);

            let mut iter = ledger_db.write_set_db_raw().iter::<WriteSetSchema>().unwrap();
            iter.seek_to_last();
            prop_assert_eq!(iter.next().transpose().unwrap().unwrap().0, target_version);

            let mut iter = ledger_metadata_db.iter::<EpochByVersionSchema>().unwrap();
            iter.seek_to_last();
            let (version, epoch) = iter.next().transpose().unwrap().unwrap();
            prop_assert!(version <= target_version);

            let mut iter = ledger_metadata_db.iter::<LedgerInfoSchema>().unwrap();
            iter.seek_to_last();
            prop_assert_eq!(iter.next().transpose().unwrap().unwrap().0, epoch);

            if sharding_config.enable_storage_sharding {
                let mut iter = state_kv_db.metadata_db().iter::<StateValueByKeyHashSchema>().unwrap();
                iter.seek_to_first();
                for item in iter {
                    let ((_, version), _) = item.unwrap();
                    prop_assert!(version <= target_version);
                }

                let mut iter = state_kv_db.metadata_db().iter::<StaleStateValueIndexByKeyHashSchema>().unwrap();
                iter.seek_to_first();
                for item in iter {
                    let version = item.unwrap().0.stale_since_version;
                    prop_assert!(version <= target_version);
                }

            } else {
                let mut iter = state_kv_db.metadata_db().iter::<StateValueSchema>().unwrap();
                iter.seek_to_first();
                for item in iter {
                    let ((_, version), _) = item.unwrap();
                    prop_assert!(version <= target_version);
                }

                let mut iter = state_kv_db.metadata_db().iter::<StaleStateValueIndexSchema>().unwrap();
                iter.seek_to_first();
                for item in iter {
                    let version = item.unwrap().0.stale_since_version;
                    prop_assert!(version <= target_version);
                }
            }

            let mut iter = state_merkle_db.metadata_db().iter::<StaleNodeIndexSchema>().unwrap();
            iter.seek_to_first();
            for item in iter {
                let version = item.unwrap().0.stale_since_version;
                prop_assert!(version <= target_version);
            }

            let mut iter = state_merkle_db.metadata_db().iter::<StaleNodeIndexCrossEpochSchema>().unwrap();
            iter.seek_to_first();
            for item in iter {
                let version = item.unwrap().0.stale_since_version;
                prop_assert!(version <= target_version);
            }

            let mut iter = state_merkle_db.metadata_db().iter::<JellyfishMerkleNodeSchema>().unwrap();
            iter.seek_to_first();
            for item in iter {
                let version = item.unwrap().0.version();
                prop_assert!(version <= target_version);
            }

            if sharding_config.enable_storage_sharding {
                let state_merkle_db = Arc::new(state_merkle_db);
                for i in 0..NUM_STATE_SHARDS {
                    let mut kv_shard_iter = state_kv_db.db_shard(i).iter::<StateValueByKeyHashSchema>().unwrap();
                    kv_shard_iter.seek_to_first();
                    for item in kv_shard_iter {
                        let ((_, version), _) = item.unwrap();
                        prop_assert!(version <= target_version);
                    }

                    let value_index_shard_iter = state_kv_db.db_shard(i).iter::<StaleStateValueIndexByKeyHashSchema>().unwrap();
                    for item in value_index_shard_iter {
                        let version = item.unwrap().0.stale_since_version;
                        prop_assert!(version <= target_version);
                    }

                    let mut stale_node_ind_iter = state_merkle_db.db_shard(i).iter::<StaleNodeIndexSchema>().unwrap();
                    stale_node_ind_iter.seek_to_first();
                    for item in stale_node_ind_iter {
                        let version = item.unwrap().0.stale_since_version;
                        prop_assert!(version <= target_version);
                    }

                    let mut jelly_iter = state_merkle_db.db_shard(i).iter::<JellyfishMerkleNodeSchema>().unwrap();
                    jelly_iter.seek_to_first();
                    for item in jelly_iter {
                        let version = item.unwrap().0.version();
                        prop_assert!(version <= target_version);
                    }

                    let mut cross_iter = state_merkle_db.db_shard(i).iter::<StaleNodeIndexCrossEpochSchema>().unwrap();
                    cross_iter.seek_to_first();
                    for item in cross_iter {
                        let version = item.unwrap().0.stale_since_version;
                        prop_assert!(version <= target_version);
                    }
                }
            }
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L382-382)
```rust
            .prune_transaction_by_hash_indices(transactions.iter().map(|txn| txn.hash()), batch)?;
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L435-439)
```rust
    delete_per_version_data_impl::<TransactionAccumulatorRootHashSchema>(
        ledger_db.transaction_accumulator_db_raw(),
        start_version,
        &mut batch.transaction_accumulator_db_batches,
    )?;
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L483-486)
```rust
                    batch.delete::<TransactionSummariesByAccountSchema>(&(
                        signed_txn.sender(),
                        version,
                    ))?;
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L520-549)
```rust
fn delete_event_data(
    ledger_db: &LedgerDb,
    start_version: Version,
    batch: &mut SchemaBatch,
) -> Result<()> {
    if let Some(latest_version) = ledger_db.event_db().latest_version()? {
        if latest_version >= start_version {
            info!(
                start_version = start_version,
                latest_version = latest_version,
                "Truncate event data."
            );
            let num_events_per_version = ledger_db.event_db().prune_event_indices(
                start_version,
                latest_version + 1,
                // Assuming same data will be overwritten into indices, we don't bother to deal
                // with the existence or placement of indices
                // TODO: prune data from internal indices
                None,
            )?;
            ledger_db.event_db().prune_events(
                num_events_per_version,
                start_version,
                latest_version + 1,
                batch,
            )?;
        }
    }
    Ok(())
}
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L349-353)
```rust
                            LedgerMetadataDb::put_block_info(
                                version,
                                event,
                                &mut ledger_metadata_batch,
                            )?;
```

**File:** storage/aptosdb/src/schema/mod.rs (L9-33)
```rust
pub(crate) mod block_by_version;
pub(crate) mod block_info;
pub(crate) mod db_metadata;
pub(crate) mod epoch_by_version;
pub(crate) mod event;
pub(crate) mod event_accumulator;
pub(crate) mod hot_state_value_by_key_hash;
pub(crate) mod jellyfish_merkle_node;
pub(crate) mod ledger_info;
pub(crate) mod persisted_auxiliary_info;
pub(crate) mod stale_node_index;
pub(crate) mod stale_node_index_cross_epoch;
pub(crate) mod stale_state_value_index;
pub(crate) mod stale_state_value_index_by_key_hash;
pub(crate) mod state_value;
pub(crate) mod state_value_by_key_hash;
pub(crate) mod transaction;
pub(crate) mod transaction_accumulator;
pub(crate) mod transaction_accumulator_root_hash;
pub(crate) mod transaction_auxiliary_data;
pub(crate) mod transaction_by_hash;
pub(crate) mod transaction_info;
pub(crate) mod transaction_summaries_by_account;
pub(crate) mod version_data;
pub(crate) mod write_set;
```
