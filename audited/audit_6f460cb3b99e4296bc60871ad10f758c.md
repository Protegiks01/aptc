# Audit Report

## Title
Unlimited Fund Minting via Faucet Amount Parameter Bypass in CLI Configuration

## Summary
The `RunConfig::build_for_cli` function configures the faucet with `amount_to_fund=100_000_000_000` OCTA but sets `maximum_amount=None`, allowing attackers to bypass the intended funding limit by supplying arbitrary amounts in request parameters, enabling unlimited fund minting.

## Finding Description
The vulnerability exists in the faucet's amount validation logic. When `RunConfig::build_for_cli` is invoked, it creates a `TransactionSubmissionConfig` with both `maximum_amount` and `maximum_amount_with_bypass` set to `None`: [1](#0-0) 

While `amount_to_fund` is set to 100_000_000_000 OCTA: [2](#0-1) 

The `MintFunder::get_amount` method uses pattern matching to determine the final funding amount. When a user-supplied amount is provided and `maximum_amount` is `None`, it returns the user's amount without any cap: [3](#0-2) 

The critical branch is `(Some(amount), None) => amount` which returns the attacker-controlled value with no upper bound validation. The `FundRequest` struct accepts an optional `amount` parameter: [4](#0-3) 

This amount flows directly to the minting logic without proper validation when `maximum_amount` is not configured.

**Attack Flow:**
1. Attacker sends POST request to `/fund` endpoint: `{"amount": 18446744073709551615, "address": "0x..."}`
2. Request passes through `fund_inner` which calls `funder.fund(fund_request.amount, ...)`
3. `MintFunder::get_amount` receives `Some(18446744073709551615)` and `None` for maximum
4. Returns attacker's amount (u64::MAX) without cap
5. Faucet mints 18,446,744,073,709,551,615 OCTA to attacker's account

## Impact Explanation
**Severity: Critical** - This vulnerability qualifies as "Loss of Funds (minting)" under the Critical severity category, potentially eligible for up to $1,000,000 bounty.

An attacker can mint unlimited funds, completely bypassing the intended 100 APT (100_000_000_000 OCTA) limit. This breaks the fundamental economic assumption that faucets provide limited test funds. On localnet/testnet, this enables:
- Unlimited APT minting (up to u64::MAX OCTA per request)
- Complete compromise of faucet security controls
- Potential blockchain state bloat through repeated max-value minting
- Violation of the "Resource Limits" invariant

## Likelihood Explanation
**Likelihood: High** - This vulnerability is trivially exploitable:
- Requires only a single HTTP POST request
- No authentication or bypass tokens needed
- No special permissions or validator access required
- Works on any faucet deployed via `build_for_cli` (including localnet)
- Attacker can repeat the attack unlimited times

The vulnerability affects all instances where `build_for_cli` is used, which includes the workspace server and CLI-based local development environments.

## Recommendation
Modify `RunConfig::build_for_cli` to set explicit maximum amounts:

```rust
pub fn build_for_cli(/* ... */) -> Self {
    Self {
        // ... other fields ...
        funder_config: FunderConfig::MintFunder(MintFunderConfig {
            // ... other fields ...
            transaction_submission_config: TransactionSubmissionConfig::new(
                Some(100_000_000_000),  // Set maximum_amount to match amount_to_fund
                Some(100_000_000_000),  // Set maximum_amount_with_bypass
                30,      
                None,    
                500_000, 
                30,      
                35,      
                false,   
            ),
            // ... other fields ...
            amount_to_fund: 100_000_000_000,
        }),
        // ... other fields ...
    }
}
```

This ensures the maximum cap is enforced even when users provide custom amounts. The `get_amount` logic will then execute the safe branch `(Some(amount), Some(maximum_amount)) => std::cmp::min(amount, maximum_amount)`.

## Proof of Concept

```bash
# Start localnet with workspace server
cargo run -p aptos -- node run-localnet --force-restart --assume-yes

# Exploit: Request 1 trillion APT (far exceeding the 100 APT limit)
curl -X POST http://127.0.0.1:8080/mint \
  -H "Content-Type: application/json" \
  -d '{
    "amount": 1000000000000000,
    "address": "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
  }'

# Verify the account received 1 trillion APT instead of capped amount
aptos account list --account 0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef
```

Alternative Rust integration test demonstrating the vulnerability:

```rust
#[tokio::test]
async fn test_unlimited_minting_vulnerability() {
    // Setup faucet with build_for_cli
    let config = RunConfig::build_for_cli(/* ... */);
    let (port, _handle) = start_server_from_config(config).await.unwrap();
    
    // Attempt to mint u64::MAX OCTA (should be rejected but isn't)
    let malicious_request = FundRequest {
        amount: Some(u64::MAX),
        address: Some(random_address().to_string()),
        ..Default::default()
    };
    
    let response = reqwest::Client::new()
        .post(format!("http://127.0.0.1:{}/fund", port))
        .json(&malicious_request)
        .send()
        .await
        .unwrap();
    
    // Vulnerability: Request succeeds when it should fail
    assert_eq!(response.status(), 200);
    
    // Verify the account received u64::MAX OCTA
    let balance = get_account_balance(malicious_request.address.unwrap()).await;
    assert_eq!(balance, u64::MAX); // VULNERABILITY CONFIRMED
}
```

### Citations

**File:** crates/aptos-faucet/core/src/server/run.rs (L285-293)
```rust
                transaction_submission_config: TransactionSubmissionConfig::new(
                    None,    // maximum_amount
                    None,    // maximum_amount_with_bypass
                    30,      // gas_unit_price_ttl_secs
                    None,    // gas_unit_price_override
                    500_000, // max_gas_amount
                    30,      // transaction_expiration_secs
                    35,      // wait_for_outstanding_txns_secs
                    false,   // wait_for_transactions
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L304-304)
```rust
                amount_to_fund: 100_000_000_000,
```

**File:** crates/aptos-faucet/core/src/funder/mint.rs (L540-550)
```rust
    fn get_amount(&self, amount: Option<u64>, did_bypass_checkers: bool) -> u64 {
        match (
            amount,
            self.txn_config.get_maximum_amount(did_bypass_checkers),
        ) {
            (Some(amount), Some(maximum_amount)) => std::cmp::min(amount, maximum_amount),
            (Some(amount), None) => amount,
            (None, Some(maximum_amount)) => std::cmp::min(self.amount_to_fund, maximum_amount),
            (None, None) => self.amount_to_fund,
        }
    }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L32-47)
```rust
#[derive(Clone, Debug, Default, Object)]
pub struct FundRequest {
    /// If not set, the default is the preconfigured max funding amount. If set,
    /// we will use this amount instead assuming it is < than the maximum,
    /// otherwise we'll just use the maximum.
    pub amount: Option<u64>,

    /// Either this or `address` / `pub_key` must be provided.
    pub auth_key: Option<String>,

    /// Either this or `auth_key` / `pub_key` must be provided.
    pub address: Option<String>,

    /// Either this or `auth_key` / `address` must be provided.
    pub pub_key: Option<String>,
}
```
