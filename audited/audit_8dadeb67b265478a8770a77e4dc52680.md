# Audit Report

## Title
Version-Epoch Consistency Validation Missing in Optimistic Fetch Request Creation Causing State Synchronization Failures

## Summary
The function `get_new_transaction_data_with_proof()` does not validate that `known_version` and `known_epoch` parameters are consistent before creating an optimistic fetch request. This allows inconsistent version-epoch pairs to be propagated through the system, causing the server to reject the request and state synchronization to fail, potentially preventing nodes from syncing with the network.

## Finding Description

The state synchronization system has a critical validation gap in the request creation path. The vulnerability manifests through the following sequence: [1](#0-0) 

This function creates a `GetNewTransactionDataWithProofRequest` without validating that `known_version` and `known_epoch` represent a consistent blockchain state. In Aptos, each version belongs to exactly one epoch, and epochs end at specific versions. A valid version-epoch pair must satisfy the invariant that the version falls within or at the boundary of the specified epoch.

The inconsistent pairs originate from the continuous syncer, which fetches version and epoch separately without atomicity guarantees: [2](#0-1) 

These values are retrieved through two independent storage calls that can observe inconsistent state during concurrent updates or epoch transitions. The stream engine then propagates these values without validation: [3](#0-2) 

The server-side optimistic fetch handler eventually detects the inconsistency and rejects the request: [4](#0-3) 

When this validation fails, the request is dropped with an error message: [5](#0-4) 

**Attack Scenario:**
1. A node is syncing during an epoch transition
2. Storage updates are in progress: version advances to new epoch, but epoch state update is delayed
3. `get_highest_synced_version_and_epoch()` reads version V (in epoch E+1) and epoch E (old value)
4. Stream engine creates request with inconsistent pair (V, E)
5. Optimistic fetch is sent to server with this inconsistent pair
6. Server fetches epoch-ending ledger info for epoch E and finds it ended at version V' where V' < V
7. Server marks request as invalid and drops it
8. Node's state sync fails, preventing it from making progress

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty program criteria for the following reasons:

1. **Validator Node Slowdowns/Stalls**: When validators encounter this condition, their state sync mechanism fails. They cannot make progress syncing with the network, effectively removing them from active participation in consensus until the condition resolves or the node is restarted with consistent state.

2. **Significant Protocol Violations**: State synchronization is a critical protocol component. Systematic failures in state sync violate the protocol's availability guarantees and can lead to network degradation if multiple nodes are affected simultaneously.

3. **Network Availability Impact**: If this condition affects multiple nodes (particularly during epoch transitions when timing is synchronized), it can reduce the effective validator set size and impact network throughput and finality.

The impact is particularly severe during epoch transitions, which are critical periods for validator set changes. Nodes failing to sync during these periods cannot validate the new epoch state and risk falling further behind.

## Likelihood Explanation

This issue has **moderate to high likelihood** of occurrence in production:

1. **Race Condition Window**: The vulnerability triggers during the time window between storage updates during epoch transitions. While individual storage operations are atomic, the composite read operation (`fetch_pre_committed_version` + `fetch_latest_epoch_state`) is not.

2. **Epoch Transitions**: Aptos experiences epoch transitions periodically (based on consensus configuration). Each transition creates an opportunity for this race condition to manifest.

3. **High-Load Scenarios**: Under high transaction throughput or during catch-up synchronization, the timing sensitivity increases, making the race condition more likely to trigger.

4. **No Automatic Recovery**: Once a node enters this failed state, the optimistic fetch continuously fails until external intervention (restart) or timeout-based stream reset occurs, prolonging the impact.

5. **Observable in Practice**: The server logs explicitly handle this case with a warning message "Mismatch between known version and epoch!", indicating the developers have observed or anticipated this condition.

## Recommendation

Add validation in `get_new_transaction_data_with_proof()` to ensure version-epoch consistency before creating the request. The validation should verify that the `known_version` falls within the epoch range of `known_epoch`:

```rust
pub fn get_new_transaction_data_with_proof(
    known_version: u64,
    known_epoch: u64,
    include_events: bool,
    max_response_bytes: u64,
) -> Result<Self, Error> {
    // Validate version-epoch consistency
    // This requires access to storage to check epoch boundaries
    // Alternatively, pass a validated LedgerInfo instead of separate version/epoch
    
    let transaction_data_request_type =
        TransactionDataRequestType::TransactionData(TransactionData { include_events });
    Ok(Self::GetNewTransactionDataWithProof(GetNewTransactionDataWithProofRequest {
        transaction_data_request_type,
        known_version,
        known_epoch,
        max_response_bytes,
    }))
}
```

**Better Architectural Fix**: Modify `get_highest_synced_version_and_epoch()` to fetch version and epoch atomically from a single `LedgerInfoWithSignatures` object:

```rust
fn get_highest_synced_version_and_epoch(&self) -> Result<(Version, Epoch), Error> {
    let latest_ledger_info = utils::fetch_latest_synced_ledger_info(self.storage.clone())?;
    let highest_synced_version = latest_ledger_info.ledger_info().version();
    let highest_synced_epoch = latest_ledger_info.ledger_info().epoch();
    
    Ok((highest_synced_version, highest_synced_epoch))
}
```

This ensures version and epoch are read from the same consistent snapshot.

## Proof of Concept

```rust
#[cfg(test)]
mod test_version_epoch_inconsistency {
    use super::*;
    
    #[test]
    fn test_inconsistent_version_epoch_causes_sync_failure() {
        // Setup: Epoch 5 ends at version 1000
        // Node has synced to version 1005 (in epoch 6)
        // But epoch state still shows epoch 5 (race condition)
        
        let known_version = 1005_u64;  // Version in epoch 6
        let known_epoch = 5_u64;        // Epoch 5 ended at version 1000
        
        // Create the request - no validation occurs
        let request = DataRequest::get_new_transaction_data_with_proof(
            known_version,
            known_epoch,
            false,
            1024 * 1024,
        );
        
        // When server processes this:
        // 1. Fetches epoch-ending ledger info for epoch 5 (version 1000)
        // 2. Checks if 1000 > 1005 (false)
        // 3. Marks request as invalid
        // 4. Drops the optimistic fetch
        
        // Expected: Request should be rejected due to inconsistency
        // Actual: Request is created and sent, then rejected server-side
        // Result: State sync fails
        
        assert!(matches!(request, DataRequest::GetNewTransactionDataWithProof(_)));
        
        // To demonstrate the issue, we'd need to:
        // 1. Mock storage returning version 1005, epoch 5
        // 2. Create stream engine with these values
        // 3. Attempt optimistic fetch
        // 4. Observe server rejection
        // 5. Verify sync does not progress
    }
}
```

**Notes**: A complete PoC would require mocking the storage interface to return inconsistent values and simulating the full optimistic fetch request-response cycle. The core issue is demonstrated by the lack of validation in the request creation path, allowing inconsistent parameters to propagate through the system until server-side detection and rejection.

### Citations

**File:** state-sync/storage-service/types/src/requests.rs (L215-229)
```rust
    pub fn get_new_transaction_data_with_proof(
        known_version: u64,
        known_epoch: u64,
        include_events: bool,
        max_response_bytes: u64,
    ) -> Self {
        let transaction_data_request_type =
            TransactionDataRequestType::TransactionData(TransactionData { include_events });
        Self::GetNewTransactionDataWithProof(GetNewTransactionDataWithProofRequest {
            transaction_data_request_type,
            known_version,
            known_epoch,
            max_response_bytes,
        })
    }
```

**File:** state-sync/state-sync-driver/src/continuous_syncer.rs (L267-272)
```rust
    fn get_highest_synced_version_and_epoch(&self) -> Result<(Version, Epoch), Error> {
        let highest_synced_version = utils::fetch_pre_committed_version(self.storage.clone())?;
        let highest_synced_epoch = utils::fetch_latest_epoch_state(self.storage.clone())?.epoch;

        Ok((highest_synced_version, highest_synced_epoch))
    }
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L488-496)
```rust
    fn calculate_next_version_and_epoch(
        known_version: Version,
        known_epoch: Epoch,
    ) -> Result<(Version, Epoch), Error> {
        let next_version = known_version
            .checked_add(1)
            .ok_or_else(|| Error::IntegerOverflow("Next version has overflown!".into()))?;
        Ok((next_version, known_epoch))
    }
```

**File:** state-sync/storage-service/server/src/optimistic_fetch.rs (L533-541)
```rust
                    if epoch_ending_ledger_info.ledger_info().version() <= highest_known_version {
                        peers_with_invalid_optimistic_fetches
                            .lock()
                            .push(peer_network_id);
                    } else {
                        peers_with_ready_optimistic_fetches
                            .lock()
                            .push((peer_network_id, epoch_ending_ledger_info));
                    }
```

**File:** state-sync/storage-service/server/src/optimistic_fetch.rs (L594-603)
```rust
            warn!(LogSchema::new(LogEntry::OptimisticFetchRefresh)
                .error(&Error::InvalidRequest(
                    "Mismatch between known version and epoch!".into()
                ))
                .request(&optimistic_fetch.request)
                .message(&format!(
                    "Dropping invalid optimistic fetch request for peer: {:?}!",
                    peer_network_id
                )));
        }
```
