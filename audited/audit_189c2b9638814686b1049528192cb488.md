# Audit Report

## Title
Missing Signature Verification for First Epoch Ending LedgerInfo in Backup Restore

## Summary
The epoch ending backup restore process in `backup-cli` fails to cryptographically verify the first `LedgerInfoWithSignatures` when no trusted waypoint is provided, violating the documented security assumption that signature verification serves as the fallback authentication mechanism when trusted waypoints are not used.

## Finding Description

The security question correctly identifies that `save_ledger_infos()` does not validate signatures. The actual file path is `storage/aptosdb/src/backup/restore_utils.rs` (not `restore/restore_utils.rs`), where the function only checks for non-empty input: [1](#0-0) 

This function is called from multiple paths, but the critical vulnerability exists in the epoch ending restore path where signature verification is supposed to occur. The `TrustedWaypointOpt` documentation explicitly states that when trusted waypoints are NOT provided, the system should fall back to cryptographic signature verification: [2](#0-1) 

However, in `EpochEndingRestoreController::preheat_impl()`, the verification logic has a critical gap for the first `LedgerInfoWithSignatures`: [3](#0-2) 

The verification logic at lines 129-146 has two branches:
1. Lines 129-135: If a trusted waypoint exists, verify hash only (no signatures)
2. Lines 136-146: If no trusted waypoint, verify signatures against `previous_li`'s epoch state

**The vulnerability:** For the first LedgerInfo being restored, `previous_li` is `None` (initialized at line 88), so when no trusted waypoint is provided, neither verification branch executes. The unverified LedgerInfo is directly added at line 148.

Additionally, `PreheatedEpochEndingRestore::run_impl()` provides a second verification opportunity, but only if `previous_epoch_ending_ledger_info` is provided: [4](#0-3) 

For the first restore batch in `EpochHistoryRestoreController::run_impl()`, `previous_li` starts as `None`: [5](#0-4) 

This allows the first epoch ending LedgerInfo to be persisted without any signature verification when the operator doesn't provide a trusted waypoint, despite the documented expectation that signature verification should occur.

## Impact Explanation

**Severity: Medium**

This vulnerability enables an attacker who can provide a malicious backup to a node operator to inject a forged epoch ending LedgerInfo containing:
- Manipulated validator sets via `next_epoch_state`
- Arbitrary epoch configurations
- Fake consensus proofs

While this breaks the documented security invariant that signature verification is the fallback mechanism, the practical impact is limited because:

1. **Attack requires social engineering**: The attacker must convince a node operator to restore from an untrusted backup source
2. **Defense-in-depth failure**: The vulnerability represents a missing layer of verification rather than a complete security bypass
3. **Operator best practices**: Properly configured waypoints or backup verification would prevent exploitation
4. **Limited to restore operations**: This doesn't affect normal runtime consensus operations

However, if successfully exploited, the consequences could be severe as the forged epoch states control validator set membership, which is critical for consensus safety.

## Likelihood Explanation

**Likelihood: Low to Medium**

The attack requires:
- Node operator obtaining backup from untrusted/compromised source
- Operator not providing trusted waypoints during restore (deviating from best practices)
- Operator not verifying backup authenticity before use
- Forged data not being detected during subsequent node startup checks

While these preconditions reduce likelihood, the vulnerability violates defense-in-depth principles and contradicts the documented security model, making it worthy of remediation.

## Recommendation

Add explicit signature verification for the first LedgerInfo when no trusted waypoint exists. In `preheat_impl()`, modify the verification logic:

```rust
// Around line 129 in epoch_ending/restore.rs
if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
    ensure!(
        *wp_trusted == wp_li,
        "Waypoints don't match. In backup: {}, trusted: {}",
        wp_li,
        wp_trusted,
    );
} else if let Some(pre_li) = previous_li {
    pre_li
        .ledger_info()
        .next_epoch_state()
        .ok_or_else(|| {
            anyhow!(
                "Next epoch state not found from LI at epoch {}.",
                pre_li.ledger_info().epoch()
            )
        })?
        .verify(&li)?;
} else {
    // NEW: For the first LedgerInfo without trusted waypoint,
    // require explicit verification against genesis or fail
    return Err(anyhow!(
        "First epoch ending LedgerInfo at epoch {} requires either a trusted waypoint or genesis verification. \
        Provide --trust-waypoint for version {} to proceed.",
        li.ledger_info().epoch(),
        li.ledger_info().version()
    ));
}
```

Alternatively, require that the first epoch ending LedgerInfo always have a trusted waypoint, enforcing the security model that untrusted backups cannot be restored without at least one trusted checkpoint.

## Proof of Concept

1. Create a malicious epoch ending backup with forged `LedgerInfoWithSignatures` containing manipulated validator sets
2. Ensure the manifest waypoints match (structural validation only)
3. Restore using `aptos-db-tool` without providing `--trust-waypoint` for the first epoch
4. Observe that the forged LedgerInfo is accepted and written to database without signature verification
5. Verify the database contains the manipulated epoch state by querying the ledger metadata

The attack succeeds because the verification gap at lines 129-146 allows the first LedgerInfo to bypass signature checks when `previous_li` is `None` and no trusted waypoint is provided.

---

**Notes:**

While the practical exploitability is constrained by operational practices, this is a legitimate security bug that violates the documented fallback verification mechanism. The code structure indicates clear intent to verify signatures (as evidenced by the existing verification branches), but the logic has an incomplete case that should be addressed for defense-in-depth and to maintain consistency with the security model described in the codebase documentation.

### Citations

**File:** storage/aptosdb/src/backup/restore_utils.rs (L41-58)
```rust
pub(crate) fn save_ledger_infos(
    ledger_metadata_db: &LedgerMetadataDb,
    ledger_infos: &[LedgerInfoWithSignatures],
    existing_batch: Option<&mut SchemaBatch>,
) -> Result<()> {
    ensure!(!ledger_infos.is_empty(), "No LedgerInfos to save.");

    if let Some(existing_batch) = existing_batch {
        save_ledger_infos_impl(ledger_metadata_db, ledger_infos, existing_batch)?;
    } else {
        let mut batch = SchemaBatch::new();
        save_ledger_infos_impl(ledger_metadata_db, ledger_infos, &mut batch)?;
        ledger_metadata_db.write_schemas(batch)?;
        update_latest_ledger_info(ledger_metadata_db, ledger_infos)?;
    }

    Ok(())
}
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L332-346)
```rust
pub struct TrustedWaypointOpt {
    #[clap(
        long,
        help = "(multiple) When provided, an epoch ending LedgerInfo at the waypoint version will be \
        checked against the hash in the waypoint, but signatures on it are NOT checked. \
        Use this for two purposes: \
        1. set the genesis or the latest waypoint to confirm the backup is compatible. \
        2. set waypoints at versions where writeset transactions were used to overwrite the \
        validator set, so that the signature check is skipped. \
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
    )]
    pub trust_waypoint: Vec<Waypoint>,
}
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L80-150)
```rust
    async fn preheat_impl(&self) -> Result<EpochEndingRestorePreheatData> {
        let manifest: EpochEndingBackup =
            self.storage.load_json_file(&self.manifest_handle).await?;
        manifest.verify()?;

        let mut next_epoch = manifest.first_epoch;
        let mut waypoint_iter = manifest.waypoints.iter();

        let mut previous_li: Option<&LedgerInfoWithSignatures> = None;
        let mut ledger_infos = Vec::new();

        let mut past_target = false;
        for chunk in &manifest.chunks {
            if past_target {
                break;
            }

            let lis = self.read_chunk(&chunk.ledger_infos).await?;
            ensure!(
                chunk.first_epoch + lis.len() as u64 == chunk.last_epoch + 1,
                "Number of items in chunks doesn't match that in manifest. \
                first_epoch: {}, last_epoch: {}, items in chunk: {}",
                chunk.first_epoch,
                chunk.last_epoch,
                lis.len(),
            );

            for li in lis {
                if li.ledger_info().version() > self.target_version {
                    past_target = true;
                    break;
                }

                ensure!(
                    li.ledger_info().epoch() == next_epoch,
                    "LedgerInfo epoch not expected. Expected: {}, actual: {}.",
                    li.ledger_info().epoch(),
                    next_epoch,
                );
                let wp_manifest = waypoint_iter.next().ok_or_else(|| {
                    anyhow!("More LedgerInfo's found than waypoints in manifest.")
                })?;
                let wp_li = Waypoint::new_epoch_boundary(li.ledger_info())?;
                ensure!(
                    *wp_manifest == wp_li,
                    "Waypoints don't match. In manifest: {}, In chunk: {}",
                    wp_manifest,
                    wp_li,
                );
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
                }
                ledger_infos.push(li);
                previous_li = ledger_infos.last();
                next_epoch += 1;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L218-240)
```rust
        if let Some(li) = previous_epoch_ending_ledger_info {
            ensure!(
                li.next_block_epoch() == preheat_data.manifest.first_epoch,
                "Previous epoch ending LedgerInfo is not the one expected. \
                My first epoch: {}, previous LedgerInfo next_block_epoch: {}",
                preheat_data.manifest.first_epoch,
                li.next_block_epoch(),
            );
            // Waypoint has been verified in preheat if it's trusted, otherwise try to check
            // the signatures.
            if self
                .controller
                .trusted_waypoints
                .get(&first_li.ledger_info().version())
                .is_none()
            {
                li.next_epoch_state()
                    .ok_or_else(|| {
                        anyhow!("Previous epoch ending LedgerInfo doesn't end an epoch")
                    })?
                    .verify(first_li)?;
            }
        }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L376-381)
```rust
        let mut previous_li = None;
        let mut epoch_endings = Vec::new();

        while let Some(preheated_restore) = futs_stream.next().await {
            let manifest_handle = preheated_restore.controller.manifest_handle.clone();
            let lis = preheated_restore.run(previous_li).await?;
```
