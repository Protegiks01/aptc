# Audit Report

## Title
Missing Config Validation for hot_state_kv_db_path Allows Validator Crash on Invalid Configuration

## Summary
The `StorageConfig` sanitizer fails to validate `hot_state_kv_db_path` in `db_path_overrides`, while validating all other similar path configurations. This inconsistency allows invalid configurations to pass validation and trigger a panic during database initialization, causing validator crash.

## Finding Description

The vulnerability exists in the configuration validation logic for storage paths. The `StorageConfig::sanitize()` function validates three of the four sharded database path configurations but omits validation for `hot_state_kv_db_path`. [1](#0-0) 

The sanitizer validates:
- `state_kv_db_path` at line 759
- `state_merkle_db_path` at line 774  
- `hot_state_merkle_db_path` at line 791

But **completely omits** validation for `hot_state_kv_db_path`.

However, during database initialization, `get_dir_paths()` unconditionally calls `ShardedDbPaths::new()` for all four path types including `hot_state_kv_db_path`: [2](#0-1) 

The `ShardedDbPaths::new()` function then calls `get_shard_paths().expect("Invalid config.")`: [3](#0-2) 

The `get_shard_paths()` method performs validation that can fail with various errors: [4](#0-3) 

Invalid configurations that would trigger panic include:
- Non-absolute paths (line 60-63)
- Shard IDs >= 16 (line 65-68)
- Duplicate shard IDs (line 69-73)
- Invalid shard string format (line 98)
- Parse errors (line 86, 91-92)

**Attack Path:**
1. Attacker gains write access to validator config file (via system compromise, supply chain attack, or misconfigured automation)
2. Attacker adds malformed `hot_state_kv_db_path` configuration
3. Config passes sanitization (missing validation)
4. Validator attempts to start and open database
5. `get_dir_paths()` is called during initialization: [5](#0-4) 

6. Panic occurs in `ShardedDbPaths::new()`, crashing validator

## Impact Explanation

This is a **High Severity** issue per Aptos bug bounty criteria. It causes validator node crashes during initialization, resulting in denial of service. The impact includes:

- **Validator unavailability**: Affected validators cannot start, reducing network validator count
- **Network liveness impact**: If multiple validators are affected, could impact consensus
- **Operational disruption**: Requires manual intervention to fix config and restart

The panic occurs during the critical database initialization phase: [6](#0-5) 

This falls under "Validator node crashes" and "API crashes" in the High Severity category.

## Likelihood Explanation

**Likelihood: Medium-Low**

**Requirements:**
- Write access to validator config file
- Knowledge of the validation gap
- Ability to craft malformed configuration

**Factors reducing likelihood:**
- Requires system-level compromise or supply chain attack
- Validator operators are considered trusted in the threat model
- Config files are typically managed carefully in production

**Factors increasing likelihood:**
- Automated config generation tools may introduce errors
- Config templates from untrusted sources could contain malformed values
- File system corruption could create invalid configs
- The validation gap is non-obvious and could lead to accidental misconfigurations

While the attacker requirements are significant, the ease of exploitation once access is obtained (simply adding a malformed config value) makes this a legitimate concern for defense-in-depth.

## Recommendation

Add validation for `hot_state_kv_db_path` in the sanitizer, matching the validation pattern used for the other three path types:

```rust
// In ConfigSanitizer for StorageConfig, after line 777, add:

if let Some(hot_state_kv_db_path) = db_path_overrides.hot_state_kv_db_path.as_ref() {
    if let Some(metadata_path) = hot_state_kv_db_path.metadata_path.as_ref() {
        if !metadata_path.is_absolute() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!("Path {metadata_path:?} in db_path_overrides is not an absolute path."),
            ));
        }
    }

    if let Err(e) = hot_state_kv_db_path.get_shard_paths() {
        return Err(Error::ConfigSanitizerFailed(sanitizer_name, e.to_string()));
    }
}
```

This ensures consistent validation across all sharded database path configurations and prevents the panic from ever being reached.

## Proof of Concept

Create a malicious config file `malicious_config.yaml`:

```yaml
storage:
  rocksdb_configs:
    enable_storage_sharding: true
  db_path_overrides:
    hot_state_kv_db_path:
      shard_paths:
        - shards: "16"  # Invalid: shard_id >= 16
          path: "/tmp/bad_shard"
```

**Reproduction steps:**

1. Create test config with invalid `hot_state_kv_db_path`
2. Load config via `NodeConfig::load_from_path()`
3. Config passes sanitization (bug: hot_state_kv_db_path not validated)
4. Call `storage.get_dir_paths()` to simulate database opening
5. Observe panic in `ShardedDbPaths::new()` at the `expect()` call

**Expected result:** Panic with message "Invalid config." when attempting to parse shard ID >= 16

**Root cause:** Missing validation in sanitizer allows invalid config to reach the panic point during initialization.

## Notes

This vulnerability demonstrates an inconsistency in the defensive validation layer where one configuration field was overlooked. While the attacker requirements are significant (file system access), the principle of defense-in-depth suggests all config validation should be consistent to catch errors early and provide clear error messages rather than panics. The fix is trivial and should be applied to maintain consistency with the validation of the three other similar path configurations.

### Citations

**File:** config/src/config/storage_config.rs (L54-104)
```rust
impl ShardedDbPathConfig {
    pub fn get_shard_paths(&self) -> Result<HashMap<u8, PathBuf>> {
        let mut result = HashMap::new();
        for shard_path in &self.shard_paths {
            let shard_ids = Self::parse(shard_path.shards.as_str())?;
            let path = &shard_path.path;
            ensure!(
                path.is_absolute(),
                "Path ({path:?}) is not an absolute path."
            );
            for shard_id in shard_ids {
                ensure!(
                    shard_id < 16,
                    "Shard id ({shard_id}) is out of range [0, 16)."
                );
                let exist = result.insert(shard_id, path.clone()).is_some();
                ensure!(
                    !exist,
                    "Duplicated shard id ({shard_id}) is not allowed in the config."
                );
            }
        }

        Ok(result)
    }

    fn parse(path: &str) -> Result<Vec<u8>> {
        let mut shard_ids = vec![];
        for p in path.split(',') {
            let num_or_range: Vec<&str> = p.split('-').collect();
            match num_or_range.len() {
                1 => {
                    let num = u8::from_str(num_or_range[0])?;
                    ensure!(num < 16);
                    shard_ids.push(num);
                },
                2 => {
                    let range_start = u8::from_str(num_or_range[0])?;
                    let range_end = u8::from_str(num_or_range[1])?;
                    ensure!(range_start <= range_end && range_end < 16);
                    for num in range_start..=range_end {
                        shard_ids.push(num);
                    }
                },
                _ => bail!("Invalid path: {path}."),
            }
        }

        Ok(shard_ids)
    }
}
```

**File:** config/src/config/storage_config.rs (L488-490)
```rust
            if let Some(hot_state_kv_db_path) = db_path_overrides.hot_state_kv_db_path.as_ref() {
                hot_state_kv_db_paths = ShardedDbPaths::new(hot_state_kv_db_path);
            }
```

**File:** config/src/config/storage_config.rs (L621-631)
```rust
    fn new(config: &ShardedDbPathConfig) -> Self {
        let mut shard_paths = arr![None; 16];
        for (shard_id, shard_path) in config.get_shard_paths().expect("Invalid config.") {
            shard_paths[shard_id as usize] = Some(shard_path);
        }

        Self {
            metadata_path: config.metadata_path.clone(),
            shard_paths,
        }
    }
```

**File:** config/src/config/storage_config.rs (L730-795)
```rust
        if let Some(db_path_overrides) = config.db_path_overrides.as_ref() {
            if !config.rocksdb_configs.enable_storage_sharding {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "db_path_overrides is allowed only if sharding is enabled.".to_string(),
                ));
            }

            if let Some(ledger_db_path) = db_path_overrides.ledger_db_path.as_ref() {
                if !ledger_db_path.is_absolute() {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        format!(
                            "Path {ledger_db_path:?} in db_path_overrides is not an absolute path."
                        ),
                    ));
                }
            }

            if let Some(state_kv_db_path) = db_path_overrides.state_kv_db_path.as_ref() {
                if let Some(metadata_path) = state_kv_db_path.metadata_path.as_ref() {
                    if !metadata_path.is_absolute() {
                        return Err(Error::ConfigSanitizerFailed(
                            sanitizer_name,
                            format!("Path {metadata_path:?} in db_path_overrides is not an absolute path."),
                        ));
                    }
                }

                if let Err(e) = state_kv_db_path.get_shard_paths() {
                    return Err(Error::ConfigSanitizerFailed(sanitizer_name, e.to_string()));
                }
            }

            if let Some(state_merkle_db_path) = db_path_overrides.state_merkle_db_path.as_ref() {
                if let Some(metadata_path) = state_merkle_db_path.metadata_path.as_ref() {
                    if !metadata_path.is_absolute() {
                        return Err(Error::ConfigSanitizerFailed(
                            sanitizer_name,
                            format!("Path {metadata_path:?} in db_path_overrides is not an absolute path."),
                        ));
                    }
                }

                if let Err(e) = state_merkle_db_path.get_shard_paths() {
                    return Err(Error::ConfigSanitizerFailed(sanitizer_name, e.to_string()));
                }
            }

            if let Some(hot_state_merkle_db_path) =
                db_path_overrides.hot_state_merkle_db_path.as_ref()
            {
                if let Some(metadata_path) = hot_state_merkle_db_path.metadata_path.as_ref() {
                    if !metadata_path.is_absolute() {
                        return Err(Error::ConfigSanitizerFailed(
                            sanitizer_name,
                            format!("Path {metadata_path:?} in db_path_overrides is not an absolute path."),
                        ));
                    }
                }

                if let Err(e) = hot_state_merkle_db_path.get_shard_paths() {
                    return Err(Error::ConfigSanitizerFailed(sanitizer_name, e.to_string()));
                }
            }
        }
```

**File:** aptos-node/src/storage.rs (L112-126)
```rust
pub(crate) fn bootstrap_db(
    node_config: &NodeConfig,
) -> Result<(Arc<dyn DbReader>, DbReaderWriter, Option<Runtime>)> {
    use aptos_db::db::fake_aptosdb::FakeAptosDB;

    let aptos_db = AptosDB::open(
        node_config.storage.get_dir_paths(),
        false, /* readonly */
        node_config.storage.storage_pruner_config,
        node_config.storage.rocksdb_configs,
        node_config.storage.enable_indexer,
        node_config.storage.buffered_state_target_items,
        node_config.storage.max_num_nodes_per_lru_cache_shard,
    )
    .map_err(|err| anyhow!("DB failed to open {}", err))?;
```

**File:** aptos-node/src/storage.rs (L187-190)
```rust
    // Open the database
    let instant = Instant::now();
    let (_aptos_db, db_rw, backup_service, indexer_db_opt, update_receiver) =
        bootstrap_db(node_config)?;
```
