# Audit Report

## Title
Validator Voting Power Integer Overflow Leading to Network Liveness Failure During Epoch Transition

## Summary
A critical vulnerability exists in the staking system where improper bounds validation on `maximum_stake` configuration allows voting power calculations to exceed `u64::MAX`, causing arithmetic overflow during epoch transitions and resulting in permanent network liveness failure.

## Finding Description

The proposer election weights in `choose_index()` are derived from validator voting powers that originate from the on-chain staking system. The vulnerability stems from insufficient validation of the `maximum_stake` parameter in the staking configuration, combined with unchecked arithmetic during reward distribution.

**Weight Source Flow**: [1](#0-0) 

The weights are calculated as `reputation_weight Ã— voting_power`, where `voting_power` comes from: [2](#0-1) 

This voting power ultimately derives from: [3](#0-2) 

**The Vulnerability**:

The `validate_required_stake` function only checks that `minimum_stake <= maximum_stake` and `maximum_stake > 0`: [4](#0-3) 

There is **no upper bound** on `maximum_stake`. If governance sets `maximum_stake` to a value approaching `u64::MAX`, the following sequence causes network failure:

1. A validator stakes close to the maximum (e.g., `active = u64::MAX - 1000`, `pending_active = 500`)
2. During epoch transition, `update_stake_pool()` distributes rewards and fees: [5](#0-4) 

3. Rewards and fees are merged into the stake pools using `coin::merge()`, which performs checked `u64` addition
4. If `active_stake + rewards + fees > u64::MAX`, Move's checked arithmetic aborts the transaction
5. This causes `update_stake_pool()` to abort, which aborts `on_new_epoch()`: [6](#0-5) 

6. The network cannot transition to the next epoch, causing **permanent liveness failure**

The `add_stake_with_cap` validation occurs before rewards: [7](#0-6) 

But this check happens when adding stake, not when rewards are distributed. Even small reward percentages (0.01-0.1% per epoch) on stakes near `u64::MAX` exceed the remaining headroom.

## Impact Explanation

**Critical Severity** - This vulnerability causes:
- **Total loss of liveness/network availability**: The blockchain cannot process new blocks or transactions
- **Non-recoverable without hardfork**: Requires emergency governance action to reduce `maximum_stake`, but governance transactions cannot execute if `on_new_epoch()` fails
- **Affects all network participants**: Validators, users, and applications are completely frozen

This meets the **Critical Severity** criteria per Aptos Bug Bounty: "Total loss of liveness/network availability" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**Likelihood: Low to Medium**

While this requires governance to set `maximum_stake` to dangerous values, several factors increase likelihood:

1. **No technical safeguards**: The code has no upper bound check on `maximum_stake`
2. **Governance misconfiguration risk**: In a decentralized governance system, proposals may pass without full security review
3. **Non-obvious attack surface**: The connection between `maximum_stake` configuration and epoch transition overflow is not immediately apparent
4. **Incremental risk**: Governance could gradually increase `maximum_stake` over time, approaching dangerous levels
5. **Economic incentives**: Validators may lobby for higher stake limits to accommodate larger stakes

The attack does not require malicious intent - a well-meaning governance proposal to "increase validator participation limits" could inadvertently trigger this vulnerability.

## Recommendation

Implement strict upper bounds on `maximum_stake` in the validation function:

```move
fun validate_required_stake(minimum_stake: u64, maximum_stake: u64) {
    // Existing checks
    assert!(minimum_stake <= maximum_stake && maximum_stake > 0, error::invalid_argument(EINVALID_STAKE_RANGE));
    
    // New: Enforce safe upper bound to prevent overflow during reward distribution
    // Reserve headroom for rewards (assume max 10% annual rewards, ~0.02% per epoch with 5000 epochs/year)
    // Safe maximum: u64::MAX / 2 provides ample headroom for rewards and fees
    const MAX_SAFE_STAKE: u64 = 9223372036854775807; // u64::MAX / 2
    assert!(maximum_stake <= MAX_SAFE_STAKE, error::invalid_argument(ESTAKE_EXCEEDS_SAFE_MAXIMUM));
}
```

Additionally, add defensive checks in `update_stake_pool()` before merging rewards to gracefully handle edge cases.

## Proof of Concept

```move
#[test_only]
module test_stake_overflow {
    use aptos_framework::stake;
    use aptos_framework::staking_config;
    use aptos_framework::coin;
    
    #[test(aptos_framework = @aptos_framework)]
    #[expected_failure(abort_code = ARITHMETIC_ERROR)]
    fun test_voting_power_overflow_during_epoch_transition(aptos_framework: signer) {
        // 1. Initialize with dangerous maximum_stake near u64::MAX
        let maximum_stake = 18446744073709551615 - 1000; // u64::MAX - 1000
        staking_config::initialize_for_test(&aptos_framework, 1000000, maximum_stake, 7200, true, 1, 100, 10);
        
        // 2. Create validator with stake approaching maximum
        // ... (validator setup code)
        
        // 3. Add stake close to maximum (active + pending_active = maximum_stake - 100)
        // ... (add stake code)
        
        // 4. Trigger epoch transition
        // This will attempt to distribute rewards and merge them into active stake
        // The coin::merge() will cause u64 overflow and abort
        stake::on_new_epoch();
        // Test expects abort with ARITHMETIC_ERROR
    }
}
```

## Notes

This vulnerability demonstrates a critical gap between governance configuration parameters and the underlying arithmetic constraints of the Move VM. The absence of bounds checking on `maximum_stake` creates a path for network-wide liveness failure through a seemingly innocuous configuration change. The fix requires both input validation at the configuration layer and defensive programming at the execution layer.

### Citations

**File:** consensus/src/liveness/leader_reputation.rs (L711-716)
```rust
        let stake_weights: Vec<u128> = weights
            .iter_mut()
            .enumerate()
            .map(|(i, w)| *w as u128 * self.voting_powers[i] as u128)
            .collect();

```

**File:** consensus/src/epoch_manager.rs (L348-359)
```rust
                    proposers
                        .iter()
                        .map(|p| {
                            epoch_state
                                .verifier
                                .get_voting_power(p)
                                .expect("INVARIANT VIOLATION: proposer not in verifier set")
                        })
                        .collect()
                } else {
                    vec![1; proposers.len()]
                };
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L844-845)
```text
        let voting_power = get_next_epoch_voting_power(stake_pool);
        assert!(voting_power <= maximum_stake, error::invalid_argument(ESTAKE_EXCEEDS_MAX));
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1351-1354)
```text
        vector::for_each_ref(&validator_set.active_validators, |validator| {
            let validator: &ValidatorInfo = validator;
            update_stake_pool(validator_perf, validator.addr, &config);
        });
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1693-1718)
```text
        let rewards_active = distribute_rewards(
            &mut stake_pool.active,
            num_successful_proposals,
            num_total_proposals,
            rewards_rate,
            rewards_rate_denominator
        );
        let rewards_pending_inactive = distribute_rewards(
            &mut stake_pool.pending_inactive,
            num_successful_proposals,
            num_total_proposals,
            rewards_rate,
            rewards_rate_denominator
        );
        spec {
            assume rewards_active + rewards_pending_inactive <= MAX_U64;
        };

        if (std::features::is_distribute_transaction_fee_enabled()) {
            let mint_cap = &borrow_global<AptosCoinCapabilities>(@aptos_framework).mint_cap;
            if (fee_active > 0) {
                coin::merge(&mut stake_pool.active, coin::mint(fee_active, mint_cap));
            };
            if (fee_pending_inactive > 0) {
                coin::merge(&mut stake_pool.pending_inactive, coin::mint(fee_pending_inactive, mint_cap));
            };
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1847-1855)
```text
    fun get_next_epoch_voting_power(stake_pool: &StakePool): u64 {
        let value_pending_active = coin::value(&stake_pool.pending_active);
        let value_active = coin::value(&stake_pool.active);
        let value_pending_inactive = coin::value(&stake_pool.pending_inactive);
        spec {
            assume value_pending_active + value_active + value_pending_inactive <= MAX_U64;
        };
        value_pending_active + value_active + value_pending_inactive
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/staking_config.move (L372-374)
```text
    fun validate_required_stake(minimum_stake: u64, maximum_stake: u64) {
        assert!(minimum_stake <= maximum_stake && maximum_stake > 0, error::invalid_argument(EINVALID_STAKE_RANGE));
    }
```
