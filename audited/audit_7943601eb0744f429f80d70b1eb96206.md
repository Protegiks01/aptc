# Audit Report

## Title
Race Condition in Object Code Deployment: Non-Atomic Sequence Number Fetching Causes Address Mismatch

## Summary
The `CreateObjectAndPublishPackage::execute()` function fetches the account sequence number twice in a non-atomic manner: once to derive the object address for package compilation, and again during transaction submission. If another transaction executes between these two fetches, the package is deployed to a different object address than it was compiled for, rendering it unusable.

## Finding Description

The vulnerability exists in the asynchronous sequence number handling within the object code deployment flow: [1](#0-0) 

The function first fetches the sequence number to calculate the future object address. This object address is then used to compile the package: [2](#0-1) 

However, when the transaction is eventually submitted, the sequence number is fetched **again** inside `submit_transaction()`: [3](#0-2) 

The on-chain Move code derives the object address using the account's sequence number at transaction execution time: [4](#0-3) 

Critically, the sequence number is incremented in the transaction epilogue (AFTER payload execution): [5](#0-4) 

But the Move code reads it DURING payload execution (BEFORE epilogue increment): [6](#0-5) 

**Attack Scenario:**
1. User account has sequence number `N=5`
2. User initiates `CreateObjectAndPublishPackage`
3. CLI fetches sequence number: `5`, calculates object address from `create_object_code_deployment_address(user, 6)`
4. CLI compiles package with this object address as a named address
5. **RACE WINDOW**: Before transaction submission, user submits another transaction (or concurrent CLI operation)
6. Other transaction executes with seq `5`, incrementing account to `6`
7. `submit_transaction()` fetches sequence number: now `6`
8. Transaction created with sequence number `6`
9. On-chain execution: `get_sequence_number()` returns `6`, calculates object seed from `7`
10. Package deploys to object address derived from sequence `7` instead of `6`
11. **Result**: Package bytecode contains wrong self-address, all module references are incorrect

## Impact Explanation

This qualifies as **HIGH severity** under the Aptos bug bounty criteria for the following reasons:

1. **Significant Protocol Violation**: The package deployment mechanism fails to maintain consistency between compiled bytecode and deployment location
2. **Usability Impact**: Deployed packages become completely unusable due to address mismatch in module headers
3. **No Fund Loss**: While this doesn't directly steal funds, it breaks core platform functionality
4. **State Inconsistency**: Creates on-chain packages that cannot be properly upgraded or interacted with

The vulnerability breaks the **State Consistency** invariant that "state transitions must be atomic and verifiable" and the **Deterministic Execution** principle by allowing non-deterministic outcomes based on concurrent operation timing.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

The race condition can occur in several realistic scenarios:

1. **User Error**: User runs multiple CLI commands in parallel (common in scripts/automation)
2. **Wallet Applications**: Mobile/web wallets may queue multiple transactions
3. **CI/CD Pipelines**: Automated deployment scripts executing concurrent operations
4. **Normal Usage**: User initiates package deployment, then sends another transaction before first completes

The race window is measured in seconds (network latency + user confirmation prompts), making it highly probable in production environments. No malicious intent requiredâ€”simple concurrent usage triggers the bug.

## Recommendation

**Solution**: Fetch the sequence number once and pass it explicitly through the entire flow to ensure atomicity.

**Code Fix:**

Modify `CreateObjectAndPublishPackage::execute()` to:
1. Fetch sequence number once
2. Pass it explicitly to `submit_transaction()` 
3. Modify `submit_transaction()` to accept optional sequence number parameter
4. Skip sequence number refetch if provided

```rust
// In CreateObjectAndPublishPackage::execute()
let sequence_number = if self.chunked_publish_option.chunked_publish {
    // ... existing calculation
} else {
    self.txn_options.sequence_number(sender_address).await? + 1
};

// Store the expected sequence number for validation
let expected_txn_sequence = sequence_number - 1;

// ... existing object address derivation and package build ...

// Pass expected sequence number to submission
self.txn_options
    .submit_transaction_with_sequence(payload, Some(expected_txn_sequence))
    .await
```

Modify `TransactionOptions` to add:
```rust
pub async fn submit_transaction_with_sequence(
    &self,
    payload: TransactionPayload,
    expected_sequence: Option<u64>,
) -> CliTypedResult<Transaction> {
    // If sequence provided, validate it matches and skip refetch
    if let Some(seq) = expected_sequence {
        let current_seq = self.sequence_number(sender_address).await?;
        if current_seq != seq {
            return Err(CliError::UnexpectedError(
                format!("Sequence number mismatch: expected {}, got {}. Another transaction may have executed.", seq, current_seq)
            ));
        }
    }
    // ... continue with existing logic
}
```

## Proof of Concept

**Reproduction Steps:**

1. Create test account with initial sequence number 0
2. Start `CreateObjectAndPublishPackage` operation
3. Before it completes, submit another transaction (e.g., coin transfer)
4. Let `CreateObjectAndPublishPackage` complete
5. Verify: package deployed to object address derived from seq 2, but compiled for seq 1

**Rust Test Simulation:**
```rust
#[tokio::test]
async fn test_object_deployment_race_condition() {
    let mut harness = setup_test_harness();
    let account = harness.new_account();
    
    // Start object deployment
    let seq1 = harness.sequence_number(account.address());
    let expected_address = create_object_code_deployment_address(
        *account.address(), 
        seq1 + 1
    );
    
    // Simulate race: submit another transaction
    harness.submit_dummy_transaction(&account);
    
    // Complete object deployment with outdated sequence number
    let actual_deployment = harness.deploy_object_package(&account, expected_address);
    
    // Verify mismatch
    assert_ne!(actual_deployment.object_address, expected_address);
    // Verify package is unusable due to address mismatch
    assert!(harness.verify_package_address_mismatch(actual_deployment.object_address));
}
```

The vulnerability is confirmed through code analysis showing two separate async sequence number fetches with no synchronization mechanism between them.

## Notes

This vulnerability specifically affects:
- `CreateObjectAndPublishPackage` [7](#0-6) 
- `DeployObjectCode` (same pattern) [8](#0-7) 

Both functions follow the same vulnerable pattern of fetching sequence numbers twice without atomicity guarantees. The fix should be applied to both code paths.

### Citations

**File:** crates/aptos/src/move_tool/mod.rs (L1141-1270)
```rust
pub struct CreateObjectAndPublishPackage {
    /// The named address for compiling and using in the contract
    ///
    /// This will take the derived account address for the object and put it in this location
    #[clap(long)]
    pub(crate) address_name: String,
    #[clap(flatten)]
    pub(crate) override_size_check_option: OverrideSizeCheckOption,
    #[clap(flatten)]
    pub(crate) chunked_publish_option: ChunkedPublishOption,
    #[clap(flatten)]
    pub(crate) included_artifacts_args: IncludedArtifactsArgs,
    #[clap(flatten)]
    pub(crate) move_options: MovePackageOptions,
    #[clap(flatten)]
    pub(crate) txn_options: TransactionOptions,
}

#[async_trait]
impl CliCommand<TransactionSummary> for CreateObjectAndPublishPackage {
    fn command_name(&self) -> &'static str {
        "CreateObjectAndPublishPackage"
    }

    // TODO[Ordereless]: Update this code to support stateless accounts that don't have a sequence number
    async fn execute(mut self) -> CliTypedResult<TransactionSummary> {
        let sender_address = self.txn_options.get_public_key_and_address()?.1;

        let chunked_publish_large_packages_module_address =
            if self.chunked_publish_option.chunked_publish {
                Some(
                    self.chunked_publish_option
                        .large_packages_module
                        .large_packages_module_address(&self.txn_options)
                        .await?,
                )
            } else {
                None
            };

        let sequence_number = if self.chunked_publish_option.chunked_publish {
            // Perform a preliminary build to determine the number of transactions needed for chunked publish mode.
            // This involves building the package with mock account address `0xcafe` to calculate the transaction count.
            let mock_object_address = AccountAddress::from_hex_literal("0xcafe").unwrap();
            self.move_options
                .add_named_address(self.address_name.clone(), mock_object_address.to_string());
            let package = build_package_options(&self.move_options, &self.included_artifacts_args)?;
            let mock_payloads = create_chunked_publish_payloads(
                package,
                PublishType::AccountDeploy,
                None,
                chunked_publish_large_packages_module_address.unwrap(),
                self.chunked_publish_option.chunk_size,
            )?
            .payloads;
            let staging_tx_count = (mock_payloads.len() - 1) as u64;
            self.txn_options.sequence_number(sender_address).await? + staging_tx_count + 1
        } else {
            self.txn_options.sequence_number(sender_address).await? + 1
        };

        let object_address = create_object_code_deployment_address(sender_address, sequence_number);

        self.move_options
            .add_named_address(self.address_name, object_address.to_string());

        let package = build_package_options(&self.move_options, &self.included_artifacts_args)?;
        let message = format!(
            "Do you want to publish this package at object address {}",
            object_address
        );
        prompt_yes_with_override(&message, self.txn_options.prompt_options)?;

        let result = if self.chunked_publish_option.chunked_publish {
            let payloads = create_chunked_publish_payloads(
                package,
                PublishType::ObjectDeploy,
                None,
                chunked_publish_large_packages_module_address.unwrap(),
                self.chunked_publish_option.chunk_size,
            )?
            .payloads;

            let size = &payloads
                .iter()
                .map(bcs::serialized_size)
                .sum::<Result<usize, _>>()?;
            println!("package size {} bytes", size);
            let message = format!("Publishing package in chunked mode will submit {} transactions for staging and publishing code.\n", &payloads.len());
            println!("{}", message.bold());

            submit_chunked_publish_transactions(
                payloads,
                &self.txn_options,
                chunked_publish_large_packages_module_address.unwrap(),
            )
            .await
        } else {
            let payload = create_package_publication_data(
                package,
                PublishType::ObjectDeploy,
                Some(object_address),
            )?
            .payload;
            let size = bcs::serialized_size(&payload)?;
            println!("package size {} bytes", size);

            if !self.override_size_check_option.override_size_check
                && size > MAX_PUBLISH_PACKAGE_SIZE
            {
                return Err(CliError::PackageSizeExceeded(
                    size,
                    MAX_PUBLISH_PACKAGE_SIZE,
                ));
            }
            self.txn_options
                .submit_transaction(payload)
                .await
                .map(TransactionSummary::from)
        };

        if result.is_ok() {
            println!(
                "Code was successfully deployed to object address {}",
                object_address
            );
        }
        result
    }
}
```

**File:** crates/aptos/src/move_tool/mod.rs (L1392-1524)
```rust
#[derive(Parser)]
pub struct DeployObjectCode {
    /// The named address for compiling and using in the contract
    ///
    /// This will take the derived account address for the object and put it in this location
    #[clap(long)]
    pub(crate) address_name: String,
    #[clap(flatten)]
    pub(crate) override_size_check_option: OverrideSizeCheckOption,
    #[clap(flatten)]
    pub(crate) chunked_publish_option: ChunkedPublishOption,
    #[clap(flatten)]
    pub(crate) included_artifacts_args: IncludedArtifactsArgs,
    #[clap(flatten)]
    pub(crate) move_options: MovePackageOptions,
    #[clap(flatten)]
    pub(crate) txn_options: TransactionOptions,
}

#[async_trait]
impl CliCommand<TransactionSummary> for DeployObjectCode {
    fn command_name(&self) -> &'static str {
        "DeployObject"
    }

    // TODO[Ordereless]: Update this code to support stateless accounts that don't have a sequence number
    async fn execute(mut self) -> CliTypedResult<TransactionSummary> {
        let sender_address = self.txn_options.get_public_key_and_address()?.1;

        let chunked_publish_large_packages_module_address =
            if self.chunked_publish_option.chunked_publish {
                Some(
                    self.chunked_publish_option
                        .large_packages_module
                        .large_packages_module_address(&self.txn_options)
                        .await?,
                )
            } else {
                None
            };

        let sequence_number = if self.chunked_publish_option.chunked_publish {
            // Perform a preliminary build to determine the number of transactions needed for chunked publish mode.
            // This involves building the package with mock account address `0xcafe` to calculate the transaction count.
            let mock_object_address = AccountAddress::from_hex_literal("0xcafe").unwrap();
            self.move_options
                .add_named_address(self.address_name.clone(), mock_object_address.to_string());
            let package = build_package_options(&self.move_options, &self.included_artifacts_args)?;
            let mock_payloads: Vec<TransactionPayload> = create_chunked_publish_payloads(
                package,
                PublishType::AccountDeploy,
                None,
                chunked_publish_large_packages_module_address.unwrap(),
                self.chunked_publish_option.chunk_size,
            )?
            .payloads;
            let staging_tx_count = (mock_payloads.len() - 1) as u64;
            self.txn_options.sequence_number(sender_address).await? + staging_tx_count + 1
        } else {
            self.txn_options.sequence_number(sender_address).await? + 1
        };

        let object_address = create_object_code_deployment_address(sender_address, sequence_number);

        self.move_options
            .add_named_address(self.address_name, object_address.to_string());

        let package = build_package_options(&self.move_options, &self.included_artifacts_args)?;
        let message = format!(
            "Do you want to deploy this package at object address {}",
            object_address
        );
        prompt_yes_with_override(&message, self.txn_options.prompt_options)?;

        let mut result = if self.chunked_publish_option.chunked_publish {
            let payloads = create_chunked_publish_payloads(
                package,
                PublishType::ObjectDeploy,
                None,
                chunked_publish_large_packages_module_address.unwrap(),
                self.chunked_publish_option.chunk_size,
            )?
            .payloads;

            let size = &payloads
                .iter()
                .map(bcs::serialized_size)
                .sum::<Result<usize, _>>()?;
            println!("package size {} bytes", size);
            let message = format!("Publishing package in chunked mode will submit {} transactions for staging and publishing code.\n", &payloads.len());
            println!("{}", message.bold());

            submit_chunked_publish_transactions(
                payloads,
                &self.txn_options,
                chunked_publish_large_packages_module_address.unwrap(),
            )
            .await
        } else {
            let payload = create_package_publication_data(
                package,
                PublishType::ObjectDeploy,
                Some(object_address),
            )?
            .payload;

            let size = bcs::serialized_size(&payload)?;
            println!("package size {} bytes", size);

            if !self.override_size_check_option.override_size_check
                && size > MAX_PUBLISH_PACKAGE_SIZE
            {
                return Err(CliError::PackageSizeExceeded(
                    size,
                    MAX_PUBLISH_PACKAGE_SIZE,
                ));
            }
            dispatch_transaction(payload, &self.txn_options).await
        };

        if let Ok(tx_summary) = &mut result {
            if let Some(true) = tx_summary.success {
                println!(
                    "Code was successfully deployed to object address {}",
                    object_address
                );
                tx_summary.deployed_object_address = Some(object_address);
            }
        }

        result
    }
}
```

**File:** crates/aptos/src/common/types.rs (L1958-1960)
```rust
        // Get sequence number for account
        let (account, state) = get_account_with_state(&client, sender_address).await?;
        let sequence_number = account.sequence_number;
```

**File:** aptos-move/framework/aptos-framework/sources/object_code_deployment.move (L108-114)
```text
    inline fun object_seed(publisher: address): vector<u8> {
        let sequence_number = account::get_sequence_number(publisher) + 1;
        let seeds = vector[];
        vector::append(&mut seeds, bcs::to_bytes(&OBJECT_CODE_DEPLOYMENT_DOMAIN_SEPARATOR));
        vector::append(&mut seeds, bcs::to_bytes(&sequence_number));
        seeds
    }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L629-631)
```text
        // Increment sequence number
        let addr = signer::address_of(&account);
        account::increment_sequence_number(addr);
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L384-392)
```text
    public fun get_sequence_number(addr: address): u64 acquires Account {
        if (resource_exists_at(addr)) {
            Account[addr].sequence_number
        } else if (features::is_default_account_resource_enabled()) {
            0
        } else {
            abort error::not_found(EACCOUNT_DOES_NOT_EXIST)
        }
    }
```
