# Audit Report

## Title
Genesis Timestamp Validation Bypass Enabling Consensus Liveness Failure

## Summary
The `calculate_genesis()` function in `execution/executor/src/db_bootstrapper/mod.rs` does not validate the timestamp value in genesis transactions, allowing an attacker who controls genesis distribution to set arbitrary future/past timestamps that violate the blockchain's timestamp monotonicity invariant, causing permanent consensus liveness failure.

## Finding Description

The `calculate_genesis()` function processes genesis transactions without validating the on-chain timestamp stored in the `CurrentTimeMicroseconds` resource. This breaks the critical timestamp monotonicity invariant that requires block timestamps to strictly increase.

**Vulnerability Flow:**

1. An attacker creates a malicious `Transaction::GenesisTransaction(WriteSetPayload::Direct(custom_changeset))` where the ChangeSet directly writes `CurrentTimeMicroseconds { microseconds: 99999999999999 }` (far future timestamp) to state. [1](#0-0) 

2. The genesis transaction passes validation in `process_waypoint_change_set()` because `validate_waypoint_change_set()` only checks that NewBlockEvent and NewEpochEvent are emitted, without validating timestamp values. [2](#0-1) 

3. When `calculate_genesis()` processes this genesis:
   - For `genesis_version == 0`: Uses `GENESIS_TIMESTAMP_USECS` (0) for BlockInfo timestamp, but the on-chain `CurrentTimeMicroseconds` is set to the malicious future value, creating a mismatch.
   - For `genesis_version != 0`: Reads the malicious timestamp via `get_state_timestamp()` and uses it directly in BlockInfo without validation. [3](#0-2) 

4. When the first block after genesis is proposed, `block_prologue` calls `emit_new_block_event()`, which calls `timestamp::update_global_time()` with the current real timestamp. [4](#0-3) 

5. The `update_global_time()` function enforces monotonicity: for normal blocks, it requires `now < timestamp`. If on-chain time is year 3000 but the new block timestamp is 2024, this check fails with `EINVALID_TIMESTAMP`. [5](#0-4) 

6. **Result**: All subsequent block proposals fail, causing permanent consensus liveness failure. The blockchain is deadlocked and cannot produce new blocks.

**Root Cause:**

The genesis timestamp is set via direct WriteSet application without executing the normal Move validation logic. The standard genesis path calls `timestamp::set_time_has_started()` which hardcodes the timestamp to 0, followed by `emit_genesis_block_event()` which validates it. [6](#0-5) 

However, malicious `WriteSetPayload::Direct` genesis transactions bypass this validation entirely, and `calculate_genesis()` does not perform compensating validation.

## Impact Explanation

**Severity: Critical** (Total loss of liveness/network availability)

This vulnerability causes:
- **Permanent consensus deadlock**: No blocks can be committed after genesis
- **Non-recoverable without hard fork**: The only recovery mechanism is generating a new genesis transaction with correct timestamp
- **Breaks timestamp monotonicity invariant**: Smart contracts dependent on `timestamp::now_microseconds()` receive manipulated time values
- **Violates Consensus Safety**: All nodes are blocked from producing valid blocks

Per Aptos Bug Bounty criteria, this qualifies as Critical severity under "Total loss of liveness/network availability" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**Likelihood: Medium** (Limited to specific attack scenarios)

Exploitability is constrained by:

1. **Waypoint Verification**: Production networks verify genesis waypoints against known trusted values. A malicious genesis produces a different waypoint, causing validator rejection during bootstrap. [7](#0-6) 

2. **Genesis Distribution Control**: Attacker must control genesis distribution or conduct supply chain attack

3. **Vulnerable Scenarios**:
   - Private/test networks where attacker generates genesis
   - Hard fork scenarios (`genesis_version != 0`) with maliciously crafted recovery genesis
   - Developer environments using custom genesis for testing

The code contains a TODO comment acknowledging this validation gap: [8](#0-7) 

## Recommendation

Add timestamp validation in `calculate_genesis()` to enforce consistency:

```rust
let timestamp_usecs = if genesis_version == 0 {
    // Validate on-chain timestamp matches expected genesis timestamp
    let state_view = CachedStateView::new(
        StateViewId::Miscellaneous,
        Arc::clone(&db.reader),
        output.result_state().latest().clone(),
    )?;
    let on_chain_timestamp = get_state_timestamp(&state_view)?;
    ensure!(
        on_chain_timestamp == GENESIS_TIMESTAMP_USECS,
        "Genesis timestamp mismatch: on-chain={}, expected={}",
        on_chain_timestamp,
        GENESIS_TIMESTAMP_USECS
    );
    GENESIS_TIMESTAMP_USECS
} else {
    let state_view = CachedStateView::new(
        StateViewId::Miscellaneous,
        Arc::clone(&db.reader),
        output.result_state().latest().clone(),
    )?;
    let timestamp = get_state_timestamp(&state_view)?;
    
    // Validate timestamp is reasonable (within some bounds of current time)
    let current_time_usecs = std::time::SystemTime::now()
        .duration_since(std::time::UNIX_EPOCH)
        .unwrap()
        .as_micros() as u64;
    const MAX_TIMESTAMP_DRIFT_SECS: u64 = 365 * 24 * 60 * 60; // 1 year
    let max_drift_usecs = MAX_TIMESTAMP_DRIFT_SECS * 1_000_000;
    
    ensure!(
        timestamp <= current_time_usecs + max_drift_usecs,
        "Genesis timestamp too far in future: {}", 
        timestamp
    );
    
    timestamp
};
```

## Proof of Concept

```rust
use aptos_types::transaction::{Transaction, WriteSetPayload, ChangeSet};
use aptos_types::write_set::{WriteSet, WriteOp};
use aptos_types::state_store::state_key::StateKey;
use aptos_types::timestamp::TimestampResource;
use move_core_types::account_address::AccountAddress;

// Create malicious genesis with far-future timestamp
fn create_malicious_genesis() -> Transaction {
    let aptos_framework = AccountAddress::from_hex_literal("0x1").unwrap();
    
    // Create TimestampResource with far-future timestamp (year 3000)
    let malicious_timestamp = 32503680000000000u64; // ~year 3000 in microseconds
    let timestamp_resource = TimestampResource {
        timestamp: aptos_types::timestamp::Timestamp {
            microseconds: malicious_timestamp,
        },
    };
    
    let timestamp_bytes = bcs::to_bytes(&timestamp_resource).unwrap();
    let state_key = StateKey::resource_typed::<TimestampResource>(&aptos_framework).unwrap();
    
    let write_set = WriteSet::new(vec![(state_key, WriteOp::Value(timestamp_bytes))]);
    
    // Include required events to pass validate_waypoint_change_set
    let events = create_required_genesis_events(); // NewBlockEvent + NewEpochEvent
    
    let change_set = ChangeSet::new(write_set, events);
    Transaction::GenesisTransaction(WriteSetPayload::Direct(change_set))
}

// When calculate_genesis processes this:
// 1. For genesis_version == 0: BlockInfo.timestamp = 0, but on-chain timestamp = year 3000
// 2. First block after genesis fails with EINVALID_TIMESTAMP because:
//    - update_global_time requires: now < new_timestamp
//    - But: year_3000 < year_2024 = false
// 3. Network is permanently deadlocked
```

**Notes**

While waypoint verification provides defense-in-depth for public networks by rejecting genesis transactions with unexpected state roots, the missing validation represents a security gap that:

1. Affects private networks and hard fork scenarios where genesis is locally generated
2. Violates defense-in-depth principles by assuming external validation will catch all issues  
3. Creates maintenance burden as indicated by the TODO comment
4. Could enable sophisticated attacks if waypoint verification is bypassed or disabled

The vulnerability demonstrates that `WriteSetPayload::Direct` genesis transactions bypass Move-level timestamp validation that would normally occur in `emit_genesis_block_event()`. [9](#0-8)

### Citations

**File:** types/src/transaction/mod.rs (L42-42)
```rust
    convert::TryFrom,
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2365-2382)
```rust
    fn validate_waypoint_change_set(
        events: &[(ContractEvent, Option<MoveTypeLayout>)],
        log_context: &AdapterLogSchema,
    ) -> Result<(), VMStatus> {
        let has_new_block_event = events
            .iter()
            .any(|(e, _)| e.event_key() == Some(&new_block_event_key()));
        let has_new_epoch_event = events.iter().any(|(e, _)| e.is_new_epoch_event());
        if has_new_block_event && has_new_epoch_event {
            Ok(())
        } else {
            error!(
                *log_context,
                "[aptos_vm] waypoint txn needs to emit new epoch and block"
            );
            Err(VMStatus::error(StatusCode::INVALID_WRITE_SET, None))
        }
    }
```

**File:** execution/executor/src/db_bootstrapper/mod.rs (L157-174)
```rust
    let timestamp_usecs = if genesis_version == 0 {
        // TODO(aldenhu): fix existing tests before using real timestamp and check on-chain epoch.
        GENESIS_TIMESTAMP_USECS
    } else {
        let state_view = CachedStateView::new(
            StateViewId::Miscellaneous,
            Arc::clone(&db.reader),
            output.result_state().latest().clone(),
        )?;
        let next_epoch = epoch
            .checked_add(1)
            .ok_or_else(|| format_err!("integer overflow occurred"))?;
        ensure!(
            next_epoch == get_state_epoch(&state_view)?,
            "Genesis txn didn't bump epoch."
        );
        get_state_timestamp(&state_view)?
    };
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L281-281)
```text
        timestamp::update_global_time(vm, new_block_event.proposer, new_block_event.time_microseconds);
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L289-308)
```text
    /// Emit a `NewBlockEvent` event. This function will be invoked by genesis directly to generate the very first
    /// reconfiguration event.
    fun emit_genesis_block_event(vm: signer) acquires BlockResource, CommitHistory {
        let block_metadata_ref = borrow_global_mut<BlockResource>(@aptos_framework);
        let genesis_id = @0x0;
        emit_new_block_event(
            &vm,
            &mut block_metadata_ref.new_block_events,
            NewBlockEvent {
                hash: genesis_id,
                epoch: 0,
                round: 0,
                height: 0,
                previous_block_votes_bitvec: vector::empty(),
                proposer: @vm_reserved,
                failed_proposer_indices: vector::empty(),
                time_microseconds: 0,
            },
        );
    }
```

**File:** aptos-move/framework/aptos-framework/sources/timestamp.move (L25-29)
```text
    public(friend) fun set_time_has_started(aptos_framework: &signer) {
        system_addresses::assert_aptos_framework(aptos_framework);
        let timer = CurrentTimeMicroseconds { microseconds: 0 };
        move_to(aptos_framework, timer);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/timestamp.move (L42-49)
```text
        if (proposer == @vm_reserved) {
            // NIL block with null address as proposer. Timestamp must be equal.
            assert!(now == timestamp, error::invalid_argument(EINVALID_TIMESTAMP));
        } else {
            // Normal block. Time must advance
            assert!(now < timestamp, error::invalid_argument(EINVALID_TIMESTAMP));
            global_timer.microseconds = timestamp;
        };
```

**File:** storage/db-tool/src/bootstrap.rs (L87-93)
```rust
        if let Some(waypoint) = self.waypoint_to_verify {
            ensure!(
                waypoint == committer.waypoint(),
                "Waypoint verification failed. Expected {:?}, got {:?}.",
                waypoint,
                committer.waypoint(),
            );
```
