# Audit Report

## Title
Authentication Bypass in Aptos Faucet via X_IS_JWT_HEADER Header Injection

## Summary
The `AuthTokenChecker` in the Aptos faucet contains a critical authentication bypass vulnerability that allows any attacker to completely bypass token authentication by simply adding an `x-is-jwt` header to their request, without providing any valid JWT token or authentication credentials. This enables unlimited unauthorized access to faucet funds.

## Finding Description

The `AuthTokenChecker` implements a flawed bypass logic for JWT authentication that only checks for the **presence** of the `x-is-jwt` header, not its value or whether a valid JWT token is actually provided. [1](#0-0) 

The vulnerable code immediately returns success without performing any authentication checks when the `x-is-jwt` header exists. The intent was to allow JWT-based authentication to take precedence over API key authentication, but the implementation fails to ensure JWT verification actually occurs.

**The Authentication Flow:**

When a request is processed, the faucet iterates through all configured checkers: [2](#0-1) 

The vulnerability manifests when the faucet is configured with `AuthTokenChecker` but **without** JWT verification in a subsequent checker. This configuration is demonstrated in the official testing configuration: [3](#0-2) 

In this configuration:
- `AuthToken` checker is enabled (lines 8-9)
- `MemoryRatelimit` is used (lines 17-18) which does NOT perform JWT verification
- No `RedisRatelimit` with JWT mode is configured

JWT verification only occurs when `RedisRatelimitChecker` is configured with JWT mode: [4](#0-3) 

However, if `RedisRatelimit` is configured with IP-based ratelimiting (as shown in the testing config): [5](#0-4) 

Then no JWT verification occurs even with `RedisRatelimit` present.

**Attack Scenario:**

1. Attacker sends POST request to `/fund` endpoint
2. Includes `x-is-jwt: arbitrary_value` header (any value works, even empty string)
3. `AuthTokenChecker.check()` sees the header exists and returns `Ok(vec![])` without validation
4. Request bypasses all authentication checks
5. Attacker receives funds without any valid credentials
6. Attacker repeats indefinitely, draining faucet resources

The attacker doesn't need:
- A valid auth token from the configured token list
- A valid Firebase JWT
- Any authentication credentials whatsoever

## Impact Explanation

**Severity: Critical**

This vulnerability allows complete bypass of the authentication layer, enabling:

1. **Unlimited Faucet Access**: Attackers can request funds without any authentication, potentially draining the entire faucet balance
2. **Resource Exhaustion**: Automated attacks can overwhelm the faucet service, denying legitimate users access
3. **Financial Loss**: If the faucet distributes tokens with real or future value, attackers can steal these funds
4. **Testnet Disruption**: On testnets, this enables attackers to monopolize test resources, disrupting developer testing and ecosystem development

This meets the Critical severity criteria per Aptos bug bounty:
- **Loss of Funds**: Direct theft of faucet-controlled tokens
- **Total loss of availability**: Faucet can be drained or DOS'd, making it unavailable

## Likelihood Explanation

**Likelihood: High**

This vulnerability is:
- **Trivial to exploit**: Requires only adding a single HTTP header
- **No special access needed**: Any network client can exploit this
- **No rate limiting bypass required**: The authentication check itself is bypassed
- **Affects documented configurations**: The `testing_checkers.yaml` configuration is vulnerable
- **Silent failure**: No logs or alerts indicate the bypass is occurring

Exploitation requires only:
```
POST /fund HTTP/1.1
x-is-jwt: bypass
Content-Type: application/json

{"address": "0xAttackerAddress"}
```

The vulnerability will be exploited immediately once discovered, as it requires no sophistication and provides immediate access to funds.

## Recommendation

**Immediate Fix**: Remove the unconditional bypass logic from `AuthTokenChecker`. The header presence check should be moved to a configuration-time validation that ensures JWT verification is enabled when JWT authentication is supported.

**Option 1 - Remove Bypass (Recommended)**:
Remove lines 37-40 from `auth_token.rs`. If JWT authentication is needed, it should be configured as a separate checker or integrated properly with validation.

**Option 2 - Validate JWT When Header Present**:
If the bypass must remain, modify the logic to:
1. Check if `x-is-jwt` header value equals "true"
2. Extract and validate JWT token via `FirebaseJwtVerifier`
3. Only bypass API key check if JWT is valid

**Configuration Validation**:
Add startup validation that prevents configurations where:
- `AuthTokenChecker` is enabled AND
- No JWT verification checker (e.g., `RedisRatelimit` with JWT mode) is configured

This ensures the bypass path always leads to proper authentication.

## Proof of Concept

**Exploitation Steps:**

1. Identify an Aptos faucet instance using the vulnerable configuration
2. Send a fund request with the bypass header:

```bash
curl -X POST https://faucet.example.com/fund \
  -H "Content-Type: application/json" \
  -H "x-is-jwt: bypass" \
  -d '{"address": "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"}'
```

3. Request succeeds without any valid authentication
4. Repeat to drain faucet funds

**Test Case (Rust)**:

```rust
#[tokio::test]
async fn test_auth_bypass_vulnerability() {
    // Setup faucet with AuthTokenChecker but no JWT verification
    let config = load_config("configs/testing_checkers.yaml");
    let server = build_test_server(config).await;
    
    // Request without authentication but with bypass header
    let response = server
        .post("/fund")
        .header("x-is-jwt", "anything")  // Bypass authentication
        .json(&json!({
            "address": "0xdeadbeef"
        }))
        .send()
        .await;
    
    // Request succeeds despite no valid auth token or JWT
    assert_eq!(response.status(), 200);
    assert!(response.json::<FundResponse>().await.is_ok());
}
```

## Notes

This vulnerability exists due to a design flaw where authentication bypass logic was implemented without ensuring the alternate authentication path (JWT verification) is actually enforced. The `x-is-jwt` header check in `AuthTokenChecker` assumes JWT verification will happen elsewhere, but the faucet configuration system does not enforce this invariant.

The same vulnerable pattern exists in `AuthTokenBypasser`: [6](#0-5) 

Both components should be audited and fixed to ensure proper authentication enforcement.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/auth_token.rs (L37-40)
```rust
        // Don't check if the request has X_IS_JWT_HEADER set.
        if data.headers.contains_key(X_IS_JWT_HEADER) {
            return Ok(vec![]);
        }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L262-270)
```rust
        let mut rejection_reasons = Vec::new();
        for checker in &self.checkers {
            rejection_reasons.extend(checker.check(checker_data.clone(), dry_run).await.map_err(
                |e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError),
            )?);
            if !rejection_reasons.is_empty() && self.return_rejections_early {
                break;
            }
        }
```

**File:** crates/aptos-faucet/configs/testing_checkers.yaml (L7-18)
```yaml
checker_configs:
  - type: "AuthToken"
    file: "/tmp/auth_tokens.txt"
  - type: "IpBlocklist"
    file: "/tmp/ip_blocklist.txt"
  - type: "RefererBlocklist"
    file: "/tmp/referer_blocklist.txt"
  - type: "MagicHeader"
    magic_header_key: "what_wallet_my_guy"
    magic_header_value: "the_wallet_that_rocks"
  - type: "MemoryRatelimit"
    max_requests_per_day: 1000000000
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L44-51)
```rust
    pub async fn ratelimit_key_value(&self, data: &CheckerData) -> Result<String, AptosTapError> {
        match self {
            RatelimitKeyProvider::Ip => Ok(data.source_ip.to_string()),
            RatelimitKeyProvider::Jwt(jwt_verifier) => {
                jwt_verifier.validate_jwt(data.headers.clone()).await
            },
        }
    }
```

**File:** crates/aptos-faucet/configs/testing_redis.yaml (L11-12)
```yaml
    ratelimit_key_provider_config:
      type: "Ip"
```

**File:** crates/aptos-faucet/core/src/bypasser/auth_token.rs (L33-36)
```rust
        // Don't check if the request has X_IS_JWT_HEADER set.
        if data.headers.contains_key(X_IS_JWT_HEADER) {
            return Ok(false);
        }
```
