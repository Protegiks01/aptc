# Audit Report

## Title
Event Size Calculation Underestimates Actual Serialized Size, Enabling Gas Undercharging and Storage Limit Bypass

## Summary
The `ContractEventV2::size()` method incorrectly calculates event size by omitting the ULEB128 length prefix for the `event_data` field, resulting in systematic underestimation of actual BCS-serialized event sizes. This enables gas undercharging and storage limit bypass through events with deeply nested TypeTags.

## Finding Description

The vulnerability exists in the size calculation logic for V2 events. When an event is created via `create_event_v2()`, the size is validated and used for gas metering: [1](#0-0) 

The underlying `ContractEventV2::size()` method calculates: [2](#0-1) 

However, when the full `ContractEventV2` struct is BCS-serialized for storage, the actual format includes a ULEB128-encoded length prefix for the `event_data` Vec<u8>: [3](#0-2) 

The BCS specification requires vectors to be serialized with ULEB128 length prefixes: [4](#0-3) 

**Impact Chain:**

1. **Gas Undercharging**: The `io_gas_per_event()` function uses the incorrect size: [5](#0-4) 

2. **Storage Limit Inconsistency**: The storage limit check uses only `event_data().len()`, completely ignoring TypeTag size: [6](#0-5) 

3. **Actual Storage**: Events are persisted using full BCS serialization: [7](#0-6) 

**Exploitation Path:**

An attacker creates events with:
- Maximum allowed `event_data` size (1MB per event limit)
- Deeply nested TypeTags (up to depth 8 as per `MAX_TYPE_TAG_NESTING`): [8](#0-7) 

The discrepancy includes:
- ULEB128 length prefix: 1-5 bytes depending on `event_data` length
- TypeTag size: Hundreds to thousands of bytes for deeply nested types
- Enum discriminant: 1 byte (when serializing outer `ContractEvent`)

For `event_data.len() = 1,048,576` bytes (1MB):
- ULEB128 prefix = 3 bytes (since 1MB < 2^21)
- Deeply nested TypeTag â‰ˆ 500-1000 bytes
- **Actual stored size exceeds checked limit by ~1KB per event**

## Impact Explanation

This qualifies as **Medium Severity** under Aptos bug bounty criteria:

1. **Limited Funds Loss**: Systematic gas undercharging means validators subsidize undercharged IO operations. With the 10MB total event limit per transaction, attackers save gas proportional to the ~10KB uncounted overhead.

2. **Resource Limit Violation**: Events can exceed the intended 1MB per-event limit by the TypeTag size (confirmed 1MB limit): [9](#0-8) 

3. **Deterministic Execution Not Violated**: All validators calculate the same incorrect size, so consensus remains intact.

4. **Storage Bloat**: Accumulated over many transactions, this enables storing more event data than intended limits allow.

## Likelihood Explanation

**High Likelihood** - The vulnerability is triggered by normal event emission operations:
- No special privileges required
- Easily exploitable through standard Move `event::emit()` calls
- TypeTag depth validation exists but permits nesting up to 8 levels
- Affects all V2 events emitted on the network

## Recommendation

Fix the size calculation to include the ULEB128 length prefix and use consistent size checking:

```rust
// In types/src/contract_event.rs, ContractEventV2::size()
pub fn size(&self) -> anyhow::Result<usize> {
    use crate::serde_helper::bcs_utils::{bcs_size_of_byte_array, size_u32_as_uleb128};
    
    let type_tag_size = bcs::serialized_size(&self.type_tag)?;
    let event_data_size = bcs_size_of_byte_array(self.event_data.len());
    
    Ok(type_tag_size + event_data_size)
}

// In aptos-move/aptos-vm-types/src/storage/change_set_configs.rs
// Use event.size() instead of event.event_data().len()
for event in change_set.events_iter() {
    let size = event.size() as u64; // Now includes TypeTag + ULEB128 prefix
    if size > self.max_bytes_per_event {
        return storage_write_limit_reached(None);
    }
    // ... rest of validation
}
```

## Proof of Concept

```rust
#[test]
fn test_event_size_underestimation() {
    use aptos_types::contract_event::{ContractEvent, ContractEventV2};
    use move_core_types::language_storage::{TypeTag, StructTag, Identifier};
    use move_core_types::account_address::AccountAddress;
    
    // Create a deeply nested TypeTag (depth 8)
    let mut type_tag = TypeTag::U8;
    for _ in 0..8 {
        type_tag = TypeTag::Struct(Box::new(StructTag {
            address: AccountAddress::ONE,
            module: Identifier::new("m").unwrap(),
            name: Identifier::new("S").unwrap(),
            type_args: vec![type_tag],
        }));
    }
    
    // Create event with 1MB data
    let event_data = vec![0u8; 1_048_576];
    let event = ContractEvent::new_v2(type_tag, event_data).unwrap();
    
    // Calculated size (incorrect)
    let calculated_size = event.size();
    
    // Actual BCS serialized size
    let serialized = bcs::to_bytes(&event).unwrap();
    let actual_size = serialized.len();
    
    // Demonstrate discrepancy
    println!("Calculated size: {}", calculated_size);
    println!("Actual serialized size: {}", actual_size);
    println!("Underestimation: {} bytes", actual_size - calculated_size);
    
    assert!(actual_size > calculated_size, "Size calculation underestimates actual serialized size");
    assert!(actual_size - calculated_size > 100, "Discrepancy exceeds 100 bytes");
}
```

## Notes

The vulnerability affects the Move VM's resource accounting invariant. While the individual bypass per event is small (~0.1% of the 1MB limit), the systematic nature means it affects all V2 events across the network. The fix requires updating both the size calculation method and ensuring consistent usage in limit enforcement.

### Citations

**File:** types/src/move_utils/move_event_v2.rs (L8-14)
```rust
pub trait MoveEventV2Type: MoveStructType + Serialize {
    fn create_event_v2(&self) -> anyhow::Result<ContractEvent> {
        ContractEvent::new_v2(
            TypeTag::Struct(Box::new(Self::struct_tag())),
            bcs::to_bytes(self)?,
        )
    }
```

**File:** types/src/contract_event.rs (L246-254)
```rust
/// Entry produced via a call to the `emit` builtin.
#[derive(Hash, Clone, Eq, PartialEq, Serialize, Deserialize, CryptoHasher)]
pub struct ContractEventV2 {
    /// The type of the data
    type_tag: TypeTag,
    /// The data payload of the event
    #[serde(with = "serde_bytes")]
    event_data: Vec<u8>,
}
```

**File:** types/src/contract_event.rs (L268-271)
```rust
    pub fn size(&self) -> anyhow::Result<usize> {
        let size = bcs::serialized_size(&self.type_tag)? + self.event_data.len();
        Ok(size)
    }
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L441-443)
```rust
pub fn bcs_size_of_byte_array(length: usize) -> usize {
    size_u32_as_uleb128(length) + length
}
```

**File:** aptos-move/aptos-vm-types/src/storage/io_pricing.rs (L296-301)
```rust
    pub fn io_gas_per_event(
        &self,
        event: &ContractEvent,
    ) -> impl GasExpression<VMGasParameters, Unit = InternalGasUnit> + use<> {
        STORAGE_IO_PER_EVENT_BYTE_WRITE * NumBytes::new(event.size() as u64)
    }
```

**File:** aptos-move/aptos-vm-types/src/storage/change_set_configs.rs (L115-125)
```rust
        let mut total_event_size = 0;
        for event in change_set.events_iter() {
            let size = event.event_data().len() as u64;
            if size > self.max_bytes_per_event {
                return storage_write_limit_reached(None);
            }
            total_event_size += size;
            if total_event_size > self.max_bytes_all_events_per_transaction {
                return storage_write_limit_reached(None);
            }
        }
```

**File:** storage/aptosdb/src/schema/event/mod.rs (L49-52)
```rust
impl ValueCodec<EventSchema> for ContractEvent {
    fn encode_value(&self) -> Result<Vec<u8>> {
        bcs::to_bytes(self).map_err(Into::into)
    }
```

**File:** third_party/move/move-core/types/src/safe_serialize.rs (L11-11)
```rust
pub(crate) const MAX_TYPE_TAG_NESTING: u8 = 8;
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L164-167)
```rust
            max_bytes_per_event: NumBytes,
            { 5.. => "max_bytes_per_event" },
            1 << 20, // a single event is 1MB max
        ],
```
