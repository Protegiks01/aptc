# Audit Report

## Title
Race Condition in Resource Group Initialization Causes Non-Deterministic Parallel Execution Failures

## Summary
A race condition exists between `group_sizes` and `group_tags` initialization in `VersionedGroupData::set_raw_base_values()`, allowing concurrent transactions to trigger code invariant errors during parallel execution. This forces fallback to sequential execution, creating a performance DoS vector affecting validator throughput.

## Finding Description

The vulnerability occurs in the parallel execution path (BlockSTM) when resource groups are lazily initialized. The initialization process creates two separate DashMap data structures non-atomically:

1. First, `group_sizes` is created: [1](#0-0) 

2. Then, `group_tags` is created separately: [2](#0-1) 

Between these operations, there is a critical race window where `group_sizes` exists but `group_tags` does not. The read path determines initialization solely by checking `group_sizes`: [3](#0-2) 

However, the write path requires `group_tags` to exist: [4](#0-3) 

**Exploitation Path:**

1. Thread 1 (T1) initializes resource group G via `set_raw_base_values(G)`, creating `group_sizes[G]` entry
2. Thread 2 (T2) concurrently reads from G, sees `group_sizes.contains_key(G)` returns true, considers group initialized
3. T2 receives `TagNotFound` error (values not set yet), updates base value via `update_tagged_base_value_with_layout`: [5](#0-4) 
4. T2 later writes to G via `write_v2()` → `data_write_impl()` → checks `group_tags.get(G)` → None!
5. Returns code_invariant_error, halting parallel execution: [6](#0-5) 

This triggers the error handling path that sets shared error flag and halts the scheduler: [7](#0-6) 

Leading to fallback to sequential execution when `allow_fallback` is enabled: [8](#0-7) 

The code contains TODO comments acknowledging these initialization issues need refactoring: [9](#0-8) 

## Impact Explanation

**HIGH Severity** per Aptos bug bounty criteria: "Validator node slowdowns"

The vulnerability forces validators to fall back from parallel to sequential execution, causing significant performance degradation:

- Parallel execution throughput: ~N transactions concurrently (N = concurrency_level)
- Sequential execution throughput: 1 transaction at a time  
- Performance degradation: ~N× slower block execution

The default configuration enables fallback, preventing consensus failures but allowing performance attacks: [10](#0-9) 

**Security Impacts:**
1. **Performance DoS**: Attackers can force sequential execution across all validators by submitting transactions that access new resource groups concurrently
2. **Non-deterministic behavior**: Same block executes differently (parallel vs sequential) based on timing races
3. **Resource waste**: Computational resources wasted on failed parallel execution attempts
4. **Code invariant violation**: The system explicitly treats this as a bug that shouldn't occur

## Likelihood Explanation

**MODERATE to HIGH Likelihood** for the following reasons:

1. **Low attacker complexity**: Simply submit transactions accessing new resource groups in the same block
2. **No special privileges required**: Any transaction sender can submit such transactions
3. **Reproducible with attempts**: While the race window is narrow, attackers can submit multiple blocks to increase hit probability
4. **Natural occurrence possible**: Can happen without malicious intent when legitimate transactions access new groups concurrently
5. **Parallel execution is standard**: Most validators run with concurrency_level > 1

The race window exists between DashMap operations on separate data structures (`group_sizes` and `group_tags`), with no atomic cross-map synchronization. The comment at line 84 acknowledges this: [11](#0-10) 

## Recommendation

Implement atomic initialization of both `group_sizes` and `group_tags` to eliminate the race window:

1. **Short-term fix**: Use a single lock or atomic flag to coordinate initialization of both maps
2. **Long-term fix**: Refactor initialization logic as indicated by TODO comments to use a single data structure or ensure atomic updates across both maps
3. **Alternative**: Make the read path check both `group_sizes` AND `group_tags` before considering a group initialized

The initialization check should be atomic across both data structures, or the write path should handle missing `group_tags` gracefully during the initialization window.

## Proof of Concept

The race can be demonstrated by creating two concurrent transactions in the same block that both access a previously unaccessed resource group. While direct PoC construction requires parallel execution infrastructure, the vulnerability is evident from the code structure where:

1. Test case confirms writes fail before initialization: [12](#0-11) 

2. The race window exists between lines 155 and 175 in `set_raw_base_values()`

3. Concurrent access patterns in BlockSTM can trigger this sequence given the non-atomic initialization

The vulnerability is confirmed by the code structure and acknowledged initialization issues in TODO comments.

### Citations

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L84-84)
```rust
    // group related APIs. The accesses are synchronized with group size entry (for now),
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L155-155)
```rust
        let mut group_sizes = self.group_sizes.entry(group_key.clone()).or_default();
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L175-175)
```rust
            let mut superset_tags = self.group_tags.entry(group_key.clone()).or_default();
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L282-283)
```rust
            // TODO(BlockSTMv2): when we refactor MVHashMap and group initialization logic,
            // also revisit and address the read-before-write assumption.
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L452-452)
```rust
        let initialized = self.group_sizes.contains_key(group_key);
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L630-633)
```rust
            let superset_tags = self.group_tags.get(group_key).ok_or_else(|| {
                // Due to read-before-write.
                code_invariant_error("Group (tags) must be initialized to write to")
            })?;
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L1278-1287)
```rust
        // Write should fail because group is not initialized (R before W, where
        // and read causes the base values/size to be set).
        assert_err!(map.write(
            ap.clone(),
            3,
            1,
            (0..2).map(|i| (i, (TestValue::creation_with_len(1), None))),
            idx_3_size,
            HashSet::new(),
        ));
```

**File:** aptos-move/block-executor/src/view.rs (L815-827)
```rust
                Err(TagNotFound) => {
                    // TagNotFound means group was initialized (o.w. Uninitialized branch
                    // would be visited), but the tag didn't exist. So record an empty resource
                    // as a base value, and do continue to retry the read.
                    self.versioned_map
                        .group_data()
                        .update_tagged_base_value_with_layout(
                            group_key.clone(),
                            resource_tag.clone(),
                            TransactionWrite::from_state_value(None),
                            None,
                        );
                    continue;
```

**File:** aptos-move/block-executor/src/executor.rs (L1789-1799)
```rust
                        if let PanicOr::CodeInvariantError(err_msg) = err {
                            alert!(
                                "[BlockSTMv2] worker loop: CodeInvariantError({:?})",
                                err_msg
                            );
                        }
                        shared_maybe_error.store(true, Ordering::SeqCst);

                        // Make sure to halt the scheduler if it hasn't already been halted.
                        scheduler.halt();
                    }
```

**File:** aptos-move/block-executor/src/executor.rs (L2596-2596)
```rust
            info!("parallel execution requiring fallback");
```

**File:** types/src/block_executor/config.rs (L75-75)
```rust
            allow_fallback: true,
```
