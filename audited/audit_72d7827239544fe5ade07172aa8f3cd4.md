# Audit Report

## Title
Vault Authentication Token Leakage via Configuration Debug Endpoint Despite SilentDebug Claims

## Summary
The configuration endpoint at `/configuration` exposes Vault authentication tokens in plaintext when they are configured using the `Token::FromConfig` variant, violating the security guarantee stated in the code comments that "all secret keys are marked with SilentDisplay and SilentDebug." This allows attackers with access to the inspection service to extract Vault tokens, potentially compromising the entire secure storage backend containing consensus keys, network keys, and other sensitive validator credentials.

## Finding Description

The configuration endpoint handler formats the entire NodeConfig using debug formatting with the stated intention of protecting secrets: [1](#0-0) 

However, the `Token` enum used in `VaultConfig` for Vault authentication derives the standard `Debug` trait, not `SilentDebug`: [2](#0-1) 

This `Token` type is used as a field in `VaultConfig`: [3](#0-2) 

When a node operator configures their Vault backend using `Token::FromConfig(String)` to embed the token directly (as shown in the test cases): [4](#0-3) 

The token string will be exposed in plaintext when the configuration is debug-formatted, because the derived `Debug` implementation for the `Token` enum will print: `FromConfig("actual_vault_token_here")`.

**Attack Path:**

1. Operator configures a validator with Vault backend using `token: { from_config: "hvs.CAESIJ..." }` instead of the recommended `from_disk` variant
2. Operator enables the configuration endpoint with `inspection_service.expose_configuration: true`
3. Attacker queries the `/configuration` endpoint
4. The debug output includes `VaultConfig { ... token: FromConfig("hvs.CAESIJ...") ... }`
5. Attacker extracts the Vault token and can now access all secrets in that Vault namespace
6. This compromises consensus private keys, network private keys, and other sensitive credentials stored in Vault

The vulnerability exists because the code comment claims protection for "all secret keys" but the `Token` type is not marked with `SilentDebug`, creating a false sense of security.

## Impact Explanation

**High Severity** - This qualifies as a "Significant protocol violation" under the Aptos bug bounty criteria.

While the configuration endpoint is disabled by default (`expose_configuration: false`), if enabled, this vulnerability allows extraction of Vault authentication tokens. A compromised Vault token enables an attacker to:

1. Read all consensus private keys stored in Vault (for validators using Vault storage)
2. Read network identity keys 
3. Potentially write/modify keys if the token has write permissions
4. Access any other sensitive configuration data stored in the Vault namespace

This could lead to:
- Consensus key compromise, enabling signature forgery
- Network key compromise, enabling man-in-the-middle attacks or validator impersonation
- Complete validator compromise if the attacker gains access to signing capabilities

The impact is not Critical because:
- The endpoint must be explicitly enabled by the operator
- The secure configuration uses `from_disk`, not `from_config`
- Most production deployments likely use the file-based token approach

However, the discrepancy between the code comment's security guarantee and the actual implementation creates a dangerous false sense of security.

## Likelihood Explanation

**Medium Likelihood** - The vulnerability requires several preconditions:

1. Node operator must enable `expose_configuration: true` (not default)
2. Node operator must use `Token::FromConfig` variant (not recommended in examples)
3. Attacker must have network access to the inspection service endpoint
4. The inspection service must be exposed to untrusted networks

The recommended configuration pattern uses `from_disk`: [5](#0-4) 

However, the `FromConfig` variant is explicitly supported and tested, indicating it's a valid configuration option that operators might use for convenience in development or testing environments that accidentally get promoted to production.

The false security guarantee in the code comments increases likelihood, as operators may believe all secrets are protected and feel safe enabling the endpoint.

## Recommendation

**Primary Fix:** Mark the `Token` enum with `SilentDebug` to prevent token leakage:

```rust
#[derive(Clone, SilentDebug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(rename_all = "snake_case")]
pub enum Token {
    FromConfig(String),
    FromDisk(PathBuf),
}
```

**Additional Recommendations:**

1. Add `SilentDisplay` as well to prevent accidental logging
2. Update the configuration handler comment to accurately reflect what is protected
3. Consider deprecating `Token::FromConfig` entirely and requiring file-based tokens for production
4. Add a configuration validator that warns or errors when `FromConfig` is used with `expose_configuration: true`
5. Review all other configuration fields for similar issues (database passwords, API keys, etc.)

**Code locations requiring changes:** [6](#0-5) 

## Proof of Concept

```rust
// This test demonstrates the token leakage vulnerability
#[test]
fn test_vault_token_leaks_in_debug_output() {
    use aptos_config::config::{NodeConfig, SecureBackend, VaultConfig, Token};
    
    // Create a node config with Vault backend using FromConfig token
    let mut node_config = NodeConfig::get_default_validator_config();
    
    // Configure Vault with an embedded token (insecure but supported)
    let vault_config = VaultConfig {
        namespace: Some("test".to_string()),
        server: "https://vault.example.com:8200".to_string(),
        ca_certificate: None,
        token: Token::FromConfig("hvs.CAESIJ_SENSITIVE_TOKEN_12345".to_string()),
        renew_ttl_secs: None,
        disable_cas: None,
        connection_timeout_ms: None,
        response_timeout_ms: None,
    };
    
    // Set this as the consensus backend
    node_config.consensus.safety_rules.backend = SecureBackend::Vault(vault_config);
    
    // Enable the configuration endpoint
    node_config.inspection_service.expose_configuration = true;
    
    // Format the config using debug (same as the endpoint does)
    let debug_output = format!("{:?}", node_config);
    
    // VULNERABILITY: The sensitive token is exposed in plaintext
    assert!(debug_output.contains("hvs.CAESIJ_SENSITIVE_TOKEN_12345"));
    
    // This should NOT happen if the security guarantee held
    println!("LEAKED TOKEN IN DEBUG OUTPUT:\n{}", debug_output);
    
    // Expected behavior: Token should be elided like private keys
    // Actual behavior: Token is fully exposed
}
```

**Steps to reproduce:**

1. Create a validator config with Vault backend
2. Use `token: { from_config: "actual_token" }` in the Vault config
3. Enable `inspection_service.expose_configuration: true`
4. Start the node and query `http://localhost:9101/configuration`
5. Observe the Vault token in plaintext in the response

The vulnerability is confirmed by the test suite itself, which demonstrates that `FromConfig` tokens are stored and can be serialized: [7](#0-6)

### Citations

**File:** crates/aptos-inspection-service/src/server/configuration.rs (L16-19)
```rust
        // We format the configuration using debug formatting. This is important to
        // prevent secret/private keys from being serialized and leaked (i.e.,
        // all secret keys are marked with SilentDisplay and SilentDebug).
        let encoded_configuration = format!("{:?}", node_config);
```

**File:** config/src/config/secure_backend_config.rs (L51-67)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(deny_unknown_fields)]
pub struct VaultConfig {
    /// Optional SSL Certificate for the vault host, this is expected to be a full path.
    pub ca_certificate: Option<PathBuf>,
    /// A namespace is an optional portion of the path to a key stored within Vault. For example,
    /// a secret, S, without a namespace would be available in secret/data/S, with a namespace, N, it
    /// would be in secret/data/N/S.
    pub namespace: Option<String>,
    /// Vault leverages leases on many tokens, specify this to automatically have your lease
    /// renewed up to that many seconds more. If this is not specified, the lease will not
    /// automatically be renewed.
    pub renew_ttl_secs: Option<u32>,
    /// Vault's URL, note: only HTTP is currently supported.
    pub server: String,
    /// The authorization token for accessing secrets
    pub token: Token,
```

**File:** config/src/config/secure_backend_config.rs (L99-106)
```rust
/// Tokens can either be directly within this config or stored somewhere on disk.
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(rename_all = "snake_case")]
pub enum Token {
    FromConfig(String),
    /// This is an absolute path and not relative to data_dir
    FromDisk(PathBuf),
}
```

**File:** config/src/config/secure_backend_config.rs (L221-226)
```rust
        let text_from_config = r#"
vault:
    server: "127.0.0.1:8200"
    token:
        from_config: "test"
        "#;
```

**File:** config/src/config/secure_backend_config.rs (L293-304)
```rust
    fn test_token_reading() {
        let temppath = aptos_temppath::TempPath::new();
        temppath.create_as_file().unwrap();
        let mut file = File::create(temppath.path()).unwrap();
        file.write_all(b"disk_token").unwrap();

        let disk = Token::FromDisk(temppath.path().to_path_buf());
        assert_eq!("disk_token", disk.read_token().unwrap());

        let config = Token::FromConfig("config_token".to_string());
        assert_eq!("config_token", config.read_token().unwrap());
    }
```

**File:** config/src/config/test_data/validator.yaml (L9-10)
```yaml
            token:
                from_disk: "/full/path/to/token"
```
