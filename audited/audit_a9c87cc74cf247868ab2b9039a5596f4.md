# Audit Report

## Title
Unauthenticated Failpoint API Enables Remote Consensus Denial of Service on Non-Mainnet Validators

## Summary
The consensus payload client contains a failpoint at line 103 that can be remotely triggered via an unauthenticated REST API endpoint, allowing network attackers to cause consensus proposal failures on testnet and devnet validators that have failpoints enabled in their configuration.

## Finding Description

The `QuorumStoreClient::pull()` function contains a failpoint that injects errors into the consensus payload retrieval mechanism: [1](#0-0) 

This failpoint can be triggered remotely through an unauthenticated HTTP GET endpoint at `/v1/set_failpoint`: [2](#0-1) 

The endpoint implementation only verifies that failpoints are enabled in the configuration, with no authentication or authorization checks: [3](#0-2) 

When the `consensus::pull_payload` failpoint is activated, every subsequent call to `pull()` returns an error, causing the proposal generation process to fail: [4](#0-3) 

The error propagates through the consensus layer, causing the node to fail proposal generation: [5](#0-4) 

**Attack Path:**
1. Attacker identifies a testnet/devnet validator with `api.failpoints_enabled: true` and publicly exposed API
2. Attacker sends: `GET http://target:8080/v1/set_failpoint?name=consensus::pull_payload&actions=return`
3. The failpoint is activated without any authentication
4. All subsequent consensus proposal attempts on that node fail
5. When the affected node is the proposer, no proposal is sent, causing round timeouts
6. If multiple validators are targeted, consensus experiences severe liveness degradation

**Invariants Broken:**
- **Consensus Safety**: While not directly breaking safety, severely impacts liveness
- **Access Control**: Administrative debug functionality exposed without authentication
- **Resource Limits**: Allows external actors to exhaust consensus capability

## Impact Explanation

This qualifies as **High Severity** per Aptos bug bounty criteria for the following reasons:

**"Validator node slowdowns"**: Affected validators fail to generate proposals, causing them to miss their proposer turns and creating consensus round timeouts.

**"Significant protocol violations"**: Prevents validators from fulfilling their consensus duties, violating the liveness guarantee of the AptosBFT protocol.

The impact scales with the number of affected nodes:
- **Single node**: Intermittent round timeouts when that node is proposer
- **Multiple nodes**: Frequent consensus delays and degraded performance  
- **Many nodes**: Severe liveness impact approaching network partition

While mainnet is explicitly protected by configuration sanitization: [6](#0-5) 

Testnet and devnet are critical infrastructure for development, testing, and ecosystem onboarding. A DoS attack on these networks would significantly disrupt the Aptos ecosystem.

## Likelihood Explanation

**Likelihood: Low to Medium** depending on operator practices.

**Required Conditions:**
1. Node compiled with `failpoints` feature flag (common in non-production builds)
2. Operator sets `api.failpoints_enabled: true` in configuration (non-default but possible for debugging)
3. API bound to public address or attacker has network access (varies by deployment)
4. Network is testnet/devnet (mainnet explicitly blocked)

The vulnerability requires operator misconfiguration, but the **lack of authentication is a design flaw**. Operators may enable failpoints temporarily for debugging and forget to disable them, or may not fully understand the security implications. The API documentation mentions that "some administrative endpoints may require additional authorization" but does not specify which: [7](#0-6) 

The failpoint endpoint is not clearly documented as requiring special protection, making misconfiguration more likely.

## Recommendation

**Immediate Fix:** Add authentication/authorization to the failpoint endpoint. Even when failpoints are enabled, they should require cryptographic proof of authorization (e.g., signed requests, API keys, or local-only access).

**Implementation Approach:**
1. Add authentication middleware to the `/set_failpoint` route
2. Require either:
   - Bearer token authentication with authorized keys
   - Restrict endpoint to localhost (127.0.0.1) only
   - mTLS certificate validation

**Example Fix (restrictive approach):**

Modify the endpoint registration to restrict to localhost:

```rust
// In api/src/runtime.rs
.at(
    "/set_failpoint",
    poem::get(set_failpoints::set_failpoint_poem)
        .data(context.clone())
        .with(LocalhostOnly::new()), // Add localhost-only middleware
)
```

**Defense-in-Depth:** Add warning logs when failpoints are enabled:

```rust
// In aptos-node/src/lib.rs
if fail::has_failpoints() {
    warn!("⚠️  SECURITY WARNING: Failpoints are enabled! This should ONLY be used in isolated test environments.");
    warn!("⚠️  The /v1/set_failpoint endpoint is exposed and can be used to trigger consensus failures.");
    warn!("⚠️  Ensure this node's API is NOT publicly accessible.");
}
```

## Proof of Concept

**Reproduction Steps:**

1. Start a testnet validator node with failpoints enabled:
```yaml
# node.yaml
api:
  enabled: true
  address: "0.0.0.0:8080"
  failpoints_enabled: true
```

2. From a remote attacker machine, trigger the failpoint:
```bash
curl "http://validator-ip:8080/v1/set_failpoint?name=consensus::pull_payload&actions=return"
```

3. Monitor the validator logs - you will see repeated failures:
```
[consensus] WARN Error generating and sending proposal: Fail to retrieve payload
Caused by: Injected error in pull_payload
```

4. Observe consensus metrics - the affected validator will:
   - Increment `ERROR_COUNT` counter
   - Fail to send proposals during its proposer turns
   - Cause round timeouts visible to other validators

**Verification:**
The attack succeeds when:
- The validator stops sending proposals (visible in network traffic)
- Consensus rounds timeout when this validator is the proposer
- Other validators log "timeout waiting for proposal" messages

**Recovery:**
The failpoint persists until explicitly cleared:
```bash
curl "http://validator-ip:8080/v1/set_failpoint?name=consensus::pull_payload&actions=off"
```

Or until the node is restarted without failpoints in config.

---

## Notes

**Why This is a Valid Vulnerability:**

Despite requiring configuration enablement, this represents a genuine security flaw because:

1. **Defense-in-depth principle violated**: Dangerous administrative functionality should have multiple layers of protection, not just a configuration flag

2. **Testnet/devnet are production infrastructure**: These networks serve critical ecosystem functions and should be secured against unauthorized DoS attacks

3. **Operator error is a realistic threat model**: Security should account for misconfiguration, especially when the implications are not clearly documented

4. **Unauthenticated access is the core issue**: The vulnerability is not that failpoints exist (they're a legitimate testing tool), but that they can be triggered by any network attacker without authentication once enabled

The fix is straightforward: add authentication to protect against unauthorized access even when the feature is enabled.

### Citations

**File:** consensus/src/payload_client/user/quorum_store_client.rs (L103-105)
```rust
        fail_point!("consensus::pull_payload", |_| {
            Err(anyhow::anyhow!("Injected error in pull_payload").into())
        });
```

**File:** api/src/runtime.rs (L248-251)
```rust
                    .at(
                        "/set_failpoint",
                        poem::get(set_failpoints::set_failpoint_poem).data(context.clone()),
                    ),
```

**File:** api/src/set_failpoints.rs (L22-40)
```rust
#[handler]
pub fn set_failpoint_poem(
    context: Data<&std::sync::Arc<Context>>,
    Query(failpoint_conf): Query<FailpointConf>,
) -> poem::Result<String> {
    if context.failpoints_enabled() {
        fail::cfg(&failpoint_conf.name, &failpoint_conf.actions)
            .map_err(|e| poem::Error::from(anyhow::anyhow!(e)))?;
        info!(
            "Configured failpoint {} to {}",
            failpoint_conf.name, failpoint_conf.actions
        );
        Ok(format!("Set failpoint {}", failpoint_conf.name))
    } else {
        Err(poem::Error::from(anyhow::anyhow!(
            "Failpoints are not enabled at a config level"
        )))
    }
}
```

**File:** consensus/src/liveness/proposal_generator.rs (L652-672)
```rust
        let (validator_txns, mut payload) = self
            .payload_client
            .pull_payload(
                PayloadPullParameters {
                    max_poll_time: self.quorum_store_poll_time.saturating_sub(proposal_delay),
                    max_txns: max_block_txns,
                    max_txns_after_filtering: max_block_txns_after_filtering,
                    soft_max_txns_after_filtering: max_txns_from_block_to_execute
                        .unwrap_or(max_block_txns_after_filtering),
                    max_inline_txns: self.max_inline_txns,
                    maybe_optqs_payload_pull_params,
                    user_txn_filter: payload_filter,
                    pending_ordering,
                    pending_uncommitted_blocks: pending_blocks.len(),
                    recent_max_fill_fraction: max_fill_fraction,
                    block_timestamp: timestamp,
                },
                validator_txn_filter,
            )
            .await
            .context("Fail to retrieve payload")?;
```

**File:** consensus/src/round_manager.rs (L496-510)
```rust
                if let Err(e) = monitor!(
                    "generate_and_send_proposal",
                    Self::generate_and_send_proposal(
                        epoch_state,
                        new_round_event,
                        network,
                        sync_info,
                        proposal_generator,
                        safety_rules,
                        proposer_election,
                    )
                    .await
                ) {
                    warn!("Error generating and sending proposal: {}", e);
                }
```

**File:** config/src/config/api_config.rs (L177-185)
```rust
        // Verify that failpoints are not enabled in mainnet
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() && api_config.failpoints_enabled {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Failpoints are not supported on mainnet nodes!".into(),
                ));
            }
        }
```

**File:** api/doc/README.md (L18-19)
```markdown
## Authentication
The API does not require authentication for public endpoints. Some administrative endpoints may require additional authorization.
```
