# Audit Report

## Title
Missing Preferred Round Validation in Voting Path Enables 2-Chain Safety Rule Bypass via Timeout Certificates

## Summary
The `verify_and_update_preferred_round` check that enforces the 2-chain voting rule is only applied when leaders sign proposals but is **completely missing** from the validator voting path. This asymmetry allows Byzantine leaders to craft proposals with timeout certificates that trick honest validators into voting on blocks extending from earlier chain points than their highest observed 2-chain, potentially enabling conflicting blocks to be committed and violating consensus safety.

## Finding Description

The `IncorrectPreferredRound` error is designed to enforce a critical safety invariant: validators should never build on a quorum certificate whose `one_chain_round` (certified block round) is lower than their `preferred_round` (highest 2-chain round observed). This prevents validators from voting on branches that "go backwards" relative to the highest 2-chain they've witnessed. [1](#0-0) 

However, this check is **only enforced** in `guarded_sign_proposal` when a leader creates a proposal: [2](#0-1) 

It is **completely absent** from `guarded_construct_and_sign_vote_two_chain`, which validators use to vote on proposals: [3](#0-2) 

The voting path only checks `safe_to_vote` and `verify_and_update_last_vote_round`, neither of which validates the preferred round invariant. The `safe_to_vote` check permits blocks with timeout certificates as long as `qc_round >= tc.highest_hqc_round`: [4](#0-3) 

### Attack Scenario

**Setup:**
- Network progresses: genesis(0) → B1(1) → B2(2) → B3(3) → B4(4) → B5(5)
- Honest validator V has voted on all blocks through B5, establishing:
  - `last_voted_round = 5`
  - `one_chain_round = 5`  
  - `preferred_round = 4` (from observing the 2-chain B3→B4→B5)
- B4 becomes committed via the certified 2-chain B3→B4→B5

**Attack Execution:**
1. Due to network asynchrony, some validators form a timeout certificate TC5 for round 5 with `highest_hqc_round = 3` (legitimately possible if those validators only observed blocks up to B3)
2. Byzantine leader L (selected for round 6) crafts block B6_malicious:
   - `round = 6`
   - `quorum_cert` from B3 (certified_block_round = 3, parent_block_round = 2)
   - `timeout_cert = TC5` (round = 5, highest_hqc_round = 3)
3. Honest validator V receives B6_malicious and processes it:
   - ✅ `verify_proposal`: Signatures valid, QC valid
   - ✅ `safe_to_vote`: `round 6 == next_round(5) && qc_round 3 >= hqc_round 3` → **PASSES**
   - ✅ `verify_and_update_last_vote_round`: `6 > 5` → **PASSES**
   - ❌ **MISSING**: `verify_and_update_preferred_round` would check: `3 >= 4` → **SHOULD FAIL**
4. V votes on B6_malicious, even though its QC's one_chain_round (3) violates V's preferred_round (4)
5. B6_malicious gets certified with 2f+1 votes
6. A subsequent B7 extending B6 gets certified, committing B6 via 2-chain rule

**Result:** Both B4 and B6 become committed. Since B6 extends B3 but not B4, this creates a fork in the committed chain after B3, violating the fundamental consensus safety guarantee that only one block per round can be committed in the canonical chain.

## Impact Explanation

**Critical Severity (up to $1,000,000)** - This vulnerability directly violates the core consensus safety invariant: [5](#0-4) 

The attack enables:
- **Consensus Safety Violation**: Two conflicting blocks can be committed, breaking the "no-fork" guarantee
- **Double-Spending**: Transactions in B4 can be replaced by conflicting transactions in B6
- **Chain Split**: Different validators may commit different chains, requiring manual intervention or hard fork
- **Loss of Funds**: Assets transferred in one branch can be spent again in the conflicting branch

This meets the Critical severity category: "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)."

## Likelihood Explanation

**High Likelihood** - The attack is practical and exploitable:

1. **Requires only single Byzantine validator** (< 1/3 threshold): The attacker must be elected as leader for a round, which occurs naturally in rotation
2. **Legitimate timeout certificates**: Network partitions and timeouts occur organically in distributed systems, making TC formation with varied `highest_hqc_round` values common
3. **No collusion needed**: A single Byzantine leader can exploit this without coordinating with other validators
4. **Detection difficulty**: The malicious proposal passes all cryptographic and structural validations - only the missing semantic check would catch it
5. **Persistent vulnerability**: Every round with a timeout certificate provides an opportunity for exploitation

The combination of low attacker requirements, realistic preconditions (network timeouts), and undetectable malicious proposals makes exploitation highly likely in production environments.

## Recommendation

Add the `verify_and_update_preferred_round` check to the validator voting path. Modify `guarded_construct_and_sign_vote_two_chain` to validate preferred round before voting:

```rust
pub(crate) fn guarded_construct_and_sign_vote_two_chain(
    &mut self,
    vote_proposal: &VoteProposal,
    timeout_cert: Option<&TwoChainTimeoutCertificate>,
) -> Result<Vote, Error> {
    self.signer()?;
    
    let vote_data = self.verify_proposal(vote_proposal)?;
    if let Some(tc) = timeout_cert {
        self.verify_tc(tc)?;
    }
    let proposed_block = vote_proposal.block();
    let mut safety_data = self.persistent_storage.safety_data()?;

    if let Some(vote) = safety_data.last_vote.clone() {
        if vote.vote_data().proposed().round() == proposed_block.round() {
            return Ok(vote);
        }
    }

    // Two voting rules
    self.verify_and_update_last_vote_round(
        proposed_block.block_data().round(),
        &mut safety_data,
    )?;
    self.safe_to_vote(proposed_block, timeout_cert)?;
    
    // ADD THIS CHECK - Validate preferred round before voting
    self.verify_and_update_preferred_round(
        proposed_block.quorum_cert(),
        &mut safety_data,
    )?;

    // Record 1-chain data  
    self.observe_qc(proposed_block.quorum_cert(), &mut safety_data);
    // ... rest of function
}
```

This ensures validators cannot vote on proposals that violate the 2-chain safety rule, maintaining symmetry with the leader proposal path.

## Proof of Concept

```rust
#[test]
fn test_vote_with_early_preferred_round_via_timeout() {
    let (mut safety_rules, signer) = make_safety_rules();
    let (proof, genesis_qc) = make_genesis(&signer);
    let round = genesis_qc.certified_block().round();
    
    safety_rules.initialize(&proof).unwrap();
    
    // Build normal chain: genesis → b1 → b2 → b3 → b4 → b5
    let b1 = make_proposal_with_qc(round + 1, genesis_qc.clone(), &signer);
    let b2 = make_proposal_with_parent(round + 2, &b1, None, &signer);
    let b3 = make_proposal_with_parent(round + 3, &b2, None, &signer);
    let b4 = make_proposal_with_parent(round + 4, &b3, None, &signer);
    let b5 = make_proposal_with_parent(round + 5, &b4, None, &signer);
    
    // Vote on all blocks, establishing preferred_round = 4
    safety_rules.construct_and_sign_vote_two_chain(&b1, None).unwrap();
    safety_rules.construct_and_sign_vote_two_chain(&b2, None).unwrap();
    safety_rules.construct_and_sign_vote_two_chain(&b3, None).unwrap();
    safety_rules.construct_and_sign_vote_two_chain(&b4, None).unwrap();
    safety_rules.construct_and_sign_vote_two_chain(&b5, None).unwrap();
    
    let state = safety_rules.consensus_state().unwrap();
    assert_eq!(state.preferred_round(), 4);
    
    // Create timeout certificate for round 5 with highest_hqc_round = 3
    let tc5 = make_timeout_cert(round + 5, b3.block().quorum_cert(), &signer);
    
    // Byzantine leader proposes b6 with QC from b3 (round 3) and TC from round 5
    let b6_malicious = make_proposal_with_qc_and_proof(
        round + 6,
        empty_proof(),
        b3.block().quorum_cert().clone(),
        &signer,
    );
    
    // VULNERABILITY: This should fail with IncorrectPreferredRound(3, 4)
    // because QC's one_chain_round (3) < preferred_round (4)
    // But it passes because the check is missing in the voting path!
    let result = safety_rules.construct_and_sign_vote_two_chain(&b6_malicious, Some(&tc5));
    
    // With the fix, this should return Err(Error::IncorrectPreferredRound(3, 4))
    // Without the fix, it incorrectly returns Ok, allowing the safety violation
    assert!(result.is_err()); // This assertion FAILS without the fix
    assert_eq!(result.unwrap_err(), Error::IncorrectPreferredRound(3, 4));
}
```

## Notes

This vulnerability exists due to code asymmetry between the leader proposal path and validator voting path. The `verify_and_update_preferred_round` check was correctly implemented for proposal signing (preventing leaders from creating invalid proposals) but was inadvertently omitted from the voting path (allowing validators to vote on such proposals if they originate from Byzantine leaders).

The vulnerability is particularly subtle because `safe_to_vote` provides partial protection by requiring `qc_round >= tc.highest_hqc_round`, but this is insufficient when validators have heterogeneous state due to network asynchrony. The `preferred_round` check provides an additional per-validator safety guarantee that must be enforced consistently across both proposal creation and voting.

### Citations

**File:** consensus/safety-rules/src/safety_rules.rs (L173-188)
```rust
    fn verify_and_update_preferred_round(
        &mut self,
        quorum_cert: &QuorumCert,
        safety_data: &mut SafetyData,
    ) -> Result<bool, Error> {
        let preferred_round = safety_data.preferred_round;
        let one_chain_round = quorum_cert.certified_block().round();

        if one_chain_round < preferred_round {
            return Err(Error::IncorrectPreferredRound(
                one_chain_round,
                preferred_round,
            ));
        }
        Ok(self.observe_qc(quorum_cert, safety_data))
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L346-370)
```rust
    fn guarded_sign_proposal(
        &mut self,
        block_data: &BlockData,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;
        self.verify_author(block_data.author())?;

        let mut safety_data = self.persistent_storage.safety_data()?;
        self.verify_epoch(block_data.epoch(), &safety_data)?;

        if block_data.round() <= safety_data.last_voted_round {
            return Err(Error::InvalidProposal(format!(
                "Proposed round {} is not higher than last voted round {}",
                block_data.round(),
                safety_data.last_voted_round
            )));
        }

        self.verify_qc(block_data.quorum_cert())?;
        self.verify_and_update_preferred_round(block_data.quorum_cert(), &mut safety_data)?;
        // we don't persist the updated preferred round to save latency (it'd be updated upon voting)

        let signature = self.sign(block_data)?;
        Ok(signature)
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L53-95)
```rust
    pub(crate) fn guarded_construct_and_sign_vote_two_chain(
        &mut self,
        vote_proposal: &VoteProposal,
        timeout_cert: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<Vote, Error> {
        // Exit early if we cannot sign
        self.signer()?;

        let vote_data = self.verify_proposal(vote_proposal)?;
        if let Some(tc) = timeout_cert {
            self.verify_tc(tc)?;
        }
        let proposed_block = vote_proposal.block();
        let mut safety_data = self.persistent_storage.safety_data()?;

        // if already voted on this round, send back the previous vote
        // note: this needs to happen after verifying the epoch as we just check the round here
        if let Some(vote) = safety_data.last_vote.clone() {
            if vote.vote_data().proposed().round() == proposed_block.round() {
                return Ok(vote);
            }
        }

        // Two voting rules
        self.verify_and_update_last_vote_round(
            proposed_block.block_data().round(),
            &mut safety_data,
        )?;
        self.safe_to_vote(proposed_block, timeout_cert)?;

        // Record 1-chain data
        self.observe_qc(proposed_block.quorum_cert(), &mut safety_data);
        // Construct and sign vote
        let author = self.signer()?.author();
        let ledger_info = self.construct_ledger_info_2chain(proposed_block, vote_data.hash())?;
        let signature = self.sign(&ledger_info)?;
        let vote = Vote::new_with_signature(vote_data, author, ledger_info, signature);

        safety_data.last_vote = Some(vote.clone());
        self.persistent_storage.set_safety_data(safety_data)?;

        Ok(vote)
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L147-166)
```rust
    /// Core safety voting rule for 2-chain protocol. Return success if 1 or 2 is true
    /// 1. block.round == block.qc.round + 1
    /// 2. block.round == tc.round + 1 && block.qc.round >= tc.highest_hqc.round
    fn safe_to_vote(
        &self,
        block: &Block,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<(), Error> {
        let round = block.round();
        let qc_round = block.quorum_cert().certified_block().round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        let hqc_round = maybe_tc.map_or(0, |tc| tc.highest_hqc_round());
        if round == next_round(qc_round)?
            || (round == next_round(tc_round)? && qc_round >= hqc_round)
        {
            Ok(())
        } else {
            Err(Error::NotSafeToVote(round, qc_round, tc_round, hqc_round))
        }
    }
```

**File:** consensus/consensus-types/src/safety_data.rs (L8-21)
```rust
/// Data structure for safety rules to ensure consensus safety.
#[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```
