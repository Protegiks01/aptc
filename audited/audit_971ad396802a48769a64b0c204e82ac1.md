# Audit Report

## Title
Incomplete Credential Masking in Node Configuration Logging Exposes Vault Authentication Tokens

## Summary
The `log_config_and_build_information()` function in `logger.rs` only masks PostgreSQL URI passwords but fails to mask other sensitive credentials such as Vault authentication tokens when logging the complete node configuration. This allows Vault tokens configured via `Token::FromConfig` to be leaked in plaintext logs, potentially exposing access to the validator's secure storage containing consensus private keys.

## Finding Description

The logging function at [1](#0-0)  performs selective credential masking that only targets the `postgres_uri` password field. When the entire `NodeConfig` is logged using the Debug trait at line 101, all other credentials remain unmasked.

The critical vulnerability path is as follows:

1. The `NodeConfig` structure contains a `ConsensusConfig` which includes a `SafetyRulesConfig` [2](#0-1) 

2. This `SafetyRulesConfig` has a `backend: SecureBackend` field that can be configured as `Vault(VaultConfig)` [3](#0-2) 

3. The `VaultConfig` contains a `token: Token` field that authenticates access to HashiCorp Vault

4. The `Token` enum supports two variants: `FromDisk(PathBuf)` and `FromConfig(String)` [4](#0-3) 

5. All these structures derive the `Debug` trait without custom implementations that mask sensitive fields [5](#0-4) 

When an operator configures Vault authentication using `Token::FromConfig("secret_vault_token")` instead of the recommended `Token::FromDisk(path)`, the token string will be printed in plaintext when the config is logged.

**Attack Scenario:**
- Validator operator configures Vault with `token: { from_config: "hvs.CAESIJ..." }` 
- Node starts and logs configuration at INFO level
- Logs are collected by centralized logging (ELK, Splunk, CloudWatch, etc.)
- Attacker gains access to logs through compromised logging infrastructure, misconfigured permissions, or insider access
- Attacker extracts Vault token from logs
- Attacker uses token to authenticate to Vault and retrieve consensus private keys
- Attacker can now sign blocks as the compromised validator, enabling equivocation attacks

## Impact Explanation

This vulnerability falls under **Medium Severity** per the Aptos bug bounty program criteria for the following reasons:

1. **Information Disclosure with Severe Consequences**: While the primary issue is information leakage, the leaked Vault tokens provide access to the validator's secure storage backend containing consensus private keys, network identity keys, and other critical cryptographic material.

2. **Potential for Validator Compromise**: With access to consensus keys, an attacker could:
   - Sign conflicting blocks (equivocation)
   - Participate in consensus as the compromised validator
   - Potentially violate consensus safety if coordinated with other compromised validators
   - This maps to "Limited funds loss or manipulation" and "State inconsistencies requiring intervention" under Medium severity.

3. **Scope**: While not affecting all validators automatically, any validator using the `from_config` token configuration pattern is vulnerable to credential exposure through log access.

The impact is more severe than "Low Severity" (minor information leaks) because compromising a validator's consensus keys can lead to consensus attacks and network instability.

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability requires two conditions:

1. **Operator Misconfiguration**: The operator must configure Vault tokens using `from_config` instead of `from_disk`. While example configurations use `from_disk` [6](#0-5) , the code fully supports `from_config` and some operators may use it for convenience or due to misunderstanding.

2. **Log Access**: An attacker must gain access to the node's logs through:
   - Compromised centralized logging infrastructure (common in production environments)
   - Misconfigured log permissions or storage
   - Insider threat with legitimate log access
   - Cloud provider compromise or misconfiguration
   - Logs inadvertently stored in insecure locations or sent to third-party services

Both conditions are realistic in production environments. Operators may choose `from_config` for testing or convenience, and log access through various attack vectors is a well-documented threat in modern infrastructure.

## Recommendation

Implement comprehensive credential masking for all sensitive fields in the configuration before logging. This should include:

1. **Add custom Debug implementations** for types containing credentials to mask sensitive fields:

```rust
// In config/src/config/secure_backend_config.rs
impl Debug for Token {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        match self {
            Token::FromDisk(path) => f.debug_tuple("FromDisk").field(path).finish(),
            Token::FromConfig(_) => f.debug_tuple("FromConfig").field(&"***MASKED***").finish(),
        }
    }
}

impl Debug for VaultConfig {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        f.debug_struct("VaultConfig")
            .field("server", &self.server)
            .field("namespace", &self.namespace)
            .field("token", &"***MASKED***")
            .field("ca_certificate", &self.ca_certificate)
            .field("renew_ttl_secs", &self.renew_ttl_secs)
            .field("disable_cas", &self.disable_cas)
            .field("connection_timeout_ms", &self.connection_timeout_ms)
            .field("response_timeout_ms", &self.response_timeout_ms)
            .finish()
    }
}
```

2. **Document security best practices** clearly stating that `from_disk` should always be used for production Vault tokens, never `from_config`.

3. **Add runtime warnings** when `from_config` is used for sensitive credentials in production environments.

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[test]
fn test_vault_token_leakage_in_logs() {
    use aptos_config::config::{NodeConfig, ConsensusConfig, SafetyRulesConfig};
    use aptos_config::config::secure_backend_config::{SecureBackend, VaultConfig, Token};
    use std::path::PathBuf;

    // Create a node config with Vault token in config (vulnerable pattern)
    let mut node_config = NodeConfig::default();
    node_config.consensus = ConsensusConfig {
        safety_rules: SafetyRulesConfig {
            backend: SecureBackend::Vault(VaultConfig {
                server: "https://vault.example.com:8200".to_string(),
                token: Token::FromConfig("hvs.CAESIJ_SECRET_TOKEN_12345".to_string()),
                namespace: Some("validator".to_string()),
                ca_certificate: None,
                renew_ttl_secs: None,
                disable_cas: None,
                connection_timeout_ms: None,
                response_timeout_ms: None,
            }),
            ..Default::default()
        },
        ..Default::default()
    };

    // Simulate what happens in logger.rs line 101
    let debug_output = format!("{:?}", node_config);
    
    // Verify that the token is leaked
    assert!(debug_output.contains("hvs.CAESIJ_SECRET_TOKEN_12345"),
            "Vault token should be visible in debug output, demonstrating the vulnerability");
    
    // This token would be logged and potentially accessible to attackers
    println!("Leaked token in logs: {}", debug_output);
}
```

**Notes**

The postgres_uri password masking at lines 94-95 correctly handles special characters and empty passwords by completely replacing the password component with "*". The `url::Url::set_password()` method properly handles all password values regardless of content. However, this masking is **insufficient** as it only covers one specific credential type.

The broader issue is that the configuration logging assumes only database passwords need masking, while modern validator configurations contain multiple credential types (Vault tokens, API keys, authentication tokens) that also require protection. The vulnerability exists because all configuration structures derive `Debug` without implementing custom formatters to mask sensitive fields.

The `IndexerConfig` demonstrates the same password-masking pattern [7](#0-6)  but this is also limited to postgres_uri passwords only.

While the example configurations promote the secure `from_disk` pattern, the code must be defensive against misconfigurations since it explicitly supports the `from_config` variant as a valid deserializable option.

### Citations

**File:** aptos-node/src/logger.rs (L67-102)
```rust
fn log_config_and_build_information(node_config: &NodeConfig) {
    // Log the build information
    info!("Build information:");
    let build_info = build_information!();
    for (key, value) in build_info {
        info!("{}: {}", key, value);
    }

    // Log the feature information. Note: this should be kept up-to-date
    // with the features defined in the aptos-node Cargo.toml file.
    info!("Feature information:");
    log_feature_info!(
        "assert-private-keys-not-cloneable",
        "check-vm-features",
        "consensus-only-perf-test",
        "default",
        "failpoints",
        "indexer",
        "tokio-console"
    );

    // Log the node config
    let mut config = node_config;
    let mut masked_config;
    if let Some(u) = &node_config.indexer.postgres_uri {
        let mut parsed_url = url::Url::parse(u).expect("Invalid postgres uri");
        if parsed_url.password().is_some() {
            masked_config = node_config.clone();
            parsed_url.set_password(Some("*")).unwrap();
            masked_config.indexer.postgres_uri = Some(parsed_url.to_string());
            config = &masked_config;
        }
    }

    info!("Loaded node config: {:?}", config);
}
```

**File:** config/src/config/safety_rules_config.rs (L23-34)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct SafetyRulesConfig {
    pub backend: SecureBackend,
    pub logger: LoggerConfig,
    pub service: SafetyRulesService,
    pub test: Option<SafetyRulesTestConfig>,
    // Read/Write/Connect networking operation timeout in milliseconds.
    pub network_timeout_ms: u64,
    pub enable_cached_safety_data: bool,
    pub initial_safety_rules_config: InitialSafetyRulesConfig,
}
```

**File:** config/src/config/secure_backend_config.rs (L51-74)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(deny_unknown_fields)]
pub struct VaultConfig {
    /// Optional SSL Certificate for the vault host, this is expected to be a full path.
    pub ca_certificate: Option<PathBuf>,
    /// A namespace is an optional portion of the path to a key stored within Vault. For example,
    /// a secret, S, without a namespace would be available in secret/data/S, with a namespace, N, it
    /// would be in secret/data/N/S.
    pub namespace: Option<String>,
    /// Vault leverages leases on many tokens, specify this to automatically have your lease
    /// renewed up to that many seconds more. If this is not specified, the lease will not
    /// automatically be renewed.
    pub renew_ttl_secs: Option<u32>,
    /// Vault's URL, note: only HTTP is currently supported.
    pub server: String,
    /// The authorization token for accessing secrets
    pub token: Token,
    /// Disable check-and-set when writing secrets to Vault
    pub disable_cas: Option<bool>,
    /// Timeout for new vault socket connections, in milliseconds.
    pub connection_timeout_ms: Option<u64>,
    /// Timeout for generic vault operations (e.g., reads and writes), in milliseconds.
    pub response_timeout_ms: Option<u64>,
}
```

**File:** config/src/config/secure_backend_config.rs (L100-106)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(rename_all = "snake_case")]
pub enum Token {
    FromConfig(String),
    /// This is an absolute path and not relative to data_dir
    FromDisk(PathBuf),
}
```

**File:** config/src/config/test_data/validator.yaml (L9-10)
```yaml
            token:
                from_disk: "/full/path/to/token"
```

**File:** config/src/config/indexer_config.rs (L92-117)
```rust
impl Debug for IndexerConfig {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        let postgres_uri = self.postgres_uri.as_ref().map(|u| {
            let mut parsed_url = url::Url::parse(u).expect("Invalid postgres uri");
            if parsed_url.password().is_some() {
                parsed_url.set_password(Some("*")).unwrap();
            }
            parsed_url.to_string()
        });
        f.debug_struct("IndexerConfig")
            .field("enabled", &self.enabled)
            .field("postgres_uri", &postgres_uri)
            .field("processor", &self.processor)
            .field("starting_version", &self.starting_version)
            .field("skip_migrations", &self.skip_migrations)
            .field("check_chain_id", &self.check_chain_id)
            .field("batch_size", &self.batch_size)
            .field("fetch_tasks", &self.fetch_tasks)
            .field("processor_tasks", &self.processor_tasks)
            .field("emit_every", &self.emit_every)
            .field("gap_lookback_versions", &self.gap_lookback_versions)
            .field("ans_contract_address", &self.ans_contract_address)
            .field("nft_points_contract", &self.nft_points_contract)
            .finish()
    }
}
```
