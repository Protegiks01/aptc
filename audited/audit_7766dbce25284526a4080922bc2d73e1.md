# Audit Report

## Title
Governance Proposal Signer Address Parameter Allows Framework Reserved Address Compromise via Arbitrary Signer Capability Access

## Summary
The `aptos_governance::resolve()` function accepts an arbitrary `signer_address` parameter without validation, allowing governance proposals to obtain signers for any framework-reserved address (@0x1 through @0xa) instead of only @0x1. This enables attackers to publish malicious modules at framework-reserved addresses that are marked as "trusted" by the Move VM, bypassing critical security checks. [1](#0-0) [2](#0-1) 

## Finding Description

The vulnerability exists in the governance proposal resolution mechanism. The code generator in `utils.rs` hardcodes `AccountAddress::ONE` (@0x1) when generating governance proposal scripts, suggesting the intent is to restrict signer access to only the main framework address. However, this hardcoding is merely a convenience tool and not an actual security control. [2](#0-1) 

The `resolve()` function does not validate which address is requested - it simply calls `get_signer(signer_address)` with the provided parameter. During genesis, signer capabilities for ALL framework-reserved addresses (@0x1 through @0xa) are stored in `GovernanceResponsbility`: [3](#0-2) 

The formal verification specification confirms no address validation exists - it only checks that the requested address has a signer capability stored: [4](#0-3) 

**Attack Vector:**

1. Attacker creates a custom governance proposal script that calls `aptos_governance::resolve(proposal_id, @0x2)` (or any address @0x2-@0xa) instead of @0x1
2. Gets the proposal voted through via legitimate governance process or stake accumulation
3. Upon execution, obtains a valid signer for the alternate framework address
4. Publishes malicious modules at that address using the obtained signer

**Critical Impact - VM Trusted Status:**

Modules published at framework-reserved addresses (0x0-0xf) are marked as "trusted" by the Move VM: [5](#0-4) [6](#0-5) 

The module publishing validation only checks that the sender address matches the module's self-address, which will pass when using the compromised signer: [7](#0-6) 

## Impact Explanation

**Critical Severity** - This vulnerability allows:

1. **Access Control Bypass**: Circumvents the intended restriction to only use @0x1 for governance proposals
2. **Trusted Code Injection**: Malicious modules published at framework-reserved addresses (@0x2-@0xa) receive "trusted" status in the VM, granting them relaxed security checks including stack size validation
3. **Framework Address Compromise**: Any future code that validates `is_framework_reserved_address()` instead of specifically checking for @0x1 would accept signers for compromised addresses as legitimate framework signers
4. **Module Publishing at Reserved Addresses**: Attackers can deploy arbitrary code at addresses reserved for the Aptos framework, potentially impersonating framework functionality

This breaks the critical invariant: "Access Control: System addresses (@aptos_framework, @core_resources) must be protected" and enables potential consensus violations if malicious trusted modules interfere with core protocol operations.

## Likelihood Explanation

**Medium-High Likelihood:**

**Requirements:**
- Attacker must create and submit a governance proposal with malicious script
- Proposal must achieve sufficient voting threshold to pass (requires either: significant stake accumulation, social engineering of validators, or compromised validator accounts)
- Proposal must not be detected during the voting period

**Feasibility:**
- Technical execution is straightforward - creating a custom proposal script is trivial
- The main barrier is passing the governance vote, which requires either stake majority or validator compromise
- Once executed, the attack succeeds deterministically
- No special privileges beyond governance participation are required

## Recommendation

Add explicit validation in the `resolve()` and `resolve_multi_step_proposal()` functions to enforce that only @0x1 (aptos_framework) can be requested:

```move
public fun resolve(
    proposal_id: u64,
    signer_address: address
): signer acquires ApprovedExecutionHashes, GovernanceResponsbility {
    // Add validation to enforce only @0x1 can be resolved
    assert!(
        signer_address == @aptos_framework,
        error::invalid_argument(EINVALID_SIGNER_ADDRESS)
    );
    
    voting::resolve<GovernanceProposal>(@aptos_framework, proposal_id);
    remove_approved_hash(proposal_id);
    get_signer(signer_address)
}

public fun resolve_multi_step_proposal(
    proposal_id: u64,
    signer_address: address,
    next_execution_hash: vector<u8>
): signer acquires GovernanceResponsbility, ApprovedExecutionHashes {
    // Add same validation
    assert!(
        signer_address == @aptos_framework,
        error::invalid_argument(EINVALID_SIGNER_ADDRESS)
    );
    
    voting::resolve_proposal_v2<GovernanceProposal>(@aptos_framework, proposal_id, next_execution_hash);
    // ... rest of function
}
```

Alternatively, if multiple framework addresses are legitimately needed for governance, implement a whitelist mechanism with explicit documentation of which addresses can be requested and why.

## Proof of Concept

```move
#[test_only]
module aptos_framework::governance_address_exploit_test {
    use aptos_framework::aptos_governance;
    use aptos_framework::code;
    use std::signer;
    
    // Malicious governance proposal script that exploits the vulnerability
    script {
        fun exploit_proposal(proposal_id: u64) {
            // Instead of resolving to @0x1 as intended, resolve to @0x2
            let framework_signer_2 = aptos_governance::resolve(proposal_id, @0x2);
            
            // Verify we obtained a signer for @0x2, not @0x1
            assert!(signer::address_of(&framework_signer_2) == @0x2, 1);
            
            // Now we can publish malicious modules at @0x2
            // These modules will be marked as "trusted" by the VM
            // Example: code::publish_package_txn(&framework_signer_2, metadata, code);
        }
    }
    
    #[test(aptos_framework = @aptos_framework, proposer = @0x123)]
    fun test_alternate_address_resolution(
        aptos_framework: signer,
        proposer: signer,
    ) {
        // Setup: Initialize governance and create a proposal
        // When the proposal executes with the script above,
        // it will successfully obtain a signer for @0x2
        // demonstrating the vulnerability
    }
}
```

## Notes

The vulnerability demonstrates that code generation utilities (`utils.rs`) cannot serve as security controls. The hardcoding of `@0x1` in the Rust generator does not prevent attackers from creating custom governance proposal scripts with different addresses. Security enforcement must occur in the Move contract itself through explicit validation of the `signer_address` parameter in the `resolve()` function.

### Citations

**File:** aptos-move/aptos-release-builder/src/utils.rs (L30-34)
```rust
        emitln!(
            writer,
            "let framework_signer = aptos_governance::resolve(proposal_id, @{});\n",
            AccountAddress::ONE,
        );
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L634-641)
```text
    public fun resolve(
        proposal_id: u64,
        signer_address: address
    ): signer acquires ApprovedExecutionHashes, GovernanceResponsbility {
        voting::resolve<GovernanceProposal>(@aptos_framework, proposal_id);
        remove_approved_hash(proposal_id);
        get_signer(signer_address)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/genesis.move (L101-106)
```text
        let framework_reserved_addresses = vector<address>[@0x2, @0x3, @0x4, @0x5, @0x6, @0x7, @0x8, @0x9, @0xa];
        while (!vector::is_empty(&framework_reserved_addresses)) {
            let address = vector::pop_back<address>(&mut framework_reserved_addresses);
            let (_, framework_signer_cap) = account::create_framework_reserved_account(address);
            aptos_governance::store_signer_cap(&aptos_framework_account, address, framework_signer_cap);
        };
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.spec.move (L723-729)
```text
    spec schema GetSignerAbortsIf {
        signer_address: address;

        aborts_if !exists<GovernanceResponsbility>(@aptos_framework);
        let cap_map = global<GovernanceResponsbility>(@aptos_framework).signer_caps;
        aborts_if !simple_map::spec_contains_key(cap_map, signer_address);
    }
```

**File:** third_party/move/move-vm/runtime/src/loader/function.rs (L644-645)
```rust
        // For now, just framework code considered trusted, but this could be expanded.
        let is_trusted = module.address().is_special();
```

**File:** third_party/move/move-core/types/src/account_address.rs (L120-122)
```rust
    pub fn is_special(&self) -> bool {
        self.0[..Self::LENGTH - 1].iter().all(|x| *x == 0) && self.0[Self::LENGTH - 1] < 0b10000
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L156-171)
```rust
            // Make sure all modules' addresses match the sender. The self address is
            // where the module will actually be published. If we did not check this,
            // the sender could publish a module under anyone's account.
            if addr != sender {
                let msg = format!(
                    "Compiled modules address {} does not match the sender {}",
                    addr, sender
                );
                return Err(verification_error(
                    StatusCode::MODULE_ADDRESS_DOES_NOT_MATCH_SENDER,
                    IndexKind::AddressIdentifier,
                    compiled_module.self_handle_idx().0,
                )
                .with_message(msg)
                .finish(Location::Undefined));
            }
```
