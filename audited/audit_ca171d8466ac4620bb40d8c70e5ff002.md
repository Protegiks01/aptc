# Audit Report

## Title
Inconsistent Snapshot Lookup Logic Causes Restore Operation Failures

## Summary
The backup restore coordinator incorrectly uses `select_state_snapshot()` (which uses `<= version` comparison) but then asserts that the returned snapshot has an exact version match. This logic error causes restore operations to fail when resuming from in-progress snapshots that don't have exact version matches in the backup metadata.

## Finding Description

The vulnerability exists in the snapshot lookup logic within the restore coordinator. There are two methods for finding state snapshots:

1. **`select_state_snapshot(target_version)`** [1](#0-0)  - Returns the **latest** snapshot where `version <= target_version`

2. **`expect_state_snapshot(version)`** [2](#0-1)  - Returns a snapshot where `version == version` (exact match only)

The critical flaw occurs in the restore coordinator where code calls `select_state_snapshot()` but then asserts the result has an exact version match:

**First vulnerable location:** [3](#0-2) 

**Second vulnerable location:** [4](#0-3) 

**Attack Scenario:**
1. Available snapshots exist at versions: [100, 200, 300]
2. A node begins restoring from a snapshot at version 250 and stores this in-progress state in its database metadata
3. The node crashes mid-restore and attempts to resume
4. The code retrieves the in-progress version (250) and calls `select_state_snapshot(250)`
5. `select_state_snapshot()` returns the snapshot at version 200 (the latest where `version <= 250`)
6. The assertion `snapshot.version == 250` fails
7. The restore operation crashes with error: "cannot find in-progress state snapshot 250"

This breaks the fundamental invariant that **backup restore operations should be resumable** after interruption.

## Impact Explanation

This is a **Medium severity** vulnerability per Aptos bug bounty criteria because it causes "State inconsistencies requiring intervention":

1. **Availability Impact**: Nodes cannot recover from backups when in-progress snapshot versions don't have exact matches, requiring manual intervention
2. **Operational Impact**: Failed restore operations prevent nodes from syncing from backup storage, degrading network resilience
3. **Recovery Impact**: In disaster recovery scenarios where backups are critical, this bug prevents successful restoration

While this doesn't directly enable fund theft or consensus violations, it significantly impacts the reliability of the backup/restore infrastructure, which is critical for node operators and network availability.

## Likelihood Explanation

This vulnerability has **HIGH likelihood** of occurrence because:

1. **Natural Occurrence**: This isn't an exploit that requires attacker action - it happens naturally during normal operations
2. **Timing-Dependent**: Any node crash or interruption during restore operations can trigger this bug
3. **Metadata Mismatch**: The bug occurs whenever database metadata references a snapshot version that doesn't exist exactly in backup storage
4. **Resume Scenarios**: Most production deployments will eventually need to resume interrupted restore operations

The bug is triggered automatically when operational conditions align - no attacker involvement needed.

## Recommendation

The code should either:

**Option 1** (Preferred): Use `expect_state_snapshot()` for exact version lookups when an exact match is required:

```rust
// Instead of:
let snapshot = metadata_view.select_state_snapshot(ver)?;
ensure!(
    snapshot.is_some() && snapshot.as_ref().unwrap().version == ver,
    "cannot find in-progress state snapshot {}",
    ver
);

// Use:
let snapshot = metadata_view.expect_state_snapshot(ver)?;
```

**Option 2**: Don't assert exact version match when using `select_state_snapshot()`, and handle the case where a lower version is returned:

```rust
let snapshot = metadata_view.select_state_snapshot(ver)?
    .ok_or_else(|| anyhow!("No state snapshot found at or before version {}", ver))?;

// Update the in-progress version to the actual snapshot version
let actual_version = snapshot.version;
// ... continue with actual_version instead of ver
```

The same fix should be applied to both vulnerable locations in `restore.rs`.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    
    #[test]
    fn test_inconsistent_snapshot_lookup() {
        // Create a MetadataView with snapshots at versions 100, 200, 300
        let snapshots = vec![
            StateSnapshotBackupMeta {
                epoch: 1,
                version: 100,
                manifest: FileHandle::new("snapshot_100"),
            },
            StateSnapshotBackupMeta {
                epoch: 2,
                version: 200,
                manifest: FileHandle::new("snapshot_200"),
            },
            StateSnapshotBackupMeta {
                epoch: 3,
                version: 300,
                manifest: FileHandle::new("snapshot_300"),
            },
        ];
        
        let metadata_view = MetadataView {
            epoch_ending_backups: vec![],
            state_snapshot_backups: snapshots,
            transaction_backups: vec![],
            _identity: None,
            compaction_timestamps: None,
        };
        
        // Try to find snapshot at version 250 (doesn't exist exactly)
        let selected = metadata_view.select_state_snapshot(250).unwrap();
        assert!(selected.is_some());
        assert_eq!(selected.unwrap().version, 200); // Returns version 200
        
        // Try expect_state_snapshot at version 250
        let expected = metadata_view.expect_state_snapshot(250);
        assert!(expected.is_err()); // Fails - no exact match
        
        // This demonstrates the inconsistency:
        // select_state_snapshot(250) succeeds and returns version 200
        // but code that asserts snapshot.version == 250 will fail
        
        // Simulate the vulnerable code pattern:
        let snapshot = metadata_view.select_state_snapshot(250).unwrap();
        if let Some(s) = snapshot {
            // This assertion will fail!
            assert_eq!(s.version, 250, "cannot find in-progress state snapshot 250");
        }
    }
}
```

**Notes:**
- The bug also appears in [5](#0-4)  where `expect_state_snapshot()` is correctly used for exact matches, showing the intended pattern
- This vulnerability specifically affects backup restore reliability, not core consensus or execution logic
- The fix is straightforward: consistently use `expect_state_snapshot()` when exact version matches are required

### Citations

**File:** storage/backup/backup-cli/src/metadata/view.rs (L111-122)
```rust
    pub fn select_state_snapshot(
        &self,
        target_version: Version,
    ) -> Result<Option<StateSnapshotBackupMeta>> {
        Ok(self
            .state_snapshot_backups
            .iter()
            .sorted()
            .rev()
            .find(|m| m.version <= target_version)
            .cloned())
    }
```

**File:** storage/backup/backup-cli/src/metadata/view.rs (L124-130)
```rust
    pub fn expect_state_snapshot(&self, version: Version) -> Result<StateSnapshotBackupMeta> {
        self.state_snapshot_backups
            .iter()
            .find(|m| m.version == version)
            .cloned()
            .ok_or_else(|| anyhow!("State snapshot not found at version {}", version))
    }
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L163-168)
```rust
                    let snapshot = metadata_view.select_state_snapshot(ver)?;
                    ensure!(
                        snapshot.is_some() && snapshot.as_ref().unwrap().version == ver,
                        "cannot find in-progress state snapshot {}",
                        ver
                    );
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L184-190)
```rust
            let snapshot = metadata_view.select_state_snapshot(latest_tree_version)?;

            ensure!(
                snapshot.is_some() && snapshot.as_ref().unwrap().version == latest_tree_version,
                "cannot find tree snapshot {}",
                latest_tree_version
            );
```

**File:** storage/backup/backup-cli/src/coordinators/replay_verify.rs (L129-129)
```rust
                Some(metadata_view.expect_state_snapshot(version)?),
```
