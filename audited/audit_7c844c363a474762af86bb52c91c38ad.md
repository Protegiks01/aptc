# Audit Report

## Title
Consensus Observer Denial of Service via Unvalidated Epoch/Round Parameters in Future Epoch Commit Decisions

## Summary
The `get_ordered_block()` function and related consensus observer code paths fail to validate epoch and round parameters for overflow or maximum values. An unprivileged network attacker can send a malicious `CommitDecision` message with extreme epoch/round values (near `u64::MAX`) that bypasses signature verification when treated as a "future epoch" commit, triggering state sync and clearing the ordered blocks store via incorrect BTreeMap split operations.

## Finding Description

The vulnerability exists in the consensus observer's commit decision processing flow. The core issue is that `get_ordered_block()` at line 67 [1](#0-0)  accepts epoch and round parameters without any validation for extreme values.

More critically, when a `CommitDecision` arrives with an epoch that doesn't match the current epoch, signature verification is conditionally skipped [2](#0-1) , and the message is processed as a "future epoch" commit that triggers state synchronization [3](#0-2) .

**Attack Flow:**

1. Attacker crafts a `CommitDecision` with extreme values (e.g., `epoch = u64::MAX`, `round = u64::MAX - 1`) and sends it over the network
2. The message is deserialized successfully (BCS accepts any valid u64 values)
3. At the commit decision processing handler, since `commit_epoch (u64::MAX) != epoch_state.epoch`, the signature verification check is SKIPPED
4. The code proceeds to handle it as a future epoch commit, calling `update_blocks_for_state_sync_commit` [4](#0-3) 
5. This invokes `remove_blocks_for_commit` [5](#0-4) 
6. In `remove_blocks_for_commit`, the split_off round is calculated as `round.saturating_add(1)`, which for `u64::MAX - 1` yields `u64::MAX` [6](#0-5) 
7. The BTreeMap split_off operation with key `(u64::MAX, u64::MAX)` removes ALL blocks with keys less than this maximum value [7](#0-6) 
8. Result: The `ordered_blocks` BTreeMap is essentially cleared, disrupting the consensus observer's ability to track and process blocks

The root cause is the lack of validation that epoch/round values are within reasonable bounds before using them in state management operations, combined with conditional signature verification that can be bypassed for "future epoch" messages.

## Impact Explanation

**Severity: Medium** (up to $10,000 per Aptos bug bounty criteria)

This vulnerability causes **state inconsistencies requiring intervention**:

- **Affected Components**: All consensus observer nodes in the network
- **Denial of Service**: Clearing the ordered blocks store disrupts the observer's core functionality of tracking consensus progress
- **State Corruption**: The observer loses track of pending blocks and must reinitialize
- **Availability Impact**: Observers cannot properly track consensus until they restart or resync
- **No Fund Loss**: This doesn't directly steal or lock funds, but degrades network observability

While this doesn't directly violate consensus safety (validators are unaffected), it breaks the state consistency invariant for observer nodes and requires manual intervention to recover.

## Likelihood Explanation

**Likelihood: HIGH**

- **Attack Complexity**: LOW - attacker only needs to send a single malformed network message
- **Attacker Prerequisites**: NONE - any network peer can send consensus observer messages
- **Detection Difficulty**: The attack leaves obvious traces (extreme epoch/round values in logs), but may not be noticed immediately
- **Exploit Reliability**: Very high - the code path is deterministic and doesn't require race conditions
- **Network Accessibility**: Consensus observer protocol is exposed to any connected peer

The attack is trivial to execute: craft a BCS-encoded `CommitDecision` with `epoch = u64::MAX` and `round = u64::MAX - 1`, and send it to any consensus observer node.

## Recommendation

Add validation for epoch and round parameters to ensure they are within reasonable bounds before processing:

```rust
// In consensus_observer.rs, process_commit_decision_message function
fn process_commit_decision_message(..., commit_decision: CommitDecision) {
    let commit_epoch = commit_decision.epoch();
    let commit_round = commit_decision.round();
    
    // ADD THIS VALIDATION
    const MAX_REASONABLE_EPOCH_DELTA: u64 = 100;
    const MAX_REASONABLE_ROUND: u64 = u64::MAX / 2; // Prevent saturation issues
    
    let epoch_state = self.get_epoch_state();
    
    // Reject commits with extreme epoch values
    if commit_epoch > epoch_state.epoch + MAX_REASONABLE_EPOCH_DELTA {
        error!("Rejecting commit with unreasonably high epoch: {}", commit_epoch);
        return;
    }
    
    // Reject commits with extreme round values
    if commit_round > MAX_REASONABLE_ROUND {
        error!("Rejecting commit with unreasonably high round: {}", commit_round);
        return;
    }
    
    // existing validation continues...
}
```

Additionally, always verify commit decisions before processing them, even for future epochs:

```rust
// Verify ALL commit decisions, not just current epoch
if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
    error!("Failed to verify commit decision: {:?}", error);
    return;
}
```

## Proof of Concept

```rust
// PoC: Sending malicious commit decision to consensus observer
use aptos_types::{
    ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
    block_info::BlockInfo,
    aggregate_signature::AggregateSignature,
};
use aptos_crypto::HashValue;

// Create malicious commit decision with extreme values
let malicious_block_info = BlockInfo::new(
    u64::MAX,           // epoch = u64::MAX
    u64::MAX - 1,       // round = u64::MAX - 1
    HashValue::random(),
    HashValue::random(),
    0,
    0,
    None,
);

let malicious_ledger_info = LedgerInfo::new(
    malicious_block_info,
    HashValue::random(),
);

// No valid signatures needed - verification will be skipped!
let malicious_commit_proof = LedgerInfoWithSignatures::new(
    malicious_ledger_info,
    AggregateSignature::empty(), // Empty/invalid signatures
);

let malicious_commit_decision = CommitDecision::new(malicious_commit_proof);

// Send to consensus observer - it will process without verification
// and clear the ordered_blocks BTreeMap via remove_blocks_for_commit
// Result: Consensus observer DoS
```

**Attack Steps:**
1. Construct `CommitDecision` with `epoch = u64::MAX`, `round = u64::MAX - 1`
2. Send via network to any consensus observer node
3. Observer processes it as "future epoch", skips signature verification
4. `remove_blocks_for_commit` clears the entire ordered blocks store
5. Observer is unable to process subsequent blocks until restart

### Citations

**File:** consensus/src/consensus_observer/observer/ordered_blocks.rs (L67-71)
```rust
    pub fn get_ordered_block(&self, epoch: u64, round: Round) -> Option<OrderedBlock> {
        self.ordered_blocks
            .get(&(epoch, round))
            .map(|(observed_ordered_block, _)| observed_ordered_block.ordered_block().clone())
    }
```

**File:** consensus/src/consensus_observer/observer/ordered_blocks.rs (L115-115)
```rust
        let split_off_round = commit_ledger_info.commit_info().round().saturating_add(1);
```

**File:** consensus/src/consensus_observer/observer/ordered_blocks.rs (L118-120)
```rust
        self.ordered_blocks = self
            .ordered_blocks
            .split_off(&(split_off_epoch, split_off_round));
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L468-482)
```rust
        if commit_epoch == epoch_state.epoch {
            // Verify the commit decision
            if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify commit decision! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                        commit_decision.proof_block_info(),
                        peer_network_id,
                        error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
                return;
            }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L502-527)
```rust
        let last_block = self.observer_block_data.lock().get_last_ordered_block();
        let epoch_changed = commit_epoch > last_block.epoch();
        if epoch_changed || commit_round > last_block.round() {
            // If we're waiting for state sync to transition into a new epoch,
            // we should just wait and not issue a new state sync request.
            if self.state_sync_manager.is_syncing_through_epoch() {
                info!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Already waiting for state sync to reach new epoch: {:?}. Dropping commit decision: {:?}!",
                        self.observer_block_data.lock().root().commit_info(),
                        commit_decision.proof_block_info()
                    ))
                );
                return;
            }

            // Otherwise, we should start the state sync process for the commit.
            // Update the block data (to the commit decision).
            self.observer_block_data
                .lock()
                .update_blocks_for_state_sync_commit(&commit_decision);

            // Start state syncing to the commit decision
            self.state_sync_manager
                .sync_to_commit(commit_decision, epoch_changed);
        }
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L289-290)
```rust
        self.ordered_block_store
            .remove_blocks_for_commit(commit_proof);
```
