# Audit Report

## Title
Asymmetric Peer Scoring Allows Malicious Peers to Maintain Good Reputation While Conducting Subtle State Sync Attacks

## Summary
The state sync peer scoring system uses an asymmetric scoring mechanism where successful responses add a fixed value (+1.0) while errors multiply the score by a factor (×0.95 or ×0.8). This asymmetry allows malicious peers to maintain scores above the ignore threshold (25.0) by strategically mixing valid and invalid responses, enabling subtle attacks that degrade state synchronization performance without triggering peer banning.

## Finding Description

The vulnerability exists in the peer reputation scoring system used by the Aptos Data Client for state synchronization. The scoring logic has a critical asymmetry: [1](#0-0) 

Peers start at score 50.0, and the system updates scores as follows:

**For successful responses:** [2](#0-1) 

**For errors:** [3](#0-2) 

Error types are classified as: [4](#0-3) 

The critical flaw is that **successes use addition** while **errors use multiplication**. Mathematical analysis reveals:

**For NotUseful errors (×0.95):**
To maintain equilibrium at score S, a peer needs k successes per error where:
k = S(1-0.95)/0.95 ≈ 0.0526×S

At score 25.0: k ≈ 1.3 successes per error → **43% error rate**
At score 30.0: k ≈ 1.6 successes per error → **38% error rate**
At score 50.0: k ≈ 2.6 successes per error → **27% error rate**

**For Malicious errors (×0.8):**
k = S(1-0.8)/0.8 = 0.25×S

At score 25.0: k ≈ 6.25 successes per error → **14% error rate**
At score 30.0: k ≈ 7.5 successes per error → **12% error rate**  
At score 50.0: k ≈ 12.5 successes per error → **7% error rate**

Network and RPC errors are classified as NotUseful: [5](#0-4) 

This allows a malicious peer to:
1. Send 40% timeout/invalid data responses while maintaining score >25.0
2. Send 13% invalid proof responses while maintaining score >25.0
3. Waste computational resources on proof verification
4. Significantly slow down state synchronization without detection

The peer is only ignored when the score drops to or below 25.0: [6](#0-5) 

## Impact Explanation

**Medium Severity** - This vulnerability allows malicious peers to conduct sustained subtle attacks on state synchronization:

1. **State Sync Degradation**: Peers can deliberately slow down state sync by sending timeouts 40% of the time, never getting banned
2. **Resource Exhaustion**: Invalid proofs waste validator CPU/memory on verification, sent 13% of the time without banning
3. **No Consecutive Error Tracking**: Unlike the health checker system, there's no mechanism to detect rapid bursts of errors
4. **Network-Wide Impact**: Multiple colluding malicious peers can severely degrade the network's state sync performance

This fits the bug bounty's Medium Severity category: "State inconsistencies requiring intervention" and "Validator node slowdowns."

## Likelihood Explanation

**High Likelihood** - This vulnerability is:

1. **Easy to Exploit**: Attacker just needs to run a storage service peer and control response patterns
2. **No Special Access Required**: Any peer can participate in state sync
3. **Hard to Detect**: The attack appears as normal network issues (timeouts, occasional bad data)
4. **Persistent**: Peer maintains reputation indefinitely with the right response ratio
5. **No Defense Mechanism**: System lacks consecutive error detection or rate-limiting

The mathematical thresholds are fixed and predictable, making exploitation straightforward.

## Recommendation

Implement multiple defenses:

**1. Track Consecutive Errors:**
```rust
pub struct PeerState {
    // ... existing fields ...
    consecutive_errors: u64,
    max_consecutive_errors: u64, // e.g., 5
}

fn update_score_error(&mut self, error: ErrorType) {
    self.consecutive_errors += 1;
    
    // Immediate ban on consecutive errors
    if self.consecutive_errors >= self.max_consecutive_errors {
        self.score = MIN_SCORE;
        return;
    }
    
    // Existing multiplicative scoring
    let multiplier = match error {
        ErrorType::NotUseful => NOT_USEFUL_MULTIPLIER,
        ErrorType::Malicious => MALICIOUS_MULTIPLIER,
    };
    self.score = f64::max(self.score * multiplier, MIN_SCORE);
}

fn update_score_success(&mut self) {
    self.consecutive_errors = 0; // Reset on success
    self.score = f64::min(self.score + SUCCESSFUL_RESPONSE_DELTA, MAX_SCORE);
}
```

**2. Use Multiplicative Penalty for Both Success and Failure:**
Change success to also use multiplication to maintain symmetry:
```rust
const SUCCESS_MULTIPLIER: f64 = 1.02; // 2% increase per success
const MALICIOUS_MULTIPLIER: f64 = 0.80; // 20% decrease per error
const NOT_USEFUL_MULTIPLIER: f64 = 0.90; // 10% decrease per error
```

**3. Implement Time-Based Reputation Decay:**
Prevent peers from building up reputation and then exploiting it:
```rust
fn decay_score_over_time(&mut self, time_elapsed: Duration) {
    let decay_rate = 0.01; // 1% per hour
    let hours = time_elapsed.as_secs_f64() / 3600.0;
    self.score *= (1.0 - decay_rate).powf(hours);
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    
    #[test]
    fn test_malicious_peer_maintains_reputation() {
        let config = Arc::new(AptosDataClientConfig {
            ignore_low_score_peers: true,
            ..Default::default()
        });
        
        let mut peer_state = PeerState::new(config);
        
        // Initial score
        assert_eq!(peer_state.get_score(), 50.0);
        
        // Simulate alternating pattern: 2 successes, 1 NotUseful error
        // This should maintain score around 48-51
        for round in 0..100 {
            // 2 successes
            peer_state.update_score_success();
            peer_state.update_score_success();
            
            // 1 NotUseful error
            peer_state.update_score_error(ErrorType::NotUseful);
            
            println!("Round {}: Score = {}", round, peer_state.get_score());
        }
        
        // After 100 rounds (200 successes, 100 errors = 33% error rate)
        // Peer should still be above ignore threshold
        assert!(peer_state.get_score() > IGNORE_PEER_THRESHOLD);
        assert!(!peer_state.is_ignored());
        
        println!("Final score after 33% error rate: {}", peer_state.get_score());
        println!("Peer ignored? {}", peer_state.is_ignored());
    }
    
    #[test]
    fn test_malicious_peer_invalid_proofs() {
        let config = Arc::new(AptosDataClientConfig {
            ignore_low_score_peers: true,
            ..Default::default()
        });
        
        let mut peer_state = PeerState::new(config);
        
        // Simulate pattern: 10 successes, 1 Malicious error
        // This should maintain score around 45-55
        for round in 0..50 {
            // 10 successes
            for _ in 0..10 {
                peer_state.update_score_success();
            }
            
            // 1 Malicious error (invalid proof)
            peer_state.update_score_error(ErrorType::Malicious);
            
            println!("Round {}: Score = {}", round, peer_state.get_score());
        }
        
        // After 50 rounds (500 successes, 50 malicious errors = 9% error rate)
        // Peer should still be above ignore threshold
        assert!(peer_state.get_score() > IGNORE_PEER_THRESHOLD);
        assert!(!peer_state.is_ignored());
        
        println!("Final score after 9% malicious error rate: {}", peer_state.get_score());
        println!("Peer ignored? {}", peer_state.is_ignored());
    }
}
```

**Notes**

This vulnerability demonstrates a fundamental flaw in the peer reputation system design. While the peer monitoring service (referenced in the security question) lacks reputation scoring entirely and only logs warnings after consecutive failures [7](#0-6) , the actual reputation system used for state synchronization has this exploitable asymmetry.

The issue is particularly concerning because the state sync system is critical for network health - it's how nodes catch up to the current state. Malicious peers exploiting this can significantly degrade network performance without ever being detected or banned. The lack of consecutive error tracking means there's no "circuit breaker" to immediately stop obviously malicious behavior.

### Citations

**File:** state-sync/aptos-data-client/src/peer_states.rs (L32-43)
```rust
/// Scores for peer rankings based on preferences and behavior.
const MAX_SCORE: f64 = 100.0;
const MIN_SCORE: f64 = 0.0;
const STARTING_SCORE: f64 = 50.0;
/// Add this score on a successful response.
const SUCCESSFUL_RESPONSE_DELTA: f64 = 1.0;
/// Not necessarily a malicious response, but not super useful.
const NOT_USEFUL_MULTIPLIER: f64 = 0.95;
/// Likely to be a malicious response.
const MALICIOUS_MULTIPLIER: f64 = 0.8;
/// Ignore a peer when their score dips below this threshold.
const IGNORE_PEER_THRESHOLD: f64 = 25.0;
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L45-62)
```rust
pub enum ErrorType {
    /// A response or error that's not actively malicious but also doesn't help
    /// us make progress, e.g., timeouts, remote errors, invalid data, etc...
    NotUseful,
    /// A response or error that appears to be actively hindering progress or
    /// attempting to deceive us, e.g., invalid proof.
    Malicious,
}

impl From<ResponseError> for ErrorType {
    fn from(error: ResponseError) -> Self {
        match error {
            ResponseError::InvalidData | ResponseError::InvalidPayloadDataType => {
                ErrorType::NotUseful
            },
            ResponseError::ProofVerificationError => ErrorType::Malicious,
        }
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L152-160)
```rust
    fn is_ignored(&self) -> bool {
        // Only ignore peers if the config allows it
        if !self.data_client_config.ignore_low_score_peers {
            return false;
        }

        // Otherwise, ignore peers with a low score
        self.score <= IGNORE_PEER_THRESHOLD
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L163-165)
```rust
    fn update_score_success(&mut self) {
        self.score = f64::min(self.score + SUCCESSFUL_RESPONSE_DELTA, MAX_SCORE);
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L168-174)
```rust
    fn update_score_error(&mut self, error: ErrorType) {
        let multiplier = match error {
            ErrorType::NotUseful => NOT_USEFUL_MULTIPLIER,
            ErrorType::Malicious => MALICIOUS_MULTIPLIER,
        };
        self.score = f64::max(self.score * multiplier, MIN_SCORE);
    }
```

**File:** state-sync/aptos-data-client/src/client.rs (L865-866)
```rust
                self.notify_bad_response(id, peer, &request, ErrorType::NotUseful);
                Err(client_error)
```

**File:** peer-monitoring-service/client/src/peer_states/latency_info.rs (L60-72)
```rust
    fn handle_request_failure(&self, peer_network_id: &PeerNetworkId) {
        // Update the number of ping failures for the request tracker
        self.request_tracker.write().record_response_failure();

        // TODO: If the number of ping failures is too high, disconnect from the node
        let num_consecutive_failures = self.request_tracker.read().get_num_consecutive_failures();
        if num_consecutive_failures >= self.latency_monitoring_config.max_latency_ping_failures {
            warn!(LogSchema::new(LogEntry::LatencyPing)
                .event(LogEvent::TooManyPingFailures)
                .peer(peer_network_id)
                .message("Too many ping failures occurred for the peer!"));
        }
    }
```
