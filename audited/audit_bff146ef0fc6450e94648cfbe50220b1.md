# Audit Report

## Title
Missing Translation Detection Allows Silent Backward Compatibility Breakage in V2 Event System

## Summary
The TranslatedV1EventSchema system lacks detection mechanisms to identify when V2 events should have translated V1 entries but don't. Translation failures are silently ignored, causing API clients expecting V1 events to receive untranslated V2 events with dummy values, breaking backward compatibility without detection or alerting.

## Finding Description

The Aptos blockchain's event system supports both V1 events (with EventKey and sequence numbers) and V2 events (module events). To maintain backward compatibility, V2 events should be translated to V1 format and stored in `TranslatedV1EventSchema`.

**Critical Flow Analysis:**

When a V2 event is processed during transaction indexing: [1](#0-0) 

The translation process calls `translate_event_v2_to_v1`, which has two silent failure modes: [2](#0-1) 

**Problem 1: No translator exists for event type** - Returns `Ok(None)` at line 582, silently skipping translation with no indication this is abnormal.

**Problem 2: Translation fails** - Logs a warning at lines 572-576, then returns `Ok(None)` at line 578, allowing processing to continue without the translation being stored.

When V2 events are not translated, they are NOT indexed in `EventByKeySchema`, making them invisible to event key queries. However, they still exist in the main event database.

**Impact on API Clients:**

When retrieving events through transactions, the system attempts translation: [3](#0-2) 

If translation doesn't exist (line 1030), it silently fails with `if let Ok(...)` and leaves the V2 event untranslated. The V2 event is then converted to API format with dummy values: [4](#0-3) [5](#0-4) 

**The Security Guarantee Broken:**

The system promises backward compatibility - V2 events should be transparently translated to V1 format for existing API clients. This is violated when translations silently fail.

**No Detection Mechanism:**

The validation system explicitly ignores V2 events: [6](#0-5) 

At line 308, V2 events are skipped with `_ => continue`, meaning there's no validation that translations exist for V2 events with registered translators.

**Metrics:**

Only timing metrics exist, no counters for translation failures: [7](#0-6) 

## Impact Explanation

**Medium Severity** - State inconsistencies requiring intervention:

1. **API Backward Compatibility Breakage**: Clients expecting V1 events receive V2 events with dummy GUID (0x0 address, creation_number 0) and sequence_number 0, breaking client logic that relies on these fields for tracking/deduplication.

2. **Silent Data Inconsistency**: Some V2 events are translated, others aren't, with no way for operators or clients to detect which events failed translation.

3. **Query Failures**: Event queries by EventKey fail with `NotFound` errors when encountering untranslated V2 events: [8](#0-7) 

4. **No Recovery Path**: Once translations are missed, there's no mechanism to detect and re-process them.

5. **Operational Blindness**: No metrics/alerts exist to notify operators of systematic translation failures.

This meets Medium severity criteria as it causes state inconsistencies (some events translated, others not) that require manual intervention to detect and remediate.

## Likelihood Explanation

**High Likelihood** - This will occur in production:

1. **Resource-dependent translations**: Many translators query on-chain resources. If resources are deleted/burned before translation occurs, translation fails: [9](#0-8) 

2. **Race conditions**: Between event emission and translation, the required on-chain state may change.

3. **Expected failures**: The code explicitly handles "expected" failures (MINT_TYPE/BURN_TYPE with ConcurrentSupply), indicating this is a known occurrence.

4. **No safeguards**: System continues processing despite translation failures, ensuring the issue propagates to API clients.

## Recommendation

Implement a comprehensive translation validation and detection system:

```rust
// In storage/indexer/src/db_indexer.rs

// 1. Add metrics for translation tracking
pub static TRANSLATION_FAILURES: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "aptos_event_v2_translation_failures",
        "Count of V2 event translation failures by event type",
        &["event_type", "reason"]
    ).unwrap()
});

pub static TRANSLATION_MISSING: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "aptos_event_v2_translation_missing",
        "V2 events without translators",
        &["event_type"]
    ).unwrap()
});

// 2. Modified translate_event_v2_to_v1 with detection
pub fn translate_event_v2_to_v1(
    &self,
    v2: &ContractEventV2,
) -> Result<Option<ContractEventV1>> {
    if let Some(translator) = self.event_v2_translation_engine.translators.get(v2.type_tag()) {
        let result = translator.translate_event_v2_to_v1(v2, &self.event_v2_translation_engine);
        match result {
            Ok(v1) => Ok(Some(v1)),
            Err(e) => {
                let event_type = v2.type_tag().to_string();
                TRANSLATION_FAILURES.with_label_values(&[&event_type, "translation_failed"]).inc();
                
                let is_ignored_error = (v2.type_tag() == &*MINT_TYPE || v2.type_tag() == &*BURN_TYPE)
                    && e.to_string().contains("resource not found");
                
                if !is_ignored_error {
                    error!("V2 event translation failed: {:?}. Error: {}", v2, e);
                }
                Ok(None)
            },
        }
    } else {
        // Track events without translators
        TRANSLATION_MISSING.with_label_values(&[&v2.type_tag().to_string()]).inc();
        Ok(None)
    }
}

// 3. Add validation in db_debugger/validation.rs to check V2 translations
fn verify_v2_event_translations(
    transaction_list: &TransactionListWithProofV2,
    internal_indexer_db: &DB,
    start_version: u64,
    translators: &HashMap<TypeTag, Box<dyn EventV2Translator>>,
) -> Result<()> {
    let mut version = start_version;
    if let Some(event_vec) = &transaction_list.get_transaction_list_with_proof().events {
        for events in event_vec {
            for (idx, event) in events.iter().enumerate() {
                if let ContractEvent::V2(v2) = event {
                    // If translator exists, translation should exist
                    if translators.contains_key(v2.type_tag()) {
                        match internal_indexer_db.get::<TranslatedV1EventSchema>(&(version, idx as u64))? {
                            None => {
                                warn!("Missing translation for V2 event at version {}, index {}, type {:?}",
                                      version, idx, v2.type_tag());
                            },
                            Some(_) => {}, // Translation exists, OK
                        }
                    }
                }
            }
            version += 1;
        }
    }
    Ok(())
}

// 4. Add alert thresholds in monitoring config
// Alert if translation_failures > 100/hour or translation_missing rate increases
```

## Proof of Concept

```rust
// Demonstrating the vulnerability - translation failure leads to dummy values

#[test]
fn test_missing_translation_breaks_backward_compatibility() {
    // Setup: Create a V2 event type with a registered translator
    // that will fail due to missing resource
    
    let mut harness = TestHarness::new();
    
    // 1. Emit a V2 CoinDeposit event
    // 2. Delete the CoinStore resource before translation occurs
    // 3. Translation fails, returns Ok(None)
    // 4. Event is not stored in TranslatedV1EventSchema
    
    // When client queries transaction:
    let txn = harness.get_transaction_by_version(version);
    
    // Events contain V2 event instead of translated V1
    assert!(matches!(txn.events[0], ContractEvent::V2(_)));
    
    // When converted to API response:
    let versioned_event = convert_to_versioned_event(&txn.events[0]);
    
    // Client receives dummy values breaking backward compatibility
    assert_eq!(versioned_event.guid.creation_number, 0);
    assert_eq!(versioned_event.guid.account_address, AccountAddress::ZERO);
    assert_eq!(versioned_event.sequence_number, 0);
    
    // Expected: Real GUID and sequence number from translated V1 event
    // Actual: Dummy values, client logic breaks
    
    // Additionally, querying by EventKey fails:
    let result = harness.get_events_by_event_key(&expected_key, 0, 10);
    // Returns NotFound because event wasn't indexed
    assert!(result.is_err());
}
```

## Notes

This vulnerability represents a **systemic architectural flaw** in the V2-to-V1 event translation system:

1. **Silent failures are design bugs**: The system's approach of returning `Ok(None)` on translation failures violates the principle of explicit error handling for critical compatibility features.

2. **Missing observability**: The lack of metrics and validation for a backward-compatibility critical system indicates insufficient operational monitoring.

3. **No recovery mechanism**: Once translations are missed, they're permanently lost unless the entire indexer is rebuilt.

4. **Client impact**: Downstream clients have no way to detect they're receiving untranslated V2 events with dummy values instead of properly translated V1 events, leading to silent data corruption in client applications.

**Recommended Priority**: This should be treated as **Medium severity** requiring prompt remediation, as it affects API reliability and data consistency for the broader Aptos ecosystem.

### Citations

**File:** storage/indexer/src/db_indexer.rs (L294-302)
```rust
    pub fn get_translated_v1_event_by_version_and_index(
        &self,
        version: Version,
        index: u64,
    ) -> Result<ContractEventV1> {
        self.db
            .get::<TranslatedV1EventSchema>(&(version, index))?
            .ok_or_else(|| AptosDbError::NotFound(format!("Event {} of Txn {}", index, version)))
    }
```

**File:** storage/indexer/src/db_indexer.rs (L448-484)
```rust
                    if self.indexer_db.event_v2_translation_enabled() {
                        if let ContractEvent::V2(v2) = event {
                            if let Some(translated_v1_event) =
                                self.translate_event_v2_to_v1(v2).map_err(|e| {
                                    anyhow::anyhow!(
                                        "Failed to translate event: {:?}. Error: {}",
                                        v2,
                                        e
                                    )
                                })?
                            {
                                let key = *translated_v1_event.key();
                                let sequence_number = translated_v1_event.sequence_number();
                                self.event_v2_translation_engine
                                    .cache_sequence_number(&key, sequence_number);
                                event_keys.insert(key);
                                batch
                                    .put::<EventByKeySchema>(
                                        &(key, sequence_number),
                                        &(version, idx as u64),
                                    )
                                    .expect("Failed to put events by key to a batch");
                                batch
                                    .put::<EventByVersionSchema>(
                                        &(key, version, sequence_number),
                                        &(idx as u64),
                                    )
                                    .expect("Failed to put events by version to a batch");
                                batch
                                    .put::<TranslatedV1EventSchema>(
                                        &(version, idx as u64),
                                        &translated_v1_event,
                                    )
                                    .expect("Failed to put translated v1 events to a batch");
                            }
                        }
                    }
```

**File:** storage/indexer/src/db_indexer.rs (L552-584)
```rust
    pub fn translate_event_v2_to_v1(
        &self,
        v2: &ContractEventV2,
    ) -> Result<Option<ContractEventV1>> {
        let _timer = TIMER.timer_with(&["translate_event_v2_to_v1"]);
        if let Some(translator) = self
            .event_v2_translation_engine
            .translators
            .get(v2.type_tag())
        {
            let result = translator.translate_event_v2_to_v1(v2, &self.event_v2_translation_engine);
            match result {
                Ok(v1) => Ok(Some(v1)),
                Err(e) => {
                    // If the token object collection uses ConcurrentSupply, skip the translation and ignore the error.
                    // This is expected, as the event handle won't be found in either FixedSupply or UnlimitedSupply.
                    let is_ignored_error = (v2.type_tag() == &*MINT_TYPE
                        || v2.type_tag() == &*BURN_TYPE)
                        && e.to_string().contains("resource not found");
                    if !is_ignored_error {
                        warn!(
                            "Failed to translate event: {:?}. Error: {}",
                            v2,
                            e.to_string()
                        );
                    }
                    Ok(None)
                },
            }
        } else {
            Ok(None)
        }
    }
```

**File:** api/src/context.rs (L1020-1036)
```rust
    fn translate_v2_to_v1_events_for_version(
        &self,
        version: u64,
        events: &mut [ContractEvent],
    ) -> Result<()> {
        for (idx, event) in events.iter_mut().enumerate() {
            let translated_event = self
                .indexer_reader
                .as_ref()
                .ok_or(anyhow!("Internal indexer reader doesn't exist"))?
                .get_translated_v1_event_by_version_and_index(version, idx as u64);
            if let Ok(translated_event) = translated_event {
                *event = ContractEvent::V1(translated_event);
            }
        }
        Ok(())
    }
```

**File:** api/types/src/transaction.rs (L48-52)
```rust
static DUMMY_GUID: Lazy<EventGuid> = Lazy::new(|| EventGuid {
    creation_number: U64::from(0u64),
    account_address: Address::from(AccountAddress::ZERO),
});
static DUMMY_SEQUENCE_NUMBER: Lazy<U64> = Lazy::new(|| U64::from(0));
```

**File:** api/types/src/transaction.rs (L911-930)
```rust
impl From<(&EventWithVersion, serde_json::Value)> for VersionedEvent {
    fn from((event, data): (&EventWithVersion, serde_json::Value)) -> Self {
        match &event.event {
            ContractEvent::V1(v1) => Self {
                version: event.transaction_version.into(),
                guid: (*v1.key()).into(),
                sequence_number: v1.sequence_number().into(),
                typ: v1.type_tag().into(),
                data,
            },
            ContractEvent::V2(v2) => Self {
                version: event.transaction_version.into(),
                guid: *DUMMY_GUID,
                sequence_number: *DUMMY_SEQUENCE_NUMBER,
                typ: v2.type_tag().into(),
                data,
            },
        }
    }
}
```

**File:** storage/aptosdb/src/db_debugger/validation.rs (L276-316)
```rust
fn verify_events(
    transaction_list: &TransactionListWithProofV2,
    internal_indexer_db: &DB,
    start_version: u64,
) -> Result<()> {
    let mut version = start_version;
    match &transaction_list.get_transaction_list_with_proof().events {
        None => {
            return Ok(());
        },
        Some(event_vec) => {
            for events in event_vec {
                for (idx, event) in events.iter().enumerate() {
                    match event {
                        ContractEvent::V1(event) => {
                            let seq_num = event.sequence_number();
                            let event_key = event.key();
                            verify_event_by_version(
                                event_key,
                                seq_num,
                                internal_indexer_db,
                                version,
                                idx,
                            )?;
                            verify_event_by_key(
                                event_key,
                                seq_num,
                                internal_indexer_db,
                                idx,
                                version,
                            )?;
                        },
                        _ => continue,
                    }
                }
                version += 1;
            }
        },
    }
    Ok(())
}
```

**File:** storage/indexer/src/metrics.rs (L1-15)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use aptos_metrics_core::{exponential_buckets, register_histogram_vec, HistogramVec};
use once_cell::sync::Lazy;

pub static TIMER: Lazy<HistogramVec> = Lazy::new(|| {
    register_histogram_vec!(
        "aptos_internal_indexer_timer_seconds",
        "Various timers for performance analysis.",
        &["name"],
        exponential_buckets(/*start=*/ 1e-9, /*factor=*/ 2.0, /*count=*/ 32).unwrap(),
    )
    .unwrap()
});
```

**File:** storage/indexer/src/event_v2_translator.rs (L430-468)
```rust
struct TokenMutationTranslator;
impl EventV2Translator for TokenMutationTranslator {
    fn translate_event_v2_to_v1(
        &self,
        v2: &ContractEventV2,
        engine: &EventV2TranslationEngine,
    ) -> Result<ContractEventV1> {
        let token_mutation = TokenMutation::try_from_bytes(v2.event_data())?;
        let struct_tag_str = "0x4::token::Token".to_string();
        let struct_tag = StructTag::from_str(&struct_tag_str)?;
        let (key, sequence_number) = if let Some(state_value_bytes) = engine
            .get_state_value_bytes_for_object_group_resource(
                token_mutation.token_address(),
                &struct_tag,
            )? {
            let token_resource: TokenResource = bcs::from_bytes(&state_value_bytes)?;
            let key = *token_resource.mutation_events().key();
            let sequence_number =
                engine.get_next_sequence_number(&key, token_resource.mutation_events().count())?;
            (key, sequence_number)
        } else {
            // If the token resource is not found, we skip the event translation to avoid panic
            // because the creation number cannot be decided. The token may have been burned.
            return Err(AptosDbError::from(anyhow::format_err!(
                "Token resource not found"
            )));
        };
        let token_mutation_event = TokenMutationEvent::new(
            token_mutation.mutated_field_name().clone(),
            token_mutation.old_value().clone(),
            token_mutation.new_value().clone(),
        );
        Ok(ContractEventV1::new(
            key,
            sequence_number,
            TOKEN_MUTATION_EVENT_TYPE.clone(),
            bcs::to_bytes(&token_mutation_event)?,
        )?)
    }
```
