# Audit Report

## Title
Premature Peer Success Scoring Allows Malicious Peers to Evade Penalties for Type Mismatch Responses

## Summary
The `send_request_to_peer_and_decode()` function in the Aptos data client awards peer success scores before validating response type correctness. This allows malicious peers to send responses with wrong data types, receiving reduced penalties compared to legitimate failures, enabling them to persist 2-8x longer in the serviceable peer pool.

## Finding Description

The vulnerability exists in the state synchronization peer scoring logic where score updates occur in two separate stages with incorrect ordering.

**Execution Flow:**

When `send_request_to_peer()` receives a valid RPC response, it immediately calls `update_score_success(peer)` which adds +1.0 to the peer's score (capped at 100.0). [1](#0-0) 

The scoring constants are defined as: SUCCESSFUL_RESPONSE_DELTA = 1.0, NOT_USEFUL_MULTIPLIER = 0.95, MALICIOUS_MULTIPLIER = 0.8, STARTING_SCORE = 50.0, and IGNORE_PEER_THRESHOLD = 25.0. [2](#0-1) 

The `update_score_success()` implementation increments the score before any type validation occurs. [3](#0-2) 

Subsequently, in `send_request_to_peer_and_decode()`, the response type is validated via `TryFrom` conversion. When this fails, `notify_bad_response(ResponseError::InvalidPayloadDataType)` is called. [4](#0-3) 

The `InvalidPayloadDataType` error maps to `ErrorType::NotUseful`, which applies a 0.95 multiplier penalty. [5](#0-4) 

The `update_score_error()` implementation multiplies the score (which was already incremented) by the penalty multiplier. [6](#0-5) 

**The Problem:**

A malicious peer sending wrong-type responses receives net score change of: `min(score + 1.0, 100.0) × 0.95` instead of the correct `score × 0.95`. For a peer with score 50:
- Wrong-type response: (50 + 1) × 0.95 = 48.45 (net: -1.55)
- Network timeout: 50 × 0.95 = 47.5 (net: -2.5)
- Proof failure: 50 × 0.8 = 40 (net: -10)

To reach the ignore threshold (25.0) from starting score (50.0) requires approximately 32 wrong-type responses versus 14 network failures or 4 proof failures.

## Impact Explanation

This is a **Medium Severity** vulnerability under the Aptos bug bounty program criteria, specifically a "Limited Protocol Violation."

The peer scoring system is a critical protocol mechanism designed to filter out unreliable peers quickly. This vulnerability subverts that mechanism by allowing malicious peers to persist 2-8x longer than intended when sending type-mismatched responses.

**Impact on State Synchronization:**
- Validators must deserialize and attempt conversion of invalid responses
- Increased retry overhead when fetching state sync data
- Low-quality peers consume disproportionate network and CPU resources
- State synchronization operations experience degraded performance

While this does not directly cause consensus failures or fund loss, it enables sustained disruption of state sync operations, meeting Medium severity criteria for protocol violations.

## Likelihood Explanation

**High Likelihood:**

**Attacker Requirements:**
- Network peer access (no special privileges required)
- Knowledge of storage service protocol (publicly documented)
- Ability to send valid RPC responses with incorrect payload type variants

**Attack Complexity:** 
Low - trivial implementation requiring only returning wrong `DataResponse` enum variant. No cryptographic operations or validator participation required. Attack is easily automatable and sustainable.

**Detection Difficulty:**
The attack appears as routine peer reliability issues rather than obvious malicious activity, making it difficult to distinguish from legitimate network problems.

## Recommendation

Reorder the scoring logic to validate response correctness before awarding success scores. Move the `update_score_success()` call to occur after successful type conversion in `send_request_to_peer_and_decode()` rather than immediately after RPC response receipt in `send_request_to_peer()`.

Alternatively, implement a callback mechanism that allows rolling back the success score increment when subsequent validation fails, or use a two-phase scoring approach where preliminary credit is contingent on final validation.

## Proof of Concept

A complete PoC would require implementing a malicious storage service peer that:
1. Joins the network as a valid peer
2. Responds to `GetTransactionsWithProof` requests with `TransactionOutputsWithProof` responses
3. Demonstrates persistence in the serviceable peer pool for 32+ iterations versus 4-14 for legitimate failure modes

The PoC would verify the mathematical impact by monitoring peer scores through the scoring system and confirming the 2-8x longer persistence time for type-mismatch attacks versus legitimate failures.

### Citations

**File:** state-sync/aptos-data-client/src/client.rs (L753-760)
```rust
            match T::try_from(storage_response) {
                Ok(new_payload) => Ok(Response::new(context, new_payload)),
                // If the variant doesn't match what we're expecting, report the issue
                Err(err) => {
                    context
                        .response_callback
                        .notify_bad_response(ResponseError::InvalidPayloadDataType);
                    Err(err.into())
```

**File:** state-sync/aptos-data-client/src/client.rs (L817-817)
```rust
                self.peer_states.update_score_success(peer);
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L33-43)
```rust
const MAX_SCORE: f64 = 100.0;
const MIN_SCORE: f64 = 0.0;
const STARTING_SCORE: f64 = 50.0;
/// Add this score on a successful response.
const SUCCESSFUL_RESPONSE_DELTA: f64 = 1.0;
/// Not necessarily a malicious response, but not super useful.
const NOT_USEFUL_MULTIPLIER: f64 = 0.95;
/// Likely to be a malicious response.
const MALICIOUS_MULTIPLIER: f64 = 0.8;
/// Ignore a peer when their score dips below this threshold.
const IGNORE_PEER_THRESHOLD: f64 = 25.0;
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L54-62)
```rust
impl From<ResponseError> for ErrorType {
    fn from(error: ResponseError) -> Self {
        match error {
            ResponseError::InvalidData | ResponseError::InvalidPayloadDataType => {
                ErrorType::NotUseful
            },
            ResponseError::ProofVerificationError => ErrorType::Malicious,
        }
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L163-165)
```rust
    fn update_score_success(&mut self) {
        self.score = f64::min(self.score + SUCCESSFUL_RESPONSE_DELTA, MAX_SCORE);
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L167-174)
```rust
    /// Updates the score of the peer according to an error
    fn update_score_error(&mut self, error: ErrorType) {
        let multiplier = match error {
            ErrorType::NotUseful => NOT_USEFUL_MULTIPLIER,
            ErrorType::Malicious => MALICIOUS_MULTIPLIER,
        };
        self.score = f64::max(self.score * multiplier, MIN_SCORE);
    }
```
