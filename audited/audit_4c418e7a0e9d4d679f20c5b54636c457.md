# Audit Report

## Title
Complexity Metering Bypass via Struct Field Signature Undercharging

## Summary
The `meter_struct_defs()` function in `check_complexity.rs` incorrectly meters struct field type signatures by only counting type nodes, omitting identifier length costs for referenced struct names. This allows modules with struct fields containing deeply nested struct types with long identifiers to bypass complexity limits.

## Finding Description

The complexity metering system is designed to prevent excessively complex modules from being published. It charges costs based on type nodes (8 units each) and identifier bytes (1 unit each). [1](#0-0) 

The `signature_token_cost()` function properly calculates complexity for signature tokens by charging for both type nodes AND identifier lengths: [2](#0-1) 

For `Struct` and `StructInstantiation` nodes, it charges for the struct name and module name lengths (lines 67-68).

However, `meter_struct_defs()` uses a different approach for struct field signatures: [3](#0-2) 

Lines 243 and 250 only charge `num_nodes() * COST_PER_TYPE_NODE`, missing the identifier costs that should be included via `signature_token_cost()`.

**Attack Path:**
1. Attacker creates a module with struct definitions containing many fields
2. Each field's type references structs with maximum-length identifiers (255 bytes with `LIMIT_MAX_IDENTIFIER_LENGTH`, or 65,535 bytes in legacy mode)
3. Complexity check undercharges: charges 8 units per field instead of 8 + 255 + 255 = 518 units (or up to 131,078 in legacy mode)
4. Module bypasses complexity limits set at line 1556 of `aptos_vm.rs`: [4](#0-3) 

5. Module gets published despite excessive identifier storage requirements
6. When validators load the module, they experience memory pressure from storing all long identifiers [5](#0-4) 

## Impact Explanation

**Mitigation Status:** A secondary complexity check exists in `module_metadata.rs` that properly validates struct field signatures: [6](#0-5) 

However, this check only runs when the `SAFER_METADATA` feature flag is enabled: [7](#0-6) 

While `SAFER_METADATA` is enabled by default: [8](#0-7) 

It can be disabled via on-chain governance, exposing the vulnerability.

**Impact if SAFER_METADATA is disabled:**
- **High Severity**: Validator node slowdowns from excessive memory consumption and type resolution overhead
- Undercharging factor: up to 98.46% with new identifier limits (510/518), or 99.99% in legacy mode (131,070/131,078)
- Could publish modules exceeding intended complexity limits by orders of magnitude

## Likelihood Explanation

**Current Likelihood: Low** - `SAFER_METADATA` is enabled by default, preventing exploitation.

**Conditional Likelihood: High** - If `SAFER_METADATA` is disabled through governance (possible but unlikely), exploitation becomes trivial for any module publisher.

The primary complexity check should be correct regardless of secondary defenses. This represents a defense-in-depth failure where the primary security mechanism is flawed.

## Recommendation

Modify `meter_struct_defs()` to use `signature_token_cost()` instead of `num_nodes()`:

```rust
fn meter_struct_defs(&self) -> PartialVMResult<()> {
    let struct_defs = self.resolver.struct_defs().ok_or_else(|| {
        PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
            .with_message("Can't get struct defs -- not a module.".to_string())
    })?;

    for sdef in struct_defs {
        match &sdef.field_information {
            StructFieldInformation::Native => continue,
            StructFieldInformation::Declared(fields) => {
                for field in fields {
                    // FIX: Use signature_token_cost instead of num_nodes
                    let cost = self.signature_token_cost(&field.signature.0)?;
                    self.charge(cost)?;
                }
            },
            StructFieldInformation::DeclaredVariants(variants) => {
                for variant in variants {
                    self.meter_identifier(variant.name)?;
                    for field in &variant.fields {
                        // FIX: Use signature_token_cost instead of num_nodes
                        let cost = self.signature_token_cost(&field.signature.0)?;
                        self.charge(cost)?;
                    }
                }
            },
        }
    }
    Ok(())
}
```

This ensures consistency with how other signatures are metered throughout the complexity checker.

## Proof of Concept

```rust
#[test]
fn test_struct_field_complexity_undercharge() {
    use move_binary_format::file_format::*;
    use move_binary_format::check_complexity::check_module_complexity;
    
    // Create a module with a struct containing a field of type Struct
    // with maximum-length identifier (255 bytes)
    let long_name = "A".repeat(255);
    
    let mut module = CompiledModule {
        version: 6,
        self_module_handle_idx: ModuleHandleIndex(0),
        module_handles: vec![ModuleHandle {
            address: AddressIdentifierIndex(0),
            name: IdentifierIndex(0),  // Points to long_name
        }],
        struct_handles: vec![StructHandle {
            module: ModuleHandleIndex(0),
            name: IdentifierIndex(1),  // Points to another long_name
            abilities: AbilitySet::EMPTY,
            type_parameters: vec![],
        }],
        function_handles: vec![],
        field_handles: vec![],
        friend_decls: vec![],
        struct_def_instantiations: vec![],
        function_instantiations: vec![],
        field_instantiations: vec![],
        signatures: SignaturePool(vec![]),
        identifiers: IdentifierPool(vec![
            Identifier::new(long_name.clone()).unwrap(),
            Identifier::new(long_name).unwrap(),
        ]),
        address_identifiers: AddressIdentifierPool(vec![AccountAddress::ZERO]),
        constant_pool: vec![],
        metadata: vec![],
        struct_defs: vec![StructDefinition {
            struct_handle: StructHandleIndex(0),
            field_information: StructFieldInformation::Declared(vec![
                FieldDefinition {
                    name: IdentifierIndex(0),
                    signature: TypeSignature(SignatureToken::Struct(StructHandleIndex(0))),
                }
            ]),
        }],
        function_defs: vec![],
        struct_variant_handles: vec![],
        struct_variant_instantiations: vec![],
        variant_field_handles: vec![],
        variant_field_instantiations: vec![],
    };
    
    // With the bug: charged cost should be much higher but will be just 8
    // Expected: 8 (node) + 255 (module) + 255 (struct) = 518
    // Actual: 8
    let budget = 100;  // Set low budget that should fail with correct metering
    let result = check_module_complexity(&module, budget);
    
    // BUG: This will pass with current implementation but should fail
    assert!(result.is_ok()); // Demonstrates the undercharging bug
}
```

## Notes

This vulnerability demonstrates an inconsistency in the complexity metering implementation where struct field signatures receive different (incorrect) treatment compared to other signatures. While currently mitigated by the `SAFER_METADATA` feature flag, the primary security mechanism remains flawed and should be fixed for defense-in-depth.

### Citations

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L20-21)
```rust
const COST_PER_TYPE_NODE: u64 = 8;
const COST_PER_IDENT_BYTE: u64 = 1;
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L52-77)
```rust
    fn signature_token_cost(&self, tok: &SignatureToken) -> PartialVMResult<u64> {
        use SignatureToken::*;

        let mut cost: u64 = 0;

        for node in tok.preorder_traversal() {
            cost = cost.saturating_add(COST_PER_TYPE_NODE);

            match node {
                Struct(sh_idx) | StructInstantiation(sh_idx, _) => {
                    let sh = safe_get_table(self.resolver.struct_handles(), sh_idx.0)?;
                    let mh = safe_get_table(self.resolver.module_handles(), sh.module.0)?;
                    let struct_name = safe_get_table(self.resolver.identifiers(), sh.name.0)?;
                    let moduel_name = safe_get_table(self.resolver.identifiers(), mh.name.0)?;

                    cost = cost.saturating_add(struct_name.len() as u64 * COST_PER_IDENT_BYTE);
                    cost = cost.saturating_add(moduel_name.len() as u64 * COST_PER_IDENT_BYTE);
                },
                U8 | U16 | U32 | U64 | U128 | U256 | I8 | I16 | I32 | I64 | I128 | I256
                | Signer | Address | Bool | Vector(_) | Function(..) | TypeParameter(_)
                | Reference(_) | MutableReference(_) => (),
            }
        }

        Ok(cost)
    }
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L232-257)
```rust
    fn meter_struct_defs(&self) -> PartialVMResult<()> {
        let struct_defs = self.resolver.struct_defs().ok_or_else(|| {
            PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                .with_message("Can't get struct defs -- not a module.".to_string())
        })?;

        for sdef in struct_defs {
            match &sdef.field_information {
                StructFieldInformation::Native => continue,
                StructFieldInformation::Declared(fields) => {
                    for field in fields {
                        self.charge(field.signature.0.num_nodes() as u64)?;
                    }
                },
                StructFieldInformation::DeclaredVariants(variants) => {
                    for variant in variants {
                        self.meter_identifier(variant.name)?;
                        for field in &variant.fields {
                            self.charge(field.signature.0.num_nodes() as u64)?;
                        }
                    }
                },
            }
        }
        Ok(())
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1554-1559)
```rust
        for (module, blob) in modules.iter().zip(bundle.iter()) {
            // TODO(Gas): Make budget configurable.
            let budget = 2048 + blob.code().len() as u64 * 20;
            move_binary_format::check_complexity::check_module_complexity(module, budget)
                .map_err(|err| err.finish(Location::Undefined))?;
        }
```

**File:** third_party/move/move-binary-format/src/file_format.rs (L3460-3461)
```rust
    /// All identifiers used in this module.
    pub identifiers: IdentifierPool,
```

**File:** types/src/vm/module_metadata.rs (L445-447)
```rust
    if features.is_enabled(FeatureFlag::SAFER_METADATA) {
        check_module_complexity(module)?;
    }
```

**File:** types/src/vm/module_metadata.rs (L579-597)
```rust
    for def in module.struct_defs() {
        match &def.field_information {
            StructFieldInformation::Native => {},
            StructFieldInformation::Declared(fields) => {
                for field in fields {
                    check_ident_complexity(module, &mut meter, field.name)?;
                    check_sigtok_complexity(module, &mut meter, &field.signature.0)?
                }
            },
            StructFieldInformation::DeclaredVariants(variants) => {
                for variant in variants {
                    check_ident_complexity(module, &mut meter, variant.name)?;
                    for field in &variant.fields {
                        check_ident_complexity(module, &mut meter, field.name)?;
                        check_sigtok_complexity(module, &mut meter, &field.signature.0)?
                    }
                }
            },
        }
```

**File:** types/src/on_chain_config/aptos_features.rs (L206-206)
```rust
            FeatureFlag::SAFER_METADATA,
```
