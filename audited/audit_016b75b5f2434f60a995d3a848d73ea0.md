# Audit Report

## Title
Missing Mempool Configuration Validation Allows Node Crash and Complete Transaction Processing Failure via Division-by-Zero and Invalid Parameters

## Summary
The `sanitize()` function in `MempoolConfig` contains no validation logic, allowing multiple critical configuration values to bypass all safety checks. This enables node crashes through division-by-zero panics and permanent transaction processing failures. An operator or attacker with config file access can set `num_sender_buckets=0`, `broadcast_buckets=[]`, `capacity=0`, or `capacity_bytes=0` to cause immediate node failure or complete mempool denial of service.

## Finding Description

The mempool configuration sanitizer is completely unimplemented: [1](#0-0) 

Despite being called during node initialization in the config loading pipeline: [2](#0-1) 

This missing validation allows four distinct attack vectors:

**Vector 1: Division-by-Zero Panic (num_sender_buckets=0)**

The `sender_bucket()` function performs modulo arithmetic without checking for zero: [3](#0-2) 

This function is called during every transaction processing operation: [4](#0-3) 

Setting `num_sender_buckets: 0` in the config causes an immediate panic: "attempt to calculate the remainder with a divisor of zero" when any transaction is processed.

**Vector 2: Initialization Panic (invalid broadcast_buckets)**

During `TransactionStore` initialization, the `MultiBucketTimelineIndex::new()` is called with `.unwrap()`: [5](#0-4) 

The `MultiBucketTimelineIndex::new()` validates that buckets are non-empty and start at 0: [6](#0-5) 

Setting `broadcast_buckets: []` or `broadcast_buckets: [100]` causes the node to panic during startup with "Must not be empty" or "First bucket must start at 0".

**Vector 3 & 4: Permanent Mempool Full (capacity=0 or capacity_bytes=0)**

The `is_full()` check compares current size against configured limits: [7](#0-6) 

Since `size >= 0` is always true when capacity=0, the mempool is permanently full. This is checked during transaction insertion: [8](#0-7) 

With `capacity: 0` or `capacity_bytes: 0`, **every single transaction** is rejected with `MempoolIsFull`, rendering the node completely unable to process any transactions.

**Attack Propagation:**

1. Malicious/misconfigured YAML config is provided with invalid values
2. Config is deserialized via serde (automatic, no validation)
3. `MempoolConfig::sanitize()` is called but returns `Ok(())` without checks
4. Node continues initialization with dangerous values
5. Depending on configuration:
   - **Immediate crash**: Invalid `broadcast_buckets` causes panic in `TransactionStore::new()`
   - **First transaction crash**: `num_sender_buckets=0` causes division-by-zero on first txn
   - **Silent failure**: `capacity=0` causes all transactions to be permanently rejected

## Impact Explanation

**Severity: Critical** 

This vulnerability meets multiple Critical severity criteria from the Aptos bug bounty:

1. **Total loss of liveness/network availability**: A node with these configurations cannot process ANY transactions, resulting in complete loss of function. If multiple validators are affected (e.g., through shared config templates, deployment automation, or deliberate attack), network liveness is compromised.

2. **Non-recoverable network partition**: If sufficient validators deploy malicious configs simultaneously, the network could partition between functioning and non-functioning nodes, potentially requiring manual intervention or hard fork to recover.

3. **Validator node crashes**: The division-by-zero and initialization panics cause immediate process termination, requiring manual restart with fixed configuration.

The vulnerability directly violates the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." With capacity=0, the mempool cannot respect any limits because it cannot accept transactions at all.

Unlike network-level DoS attacks (which are out of scope), this is a **configuration validation bug** in core node software that causes deterministic failure states.

## Likelihood Explanation

**Likelihood: Medium to High**

While this requires configuration file access (limiting direct attacker exploitation), the likelihood is elevated due to:

1. **Operator Error**: Misconfiguration during deployment is common. Setting invalid values during testing/debugging could persist to production.

2. **Shared Config Templates**: Many node operators use shared deployment scripts, Docker images, or Helm charts. A malicious or buggy template could propagate to multiple nodes.

3. **CI/CD Vulnerabilities**: Automated deployment pipelines may allow config injection through environment variables or parameter substitution.

4. **Supply Chain Attacks**: Configuration management systems (Ansible, Terraform) could be compromised to inject malicious values.

5. **The TODO Comment**: The explicit TODO in the code suggests developers KNEW validation was needed but never implemented it, increasing the risk of it being forgotten permanently.

The lack of ANY validation means even accidental typos (e.g., setting `num_sender_buckets: 0` instead of `4`) cause catastrophic failures.

## Recommendation

Implement comprehensive validation in the `sanitize()` function: [1](#0-0) 

**Proposed Fix:**

```rust
impl ConfigSanitizer for MempoolConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let mempool_config = &node_config.mempool;
        let sanitizer_name = Self::get_sanitizer_name();

        // Validate capacity
        if mempool_config.capacity == 0 {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Mempool capacity must be greater than 0".into(),
            ));
        }

        // Validate capacity_bytes
        if mempool_config.capacity_bytes == 0 {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Mempool capacity_bytes must be greater than 0".into(),
            ));
        }

        // Validate capacity_per_user
        if mempool_config.capacity_per_user == 0 {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Mempool capacity_per_user must be greater than 0".into(),
            ));
        }

        // Validate orderless_txn_capacity_per_user
        if mempool_config.orderless_txn_capacity_per_user == 0 {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Mempool orderless_txn_capacity_per_user must be greater than 0".into(),
            ));
        }

        // Validate num_sender_buckets
        if mempool_config.num_sender_buckets == 0 {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Mempool num_sender_buckets must be greater than 0".into(),
            ));
        }

        // Validate broadcast_buckets
        if mempool_config.broadcast_buckets.is_empty() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Mempool broadcast_buckets cannot be empty".into(),
            ));
        }

        if mempool_config.broadcast_buckets[0] != 0 {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Mempool broadcast_buckets must start with 0".into(),
            ));
        }

        // Validate broadcast_buckets are sorted and unique
        for i in 1..mempool_config.broadcast_buckets.len() {
            if mempool_config.broadcast_buckets[i] <= mempool_config.broadcast_buckets[i - 1] {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mempool broadcast_buckets must be strictly increasing".into(),
                ));
            }
        }

        // Validate shared_mempool_max_batch_bytes
        if mempool_config.shared_mempool_max_batch_bytes == 0 {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Mempool shared_mempool_max_batch_bytes must be greater than 0".into(),
            ));
        }

        Ok(())
    }
}
```

## Proof of Concept

**PoC 1: Division-by-Zero Crash**

Create a malicious config file `malicious_config.yaml`:
```yaml
base:
  role: "full_node"
  
mempool:
  capacity: 2000000
  capacity_bytes: 2147483648
  capacity_per_user: 100
  num_sender_buckets: 0  # MALICIOUS VALUE
  broadcast_buckets: [0, 150, 300]
```

Start node with this config:
```bash
cargo run --bin aptos-node -- -f malicious_config.yaml
```

Submit any transaction - the node will panic with:
```
thread 'main' panicked at 'attempt to calculate the remainder with a divisor of zero'
```

**PoC 2: Initialization Crash**

Malicious config with invalid broadcast_buckets:
```yaml
mempool:
  num_sender_buckets: 4
  broadcast_buckets: []  # MALICIOUS VALUE - empty
```

Node crashes during startup:
```
thread 'main' panicked at 'called `Result::unwrap()` on an `Err` value: Must not be empty'
```

**PoC 3: Permanent Transaction Rejection**

Malicious config with zero capacity:
```yaml
mempool:
  capacity: 0  # MALICIOUS VALUE
  capacity_bytes: 2147483648
  num_sender_buckets: 4
  broadcast_buckets: [0, 150, 300]
```

Node starts successfully but ALL transaction submissions return:
```
MempoolStatus { code: MempoolIsFull, message: "Mempool is full. Mempool size: 0, Capacity: 0" }
```

The node becomes a permanent transaction rejection machine, unable to serve its purpose in the network.

---

**Notes:**

This vulnerability is particularly severe because:
1. The sanitize infrastructure EXISTS and is CALLED, but does nothing
2. Multiple critical failure modes can be triggered through simple config changes
3. The failures range from immediate crashes to silent permanent unavailability
4. No runtime warnings or errors indicate the misconfiguration until catastrophic failure
5. The TODO comment shows this was a known gap that was never addressed

### Citations

**File:** config/src/config/mempool_config.rs (L176-184)
```rust
impl ConfigSanitizer for MempoolConfig {
    fn sanitize(
        _node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        Ok(()) // TODO: add reasonable verifications
    }
}
```

**File:** config/src/config/config_sanitizer.rs (L62-62)
```rust
        MempoolConfig::sanitize(node_config, node_type, chain_id)?;
```

**File:** mempool/src/core_mempool/transaction_store.rs (L42-47)
```rust
pub fn sender_bucket(
    address: &AccountAddress,
    num_sender_buckets: MempoolSenderBucket,
) -> MempoolSenderBucket {
    address.as_ref()[address.as_ref().len() - 1] as MempoolSenderBucket % num_sender_buckets
}
```

**File:** mempool/src/core_mempool/transaction_store.rs (L105-111)
```rust
        let mut timeline_index = HashMap::new();
        for sender_bucket in 0..config.num_sender_buckets {
            timeline_index.insert(
                sender_bucket,
                MultiBucketTimelineIndex::new(config.broadcast_buckets.clone()).unwrap(),
            );
        }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L311-317)
```rust
        if self.check_is_full_after_eviction(&txn, account_sequence_number) {
            return MempoolStatus::new(MempoolStatusCode::MempoolIsFull).with_message(format!(
                "Mempool is full. Mempool size: {}, Capacity: {}",
                self.system_ttl_index.size(),
                self.capacity,
            ));
        }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L458-460)
```rust
    fn is_full(&self) -> bool {
        self.system_ttl_index.size() >= self.capacity || self.size_bytes >= self.capacity_bytes
    }
```

**File:** mempool/src/core_mempool/transaction_store.rs (L547-555)
```rust
    fn process_ready_transaction(
        &mut self,
        address: &AccountAddress,
        txn_replay_protector: ReplayProtector,
    ) -> bool {
        if let Some(txns) = self.transactions.get_mut(address) {
            if let Some(txn) = txns.get_mut(&txn_replay_protector) {
                let sender_bucket = sender_bucket(address, self.num_sender_buckets);
                let ready_for_quorum_store = !self.priority_index.contains(txn);
```

**File:** mempool/src/core_mempool/index.rs (L405-413)
```rust
    pub(crate) fn new(bucket_mins: Vec<RankingScore>) -> anyhow::Result<Self> {
        anyhow::ensure!(!bucket_mins.is_empty(), "Must not be empty");
        anyhow::ensure!(bucket_mins[0] == 0, "First bucket must start at 0");

        let mut prev = None;
        let mut timelines = vec![];
        for entry in bucket_mins.clone() {
            if let Some(prev) = prev {
                anyhow::ensure!(prev < entry, "Values must be sorted and not repeat");
```
