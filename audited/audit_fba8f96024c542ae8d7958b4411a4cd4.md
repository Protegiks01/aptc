# Audit Report

## Title
Order Vote Aggregation Failure Due to Execution Timing Race Condition in Decoupled Execution Mode

## Summary
In Aptos's decoupled execution mode (always enabled), validators create order votes using their local execution state, which may differ from the placeholder state used in the original QC. When execution completes at different times across validators, some validators cannot create order votes due to hash mismatches, preventing order certificate formation and causing consensus liveness failures.

## Finding Description

Aptos consensus operates in decoupled execution mode where voting occurs before execution completes. The critical flow is:

1. **Regular Voting Phase**: Validators receive a `VoteProposal` and create votes using placeholder execution state. The `gen_vote_data()` method with `decoupled_execution=true` creates `BlockInfo` with `ACCUMULATOR_PLACEHOLDER_HASH` as the `executed_state_id`. [1](#0-0) 

2. **QC Formation**: When 2f+1 votes are collected, a `QuorumCert` is formed with `certified_block` containing the placeholder hash.

3. **Order Vote Creation**: After QC formation, validators attempt to create order votes by calling `broadcast_order_vote()`, which creates an `OrderVoteProposal` using `block.order_vote_proposal(qc)`. [2](#0-1) 

4. **Critical Race Condition**: The `order_vote_proposal()` method calls `block.block_info()` which retrieves the current `StateComputeResult`: [3](#0-2) [4](#0-3) 

The `compute_result()` returns whatever `StateComputeResult` is currently stored, which could be:
- **Dummy state** with `ACCUMULATOR_PLACEHOLDER_HASH` if execution hasn't completed
- **Real execution result** with actual `root_hash` if execution has completed

5. **Safety Rules Validation Failure**: When creating the order vote, safety rules validates that the `OrderVoteProposal`'s `block_info` matches the QC's `certified_block`: [5](#0-4) 

**If execution has completed**, the validator's `block_info` contains the real `executed_state_id`, which **does NOT match** the QC's `certified_block` (which has placeholder hash). Safety rules **rejects** the order vote proposal with `Error::InvalidOneChainQuorumCertificate`.

6. **Decoupled Execution Always Enabled**: This vulnerability is always active because `decoupled_execution()` is hardcoded to return `true`: [6](#0-5) 

**Attack Scenario**: Due to natural variance in execution speeds across validators:
- Validators with fast execution: Their `block_info()` returns real hash → Cannot create order vote
- Validators with slow execution: Their `block_info()` returns placeholder hash → Can create order vote
- If insufficient validators have slow execution, quorum cannot be reached for order votes
- Order certificate formation fails → Consensus liveness failure

This breaks the **Deterministic Execution** invariant: validators cannot agree on what `BlockInfo` to sign for order votes because their execution completion timing differs.

## Impact Explanation

**HIGH Severity** - This vulnerability causes consensus liveness failures:

1. **Order Certificate Formation Failure**: When validators cannot aggregate enough order votes due to hash mismatches, no order certificate can be formed for blocks.

2. **Consensus Pipeline Stall**: The ordering phase of the consensus pipeline cannot progress, preventing block finalization even though regular QCs were successfully formed.

3. **Network-Wide Impact**: All validators are affected simultaneously when this race condition manifests, as it depends on the execution timing distribution across the validator set.

4. **Unpredictable Occurrence**: The bug manifests based on:
   - Network latency variations
   - Hardware performance differences  
   - Current system load on validator nodes
   - Transaction execution complexity

According to Aptos bug bounty criteria, this qualifies as **High Severity** due to "Significant protocol violations" that impact the ordering mechanism critical to consensus operation.

## Likelihood Explanation

**HIGH Likelihood** - This issue will occur frequently in production:

1. **Always Active**: Decoupled execution is hardcoded to `true` in all environments.

2. **Natural Timing Variance**: Validators naturally have different execution speeds due to:
   - Hardware heterogeneity
   - Network conditions
   - Load variations
   - Geographic distribution

3. **No Synchronization**: There is no mechanism to wait for execution completion before creating order votes. The `broadcast_order_vote()` function directly calls `create_order_vote()` without awaiting execution futures. [7](#0-6) 

4. **Window of Vulnerability**: The race window exists from QC formation until all validators complete execution - typically hundreds of milliseconds to seconds.

## Recommendation

**Fix**: Ensure order votes always use the same execution state that was used for the original QC, regardless of whether local execution has completed.

**Solution 1 - Use QC's certified_block directly**:
```rust
// In pipelined_block.rs
pub fn order_vote_proposal(&self, quorum_cert: Arc<QuorumCert>) -> OrderVoteProposal {
    // Use the certified_block from the QC instead of computing block_info
    OrderVoteProposal::new(
        self.block.clone(), 
        quorum_cert.certified_block().clone(),  // Use QC's BlockInfo
        quorum_cert
    )
}
```

**Solution 2 - Wait for execution before order voting**:
```rust
// In round_manager.rs broadcast_order_vote
async fn broadcast_order_vote(&mut self, vote: &Vote, qc: Arc<QuorumCert>) -> anyhow::Result<()> {
    if let Some(proposed_block) = self.block_store.get_block(vote.vote_data().proposed().id()) {
        // Wait for execution to complete before creating order vote
        let _ = proposed_block.wait_for_compute_result().await?;
        
        let order_vote = self.create_order_vote(proposed_block.clone(), qc.clone()).await?;
        // ... rest of function
    }
}
```

**Recommended approach**: Solution 1 is preferable as it maintains consistency with the QC and doesn't introduce execution waiting delays that could impact performance.

## Proof of Concept

```rust
// Test demonstrating the race condition
#[tokio::test]
async fn test_order_vote_aggregation_race_condition() {
    use aptos_consensus_types::{block::Block, order_vote_proposal::OrderVoteProposal};
    use aptos_crypto::hash::ACCUMULATOR_PLACEHOLDER_HASH;
    use aptos_executor_types::StateComputeResult;
    use aptos_types::block_info::BlockInfo;
    
    // Scenario: Create a QC from votes with placeholder hash
    let block = create_test_block();
    let qc_with_placeholder = create_qc_with_placeholder_hash(&block);
    
    // Simulate two validators:
    
    // Validator A: Execution NOT completed yet
    let pipelined_block_a = PipelinedBlock::new(
        block.clone(),
        vec![],
        StateComputeResult::new_dummy() // Still has placeholder hash
    );
    let order_vote_proposal_a = pipelined_block_a.order_vote_proposal(qc_with_placeholder.clone());
    // This should succeed - both use placeholder hash
    assert_eq!(
        order_vote_proposal_a.block_info().executed_state_id(),
        *ACCUMULATOR_PLACEHOLDER_HASH
    );
    
    // Validator B: Execution COMPLETED with real state
    let pipelined_block_b = PipelinedBlock::new(
        block.clone(),
        vec![],
        StateComputeResult::new_dummy()
    );
    // Simulate execution completing
    let real_state_hash = HashValue::random();
    pipelined_block_b.set_compute_result(
        StateComputeResult::new_dummy_with_root_hash(real_state_hash),
        Duration::from_millis(100)
    );
    
    let order_vote_proposal_b = pipelined_block_b.order_vote_proposal(qc_with_placeholder.clone());
    
    // Validator B's block_info has real hash, NOT placeholder
    assert_ne!(
        order_vote_proposal_b.block_info().executed_state_id(),
        *ACCUMULATOR_PLACEHOLDER_HASH
    );
    assert_eq!(
        order_vote_proposal_b.block_info().executed_state_id(),
        real_state_hash
    );
    
    // Safety rules validation would fail for Validator B:
    // qc.certified_block() (placeholder) != order_vote_proposal_b.block_info() (real hash)
    assert_ne!(
        qc_with_placeholder.certified_block(),
        order_vote_proposal_b.block_info()
    );
    
    // This demonstrates that validators in different execution states
    // cannot both successfully create order votes for the same QC
}
```

## Notes

This vulnerability is particularly insidious because:

1. **Silent Failure**: Validators whose execution completes simply fail to create order votes without obvious errors visible to operators.

2. **Intermittent**: The bug manifests unpredictably based on execution timing, making it difficult to diagnose.

3. **Production Impact**: The hardcoded `decoupled_execution=true` means every Aptos network is vulnerable.

4. **Design vs Implementation Gap**: The decoupled execution design assumes order votes use placeholder state like regular votes, but the implementation reads current execution state which may have been updated.

The root cause is that `block.block_info()` dynamically computes `BlockInfo` from the current `StateComputeResult` rather than preserving the original placeholder state used during voting. Order votes must maintain consistency with the QC they reference, but the current implementation allows divergence based on execution timing.

### Citations

**File:** consensus/consensus-types/src/vote_proposal.rs (L59-69)
```rust
    /// This function returns the vote data with a dummy executed_state_id and version
    fn vote_data_ordering_only(&self) -> VoteData {
        VoteData::new(
            self.block().gen_block_info(
                *ACCUMULATOR_PLACEHOLDER_HASH,
                0,
                self.next_epoch_state().cloned(),
            ),
            self.block().quorum_cert().certified_block().clone(),
        )
    }
```

**File:** consensus/src/round_manager.rs (L1626-1651)
```rust
    async fn create_order_vote(
        &mut self,
        block: Arc<PipelinedBlock>,
        qc: Arc<QuorumCert>,
    ) -> anyhow::Result<OrderVote> {
        let order_vote_proposal = block.order_vote_proposal(qc);
        let order_vote_result = self
            .safety_rules
            .lock()
            .construct_and_sign_order_vote(&order_vote_proposal);
        let order_vote = order_vote_result.context(format!(
            "[RoundManager] SafetyRules Rejected {} for order vote",
            block.block()
        ))?;

        fail_point!("consensus::create_invalid_order_vote", |_| {
            use aptos_crypto::bls12381;
            let faulty_order_vote = OrderVote::new_with_signature(
                order_vote.author(),
                order_vote.ledger_info().clone(),
                bls12381::Signature::dummy_signature(),
            );
            Ok(faulty_order_vote)
        });
        Ok(order_vote)
    }
```

**File:** consensus/src/round_manager.rs (L1653-1662)
```rust
    async fn broadcast_order_vote(
        &mut self,
        vote: &Vote,
        qc: Arc<QuorumCert>,
    ) -> anyhow::Result<()> {
        if let Some(proposed_block) = self.block_store.get_block(vote.vote_data().proposed().id()) {
            // Generate an order vote with ledger_info = proposed_block
            let order_vote = self
                .create_order_vote(proposed_block.clone(), qc.clone())
                .await?;
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L452-459)
```rust
    pub fn block_info(&self) -> BlockInfo {
        let compute_result = self.compute_result();
        self.block().gen_block_info(
            compute_result.root_hash(),
            compute_result.last_version_or_0(),
            compute_result.epoch_state().clone(),
        )
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L471-473)
```rust
    pub fn order_vote_proposal(&self, quorum_cert: Arc<QuorumCert>) -> OrderVoteProposal {
        OrderVoteProposal::new(self.block.clone(), self.block_info(), quorum_cert)
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L87-111)
```rust
    pub(crate) fn verify_order_vote_proposal(
        &mut self,
        order_vote_proposal: &OrderVoteProposal,
    ) -> Result<(), Error> {
        let proposed_block = order_vote_proposal.block();
        let safety_data = self.persistent_storage.safety_data()?;

        self.verify_epoch(proposed_block.epoch(), &safety_data)?;

        let qc = order_vote_proposal.quorum_cert();
        if qc.certified_block() != order_vote_proposal.block_info() {
            return Err(Error::InvalidOneChainQuorumCertificate(
                qc.certified_block().id(),
                order_vote_proposal.block_info().id(),
            ));
        }
        if qc.certified_block().id() != proposed_block.id() {
            return Err(Error::InvalidOneChainQuorumCertificate(
                qc.certified_block().id(),
                proposed_block.id(),
            ));
        }
        self.verify_qc(qc)?;
        Ok(())
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L238-241)
```rust
    /// Decouple execution from consensus or not.
    pub fn decoupled_execution(&self) -> bool {
        true
    }
```
