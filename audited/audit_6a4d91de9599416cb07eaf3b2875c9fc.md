# Audit Report

## Title
Serialization Bomb in Remote Executor Service State Value Responses

## Summary
The `RemoteStateViewService` in the executor service can be exploited to cause excessive memory consumption and CPU usage through a serialization bomb attack. An attacker can create many large state values (up to 1MB each) that, when requested in batches of 200, result in serialization of responses up to 200MB, exceeding the 80MB network message size limit and causing service failures.

## Finding Description

The vulnerability exists in the remote executor service's state value serving mechanism. [1](#0-0) 

The attack flow works as follows:

1. **State Value Creation**: The Aptos blockchain allows individual state values up to 1MB in size, controlled by the `max_bytes_per_write_op` gas parameter. [2](#0-1) 

2. **Batch Size**: The remote state view client batches state key requests in groups of 200. [3](#0-2) 

3. **Unbounded Response Serialization**: When the `RemoteStateViewService` receives a request for 200 keys, it fetches all corresponding state values and serializes them into a single `RemoteKVResponse` using BCS encoding without checking the total size. [4](#0-3) 

4. **Network Limit Exceeded**: The gRPC network service has a maximum message size of 80MB. [5](#0-4) 

**Attack Scenario**: An attacker submits transactions that create 200 or more state values, each close to 1MB in size. When these state values are later accessed during sharded block execution, the coordinator's `RemoteStateViewService` attempts to serialize a response containing all 200 values (approximately 200MB total). This causes:
- Excessive memory allocation during BCS serialization
- Significant CPU time spike (measured by the `kv_resp_ser` metric)
- gRPC send failure due to exceeding the 80MB message size limit
- Repeated failures in sharded execution

The `RemoteKVResponse` structure holds a vector of state key-value pairs without size constraints. [6](#0-5) 

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." The serialization operation is unbounded and can consume arbitrary amounts of memory and CPU time based on the total size of state values in the batch.

## Impact Explanation

This vulnerability qualifies as **High Severity** according to Aptos bug bounty criteria:
- **Validator node slowdowns**: The serialization bomb causes significant performance degradation on coordinator nodes during sharded execution
- **API crashes**: The gRPC service will fail when attempting to send messages exceeding 80MB
- **Significant protocol violations**: Block execution failures in sharded mode can affect consensus progress

The impact includes:
1. **Memory Exhaustion**: Attempting to serialize 200MB+ responses can exhaust available memory
2. **CPU Spike**: BCS serialization of large data structures is CPU-intensive
3. **Service Unavailability**: Repeated failures prevent successful sharded execution
4. **Network Bandwidth Waste**: Even if serialization succeeds, the oversized messages fail at the network layer

## Likelihood Explanation

This vulnerability has **HIGH likelihood** because:

1. **Low Attack Cost**: Creating large state values only requires sufficient gas fees (which an attacker with funds can afford)
2. **Natural Occurrence**: Legitimate applications could inadvertently create many large state values that trigger this issue
3. **No Authentication Barrier**: Any transaction sender can create state values
4. **Direct Trigger Path**: The sharded executor service automatically triggers the vulnerability when executing transactions that read these state values
5. **No Size Validation**: There is no check on the total size of a `RemoteKVResponse` before serialization

The attack requires:
- Funding to pay for transactions creating large state values
- Knowledge of the sharded execution architecture
- Ability to submit transactions that later get executed in sharded mode

## Recommendation

Implement size validation before serializing `RemoteKVResponse` messages:

1. **Add Total Size Limit**: Introduce a maximum total response size (e.g., 50MB) that respects the network message size limit with headroom.

2. **Check Before Serialization**: In `RemoteStateViewService::handle_message`, calculate the total size of all state values before serialization:

```rust
// Calculate total response size
let mut total_size = 0usize;
for (state_key, state_value) in &resp {
    total_size += state_key.size();
    if let Some(value) = state_value {
        total_size += value.size();
    }
    if total_size > MAX_RESPONSE_SIZE {
        // Return error or split into multiple responses
        break;
    }
}
```

3. **Implement Response Chunking**: Split large responses into multiple smaller responses that stay within the network message size limit.

4. **Add Response Size Metric**: Track the size of serialized responses to monitor for abnormal patterns.

5. **Consider Dynamic Batch Sizing**: Instead of a fixed batch size of 200, adjust batch size based on estimated state value sizes to keep total response size bounded.

The fix should be implemented in: [1](#0-0) 

## Proof of Concept

```rust
// Rust test demonstrating the serialization bomb
#[test]
fn test_serialization_bomb() {
    use aptos_types::state_store::state_value::StateValue;
    use aptos_types::state_store::state_key::StateKey;
    use bytes::Bytes;
    
    // Create 200 state values, each 1MB in size
    let num_values = 200;
    let value_size = 1024 * 1024; // 1MB
    let large_data = vec![0u8; value_size];
    
    let mut state_values = Vec::new();
    for i in 0..num_values {
        let key = StateKey::raw(format!("key_{}", i).as_bytes());
        let value = StateValue::new_legacy(Bytes::from(large_data.clone()));
        state_values.push((key, Some(value)));
    }
    
    // Create RemoteKVResponse
    let response = RemoteKVResponse::new(state_values);
    
    // Measure serialization time and size
    let start = std::time::Instant::now();
    let serialized = bcs::to_bytes(&response).unwrap();
    let duration = start.elapsed();
    
    println!("Serialized size: {} MB", serialized.len() / (1024 * 1024));
    println!("Serialization time: {:?}", duration);
    
    // Verify it exceeds the network message size limit
    const MAX_MESSAGE_SIZE: usize = 80 * 1024 * 1024; // 80MB
    assert!(serialized.len() > MAX_MESSAGE_SIZE, 
            "Response size {} exceeds network limit {}", 
            serialized.len(), MAX_MESSAGE_SIZE);
}
```

This test demonstrates that 200 state values of 1MB each produce a serialized response of approximately 200MB, which exceeds the 80MB network message size limit and would cause the gRPC send to fail.

## Notes

The vulnerability is specific to the sharded executor service architecture and affects the coordinator node's ability to serve state values to remote execution shards. The fix requires coordination between:
- Batch size limits in the client
- Response size validation in the service
- Network message size limits

The issue is particularly concerning because it can be triggered unintentionally by legitimate applications storing large amounts of data, not just by malicious actors.

### Citations

**File:** execution/executor-service/src/remote_state_view_service.rs (L74-122)
```rust
    pub fn handle_message(
        message: Message,
        state_view: Arc<RwLock<Option<Arc<S>>>>,
        kv_tx: Arc<Vec<Sender<Message>>>,
    ) {
        // we don't know the shard id until we deserialize the message, so lets default it to 0
        let _timer = REMOTE_EXECUTOR_TIMER
            .with_label_values(&["0", "kv_requests"])
            .start_timer();
        let bcs_deser_timer = REMOTE_EXECUTOR_TIMER
            .with_label_values(&["0", "kv_req_deser"])
            .start_timer();
        let req: RemoteKVRequest = bcs::from_bytes(&message.data).unwrap();
        drop(bcs_deser_timer);

        let (shard_id, state_keys) = req.into();
        trace!(
            "remote state view service - received request for shard {} with {} keys",
            shard_id,
            state_keys.len()
        );
        let resp = state_keys
            .into_iter()
            .map(|state_key| {
                let state_value = state_view
                    .read()
                    .unwrap()
                    .as_ref()
                    .unwrap()
                    .get_state_value(&state_key)
                    .unwrap();
                (state_key, state_value)
            })
            .collect_vec();
        let len = resp.len();
        let resp = RemoteKVResponse::new(resp);
        let bcs_ser_timer = REMOTE_EXECUTOR_TIMER
            .with_label_values(&["0", "kv_resp_ser"])
            .start_timer();
        let resp = bcs::to_bytes(&resp).unwrap();
        drop(bcs_ser_timer);
        trace!(
            "remote state view service - sending response for shard {} with {} keys",
            shard_id,
            len
        );
        let message = Message::new(resp);
        kv_tx[shard_id].send(message).unwrap();
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L154-157)
```rust
            max_bytes_per_write_op: NumBytes,
            { 5.. => "max_bytes_per_write_op" },
            1 << 20, // a single state item is 1MB max
        ],
```

**File:** execution/executor-service/src/remote_state_view.rs (L27-27)
```rust
pub static REMOTE_STATE_KEY_BATCH_SIZE: usize = 200;
```

**File:** secure/net/src/grpc_network_service/mod.rs (L23-23)
```rust
const MAX_MESSAGE_SIZE: usize = 1024 * 1024 * 80;
```

**File:** execution/executor-service/src/lib.rs (L83-91)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RemoteKVResponse {
    pub(crate) inner: Vec<(StateKey, Option<StateValue>)>,
}

impl RemoteKVResponse {
    pub fn new(inner: Vec<(StateKey, Option<StateValue>)>) -> Self {
        Self { inner }
    }
```
