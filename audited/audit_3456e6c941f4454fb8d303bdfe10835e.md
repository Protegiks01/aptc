# Audit Report

## Title
Federated Keyless Accounts Allow Arbitrary Self-Signed OIDC Authentication Bypass

## Summary
An attacker can create a federated keyless account with `jwk_addr` pointing to their own controlled address, install self-signed JWKs at that address, and successfully validate transactions without any legitimate OIDC provider authentication. This completely bypasses the core security model of keyless accounts.

## Finding Description

The federated keyless account system allows users to specify a custom `jwk_addr` where JWKs (JSON Web Keys) are stored for signature verification. The validation logic implements a fallback mechanism where it first checks JWKs at the Aptos framework address (0x1), and only if not found there, reads from the federated `jwk_addr`.

The critical flaw is that there is **no validation** that:
1. The issuer (`iss_val`) corresponds to a legitimate OIDC provider
2. The `jwk_addr` is controlled by a trusted entity  
3. The issuer is in the `SupportedOIDCProviders` list maintained by governance

The Move function `update_federated_jwk_set` is a **public entry function** that anyone can call to install `FederatedJWKs` at their own address. This function performs NO validation on the `iss` parameter, accepting any arbitrary issuer value. [1](#0-0) 

The only restriction is that federated JWKs cannot be installed at the Aptos framework address: [2](#0-1) 

**Attack Path:**

1. Attacker chooses a custom issuer not in 0x1's `PatchedJWKs` (e.g., "https://attacker-controlled.com")
2. Attacker calls `update_federated_jwk_set` to install their own JWKs at their address with issuer "https://attacker-controlled.com"
3. Attacker creates a `FederatedKeylessPublicKey` with:
   - `jwk_addr` = attacker's address
   - `iss_val` = "https://attacker-controlled.com"
   - `idc` = any valid identity commitment
4. Attacker derives the account address from this public key
5. Attacker creates a JWT signed with their own private key (matching their installed JWK)
6. During transaction validation:
   - Lookup for "https://attacker-controlled.com" in 0x1 fails (custom issuer)
   - Falls back to reading `FederatedJWKs` from attacker's `jwk_addr` [3](#0-2) 
   - Finds attacker's self-signed JWK
   - Signature validation **succeeds** using attacker's JWK

The 0x1 override mechanism only protects against attacks where the issuer **already exists** in 0x1. For custom issuers not in 0x1, there is zero validation. The JWT claims verification only checks that the issuer in the JWT matches the public key's issuer, but does NOT validate whether that issuer is legitimate: [4](#0-3) 

## Impact Explanation

**Critical Severity** - This vulnerability completely undermines the security model of keyless accounts:

- **Transaction Validation Bypass**: The fundamental assumption of keyless accounts is that authentication is delegated to trusted OIDC providers (Google, Facebook, etc.). This vulnerability allows anyone to be their own "OIDC provider" without any real authentication.

- **Identity Spoofing**: Attackers can create accounts that appear to be authenticated but have no connection to any legitimate identity provider.

- **Consensus Impact**: All validators will deterministically accept these invalid authentications, meaning the entire network validates transactions that should be rejected. This is a protocol-level validation failure where all nodes follow the same flawed logic.

This breaks the **Transaction Validation** invariant: "Prologue/epilogue checks must enforce all invariants" - specifically that keyless accounts must be authenticated by legitimate OIDC providers, not self-signed by arbitrary attackers.

This aligns with the Aptos bug bounty **Critical** severity category as it represents a fundamental authentication bypass affecting consensus validation.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is trivially exploitable:
- No special permissions required - any Aptos user can execute the attack
- Public entry functions are available to anyone
- Attack requires only basic understanding of the keyless account system
- No rate limiting or additional security checks
- Can be executed entirely on-chain with standard transactions
- Test infrastructure already demonstrates the attack path is functional [5](#0-4) 

The only reason this might not be immediately exploited is limited awareness of the federated keyless feature, but once known, exploitation is straightforward.

## Recommendation

Implement issuer validation for federated keyless accounts:

1. **Require governance approval**: Federated JWK installation should require the issuer to be in a governance-approved allowlist, similar to how `SupportedOIDCProviders` works for 0x1.

2. **Add validation in `patch_federated_jwks`**: Before accepting any issuer, verify it against an approved list or implement a registration process requiring governance approval.

3. **Alternative approach**: Remove the federated keyless feature entirely if the trust model cannot be properly enforced, or restrict it to only work with issuers that already exist in `SupportedOIDCProviders` at 0x1.

Example fix in `jwks.move`:
```move
public fun patch_federated_jwks(jwk_owner: &signer, patches: vector<Patch>) acquires FederatedJWKs, SupportedOIDCProviders {
    // Existing check
    assert!(!system_addresses::is_aptos_framework_address(signer::address_of(jwk_owner)),
        error::invalid_argument(EINSTALL_FEDERATED_JWKS_AT_APTOS_FRAMEWORK)
    );
    
    // NEW: Validate that all issuers in patches are approved
    let supported = borrow_global<SupportedOIDCProviders>(@aptos_framework);
    vector::for_each_ref(&patches, |patch_ref| {
        let patch: &Patch = patch_ref;
        // Extract issuer from patch and verify it's in supported.providers
        assert!(is_issuer_supported(patch, supported), 
            error::invalid_argument(EUNAPPROVED_ISSUER));
    });
    
    // Rest of existing logic...
}
```

## Proof of Concept

The existing test infrastructure demonstrates the exploit path is functional. An attacker can execute the following sequence:

1. Call `0x1::jwks::update_federated_jwk_set` with their own issuer and JWKs
2. Create a `FederatedKeylessPublicKey` with `jwk_addr` pointing to their address
3. Sign transactions with keys matching their self-installed JWKs
4. Submit transactions which will validate successfully

The test helper `federated_keyless_install_jwk` at lines 553-583 of `keyless_feature_gating.rs` shows exactly how this can be executed, and test `test_federated_keyless_at_jwk_addr` demonstrates that transactions validate after JWK installation with no issuer validation performed.

## Notes

This vulnerability represents a fundamental design flaw in the federated keyless authentication system. While the feature was intended to allow legitimate OIDC providers (Auth0, AWS Cognito) to self-manage their JWKs, the lack of any trust establishment mechanism means anyone can pretend to be an OIDC provider. The `SupportedOIDCProviders` governance mechanism exists but is never checked for federated accounts, creating a complete bypass of the keyless account security model.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L183-187)
```text
    public fun patch_federated_jwks(jwk_owner: &signer, patches: vector<Patch>) acquires FederatedJWKs {
        // Prevents accidental calls in 0x1::jwks that install federated JWKs at the Aptos framework address.
        assert!(!system_addresses::is_aptos_framework_address(signer::address_of(jwk_owner)),
            error::invalid_argument(EINSTALL_FEDERATED_JWKS_AT_APTOS_FRAMEWORK)
        );
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L258-263)
```text
    public entry fun update_federated_jwk_set(jwk_owner: &signer, iss: vector<u8>, kid_vec: vector<String>, alg_vec: vector<String>, e_vec: vector<String>, n_vec: vector<String>) acquires FederatedJWKs {
        assert!(!vector::is_empty(&kid_vec), error::invalid_argument(EINVALID_FEDERATED_JWK_SET));
        let num_jwk = vector::length<String>(&kid_vec);
        assert!(vector::length(&alg_vec) == num_jwk , error::invalid_argument(EINVALID_FEDERATED_JWK_SET));
        assert!(vector::length(&e_vec) == num_jwk, error::invalid_argument(EINVALID_FEDERATED_JWK_SET));
        assert!(vector::length(&n_vec) == num_jwk, error::invalid_argument(EINVALID_FEDERATED_JWK_SET));
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L236-260)
```rust
        // Try looking up the jwk in 0x1.
        let jwk = match get_jwk_for_authenticator(&patched_jwks.jwks, pk.inner_keyless_pk(), sig) {
            // 1: If found in 0x1, then we consider that the ground truth & we are done.
            Ok(jwk) => jwk,
            // 2: If not found in 0x1, we check the Keyless PK type.
            Err(e) => {
                match pk {
                    // 2.a: If this is a federated keyless account; look in `jwk_addr` for JWKs
                    AnyKeylessPublicKey::Federated(fed_pk) => {
                        let federated_jwks =
                            get_federated_jwks_onchain(resolver, &fed_pk.jwk_addr, module_storage)
                                .map_err(|_| {
                                    invalid_signature!(format!(
                                        "Could not fetch federated PatchedJWKs at {}",
                                        fed_pk.jwk_addr
                                    ))
                                })?;
                        // 2.a.i If not found in jwk_addr either, then we fail the validation.
                        get_jwk_for_authenticator(&federated_jwks.jwks, pk.inner_keyless_pk(), sig)?
                    },
                    // 2.b: If this is not a federated keyless account, then we fail the validation.
                    AnyKeylessPublicKey::Normal(_) => return Err(e),
                }
            },
        };
```

**File:** types/src/keyless/openid_sig.rs (L80-84)
```rust
        ensure!(
            claims.oidc_claims.iss.eq(&pk.iss_val),
            "'iss' claim was supposed to match \"{}\"",
            pk.iss_val
        );
```

**File:** aptos-move/e2e-move-tests/src/tests/keyless_feature_gating.rs (L553-583)
```rust
fn federated_keyless_install_jwk(
    h: &mut MoveHarness,
    jwk_owner: AccountAddress,
    iss: String,
    jwk: RSA_JWK,
) {
    let jwk_owner_account = h.new_account_at(jwk_owner);

    let txn = TransactionBuilder::new(jwk_owner_account.clone())
        .entry_function(EntryFunction::new(
            ModuleId::new(CORE_CODE_ADDRESS, ident_str!("jwks").to_owned()),
            ident_str!("update_federated_jwk_set").to_owned(),
            vec![],
            serialize_values(&vec![
                MoveValue::vector_u8(iss.into_bytes()),
                MoveValue::Vector(vec![MoveValue::vector_u8(jwk.kid.into_bytes())]),
                MoveValue::Vector(vec![MoveValue::vector_u8(jwk.alg.into_bytes())]),
                MoveValue::Vector(vec![MoveValue::vector_u8(jwk.e.into_bytes())]),
                MoveValue::Vector(vec![MoveValue::vector_u8(jwk.n.into_bytes())]),
            ]),
        ))
        .sequence_number(h.sequence_number(jwk_owner_account.address()))
        .max_gas_amount(1_000_000)
        .gas_unit_price(1)
        .sign();

    // NOTE: We cannot write the Configuration and Groth16Verification key via MoveHarness::set_resource
    // because it does not (yet) work with resource groups.

    assert_success!(h.run(txn));
}
```
