# Audit Report

## Title
Unmetered O(N×M) Entry Function Signature Verification Can Delay Block Validation

## Summary
The `script_signature::verify_module()` function performs O(N×M) signature verification for entry functions without metering, where N is the number of entry functions and M is parameters per function. An attacker can deploy modules with thousands of entry functions (limited by the 64KB transaction size) to cause verification delays during block processing.

## Finding Description

The bytecode verification process includes an unmetered O(N×M) complexity check in the entry function signature verification path. [1](#0-0) 

This function iterates through all entry functions (N) and for each one, calls `verify_module_function_signature`, which validates all M parameters through `legacy_script_signature_checks`: [2](#0-1) 

The key issue is that this verification occurs during module loading in block execution, but is NOT included in the bytecode verifier's metering system: [3](#0-2) 

Note that `script_signature::verify_module` is called on line 163 AFTER all metered checks complete, with no meter parameter passed.

The verification happens during block execution when modules are loaded: [4](#0-3) 

**Attack Path:**

1. Attacker crafts a module with maximum entry functions that fit in the 64KB transaction size limit (~2000 entry functions)
2. Each function has 128 parameters (the maximum allowed by production config) [5](#0-4) 

3. Note that `max_function_definitions` is set to `None` (unlimited) in production: [6](#0-5) 

4. Transaction size is limited to 64KB: [7](#0-6) 

5. With ~2000 entry functions × 128 parameters = 256,000 signature validation iterations
6. Each iteration performs pattern matching and boolean checks (~50-100 CPU cycles)
7. Total verification time per transaction: ~8-20ms on modern hardware
8. Multiple such transactions in a block accumulate delays: 10 transactions = 80-200ms overhead

## Impact Explanation

This qualifies as **High Severity** under "Validator node slowdowns" category. While a single transaction adds only 8-20ms, an attacker can include multiple such transactions in blocks they propose or influence through mempool manipulation. With 10-50 such transactions, validators experience 80-1000ms of additional verification overhead per block, representing 2-25% of the typical 2-4 second block time. This degrades network performance and could cause validators to fall behind in consensus, though it does not break consensus safety.

## Likelihood Explanation

**Likelihood: Medium to High**

- Attackers can easily create modules with maximum entry functions within transaction size limits
- No special privileges required beyond the ability to publish modules (standard transaction)
- Gas costs for publishing are standard and not prohibitively expensive
- The verification cache provides partial mitigation, but only for identical module hashes
- Attackers can generate unique modules (different names, small code variations) to bypass caching
- The attack can be repeated across multiple blocks

## Recommendation

Add metering to the entry function signature verification in `script_signature::verify_module()`:

1. **Pass meter to signature verification:**
   - Modify `verify_module()` to accept a `Meter` parameter
   - Charge meter units proportional to (number of entry functions × parameters per function)
   - Fail verification if meter budget exceeded

2. **Enforce function definition limit in production:**
   - Set `max_function_definitions` to a reasonable value (e.g., 1000) instead of `None`
   - This limits N in the O(N×M) complexity

3. **Short-term mitigation:**
   - Add explicit check before verification: reject modules with (entry_functions × max_params > threshold)
   - Example threshold: 10,000 to limit worst case to ~5ms

## Proof of Concept

```rust
// Create a module with many entry functions
module 0x1::attack_module {
    // Function generator would create ~2000 entry functions like:
    public entry fun f1(
        _p1: u64, _p2: u64, /* ... 128 parameters ... */ _p128: u64
    ) {}
    
    public entry fun f2(
        _p1: u64, _p2: u64, /* ... 128 parameters ... */ _p128: u64
    ) {}
    
    // ... repeat for ~2000 functions ...
    
    public entry fun f2000(
        _p1: u64, _p2: u64, /* ... 128 parameters ... */ _p128: u64
    ) {}
}

// Publish this module in a transaction
// Verification time: ~8-20ms per transaction
// Submit 10+ such transactions to accumulate 80-200ms+ delay
```

**Notes:**
- The verification cache mitigates repeated identical modules but not unique variations
- The O(N×M) pattern violates the "Resource Limits" invariant (operations must respect computational limits)
- Current production config with unlimited `max_function_definitions` exacerbates the issue
- The lack of metering in this specific verification phase creates an unbounded computational path

### Citations

**File:** third_party/move/move-bytecode-verifier/src/script_signature.rs (L51-73)
```rust
pub fn verify_module(
    module: &CompiledModule,
    check_signature: FnCheckScriptSignature,
) -> VMResult<()> {
    // important for not breaking old modules
    if module.version < VERSION_5 {
        return Ok(());
    }

    for (idx, _fdef) in module
        .function_defs()
        .iter()
        .enumerate()
        .filter(|(_idx, fdef)| fdef.is_entry)
    {
        verify_module_function_signature(
            module,
            FunctionDefinitionIndex(idx as TableIndex),
            check_signature,
        )?
    }
    Ok(())
}
```

**File:** third_party/move/move-bytecode-verifier/src/script_signature.rs (L147-181)
```rust
pub fn legacy_script_signature_checks(
    resolver: &BinaryIndexedView,
    _is_entry: bool,
    parameters_idx: SignatureIndex,
    return_idx: Option<SignatureIndex>,
) -> PartialVMResult<()> {
    use SignatureToken as S;
    let empty_vec = &vec![];
    let parameters = &resolver.signature_at(parameters_idx).0;
    let return_types = return_idx
        .map(|idx| &resolver.signature_at(idx).0)
        .unwrap_or(empty_vec);
    // Check that all `signer` arguments occur before non-`signer` arguments
    // signer is a type that can only be populated by the Move VM. And its value is filled
    // based on the sender of the transaction
    let all_args_have_valid_type = if resolver.version() <= VERSION_1 {
        parameters
            .iter()
            .skip_while(|typ| matches!(typ, S::Reference(inner) if matches!(&**inner, S::Signer)))
            .all(|typ| typ.is_valid_for_constant())
    } else {
        parameters
            .iter()
            .skip_while(|typ| matches!(typ, S::Signer))
            .all(|typ| typ.is_valid_for_constant())
    };
    let has_valid_return_type = return_types.is_empty();
    if !all_args_have_valid_type || !has_valid_return_type {
        Err(PartialVMError::new(
            StatusCode::INVALID_MAIN_FUNCTION_SIGNATURE,
        ))
    } else {
        Ok(())
    }
}
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L134-173)
```rust
pub fn verify_module_with_config(config: &VerifierConfig, module: &CompiledModule) -> VMResult<()> {
    if config.verify_nothing() {
        return Ok(());
    }
    let prev_state = move_core_types::state::set_state(VMState::VERIFIER);
    let result = std::panic::catch_unwind(|| {
        // Always needs to run bound checker first as subsequent passes depend on it
        BoundsChecker::verify_module(module).map_err(|e| {
            // We can't point the error at the module, because if bounds-checking
            // failed, we cannot safely index into module's handle to itself.
            e.finish(Location::Undefined)
        })?;
        FeatureVerifier::verify_module(config, module)?;
        LimitsVerifier::verify_module(config, module)?;
        DuplicationChecker::verify_module(module)?;

        signature_v2::verify_module(config, module)?;

        InstructionConsistency::verify_module(module)?;
        constants::verify_module(module)?;
        friends::verify_module(module)?;

        RecursiveStructDefChecker::verify_module(module)?;
        InstantiationLoopChecker::verify_module(module)?;
        CodeUnitVerifier::verify_module(config, module)?;

        // Add the failpoint injection to test the catch_unwind behavior.
        fail::fail_point!("verifier-failpoint-panic");

        script_signature::verify_module(module, no_additional_script_signature_checks)
    })
    .unwrap_or_else(|_| {
        Err(
            PartialVMError::new(StatusCode::VERIFIER_INVARIANT_VIOLATION)
                .finish(Location::Undefined),
        )
    });
    move_core_types::state::set_state(prev_state);
    result
}
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L184-198)
```rust
        if !VERIFIED_MODULES_CACHE.contains(module_hash) {
            let _timer =
                VM_TIMER.timer_with_label("move_bytecode_verifier::verify_module_with_config");

            // For regular execution, we cache already verified modules. Note that this even caches
            // verification for the published modules. This should be ok because as long as the
            // hash is the same, the deployed bytecode and any dependencies are the same, and so
            // the cached verification result can be used.
            move_bytecode_verifier::verify_module_with_config(
                &self.vm_config().verifier_config,
                compiled_module.as_ref(),
            )?;
            check_natives(compiled_module.as_ref())?;
            VERIFIED_MODULES_CACHE.put(*module_hash);
        }
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L145-159)
```rust
pub fn aptos_prod_verifier_config(gas_feature_version: u64, features: &Features) -> VerifierConfig {
    let sig_checker_v2_fix_script_ty_param_count =
        features.is_enabled(FeatureFlag::SIGNATURE_CHECKER_V2_SCRIPT_FIX);
    let sig_checker_v2_fix_function_signatures = gas_feature_version >= RELEASE_V1_34;
    let enable_enum_types = features.is_enabled(FeatureFlag::ENABLE_ENUM_TYPES);
    let enable_resource_access_control =
        features.is_enabled(FeatureFlag::ENABLE_RESOURCE_ACCESS_CONTROL);
    let enable_function_values = features.is_enabled(FeatureFlag::ENABLE_FUNCTION_VALUES);
    // Note: we reuse the `enable_function_values` flag to set various stricter limits on types.

    VerifierConfig {
        scope: VerificationScope::Everything,
        max_loop_depth: Some(5),
        max_generic_instantiation_length: Some(32),
        max_function_parameters: Some(128),
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L168-171)
```rust
        max_struct_definitions: None,
        max_struct_variants: None,
        max_fields_in_struct: None,
        max_function_definitions: None,
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L73-76)
```rust
            max_transaction_size_in_bytes: NumBytes,
            "max_transaction_size_in_bytes",
            64 * 1024
        ],
```
