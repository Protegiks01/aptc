# Audit Report

## Title
Privilege Escalation via Automatic ValidatorFullNode Role Assignment on VFN Network Bypasses Access Controls

## Summary
Attackers can bypass inbound connection limits and state sync rate limiting on validators by connecting to the VFN network port (6181), where they are automatically assigned `PeerRole::ValidatorFullNode` without proper authentication, enabling resource exhaustion attacks.

## Finding Description

The vulnerability exists in the peer role determination logic during Noise handshake authentication. When a validator receives an inbound connection on the VFN network (`NetworkId::Vfn`) in `MaybeMutual` authentication mode, any peer—even those not in the trusted peers set—is automatically assigned `PeerRole::ValidatorFullNode`. [1](#0-0) 

This automatic role assignment bypasses critical access control checks:

1. **Inbound Connection Limit Bypass**: The peer manager only enforces connection limits on peers with `PeerRole::Unknown`. Since attackers are marked as `ValidatorFullNode`, they bypass this limit entirely. [2](#0-1) 

2. **State Sync Rate Limiting Bypass**: The storage service request moderator only ignores peers on the public network (`NetworkId::Public`). VFN peers are never ignored regardless of invalid request count. [3](#0-2) 

**Attack Path:**
1. Attacker generates valid x25519 keypair and derives PeerId correctly
2. Attacker connects to validator's VFN network port (6181) from multiple IPs
3. During Noise handshake, peer is authenticated in `MaybeMutual` mode
4. Since peer is not in trusted set but connects on VFN network, automatically receives `PeerRole::ValidatorFullNode`
5. Peer manager skips inbound connection limit check (line 355: only checks `Unknown` role)
6. Attacker opens hundreds/thousands of connections
7. Attacker sends unlimited state sync requests without being rate-limited
8. Validator resources (memory, CPU, bandwidth, file descriptors) are exhausted

The VFN network uses `MaybeMutual` authentication by default (no `mutual_authentication: true` in config): [4](#0-3) [5](#0-4) 

While HAProxy provides IP-based blocking and Kubernetes NetworkPolicy can restrict access, these are:
- Optional (NetworkPolicy requires explicit enablement)
- Environment-specific (not in all deployments)
- Bypassable (HAProxy IP blocking can be circumvented via multiple IPs) [6](#0-5) 

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria, meeting the "Validator node slowdowns" category. The attack enables:

- **Resource Exhaustion**: Unlimited connections consuming memory, file descriptors, and CPU
- **Bandwidth Saturation**: Unlimited state sync requests consuming network bandwidth
- **Service Degradation**: Legitimate VFNs may be unable to connect or receive data
- **Potential Node Unavailability**: In extreme cases, validator operations may be disrupted

The impact is amplified because validators are critical infrastructure nodes that must maintain high availability for consensus participation. Even partial degradation affects network performance.

## Likelihood Explanation

**Likelihood: High**

Attack requirements are minimal:
- No insider access needed
- No stake or validator keys required  
- Attack can be automated and scaled across multiple source IPs
- VFN network port (6181) is exposed in standard deployments
- Works against any validator not using strict NetworkPolicy or firewall rules

The attack is easily discoverable through network scanning and connection testing. The automatic role assignment is triggered simply by connecting to the correct port.

## Recommendation

**Option 1: Enforce Mutual Authentication on VFN Network**

Add `mutual_authentication: true` to VFN network configuration in validator configs:

```yaml
full_node_networks:
  - network_id:
      private: "vfn"
    listen_address: "/ip4/0.0.0.0/tcp/6181"
    mutual_authentication: true  # Add this
    identity:
      type: "from_config"
      key: "..."
```

This ensures only VFNs in the trusted peers set can connect.

**Option 2: Remove Automatic Role Inference**

Modify the handshake logic to mark unknown peers as `PeerRole::Unknown` regardless of network:

```rust
// In network/framework/src/noise/handshake.rs, lines 407-416
} else {
    // Don't infer role from network context - mark as Unknown
    Ok(PeerRole::Unknown)
}
```

Then rely on explicit peer discovery/configuration to mark legitimate VFNs.

**Option 3: Apply Connection Limits to All Inbound Peers**

Modify peer manager to enforce connection limits on all inbound connections, not just `Unknown`:

```rust
// In network/framework/src/peer_manager/mod.rs
if conn.metadata.origin == ConnectionOrigin::Inbound {
    // Count ALL inbound connections, not just Unknown
    let inbound_conns = self
        .active_peers
        .iter()
        .filter(|(_, (metadata, _))| metadata.origin == ConnectionOrigin::Inbound)
        .count();
    
    if inbound_conns + 1 > self.inbound_connection_limit {
        // Reject
    }
}
```

**Recommended Solution**: Option 1 (Mutual Authentication) provides the strongest security guarantee and aligns with the design intent that VFN networks should only serve known VFNs.

## Proof of Concept

```rust
// PoC demonstrating the vulnerability
// File: network/framework/src/tests/connection_limit_bypass.rs

#[tokio::test]
async fn test_vfn_network_connection_limit_bypass() {
    use aptos_config::config::{NetworkId, PeerRole};
    use aptos_crypto::x25519;
    use aptos_network::noise::HandshakeAuthMode;
    use aptos_types::PeerId;
    
    // Setup: Create a validator with VFN network (MaybeMutual auth)
    let validator_key = x25519::PrivateKey::generate_for_testing();
    let validator_peer_id = PeerId::random();
    
    // Configure with inbound connection limit = 5
    let max_inbound_connections = 5;
    
    // Attack: Generate many attacker identities
    let num_attackers = 20; // Far exceeds limit
    let mut attacker_connections = vec![];
    
    for _ in 0..num_attackers {
        let attacker_key = x25519::PrivateKey::generate_for_testing();
        let attacker_peer_id = PeerId::from_identity_public_key(attacker_key.public_key());
        
        // Connect to VFN network port (not in trusted peers)
        // In MaybeMutual mode, will be assigned ValidatorFullNode role
        let connection = connect_to_validator(
            validator_peer_id,
            NetworkId::Vfn,
            attacker_key,
            attacker_peer_id,
        ).await.expect("Connection should succeed");
        
        // Verify role is ValidatorFullNode (not Unknown)
        assert_eq!(connection.metadata.role, PeerRole::ValidatorFullNode);
        
        attacker_connections.push(connection);
    }
    
    // Attack successful: 20 connections established despite limit of 5
    assert_eq!(attacker_connections.len(), 20);
    
    // All connections can send unlimited state sync requests without being ignored
    for conn in &attacker_connections {
        for _ in 0..1000 {
            // Send invalid state sync requests - will never be ignored
            send_invalid_state_sync_request(conn).await;
        }
    }
}
```

## Notes

While `ConnectionOrigin` itself cannot be spoofed (it's determined locally by socket state), the vulnerability lies in the subsequent access control decisions that rely on `PeerRole` assignment. The automatic elevation to `ValidatorFullNode` status based solely on network type enables privilege escalation without proper authentication. This breaks the access control invariant that untrusted peers should be subject to connection limits and rate limiting.

### Citations

**File:** network/framework/src/noise/handshake.rs (L407-410)
```rust
                            if self.network_context.role().is_validator() {
                                if network_id.is_vfn_network() {
                                    // Inbound connections to validators on the VFN network must be VFNs
                                    Ok(PeerRole::ValidatorFullNode)
```

**File:** network/framework/src/peer_manager/mod.rs (L352-390)
```rust
        if conn.metadata.origin == ConnectionOrigin::Inbound {
            // Everything below here is meant for unknown peers only. The role comes from
            // the Noise handshake and if it's not `Unknown` then it is trusted.
            if conn.metadata.role == PeerRole::Unknown {
                // TODO: Keep track of somewhere else to not take this hit in case of DDoS
                // Count unknown inbound connections
                let unknown_inbound_conns = self
                    .active_peers
                    .iter()
                    .filter(|(peer_id, (metadata, _))| {
                        metadata.origin == ConnectionOrigin::Inbound
                            && trusted_peers
                                .get(peer_id)
                                .is_none_or(|peer| peer.role == PeerRole::Unknown)
                    })
                    .count();

                // Reject excessive inbound connections made by unknown peers
                // We control outbound connections with Connectivity manager before we even send them
                // and we must allow connections that already exist to pass through tie breaking.
                if !self
                    .active_peers
                    .contains_key(&conn.metadata.remote_peer_id)
                    && unknown_inbound_conns + 1 > self.inbound_connection_limit
                {
                    info!(
                        NetworkSchema::new(&self.network_context)
                            .connection_metadata_with_address(&conn.metadata),
                        "{} Connection rejected due to connection limit: {}",
                        self.network_context,
                        conn.metadata
                    );
                    counters::connections_rejected(&self.network_context, conn.metadata.origin)
                        .inc();
                    self.disconnect(conn);
                    return;
                }
            }
        }
```

**File:** state-sync/storage-service/server/src/moderator.rs (L49-69)
```rust
    /// Note: we only ignore peers on the public network.
    pub fn increment_invalid_request_count(&mut self, peer_network_id: &PeerNetworkId) {
        // Increment the invalid request count
        self.invalid_request_count += 1;

        // If the peer is a PFN and has sent too many invalid requests, start ignoring it
        if self.ignore_start_time.is_none()
            && peer_network_id.network_id().is_public_network()
            && self.invalid_request_count >= self.max_invalid_requests
        {
            // TODO: at some point we'll want to terminate the connection entirely

            // Start ignoring the peer
            self.ignore_start_time = Some(self.time_service.now());

            // Log the fact that we're now ignoring the peer
            warn!(LogSchema::new(LogEntry::RequestModeratorIgnoredPeer)
                .peer_network_id(peer_network_id)
                .message("Ignoring peer due to too many invalid requests!"));
        }
    }
```

**File:** terraform/helm/aptos-node/files/configs/validator-base.yaml (L27-34)
```yaml
full_node_networks:
  - network_id:
      private: "vfn"
    listen_address: "/ip4/0.0.0.0/tcp/6181"
    identity:
      type: "from_config"
      key: "b0f405a3e75516763c43a2ae1d70423699f34cd68fa9f8c6bb2d67aa87d0af69"
      peer_id: "00000000000000000000000000000000d58bc7bb154b38039bc9096ce04e1237"
```

**File:** network/builder/src/builder.rs (L171-175)
```rust
        let authentication_mode = if config.mutual_authentication {
            AuthenticationMode::Mutual(identity_key)
        } else {
            AuthenticationMode::MaybeMutual(identity_key)
        };
```

**File:** terraform/helm/aptos-node/files/haproxy.cfg (L80-90)
```text
## Specify the VFN network frontend
frontend fe-{{ include "aptos-validator.fullname" $ }}-validator-fn
    bind :6181
    default_backend {{ include "aptos-validator.fullname" $ }}-validator-fn

    # Deny requests from blocked IPs
    tcp-request connection silent-drop if { src -n -f /usr/local/etc/haproxy/blocked.ips }

## Specify the VFN network backend
backend {{ include "aptos-validator.fullname" $ }}-validator-fn
    server {{ include "aptos-validator.fullname" $ }}-{{ $.Values.i }}-validator {{ include "aptos-validator.fullname" $ }}-{{ $.Values.i }}-validator:6181
```
