# Audit Report

## Title
Critical Signature Verification Bypass in Transaction Backup Restore Enabling Arbitrary State Injection

## Summary

The `LoadedChunk::load()` function in `storage/backup/backup-cli/src/backup_types/transaction/restore.rs` conditionally skips cryptographic signature verification of `LedgerInfoWithSignatures` when `epoch_history` is `None`. This occurs when the `skip_epoch_endings` option is enabled in restore/verify coordinators. Without signature verification, an attacker controlling backup storage can inject completely fabricated transaction data that passes all verification checks, leading to arbitrary blockchain state corruption.

## Finding Description

The vulnerability exists in the transaction restore flow where ledger info signature verification is conditional: [1](#0-0) 

When `epoch_history` is `None`, the critical signature verification is completely bypassed. This happens when coordinators set `skip_epoch_endings` to `true`: [2](#0-1) [3](#0-2) 

The signature verification in `EpochHistory::verify_ledger_info()` is essential for cryptographic authenticity: [4](#0-3) 

**Attack Scenario:**

1. Attacker controls backup storage or provides malicious backup files
2. Attacker creates fabricated transactions with matching transaction infos (hashes align by design)
3. Attacker computes transaction accumulator root for the fake data
4. Attacker creates fake `LedgerInfoWithSignatures` with:
   - Arbitrary/invalid signatures (won't be checked)
   - `transaction_accumulator_hash` matching the computed root
5. Attacker creates valid `TransactionAccumulatorRangeProof` proving fake txn_infos against fake ledger_info
6. Attacker creates manifest pointing to these files with `skip_epoch_endings=true`

During verification in `LoadedChunk::load()`: [5](#0-4) 

All checks pass:
- Transaction count matches manifest (line 139-145)
- Transaction hashes match txn_infos (line 2318-2332 in types/src/transaction/mod.rs) - attacker controls both
- Range proof verifies against fake ledger_info (line 2334-2336) - self-consistent by design
- Event verification passes (line 2338-2351) - attacker controls events

The only missing verification is the cryptographic signature check, which anchors the data to validator consensus. Without it, the system accepts completely fabricated blockchain history.

## Impact Explanation

**Critical Severity - Multiple Vectors:**

1. **Consensus/Safety Violation**: Nodes restored from malicious backups will have different state than legitimate nodes, causing permanent chain splits that cannot be reconciled through normal consensus mechanisms.

2. **State Consistency Breach**: The fundamental invariant that "state transitions must be atomic and verifiable via Merkle proofs" is violated. The Merkle proofs verify internal consistency but not authenticity without signature verification.

3. **Non-Recoverable Network Partition**: A node restored with fake state cannot re-sync with the legitimate network because its historical state diverges from the canonical chain. This requires manual intervention or complete re-restoration.

4. **Arbitrary State Injection**: Attackers can inject:
   - Fake balance transfers
   - Invalid Move module deployments  
   - Corrupted governance state
   - Manipulated validator sets
   - Arbitrary transaction history

This meets **Critical Severity** criteria per Aptos Bug Bounty for:
- Consensus/Safety violations (permanent fork)
- Non-recoverable network partition (requires hardfork or manual fix)
- Potential loss of funds (fake balance states)

## Likelihood Explanation

**High Likelihood in Specific Scenarios:**

The vulnerability is exploitable when:
- Users enable `skip_epoch_endings` option (documented feature for faster restore/verify)
- Backup storage is compromised or attacker provides backup files
- Automated restore/verify processes use this optimization

**Attacker Requirements (LOW barrier):**
- Control over backup storage OR ability to provide backup files to victim
- Ability to compute Merkle tree roots (standard cryptographic operations)
- NO validator keys required
- NO consensus participation required
- NO economic stake required

**Realistic Attack Vectors:**
1. Compromised backup storage services
2. Man-in-the-middle attacks during backup retrieval
3. Social engineering to provide "faster" backup sets with `skip_epoch_endings`
4. Insider attacks on backup infrastructure

The `skip_epoch_endings` option exists for performance reasons, making this a realistic deployment scenario rather than a theoretical edge case.

## Recommendation

**Immediate Fix**: Make signature verification mandatory regardless of `epoch_history` status. If epoch history is unavailable, the restore/verify operation should fail safely rather than skip critical security checks.

**Code Fix:**

```rust
// In LoadedChunk::load() - around line 152
let (range_proof, ledger_info) = storage
    .load_bcs_file::<(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)>(
        &manifest.proof,
    )
    .await?;

// FIXED: Always require epoch_history for signature verification
let epoch_history = epoch_history.ok_or_else(|| {
    anyhow!(
        "Epoch history is required for ledger info signature verification. \
         Cannot proceed with restore/verify without cryptographic validation. \
         Remove skip_epoch_endings option or provide epoch ending backups."
    )
})?;

epoch_history.verify_ledger_info(&ledger_info)?;
```

**Additional Recommendations:**

1. Add explicit documentation warning about security implications of `skip_epoch_endings`
2. Consider deprecating or removing `skip_epoch_endings` option entirely
3. Add end-to-end tests specifically for signature verification during restore
4. Implement backup integrity checks at storage layer before restore begins

**Alternative Approach**: If `skip_epoch_endings` must remain for performance, require trusted waypoints to be provided for all transaction versions being restored, and verify against those waypoints instead.

## Proof of Concept

```rust
// Conceptual PoC demonstrating the attack
// File: storage/backup/backup-cli/src/backup_types/transaction/tests.rs

#[tokio::test]
async fn test_signature_bypass_vulnerability() {
    // Setup: Create fake backup data
    let fake_txns = vec![/* arbitrary transactions */];
    let fake_txn_infos = vec![/* matching txn_infos with correct hashes */];
    let fake_events = vec![/* corresponding events */];
    
    // Compute what the accumulator root would be for our fake data
    let fake_txn_info_hashes: Vec<_> = fake_txn_infos.iter()
        .map(|ti| CryptoHash::hash(ti))
        .collect();
    
    // Create fake accumulator and get root
    let fake_accumulator = InMemoryTransactionAccumulator::new(vec![], 0)?
        .append(&fake_txn_info_hashes);
    let fake_root = fake_accumulator.root_hash();
    
    // Create fake LedgerInfo with our computed root
    let fake_ledger_info = LedgerInfo::new(
        BlockInfo::new(
            /* epoch */ 1,
            /* round */ 1,
            /* id */ HashValue::zero(),
            fake_root, // Use our computed root
            /* version */ 100,
            /* timestamp */ 0,
            None,
        ),
        HashValue::zero(),
    );
    
    // Create fake signatures (won't be verified!)
    let fake_signatures = AggregateSignature::empty();
    let fake_li_with_sigs = LedgerInfoWithSignatures::new(
        fake_ledger_info,
        BTreeMap::new(), // Empty signature map
    );
    
    // Create valid proof for fake data against fake ledger info
    let fake_proof = TransactionAccumulatorRangeProof::new(
        vec![/* computed left siblings */],
        vec![/* computed right siblings */],
    );
    
    // Store fake backup files
    let storage = setup_test_storage();
    storage.save_bcs_file(&manifest.proof, &(fake_proof, fake_li_with_sigs)).await?;
    storage.save_transactions(&manifest.transactions, &fake_txns, &fake_txn_infos).await?;
    
    // Attempt restore with skip_epoch_endings=true (epoch_history=None)
    let loaded_chunk = LoadedChunk::load(
        manifest,
        &storage,
        None, // THIS IS THE VULNERABILITY - No signature verification!
    ).await;
    
    // VULNERABILITY: This succeeds even with completely fake data!
    assert!(loaded_chunk.is_ok());
    
    // The fake transactions are now in the restored state
    let chunk = loaded_chunk.unwrap();
    assert_eq!(chunk.txns, fake_txns); // Attacker's fake data accepted!
}
```

**To demonstrate the full exploit:**

1. Build Aptos backup-cli with modifications to inject fake data
2. Run restore with `--skip-epoch-endings` flag
3. Observe that fabricated blockchain state is accepted
4. Show restored node cannot sync with legitimate network
5. Demonstrate state divergence between nodes restored from legitimate vs. malicious backups

The vulnerability is exploitable in production environments where `skip_epoch_endings` is used for performance optimization during backup verification or fast node bootstrapping.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L139-167)
```rust
        ensure!(
            manifest.first_version + (txns.len() as Version) == manifest.last_version + 1,
            "Number of items in chunks doesn't match that in manifest. first_version: {}, last_version: {}, items in chunk: {}",
            manifest.first_version,
            manifest.last_version,
            txns.len(),
        );

        let (range_proof, ledger_info) = storage
            .load_bcs_file::<(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)>(
                &manifest.proof,
            )
            .await?;
        if let Some(epoch_history) = epoch_history {
            epoch_history.verify_ledger_info(&ledger_info)?;
        }

        // make a `TransactionListWithProof` to reuse its verification code.
        let txn_list_with_proof =
            TransactionListWithProofV2::new(TransactionListWithAuxiliaryInfos::new(
                TransactionListWithProof::new(
                    txns,
                    Some(event_vecs),
                    Some(manifest.first_version),
                    TransactionInfoListWithProof::new(range_proof, txn_infos),
                ),
                persisted_aux_info,
            ));
        txn_list_with_proof.verify(ledger_info.ledger_info(), Some(manifest.first_version))?;
```

**File:** storage/backup/backup-cli/src/coordinators/verify.rs (L106-121)
```rust
        let epoch_history = if self.skip_epoch_endings {
            None
        } else {
            Some(Arc::new(
                EpochHistoryRestoreController::new(
                    epoch_endings
                        .into_iter()
                        .map(|backup| backup.manifest)
                        .collect(),
                    global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
        };
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L219-230)
```rust
        let epoch_history = if !self.skip_epoch_endings {
            Some(Arc::new(
                EpochHistoryRestoreController::new(
                    epoch_handles,
                    self.global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
        } else {
            None
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L276-312)
```rust
    pub fn verify_ledger_info(&self, li_with_sigs: &LedgerInfoWithSignatures) -> Result<()> {
        let epoch = li_with_sigs.ledger_info().epoch();
        ensure!(!self.epoch_endings.is_empty(), "Empty epoch history.",);
        if epoch > self.epoch_endings.len() as u64 {
            // TODO(aldenhu): fix this from upper level
            warn!(
                epoch = epoch,
                epoch_history_until = self.epoch_endings.len(),
                "Epoch is too new and can't be verified. Previous chunks are verified and node \
                won't be able to start if this data is malicious."
            );
            return Ok(());
        }
        if epoch == 0 {
            ensure!(
                li_with_sigs.ledger_info() == &self.epoch_endings[0],
                "Genesis epoch LedgerInfo info doesn't match.",
            );
        } else if let Some(wp_trusted) = self
            .trusted_waypoints
            .get(&li_with_sigs.ledger_info().version())
        {
            let wp_li = Waypoint::new_any(li_with_sigs.ledger_info());
            ensure!(
                *wp_trusted == wp_li,
                "Waypoints don't match. In backup: {}, trusted: {}",
                wp_li,
                wp_trusted,
            );
        } else {
            self.epoch_endings[epoch as usize - 1]
                .next_epoch_state()
                .ok_or_else(|| anyhow!("Shouldn't contain non- epoch bumping LIs."))?
                .verify(li_with_sigs)?;
        };
        Ok(())
    }
```
