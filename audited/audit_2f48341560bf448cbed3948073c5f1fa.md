# Audit Report

## Title
Non-Atomic Database Restore Operation Leaves System in Unrecoverable State After Process Crash

## Summary
The `restore_db_snapshot()` function in the indexer-grpc-table-info module contains a critical atomicity violation in its underlying `unpack_tar_gz()` helper function. If a process crash occurs during the database restore operation—specifically after the old database is deleted but before the new database directory is renamed—the system is left in an inconsistent state that requires manual intervention to recover.

## Finding Description

The vulnerability exists in the `unpack_tar_gz()` function [1](#0-0)  which is called by `restore_db_snapshot()` [2](#0-1) .

The restore operation performs the following non-atomic sequence:

1. Creates a temporary directory with `.tmp` extension [3](#0-2) 
2. Unpacks the archive to the temporary directory [4](#0-3) 
3. Removes the old target database directory [5](#0-4) 
4. Atomically renames the temporary directory to the target [6](#0-5) 

**The Critical Window**: If the process crashes after step 3 (old database removed) but before step 4 (rename completes):
- The target database path is empty (old database deleted)
- The restored database exists in the `.tmp` directory
- The system cannot automatically recover

On restart, when `restore_db_snapshot()` is called again, the `fs::create_dir(&temp_dir_path)?` operation will fail with "directory already exists" error because the leftover `.tmp` directory still exists from the previous failed attempt. The restore process cannot proceed without manual intervention.

Evidence that the codebase is aware of orphaned `.tmp` directories: [7](#0-6) 

This breaks the **State Consistency** invariant: "State transitions must be atomic and verifiable via Merkle proofs."

## Impact Explanation

This qualifies as **Medium Severity** under the Aptos Bug Bounty program criteria: "State inconsistencies requiring intervention."

**Specific impacts:**
- The indexer-grpc-table-info service cannot start after a crash during restore
- Manual intervention required (operator must rename or delete `.tmp` directory)
- Service downtime until manual recovery is performed
- Affects data availability for applications querying table information
- Does not affect core blockchain consensus or validator operations

While this service is part of the ecosystem infrastructure (not core consensus), it provides critical indexing functionality for applications built on Aptos. The inability to automatically recover from crashes represents a significant operational risk.

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability can occur in realistic scenarios:
- Process crashes due to OOM conditions during large database unpacking
- System power loss during restore operation
- Container/pod termination during initialization
- System reboots during restore
- Manual process termination during startup

The crash window is narrow (between two filesystem operations), but given that:
- Restore operations can take significant time for large databases
- The unpacking phase is I/O and CPU intensive
- Modern containerized deployments frequently experience restarts

The probability of hitting this window during production operations is non-negligible.

## Recommendation

Implement proper crash recovery logic by checking for and cleaning up leftover `.tmp` directories before attempting restore:

```rust
pub fn unpack_tar_gz(temp_file_path: &PathBuf, target_db_path: &PathBuf) -> anyhow::Result<()> {
    let temp_dir_path = target_db_path.with_extension("tmp");
    
    // Clean up any leftover temp directory from previous failed attempt
    if temp_dir_path.exists() {
        fs::remove_dir_all(&temp_dir_path)
            .context("Failed to clean up leftover temp directory")?;
    }
    
    fs::create_dir(&temp_dir_path)?;

    let file = File::open(temp_file_path)?;
    let gz_decoder = GzDecoder::new(file);
    let mut archive = Archive::new(gz_decoder);
    archive.unpack(&temp_dir_path)?;

    fs::remove_dir_all(target_db_path).unwrap_or(());
    fs::rename(&temp_dir_path, target_db_path)?;
    Ok(())
}
```

Alternatively, use a unique temporary directory name (e.g., with timestamp or UUID) to avoid conflicts entirely.

## Proof of Concept

```rust
#[cfg(test)]
mod test_crash_recovery {
    use super::*;
    use std::fs;
    use tempfile::tempdir;

    #[test]
    fn test_crash_leaves_tmp_directory() {
        let temp_dir = tempdir().unwrap();
        let target_db = temp_dir.path().join("target_db");
        let tmp_dir = temp_dir.path().join("target_db.tmp");
        
        // Create existing target database
        fs::create_dir(&target_db).unwrap();
        fs::write(target_db.join("data"), b"old data").unwrap();
        
        // Simulate crash: Create .tmp directory as if unpack started
        fs::create_dir(&tmp_dir).unwrap();
        fs::write(tmp_dir.join("data"), b"new data").unwrap();
        
        // Simulate the crash scenario where old db is removed
        fs::remove_dir_all(&target_db).unwrap();
        
        // Now try to restore again - this will fail
        let tar_path = temp_dir.path().join("snapshot.tar.gz");
        // Create a minimal tar.gz file
        let gz_encoder = flate2::write::GzEncoder::new(Vec::new(), flate2::Compression::fast());
        let tar_data = std::io::BufWriter::new(gz_encoder);
        let mut tar_builder = tar::Builder::new(tar_data);
        tar_builder.append_dir_all(".", &tmp_dir).unwrap();
        let tar_data = tar_builder.into_inner().unwrap();
        let gz_encoder = tar_data.into_inner().unwrap();
        let compressed = gz_encoder.finish().unwrap();
        fs::write(&tar_path, compressed).unwrap();
        
        // This call will fail because tmp_dir already exists
        let result = unpack_tar_gz(&tar_path, &target_db);
        
        assert!(result.is_err());
        assert!(result.unwrap_err().to_string().contains("File exists") || 
                result.unwrap_err().to_string().contains("already exists"));
        
        // Database is now in inconsistent state:
        // - target_db doesn't exist
        // - tmp_dir contains the restored data but in wrong location
        assert!(!target_db.exists());
        assert!(tmp_dir.exists());
    }
}
```

## Notes

This vulnerability affects the indexer-grpc-table-info service's ability to recover from crashes during database restoration. While it does not directly impact blockchain consensus or validator operations, it represents a significant operational risk for the Aptos ecosystem infrastructure. The fix is straightforward and should be implemented to ensure robust crash recovery behavior.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/backup_restore/fs_ops.rs (L100-113)
```rust
/// Unpack a tar.gz archive to a specified directory
pub fn unpack_tar_gz(temp_file_path: &PathBuf, target_db_path: &PathBuf) -> anyhow::Result<()> {
    let temp_dir_path = target_db_path.with_extension("tmp");
    fs::create_dir(&temp_dir_path)?;

    let file = File::open(temp_file_path)?;
    let gz_decoder = GzDecoder::new(file);
    let mut archive = Archive::new(gz_decoder);
    archive.unpack(&temp_dir_path)?;

    fs::remove_dir_all(target_db_path).unwrap_or(());
    fs::rename(&temp_dir_path, target_db_path)?; // Atomically replace the directory
    Ok(())
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/backup_restore/gcs.rs (L302-305)
```rust
                // Spawn blocking a thread to synchronously unpack gzipped tar file without blocking the async thread
                task::spawn_blocking(move || unpack_tar_gz(&temp_file_path_clone, &db_path))
                    .await?
                    .expect("Failed to unpack gzipped tar file");
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs (L456-458)
```rust
                && file_name.starts_with(&target_snapshot_directory_prefix)
                && !file_name.ends_with(".tmp")
            {
```
