# Audit Report

## Title
Time-of-Check-Time-of-Use (TOCTOU) Race Condition in Move Package Source Digest Verification

## Summary
A TOCTOU vulnerability exists in the Move package build system where source files can be modified after digest computation but before compilation, allowing malicious bytecode to be compiled while bypassing digest-based integrity verification.

## Finding Description

The Move package build system computes a source digest to verify package integrity, but there is a race condition window between digest computation and actual compilation where files can be modified.

**The vulnerability occurs in this sequence:**

1. **Digest Computation Phase** - During resolution graph building, the source digest is computed: [1](#0-0) 

The digest is computed by reading all source files: [2](#0-1) 

2. **Lock Release** - After resolution completes, the package lock is released: [3](#0-2) 

3. **Race Window** - Between resolution and compilation, there is no lock held and files can be modified.

4. **Compilation Phase** - A new lock is acquired and compilation reads the files again: [4](#0-3) 

This calls `BuildPlan::compile_no_exit` which reads source files: [5](#0-4) 

**The digest verification occurs ONLY during dependency resolution:** [6](#0-5) 

**No re-verification occurs during or after compilation.** The compiled bytecode can differ from what the digest represents.

## Impact Explanation

This vulnerability has **Medium severity** because it affects build-time package integrity rather than blockchain runtime security:

- **Supply Chain Attack Vector**: Attackers with filesystem access during builds can inject malicious code into packages, bypassing digest-based dependency pinning
- **CI/CD Pipeline Risk**: Compromised build environments could produce malicious packages that pass digest verification
- **Limited Runtime Impact**: While malicious packages could be deployed on-chain, the blockchain has separate bytecode verification mechanisms

This does not directly affect consensus, execution, or on-chain operations, but could enable supply chain attacks on packages before deployment.

## Likelihood Explanation

The likelihood is **Low to Medium**:

**Prerequisites for exploitation:**
- Write access to the filesystem during package build
- Ability to monitor and precisely time file modifications
- Build environment access (local dev or CI/CD)

**Attack window:** Microseconds to seconds between resolution and compilation

**Realistic scenarios:**
- Compromised CI/CD pipelines with malicious build scripts
- Malicious git hooks in dependencies
- Development environment compromise with filesystem monitoring

The attack is technically feasible but requires specific conditions.

## Recommendation

**Fix: Extend the package lock to cover both resolution and compilation, or re-verify digest before compilation.**

**Option 1: Extend lock scope**
In `aptos-move/framework/src/built_package.rs`, hold the lock across both operations:

```rust
pub fn prepare_and_compile(
    package_path: PathBuf,
    build_config: BuildConfig,
    options: BuildOptions,
) -> anyhow::Result<(ResolvedGraph, CompiledPackage)> {
    let mutx = PackageLock::lock();  // Acquire once
    let resolved_graph = build_config.resolution_graph_for_package_no_lock(&package_path)?;
    let result = build_config.compile_package_no_exit_no_lock(resolved_graph, vec![])?;
    mutx.unlock();  // Release after both complete
    Ok(result)
}
```

**Option 2: Re-verify digest before compilation**
In `CompiledPackage::build_all`, recompute digest and verify it matches:

```rust
// Before compilation, re-verify digest
let current_digest = ResolvingPackage::get_package_digest_for_config(
    &resolved_package.package_path, 
    &resolution_graph.build_options
)?;
if current_digest != resolved_package.source_digest {
    bail!("Source files modified after digest computation - potential tampering detected");
}
```

## Proof of Concept

**Exploitation scenario:**

```rust
// attack_script.sh
#!/bin/bash

# Monitor for resolution completion
inotifywait -e close_write -m build/ | while read event; do
    if [[ "$event" == *"resolution_complete"* ]]; then
        # Inject malicious code
        echo "malicious_code()" >> sources/target.move
        # Allow compilation to proceed
        break
    fi
done
```

**Demonstration steps:**

1. Start a Move package build with digest verification enabled
2. Run monitoring script in parallel to detect resolution completion
3. Script modifies source files after resolution but before compilation
4. Build completes successfully with old digest but new malicious bytecode
5. Digest verification passes despite bytecode containing injected code

**Expected vs Actual:**
- **Expected**: Build should fail if sources change after digest computation
- **Actual**: Build succeeds with mismatched digest and bytecode

---

**Notes:**

This vulnerability exists in the Move package build tooling, not the Aptos blockchain runtime. While it represents a supply chain security risk that could enable injection of malicious code into packages, it does not directly compromise consensus, execution, or on-chain security mechanisms. The impact is limited to the build phase and requires filesystem access during compilation, making it a build-time rather than runtime vulnerability.

### Citations

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L306-307)
```rust
        let source_digest =
            ResolvingPackage::get_package_digest_for_config(&package_path, &self.build_options)?;
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L456-472)
```rust
        match dep.digest {
            None => (),
            Some(fixed_digest) => {
                let resolved_pkg = self
                    .package_table
                    .get(&dep_name_in_pkg)
                    .context("Unable to find resolved package by name")?;
                if fixed_digest != resolved_pkg.source_digest {
                    bail!(
                        "Source digest mismatch in dependency '{}'. Expected '{}' but got '{}'.",
                        dep_name_in_pkg,
                        fixed_digest,
                        resolved_pkg.source_digest
                    )
                }
            },
        }
```

**File:** third_party/move/tools/move-package/src/resolution/digest.rs (L11-51)
```rust
pub fn compute_digest(paths: &[PathBuf]) -> Result<PackageDigest> {
    let mut hashed_files = Vec::new();
    let mut hash = |path: &Path| {
        let contents = std::fs::read(path)?;
        hashed_files.push(format!("{:X}", Sha256::digest(&contents)));
        Ok(())
    };
    let mut maybe_hash_file = |path: &Path| -> Result<()> {
        match path.extension() {
            Some(x) if MOVE_EXTENSION == x => hash(path),
            _ if path.ends_with(SourcePackageLayout::Manifest.path()) => hash(path),
            _ => Ok(()),
        }
    };

    for path in paths {
        if path.is_file() {
            maybe_hash_file(path)?;
        } else {
            for entry in walkdir::WalkDir::new(path)
                .follow_links(true)
                .into_iter()
                .filter_map(|e| e.ok())
            {
                if entry.file_type().is_file() {
                    maybe_hash_file(entry.path())?
                }
            }
        }
    }

    // Sort the hashed files to ensure that the order of files is always stable
    hashed_files.sort();

    let mut hasher = Sha256::new();
    for file_hash in hashed_files.into_iter() {
        hasher.update(file_hash.as_bytes());
    }

    Ok(PackageDigest::from(format!("{:X}", hasher.finalize())))
}
```

**File:** third_party/move/tools/move-package/src/lib.rs (L164-168)
```rust
        let mutx = PackageLock::lock();
        let ret =
            BuildPlan::create(resolved_graph)?.compile_no_exit(&config, external_checks, writer);
        mutx.unlock();
        ret
```

**File:** third_party/move/tools/move-package/src/lib.rs (L214-221)
```rust
        let mutx = PackageLock::lock();
        // This should be locked as it inspects the environment for `MOVE_HOME` which could
        // possibly be set by a different process in parallel.
        let manifest = manifest_parser::parse_source_manifest(toml_manifest)?;
        let resolution_graph = ResolutionGraph::new(manifest, path, self, writer)?;
        let ret = resolution_graph.resolve();
        mutx.unlock();
        ret
```

**File:** third_party/move/tools/move-package/src/compilation/compiled_package.rs (L577-581)
```rust
        let (sources_package_paths, deps_package_paths) = make_source_and_deps_for_compiler(
            resolution_graph,
            &resolved_package,
            transitive_dependencies,
        )?;
```
