# Audit Report

## Title
Governance Can Brick Entire Network via Unconstrained Gas Parameter Manipulation

## Summary
Malicious governance proposals can set transaction gas parameters (`txn_gas_params`) to extreme values that cause ALL transactions to fail, leading to complete network liveness loss requiring a hardfork to recover. The gas schedule validation contains unimplemented TODO comments, allowing parameters like `maximum_number_of_gas_units`, `max_transaction_size_in_bytes`, and gas price bounds to be set to values (0 or u64::MAX) that make the network permanently unusable.

## Finding Description

The `gas_schedule.move` module allows governance proposals to update gas parameters via `set_for_next_epoch()` with only minimal validation. [1](#0-0) 

The only checks performed are:
1. The blob is not empty
2. The new `feature_version` >= current `feature_version`

However, the actual parameter values are never validated. The code contains three TODO comments explicitly stating validation should be added but was never implemented: [2](#0-1) [3](#0-2) 

The gas parameters are deserialized from the governance proposal blob into a `GasScheduleV2` struct containing key-value pairs with u64 values. The deserialization macro simply converts any u64 value to the target type without bounds checking: [4](#0-3) 

The `check_gas()` function validates every transaction against these parameters before execution: [5](#0-4) 

**Attack Scenario 1: Denial of Service (Set limits to 0)**

A malicious governance proposal sets critical parameters to 0:
- `maximum_number_of_gas_units = 0`
- `max_transaction_size_in_bytes = 0`  
- `max_price_per_gas_unit = 0`

This causes ALL transactions to fail because: [6](#0-5) [7](#0-6) [8](#0-7) 

**Attack Scenario 2: Denial of Service (Set min bounds to max)**

Setting `min_price_per_gas_unit = u64::MAX` or `min_transaction_gas_units = u64::MAX` makes it impossible for any transaction to satisfy the minimum requirements: [9](#0-8) [10](#0-9) 

**Critical Escalation: Governance Cannot Fix Itself**

Even approved governance scripts must pass through `check_gas()` and are subject to most of the same parameter checks (except they have alternate size limits). Once malicious parameters take effect: [11](#0-10) 

Note that governance scripts still check `maximum_number_of_gas_units`, gas price bounds, and intrinsic gas requirements. If these are set maliciously, governance proposals to fix the gas schedule will also fail, creating a **permanent brick** requiring a hardfork.

The transaction gas parameter definitions show all the vulnerable parameters: [12](#0-11) 

## Impact Explanation

**Critical Severity - Total Loss of Liveness/Network Availability + Non-Recoverable Network Partition**

This vulnerability meets the Critical severity threshold per Aptos Bug Bounty criteria:

1. **Total loss of liveness/network availability**: Setting any of these parameters to extreme values (0 or u64::MAX) causes ALL user transactions to fail. The network continues producing blocks via consensus, but cannot process any transactions.

2. **Non-recoverable without hardfork**: Once malicious parameters activate at epoch boundary, the chain is bricked. Even governance proposals to restore correct parameters cannot execute because they fail the same `check_gas()` validations. The only recovery path is a coordinated hardfork by all validators to manually restore correct gas parameters.

3. **Affects all nodes uniformly**: This is deterministic - all validators will reject the same transactions, so consensus remains functional but the network becomes useless.

4. **Breaks critical invariants**:
   - **Resource Limits invariant**: "All operations must respect gas, storage, and computational limits" - but limits can be set to make all operations impossible
   - **Transaction Validation invariant**: "Prologue/epilogue checks must enforce all invariants" - but checks can be weaponized to reject all transactions

## Likelihood Explanation

**Moderate to High Likelihood in Adversarial Scenarios**

While this requires governance proposal voting power, the likelihood is elevated because:

1. **No technical barriers**: Once a proposal has sufficient votes, there are zero technical safeguards preventing malicious gas parameters from being applied.

2. **Explicit TODO comments**: The code itself acknowledges that validation "should" be implemented but never was, indicating this is a known gap in security controls.

3. **Governance attack surface**: In scenarios where:
   - A large stakeholder is compromised
   - Validator collusion occurs
   - Governance process is manipulated
   
   This attack becomes immediately exploitable.

4. **Non-obvious consequences**: A proposer might not realize setting a parameter to 0 or max value will brick the entire network, leading to accidental catastrophic failure.

5. **Permanent damage**: Unlike most vulnerabilities that can be patched, this creates irreversible damage requiring emergency hardfork coordination across all validators.

## Recommendation

Implement comprehensive validation of gas parameters in the `gas_schedule.move` module before accepting any updates. Add bounds checking to prevent extreme values:

```move
/// Validates that gas schedule parameters are within safe operational bounds
fun validate_gas_schedule(gas_schedule: &GasScheduleV2): bool {
    // Convert to map for easier lookup
    let map = to_btree_map(gas_schedule);
    
    // Define safe bounds for critical parameters
    let MIN_MAX_GAS_UNITS: u64 = 1000;  // At least 1000 gas units must be allowed
    let MAX_MAX_GAS_UNITS: u64 = 100_000_000;  // Reasonable upper bound
    
    let MIN_TRANSACTION_SIZE: u64 = 1024;  // At least 1KB transactions
    let MAX_TRANSACTION_SIZE: u64 = 10_485_760;  // 10MB max
    
    let MAX_GAS_PRICE: u64 = 100_000_000_000;  // 100 APT per gas unit max
    let MIN_GAS_PRICE: u64 = 0;  // Can be 0 for now
    
    // Validate maximum_number_of_gas_units
    if (map.contains_key(&string::utf8(b"txn.maximum_number_of_gas_units"))) {
        let val = *map.get(&string::utf8(b"txn.maximum_number_of_gas_units"));
        assert!(val >= MIN_MAX_GAS_UNITS && val <= MAX_MAX_GAS_UNITS, EINVALID_GAS_SCHEDULE);
    };
    
    // Validate max_transaction_size_in_bytes
    if (map.contains_key(&string::utf8(b"txn.max_transaction_size_in_bytes"))) {
        let val = *map.get(&string::utf8(b"txn.max_transaction_size_in_bytes"));
        assert!(val >= MIN_TRANSACTION_SIZE && val <= MAX_TRANSACTION_SIZE, EINVALID_GAS_SCHEDULE);
    };
    
    // Validate gas price bounds are ordered correctly
    let min_price = if (map.contains_key(&string::utf8(b"txn.min_price_per_gas_unit"))) {
        *map.get(&string::utf8(b"txn.min_price_per_gas_unit"))
    } else { 0 };
    
    let max_price = if (map.contains_key(&string::utf8(b"txn.max_price_per_gas_unit"))) {
        *map.get(&string::utf8(b"txn.max_price_per_gas_unit"))
    } else { u64::MAX };
    
    assert!(min_price <= max_price, EINVALID_GAS_SCHEDULE);
    assert!(max_price <= MAX_GAS_PRICE, EINVALID_GAS_SCHEDULE);
    
    // Validate other critical parameters similarly...
    true
}
```

Then call this validation in all gas schedule update functions:

```move
public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    // ADD VALIDATION HERE
    assert!(validate_gas_schedule(&new_gas_schedule), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    config_buffer::upsert(new_gas_schedule);
}
```

Replace all TODO comments with actual validation logic.

## Proof of Concept

```rust
#[test]
fn test_malicious_gas_params_brick_network() {
    use aptos_types::on_chain_config::GasScheduleV2;
    use aptos_gas_schedule::{AptosGasParameters, TransactionGasParameters};
    
    // Create a malicious gas schedule with maximum_number_of_gas_units = 0
    let mut malicious_params = AptosGasParameters::initial();
    malicious_params.vm.txn.maximum_number_of_gas_units = 0.into();
    
    // Serialize to on-chain format
    let entries = malicious_params.to_on_chain_gas_schedule(current_feature_version);
    let malicious_schedule = GasScheduleV2 {
        feature_version: current_feature_version,
        entries: entries.into_iter().map(|(k, v)| (k, v)).collect(),
    };
    
    // Apply via governance (in real scenario, this would be a governance proposal)
    aptos_framework::gas_schedule::set_for_next_epoch(
        &framework_signer,
        bcs::to_bytes(&malicious_schedule).unwrap()
    );
    
    // Trigger epoch change to apply the malicious params
    aptos_framework::reconfiguration::reconfigure(&framework_signer);
    
    // Now try to submit ANY transaction - it will fail
    let txn = create_test_transaction(max_gas_amount: 1000000); // Any value > 0
    
    // This will fail with MAX_GAS_UNITS_EXCEEDS_MAX_GAS_UNITS_BOUND
    // because txn.max_gas_amount (1000000) > params.maximum_number_of_gas_units (0)
    let result = execute_transaction(txn);
    assert!(result.is_err());
    assert_eq!(result.unwrap_err().status_code(), StatusCode::MAX_GAS_UNITS_EXCEEDS_MAX_GAS_UNITS_BOUND);
    
    // Even a governance proposal to fix it will fail with the same error!
    let fix_proposal = create_governance_proposal_to_restore_gas_params();
    let fix_result = execute_transaction(fix_proposal);
    assert!(fix_result.is_err()); // Network is permanently bricked!
}
```

**Alternative PoC targeting other parameters:**

```rust
// Set max_transaction_size_in_bytes = 0
malicious_params.vm.txn.max_transaction_size_in_bytes = 0.into();
// Result: ALL transactions fail with EXCEEDED_MAX_TRANSACTION_SIZE

// Set min_price_per_gas_unit = u64::MAX  
malicious_params.vm.txn.min_price_per_gas_unit = u64::MAX.into();
// Result: ALL transactions fail with GAS_UNIT_PRICE_BELOW_MIN_BOUND

// Set max_price_per_gas_unit = 0
malicious_params.vm.txn.max_price_per_gas_unit = 0.into();
// Result: ALL transactions with gas_price > 0 fail with GAS_UNIT_PRICE_ABOVE_MAX_BOUND
```

## Notes

This vulnerability is particularly severe because:

1. **Self-perpetuating**: Once activated, it prevents its own remediation
2. **Deterministic failure**: All validators reject transactions identically, so consensus continues while the network is useless
3. **Explicit technical debt**: The TODO comments prove developers knew this validation was needed but never implemented it
4. **No recovery mechanism**: The only fix is a coordinated emergency hardfork

The vulnerability exists because governance assumes parameter values will be reasonable, but provides no enforcement of that assumption. The TODO comments at lines 45, 66, and 73 of `gas_schedule.move` document this missing validation, making this a known security gap that was never addressed.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L45-48)
```text
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));

        // TODO(Gas): check if gas schedule is consistent
        let gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L63-68)
```text
            let gas_schedule = borrow_global_mut<GasScheduleV2>(@aptos_framework);
            let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
            assert!(new_gas_schedule.feature_version >= gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION));
            // TODO(Gas): check if gas schedule is consistent
            *gas_schedule = new_gas_schedule;
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L32-46)
```rust
        impl $crate::traits::FromOnChainGasSchedule for $params_name {
            #[allow(unused)]
            fn from_on_chain_gas_schedule(gas_schedule: &std::collections::BTreeMap<String, u64>, feature_version: u64) -> Result<Self, String> {
                let mut params = $params_name::zeros();

                $(
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        let name = format!("{}.{}", $prefix, key);
                        params.$name = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?.into();
                    }
                )*

                Ok(params)
            }
        }
```

**File:** aptos-move/aptos-vm/src/gas.rs (L70-79)
```rust
pub(crate) fn check_gas(
    gas_params: &AptosGasParameters,
    gas_feature_version: u64,
    resolver: &impl AptosMoveResolver,
    module_storage: &impl ModuleStorage,
    txn_metadata: &TransactionMetadata,
    features: &Features,
    is_approved_gov_script: bool,
    log_context: &AdapterLogSchema,
) -> Result<(), VMStatus> {
```

**File:** aptos-move/aptos-vm/src/gas.rs (L83-108)
```rust
    if is_approved_gov_script {
        let max_txn_size_gov = if gas_feature_version >= RELEASE_V1_13 {
            gas_params.vm.txn.max_transaction_size_in_bytes_gov
        } else {
            MAXIMUM_APPROVED_TRANSACTION_SIZE_LEGACY.into()
        };

        if txn_metadata.transaction_size > max_txn_size_gov
            // Ensure that it is only the approved payload that exceeds the
            // maximum. The (unknown) user input should be restricted to the original
            // maximum transaction size.
            || txn_metadata.transaction_size
                > txn_metadata.script_size + txn_gas_params.max_transaction_size_in_bytes
        {
            speculative_warn!(
                log_context,
                format!(
                    "[VM] Governance transaction size too big {} payload size {}",
                    txn_metadata.transaction_size, txn_metadata.script_size,
                ),
            );
            return Err(VMStatus::error(
                StatusCode::EXCEEDED_MAX_TRANSACTION_SIZE,
                None,
            ));
        }
```

**File:** aptos-move/aptos-vm/src/gas.rs (L109-121)
```rust
    } else if txn_metadata.transaction_size > txn_gas_params.max_transaction_size_in_bytes {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Transaction size too big {} (max {})",
                txn_metadata.transaction_size, txn_gas_params.max_transaction_size_in_bytes
            ),
        );
        return Err(VMStatus::error(
            StatusCode::EXCEEDED_MAX_TRANSACTION_SIZE,
            None,
        ));
    }
```

**File:** aptos-move/aptos-vm/src/gas.rs (L126-139)
```rust
    if txn_metadata.max_gas_amount() > txn_gas_params.maximum_number_of_gas_units {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; max {}, submitted {}",
                txn_gas_params.maximum_number_of_gas_units,
                txn_metadata.max_gas_amount()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::MAX_GAS_UNITS_EXCEEDS_MAX_GAS_UNITS_BOUND,
            None,
        ));
    }
```

**File:** aptos-move/aptos-vm/src/gas.rs (L154-172)
```rust
    let intrinsic_gas = txn_gas_params
        .calculate_intrinsic_gas(raw_bytes_len)
        .evaluate(gas_feature_version, &gas_params.vm);
    let total_rounded: Gas =
        (intrinsic_gas + keyless + slh_dsa_sha2_128s).to_unit_round_up_with_params(txn_gas_params);
    if txn_metadata.max_gas_amount() < total_rounded {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; min {}, submitted {}",
                total_rounded,
                txn_metadata.max_gas_amount()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::MAX_GAS_UNITS_BELOW_MIN_TRANSACTION_GAS_UNITS,
            None,
        ));
    }
```

**File:** aptos-move/aptos-vm/src/gas.rs (L178-192)
```rust
    let below_min_bound = txn_metadata.gas_unit_price() < txn_gas_params.min_price_per_gas_unit;
    if below_min_bound {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; min {}, submitted {}",
                txn_gas_params.min_price_per_gas_unit,
                txn_metadata.gas_unit_price()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::GAS_UNIT_PRICE_BELOW_MIN_BOUND,
            None,
        ));
    }
```

**File:** aptos-move/aptos-vm/src/gas.rs (L195-208)
```rust
    if txn_metadata.gas_unit_price() > txn_gas_params.max_price_per_gas_unit {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; max {}, submitted {}",
                txn_gas_params.max_price_per_gas_unit,
                txn_metadata.gas_unit_price()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::GAS_UNIT_PRICE_ABOVE_MAX_BOUND,
            None,
        ));
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L28-86)
```rust
    [
        // The flat minimum amount of gas required for any transaction.
        // Charged at the start of execution.
        // It is variable to charge more for more expensive authenticators, e.g., keyless
        [
            min_transaction_gas_units: InternalGas,
            "min_transaction_gas_units",
            2_760_000
        ],
        // Any transaction over this size will be charged an additional amount per byte.
        [
            large_transaction_cutoff: NumBytes,
            "large_transaction_cutoff",
            600
        ],
        // The units of gas that to be charged per byte over the `large_transaction_cutoff` in addition to
        // `min_transaction_gas_units` for transactions whose size exceeds `large_transaction_cutoff`.
        [
            intrinsic_gas_per_byte: InternalGasPerByte,
            "intrinsic_gas_per_byte",
            1_158
        ],
        // ~5 microseconds should equal one unit of computational gas. We bound the maximum
        // computational time of any given transaction at roughly 20 seconds. We want this number and
        // `MAX_PRICE_PER_GAS_UNIT` to always satisfy the inequality that
        // MAXIMUM_NUMBER_OF_GAS_UNITS * MAX_PRICE_PER_GAS_UNIT < min(u64::MAX, GasUnits<GasCarrier>::MAX)
        [
            maximum_number_of_gas_units: Gas,
            "maximum_number_of_gas_units",
            aptos_global_constants::MAX_GAS_AMOUNT
        ],
        // The minimum gas price that a transaction can be submitted with.
        // TODO(Gas): should probably change this to something > 0
        [
            min_price_per_gas_unit: FeePerGasUnit,
            "min_price_per_gas_unit",
            aptos_global_constants::GAS_UNIT_PRICE
        ],
        // The maximum gas unit price that a transaction can be submitted with.
        [
            max_price_per_gas_unit: FeePerGasUnit,
            "max_price_per_gas_unit",
            10_000_000_000
        ],
        [
            max_transaction_size_in_bytes: NumBytes,
            "max_transaction_size_in_bytes",
            64 * 1024
        ],
        [
            max_transaction_size_in_bytes_gov: NumBytes,
            { RELEASE_V1_13.. => "max_transaction_size_in_bytes.gov" },
            1024 * 1024
        ],
        [
            gas_unit_scaling_factor: GasScalingFactor,
            "gas_unit_scaling_factor",
            GAS_SCALING_FACTOR
        ],
```
