# Audit Report

## Title
Log Injection via Unsanitized User Input in Move Identifier Error Messages

## Summary
Attackers can inject newline characters and ANSI escape codes into API error messages through malformed Move module and function identifiers. This allows manipulation of log entries captured by SIEM systems monitoring validator API security, potentially enabling attackers to hide malicious activity or forge fake log entries.

## Finding Description

The Aptos API accepts user-supplied Move identifiers (module names, function names) through transaction submission endpoints. When these identifiers fail validation, error messages are generated that include the unsanitized user input directly.

**Attack Flow:**

1. Attacker submits a transaction via JSON API with a crafted entry function containing newlines or ANSI escape codes in the module/function name:
   ```json
   {
     "function": "0x1::malicious_module\n[2024-01-01 00:00:00] INFO Valid transaction approved::transfer",
     ...
   }
   ```

2. During deserialization, the `EntryFunctionId::from_str()` parses the string and attempts to create an `Identifier`: [1](#0-0) 

3. The parsing delegates to `Identifier::new()` which validates the identifier. When validation fails, it generates an error message containing the raw user input WITHOUT sanitization: [2](#0-1) 

4. The `bail!` macro at line 124 creates an error message: `"Invalid identifier 'malicious_module\n[FAKE LOG]'"` that preserves newlines and ANSI escape codes.

5. This error propagates through multiple layers, with each potentially adding context but preserving the malicious content: [3](#0-2) [4](#0-3) 

6. The error is wrapped in an `AptosError` and returned as an HTTP 400 response: [5](#0-4) 

7. The `AptosError::Display` implementation formats the error including the unsanitized message: [6](#0-5) 

8. External monitoring systems (SIEM, log aggregators) that capture HTTP responses will parse these error messages, allowing the attacker to:
   - Inject fake log entries by including newlines
   - Hide malicious activity by using ANSI escape codes to make text invisible in terminals
   - Manipulate log parsing rules that rely on line-based parsing
   - Create confusion in security incident response

The logging infrastructure does not sanitize these messages: [7](#0-6) 

The logging macros use standard Rust `format_args!` without any sanitization of control characters.

## Impact Explanation

While this vulnerability does not directly affect blockchain consensus, state integrity, or funds, it impacts **validator operational security** in the following ways:

1. **Security Monitoring Evasion**: Validators rely on SIEM systems to detect attack patterns. Log injection allows attackers to hide reconnaissance activities, failed authentication attempts, or exploit attempts by breaking up log entries or injecting false "success" messages.

2. **Incident Response Confusion**: During security incidents, forged log entries can mislead incident responders, causing them to overlook actual attacks or waste time investigating fake events.

3. **Compliance Violations**: Many validator operators must maintain audit trails for compliance. Manipulated logs could invalidate audit integrity.

However, this does **not** meet the standard Aptos Bug Bounty severity criteria:
- NOT Critical: No funds loss, consensus violation, or network partition
- NOT High: No validator slowdown or API crashes  
- NOT Medium: No funds manipulation or state inconsistencies
- Potentially Low: Information security issue affecting external monitoring

## Likelihood Explanation

**Likelihood: High**

- **Attack Complexity**: Very low - requires only crafting a JSON POST request
- **Prerequisites**: None - any unauthenticated user can submit transactions to public API endpoints
- **Detection Difficulty**: Moderate - monitoring systems would see 400 errors, but malicious content is in error messages
- **Frequency**: Can be repeated unlimited times without cost

Every public validator API endpoint accepting transaction submissions is vulnerable.

## Recommendation

Implement sanitization of all user-controlled input before including it in error messages. This should strip or escape:
- Newline characters (`\n`, `\r`)
- ANSI escape codes (`\x1b[...`)
- Other control characters

**Fix Location 1** - Sanitize in `Identifier::new()`: [2](#0-1) 

```rust
pub fn new(s: impl Into<Box<str>>) -> Result<Self> {
    let s = s.into();
    if Self::is_valid(&s) {
        Ok(Self(s))
    } else {
        // Sanitize the string for error message
        let sanitized = s.chars()
            .map(|c| if c.is_control() { '�' } else { c })
            .collect::<String>();
        bail!("Invalid identifier '{}'", sanitized);
    }
}
```

**Fix Location 2** - Add sanitization helper:

```rust
// In api/types/src/move_types.rs or common utils
fn sanitize_for_logs(s: &str) -> String {
    s.chars()
        .map(|c| match c {
            '\n' | '\r' | '\t' => ' ',
            c if c.is_control() => '�',
            c => c,
        })
        .collect()
}

fn invalid_entry_function_id<S: Display + Sized>(s: S) -> anyhow::Error {
    let sanitized = sanitize_for_logs(&s.to_string());
    format_err!("Invalid entry function ID {}", sanitized)
}
```

## Proof of Concept

```bash
# Send malicious transaction with log injection
curl -X POST https://validator-api:8080/v1/transactions \
  -H "Content-Type: application/json" \
  -d '{
    "sender": "0x1",
    "sequence_number": "0",
    "max_gas_amount": "1000",
    "gas_unit_price": "1",
    "expiration_timestamp_secs": "9999999999",
    "payload": {
      "type": "entry_function_payload",
      "function": "0x1::fake\n[2024-01-01 12:00:00] INFO: Authentication successful for admin::transfer",
      "type_arguments": [],
      "arguments": []
    }
  }'

# Expected response contains unsanitized newline:
# {
#   "message": "Invalid identifier 'fake\n[2024-01-01 12:00:00] INFO: Authentication successful for admin'",
#   "error_code": "invalid_input",
#   ...
# }

# When logged by SIEM, this creates two log entries:
# [actual timestamp] ERROR Invalid identifier 'fake
# [2024-01-01 12:00:00] INFO: Authentication successful for admin'
```

**Notes**

After strict validation against the Aptos Bug Bounty criteria, this issue does NOT meet the threshold for Medium severity as it does not cause "Limited funds loss or manipulation" or "State inconsistencies requiring intervention." It is an operational security issue affecting external monitoring systems rather than the blockchain protocol itself. However, it represents a legitimate security best practice violation that should be addressed to maintain validator operational security integrity.

### Citations

**File:** api/types/src/move_types.rs (L1416-1428)
```rust
impl FromStr for EntryFunctionId {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        if let Some((module, name)) = s.rsplit_once("::") {
            return Ok(Self {
                module: module.parse().map_err(|_| invalid_entry_function_id(s))?,
                name: name.parse().map_err(|_| invalid_entry_function_id(s))?,
            });
        }
        Err(invalid_entry_function_id(s))
    }
}
```

**File:** api/types/src/move_types.rs (L1430-1433)
```rust
#[inline]
fn invalid_entry_function_id<S: Display + Sized>(s: S) -> anyhow::Error {
    format_err!("Invalid entry function ID {}", s)
}
```

**File:** api/types/src/move_types.rs (L1457-1462)
```rust
pub fn verify_function_identifier(function: &str) -> anyhow::Result<()> {
    verify_identifier(function).map_err(|_| format_err!("invalid Move function name: {}", function))
}
pub fn verify_module_identifier(module: &str) -> anyhow::Result<()> {
    verify_identifier(module).map_err(|_| format_err!("invalid Move module name: {}", module))
}
```

**File:** third_party/move/move-core/types/src/identifier.rs (L119-126)
```rust
    pub fn new(s: impl Into<Box<str>>) -> Result<Self> {
        let s = s.into();
        if Self::is_valid(&s) {
            Ok(Self(s))
        } else {
            bail!("Invalid identifier '{}'", s);
        }
    }
```

**File:** api/types/src/error.rs (L20-24)
```rust
impl std::fmt::Display for AptosError {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "Error({:?}): {:#}", self.error_code, self.message)
    }
}
```

**File:** api/types/src/error.rs (L28-38)
```rust
impl AptosError {
    pub fn new_with_error_code<ErrorType: std::fmt::Display>(
        error: ErrorType,
        error_code: AptosErrorCode,
    ) -> AptosError {
        Self {
            message: format!("{:#}", error),
            error_code,
            vm_error_code: None,
        }
    }
```

**File:** crates/aptos-logger/src/macros.rs (L52-69)
```rust
macro_rules! log {
    // Entry, Log Level + stuff
    ($level:expr, $($args:tt)+) => {{
        const METADATA: $crate::Metadata = $crate::Metadata::new(
            $level,
            env!("CARGO_CRATE_NAME"),
            module_path!(),
            concat!(file!(), ':', line!()),
        );

        if METADATA.enabled() {
            $crate::Event::dispatch(
                &METADATA,
                $crate::fmt_args!($($args)+),
                $crate::schema!($($args)+),
            );
        }
    }};
```
