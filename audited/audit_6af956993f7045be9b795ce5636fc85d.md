# Audit Report

## Title
Feature Version Inconsistency in Gas Schedule Serialization Causes Total Network Liveness Failure

## Summary
The `to_on_chain_gas_schedule()` method uses a `feature_version` parameter to conditionally include/exclude gas parameters based on version ranges, but the `GasScheduleV2` struct stores `feature_version` as an independent field with no validation that the serialized entries match that version. This allows a malicious or buggy governance proposal to create a gas schedule where the entries were serialized with one version but the struct claims a different version, causing all validators to fail deserialization and enter `VM_STARTUP_FAILURE` state, halting the entire network.

## Finding Description

The gas schedule serialization system uses a versioned key mechanism where parameters are conditionally included based on feature version ranges. [1](#0-0) 

The macro generates serialization code that checks the feature version to determine which keys to include: [2](#0-1) 

For example, signed integer types (`i8`, `i16`, etc.) are only serialized for version 42 and above: [3](#0-2) 

During deserialization, if a parameter is expected for the given version but doesn't exist in the map, an error is returned: [4](#0-3) 

The critical vulnerability is that the `GasScheduleV2` struct has a separate `feature_version` field that is independent of how the entries were actually serialized: [5](#0-4) 

The Move framework only validates that the new version number is greater than or equal to the old version, but does NOT validate that the entries match that version: [6](#0-5) 

Note the TODO comments indicating this validation is missing: [7](#0-6) 

When validators load the gas schedule and deserialization fails, the error is stored and propagated as `VM_STARTUP_FAILURE`: [8](#0-7) 

This causes all transaction validation to fail: [9](#0-8) 

**Attack Path:**
1. Attacker creates `GasScheduleV2` where entries are serialized with `to_on_chain_gas_schedule(36)` (before RELEASE_V1_38 = 42)
2. But sets the struct's `feature_version` field to 42
3. Submits this as a governance proposal
4. Proposal passes governance vote and is applied via `set_for_next_epoch()`
5. At next epoch boundary, validators call `from_on_chain_gas_schedule(&map, 42)`
6. Deserialization expects "misc.abs_val.i8" (required for version 42 per the version range)
7. Entry doesn't exist (was only serialized for version 36)
8. Returns error: "Gas parameter misc.abs_val.i8 does not exist. Feature version: 42."
9. All validators store this error in their environment
10. Every transaction validation calls `gas_params()` which returns `VM_STARTUP_FAILURE`
11. All transactions fail, network halts completely

## Impact Explanation

This vulnerability meets **Critical Severity** criteria per the Aptos bug bounty program as it causes "Total loss of liveness/network availability". Once a mismatched gas schedule is applied:

- All validators simultaneously enter `VM_STARTUP_FAILURE` state
- No transactions can be validated or executed
- The network is completely halted
- Recovery requires a hard fork to replace the malformed gas schedule on-chain

This breaks Invariant #2 (Consensus Safety) by causing total liveness failure. Unlike safety violations where nodes might disagree on state, this is worse - no nodes can make progress at all.

## Likelihood Explanation

**Likelihood: Medium**

**Requirements:**
- Attacker needs ability to submit governance proposals (requires some governance participation)
- Proposal must pass governance vote (requires majority approval)
- No validator privileges or collusion required

**Scenarios:**
1. **Malicious Attack**: Attacker deliberately crafts mismatched gas schedule to halt network
2. **Accidental Bug**: Developer error in gas schedule generation tooling creates mismatch
3. **Testing Artifact**: Test gas schedule with incorrect version accidentally deployed to mainnet

The likelihood is medium rather than high because governance approval is required, but the attack is realistic given:
- Gas schedule updates are complex and the mismatch might not be obvious during review
- The governance proposal tool could have a bug that creates this condition
- No automated validation exists to catch this before deployment

## Recommendation

Implement validation in the Move framework to ensure gas schedule entries match the declared feature version:

```move
// In gas_schedule.move, add validation function:
fun validate_gas_schedule_consistency(gas_schedule: &GasScheduleV2): bool {
    // Re-serialize with claimed version and compare
    let native_params = from_native_gas_schedule(gas_schedule);
    let re_serialized = to_native_gas_schedule(native_params, gas_schedule.feature_version);
    
    // Check that all expected keys exist
    vector::length(&gas_schedule.entries) == vector::length(&re_serialized)
}

// Call in set_for_next_epoch:
public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    // VALIDATE CONSISTENCY
    assert!(
        validate_gas_schedule_consistency(&new_gas_schedule),
        error::invalid_argument(EINVALID_GAS_SCHEDULE)
    );
    
    // ... rest of validation
}
```

Alternatively, add Rust-side validation in the gas schedule updator tool to prevent generating mismatched schedules: [10](#0-9) 

## Proof of Concept

```rust
#[test]
fn test_feature_version_mismatch_causes_deserialization_failure() {
    use aptos_gas_schedule::{AptosGasParameters, InitialGasSchedule, ToOnChainGasSchedule, FromOnChainGasSchedule};
    use aptos_types::on_chain_config::GasScheduleV2;
    use std::collections::BTreeMap;
    
    // Simulate creating a mismatched gas schedule
    let gas_params = AptosGasParameters::initial();
    
    // Serialize with version 36 (before RELEASE_V1_38 = 42)
    let entries_v36 = gas_params.to_on_chain_gas_schedule(36);
    
    // Create GasScheduleV2 claiming to be version 42
    let malicious_schedule = GasScheduleV2 {
        feature_version: 42,
        entries: entries_v36,
    };
    
    // Try to deserialize with claimed version 42
    let map: BTreeMap<String, u64> = malicious_schedule.entries.into_iter().collect();
    let result = AptosGasParameters::from_on_chain_gas_schedule(&map, 42);
    
    // This should fail because version 42 expects parameters like "misc.abs_val.i8"
    // that don't exist in version 36 serialization
    assert!(result.is_err());
    assert!(result.unwrap_err().contains("misc.abs_val.i8"));
    assert!(result.unwrap_err().contains("does not exist"));
    
    // This demonstrates that validators would fail to load gas parameters
    // and enter VM_STARTUP_FAILURE state, halting all transaction processing
}
```

**Impact Demonstration:**
When this test runs, it confirms that a gas schedule with mismatched versions causes deserialization failure. In production, this error would propagate through: [11](#0-10)  and result in all validators being unable to process transactions, causing total network liveness failure.

### Citations

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L4-16)
```rust
macro_rules! define_gas_parameters_extract_key_at_version {
    ($key: literal, $cur_ver: expr) => {
        Some($key)
    };

    ({ $($ver: pat => $key: literal),+ }, $cur_ver: expr) => {
        match $cur_ver {
            $($ver => Some($key)),+,
            #[allow(unreachable_patterns)]
            _ => None,
        }
    }
}
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L37-42)
```rust
                $(
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        let name = format!("{}.{}", $prefix, key);
                        params.$name = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?.into();
                    }
                )*
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L48-61)
```rust
        impl $crate::traits::ToOnChainGasSchedule for $params_name {
            #[allow(unused)]
            fn to_on_chain_gas_schedule(&self, feature_version: u64) -> Vec<(String, u64)> {
                let mut output = vec![];

                $(
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        output.push((format!("{}.{}", $prefix, key), self.$name.into()))
                    }
                )*

                output
            }
        }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/misc.rs (L39-44)
```rust
        [i8: AbstractValueSize, { RELEASE_V1_38.. => "i8" }, 40],
        [i16: AbstractValueSize, { RELEASE_V1_38.. => "i16" }, 40],
        [i32: AbstractValueSize, { RELEASE_V1_38.. => "i32" }, 40],
        [i64: AbstractValueSize, { RELEASE_V1_38.. => "i64" }, 40],
        [i128: AbstractValueSize, { RELEASE_V1_38.. => "i128" }, 40],
        [i256: AbstractValueSize, { RELEASE_V1_38.. => "i256" }, 40],
```

**File:** types/src/on_chain_config/gas_schedule.rs (L13-17)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
pub struct GasScheduleV2 {
    pub feature_version: u64,
    pub entries: Vec<(String, u64)>,
}
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L47-47)
```text
        // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L273-282)
```rust
pub(crate) fn get_or_vm_startup_failure<'a, T>(
    gas_params: &'a Result<T, String>,
    log_context: &AdapterLogSchema,
) -> Result<&'a T, VMStatus> {
    gas_params.as_ref().map_err(|err| {
        let msg = format!("VM Startup Failed. {}", err);
        speculative_error!(log_context, msg.clone());
        VMStatus::error(StatusCode::VM_STARTUP_FAILURE, Some(msg))
    })
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2805-2814)
```rust
        check_gas(
            self.gas_params(log_context)?,
            self.gas_feature_version(),
            session.resolver,
            module_storage,
            txn_data,
            self.features(),
            is_approved_gov_script,
            log_context,
        )?;
```

**File:** aptos-move/aptos-gas-schedule-updator/src/lib.rs (L115-121)
```rust
/// Constructs the current gas schedule in on-chain format.
pub fn current_gas_schedule(feature_version: u64) -> GasScheduleV2 {
    GasScheduleV2 {
        feature_version,
        entries: AptosGasParameters::initial().to_on_chain_gas_schedule(feature_version),
    }
}
```

**File:** aptos-move/aptos-vm-environment/src/gas.rs (L23-46)
```rust
fn get_gas_config_from_storage(
    sha3_256: &mut Sha3_256,
    state_view: &impl StateView,
) -> (Result<AptosGasParameters, String>, u64) {
    match GasScheduleV2::fetch_config_and_bytes(state_view) {
        Some((gas_schedule, bytes)) => {
            sha3_256.update(&bytes);
            let feature_version = gas_schedule.feature_version;
            let map = gas_schedule.into_btree_map();
            (
                AptosGasParameters::from_on_chain_gas_schedule(&map, feature_version),
                feature_version,
            )
        },
        None => match GasSchedule::fetch_config_and_bytes(state_view) {
            Some((gas_schedule, bytes)) => {
                sha3_256.update(&bytes);
                let map = gas_schedule.into_btree_map();
                (AptosGasParameters::from_on_chain_gas_schedule(&map, 0), 0)
            },
            None => (Err("Neither gas schedule v2 nor v1 exists.".to_string()), 0),
        },
    }
}
```
