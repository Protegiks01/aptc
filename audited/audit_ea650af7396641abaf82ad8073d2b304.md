# Audit Report

## Title
Gas Metering Bypass in Module Verification Allowing Validator Resource Exhaustion

## Summary
The Aptos blockchain charges gas for module publishing based solely on module size (bytes), but the bytecode verification process that follows can consume computational resources disproportionate to the charged gas. An attacker can craft small modules with complex verification requirements that exhaust validator resources while paying minimal gas, enabling a resource exhaustion attack.

## Finding Description

The vulnerability exists in the module publishing transaction flow where gas charging and bytecode verification are misaligned:

**Gas Charging Phase** - Gas is charged based on module SIZE only: [1](#0-0) 

The gas charged is proportional to `blob.code().len()` (module size in bytes), not verification complexity.

**Complexity Check** - A preliminary check with a size-based budget: [2](#0-1) 

This check has budget `2048 + blob.code().len() * 20`, still based on module size.

**Bytecode Verification Phase** - Expensive verification happens WITHOUT gas metering: [3](#0-2) 

The `build_locally_verified_module` function is called without any gas meter parameter: [4](#0-3) 

This function performs full bytecode verification including control flow analysis, type safety checking, reference safety analysis, and other expensive operations, but does NOT charge gas for this work.

**Verifier Metering Limits** - The verifier has internal limits but they are NOT charged as gas: [5](#0-4) 

The production configuration sets limits of 80,000,000 meter units per function and per module. If exceeded, verification fails with `CONSTRAINT_NOT_SATISFIED`: [6](#0-5) 

**The Attack Vector:**

1. Attacker creates a module that is small in size (e.g., 1000 bytes) but has complex verification requirements:
   - Deeply nested type parameters
   - Complex control flow with many basic blocks and loops
   - Extensive reference safety checks

2. Transaction is submitted with this module

3. Prologue passes (account has balance for size-based gas)

4. Gas is charged: ~1000 bytes × 20 + 2048 = ~22,048 units (complexity check budget)

5. Bytecode verification begins and performs up to 80,000,000 meter units of work before failing

6. Ratio: 80,000,000 / 22,048 = ~3,600× more verification work than gas paid

7. Transaction fails with `CONSTRAINT_NOT_SATISFIED`, but epilogue still charges only the size-based gas

8. Attacker can repeat this attack with many transactions, exhausting validator CPU resources

**Verification Operations That Consume Meter Units:** [7](#0-6) 

Each verification step, local operation, graph operation, and join operation consumes meter units. With 80,000,000 available units, this allows millions of verification operations per module.

## Impact Explanation

This is a **High Severity** issue under the Aptos bug bounty program, specifically falling under "Validator node slowdowns."

**Resource Exhaustion Attack:**
- An attacker can submit numerous transactions with modules designed to hit verifier limits
- Each transaction forces validators to perform up to 80,000,000 meter units of verification work
- Gas charged is based only on module size (typically 1000-5000× less than verification work)
- Validators' CPU resources become exhausted processing these verification-heavy modules
- Legitimate transactions experience delays or timeouts
- Network throughput degrades significantly

**Economic Imbalance:**
- Attacker pays minimal gas (proportional to module size)
- Validators perform maximum verification work (up to configured limits)
- This creates an economic attack where verification costs far exceed gas revenue

**Network-Wide Impact:**
- All validators must verify modules before accepting them
- Simultaneous submission of many such transactions affects network-wide performance
- May require emergency intervention to mitigate the attack

## Likelihood Explanation

**Likelihood: HIGH**

The attack is highly likely to occur because:

1. **Easy to Execute**: Creating modules with complex verification requirements is straightforward using nested types, complex control flow, or extensive reference operations

2. **Low Cost**: Attacker only pays gas proportional to module size, making the attack economically viable

3. **No Special Privileges Required**: Any user can submit module publishing transactions

4. **Deterministic Behavior**: The verifier limits are fixed and predictable, making it easy to craft modules that maximize verification work

5. **No Rate Limiting**: There are no additional protections against submitting many verification-heavy transactions

6. **Production Deployment**: The verifier configuration with these limits is actively used in production: [8](#0-7) 

## Recommendation

**Immediate Mitigation:**

1. **Charge Gas for Verification Work**: Modify the verification process to charge gas proportional to verification complexity, not just module size:

```rust
// In build_locally_verified_module, accept a gas meter
pub fn build_locally_verified_module(
    &self,
    gas_meter: &mut impl GasMeter,  // Add gas meter parameter
    compiled_module: Arc<CompiledModule>,
    module_size: usize,
    module_hash: &[u8; 32],
) -> VMResult<LocallyVerifiedModule> {
    if !VERIFIED_MODULES_CACHE.contains(module_hash) {
        // Create a metering wrapper that charges gas for verifier operations
        let verifier_gas_meter = VerifierGasMeter::new(
            gas_meter, 
            &self.vm_config().verifier_config
        );
        
        // Verification now charges gas
        move_bytecode_verifier::verify_module_with_metering(
            &self.vm_config().verifier_config,
            compiled_module.as_ref(),
            &mut verifier_gas_meter,
        )?;
        
        check_natives(compiled_module.as_ref())?;
        VERIFIED_MODULES_CACHE.put(*module_hash);
    }
    Ok(LocallyVerifiedModule(compiled_module, module_size))
}
```

2. **Lower Verifier Limits**: Reduce `max_per_fun_meter_units` and `max_per_mod_meter_units` to values more aligned with gas budgets (e.g., 1,000,000 instead of 80,000,000)

3. **Add Pre-Verification Heuristics**: Implement fast heuristics before full verification to reject obviously expensive modules early:
   - Count total type nodes across all signatures
   - Count total basic blocks across all functions
   - Estimate verification complexity and reject if too high for given gas

4. **Transaction Pool Filtering**: Add mempool-level filtering to reject transactions with verification-heavy modules before they enter consensus

**Long-term Solutions:**

1. **Unified Metering**: Integrate verifier metering with the gas meter so all computational work is charged proportionally

2. **Graduated Verification**: Implement multi-stage verification where expensive checks are only performed if simpler checks pass and sufficient gas is available

3. **Caching Improvements**: Expand the verification cache to cover partial verification results and module components

## Proof of Concept

```rust
// Conceptual PoC - Module that is small but expensive to verify

module attacker::resource_exhaustion {
    use std::vector;
    
    // Create deeply nested type parameters to increase type checking complexity
    struct Nested<T1, T2, T3, T4, T5> { 
        v: vector<vector<vector<vector<vector<T1>>>>>
    }
    
    // Function with complex control flow to maximize verification work
    public fun expensive_verification<T1, T2, T3>(x: u64): u64 {
        let i = 0;
        let result = 0;
        
        // Create many basic blocks with complex branching
        while (i < 100) {
            if (i % 10 == 0) {
                if (i % 5 == 0) {
                    if (i % 3 == 0) {
                        result = result + 1;
                    } else {
                        result = result + 2;
                    }
                } else {
                    result = result + 3;
                }
            } else {
                if (i % 7 == 0) {
                    result = result + 4;
                } else {
                    result = result + 5;
                }
            };
            i = i + 1;
        };
        
        // Additional complexity with multiple type instantiations
        let _v1: Nested<u8, u16, u32, u64, u128> = Nested { 
            v: vector::empty() 
        };
        let _v2: Nested<u128, u64, u32, u16, u8> = Nested { 
            v: vector::empty() 
        };
        
        result
    }
}

// Attack simulation (Rust pseudocode):
// 1. Compile the above module (small size ~2KB)
// 2. Submit 100 transactions publishing variations of this module
// 3. Each transaction:
//    - Pays gas for ~2KB module (~40,000 units)
//    - Forces verification work up to 80,000,000 units
//    - Ratio: 2000× more work than gas paid
// 4. All validators must verify, causing network-wide CPU exhaustion
```

**Notes:**

- The actual verification complexity depends on specific verifier implementations
- Control flow verification currently has limited metering (TODO comment found): [9](#0-8) 
- Reference safety and type safety checks consume significant meter units
- The vulnerability is exacerbated by the 3,600× ratio between verifier limits and complexity check budgets

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1529-1536)
```rust
                gas_meter
                    .charge_dependency(
                        DependencyKind::New,
                        addr,
                        name,
                        NumBytes::new(blob.code().len() as u64),
                    )
                    .map_err(|err| err.finish(Location::Undefined))?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1554-1559)
```rust
        for (module, blob) in modules.iter().zip(bundle.iter()) {
            // TODO(Gas): Make budget configurable.
            let budget = 2048 + blob.code().len() as u64 * 20;
            move_binary_format::check_complexity::check_module_complexity(module, budget)
                .map_err(|err| err.finish(Location::Undefined))?;
        }
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L252-257)
```rust
                let locally_verified_code = staged_runtime_environment
                    .build_locally_verified_module(
                        compiled_module.clone(),
                        bytes.len(),
                        &sha3_256(bytes),
                    )?;
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L178-195)
```rust
    pub fn build_locally_verified_module(
        &self,
        compiled_module: Arc<CompiledModule>,
        module_size: usize,
        module_hash: &[u8; 32],
    ) -> VMResult<LocallyVerifiedModule> {
        if !VERIFIED_MODULES_CACHE.contains(module_hash) {
            let _timer =
                VM_TIMER.timer_with_label("move_bytecode_verifier::verify_module_with_config");

            // For regular execution, we cache already verified modules. Note that this even caches
            // verification for the published modules. This should be ok because as long as the
            // hash is the same, the deployed bytecode and any dependencies are the same, and so
            // the cached verification result can be used.
            move_bytecode_verifier::verify_module_with_config(
                &self.vm_config().verifier_config,
                compiled_module.as_ref(),
            )?;
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L175-176)
```rust
        max_per_fun_meter_units: Some(1000 * 80000),
        max_per_mod_meter_units: Some(1000 * 80000),
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L286-321)
```rust
    pub fn fetch(state_view: &impl StateView) -> Self {
        let randomness_api_v0_required_deposit = RequiredGasDeposit::fetch_config(state_view)
            .unwrap_or_else(RequiredGasDeposit::default_if_missing)
            .gas_amount;
        let allow_rand_contract_custom_max_gas = AllowCustomMaxGasFlag::fetch_config(state_view)
            .unwrap_or_else(AllowCustomMaxGasFlag::default_if_missing)
            .value;
        Self {
            randomness_api_v0_required_deposit,
            allow_rand_contract_custom_max_gas,
        }
    }
}

```

**File:** third_party/move/move-bytecode-verifier/src/meter.rs (L91-106)
```rust
    fn add(&mut self, units: u128) -> PartialVMResult<()> {
        if let Some(max) = self.max {
            let new_units = self.units.saturating_add(units);
            if new_units > max {
                // TODO: change to a new status PROGRAM_TOO_COMPLEX once this is rolled out. For
                // now we use an existing code to avoid breaking changes on potential rollback.
                return Err(PartialVMError::new(StatusCode::CONSTRAINT_NOT_SATISFIED)
                    .with_message(format!(
                        "program too complex (in `{}` with `{} current + {} new > {} max`)",
                        self.name, self.units, units, max
                    )));
            }
            self.units = new_units;
        }
        Ok(())
    }
```

**File:** third_party/move/move-bytecode-verifier/src/reference_safety/abstract_state.rs (L75-87)
```rust
pub(crate) const STEP_BASE_COST: u128 = 10;
pub(crate) const STEP_PER_LOCAL_COST: u128 = 20;
pub(crate) const STEP_PER_GRAPH_ITEM_COST: u128 = 50;
pub(crate) const JOIN_BASE_COST: u128 = 100;
pub(crate) const JOIN_PER_LOCAL_COST: u128 = 10;
pub(crate) const JOIN_PER_GRAPH_ITEM_COST: u128 = 50;

// The cost for an edge from an input reference parameter to output reference.
pub(crate) const REF_PARAM_EDGE_COST: u128 = 100;
pub(crate) const REF_PARAM_EDGE_COST_GROWTH: f32 = 1.5;

// The cost of an acquires in a call.
pub(crate) const CALL_PER_ACQUIRES_COST: u128 = 100;
```

**File:** third_party/move/move-bytecode-verifier/src/control_flow.rs (L41-41)
```rust
    _meter: &mut impl Meter, // TODO: metering
```
