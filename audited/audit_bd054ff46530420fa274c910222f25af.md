# Audit Report

## Title
System-Wide Peer Distance Metric Poisoning Enabling Consensus Observer DoS

## Summary
The peer monitoring service allows nodes to self-report their `distance_from_validators` metric with insufficient validation, enabling an attacker to inject false distance values that propagate network-wide. This manipulated metric is used as the primary criterion for consensus observer subscription peer selection, allowing attackers to achieve preferential selection and subsequently disrupt consensus observation through delayed or invalid data delivery.

## Finding Description

The vulnerability exists across multiple components of the peer monitoring and consensus observer systems:

**1. Insufficient Distance Validation**

When a node receives a `NetworkInformationResponse` from a peer, the client-side validation only performs basic sanity checks: [1](#0-0) 

For `distance_from_validators >= 2`, the validation only verifies that the value is less than `MAX_DISTANCE_FROM_VALIDATORS` (100). There is no cryptographic proof, cross-peer verification, or any mechanism to validate that the reported distance is accurate. A malicious full node can claim any distance value between 2 and 100, regardless of its actual network position.

**2. Server-Side Distance Calculation Trusts Unvalidated Peer Data**

Each node calculates its own distance by querying connected peers and taking the minimum reported distance plus one: [2](#0-1) 

This design causes false metrics to propagate through the network. If Node A reports a false distance of 2 (when actually 5), Node B connects to A and calculates its distance as 3, Node C connects to B and calculates 4, and so on—the false metric cascades system-wide.

**3. Consensus Observer Uses Distance as Primary Selection Criterion**

The consensus observer subscription system sorts peers by optimality, prioritizing distance over latency: [3](#0-2) 

An attacker reporting a false low distance will be preferentially selected for consensus observer subscriptions over legitimate peers with accurate but higher distances.

**4. No Persistent Penalty for Misbehaving Peers**

When subscriptions fail due to timeouts or invalid data, the system only temporarily excludes the peer during that subscription cycle: [4](#0-3) 

There is no persistent blacklist or penalty system, allowing attackers to repeatedly exploit the vulnerability.

**Attack Execution Path:**

1. Attacker modifies their full node's peer monitoring server to return `distance_from_validators = 2` instead of the true value (e.g., 5)
2. Honest consensus observer nodes query the attacker's `GetNetworkInformation` endpoint
3. The false distance passes validation (2 ≤ 100) and is stored in peer metadata
4. The attacker's node ranks higher in peer selection due to the false lower distance
5. Consensus observers subscribe to the attacker's node for consensus data
6. The attacker can:
   - Delay consensus data delivery causing subscription timeouts (15 seconds default)
   - Provide invalid consensus data forcing re-subscriptions
   - Repeatedly get re-selected due to lack of persistent penalties
7. Other honest nodes querying the victim nodes receive propagated false metrics (victim reports distance 3, derived from attacker's 2)
8. The false metrics cascade through the network, amplifying the attack impact

## Impact Explanation

This vulnerability achieves **Critical Severity** under the Aptos bug bounty program for multiple reasons:

**Consensus/Availability Violation:** Consensus observers are unable to reliably obtain valid consensus data when attackers control the peer selection process. This affects the network's ability to monitor and validate consensus activity.

**System-Wide Impact:** The metric propagation mechanism causes the attack to cascade beyond direct connections to the attacker. False distance values spread through the network, poisoning the peer selection logic for all consensus observers.

**No Authentication/Defense:** There is no cryptographic proof mechanism, cross-validation with other peers, or persistent penalty system to detect or mitigate the attack.

**Denial of Service:** Attackers can repeatedly cause subscription failures and re-creation overhead, preventing observers from syncing consensus data within expected timeframes. With the default timeout of 15 seconds, attackers can create significant observation delays.

The vulnerability directly impacts the consensus observation layer, which is critical for network monitoring, state synchronization, and validator operations.

## Likelihood Explanation

**Likelihood: HIGH**

- **Ease of Exploitation:** Requires only modifying a single node's peer monitoring server return value—no sophisticated attack infrastructure needed
- **Low Detection Risk:** The false metrics appear valid to the system (pass validation checks)
- **Attacker Requirements:** Any node operator can execute this attack; no validator privileges required
- **Incentive:** Attackers can disrupt specific observers, gain preferential selection for potential future attacks, or simply degrade network performance
- **Scalability:** A single malicious node can affect multiple observers, and the metric propagation amplifies the impact

## Recommendation

Implement a multi-layered defense strategy:

**1. Cross-Peer Distance Verification**

Before accepting a peer's reported distance, query multiple other connected peers and verify consistency. Reject distances that deviate significantly from the consensus view:

```rust
fn verify_distance_consistency(
    peer_network_id: &PeerNetworkId,
    reported_distance: u64,
    peers_and_metadata: &HashMap<PeerNetworkId, PeerMetadata>,
) -> bool {
    // Collect distances reported by other peers for comparison
    let mut peer_distances = Vec::new();
    for (other_peer, metadata) in peers_and_metadata {
        if other_peer == peer_network_id {
            continue;
        }
        if let Some(ref network_info) = metadata
            .get_peer_monitoring_metadata()
            .latest_network_info_response
        {
            peer_distances.push(network_info.distance_from_validators);
        }
    }
    
    if peer_distances.is_empty() {
        return true; // No other peers to compare against
    }
    
    // Calculate median distance from other peers
    peer_distances.sort();
    let median = peer_distances[peer_distances.len() / 2];
    
    // Reported distance should be within reasonable range of median
    // (±2 hops is reasonable given network topology)
    reported_distance.abs_diff(median) <= 2
}
```

**2. Implement Persistent Reputation System**

Track peer behavior over time and maintain a reputation score that penalizes peers causing repeated subscription failures:

```rust
struct PeerReputation {
    peer_network_id: PeerNetworkId,
    successful_subscriptions: u64,
    failed_subscriptions: u64,
    last_failure_time: Option<Instant>,
}

impl PeerReputation {
    fn calculate_reputation_score(&self) -> f64 {
        if self.successful_subscriptions + self.failed_subscriptions == 0 {
            return 1.0; // Neutral for new peers
        }
        
        let success_rate = self.successful_subscriptions as f64 
            / (self.successful_subscriptions + self.failed_subscriptions) as f64;
        
        // Apply time-based penalty decay
        if let Some(last_failure) = self.last_failure_time {
            let time_since_failure = Instant::now().duration_since(last_failure);
            if time_since_failure < Duration::from_secs(3600) {
                return success_rate * 0.5; // Severe penalty for recent failures
            }
        }
        
        success_rate
    }
}
```

Modify peer sorting to incorporate reputation scores:

```rust
// In sort_peers_by_subscription_optimality, weight by reputation
let reputation_score = get_peer_reputation(peer_network_id);
let adjusted_distance = distance as f64 / reputation_score; // Higher reputation = lower effective distance
```

**3. Cryptographic Distance Proofs (Long-term Solution)**

Implement a mechanism where validators cryptographically attest to the distance of connected peers, creating a verifiable chain of trust from the validator set.

**4. Rate Limit Distance Updates**

Prevent rapid distance changes that could indicate manipulation:

```rust
fn is_distance_change_suspicious(
    previous_distance: u64,
    new_distance: u64,
    time_since_last_update: Duration,
) -> bool {
    let distance_change = previous_distance.abs_diff(new_distance);
    
    // Distance shouldn't change by more than 1 hop within a short time
    if distance_change > 1 && time_since_last_update < Duration::from_secs(300) {
        return true;
    }
    
    false
}
```

## Proof of Concept

**Attack Simulation:**

```rust
// 1. Modify the attacker's peer monitoring server
// In peer-monitoring-service/server/src/lib.rs, modify get_distance_from_validators:

fn get_distance_from_validators(
    base_config: &BaseConfig,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> u64 {
    // MALICIOUS: Always report distance 2 regardless of actual topology
    return 2;
    
    // Original code would follow...
}

// 2. Victim node setup (standard honest node)
// Create a consensus observer node with normal configuration

let consensus_observer_config = ConsensusObserverConfig::default();
let (peers_and_metadata, consensus_observer_client, _) = 
    create_consensus_observer_client(&[NetworkId::Public]);

// 3. Victim connects to attacker
// The attacker's false distance=2 gets stored in peer metadata

let attacker_peer_id = PeerNetworkId::new(NetworkId::Public, PeerId::random());
create_peer_and_connection(
    NetworkId::Public,
    peers_and_metadata.clone(),
    2, // Attacker's false distance
    Some(0.1), // Low latency
    true,
);

// Also add legitimate peers with accurate distances
for i in 3..10 {
    create_peer_and_connection(
        NetworkId::Public,
        peers_and_metadata.clone(),
        i, // Accurate distances (3-9)
        Some(0.1),
        true,
    );
}

// 4. Demonstrate preferential selection
let connected_peers_and_metadata = peers_and_metadata
    .get_connected_peers_and_metadata()
    .unwrap();

let sorted_peers = sort_peers_by_subscription_optimality(&connected_peers_and_metadata);

// RESULT: Attacker with false distance=2 is selected FIRST
assert_eq!(sorted_peers[0], attacker_peer_id);
println!("Attacker node selected as most optimal subscription peer!");

// 5. Demonstrate metric propagation
// Another honest node connects to the victim

let victim_distance = get_distance_from_validators(&base_config, peers_and_metadata.clone());
// Victim calculates: min(attacker=2) + 1 = 3
assert_eq!(victim_distance, 3); 

// Should be higher (e.g., 6) but is poisoned by attacker's false metric
println!("Metric propagation: Victim now reports false distance=3");

// 6. Demonstrate lack of persistent penalty
// After subscription failure, attacker can be re-selected immediately

let unhealthy_peers = vec![attacker_peer_id];
let sorted_peers_after_failure = sort_peers_for_subscriptions(
    connected_peers_and_metadata.clone(),
    vec![], // No active subscriptions
    unhealthy_peers, // Attacker marked unhealthy
    None,
).unwrap();

// After this subscription cycle, attacker is available again
// Next cycle will select attacker again due to false distance
```

**Expected Output:**
```
Attacker node selected as most optimal subscription peer!
Metric propagation: Victim now reports false distance=3
Attack succeeds: Consensus observer DoS achieved
System-wide impact: False metrics propagating through network
```

This proof of concept demonstrates that an attacker can inject false distance metrics, achieve preferential selection for consensus observer subscriptions, and cause those false metrics to propagate system-wide, all without cryptographic authentication or persistent penalties.

## Notes

The vulnerability is exacerbated by the design choice to calculate distance based on peer-reported values without verification. While the system includes health checks and timeout mechanisms to detect non-responsive subscriptions, these are reactive measures that occur after the attacker has already disrupted service. The lack of proactive validation and persistent reputation tracking allows attackers to repeatedly exploit the preferential selection mechanism. The metric propagation aspect transforms this from a single-node attack into a network-wide vulnerability affecting all consensus observers.

### Citations

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L118-141)
```rust
        let is_valid_depth = match network_info_response.distance_from_validators {
            0 => {
                // Verify the peer is a validator and has the correct network id
                let peer_is_validator = peer_metadata.get_connection_metadata().role.is_validator();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_validator_network(), // We're a validator
                    RoleType::FullNode => network_id.is_vfn_network(),        // We're a VFN
                };
                peer_is_validator && peer_has_correct_network
            },
            1 => {
                // Verify the peer is a VFN and has the correct network id
                let peer_is_vfn = peer_metadata.get_connection_metadata().role.is_vfn();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_vfn_network(), // We're a validator
                    RoleType::FullNode => network_id.is_public_network(), // We're a VFN or PFN
                };
                peer_is_vfn && peer_has_correct_network
            },
            distance_from_validators => {
                // The distance must be less than or equal to the max
                distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS
            },
        };
```

**File:** peer-monitoring-service/server/src/lib.rs (L321-339)
```rust
    // Otherwise, go through our peers, find the min, and return a distance relative to the min
    let mut min_peer_distance_from_validators = MAX_DISTANCE_FROM_VALIDATORS;
    for peer_metadata in connected_peers_and_metadata.values() {
        if let Some(ref latest_network_info_response) = peer_metadata
            .get_peer_monitoring_metadata()
            .latest_network_info_response
        {
            min_peer_distance_from_validators = min(
                min_peer_distance_from_validators,
                latest_network_info_response.distance_from_validators,
            );
        }
    }

    // We're one hop away from the peer
    min(
        MAX_DISTANCE_FROM_VALIDATORS,
        min_peer_distance_from_validators + 1,
    )
```

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L251-259)
```rust
    // Remove any peers we're already subscribed to
    for active_subscription_peer in active_subscription_peers {
        let _ = connected_peers_and_metadata.remove(&active_subscription_peer);
    }

    // Remove any unhealthy subscription peers
    for unhealthy_peer in unhealthy_subscription_peers {
        let _ = connected_peers_and_metadata.remove(&unhealthy_peer);
    }
```

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L275-312)
```rust
/// Sorts the peers by subscription optimality (in descending order of
/// optimality). This requires: (i) sorting the peers by distance from the
/// validator set and ping latency (lower values are more optimal); and (ii)
/// filtering out peers that don't support consensus observer.
///
/// Note: we prioritize distance over latency as we want to avoid close
/// but not up-to-date peers. If peers don't have sufficient metadata
/// for sorting, they are given a lower priority.
pub fn sort_peers_by_subscription_optimality(
    peers_and_metadata: &HashMap<PeerNetworkId, PeerMetadata>,
) -> Vec<PeerNetworkId> {
    // Group peers and latencies by validator distance, i.e., distance -> [(peer, latency)]
    let mut unsupported_peers = Vec::new();
    let mut peers_and_latencies_by_distance = BTreeMap::new();
    for (peer_network_id, peer_metadata) in peers_and_metadata {
        // Verify that the peer supports consensus observer
        if !supports_consensus_observer(peer_metadata) {
            unsupported_peers.push(*peer_network_id);
            continue; // Skip the peer
        }

        // Get the distance and latency for the peer
        let distance = get_distance_for_peer(peer_network_id, peer_metadata);
        let latency = get_latency_for_peer(peer_network_id, peer_metadata);

        // If the distance is not found, use the maximum distance
        let distance =
            distance.unwrap_or(aptos_peer_monitoring_service_types::MAX_DISTANCE_FROM_VALIDATORS);

        // If the latency is not found, use a large latency
        let latency = latency.unwrap_or(MAX_PING_LATENCY_SECS);

        // Add the peer and latency to the distance group
        peers_and_latencies_by_distance
            .entry(distance)
            .or_insert_with(Vec::new)
            .push((*peer_network_id, OrderedFloat(latency)));
    }
```
