# Audit Report

## Title
Unvalidated PackageMetadata During Genesis Installation Enables Framework Compromise via Malicious Release Bundles

## Summary
The genesis initialization path lacks validation of PackageMetadata fields when installing framework packages from `.mrb` files, allowing malicious release bundles to install packages with arbitrary upgrade policies and malformed dependency declarations that bypass all normal publish-time security checks.

## Finding Description

The vulnerability exists in the divergent code paths between genesis package installation and normal package publishing:

**Normal Package Publishing Path (Validated):** [1](#0-0) 

When packages are published via `publish_package()`, multiple validation checks occur:
- Line 171-174: Rejects arbitrary upgrade policy
- Line 182: Validates dependencies via `check_dependencies()`  
- Line 197: Validates upgrade compatibility via `check_upgradability()`

**Genesis Installation Path (Unvalidated):** [2](#0-1) 

During genesis, `initialize_package()` calls `code::initialize()` which directly stores PackageMetadata: [3](#0-2) 

The `initialize()` function only checks that the first signer is `@aptos_framework` (line 157), then directly stores the metadata without validating upgrade_policy, deps, or any other fields.

**Attack Vector:**

1. Attacker creates malicious `.mrb` file with PackageMetadata containing:
   - `upgrade_policy` set to arbitrary (0) when framework should be immutable
   - Non-existent packages in `deps` field
   - Missing actual bytecode dependencies from `deps`
   - Incorrect `upgrade_number`

2. The `.mrb` file is deserialized without validation: [4](#0-3) [5](#0-4) 

3. Genesis generation loads the malicious framework: [6](#0-5) 

4. Malformed metadata is installed without validation during `publish_framework()`: [7](#0-6) 

**Consequences:**

- **Unauthorized Framework Upgrades**: Framework installed with arbitrary/compatible upgrade policy can be upgraded when it should be immutable
- **Dependency Resolution Bypass**: Malformed `deps` field breaks future upgrade validation and dependency policy enforcement
- **State Inconsistency**: On-chain PackageMetadata doesn't match actual bytecode dependencies, violating protocol invariants

## Impact Explanation

**Severity: Medium**

This vulnerability enables **state inconsistencies requiring intervention** per the Aptos bug bounty criteria. Specifically:

1. Framework packages can be installed with incorrect upgrade policies, allowing unauthorized future upgrades that bypass the compatibility enforcement mechanism defined in `can_change_upgrade_policy_to()` and `check_upgradability()`

2. Malformed dependency metadata breaks the dependency policy hierarchy where `check_dependencies()` validates that dependencies have equal or stronger upgrade policies

3. Future package publishing operations will reference corrupted metadata, potentially allowing weaker policies or broken dependency chains

While this doesn't directly cause consensus breaks or fund loss, it compromises the integrity of the framework upgrade mechanism and dependency validation system, requiring manual intervention to correct.

## Likelihood Explanation

**Likelihood: Medium for private networks, Low for mainnet**

**Attack Requirements:**
- Attacker must convince operator to use malicious `.mrb` file during genesis generation
- Applies to private networks, testnets, or forks where operators control genesis
- For mainnet, Aptos Foundation controls genesis making this unlikely

**Feasibility:**
- Creating malicious `.mrb` is straightforward (modify PackageMetadata, serialize with BCS)
- Supply chain attack vector: hosting malicious framework on GitHub or local filesystem
- Social engineering: convincing operators to use "optimized" or "customized" framework

The technical exploit is trivial once the malicious `.mrb` is loaded, but requires operator cooperation or mistake.

## Recommendation

Add PackageMetadata validation to the `code::initialize()` function to match the validation in `publish_package()`:

```move
fun initialize(aptos_framework: &signer, package_owner: &signer, metadata: PackageMetadata)
acquires PackageRegistry {
    system_addresses::assert_aptos_framework(aptos_framework);
    
    // NEW: Validate upgrade policy
    assert!(
        metadata.upgrade_policy.policy > upgrade_policy_arbitrary().policy,
        error::invalid_argument(EINCOMPATIBLE_POLICY_DISABLED),
    );
    
    let addr = signer::address_of(package_owner);
    
    // NEW: Validate dependencies if registry exists
    if (exists<PackageRegistry>(addr)) {
        check_dependencies(addr, &metadata);
    };
    
    if (!exists<PackageRegistry>(addr)) {
        move_to(package_owner, PackageRegistry { packages: vector[metadata] })
    } else {
        vector::push_back(&mut borrow_global_mut<PackageRegistry>(addr).packages, metadata)
    }
}
```

Alternatively, add validation in the Rust genesis code before calling `initialize()`.

## Proof of Concept

```rust
// Create malicious ReleaseBundle with arbitrary upgrade policy
use aptos_framework::{ReleaseBundle, ReleasePackage};
use aptos_framework::natives::code::{PackageMetadata, UpgradePolicy, PackageDep};

fn create_malicious_mrb() -> ReleaseBundle {
    let malicious_metadata = PackageMetadata {
        name: "aptos-framework".to_string(),
        upgrade_policy: UpgradePolicy::arbitrary(), // Should be immutable!
        upgrade_number: 0,
        source_digest: "fake_digest".to_string(),
        manifest: vec![],
        modules: vec![],
        deps: vec![
            PackageDep {
                account: AccountAddress::from_hex_literal("0x999").unwrap(),
                package_name: "NonExistentPackage".to_string(), // Fake dependency!
            }
        ],
        extension: None,
    };
    
    let package = ReleasePackage::new(malicious_metadata, vec![]);
    ReleaseBundle::new(vec![package], vec![])
}

// This bundle can be serialized and used in genesis
let malicious_bundle = create_malicious_mrb();
malicious_bundle.write(PathBuf::from("malicious.mrb")).unwrap();

// When used in genesis generation:
// aptos genesis generate-genesis --local-repository-dir ./malicious_genesis/
// The framework.mrb will be loaded without validation and installed with
// arbitrary upgrade policy and fake dependencies
```

**Notes:**
This vulnerability specifically affects genesis generation workflows where operators have control over the framework source. The lack of metadata validation in the `code::initialize()` function creates a discrepancy from the normal publishing path that could be exploited through supply chain compromise or social engineering to install framework packages with security-critical metadata corruption.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/code.move (L155-164)
```text
    fun initialize(aptos_framework: &signer, package_owner: &signer, metadata: PackageMetadata)
    acquires PackageRegistry {
        system_addresses::assert_aptos_framework(aptos_framework);
        let addr = signer::address_of(package_owner);
        if (!exists<PackageRegistry>(addr)) {
            move_to(package_owner, PackageRegistry { packages: vector[metadata] })
        } else {
            vector::push_back(&mut borrow_global_mut<PackageRegistry>(addr).packages, metadata)
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L168-228)
```text
    public fun publish_package(owner: &signer, pack: PackageMetadata, code: vector<vector<u8>>) acquires PackageRegistry {
        check_code_publishing_permission(owner);
        // Disallow incompatible upgrade mode. Governance can decide later if this should be reconsidered.
        assert!(
            pack.upgrade_policy.policy > upgrade_policy_arbitrary().policy,
            error::invalid_argument(EINCOMPATIBLE_POLICY_DISABLED),
        );

        let addr = signer::address_of(owner);
        if (!exists<PackageRegistry>(addr)) {
            move_to(owner, PackageRegistry { packages: vector::empty() })
        };

        // Checks for valid dependencies to other packages
        let allowed_deps = check_dependencies(addr, &pack);

        // Check package against conflicts
        // To avoid prover compiler error on spec
        // the package need to be an immutable variable
        let module_names = get_module_names(&pack);
        let package_immutable = &borrow_global<PackageRegistry>(addr).packages;
        let len = vector::length(package_immutable);
        let index = len;
        let upgrade_number = 0;
        vector::enumerate_ref(package_immutable
        , |i, old| {
            let old: &PackageMetadata = old;
            if (old.name == pack.name) {
                upgrade_number = old.upgrade_number + 1;
                check_upgradability(old, &pack, &module_names);
                index = i;
            } else {
                check_coexistence(old, &module_names)
            };
        });

        // Assign the upgrade counter.
        pack.upgrade_number = upgrade_number;

        let packages = &mut borrow_global_mut<PackageRegistry>(addr).packages;
        // Update registry
        let policy = pack.upgrade_policy;
        if (index < len) {
            *vector::borrow_mut(packages, index) = pack
        } else {
            vector::push_back(packages, pack)
        };

        event::emit(PublishPackage {
            code_address: addr,
            is_upgrade: upgrade_number > 0
        });

        // Request publish
        if (features::code_dependency_check_enabled())
            request_publish_with_allowed_deps(addr, module_names, allowed_deps, code, policy.policy)
        else
        // The new `request_publish_with_allowed_deps` has not yet rolled out, so call downwards
        // compatible code.
            request_publish(addr, module_names, code, policy.policy)
    }
```

**File:** aptos-move/vm-genesis/src/lib.rs (L1104-1126)
```rust
fn initialize_package(
    session: &mut SessionExt<impl AptosMoveResolver>,
    module_storage: &impl ModuleStorage,
    traversal_context: &mut TraversalContext,
    addr: AccountAddress,
    package: &ReleasePackage,
) {
    exec_function(
        session,
        module_storage,
        traversal_context,
        CODE_MODULE_NAME,
        "initialize",
        vec![],
        vec![
            MoveValue::Signer(CORE_CODE_ADDRESS)
                .simple_serialize()
                .unwrap(),
            MoveValue::Signer(addr).simple_serialize().unwrap(),
            bcs::to_bytes(package.package_metadata()).unwrap(),
        ],
    );
}
```

**File:** aptos-move/vm-genesis/src/lib.rs (L1155-1228)
```rust
fn publish_framework(
    genesis_vm: &GenesisMoveVm,
    genesis_runtime_environment: &RuntimeEnvironment,
    hash_value: HashValue,
    framework: &ReleaseBundle,
) -> (VMChangeSet, ModuleWriteSet) {
    // Reset state view to be empty, to make sure all module write ops are creations.
    let mut state_view = GenesisStateView::new();

    // First, publish modules.
    let mut writes = BTreeMap::new();
    for pack in &framework.packages {
        let modules = pack.sorted_code_and_modules();

        let addr = *modules.first().unwrap().1.self_id().address();
        let code = modules
            .into_iter()
            .map(|(c, _)| c.to_vec().into())
            .collect::<Vec<_>>();

        let package_writes = code_to_writes_for_publishing(
            genesis_runtime_environment,
            genesis_vm.genesis_features(),
            &state_view,
            addr,
            code,
        )
        .unwrap_or_else(|e| {
            panic!(
                "Failure publishing package `{}`: {:?}",
                pack.package_metadata().name,
                e
            )
        });

        // Add write ops so that we can later create a module write set. Also add them to the state
        // view so that modules in subsequent packages can link to them.
        writes.extend(package_writes.clone());
        state_view.add_module_write_ops(package_writes);
    }
    let module_write_set = ModuleWriteSet::new(writes);

    // At this point we processed all packages, and the state view contains all the code. We can
    // run package initialization.

    let module_storage = state_view.as_aptos_code_storage(genesis_runtime_environment);
    let resolver = state_view.as_move_resolver();
    let mut session = genesis_vm.new_genesis_session(&resolver, hash_value);

    let traversal_storage = TraversalStorage::new();
    let mut traversal_context = TraversalContext::new(&traversal_storage);

    for pack in &framework.packages {
        // Unfortunately, package does not contain address information, so we have to access its
        // modules to extract the destination address.
        let addr = *pack
            .sorted_code_and_modules()
            .first()
            .unwrap()
            .1
            .self_id()
            .address();
        initialize_package(
            &mut session,
            &module_storage,
            &mut traversal_context,
            addr,
            pack,
        );
    }

    let change_set =
        assert_ok!(session.finish(&genesis_vm.genesis_change_set_configs(), &module_storage,));
    (change_set, module_write_set)
```

**File:** aptos-move/framework/src/release_bundle.rs (L45-49)
```rust
    pub fn read(file: PathBuf) -> anyhow::Result<ReleaseBundle> {
        let content =
            std::fs::read(&file).with_context(|| format!("while reading `{}`", file.display()))?;
        Ok(bcs::from_bytes::<ReleaseBundle>(&content)?)
    }
```

**File:** aptos-move/framework/cached-packages/src/lib.rs (L17-19)
```rust
static HEAD_RELEASE_BUNDLE: Lazy<ReleaseBundle> = Lazy::new(|| {
    bcs::from_bytes::<ReleaseBundle>(HEAD_RELEASE_BUNDLE_BYTES).expect("bcs succeeds")
});
```

**File:** crates/aptos/src/genesis/git.rs (L230-247)
```rust
    pub fn get_framework(&self) -> CliTypedResult<ReleaseBundle> {
        match self {
            Client::Local(local_repository_path) => {
                let path = local_repository_path.join(FRAMEWORK_NAME);
                if !path.exists() {
                    return Err(CliError::UnableToReadFile(
                        path.display().to_string(),
                        "File not found".to_string(),
                    ));
                }
                Ok(ReleaseBundle::read(path)?)
            },
            Client::Github(client) => {
                let bytes = base64::decode(client.get_file(FRAMEWORK_NAME)?)?;
                Ok(bcs::from_bytes::<ReleaseBundle>(&bytes)?)
            },
        }
    }
```
