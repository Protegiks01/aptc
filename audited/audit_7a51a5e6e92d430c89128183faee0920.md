# Audit Report

## Title
Byzantine Shard Transaction Censorship Causes Coordinator Panic and Denial of Service

## Summary
A Byzantine remote executor shard can selectively drop transactions by returning fewer transaction outputs than it received as input, causing the coordinator node to panic when attempting to aggregate results. This vulnerability enables undetected transaction censorship that results in a complete denial of service for the sharded block execution system.

## Finding Description

The remote executor service architecture lacks validation that transaction outputs match transaction inputs at critical aggregation points, allowing a Byzantine shard to cause coordinator failure through selective transaction censorship.

**Attack Flow:**

1. The coordinator partitions a block into `N` total transactions distributed across multiple shards using `PartitionedTransactions` [1](#0-0) 

2. Each remote executor shard receives its `SubBlocksForShard` containing `K` transactions via `RemoteCoordinatorClient.receive_execute_command()` [2](#0-1) 

3. A Byzantine shard maliciously executes only `M < K` transactions and sends back truncated results via `send_execution_result()` [3](#0-2) 

4. The coordinator aggregates results from all shards without validating output counts against input counts [4](#0-3) 

5. When `Parser::parse()` attempts to create `TransactionsWithOutput`, it receives:
   - `transactions`: All `N` original transactions from `PartitionedTransactions::flatten()`
   - `transaction_outputs`: Only `N - K + M` outputs (fewer than expected) [5](#0-4) 

6. The `TransactionsWithOutput::new()` constructor uses `assert_eq!` to validate length equality, causing a panic when lengths don't match [6](#0-5) 

**Root Cause:**

The vulnerability stems from three interconnected failures:

1. **No Pre-Aggregation Validation**: `RemoteExecutorClient.get_output_from_shards()` receives and deserializes results without validating output counts [7](#0-6) 

2. **No Post-Aggregation Validation**: `ShardedBlockExecutor.execute_block()` blindly extends aggregated results without checking total output count [8](#0-7) 

3. **Unsafe Assertion Instead of Error Handling**: `TransactionsWithOutput::new()` uses `assert_eq!` rather than returning a `Result`, making the failure unrecoverable [9](#0-8) 

## Impact Explanation

**Severity: High**

This vulnerability qualifies as **High Severity** under the Aptos Bug Bounty program criteria for:
- **"Validator node slowdowns"**: Coordinator crashes prevent block execution
- **"API crashes"**: The panic causes process termination
- **"Significant protocol violations"**: Breaks deterministic execution invariant

**Concrete Impact:**

1. **Denial of Service**: A single Byzantine shard can crash the coordinator node, halting all sharded block execution
2. **Transaction Censorship**: The Byzantine shard achieves undetected censorship - its dropped transactions never get executed and the system doesn't detect which shard is malicious before crashing
3. **Network Availability**: The coordinator must restart and potentially re-execute, causing delays and reducing throughput
4. **State Consistency Risk**: Partial execution followed by crash could leave the system in an inconsistent state requiring manual intervention

The attack breaks the **Deterministic Execution** invariant (all validators must produce identical state roots) and **State Consistency** invariant (state transitions must be atomic).

## Likelihood Explanation

**Likelihood: High (given Byzantine shard compromise)**

**Attack Prerequisites:**
- Attacker must compromise at least one remote executor shard process
- Remote executor shards run as separate processes/services that can be modified independently
- No authentication or integrity checks on executor shard responses

**Attack Complexity:**
- **Low**: Simply truncate the output vector before calling `send_execution_result()`
- **No special timing or race conditions required**
- **Repeatable on every block**: Shard can consistently censor transactions

**Detection Difficulty:**
- **No validation**: The coordinator has no mechanism to detect which shard returned incorrect output counts before the panic
- **No logging**: The assertion failure provides no forensic information about which shard was malicious
- **Silent censorship**: Dropped transactions are not flagged or reported

If an attacker can compromise a remote executor shard (through software vulnerabilities, supply chain attacks, or infrastructure compromise), this attack is trivial to execute and highly effective.

## Recommendation

Implement multi-layered validation to detect and handle mismatched transaction counts gracefully:

**1. Add Pre-Aggregation Validation** in `RemoteExecutorClient::get_output_from_shards()`:

```rust
fn get_output_from_shards(
    &self,
    expected_counts_per_shard: &[usize],
) -> Result<Vec<Vec<Vec<TransactionOutput>>>, VMStatus> {
    trace!("RemoteExecutorClient Waiting for results");
    let mut results = vec![];
    for (shard_id, (rx, expected_count)) in self.result_rxs.iter()
        .zip(expected_counts_per_shard.iter())
        .enumerate() 
    {
        let received_bytes = rx.recv().unwrap().to_bytes();
        let result: RemoteExecutionResult = bcs::from_bytes(&received_bytes).unwrap();
        let outputs = result.inner?;
        
        // Validate output count matches expected input count
        let actual_count: usize = outputs.iter().map(|round| round.len()).sum();
        if actual_count != *expected_count {
            return Err(VMStatus::error(
                StatusCode::UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION,
                Some(format!("Shard {} returned {} outputs, expected {}", 
                    shard_id, actual_count, expected_count))
            ));
        }
        
        results.push(outputs);
    }
    Ok(results)
}
```

**2. Add Post-Aggregation Validation** in `ShardedBlockExecutor::execute_block()`:

```rust
pub fn execute_block(
    &self,
    state_view: Arc<S>,
    transactions: PartitionedTransactions,
    concurrency_level_per_shard: usize,
    onchain_config: BlockExecutorConfigFromOnchain,
) -> Result<Vec<TransactionOutput>, VMStatus> {
    let expected_total = transactions.num_txns();
    
    // ... existing execution code ...
    
    // Validate total output count before returning
    if aggregated_results.len() != expected_total {
        return Err(VMStatus::error(
            StatusCode::UNEXPECTED_ERROR_FROM_KNOWN_MOVE_FUNCTION,
            Some(format!("Expected {} outputs, got {}", 
                expected_total, aggregated_results.len()))
        ));
    }
    
    Ok(aggregated_results)
}
```

**3. Replace Unsafe Assertion** in `TransactionsWithOutput::new()`:

```rust
pub fn new(
    transactions: Vec<Transaction>,
    transaction_outputs: Vec<TransactionOutput>,
    persisted_auxiliary_infos: Vec<PersistedAuxiliaryInfo>,
) -> Result<Self> {
    ensure!(
        transactions.len() == transaction_outputs.len(),
        "Transaction count mismatch: {} transactions, {} outputs",
        transactions.len(),
        transaction_outputs.len()
    );
    ensure!(
        transactions.len() == persisted_auxiliary_infos.len(),
        "Transaction count mismatch: {} transactions, {} auxiliary infos",
        transactions.len(),
        persisted_auxiliary_infos.len()
    );
    Ok(Self {
        transactions,
        transaction_outputs,
        persisted_auxiliary_infos,
    })
}
```

## Proof of Concept

```rust
// File: execution/executor-service/src/tests/byzantine_shard_attack.rs
#[cfg(test)]
mod byzantine_shard_tests {
    use super::*;
    use aptos_types::{
        block_executor::partitioner::SubBlocksForShard,
        transaction::{TransactionOutput, TransactionStatus, ExecutionStatus},
    };
    
    #[test]
    #[should_panic(expected = "assertion `left == right` failed")]
    fn test_byzantine_shard_truncates_outputs() {
        // Simulate a Byzantine shard that receives 10 transactions
        // but only returns 7 outputs
        
        let transactions = create_test_transactions(10);
        let sub_blocks = partition_into_sub_blocks(transactions.clone(), 1);
        
        // Byzantine shard executes only 7 transactions
        let byzantine_outputs = vec![
            vec![create_test_output(); 7], // Only 7 outputs instead of 10
        ];
        
        // Coordinator tries to aggregate results
        let all_transactions = transactions; // 10 transactions
        let all_outputs: Vec<TransactionOutput> = byzantine_outputs
            .into_iter()
            .flat_map(|v| v)
            .collect(); // Only 7 outputs
        
        // This should panic due to assertion failure
        let _result = TransactionsWithOutput::new(
            all_transactions,
            all_outputs,
            vec![PersistedAuxiliaryInfo::None; 10],
        );
        // PANIC: assertion `left == right` failed: left: 10, right: 7
    }
    
    fn create_test_transactions(count: usize) -> Vec<Transaction> {
        (0..count)
            .map(|_| Transaction::StateCheckpoint(HashValue::zero()))
            .collect()
    }
    
    fn create_test_output() -> TransactionOutput {
        TransactionOutput::new(
            WriteSet::default(),
            vec![],
            0,
            TransactionStatus::Keep(ExecutionStatus::Success),
            TransactionAuxiliaryData::None,
        )
    }
}
```

**Notes:**

This vulnerability demonstrates a critical gap in Byzantine fault tolerance for the sharded execution architecture. While the system assumes remote executor shards are trusted components, the lack of output validation allows a compromised shard to cause coordinator crashes through selective transaction censorship. The use of `assert_eq!` instead of proper error handling makes the failure unrecoverable and provides no mechanism for identifying the malicious shard. Implementing the recommended validation layers would enable graceful error handling and facilitate identification of Byzantine shards for remediation.

### Citations

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L188-223)
```rust
    pub fn by_transaction_execution_sharded<V: VMBlockExecutor>(
        transactions: PartitionedTransactions,
        auxiliary_infos: Vec<AuxiliaryInfo>,
        parent_state: &LedgerState,
        state_view: CachedStateView,
        onchain_config: BlockExecutorConfigFromOnchain,
        append_state_checkpoint_to_block: Option<HashValue>,
    ) -> Result<ExecutionOutput> {
        let state_view_arc = Arc::new(state_view);
        let transaction_outputs = Self::execute_block_sharded::<V>(
            transactions.clone(),
            state_view_arc.clone(),
            onchain_config,
        )?;

        // TODO(Manu): Handle state checkpoint here.

        // TODO(skedia) add logic to emit counters per shard instead of doing it globally.

        // Unwrapping here is safe because the execution has finished and it is guaranteed that
        // the state view is not used anymore.
        let state_view = Arc::try_unwrap(state_view_arc).unwrap();
        Parser::parse(
            state_view.next_version(),
            PartitionedTransactions::flatten(transactions)
                .into_iter()
                .map(|t| t.into_txn().into_inner())
                .collect(),
            transaction_outputs,
            auxiliary_infos,
            parent_state,
            state_view,
            false, // prime_state_cache
            append_state_checkpoint_to_block.is_some(),
        )
    }
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L80-113)
```rust
    fn receive_execute_command(&self) -> ExecutorShardCommand<RemoteStateViewClient> {
        match self.command_rx.recv() {
            Ok(message) => {
                let _rx_timer = REMOTE_EXECUTOR_TIMER
                    .with_label_values(&[&self.shard_id.to_string(), "cmd_rx"])
                    .start_timer();
                let bcs_deser_timer = REMOTE_EXECUTOR_TIMER
                    .with_label_values(&[&self.shard_id.to_string(), "cmd_rx_bcs_deser"])
                    .start_timer();
                let request: RemoteExecutionRequest = bcs::from_bytes(&message.data).unwrap();
                drop(bcs_deser_timer);

                match request {
                    RemoteExecutionRequest::ExecuteBlock(command) => {
                        let init_prefetch_timer = REMOTE_EXECUTOR_TIMER
                            .with_label_values(&[&self.shard_id.to_string(), "init_prefetch"])
                            .start_timer();
                        let state_keys = Self::extract_state_keys(&command);
                        self.state_view_client.init_for_block(state_keys);
                        drop(init_prefetch_timer);

                        let (sub_blocks, concurrency, onchain_config) = command.into();
                        ExecutorShardCommand::ExecuteSubBlocks(
                            self.state_view_client.clone(),
                            sub_blocks,
                            concurrency,
                            onchain_config,
                        )
                    },
                }
            },
            Err(_) => ExecutorShardCommand::Stop,
        }
    }
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L115-119)
```rust
    fn send_execution_result(&self, result: Result<Vec<Vec<TransactionOutput>>, VMStatus>) {
        let remote_execution_result = RemoteExecutionResult::new(result);
        let output_message = bcs::to_bytes(&remote_execution_result).unwrap();
        self.result_tx.send(Message::new(output_message)).unwrap();
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/mod.rs (L96-115)
```rust
        info!("ShardedBlockExecutor Received all results");
        let _aggregation_timer = SHARDED_EXECUTION_RESULT_AGGREGATION_SECONDS.start_timer();
        let num_rounds = sharded_output[0].len();
        let mut aggregated_results = vec![];
        let mut ordered_results = vec![vec![]; num_executor_shards * num_rounds];
        // Append the output from individual shards in the round order
        for (shard_id, results_from_shard) in sharded_output.into_iter().enumerate() {
            for (round, result) in results_from_shard.into_iter().enumerate() {
                ordered_results[round * num_executor_shards + shard_id] = result;
            }
        }

        for result in ordered_results.into_iter() {
            aggregated_results.extend(result);
        }

        // Lastly append the global output
        aggregated_results.extend(global_output);

        Ok(aggregated_results)
```

**File:** execution/executor-types/src/transactions_with_output.rs (L23-35)
```rust
    pub fn new(
        transactions: Vec<Transaction>,
        transaction_outputs: Vec<TransactionOutput>,
        persisted_auxiliary_infos: Vec<PersistedAuxiliaryInfo>,
    ) -> Self {
        assert_eq!(transactions.len(), transaction_outputs.len());
        assert_eq!(transactions.len(), persisted_auxiliary_infos.len());
        Self {
            transactions,
            transaction_outputs,
            persisted_auxiliary_infos,
        }
    }
```

**File:** execution/executor-service/src/remote_executor_client.rs (L163-172)
```rust
    fn get_output_from_shards(&self) -> Result<Vec<Vec<Vec<TransactionOutput>>>, VMStatus> {
        trace!("RemoteExecutorClient Waiting for results");
        let mut results = vec![];
        for rx in self.result_rxs.iter() {
            let received_bytes = rx.recv().unwrap().to_bytes();
            let result: RemoteExecutionResult = bcs::from_bytes(&received_bytes).unwrap();
            results.push(result.inner?);
        }
        Ok(results)
    }
```
