# Audit Report

## Title
Redis Credential Exposure Through Improper URL Sanitization in Indexer-gRPC Services

## Summary
The `RedisUrl` type in the indexer-grpc-utils module fails to sanitize credentials from Redis connection URLs before logging or displaying them, leading to password exposure in application logs, stdout output, and error messages. This violates secure credential handling practices and could enable unauthorized access to Redis instances containing cached blockchain transaction data.

## Finding Description

The `RedisUrl` type implements both `Display` and `Debug` traits (derived) that directly expose the underlying URL without sanitizing embedded credentials. [1](#0-0) 

The `Display` implementation directly forwards to the inner `Url`'s display, which includes credentials: [2](#0-1) 

The `from_str()` function only validates the scheme but performs no credential sanitization: [3](#0-2) 

**Concrete Exposure Points:**

1. **Direct stdout logging** exposes credentials using debug formatting: [4](#0-3) 

2. **Error messages in cache worker** expose credentials via Display trait: [5](#0-4) 

3. **Error messages in data service** expose credentials via Display trait: [6](#0-5) 

4. **Error messages in file store processor** expose credentials in two locations: [7](#0-6) 

The codebase already demonstrates proper credential sanitization patterns in other components, masking passwords before display: [8](#0-7) 

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty criteria for the following reasons:

1. **Credential Exposure**: Redis credentials containing passwords are exposed in plaintext through multiple channels (stdout, logs, error messages)
2. **Infrastructure Access**: Compromised credentials enable unauthorized access to Redis instances storing cached blockchain transaction data
3. **Service Disruption**: Attackers with Redis access could corrupt or delete cached data, causing indexer service failures
4. **Data Access**: Unauthorized parties could read cached transaction data, potentially including sensitive information
5. **Log System Proliferation**: Application logs are typically accessible to multiple personnel, stored in centralized logging systems, and may be retained long-term, increasing exposure risk

While this affects ecosystem infrastructure rather than core consensus, the indexer-grpc services are critical components for blockchain data access, and credential exposure represents a significant protocol violation in secure systems design.

## Likelihood Explanation

This vulnerability has **HIGH** likelihood of exploitation:

1. **Automatic Exposure**: Credentials are exposed automatically during normal operation (service startup) and error conditions, requiring no special triggering
2. **Common Attack Vector**: Log access is a standard penetration testing target and frequently available to:
   - System administrators and operators
   - Personnel with access to centralized logging systems (Splunk, ELK, CloudWatch, etc.)
   - Attackers who compromise adjacent systems
   - Insider threats
3. **Production Deployment**: These services run in production environments where logs are collected, aggregated, and accessible to multiple parties
4. **Long Exposure Window**: Credentials remain exposed in historical logs potentially for months or years depending on retention policies

## Recommendation

Implement proper credential sanitization following the existing pattern in `IndexerConfig`. The `RedisUrl` type should mask credentials in both `Display` and `Debug` implementations:

```rust
impl Display for RedisUrl {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        let mut sanitized_url = self.0.clone();
        if sanitized_url.password().is_some() {
            sanitized_url.set_password(Some("***")).ok();
        }
        write!(f, "{}", sanitized_url)
    }
}

impl Debug for RedisUrl {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        let mut sanitized_url = self.0.clone();
        if sanitized_url.password().is_some() {
            sanitized_url.set_password(Some("***")).ok();
        }
        f.debug_tuple("RedisUrl")
            .field(&sanitized_url.as_str())
            .finish()
    }
}
```

Additionally, remove or replace the direct `println!` statement with proper structured logging that sanitizes credentials.

## Proof of Concept

**Setup:**
1. Configure an indexer-grpc service with a Redis URL containing credentials: `redis://:secretpassword@localhost:6379`
2. Start the indexer-grpc-data-service

**Exploitation:**
1. The service automatically prints credentials to stdout during startup
2. If a connection error occurs, credentials are exposed in error messages
3. An attacker with access to application logs can extract: `redis://:secretpassword@localhost:6379`
4. Attacker uses extracted credentials to connect to Redis instance
5. Attacker can read cached transaction data or disrupt service by corrupting/deleting cache entries

**Rust Test to Demonstrate Exposure:**

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_redis_url_exposes_credentials() {
        let url_str = "redis://:mysecretpassword@localhost:6379/0";
        let redis_url = RedisUrl::from_str(url_str).unwrap();
        
        // Display trait exposes credentials
        let display_output = format!("{}", redis_url);
        assert!(display_output.contains("mysecretpassword"), 
                "Display should NOT contain password but does: {}", display_output);
        
        // Debug trait exposes credentials
        let debug_output = format!("{:?}", redis_url);
        assert!(debug_output.contains("mysecretpassword"),
                "Debug should NOT contain password but does: {}", debug_output);
    }
}
```

This test will pass, confirming that credentials are exposed through both `Display` and `Debug` formatting, demonstrating the vulnerability.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/types.rs (L13-14)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize)]
pub struct RedisUrl(pub Url);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/types.rs (L16-26)
```rust
impl FromStr for RedisUrl {
    type Err = anyhow::Error;

    fn from_str(s: &str) -> Result<Self, Self::Err> {
        let url = Url::parse(s)?;
        if url.scheme() != "redis" {
            return Err(anyhow::anyhow!("Invalid scheme: {}", url.scheme()));
        }
        Ok(RedisUrl(url))
    }
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/types.rs (L58-61)
```rust
impl Display for RedisUrl {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        write!(f, "{}", self.0)
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/config.rs (L162-165)
```rust
        println!(
            ">>>> Starting Redis connection: {:?}",
            &self.redis_read_replica_address.0
        );
```

**File:** ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs (L84-90)
```rust
        let redis_client = redis::Client::open(redis_main_instance_address.0.clone())
            .with_context(|| {
                format!(
                    "[Indexer Cache] Failed to create redis client for {}",
                    redis_main_instance_address
                )
            })?;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs (L110-113)
```rust
            redis_client: Arc::new(
                redis::Client::open(redis_address.0.clone()).with_context(|| {
                    format!("Failed to create redis client for {}", redis_address)
                })?,
```

**File:** ecosystem/indexer-grpc/indexer-grpc-file-store/src/processor.rs (L44-58)
```rust
        let conn = redis::Client::open(redis_main_instance_address.0.clone())
            .with_context(|| {
                format!(
                    "Create redis client for {} failed",
                    redis_main_instance_address.0
                )
            })?
            .get_tokio_connection_manager()
            .await
            .with_context(|| {
                format!(
                    "Create redis connection to {} failed.",
                    redis_main_instance_address.0
                )
            })?;
```

**File:** config/src/config/indexer_config.rs (L92-100)
```rust
impl Debug for IndexerConfig {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        let postgres_uri = self.postgres_uri.as_ref().map(|u| {
            let mut parsed_url = url::Url::parse(u).expect("Invalid postgres uri");
            if parsed_url.password().is_some() {
                parsed_url.set_password(Some("*")).unwrap();
            }
            parsed_url.to_string()
        });
```
