# Audit Report

## Title
Protocol Support Spoofing in Consensus Observer Peer Selection Enables Resource Exhaustion Attack

## Summary
A malicious peer can falsely claim support for Consensus Observer protocols during the network handshake to be selected as a subscription target by consensus observer nodes. This enables resource exhaustion attacks that degrade validator node performance and consensus observation capabilities without affecting core AptosBFT consensus safety.

## Finding Description

The Aptos network layer allows peers to self-declare supported protocols during the handshake phase without cryptographic verification. When a peer connects, it sends a `HandshakeMsg` containing a `ProtocolIdSet` bitfield claiming which application protocols it supports. [1](#0-0) 

This handshake negotiation process computes the intersection of supported protocols between peers but does not validate that a peer actually implements the protocols it claims to support. The negotiated protocols are stored in `ConnectionMetadata.application_protocols`: [2](#0-1) 

The Consensus Observer component, which allows non-validator nodes to observe consensus progress, relies on these self-declared protocol capabilities when selecting peers for subscriptions. The peer selection function explicitly filters peers based on protocol support: [3](#0-2) 

**Attack Path:**

1. Attacker establishes connection to a validator node running consensus observer
2. During handshake, attacker claims support for `ProtocolId::ConsensusObserver` and `ProtocolId::ConsensusObserverRpc` 
3. The connection is accepted with these protocols stored in peer metadata
4. When consensus observer sorts peers by optimality, attacker's peer passes the `supports_consensus_observer()` check
5. Attacker can manipulate perceived latency/distance metrics to be prioritized
6. Consensus observer subscribes to attacker's peer, consuming a limited subscription slot
7. Attacker can then:
   - Accept subscription but send no data (causing timeouts)
   - Accept subscription but send invalid data (rejected after signature verification, but wastes processing)
   - Reject subscription requests (causing continuous resubscription attempts)

While core AptosBFT consensus is unaffected (validators use `ValidatorVerifier` from `EpochState` to determine validator set, not protocol support checks), the Consensus Observer functionality can be severely degraded. [4](#0-3) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program's criteria for "Validator node slowdowns" and "Significant protocol violations."

**Impact on Validator Nodes:**
- Consensus observers running on validator infrastructure waste computational resources on failed subscription attempts
- Subscription slots (limited by `max_concurrent_subscriptions` configuration) can be saturated by malicious peers
- Continuous resubscription churn increases CPU and network overhead
- Delayed or missed consensus observations if all subscription slots target malicious peers

**Impact on Network:**
- Legitimate consensus observer peers may be crowded out by attackers claiming better metrics
- Coordinated attack with multiple malicious peers can completely deny consensus observer functionality
- Degrades decentralization by preventing non-validator nodes from reliably observing consensus

**Scope Limitation:**
Core consensus safety is preserved because:
- Validator message broadcasting uses `ValidatorVerifier`, not protocol support checks
- Block and vote signatures are cryptographically verified using epoch state
- Quorum certificate validation is independent of network protocol claims

## Likelihood Explanation

**Likelihood: High**

- **Attacker Requirements:** Minimal - only requires ability to establish network connection
- **Attack Complexity:** Low - simply requires modifying handshake message to claim protocol support
- **Detection Difficulty:** Medium - malicious peers appear as legitimate failed connections
- **Attack Prerequisites:** None - no validator credentials or stake required
- **Economic Cost:** Negligible - standard network connection overhead

The attack is particularly likely because:
1. No authentication beyond basic noise handshake is required
2. Protocol support is never validated post-handshake
3. Multiple attack vectors exist (non-response, invalid data, continuous rejection)
4. Coordinated attacks amplify impact significantly

## Recommendation

**Immediate Mitigation:**
Implement peer reputation tracking to deprioritize peers with high subscription failure rates and automatically ban peers that repeatedly fail consensus observer subscriptions.

**Long-term Fix:**
Add cryptographic proof-of-capability to protocol support claims. Options include:

1. **Challenge-Response Protocol:** After handshake, require peers to demonstrate protocol support by responding to a protocol-specific challenge before storing protocol support claims.

2. **Validator-Set Filtering:** For consensus-critical protocols like ConsensusObserver, restrict subscription targets to peers that are known validators or have cryptographic attestations from validators.

3. **Protocol Support Verification:** Implement periodic health checks that verify claimed protocol support remains valid, removing protocols from peer metadata if verification fails.

**Example Fix for Consensus Observer:**
```rust
// In consensus/src/consensus_observer/observer/subscription_utils.rs

fn sort_peers_by_subscription_optimality(
    peers_and_metadata: &HashMap<PeerNetworkId, PeerMetadata>,
) -> Vec<PeerNetworkId> {
    let mut peers_and_latencies_by_distance = BTreeMap::new();
    
    for (peer_network_id, peer_metadata) in peers_and_metadata {
        // Verify protocol support AND check if peer is a known validator
        // or has successful prior consensus observer interactions
        if !supports_consensus_observer(peer_metadata) {
            continue;
        }
        
        // NEW: Add reputation check
        if has_poor_subscription_reputation(peer_network_id) {
            continue; // Skip peers with history of failed subscriptions
        }
        
        // NEW: For validator networks, verify peer is in validator set
        if is_validator_network(peer_network_id.network_id()) 
            && !is_known_validator(peer_network_id) {
            continue; // Only subscribe to actual validators on validator network
        }
        
        // ... rest of sorting logic
    }
    // ...
}
```

## Proof of Concept

```rust
// Network test demonstrating protocol support spoofing
// File: network/framework/src/application/storage_test.rs

#[tokio::test]
async fn test_protocol_support_spoofing_consensus_observer() {
    use crate::protocols::wire::handshake::v1::{ProtocolId, ProtocolIdSet};
    use aptos_config::network_id::NetworkId;
    use aptos_types::PeerId;
    
    // Create a malicious peer claiming consensus observer support
    let malicious_peer_id = PeerId::random();
    let mut malicious_protocols = ProtocolIdSet::empty();
    malicious_protocols.insert(ProtocolId::ConsensusObserver);
    malicious_protocols.insert(ProtocolId::ConsensusObserverRpc);
    
    // Create peers and metadata storage
    let peers_and_metadata = Arc::new(PeersAndMetadata::new(&[NetworkId::Validator]));
    
    // Simulate handshake completion with malicious peer
    let connection_metadata = ConnectionMetadata::new(
        malicious_peer_id,
        ConnectionId::default(),
        NetworkAddress::mock(),
        ConnectionOrigin::Inbound,
        MessagingProtocolVersion::V1,
        malicious_protocols.clone(), // Malicious peer claims protocols it doesn't support
        PeerRole::Unknown,
    );
    
    // Insert the malicious peer connection
    let peer_network_id = PeerNetworkId::new(NetworkId::Validator, malicious_peer_id);
    peers_and_metadata
        .insert_connection_metadata(peer_network_id, connection_metadata)
        .unwrap();
    
    // Query for peers supporting consensus observer protocols
    let consensus_observer_protocols = vec![
        ProtocolId::ConsensusObserver,
        ProtocolId::ConsensusObserverRpc,
    ];
    
    let available_peers = peers_and_metadata
        .get_connected_supported_peers(&consensus_observer_protocols)
        .unwrap();
    
    // Verify malicious peer is included despite not actually supporting the protocols
    assert!(available_peers.contains(&peer_network_id));
    
    // This malicious peer would be selected for consensus observer subscriptions
    // and could waste subscription slots, cause timeouts, or force resubscriptions
}
```

**Notes:**
- The vulnerability does not affect core consensus safety as validators use `ValidatorVerifier` from on-chain epoch state, not network protocol claims
- The issue specifically impacts Consensus Observer functionality which relies on protocol support filtering for peer selection
- While data integrity is protected by signature verification, resource exhaustion and performance degradation are realistic attack outcomes

### Citations

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L428-465)
```rust
    /// This function:
    /// 1. verifies that both HandshakeMsg are compatible and
    /// 2. finds out the intersection of protocols that is supported
    pub fn perform_handshake(
        &self,
        other: &HandshakeMsg,
    ) -> Result<(MessagingProtocolVersion, ProtocolIdSet), HandshakeError> {
        // verify that both peers are on the same chain
        if self.chain_id != other.chain_id {
            return Err(HandshakeError::InvalidChainId(
                other.chain_id,
                self.chain_id,
            ));
        }

        // verify that both peers are on the same network
        if self.network_id != other.network_id {
            return Err(HandshakeError::InvalidNetworkId(
                other.network_id,
                self.network_id,
            ));
        }

        // find the greatest common MessagingProtocolVersion where we both support
        // at least one common ProtocolId.
        for (our_handshake_version, our_protocols) in self.supported_protocols.iter().rev() {
            if let Some(their_protocols) = other.supported_protocols.get(our_handshake_version) {
                let common_protocols = our_protocols.intersect(their_protocols);

                if !common_protocols.is_empty() {
                    return Ok((*our_handshake_version, common_protocols));
                }
            }
        }

        // no intersection found
        Err(HandshakeError::NoCommonProtocols)
    }
```

**File:** network/framework/src/transport/mod.rs (L298-331)
```rust
    let handshake_msg = HandshakeMsg {
        supported_protocols: ctxt.supported_protocols.clone(),
        chain_id: ctxt.chain_id,
        network_id: ctxt.network_id,
    };
    let remote_handshake = exchange_handshake(&handshake_msg, &mut socket)
        .await
        .map_err(|err| add_pp_addr(proxy_protocol_enabled, err, &addr))?;

    // try to negotiate common aptosnet version and supported application protocols
    let (messaging_protocol, application_protocols) = handshake_msg
        .perform_handshake(&remote_handshake)
        .map_err(|err| {
            let err = format!(
                "handshake negotiation with peer {} failed: {}",
                remote_peer_id.short_str(),
                err
            );
            add_pp_addr(proxy_protocol_enabled, io::Error::other(err), &addr)
        })?;

    // return successful connection
    Ok(Connection {
        socket,
        metadata: ConnectionMetadata::new(
            remote_peer_id,
            CONNECTION_ID_GENERATOR.next(),
            addr,
            origin,
            messaging_protocol,
            application_protocols,
            peer_role,
        ),
    })
```

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L283-356)
```rust
pub fn sort_peers_by_subscription_optimality(
    peers_and_metadata: &HashMap<PeerNetworkId, PeerMetadata>,
) -> Vec<PeerNetworkId> {
    // Group peers and latencies by validator distance, i.e., distance -> [(peer, latency)]
    let mut unsupported_peers = Vec::new();
    let mut peers_and_latencies_by_distance = BTreeMap::new();
    for (peer_network_id, peer_metadata) in peers_and_metadata {
        // Verify that the peer supports consensus observer
        if !supports_consensus_observer(peer_metadata) {
            unsupported_peers.push(*peer_network_id);
            continue; // Skip the peer
        }

        // Get the distance and latency for the peer
        let distance = get_distance_for_peer(peer_network_id, peer_metadata);
        let latency = get_latency_for_peer(peer_network_id, peer_metadata);

        // If the distance is not found, use the maximum distance
        let distance =
            distance.unwrap_or(aptos_peer_monitoring_service_types::MAX_DISTANCE_FROM_VALIDATORS);

        // If the latency is not found, use a large latency
        let latency = latency.unwrap_or(MAX_PING_LATENCY_SECS);

        // Add the peer and latency to the distance group
        peers_and_latencies_by_distance
            .entry(distance)
            .or_insert_with(Vec::new)
            .push((*peer_network_id, OrderedFloat(latency)));
    }

    // If there are peers that don't support consensus observer, log them
    if !unsupported_peers.is_empty() {
        info!(
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Found {} peers that don't support consensus observer! Peers: {:?}",
                unsupported_peers.len(),
                unsupported_peers
            ))
        );
    }

    // Sort the peers by distance and latency. Note: BTreeMaps are
    // sorted by key, so the entries will be sorted by distance in ascending order.
    let mut sorted_peers_and_latencies = Vec::new();
    for (_, mut peers_and_latencies) in peers_and_latencies_by_distance {
        // Sort the peers by latency
        peers_and_latencies.sort_by_key(|(_, latency)| *latency);

        // Add the peers to the sorted list (in sorted order)
        sorted_peers_and_latencies.extend(peers_and_latencies);
    }

    // Log the sorted peers and latencies
    info!(
        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
            "Sorted {} peers by subscription optimality! Peers and latencies: {:?}",
            sorted_peers_and_latencies.len(),
            sorted_peers_and_latencies
        ))
    );

    // Only return the sorted peers (without the latencies)
    sorted_peers_and_latencies
        .into_iter()
        .map(|(peer, _)| peer)
        .collect()
}

/// Returns true iff the peer metadata indicates support for consensus observer
fn supports_consensus_observer(peer_metadata: &PeerMetadata) -> bool {
    peer_metadata.supports_protocol(ProtocolId::ConsensusObserver)
        && peer_metadata.supports_protocol(ProtocolId::ConsensusObserverRpc)
}
```

**File:** consensus/src/network.rs (L387-400)
```rust
    pub fn broadcast_without_self(&self, msg: ConsensusMsg) {
        fail_point!("consensus::send::any", |_| ());

        let self_author = self.author;
        let mut other_validators: Vec<_> = self
            .validators
            .get_ordered_account_addresses_iter()
            .filter(|author| author != &self_author)
            .collect();
        self.sort_peers_by_latency(&mut other_validators);

        counters::CONSENSUS_SENT_MSGS
            .with_label_values(&[msg.name()])
            .inc_by(other_validators.len() as u64);
```
