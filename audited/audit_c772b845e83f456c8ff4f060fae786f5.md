# Audit Report

## Title
Network Identity Private Key Leakage via Telemetry Node Configuration Events

## Summary
The telemetry service periodically serializes and transmits the entire `NodeConfig` to the telemetry service using JSON serialization. When a validator or fullnode is configured with `Identity::FromConfig` (which embeds network private keys directly in the configuration), these private keys are serialized as hex-encoded strings and transmitted to the telemetry service every hour, bypassing the `SilentDebug`/`SilentDisplay` protection mechanisms designed to prevent key leakage.

## Finding Description
The Aptos telemetry system includes a mechanism to protect sensitive cryptographic material from accidental exposure. Private keys like `x25519::PrivateKey` are marked with the `SilentDebug` and `SilentDisplay` derive macros, which replace the actual key value with `<elided secret for PrivateKey>` when using Debug or Display formatting. [1](#0-0) 

The inspection service correctly leverages this protection by using Debug formatting when exposing node configuration: [2](#0-1) 

However, the telemetry service's `send_node_config` function bypasses this protection by using JSON serialization instead of Debug formatting: [3](#0-2) 

When `serde_json::to_value()` is called, it uses the `Serialize` trait implementation, not the `Debug` trait. The `x25519::PrivateKey` type uses the `SerializeKey` derive macro, which serializes keys as hex-encoded strings when using human-readable serialization (like JSON): [4](#0-3) 

When a node is configured with `Identity::FromConfig`, the private key is stored inline in the `IdentityFromConfig` struct within a `ConfigKey` wrapper: [5](#0-4) 

The `ConfigKey` type directly serializes the wrapped private key: [6](#0-5) 

This configuration is sent to the telemetry service every hour: [7](#0-6) [8](#0-7) 

The telemetry data is transmitted to external servers controlled by Aptos Foundation: [9](#0-8) 

**Attack Scenario:**
1. A validator/fullnode operator configures their node with `Identity::FromConfig` for their validator network or VFN (Validator Full Node) network
2. Telemetry is enabled by default (unless `APTOS_DISABLE_TELEMETRY` environment variable is set)
3. Every hour, the `send_node_config` function serializes the entire `NodeConfig` including the `x25519::PrivateKey` as a hex string
4. This data is sent to the telemetry service via `post_custom_metrics()`
5. An attacker who compromises the telemetry service infrastructure or performs a MITM attack can extract these private keys
6. With the network private key, an attacker can impersonate the validator/node in network communications

## Impact Explanation
This vulnerability meets **Medium Severity** criteria per the Aptos bug bounty program:

- **Limited Information Leak**: Network private keys are exposed to the telemetry service
- **State Inconsistencies**: While not directly causing state inconsistencies, compromised network keys could enable attacks on validator communication
- **Scope**: While production validators are recommended to use `Identity::FromStorage` or `Identity::FromFile` for their main validator network, VFN (Validator Full Node) networks commonly use `Identity::FromConfig` even in production deployments [10](#0-9) 

The impact is not Critical because:
- It requires compromise of the telemetry service or MITM position
- It doesn't directly enable fund theft or consensus violations
- Validators can disable telemetry or use secure identity storage methods

However, it represents a significant security weakness as it violates the principle of least privilege and bypasses intentional protection mechanisms.

## Likelihood Explanation
**Likelihood: Medium to High**

**Factors increasing likelihood:**
1. Telemetry is enabled by default unless explicitly disabled
2. VFN networks commonly use `Identity::FromConfig` in production configurations
3. Operators may not be aware that their configuration (including keys) is being transmitted
4. The leak occurs automatically every hour without operator knowledge or intervention
5. No warnings exist in the code or documentation about this behavior

**Factors decreasing likelihood:**
1. Production validator consensus networks are recommended to use `Identity::FromStorage` or `Identity::FromFile`
2. The telemetry service is operated by Aptos Foundation (a trusted entity)
3. Communications use HTTPS encryption
4. Operators can disable telemetry via environment variable

## Recommendation

**Immediate Fix:**
Use Debug formatting instead of JSON serialization for node configuration telemetry, matching the pattern used by the inspection service:

```rust
async fn send_node_config(
    peer_id: String,
    chain_id: String,
    node_config: &NodeConfig,
    telemetry_sender: Option<TelemetrySender>,
) {
    // Use Debug formatting to respect SilentDebug/SilentDisplay markers
    let config_debug_string = format!("{:?}", node_config);
    
    let mut params = BTreeMap::new();
    params.insert("config".to_string(), config_debug_string);
    
    let telemetry_event = TelemetryEvent {
        name: APTOS_NODE_CONFIG_EVENT_NAME.into(),
        params,
    };
    prepare_and_send_telemetry_event(peer_id, chain_id, telemetry_sender, telemetry_event).await;
}
```

**Long-term Solutions:**
1. Implement a configuration sanitizer that explicitly filters sensitive fields before serialization
2. Add compiler warnings or runtime checks when `Identity::FromConfig` is used with telemetry enabled
3. Document the privacy implications of telemetry in node operator guides
4. Consider making telemetry opt-in rather than opt-out for production deployments

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_config::config::{Identity, NetworkConfig, NodeConfig};
    use aptos_crypto::{x25519, Uniform};
    use aptos_types::chain_id::ChainId;
    use std::collections::BTreeMap;

    #[test]
    fn test_node_config_serialization_leaks_private_key() {
        // Generate a test private key
        let mut rng = rand::thread_rng();
        let private_key = x25519::PrivateKey::generate(&mut rng);
        let peer_id = aptos_types::account_address::from_identity_public_key(
            private_key.public_key()
        );
        
        // Create a NodeConfig with Identity::FromConfig
        let mut node_config = NodeConfig::default();
        let mut network_config = NetworkConfig::network_with_id(
            aptos_types::network_id::NetworkId::Validator
        );
        network_config.identity = Identity::from_config(private_key.clone(), peer_id);
        node_config.validator_network = Some(network_config);
        
        // Simulate what send_node_config does
        let node_config_json = serde_json::to_value(&node_config)
            .expect("Failed to serialize node config");
        
        // Convert to string map as done in send_node_config
        let node_config_map: BTreeMap<String, String> = node_config_json
            .as_object()
            .map(|obj| {
                obj.into_iter()
                    .map(|(k, v)| (k.clone(), v.to_string()))
                    .collect()
            })
            .unwrap_or_default();
        
        // Verify that the serialized config contains the private key
        let serialized = serde_json::to_string(&node_config_map).unwrap();
        
        // The private key should be in the serialized output as hex
        let private_key_hex = hex::encode(private_key.to_bytes());
        assert!(
            serialized.contains(&private_key_hex),
            "Private key was not found in serialized config - VULNERABILITY NOT PRESENT"
        );
        
        // Verify that Debug formatting does NOT leak the key
        let debug_output = format!("{:?}", node_config);
        assert!(
            !debug_output.contains(&private_key_hex),
            "Debug formatting should not contain private key"
        );
        assert!(
            debug_output.contains("<elided secret for PrivateKey>"),
            "Debug formatting should show elided message"
        );
        
        println!("VULNERABILITY CONFIRMED:");
        println!("- JSON serialization exposes private key: {}", private_key_hex);
        println!("- Debug formatting correctly elides it");
    }
}
```

**Notes:**
- This vulnerability affects nodes using `Identity::FromConfig` for network configuration
- While `Identity::FromStorage` and `Identity::FromFile` are safe (they only serialize references, not keys), `Identity::FromConfig` is commonly used for VFN networks
- The telemetry transmission occurs automatically via authenticated HTTPS to Aptos-controlled servers
- Operators can disable telemetry by setting `APTOS_DISABLE_TELEMETRY=true` environment variable
- The vulnerability bypasses the intentional `SilentDebug`/`SilentDisplay` protection mechanisms designed to prevent key leakage

### Citations

**File:** crates/aptos-crypto-derive/src/lib.rs (L128-143)
```rust
#[proc_macro_derive(SilentDebug)]
pub fn silent_debug(source: TokenStream) -> TokenStream {
    let ast: DeriveInput = syn::parse(source).expect("Incorrect macro input");
    let name = &ast.ident;
    let (impl_generics, ty_generics, where_clause) = ast.generics.split_for_impl();

    quote! {
        // In order to ensure that secrets are never leaked, Debug is elided
        impl #impl_generics ::std::fmt::Debug for #name #ty_generics #where_clause {
            fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
                write!(f, "<elided secret for {}>", stringify!(#name))
            }
        }
    }
    .into()
}
```

**File:** crates/aptos-crypto-derive/src/lib.rs (L185-210)
```rust
#[proc_macro_derive(SerializeKey)]
pub fn serialize_key(source: TokenStream) -> TokenStream {
    let ast: DeriveInput = syn::parse(source).expect("Incorrect macro input");
    let name = &ast.ident;
    let name_string = find_key_name(&ast, name.to_string());
    quote! {
        impl ::serde::Serialize for #name {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: ::serde::Serializer,
            {
                if serializer.is_human_readable() {
                    self.to_encoded_string()
                        .map_err(<S::Error as ::serde::ser::Error>::custom)
                        .and_then(|str| serializer.serialize_str(&str[..]))
                } else {
                    // See comment in deserialize_key.
                    serializer.serialize_newtype_struct(
                        #name_string,
                        serde_bytes::Bytes::new(&ValidCryptoMaterial::to_bytes(self).as_slice()),
                    )
                }
            }
        }
    }
    .into()
```

**File:** crates/aptos-inspection-service/src/server/configuration.rs (L16-19)
```rust
        // We format the configuration using debug formatting. This is important to
        // prevent secret/private keys from being serialized and leaked (i.e.,
        // all secret keys are marked with SilentDisplay and SilentDebug).
        let encoded_configuration = format!("{:?}", node_config);
```

**File:** crates/aptos-telemetry/src/service.rs (L348-355)
```rust
        run_function_periodically(NODE_CONFIG_FREQ_SECS, || {
            send_node_config(
                peer_id.clone(),
                chain_id.to_string(),
                &node_config,
                telemetry_sender.clone(),
            )
        }),
```

**File:** crates/aptos-telemetry/src/service.rs (L378-389)
```rust
    let node_config: BTreeMap<String, String> = serde_json::to_value(node_config)
        .map(|value| {
            value
                .as_object()
                .map(|obj| {
                    obj.into_iter()
                        .map(|(k, v)| (k.clone(), v.to_string()))
                        .collect::<BTreeMap<String, String>>()
                })
                .unwrap_or_default()
        })
        .unwrap_or_default();
```

**File:** config/src/config/identity_config.rs (L130-139)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IdentityFromConfig {
    #[serde(flatten)]
    pub key: ConfigKey<x25519::PrivateKey>,
    pub peer_id: PeerId,

    #[serde(skip)]
    pub source: IdentitySource,
}
```

**File:** config/src/keys.rs (L25-29)
```rust
#[derive(Debug, Deserialize, Serialize)]
pub struct ConfigKey<T: PrivateKey + Serialize> {
    #[serde(bound(deserialize = "T: Deserialize<'de>"))]
    key: T,
}
```

**File:** crates/aptos-telemetry/src/constants.rs (L31-32)
```rust
pub(crate) const TELEMETRY_SERVICE_URL: &str = "https://telemetry.aptoslabs.com";
pub(crate) const MAINNET_TELEMETRY_SERVICE_URL: &str = "https://telemetry.mainnet.aptoslabs.com";
```

**File:** crates/aptos-telemetry/src/constants.rs (L39-39)
```rust
pub(crate) const NODE_CONFIG_FREQ_SECS: u64 = 60 * 60; // 60 minutes
```

**File:** docker/compose/aptos-node/validator.yaml (L1-1)
```yaml
base:
```
