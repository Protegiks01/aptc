# Audit Report

## Title
Pre-Committed State Exposure via Unbounded Version Queries in State Sync Protocol

## Summary
The `get_state_value_by_version()` function and related state retrieval methods can return pre-committed state values that haven't been consensus-certified. This occurs because version bounds are not validated against the latest committed version, allowing malicious peers to request and receive state data that may later be rolled back during crash recovery.

## Finding Description

The Aptos storage layer uses a two-phase commit process where consensus first pre-commits transactions to the database, then certifies them with a `LedgerInfoWithSignatures`. During the window between these phases, pre-committed state exists in storage but lacks consensus certification.

**The vulnerability chain:**

1. **Storage Read Path Missing Certification Check**: The `get_state_value_by_version()` function only validates that the requested version hasn't been pruned, but doesn't check if it exceeds the latest committed (certified) version. [1](#0-0) 

The function only calls `error_if_state_kv_pruned()` which checks the lower bound: [2](#0-1) 

2. **Pre-Committed Data in Storage**: When consensus pre-commits a block, data is written to RocksDB immediately, before certification: [3](#0-2) 

3. **State Sync Protocol Accepts Arbitrary Versions**: The storage service handler processes state sync requests without validating the requested version against the latest certified version: [4](#0-3) 

4. **Crash Recovery Truncates Pre-Committed Data**: During restart, pre-committed data that exceeds the overall commit progress is truncated, proving it's not guaranteed to persist: [5](#0-4) 

**Attack Scenario:**

1. Node pre-commits block at version V+1 (writes to RocksDB but no LedgerInfo yet)
2. Malicious peer sends `StateValuesWithProofRequest` with version=V+1
3. Storage service processes request without checking V+1 > latest_committed_version
4. Peer receives state values that haven't been consensus-certified
5. If consensus later rejects the block (network partition, Byzantine behavior), the state is rolled back but the peer already observed it

## Impact Explanation

This is a **Critical** severity vulnerability under the Aptos bug bounty criteria:

- **Consensus Safety Violation**: Violates the fundamental invariant that only consensus-certified state should be externally visible. This breaks the "State Consistency" and "Consensus Safety" critical invariants.

- **Information Leakage**: Exposes uncommitted state that may contain sensitive data or intermediate computational results that were never intended to be public.

- **State Inconsistency**: Nodes could make decisions based on state values that are later rolled back, leading to divergent network behavior.

- **Potential Chain Split**: If different nodes observe different pre-committed states (due to selective exposure or timing), they could develop inconsistent views of the ledger.

While the API layer includes version bounds checking for external clients [6](#0-5) , the state sync protocol serves requests from network peers without this protection.

## Likelihood Explanation

**Likelihood: Medium-High**

- **Attack Complexity**: Low - A malicious peer only needs to send crafted state sync requests with version numbers slightly ahead of the committed version
- **Detection**: The timing window between pre-commit and commit is narrow (typically milliseconds) but predictable based on network observation
- **Prerequisites**: Attacker must be a network peer, which is permissionless in Aptos
- **Automation**: Easily automated to continuously probe for pre-committed versions

The attack is feasible because:
1. State sync storage service is exposed to all network peers
2. No authentication or authorization beyond network connectivity
3. Version numbers are sequential and predictable
4. Pre-commit timing is observable through network monitoring

## Recommendation

**Immediate Fix**: Add upper-bound version validation to all state query functions:

```rust
// In storage/aptosdb/src/db/aptosdb_reader.rs
fn get_state_value_by_version(
    &self,
    state_store_key: &StateKey,
    version: Version,
) -> Result<Option<StateValue>> {
    gauged_api("get_state_value_by_version", || {
        self.error_if_state_kv_pruned("StateValue", version)?;
        
        // NEW: Check upper bound against latest committed version
        let latest_committed = self.get_latest_ledger_info_version()?;
        ensure!(
            version <= latest_committed,
            "Requested version {} exceeds latest committed version {}",
            version,
            latest_committed
        );
        
        self.state_store
            .get_state_value_by_version(state_store_key, version)
    })
}
```

Apply the same fix to:
- `get_state_value_with_version_by_version()`
- `get_state_value_chunk_with_proof()`
- `get_state_value_chunk_iter()`
- All related state query functions

**Defense in Depth**: 
1. Add version validation at the state sync handler level before delegating to storage
2. Include the latest committed version in the storage service's data summary and enforce it as a hard limit
3. Add monitoring/alerting for requests exceeding committed versions

## Proof of Concept

```rust
// Integration test demonstrating the vulnerability
#[tokio::test]
async fn test_pre_committed_state_exposure() {
    // Setup: Create a test node with storage and consensus
    let (mut node, storage) = setup_test_node().await;
    
    // Step 1: Pre-commit block at version 101
    let block = create_test_block(101);
    storage.pre_commit_ledger(block.to_chunk(), false).unwrap();
    
    // Verify: Version 101 is pre-committed but not certified
    assert!(storage.get_pre_committed_version().unwrap() == Some(101));
    assert!(storage.get_latest_ledger_info_version().unwrap() == 100);
    
    // Step 2: Malicious peer requests state at version 101 (pre-committed)
    let state_key = StateKey::resource(&test_address(), &test_struct_tag()).unwrap();
    
    // This should FAIL but currently SUCCEEDS
    let result = storage.get_state_value_by_version(&state_key, 101);
    
    // Bug: Returns pre-committed state without checking certification
    assert!(result.is_ok());
    let state_value = result.unwrap();
    assert!(state_value.is_some()); // Pre-committed state is exposed!
    
    // Step 3: Simulate crash - pre-committed data gets truncated
    drop(storage);
    let storage = reopen_storage().await;
    
    // After recovery, version 101 is gone (rolled back)
    assert!(storage.get_latest_ledger_info_version().unwrap() == 100);
    
    // The state value that was exposed is now invalid
    println!("Pre-committed state was exposed but later rolled back!");
}
```

**Notes**

This vulnerability exists because the storage layer trusts all callers to only request committed versions. While the public REST API validates this assumption, the state sync protocol serving network peers does not. The fix requires adding certification checks at the storage layer to make it robust against untrusted callers.

The issue is particularly concerning because state sync is fundamental to node operation and security - nodes must trust the state they receive to bootstrap and stay synchronized. Exposing non-certified state undermines this trust model.

### Citations

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L631-642)
```rust
    fn get_state_value_by_version(
        &self,
        state_store_key: &StateKey,
        version: Version,
    ) -> Result<Option<StateValue>> {
        gauged_api("get_state_value_by_version", || {
            self.error_if_state_kv_pruned("StateValue", version)?;

            self.state_store
                .get_state_value_by_version(state_store_key, version)
        })
    }
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L305-315)
```rust
    pub(super) fn error_if_state_kv_pruned(&self, data_type: &str, version: Version) -> Result<()> {
        let min_readable_version = self.state_store.state_kv_pruner.get_min_readable_version();
        ensure!(
            version >= min_readable_version,
            "{} at version {} is pruned, min available version is {}.",
            data_type,
            version,
            min_readable_version
        );
        Ok(())
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L44-76)
```rust
    fn pre_commit_ledger(&self, chunk: ChunkToCommit, sync_commit: bool) -> Result<()> {
        gauged_api("pre_commit_ledger", || {
            // Pre-committing and committing in concurrency is allowed but not pre-committing at the
            // same time from multiple threads, the same for committing.
            // Consensus and state sync must hand over to each other after all pending execution and
            // committing complete.
            let _lock = self
                .pre_commit_lock
                .try_lock()
                .expect("Concurrent committing detected.");
            let _timer = OTHER_TIMERS_SECONDS.timer_with(&["pre_commit_ledger"]);

            chunk
                .state_summary
                .latest()
                .global_state_summary
                .log_generation("db_save");

            self.pre_commit_validation(&chunk)?;
            let _new_root_hash =
                self.calculate_and_commit_ledger_and_state_kv(&chunk, self.skip_index_and_usage)?;

            let _timer = OTHER_TIMERS_SECONDS.timer_with(&["save_transactions__others"]);

            self.state_store.buffered_state().lock().update(
                chunk.result_ledger_state_with_summary(),
                chunk.estimated_total_state_updates(),
                sync_commit || chunk.is_reconfig,
            )?;

            Ok(())
        })
    }
```

**File:** state-sync/storage-service/server/src/handler.rs (L463-476)
```rust
    fn get_state_value_chunk_with_proof(
        &self,
        request: &StateValuesWithProofRequest,
    ) -> aptos_storage_service_types::Result<DataResponse, Error> {
        let state_value_chunk_with_proof = self.storage.get_state_value_chunk_with_proof(
            request.version,
            request.start_index,
            request.end_index,
        )?;

        Ok(DataResponse::StateValueChunkWithProof(
            state_value_chunk_with_proof,
        ))
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L408-502)
```rust
    // We commit the overall commit progress at the last, and use it as the source of truth of the
    // commit progress.
    pub fn sync_commit_progress(
        ledger_db: Arc<LedgerDb>,
        state_kv_db: Arc<StateKvDb>,
        state_merkle_db: Arc<StateMerkleDb>,
        crash_if_difference_is_too_large: bool,
    ) {
        let ledger_metadata_db = ledger_db.metadata_db();
        if let Some(overall_commit_progress) = ledger_metadata_db
            .get_synced_version()
            .expect("DB read failed.")
        {
            info!(
                overall_commit_progress = overall_commit_progress,
                "Start syncing databases..."
            );
            let ledger_commit_progress = ledger_metadata_db
                .get_ledger_commit_progress()
                .expect("Failed to read ledger commit progress.");
            assert_ge!(ledger_commit_progress, overall_commit_progress);

            let state_kv_commit_progress = state_kv_db
                .metadata_db()
                .get::<DbMetadataSchema>(&DbMetadataKey::StateKvCommitProgress)
                .expect("Failed to read state K/V commit progress.")
                .expect("State K/V commit progress cannot be None.")
                .expect_version();
            assert_ge!(state_kv_commit_progress, overall_commit_progress);

            // LedgerCommitProgress was not guaranteed to commit after all ledger changes finish,
            // have to attempt truncating every column family.
            info!(
                ledger_commit_progress = ledger_commit_progress,
                "Attempt ledger truncation...",
            );
            let difference = ledger_commit_progress - overall_commit_progress;
            if crash_if_difference_is_too_large {
                assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
            }
            truncate_ledger_db(ledger_db.clone(), overall_commit_progress)
                .expect("Failed to truncate ledger db.");

            // State K/V commit progress isn't (can't be) written atomically with the data,
            // because there are shards, so we have to attempt truncation anyway.
            info!(
                state_kv_commit_progress = state_kv_commit_progress,
                "Start state KV truncation..."
            );
            let difference = state_kv_commit_progress - overall_commit_progress;
            if crash_if_difference_is_too_large {
                assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
            }
            truncate_state_kv_db(
                &state_kv_db,
                state_kv_commit_progress,
                overall_commit_progress,
                std::cmp::max(difference as usize, 1), /* batch_size */
            )
            .expect("Failed to truncate state K/V db.");

            let state_merkle_max_version = get_max_version_in_state_merkle_db(&state_merkle_db)
                .expect("Failed to get state merkle max version.")
                .expect("State merkle max version cannot be None.");
            if state_merkle_max_version > overall_commit_progress {
                let difference = state_merkle_max_version - overall_commit_progress;
                if crash_if_difference_is_too_large {
                    assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
                }
            }
            let state_merkle_target_version = find_tree_root_at_or_before(
                ledger_metadata_db,
                &state_merkle_db,
                overall_commit_progress,
            )
            .expect("DB read failed.")
            .unwrap_or_else(|| {
                panic!(
                    "Could not find a valid root before or at version {}, maybe it was pruned?",
                    overall_commit_progress
                )
            });
            if state_merkle_target_version < state_merkle_max_version {
                info!(
                    state_merkle_max_version = state_merkle_max_version,
                    target_version = state_merkle_target_version,
                    "Start state merkle truncation..."
                );
                truncate_state_merkle_db(&state_merkle_db, state_merkle_target_version)
                    .expect("Failed to truncate state merkle db.");
            }
        } else {
            info!("No overall commit progress was found!");
        }
    }
```

**File:** api/src/context.rs (L294-317)
```rust
    pub fn get_latest_ledger_info_and_verify_lookup_version<E: StdApiError>(
        &self,
        requested_ledger_version: Option<Version>,
    ) -> Result<(LedgerInfo, Version), E> {
        let latest_ledger_info = self.get_latest_ledger_info()?;

        let requested_ledger_version =
            requested_ledger_version.unwrap_or_else(|| latest_ledger_info.version());

        // This is too far in the future, a retriable case
        if requested_ledger_version > latest_ledger_info.version() {
            return Err(version_not_found(
                requested_ledger_version,
                &latest_ledger_info,
            ));
        } else if requested_ledger_version < latest_ledger_info.oldest_ledger_version.0 {
            return Err(version_pruned(
                requested_ledger_version,
                &latest_ledger_info,
            ));
        }

        Ok((latest_ledger_info, requested_ledger_version))
    }
```
