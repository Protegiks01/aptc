# Audit Report

## Title
OnDiskStorage Not Blocked by Config Sanitizer for Mainnet Validators Despite Inadequate Security

## Summary
The configuration sanitizer that protects mainnet validators from using insecure storage backends only checks for `InMemoryStorage`, but fails to check for `OnDiskStorage`. This allows validators to be deployed on mainnet with consensus private keys stored in plaintext JSON files on disk, violating the same security guarantees that the existing `InMemoryStorage` check is designed to enforce.

## Finding Description

The `SafetyRulesConfig` sanitizer enforces security requirements for mainnet validators, including blocking the use of `InMemoryStorage` for storing consensus private keys. However, it fails to apply the same check to `OnDiskStorage`, which has identical security deficiencies. [1](#0-0) 

The sanitizer only calls `backend.is_in_memory()`, which exclusively checks for `SecureBackend::InMemoryStorage`: [2](#0-1) 

Both `InMemoryStorage` and `OnDiskStorage` are explicitly documented as unsuitable for production use: [3](#0-2) [4](#0-3) 

The README confirms that only Vault should be used in production: [5](#0-4) 

When `OnDiskStorage` is used, the consensus private key is stored unencrypted: [6](#0-5) 

The key is stored using `CONSENSUS_KEY` constant and written to disk as plain JSON: [7](#0-6) 

Notably, production-adjacent configurations (Terraform/Helm) actually default to `OnDiskStorage`: [8](#0-7) [9](#0-8) 

Additionally, the sanitizer can be completely bypassed via configuration: [10](#0-9) [11](#0-10) 

## Impact Explanation

**HIGH Severity** - This qualifies as a "Significant protocol violation" under the Aptos Bug Bounty program.

The vulnerability enables:
1. **Consensus Private Key Exposure**: The BLS12-381 consensus private key is written to disk in plaintext JSON format, readable by anyone with filesystem access
2. **Validator Impersonation**: An attacker who obtains the private key can sign consensus votes as that validator
3. **Consensus Safety Violation**: Stolen keys enable equivocation attacks and potential safety violations
4. **Defense Mechanism Failure**: The sanitizer successfully blocks `InMemoryStorage` but inconsistently allows `OnDiskStorage` despite equivalent security deficiencies

This breaks the **Cryptographic Correctness** invariant: "BLS signatures, VRF, and hash operations must be secure" - the private key securing BLS signatures is exposed in plaintext.

## Likelihood Explanation

**Medium-to-High Likelihood:**

1. **Configuration Error Scenario**: Production validator operators may follow Terraform/Helm examples that use `OnDiskStorage` by default, believing the sanitizer would catch security issues
2. **No Runtime Warnings**: Unlike compile-time features, there are no warnings when `OnDiskStorage` is instantiated
3. **Filesystem Access**: Attackers can gain filesystem access through:
   - Compromised backup systems or cloud storage
   - Container escape vulnerabilities
   - Node software vulnerabilities (RCE, path traversal)
   - Misconfigured permissions on shared hosting
   - Physical access to inadequately secured hardware

4. **Sanitizer Bypass**: Operators troubleshooting startup issues might set `skip_config_sanitizer: true`, disabling ALL security checks

The inconsistency between blocking `InMemoryStorage` but allowing `OnDiskStorage` creates a false sense of security, as operators may assume all insecure configurations are caught.

## Recommendation

**Fix 1: Extend the sanitizer to check OnDiskStorage**

Add a check in `SafetyRulesConfig::sanitize()`:

```rust
// In config/src/config/safety_rules_config.rs, around line 96
if chain_id.is_mainnet()
    && node_type.is_validator()
    && (safety_rules_config.backend.is_in_memory() 
        || safety_rules_config.backend.is_on_disk())
{
    return Err(Error::ConfigSanitizerFailed(
        sanitizer_name,
        "The secure backend must use Vault for mainnet validators, not in-memory or on-disk storage!".to_string(),
    ));
}
```

Add the helper method to `SecureBackend`:

```rust
// In config/src/config/secure_backend_config.rs, after line 48
pub fn is_on_disk(&self) -> bool {
    matches!(self, SecureBackend::OnDiskStorage(_))
}
```

**Fix 2: Add runtime warnings in OnDiskStorage::new()**

```rust
// In secure/storage/src/on_disk.rs, in new() method
pub fn new(file_path: PathBuf) -> Self {
    warn!(
        "OnDiskStorage initialized at {:?}. This storage backend provides NO ENCRYPTION \
        and should NEVER be used in production validator deployments. Use VaultStorage instead.",
        file_path
    );
    Self::new_with_time_service(file_path, TimeService::real())
}
```

**Fix 3: Prevent sanitizer bypass on mainnet**

```rust
// In config/src/config/config_sanitizer.rs, line 46
if node_config.node_startup.skip_config_sanitizer {
    if let Some(chain_id) = chain_id {
        if chain_id.is_mainnet() {
            return Err(Error::ConfigSanitizerFailed(
                "NodeConfig".to_string(),
                "Config sanitizer cannot be disabled on mainnet!".to_string(),
            ));
        }
    }
    return Ok(());
}
```

## Proof of Concept

```rust
#[test]
fn test_on_disk_storage_not_blocked_for_mainnet() {
    use crate::config::{
        NodeConfig, ConsensusConfig, SafetyRulesConfig, 
        SecureBackend, OnDiskStorageConfig, ConfigSanitizer
    };
    use crate::config::node_config_loader::NodeType;
    use aptos_types::chain_id::ChainId;
    use std::path::PathBuf;

    // Create a mainnet validator config with OnDiskStorage
    let node_config = NodeConfig {
        consensus: ConsensusConfig {
            safety_rules: SafetyRulesConfig {
                backend: SecureBackend::OnDiskStorage(OnDiskStorageConfig {
                    path: PathBuf::from("secure-data.json"),
                    namespace: None,
                    data_dir: PathBuf::from("/opt/aptos/data"),
                }),
                ..Default::default()
            },
            ..Default::default()
        },
        ..Default::default()
    };

    // The sanitizer should fail for mainnet validators with OnDiskStorage,
    // but it currently passes (BUG!)
    let result = SafetyRulesConfig::sanitize(
        &node_config,
        NodeType::Validator,
        Some(ChainId::mainnet()),
    );

    // This assertion SHOULD fail (proving the bug), 
    // but currently passes because OnDiskStorage is not checked
    assert!(result.is_ok(), "OnDiskStorage is allowed on mainnet (BUG)");

    // For comparison, InMemoryStorage IS correctly blocked:
    let bad_config = NodeConfig {
        consensus: ConsensusConfig {
            safety_rules: SafetyRulesConfig {
                backend: SecureBackend::InMemoryStorage,
                ..Default::default()
            },
            ..Default::default()
        },
        ..Default::default()
    };

    let result = SafetyRulesConfig::sanitize(
        &bad_config,
        NodeType::Validator,
        Some(ChainId::mainnet()),
    );
    
    assert!(result.is_err(), "InMemoryStorage is correctly blocked");
}
```

To demonstrate the plaintext key exposure:

```rust
#[test]
fn test_consensus_key_written_to_plaintext_file() {
    use aptos_secure_storage::{OnDiskStorage, KVStorage, Storage};
    use aptos_crypto::{bls12381, PrivateKey, Uniform};
    use aptos_global_constants::CONSENSUS_KEY;
    use std::fs;
    use aptos_temppath::TempPath;

    let temp_path = TempPath::new();
    temp_path.create_as_file().unwrap();

    let mut storage = Storage::from(OnDiskStorage::new(temp_path.path().to_path_buf()));
    
    // Generate a test consensus key
    let mut rng = rand::thread_rng();
    let private_key = bls12381::PrivateKey::generate(&mut rng);
    
    // Store it (as safety rules would)
    storage.set(CONSENSUS_KEY, private_key.clone()).unwrap();

    // Read the file as plaintext
    let file_contents = fs::read_to_string(temp_path.path()).unwrap();
    
    // The private key is visible in plaintext JSON!
    assert!(file_contents.contains("consensus"));
    assert!(file_contents.contains(&hex::encode(private_key.to_bytes())));
    
    println!("SECURITY ISSUE: Consensus private key stored in plaintext:");
    println!("{}", file_contents);
}
```

## Notes

This vulnerability demonstrates an **inconsistent security policy** where one testing-only storage backend (`InMemoryStorage`) is correctly blocked for production use, while another equally insecure backend (`OnDiskStorage`) is not. The codebase's own documentation explicitly warns against using `OnDiskStorage` in production, yet the enforcement mechanism fails to prevent its use. The existence of production-adjacent configurations (Terraform/Helm) that default to `OnDiskStorage` increases the likelihood that operators may deploy with this insecure configuration, believing the sanitizer would catch critical security issues.

### Citations

**File:** config/src/config/safety_rules_config.rs (L86-96)
```rust
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }
```

**File:** config/src/config/secure_backend_config.rs (L45-49)
```rust
    /// Returns true iff the backend is in memory
    pub fn is_in_memory(&self) -> bool {
        matches!(self, SecureBackend::InMemoryStorage)
    }
}
```

**File:** secure/storage/src/in_memory.rs (L9-14)
```rust
/// InMemoryStorage represents a key value store that is purely in memory and intended for single
/// threads (or must be wrapped by a Arc<RwLock<>>). This provides no permission checks and simply
/// is a proof of concept to unblock building of applications without more complex data stores.
/// Internally, it retains all data, which means that it must make copies of all key material which
/// violates the code base. It violates it because the anticipation is that data stores would
/// securely handle key material. This should not be used in production.
```

**File:** secure/storage/src/on_disk.rs (L16-22)
```rust
/// OnDiskStorage represents a key value store that is persisted to the local filesystem and is
/// intended for single threads (or must be wrapped by a Arc<RwLock<>>). This provides no permission
/// checks and simply offers a proof of concept to unblock building of applications without more
/// complex data stores. Internally, it reads and writes all data to a file, which means that it
/// must make copies of all key material which violates the code base. It violates it because
/// the anticipation is that data stores would securely handle key material. This should not be used
/// in production.
```

**File:** secure/storage/src/on_disk.rs (L64-70)
```rust
    fn write(&self, data: &HashMap<String, Value>) -> Result<(), Error> {
        let contents = serde_json::to_vec(data)?;
        let mut file = File::create(self.temp_path.path())?;
        file.write_all(&contents)?;
        fs::rename(&self.temp_path, &self.file_path)?;
        Ok(())
    }
```

**File:** secure/storage/README.md (L33-42)
```markdown
is the one primarily used in production environments by nodes in the blockchain.
- `InMemory`: The InMemory secure storage implementation provides a simple in-memory storage
engine. This engine should only be used for testing, as it does not offer any persistence, or
security (i.e., data is simply held in DRAM and may be lost on a crash, or restart).
- `OnDisk`: Similar to InMemory, the OnDisk secure storage implementation provides another
useful testing implementation: an on-disk storage engine, where the storage backend is
implemented using a single file written to local disk. In a similar fashion to the in-memory
storage, on-disk should not be used in production environments as it provides no security
guarantees (e.g., encryption before writing to disk). Moreover, OnDisk storage does not
currently support concurrent data accesses.
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L63-80)
```rust
    fn initialize_keys_and_accounts(
        internal_store: &mut Storage,
        author: Author,
        consensus_private_key: bls12381::PrivateKey,
    ) -> Result<(), Error> {
        let result = internal_store.set(CONSENSUS_KEY, consensus_private_key);
        // Attempting to re-initialize existing storage. This can happen in environments like
        // forge. Rather than be rigid here, leave it up to the developer to detect
        // inconsistencies or why they did not reset storage between rounds. Do not repeat the
        // checks again below, because it is just too strange to have a partially configured
        // storage.
        if let Err(aptos_secure_storage::Error::KeyAlreadyExists(_)) = result {
            warn!("Attempted to re-initialize existing storage");
            return Ok(());
        }

        internal_store.set(OWNER_ACCOUNT, author)?;
        Ok(())
```

**File:** terraform/helm/aptos-node/files/configs/validator-base.yaml (L10-17)
```yaml
consensus:
  safety_rules:
    service:
      type: "local"
    backend:
      type: "on_disk_storage"
      path: secure-data.json
      namespace: ~
```

**File:** docker/compose/aptos-node/validator.yaml (L7-13)
```yaml
consensus:
  safety_rules:
    service:
      type: "local"
    backend:
      type: "on_disk_storage"
      path: secure-data.json
```

**File:** config/src/config/config_sanitizer.rs (L45-48)
```rust
        // If config sanitization is disabled, don't do anything!
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }
```

**File:** config/src/config/node_startup_config.rs (L8-11)
```rust
pub struct NodeStartupConfig {
    pub skip_config_optimizer: bool, // Whether or not to skip the config optimizer at startup
    pub skip_config_sanitizer: bool, // Whether or not to skip the config sanitizer at startup
}
```
