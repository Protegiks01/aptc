# Audit Report

## Title
Lack of Verification for Peer-Advertised GlobalDataSummary Allows Byzantine Peers to Degrade State Sync Performance Without Penalty

## Summary
Byzantine peers can repeatedly advertise false data availability in their `StorageServerSummary` without being adequately penalized. The data client aggregates these unverified claims into the `GlobalDataSummary` without validation, allowing malicious peers to degrade state synchronization performance by causing honest nodes to waste time querying peers that cannot fulfill requests.

## Finding Description
The Aptos data client builds a `GlobalDataSummary` by aggregating `StorageServerSummary` data from all connected peers. This summary is used by nodes to determine which peers to query for state synchronization data. The vulnerability exists because:

1. **No Validation of Advertised Data**: When peers respond to storage summary polls, the system accepts their advertised data ranges without verification. [1](#0-0) 

2. **Unverified Aggregation**: The `calculate_global_data_summary()` function aggregates all peer summaries without cross-validation or consistency checks. [2](#0-1) 

3. **Inadequate Penalty for False Advertisements**: When a peer advertises data it doesn't have, subsequent request failures only result in a mild score reduction (multiplied by 0.95 for `ErrorType::NotUseful`). [3](#0-2) 

The peer score reduction occurs when data requests fail, but the penalty is insufficient: [4](#0-3) 

When storage service errors occur (like a peer not having advertised data), they're categorized as `NotUseful` rather than `Malicious`: [5](#0-4) 

**Attack Scenario:**
1. Byzantine peer advertises having transaction ranges 1-1,000,000 when it only has 1-100
2. Honest node building `GlobalDataSummary` includes this false advertisement
3. Honest node attempts to sync and selects Byzantine peer based on advertised data
4. Request fails (timeout or "data unavailable" error)
5. Byzantine peer score reduced by only 5% (0.95 multiplier)
6. Honest node retries with different peer, wasting time
7. Byzantine peer can repeat this indefinitely, staying above the ignore threshold (25.0) by occasionally succeeding with valid data ranges

## Impact Explanation
This vulnerability qualifies as **MEDIUM to HIGH severity** based on the following impacts:

**Medium Severity - State Synchronization Degradation:**
- Nodes attempting to sync state will experience significant delays as they repeatedly query Byzantine peers
- Multiple coordinated Byzantine peers can severely degrade sync performance across the network
- New validator nodes or nodes recovering from downtime will take much longer to sync
- Requires manual intervention to identify and ban malicious peers

**Potential for High Severity:**
- In networks with a significant number of Byzantine peers (but still < 1/3), state sync could become practically impossible
- This could affect network liveness if nodes cannot sync quickly enough to participate in consensus
- Validator node performance degrades as they waste resources on failed requests

This aligns with the bug bounty categories:
- High: "Validator node slowdowns"
- Medium: "State inconsistencies requiring intervention"

## Likelihood Explanation
**Likelihood: HIGH**

This attack is highly likely because:
1. **Easy to Execute**: Any network peer can advertise false data summaries without requiring validator privileges
2. **Difficult to Detect**: False advertisements blend with legitimate network variability and temporary unavailability
3. **Low Cost**: Attackers only need to run a malicious storage service peer
4. **Persistent Impact**: The 5% score reduction per failure allows peers to maintain presence above the ignore threshold
5. **No Direct Penalty**: There is no mechanism to detect or penalize false advertisements specifically

The attack requires minimal resources and technical sophistication while providing significant disruption potential.

## Recommendation
Implement a multi-layered defense:

**1. Cross-Validation of Advertised Data:**
Track discrepancies between advertised data and actual delivery. When a peer advertises data ranges but consistently fails to deliver:
```rust
// In peer_states.rs
struct PeerState {
    // ... existing fields ...
    advertised_vs_delivered_mismatches: u64,
}

impl PeerState {
    fn update_score_for_false_advertisement(&mut self) {
        // More severe penalty for advertising unavailable data
        self.score *= 0.5; // 50% reduction instead of 5%
        self.advertised_vs_delivered_mismatches += 1;
    }
}
```

**2. Strengthen Penalty for Data Unavailability:**
Differentiate between network errors and false advertisements: [6](#0-5) 

Add a new `ErrorType::FalseAdvertisement` with a stronger penalty multiplier (0.5 or lower).

**3. Reputation-Based Advertisement Trust:**
Only include advertisements from peers with high reputation scores in the global summary, or weight advertisements by peer score.

**4. Periodic Spot Checks:**
Randomly verify advertised data ranges by requesting small chunks and penalize peers that cannot deliver.

## Proof of Concept
```rust
// Pseudocode for malicious peer behavior

// 1. Setup malicious storage service
let mut malicious_peer = StorageServicePeer::new();

// 2. Advertise false data availability
let false_summary = StorageServerSummary {
    data_summary: DataSummary {
        transactions: Some(CompleteDataRange::new(0, 1_000_000).unwrap()),
        // Actually only have 0-100
        // ... other fields with inflated ranges
    },
    protocol_metadata: ProtocolMetadata::default(),
};

// 3. Respond to poll requests with false summary
loop {
    if let Some(poll_request) = malicious_peer.receive_poll() {
        malicious_peer.send_response(false_summary.clone());
    }
    
    // 4. Fail actual data requests outside real range
    if let Some(data_request) = malicious_peer.receive_data_request() {
        if data_request.version > 100 {
            // Return error or timeout
            malicious_peer.send_error(StorageServiceError::InvalidRequest(
                "Data not available".to_string()
            ));
            // Peer score only reduced by 5%
        } else {
            // Occasionally succeed to maintain score
            malicious_peer.send_valid_response(data_request);
            // Peer score increased by 1.0
        }
    }
}

// Result: Peer maintains score around 40-50, stays above ignore threshold of 25,
// while causing honest nodes to waste time querying for non-existent data
```

**Testing Instructions:**
1. Deploy a modified storage service that advertises 10x more data than it has
2. Observe that honest nodes include this data in their GlobalDataSummary
3. Monitor sync performance - nodes will repeatedly attempt to fetch non-existent data
4. Observe peer score oscillates but remains above ignore threshold
5. Demonstrate that multiple such peers can significantly slow network-wide state sync

## Notes
The vulnerability exists because the system trusts peer-advertised metadata without verification and applies insufficient penalties for false advertisements. While cryptographic proofs verify actual data correctness, the metadata layer (which drives peer selection) has no such protection. This creates an asymmetry where Byzantine peers can pollute the network's view of data availability at minimal cost, degrading performance for honest participants attempting to synchronize state.

### Citations

**File:** state-sync/aptos-data-client/src/poller.rs (L422-439)
```rust
        let storage_summary = match result {
            Ok(storage_summary) => storage_summary,
            Err(error) => {
                warn!(
                    (LogSchema::new(LogEntry::StorageSummaryResponse)
                        .event(LogEvent::PeerPollingError)
                        .message("Error encountered when polling peer!")
                        .error(&error)
                        .peer(&peer))
                );
                return;
            },
        };

        // Update the summary for the peer
        data_summary_poller
            .data_client
            .update_peer_storage_summary(peer, storage_summary);
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L32-43)
```rust
/// Scores for peer rankings based on preferences and behavior.
const MAX_SCORE: f64 = 100.0;
const MIN_SCORE: f64 = 0.0;
const STARTING_SCORE: f64 = 50.0;
/// Add this score on a successful response.
const SUCCESSFUL_RESPONSE_DELTA: f64 = 1.0;
/// Not necessarily a malicious response, but not super useful.
const NOT_USEFUL_MULTIPLIER: f64 = 0.95;
/// Likely to be a malicious response.
const MALICIOUS_MULTIPLIER: f64 = 0.8;
/// Ignore a peer when their score dips below this threshold.
const IGNORE_PEER_THRESHOLD: f64 = 25.0;
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L45-52)
```rust
pub enum ErrorType {
    /// A response or error that's not actively malicious but also doesn't help
    /// us make progress, e.g., timeouts, remote errors, invalid data, etc...
    NotUseful,
    /// A response or error that appears to be actively hindering progress or
    /// attempting to deceive us, e.g., invalid proof.
    Malicious,
}
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L168-174)
```rust
    fn update_score_error(&mut self, error: ErrorType) {
        let multiplier = match error {
            ErrorType::NotUseful => NOT_USEFUL_MULTIPLIER,
            ErrorType::Malicious => MALICIOUS_MULTIPLIER,
        };
        self.score = f64::max(self.score * multiplier, MIN_SCORE);
    }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L338-408)
```rust
    /// Calculates a global data summary using all known storage summaries
    pub fn calculate_global_data_summary(&self) -> GlobalDataSummary {
        // Gather all storage summaries, but exclude peers that are ignored
        let storage_summaries: Vec<StorageServerSummary> = self
            .peer_to_state
            .iter()
            .filter_map(|peer_state| {
                peer_state
                    .value()
                    .get_storage_summary_if_not_ignored()
                    .cloned()
            })
            .collect();

        // If we have no peers, return an empty global summary
        if storage_summaries.is_empty() {
            return GlobalDataSummary::empty();
        }

        // Calculate the global data summary using the advertised peer data
        let mut advertised_data = AdvertisedData::empty();
        let mut max_epoch_chunk_sizes = vec![];
        let mut max_state_chunk_sizes = vec![];
        let mut max_transaction_chunk_sizes = vec![];
        let mut max_transaction_output_chunk_sizes = vec![];
        for summary in storage_summaries {
            // Collect aggregate data advertisements
            if let Some(epoch_ending_ledger_infos) = summary.data_summary.epoch_ending_ledger_infos
            {
                advertised_data
                    .epoch_ending_ledger_infos
                    .push(epoch_ending_ledger_infos);
            }
            if let Some(states) = summary.data_summary.states {
                advertised_data.states.push(states);
            }
            if let Some(synced_ledger_info) = summary.data_summary.synced_ledger_info.as_ref() {
                advertised_data
                    .synced_ledger_infos
                    .push(synced_ledger_info.clone());
            }
            if let Some(transactions) = summary.data_summary.transactions {
                advertised_data.transactions.push(transactions);
            }
            if let Some(transaction_outputs) = summary.data_summary.transaction_outputs {
                advertised_data
                    .transaction_outputs
                    .push(transaction_outputs);
            }

            // Collect preferred max chunk sizes
            max_epoch_chunk_sizes.push(summary.protocol_metadata.max_epoch_chunk_size);
            max_state_chunk_sizes.push(summary.protocol_metadata.max_state_chunk_size);
            max_transaction_chunk_sizes.push(summary.protocol_metadata.max_transaction_chunk_size);
            max_transaction_output_chunk_sizes
                .push(summary.protocol_metadata.max_transaction_output_chunk_size);
        }

        // Calculate optimal chunk sizes based on the advertised data
        let optimal_chunk_sizes = calculate_optimal_chunk_sizes(
            &self.data_client_config,
            max_epoch_chunk_sizes,
            max_state_chunk_sizes,
            max_transaction_chunk_sizes,
            max_transaction_output_chunk_sizes,
        );
        GlobalDataSummary {
            advertised_data,
            optimal_chunk_sizes,
        }
    }
```

**File:** state-sync/aptos-data-client/src/client.rs (L844-866)
```rust
                    aptos_storage_service_client::Error::StorageServiceError(err) => {
                        Error::UnexpectedErrorEncountered(err.to_string())
                    },
                    _ => Error::UnexpectedErrorEncountered(error.to_string()),
                };

                warn!(
                    (LogSchema::new(LogEntry::StorageServiceResponse)
                        .event(LogEvent::ResponseError)
                        .request_type(&request.get_label())
                        .request_id(id)
                        .peer(&peer)
                        .error(&client_error))
                );

                increment_request_counter(
                    &metrics::ERROR_RESPONSES,
                    client_error.get_label(),
                    peer,
                );

                self.notify_bad_response(id, peer, &request, ErrorType::NotUseful);
                Err(client_error)
```
