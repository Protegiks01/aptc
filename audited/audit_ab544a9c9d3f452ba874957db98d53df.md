# Audit Report

## Title
Signature Replay Vulnerability in CoinClient Due to Improper Sequence Number Management on Transaction Failure

## Summary
The `CoinClient::transfer()` function in `sdk/src/coin_client.rs` lacks proper error handling for failed transaction submissions. When `sign_with_transaction_builder()` creates and signs a transaction, it immediately increments the local sequence number. If the subsequent `submit()` call fails, the local sequence number remains incremented while the on-chain sequence number is unchanged. This creates two security issues: (1) the signed transaction remains valid and can be maliciously replayed by network observers, and (2) the user's `LocalAccount` becomes desynchronized with the blockchain state, preventing subsequent transactions from succeeding.

## Finding Description

The vulnerability exists in the transaction signing and submission flow: [1](#0-0) 

When `get_signed_transfer_txn()` calls `sign_with_transaction_builder()`, the sequence number increment happens immediately: [2](#0-1) 

The `increment_sequence_number()` uses atomic fetch-and-add, returning the old value and incrementing the internal counter: [3](#0-2) 

**Attack Scenario:**

1. User calls `transfer()` with `LocalAccount` sequence number = 5
2. `sign_with_transaction_builder()` increments local sequence to 6, creates transaction with seq_num=5, signs it
3. `submit()` fails (network error, mempool full, gas estimation error, etc.)
4. Local sequence number is now 6, on-chain sequence number is still 5
5. The `SignedTransaction` with seq_num=5 remains cryptographically valid

**Exploitation Paths:**

**Path 1 - Malicious Replay by Observer:**
- Network observer (malicious node operator, MitM attacker) captures the `SignedTransaction` during failed submission
- Observer waits for transaction to fail
- Observer resubmits the transaction when advantageous (e.g., after price changes in DeFi operations)
- Transaction executes because sequence number matches and signature is valid

**Path 2 - State Desynchronization Attack:**
- User's local sequence number is 6, on-chain is 5
- User attempts to create new transaction, which will have seq_num=6
- New transaction fails with `PROLOGUE_ESEQUENCE_NUMBER_TOO_NEW`: [4](#0-3) 

- User is unable to submit transactions until manually fixing the sequence number mismatch
- Original failed transaction can still be replayed by anyone with the `SignedTransaction` bytes

The signature is cryptographically bound to all transaction parameters, preventing modification: [5](#0-4) 

However, the SAME signed transaction can be resubmitted as long as the sequence number matches and the transaction hasn't expired. The sequence number only increments in the epilogue after successful execution: [6](#0-5) 

**Proper Handling Pattern:**

The faucet correctly handles this by decrementing the sequence number on submission failure: [7](#0-6) 

## Impact Explanation

This vulnerability qualifies as **Medium Severity** under the Aptos bug bounty program for the following reasons:

1. **Limited Funds Loss or Manipulation**: In DeFi scenarios involving token swaps, the timing of transaction execution affects the exchange rate. An attacker replaying a stale transaction could cause the user to execute a trade at an unfavorable price, resulting in financial loss.

2. **State Inconsistencies Requiring Intervention**: Users experience `LocalAccount` desynchronization, requiring manual sequence number management via `decrement_sequence_number()` or recreating the `LocalAccount` from on-chain state. The SDK documentation doesn't provide clear guidance on handling this scenario.

3. **Violation of User Intent**: The user may have decided not to proceed with the transaction after the initial failure (e.g., changed their mind, market conditions changed), but the signed transaction remains valid and executable by any party with access to it.

4. **No Direct Fund Theft**: The attacker cannot modify the transaction payload, recipient address, or amount since these are cryptographically bound by the signature. This prevents escalation to Critical severity.

The vulnerability does NOT qualify as High severity because it doesn't cause validator node slowdowns, API crashes, or require changes to consensus protocols.

## Likelihood Explanation

**Likelihood: Medium to High**

**Triggering Conditions:**
- Transaction submission failures are common in production (network issues, mempool saturation, gas price volatility)
- The `CoinClient` is a commonly used SDK component for basic token transfers
- The vulnerability affects all SDK users who don't implement custom error handling

**Attacker Requirements:**
- Ability to observe network traffic (malicious node operator, MitM position, mempool monitoring)
- No special privileges required
- Transaction expiration provides time-limited window (default 10 seconds in `CoinClient`)

**Complexity:**
- Low technical barrier - simply resubmit captured transaction bytes
- Automated attacks are feasible

**Realistic Scenarios:**
1. High network congestion causes initial submission to fail/timeout
2. User attempts retry but creates sequence number conflict
3. Original transaction executed by mempool or attacker
4. DeFi swap executes at different price than intended

## Recommendation

Implement proper error handling in `CoinClient::transfer()` to decrement the sequence number on submission failures:

```rust
pub async fn transfer(
    &self,
    from_account: &mut LocalAccount,
    to_account: AccountAddress,
    amount: u64,
    options: Option<TransferOptions<'_>>,
) -> Result<PendingTransaction> {
    let signed_txn = self
        .get_signed_transfer_txn(from_account, to_account, amount, options)
        .await?;
    
    match self.api_client.submit(&signed_txn).await {
        Ok(pending) => Ok(pending.into_inner()),
        Err(e) => {
            // Decrement sequence number on submission failure to maintain sync
            from_account.decrement_sequence_number();
            Err(e).context("Failed to submit transfer transaction")
        }
    }
}
```

**Additional Recommendations:**
1. Document the sequence number management pattern in SDK documentation
2. Consider implementing a `TransactionBuilder` pattern that only increments sequence number after successful submission
3. Add warning comments in `sign_with_transaction_builder()` about error handling requirements
4. Implement automatic sequence number recovery utilities for SDK users

## Proof of Concept

```rust
#[tokio::test]
async fn test_signature_replay_on_failed_transaction() {
    use aptos_sdk::{
        coin_client::CoinClient,
        rest_client::Client,
        types::{AccountAddress, LocalAccount},
    };
    
    // Setup
    let client = Client::new(url::Url::parse("http://localhost:8080").unwrap());
    let coin_client = CoinClient::new(&client);
    let mut sender = LocalAccount::generate(&mut rand::thread_rng());
    let receiver = AccountAddress::random();
    
    // Record initial sequence number
    let initial_seq = sender.sequence_number();
    assert_eq!(initial_seq, 0);
    
    // Create and sign transaction
    let signed_txn = coin_client
        .get_signed_transfer_txn(&mut sender, receiver, 1000, None)
        .await
        .unwrap();
    
    // Sequence number has been incremented locally
    assert_eq!(sender.sequence_number(), 1);
    
    // Simulate submission failure (e.g., network error, invalid signature due to account not existing)
    let submission_result = client.submit(&signed_txn).await;
    
    // On failure, sequence number is still 1 locally but 0 on-chain
    if submission_result.is_err() {
        // BUG: CoinClient doesn't decrement sequence number
        assert_eq!(sender.sequence_number(), 1); // Local is 1
        
        // On-chain sequence is still 0 (can verify via API)
        // The signed transaction can now be replayed by anyone who captured it
        
        // Attempting to submit a new transaction will fail
        let new_signed_txn = coin_client
            .get_signed_transfer_txn(&mut sender, receiver, 2000, None)
            .await
            .unwrap();
        
        // New transaction has seq_num=1, but will increment local to 2
        assert_eq!(sender.sequence_number(), 2);
        
        // If on-chain is still 0, this will fail with ESEQUENCE_NUMBER_TOO_NEW
        // Meanwhile, the original signed_txn with seq_num=0 is still valid
        // and can be replayed by an attacker
    }
    
    // Proof that the original transaction can be replayed
    // (would need to actually execute this against a running network)
    let replay_result = client.submit(&signed_txn).await;
    // This succeeds if on-chain sequence is still 0
}
```

**Notes**

This vulnerability stems from a design flaw in the SDK's transaction lifecycle management. The core blockchain protocol correctly enforces sequence number validation [8](#0-7) , but the SDK client creates exploitable conditions by eagerly incrementing sequence numbers before confirming transaction execution. The faucet implementation demonstrates the correct pattern [9](#0-8) , indicating this is a known issue that should be fixed consistently across the SDK.

### Citations

**File:** sdk/src/coin_client.rs (L36-53)
```rust
    pub async fn transfer(
        &self,
        from_account: &mut LocalAccount,
        to_account: AccountAddress,
        amount: u64,
        options: Option<TransferOptions<'_>>,
    ) -> Result<PendingTransaction> {
        let signed_txn = self
            .get_signed_transfer_txn(from_account, to_account, amount, options)
            .await?;
        Ok(self
            .api_client
            .submit(&signed_txn)
            .await
            .context("Failed to submit transfer transaction")?
            .into_inner())
        // <:!:section_1
    }
```

**File:** sdk/src/types.rs (L354-368)
```rust
    pub fn sign_with_transaction_builder(&self, builder: TransactionBuilder) -> SignedTransaction {
        let raw_txn = if builder.has_nonce() {
            // Do not increment sequence number for orderless transactions.
            builder
                .sender(self.address())
                .sequence_number(u64::MAX)
                .build()
        } else {
            builder
                .sender(self.address())
                .sequence_number(self.increment_sequence_number())
                .build()
        };
        self.sign_transaction(raw_txn)
    }
```

**File:** sdk/src/types.rs (L546-548)
```rust
    pub fn increment_sequence_number(&self) -> u64 {
        self.sequence_number.fetch_add(1, Ordering::SeqCst)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L215-250)
```text
    fun check_for_replay_protection_regular_txn(
        sender_address: address,
        gas_payer_address: address,
        txn_sequence_number: u64,
    ) {
        if (
            sender_address == gas_payer_address
                || account::exists_at(sender_address)
                || !features::sponsored_automatic_account_creation_enabled()
                || txn_sequence_number > 0
        ) {
            assert!(account::exists_at(sender_address), error::invalid_argument(PROLOGUE_EACCOUNT_DOES_NOT_EXIST));
            let account_sequence_number = account::get_sequence_number(sender_address);
            assert!(
                txn_sequence_number < (1u64 << 63),
                error::out_of_range(PROLOGUE_ESEQUENCE_NUMBER_TOO_BIG)
            );

            assert!(
                txn_sequence_number >= account_sequence_number,
                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_OLD)
            );

            assert!(
                txn_sequence_number == account_sequence_number,
                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_NEW)
            );
        } else {
            // In this case, the transaction is sponsored and the account does not exist, so ensure
            // the default values match.
            assert!(
                txn_sequence_number == 0,
                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_NEW)
            );
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L629-632)
```text
        // Increment sequence number
        let addr = signer::address_of(&account);
        account::increment_sequence_number(addr);
    }
```

**File:** types/src/transaction/mod.rs (L175-205)
```rust
/// RawTransaction is the portion of a transaction that a client signs.
#[derive(
    Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash,
)]
pub struct RawTransaction {
    /// Sender's address.
    sender: AccountAddress,

    /// Sequence number of this transaction. This must match the sequence number
    /// stored in the sender's account at the time the transaction executes.
    sequence_number: u64,

    /// The transaction payload, e.g., a script to execute.
    payload: TransactionPayload,

    /// Maximal total gas to spend for this transaction.
    max_gas_amount: u64,

    /// Price to be paid per gas unit.
    gas_unit_price: u64,

    /// Expiration timestamp for this transaction, represented
    /// as seconds from the Unix Epoch. If the current blockchain timestamp
    /// is greater than or equal to this time, then the transaction has
    /// expired and will be discarded. This can be set to a large value far
    /// in the future to indicate that a transaction does not expire.
    expiration_timestamp_secs: u64,

    /// Chain ID of the Aptos network this transaction is intended for.
    chain_id: ChainId,
}
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L377-399)
```rust
    // If there was an issue submitting a transaction we should just reset
    // our sequence numbers to what it was before.
    match result {
        Ok(_) => {
            info!(
                hash = signed_transaction.committed_hash(),
                address = receiver_address,
                event = event_on_success,
            );
            Ok(signed_transaction)
        },
        Err(e) => {
            faucet_account.write().await.decrement_sequence_number();
            warn!(
                hash = signed_transaction.committed_hash(),
                address = receiver_address,
                event = "transaction_failure",
                error_message = format!("{:#}", e)
            );
            Err(e)
        },
    }
}
```
