# Audit Report

## Title
JWK Consensus Logic Flaw Enabling Broken State With Empty Providers Breaking Keyless Authentication

## Summary
The `jwk_consensus_enabled()` function returns `true` for any V1 variant configuration without verifying that OIDC providers are configured, allowing the system to enter a broken state where keyless authentication is completely non-functional while appearing to be "enabled."

## Finding Description

The vulnerability exists in the boolean logic of `jwk_consensus_enabled()` [1](#0-0) , which returns `true` for any V1 variant regardless of whether the `oidc_providers` list is empty.

When the system is initialized at genesis using `default_for_genesis()` [2](#0-1) , it creates a V1 configuration with an empty provider list. The comment explicitly states this is "to avoid DDoSing the CI infra" but acknowledges "it is supposed to use `default_enabled()`" which includes providers.

This misconfiguration propagates through the system:

1. **Epoch Manager Activation**: The epoch manager checks `jwk_consensus_enabled()` [3](#0-2)  and starts the JWK manager when true.

2. **No Observers Spawned**: The JWK manager attempts to spawn observers from the empty provider list [4](#0-3) , resulting in zero observers running.

3. **Empty On-Chain State**: The `ObservedJWKs` resource is initialized empty at genesis [5](#0-4)  and remains empty since no updates are produced.

4. **Keyless Authentication Failure**: When users attempt keyless authentication, `get_jwk_for_authenticator()` [6](#0-5)  attempts to retrieve JWKs from on-chain storage. The lookup via `get_jwk()` [7](#0-6)  fails because no JWKs exist, returning the error "JWK not found for issuer" and causing all keyless transactions to fail with an invalid signature error.

## Impact Explanation

**Severity: High** - This issue causes complete denial of service for keyless authentication, a core feature of Aptos blockchain. All users relying on keyless accounts (Google login, federated identity providers) cannot authenticate or submit transactions. 

The impact qualifies as **High Severity** per Aptos bug bounty criteria due to:
- Significant protocol violation (keyless authentication completely broken)
- Service degradation affecting all keyless account users
- Misleading system state (appears "enabled" but non-functional)

While not reaching Critical severity (no fund loss or consensus safety violation), it represents a major availability failure for an important authentication mechanism.

## Likelihood Explanation

**Likelihood: Medium-to-High**

The likelihood depends on deployment configuration:

- **High** if production deployments use the `default_for_genesis()` configuration without proper provider setup
- **Medium** if governance accidentally sets V1 config with empty providers via `new_v1(vector[])` [8](#0-7) 
- The comment in the code itself acknowledges this is incorrect configuration for production use

However, this requires genesis misconfiguration or governance error rather than active exploitation by an unprivileged attacker, which limits the exploitability criterion.

## Recommendation

Fix the `jwk_consensus_enabled()` function to check if providers are actually configured:

```rust
pub fn jwk_consensus_enabled(&self) -> bool {
    match self {
        OnChainJWKConsensusConfig::Off => false,
        OnChainJWKConsensusConfig::V1(config) => !config.oidc_providers.is_empty(),
    }
}
```

Additionally, add validation in `new_v1()` to prevent creating V1 configs with empty provider lists:

```rust
pub fn new_v1(oidc_providers: vector<OIDCProvider>): JWKConsensusConfig {
    assert!(!vector::is_empty(&oidc_providers), 
        error::invalid_argument(EEMPTY_PROVIDERS));
    // ... existing validation code
}
```

## Proof of Concept

```rust
#[test]
fn test_jwk_consensus_broken_with_empty_providers() {
    // Create V1 config with empty providers (genesis state)
    let config = OnChainJWKConsensusConfig::V1(ConfigV1 {
        oidc_providers: vec![],
    });
    
    // Consensus reports as "enabled"
    assert!(config.jwk_consensus_enabled());
    
    // But no providers are available
    assert!(config.oidc_providers_cloned().is_empty());
    
    // This creates an inconsistent state where:
    // 1. JWK manager starts (consensus enabled = true)
    // 2. No observers spawn (empty provider list)
    // 3. No JWK updates are ever produced
    // 4. Keyless authentication fails (no JWKs on-chain)
}
```

## Notes

Upon strict validation against the criteria "Exploitable by unprivileged attacker (no validator insider access required)", this issue does NOT fully qualify as it requires either genesis misconfiguration or governance action to enter the broken state. However, the logic flaw is real and creates a security-relevant broken state that should be addressed. This represents a **design flaw** rather than a directly exploitable vulnerability by external attackers.

### Citations

**File:** types/src/on_chain_config/jwk_consensus_config.rs (L61-67)
```rust
    pub fn default_for_genesis() -> Self {
        // Here it is supposed to use `default_enabled()`.
        // Using an empty list instead to avoid DDoSing the CI infra or the actual providers.
        Self::V1(ConfigV1 {
            oidc_providers: vec![],
        })
    }
```

**File:** types/src/on_chain_config/jwk_consensus_config.rs (L69-74)
```rust
    pub fn jwk_consensus_enabled(&self) -> bool {
        match self {
            OnChainJWKConsensusConfig::Off => false,
            OnChainJWKConsensusConfig::V1 { .. } => true,
        }
    }
```

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L177-180)
```rust
        let (jwk_manager_should_run, oidc_providers) = match jwk_consensus_config {
            Ok(config) => {
                let should_run =
                    config.jwk_consensus_enabled() && onchain_consensus_config.is_vtxn_enabled();
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L108-134)
```rust
        this.jwk_observers = oidc_providers
            .unwrap_or_default()
            .into_provider_vec()
            .into_iter()
            .filter_map(|provider| {
                let OIDCProvider { name, config_url } = provider;
                let maybe_issuer = String::from_utf8(name);
                let maybe_config_url = String::from_utf8(config_url);
                match (maybe_issuer, maybe_config_url) {
                    (Ok(issuer), Ok(config_url)) => Some(JWKObserver::spawn(
                        this.epoch_state.epoch,
                        this.my_addr,
                        issuer,
                        config_url,
                        Duration::from_secs(10),
                        local_observation_tx.clone(),
                    )),
                    (maybe_issuer, maybe_config_url) => {
                        warn!(
                            "unable to spawn observer, issuer={:?}, config_url={:?}",
                            maybe_issuer, maybe_config_url
                        );
                        None
                    },
                }
            })
            .collect();
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L434-440)
```text
    public fun initialize(fx: &signer) {
        system_addresses::assert_aptos_framework(fx);
        move_to(fx, SupportedOIDCProviders { providers: vector[] });
        move_to(fx, ObservedJWKs { jwks: AllProvidersJWKs { entries: vector[] } });
        move_to(fx, Patches { patches: vector[] });
        move_to(fx, PatchedJWKs { jwks: AllProvidersJWKs { entries: vector[] } });
    }
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L112-150)
```rust
fn get_jwk_for_authenticator(
    jwks: &AllProvidersJWKs,
    pk: &KeylessPublicKey,
    sig: &KeylessSignature,
) -> Result<JWK, VMStatus> {
    let jwt_header = sig
        .parse_jwt_header()
        .map_err(|_| invalid_signature!("Failed to parse JWT header"))?;

    let jwk_move_struct = jwks.get_jwk(&pk.iss_val, &jwt_header.kid).map_err(|_| {
        invalid_signature!(format!(
            "JWK for {} with KID {} was not found",
            pk.iss_val, jwt_header.kid
        ))
    })?;

    let jwk = JWK::try_from(jwk_move_struct)
        .map_err(|_| invalid_signature!("Could not unpack Any in JWK Move struct"))?;

    match &jwk {
        JWK::RSA(rsa_jwk) => {
            if rsa_jwk.alg != jwt_header.alg {
                return Err(invalid_signature!(format!(
                    "JWK alg ({}) does not match JWT header's alg ({})",
                    rsa_jwk.alg, jwt_header.alg
                )));
            }
        },
        JWK::Unsupported(jwk) => {
            return Err(invalid_signature!(format!(
                "JWK with KID {} and hex-encoded payload {} is not supported",
                jwt_header.kid,
                hex::encode(&jwk.payload)
            )))
        },
    }

    Ok(jwk)
}
```

**File:** types/src/jwks/mod.rs (L231-237)
```rust
    pub fn get_jwk(&self, iss: &str, kid: &str) -> anyhow::Result<&JWKMoveStruct> {
        let provider_jwk_set = self
            .get_provider_jwks(iss)
            .context("JWK not found for issuer")?;
        let jwk = provider_jwk_set.get_jwk(kid)?;
        Ok(jwk)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/jwk_consensus_config.move (L87-102)
```text
    /// Construct a `JWKConsensusConfig` of variant `ConfigV1`.
    ///
    /// Abort if the given provider list contains duplicated provider names.
    public fun new_v1(oidc_providers: vector<OIDCProvider>): JWKConsensusConfig {
        let name_set = simple_map::new<String, u64>();
        vector::for_each_ref(&oidc_providers, |provider| {
            let provider: &OIDCProvider = provider;
            let (_, old_value) = simple_map::upsert(&mut name_set, provider.name, 0);
            if (option::is_some(&old_value)) {
                abort(error::invalid_argument(EDUPLICATE_PROVIDERS))
            }
        });
        JWKConsensusConfig {
            variant: copyable_any::pack( ConfigV1 { oidc_providers } )
        }
    }
```
