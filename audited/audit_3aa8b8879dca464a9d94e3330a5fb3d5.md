# Audit Report

## Title
Insufficient Length Validation on CoinWithdraw Event coin_type Field Enabling Storage Bloat and Indexer DoS

## Summary
The `coin_type` field in the `CoinWithdraw` event structure lacks explicit length validation beyond the 1 MB event size limit, allowing creation of events with excessively large coin_type strings (hundreds of KB). This can cause storage bloat, memory exhaustion during event processing, and denial-of-service conditions for indexers.

## Finding Description
The `CoinWithdraw` struct defines `coin_type` as an unbounded `String` type: [1](#0-0) 

When events are deserialized, no length validation is performed on the `coin_type` field: [2](#0-1) 

The event translation layer uses this unbounded string unsafely by formatting it into a larger string without validation: [3](#0-2) 

An attacker can exploit this by:
1. Creating a coin type with deeply nested type parameters (Move allows up to 256 levels of type nesting) [4](#0-3) 

2. The type name generated by `type_info::type_name<T>()` has no intrinsic length limit: [5](#0-4) 

3. Events are only limited to 1 MB per event: [6](#0-5) 

4. This limit is enforced but allows very large strings: [7](#0-6) 

With 256 levels of type nesting and reasonable identifier lengths, an attacker can create coin_type strings of tens of kilobytes. Multiple such events per transaction (up to 10 MB total) can significantly bloat on-chain storage and cause resource exhaustion in indexers that must process and format these strings.

## Impact Explanation
This issue qualifies as **High Severity** under the Aptos bug bounty program:
- **Validator node slowdowns**: Processing events with large coin_type strings requires significant memory allocation and string parsing
- **Storage bloat**: Events are permanently stored on-chain; large coin_type strings waste storage resources
- **Indexer DoS**: Indexers processing these events must allocate and format large strings, potentially causing crashes or severe performance degradation

The vulnerability breaks the **Resource Limits** invariant - operations should respect storage and computational limits, but there's no reasonable limit on coin_type length despite other framework components enforcing strict limits (e.g., coin names limited to 32 bytes). [8](#0-7) 

## Likelihood Explanation
Likelihood is **Medium to High** because:
- Any actor who can initialize a coin type can exploit this (minimal barrier)
- No special privileges required beyond publishing a Move module with nested types
- Gas costs exist but are manageable for a determined attacker
- The attack is repeatable across multiple transactions

## Recommendation
Add explicit length validation for the `coin_type` field. The maximum reasonable length for a fully qualified type name should be established (e.g., 512 or 1024 bytes).

**Fix 1**: Add validation in the Rust deserialization:
```rust
pub fn try_from_bytes(bytes: &[u8]) -> anyhow::Result<Self> {
    let event: Self = bcs::from_bytes(bytes)?;
    const MAX_COIN_TYPE_LENGTH: usize = 1024;
    if event.coin_type.len() > MAX_COIN_TYPE_LENGTH {
        anyhow::bail!("coin_type exceeds maximum length of {} bytes", MAX_COIN_TYPE_LENGTH);
    }
    Ok(event)
}
```

**Fix 2**: Add validation in the Move framework when creating coins to prevent initialization with excessively nested types.

**Fix 3**: Add defensive checks in the event translator before string formatting:
```rust
if coin_withdraw.coin_type().len() > MAX_REASONABLE_TYPE_NAME_LENGTH {
    return Err(anyhow::anyhow!("coin_type too long"));
}
```

## Proof of Concept
```move
// Malicious module creating deeply nested coin type
module attacker::nested_coin {
    use std::signer;
    use aptos_framework::coin;
    
    // Deeply nested type to generate long type names
    struct A<T> has key, store { value: T }
    struct B<T> has key, store { value: T }
    struct C<T> has key, store { value: T }
    // ... repeat for many levels
    
    // Coin type with extreme nesting
    struct MaliciousCoin has key, store {}
    
    public entry fun initialize(account: &signer) {
        // Type name for this will be extremely long:
        // 0xAttacker::nested_coin::A<0xAttacker::nested_coin::B<0xAttacker::nested_coin::C<...>>>
        let name = b"Attack";
        let symbol = b"ATK";
        coin::initialize<A<B<C</* deeply nested */ MaliciousCoin>>>>(
            account,
            string::utf8(name),
            string::utf8(symbol),
            8,
            false
        );
        
        // Any withdraw operation will now create CoinWithdraw events
        // with multi-kilobyte coin_type strings
    }
}
```

**Notes:**
While other framework components like fungible assets enforce strict length limits on names (32 bytes) and symbols (32 bytes), the `coin_type` field in events has no such protection beyond the 1 MB event size limit. This asymmetry creates an exploitable gap where type names can be arbitrarily long, causing resource exhaustion during event processing and permanent storage bloat.

### Citations

**File:** types/src/account_config/events/coin_withdraw.rs (L15-20)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize)]
pub struct CoinWithdraw {
    pub coin_type: String,
    pub account: AccountAddress,
    pub amount: u64,
}
```

**File:** types/src/account_config/events/coin_withdraw.rs (L31-33)
```rust
    pub fn try_from_bytes(bytes: &[u8]) -> anyhow::Result<Self> {
        bcs::from_bytes(bytes).map_err(Into::into)
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L283-285)
```rust
        let coin_withdraw = CoinWithdraw::try_from_bytes(v2.event_data())?;
        let struct_tag_str = format!("0x1::coin::CoinStore<{}>", coin_withdraw.coin_type());
        let struct_tag = StructTag::from_str(&struct_tag_str)?;
```

**File:** third_party/move/move-binary-format/src/file_format_common.rs (L88-88)
```rust
pub const SIGNATURE_TOKEN_DEPTH_MAX: usize = 256;
```

**File:** aptos-move/framework/src/natives/type_info.rs (L84-103)
```rust
fn native_type_name(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(ty_args.len() == 1);
    debug_assert!(arguments.is_empty());

    context.charge(TYPE_INFO_TYPE_NAME_BASE)?;

    let type_tag = context.type_to_type_tag(&ty_args[0])?;
    let type_name = type_tag.to_canonical_string();

    // TODO: Ideally, we would charge *before* the `type_to_type_tag()` and `type_tag.to_string()` calls above.
    context.charge(TYPE_INFO_TYPE_NAME_PER_BYTE_IN_STR * NumBytes::new(type_name.len() as u64))?;

    Ok(smallvec![Value::struct_(Struct::pack(vec![
        Value::vector_u8(type_name.as_bytes().to_vec())
    ]))])
}
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L164-166)
```rust
            max_bytes_per_event: NumBytes,
            { 5.. => "max_bytes_per_event" },
            1 << 20, // a single event is 1MB max
```

**File:** aptos-move/aptos-vm-types/src/storage/change_set_configs.rs (L115-125)
```rust
        let mut total_event_size = 0;
        for event in change_set.events_iter() {
            let size = event.event_data().len() as u64;
            if size > self.max_bytes_per_event {
                return storage_write_limit_reached(None);
            }
            total_event_size += size;
            if total_event_size > self.max_bytes_all_events_per_transaction {
                return storage_write_limit_reached(None);
            }
        }
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L125-127)
```text
    const MAX_COIN_NAME_LENGTH: u64 = 32;
    const MAX_COIN_SYMBOL_LENGTH: u64 = 32;
    const MAX_DECIMALS: u8 = 32;
```
