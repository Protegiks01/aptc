# Audit Report

## Title
Shift Overflow in Chunky PVSS DKG Causes Debug/Release Build Inconsistency and Cryptographic Failure When ell=64

## Summary
The chunky PVSS DKG implementation contains a critical integer overflow vulnerability where `1u64 << ell` in `compute_powers_of_radix()` overflows when `ell=64`, while `1u128 << num_bits` in `le_chunks_to_scalar()` correctly handles the same value. This inconsistency causes different behavior between debug builds (panic) and release builds (wrong cryptographic computation), breaking the deterministic execution invariant required for consensus.

## Finding Description

The vulnerability exists in two related functions that compute the same radix value but use different integer types:

**Location 1:** [1](#0-0) 

This function computes powers of the radix using `1u64 << ell`. When `ell=64`, this causes shift overflow because shifting a 64-bit value by 64 positions is undefined behavior in Rust.

**Location 2:** [2](#0-1) 

This function correctly uses `1u128 << num_bits`, which can safely handle shifts up to 127 positions.

**Rust Overflow Behavior:**
- **Debug builds**: Integer overflow checks are enabled by default. The expression `1u64 << 64` triggers a panic with "attempt to shift left with overflow"
- **Release builds**: Overflow checks are disabled. The shift amount is masked to fit the type width (`64 & 0x3F = 0`), making `1u64 << 64` equivalent to `1u64 << 0 = 1`

**Constraint Validation:**
The assertion at [3](#0-2)  explicitly allows `num_bits <= 64`, making `ell=64` a valid configuration parameter.

**Attack Path:**
1. DKG configured with chunky PVSS scheme and `ell=64`
2. `PublicParameters::new()` calls `compute_powers_of_radix(64)`
3. In release builds: computes `powers_of_radix = [1, 1, 1, ...]` instead of `[1, 2^64, 2^128, ...]`
4. These wrong powers are used in transcript aggregation: [4](#0-3) 
5. During decryption, `le_chunks_to_scalar()` uses the correct base `2^64`
6. The mismatch causes validators to compute different DKG shares, breaking consensus

**Current Status:**
The production DKG implementation uses `pvss::das::WeightedTranscript` as shown in [5](#0-4) , NOT the chunky PVSS variant. However, the chunky implementation is part of the codebase and could be deployed in the future.

## Impact Explanation

**Critical Severity** - This vulnerability would cause:

1. **Consensus Failure**: Different validators with different build configurations (debug vs release) would compute completely different DKG results, violating the deterministic execution invariant
2. **Network Partition**: Debug-built validators would crash during DKG setup, while release-built validators would continue with corrupted cryptographic material
3. **Cryptographic Integrity Violation**: Even if all validators use release builds, the wrong `powers_of_radix` values would cause incorrect multi-scalar multiplication (MSM), producing invalid shares

**Severity Classification**: While this meets Critical severity criteria (consensus violation, deterministic execution break), it applies only to the unused chunky PVSS implementation. If this code were deployed with `ell=64`, it would immediately cause network-wide DKG failure.

## Likelihood Explanation

**Current Likelihood: Very Low**
- Chunky PVSS is not in production; DAS PVSS is used instead
- No configuration pathway exists to enable chunky PVSS in current deployment
- Tests use `DEFAULT_ELL_FOR_TESTING = 16`, not 64

**Future Likelihood: High IF Deployed**
- The constraint explicitly allows `ell=64` as valid
- No tests exist with `ell=64` to catch this bug
- Validators typically run release builds in production, which would silently produce wrong values rather than crashing

## Recommendation

**Fix Option 1 - Change to u128 (Recommended):**
```rust
fn compute_powers_of_radix<E: Pairing>(ell: u8) -> Vec<E::ScalarField> {
    utils::powers(
        E::ScalarField::from(1u128 << ell),  // Change from 1u64 to 1u128
        num_chunks_per_scalar::<E::ScalarField>(ell) as usize,
    )
}
```

**Fix Option 2 - Add runtime check:**
```rust
fn compute_powers_of_radix<E: Pairing>(ell: u8) -> Vec<E::ScalarField> {
    assert!(ell < 64, "ell must be less than 64 for u64 shift");
    utils::powers(
        E::ScalarField::from(1u64 << ell),
        num_chunks_per_scalar::<E::ScalarField>(ell) as usize,
    )
}
```

**Additional Recommendation:**
Add integration test with `ell=64` to verify consistency between `compute_powers_of_radix` and `le_chunks_to_scalar`.

## Proof of Concept

```rust
// Test demonstrating the inconsistency
#[cfg(test)]
mod test_ell_64_bug {
    use super::*;
    use ark_bls12_381::{Bls12_381, Fr};
    
    #[test]
    #[should_panic(expected = "attempt to shift left with overflow")]
    fn test_overflow_in_debug() {
        // This panics in debug builds
        let _bad_value = 1u64 << 64;
    }
    
    #[test]
    fn test_inconsistency_release() {
        // In release builds, these produce different values
        let wrong_radix = 1u64 << 64; // Wraps to 1
        let correct_radix = 1u128 << 64; // Correctly computes 2^64
        
        assert_eq!(wrong_radix, 1); // Wrong!
        assert_eq!(correct_radix, 18446744073709551616u128); // Correct
        
        // This shows the bug: compute_powers_of_radix would use wrong value
        let field_wrong = Fr::from(wrong_radix);
        let field_correct = Fr::from(correct_radix);
        
        assert_ne!(field_wrong, field_correct);
    }
    
    #[test]
    fn test_full_inconsistency() {
        use ark_std::test_rng;
        let mut rng = test_rng();
        
        // Create PublicParameters with ell=64 (would panic in debug)
        // In release, powers_of_radix would be all 1s
        
        // Demonstrate chunk/unchunk still works because it uses u128
        let num_bits = 64u8;
        let original = Fr::rand(&mut rng);
        let chunks = crate::pvss::chunky::chunks::scalar_to_le_chunks(num_bits, &original);
        let reconstructed = crate::pvss::chunky::chunks::le_chunks_to_scalar(num_bits, &chunks);
        
        assert_eq!(original, reconstructed); // This works fine
        
        // But if PublicParameters used powers_of_radix computed from 1u64<<64,
        // it would have all 1s instead of [1, 2^64, 2^128, ...], breaking MSM
    }
}
```

**Notes**
- This vulnerability is in the chunky PVSS implementation which is **not currently deployed in production**
- Production DKG uses the DAS PVSS scheme instead
- However, the bug is real and would cause immediate consensus failure if chunky PVSS were deployed with `ell=64`
- The inconsistency between debug and release builds violates deterministic execution requirements
- No existing tests catch this because they use `ell=16` and don't test with `ell=64`

### Citations

**File:** crates/aptos-dkg/src/pvss/chunky/public_parameters.rs (L35-40)
```rust
fn compute_powers_of_radix<E: Pairing>(ell: u8) -> Vec<E::ScalarField> {
    utils::powers(
        E::ScalarField::from(1u64 << ell),
        num_chunks_per_scalar::<E::ScalarField>(ell) as usize,
    )
}
```

**File:** crates/aptos-dkg/src/pvss/chunky/chunks.rs (L32-48)
```rust
pub fn le_chunks_to_scalar<F: PrimeField>(num_bits: u8, chunks: &[F]) -> F {
    assert!(
        num_bits.is_multiple_of(8) && num_bits > 0 && num_bits <= 64, // TODO: so make num_bits a u8?
        "Invalid chunk size"
    );

    let base = F::from(1u128 << num_bits); // need u128 in the case where `num_bits` is 64, because of `chunk * multiplier`
    let mut acc = F::zero();
    let mut multiplier = F::one();

    for &chunk in chunks {
        acc += chunk * multiplier;
        multiplier *= base;
    }

    acc
}
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L255-262)
```rust
        for i in 0..Cs_flat.len() {
            for j in 0..Cs_flat[i].len() {
                let base = Cs_flat[i][j];
                let exp = pp.powers_of_radix[j] * powers_of_beta[i];
                base_vec.push(base);
                exp_vec.push(exp);
            }
        }
```

**File:** types/src/dkg/real_dkg/mod.rs (L38-39)
```rust
pub type WTrx = pvss::das::WeightedTranscript;
pub type DkgPP = <WTrx as Transcript>::PublicParameters;
```
