# Audit Report

## Title
Genesis Block ID Divergence Causing Permanent Network Partition at Epoch Transitions

## Summary
Validators can create different genesis blocks with conflicting IDs when transitioning between epochs, leading to permanent network partition and complete liveness failure. The vulnerability occurs because genesis block IDs are computed from end-epoch ledger info state, and different validators may have different end-epoch states due to network partitions or timing.

## Finding Description

At epoch transitions, each validator creates a genesis block for the next epoch based on their local end-epoch `LedgerInfo`. The genesis block ID is computed as a hash of `BlockData`, which includes critical state fields from the end-epoch ledger: `transaction_accumulator_hash`, `version`, `timestamp_usecs`, and `epoch`. [1](#0-0) 

The genesis block ID is then computed from this BlockData: [2](#0-1) 

**The Critical Flaw**: When validators have different end-epoch states (different committed blocks), they compute DIFFERENT genesis block IDs. The genesis QC verification only checks internal consistency but does NOT verify that all validators agree on the same genesis block: [3](#0-2) 

The comment claims "If someone sends us a QC on a fake genesis, it'll fail to insert into BlockStore because of the round constraint," but this assumes all validators agree on what the "real" genesis is—which this vulnerability violates.

**Attack Scenario**:

1. At epoch N end, network conditions cause validators to commit different final blocks:
   - Validators A-J commit block X (version=1000, accumulator_hash=H1, timestamp=T1)
   - Validators K-T commit block Y (version=1001, accumulator_hash=H2, timestamp=T2)

2. Both blocks are valid and properly signed by their quorums, both trigger epoch transition (`ends_epoch()=true`)

3. Each validator broadcasts an `EpochChangeProof` containing their own committed ledger info: [4](#0-3) 

4. When starting epoch N+1, validators call `storage.start()` which retrieves their local end-epoch ledger info and creates a genesis block: [5](#0-4) 

5. Validators that synced to block X create genesis with ID = `hash(BlockData containing H1, 1000, T1, epoch N+1)`

6. Validators that synced to block Y create genesis with ID = `hash(BlockData containing H2, 1001, T2, epoch N+1)`

7. These genesis blocks have **different IDs** despite being at the same epoch and round

8. Validators are now on permanently diverged chains—they cannot build consensus on top of different genesis blocks

9. The network is partitioned and cannot recover without manual intervention or hard fork

## Impact Explanation

This is **Critical Severity** under Aptos Bug Bounty criteria:
- **Non-recoverable network partition (requires hardfork)**: Validators on different genesis blocks cannot converge through normal consensus mechanisms
- **Total loss of liveness/network availability**: The blockchain cannot produce new blocks when validators disagree on the genesis block for an epoch
- **Consensus Safety violation**: The fundamental invariant that all validators agree on the canonical chain is broken

The impact affects the entire validator network. Even a single validator with a different genesis block creates a permanent fork that cannot be resolved through AptosBFT's normal recovery mechanisms.

## Likelihood Explanation

**High Likelihood** - This can occur naturally without malicious actors:

1. **Network Partitions**: Temporary network splits during epoch transitions can cause different validator groups to commit different final blocks
2. **Timing Differences**: Validators may observe different blocks as the "last" block of an epoch due to message propagation delays
3. **State Sync Variability**: The `EpochChangeProof` broadcast mechanism allows different validators to receive different end-epoch states: [6](#0-5) 

4. **No Synchronization Check**: There is no mechanism to ensure all validators converge to the same end-epoch state before creating the genesis block: [7](#0-6) 

The vulnerability requires no attacker—it can manifest from normal network conditions.

## Recommendation

Implement a two-phase epoch transition protocol:

**Phase 1 - Epoch End Commitment**: Before transitioning epochs, all validators must agree on a canonical end-epoch block through consensus:

```rust
// In persistent_liveness_storage.rs - modify find_root() method
pub fn find_root_with_canonical_genesis_check(
    &self,
    blocks: &mut Vec<Block>,
    quorum_certs: &mut Vec<QuorumCert>,
    order_vote_enabled: bool,
    window_size: Option<u64>,
    canonical_end_epoch_block_id: Option<HashValue>, // NEW: consensus-agreed block
) -> Result<RootInfo> {
    if self.storage_ledger.ledger_info().ends_epoch() {
        // Verify that our end-epoch state matches the canonical one
        if let Some(expected_id) = canonical_end_epoch_block_id {
            let actual_id = self.storage_ledger.ledger_info().consensus_block_id();
            ensure!(
                actual_id == expected_id,
                "End-epoch block mismatch: expected {}, got {}. Must sync before epoch transition.",
                expected_id,
                actual_id
            );
        }
        // ... rest of genesis creation
    }
    // ... rest of function
}
```

**Phase 2 - Genesis Block Verification**: Add validation to ensure all validators create identical genesis blocks:

```rust
// In quorum_cert.rs - enhance genesis QC verification
pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
    // ... existing verification ...
    
    if self.certified_block().round() == 0 {
        // NEW: Add deterministic genesis ID check
        // Genesis ID must be derivable from the end-epoch ledger info
        // that was consensus-committed in the previous epoch
        
        // Verify genesis block matches expected structure
        ensure!(
            self.parent_block() == self.certified_block(),
            "Genesis QC has inconsistent parent block with certified block"
        );
        ensure!(
            self.certified_block() == self.ledger_info().ledger_info().commit_info(),
            "Genesis QC has inconsistent commit block with certified block"
        );
        ensure!(
            self.ledger_info().get_num_voters() == 0,
            "Genesis QC should not carry signatures"
        );
        
        // NEW: If we have a trusted genesis ID (from consensus), verify it matches
        // This would be passed through the validator context
        // validate_genesis_id_matches_expected(self.certified_block().id())?;
        
        return Ok(());
    }
    // ... rest of verification
}
```

**Phase 3 - Synchronization Protocol**: Modify epoch manager to ensure all validators sync to a consensus-agreed end-epoch state before generating genesis:

```rust
// In epoch_manager.rs - add pre-genesis synchronization
async fn initiate_new_epoch(&mut self, proof: EpochChangeProof) -> anyhow::Result<()> {
    let ledger_info = proof.verify(self.epoch_state())?;
    
    // NEW: Broadcast and collect end-epoch commitments from other validators
    // Ensure 2f+1 validators agree on the same end-epoch block ID
    let canonical_end_epoch_id = self.synchronize_end_epoch_state(ledger_info).await?;
    
    self.shutdown_current_processor().await;
    *self.pending_blocks.lock() = PendingBlocks::new();
    
    // Sync to the canonical end-epoch state (not just any ledger_info)
    self.execution_client
        .sync_to_target_with_verification(ledger_info.clone(), canonical_end_epoch_id)
        .await?;
    
    monitor!("reconfig", self.await_reconfig_notification().await);
    Ok(())
}
```

## Proof of Concept

```rust
// Reproduction steps (Rust test in consensus module)

#[tokio::test]
async fn test_genesis_qc_divergence() {
    use aptos_types::{
        block_info::BlockInfo,
        ledger_info::LedgerInfo,
    };
    use consensus_types::{
        block::Block,
        quorum_cert::QuorumCert,
    };
    
    // Create two different end-epoch ledger infos (simulating network partition)
    let epoch = 5;
    
    // Validator group A's end-epoch state
    let ledger_info_a = LedgerInfo::new(
        BlockInfo::new(
            epoch,
            100, // round
            HashValue::random(),
            HashValue::sha3_256_of(b"state_A"), // Different accumulator hash
            1000, // version
            1000000, // timestamp
            Some(EpochState::empty()), // triggers epoch change
        ),
        HashValue::zero(),
    );
    
    // Validator group B's end-epoch state (different version/hash/timestamp)
    let ledger_info_b = LedgerInfo::new(
        BlockInfo::new(
            epoch,
            100, // same round
            HashValue::random(),
            HashValue::sha3_256_of(b"state_B"), // Different accumulator hash!
            1001, // Different version!
            1000001, // Different timestamp!
            Some(EpochState::empty()),
        ),
        HashValue::zero(),
    );
    
    // Both validator groups create genesis blocks for epoch 6
    let genesis_a = Block::make_genesis_block_from_ledger_info(&ledger_info_a);
    let genesis_b = Block::make_genesis_block_from_ledger_info(&ledger_info_b);
    
    // VULNERABILITY: Genesis blocks have DIFFERENT IDs!
    assert_ne!(
        genesis_a.id(),
        genesis_b.id(),
        "Genesis blocks should have different IDs (vulnerability!)"
    );
    
    // Both genesis QCs pass individual verification
    let qc_a = QuorumCert::certificate_for_genesis_from_ledger_info(
        &ledger_info_a,
        genesis_a.id(),
    );
    let qc_b = QuorumCert::certificate_for_genesis_from_ledger_info(
        &ledger_info_b,
        genesis_b.id(),
    );
    
    // Both QCs are "valid" according to current verification logic
    let dummy_verifier = ValidatorVerifier::new(vec![]);
    assert!(qc_a.verify(&dummy_verifier).is_ok());
    assert!(qc_b.verify(&dummy_verifier).is_ok());
    
    // But validators using qc_a cannot accept blocks building on qc_b
    // and vice versa - PERMANENT PARTITION!
    println!("Genesis A ID: {}", genesis_a.id());
    println!("Genesis B ID: {}", genesis_b.id());
    println!("Network is now permanently partitioned!");
}
```

## Notes

This vulnerability represents a fundamental design flaw in epoch transition logic where consensus agreement is not enforced at the critical moment of genesis block creation. The issue stems from an implicit assumption that all validators will naturally converge to the same end-epoch state, which network conditions can violate. The fix requires adding an explicit synchronization phase before genesis creation to ensure all validators build on the same canonical end-epoch state.

### Citations

**File:** consensus/consensus-types/src/block_data.rs (L235-258)
```rust
    pub fn new_genesis_from_ledger_info(ledger_info: &LedgerInfo) -> Self {
        assert!(ledger_info.ends_epoch());
        let ancestor = BlockInfo::new(
            ledger_info.epoch(),
            0,                 /* round */
            HashValue::zero(), /* parent block id */
            ledger_info.transaction_accumulator_hash(),
            ledger_info.version(),
            ledger_info.timestamp_usecs(),
            None,
        );

        // Genesis carries a placeholder quorum certificate to its parent id with LedgerInfo
        // carrying information about version from the last LedgerInfo of previous epoch.
        let genesis_quorum_cert = QuorumCert::new(
            VoteData::new(ancestor.clone(), ancestor.clone()),
            LedgerInfoWithSignatures::new(
                LedgerInfo::new(ancestor, HashValue::zero()),
                AggregateSignature::empty(),
            ),
        );

        BlockData::new_genesis(ledger_info.timestamp_usecs(), genesis_quorum_cert)
    }
```

**File:** consensus/consensus-types/src/block.rs (L277-284)
```rust
    pub fn make_genesis_block_from_ledger_info(ledger_info: &LedgerInfo) -> Self {
        let block_data = BlockData::new_genesis_from_ledger_info(ledger_info);
        Block {
            id: block_data.hash(),
            block_data,
            signature: None,
        }
    }
```

**File:** consensus/consensus-types/src/quorum_cert.rs (L125-141)
```rust
        // Genesis's QC is implicitly agreed upon, it doesn't have real signatures.
        // If someone sends us a QC on a fake genesis, it'll fail to insert into BlockStore
        // because of the round constraint.
        if self.certified_block().round() == 0 {
            ensure!(
                self.parent_block() == self.certified_block(),
                "Genesis QC has inconsistent parent block with certified block"
            );
            ensure!(
                self.certified_block() == self.ledger_info().ledger_info().commit_info(),
                "Genesis QC has inconsistent commit block with certified block"
            );
            ensure!(
                self.ledger_info().get_num_voters() == 0,
                "Genesis QC should not carry signatures"
            );
            return Ok(());
```

**File:** consensus/src/block_storage/sync_manager.rs (L190-198)
```rust
            if qc.ends_epoch() {
                retriever
                    .network
                    .broadcast_epoch_change(EpochChangeProof::new(
                        vec![qc.ledger_info().clone()],
                        /* more = */ false,
                    ))
                    .await;
            }
```

**File:** consensus/src/block_storage/sync_manager.rs (L316-324)
```rust
        if highest_commit_cert.ledger_info().ledger_info().ends_epoch() {
            retriever
                .network
                .send_epoch_change(EpochChangeProof::new(
                    vec![highest_quorum_cert.ledger_info().clone()],
                    /* more = */ false,
                ))
                .await;
        }
```

**File:** consensus/src/persistent_liveness_storage.rs (L109-123)
```rust
        // We start from the block that storage's latest ledger info, if storage has end-epoch
        // LedgerInfo, we generate the virtual genesis block
        let (latest_commit_id, latest_ledger_info_sig) =
            if self.storage_ledger.ledger_info().ends_epoch() {
                let genesis =
                    Block::make_genesis_block_from_ledger_info(self.storage_ledger.ledger_info());
                let genesis_qc = QuorumCert::certificate_for_genesis_from_ledger_info(
                    self.storage_ledger.ledger_info(),
                    genesis.id(),
                );
                let genesis_ledger_info = genesis_qc.ledger_info().clone();
                let genesis_id = genesis.id();
                blocks.push(genesis);
                quorum_certs.push(genesis_qc);
                (genesis_id, genesis_ledger_info)
```

**File:** consensus/src/epoch_manager.rs (L1383-1418)
```rust
        match self.storage.start(
            consensus_config.order_vote_enabled(),
            consensus_config.window_size(),
        ) {
            LivenessStorageData::FullRecoveryData(initial_data) => {
                self.recovery_mode = false;
                self.start_round_manager(
                    consensus_key,
                    initial_data,
                    epoch_state,
                    consensus_config,
                    execution_config,
                    onchain_randomness_config,
                    jwk_consensus_config,
                    Arc::new(network_sender),
                    payload_client,
                    payload_manager,
                    rand_config,
                    fast_rand_config,
                    rand_msg_rx,
                    secret_share_msg_rx,
                )
                .await
            },
            LivenessStorageData::PartialRecoveryData(ledger_data) => {
                self.recovery_mode = true;
                self.start_recovery_manager(
                    ledger_data,
                    consensus_config,
                    epoch_state,
                    Arc::new(network_sender),
                )
                .await
            },
        }
    }
```
