# Audit Report

## Title
Network-Wide Denial of Service via Malicious Execution Pool Window Size Configuration

## Summary

A malicious on-chain consensus configuration can set the execution pool `window_size` parameter to extreme values (0 or u64::MAX), causing all consensus validators and observers to crash or experience severe resource exhaustion. This vulnerability lacks input validation at both the Move governance layer and Rust consensus implementation, enabling a network-wide liveness failure.

## Finding Description

The vulnerability exists in the execution pool window size configuration flow, which lacks validation of extreme values. The attack propagates as follows:

**Attack Vector 1: window_size = 0 (Node Crash)**

1. A malicious governance proposal sets `OnChainConsensusConfig` with `window_size: Some(0)` through the consensus_config module [1](#0-0) 

2. The Move code only validates that config bytes are non-empty, but does not validate the window_size value itself [2](#0-1) 

3. On epoch change, validators load the malicious config via `extract_on_chain_configs()`, extracting window_size without validation [3](#0-2) 

4. The window_size is stored in consensus state [4](#0-3) 

5. Regular validators initialize BlockStore with the malicious window_size [5](#0-4) 

6. When processing blocks via `insert_block()`, the code calls `get_ordered_block_window()` which invokes `calculate_window_start_round()` [6](#0-5) 

7. **CRITICAL FAILURE**: The `calculate_window_start_round()` function contains an assertion that panics if window_size is 0 [7](#0-6) 

8. All validators crash simultaneously, causing total network liveness failure

**Attack Vector 2: window_size = u64::MAX (Resource Exhaustion)**

Following the same configuration path, when `window_size = u64::MAX`:

1. The `calculate_window_start_round()` function returns `(current_round + 1).saturating_sub(u64::MAX)`, which equals 0 or near-zero [7](#0-6) 

2. Back in `get_ordered_block_window()`, the calculated window size becomes approximately equal to the current round number [8](#0-7) 

3. The while loop attempts to collect ALL blocks from genesis to current block into memory [9](#0-8) 

4. This causes memory exhaustion, severe performance degradation, or out-of-memory crashes

**Additional Attack Surface:**

The same vulnerability affects fast-forward sync operations where `calculate_window_start_round()` is called during node recovery [10](#0-9) 

This causes nodes attempting to rejoin the network to crash or hang, preventing recovery.

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under the Aptos Bug Bounty program for the following reasons:

1. **Total loss of liveness/network availability**: Setting window_size to 0 causes all validators to crash simultaneously via assertion failure, halting block production across the entire network.

2. **Non-recoverable network partition**: Once the malicious configuration is applied during an epoch change, all validators fail when processing the next block. Recovery requires either:
   - Emergency governance intervention (difficult if all validators are down)
   - Manual node restarts with overridden configuration (requires coordination)
   - Potential hard fork if the configuration persists

3. **Affects critical infrastructure**: Both regular consensus validators and consensus observers are affected, as they share the same code paths for block processing and window size calculations.

4. **Breaks core invariant #9**: "Resource Limits: All operations must respect gas, storage, and computational limits" - The u64::MAX case attempts unbounded memory allocation.

The severity meets the "up to $1,000,000" category for Critical findings involving "Total loss of liveness/network availability."

## Likelihood Explanation

**Likelihood: Medium-High**

While this requires a malicious governance proposal to execute, several factors increase the likelihood:

1. **No technical barriers**: There is zero validation preventing this attack at any layer (Move, Rust deserialization, or consensus initialization)

2. **Single point of failure**: One malicious or compromised governance participant with sufficient voting power could propose this

3. **Undetectable during proposal**: The malicious configuration appears syntactically valid and would pass all current checks

4. **Persistent damage**: Once applied, the configuration affects all subsequent epochs until manually corrected

5. **No alerting**: There are no safeguards, monitoring, or validation that would detect this configuration as dangerous before deployment

The attack complexity is low - it requires only crafting a governance proposal with specific numeric values.

## Recommendation

Implement defense-in-depth validation at multiple layers:

**1. Move Layer Validation** (Primary Defense):

Add validation in `consensus_config.move`:

```move
public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
    system_addresses::assert_aptos_framework(account);
    assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
    
    // Validate the deserialized config before storing
    validate_consensus_config(&config);
    
    std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
}

native fun validate_consensus_config(config_bytes: &vector<u8>);
```

**2. Rust Native Function Validation**:

Implement the native validator in `aptos-move/framework/src/natives/consensus_config.rs`:

```rust
pub fn validate_consensus_config(config_bytes: &[u8]) -> Result<()> {
    let config: OnChainConsensusConfig = bcs::from_bytes(config_bytes)?;
    
    if let Some(window_size) = config.window_size() {
        ensure!(
            window_size > 0 && window_size <= MAX_SAFE_WINDOW_SIZE,
            "Invalid window_size: must be between 1 and {}", 
            MAX_SAFE_WINDOW_SIZE
        );
    }
    
    Ok(())
}

const MAX_SAFE_WINDOW_SIZE: u64 = 1000; // Reasonable upper bound
```

**3. Rust Defensive Programming**:

Replace the assertion in `calculate_window_start_round()` with proper error handling:

```rust
pub fn calculate_window_start_round(current_round: Round, window_size: u64) -> Result<Round, Error> {
    ensure!(window_size > 0, "Window size must be greater than 0");
    ensure!(
        window_size <= MAX_SAFE_WINDOW_SIZE,
        "Window size {} exceeds maximum {}", 
        window_size, 
        MAX_SAFE_WINDOW_SIZE
    );
    Ok((current_round + 1).saturating_sub(window_size))
}
```

**4. Additional Safeguards**:

Add bounds checking when the window_size is loaded: [4](#0-3) 

```rust
let window_size = consensus_config.window_size();
if let Some(size) = window_size {
    ensure!(size > 0 && size <= MAX_SAFE_WINDOW_SIZE, 
        "Invalid window_size in on-chain config: {}", size);
}
self.execution_pool_window_size = window_size;
```

## Proof of Concept

**Rust Test Demonstrating Panic with window_size = 0:**

```rust
#[test]
#[should_panic(expected = "assertion failed: window_size > 0")]
fn test_window_size_zero_causes_panic() {
    use aptos_consensus::util::calculate_window_start_round;
    
    // This will panic due to assertion failure
    let _result = calculate_window_start_round(100, 0);
}
```

**Rust Test Demonstrating Resource Exhaustion with window_size = u64::MAX:**

```rust
#[test]
fn test_window_size_max_causes_massive_window() {
    use aptos_consensus::util::calculate_window_start_round;
    
    let current_round = 100_000; // Realistic round number
    let window_size = u64::MAX;
    
    let window_start = calculate_window_start_round(current_round, window_size);
    
    // Window start will be 0 due to saturating_sub
    assert_eq!(window_start, 0);
    
    // This means the window size will be current_round + 1
    let actual_window_size = current_round - window_start + 1;
    assert_eq!(actual_window_size, 100_001);
    
    // For a network at round 10,000,000, this would attempt to load
    // 10 million blocks into memory, causing resource exhaustion
}
```

**Move Script to Create Malicious Governance Proposal:**

```move
script {
    use aptos_framework::aptos_governance;
    use aptos_framework::consensus_config;
    
    fun malicious_window_size_proposal(proposal_creator: &signer) {
        // Create malicious consensus config with window_size = 0
        let malicious_config = /* BCS-serialized OnChainConsensusConfig::V4 
            with window_size: Some(0) */;
        
        consensus_config::set_for_next_epoch(proposal_creator, malicious_config);
        aptos_governance::reconfigure(proposal_creator);
        
        // After epoch change, all validators will crash when processing blocks
    }
}
```

## Notes

This vulnerability demonstrates a critical gap in the defense-in-depth strategy for on-chain configuration management. While governance is generally trusted, the lack of technical validation allows a single malicious or compromised configuration to cause catastrophic network failure. The fix requires coordinated changes across both Move and Rust layers to ensure robust validation of all consensus parameters before deployment.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L23-27)
```text
    public(friend) fun initialize(aptos_framework: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        move_to(aptos_framework, ConsensusConfig { config });
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```

**File:** consensus/src/consensus_observer/observer/epoch_state.rs (L100-103)
```rust
        self.epoch_state = Some(epoch_state.clone());
        self.execution_pool_window_size = consensus_config.window_size();
        self.quorum_store_enabled = consensus_config.quorum_store_enabled();
        info!(
```

**File:** consensus/src/consensus_observer/observer/epoch_state.rs (L156-166)
```rust
    // Extract the consensus config (or use the default if it's missing)
    let onchain_consensus_config: anyhow::Result<OnChainConsensusConfig> = on_chain_configs.get();
    if let Err(error) = &onchain_consensus_config {
        error!(
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Failed to read on-chain consensus config! Error: {:?}",
                error
            ))
        );
    }
    let consensus_config = onchain_consensus_config.unwrap_or_default();
```

**File:** consensus/src/epoch_manager.rs (L887-896)
```rust
        let block_store = Arc::new(BlockStore::new(
            Arc::clone(&self.storage),
            recovery_data,
            self.execution_client.clone(),
            self.config.max_pruned_blocks_in_mem,
            Arc::clone(&self.time_service),
            self.config.vote_back_pressure_limit,
            payload_manager,
            onchain_consensus_config.order_vote_enabled(),
            onchain_consensus_config.window_size(),
```

**File:** consensus/src/block_storage/block_tree.rs (L281-284)
```rust
        let round = block.round();
        let window_start_round = calculate_window_start_round(round, window_size);
        let window_size = round - window_start_round + 1;
        ensure!(window_size > 0, "window_size must be greater than 0");
```

**File:** consensus/src/block_storage/block_tree.rs (L290-299)
```rust
        while !current_block.is_genesis_block()
            && current_block.quorum_cert().certified_block().round() >= window_start_round
        {
            if let Some(current_pipelined_block) = self.get_block(&current_block.parent_id()) {
                current_block = current_pipelined_block.block().clone();
                window.push(current_pipelined_block);
            } else {
                bail!("Parent block not found for block {}", current_block.id());
            }
        }
```

**File:** consensus/src/util/mod.rs (L26-29)
```rust
pub fn calculate_window_start_round(current_round: Round, window_size: u64) -> Round {
    assert!(window_size > 0);
    (current_round + 1).saturating_sub(window_size)
}
```

**File:** consensus/src/block_storage/sync_manager.rs (L350-355)
```rust
                let target_round = calculate_window_start_round(
                    highest_commit_cert.ledger_info().ledger_info().round(),
                    window_size,
                )
                .max(1); // Never retrieve genesis block
                let num_blocks = highest_quorum_cert.certified_block().round() - target_round + 1;
```
