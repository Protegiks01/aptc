# Audit Report

## Title
Remote Executor Network Communication Lacks TLS Encryption and Authentication, Enabling Transaction Data Interception and Man-in-the-Middle Attacks

## Summary
The remote executor infrastructure uses unencrypted HTTP for gRPC communication, transmitting sensitive transaction data in cleartext without any authentication mechanism. This allows network-level attackers to intercept transaction details and potentially inject malicious messages.

## Finding Description

The Aptos remote executor service, used for distributed transaction execution across shards, communicates over plain HTTP without TLS encryption or authentication. This breaks fundamental security guarantees for network communication.

**Vulnerable Code Path:**

The gRPC client explicitly connects using HTTP instead of HTTPS: [1](#0-0) 

The remote executor service initializes the network controller without any TLS configuration: [2](#0-1) 

**Critical Production Usage:**

This is not just benchmark codeâ€”the production executor workflow uses remote executors when configured: [3](#0-2) 

**Sensitive Data Transmitted:**

The remote executor client sends `AnalyzedTransaction` objects containing full transaction details: [4](#0-3) 

These transactions include: [5](#0-4) 

Which wrap `SignatureVerifiedTransaction` containing: [6](#0-5) 

The underlying `Transaction` enum includes user transactions with sender addresses, payloads, signatures, and gas parameters: [7](#0-6) 

**Attack Scenario:**

1. Validator node is configured with remote executors via command-line arguments [8](#0-7) 

2. Network-level attacker positions themselves between coordinator and remote executor (e.g., compromised network infrastructure, ARP spoofing, BGP hijacking)

3. Attacker intercepts unencrypted gRPC messages on the network

4. Transaction data including sender addresses, transaction payloads (transfers, smart contract calls), arguments, and amounts are exposed in cleartext

5. Without authentication, attacker can also inject forged execution requests or responses, potentially causing:
   - Incorrect execution results
   - Denial of service by sending malformed messages
   - State inconsistencies between shards

## Impact Explanation

**HIGH Severity** per Aptos bug bounty criteria:

1. **Confidentiality Breach**: Transaction data leakage exposes sensitive user information including:
   - Account addresses
   - Transaction amounts and recipients
   - Smart contract function calls and parameters
   - Sequence numbers

2. **Integrity Risk**: Lack of authentication allows message injection/modification, potentially causing:
   - State inconsistencies between execution shards
   - Incorrect transaction execution results
   - Protocol violations

3. **Validator Node Security**: Affects validator nodes using remote executor configuration, potentially compromising network security

While this doesn't directly cause consensus violations or fund theft, it represents a significant protocol violation and security breach that could facilitate other attacks.

## Likelihood Explanation

**Moderate to High Likelihood:**

1. **Ease of Exploitation**: Standard MITM attacks are well-understood and tooling exists
2. **Network Visibility**: Unencrypted traffic is trivially interceptable on shared networks
3. **Limited Deployment**: Depends on how many validators actually configure remote executors
4. **Configuration-Dependent**: Only affects nodes with `remote_executor_addresses` configured

The vulnerability is exploitable whenever:
- Remote executors are configured (via CLI or environment)
- Attacker has network-level access (same subnet, compromised router, ISP-level)
- Traffic traverses untrusted networks

## Recommendation

**Immediate Fix: Enable TLS for All Remote Executor Communication**

1. Modify the gRPC client to use HTTPS with TLS:

```rust
// In secure/net/src/grpc_network_service/mod.rs
async fn get_channel(remote_addr: String) -> NetworkMessageServiceClient<Channel> {
    info!("Trying to connect to remote server at {:?}", remote_addr);
    
    // Use HTTPS instead of HTTP
    let tls_config = tonic::transport::ClientTlsConfig::new()
        .domain_name("remote-executor"); // Configure appropriate domain
    
    let conn = tonic::transport::Endpoint::new(format!("https://{}", remote_addr))
        .unwrap()
        .tls_config(tls_config)
        .unwrap()
        .connect_lazy();
    
    NetworkMessageServiceClient::new(conn).max_decoding_message_size(MAX_MESSAGE_SIZE)
}
```

2. Configure server-side TLS in the executor service:

```rust
// In secure/net/src/grpc_network_service/mod.rs (server)
async fn start_async(...) {
    let tls_config = tonic::transport::ServerTlsConfig::new()
        .identity(/* load certificate and key */);
    
    Server::builder()
        .tls_config(tls_config).unwrap()
        .timeout(std::time::Duration::from_millis(rpc_timeout_ms))
        // ... rest of configuration
}
```

3. **Add Mutual TLS (mTLS) Authentication**:
   - Require client certificates to verify executor identity
   - Validate certificates against known executors
   - Reject connections from unauthorized clients

4. **Certificate Management**:
   - Implement proper certificate rotation
   - Use validator identity for cert generation
   - Store certs securely with restricted permissions

## Proof of Concept

**Network Interception PoC:**

```bash
# 1. Start a remote executor with address 127.0.0.1:8080
# 2. Start coordinator configured to use remote executor
# 3. Intercept traffic with tcpdump/wireshark

sudo tcpdump -i lo -A 'tcp port 8080' -w remote_executor_traffic.pcap

# 4. Analyze captured packets - transaction data will be visible in cleartext
wireshark remote_executor_traffic.pcap

# Expected Result: Transaction payloads visible as BCS-serialized data
# in HTTP/2 frames without encryption
```

**Verification Steps:**

1. Configure executor-benchmark with remote executors:
```bash
cargo run -p aptos-executor-benchmark -- \
  --remote-executor-addresses 192.168.1.100:8080,192.168.1.101:8080 \
  --coordinator-address 192.168.1.1:52200
```

2. Monitor network traffic on the wire
3. Observe unencrypted gRPC messages containing transaction data
4. Verify absence of TLS handshake in packet capture

**Impact Demonstration:**

The vulnerability breaks the security invariant that sensitive transaction data must be protected during transmission. Any network observer can read transaction details, violating user privacy and potentially enabling targeted attacks based on transaction patterns.

## Notes

- The TODO comment in `transaction_bench_state.rs` indicates awareness that remote executor support needs completion, but the underlying network infrastructure is already implemented and used in production code paths [9](#0-8) 

- The executor workflow will use remote executors when addresses are configured, making this a production security issue, not just a benchmarking concern [10](#0-9) 

- This vulnerability affects the **Cryptographic Correctness** invariant (secure network communications) and general network security best practices

- No authentication mechanism exists in the message handlers, allowing any network peer to send messages [11](#0-10)

### Citations

**File:** secure/net/src/grpc_network_service/mod.rs (L91-115)
```rust
#[tonic::async_trait]
impl NetworkMessageService for GRPCNetworkMessageServiceServerWrapper {
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
```

**File:** secure/net/src/grpc_network_service/mod.rs (L124-138)
```rust
    pub fn new(rt: &Runtime, remote_addr: SocketAddr) -> Self {
        Self {
            remote_addr: remote_addr.to_string(),
            remote_channel: rt
                .block_on(async { Self::get_channel(format!("http://{}", remote_addr)).await }),
        }
    }

    async fn get_channel(remote_addr: String) -> NetworkMessageServiceClient<Channel> {
        info!("Trying to connect to remote server at {:?}", remote_addr);
        let conn = tonic::transport::Endpoint::new(remote_addr)
            .unwrap()
            .connect_lazy();
        NetworkMessageServiceClient::new(conn).max_decoding_message_size(MAX_MESSAGE_SIZE)
    }
```

**File:** execution/executor-service/src/remote_executor_service.rs (L21-55)
```rust
impl ExecutorService {
    pub fn new(
        shard_id: ShardId,
        num_shards: usize,
        num_threads: usize,
        self_address: SocketAddr,
        coordinator_address: SocketAddr,
        remote_shard_addresses: Vec<SocketAddr>,
    ) -> Self {
        let service_name = format!("executor_service-{}", shard_id);
        let mut controller = NetworkController::new(service_name, self_address, 5000);
        let coordinator_client = Arc::new(RemoteCoordinatorClient::new(
            shard_id,
            &mut controller,
            coordinator_address,
        ));
        let cross_shard_client = Arc::new(RemoteCrossShardClient::new(
            &mut controller,
            remote_shard_addresses,
        ));

        let executor_service = Arc::new(ShardedExecutorService::new(
            shard_id,
            num_shards,
            num_threads,
            coordinator_client,
            cross_shard_client,
        ));

        Self {
            shard_id,
            controller,
            executor_service,
        }
    }
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L256-276)
```rust
    fn execute_block_sharded<V: VMBlockExecutor>(
        partitioned_txns: PartitionedTransactions,
        state_view: Arc<CachedStateView>,
        onchain_config: BlockExecutorConfigFromOnchain,
    ) -> Result<Vec<TransactionOutput>> {
        if !get_remote_addresses().is_empty() {
            Ok(V::execute_block_sharded(
                &REMOTE_SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        } else {
            Ok(V::execute_block_sharded(
                &SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        }
    }
```

**File:** execution/executor-service/src/remote_executor_client.rs (L180-206)
```rust
    fn execute_block(
        &self,
        state_view: Arc<S>,
        transactions: PartitionedTransactions,
        concurrency_level_per_shard: usize,
        onchain_config: BlockExecutorConfigFromOnchain,
    ) -> Result<ShardedExecutionOutput, VMStatus> {
        trace!("RemoteExecutorClient Sending block to shards");
        self.state_view_service.set_state_view(state_view);
        let (sub_blocks, global_txns) = transactions.into();
        if !global_txns.is_empty() {
            panic!("Global transactions are not supported yet");
        }
        for (shard_id, sub_blocks) in sub_blocks.into_iter().enumerate() {
            let senders = self.command_txs.clone();
            let execution_request = RemoteExecutionRequest::ExecuteBlock(ExecuteBlockCommand {
                sub_blocks,
                concurrency_level: concurrency_level_per_shard,
                onchain_config: onchain_config.clone(),
            });

            senders[shard_id]
                .lock()
                .unwrap()
                .send(Message::new(bcs::to_bytes(&execution_request).unwrap()))
                .unwrap();
        }
```

**File:** types/src/transaction/analyzed_transaction.rs (L23-37)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AnalyzedTransaction {
    transaction: SignatureVerifiedTransaction,
    /// Set of storage locations that are read by the transaction - this doesn't include location
    /// that are written by the transactions to avoid duplication of locations across read and write sets
    /// This can be accurate or strictly overestimated.
    pub read_hints: Vec<StorageLocation>,
    /// Set of storage locations that are written by the transaction. This can be accurate or strictly
    /// overestimated.
    pub write_hints: Vec<StorageLocation>,
    /// A transaction is predictable if neither the read_hint or the write_hint have wildcards.
    predictable_transaction: bool,
    /// The hash of the transaction - this is cached for performance reasons.
    hash: HashValue,
}
```

**File:** types/src/transaction/signature_verified_transaction.rs (L18-22)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub enum SignatureVerifiedTransaction {
    Valid(Transaction),
    Invalid(Transaction),
}
```

**File:** types/src/transaction/mod.rs (L2938-2977)
```rust
/// `Transaction` will be the transaction type used internally in the aptos node to represent the
/// transaction to be processed and persisted.
///
/// We suppress the clippy warning here as we would expect most of the transaction to be user
/// transaction.
#[allow(clippy::large_enum_variant)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
pub enum Transaction {
    /// Transaction submitted by the user. e.g: P2P payment transaction, publishing module
    /// transaction, etc.
    /// TODO: We need to rename SignedTransaction to SignedUserTransaction, as well as all the other
    ///       transaction types we had in our codebase.
    UserTransaction(SignedTransaction),

    /// Transaction that applies a WriteSet to the current storage, it's applied manually via aptos-db-bootstrapper.
    GenesisTransaction(WriteSetPayload),

    /// Transaction to update the block metadata resource at the beginning of a block,
    /// when on-chain randomness is disabled.
    BlockMetadata(BlockMetadata),

    /// Transaction to let the executor update the global state tree and record the root hash
    /// in the TransactionInfo
    /// The hash value inside is unique block id which can generate unique hash of state checkpoint transaction
    StateCheckpoint(HashValue),

    /// Transaction that only proposed by a validator mainly to update on-chain configs.
    ValidatorTransaction(ValidatorTransaction),

    /// Transaction to update the block metadata resource at the beginning of a block,
    /// when on-chain randomness is enabled.
    BlockMetadataExt(BlockMetadataExt),

    /// Transaction to let the executor update the global state tree and record the root hash
    /// in the TransactionInfo
    /// The hash value inside is unique block id which can generate unique hash of state checkpoint transaction
    /// Replaces StateCheckpoint, with optionally having more data.
    BlockEpilogue(BlockEpiloguePayload),
}
```

**File:** aptos-move/aptos-transaction-benchmarks/src/main.rs (L78-79)
```rust
    #[clap(long, num_args = 1.., conflicts_with = "num_executor_shards")]
    pub remote_executor_addresses: Option<Vec<SocketAddr>>,
```

**File:** aptos-move/aptos-transaction-benchmarks/src/transaction_bench_state.rs (L84-85)
```rust
        // TODO(skedia): add support for remote executor addresses.
        _remote_executor_addresses: Option<Vec<SocketAddr>>,
```
