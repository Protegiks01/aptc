# Audit Report

## Title
JWK Consensus HashMap Memory Exhaustion via Unvalidated Issuer Requests

## Summary
Byzantine validators can exhaust memory on honest validators by sending `ObservationRequest` messages with arbitrary issuer names. The `process_peer_request()` function creates HashMap entries without validating that the requested issuer exists in the supported OIDC providers list, enabling unbounded memory growth between infrequent cleanup events.

## Finding Description

The JWK consensus mechanism processes peer requests for OIDC issuer observations without validating that the requested issuer is in the supported providers list. The vulnerability exists in the issuer-level consensus mode where `process_peer_request()` unconditionally creates HashMap entries: [1](#0-0) 

The same pattern exists in key-level consensus mode, creating entries for arbitrary (issuer, kid) pairs: [2](#0-1) 

**Attack Path:**

1. Byzantine validator (within <1/3 threat model) crafts `ObservationRequest` messages with unique, non-existent issuer names
2. Sends requests through the validator network to honest validators
3. Each request triggers HashMap entry creation via `.or_default()`
4. Entries persist in memory until next on-chain JWK update event
5. Attacker continuously cycles through channel capacity, accumulating entries over hours/days
6. Memory exhaustion causes GC pressure, slowdowns, or crashes

**Evidence of Missing Invariant:**

The `reset_with_on_chain_state()` function explicitly demonstrates that only on-chain issuers should persist: [3](#0-2) 

This cleanup retains only issuers in `onchain_issuer_set`, but `process_peer_request()` bypasses this invariant by creating entries on-demand for any requested issuer.

**Rate Limiting Insufficiency:**

Network channels have limited capacity: [4](#0-3) [5](#0-4) 

However, these limits do not prevent memory exhaustion because:
- Requests are processed quickly (milliseconds), freeing channel space
- HashMap entries persist after processing
- Cleanup only occurs on `ObservedJWKsUpdated` events (triggered by on-chain JWK updates)
- Between cleanup events (potentially hours or days), attacker can accumulate thousands to millions of entries
- At ~32 bytes per default entry plus HashMap overhead, this scales to megabytes or gigabytes

## Impact Explanation

**Severity: HIGH**

This vulnerability qualifies as **HIGH severity** under Aptos bug bounty category #8: "Validator Node Slowdowns - DoS through resource exhaustion."

**Quantified Impact:**
- Memory consumption grows linearly with unique issuer names sent
- Default `PerProviderState` entries (None, None, NotStarted) consume ~16-32 bytes plus HashMap overhead
- Over time between cleanup events: 10 requests/cycle Ã— continuous cycling = thousands of entries/hour
- Potential accumulation: 100K-1M entries = 3-32 MB to 32-320 MB per validator
- Memory exhaustion causes: increased GC pressure, degraded performance, potential OOM crashes
- Affects consensus participation and validator availability

This does NOT cause consensus safety violations (no chain splits or fund loss) but degrades availability by exhausting validator resources, which is the defining characteristic of HIGH severity validator slowdowns.

## Likelihood Explanation

**Likelihood: HIGH**

**Requirements:**
- Attacker must be a validator or compromise validator network identity
- This is the standard threat model (Byzantine validators < 1/3)
- No cryptographic breaks or special conditions required

**Execution Simplicity:**
- Trivial attack: send RPC messages with varying issuer names
- Can be executed continuously throughout an epoch
- Difficult to attribute to specific validator
- No existing per-issuer rate limiting or validation

**Realistic Constraints:**
- Channel size limits concurrent requests but not total accumulation
- Cleanup frequency depends on on-chain JWK update rate (typically infrequent)
- Attacker has hours to days to build up malicious entries

## Recommendation

Implement issuer validation in `process_peer_request()` before creating HashMap entries:

```rust
pub fn process_peer_request(&mut self, rpc_req: IncomingRpcRequest) -> Result<()> {
    let IncomingRpcRequest {
        msg,
        mut response_sender,
        ..
    } = rpc_req;
    match msg {
        JWKConsensusMsg::ObservationRequest(request) => {
            // Validate issuer exists in states_by_issuer (populated from on-chain state)
            let state = match self.states_by_issuer.get_mut(&request.issuer) {
                Some(state) => state,
                None => {
                    response_sender.send(Err(anyhow!("unknown issuer")));
                    return Ok(());
                }
            };
            
            let response: Result<JWKConsensusMsg> = match &state.consensus_state {
                ConsensusState::NotStarted => Err(anyhow!("observed update unavailable")),
                ConsensusState::InProgress { my_proposal, .. }
                | ConsensusState::Finished { my_proposal, .. } => Ok(
                    JWKConsensusMsg::ObservationResponse(ObservedUpdateResponse {
                        epoch: self.epoch_state.epoch,
                        update: my_proposal.clone(),
                    }),
                ),
            };
            response_sender.send(response);
            Ok(())
        },
        _ => {
            bail!("unexpected rpc: {}", msg.name());
        },
    }
}
```

Apply the same fix to `KeyLevelConsensusManager::process_peer_request()` for key-level mode.

## Proof of Concept

```rust
#[test]
fn test_memory_exhaustion_via_unvalidated_issuer() {
    // Setup: Create JWK manager with legitimate on-chain issuer
    let legitimate_issuer = b"https://legitimate.issuer".to_vec();
    let mut manager = setup_jwk_manager_with_issuer(legitimate_issuer.clone());
    
    // Initial state: Only legitimate issuer in HashMap
    assert_eq!(manager.states_by_issuer.len(), 1);
    
    // Attack: Send requests for 1000 non-existent issuers
    for i in 0..1000 {
        let fake_issuer = format!("https://fake-issuer-{}", i).into_bytes();
        let request = JWKConsensusMsg::ObservationRequest(ObservationRequest {
            epoch: 1,
            issuer: fake_issuer,
        });
        
        // Process request - creates HashMap entry via .or_default()
        let _ = manager.process_peer_request(create_rpc_request(request));
    }
    
    // Vulnerability: HashMap now contains 1001 entries (1 legitimate + 1000 fake)
    assert_eq!(manager.states_by_issuer.len(), 1001);
    
    // Entries persist until reset_with_on_chain_state() is called
    // which only happens on ObservedJWKsUpdated events (infrequent)
    
    // Cleanup would remove fake entries:
    manager.reset_with_on_chain_state(create_on_chain_state(vec![legitimate_issuer])).unwrap();
    assert_eq!(manager.states_by_issuer.len(), 1);
}
```

### Citations

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L252-253)
```rust
        self.states_by_issuer
            .retain(|issuer, _| onchain_issuer_set.contains(issuer));
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L302-302)
```rust
                let state = self.states_by_issuer.entry(request.issuer).or_default();
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L276-276)
```rust
                    .entry((issuer.clone(), kid.clone()))
```

**File:** crates/aptos-jwk-consensus/src/network.rs (L169-169)
```rust
        let (rpc_tx, rpc_rx) = aptos_channel::new(QueueStyle::FIFO, 10, None);
```

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L222-222)
```rust
            let (jwk_rpc_msg_tx, jwk_rpc_msg_rx) = aptos_channel::new(QueueStyle::FIFO, 100, None);
```
