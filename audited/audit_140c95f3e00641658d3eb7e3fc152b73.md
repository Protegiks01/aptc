# Audit Report

## Title
IP Spoofing Vulnerability in Aptos Faucet Rate Limiting Allows Unlimited Fund Requests

## Summary
The Aptos faucet's rate limiting mechanism can be completely bypassed by spoofing the `X-Forwarded-For` or `X-Real-IP` HTTP headers. An attacker can make unlimited funding requests by rotating through arbitrary IP addresses, exhausting faucet resources and denying service to legitimate users.

## Finding Description

The faucet uses the `RealIp` extractor from the `poem` web framework to determine the client's source IP address for rate limiting purposes. [1](#0-0)  The comments explicitly acknowledge that this extractor reads from proxy headers like `X-Forwarded-For` and `X-Real-IP`. [2](#0-1) 

The extracted IP address is then used without validation as the source IP in the `CheckerData` structure. [3](#0-2)  This source IP becomes the rate limiting key when using IP-based rate limiting. [4](#0-3) 

**Attack Flow:**

1. Attacker sends a funding request with header `X-Forwarded-For: 1.2.3.4`
2. The `RealIp` extractor parses this header and returns `1.2.3.4` [5](#0-4) 
3. Rate limiter creates key `"ip:1.2.3.4:DAY"` and increments counter
4. Attacker sends next request with `X-Forwarded-For: 5.6.7.8`
5. Rate limiter treats this as a completely different client with a fresh rate limit quota
6. Attacker repeats with arbitrary IPs, bypassing all rate limits

**Root Cause:**

The `poem` framework's `RealIp` extractor automatically trusts proxy headers without any configuration for trusted proxy IP addresses. In production deployments where the faucet is exposed directly to the internet (as shown in the Docker Compose configuration [6](#0-5) ), any client can set these headers to arbitrary values.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria:

1. **API crashes / significant protocol violations**: The rate limiting mechanism is a critical security control. Its complete bypass constitutes a significant protocol violation that can lead to:
   - Resource exhaustion of the faucet service
   - Denial of service to legitimate testnet users
   - Potential draining of testnet funds allocated to the faucet

2. **Service Availability Impact**: An attacker can make unlimited requests, potentially:
   - Exhausting the faucet's transaction submission capacity
   - Overloading the backing validator node with excessive transactions
   - Depleting the faucet account balance in JWT-bypass mode configurations

3. **Breaks Resource Limits Invariant**: The vulnerability directly violates the documented invariant that "All operations must respect gas, storage, and computational limits" - rate limiting is the mechanism to enforce these limits on faucet operations.

## Likelihood Explanation

**Likelihood: Very High**

1. **Trivial to Exploit**: Any HTTP client (curl, browser, Python script) can set custom headers. No specialized tools or knowledge required beyond basic HTTP.

2. **No Authentication Required**: The attack works on the default faucet endpoint without any authentication tokens or bypasser requirements.

3. **Widely Known Attack Vector**: IP spoofing via proxy headers is a well-documented vulnerability pattern. Security-conscious attackers will immediately test for this.

4. **Current Deployment Model**: The Docker Compose configuration shows the faucet is deployed without a reverse proxy [6](#0-5) , making the vulnerability immediately exploitable in default deployments.

## Recommendation

**Immediate Fix: Use Socket Address Instead of Proxy Headers**

For deployments where the faucet is NOT behind a reverse proxy (current default), extract the IP address directly from the TCP socket connection instead of trusting proxy headers:

```rust
// In fund.rs, replace RealIp parameter with RemoteAddr
use poem::web::RemoteAddr;

async fn fund(
    &self,
    fund_request: Json<FundRequest>,
    asset: poem_openapi::param::Query<Option<String>>,
    // Use RemoteAddr instead of RealIp - gets IP from socket, not headers
    source_addr: RemoteAddr,
    header_map: &HeaderMap,
) -> poem::Result<Json<FundResponse>, AptosTapErrorResponse> {
    let source_ip = source_addr.0.ip();
    // ... rest of implementation
}
```

**Long-term Solution: Configure Trusted Proxy List**

For deployments behind reverse proxies (load balancers, CDNs), implement trusted proxy validation:

1. Add configuration option for trusted proxy IP ranges
2. Only parse proxy headers if the direct connection comes from a trusted proxy
3. Use socket IP if not from trusted proxy
4. Document deployment requirements clearly

**Additional Mitigations:**

1. Implement JWT-based rate limiting as the primary mechanism (not IP-based)
2. Add multiple rate limiting layers (per-account, per-transaction-type)
3. Monitor for suspicious patterns (many unique IPs from single source)

## Proof of Concept

```bash
#!/bin/bash
# PoC: Bypass rate limiting by spoofing IP addresses

FAUCET_URL="http://127.0.0.1:8081/fund"
TARGET_ADDRESS="0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"

echo "Making 10 requests with different spoofed IPs..."
for i in {1..10}; do
    SPOOFED_IP="10.0.0.$i"
    echo "Request $i with IP: $SPOOFED_IP"
    
    curl -X POST "$FAUCET_URL" \
        -H "Content-Type: application/json" \
        -H "X-Forwarded-For: $SPOOFED_IP" \
        -H "X-Real-IP: $SPOOFED_IP" \
        -d "{\"address\": \"$TARGET_ADDRESS\", \"amount\": 100000000}" \
        -w "\nStatus: %{http_code}\n\n"
    
    sleep 0.1
done

echo "All 10 requests completed successfully, bypassing the 3-per-day rate limit"
```

**Expected Result**: All 10 requests succeed with HTTP 200, each appearing to come from a different IP address. The Redis rate limiter creates 10 separate keys (`ip:10.0.0.1:DAY`, `ip:10.0.0.2:DAY`, etc.), each with a count of 1, instead of rejecting requests 4-10 as it should when they all come from the same actual source.

**To Verify the Vulnerability:**

1. Start a local testnet: `cargo run -p aptos -- node run-local-testnet`
2. Start the faucet with Redis rate limiting enabled (max 3 requests/day)
3. Run the PoC script above
4. Observe that all requests succeed despite exceeding the rate limit
5. Check Redis: `redis-cli KEYS "ip:*"` shows 10 different keys instead of 1

## Notes

This vulnerability affects all faucet deployments that use IP-based rate limiting (`RatelimitKeyProvider::Ip`) and are not behind a properly configured reverse proxy that strips client-provided forwarding headers. The same issue exists in the telemetry service [7](#0-6) , though with different impact (incorrect IP logging rather than security bypass).

### Citations

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L106-108)
```rust
        // This automagically uses FromRequest to get this data from the request.
        // It takes into things like X-Forwarded-IP and X-Real-IP.
        source_ip: RealIp,
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L217-225)
```rust
        let source_ip = match source_ip.0 {
            Some(ip) => ip,
            None => {
                return Err(AptosTapError::new(
                    "No source IP found in the request".to_string(),
                    AptosTapErrorCode::SourceIpMissing,
                ))
            },
        };
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L237-242)
```rust
        let checker_data = CheckerData {
            receiver,
            source_ip,
            headers: Arc::new(header_map.clone()),
            time_request_received_secs: get_current_time_secs(),
        };
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L44-46)
```rust
    pub async fn ratelimit_key_value(&self, data: &CheckerData) -> Result<String, AptosTapError> {
        match self {
            RatelimitKeyProvider::Ip => Ok(data.source_ip.to_string()),
```

**File:** docker/compose/validator-testnet/docker-compose.yaml (L76-77)
```yaml
    ports:
      - "8081:8081"
```

**File:** crates/aptos-telemetry-service/src/custom_event.rs (L77-80)
```rust
    let client_ip = forwarded_for
        .as_ref()
        .and_then(|xff| xff.split(',').next())
        .unwrap_or("UNKNOWN");
```
