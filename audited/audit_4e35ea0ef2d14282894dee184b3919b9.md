# Audit Report

## Title
Rosetta API Error Code Collision Causing Potential Mishandling of Transaction Update Failures by Exchanges

## Summary
The Aptos Rosetta API implementation contains error code collisions where multiple distinct error conditions map to the same error code, violating the Rosetta API specification. Specifically, three different REST API error types (`InvalidInput`, `InvalidTransactionUpdate`, and `BcsNotSupported`) all map to Rosetta error code 28, while the dedicated `InvalidTransactionUpdate` variant (code 29) is advertised but never returned. Additionally, the `RejectedByFilter` error is used but not advertised in the `/network/options` endpoint. [1](#0-0) 

## Finding Description

The Rosetta API specification requires unique error codes for each distinct error type to enable programmatic error handling by integrators such as cryptocurrency exchanges. The Aptos Rosetta implementation violates this requirement through improper error mapping.

**Error Code 28 Collision:**

The `From<RestError>` implementation incorrectly maps three distinct REST API errors to the same Rosetta error code 28: [2](#0-1) [3](#0-2) 

These mappings cause `AptosErrorCode::InvalidTransactionUpdate` (401) and `AptosErrorCode::BcsNotSupported` (602) to both return Rosetta error code 28 instead of their intended distinct codes.

**Unused Error Code 29:**

The `ApiError::InvalidTransactionUpdate` variant is assigned code 29 and included in the error list returned to exchanges: [4](#0-3) [5](#0-4) 

However, this error code is never actually returned due to the incorrect mapping at line 300, creating a mismatch between advertised and actual error codes.

**Missing Error Code 35:**

The `RejectedByFilter` error (code 35) is defined and can be returned but is not included in the `all()` method, meaning exchanges are never informed this error exists. [6](#0-5) 

**Attack Scenario:**

When a transaction update attempt fails (e.g., user tries to change a pending withdrawal's recipient), the mempool returns `InvalidUpdate`, which becomes `AptosErrorCode::InvalidTransactionUpdate`: [7](#0-6) 

This gets incorrectly mapped to `InvalidInput` (code 28) instead of `InvalidTransactionUpdate` (code 29). An exchange implementing code-based error handling might:
1. Treat code 28 as "user input formatting error" 
2. Mark the original transaction as failed
3. Allow the user to submit another withdrawal
4. The original transaction still executes later, causing double-withdrawal

## Impact Explanation

This qualifies as **Medium Severity** under the bug bounty program's definition of "Limited funds loss or manipulation." The vulnerability could enable:

1. **Transaction State Confusion**: Exchanges cannot distinguish between benign input errors and transaction-already-in-mempool errors
2. **Potential Double-Spending**: If exchanges rely on error codes for transaction state management, they might incorrectly mark pending transactions as failed
3. **Incorrect Retry Logic**: Generic errors (code 28) may trigger different retry behavior than transaction-specific errors (code 29)

The impact is conditional on exchange implementation qualityâ€”well-designed exchanges checking error messages will be unaffected. However, the Rosetta specification explicitly requires unique error codes to prevent such issues, and many integrators rely on codes for automated handling.

## Likelihood Explanation

**Likelihood: Medium**

- The error collision exists in production code and affects all Rosetta API users
- Transaction update scenarios occur whenever users attempt to modify pending transactions
- Exchanges commonly implement code-based error handling for automation
- However, exploitation requires exchanges to implement insufficient error checking
- The `retriable` flag correctly indicates non-retriability for affected errors, providing partial mitigation

## Recommendation

**Fix 1: Correct the error mapping** [8](#0-7) 

Change line 300 to map to the correct variant:
```rust
AptosErrorCode::InvalidTransactionUpdate => {
    ApiError::InvalidTransactionUpdate(Some(err.error.message))
},
```

**Fix 2: Add missing error to all() method** [9](#0-8) 

Add after line 104:
```rust
RejectedByFilter(None),
```

**Fix 3: Review all error mappings for uniqueness**

Ensure each `AptosErrorCode` maps to a unique `ApiError` variant with a unique code number. Document the mapping explicitly.

## Proof of Concept

```rust
// Compile and run this test in the aptos-rosetta crate to demonstrate the collision
#[test]
fn test_error_code_collision() {
    use crate::error::ApiError;
    use aptos_rest_client::error::{RestError, AptosError};
    use aptos_rest_client::aptos_api_types::AptosErrorCode;
    
    // Create REST API errors
    let invalid_input_rest = RestError::Api(AptosError {
        message: "Invalid input".to_string(),
        error_code: AptosErrorCode::InvalidInput,
        vm_error_code: None,
    });
    
    let invalid_update_rest = RestError::Api(AptosError {
        message: "Invalid transaction update".to_string(),
        error_code: AptosErrorCode::InvalidTransactionUpdate,
        vm_error_code: None,
    });
    
    let bcs_not_supported_rest = RestError::Api(AptosError {
        message: "BCS not supported".to_string(),
        error_code: AptosErrorCode::BcsNotSupported,
        vm_error_code: None,
    });
    
    // Convert to ApiError
    let api_error_1: ApiError = invalid_input_rest.into();
    let api_error_2: ApiError = invalid_update_rest.into();
    let api_error_3: ApiError = bcs_not_supported_rest.into();
    
    // All three map to code 28 - COLLISION!
    assert_eq!(api_error_1.code(), 28);
    assert_eq!(api_error_2.code(), 28); // Should be 29!
    assert_eq!(api_error_3.code(), 28);
    
    // Verify that code 29 exists but is never used
    let unused_error = ApiError::InvalidTransactionUpdate(Some("test".to_string()));
    assert_eq!(unused_error.code(), 29); // Code 29 is advertised but never returned!
    
    println!("Error code collision confirmed: 3 distinct errors map to code 28");
    println!("Code 29 exists but is unreachable through REST API conversion");
}
```

## Notes

This vulnerability is specific to the Rosetta API integration layer and does not affect core blockchain consensus, execution, or state management. The severity is rated Medium because while error code collisions can cause incorrect error handling by exchanges, the actual exploitability depends on exchange implementation quality. Exchanges following Rosetta best practices (checking both error codes and messages) will not be significantly affected, though the specification violation should still be corrected for API compliance and defense-in-depth.

### Citations

**File:** crates/aptos-rosetta/src/types/misc.rs (L33-44)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct Error {
    /// Error code
    pub code: u32,
    /// Message that always matches the error code
    pub message: String,
    /// Whether a call can retry on the error
    pub retriable: bool,
    /// Specific details of the error e.g. stack trace
    #[serde(skip_serializing_if = "Option::is_none")]
    pub details: Option<ErrorDetails>,
}
```

**File:** crates/aptos-rosetta/src/error.rs (L55-55)
```rust
    RejectedByFilter(Option<String>),
```

**File:** crates/aptos-rosetta/src/error.rs (L68-106)
```rust
    pub fn all() -> Vec<ApiError> {
        use ApiError::*;
        vec![
            TransactionIsPending,
            NetworkIdentifierMismatch,
            ChainIdMismatch,
            DeserializationFailed(None),
            InvalidTransferOperations(None),
            InvalidSignatureType,
            InvalidMaxGasFees,
            MaxGasFeeTooLow(None),
            InvalidGasMultiplier,
            GasEstimationFailed(None),
            InvalidOperations(None),
            MissingPayloadMetadata,
            UnsupportedCurrency(None),
            UnsupportedSignatureCount(None),
            NodeIsOffline,
            TransactionParseError(None),
            InternalError(None),
            CoinTypeFailedToBeFetched(None),
            AccountNotFound(None),
            ResourceNotFound(None),
            ModuleNotFound(None),
            StructFieldNotFound(None),
            VersionNotFound(None),
            TransactionNotFound(None),
            TableItemNotFound(None),
            BlockNotFound(None),
            StateValueNotFound(None),
            VersionPruned(None),
            BlockPruned(None),
            InvalidInput(None),
            InvalidTransactionUpdate(None),
            SequenceNumberTooOld(None),
            VmError(None),
            MempoolIsFull(None),
        ]
    }
```

**File:** crates/aptos-rosetta/src/error.rs (L109-148)
```rust
    pub fn code(&self) -> u32 {
        use ApiError::*;
        match self {
            TransactionIsPending => 1,
            NetworkIdentifierMismatch => 2,
            ChainIdMismatch => 3,
            DeserializationFailed(_) => 4,
            InvalidTransferOperations(_) => 5,
            InvalidSignatureType => 6,
            InvalidMaxGasFees => 7,
            MaxGasFeeTooLow(_) => 8,
            InvalidGasMultiplier => 9,
            InvalidOperations(_) => 10,
            MissingPayloadMetadata => 11,
            UnsupportedCurrency(_) => 12,
            UnsupportedSignatureCount(_) => 13,
            NodeIsOffline => 14,
            TransactionParseError(_) => 15,
            GasEstimationFailed(_) => 16,
            InternalError(_) => 17,
            AccountNotFound(_) => 18,
            ResourceNotFound(_) => 19,
            ModuleNotFound(_) => 20,
            StructFieldNotFound(_) => 21,
            VersionNotFound(_) => 22,
            TransactionNotFound(_) => 23,
            TableItemNotFound(_) => 24,
            BlockNotFound(_) => 25,
            VersionPruned(_) => 26,
            BlockPruned(_) => 27,
            InvalidInput(_) => 28,
            InvalidTransactionUpdate(_) => 29,
            SequenceNumberTooOld(_) => 30,
            VmError(_) => 31,
            MempoolIsFull(_) => 32,
            CoinTypeFailedToBeFetched(_) => 33,
            StateValueNotFound(_) => 34,
            RejectedByFilter(_) => 35,
        }
    }
```

**File:** crates/aptos-rosetta/src/error.rs (L298-301)
```rust
                AptosErrorCode::InvalidInput => ApiError::InvalidInput(Some(err.error.message)),
                AptosErrorCode::InvalidTransactionUpdate => {
                    ApiError::InvalidInput(Some(err.error.message))
                },
```

**File:** crates/aptos-rosetta/src/error.rs (L316-316)
```rust
                AptosErrorCode::BcsNotSupported => ApiError::InvalidInput(Some(err.error.message)),
```

**File:** api/src/transactions.rs (L1478-1481)
```rust
            MempoolStatusCode::InvalidUpdate => Err(AptosError::new_with_error_code(
                mempool_status.message,
                AptosErrorCode::InvalidTransactionUpdate,
            )),
```
