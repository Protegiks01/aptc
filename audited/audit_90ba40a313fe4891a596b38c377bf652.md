# Audit Report

## Title
Permanent Fund Loss via Transfers to Reserved Address 0x0

## Summary
Transfers to the reserved VM address `0x0` can result in permanent and irrecoverable fund loss. When the `default_account_resource` feature flag is enabled, the transfer mechanism creates a primary fungible store for address `0x0` without validation, allowing funds to be deposited to an address that cannot be controlled by any private key.

## Finding Description

The vulnerability exists in the interaction between account existence checks and object creation validation: [1](#0-0) 

Address `0x0` is defined as `@vm_reserved`, a special system address. Account creation explicitly prevents creating accounts at this address: [2](#0-1) 

However, when `default_account_resource` feature is enabled, the `exists_at()` function returns `true` for ALL addresses: [3](#0-2) 

This causes the transfer function to skip account creation: [4](#0-3) 

The transfer then proceeds through the fungible asset path, which creates a primary fungible store for address `0x0`: [5](#0-4) 

The critical flaw is in `create_object_internal()`, which creates objects without validating the owner address: [6](#0-5) 

This function accepts any `creator_address` (including `0x0`) and sets it as the object owner without restriction. Once funds are deposited to this store, they become permanently inaccessible because:

1. No private key exists for address `0x0`
2. Account creation at `0x0` is explicitly blocked
3. No system recovery mechanism exists for funds owned by reserved addresses

## Impact Explanation

This vulnerability qualifies as **Medium Severity** under Aptos bug bounty criteria for "Limited funds loss or manipulation." 

The impact is limited to individual transactions where users accidentally specify `0x0` as the recipient. Each affected transaction results in:
- Complete and permanent loss of transferred funds
- No possibility of recovery (requires protocol-level intervention)
- Silent failure without clear error messaging

The funds are not stolen by an attacker but are effectively burned in an unintended manner, as `0x0` is not designated as the official burn address: [7](#0-6) 

## Likelihood Explanation

The likelihood is **Medium** because:

1. **User error required**: The vulnerability requires a user to explicitly specify `0x0` as the recipient, which is not a common operation
2. **Feature flag dependency**: Only occurs when `default_account_resource` feature is enabled (modern deployments)
3. **Realistic scenarios** where this could occur:
   - Null/zero address bugs in client applications
   - Copy-paste errors in address fields
   - Script bugs that pass uninitialized address variables
   - Testing/debugging code accidentally used in production

The vulnerability has been confirmed through code analysis across multiple framework modules.

## Recommendation

Implement validation in the primary fungible store creation to reject reserved addresses. Add this check to `ensure_primary_fungible_store_exists()`:

```move
inline fun ensure_primary_fungible_store_exists(owner: address): address {
    // Prevent creating stores for reserved VM address
    assert!(owner != @vm_reserved, error::invalid_argument(ECANNOT_CREATE_STORE_FOR_RESERVED_ADDRESS));
    
    let store_addr = primary_fungible_store_address(owner);
    if (fungible_asset::store_exists(store_addr)) {
        store_addr
    } else {
        object::object_address(
            &primary_fungible_store::create_primary_store(
                owner, object::address_to_object<Metadata>(@aptos_fungible_asset)
            )
        )
    }
}
```

Additionally, add validation in `create_object_internal()` to prevent object creation with reserved addresses as owners:

```move
fun create_object_internal(
    creator_address: address,
    object: address,
    can_delete: bool,
): ConstructorRef {
    // Validate creator is not a reserved address
    assert!(
        creator_address != @vm_reserved,
        error::invalid_argument(ECANNOT_USE_RESERVED_ADDRESS_AS_OWNER)
    );
    
    assert!(!exists<ObjectCore>(object), error::already_exists(EOBJECT_EXISTS));
    // ... rest of implementation
}
```

## Proof of Concept

```move
#[test(sender = @0xcafe, framework = @0x1)]
fun test_transfer_to_zero_address_burns_funds(sender: &signer, framework: &signer) {
    use aptos_framework::aptos_coin;
    use aptos_framework::coin;
    use aptos_framework::aptos_account;
    
    // Initialize framework
    let (burn_cap, mint_cap) = aptos_coin::initialize_for_test(framework);
    
    // Setup sender account with funds
    let sender_addr = signer::address_of(sender);
    aptos_account::create_account(sender_addr);
    coin::deposit(sender_addr, coin::mint(10000000000, &mint_cap));
    
    let initial_balance = coin::balance<aptos_coin::AptosCoin>(sender_addr);
    assert!(initial_balance == 10000000000, 0);
    
    // Transfer to 0x0 - THIS SHOULD FAIL BUT DOESN'T
    aptos_account::transfer(sender, @0x0, 1000000000);
    
    // Verify funds were deducted from sender
    let final_balance = coin::balance<aptos_coin::AptosCoin>(sender_addr);
    assert!(final_balance == 9000000000, 1);
    
    // Funds are now permanently lost at 0x0
    // The primary fungible store exists but cannot be accessed
    let store_addr = primary_fungible_store::primary_store_address(
        @0x0, 
        object::address_to_object<fungible_asset::Metadata>(@aptos_fungible_asset)
    );
    assert!(fungible_asset::store_exists(store_addr), 2);
    
    coin::destroy_burn_cap(burn_cap);
    coin::destroy_mint_cap(mint_cap);
}
```

This test demonstrates that funds can be transferred to `0x0`, creating a primary fungible store that permanently holds the funds without any mechanism for recovery.

## Notes

The formal verification specification suggests `0x0` should exist after genesis, but the actual implementation does not explicitly create it: [8](#0-7) 

The genesis implementation only creates accounts for addresses `0x2` through `0xa`: [9](#0-8) 

This discrepancy between specification and implementation, combined with the lack of validation in object creation, creates the vulnerability vector.

### Citations

**File:** aptos-move/framework/aptos-framework/Move.toml (L12-12)
```text
vm_reserved = "0x0"
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L293-295)
```text
        assert!(
            new_address != @vm_reserved && new_address != @aptos_framework && new_address != @aptos_token,
            error::invalid_argument(ECANNOT_RESERVED_ADDRESS)
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L348-350)
```text
    public fun exists_at(addr: address): bool {
        features::is_default_account_resource_enabled() || exists<Account>(addr)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L82-85)
```text
    public entry fun transfer(source: &signer, to: address, amount: u64) {
        if (!account::exists_at(to)) {
            create_account(to)
        };
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L286-291)
```text
    public(friend) entry fun fungible_transfer_only(
        source: &signer, to: address, amount: u64
    ) {
        let sender_store =
            ensure_primary_fungible_store_exists(signer::address_of(source));
        let recipient_store = ensure_primary_fungible_store_exists(to);
```

**File:** aptos-move/framework/aptos-framework/sources/object.move (L94-94)
```text
    const BURN_ADDRESS: address = @0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff;
```

**File:** aptos-move/framework/aptos-framework/sources/object.move (L318-333)
```text
    fun create_object_internal(
        creator_address: address,
        object: address,
        can_delete: bool,
    ): ConstructorRef {
        assert!(!exists<ObjectCore>(object), error::already_exists(EOBJECT_EXISTS));

        let object_signer = create_signer(object);
        let guid_creation_num = INIT_GUID_CREATION_NUM;
        let transfer_events_guid = guid::create(object, &mut guid_creation_num);

        move_to(
            &object_signer,
            ObjectCore {
                guid_creation_num,
                owner: creator_address,
```

**File:** aptos-move/framework/aptos-framework/sources/genesis.spec.move (L67-67)
```text
        ensures exists<account::Account>(@0x0);
```

**File:** aptos-move/framework/aptos-framework/sources/genesis.move (L101-106)
```text
        let framework_reserved_addresses = vector<address>[@0x2, @0x3, @0x4, @0x5, @0x6, @0x7, @0x8, @0x9, @0xa];
        while (!vector::is_empty(&framework_reserved_addresses)) {
            let address = vector::pop_back<address>(&mut framework_reserved_addresses);
            let (_, framework_signer_cap) = account::create_framework_reserved_account(address);
            aptos_governance::store_signer_cap(&aptos_framework_account, address, framework_signer_cap);
        };
```
