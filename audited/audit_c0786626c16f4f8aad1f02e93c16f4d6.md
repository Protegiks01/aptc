# Audit Report

## Title
Indexer Database Corruption Due to Empty Transaction List Processing During Epoch Boundaries

## Summary
The `process_transactions_in_parallel()` function in the table info service incorrectly updates the indexer database's next version to 1 when called with an empty transaction list, which occurs naturally during epoch boundaries. This corrupts the indexer state and creates a permanent mismatch between the service's current version tracking and the persisted database state.

## Finding Description
The vulnerability exists in the interaction between three functions in the table info service: [1](#0-0) 

When `process_transactions_in_parallel()` receives an empty transaction list, it calculates `last_version = 0` using `unwrap_or_default()`. [2](#0-1) 

This value is then assigned to `end_version`. [3](#0-2) 

Finally, `update_next_version(end_version + 1)` is called with value 1, which writes `LatestVersion = 0` to the database and sets the in-memory `next_version = 1`. [4](#0-3) 

This scenario occurs during epoch transitions when transactions are split into previous and current epochs: [5](#0-4) 

The `transactions_in_epochs()` function can produce an empty `transactions_in_current_epoch` when all fetched transactions belong to the previous epoch and the epoch boundary occurs right after the last transaction. [6](#0-5) 

When `split_off_index` equals the length of the transactions vector, `split_off()` returns an empty vector.

The critical flaw is that while the code guards the previous epoch processing with an empty check: [7](#0-6) 

No such guard exists for the current epoch processing: [8](#0-7) 

This inconsistency allows empty transaction lists to reach `process_transactions_in_parallel()`, corrupting the indexer database state.

## Impact Explanation
This vulnerability qualifies as **Medium Severity** ($10,000 bounty category) as it causes "State inconsistencies requiring intervention":

1. **Database Corruption**: The IndexerAsyncV2 database persistently stores incorrect metadata (LatestVersion = 0, next_version = 1) even though thousands of versions have been processed
2. **Service Restart Impact**: When the table info service restarts, other components reading from the same IndexerAsyncV2 database will see next_version = 1, potentially causing reindexing from version 1
3. **Cross-Component Inconsistency**: The TableInfoService's in-memory `current_version` continues tracking correctly (e.g., version 1003), but the shared indexer database reports version 1, creating dangerous state divergence
4. **Data Loss Risk**: Reindexing from version 1 could overwrite correctly indexed table information with stale data

This breaks the **State Consistency** invariant: "State transitions must be atomic and verifiable via Merkle proofs" - the indexer's state tracking becomes inconsistent and unverifiable.

## Likelihood Explanation
**High Likelihood** - This occurs naturally and predictably:

1. **Automatic Trigger**: Happens during normal epoch boundaries when the last fetched batch of transactions all belong to the previous epoch
2. **No Attacker Required**: This is a deterministic bug triggered by legitimate blockchain operation, not requiring any malicious action
3. **Frequent Occurrence**: Epochs transition regularly in Aptos (every few hours), and the specific alignment where fetched transactions are exactly at the epoch boundary is common
4. **Production Impact**: Any long-running table info service will eventually encounter this condition during its operation

The vulnerability has likely already manifested in production deployments, though its effects may be masked by the fact that the TableInfoService uses its own `current_version` field for immediate processing decisions.

## Recommendation
Add an early return guard at the beginning of `process_transactions_in_parallel()` to handle empty transaction lists:

```rust
async fn process_transactions_in_parallel(
    &self,
    indexer_async_v2: Arc<IndexerAsyncV2>,
    transactions: Vec<TransactionOnChainData>,
) -> Vec<EndVersion> {
    // Early return for empty transactions - no state update needed
    if transactions.is_empty() {
        return vec![];
    }
    
    let mut tasks = vec![];
    let context = self.context.clone();
    let last_version = transactions
        .last()
        .map(|txn| txn.version)
        .unwrap_or_default();
    // ... rest of function
}
```

Additionally, add a guard in the `run()` function before calling `process_transactions_in_parallel()` for current epoch transactions, matching the existing pattern for previous epoch:

```rust
if !transactions_in_current_epoch.is_empty() {
    self.process_transactions_in_parallel(
        self.indexer_async_v2.clone(),
        transactions_in_current_epoch,
    )
    .await;
}
```

This pattern already exists in the codebase for other parallel execution functions: [9](#0-8) 

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_api_types::TransactionOnChainData;
    
    #[tokio::test]
    async fn test_empty_transactions_corruption() {
        // Setup: Create an IndexerAsyncV2 with next_version = 1000
        let temp_dir = tempfile::tempdir().unwrap();
        let db = DB::open_default(temp_dir.path()).unwrap();
        let indexer = Arc::new(IndexerAsyncV2::new(db).unwrap());
        
        // Manually set next_version to 1000
        indexer.update_next_version(1000).unwrap();
        assert_eq!(indexer.next_version(), 1000);
        
        // Create table info service
        let service = TableInfoService::new(
            context,
            1000,
            4,
            100,
            None,
            indexer.clone(),
        );
        
        // Simulate epoch boundary: process empty current epoch transactions
        let empty_transactions = vec![];
        service.process_transactions_in_parallel(
            indexer.clone(),
            empty_transactions,
        ).await;
        
        // Verify corruption: next_version should be 1000, but is now 1
        let corrupted_version = indexer.next_version();
        assert_eq!(corrupted_version, 1); // BUG: Should be 1000!
        
        // This demonstrates the state inconsistency:
        // - service.current_version would remain at 1000
        // - indexer.next_version is corrupted to 1
        println!("VULNERABILITY: Indexer next_version corrupted from 1000 to {}", corrupted_version);
    }
}
```

## Notes
The root cause is an asymmetry in how the two epoch-split transaction lists are handled - `transactions_in_previous_epoch` is guarded with an emptiness check before processing, while `transactions_in_current_epoch` is not. This allows the empty list edge case to propagate through `process_transactions_in_parallel()`, where the `unwrap_or_default()` pattern produces incorrect version 0, ultimately corrupting the persistent indexer database state to version 1.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs (L120-121)
```rust
            let (transactions_in_previous_epoch, transactions_in_current_epoch, epoch) =
                transactions_in_epochs(&self.context, current_epoch, transactions);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs (L124-129)
```rust
            if !transactions_in_previous_epoch.is_empty() {
                self.process_transactions_in_parallel(
                    self.indexer_async_v2.clone(),
                    transactions_in_previous_epoch,
                )
                .await;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs (L168-172)
```rust
            self.process_transactions_in_parallel(
                self.indexer_async_v2.clone(),
                transactions_in_current_epoch,
            )
            .await;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs (L252-256)
```rust
        let last_version = transactions
            .last()
            .map(|txn| txn.version)
            .unwrap_or_default();

```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs (L278-278)
```rust
                let end_version = last_version;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs (L302-304)
```rust
                self.indexer_async_v2
                    .update_next_version(end_version + 1)
                    .unwrap();
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs (L651-654)
```rust
        CmpOrdering::Less => {
            // Try the best to split the transactions into two epochs.
            epoch_first_version - first_version
        },
```

**File:** storage/indexer/src/db_v2.rs (L117-124)
```rust
    pub fn update_next_version(&self, end_version: u64) -> Result<()> {
        self.db.put::<IndexerMetadataSchema>(
            &MetadataKey::LatestVersion,
            &MetadataValue::Version(end_version - 1),
        )?;
        self.next_version.store(end_version, Ordering::Relaxed);
        Ok(())
    }
```

**File:** aptos-move/block-executor/src/executor.rs (L1872-1873)
```rust
        if num_txns == 0 {
            return Ok(BlockOutput::new(vec![], None));
```
