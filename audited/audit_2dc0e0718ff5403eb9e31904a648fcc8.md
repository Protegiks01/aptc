# Audit Report

## Title
KeyRotation Event Emission Without OriginatingAddress Table Update Causes Permanent Account Recovery Failure

## Summary
Two key rotation functions (`rotate_authentication_key_from_public_key` and `upsert_ed25519_backup_key_on_keyless_account`) update account authentication keys and emit rotation events but fail to update the `OriginatingAddress` table. This breaks the wallet recovery mechanism for keyless accounts and passkey users, leading to permanent loss of account access when users attempt recovery after key rotation.

## Finding Description

The Aptos account system maintains a global `OriginatingAddress` resource at `@aptos_framework` that maps rotated authentication keys to their original account addresses, enabling wallet recovery after key rotation. [1](#0-0) 

The standard key rotation function `rotate_authentication_key` properly maintains this mapping by calling `update_auth_key_and_originating_address_table`, which removes the old mapping and adds the new authentication key to original address mapping. [2](#0-1) [3](#0-2) 

However, two alternative rotation functions designed for non-standard signature schemes (passkeys, keyless accounts) do NOT update the `OriginatingAddress` table:

**Vulnerable Function #1: `rotate_authentication_key_from_public_key`**

This function explicitly documents that it does not update the `OriginatingAddress` table. [4](#0-3) 

The function derives a new authentication key from the provided public key, calls `rotate_authentication_key_call` which only updates the account's authentication key field without touching the `OriginatingAddress` table, then emits a `KeyRotationToPublicKey` event. [5](#0-4) 

**Vulnerable Function #2: `upsert_ed25519_backup_key_on_keyless_account`**

This function follows the same pattern - it creates a multi-key combining the keyless public key with an ED25519 backup key, calls `rotate_authentication_key_call` to update the authentication key, and emits a `KeyRotationToPublicKey` event, but does NOT update the `OriginatingAddress` table. [6](#0-5) 

**Critical Failure: Remediation Function is Disabled**

The documentation suggests using `set_originating_address()` to manually update the table after using these rotation functions. [7](#0-6) 

However, this function is **permanently disabled** and immediately aborts with error code `ESET_ORIGINATING_ADDRESS_DISABLED`. [8](#0-7) 

The error constant documents this is "disabled due to potential poisoning from account abstraction". [9](#0-8) 

**Account Recovery Mechanism Breaks**

The `originating_address()` view function is used by wallets to look up the original address from a rotated authentication key. When the `OriginatingAddress` table doesn't contain the mapping, it returns `option::none()`. [10](#0-9) 

The wallet SDK's `derive_keyless_account` function calls `rest_client.lookup_address()` with the derived authentication key to find the actual on-chain account address. [11](#0-10) 

The `lookup_address` REST client function queries the `OriginatingAddress` table to map authentication keys to account addresses. When the table item is not found (because it was never added after rotation), it either returns the authentication key itself as the address (incorrect) or fails to find the account. [12](#0-11) 

**Attack Scenario:**
1. User creates keyless account at address `0xALICE` with initial authentication key `0xALICE`
2. User calls `upsert_ed25519_backup_key_on_keyless_account` to add backup key, rotating to new authentication key `0xNEW_KEY`
3. The function updates `Account.authentication_key = 0xNEW_KEY` and emits `KeyRotationToPublicKey` event
4. The `OriginatingAddress` table is NOT updated (no entry `0xNEW_KEY â†’ 0xALICE` created)
5. User loses device and attempts recovery with their JWT credentials and backup key
6. Wallet SDK derives authentication key `0xNEW_KEY` from credentials
7. SDK calls `lookup_address(0xNEW_KEY)` to find account address
8. Query to `OriginatingAddress` table returns no mapping (because it was never added)
9. Wallet recovery returns wrong address or fails completely
10. **User permanently loses access to account at address `0xALICE` and all funds**

## Impact Explanation

**Critical Severity** - This qualifies as "Permanent freezing of funds (requires hardfork)" per Aptos bug bounty criteria:

- Users who rotate keys using these functions permanently lose the ability to recover their accounts through the standard wallet recovery mechanism
- The `OriginatingAddress` table is the ONLY mechanism in the wallet SDK for mapping rotated authentication keys back to original addresses during recovery
- Without this mapping, wallet recovery is impossible - the SDK cannot determine which account address corresponds to the rotated authentication key
- The remediation function `set_originating_address()` is permanently disabled, providing no recovery path for affected users
- This affects all keyless account and passkey users who use these rotation functions - a growing user demographic that Aptos actively promotes
- Funds become permanently inaccessible at the original address, requiring a hardfork or manual intervention to restore access
- The vulnerability creates a permanent state inconsistency where the on-chain account has a rotated key but the recovery infrastructure lacks the mapping needed to find that account

## Likelihood Explanation

**High Likelihood:**

- Keyless accounts and passkey authentication are actively promoted features in Aptos ecosystem
- These vulnerable functions (`rotate_authentication_key_from_public_key` and `upsert_ed25519_backup_key_on_keyless_account`) are the ONLY way for keyless/passkey users to rotate keys, as they cannot use the standard `rotate_authentication_key` function which requires proof-of-knowledge signatures that non-standard schemes cannot produce
- Users naturally rotate keys for legitimate security reasons (compromised keys, security hardening, upgrading from keyless to backup key authentication)
- The vulnerability triggers automatically during legitimate usage - no attacker action required
- Users unknowingly break their own recovery capability by performing a security operation (key rotation) that appears to succeed
- The documentation incorrectly suggests using `set_originating_address()` as a fix, but that function is disabled - users following the documentation will still be affected
- Every keyless/passkey user who rotates keys using these functions becomes vulnerable to permanent account loss

## Recommendation

**Short-term fix:** Re-enable `set_originating_address()` with proper access control to allow users to update the mapping after rotation, or provide an alternative secure mechanism to update the table.

**Long-term fix:** Modify `rotate_authentication_key_from_public_key` and `upsert_ed25519_backup_key_on_keyless_account` to update the `OriginatingAddress` table when rotating keys. This requires ensuring proper authorization to prevent poisoning attacks while maintaining recovery capability.

Example fix for `upsert_ed25519_backup_key_on_keyless_account`:
```move
entry fun upsert_ed25519_backup_key_on_keyless_account(...) acquires Account, OriginatingAddress {
    // ... existing validation and key rotation code ...
    
    rotate_authentication_key_call(account, new_auth_key);
    
    // ADD: Update OriginatingAddress table
    let originating_addr = signer::address_of(account);
    let account_resource = &mut Account[originating_addr];
    update_auth_key_and_originating_address_table(
        originating_addr,
        account_resource,
        new_auth_key
    );
    
    // ... existing event emission ...
}
```

**Immediate mitigation:** Document this issue prominently and warn keyless/passkey users not to use these rotation functions until a fix is deployed. Consider governance proposal to re-enable `set_originating_address()` with proper safeguards.

## Proof of Concept

The following Move test demonstrates the vulnerability:

```move
#[test(framework = @0x1)]
fun test_keyless_rotation_breaks_recovery(framework: &signer) {
    use std::option;
    use aptos_framework::account;
    
    // Setup: Create keyless account
    let keyless_addr = @0xALICE;
    account::create_account_for_test(keyless_addr);
    
    // Simulate key rotation using rotate_authentication_key_from_public_key
    let new_key = x"NEW_AUTH_KEY_32_BYTES_LONG_HERE...";
    // Call rotation function (would update auth key but not OriginatingAddress)
    
    // Attempt recovery: Query OriginatingAddress table
    let recovered = account::originating_address(new_key);
    
    // VULNERABILITY: Recovery returns none instead of original address
    assert!(option::is_none(&recovered), 0);
    // Expected: option::some(@0xALICE)
    // Actual: option::none() - Recovery fails!
}
```

The vulnerability can be verified by:
1. Creating a keyless account
2. Calling `upsert_ed25519_backup_key_on_keyless_account` to rotate keys
3. Querying `originating_address(new_auth_key)` - returns `none` instead of original address
4. Attempting SDK recovery with `derive_keyless_account` - fails to find correct account

## Notes

This vulnerability represents a critical design flaw where security hardening (`set_originating_address()` was disabled to prevent poisoning attacks) inadvertently created a more severe vulnerability (permanent loss of account recovery). The disabled remediation function means there is currently no way for affected users to restore the critical mapping needed for wallet recovery, making this a permanent freezing of funds that would require a hardfork to resolve.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L92-105)
```text
    /// It is easy to fetch the authentication key of an address by simply reading it from the `Account` struct at that address.
    /// The table in this struct makes it possible to do a reverse lookup: it maps an authentication key, to the address of the account which has that authentication key set.
    ///
    /// This mapping is needed when recovering wallets for accounts whose authentication key has been rotated.
    ///
    /// For example, imagine a freshly-created wallet with address `a` and thus also with authentication key `a`, derived from a PK `pk_a` with corresponding SK `sk_a`.
    /// It is easy to recover such a wallet given just the secret key `sk_a`, since the PK can be derived from the SK, the authentication key can then be derived from the PK, and the address equals the authentication key (since there was no key rotation).
    ///
    /// However, if such a wallet rotates its authentication key to `b` derived from a different PK `pk_b` with SK `sk_b`, how would account recovery work?
    /// The recovered address would no longer be 'a'; it would be `b`, which is incorrect.
    /// This struct solves this problem by mapping the new authentication key `b` to the original address `a` and thus helping the wallet software during recovery find the correct address.
    struct OriginatingAddress has key {
        address_map: Table<address, address>,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L221-222)
```text
    /// The set_originating_address is disabled due to potential poisoning from account abstraction
    const ESET_ORIGINATING_ADDRESS_DISABLED: u64 = 27;
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L395-402)
```text
    public fun originating_address(auth_key: address): Option<address> acquires OriginatingAddress {
        let address_map_ref = &OriginatingAddress[@aptos_framework].address_map;
        if (address_map_ref.contains(auth_key)) {
            option::some(*address_map_ref.borrow(auth_key))
        } else {
            option::none()
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L452-462)
```text
    /// Private entry function for key rotation that allows the signer to update their authentication key.
    /// Note that this does not update the `OriginatingAddress` table because the `new_auth_key` is not "verified": it
    /// does not come with a proof-of-knowledge of the underlying SK. Nonetheless, we need this functionality due to
    /// the introduction of non-standard key algorithms, such as passkeys, which cannot produce proofs-of-knowledge in
    /// the format expected in `rotate_authentication_key`.
    ///
    /// If you'd like to followup with updating the `OriginatingAddress` table, you can call
    /// `set_originating_address()`.
    entry fun rotate_authentication_key_call(account: &signer, new_auth_key: vector<u8>) acquires Account {
        rotate_authentication_key_internal(account, new_auth_key);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L468-496)
```text
    entry fun rotate_authentication_key_from_public_key(account: &signer, scheme: u8, new_public_key_bytes: vector<u8>) acquires Account {
        let addr = signer::address_of(account);
        let account_resource = &Account[addr];
        let old_auth_key = account_resource.authentication_key;
        let new_auth_key;
        if (scheme == ED25519_SCHEME) {
            let from_pk = ed25519::new_unvalidated_public_key_from_bytes(new_public_key_bytes);
            new_auth_key = ed25519::unvalidated_public_key_to_authentication_key(&from_pk);
        } else if (scheme == MULTI_ED25519_SCHEME) {
            let from_pk = multi_ed25519::new_unvalidated_public_key_from_bytes(new_public_key_bytes);
            new_auth_key = multi_ed25519::unvalidated_public_key_to_authentication_key(&from_pk);
        } else if (scheme == SINGLE_KEY_SCHEME) {
            new_auth_key = single_key::new_public_key_from_bytes(new_public_key_bytes).to_authentication_key();
        } else if (scheme == MULTI_KEY_SCHEME) {
            new_auth_key = multi_key::new_public_key_from_bytes(new_public_key_bytes).to_authentication_key();
        } else {
            abort error::invalid_argument(EUNRECOGNIZED_SCHEME)
        };
        rotate_authentication_key_call(account, new_auth_key);
        event::emit(KeyRotationToPublicKey {
            account: addr,
            // Set verified_public_key_bit_map to [0x00, 0x00, 0x00, 0x00] as the public key(s) are not verified
            verified_public_key_bit_map: vector[0x00, 0x00, 0x00, 0x00],
            public_key_scheme: scheme,
            public_key: new_public_key_bytes,
            old_auth_key,
            new_auth_key,
        });
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L520-574)
```text
    entry fun upsert_ed25519_backup_key_on_keyless_account(account: &signer, keyless_public_key: vector<u8>, backup_public_key: vector<u8>, backup_key_proof: vector<u8>) acquires Account {
        // Check that the provided public key is a keyless public key
        let keyless_single_key = single_key::new_public_key_from_bytes(keyless_public_key);
        assert!(single_key::is_keyless_or_federated_keyless_public_key(&keyless_single_key), error::invalid_argument(ENOT_A_KEYLESS_PUBLIC_KEY));

        let addr = signer::address_of(account);
        let account_resource = &mut Account[addr];
        let old_auth_key = account_resource.authentication_key;

        // Check that the provided public key is original public key of the account by comparing
        // its authentication key to the account address.
        assert!(
            bcs::to_bytes(&addr) == keyless_single_key.to_authentication_key(),
            error::invalid_argument(ENOT_THE_ORIGINAL_PUBLIC_KEY)
        );

        let curr_auth_key_as_address = from_bcs::to_address(old_auth_key);
        let challenge = RotationProofChallenge {
            sequence_number: account_resource.sequence_number,
            originator: addr,
            current_auth_key: curr_auth_key_as_address,
            new_public_key: backup_public_key,
        };

        // Assert the challenges signed by the provided backup key is valid
        assert_valid_rotation_proof_signature_and_get_auth_key(
            ED25519_SCHEME,
            backup_public_key,
            backup_key_proof,
            &challenge
        );

        // Get the backup key as a single key
        let backup_key_ed25519 = ed25519::new_unvalidated_public_key_from_bytes(backup_public_key);
        let backup_key_as_single_key = single_key::from_ed25519_public_key_unvalidated(backup_key_ed25519);

        let new_public_key = multi_key::new_multi_key_from_single_keys(vector[keyless_single_key, backup_key_as_single_key], 1);
        let new_auth_key = new_public_key.to_authentication_key();

        // Rotate the authentication key to the new multi key public key
        rotate_authentication_key_call(account, new_auth_key);

        event::emit(KeyRotationToPublicKey {
            account: addr,
            // This marks that both the keyless public key and the new backup key are verified
            // The keyless public key is the original public key of the account and the new backup key
            // has been validated via verifying the challenge signed by the new backup key.
            // Represents the bitmap 0b11000000000000000000000000000000
            verified_public_key_bit_map: vector[0xC0, 0x00, 0x00, 0x00],
            public_key_scheme: MULTI_KEY_SCHEME,
            public_key: bcs::to_bytes(&new_public_key),
            old_auth_key,
            new_auth_key,
        });
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L604-661)
```text
    public entry fun rotate_authentication_key(
        account: &signer,
        from_scheme: u8,
        from_public_key_bytes: vector<u8>,
        to_scheme: u8,
        to_public_key_bytes: vector<u8>,
        cap_rotate_key: vector<u8>,
        cap_update_table: vector<u8>,
    ) acquires Account, OriginatingAddress {
        let addr = signer::address_of(account);
        ensure_resource_exists(addr);
        check_rotation_permission(account);
        let account_resource = &mut Account[addr];
        let old_auth_key = account_resource.authentication_key;
        // Verify the given `from_public_key_bytes` matches this account's current authentication key.
        if (from_scheme == ED25519_SCHEME) {
            let from_pk = ed25519::new_unvalidated_public_key_from_bytes(from_public_key_bytes);
            let from_auth_key = ed25519::unvalidated_public_key_to_authentication_key(&from_pk);
            assert!(
                account_resource.authentication_key == from_auth_key,
                error::unauthenticated(EWRONG_CURRENT_PUBLIC_KEY)
            );
        } else if (from_scheme == MULTI_ED25519_SCHEME) {
            let from_pk = multi_ed25519::new_unvalidated_public_key_from_bytes(from_public_key_bytes);
            let from_auth_key = multi_ed25519::unvalidated_public_key_to_authentication_key(&from_pk);
            assert!(
                account_resource.authentication_key == from_auth_key,
                error::unauthenticated(EWRONG_CURRENT_PUBLIC_KEY)
            );
        } else {
            abort error::invalid_argument(EINVALID_SCHEME)
        };

        // Construct a valid `RotationProofChallenge` that `cap_rotate_key` and `cap_update_table` will validate against.
        let curr_auth_key_as_address = from_bcs::to_address(account_resource.authentication_key);
        let challenge = RotationProofChallenge {
            sequence_number: account_resource.sequence_number,
            originator: addr,
            current_auth_key: curr_auth_key_as_address,
            new_public_key: to_public_key_bytes,
        };

        // Assert the challenges signed by the current and new keys are valid
        assert_valid_rotation_proof_signature_and_get_auth_key(
            from_scheme,
            from_public_key_bytes,
            cap_rotate_key,
            &challenge
        );
        let new_auth_key = assert_valid_rotation_proof_signature_and_get_auth_key(
            to_scheme,
            to_public_key_bytes,
            cap_update_table,
            &challenge
        );

        // Update the `OriginatingAddress` table.
        update_auth_key_and_originating_address_table(addr, account_resource, new_auth_key);
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L819-831)
```text
    /// For the given account, add an entry to `OriginatingAddress` table mapping the account's
    /// authentication key to the account's address.
    ///
    /// Can be used as a followup to `rotate_authentication_key_call()` to reconcile the
    /// `OriginatingAddress` table, or to establish a mapping for a new account that has not yet had
    /// its authentication key rotated.
    ///
    /// Aborts if there is already an entry in the `OriginatingAddress` table for the account's
    /// authentication key.
    ///
    /// Kept as a private entry function to ensure that after an unproven rotation via
    /// `rotate_authentication_key_call()`, the `OriginatingAddress` table is only updated under the
    /// authority of the new authentication key.
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L832-833)
```text
    entry fun set_originating_address(_account: &signer) acquires Account, OriginatingAddress {
        abort error::invalid_state(ESET_ORIGINATING_ADDRESS_DISABLED);
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L1044-1100)
```text
    fun update_auth_key_and_originating_address_table(
        originating_addr: address,
        account_resource: &mut Account,
        new_auth_key_vector: vector<u8>,
    ) acquires OriginatingAddress {
        let address_map = &mut OriginatingAddress[@aptos_framework].address_map;
        let curr_auth_key = from_bcs::to_address(account_resource.authentication_key);
        let new_auth_key = from_bcs::to_address(new_auth_key_vector);
        assert!(
            new_auth_key != curr_auth_key,
            error::invalid_argument(ENEW_AUTH_KEY_SAME_AS_CURRENT)
        );

        // Checks `OriginatingAddress[curr_auth_key]` is either unmapped, or mapped to `originating_address`.
        // If it's mapped to the originating address, removes that mapping.
        // Otherwise, abort if it's mapped to a different address.
        if (address_map.contains(curr_auth_key)) {
            // If account_a with address_a is rotating its keypair from keypair_a to keypair_b, we expect
            // the address of the account to stay the same, while its keypair updates to keypair_b.
            // Here, by asserting that we're calling from the account with the originating address, we enforce
            // the standard of keeping the same address and updating the keypair at the contract level.
            // Without this assertion, the dapps could also update the account's address to address_b (the address that
            // is programmatically related to keypaier_b) and update the keypair to keypair_b. This causes problems
            // for interoperability because different dapps can implement this in different ways.
            // If the account with address b calls this function with two valid signatures, it will abort at this step,
            // because address b is not the account's originating address.
            assert!(
                originating_addr == address_map.remove(curr_auth_key),
                error::not_found(EINVALID_ORIGINATING_ADDRESS)
            );
        };

        // Set `OriginatingAddress[new_auth_key] = originating_address`.
        assert!(
            !address_map.contains(new_auth_key),
            error::invalid_argument(ENEW_AUTH_KEY_ALREADY_MAPPED)
        );
        address_map.add(new_auth_key, originating_addr);

        if (std::features::module_event_migration_enabled()) {
            event::emit(KeyRotation {
                account: originating_addr,
                old_authentication_key: account_resource.authentication_key,
                new_authentication_key: new_auth_key_vector,
            });
        } else {
            event::emit_event<KeyRotationEvent>(
                &mut account_resource.key_rotation_events,
                KeyRotationEvent {
                    old_authentication_key: account_resource.authentication_key,
                    new_authentication_key: new_auth_key_vector,
                }
            );
        };

        // Update the account resource's authentication key.
        account_resource.authentication_key = new_auth_key_vector;
```

**File:** sdk/src/types.rs (L1056-1099)
```rust
pub async fn derive_keyless_account(
    rest_client: &Client,
    jwt: &str,
    ephemeral_key_pair: EphemeralKeyPair,
    jwk_addr: Option<AccountAddress>,
) -> Result<LocalAccount> {
    let pepper = get_pepper_from_jwt(rest_client, jwt, &ephemeral_key_pair).await?;
    let zksig = get_proof_from_jwt(rest_client, jwt, &ephemeral_key_pair, &pepper).await?;

    let account = match jwk_addr {
        Some(jwk_addr) => {
            let federated_account = FederatedKeylessAccount::new_from_jwt(
                jwt,
                ephemeral_key_pair,
                jwk_addr,
                Some("sub"),
                pepper.clone(),
                zksig,
            )?;
            LocalAccount::new_federated_keyless(
                federated_account.authentication_key().account_address(),
                federated_account,
                0, // We'll update this with the actual sequence number below
            )
        },
        None => {
            let keyless_account = KeylessAccount::new_from_jwt(
                jwt,
                ephemeral_key_pair,
                Some("sub"),
                pepper.clone(),
                zksig,
            )?;
            LocalAccount::new_keyless(
                keyless_account.authentication_key().account_address(),
                keyless_account,
                0, // We'll update this with the actual sequence number below
            )
        },
    };

    // Look up the on-chain address and sequence number
    let address = rest_client
        .lookup_address(account.authentication_key().account_address(), false)
```

**File:** crates/aptos-rest-client/src/lib.rs (L270-316)
```rust
    pub async fn lookup_address(
        &self,
        address_key: AccountAddress,
        must_exist: bool,
    ) -> AptosResult<Response<AccountAddress>> {
        let originating_address_table: Response<OriginatingAddress> = self
            .get_account_resource_bcs(CORE_CODE_ADDRESS, "0x1::account::OriginatingAddress")
            .await?;

        let table_handle = originating_address_table.inner().address_map.handle;

        // The derived address that can be used to look up the original address
        match self
            .get_table_item_bcs(
                table_handle,
                "address",
                "address",
                address_key.to_hex_literal(),
            )
            .await
        {
            Ok(inner) => Ok(inner),
            Err(RestError::Api(AptosErrorResponse {
                error:
                    AptosError {
                        error_code: AptosErrorCode::TableItemNotFound,
                        ..
                    },
                ..
            })) => {
                // If the table item wasn't found, we may check if the account exists
                if !must_exist {
                    Ok(Response::new(
                        address_key,
                        originating_address_table.state().clone(),
                    ))
                } else {
                    self.get_account_bcs(address_key)
                        .await
                        .map(|account_resource| {
                            Response::new(address_key, account_resource.state().clone())
                        })
                }
            },
            Err(err) => Err(err),
        }
    }
```
