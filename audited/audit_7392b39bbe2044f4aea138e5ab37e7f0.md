# Audit Report

## Title
IPFS Gateway Authentication Token Exposure in NFT Metadata Crawler Logs

## Summary
The NFT metadata crawler's URI parser appends IPFS gateway authentication tokens as query parameters to URIs, which are then directly logged in structured application logs at multiple locations. This exposes sensitive Pinata gateway credentials in server logs, error messages, and monitoring systems.

## Finding Description
The `format_capture()` function constructs URIs with authentication tokens embedded as query parameters: [1](#0-0) 

The `ipfs_auth_param` is constructed as `?pinataGatewayToken=<secret_token>`: [2](#0-1) [3](#0-2) 

These URIs containing authentication tokens are then directly logged in two critical locations:

**1. JSON Parser Logging:** [4](#0-3) 

**2. Image Optimizer Logging:** [5](#0-4) 

Additionally, when HTTP requests fail, error messages containing these URIs are logged through the worker's error handling: [6](#0-5) [7](#0-6) 

The error chain from reqwest may include the full URI with the authentication token, which gets logged with `error = ?e`.

## Impact Explanation
This vulnerability qualifies as **Low Severity** per Aptos bug bounty criteria ("Minor information leaks"). The exposed credentials can lead to:

1. **Credential Theft**: Authentication tokens are visible in application logs, which may be accessed by operators, log aggregation platforms (Datadog, Splunk), monitoring systems, and debugging tools
2. **Unauthorized Gateway Access**: Stolen tokens enable unauthorized use of the IPFS gateway service, potentially incurring costs to the token owner
3. **Log Retention Risk**: Tokens remain exposed in archived logs long after rotation, extending the attack window
4. **Third-Party Exposure**: Logs shared with external monitoring or analytics services leak credentials beyond the immediate infrastructure

While this does not directly affect blockchain consensus, execution, or state management, it represents a real operational security risk for the NFT metadata crawler infrastructure.

## Likelihood Explanation
**High Likelihood**: This vulnerability is triggered during normal operation:
- Every NFT metadata fetch operation logs the URI with embedded tokens
- Image and animation optimization operations log URIs with tokens
- Error conditions also expose tokens in error messages
- No attacker action is required - logs accumulate automatically

The only requirement for exploitation is access to application logs, which may be achieved through:
- Compromised log aggregation systems
- Insider access (operators, SRE teams)
- Misconfigured log permissions
- Log export features

## Recommendation
**Sanitize URIs before logging** by removing query parameters containing authentication tokens. Implement a URI sanitization function:

```rust
fn sanitize_uri_for_logging(uri: &str) -> String {
    match Url::parse(uri) {
        Ok(mut url) => {
            // Remove sensitive query parameters
            url.set_query(None);
            url.to_string()
        }
        Err(_) => uri.to_string()
    }
}
```

Apply this sanitization in both logging locations:

**json_parser.rs line 53:**
```rust
info!(asset_uri = sanitize_uri_for_logging(&uri), "Sending request for asset_uri");
```

**image_optimizer.rs line 54:**
```rust
info!(image_uri = sanitize_uri_for_logging(uri), "Sending request for image");
```

Alternatively, use HTTP header-based authentication instead of query parameters, as headers are not typically logged by web servers or included in URLs.

## Proof of Concept

**Steps to reproduce:**

1. Configure NFT metadata crawler with an IPFS authentication key in the config
2. Process any NFT with IPFS metadata URIs
3. Monitor application logs

**Expected observation:**
```
INFO asset_uri=https://gateway.pinata.cloud/ipfs/QmXx...?pinataGatewayToken=SECRET_TOKEN_HERE
```

**Rust reproduction:**
```rust
use nft_metadata_crawler::utils::{uri_parser::URIParser, constants::IPFS_AUTH_KEY};

fn main() {
    let ipfs_prefix = "https://gateway.pinata.cloud/ipfs/";
    let test_uri = "ipfs://QmTest123/metadata.json";
    let auth_key = "secret_token_12345";
    
    let parsed_uri = URIParser::parse(ipfs_prefix, test_uri, Some(auth_key)).unwrap();
    
    // This URI now contains: ?pinataGatewayToken=secret_token_12345
    println!("Parsed URI (would be logged): {}", parsed_uri);
    
    // Verify token is in the URI
    assert!(parsed_uri.contains(auth_key));
    assert!(parsed_uri.contains(IPFS_AUTH_KEY));
}
```

## Notes
While this vulnerability is in the NFT metadata crawler ecosystem tool rather than core blockchain components (consensus, Move VM, storage, governance), it represents a genuine information disclosure issue that exposes operational credentials. The finding is limited to the metadata crawler's operational security and does not affect blockchain integrity, consensus safety, or on-chain state.

### Citations

**File:** ecosystem/nft-metadata-crawler/src/utils/uri_parser.rs (L33-37)
```rust
        let ipfs_auth_param = if ipfs_auth_key.is_some() {
            Some(format!("?{}={}", IPFS_AUTH_KEY, ipfs_auth_key.unwrap()))
        } else {
            None
        };
```

**File:** ecosystem/nft-metadata-crawler/src/utils/uri_parser.rs (L68-74)
```rust
        Ok(format!(
            "{}{}{}{}",
            ipfs_prefix,
            cid,
            path.unwrap_or_default(),
            ipfs_auth_param.unwrap_or_default()
        ))
```

**File:** ecosystem/nft-metadata-crawler/src/utils/constants.rs (L31-32)
```rust
/// Default IPFS gateway auth param key
pub const IPFS_AUTH_KEY: &str = "pinataGatewayToken";
```

**File:** ecosystem/nft-metadata-crawler/src/utils/json_parser.rs (L53-53)
```rust
                info!(asset_uri = uri, "Sending request for asset_uri");
```

**File:** ecosystem/nft-metadata-crawler/src/utils/image_optimizer.rs (L54-54)
```rust
                info!(image_uri = uri, "Sending request for image");
```

**File:** ecosystem/nft-metadata-crawler/src/parser/worker.rs (L129-134)
```rust
                    .unwrap_or_else(|e| {
                        // Increment retry count if JSON parsing fails
                        self.log_warn("JSON parsing failed", Some(&e));
                        self.model.increment_json_parser_retry_count();
                        (None, None, Value::Null)
                    });
```

**File:** ecosystem/nft-metadata-crawler/src/parser/worker.rs (L405-416)
```rust
    fn log_warn(&self, message: &str, e: Option<&anyhow::Error>) {
        warn!(
            pubsub_message = self.pubsub_message,
            asset_data_id = self.asset_data_id,
            asset_uri = self.asset_uri,
            last_transaction_version = self.last_transaction_version,
            last_transaction_timestamp = self.last_transaction_timestamp.to_string(),
            error = ?e,
            "[NFT Metadata Crawler] {}",
            message
        );
    }
```
