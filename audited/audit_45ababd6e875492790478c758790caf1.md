# Audit Report

## Title
Gas Limit Bypass in Consensus Observer Block Payload Verification

## Summary
The `verify_against_ordered_payload` function fails to verify the `gas_limit` field in BlockPayload messages for `QuorumStoreInlineHybridV2` and `OptQuorumStore` payload types. This allows a malicious consensus publisher to send BlockPayload messages with inflated gas_limit values that bypass consensus-agreed resource limits, potentially causing consensus splits and deterministic execution violations.

## Finding Description

The consensus observer system receives BlockPayload messages from consensus publishers and stores them for later execution. When an OrderedBlock is received, the system verifies that stored BlockPayloads match the consensus-agreed payload data through the `verify_against_ordered_payload` method. [1](#0-0) 

However, this verification function contains a critical flaw. For `Payload::QuorumStoreInlineHybridV2`, it verifies the transaction_limit but explicitly skips gas_limit verification (note the TODO comment). Similarly, for `Payload::OptQuorumStore`, only the transaction_limit is verified. [2](#0-1) 

The stored BlockPayload is later retrieved in `get_transactions_for_observer`, which directly returns the unverified gas_limit value: [3](#0-2) 

This unverified gas_limit is then used to override the execution configuration: [4](#0-3) 

The overridden gas_limit takes precedence in the BlockGasLimitProcessor, which determines when block execution should halt: [5](#0-4) 

**Attack Path:**
1. Malicious consensus publisher sends BlockPayload message with inflated gas_limit (e.g., 10x the consensus-agreed value)
2. BlockPayload passes signature verification and digest verification
3. `verify_against_ordered_payload` verifies transaction_limit but skips gas_limit verification
4. BlockPayload is stored as `AvailableAndVerified`
5. When OrderedBlock arrives, payload verification passes despite manipulated gas_limit
6. During execution, `get_transactions_for_observer` returns the inflated gas_limit
7. Execution config is overridden with inflated gas_limit
8. BlockGasLimitProcessor uses inflated limit, allowing more transactions to execute than consensus agreed upon

## Impact Explanation

**Severity: HIGH to CRITICAL**

This vulnerability breaks **Critical Invariant #1 (Deterministic Execution)** and **Critical Invariant #9 (Resource Limits)**:

1. **Consensus Safety Violation**: Different consensus observers receiving different gas_limit values will execute different numbers of transactions from the same block, producing different state roots. This breaks the fundamental requirement that all validators produce identical results for identical blocks.

2. **Resource Limit Bypass**: An attacker can force nodes to consume more computational resources than consensus agreed upon, potentially enabling:
   - Execution of more transactions than intended
   - Higher gas consumption leading to performance degradation
   - Resource exhaustion attacks on consensus observer nodes

3. **Network Partition Risk**: If some observers use the correct gas_limit while others use inflated values, the network could experience state divergence requiring manual intervention or a hard fork to resolve.

This qualifies as **Critical Severity** under the Aptos bug bounty program as it represents a consensus/safety violation that can cause non-deterministic execution and potential network partitioning.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

The vulnerability is exploitable under the following conditions:

1. **Attacker Requirements**: The attacker needs to be a consensus publisher (validator in the active set) or compromise a publisher's network communication
2. **Attack Complexity**: Low - simply send BlockPayload messages with modified gas_limit values
3. **Detection Difficulty**: The manipulation may go unnoticed as BlockPayload messages pass all current verification checks
4. **Impact Scope**: Affects all consensus observer nodes (non-validating full nodes)

While the attacker needs to be a consensus publisher, this is a realistic threat model since:
- The consensus observer protocol assumes publishers may be Byzantine
- No additional privileges beyond being a publisher are required
- The attack leaves no cryptographic trace (signatures remain valid)

## Recommendation

Add gas_limit verification to the `verify_against_ordered_payload` function. Specifically:

1. For `Payload::QuorumStoreInlineHybridV2`, add verification after line 695:
```rust
// Verify the transaction limit
self.verify_transaction_limit(execution_limits.max_txns_to_execute())?;

// Verify the block gas limit
self.verify_gas_limit(execution_limits.block_gas_limit())?;
```

2. For `Payload::OptQuorumStore(V1)`, add verification after line 707:
```rust
// Verify the transaction limit
self.verify_transaction_limit(p.max_txns_to_execute())?;

// Verify the block gas limit
self.verify_gas_limit(p.block_gas_limit())?;
```

3. Implement the `verify_gas_limit` method similar to `verify_transaction_limit`: [6](#0-5) 

The new method should follow the same pattern, comparing the expected gas_limit from the ordered block against the BlockPayload's gas_limit value.

## Proof of Concept

The following test demonstrates the vulnerability:

```rust
#[tokio::test]
async fn test_gas_limit_manipulation() {
    use consensus_observer::network::observer_message::*;
    use consensus_types::common::Payload;
    
    // Create a BlockPayload with gas_limit = 1000
    let transaction_payload = BlockTransactionPayload::new_quorum_store_inline_hybrid(
        vec![],  // transactions
        vec![],  // proofs
        Some(100),  // transaction_limit
        Some(1000), // gas_limit (consensus-agreed value)
        vec![],  // inline_batches
        true,    // enable_payload_v2
    );
    let block_payload = BlockPayload::new(block_info, transaction_payload);
    
    // Create OrderedBlock with matching transaction_limit but different gas_limit
    let execution_limits = PayloadExecutionLimit::TxnAndGasLimits(TxnAndGasLimits {
        transaction_limit: Some(100),
        gas_limit: Some(1000), // Consensus agreed value
    });
    
    // Verify should pass with correct values
    assert!(block_payload.transaction_payload()
        .verify_against_ordered_payload(&ordered_payload).is_ok());
    
    // Now create malicious BlockPayload with inflated gas_limit = 10000
    let malicious_payload = BlockTransactionPayload::new_quorum_store_inline_hybrid(
        vec![],
        vec![],
        Some(100),  // transaction_limit matches
        Some(10000), // gas_limit is 10x higher! 
        vec![],
        true,
    );
    let malicious_block_payload = BlockPayload::new(block_info, malicious_payload);
    
    // VULNERABILITY: Verification passes even though gas_limit is manipulated
    let result = malicious_block_payload.transaction_payload()
        .verify_against_ordered_payload(&ordered_payload);
    
    // This should FAIL but currently PASSES due to missing gas_limit verification
    assert!(result.is_ok()); // Test demonstrates the bug
    
    // The inflated gas_limit will be used during execution, bypassing consensus limits
}
```

The test shows that a BlockPayload with transaction_limit matching the OrderedBlock but with an inflated gas_limit will pass all verification checks and be marked as `AvailableAndVerified`, allowing the manipulated gas_limit to be used during execution.

## Notes

This vulnerability is explicitly marked as a known gap in the codebase via the TODO comment at line 697 of `observer_message.rs`. However, its presence in production code represents a critical security issue that must be addressed. The fix is straightforward and should be implemented immediately to prevent potential consensus splits in the consensus observer network.

### Citations

**File:** consensus/src/consensus_observer/network/observer_message.rs (L647-717)
```rust
    /// Verifies the transaction payload against the given ordered block payload
    pub fn verify_against_ordered_payload(
        &self,
        ordered_block_payload: &Payload,
    ) -> Result<(), Error> {
        match ordered_block_payload {
            Payload::DirectMempool(_) => {
                return Err(Error::InvalidMessageError(
                    "Direct mempool payloads are not supported for consensus observer!".into(),
                ));
            },
            Payload::InQuorumStore(proof_with_data) => {
                // Verify the batches in the requested block
                self.verify_batches(&proof_with_data.proofs)?;
            },
            Payload::InQuorumStoreWithLimit(proof_with_data) => {
                // Verify the batches in the requested block
                self.verify_batches(&proof_with_data.proof_with_data.proofs)?;

                // Verify the transaction limit
                self.verify_transaction_limit(proof_with_data.max_txns_to_execute)?;
            },
            Payload::QuorumStoreInlineHybrid(
                inline_batches,
                proof_with_data,
                max_txns_to_execute,
            ) => {
                // Verify the batches in the requested block
                self.verify_batches(&proof_with_data.proofs)?;

                // Verify the inline batches
                self.verify_inline_batches(inline_batches)?;

                // Verify the transaction limit
                self.verify_transaction_limit(*max_txns_to_execute)?;
            },
            Payload::QuorumStoreInlineHybridV2(
                inline_batches,
                proof_with_data,
                execution_limits,
            ) => {
                // Verify the batches in the requested block
                self.verify_batches(&proof_with_data.proofs)?;

                // Verify the inline batches
                self.verify_inline_batches(inline_batches)?;

                // Verify the transaction limit
                self.verify_transaction_limit(execution_limits.max_txns_to_execute())?;

                // TODO: verify the block gas limit?
            },
            Payload::OptQuorumStore(OptQuorumStorePayload::V1(p)) => {
                // Verify the batches in the requested block
                self.verify_batches(p.proof_with_data())?;

                // Verify optQS and inline batches
                self.verify_optqs_and_inline_batches(p.opt_batches(), p.inline_batches())?;

                // Verify the transaction limit
                self.verify_transaction_limit(p.max_txns_to_execute())?;
            },
            Payload::OptQuorumStore(OptQuorumStorePayload::V2(_p)) => {
                return Err(Error::InvalidMessageError(
                    "OptQuorumStorePayload V2 is not supproted".into(),
                ));
            },
        }

        Ok(())
    }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L805-836)
```rust
    /// Verifies the payload limit against the expected limit
    fn verify_transaction_limit(
        &self,
        expected_transaction_limit: Option<u64>,
    ) -> Result<(), Error> {
        // Get the payload limit
        let limit = match self {
            BlockTransactionPayload::DeprecatedInQuorumStore(_) => {
                return Err(Error::InvalidMessageError(
                    "Transaction payload does not contain a limit!".to_string(),
                ))
            },
            BlockTransactionPayload::DeprecatedInQuorumStoreWithLimit(payload) => {
                payload.transaction_limit
            },
            BlockTransactionPayload::QuorumStoreInlineHybrid(payload, _) => {
                payload.transaction_limit
            },
            BlockTransactionPayload::QuorumStoreInlineHybridV2(payload, _)
            | BlockTransactionPayload::OptQuorumStore(payload, _) => payload.transaction_limit(),
        };

        // Compare the expected limit against the payload limit
        if expected_transaction_limit != limit {
            return Err(Error::InvalidMessageError(format!(
                "Transaction payload failed limit verification! Expected limit: {:?}, Found limit: {:?}",
                expected_transaction_limit, limit
            )));
        }

        Ok(())
    }
```

**File:** consensus/src/payload_manager/co_payload_manager.rs (L70-75)
```rust
    // Return the transactions and the transaction limit
    Ok((
        transaction_payload.transactions(),
        transaction_payload.transaction_limit(),
        transaction_payload.gas_limit(),
    ))
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L799-801)
```rust
        let (user_txns, block_gas_limit) = prepare_fut.await?;
        let onchain_execution_config =
            onchain_execution_config.with_block_gas_limit_override(block_gas_limit);
```

**File:** aptos-move/block-executor/src/limit_processor.rs (L119-125)
```rust
    fn block_gas_limit(&self) -> Option<u64> {
        if self.block_gas_limit_override.is_some() {
            self.block_gas_limit_override
        } else {
            self.block_gas_limit_type.block_gas_limit()
        }
    }
```
