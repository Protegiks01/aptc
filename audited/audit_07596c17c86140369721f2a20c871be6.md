# Audit Report

## Title
Root Node Misclassification in StaleNodeIndexCrossEpochSchema Due to Incomplete Epoch Boundary Check

## Summary
The `create_jmt_commit_batch_for_shard` function in `StateMerkleDb` uses an incomplete logic check when determining whether stale root nodes should be stored in `StaleNodeIndexCrossEpochSchema` versus `StaleNodeIndexSchema`. Root nodes that become stale exactly at epoch-ending transactions are incorrectly routed to the regular schema when their version falls after the previous epoch ending, even though they were the latest root at the current epoch boundary. This violates the schema's stated purpose and could cause epoch snapshot inconsistencies.

## Finding Description

The vulnerability lies in the conditional logic that determines schema selection for stale node indices: [1](#0-0) 

The check `row.node_key.version() <= previous_epoch_ending_version.unwrap()` only considers whether the node version is at or before the **previous** epoch ending, not whether the node was the latest at **any** epoch ending (including the current one).

The `previous_epoch_ending_version` is obtained via: [2](#0-1) 

which calls: [3](#0-2) 

This function returns the epoch ending **strictly before** the current version, not including it.

**Vulnerable Scenario:**
1. Epoch 0 ends at version 1000
2. At version 1990, a new root node is created via `put_top_levels_nodes`: [4](#0-3) 

3. At version 2000 (Epoch 1 ending), the tree is updated with a new root
4. The old root (v1990) becomes stale and enters `create_jmt_commit_batch_for_shard`
5. `previous_epoch_ending_version = get_previous_epoch_ending(2000) = Some(1000)`
6. Check: `1990 <= 1000` evaluates to **FALSE**
7. The root is stored in `StaleNodeIndexSchema` instead of `StaleNodeIndexCrossEpochSchema`

According to the schema's documented purpose, this is incorrect: [5](#0-4) 

The root at v1990 **was** the latest root during Epoch 1, including at the epoch 1 ending (v2000), but fails the check because it was created after the Epoch 0 ending (v1000).

## Impact Explanation

This qualifies as **Medium Severity** under the "State inconsistencies requiring intervention" category, potentially escalating to **High Severity** for "Significant protocol violations."

The misclassification causes root nodes to be:
- Pruned by the regular state merkle pruner instead of the epoch snapshot pruner
- These pruners have different prune windows configured via `StateMerklePrunerConfig` and `EpochSnapshotPrunerConfig`
- Epoch snapshots become incomplete, breaking state synchronization for validators joining from epoch checkpoints
- Different validators pruning at different rates could observe inconsistent state availability
- Breaks the invariant that "nodes that are the latest in at least one epoch" are preserved for epoch snapshot purposes

While not causing immediate consensus failure, this creates a latent correctness violation that degrades network reliability over time.

## Likelihood Explanation

This occurs with **moderate likelihood** in production:
- Triggers whenever a root node is updated at an epoch-ending transaction
- Root updates happen frequently as the Jellyfish Merkle tree evolves
- The condition (root version between previous and current epoch endings) is common during active networks
- The bug is deterministic once the timing conditions are met
- No attacker action is requiredâ€”happens during normal operation

However, this is **not directly exploitable** by an external attacker as it depends on internal timing of epoch boundaries and state updates controlled by consensus.

## Recommendation

Fix the logic to check whether the node was the latest at **any** epoch ending between its creation and when it became stale:

```rust
// In create_jmt_commit_batch_for_shard, replace lines 378-385 with:

let should_use_cross_epoch_schema = if let Some(prev_epoch) = previous_epoch_ending_version {
    // Check if node was created at or before any epoch that ended before stale_since_version
    // This includes both the previous epoch and the current version if it's an epoch ending
    row.node_key.version() <= prev_epoch || 
    self.ledger_db.metadata_db().is_epoch_ending(row.node_key.version()).unwrap_or(false)
} else {
    false
};

if should_use_cross_epoch_schema {
    batch.put::<StaleNodeIndexCrossEpochSchema>(row, &())
} else {
    batch.put::<StaleNodeIndexSchema>(row, &())
}
```

Alternatively, pass the current version's epoch-ending status to the function and check if the node was the latest at the current epoch ending.

## Proof of Concept

```rust
// Test demonstrating the misclassification
// File: storage/aptosdb/src/state_merkle_db_test.rs

#[test]
fn test_root_node_cross_epoch_classification() {
    let tmpdir = TempPath::new();
    let db = AptosDB::new_for_test(&tmpdir);
    let state_merkle_db = &db.state_store.state_merkle_db;
    
    // Setup: Create epoch ending at version 1000
    db.save_transactions(/* ... epoch ending transaction at v1000 ... */);
    
    // Create root node at version 1990 (after epoch 0 ending at v1000)
    let value_set_1990 = vec![/* ... some state updates ... */];
    let (batch1, _, _) = state_merkle_db.merklize_value_set(
        value_set_1990,
        1990,
        Some(1000),  // base_version
        Some(1000),  // previous_epoch_ending_version  
    ).unwrap();
    
    // Create epoch ending at version 2000 with new root
    let value_set_2000 = vec![/* ... state updates triggering root change ... */];
    let (batch2, _, _) = state_merkle_db.merklize_value_set(
        value_set_2000,
        2000,
        Some(1990),  // base_version (root at v1990 becomes stale)
        Some(1000),  // previous_epoch_ending_version (still 1000, not 2000!)
    ).unwrap();
    
    // Verify: The stale root from v1990 should be in StaleNodeIndexCrossEpochSchema
    // but will incorrectly be in StaleNodeIndexSchema
    let stale_root_key = NodeKey::new_empty_path(1990);
    let stale_index = StaleNodeIndex {
        stale_since_version: 2000,
        node_key: stale_root_key,
    };
    
    // This will FAIL - the index is in the wrong schema
    assert!(state_merkle_db.metadata_db()
        .get::<StaleNodeIndexCrossEpochSchema>(&stale_index)
        .unwrap()
        .is_some(),
        "Root from v1990 (latest at epoch 1 ending v2000) should be in cross-epoch schema"
    );
}
```

## Notes

This vulnerability represents a correctness bug rather than a directly exploitable security vulnerability. While an external attacker cannot trigger this condition on demand (as it depends on internal consensus-driven epoch transitions), the bug systematically misclassifies root nodes at epoch boundaries, violating the system's invariants for epoch snapshot preservation and potentially causing state sync failures for validators joining the network.

### Citations

**File:** storage/aptosdb/src/state_merkle_db.rs (L376-386)
```rust
        stale_node_index_batch.iter().try_for_each(|row| {
            ensure!(row.node_key.get_shard_id() == shard_id, "shard_id mismatch");
            if previous_epoch_ending_version.is_some()
                && row.node_key.version() <= previous_epoch_ending_version.unwrap()
            {
                batch.put::<StaleNodeIndexCrossEpochSchema>(row, &())
            } else {
                // These are processed by the state merkle pruner.
                batch.put::<StaleNodeIndexSchema>(row, &())
            }
        })?;
```

**File:** storage/aptosdb/src/state_store/state_snapshot_committer.rs (L93-99)
```rust
                    let previous_epoch_ending_version = self
                        .state_db
                        .ledger_db
                        .metadata_db()
                        .get_previous_epoch_ending(version)
                        .unwrap()
                        .map(|(v, _e)| v);
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L244-259)
```rust
    /// Returns the latest ended epoch strictly before required version, i.e. if the passed in
    /// version ends an epoch, return one epoch early than that.
    pub(crate) fn get_previous_epoch_ending(
        &self,
        version: Version,
    ) -> Result<Option<(u64, Version)>> {
        if version == 0 {
            return Ok(None);
        }
        let prev_version = version - 1;

        let mut iter = self.db.iter::<EpochByVersionSchema>()?;
        // Search for the end of the previous epoch.
        iter.seek_for_prev(&prev_version)?;
        iter.next().transpose()
    }
```

**File:** storage/jellyfish-merkle/src/lib.rs (L450-454)
```rust
        let mut tree_update_batch = TreeUpdateBatch::new();
        if let Some(persisted_version) = persisted_version {
            tree_update_batch.put_stale_node(NodeKey::new_empty_path(persisted_version), version);
        }
        tree_update_batch.put_node(NodeKey::new_empty_path(version), root_node);
```

**File:** storage/aptosdb/src/schema/stale_node_index_cross_epoch/mod.rs (L4-6)
```rust
//! Similar to `state_node_index`, this records the same node replacement information except that
//! the stale nodes here are the latest in at least one epoch.
//!
```
