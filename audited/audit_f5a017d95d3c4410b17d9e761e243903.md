# Audit Report

## Title
Lock Poisoning Denial of Service in PackageLock Implementation Prevents All Package Operations

## Summary
The `PackageLock` implementation uses `.unwrap()` when acquiring a Rust `Mutex`, which causes a panic if the mutex is poisoned. When any thread panics while holding the `PackageLock`, the underlying mutex becomes poisoned, and all subsequent attempts to acquire the lock will panic, creating a permanent Denial of Service condition that requires process restart to recover.

## Finding Description

The vulnerability exists in the `PackageLock::strict_lock()` method which unconditionally unwraps the mutex lock result: [1](#0-0) 

In Rust, when a thread panics while holding a `MutexGuard`, the mutex becomes "poisoned" and subsequent calls to `.lock()` return `Err(PoisonError)`. By calling `.unwrap()` on line 47, any poisoned mutex will cause an immediate panic.

The `PackageLock` is used across all critical package operations including compilation, dependency resolution, and model building: [2](#0-1) [3](#0-2) [4](#0-3) 

Between the `lock()` and `unlock()` calls, numerous operations with `.unwrap()` can panic: [5](#0-4) [6](#0-5) 

**Attack Scenario:**

1. An attacker triggers a panic condition during package compilation (e.g., by providing a malformed package that causes I/O errors in `get_sources()` or `get_bytecodes()`)
2. The panic occurs while `PackageLock` is held, causing the `PACKAGE_THREAD_MUTEX` to become poisoned
3. The mutex guard is dropped during stack unwinding, marking the mutex as poisoned
4. All future calls to `PackageLock::lock()` or `PackageLock::strict_lock()` panic at line 47 when `.unwrap()` is called on the poisoned mutex
5. All package operations (compilation, dependency downloads, model building) become permanently unavailable until the process is restarted

## Impact Explanation

This vulnerability qualifies as **High Severity** according to Aptos Bug Bounty criteria:

- **Validator node slowdowns**: Validators that use move-package tooling for compilation or testing would experience complete failure of package operations
- **API crashes**: Any service using the move-package library would experience cascading panics on every package operation attempt
- **Significant protocol violations**: While not directly affecting consensus, this breaks the operational integrity of nodes that need to compile or update Move packages

The impact extends to:
- Validator nodes performing package compilation
- Developer tools and CLI utilities
- Any automated systems that compile Move packages
- Node upgrade processes that involve package compilation

## Likelihood Explanation

The likelihood is **MEDIUM to HIGH** because:

1. **Trigger conditions are realistic**: Any panic in the extensive code paths between `lock()` and `unlock()` will cause poisoning
2. **Multiple panic sources exist**: The code contains numerous `.unwrap()` calls on operations that can fail (filesystem I/O, package resolution, dependency lookup)
3. **No recovery mechanism**: Once poisoned, the mutex remains poisoned for the process lifetime
4. **Broad attack surface**: Attackers can trigger panics through malformed packages, missing dependencies, filesystem errors, or corrupted package metadata
5. **Common operations affected**: Package compilation and dependency resolution are frequent operations in blockchain development and node operations

## Recommendation

Replace `.unwrap()` with proper error handling that recovers from poisoned mutexes. The standard pattern is to call `.unwrap_or_else()` with a closure that handles the `PoisonError`:

```rust
pub(crate) fn strict_lock() -> PackageLock {
    let thread_lock = PACKAGE_THREAD_MUTEX
        .lock()
        .unwrap_or_else(|poisoned| {
            // Recover from poisoned mutex by taking the guard
            // This clears the poisoned state
            poisoned.into_inner()
        });
    let process_lock = PACKAGE_PROCESS_MUTEX
        .lock()
        .unwrap_or_else(|poisoned| {
            poisoned.into_inner()
        });
    Self::Active {
        thread_lock,
        process_lock,
    }
}
```

Alternatively, use a more defensive approach that logs the poisoning event:

```rust
pub(crate) fn strict_lock() -> PackageLock {
    let thread_lock = PACKAGE_THREAD_MUTEX
        .lock()
        .unwrap_or_else(|poisoned| {
            eprintln!("Warning: PackageLock mutex was poisoned, recovering...");
            poisoned.into_inner()
        });
    let process_lock = PACKAGE_PROCESS_MUTEX
        .lock()
        .unwrap_or_else(|poisoned| {
            eprintln!("Warning: NamedLock mutex was poisoned, recovering...");
            poisoned.into_inner()
        });
    Self::Active {
        thread_lock,
        process_lock,
    }
}
```

Additionally, consider wrapping critical operations between `lock()` and `unlock()` with panic handlers or using RAII patterns to ensure proper cleanup.

## Proof of Concept

```rust
// File: test_lock_poisoning.rs
// This PoC demonstrates the lock poisoning vulnerability

use std::sync::{Mutex, Arc};
use std::thread;
use std::panic;

// Simulate the PackageLock pattern
static TEST_MUTEX: once_cell::sync::Lazy<Mutex<()>> = 
    once_cell::sync::Lazy::new(|| Mutex::new(()));

fn acquire_lock_with_unwrap() {
    let _guard = TEST_MUTEX.lock().unwrap();
    println!("Lock acquired successfully");
}

fn main() {
    println!("=== Lock Poisoning PoC ===\n");
    
    // Step 1: First acquisition succeeds
    println!("Step 1: Acquiring lock normally...");
    acquire_lock_with_unwrap();
    println!("Success!\n");
    
    // Step 2: Simulate a panic while holding the lock
    println!("Step 2: Acquiring lock and panicking...");
    let handle = thread::spawn(|| {
        let _guard = TEST_MUTEX.lock().unwrap();
        println!("Lock acquired, about to panic!");
        panic!("Simulating panic during package operation");
    });
    
    let _ = handle.join();
    println!("Thread panicked (expected)\n");
    
    // Step 3: Attempt to acquire poisoned lock with unwrap() - this will panic
    println!("Step 3: Attempting to acquire poisoned lock with unwrap()...");
    println!("This will panic, demonstrating the DoS condition:\n");
    
    let result = panic::catch_unwind(|| {
        acquire_lock_with_unwrap();
    });
    
    match result {
        Ok(_) => println!("ERROR: Should have panicked!"),
        Err(_) => {
            println!("✗ PANIC OCCURRED - All future operations are now broken!");
            println!("✗ This demonstrates the permanent DoS condition");
            println!("✗ Process restart is the only recovery method");
        }
    }
}
```

**To reproduce in the actual codebase:**

1. Create a malformed Move package with invalid filesystem paths
2. Attempt to compile it using `BuildConfig::compile_package()`
3. Trigger an I/O error or panic in `get_sources()` or `get_bytecodes()`
4. Observe that all subsequent package operations panic
5. Verify that only process restart recovers functionality

## Notes

This vulnerability affects all nodes and tools using the move-package library. While it doesn't directly compromise consensus, it creates a severe operational vulnerability where package compilation becomes permanently unavailable after a single panic event. The fix is straightforward and should be applied to all mutex acquisition points in the `PackageLock` implementation.

### Citations

**File:** third_party/move/tools/move-package/src/package_lock.rs (L46-53)
```rust
    pub(crate) fn strict_lock() -> PackageLock {
        let thread_lock = PACKAGE_THREAD_MUTEX.lock().unwrap();
        let process_lock = PACKAGE_PROCESS_MUTEX.lock().unwrap();
        Self::Active {
            thread_lock,
            process_lock,
        }
    }
```

**File:** third_party/move/tools/move-package/src/lib.rs (L145-152)
```rust
    pub fn compile_package<W: Write>(self, path: &Path, writer: &mut W) -> Result<CompiledPackage> {
        let config = self.compiler_config.clone(); // Need clone because of mut self
        let resolved_graph = self.resolution_graph_for_package(path, writer)?;
        let mutx = PackageLock::lock();
        let ret = BuildPlan::create(resolved_graph)?.compile(&config, writer);
        mutx.unlock();
        ret
    }
```

**File:** third_party/move/tools/move-package/src/lib.rs (L157-169)
```rust
    pub fn compile_package_no_exit<W: Write>(
        self,
        resolved_graph: ResolvedGraph,
        external_checks: Vec<Arc<dyn ExternalChecks>>,
        writer: &mut W,
    ) -> Result<(CompiledPackage, Option<model::GlobalEnv>)> {
        let config = self.compiler_config.clone(); // Need clone because of mut self
        let mutx = PackageLock::lock();
        let ret =
            BuildPlan::create(resolved_graph)?.compile_no_exit(&config, external_checks, writer);
        mutx.unlock();
        ret
    }
```

**File:** third_party/move/tools/move-package/src/lib.rs (L176-188)
```rust
    pub fn move_model_for_package(
        self,
        path: &Path,
        model_config: ModelConfig,
    ) -> Result<model::GlobalEnv> {
        // resolution graph diagnostics are only needed for CLI commands so ignore them by passing a
        // vector as the writer
        let resolved_graph = self.resolution_graph_for_package(path, &mut Vec::new())?;
        let mutx = PackageLock::lock();
        let ret = ModelBuilder::create(resolved_graph, model_config).build_model();
        mutx.unlock();
        ret
    }
```

**File:** third_party/move/tools/move-package/src/compilation/build_plan.rs (L99-124)
```rust
        let transitive_dependencies = root_package
            .transitive_dependencies(&self.resolution_graph)
            .into_iter()
            .map(|package_name| {
                let dep_package = self
                    .resolution_graph
                    .package_table
                    .get(&package_name)
                    .unwrap();
                let mut dep_source_paths = dep_package
                    .get_sources(&self.resolution_graph.build_options)
                    .unwrap();
                let mut source_available = true;
                // If source is empty, search bytecode(mv) files
                if dep_source_paths.is_empty() {
                    dep_source_paths = dep_package.get_bytecodes().unwrap();
                    source_available = false;
                }
                (
                    package_name,
                    immediate_dependencies_names.contains(&package_name),
                    dep_source_paths,
                    &dep_package.resolution_table,
                    source_available,
                )
            })
```

**File:** third_party/move/tools/move-package/src/compilation/model_builder.rs (L47-54)
```rust
                let mut dep_source_paths = pkg
                    .get_sources(&self.resolution_graph.build_options)
                    .unwrap();
                let mut source_available = true;
                // If source is empty, search bytecode
                if dep_source_paths.is_empty() {
                    dep_source_paths = pkg.get_bytecodes().unwrap();
                    source_available = false;
```
