# Audit Report

## Title
Mempool Memory Underestimation Due to Excluded Transaction Authenticator Size Allows OOM Attacks

## Summary
The mempool's `get_estimated_bytes()` function systematically underestimates transaction memory usage by excluding the `TransactionAuthenticator` size from its calculation. This allows attackers to bypass the `capacity_bytes` limit by submitting transactions with large authenticators (e.g., FeePayer with multiple secondary signers), potentially causing out-of-memory crashes on validator nodes.

## Finding Description

The mempool tracks memory usage to enforce capacity limits and prevent resource exhaustion. However, the size estimation is critically incomplete. [1](#0-0) 

The `get_estimated_bytes()` method uses `self.txn.raw_txn_bytes_len()`, which only returns the serialized size of the `RawTransaction`: [2](#0-1) 

However, a `SignedTransaction` contains both the `raw_txn` AND the `authenticator`: [3](#0-2) 

The correct method `txn_bytes_len()` exists but is not used: [4](#0-3) 

The `TransactionAuthenticator` can be extremely large, especially for FeePayer and MultiAgent variants: [5](#0-4) 

These variants contain `Vec<AccountAddress>` and `Vec<AccountAuthenticator>`, which can hold up to 32 signatures: [6](#0-5) 

Additionally, `Abstract` authenticators contain arbitrary-sized `Vec<u8>` fields: [7](#0-6) 

**Attack Scenario:**
1. Attacker crafts FeePayer transactions with 31 secondary signers (plus sender and fee payer = 32 total signatures)
2. Each authenticator consumes ~4KB (32 addresses × 32 bytes + 32 Ed25519 signatures × 96 bytes)
3. Mempool only counts the RawTransaction size (~200 bytes) but misses the 4KB authenticator
4. With default capacity_bytes = 2GB, attacker can insert 500,000 such transactions
5. Actual memory usage: 500,000 × 4KB = 2GB of unaccounted authenticator data + 2GB of counted data = 4GB total
6. Node exceeds configured memory limits and crashes with OOM

The mempool's fullness check relies on the underestimated size: [8](#0-7) 

The size tracking uses the flawed estimation: [9](#0-8) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria:

1. **Validator node slowdowns**: Excessive memory consumption degrades performance before OOM
2. **Node crashes**: OOM kills lead to validator unavailability and network disruption
3. **Protocol violation**: Bypasses the mempool's resource limit enforcement mechanism

While not directly causing consensus violations or fund loss, this enables DoS attacks against individual validators. However, this differs from excluded "network-level DoS" because it exploits a logic bug in memory accounting, not network flooding.

The default configuration sets `capacity_bytes: 2 * 1024 * 1024 * 1024` (2GB): [10](#0-9) 

An attacker can cause 2x-4x memory overrun beyond this limit, depending on authenticator sizes used.

## Likelihood Explanation

**Likelihood: High**

1. **Zero cost to attacker**: Transaction submission is free before execution
2. **No special access required**: Any user can create FeePayer or MultiAgent transactions
3. **Supported feature**: These authenticator types are intentionally supported
4. **Easy to automate**: Simple script can generate and submit malicious transactions
5. **Current bug**: This is not a hypothetical future risk—the bug exists today

The only mitigating factor is that nodes may have OS-level memory limits that kill the process before complete system failure, but this still achieves the attacker's DoS goal.

## Recommendation

Replace `raw_txn_bytes_len()` with `txn_bytes_len()` in the estimation:

```rust
// In mempool/src/core_mempool/transaction.rs
pub(crate) fn get_estimated_bytes(&self) -> usize {
    self.txn.txn_bytes_len() + TXN_FIXED_ESTIMATED_BYTES + TXN_INDEX_ESTIMATED_BYTES
}
```

This correctly accounts for the authenticator size. Additionally, review whether `TXN_FIXED_ESTIMATED_BYTES` using `size_of::<MempoolTransaction>()` is appropriate, as it doesn't capture heap allocations like the `Arc<AtomicUsize>` in `InsertionInfo`: [11](#0-10) 

Consider adding a constant overhead for the Arc allocation or using a more accurate calculation.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_crypto::{ed25519::Ed25519PrivateKey, PrivateKey, SigningKey, Uniform};
    use aptos_types::{
        account_address::AccountAddress,
        chain_id::ChainId,
        transaction::{
            authenticator::{AccountAuthenticator, TransactionAuthenticator},
            RawTransaction, ReplayProtector, Script, SignedTransaction, TransactionExecutable,
        },
    };
    use std::time::{Duration, SystemTime};

    #[test]
    fn test_authenticator_size_underestimation() {
        // Create a simple Ed25519 transaction
        let simple_txn = create_simple_transaction();
        let simple_mempool_txn = create_test_mempool_transaction(simple_txn.clone());
        
        // Create a FeePayer transaction with 10 secondary signers
        let fee_payer_txn = create_fee_payer_transaction(10);
        let fee_payer_mempool_txn = create_test_mempool_transaction(fee_payer_txn.clone());
        
        // Get estimated bytes (what mempool thinks)
        let simple_estimated = simple_mempool_txn.get_estimated_bytes();
        let fee_payer_estimated = fee_payer_mempool_txn.get_estimated_bytes();
        
        // Get actual bytes (what it really uses)
        let simple_actual = simple_txn.txn_bytes_len() + TXN_FIXED_ESTIMATED_BYTES + TXN_INDEX_ESTIMATED_BYTES;
        let fee_payer_actual = fee_payer_txn.txn_bytes_len() + TXN_FIXED_ESTIMATED_BYTES + TXN_INDEX_ESTIMATED_BYTES;
        
        // For simple transaction, estimation should be close
        assert!((simple_estimated as i64 - simple_actual as i64).abs() < 100);
        
        // For FeePayer transaction, estimation is SIGNIFICANTLY lower than actual
        // This demonstrates the underestimation vulnerability
        println!("FeePayer estimated: {}, actual: {}, underestimation: {} bytes", 
                 fee_payer_estimated, fee_payer_actual, fee_payer_actual - fee_payer_estimated);
        
        // The underestimation should be substantial (multiple KB for 10 signers)
        assert!(fee_payer_actual - fee_payer_estimated > 1000, 
                "Expected significant underestimation, got {} bytes", 
                fee_payer_actual - fee_payer_estimated);
    }

    fn create_fee_payer_transaction(num_secondary_signers: usize) -> SignedTransaction {
        let sender_key = Ed25519PrivateKey::generate_for_testing();
        let fee_payer_key = Ed25519PrivateKey::generate_for_testing();
        
        let raw_txn = RawTransaction::new_txn(
            AccountAddress::random(),
            ReplayProtector::SequenceNumber(0),
            TransactionExecutable::Script(Script::new(vec![0x1], vec![], vec![])),
            None,
            0,
            0,
            u64::MAX,
            ChainId::new(10),
        );
        
        // Create secondary signers
        let mut secondary_addresses = vec![];
        let mut secondary_signers = vec![];
        for _ in 0..num_secondary_signers {
            let key = Ed25519PrivateKey::generate_for_testing();
            secondary_addresses.push(AccountAddress::random());
            secondary_signers.push(AccountAuthenticator::ed25519(
                key.public_key(),
                key.sign(&raw_txn).unwrap(),
            ));
        }
        
        SignedTransaction::new_fee_payer(
            raw_txn.clone(),
            AccountAuthenticator::ed25519(sender_key.public_key(), sender_key.sign(&raw_txn).unwrap()),
            secondary_addresses,
            secondary_signers,
            AccountAddress::random(),
            AccountAuthenticator::ed25519(fee_payer_key.public_key(), fee_payer_key.sign(&raw_txn).unwrap()),
        )
    }

    fn create_simple_transaction() -> SignedTransaction {
        let private_key = Ed25519PrivateKey::generate_for_testing();
        let public_key = private_key.public_key();
        
        let raw_transaction = RawTransaction::new_txn(
            AccountAddress::random(),
            ReplayProtector::SequenceNumber(0),
            TransactionExecutable::Script(Script::new(vec![0x1], vec![], vec![])),
            None,
            0,
            0,
            u64::MAX,
            ChainId::new(10),
        );
        
        SignedTransaction::new(
            raw_transaction.clone(),
            public_key,
            private_key.sign(&raw_transaction).unwrap(),
        )
    }

    fn create_test_mempool_transaction(signed_txn: SignedTransaction) -> MempoolTransaction {
        MempoolTransaction::new(
            signed_txn,
            Duration::from_secs(1),
            1,
            TimelineState::NotReady,
            SystemTime::now(),
            false,
            Some(BroadcastPeerPriority::Primary),
        )
    }
}
```

**Notes**

The vulnerability exists in the current codebase and represents a **concrete exploitable bug**, not a hypothetical future risk. While the security question asks about "future code adding large fields," the investigation reveals that large heap-allocated data already exists in `TransactionAuthenticator` variants but is systematically excluded from size estimation. An attacker can exploit this today by submitting FeePayer or MultiAgent transactions with maximum allowed signers, causing memory usage to exceed configured limits and potentially crash validator nodes.

### Citations

**File:** mempool/src/core_mempool/transaction.rs (L70-72)
```rust
    pub(crate) fn get_estimated_bytes(&self) -> usize {
        self.txn.raw_txn_bytes_len() + TXN_FIXED_ESTIMATED_BYTES + TXN_INDEX_ESTIMATED_BYTES
    }
```

**File:** mempool/src/core_mempool/transaction.rs (L109-116)
```rust
#[derive(Debug, Clone)]
pub struct InsertionInfo {
    pub insertion_time: SystemTime,
    pub ready_time: SystemTime,
    pub park_time: Option<SystemTime>,
    pub submitted_by: SubmittedBy,
    pub consensus_pulled_counter: Arc<AtomicUsize>,
}
```

**File:** types/src/transaction/mod.rs (L1038-1058)
```rust
pub struct SignedTransaction {
    /// The raw transaction
    raw_txn: RawTransaction,

    /// Public key and signature to authenticate
    authenticator: TransactionAuthenticator,

    /// A cached size of the raw transaction bytes.
    /// Prevents serializing the same transaction multiple times to determine size.
    #[serde(skip)]
    raw_txn_size: OnceCell<usize>,

    /// A cached size of the authenticator.
    /// Prevents serializing the same authenticator multiple times to determine size.
    #[serde(skip)]
    authenticator_size: OnceCell<usize>,

    /// A cached hash of the transaction.
    #[serde(skip)]
    committed_hash: OnceCell<HashValue>,
}
```

**File:** types/src/transaction/mod.rs (L1294-1298)
```rust
    pub fn raw_txn_bytes_len(&self) -> usize {
        *self.raw_txn_size.get_or_init(|| {
            bcs::serialized_size(&self.raw_txn).expect("Unable to serialize RawTransaction")
        })
    }
```

**File:** types/src/transaction/mod.rs (L1300-1306)
```rust
    pub fn txn_bytes_len(&self) -> usize {
        let authenticator_size = *self.authenticator_size.get_or_init(|| {
            bcs::serialized_size(&self.authenticator)
                .expect("Unable to serialize TransactionAuthenticator")
        });
        self.raw_txn_bytes_len() + authenticator_size
    }
```

**File:** types/src/transaction/authenticator.rs (L32-34)
```rust
/// Maximum number of signatures supported in `TransactionAuthenticator`,
/// across all `AccountAuthenticator`s included.
pub const MAX_NUM_OF_SIGS: usize = 32;
```

**File:** types/src/transaction/authenticator.rs (L74-102)
```rust
pub enum TransactionAuthenticator {
    /// Single Ed25519 signature
    Ed25519 {
        public_key: Ed25519PublicKey,
        signature: Ed25519Signature,
    },
    /// K-of-N multisignature
    MultiEd25519 {
        public_key: MultiEd25519PublicKey,
        signature: MultiEd25519Signature,
    },
    /// Multi-agent transaction.
    MultiAgent {
        sender: AccountAuthenticator,
        secondary_signer_addresses: Vec<AccountAddress>,
        secondary_signers: Vec<AccountAuthenticator>,
    },
    /// Optional Multi-agent transaction with a fee payer.
    FeePayer {
        sender: AccountAuthenticator,
        secondary_signer_addresses: Vec<AccountAddress>,
        secondary_signers: Vec<AccountAuthenticator>,
        fee_payer_address: AccountAddress,
        fee_payer_signer: AccountAuthenticator,
    },
    SingleSender {
        sender: AccountAuthenticator,
    },
}
```

**File:** types/src/transaction/authenticator.rs (L595-611)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, Hash)]
pub enum AbstractAuthenticationData {
    V1 {
        #[serde(with = "serde_bytes")]
        signing_message_digest: Vec<u8>,
        #[serde(with = "serde_bytes")]
        abstract_signature: Vec<u8>,
    },
    DerivableV1 {
        #[serde(with = "serde_bytes")]
        signing_message_digest: Vec<u8>,
        #[serde(with = "serde_bytes")]
        abstract_signature: Vec<u8>,
        #[serde(with = "serde_bytes")]
        abstract_public_key: Vec<u8>,
    },
}
```

**File:** mempool/src/core_mempool/transaction_store.rs (L354-354)
```rust
            self.size_bytes += txn.get_estimated_bytes();
```

**File:** mempool/src/core_mempool/transaction_store.rs (L458-460)
```rust
    fn is_full(&self) -> bool {
        self.system_ttl_index.size() >= self.capacity || self.size_bytes >= self.capacity_bytes
    }
```

**File:** config/src/config/mempool_config.rs (L122-122)
```rust
            capacity_bytes: 2 * 1024 * 1024 * 1024,
```
