# Audit Report

## Title
Unauthenticated Peer Storage Summary Disclosure Enables Targeted Data Withholding Attacks

## Summary
The inspection service's `/peer_information` endpoint exposes detailed storage summaries of all connected peers without authentication, revealing which nodes have incomplete blockchain state. This information disclosure enables attackers to precisely identify and target syncing validators with data withholding attacks, degrading network resilience and potentially preventing specific validators from participating in consensus.

## Finding Description

The `display_state_sync_metadata()` function in the inspection service exposes sensitive peer synchronization information through an unauthenticated HTTP endpoint. Specifically, it reveals each peer's advertised storage summary, which contains: [1](#0-0) 

This storage summary includes critical data ranges that reveal synchronization state: [2](#0-1) 

The inspection service is enabled by default and binds to all network interfaces without authentication: [3](#0-2) 

The service accepts any HTTP request without authentication or authorization checks: [4](#0-3) 

**Attack Path:**

1. **Information Gathering:** Attacker scans for open port 9101 on Aptos nodes or accesses it through exposed HAProxy endpoints
2. **Vulnerability Mapping:** Attacker queries `/peer_information` on multiple nodes to build a network map showing which nodes are syncing and what data ranges they're missing
3. **Target Selection:** Attacker identifies high-value targets (e.g., validators with incomplete state that are trying to catch up before their epoch)
4. **Malicious Peer Deployment:** Attacker deploys malicious peers that advertise having the specific data ranges the target needs
5. **Data Withholding:** When targets request data, malicious peers either timeout, respond slowly, or provide invalid data to degrade synchronization performance
6. **Targeted Disruption:** Unlike blind attacks, the attacker can focus resources on specific critical infrastructure nodes

Normal state sync protocol already shares storage summaries between connected peers, but the inspection service extends this to ANY party who can reach the HTTP endpoint: [5](#0-4) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program's "Validator node slowdowns" category.

**Direct Impact:**
- Enables precision targeting of syncing validators, preventing them from catching up and participating in consensus
- Reduces network resilience by allowing attackers to identify and exploit nodes in vulnerable states
- Facilitates strategic attacks on critical infrastructure (RPC nodes, indexers, specific validators)

**Amplification Factors:**
- The endpoint is enabled by default for all node types
- No authentication, rate limiting, or access controls exist
- The information is updated in real-time through periodic peer polling
- Attackers can query multiple nodes to build comprehensive network intelligence

While the state sync protocol has retry mechanisms and peer scoring to mitigate individual peer failures: [6](#0-5) 

These defenses are less effective against targeted attacks where the attacker knows exactly which nodes are vulnerable and what data they need.

## Likelihood Explanation

**High Likelihood** of exploitation:

1. **Default Configuration:** The endpoint is exposed by default with `expose_peer_information: true`
2. **Network Exposure:** Binds to 0.0.0.0:9101, accessible if not properly firewalled
3. **No Authentication:** Any party can query the endpoint
4. **Operational Reality:** Many node operators may not properly firewall the inspection service, especially on testnets or for development nodes
5. **Attack Complexity:** Low - requires only HTTP requests and P2P connectivity

The sanitizer only restricts configuration disclosure on mainnet validators, not peer information: [7](#0-6) 

## Recommendation

**Immediate Mitigation:**
1. Disable `expose_peer_information` by default for all production networks
2. Add authentication requirements for the `/peer_information` endpoint
3. Implement rate limiting to prevent reconnaissance scanning
4. Add configuration warnings when the endpoint is enabled on mainnet

**Code Fix:**

```rust
// In config/src/config/inspection_service_config.rs
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "127.0.0.1".to_string(), // Bind to localhost only by default
            port: 9101,
            expose_configuration: false,
            expose_identity_information: false, // Disable by default
            expose_peer_information: false,     // Disable by default - SECURITY CRITICAL
            expose_system_information: false,   // Disable by default
        }
    }
}

// Add sanitizer check
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Verify that mainnet nodes do not expose peer information
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() && inspection_service_config.expose_peer_information {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet nodes should not expose peer information publicly!".to_string(),
                ));
            }
        }
        
        // ... existing configuration check ...
        Ok(())
    }
}
```

## Proof of Concept

**Step 1: Query Inspection Service**
```bash
# Discover nodes with open inspection service
curl http://<target-node>:9101/peer_information

# Output reveals peer storage summaries:
# - Peer: PeerNetworkId(...), score: 45.2, bucket ID: 2
#   - Advertised storage summary: StorageServerSummary {
#       synced_ledger_info: Some(LedgerInfo { version: 50000000, epoch: 1234 }),
#       transactions: Some(CompleteDataRange { lowest: 0, highest: 45000000 }),
#       states: Some(CompleteDataRange { lowest: 0, highest: 40000000 })
#     }
```

**Step 2: Identify Syncing Validators**
From the output, identify peers with incomplete state (e.g., missing recent transactions/states compared to the global summary).

**Step 3: Deploy Malicious Peer**
```rust
// Pseudo-code for malicious peer
impl MaliciousPeer {
    fn advertise_storage_summary(&self) -> StorageServerSummary {
        // Advertise having the exact data ranges the target needs
        StorageServerSummary {
            synced_ledger_info: Some(current_ledger_info),
            transactions: Some(CompleteDataRange { 
                lowest: 45000000, 
                highest: 52000000  // Data the target is missing
            }),
            // ... other ranges the target needs
        }
    }
    
    fn handle_request(&self, request: StorageServiceRequest) -> Response {
        // Either timeout or respond with invalid data
        sleep(Duration::from_secs(60)); // Exceed timeout
        // OR: return malformed proof
    }
}
```

**Step 4: Observe Impact**
The targeted validator's sync progress slows significantly as it repeatedly times out requesting data from the malicious peer, while the attacker's peer score stays just above the ignore threshold by occasionally responding successfully.

**Notes:**
- This attack is significantly more effective than random data withholding because the attacker knows exactly which nodes to target and what data they need
- The information disclosure violates the principle of least privilege - external parties should not have visibility into internal peer synchronization state
- Production deployments should treat inspection endpoints as internal-only debugging tools, not public APIs

### Citations

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L244-254)
```rust
            let peer_storage_summary = peer_state_entry.get_storage_summary();

            // Display the peer states
            peer_information_output.push(format!(
                "\t- Peer: {}, score: {}, bucket ID: {}",
                peer, peer_score, peer_bucket_id
            ));
            peer_information_output.push(format!(
                "\t\t- Advertised storage summary: {:?}",
                peer_storage_summary
            ));
```

**File:** state-sync/storage-service/types/src/responses.rs (L666-686)
```rust
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct DataSummary {
    /// The ledger info corresponding to the highest synced version in storage.
    /// This indicates the highest version and epoch that storage can prove.
    pub synced_ledger_info: Option<LedgerInfoWithSignatures>,
    /// The range of epoch ending ledger infos in storage, e.g., if the range
    /// is [(X,Y)], it means all epoch ending ledger infos for epochs X->Y
    /// (inclusive) are held.
    pub epoch_ending_ledger_infos: Option<CompleteDataRange<Epoch>>,
    /// The range of states held in storage, e.g., if the range is
    /// [(X,Y)], it means all states are held for every version X->Y
    /// (inclusive).
    pub states: Option<CompleteDataRange<Version>>,
    /// The range of transactions held in storage, e.g., if the range is
    /// [(X,Y)], it means all transactions for versions X->Y (inclusive) are held.
    pub transactions: Option<CompleteDataRange<Version>>,
    /// The range of transaction outputs held in storage, e.g., if the range
    /// is [(X,Y)], it means all transaction outputs for versions X->Y
    /// (inclusive) are held.
    pub transaction_outputs: Option<CompleteDataRange<Version>>,
}
```

**File:** config/src/config/inspection_service_config.rs (L26-36)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
```

**File:** config/src/config/inspection_service_config.rs (L54-65)
```rust
        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
        }
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L104-170)
```rust
async fn serve_requests(
    req: Request<Body>,
    node_config: NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> Result<Response<Body>, hyper::Error> {
    // Process the request and get the response components
    let (status_code, body, content_type) = match req.uri().path() {
        CONFIGURATION_PATH => {
            // /configuration
            // Exposes the node configuration
            configuration::handle_configuration_request(&node_config)
        },
        CONSENSUS_HEALTH_CHECK_PATH => {
            // /consensus_health_check
            // Exposes the consensus health check
            metrics::handle_consensus_health_check(&node_config).await
        },
        FORGE_METRICS_PATH => {
            // /forge_metrics
            // Exposes forge encoded metrics
            metrics::handle_forge_metrics()
        },
        IDENTITY_INFORMATION_PATH => {
            // /identity_information
            // Exposes the identity information of the node
            identity_information::handle_identity_information_request(&node_config)
        },
        INDEX_PATH => {
            // /
            // Exposes the index and list of available endpoints
            index::handle_index_request()
        },
        JSON_METRICS_PATH => {
            // /json_metrics
            // Exposes JSON encoded metrics
            metrics::handle_json_metrics_request()
        },
        METRICS_PATH => {
            // /metrics
            // Exposes text encoded metrics
            metrics::handle_metrics_request()
        },
        PEER_INFORMATION_PATH => {
            // /peer_information
            // Exposes the peer information
            peer_information::handle_peer_information_request(
                &node_config,
                aptos_data_client,
                peers_and_metadata,
            )
        },
        SYSTEM_INFORMATION_PATH => {
            // /system_information
            // Exposes the system and build information
            system_information::handle_system_information_request(node_config)
        },
        _ => {
            // Handle the invalid path
            (
                StatusCode::NOT_FOUND,
                Body::from(INVALID_ENDPOINT_MESSAGE),
                CONTENT_TYPE_TEXT.into(),
            )
        },
    };

```

**File:** state-sync/aptos-data-client/src/poller.rs (L405-416)
```rust
        // Construct the request for polling
        let data_request = DataRequest::GetStorageServerSummary;
        let use_compression = data_summary_poller.data_client_config.use_compression;
        let storage_request = StorageServiceRequest::new(data_request, use_compression);

        // Fetch the storage summary for the peer and stop the timer
        let request_timeout = data_summary_poller.data_client_config.response_timeout_ms;
        let result: crate::error::Result<StorageServerSummary> = data_summary_poller
            .data_client
            .send_request_to_peer_and_decode(peer, storage_request, request_timeout)
            .await
            .map(Response::into_payload);
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L152-160)
```rust
    fn is_ignored(&self) -> bool {
        // Only ignore peers if the config allows it
        if !self.data_client_config.ignore_low_score_peers {
            return false;
        }

        // Otherwise, ignore peers with a low score
        self.score <= IGNORE_PEER_THRESHOLD
    }
```
