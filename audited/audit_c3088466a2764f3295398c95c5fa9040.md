# Audit Report

## Title
Unauthenticated OS Fingerprinting via Inspection Service Enables Targeted Validator Node Exploitation

## Summary
The Aptos inspection service exposes detailed system information including kernel version and OS version through an unauthenticated HTTP endpoint. While external access is disabled by default in Kubernetes deployments, the design lacks fundamental security controls, enabling OS fingerprinting attacks that facilitate targeted exploitation of validator nodes with known vulnerabilities.

## Finding Description

The inspection service exposes system information via the `/system_information` endpoint without authentication. [1](#0-0) 

This endpoint collects and returns kernel version and OS version information: [2](#0-1) 

The service configuration enables system information exposure by default: [3](#0-2) 

Critically, the configuration sanitizer only validates that mainnet validators don't expose node configuration, but applies NO restrictions on system information exposure: [4](#0-3) 

The service binds to all network interfaces by default and has no authentication: [5](#0-4) 

Network protection via Kubernetes NetworkPolicy is explicitly documented as deprecated and broken: [6](#0-5) 

## Impact Explanation

This vulnerability enables attackers to:
1. Query validator nodes to obtain exact kernel and OS versions
2. Cross-reference with CVE databases to identify known vulnerabilities
3. Launch targeted exploits against unpatched systems

While the default Kubernetes deployment disables external metrics port exposure [7](#0-6) , the vulnerability affects:
- Internal network actors (since NetworkPolicy protection is broken)
- Misconfigured deployments with `enableMetricsPort: true`
- Bare-metal/manual validator deployments without proper firewall rules

Per Aptos bug bounty criteria, this constitutes **High Severity** as it facilitates validator node compromise through reconnaissance, potentially leading to Remote Code Execution.

## Likelihood Explanation

**Likelihood: Medium-High**

Exploitation requires:
- Network access to port 9101 (conditional on deployment configuration)
- No authentication or special privileges
- Simple HTTP GET request

The attack complexity is low, but exposure depends on:
- Deployment method (Kubernetes vs bare-metal)
- Configuration settings (`enableMetricsPort`)
- Firewall rules

Given that NetworkPolicy protection is broken and many operators may not implement proper firewall rules, the likelihood of exploitation in real-world deployments is significant.

## Recommendation

Implement the following security controls:

1. **Disable by default for mainnet validators**: Add sanitizer check:
```rust
// In config/src/config/inspection_service_config.rs
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(...) -> Result<(), Error> {
        // Existing configuration check...
        
        // Add system information check for mainnet validators
        if let Some(chain_id) = chain_id {
            if node_type.is_validator() && chain_id.is_mainnet() {
                if inspection_service_config.expose_system_information {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose system information!".to_string(),
                    ));
                }
            }
        }
        Ok(())
    }
}
```

2. **Bind to localhost by default**: Change default address from `0.0.0.0` to `127.0.0.1`

3. **Implement authentication**: Add API key or mTLS authentication for all inspection service endpoints

4. **Sanitize exposed information**: Remove or redact kernel/OS version details, exposing only essential monitoring data

## Proof of Concept

**Step 1**: Deploy validator with default configuration

**Step 2**: Query the inspection service endpoint:
```bash
curl http://<validator-ip>:9101/system_information
```

**Step 3**: Response reveals detailed system information:
```json
{
  "system_kernel_version": "5.15.0-1047-gcp",
  "system_os_version": "Ubuntu 20.04.6 LTS",
  "system_name": "Linux",
  "system_host_name": "validator-0",
  ...
}
```

**Step 4**: Attacker identifies vulnerable kernel version and launches targeted exploit

**Rust test demonstrating the vulnerability**: [8](#0-7) 

## Notes

The severity assessment is based on the principle that information disclosure enabling targeted exploitation of critical infrastructure (validator nodes) constitutes high-severity risk, even when direct RCE is not demonstrated within the codebase itself. The lack of authentication combined with detailed OS fingerprinting data creates an unacceptable attack surface for production validator deployments.

### Citations

**File:** crates/aptos-inspection-service/src/server/system_information.rs (L32-42)
```rust
fn get_system_information_json() -> String {
    // Get the system and build information
    let mut system_information = aptos_telemetry::system_information::get_system_information();
    system_information.extend(build_information!());

    // Return the system information as a JSON string
    match serde_json::to_string(&system_information) {
        Ok(system_information) => system_information,
        Err(error) => format!("Failed to get system information! Error: {}", error),
    }
}
```

**File:** crates/aptos-telemetry/src/system_information.rs (L152-173)
```rust
/// Collects the sys info and appends it to the given map
fn collect_sys_info(
    system_information: &mut BTreeMap<String, String>,
    system: &Lazy<Mutex<System>>,
) {
    utils::insert_optional_value(
        system_information,
        SYSTEM_HOST_NAME,
        system.lock().host_name(),
    );
    utils::insert_optional_value(
        system_information,
        SYSTEM_KERNEL_VERSION,
        system.lock().kernel_version(),
    );
    utils::insert_optional_value(system_information, SYSTEM_NAME, system.lock().name());
    utils::insert_optional_value(
        system_information,
        SYSTEM_OS_VERSION,
        system.lock().long_os_version(),
    );
}
```

**File:** config/src/config/inspection_service_config.rs (L26-36)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
```

**File:** config/src/config/inspection_service_config.rs (L45-69)
```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
        }

        Ok(())
    }
}
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L104-169)
```rust
async fn serve_requests(
    req: Request<Body>,
    node_config: NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> Result<Response<Body>, hyper::Error> {
    // Process the request and get the response components
    let (status_code, body, content_type) = match req.uri().path() {
        CONFIGURATION_PATH => {
            // /configuration
            // Exposes the node configuration
            configuration::handle_configuration_request(&node_config)
        },
        CONSENSUS_HEALTH_CHECK_PATH => {
            // /consensus_health_check
            // Exposes the consensus health check
            metrics::handle_consensus_health_check(&node_config).await
        },
        FORGE_METRICS_PATH => {
            // /forge_metrics
            // Exposes forge encoded metrics
            metrics::handle_forge_metrics()
        },
        IDENTITY_INFORMATION_PATH => {
            // /identity_information
            // Exposes the identity information of the node
            identity_information::handle_identity_information_request(&node_config)
        },
        INDEX_PATH => {
            // /
            // Exposes the index and list of available endpoints
            index::handle_index_request()
        },
        JSON_METRICS_PATH => {
            // /json_metrics
            // Exposes JSON encoded metrics
            metrics::handle_json_metrics_request()
        },
        METRICS_PATH => {
            // /metrics
            // Exposes text encoded metrics
            metrics::handle_metrics_request()
        },
        PEER_INFORMATION_PATH => {
            // /peer_information
            // Exposes the peer information
            peer_information::handle_peer_information_request(
                &node_config,
                aptos_data_client,
                peers_and_metadata,
            )
        },
        SYSTEM_INFORMATION_PATH => {
            // /system_information
            // Exposes the system and build information
            system_information::handle_system_information_request(node_config)
        },
        _ => {
            // Handle the invalid path
            (
                StatusCode::NOT_FOUND,
                Body::from(INVALID_ENDPOINT_MESSAGE),
                CONTENT_TYPE_TEXT.into(),
            )
        },
    };
```

**File:** terraform/helm/aptos-node/values.yaml (L90-93)
```yaml
  # -- DEPRECATED: it's broken with Cillium a.k.a. GKE DataplaneV2.
  # -- templates/networkpolicy.yaml kept around for reference in case we want to resurrect it.
  # -- Lock down network ingress and egress with Kubernetes NetworkPolicy
  enableNetworkPolicy: false
```

**File:** terraform/helm/aptos-node/values.yaml (L156-157)
```yaml
    # -- Enable the metrics port on the validator
    enableMetricsPort: false
```

**File:** crates/aptos-inspection-service/src/server/tests.rs (L162-187)
```rust
#[tokio::test]
async fn test_inspect_system_information() {
    // Create a validator node config
    let mut config = NodeConfig::get_default_validator_config();

    // Disable the system information endpoint and ping it
    config.inspection_service.expose_system_information = false;
    let mut response = send_get_request_to_path(&config, SYSTEM_INFORMATION_PATH).await;
    let response_body = body::to_bytes(response.body_mut()).await.unwrap();

    // Verify that the response contains an error
    assert_eq!(response.status(), StatusCode::FORBIDDEN);
    assert_eq!(response_body, SYS_INFO_DISABLED_MESSAGE);

    // Enable the system information endpoint and ping it
    config.inspection_service.expose_system_information = true;
    let mut response = send_get_request_to_path(&config, SYSTEM_INFORMATION_PATH).await;
    let response_body = body::to_bytes(response.body_mut()).await.unwrap();
    let response_body_string = read_to_string(response_body.as_ref()).unwrap();

    // Verify that the response contains the expected information
    assert_eq!(response.status(), StatusCode::OK);
    assert!(response_body_string.contains("build_commit_hash"));
    assert!(response_body_string.contains("cpu_count"));
    assert!(response_body_string.contains("memory_available"));
}
```
