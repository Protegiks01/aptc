# Audit Report

## Title
Consensus Safety Violation: Non-Deterministic Execution Due to Unsynchronized Transaction Filter Configurations

## Summary
Transaction filter configurations (`quorum_store_filter`, `consensus_filter`, `execution_filter`) are stored in local `NodeConfig` without on-chain consensus enforcement. Different validators can have different `execution_filter` configurations, causing them to execute different transaction sets for the same block, resulting in divergent state roots and breaking consensus safety. Additionally, when `quorum_store_filter` is disabled while `execution_filter` is enabled, malicious batches containing transactions that should be denied can be certified via Proof-of-Store, wasting network resources and enabling resource exhaustion attacks.

## Finding Description

The Aptos transaction filtering system operates at three stages:

1. **Batch Voting Stage** (`quorum_store_filter`): Applied when validators vote on batches in the quorum store [1](#0-0) 

2. **Consensus Proposal Stage** (`consensus_filter`): Applied when validators vote on block proposals (inline transactions only) [2](#0-1) 

3. **Block Execution Stage** (`execution_filter`): Applied when ALL validators execute blocks [3](#0-2) 

**Critical Issue #1: Unsynchronized Filter Configurations**

All filter configurations originate from local `NodeConfig`, not from on-chain consensus: [4](#0-3) 

The `execution_filter` is passed to `ExecutionProxy` and used by ALL validators during block execution: [5](#0-4) 

Since filter configurations are local to each node and not consensus-agreed, different validators can have different `execution_filter` configurations. During block execution, each validator calls `filter_block_transactions` with their local configuration: [6](#0-5) 

This causes validators with different configurations to execute different transaction sets, producing different state roots.

**Critical Issue #2: Gap Between Batch Certification and Execution Filtering**

The `consensus_filter` only checks inline transactions, NOT transactions in batches referenced by Proof-of-Store: [7](#0-6) 

When `quorum_store_filter` is disabled (default configuration): [8](#0-7) 

Malicious batches containing transactions that should be denied can be certified: [9](#0-8) 

These certified batches are included in blocks, but the transactions are later filtered during execution, wasting resources.

## Impact Explanation

**Critical Severity - Consensus Safety Violation:**

This vulnerability breaks **Invariant #1: Deterministic Execution** - "All validators must produce identical state roots for identical blocks."

When validators have different `execution_filter` configurations:
- Validator A (filter disabled) executes transaction T from address X
- Validator B (filter enabled, denies address X) filters out transaction T
- They compute different state roots for the same block
- Consensus fails to reach agreement on committed state
- The blockchain cannot make progress without manual intervention (requires hard fork)

This meets **Critical Severity** criteria: "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)."

**High Severity - Resource Exhaustion:**

When `quorum_store_filter` is disabled but `execution_filter` is enabled:
- Attackers can submit transactions that should be denied
- These transactions get batched and certified (Proof-of-Store created)
- Validators waste bandwidth broadcasting, storage persisting, and computation signing these batches
- The transactions are filtered during execution, making the certification effort wasted
- Sustained attacks can degrade network performance

This meets **High Severity** criteria: "Validator node slowdowns" and "Significant protocol violations."

## Likelihood Explanation

**Very High Likelihood:**

1. **Default Configuration Vulnerability**: All filters are disabled by default. Operators must explicitly enable them, creating opportunity for misconfiguration. [10](#0-9) 

2. **No Enforcement Mechanism**: The codebase has no mechanism to ensure all validators have identical filter configurations. Each validator independently configures filters via local `NodeConfig`.

3. **Independent Operator Decisions**: Validators are operated by different organizations with different security policies. Some may enable transaction filtering to comply with regulations while others may not, naturally creating configuration divergence.

4. **Observable Behavior**: Attackers can infer filter configurations by observing which transactions validators include in blocks and which they reject, then craft transactions that exploit configuration differences.

5. **No Warning System**: There are no runtime checks or warnings when validators have different filter configurations, so the issue can persist undetected.

## Recommendation

**Immediate Mitigation:**

1. **Add On-Chain Filter Configuration**: Move transaction filter configurations from local `NodeConfig` to on-chain configuration managed through governance:

```rust
// types/src/on_chain_config/mod.rs
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
pub struct OnChainTransactionFilters {
    pub execution_filter: BlockTransactionFilter,
    pub consensus_filter: BlockTransactionFilter,
    pub quorum_store_filter: BatchTransactionFilter,
}

impl OnChainConfig for OnChainTransactionFilters {
    const MODULE_IDENTIFIER: &'static str = "transaction_filter_config";
    const TYPE_IDENTIFIER: &'static str = "TransactionFilterConfig";
}
```

2. **Synchronize Filter Application**: Ensure the same filter is applied at all three stages (batch voting, consensus voting, execution) to prevent resource waste:

```rust
// consensus/src/quorum_store/batch_coordinator.rs
// Use execution_filter instead of separate quorum_store_filter
if self.execution_filter_config.is_enabled() {
    let transaction_filter = &self.execution_filter_config.block_transaction_filter();
    // Apply same filter at batch voting stage
}
```

3. **Add Runtime Validation**: Implement checks during epoch initialization to verify all validators are using the same filter configuration (by comparing configuration hashes).

**Long-term Solution:**

Redesign the transaction filtering system to use on-chain governance:
- Filters defined in Move modules under governance control
- Configuration changes trigger reconfiguration events
- All validators automatically synchronize to new filter rules
- Maintain audit trail of filter changes on-chain

## Proof of Concept

**Scenario 1: State Divergence via Different Execution Filters**

```rust
// Setup: Create a test swarm with 4 validators
// - Validators 0, 1: execution_filter enabled, denies transactions from address ATTACKER_ADDR
// - Validators 2, 3: execution_filter disabled

use aptos_forge::{LocalSwarm, SwarmBuilder};
use aptos_config::config::BlockTransactionFilterConfig;
use aptos_transaction_filters::block_transaction_filter::BlockTransactionFilter;

#[tokio::test]
async fn test_state_divergence_via_filter_mismatch() {
    let attacker_addr = AccountAddress::from_hex_literal("0xBAD").unwrap();
    
    // Create swarm with mixed filter configurations
    let mut swarm = SwarmBuilder::new_local(4)
        .with_aptos()
        .with_init_config(Arc::new(move |idx, config, _| {
            if idx < 2 {
                // Validators 0, 1: Enable filter to deny attacker
                let filter = BlockTransactionFilter::empty()
                    .add_sender_filter(false, attacker_addr);
                config.transaction_filters.execution_filter =
                    BlockTransactionFilterConfig::new(true, filter);
            }
            // Validators 2, 3: Keep filter disabled (default)
        }))
        .build()
        .await;

    // Attacker submits transaction
    let attacker_txn = create_transaction_from_address(attacker_addr, &mut swarm).await;
    
    // Transaction gets included in a block and committed
    let result = swarm.aptos_public_info().client()
        .submit_and_wait(&attacker_txn).await;

    // Check state roots across validators
    let state_roots: Vec<_> = swarm.validators()
        .map(|v| v.latest_state_root())
        .collect();

    // EXPECTED: State divergence detected
    // Validators 0, 1 filtered the transaction (one state root)
    // Validators 2, 3 executed the transaction (different state root)
    assert!(state_roots[0] == state_roots[1]);
    assert!(state_roots[2] == state_roots[3]);
    assert!(state_roots[0] != state_roots[2]); // STATE DIVERGENCE!
}
```

**Scenario 2: Resource Waste via Certified but Filtered Batches**

```rust
#[tokio::test]
async fn test_certified_batch_filtered_at_execution() {
    let denied_addr = AccountAddress::from_hex_literal("0xBAD").unwrap();
    
    // All validators have execution_filter enabled but quorum_store_filter disabled
    let mut swarm = SwarmBuilder::new_local(4)
        .with_aptos()
        .with_init_config(Arc::new(move |_, config, _| {
            let filter = BlockTransactionFilter::empty()
                .add_sender_filter(false, denied_addr);
            config.transaction_filters.execution_filter =
                BlockTransactionFilterConfig::new(true, filter);
            // quorum_store_filter remains disabled (default)
        }))
        .build()
        .await;

    // Submit transaction that should be denied
    let denied_txn = create_transaction_from_address(denied_addr, &mut swarm).await;
    
    // Transaction gets into a batch and batch gets certified (ProofOfStore created)
    // This can be verified by checking quorum store metrics
    let batch_certified_count = swarm.validators().next().unwrap()
        .get_metric("aptos_quorum_store_batch_certified_count");
    
    // Transaction is submitted to mempool and batched
    swarm.aptos_public_info().client().submit(&denied_txn).await.unwrap();
    
    // Wait for batch certification
    tokio::time::sleep(Duration::from_secs(2)).await;
    
    let new_batch_count = swarm.validators().next().unwrap()
        .get_metric("aptos_quorum_store_batch_certified_count");
    
    // EXPECTED: Batch was certified (wasted resources)
    assert!(new_batch_count > batch_certified_count);
    
    // But transaction was never executed (filtered)
    let result = swarm.aptos_public_info().client()
        .wait_for_transaction(&denied_txn).await;
    assert!(result.is_err()); // Transaction expired, never executed
}
```

## Notes

This vulnerability has two critical manifestations:

1. **Consensus Safety Violation** (Critical): If validators have different `execution_filter` configurations, they will execute different transaction sets and compute different state roots, breaking consensus safety. This requires a hard fork to resolve.

2. **Resource Exhaustion** (High): Even if all validators have the same `execution_filter`, disabling `quorum_store_filter` while keeping `execution_filter` enabled allows malicious batches to be certified and included in blocks, only to be filtered during execution, wasting network resources.

The root cause is that filter configurations are not consensus-agreed and exist only in local `NodeConfig`. The system assumes all validators will have identical configurations, but provides no enforcement mechanism. This violates the fundamental principle that consensus execution must be deterministic across all validators.

### Citations

**File:** consensus/src/quorum_store/batch_coordinator.rs (L173-213)
```rust
    pub(crate) async fn handle_batches_msg(
        &mut self,
        author: PeerId,
        batches: Vec<Batch<BatchInfoExt>>,
    ) {
        if let Err(e) = self.ensure_max_limits(&batches) {
            error!("Batch from {}: {}", author, e);
            counters::RECEIVED_BATCH_MAX_LIMIT_FAILED.inc();
            return;
        }

        let Some(batch) = batches.first() else {
            error!("Empty batch received from {}", author.short_str().as_str());
            return;
        };

        // Filter the transactions in the batches. If any transaction is rejected,
        // the message will be dropped, and all batches will be rejected.
        if self.transaction_filter_config.is_enabled() {
            let transaction_filter = &self.transaction_filter_config.batch_transaction_filter();
            for batch in batches.iter() {
                for transaction in batch.txns() {
                    if !transaction_filter.allows_transaction(
                        batch.batch_info().batch_id(),
                        batch.author(),
                        batch.digest(),
                        transaction,
                    ) {
                        error!(
                            "Transaction {}, in batch {}, from {}, was rejected by the filter. Dropping {} batches!",
                            transaction.committed_hash(),
                            batch.batch_info().batch_id(),
                            author.short_str().as_str(),
                            batches.len()
                        );
                        counters::RECEIVED_BATCH_REJECTED_BY_FILTER.inc();
                        return;
                    }
                }
            }
        }
```

**File:** consensus/src/round_manager.rs (L1204-1214)
```rust
        if let Err(error) = self
            .block_store
            .check_denied_inline_transactions(&proposal, &self.block_txn_filter_config)
        {
            counters::REJECTED_PROPOSAL_DENY_TXN_COUNT.inc();
            bail!(
                "[RoundManager] Proposal for block {} contains denied inline transactions: {}. Dropping proposal!",
                proposal.id(),
                error
            );
        }
```

**File:** consensus/src/block_preparer.rs (L91-98)
```rust
            let filtered_txns = filter_block_transactions(
                txn_filter_config,
                block_id,
                block_author,
                block_epoch,
                block_timestamp_usecs,
                txns,
            );
```

**File:** consensus/src/block_preparer.rs (L123-146)
```rust
fn filter_block_transactions(
    txn_filter_config: Arc<BlockTransactionFilterConfig>,
    block_id: HashValue,
    block_author: Option<AccountAddress>,
    block_epoch: u64,
    block_timestamp_usecs: u64,
    txns: Vec<SignedTransaction>,
) -> Vec<SignedTransaction> {
    // If the transaction filter is disabled, return early
    if !txn_filter_config.is_enabled() {
        return txns;
    }

    // Otherwise, filter the transactions
    txn_filter_config
        .block_transaction_filter()
        .filter_block_transactions(
            block_id,
            block_author,
            block_epoch,
            block_timestamp_usecs,
            txns,
        )
}
```

**File:** consensus/src/epoch_manager.rs (L211-213)
```rust
        let consensus_txn_filter_config = node_config.transaction_filters.consensus_filter.clone();
        let quorum_store_txn_filter_config =
            node_config.transaction_filters.quorum_store_filter.clone();
```

**File:** consensus/src/state_computer.rs (L104-109)
```rust
        let block_preparer = Arc::new(BlockPreparer::new(
            payload_manager.clone(),
            self.txn_filter_config.clone(),
            transaction_deduper.clone(),
            transaction_shuffler.clone(),
        ));
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L568-599)
```rust
fn get_inline_transactions(block: &Block) -> Vec<SignedTransaction> {
    // If the block has no payload, return an empty vector
    let Some(payload) = block.payload() else {
        return vec![];
    };

    // Fetch the inline transactions from the payload
    match payload {
        Payload::QuorumStoreInlineHybrid(inline_batches, ..) => {
            // Flatten the inline batches and return the transactions
            inline_batches
                .iter()
                .flat_map(|(_batch_info, txns)| txns.clone())
                .collect()
        },
        Payload::QuorumStoreInlineHybridV2(inline_batches, ..) => {
            // Flatten the inline batches and return the transactions
            inline_batches
                .iter()
                .flat_map(|(_batch_info, txns)| txns.clone())
                .collect()
        },
        Payload::OptQuorumStore(OptQuorumStorePayload::V1(p)) => p.inline_batches().transactions(),
        Payload::OptQuorumStore(OptQuorumStorePayload::V2(_p)) => {
            error!("OptQSPayload V2 is not expected");
            Vec::new()
        },
        _ => {
            vec![] // Other payload types do not have inline transactions
        },
    }
}
```

**File:** config/src/config/transaction_filters_config.rs (L46-53)
```rust
impl Default for TransactionFilterConfig {
    fn default() -> Self {
        Self {
            filter_enabled: false,                          // Disable the filter
            transaction_filter: TransactionFilter::empty(), // Use an empty filter
        }
    }
}
```

**File:** config/src/config/transaction_filters_config.rs (L81-88)
```rust
impl Default for BatchTransactionFilterConfig {
    fn default() -> Self {
        Self {
            filter_enabled: false,                                     // Disable the filter
            batch_transaction_filter: BatchTransactionFilter::empty(), // Use an empty filter
        }
    }
}
```
