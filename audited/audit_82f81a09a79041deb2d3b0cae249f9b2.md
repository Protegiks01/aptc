# Audit Report

## Title
Response Amplification Attack via Type Confusion in Peer Monitoring Service

## Summary
A malicious peer monitoring service server can exploit type confusion to cause resource exhaustion on client nodes. By responding to small LatencyPing requests (8 bytes) with large NetworkInformationResponse messages (megabytes), the attacker forces clients to deserialize and process massive responses before type validation occurs, creating an amplification factor of 100,000x or more.

## Finding Description

The peer monitoring service protocol allows any response variant (`LatencyPingResponse`, `NetworkInformationResponse`, `NodeInformationResponse`, `ServerProtocolVersionResponse`) to be returned for any request type. The vulnerability arises from the order of operations in the RPC handling:

1. **Network Layer Deserialization First**: When a client sends a LatencyPing request, the network layer receives the response bytes and immediately deserializes them into a `PeerMonitoringServiceResponse` enum, regardless of the expected type. [1](#0-0) 

2. **Application Layer Type Validation Second**: Only after full deserialization does the application layer check if the response variant matches the request type. [2](#0-1) 

3. **No Size Limits on Individual Messages**: The BCS deserialization uses a recursion depth limit (64) but no byte size limit for peer monitoring service messages. [3](#0-2) 

**Attack Scenario:**

A malicious peer runs a peer monitoring service server. When honest clients connect and send periodic LatencyPing requests (containing only a u64 counter, ~8 bytes), the malicious server responds with NetworkInformationResponse containing a fabricated list of 100,000 connected peers. The test infrastructure explicitly supports creating such large responses: [4](#0-3) 

Each `ConnectionMetadata` entry contains a `NetworkAddress` (variable size, often 100+ bytes), `PeerId` (32 bytes), and `PeerRole` (small enum). With 100,000 entries, the response size can reach 5-10 MB. The client must:

1. Receive the entire 5-10 MB response over the network
2. Allocate memory for the full response
3. Deserialize all 100,000 peer entries using CPU-intensive BCS decoding
4. Only then discover the response type is wrong and discard it

The response is wrapped in the general `PeerMonitoringServiceMessage` envelope: [5](#0-4) 

This breaks the **Resource Limits** invariant: small requests should not trigger disproportionate resource consumption. The attack can be repeated continuously since latency pings occur every few seconds by default, causing sustained resource exhaustion.

## Impact Explanation

**Medium Severity** - This vulnerability causes resource exhaustion without directly compromising consensus, funds, or data integrity:

- **CPU Exhaustion**: BCS deserialization of megabyte-sized responses is CPU-intensive, especially repeated continuously
- **Memory Exhaustion**: Each large response requires allocating memory for the full structure before validation
- **Bandwidth Exhaustion**: 5-10 MB responses for every 8-byte request drains network bandwidth
- **Node Degradation**: Affected nodes experience slowdowns, potentially impacting block production and network participation

The impact aligns with Medium severity criteria: "Validator node slowdowns" and resource exhaustion requiring manual intervention. While not directly causing fund loss or consensus violations, sustained resource exhaustion can degrade network health and validator performance.

## Likelihood Explanation

**High Likelihood** - This attack is easily exploitable:

1. **Low Attacker Requirements**: Any node can run a malicious peer monitoring service server
2. **No Special Access**: No validator credentials or special network position required
3. **Simple Exploitation**: Just respond with wrong message types - no complex timing or race conditions
4. **Continuous Attack Surface**: Clients periodically send LatencyPing requests, providing repeated exploitation opportunities
5. **No Detection Difficulty**: The malicious server appears to be responding (albeit with wrong types), making detection harder than a silent non-responsive server

The test infrastructure shows awareness of wrong message types and large messages as separate concerns, but not their combination: [6](#0-5) 

## Recommendation

Implement **early type validation** before deserialization by adding request-response pairing metadata:

1. **Protocol-Level Fix**: Modify `PeerMonitoringServiceMessage` to include expected response type information, allowing the network layer to validate responses before deserialization:

```rust
// Add to peer-monitoring-service/types/src/lib.rs
pub enum PeerMonitoringServiceMessage {
    Request(PeerMonitoringServiceRequest),
    Response {
        expected_type: ResponseType,
        response: Result<PeerMonitoringServiceResponse>,
    },
}

pub enum ResponseType {
    LatencyPing,
    NetworkInformation,
    NodeInformation,
    ServerProtocolVersion,
}
```

2. **Size Limit Enforcement**: Add per-message size limits for peer monitoring service:

```rust
// In network layer before deserialization
const MAX_LATENCY_PING_RESPONSE_SIZE: usize = 1024; // 1 KB
const MAX_NETWORK_INFO_RESPONSE_SIZE: usize = 100_000; // 100 KB

if request_type == LatencyPing && response_size > MAX_LATENCY_PING_RESPONSE_SIZE {
    return Err(RpcError::ResponseTooLarge);
}
```

3. **Network Layer Validation**: Validate response type matches request type at the network layer before deserializing the full payload.

## Proof of Concept

```rust
// Add to peer-monitoring-service/client/src/tests/single_peer.rs

#[tokio::test]
async fn test_response_amplification_attack() {
    // Setup client and malicious server
    let (mut mock_server, client, peers_and_metadata, _time) = MockMonitoringServer::new(vec![NetworkId::Validator]);
    let peer_network_id = PeerNetworkId::random_validator();
    
    // Client sends small LatencyPing request (8 bytes)
    let latency_request = PeerMonitoringServiceRequest::LatencyPing(LatencyPingRequest {
        ping_counter: 0,
    });
    
    // Spawn client request
    let send_request = async {
        let result = send_request_to_peer(
            client,
            &peer_network_id,
            1,
            latency_request,
            5000,
        ).await;
        
        // Verify client rejects wrong response type
        assert!(result.is_err());
    };
    
    // Malicious server responds with large NetworkInformationResponse (megabytes)
    let respond_with_attack = async {
        let network_request = mock_server.next_request(&NetworkId::Validator).await.unwrap();
        
        // Verify this was a LatencyPing request
        match network_request.peer_monitoring_service_request {
            PeerMonitoringServiceRequest::LatencyPing(_) => {},
            _ => panic!("Expected LatencyPing request"),
        }
        
        // Respond with wrong type: large NetworkInformationResponse
        let malicious_response = PeerMonitoringServiceResponse::NetworkInformation(
            create_network_info_response(&create_large_connected_peers_map(), 0)
        );
        
        // Measure response size
        let response_bytes = bcs::to_bytes(&malicious_response).unwrap();
        println!("Response size: {} bytes", response_bytes.len());
        assert!(response_bytes.len() > 1_000_000); // Verify > 1 MB
        
        network_request.response_sender.send(Ok(malicious_response));
    };
    
    tokio::join!(send_request, respond_with_attack);
    
    // The attack succeeds: client deserializes full 1+ MB response before rejecting it
    // Repeat this continuously to exhaust client resources
}
```

This PoC demonstrates that:
1. Small LatencyPing requests can trigger large NetworkInformationResponse processing
2. Full deserialization occurs before type validation
3. The amplification factor exceeds 100,000x (8 bytes â†’ 1+ MB)
4. Continuous exploitation is feasible via repeated latency ping intervals

### Citations

**File:** network/framework/src/protocols/network/mod.rs (L455-471)
```rust
    pub async fn send_rpc_raw(
        &self,
        recipient: PeerId,
        protocol: ProtocolId,
        req_msg: Bytes,
        timeout: Duration,
    ) -> Result<TMessage, RpcError> {
        // Send the request and wait for the response
        let res_data = self
            .peer_mgr_reqs_tx
            .send_rpc(recipient, protocol, req_msg, timeout)
            .await?;

        // Deserialize the response using a blocking task
        let res_msg = tokio::task::spawn_blocking(move || protocol.from_bytes(&res_data)).await??;
        Ok(res_msg)
    }
```

**File:** peer-monitoring-service/client/src/peer_states/latency_info.rs (L163-176)
```rust
        // Verify the response type is valid
        let latency_ping_response = match monitoring_service_response {
            PeerMonitoringServiceResponse::LatencyPing(latency_ping_response) => {
                latency_ping_response
            },
            _ => {
                warn!(LogSchema::new(LogEntry::LatencyPing)
                    .event(LogEvent::ResponseError)
                    .peer(peer_network_id)
                    .message("An unexpected response was received instead of a latency ping!"));
                self.handle_request_failure(peer_network_id);
                return;
            },
        };
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L156-172)
```rust
    fn encoding(self) -> Encoding {
        match self {
            ProtocolId::ConsensusDirectSendJson | ProtocolId::ConsensusRpcJson => Encoding::Json,
            ProtocolId::ConsensusDirectSendCompressed | ProtocolId::ConsensusRpcCompressed => {
                Encoding::CompressedBcs(RECURSION_LIMIT)
            },
            ProtocolId::ConsensusObserver => Encoding::CompressedBcs(RECURSION_LIMIT),
            ProtocolId::DKGDirectSendCompressed | ProtocolId::DKGRpcCompressed => {
                Encoding::CompressedBcs(RECURSION_LIMIT)
            },
            ProtocolId::JWKConsensusDirectSendCompressed
            | ProtocolId::JWKConsensusRpcCompressed => Encoding::CompressedBcs(RECURSION_LIMIT),
            ProtocolId::MempoolDirectSend => Encoding::CompressedBcs(USER_INPUT_RECURSION_LIMIT),
            ProtocolId::MempoolRpc => Encoding::Bcs(USER_INPUT_RECURSION_LIMIT),
            _ => Encoding::Bcs(RECURSION_LIMIT),
        }
    }
```

**File:** peer-monitoring-service/client/src/tests/utils.rs (L109-118)
```rust
pub fn create_large_connected_peers_map() -> BTreeMap<PeerNetworkId, ConnectionMetadata> {
    let mut peers = BTreeMap::new();
    for _ in 0..100_000 {
        peers.insert(
            PeerNetworkId::random(),
            ConnectionMetadata::new(NetworkAddress::mock(), PeerId::random(), PeerRole::Unknown),
        );
    }
    peers
}
```

**File:** peer-monitoring-service/client/src/tests/utils.rs (L692-703)
```rust
                    })
                } else if respond_with_invalid_message {
                    // Respond with the wrong message type
                    PeerMonitoringServiceResponse::ServerProtocolVersion(
                        ServerProtocolVersionResponse { version: 999 },
                    )
                } else {
                    // Send a valid response
                    PeerMonitoringServiceResponse::LatencyPing(LatencyPingResponse {
                        ping_counter: latency_ping.ping_counter,
                    })
                }
```

**File:** peer-monitoring-service/types/src/lib.rs (L34-41)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
#[allow(clippy::large_enum_variant)]
pub enum PeerMonitoringServiceMessage {
    /// A request to the peer monitoring service
    Request(PeerMonitoringServiceRequest),
    /// A response from the peer monitoring service
    Response(Result<PeerMonitoringServiceResponse>),
}
```
