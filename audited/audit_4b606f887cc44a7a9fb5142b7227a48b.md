# Audit Report

## Title
Incomplete ConfigSanitizer Validation Allows Mainnet Validators to Expose Sensitive Network Information

## Summary
The `ConfigSanitizer` implementation for `InspectionServiceConfig` only validates that mainnet validators do not expose configuration data (`expose_configuration`), but fails to check the other three sensitive information endpoints (`expose_identity_information`, `expose_peer_information`, `expose_system_information`). This allows mainnet validators to inadvertently run with these endpoints enabled, exposing validator network peer IDs, complete validator set topology, and connection metadata to potential attackers. [1](#0-0) 

## Finding Description
The `InspectionServiceConfig::sanitize()` function contains a security validation gap. While it correctly prevents mainnet validators from exposing their configuration, it does not validate the other three information exposure flags. [2](#0-1) 

The default values for `InspectionServiceConfig` set dangerous defaults for mainnet: [3](#0-2) 

When `expose_identity_information` is enabled, the endpoint exposes validator network peer IDs and fullnode network peer IDs: [4](#0-3) [5](#0-4) 

More critically, when `expose_peer_information` is enabled, the endpoint exposes the **entire trusted validator set** along with connection metadata: [6](#0-5) [7](#0-6) 

The `ConfigOptimizer` only auto-enables these endpoints for non-mainnet chains, but does not disable them for mainnet: [8](#0-7) 

**Attack Path:**
1. Mainnet validator operator deploys with default configuration or copies from testnet
2. `expose_identity_information` and `expose_peer_information` remain at default value `true`
3. No sanitizer error/warning occurs during node startup
4. Attacker queries `http://validator-ip:9101/identity_information` and `/peer_information`
5. Attacker obtains validator network peer IDs and complete validator set topology
6. Attacker uses this information for targeted DDoS attacks or network reconnaissance

## Impact Explanation
This vulnerability meets **High Severity** criteria per Aptos bug bounty program:

- **Validator node slowdowns**: Exposed peer IDs and network topology enable targeted DDoS attacks on specific validators, potentially degrading network performance
- **Significant protocol violations**: Operational security is compromised by exposing internal network structure

The exposed information includes:
- Validator network peer IDs (used for network authentication)
- Complete trusted validator set with peer information
- Connection states and metadata
- Internal client states for state synchronization
- Network topology mapping

This information enables sophisticated attacks:
- Targeted DDoS against specific validators
- Eclipse attacks by understanding network structure
- Infrastructure reconnaissance for physical attacks
- Correlation with on-chain validator addresses to identify operators

## Likelihood Explanation
**Likelihood: HIGH**

Multiple factors make this highly likely to occur:

1. **Default values are vulnerable**: `expose_identity_information` and `expose_peer_information` default to `true`
2. **No validation prevents it**: ConfigSanitizer does not check these fields for mainnet validators
3. **Sample configs omit inspection_service**: Reference validator configs do not explicitly configure the inspection service section, relying on defaults [9](#0-8) 

4. **Inconsistent security model**: Operators see that `expose_configuration` is validated but may assume other fields are similarly protected
5. **Silent failure**: No warnings or errors alert operators to this misconfiguration

## Recommendation
Extend the `ConfigSanitizer` implementation to validate all information exposure flags for mainnet validators:

```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Verify that mainnet validators do not expose sensitive information
        if let Some(chain_id) = chain_id {
            if node_type.is_validator() && chain_id.is_mainnet() {
                if inspection_service_config.expose_configuration {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name.clone(),
                        "Mainnet validators should not expose the node configuration!".to_string(),
                    ));
                }
                if inspection_service_config.expose_identity_information {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name.clone(),
                        "Mainnet validators should not expose identity information!".to_string(),
                    ));
                }
                if inspection_service_config.expose_peer_information {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name.clone(),
                        "Mainnet validators should not expose peer information!".to_string(),
                    ));
                }
                if inspection_service_config.expose_system_information {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Mainnet validators should not expose system information!".to_string(),
                    ));
                }
            }
        }

        Ok(())
    }
}
```

Additionally, update default values to be secure by default for all deployments:

```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: false,  // Changed to false
            expose_peer_information: false,      // Changed to false
            expose_system_information: false,    // Changed to false
        }
    }
}
```

The `ConfigOptimizer` already auto-enables these for non-mainnet chains, so this change would not impact testnet/devnet operations.

## Proof of Concept

**Step 1: Deploy mainnet validator with default configuration**

Create `mainnet-validator.yaml`:
```yaml
base:
  role: "validator"
  data_dir: "/opt/aptos/data"

validator_network:
  discovery_method: "onchain"
  mutual_authentication: true
  identity:
    type: "from_file"
    path: /opt/aptos/genesis/validator-identity.yaml

# Note: inspection_service section omitted, uses defaults
```

**Step 2: Start validator node**
```bash
aptos-node -f mainnet-validator.yaml
```

**Step 3: Query exposed endpoints (from attacker machine)**
```bash
# Get validator network peer ID
curl http://validator-ip:9101/identity_information

# Expected output:
# Identity Information:
#   - Validator network (Validator), peer ID: ca3579457555c80fc7bb39964eb298c414fd60f81a2f8eedb0244ec07a26e575
#   - Fullnode network (Private(vfn)), peer ID: 16e2f69f89e4a27d84df6d45fa7c68b26dd8e47c9b6f2a991b8647ce3e28dee0

# Get complete validator set and network topology
curl http://validator-ip:9101/peer_information

# Expected output includes:
# Trusted peers (validator set & seeds):
#   - Network: Validator
#     - Peer: AccountAddress(...), peer information: PeerInfo { ... }
#     - Peer: AccountAddress(...), peer information: PeerInfo { ... }
#     [... complete validator set exposed ...]
```

**Step 4: Verify sanitizer does not prevent this**

```rust
#[test]
fn test_mainnet_validator_exposes_identity_without_error() {
    // Create a mainnet validator config with identity information exposed
    let node_config = NodeConfig {
        inspection_service: InspectionServiceConfig {
            expose_identity_information: true,  // PROBLEM: No validation
            expose_peer_information: true,      // PROBLEM: No validation
            ..Default::default()
        },
        ..Default::default()
    };

    // This should fail but currently passes
    let result = InspectionServiceConfig::sanitize(
        &node_config,
        NodeType::Validator,
        Some(ChainId::mainnet()),
    );
    
    // BUG: This passes when it should fail
    assert!(result.is_ok());  // Demonstrates the vulnerability
}
```

## Notes

This vulnerability represents a **configuration validation gap** rather than a logic bug in the inspection service itself. The endpoints correctly check their respective configuration flags before exposing information. However, the security model assumes that the `ConfigSanitizer` will prevent dangerous configurations on mainnet validators, which it fails to do for three of the four sensitive endpoints.

The issue is particularly concerning because:
1. The codebase demonstrates security awareness by validating `expose_configuration`
2. This creates a false sense of security that all sensitive endpoints are validated
3. Default values lean toward convenience (enabled) rather than security (disabled)
4. Reference validator configurations do not explicitly disable these endpoints

While the exposed information does not directly compromise consensus safety or cause fund loss, it significantly undermines operational security and enables attack vectors that could lead to validator degradation or network instability.

### Citations

**File:** config/src/config/inspection_service_config.rs (L26-36)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
```

**File:** config/src/config/inspection_service_config.rs (L45-69)
```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
        }

        Ok(())
    }
}
```

**File:** config/src/config/inspection_service_config.rs (L82-105)
```rust
        let mut modified_config = false;
        if let Some(chain_id) = chain_id {
            if !chain_id.is_mainnet() {
                if local_inspection_config_yaml["expose_configuration"].is_null() {
                    inspection_service_config.expose_configuration = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_identity_information"].is_null() {
                    inspection_service_config.expose_identity_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_peer_information"].is_null() {
                    inspection_service_config.expose_peer_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_system_information"].is_null() {
                    inspection_service_config.expose_system_information = true;
                    modified_config = true;
                }
            }
        }
```

**File:** crates/aptos-inspection-service/src/server/identity_information.rs (L13-26)
```rust
pub fn handle_identity_information_request(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    // Only return identity information if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_identity_information {
        let identity_information = get_identity_information(node_config);
        (StatusCode::OK, Body::from(identity_information))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(IDENTITY_INFO_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}
```

**File:** crates/aptos-inspection-service/src/server/identity_information.rs (L34-49)
```rust
    if let Some(validator_network) = &node_config.validator_network {
        identity_information.push(format!(
            "\t- Validator network ({}), peer ID: {}",
            validator_network.network_id,
            validator_network.peer_id()
        ));
    }

    // For each fullnode network, fetch the identity information
    for fullnode_network in &node_config.full_node_networks {
        identity_information.push(format!(
            "\t- Fullnode network ({}), peer ID: {}",
            fullnode_network.network_id,
            fullnode_network.peer_id()
        ));
    }
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L21-37)
```rust
pub fn handle_peer_information_request(
    node_config: &NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> (StatusCode, Body, String) {
    // Only return peer information if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_peer_information {
        let peer_information = get_peer_information(aptos_data_client, peers_and_metadata);
        (StatusCode::OK, Body::from(peer_information))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(PEER_INFO_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L273-300)
```rust
/// Displays the entire set of trusted peers
fn display_trusted_peers(
    peer_information_output: &mut Vec<String>,
    registered_networks: Vec<NetworkId>,
    peers_and_metadata: &PeersAndMetadata,
) {
    peer_information_output.push("Trusted peers (validator set & seeds):".into());

    // Fetch and display the trusted peers for each network
    for network in registered_networks {
        peer_information_output.push(format!("\t- Network: {}", network));
        if let Ok(trusted_peers) = peers_and_metadata.get_trusted_peers(&network) {
            // Sort the peers before displaying them
            let mut sorted_trusted_peers = BTreeMap::new();
            for (peer_id, peer_info) in trusted_peers {
                sorted_trusted_peers.insert(peer_id, peer_info);
            }

            // Display the trusted peers
            for (peer_id, peer_info) in sorted_trusted_peers {
                peer_information_output.push(format!(
                    "\t\t- Peer: {:?}, peer information: {:?}",
                    peer_id, peer_info
                ));
            }
        }
    }
}
```

**File:** docker/compose/aptos-node/validator.yaml (L1-46)
```yaml
base:
  role: "validator"
  data_dir: "/opt/aptos/data"
  waypoint:
    from_file: "/opt/aptos/genesis/waypoint.txt"

consensus:
  safety_rules:
    service:
      type: "local"
    backend:
      type: "on_disk_storage"
      path: secure-data.json
      namespace: ~
    initial_safety_rules_config:
      from_file:
        waypoint:
          from_file: /opt/aptos/genesis/waypoint.txt
        identity_blob_path: /opt/aptos/genesis/validator-identity.yaml

execution:
  genesis_file_location: "/opt/aptos/genesis/genesis.blob"

storage:
  rocksdb_configs:
    enable_storage_sharding: true

validator_network:
  discovery_method: "onchain"
  mutual_authentication: true
  identity:
    type: "from_file"
    path: /opt/aptos/genesis/validator-identity.yaml

full_node_networks:
- network_id:
    private: "vfn"
  listen_address: "/ip4/0.0.0.0/tcp/6181"
  identity:
    type: "from_config"
    key: "b0f405a3e75516763c43a2ae1d70423699f34cd68fa9f8c6bb2d67aa87d0af69"
    peer_id: "00000000000000000000000000000000d58bc7bb154b38039bc9096ce04e1237"

api:
  enabled: true
  address: "0.0.0.0:8080"
```
