# Audit Report

## Title
StateKey Size Underreporting Leads to Storage Fee Undercharging and Limit Bypass

## Summary
The `check_change_set()` function and gas/storage fee calculation logic use `StateKey::size()` instead of `StateKey::encoded().len()`, causing a systematic underreporting of actual storage consumption. This allows attackers to pay less gas than the storage they consume and bypass transaction size limits.

## Finding Description

The vulnerability exists in how Aptos Core measures StateKey sizes for validation and gas charging. There is a critical discrepancy between two methods:

1. **`StateKey::size()`** - Returns the raw data size without serialization overhead [1](#0-0) 

2. **`StateKey::encoded()`** - Returns the actual serialized bytes stored on-chain [2](#0-1) 

For an `AccessPath` StateKey, `size()` returns `address.len() + path.len()` (line 103), which is just the raw data. However, `encoded()` includes:
- 1 byte tag prefix
- BCS-serialized AccessPath with ULEB128 length prefixes for vectors

This discrepancy propagates through three critical code paths:

**1. Storage Limit Validation** - Uses `key.size()` to check against max limits: [3](#0-2) 

**2. IO Gas Charging** - For feature_version >= 3, uses `key.size()` instead of `key.encoded().len()`: [4](#0-3) 

**3. Storage Fee Charging** - Both V1 and V2 use `key.size()`: [5](#0-4) [6](#0-5) 

**Concrete Example:**

For an AccessPath with 32-byte address and 50-byte path:
- `key.size()` returns: 82 bytes
- `key.encoded().len()` returns: 1 (tag) + 32 (address) + 1 (ULEB128 prefix) + 50 (path) = 84 bytes
- **Discrepancy: 2 bytes per key**

The test suite even demonstrates this without recognizing the security implication: [7](#0-6) 

A StateKey of 3 raw bytes has `size() = 3` but `encoded().len() = 4` due to the tag byte.

## Impact Explanation

**HIGH Severity** - This qualifies as a "Significant protocol violation" under the bug bounty program because:

1. **Resource Limit Bypass**: The invariant "All operations must respect gas, storage, and computational limits" is violated. Attackers can bypass `max_bytes_per_write_op` and `max_bytes_all_write_ops_per_transaction` limits by at least 2 bytes per StateKey.

2. **Gas Undercharging**: Users systematically pay less gas than their actual storage consumption. For a transaction with 1000 write operations, this could result in 2000+ bytes of unpaid storage.

3. **Storage Bloat Attack**: Over time, this allows malicious actors to bloat state storage without paying the proper fees, potentially degrading network performance and increasing validator costs.

4. **Deterministic but Incorrect**: While all validators execute identically (maintaining consensus), they all apply the same incorrect pricing, making this a protocol-level economic exploit rather than a consensus break.

This does not reach Critical severity because it doesn't cause loss of funds, consensus breaks, or network unavailability, but it represents a significant economic security flaw.

## Likelihood Explanation

**HIGH Likelihood** - This vulnerability is:

- **Always active**: Every transaction with write operations on feature_version >= 3 networks is affected
- **No special privileges required**: Any user submitting normal transactions exploits this
- **Undetectable**: The undercharging happens transparently during normal operation
- **Cumulative impact**: The economic damage accumulates with every transaction across the network
- **Already occurring**: This is likely already being exploited unknowingly in production

The attack complexity is NONE - it happens automatically whenever users create transactions with StateKeys.

## Recommendation

Replace all uses of `key.size()` with `key.encoded().len()` in gas and storage calculations to accurately reflect on-chain storage consumption:

**In `change_set_configs.rs`:**
```rust
let write_op_size = len + (key.encoded().len() as u64);  // Changed from key.size()
```

**In `io_pricing.rs` (IoPricingV2, V3, V4):**
```rust
let key_size = NumBytes::new(key.encoded().len() as u64);  // Changed from key.size()
```

**In `space_pricing.rs`:**
```rust
let size = NumBytes::new(key.encoded().len() as u64) + NumBytes::new(value_size);  // Changed
```

This requires a gas schedule update to adjust the per-byte pricing since the base values were likely calibrated against the incorrect `size()` values.

## Proof of Concept

```rust
#[test]
fn test_state_key_size_discrepancy() {
    use aptos_types::state_store::state_key::StateKey;
    use aptos_types::account_address::AccountAddress;
    use move_core_types::language_storage::StructTag;
    
    // Create an AccessPath StateKey
    let address = AccountAddress::random();
    let struct_tag = StructTag {
        address: AccountAddress::ONE,
        module: "test".parse().unwrap(),
        name: "Resource".parse().unwrap(),
        type_args: vec![],
    };
    let key = StateKey::resource(&address, &struct_tag).unwrap();
    
    let reported_size = key.size();
    let actual_encoded_size = key.encoded().len();
    
    // Demonstrate the discrepancy
    assert!(actual_encoded_size > reported_size, 
        "Actual encoded size {} should be greater than reported size {}", 
        actual_encoded_size, reported_size);
    
    println!("Reported size (key.size()): {} bytes", reported_size);
    println!("Actual encoded size: {} bytes", actual_encoded_size);
    println!("Underreported by: {} bytes", actual_encoded_size - reported_size);
    
    // For 1000 such keys in a transaction
    let num_keys = 1000;
    let total_underreported = (actual_encoded_size - reported_size) * num_keys;
    println!("Total underreported for {} keys: {} bytes", num_keys, total_underreported);
}
```

This test will demonstrate that `key.size()` consistently underreports the actual storage consumption, confirming the vulnerability.

### Citations

**File:** types/src/state_store/state_key/mod.rs (L101-107)
```rust
    pub fn size(&self) -> usize {
        match self.inner() {
            StateKeyInner::AccessPath(access_path) => access_path.size(),
            StateKeyInner::TableItem { handle, key } => handle.size() + key.len(),
            StateKeyInner::Raw(bytes) => bytes.len(),
        }
    }
```

**File:** types/src/state_store/state_key/inner.rs (L63-83)
```rust
    pub(crate) fn encode(&self) -> anyhow::Result<Bytes> {
        let mut writer = BytesMut::new().writer();

        match self {
            StateKeyInner::AccessPath(access_path) => {
                writer.write_all(&[StateKeyTag::AccessPath as u8])?;
                bcs::serialize_into(&mut writer, access_path)?;
            },
            StateKeyInner::TableItem { handle, key } => {
                writer.write_all(&[StateKeyTag::TableItem as u8])?;
                bcs::serialize_into(&mut writer, &handle)?;
                writer.write_all(key)?;
            },
            StateKeyInner::Raw(raw_bytes) => {
                writer.write_all(&[StateKeyTag::Raw as u8])?;
                writer.write_all(raw_bytes)?;
            },
        };

        Ok(writer.into_inner().into())
    }
```

**File:** aptos-move/aptos-vm-types/src/storage/change_set_configs.rs (L101-113)
```rust
        let mut write_set_size = 0;
        for (key, op_size) in change_set.write_set_size_iter() {
            if let Some(len) = op_size.write_len() {
                let write_op_size = len + (key.size() as u64);
                if write_op_size > self.max_bytes_per_write_op {
                    return storage_write_limit_reached(None);
                }
                write_set_size += write_op_size;
            }
            if write_set_size > self.max_bytes_all_write_ops_per_transaction {
                return storage_write_limit_reached(None);
            }
        }
```

**File:** aptos-move/aptos-vm-types/src/storage/io_pricing.rs (L124-136)
```rust
    fn write_op_size(&self, key: &StateKey, value_size: u64) -> NumBytes {
        let value_size = NumBytes::new(value_size);

        if self.feature_version >= 3 {
            let key_size = NumBytes::new(key.size() as u64);
            (key_size + value_size)
                .checked_sub(self.free_write_bytes_quota)
                .unwrap_or(NumBytes::zero())
        } else {
            let key_size = NumBytes::new(key.encoded().len() as u64);
            key_size + value_size
        }
    }
```

**File:** aptos-move/aptos-vm-types/src/storage/space_pricing.rs (L107-115)
```rust
    fn discounted_write_op_size_for_v1(
        params: &TransactionGasParameters,
        key: &StateKey,
        value_size: u64,
    ) -> NumBytes {
        let size = NumBytes::new(key.size() as u64) + NumBytes::new(value_size);
        size.checked_sub(params.legacy_free_write_bytes_quota)
            .unwrap_or(NumBytes::zero())
    }
```

**File:** aptos-move/aptos-vm-types/src/storage/space_pricing.rs (L169-171)
```rust
        let key_size = op.key.size() as u64;
        let num_bytes = key_size + op.op_size.write_len().unwrap_or(0);
        let target_bytes_deposit: u64 = num_bytes * u64::from(params.storage_fee_per_state_byte);
```

**File:** aptos-move/aptos-vm-types/src/storage/space_pricing.rs (L266-268)
```rust
        let key = StateKey::raw(&[1, 2, 3]);
        assert_eq!(key.size(), 3); // to make sure our assumptions on the numbers in the assertions below are correct
        let ts = CurrentTimeMicroseconds { microseconds: 0 };
```
