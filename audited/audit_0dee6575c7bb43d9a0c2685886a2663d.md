# Audit Report

## Title
Out-of-Order Commit Notifications Cause Permanent Batch Memory Leak and Transaction Starvation

## Summary
The `BatchGenerator::start()` function skips entire `CommitNotification` processing when `latest_block_timestamp > block_timestamp`, preventing batch cleanup for out-of-order commits. During state synchronization or async pipeline execution, batches from older blocks never get removed from `batches_in_progress`, causing unbounded memory growth and permanent transaction starvation.

## Finding Description

The vulnerability exists in the commit notification handler at [1](#0-0) 

When a `CommitNotification` arrives with an older `block_timestamp` than previously processed, the entire notification is discarded via `continue`. This skips two critical cleanup operations:

1. **Committed batch removal** (lines 528-532): Batches that were included in the committed block are never removed from `batches_in_progress`
2. **Time-based expiration** (line 536): The `batch_expirations.expire(block_timestamp)` call never executes for that timestamp

**Root Cause: Expiry Time Mismatch**

Batch expiry times are set based on wall-clock time [2](#0-1) , with a 60-second gap for local batches and 500ms for remote batches [3](#0-2) .

However, batch expiration is triggered by blockchain timestamps via `expire(block_timestamp)` [4](#0-3) . During state synchronization, blockchain timestamps can lag significantly behind wall-clock time, creating a temporal gap where batches cannot expire.

**Attack Scenario:**

1. Node enters state sync, processing blocks from 5 minutes ago
2. Remote batch X arrives, added with `expiry_time = wall_clock_now + 500ms`
3. Block B2 at blockchain time `T2 = wall_clock_now - 5min` commits first
4. `latest_block_timestamp = T2`, `expire(T2)` called
5. Batch X has `expiry_time >> T2`, so it's not expired
6. Block B1 at blockchain time `T1 < T2` commits later (out-of-order)
7. Block B1 contains batch X in its batches list
8. `CommitNotification(T1, [batch_X, ...])` arrives
9. Check: `latest_block_timestamp > block_timestamp` (T2 > T1) â†’ **SKIP ALL PROCESSING**
10. Batch X never removed via committed path (line 529 skipped)
11. Batch X only removable when `blockchain_time >= expiry_time`
12. But blockchain time is 5 minutes behind and advancing slowly
13. Batch X remains in `batches_in_progress` for extended period

**State Sync Confirmation:**

During state sync, `notify_commit` is explicitly called with old timestamps [5](#0-4) , making this scenario inevitable during normal operations.

**Cascading Effects:**

- Batches stuck in `batches_in_progress` [6](#0-5) 
- Transactions stuck in `txns_in_progress_sorted` [7](#0-6) 
- These transactions excluded from mempool pulls [8](#0-7) 
- Transactions cannot be re-proposed until batches expire
- Memory grows unbounded during prolonged state sync

## Impact Explanation

**Severity: HIGH** per Aptos bug bounty criteria:

1. **Validator Node Slowdowns**: Unbounded growth of `batches_in_progress` HashMap and `txns_in_progress_sorted` BTreeMap causes memory exhaustion and performance degradation

2. **Transaction Starvation**: Legitimate transactions get stuck in expired batches and cannot be re-pulled from mempool, directly impacting consensus liveness

3. **Prolonged State Sync Impact**: During extended state sync periods (network partitions, node restarts), the temporal gap between wall-clock time and blockchain time can span hours, causing severe batch accumulation

4. **No Automatic Recovery**: Only three removal paths exist [9](#0-8) : committed (skipped), expired (blocked), and proof timeout (only for local batches). Remote batches have no timeout mechanism and rely entirely on expiration.

This constitutes a "significant protocol violation" causing validator node slowdowns, meeting High severity criteria.

## Likelihood Explanation

**Likelihood: HIGH**

- **Triggering Condition**: Out-of-order commit notifications during state sync
- **Frequency**: State sync is a normal operation that occurs during:
  - Node startup/restart
  - Network partitions
  - Fast catchup
  - Falling behind consensus
- **Comment Acknowledgment**: The code comment explicitly acknowledges this race condition [10](#0-9) : "Block timestamp is updated asynchronously, so it may race when it enters state sync"
- **No Mitigation**: The current implementation provides no safeguards against batch accumulation
- **Deterministic**: Given state sync and out-of-order commits, the bug triggers reliably

## Recommendation

**Fix: Decouple committed batch removal from timestamp ordering check**

```rust
// At lines 517-553, modify the handler:
BatchGeneratorCommand::CommitNotification(block_timestamp, batches) => {
    trace!(
        "QS: got clean request from execution, block timestamp {}",
        block_timestamp
    );
    
    // ALWAYS remove committed batches, regardless of timestamp ordering
    for (author, batch_id) in batches.iter().map(|b| (b.author(), b.batch_id())) {
        if self.remove_batch_in_progress(author, batch_id) {
            counters::BATCH_IN_PROGRESS_COMMITTED.inc();
        }
    }
    
    // Only update timestamp and perform expiration if monotonically increasing
    if self.latest_block_timestamp > block_timestamp {
        // Out-of-order commit detected, skip timestamp update and expiration
        // but batches were already removed above
        continue;
    }
    self.latest_block_timestamp = block_timestamp;

    // Expiration cleanup continues as before...
    for (author, batch_id) in self.batch_expirations.expire(block_timestamp) {
        // ... rest of expiration logic unchanged
    }
},
```

**Key Changes:**
1. Move batch removal **before** the timestamp ordering check
2. Always process committed batches, even for out-of-order notifications
3. Only skip timestamp update and expiration logic for old notifications
4. Maintain the same expiration semantics for in-order commits

**Alternative: Use Monotonic Timestamp with Fallback**
Track maximum timestamp seen separately from expiration timestamp to ensure batches from out-of-order commits are eventually expired.

## Proof of Concept

```rust
// Reproduction test for batch_generator_test.rs
#[tokio::test]
async fn test_out_of_order_commit_batch_leak() {
    let (mut batch_generator, mut cmd_rx, mut network_rx) = create_batch_generator();
    
    // Simulate batch creation at current wall-clock time
    let wall_clock_now = aptos_infallible::duration_since_epoch().as_micros() as u64;
    let expiry_time = wall_clock_now + 500_000; // 500ms from now
    
    // Simulate blockchain 5 minutes behind
    let blockchain_lag = 300_000_000; // 5 minutes in microseconds
    let old_blockchain_time = wall_clock_now - blockchain_lag;
    
    // Create remote batch
    let batch_id = BatchId::new(1);
    let author = PeerId::random();
    let txns = vec![test_transaction()];
    
    // Simulate receiving remote batch
    batch_generator.handle_remote_batch(author, batch_id, txns.clone());
    assert_eq!(batch_generator.batches_in_progress.len(), 1);
    
    // Simulate newer block commit first (T2 > T1)
    let t2 = old_blockchain_time + 1000;
    let commit_notification_t2 = BatchGeneratorCommand::CommitNotification(t2, vec![]);
    // Process via command - this updates latest_block_timestamp to T2
    
    // Simulate older block commit with our batch (T1 < T2)
    let t1 = old_blockchain_time + 500;
    let batch_info = create_batch_info(author, batch_id);
    let commit_notification_t1 = BatchGeneratorCommand::CommitNotification(
        t1, 
        vec![batch_info]
    );
    // This notification gets SKIPPED due to T2 > T1
    
    // Verify batch still in batches_in_progress (BUG!)
    assert_eq!(
        batch_generator.batches_in_progress.len(), 
        1,
        "Batch should have been removed but wasn't due to out-of-order commit"
    );
    
    // Verify batch won't be expired until blockchain catches up
    // (expiry_time is ~5 minutes ahead of current blockchain time)
    assert!(expiry_time > t2);
    
    // This demonstrates the memory leak - batch remains stuck
    // until blockchain timestamp advances ~5 minutes to reach expiry_time
}
```

**Notes:**

The vulnerability represents a fundamental flaw in the timestamp-based gating of critical cleanup logic. The defensive check intended to handle asynchronous state sync races creates a worse problem by preventing necessary resource cleanup. This breaks the **Resource Limits** invariant (item 9) and degrades consensus **liveness** over time.

### Citations

**File:** consensus/src/quorum_store/batch_generator.rs (L68-68)
```rust
    batches_in_progress: HashMap<(PeerId, BatchId), BatchInProgress>,
```

**File:** consensus/src/quorum_store/batch_generator.rs (L69-69)
```rust
    txns_in_progress_sorted: BTreeMap<TransactionSummary, TransactionInProgress>,
```

**File:** consensus/src/quorum_store/batch_generator.rs (L314-330)
```rust
    fn remove_batch_in_progress(&mut self, author: PeerId, batch_id: BatchId) -> bool {
        let removed = self.batches_in_progress.remove(&(author, batch_id));
        match removed {
            Some(batch_in_progress) => {
                for txn in batch_in_progress.txns {
                    if let Entry::Occupied(mut o) = self.txns_in_progress_sorted.entry(txn) {
                        let info = o.get_mut();
                        if info.decrement() == 0 {
                            o.remove();
                        }
                    }
                }
                true
            },
            None => false,
        }
    }
```

**File:** consensus/src/quorum_store/batch_generator.rs (L352-358)
```rust
        let mut pulled_txns = self
            .mempool_proxy
            .pull_internal(
                max_count,
                self.config.sender_max_total_bytes as u64,
                self.txns_in_progress_sorted.clone(),
            )
```

**File:** consensus/src/quorum_store/batch_generator.rs (L383-384)
```rust
        let expiry_time = aptos_infallible::duration_since_epoch().as_micros() as u64
            + self.config.batch_expiry_gap_when_init_usecs;
```

**File:** consensus/src/quorum_store/batch_generator.rs (L522-525)
```rust
                            // Block timestamp is updated asynchronously, so it may race when it enters state sync.
                            if self.latest_block_timestamp > block_timestamp {
                                continue;
                            }
```

**File:** consensus/src/quorum_store/batch_generator.rs (L536-536)
```rust
                            for (author, batch_id) in self.batch_expirations.expire(block_timestamp) {
```

**File:** config/src/config/quorum_store_config.rs (L131-132)
```rust
            batch_expiry_gap_when_init_usecs: Duration::from_secs(60).as_micros() as u64,
            remote_batch_expiry_gap_when_init_usecs: Duration::from_millis(500).as_micros() as u64,
```

**File:** consensus/src/state_computer.rs (L200-203)
```rust
            let block_timestamp = target.commit_info().timestamp_usecs();
            inner
                .payload_manager
                .notify_commit(block_timestamp, Vec::new());
```
