# Audit Report

## Title
Critical Consensus Safety Violation: Unvalidated Commit Proof Acceptance in Fast-Forward Path Allows Invalid Signature Storage

## Summary
The consensus pipeline's fast-forward commit proof path accepts `LedgerInfoWithSignatures` from network peers without signature verification, allowing attackers to force honest validators to commit blocks with invalid or forged signatures. This violates the core BFT safety guarantee that all committed blocks must have valid 2f+1 signatures.

## Finding Description

The vulnerability exists across multiple components in the consensus pipeline's commit proof handling:

**Entry Point - Network Layer:**
When a `CommitDecisionMsg` is received from any network peer, it is forwarded to the buffer manager without signature verification: [1](#0-0) 

**Buffer Manager Processing:**
The `process_commit_message` function receives `CommitMessage::Decision` and either immediately uses it or stores it as pending, without verifying the signatures: [2](#0-1) 

When stored as pending, no validation occurs: [3](#0-2) 

**Fast-Forward Path Exploitation:**
When blocks complete execution, the unvalidated commit proof is retrieved and used in the fast-forward path: [4](#0-3) 

The `advance_to_executed_or_aggregated` function only validates that the `commit_info` matches execution results, but does NOT verify the aggregated signature: [5](#0-4) 

**Storage Layer:**
The commit proof is sent to the persisting phase without validation: [6](#0-5) 

The persisting phase forwards it to the block executor: [7](#0-6) 

The database layer validates only version, root hash, and epoch continuity - NOT signatures: [8](#0-7) 

**Missing Validation:**
While a `verify()` method exists for CommitDecision that should validate signatures: [9](#0-8) 

This method is NEVER called in the main consensus pipeline when processing commit decisions from the network.

**Attack Scenario:**

1. Attacker crafts a `CommitDecision` with:
   - Valid `commit_info` (BlockInfo) matching what honest nodes will compute from execution
   - Invalid/forged BLS signatures (or valid signatures for a different ledger_info)

2. Attacker sends `ConsensusMsg::CommitDecisionMsg` to victim validator nodes

3. Victim nodes receive and store the commit proof without signature verification

4. When blocks complete execution, the fast-forward path uses the unvalidated commit proof

5. Nodes advance to Aggregated state and commit to storage with invalid signatures

6. Invalid commit proofs are propagated to consensus observers: [10](#0-9) 

**Invariant Violations:**
- **Consensus Safety**: Blocks committed without valid 2f+1 signatures violate AptosBFT safety guarantees
- **Cryptographic Correctness**: BLS signature verification is bypassed entirely
- **Verifiability**: Blockchain state cannot be cryptographically verified by external parties

## Impact Explanation

**Critical Severity** - This qualifies as a Consensus/Safety violation per Aptos bug bounty criteria.

1. **Consensus Safety Break**: The fundamental BFT guarantee that all committed blocks have valid 2f+1 signatures is violated. Honest validators can be forced to commit blocks with invalid signatures.

2. **Chain Verifiability Compromised**: The stored `LedgerInfoWithSignatures` contains invalid aggregated signatures, breaking the ability of light clients, state sync nodes, and external verifiers to cryptographically verify the blockchain state.

3. **Network-Wide Impact**: All validators can be attacked simultaneously by broadcasting forged commit proofs, causing the entire network to store invalid signatures.

4. **Potential for Chain Splits**: If different attackers send different forged commit proofs for the same block, different validators might store different (all invalid) signatures, potentially causing divergence in committed state proofs.

5. **Trust Model Violation**: The blockchain's security relies on cryptographic proofs. Accepting unverified signatures fundamentally breaks this trust model.

## Likelihood Explanation

**High Likelihood**:

1. **Low Attacker Requirements**: Any network peer can send `CommitDecisionMsg` - no validator credentials or stake required

2. **Simple Exploitation**: Attacker only needs to:
   - Observe blocks being proposed/executed
   - Compute the expected `commit_info` from public block data
   - Craft a `CommitDecision` with forged signatures
   - Broadcast to target validators

3. **No Detection**: There are no logs or alerts when unvalidated commit proofs are accepted, making the attack silent

4. **Race Condition Favorable**: Attacker just needs their forged commit proof to arrive before honest commit votes aggregate, which is easily achievable for a fast network peer

## Recommendation

Add mandatory signature verification at the earliest point where commit decisions are received:

```rust
// In consensus/src/pipeline/buffer_manager.rs, process_commit_message function:

CommitMessage::Decision(commit_proof) => {
    // ADD SIGNATURE VERIFICATION HERE
    if let Err(e) = commit_proof.verify(&self.epoch_state.verifier) {
        error!(
            error = ?e,
            commit_info = ?commit_proof.ledger_info().commit_info(),
            "Invalid commit decision signature, rejecting"
        );
        reply_nack(protocol, response_sender);
        return None;
    }
    
    let target_block_id = commit_proof.ledger_info().commit_info().id();
    // ... rest of existing code
}
```

Additionally, verify signatures before storing as pending:

```rust
fn try_add_pending_commit_proof(&mut self, commit_proof: LedgerInfoWithSignatures) -> bool {
    // ADD SIGNATURE VERIFICATION HERE
    if let Err(e) = commit_proof.verify_signatures(&self.epoch_state.verifier) {
        error!(
            error = ?e,
            round = commit_proof.commit_info().round(),
            "Invalid pending commit proof signature, rejecting"
        );
        return false;
    }
    
    // ... rest of existing code
}
```

## Proof of Concept

```rust
// File: consensus/src/pipeline/buffer_manager_exploit_test.rs

#[cfg(test)]
mod exploit_tests {
    use super::*;
    use aptos_consensus_types::pipeline::commit_decision::CommitDecision;
    use aptos_crypto::{bls12381, HashValue};
    use aptos_types::{
        aggregate_signature::AggregateSignature,
        block_info::BlockInfo,
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
    };

    #[test]
    fn test_unvalidated_commit_proof_acceptance() {
        // Setup: Create a valid BlockInfo that would result from execution
        let block_info = BlockInfo::new(
            1,  // epoch
            5,  // round
            HashValue::random(),  // id
            HashValue::random(),  // executed_state_id
            100,  // version
            1000000,  // timestamp
            None,  // next_epoch_state
        );
        
        let ledger_info = LedgerInfo::new(block_info.clone(), HashValue::zero());
        
        // ATTACK: Create forged/invalid signature
        let forged_signature = AggregateSignature::empty();  // Invalid signature
        let commit_proof = LedgerInfoWithSignatures::new(ledger_info, forged_signature);
        
        // Create CommitDecision with forged signature
        let commit_decision = CommitDecision::new(commit_proof.clone());
        
        // VULNERABILITY: This commit decision with invalid signature will be accepted
        // without verification and stored in the buffer manager's pending_commit_proofs
        // or used directly in try_advance_to_aggregated_with_ledger_info
        
        // When blocks are executed and advance_to_executed_or_aggregated is called,
        // the fast-forward path at lines 146-158 will use this unvalidated commit_proof
        // and advance to Aggregated state, bypassing signature verification.
        
        // The node will then commit this block to storage with invalid signatures,
        // breaking consensus safety and verifiability guarantees.
        
        // Expected: commit_decision.verify() should be called and return Err
        // Actual: No verification happens, invalid signature is accepted
        
        assert!(commit_decision.verify(&validator_verifier).is_err());
        // But the code path does not call verify(), so invalid signatures are accepted
    }
}
```

## Notes

The vulnerability is particularly severe because:

1. The comment in `buffer_item.rs` line 230 states "this function assumes block id matches and the validity of ledger_info and that it has the voting power" - but this assumption is NEVER validated in the fast-forward path.

2. The `CommitDecision::verify()` method exists specifically for this purpose but is only called in consensus observer code, not in the main consensus pipeline.

3. The assertion at line 149 provides a false sense of security - it only checks content equality, not cryptographic validity.

4. An attacker can also exploit this for denial-of-service by sending commit proofs with mismatched `commit_info`, causing the assertion to panic and crash validator nodes.

### Citations

**File:** consensus/src/network.rs (L848-862)
```rust
                        ConsensusMsg::CommitDecisionMsg(commit_decision) => {
                            let (tx, _rx) = oneshot::channel();
                            let req_with_callback =
                                IncomingRpcRequest::CommitRequest(IncomingCommitRequest {
                                    req: CommitMessage::Decision(*commit_decision),
                                    protocol: RPC[0],
                                    response_sender: tx,
                                });
                            if let Err(e) = self.rpc_tx.push(
                                (peer_id, discriminant(&req_with_callback)),
                                (peer_id, req_with_callback),
                            ) {
                                warn!(error = ?e, "aptos channel closed");
                            };
                        },
```

**File:** consensus/src/pipeline/buffer_manager.rs (L308-333)
```rust
    fn try_add_pending_commit_proof(&mut self, commit_proof: LedgerInfoWithSignatures) -> bool {
        const MAX_PENDING_COMMIT_PROOFS: usize = 100;

        let round = commit_proof.commit_info().round();
        let block_id = commit_proof.commit_info().id();
        if self.highest_committed_round < round {
            info!(
                round = round,
                block_id = block_id,
                "Added pending commit proof."
            );
            self.pending_commit_proofs.insert(round, commit_proof);
            if self.pending_commit_proofs.len() == MAX_PENDING_COMMIT_PROOFS {
                let _ = self.pending_commit_proofs.pop_first();
            }
            true
        } else {
            debug!(
                round = round,
                highest_committed_round = self.highest_committed_round,
                block_id = block_id,
                "Commit proof too old, ignored."
            );
            false
        }
    }
```

**File:** consensus/src/pipeline/buffer_manager.rs (L514-518)
```rust
                if let Some(consensus_publisher) = &self.consensus_publisher {
                    let message =
                        ConsensusObserverMessage::new_commit_decision_message(commit_proof.clone());
                    consensus_publisher.publish_message(message);
                }
```

**File:** consensus/src/pipeline/buffer_manager.rs (L523-529)
```rust
                self.persisting_phase_tx
                    .send(self.create_new_request(PersistingRequest {
                        blocks: blocks_to_persist,
                        commit_ledger_info: aggregated_item.commit_proof,
                    }))
                    .await
                    .expect("Failed to send persist request");
```

**File:** consensus/src/pipeline/buffer_manager.rs (L667-673)
```rust
        if let Some(commit_proof) = self.drain_pending_commit_proof_till(round) {
            if !new_item.is_aggregated()
                && commit_proof.ledger_info().commit_info().id() == block_id
            {
                new_item = new_item.try_advance_to_aggregated_with_ledger_info(commit_proof)
            }
        }
```

**File:** consensus/src/pipeline/buffer_manager.rs (L786-812)
```rust
            CommitMessage::Decision(commit_proof) => {
                let target_block_id = commit_proof.ledger_info().commit_info().id();
                info!(
                    "Receive commit decision {}",
                    commit_proof.ledger_info().commit_info()
                );
                let cursor = self
                    .buffer
                    .find_elem_by_key(*self.buffer.head_cursor(), target_block_id);
                if cursor.is_some() {
                    let item = self.buffer.take(&cursor);
                    let new_item = item.try_advance_to_aggregated_with_ledger_info(
                        commit_proof.ledger_info().clone(),
                    );
                    let aggregated = new_item.is_aggregated();
                    self.buffer.set(&cursor, new_item);

                    reply_ack(protocol, response_sender);
                    if aggregated {
                        return Some(target_block_id);
                    }
                } else if self.try_add_pending_commit_proof(commit_proof.into_inner()) {
                    reply_ack(protocol, response_sender);
                } else {
                    reply_nack(protocol, response_sender); // TODO: send_commit_proof() doesn't care about the response and this should be direct send not RPC
                }
            },
```

**File:** consensus/src/pipeline/buffer_item.rs (L146-158)
```rust
                if let Some(commit_proof) = commit_proof {
                    // We have already received the commit proof in fast forward sync path,
                    // we can just use that proof and proceed to aggregated
                    assert_eq!(commit_proof.commit_info().clone(), commit_info);
                    debug!(
                        "{} advance to aggregated from ordered",
                        commit_proof.commit_info()
                    );
                    Self::Aggregated(Box::new(AggregatedItem {
                        executed_blocks,
                        commit_proof,
                    }))
                } else {
```

**File:** consensus/src/pipeline/persisting_phase.rs (L65-71)
```rust
        for b in &blocks {
            if let Some(tx) = b.pipeline_tx().lock().as_mut() {
                tx.commit_proof_tx
                    .take()
                    .map(|tx| tx.send(commit_ledger_info.clone()));
            }
            b.wait_for_commit_ledger().await;
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L540-600)
```rust
    fn check_and_put_ledger_info(
        &self,
        version: Version,
        ledger_info_with_sig: &LedgerInfoWithSignatures,
        ledger_batch: &mut SchemaBatch,
    ) -> Result<(), AptosDbError> {
        let ledger_info = ledger_info_with_sig.ledger_info();

        // Verify the version.
        ensure!(
            ledger_info.version() == version,
            "Version in LedgerInfo doesn't match last version. {:?} vs {:?}",
            ledger_info.version(),
            version,
        );

        // Verify the root hash.
        let db_root_hash = self
            .ledger_db
            .transaction_accumulator_db()
            .get_root_hash(version)?;
        let li_root_hash = ledger_info_with_sig
            .ledger_info()
            .transaction_accumulator_hash();
        ensure!(
            db_root_hash == li_root_hash,
            "Root hash pre-committed doesn't match LedgerInfo. pre-commited: {:?} vs in LedgerInfo: {:?}",
            db_root_hash,
            li_root_hash,
        );

        // Verify epoch continuity.
        let current_epoch = self
            .ledger_db
            .metadata_db()
            .get_latest_ledger_info_option()
            .map_or(0, |li| li.ledger_info().next_block_epoch());
        ensure!(
            ledger_info_with_sig.ledger_info().epoch() == current_epoch,
            "Gap in epoch history. Trying to put in LedgerInfo in epoch: {}, current epoch: {}",
            ledger_info_with_sig.ledger_info().epoch(),
            current_epoch,
        );

        // Ensure that state tree at the end of the epoch is persisted.
        if ledger_info_with_sig.ledger_info().ends_epoch() {
            let state_snapshot = self.state_store.get_state_snapshot_before(version + 1)?;
            ensure!(
                state_snapshot.is_some() && state_snapshot.as_ref().unwrap().0 == version,
                "State checkpoint not persisted at the end of the epoch, version {}, next_epoch {}, snapshot in db: {:?}",
                version,
                ledger_info_with_sig.ledger_info().next_block_epoch(),
                state_snapshot,
            );
        }

        // Put write to batch.
        self.ledger_db
            .metadata_db()
            .put_ledger_info(ledger_info_with_sig, ledger_batch)?;
        Ok(())
```

**File:** consensus/consensus-types/src/pipeline/commit_decision.rs (L49-59)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        ensure!(
            !self.ledger_info.commit_info().is_ordered_only(),
            "Unexpected ordered only commit info"
        );
        // We do not need to check the author because as long as the signature tree
        // is valid, the message should be valid.
        self.ledger_info
            .verify_signatures(validator)
            .context("Failed to verify Commit Decision")
    }
```
