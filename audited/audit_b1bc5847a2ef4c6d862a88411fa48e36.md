# Audit Report

## Title
Panic in PrintPackageMetadata Due to Unvalidated Compressed Metadata in PackageRegistry

## Summary
The `PrintPackageMetadata` command in `aptos-release-builder` panics when processing `PackageRegistry` resources containing malformed compressed metadata. The vulnerability occurs because the `Display` trait implementation for `PackageMetadata` uses `.unwrap()` on decompression operations without proper error handling, while the on-chain package publishing logic does not validate that manifest, source, and source_map fields contain valid gzipped data.

## Finding Description
The vulnerability exists in a two-stage failure:

**Stage 1 - Lack of On-Chain Validation:**
When packages are published to the blockchain via the `publish_package_txn` entry function, the `PackageMetadata` is deserialized from BCS bytes without validating the contents of the `manifest`, `source`, or `source_map` byte vector fields. [1](#0-0) 

The Move code stores this metadata directly in the `PackageRegistry` resource without checking whether these fields contain valid gzipped data: [2](#0-1) 

**Stage 2 - Unsafe Display Implementation:**
The Rust `Display` trait implementation for `PackageMetadata` calls `unzip_metadata_str().unwrap()` on the manifest field without error handling: [3](#0-2) 

The `unzip_metadata_str` function can fail in two ways:
1. Invalid gzip compression during `GzDecoder` operation
2. Invalid UTF-8 encoding after decompression [4](#0-3) 

**Exploitation Path:**
1. Attacker publishes a package with `manifest` field containing invalid gzipped data (e.g., `vec![0x00, 0x01, 0x02, 0x03]`)
2. The BCS deserialization succeeds (byte vectors have no content validation)
3. Package is stored on-chain in `PackageRegistry` resource
4. When any user runs `PrintPackageMetadata` command to query this package, the tool fetches the data successfully via `get_account_resource_bcs`
5. Upon attempting to print the package at line 458, the `Display` implementation executes
6. The `.unwrap()` call panics when `unzip_metadata_str` fails to decompress the malformed data
7. The entire tool crashes [5](#0-4) 

The same vulnerability exists in the `ModuleMetadata` Display implementation for `source` and `source_map` fields: [6](#0-5) 

## Impact Explanation
This is a **Medium Severity** vulnerability per the bug bounty program criteria. While it does not directly cause "API crashes" in the REST API server (which would be High Severity), it represents a state integrity issue where malformed data can be permanently stored on-chain and subsequently crash any tooling that attempts to display it.

The impact includes:
- **Denial of Service**: Any user running `aptos-release-builder` to query package metadata will experience tool crashes
- **Data Integrity**: Malformed metadata can be permanently stored on-chain without validation
- **Operational Impact**: Package inspection and release building workflows become unreliable

This falls under Medium Severity as it causes tool crashes and represents a state inconsistency requiring intervention, though it does not affect consensus, validator operations, or fund security.

## Likelihood Explanation
**Likelihood: Medium to High**

This vulnerability is likely to occur because:
1. **Low Attack Complexity**: Any user with package publishing permissions can create malformed metadata
2. **No Special Privileges Required**: Standard package publishing flow is sufficient
3. **Persistent Impact**: Once published, the malformed data remains on-chain permanently
4. **Wide Attack Surface**: Any package on any account can be exploited

The vulnerability could occur through:
- **Malicious Intent**: Attacker deliberately publishes packages with corrupted metadata to DoS tooling
- **Accidental Corruption**: Bugs in package publishing tools could inadvertently create malformed metadata
- **Data Corruption**: Storage or transmission errors during package publishing

## Recommendation
Implement validation and error handling at multiple levels:

**1. Add On-Chain Validation (Preferred):**
Add a native function to validate compressed metadata before publishing:

```rust
// In aptos-move/framework/src/natives/code.rs
fn validate_compressed_metadata(data: &[u8]) -> PartialVMResult<()> {
    unzip_metadata_str(data)
        .map(|_| ())
        .map_err(|_| PartialVMError::new(StatusCode::INVALID_ARGUMENT))
}
```

Call this validation in the `publish_package` function before storing metadata.

**2. Fix Display Implementation (Critical):**
Replace `.unwrap()` calls with proper error handling:

```rust
impl fmt::Display for PackageMetadata {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Package name:{}", self.name)?;
        writeln!(f, "Upgrade policy:{}", self.upgrade_policy)?;
        writeln!(f, "Upgrade number:{}", self.upgrade_number)?;
        writeln!(f, "Source digest:{}", self.source_digest)?;
        
        match unzip_metadata_str(&self.manifest) {
            Ok(manifest_str) => {
                writeln!(f, "Manifest:")?;
                writeln!(f, "{}", manifest_str)?;
            },
            Err(e) => {
                writeln!(f, "Manifest: <Error: Failed to decompress - {}>", e)?;
            }
        }
        
        // Similar handling for deps, extension, and modules...
        Ok(())
    }
}
```

**3. Add Client-Side Validation:**
In `PrintPackageMetadata` command handler, catch panics or validate before printing:

```rust
for package in packages.into_inner().packages {
    if package.name == package_name {
        // Validate before printing
        if let Err(e) = validate_package_metadata(&package) {
            eprintln!("Warning: Package contains malformed metadata: {}", e);
        }
        if print_json {
            println!("{}", serde_json::to_string(&package).unwrap());
        } else {
            println!("{}", package);
        }
        break;
    }
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test_malformed_package {
    use super::*;
    use aptos_framework::natives::code::{PackageMetadata, PackageRegistry, UpgradePolicy};
    
    #[test]
    #[should_panic(expected = "called `Result::unwrap()` on an `Err` value")]
    fn test_display_panics_on_invalid_manifest() {
        // Create PackageMetadata with invalid gzipped manifest
        let malformed_package = PackageMetadata {
            name: "test_package".to_string(),
            upgrade_policy: UpgradePolicy { policy: 1 },
            upgrade_number: 0,
            source_digest: "test_digest".to_string(),
            manifest: vec![0x00, 0x01, 0x02, 0x03], // Invalid gzip data
            modules: vec![],
            deps: vec![],
            extension: None,
        };
        
        // This will panic when Display implementation calls unzip_metadata_str().unwrap()
        let _ = format!("{}", malformed_package);
    }
    
    #[test]
    fn test_bcs_serialization_accepts_malformed_data() {
        // Demonstrate that BCS serialization doesn't validate content
        let malformed_package = PackageMetadata {
            name: "test".to_string(),
            upgrade_policy: UpgradePolicy { policy: 1 },
            upgrade_number: 0,
            source_digest: "test".to_string(),
            manifest: vec![0xFF, 0xFF, 0xFF], // Invalid data
            modules: vec![],
            deps: vec![],
            extension: None,
        };
        
        let registry = PackageRegistry {
            packages: vec![malformed_package],
        };
        
        // BCS serialization succeeds
        let serialized = bcs::to_bytes(&registry).expect("BCS serialization should succeed");
        
        // BCS deserialization also succeeds
        let deserialized: PackageRegistry = bcs::from_bytes(&serialized)
            .expect("BCS deserialization should succeed");
        
        assert_eq!(deserialized.packages[0].name, "test");
        // But attempting to display will panic:
        // println!("{}", deserialized.packages[0]); // Would panic here
    }
}
```

## Notes
This vulnerability represents a broader pattern in the codebase where on-chain data validation is insufficient. The same issue could potentially exist in other areas where compressed or encoded data is stored on-chain and later processed by tools with `.unwrap()` calls. A comprehensive audit of similar patterns across the codebase is recommended.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/code.move (L168-228)
```text
    public fun publish_package(owner: &signer, pack: PackageMetadata, code: vector<vector<u8>>) acquires PackageRegistry {
        check_code_publishing_permission(owner);
        // Disallow incompatible upgrade mode. Governance can decide later if this should be reconsidered.
        assert!(
            pack.upgrade_policy.policy > upgrade_policy_arbitrary().policy,
            error::invalid_argument(EINCOMPATIBLE_POLICY_DISABLED),
        );

        let addr = signer::address_of(owner);
        if (!exists<PackageRegistry>(addr)) {
            move_to(owner, PackageRegistry { packages: vector::empty() })
        };

        // Checks for valid dependencies to other packages
        let allowed_deps = check_dependencies(addr, &pack);

        // Check package against conflicts
        // To avoid prover compiler error on spec
        // the package need to be an immutable variable
        let module_names = get_module_names(&pack);
        let package_immutable = &borrow_global<PackageRegistry>(addr).packages;
        let len = vector::length(package_immutable);
        let index = len;
        let upgrade_number = 0;
        vector::enumerate_ref(package_immutable
        , |i, old| {
            let old: &PackageMetadata = old;
            if (old.name == pack.name) {
                upgrade_number = old.upgrade_number + 1;
                check_upgradability(old, &pack, &module_names);
                index = i;
            } else {
                check_coexistence(old, &module_names)
            };
        });

        // Assign the upgrade counter.
        pack.upgrade_number = upgrade_number;

        let packages = &mut borrow_global_mut<PackageRegistry>(addr).packages;
        // Update registry
        let policy = pack.upgrade_policy;
        if (index < len) {
            *vector::borrow_mut(packages, index) = pack
        } else {
            vector::push_back(packages, pack)
        };

        event::emit(PublishPackage {
            code_address: addr,
            is_upgrade: upgrade_number > 0
        });

        // Request publish
        if (features::code_dependency_check_enabled())
            request_publish_with_allowed_deps(addr, module_names, allowed_deps, code, policy.policy)
        else
        // The new `request_publish_with_allowed_deps` has not yet rolled out, so call downwards
        // compatible code.
            request_publish(addr, module_names, code, policy.policy)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L256-259)
```text
    public entry fun publish_package_txn(owner: &signer, metadata_serialized: vector<u8>, code: vector<vector<u8>>)
    acquires PackageRegistry {
        publish_package(owner, util::from_bytes<PackageMetadata>(metadata_serialized), code)
    }
```

**File:** aptos-move/framework/src/natives/code.rs (L73-93)
```rust
impl fmt::Display for PackageMetadata {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Package name:{}", self.name)?;
        writeln!(f, "Upgrade policy:{}", self.upgrade_policy)?;
        writeln!(f, "Upgrade number:{}", self.upgrade_number)?;
        writeln!(f, "Source digest:{}", self.source_digest)?;
        let manifest_str = unzip_metadata_str(&self.manifest).unwrap();
        writeln!(f, "Manifest:")?;
        writeln!(f, "{}", manifest_str)?;
        writeln!(f, "Package Dependency:")?;
        for dep in &self.deps {
            writeln!(f, "{:?}", dep)?;
        }
        writeln!(f, "extension:{:?}", self.extension)?;
        writeln!(f, "Modules:")?;
        for module in &self.modules {
            writeln!(f, "{}", module)?;
        }
        Ok(())
    }
}
```

**File:** aptos-move/framework/src/natives/code.rs (L111-127)
```rust
impl fmt::Display for ModuleMetadata {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        writeln!(f, "Module name:{}", self.name)?;
        if !self.source.is_empty() {
            writeln!(f, "Source code:")?;
            let source = unzip_metadata_str(&self.source).unwrap();
            writeln!(f, "{}", source)?;
        }
        if !self.source_map.is_empty() {
            writeln!(f, "Source map:")?;
            let source_map = unzip_metadata_str(&self.source_map).unwrap();
            writeln!(f, "{}", source_map)?;
        }
        writeln!(f, "Module extension:{:?}", self.extension)?;
        Ok(())
    }
}
```

**File:** aptos-move/framework/src/lib.rs (L58-62)
```rust
pub fn unzip_metadata_str(data: &[u8]) -> anyhow::Result<String> {
    let r = unzip_metadata(data)?;
    let s = String::from_utf8(r)?;
    Ok(s)
}
```

**File:** aptos-move/aptos-release-builder/src/main.rs (L450-463)
```rust
            let packages = client
                .get_account_resource_bcs::<PackageRegistry>(address, "0x1::code::PackageRegistry")
                .await?;
            for package in packages.into_inner().packages {
                if package.name == package_name {
                    if print_json {
                        println!("{}", serde_json::to_string(&package).unwrap());
                    } else {
                        println!("{}", package);
                    }
                    break;
                }
            }
            Ok(())
```
