# Audit Report

## Title
Unprotected Panic in Transaction Filter Matching Causes gRPC Service Process Termination

## Summary
The `parse_transaction_filter()` function does not catch panics, and if any panic occurs during filter parsing or subsequent transaction filtering, the global panic handler terminates the entire gRPC service process. While `BooleanTransactionFilter::new_from_proto()` itself returns `Result` and is designed not to panic during parsing, a confirmed panic exists in the transaction matching phase that will crash the service when processing transactions with invalid type values. [1](#0-0) 

## Finding Description

The security question asks whether panic propagation is handled in `parse_transaction_filter()`. Investigation reveals multiple layers of concern:

**1. No Panic Catching During Parsing**

The `parse_transaction_filter()` wrapper has no panic catching mechanism. It directly calls `BooleanTransactionFilter::new_from_proto()` and relies on error propagation via `Result`: [1](#0-0) 

**2. Global Panic Handler Terminates Process**

The indexer gRPC framework installs a global panic handler that explicitly terminates the entire process on any panic: [2](#0-1) 

When any panic occurs, including in request handlers, the process exits with code 12, taking down the entire gRPC service.

**3. Confirmed Panic in Filter Matching**

While `new_from_proto()` is designed to return `Result` and not panic during parsing, a **confirmed panic point exists** in the transaction matching phase. The `TransactionRootFilter::matches()` function uses `.expect()` which panics on invalid transaction types: [3](#0-2) 

**4. Panic Occurs During Transaction Streaming**

The parsed filter is used in `strip_transactions()` which calls `matches()` on each transaction: [4](#0-3) 

**Attack Flow:**
1. Client sends GetTransactions gRPC request with a transaction filter
2. Filter is parsed successfully (no panic here)
3. Service streams transactions and applies filter
4. If any transaction has an invalid/corrupted `type` field, `TransactionType::try_from()` fails
5. `.expect()` on line 69 of `transaction_root.rs` panics
6. Global panic handler terminates entire gRPC service process
7. All other concurrent client connections are dropped

## Impact Explanation

**High Severity** per Aptos Bug Bounty criteria:
- **API Crashes**: The vulnerability causes complete termination of the gRPC service process
- **Validator Node Slowdowns**: If this affects fullnode/validator indexer services, it impacts node operation
- **Service Availability**: Complete denial of service for all clients connected to the affected instance

The impact is categorized as High rather than Critical because:
- It does not affect consensus or cause fund loss
- It requires either corrupted data in storage or a specific edge case
- The service can be restarted (not permanent)
- It affects indexer infrastructure, not core blockchain

However, if multiple indexer instances can be targeted simultaneously, this could cause widespread service disruption.

## Likelihood Explanation

**Likelihood: Low to Medium**

The vulnerability can be triggered if:
1. A transaction with an invalid `type` field (i32 value not in TransactionType enum) exists in storage/cache
2. A client requests transactions with a filter that uses `TransactionRootFilter` with a type constraint
3. The invalid transaction is processed during filtering

**Factors reducing likelihood:**
- Transactions undergo validation before storage, making invalid types unlikely
- Would require storage corruption or a separate serialization bug
- The invalid i32 value would need to bypass protobuf validation

**Factors increasing likelihood:**
- No defensive programming (`.expect()` instead of graceful handling)
- Panic affects entire process, not just single request
- No circuit breaker or panic recovery mechanism

## Recommendation

**Immediate Fix: Replace `.expect()` with Graceful Error Handling**

Replace the panic-inducing code in `TransactionRootFilter::matches()`:

```rust
// Current (panics):
if txn_type != &TransactionType::try_from(item.r#type).expect("Invalid transaction type") {
    return false;
}

// Recommended (graceful):
match TransactionType::try_from(item.r#type) {
    Ok(item_txn_type) => {
        if txn_type != &item_txn_type {
            return false;
        }
    }
    Err(_) => {
        // Invalid transaction type - log and treat as non-matching
        warn!("Encountered transaction with invalid type: {}", item.r#type);
        return false;
    }
}
```

**Additional Hardening:**

1. **Add Panic Catching Around Critical Paths** (if panics in parsing are a concern):
```rust
pub fn parse_transaction_filter(
    proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
    max_filter_size_bytes: usize,
) -> Result<BooleanTransactionFilter, Status> {
    std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
        BooleanTransactionFilter::new_from_proto(proto_filter, Some(max_filter_size_bytes))
    }))
    .unwrap_or_else(|_| Err(anyhow::anyhow!("Panic during filter parsing")))
    .map_err(|e| Status::invalid_argument(format!("Invalid transaction_filter: {e:?}.")))
}
```

2. **Per-Request Panic Isolation**: Consider using task-level panic boundaries for each gRPC request instead of process-level panic handler

3. **Validation Audit**: Review all other `.expect()`, `.unwrap()`, and panic-inducing operations in hot paths

## Proof of Concept

```rust
// PoC: Demonstrate the panic
use aptos_protos::transaction::v1::{Transaction, TransactionInfo};
use aptos_transaction_filter::{TransactionRootFilter, Filterable};
use aptos_protos::transaction::v1::transaction::TransactionType;

#[test]
#[should_panic(expected = "Invalid transaction type")]
fn test_invalid_transaction_type_panic() {
    // Create a transaction with invalid type (999 is not a valid TransactionType)
    let mut txn = Transaction::default();
    txn.r#type = 999; // Invalid enum value
    txn.info = Some(TransactionInfo {
        success: true,
        ..Default::default()
    });

    // Create filter with transaction type constraint
    let filter = TransactionRootFilter {
        success: None,
        txn_type: Some(TransactionType::User), // Any valid type
    };

    // This will panic!
    let _ = filter.matches(&txn);
}
```

**Notes:**
- The primary answer to the security question is: **No, there is no panic catching** - if `new_from_proto()` or any downstream code panics, it will crash the entire gRPC service
- While `new_from_proto()` itself appears designed to return `Result`, the confirmed vulnerability exists in the filtering phase where `.expect()` is used
- The lack of defensive programming and panic isolation creates a systemic DoS vulnerability in the indexer gRPC infrastructure

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/filter_utils.rs (L9-15)
```rust
pub fn parse_transaction_filter(
    proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
    max_filter_size_bytes: usize,
) -> Result<BooleanTransactionFilter, Status> {
    BooleanTransactionFilter::new_from_proto(proto_filter, Some(max_filter_size_bytes))
        .map_err(|e| Status::invalid_argument(format!("Invalid transaction_filter: {e:?}.")))
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-server-framework/src/lib.rs (L149-168)
```rust
pub fn setup_panic_handler() {
    std::panic::set_hook(Box::new(move |pi: &PanicHookInfo<'_>| {
        handle_panic(pi);
    }));
}

// Formats and logs panic information
fn handle_panic(panic_info: &PanicHookInfo<'_>) {
    // The Display formatter for a PanicHookInfo contains the message, payload and location.
    let details = format!("{}", panic_info);
    let backtrace = format!("{:#?}", Backtrace::new());
    let info = CrashInfo { details, backtrace };
    let crash_info = toml::to_string_pretty(&info).unwrap();
    error!("{}", crash_info);
    // TODO / HACK ALARM: Write crash info synchronously via eprintln! to ensure it is written before the process exits which error! doesn't guarantee.
    // This is a workaround until https://github.com/aptos-labs/aptos-core/issues/2038 is resolved.
    eprintln!("{}", crash_info);
    // Kill the process
    process::exit(12);
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/transaction_root.rs (L67-73)
```rust
        if let Some(txn_type) = &self.txn_type {
            if txn_type
                != &TransactionType::try_from(item.r#type).expect("Invalid transaction type")
            {
                return false;
            }
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs (L924-954)
```rust
fn strip_transactions(
    transactions: Vec<Transaction>,
    txns_to_strip_filter: &BooleanTransactionFilter,
) -> (Vec<Transaction>, usize) {
    let mut stripped_count = 0;

    let stripped_transactions: Vec<Transaction> = transactions
        .into_iter()
        .map(|mut txn| {
            // Note: `is_allowed` means the txn matches the filter, in which case
            // we strip it.
            if txns_to_strip_filter.matches(&txn) {
                stripped_count += 1;
                if let Some(info) = txn.info.as_mut() {
                    info.changes = vec![];
                }
                if let Some(TxnData::User(user_transaction)) = txn.txn_data.as_mut() {
                    user_transaction.events = vec![];
                    if let Some(utr) = user_transaction.request.as_mut() {
                        // Wipe the payload and signature.
                        utr.payload = None;
                        utr.signature = None;
                    }
                }
            }
            txn
        })
        .collect();

    (stripped_transactions, stripped_count)
}
```
