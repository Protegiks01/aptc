# Audit Report

## Title
OnDiskStorage Creates Files with Insecure Permissions Enabling Validator Private Key Theft and Equivocation Attacks

## Summary
The `OnDiskStorage` implementation does not set restrictive file permissions (mode 0o600) when creating files that store validator private keys and safety state data. This allows unauthorized local users to read validator private keys and modify safety state files, enabling private key theft and equivocation attacks that violate consensus safety guarantees.

## Finding Description

The `OnDiskStorage` implementation in `secure/storage/src/on_disk.rs` creates files using standard `File::create()` calls without explicitly setting file permissions. [1](#0-0) 

When creating temporary files during write operations, the same insecure pattern is used: [2](#0-1) 

On Unix systems, `File::create()` uses the process's umask to determine file permissions. With a typical umask of 022, files are created with permissions 0o644 (rw-r--r--), making them world-readable. This is a critical security flaw because `OnDiskStorage` is used by `PersistentSafetyStorage` to store:

1. **CONSENSUS_KEY**: The validator's BLS12-381 private key used for signing votes and blocks [3](#0-2) 

2. **SAFETY_DATA**: The `SafetyData` struct containing `last_voted_round`, `highest_timeout_round`, and `last_vote` - critical state preventing equivocation [4](#0-3) 

Despite warnings in the README that OnDiskStorage "should not be used in production," it IS configured in production deployment templates: [5](#0-4) 

The codebase demonstrates the correct implementation pattern in `crates/aptos/src/common/utils.rs`: [6](#0-5) 

**Attack Scenario 1: Private Key Theft**
1. Attacker gains local user access to validator host (via compromised service, container escape, etc.)
2. Attacker reads `/opt/aptos/data/secure-data.json` (default path)
3. Attacker extracts CONSENSUS_KEY (validator's private key)
4. Attacker can now impersonate the validator, signing votes and blocks

**Attack Scenario 2: Equivocation Attack**
1. Attacker gains local write access to validator host
2. Attacker modifies `secure-data.json` to reset `last_voted_round` to 0
3. Safety rules are bypassed - validator can now sign conflicting votes for the same round [7](#0-6) 
4. This violates consensus safety, enabling double-spending attacks

## Impact Explanation

This vulnerability has **High Severity** impact under the Aptos Bug Bounty program:

1. **Consensus Safety Violation**: Enables equivocation attacks by allowing safety state manipulation, violating the core invariant that "AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine"

2. **Validator Compromise**: Private key theft allows complete validator impersonation, enabling:
   - Signing of malicious blocks
   - Vote manipulation
   - Consensus participation as the compromised validator

3. **Attack Prerequisites**: Requires only local user access to the validator host, which can be achieved through:
   - Compromised co-located services
   - Container escape vulnerabilities
   - Supply chain attacks
   - Insider threats (system administrators)

While this doesn't meet Critical severity (doesn't directly cause fund loss or network partition), it enables significant protocol violations and validator compromise, qualifying as High severity per the bug bounty program.

## Likelihood Explanation

**Likelihood: Medium to High**

1. **Deployment Reality**: Despite documentation warnings, OnDiskStorage is used in official deployment templates for validators, making this vulnerability present in real deployments

2. **Attack Surface**: Any compromise of the validator host system (OS vulnerabilities, container escapes, compromised services) immediately exposes validator keys

3. **No Defense in Depth**: Unlike VaultStorage which provides encryption and access controls, OnDiskStorage offers zero protection beyond filesystem permissions - which are not properly set

4. **Common Deployment Patterns**: Many validators may use these default configurations, especially in testnet, development, or initial mainnet deployments

## Recommendation

**Immediate Fix**: Set restrictive file permissions (0o600) when creating files in `OnDiskStorage`:

```rust
fn new_with_time_service(file_path: PathBuf, time_service: TimeService) -> Self {
    if !file_path.exists() {
        #[cfg(unix)]
        {
            use std::os::unix::fs::OpenOptionsExt;
            std::fs::OpenOptions::new()
                .write(true)
                .create(true)
                .mode(0o600)
                .open(&file_path)
                .unwrap_or_else(|_| panic!("Unable to create storage at path: {:?}", file_path));
        }
        #[cfg(not(unix))]
        {
            File::create(&file_path)
                .unwrap_or_else(|_| panic!("Unable to create storage at path: {:?}", file_path));
        }
    }
    // ... rest of function
}

fn write(&self, data: &HashMap<String, Value>) -> Result<(), Error> {
    let contents = serde_json::to_vec(data)?;
    #[cfg(unix)]
    {
        use std::os::unix::fs::OpenOptionsExt;
        let mut file = std::fs::OpenOptions::new()
            .write(true)
            .create(true)
            .truncate(true)
            .mode(0o600)
            .open(self.temp_path.path())?;
        file.write_all(&contents)?;
    }
    #[cfg(not(unix))]
    {
        let mut file = File::create(self.temp_path.path())?;
        file.write_all(&contents)?;
    }
    fs::rename(&self.temp_path, &self.file_path)?;
    Ok(())
}
```

**Long-term Recommendations**:
1. Deprecate OnDiskStorage for production use and enforce VaultStorage in deployment validators
2. Add runtime warnings when OnDiskStorage is used for consensus keys
3. Implement file permission checks at startup to detect misconfigured storage
4. Document security requirements clearly in deployment guides

## Proof of Concept

```rust
// File: secure/storage/src/tests/file_permissions.rs
#[cfg(unix)]
#[test]
fn test_ondisk_storage_insecure_permissions() {
    use std::os::unix::fs::PermissionsExt;
    use crate::{KVStorage, OnDiskStorage};
    use aptos_temppath::TempPath;
    
    // Create OnDiskStorage
    let temp_path = TempPath::new();
    temp_path.create_as_file().unwrap();
    let path = temp_path.path().to_path_buf();
    let mut storage = OnDiskStorage::new(path.clone());
    
    // Store a "private key" (simulated with string)
    storage.set("test_key", "sensitive_private_key_data").unwrap();
    
    // Check file permissions
    let metadata = std::fs::metadata(&path).unwrap();
    let permissions = metadata.permissions();
    let mode = permissions.mode();
    
    // Extract permission bits (last 9 bits)
    let perms = mode & 0o777;
    
    // VULNERABILITY: File is readable by others!
    println!("File permissions: {:o}", perms);
    
    // On typical systems with umask 022:
    // Expected secure: 0o600 (owner read/write only)
    // Actually created: 0o644 (world-readable!)
    assert!(perms & 0o044 != 0, 
        "VULNERABILITY CONFIRMED: File has group/other read permissions ({:o}), should be 0o600", 
        perms);
    
    // Demonstrate unauthorized read
    let unauthorized_read = std::fs::read_to_string(&path).unwrap();
    assert!(unauthorized_read.contains("sensitive_private_key_data"),
        "Unauthorized user can read private key!");
}

#[cfg(unix)]
#[test]
fn test_ondisk_storage_secure_permissions_should_be() {
    use std::os::unix::fs::{PermissionsExt, OpenOptionsExt};
    use aptos_temppath::TempPath;
    
    // Demonstrate CORRECT implementation
    let temp_path = TempPath::new();
    let path = temp_path.path();
    
    std::fs::OpenOptions::new()
        .write(true)
        .create(true)
        .mode(0o600)  // Owner read/write only
        .open(path)
        .unwrap();
    
    let metadata = std::fs::metadata(path).unwrap();
    let mode = metadata.permissions().mode() & 0o777;
    
    assert_eq!(mode, 0o600, "Secure file should have 0o600 permissions");
    println!("âœ“ Secure permissions: {:o}", mode);
}
```

Run with: `cargo test test_ondisk_storage_insecure_permissions -- --nocapture`

This test confirms that OnDiskStorage creates world-readable files, demonstrating the vulnerability.

## Notes

- The vulnerability exists in the current implementation despite clear documentation that OnDiskStorage "should not be used in production" [8](#0-7) 
- Production deployment templates still reference OnDiskStorage, creating operational risk
- The fix is straightforward and demonstrated in the codebase's own utility functions
- This affects all validators using OnDiskStorage in any environment where multiple users have access to the system
- The issue impacts both validator private keys and consensus safety state, making it a high-priority security concern

### Citations

**File:** secure/storage/src/on_disk.rs (L36-37)
```rust
            File::create(&file_path)
                .unwrap_or_else(|_| panic!("Unable to create storage at path: {:?}", file_path));
```

**File:** secure/storage/src/on_disk.rs (L66-66)
```rust
        let mut file = File::create(self.temp_path.path())?;
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L68-68)
```rust
        let result = internal_store.set(CONSENSUS_KEY, consensus_private_key);
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L160-160)
```rust
        match self.internal_store.set(SAFETY_DATA, data.clone()) {
```

**File:** terraform/helm/aptos-node/files/configs/validator-base.yaml (L14-16)
```yaml
    backend:
      type: "on_disk_storage"
      path: secure-data.json
```

**File:** crates/aptos/src/common/utils.rs (L224-228)
```rust
pub fn write_to_user_only_file(path: &Path, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    let mut opts = OpenOptions::new();
    #[cfg(unix)]
    opts.mode(0o600);
    write_to_file_with_opts(path, name, bytes, &mut opts)
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L77-80)
```rust
        self.verify_and_update_last_vote_round(
            proposed_block.block_data().round(),
            &mut safety_data,
        )?;
```

**File:** secure/storage/README.md (L37-42)
```markdown
- `OnDisk`: Similar to InMemory, the OnDisk secure storage implementation provides another
useful testing implementation: an on-disk storage engine, where the storage backend is
implemented using a single file written to local disk. In a similar fashion to the in-memory
storage, on-disk should not be used in production environments as it provides no security
guarantees (e.g., encryption before writing to disk). Moreover, OnDisk storage does not
currently support concurrent data accesses.
```
