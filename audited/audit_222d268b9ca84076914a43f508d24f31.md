# Audit Report

## Title
Missing Gas Schedule Validation Enables Network Paralysis with No Emergency Recovery Mechanism

## Summary

The gas schedule update functions lack validation to prevent catastrophically misconfigured gas parameters (such as all costs set to 0). Combined with the absence of emergency governance bypass mechanisms and long voting periods (7 days on mainnet), a misconfigured gas schedule would enable unprivileged attackers to flood the network with free transactions while governance lacks the ability to respond quickly enough, leading to total network unavailability requiring a hard fork.

## Finding Description

The gas schedule update flow contains multiple critical security gaps that violate the Resource Limits invariant:

**Missing Validation**: The `set_for_next_epoch()` and related functions in the gas schedule module contain TODO comments indicating validation should occur, but no validation is implemented: [1](#0-0) [2](#0-1) [3](#0-2) 

The `GasScheduleV2` struct contains a vector of `GasEntry` elements with `key: String` and `val: u64` fields. There is no validation that:
- Critical parameters like `min_price_per_gas_unit` are non-zero
- Gas costs are within reasonable bounds
- The schedule contains all required parameters

**Attack Propagation**: Once a zero-cost gas schedule is applied through the config buffer system: [4](#0-3) 

At epoch transition, the misconfigured schedule becomes active. Transaction validation in `gas.rs` checks if the submitted gas price meets `min_price_per_gas_unit`: [5](#0-4) 

If `min_price_per_gas_unit` is set to 0, transactions with zero gas price are accepted. All bytecode operations would cost 0 gas, enabling unlimited free computation.

**Emergency Response Failure**: Governance voting periods are configured for extended durations: [6](#0-5) 

The mainnet voting duration is 7 days. While `force_end_epoch()` exists to bypass DKG delays: [7](#0-6) 

This function only forces epoch transitions, it cannot bypass the governance voting period or directly revert a gas schedule. No emergency mechanism exists to immediately apply a corrected gas schedule.

**Network Paralysis**: With consensus configured for limited throughput per block: [8](#0-7) 

Unprivileged attackers could flood the network with unlimited free transactions. While blocks are limited to ~5000-10000 transactions, the cumulative effect over 7 days would be:
- Millions of free transactions processed
- Massive state bloat from unlimited operations
- Resource exhaustion on validator nodes
- Legitimate governance transactions drowned out by spam
- Network potentially unable to process the revert proposal even after voting completes

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under multiple categories:

1. **Total loss of liveness/network availability**: Once exploited, the network becomes unusable for legitimate transactions as attackers flood it with free operations.

2. **Non-recoverable network partition (requires hardfork)**: The 7-day governance period combined with unlimited free transaction spam would create irreversible state bloat and resource exhaustion. Even if the revert proposal eventually passes, the accumulated damage (millions of spam transactions, state database corruption, validator node crashes) would likely require coordinating a hard fork to a clean state.

3. **Consensus/Safety violations**: The inability to enforce gas limits breaks the fundamental assumption that computational resources are bounded, potentially causing consensus divergence if validators have different resource capacities.

This breaks the critical invariants:
- **Resource Limits**: "All operations must respect gas, storage, and computational limits"
- **Move VM Safety**: "Bytecode execution must respect gas limits and memory constraints"

## Likelihood Explanation

**Likelihood: Medium to High**

The vulnerability could be triggered through:

1. **Accidental misconfiguration**: A legitimate governance proposal with a bug in the gas schedule generation tooling could accidentally set dangerous values. The lack of validation means such errors would not be caught before deployment.

2. **Malicious proposal**: While requiring governance approval makes direct exploitation harder, an attacker with sufficient stake could propose a "gas optimization" that appears legitimate but contains zero values for critical parameters. Given the complexity of gas schedules (100+ parameters), subtle malicious changes might not be caught during review.

3. **Compromise of gas schedule generation tools**: The gas schedule is generated programmatically. If the generation tools or deployment scripts are compromised, a malicious schedule could be injected.

Once the misconfiguration is active, exploitation is trivial - any unprivileged attacker can immediately begin sending free transactions. The lack of emergency response mechanisms makes recovery extremely unlikely within a timeframe that prevents catastrophic damage.

## Recommendation

Implement comprehensive validation in the gas schedule update functions:

```move
public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    // Validate critical gas parameters exist and are non-zero
    validate_gas_schedule_consistency(&new_gas_schedule);
    
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    config_buffer::upsert(new_gas_schedule);
}

fun validate_gas_schedule_consistency(schedule: &GasScheduleV2) {
    // Validate min_price_per_gas_unit is non-zero
    let min_price_key = utf8(b"txn.min_price_per_gas_unit");
    let min_price_val = find_gas_entry_value(schedule, &min_price_key);
    assert!(min_price_val > 0, error::invalid_argument(EINVALID_GAS_SCHEDULE));
    
    // Validate other critical parameters
    // ... additional validation logic
}
```

Additionally, implement an emergency governance bypass mechanism restricted to a multi-sig of core validators that can:
1. Immediately apply a vetted gas schedule without waiting for voting period
2. Require 2/3+ validator approval to prevent abuse
3. Only be usable for gas schedule reverts, not arbitrary changes

## Proof of Concept

```move
#[test_only]
module aptos_framework::gas_schedule_zero_cost_attack_test {
    use aptos_framework::gas_schedule;
    use aptos_framework::reconfiguration_with_dkg;
    use std::bcs;
    
    #[test(framework = @aptos_framework)]
    #[expected_failure(abort_code = 0x010001, location = aptos_framework::gas_schedule)]
    fun test_zero_cost_gas_schedule_rejected(framework: &signer) {
        // Create a malicious gas schedule with all costs set to 0
        let malicious_schedule = create_zero_cost_gas_schedule();
        let malicious_blob = bcs::to_bytes(&malicious_schedule);
        
        // This should FAIL with EINVALID_GAS_SCHEDULE due to validation
        // Currently it would SUCCEED, demonstrating the vulnerability
        gas_schedule::set_for_next_epoch(framework, malicious_blob);
        
        // If accepted, trigger epoch transition to apply it
        reconfiguration_with_dkg::finish(framework);
        
        // At this point, all transactions would cost 0 gas
        // Network would be vulnerable to unlimited spam
    }
    
    fun create_zero_cost_gas_schedule(): gas_schedule::GasScheduleV2 {
        let entries = vector::empty();
        
        // Set min_price_per_gas_unit to 0 (critical vulnerability)
        vector::push_back(&mut entries, gas_schedule::GasEntry {
            key: string::utf8(b"txn.min_price_per_gas_unit"),
            val: 0  // DANGEROUS: allows zero-cost transactions
        });
        
        // Set all other gas costs to 0
        // ... additional zero-cost entries
        
        gas_schedule::GasScheduleV2 {
            feature_version: 100,
            entries
        }
    }
}
```

## Notes

This vulnerability represents a critical gap in Aptos's defense-in-depth security model. While governance is designed to be the primary update mechanism, the lack of validation at the technical layer means a single governance mistake (accidental or malicious) could cause irreversible network damage. The 7-day voting period, designed for democratic oversight, becomes a liability when responding to critical misconfigurations. The network's survival depends on perfect governance decision-making with no safety net for errors.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L47-47)
```text
        // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L67-67)
```text
            // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-102)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L46-61)
```text
    public(friend) fun finish(framework: &signer) {
        system_addresses::assert_aptos_framework(framework);
        dkg::try_clear_incomplete_session(framework);
        consensus_config::on_new_epoch(framework);
        execution_config::on_new_epoch(framework);
        gas_schedule::on_new_epoch(framework);
        std::version::on_new_epoch(framework);
        features::on_new_epoch(framework);
        jwk_consensus_config::on_new_epoch(framework);
        jwks::on_new_epoch(framework);
        keyless_account::on_new_epoch(framework);
        randomness_config_seqnum::on_new_epoch(framework);
        randomness_config::on_new_epoch(framework);
        randomness_api_v0_config::on_new_epoch(framework);
        reconfiguration::reconfigure();
    }
```

**File:** aptos-move/aptos-vm/src/gas.rs (L174-192)
```rust
    // The submitted gas price is less than the minimum gas unit price set by the VM.
    // NB: MIN_PRICE_PER_GAS_UNIT may equal zero, but need not in the future. Hence why
    // we turn off the clippy warning.
    #[allow(clippy::absurd_extreme_comparisons)]
    let below_min_bound = txn_metadata.gas_unit_price() < txn_gas_params.min_price_per_gas_unit;
    if below_min_bound {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; min {}, submitted {}",
                txn_gas_params.min_price_per_gas_unit,
                txn_metadata.gas_unit_price()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::GAS_UNIT_PRICE_BELOW_MIN_BOUND,
            None,
        ));
    }
```

**File:** aptos-move/vm-genesis/src/lib.rs (L1487-1487)
```rust
        voting_duration_secs: 7 * 24 * 3600, // 7 days
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L700-703)
```text
    public entry fun force_end_epoch(aptos_framework: &signer) {
        system_addresses::assert_aptos_framework(aptos_framework);
        reconfiguration_with_dkg::finish(aptos_framework);
    }
```

**File:** config/src/config/consensus_config.rs (L20-24)
```rust
const MAX_SENDING_BLOCK_TXNS_AFTER_FILTERING: u64 = 1800;
const MAX_SENDING_OPT_BLOCK_TXNS_AFTER_FILTERING: u64 = 1000;
const MAX_SENDING_BLOCK_TXNS: u64 = 5000;
pub(crate) static MAX_RECEIVING_BLOCK_TXNS: Lazy<u64> =
    Lazy::new(|| 10000.max(2 * MAX_SENDING_BLOCK_TXNS));
```
