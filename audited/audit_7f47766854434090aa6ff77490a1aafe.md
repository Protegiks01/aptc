# Audit Report

## Title
Subscription Request Validation Bypass Allows Rate Limiting Evasion and State Probing

## Summary
Subscription requests completely bypass the RequestModerator's validation and invalid request tracking, allowing attackers to repeatedly send malformed subscription requests to probe internal subscription state without triggering TooManyInvalidRequests protection.

## Finding Description

The storage service implements a RequestModerator to track peers sending invalid requests and temporarily ignore peers that exceed the threshold. However, subscription requests follow a separate code path that bypasses this protection entirely. [1](#0-0) 

When subscription requests are received, they skip the normal `validate_and_handle_request` flow and go directly to `handle_subscription_request`, which never calls `request_moderator.validate_request()`. [2](#0-1) 

In contrast, regular requests are validated through the moderator, which increments the invalid request counter when requests cannot be serviced. [3](#0-2) 

When subscription requests fail validation in `add_subscription_request` due to invalid indices, they return InvalidRequest errors: [4](#0-3) 

These errors are handled by `handle_subscription_request_failure`, which simply logs, updates metrics, and notifies the clientâ€”without incrementing any invalid request counter: [5](#0-4) 

**Attack Path:**
1. Attacker establishes a subscription stream with a valid initial request
2. Attacker sends subscription requests with systematically varied indices (0, 1, 2, 3, etc.)
3. By observing which indices return "index too low" errors, attacker learns `next_index_to_serve`
4. By observing which indices return "overwriting existing subscription" errors, attacker maps pending requests
5. This can be repeated indefinitely without triggering TooManyInvalidRequests since the moderator is bypassed
6. For public network peers, this completely circumvents the protection mechanism designed to limit abusive peers

## Impact Explanation

This vulnerability breaks the **Resource Limits** invariant (Invariant #9) which states "All operations must respect gas, storage, and computational limits." The RequestModerator exists specifically to enforce limits on invalid requests, but subscription requests evade this control.

While this does not directly cause fund loss or consensus violations, it represents a **Medium severity** issue because:

1. **Information Disclosure**: Attackers can probe internal subscription state (next_index_to_serve, pending indices) which may aid in coordinating more sophisticated attacks
2. **Rate Limiting Bypass**: The RequestModerator's protection mechanism is completely ineffective for subscription requests
3. **Operational Impact**: Unbounded invalid subscription requests can cause log spam, metric pollution, and potentially exhaust server resources through repeated memory allocations and response generation

Per the Aptos bug bounty criteria, this qualifies as Medium severity under "State inconsistencies requiring intervention" since the rate limiting state machine is inconsistent with the design intent that all invalid requests should be tracked and limited.

## Likelihood Explanation

**Likelihood: High**

The attack is trivially exploitable by any network peer:
- No special privileges required (works for public peers, VFNs, validators)
- Simple to execute (just send subscription requests with varying indices)
- No race conditions or timing dependencies
- The vulnerability is present in the core request handling logic, affecting all nodes running the storage service

## Recommendation

Subscription requests should be validated through the RequestModerator before being processed. Modify `handle_subscription_request` to call `validate_request` first:

```rust
pub fn handle_subscription_request(
    &self,
    storage_service_config: StorageServiceConfig,
    peer_network_id: PeerNetworkId,
    request: StorageServiceRequest,
    response_sender: ResponseSender,
) {
    // Validate the request with the moderator BEFORE processing
    if let Err(error) = self.request_moderator.validate_request(&peer_network_id, &request) {
        // Send error response and return early
        self.send_response(
            request,
            Err(match error {
                Error::InvalidRequest(msg) => StorageServiceError::InvalidRequest(msg),
                Error::TooManyInvalidRequests(msg) => StorageServiceError::TooManyInvalidRequests(msg),
                _ => StorageServiceError::InternalError(error.to_string()),
            }),
            response_sender,
        );
        return;
    }

    // Rest of existing logic...
    let subscription_request = SubscriptionRequest::new(request.clone(), response_sender, self.time_service.clone());
    // ... continue with normal flow
}
```

Additionally, when subscription validation fails in `add_subscription_request`, the moderator should be notified to increment the invalid request count.

## Proof of Concept

```rust
#[tokio::test]
async fn test_subscription_index_probing_bypasses_rate_limiting() {
    use aptos_config::config::StorageServiceConfig;
    use aptos_storage_service_types::requests::*;
    use aptos_types::PeerId;
    use aptos_config::network_id::{NetworkId, PeerNetworkId};
    
    // Setup storage service with max_invalid_requests = 5
    let mut config = StorageServiceConfig::default();
    config.max_invalid_requests_per_peer = 5;
    
    let peer_network_id = PeerNetworkId::new(NetworkId::Public, PeerId::random());
    let stream_id = 12345;
    
    // Create initial valid subscription to establish stream
    let valid_request = create_subscription_request(stream_id, 0);
    // Process valid request...
    
    // Send 100 subscription requests with invalid indices
    // (far exceeding max_invalid_requests = 5)
    for i in 1..100 {
        let invalid_request = create_subscription_request(stream_id, i);
        // Each request returns InvalidRequest error
        // But moderator's invalid_request_count is never incremented
        // Peer is never marked as ignored
    }
    
    // Verify the peer was never ignored despite 100 invalid requests
    // This proves the bypass - in normal flow, peer would be ignored after 5 invalid requests
}
```

The PoC demonstrates that subscription requests with invalid indices can be sent repeatedly without triggering the TooManyInvalidRequests protection that would normally activate after 5 invalid requests from public network peers.

## Notes

The vulnerability exists because subscription requests are treated as a special case that bypasses standard validation. While this may have been an intentional design decision to optimize the subscription flow, it creates a security gap where the rate limiting mechanism is completely ineffective for an entire class of requests.

This issue affects all network peer types but has the most severe impact on public network peers, who are the only ones subject to the RequestModerator's ignore mechanism under normal circumstances. Validators and VFNs are never ignored regardless, but the lack of invalid request tracking still represents a violation of the intended security model.

### Citations

**File:** state-sync/storage-service/server/src/handler.rs (L125-134)
```rust
        // Handle any subscription requests
        if request.data_request.is_subscription_request() {
            self.handle_subscription_request(
                storage_service_config,
                peer_network_id,
                request,
                response_sender,
            );
            return;
        }
```

**File:** state-sync/storage-service/server/src/handler.rs (L206-213)
```rust
    fn validate_and_handle_request(
        &self,
        peer_network_id: &PeerNetworkId,
        request: &StorageServiceRequest,
    ) -> Result<StorageServiceResponse, Error> {
        // Validate the request with the moderator
        self.request_moderator
            .validate_request(peer_network_id, request)?;
```

**File:** state-sync/storage-service/server/src/handler.rs (L354-380)
```rust
    fn handle_subscription_request_failure(
        &self,
        peer_network_id: PeerNetworkId,
        request: StorageServiceRequest,
        error: Error,
        subscription_request: SubscriptionRequest,
    ) {
        // Something went wrong when adding the request to the stream
        sample!(
            SampleRate::Duration(Duration::from_secs(ERROR_LOG_FREQUENCY_SECS)),
            warn!(LogSchema::new(LogEntry::SubscriptionRequest)
                .error(&error)
                .peer_network_id(&peer_network_id)
                .request(&request)
            );
        );

        // Update the subscription metrics
        update_failed_subscription_metrics(peer_network_id);

        // Notify the client of the failure
        self.send_response(
            request,
            Err(StorageServiceError::InvalidRequest(error.to_string())),
            subscription_request.take_response_sender(),
        );
    }
```

**File:** state-sync/storage-service/server/src/moderator.rs (L160-178)
```rust
                // Increment the invalid request count for the peer
                let mut unhealthy_peer_state = self
                    .unhealthy_peer_states
                    .entry(*peer_network_id)
                    .or_insert_with(|| {
                        // Create a new unhealthy peer state (this is the first invalid request)
                        let max_invalid_requests =
                            self.storage_service_config.max_invalid_requests_per_peer;
                        let min_time_to_ignore_peers_secs =
                            self.storage_service_config.min_time_to_ignore_peers_secs;
                        let time_service = self.time_service.clone();

                        UnhealthyPeerState::new(
                            max_invalid_requests,
                            min_time_to_ignore_peers_secs,
                            time_service,
                        )
                    });
                unhealthy_peer_state.increment_invalid_request_count(peer_network_id);
```

**File:** state-sync/storage-service/server/src/subscription.rs (L358-368)
```rust
        // Verify that the subscription request index is valid
        let subscription_request_index = subscription_request.subscription_stream_index();
        if subscription_request_index < self.next_index_to_serve {
            return Err((
                Error::InvalidRequest(format!(
                    "The subscription request index is too low! Next index to serve: {:?}, found: {:?}",
                    self.next_index_to_serve, subscription_request_index
                )),
                subscription_request,
            ));
        }
```
