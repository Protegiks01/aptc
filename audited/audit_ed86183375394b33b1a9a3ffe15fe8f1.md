# Audit Report

## Title
Critical Panic in Secret Sharing Due to Uninitialized Peer Weight Configuration

## Summary
The `SecretShareConfig` maintains peer validator weights in an empty `HashMap` that is never populated from actual validator stakes. When secret sharing is enabled and a node processes a block, attempting to add its own secret share causes a panic due to missing weight data, resulting in node crashes and potential network-wide liveness failure.

## Finding Description

The vulnerability exists in the secret sharing weight management system across multiple files: [1](#0-0) 

The `SecretShareConfig` struct contains a `weights: HashMap<Author, u64>` field that is initialized as empty and never populated from validator stakes. The struct has two inconsistent weight access methods: [2](#0-1) 

When a block is processed with secret sharing enabled, the secret share manager derives and adds the node's own share: [3](#0-2) 

This calls `add_self_share()` which retrieves the empty weights HashMap: [4](#0-3) 

The execution flow then reaches `add_share_with_metadata()` which calls `retain()`: [5](#0-4) 

Inside `retain()`, the code attempts to look up each author's weight in the empty HashMap: [6](#0-5) 

Line 79 will panic with "Author must exist for weight" because the weights HashMap is empty. This directly answers the security question: **peer weights in config are not merely inconsistent with validator stakes—they are completely absent, causing deterministic node crashes**.

Meanwhile, shares from other validators use a different code path with hardcoded weights: [7](#0-6) 

This creates a fundamental inconsistency where peer shares get weight 1 (hardcoded) while self shares attempt to use the empty weights HashMap.

## Impact Explanation

**Critical Severity** - This vulnerability causes:

1. **Total Loss of Liveness**: Every validator node crashes when processing its first block with secret sharing enabled
2. **Network-Wide Availability Loss**: All nodes experience the same deterministic panic simultaneously
3. **Consensus Safety Violation**: The network cannot progress or commit blocks
4. **Non-Recoverable Without Intervention**: Requires disabling the secret sharing feature or fixing the code

The impact aligns with Critical severity criteria: "Total loss of liveness/network availability" and "Non-recoverable network partition (requires hardfork)". If secret sharing were enabled network-wide, the entire Aptos blockchain would halt.

## Likelihood Explanation

**Likelihood: High (if feature enabled), Low (current deployment)**

The vulnerability is **deterministic** and will trigger on every node that:
1. Has secret sharing enabled (via `Option<SecretShareConfig>` being `Some`)
2. Processes any block requiring secret share generation

Currently, the likelihood depends on whether secret sharing is enabled in production. The code comment "This is temporary and meant to change in future PRs" suggests this is work-in-progress functionality. However, the infrastructure is fully integrated into the consensus pipeline, indicating potential future activation.

If enabled, the attack requires no special access—normal block processing triggers the panic. Every validator experiences the same crash simultaneously, making it a network-wide incident rather than an individual node issue.

## Recommendation

The `SecretShareConfig` must be initialized with actual validator voting powers from the `ValidatorVerifier`:

```rust
impl SecretShareConfig {
    pub fn new(
        author: Author,
        epoch: u64,
        validator: Arc<ValidatorVerifier>,
        digest_key: DigestKey,
        msk_share: MasterSecretKeyShare,
        verification_keys: Vec<VerificationKey>,
        config: <FPTXWeighted as BatchThresholdEncryption>::ThresholdConfig,
        encryption_key: EncryptionKey,
    ) -> Self {
        // FIX: Populate weights from validator voting powers
        let weights: HashMap<Author, u64> = validator
            .validator_infos
            .iter()
            .map(|info| (info.address, info.voting_power))
            .collect();
        
        Self {
            _author: author,
            _epoch: epoch,
            validator,
            digest_key,
            msk_share,
            verification_keys,
            config,
            encryption_key,
            weights,  // Now properly initialized
        }
    }
}
```

Additionally, ensure consistency by removing the hardcoded `get_peer_weight()` method or making it use the weights HashMap.

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "Author must exist for weight")]
fn test_secret_share_weight_panic() {
    use aptos_types::secret_sharing::{SecretShareConfig, SecretShare, SecretShareMetadata};
    use aptos_types::validator_verifier::{ValidatorVerifier, ValidatorConsensusInfo};
    use aptos_crypto::bls12381::PrivateKey;
    use std::sync::Arc;
    
    // Create a minimal validator set
    let author = AccountAddress::random();
    let private_key = PrivateKey::generate_for_testing();
    let public_key = private_key.public_key();
    
    let validator_info = ValidatorConsensusInfo::new(author, public_key, 100);
    let validator_verifier = Arc::new(ValidatorVerifier::new(vec![validator_info]));
    
    // Create SecretShareConfig with empty weights (the bug)
    let config = SecretShareConfig::new(
        author,
        1, // epoch
        validator_verifier,
        /* digest_key, msk_share, verification_keys, config, encryption_key - mock values */
    );
    
    // Create a SecretShareStore
    let (decision_tx, _) = futures_channel::mpsc::unbounded();
    let mut store = SecretShareStore::new(1, author, config, decision_tx);
    
    // Create a mock SecretShare for self
    let metadata = SecretShareMetadata::new(1, 1, 0, HashValue::zero(), vec![]);
    let share = SecretShare::new(author, metadata, /* mock key share */);
    
    // This will panic because weights HashMap is empty
    store.add_self_share(share).unwrap();
}
```

The test demonstrates that calling `add_self_share()` with the current implementation will panic due to the uninitialized weights HashMap, proving the vulnerability is exploitable through normal consensus operation.

### Citations

**File:** types/src/secret_sharing.rs (L134-170)
```rust
/// This is temporary and meant to change in future PRs
#[derive(Clone)]
pub struct SecretShareConfig {
    _author: Author,
    _epoch: u64,
    validator: Arc<ValidatorVerifier>,
    digest_key: DigestKey,
    msk_share: MasterSecretKeyShare,
    verification_keys: Vec<VerificationKey>,
    config: <FPTXWeighted as BatchThresholdEncryption>::ThresholdConfig,
    encryption_key: EncryptionKey,
    weights: HashMap<Author, u64>,
}

impl SecretShareConfig {
    pub fn new(
        author: Author,
        epoch: u64,
        validator: Arc<ValidatorVerifier>,
        digest_key: DigestKey,
        msk_share: MasterSecretKeyShare,
        verification_keys: Vec<VerificationKey>,
        config: <FPTXWeighted as BatchThresholdEncryption>::ThresholdConfig,
        encryption_key: EncryptionKey,
    ) -> Self {
        Self {
            _author: author,
            _epoch: epoch,
            validator,
            digest_key,
            msk_share,
            verification_keys,
            config,
            encryption_key,
            weights: HashMap::new(),
        }
    }
```

**File:** types/src/secret_sharing.rs (L196-202)
```rust
    pub fn get_peer_weight(&self, _peer: &Author) -> u64 {
        1
    }

    pub fn get_peer_weights(&self) -> &HashMap<Author, u64> {
        &self.weights
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L142-148)
```rust
        {
            let mut secret_share_store = self.secret_share_store.lock();
            secret_share_store.update_highest_known_round(block.round());
            secret_share_store
                .add_self_share(self_secret_share.clone())
                .expect("Add self dec share should succeed");
        }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L74-81)
```rust
    fn retain(&mut self, metadata: &SecretShareMetadata, weights: &HashMap<Author, u64>) {
        self.shares.retain(|_, share| share.metadata == *metadata);
        self.total_weight = self
            .shares
            .keys()
            .map(|author| weights.get(author).expect("Author must exist for weight"))
            .sum();
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L156-182)
```rust
    fn add_share_with_metadata(
        &mut self,
        share: SecretShare,
        share_weights: &HashMap<Author, u64>,
    ) -> anyhow::Result<()> {
        let item = std::mem::replace(self, Self::new(Author::ONE));
        let share_weight = *share_weights
            .get(share.author())
            .expect("Author must exist in weights");
        let new_item = match item {
            SecretShareItem::PendingMetadata(mut share_aggregator) => {
                let metadata = share.metadata.clone();
                share_aggregator.retain(share.metadata(), share_weights);
                share_aggregator.add_share(share, share_weight);
                SecretShareItem::PendingDecision {
                    metadata,
                    share_aggregator,
                }
            },
            SecretShareItem::PendingDecision { .. } => {
                bail!("Cannot add self share in PendingDecision state");
            },
            SecretShareItem::Decided { .. } => return Ok(()),
        };
        let _ = std::mem::replace(self, new_item);
        Ok(())
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L237-256)
```rust
    pub fn add_self_share(&mut self, share: SecretShare) -> anyhow::Result<()> {
        assert!(
            self.self_author == share.author,
            "Only self shares can be added with metadata"
        );
        let peer_weights = self.secret_share_config.get_peer_weights();
        let metadata = share.metadata();
        ensure!(metadata.epoch == self.epoch, "Share from different epoch");
        ensure!(
            metadata.round <= self.highest_known_round + FUTURE_ROUNDS_TO_ACCEPT,
            "Share from future round"
        );

        let item = self
            .secret_share_map
            .entry(metadata.round)
            .or_insert_with(|| SecretShareItem::new(self.self_author));
        item.add_share_with_metadata(share, peer_weights)?;
        item.try_aggregate(&self.secret_share_config, self.decision_tx.clone());
        Ok(())
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L259-275)
```rust
    pub fn add_share(&mut self, share: SecretShare) -> anyhow::Result<bool> {
        let weight = self.secret_share_config.get_peer_weight(share.author());
        let metadata = share.metadata();
        ensure!(metadata.epoch == self.epoch, "Share from different epoch");
        ensure!(
            metadata.round <= self.highest_known_round + FUTURE_ROUNDS_TO_ACCEPT,
            "Share from future round"
        );

        let item = self
            .secret_share_map
            .entry(metadata.round)
            .or_insert_with(|| SecretShareItem::new(self.self_author));
        item.add_share(share, weight)?;
        item.try_aggregate(&self.secret_share_config, self.decision_tx.clone());
        Ok(item.has_decision())
    }
```
