# Audit Report

## Title
Insecure File Permissions for Decompiled/Disassembled Move Bytecode Output on Non-Unix Systems

## Summary
The `write_to_user_only_file()` function used to write decompiled and disassembled Move bytecode output files only enforces restrictive permissions (0600) on Unix systems. On Windows and other non-Unix platforms, files are created with default system permissions, potentially allowing other users on multi-user systems to read sensitive Move code. Additionally, on Unix systems, if output files already exist with permissive permissions, the overwrite operation preserves those insecure permissions.

## Finding Description

The vulnerability exists in the file writing mechanism used by the Move bytecode disassembly and decompilation tools. When a user runs `aptos move disassemble` or `aptos move decompile`, the output is written using `write_to_user_only_file()`. [1](#0-0) 

The `write_to_user_only_file()` function attempts to set file permissions to 0600 (owner read/write only), but this protection is conditional: [2](#0-1) 

The critical issue is that the `opts.mode(0o600)` call is wrapped in `#[cfg(unix)]`, meaning:

1. **On Non-Unix Systems (Windows, etc.)**: No permission restrictions are applied at all. Files are created with default system permissions, which on Windows typically allow read access to other users on the same machine.

2. **On Unix Systems with Existing Files**: The `mode()` function only sets permissions when **creating** new files. The underlying `OpenOptions` opens existing files and truncates them without modifying their permissions: [3](#0-2) 

**Attack Scenarios:**

**Scenario 1 - Windows Systems:**
- Developer runs decompiler on Windows development machine
- Output files created with default Windows ACLs
- Other users on the system can read the decompiled Move code
- Exposes pre-deployment contract logic, potential vulnerabilities

**Scenario 2 - Permission Preservation on Unix:**
- Attacker (or misconfiguration) creates output file with world-readable permissions: `touch module.mv.move && chmod 644 module.mv.move`
- Developer runs `aptos move decompile --bytecode-path module.mv --assume-yes`
- File is overwritten but retains 0644 permissions
- Decompiled code remains readable by other users

**Scenario 3 - Shared Development Environments:**
- CI/CD systems, shared development servers, or university computing clusters
- Multiple developers/users on the same system
- Decompiled code analysis of proprietary or vulnerability-containing contracts
- Exposure of sensitive business logic before deployment

## Impact Explanation

This vulnerability constitutes a **Medium Severity** information disclosure issue per Aptos bug bounty criteria because:

1. **Information Exposure**: Decompiled Move bytecode can reveal:
   - Smart contract vulnerabilities before deployment
   - Proprietary business logic and algorithms
   - Security-sensitive contract implementations
   - Internal contract state management strategies

2. **Pre-Deployment Risk**: While deployed on-chain bytecode is public, developers analyzing pre-deployment code expect confidentiality. Exposure could enable:
   - Front-running attacks if vulnerabilities are discovered
   - Competitive intelligence theft
   - Exploitation of discovered vulnerabilities in production contracts

3. **Shared Environment Risk**: Common in:
   - Corporate development environments
   - CI/CD pipelines with multiple users
   - Educational institutions
   - Open-source development servers

4. **Deviation from Security Expectations**: The function is named `write_to_user_only_file()` and is used elsewhere for private keys, creating a false sense of security: [4](#0-3) 

## Likelihood Explanation

The likelihood is **MEDIUM-HIGH** because:

1. **Platform-Specific**: Affects 100% of Windows users and users of other non-Unix systems
2. **Common Workflow**: Decompilation/disassembly is a standard development workflow for:
   - Verifying compiled bytecode
   - Analyzing on-chain contracts
   - Security auditing
   - Debugging
3. **Shared Environments**: Many organizations use shared development infrastructure
4. **No Warning**: Users receive no indication that files lack proper protection
5. **Permission Persistence**: Once files exist with wrong permissions, they remain vulnerable

## Recommendation

**Fix 1: Add Windows-Specific Permission Handling**

Implement platform-specific permission restrictions for Windows using Windows ACLs:

```rust
pub fn write_to_user_only_file(path: &Path, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    let mut opts = OpenOptions::new();
    #[cfg(unix)]
    opts.mode(0o600);
    
    write_to_file_with_opts(path, name, bytes, &mut opts)?;
    
    // Apply permissions after file creation for Windows
    #[cfg(windows)]
    {
        use std::os::windows::fs::MetadataExt;
        // Set Windows ACLs to restrict access to current user only
        // Implementation would use Windows API calls
    }
    
    Ok(())
}
```

**Fix 2: Explicit Permission Setting on Unix for Existing Files**

On Unix systems, explicitly set permissions after opening the file:

```rust
pub fn write_to_user_only_file(path: &Path, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    let mut opts = OpenOptions::new();
    #[cfg(unix)]
    opts.mode(0o600);
    
    write_to_file_with_opts(path, name, bytes, &mut opts)?;
    
    // Explicitly set permissions after writing (Unix)
    #[cfg(unix)]
    {
        use std::fs::Permissions;
        use std::os::unix::fs::PermissionsExt;
        std::fs::set_permissions(path, Permissions::from_mode(0o600))
            .map_err(|e| CliError::IO(name.to_string(), e))?;
    }
    
    Ok(())
}
```

**Fix 3: Warning for Non-Unix Systems**

At minimum, warn users on non-Unix systems:

```rust
pub fn write_to_user_only_file(path: &Path, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    #[cfg(not(unix))]
    eprintln!("Warning: File permissions may not be restricted on this platform. Sensitive data may be readable by other users.");
    
    // ... existing implementation
}
```

## Proof of Concept

**PoC 1: Windows Permission Issue**

On Windows system:
```bash
# Download and decompile an on-chain module
aptos move download --account 0x1 --package AptosFramework --bytecode
aptos move decompile --package-path AptosFramework/bytecode_modules

# Check file permissions (PowerShell)
Get-Acl AptosFramework/bytecode_modules/account.mv.move | Format-List

# Expected: File readable by all users on the system
# Actual: No user-only restriction applied
```

**PoC 2: Unix Permission Preservation**

On Unix system:
```bash
# Create output file with world-readable permissions
mkdir -p test_output
touch test_output/module.mv.move
chmod 644 test_output/module.mv.move

# Download bytecode
aptos move download --account 0x1 --package AptosFramework --bytecode

# Decompile with assume-yes to skip overwrite prompt
aptos move decompile \
  --bytecode-path AptosFramework/bytecode_modules/account.mv \
  --output-dir test_output \
  --assume-yes

# Check permissions
ls -la test_output/module.mv.move
# Expected: -rw-r--r-- (644) - world-readable
# Should be: -rw------- (600) - owner only
```

**PoC 3: Verification Script**

```bash
#!/bin/bash
# Test permission preservation vulnerability

# Setup
mkdir -p vuln_test
cd vuln_test

# Download a sample module
aptos move download --account 0x1 --package AptosToken --bytecode

# Create output file with weak permissions
touch AptosToken/bytecode_modules/token.mv.move
chmod 666 AptosToken/bytecode_modules/token.mv.move

# Decompile (overwrites existing file)
aptos move decompile --bytecode-path AptosToken/bytecode_modules/token.mv --assume-yes

# Check if permissions were preserved (vulnerability)
PERMS=$(stat -c "%a" AptosToken/bytecode_modules/token.mv.move)
if [ "$PERMS" != "600" ]; then
    echo "VULNERABILITY CONFIRMED: File has permissions $PERMS instead of 600"
    echo "Other users can read the decompiled Move code"
else
    echo "Permissions correctly set to 600"
fi
```

## Notes

This vulnerability is particularly concerning because:

1. **Inconsistent Security Model**: The same `write_to_user_only_file()` function is used for highly sensitive data (private keys) and decompiled code, creating a false security expectation.

2. **Silent Failure**: On non-Unix systems, the function silently fails to apply any permission restrictions with no warning to users.

3. **Development Workflow Impact**: Developers commonly analyze pre-deployment code to find bugs, and exposure of this analysis could enable attacks.

4. **Cross-Platform Inconsistency**: Security guarantees differ dramatically between Unix and Windows, violating the principle of least surprise.

The fix should ensure consistent permission enforcement across all platforms or at minimum provide clear warnings when restrictions cannot be applied.

### Citations

**File:** crates/aptos/src/move_tool/bytecode.rs (L282-286)
```rust
            write_to_user_only_file(
                output_file.as_path(),
                &output_file.display().to_string(),
                output.as_bytes(),
            )?;
```

**File:** crates/aptos/src/common/utils.rs (L224-229)
```rust
pub fn write_to_user_only_file(path: &Path, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    let mut opts = OpenOptions::new();
    #[cfg(unix)]
    opts.mode(0o600);
    write_to_file_with_opts(path, name, bytes, &mut opts)
}
```

**File:** crates/aptos/src/common/utils.rs (L238-246)
```rust
    let mut file = opts
        .write(true)
        .create(true)
        .truncate(true)
        .open(path)
        .map_err(|e| CliError::IO(name.to_string(), e))?;
    file.write_all(bytes)
        .map_err(|e| CliError::IO(name.to_string(), e))
}
```

**File:** crates/aptos/src/genesis/keys.rs (L82-97)
```rust
        write_to_user_only_file(
            private_keys_file.as_path(),
            PRIVATE_KEYS_FILE,
            to_yaml(&private_identity)?.as_bytes(),
        )?;
        write_to_user_only_file(
            public_keys_file.as_path(),
            PUBLIC_KEYS_FILE,
            to_yaml(&public_identity)?.as_bytes(),
        )?;
        write_to_user_only_file(
            validator_file.as_path(),
            VALIDATOR_FILE,
            to_yaml(&validator_blob)?.as_bytes(),
        )?;
        write_to_user_only_file(vfn_file.as_path(), VFN_FILE, to_yaml(&vfn_blob)?.as_bytes())?;
```
