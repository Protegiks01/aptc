# Audit Report

## Title
Authentication Bypass via X_IS_JWT_HEADER Header Injection in Aptos Faucet

## Summary
The `X_IS_JWT_HEADER` constant can be exploited to completely bypass authentication in the Aptos faucet when it is configured with `AuthTokenChecker` (requiring bearer tokens) and IP-based rate limiting. An attacker can inject the `x-is-jwt: true` header without providing valid credentials, causing the auth token checker to skip validation while no other component validates the JWT.

## Finding Description
The vulnerability exists in the authentication logic coordination between multiple faucet checkers. The `AuthTokenChecker` is designed to validate bearer tokens in the `Authorization` header. However, it contains a special case where it skips validation entirely when the `X_IS_JWT_HEADER` ("x-is-jwt") is present: [1](#0-0) 

The design assumption is that when `X_IS_JWT_HEADER` is present, JWT validation will occur in the `RedisRatelimitChecker` when configured for JWT-based rate limiting: [2](#0-1) 

**However**, if the `RedisRatelimitChecker` is configured with IP-based rate limiting (the default), it never calls `validate_jwt()`: [3](#0-2) 

This creates an authentication gap. The JWT validation in `FirebaseJwtVerifier.validate_jwt()` only executes when explicitly called by the JWT-based rate limiter: [4](#0-3) 

**Attack Path:**
1. Faucet is configured with `AuthTokenChecker` (requires valid auth tokens) AND `RedisRatelimitChecker` with IP-based rate limiting
2. Attacker sends request to `/fund` endpoint with `x-is-jwt: true` header
3. Attacker provides NO valid auth token or JWT
4. `AuthTokenChecker.check()` sees the header and returns early without validation
5. `RedisRatelimitChecker` uses IP-based limiting, never validates JWT
6. Request passes all checkers and funds are dispensed

The `AuthTokenBypasser` also returns false when this header is present, preventing legitimate bypass mechanisms: [5](#0-4) 

## Impact Explanation
This vulnerability qualifies as **HIGH severity** per the Aptos bug bounty program criteria:

- **Authentication Bypass**: Complete circumvention of the auth token requirement
- **Unauthorized Fund Access**: Attacker can drain faucet funds without valid credentials
- **Limited Funds Loss**: Attacker is only constrained by IP-based rate limiting, which can be bypassed using multiple IP addresses (VPN, proxies, botnets)
- **Access Control Violation**: Breaks the fundamental security invariant that authentication must be enforced when configured

The CORS configuration allows credentials but doesn't restrict origins, potentially enabling cross-origin attacks: [6](#0-5) 

While this is not a consensus-level vulnerability, it represents a significant protocol violation in the faucet authentication system, enabling unauthorized resource access.

## Likelihood Explanation
**Likelihood: HIGH**

This vulnerability is highly likely to be exploited because:
- **Low Complexity**: Attack requires only adding a single HTTP header
- **No Authentication Required**: Attacker needs no valid credentials
- **Common Configuration**: Many faucet deployments use IP-based rate limiting (the default) with auth token requirements
- **Easy Discovery**: The header name is a public constant visible in the codebase
- **High Value Target**: Faucets hold significant funds for testnet/devnet operations
- **Scalable Attack**: Multiple IPs can be used to amplify the attack

## Recommendation
**Immediate Fix**: The `AuthTokenChecker` should NOT skip validation based solely on the presence of `X_IS_JWT_HEADER`. Instead:

1. **Option A** (Recommended): Remove the early return and always validate auth tokens when `AuthTokenChecker` is configured:
```rust
async fn check(&self, data: CheckerData, _dry_run: bool) -> Result<Vec<RejectionReason>, AptosTapError> {
    // Remove the X_IS_JWT_HEADER bypass - always check auth tokens
    let auth_token = match data.headers.get(AUTHORIZATION)...
```

2. **Option B**: Create a dedicated `JwtChecker` that always validates JWTs when configured, independent of rate limiting:
```rust
pub struct JwtChecker {
    pub jwt_verifier: FirebaseJwtVerifier,
}

impl CheckerTrait for JwtChecker {
    async fn check(&self, data: CheckerData, _dry_run: bool) -> Result<Vec<RejectionReason>, AptosTapError> {
        self.jwt_verifier.validate_jwt(data.headers).await?;
        Ok(vec![])
    }
}
```

3. **Option C**: Make `AuthTokenChecker` verify that JWT validation will actually occur before skipping:
```rust
// Only skip if JWT checker is actually enabled in the configuration
if data.headers.contains_key(X_IS_JWT_HEADER) && self.jwt_validation_enabled {
    return Ok(vec![]);
}
```

**Additional Hardening**:
- Explicitly set `allow_origin` in CORS configuration to restrict cross-origin requests
- Add integration tests validating the authentication flow with different checker combinations
- Document the security dependency between `AuthTokenChecker` and JWT-based rate limiting

## Proof of Concept

**Exploitation Steps**:

```bash
# Assume faucet is running at http://faucet.example.com
# Configured with AuthTokenChecker + IP-based RedisRatelimitChecker

# 1. Normal request WITHOUT bypass - should fail with auth token error
curl -X POST http://faucet.example.com/fund \
  -H "Content-Type: application/json" \
  -d '{"address": "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"}'
# Expected: 403 - "The given auth token is not allowed by the server"

# 2. Attack request WITH x-is-jwt header - bypasses authentication
curl -X POST http://faucet.example.com/fund \
  -H "Content-Type: application/json" \
  -H "x-is-jwt: true" \
  -d '{"address": "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"}'
# Expected: 200 - Funds successfully transferred!

# 3. Amplify attack with multiple IPs (use VPN/proxies to bypass IP rate limits)
for ip in proxy1 proxy2 proxy3; do
  curl -X POST http://faucet.example.com/fund \
    --proxy $ip \
    -H "Content-Type: application/json" \
    -H "x-is-jwt: true" \
    -d '{"address": "0xATTACKER_ADDRESS"}'
done
```

**Test Configuration** (vulnerable setup):
```yaml
checker_configs:
  - type: AuthToken
    # Requires valid auth tokens
    file_path: /path/to/auth_tokens.txt
  - type: RedisRatelimit
    # IP-based rate limiting (vulnerable config)
    database_address: redis.example.com
    max_requests_per_day: 10
    # Note: ratelimit_key_provider_config defaults to "Ip"
```

The vulnerability is triggered because the configuration uses IP-based rate limiting while requiring auth tokens, creating the authentication bypass condition.

## Notes
This vulnerability specifically affects the Aptos faucet service and does not impact consensus, Move VM execution, or core blockchain operations. However, it represents a significant access control failure that could result in substantial fund loss from faucet deployments. The issue arises from a coordination failure between authentication checkers rather than a single code defect, making it particularly subtle and likely to have evaded previous security reviews.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/auth_token.rs (L37-40)
```rust
        // Don't check if the request has X_IS_JWT_HEADER set.
        if data.headers.contains_key(X_IS_JWT_HEADER) {
            return Ok(vec![]);
        }
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L18-24)
```rust
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(tag = "type")]
pub enum RatelimitKeyProviderConfig {
    #[default]
    Ip,
    Jwt(FirebaseJwtVerifierConfig),
}
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L40-51)
```rust
    /// If the faucet is configured to ratelimit by IP, this will be the client's IP
    /// address. If the faucet is configured to ratelimit by JWT, we verify the JWT
    /// first. If it is valid, this will be the user's Firebase UID (taken from the
    /// JWT's `sub` field).
    pub async fn ratelimit_key_value(&self, data: &CheckerData) -> Result<String, AptosTapError> {
        match self {
            RatelimitKeyProvider::Ip => Ok(data.source_ip.to_string()),
            RatelimitKeyProvider::Jwt(jwt_verifier) => {
                jwt_verifier.validate_jwt(data.headers.clone()).await
            },
        }
    }
```

**File:** crates/aptos-faucet/core/src/firebase_jwt.rs (L41-64)
```rust
    pub async fn validate_jwt(&self, headers: Arc<HeaderMap>) -> Result<String, AptosTapError> {
        let auth_token = jwt_sub(headers)?;

        let verify = self.jwt_verifier.verify::<JwtClaims>(&auth_token);
        let token_data = match verify.await {
            Some(token_data) => token_data,
            None => {
                return Err(AptosTapError::new(
                    "Failed to verify JWT token".to_string(),
                    AptosTapErrorCode::AuthTokenInvalid,
                ));
            },
        };
        let claims = token_data.claims;

        if !claims.email_verified {
            return Err(AptosTapError::new(
                "The JWT token is not verified".to_string(),
                AptosTapErrorCode::AuthTokenInvalid,
            ));
        }

        Ok(claims.sub)
    }
```

**File:** crates/aptos-faucet/core/src/bypasser/auth_token.rs (L33-36)
```rust
        // Don't check if the request has X_IS_JWT_HEADER set.
        if data.headers.contains_key(X_IS_JWT_HEADER) {
            return Ok(false);
        }
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L175-180)
```rust
        let cors = Cors::new()
            // To allow browsers to use cookies (for cookie-based sticky
            // routing in the LB) we must enable this:
            // https://stackoverflow.com/a/24689738/3846032
            .allow_credentials(true)
            .allow_methods(vec![Method::GET, Method::POST]);
```
