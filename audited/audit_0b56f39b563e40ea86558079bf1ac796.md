# Audit Report

## Title
Unbounded Line Length Memory Exhaustion DoS in Faucet IP Range Manager

## Summary
The `IpRangeManager::new()` function uses `BufReader::lines()` without line length limits, allowing an attacker who controls the IP list file to cause memory exhaustion and crash the faucet service during startup by providing a file with extremely long lines (millions of characters without newlines).

## Finding Description

The vulnerability exists in the IP range file parsing logic. [1](#0-0) 

When `BufReader::lines()` is called, it internally uses `read_line()` which continues reading and appending to a String buffer until it encounters a newline (`\n`) or EOF. If a malicious file contains a single line with millions or billions of characters without any newline character, the entire line will be loaded into memory at once, causing unbounded memory allocation.

This affects both:
1. **IP Allowlist Bypasser** - loaded during server initialization [2](#0-1) 
2. **IP Blocklist Checker** - loaded during server initialization [3](#0-2) 

The file path is specified via configuration [4](#0-3)  and loaded during server startup [5](#0-4) 

Additionally, the same vulnerability exists in `ListManager` used for auth tokens and referer blocklists: [6](#0-5) 

## Impact Explanation

This is classified as **High Severity** under the Aptos Bug Bounty program criteria for "API crashes". The faucet service provides critical onboarding functionality for developers and users to acquire testnet tokens. A successful attack causes:

1. **Complete Service Unavailability** - The faucet crashes during startup and cannot serve any requests
2. **Resource Exhaustion** - Out-of-Memory (OOM) crash affecting the host system
3. **Persistent DoS** - The service cannot restart until the malicious file is removed

## Likelihood Explanation

The likelihood depends on the deployment configuration:

**MEDIUM-HIGH Likelihood** if:
- The faucet service automatically downloads/updates IP blocklists from external sources
- There's an administrative interface to upload IP lists
- The configuration allows reading from network paths or user-controlled directories
- Configuration injection vulnerabilities exist elsewhere that could modify file paths

**LOW Likelihood** if:
- IP list files are strictly operator-controlled and manually reviewed
- File system access is properly restricted
- No automated update mechanisms exist

However, defense-in-depth principles dictate that input validation should occur regardless of trust assumptions about the file source.

## Recommendation

Implement line length limits when reading configuration files:

```rust
use std::io::{BufRead, BufReader};

const MAX_LINE_LENGTH: usize = 1024; // Reasonable limit for IP ranges

pub fn new(config: IpRangeManagerConfig) -> Result<Self> {
    let file = File::open(&config.file)
        .with_context(|| format!("Failed to open {}", config.file.to_string_lossy()))?;

    let mut ipv4_list = IpRange::<Ipv4Net>::new();
    let mut ipv6_list = IpRange::<Ipv6Net>::new();
    
    let reader = BufReader::new(file);
    for (line_num, line_result) in reader.lines().enumerate() {
        let line = line_result?;
        
        // Validate line length
        if line.len() > MAX_LINE_LENGTH {
            bail!(
                "Line {} exceeds maximum length of {} characters (got {})",
                line_num + 1,
                MAX_LINE_LENGTH,
                line.len()
            );
        }
        
        if line.starts_with('#') || line.starts_with("//") || line.is_empty() {
            continue;
        }
        
        match line.parse::<Ipv4Net>() {
            Ok(ipv4_net) => ipv4_list.add(ipv4_net),
            Err(_) => match line.parse::<Ipv6Net>() {
                Ok(ipv6_net) => ipv6_list.add(ipv6_net),
                Err(_) => bail!("Failed to parse line {} as IPv4 or IPv6 range: {}", line_num + 1, line),
            },
        }
    }
    Ok(Self { ipv4_list, ipv6_list })
}
```

Apply the same fix to `ListManager::new()` in `list_manager.rs`.

## Proof of Concept

Create a malicious IP list file and test the faucet startup:

```bash
# Create a malicious IP list file with 10MB line without newline
python3 -c "print('A' * 10000000, end='')" > /tmp/malicious_ip_list.txt

# Create faucet config pointing to malicious file
cat > /tmp/faucet_config.yaml << EOF
server_config:
  listen_address: "0.0.0.0"
  listen_port: 8081
  api_path_base: ""

metrics_server_config:
  disable: true

bypasser_configs:
  - type: IpAllowlist
    file: /tmp/malicious_ip_list.txt

checker_configs: []

funder_config:
  type: MintFunder
  # ... (rest of config)

handler_config:
  use_helpful_errors: true
  return_rejections_early: false
  max_concurrent_requests: null
EOF

# Attempt to start faucet - will crash with OOM
cargo run --bin aptos-faucet-service -- run --config-path /tmp/faucet_config.yaml
```

Expected result: The service crashes with memory allocation error during startup when attempting to read the malicious file.

## Notes

This vulnerability also affects `ListManager` which is used for auth token and referer blocklist files, making it exploitable through multiple configuration vectors. All file-based configuration loading should implement size limits and validation.

### Citations

**File:** crates/aptos-faucet/core/src/common/ip_range_manager.rs (L12-16)
```rust
pub struct IpRangeManagerConfig {
    /// Path to a file containing one IP range per line, where an IP range is
    /// something like 32.143.133.32/24.
    pub file: PathBuf,
}
```

**File:** crates/aptos-faucet/core/src/common/ip_range_manager.rs (L30-31)
```rust
        for line in std::io::BufReader::new(file).lines() {
            let line = line?;
```

**File:** crates/aptos-faucet/core/src/bypasser/ip_allowlist.rs (L17-20)
```rust
    pub fn new(config: IpRangeManagerConfig) -> Result<Self> {
        Ok(Self {
            manager: IpRangeManager::new(config)?,
        })
```

**File:** crates/aptos-faucet/core/src/checkers/ip_blocklist.rs (L18-21)
```rust
    pub fn new(config: IpRangeManagerConfig) -> Result<Self> {
        Ok(Self {
            manager: IpRangeManager::new(config)?,
        })
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L114-139)
```rust
        // Build Bypassers.
        let mut bypassers: Vec<Bypasser> = Vec::new();
        for bypasser_config in &self.bypasser_configs {
            let bypasser = bypasser_config.clone().build().with_context(|| {
                format!("Failed to build Bypasser with args: {:?}", bypasser_config)
            })?;
            bypassers.push(bypasser);
        }

        // Create a periodic task manager.
        let mut join_set = JoinSet::new();

        // Build Checkers and let them spawn tasks on the periodic task
        // manager if they want.
        let mut checkers: Vec<Checker> = Vec::new();
        for checker_config in &self.checker_configs {
            let checker = checker_config
                .clone()
                .build(captcha_manager.clone())
                .await
                .with_context(|| {
                    format!("Failed to build Checker with args: {:?}", checker_config)
                })?;
            checker.spawn_periodic_tasks(&mut join_set);
            checkers.push(checker);
        }
```

**File:** crates/aptos-faucet/core/src/common/list_manager.rs (L25-26)
```rust
        for line in std::io::BufReader::new(file).lines() {
            let line = line?;
```
