# Audit Report

## Title
Unvalidated Quorum Certificates Allow Consensus State Corruption During Fast Forward Sync

## Summary
During state synchronization, blocks retrieved from untrusted peers contain embedded quorum certificates (QCs) that are never cryptographically validated. These unvalidated QCs are used to construct the consensus root, allowing an attacker to inject dummy or malicious consensus state that bypasses signature verification. The `build()` function explicitly permits QCs with placeholder values (`ACCUMULATOR_PLACEHOLDER_HASH` and `version==0`), accepting unverified consensus foundations.

## Finding Description

The vulnerability exists in the state sync recovery path where consensus rebuilds its block tree after falling behind. The attack exploits the absence of signature verification on quorum certificates embedded in blocks retrieved from peers.

**Attack Flow:**

1. Victim node falls behind and receives `SyncInfo` from peers
2. The `SyncInfo` contains validated `highest_quorum_cert` and `highest_commit_cert` (with proper signatures) [1](#0-0) 

3. Victim calls `fast_forward_sync()` and retrieves blocks from attacker-controlled peers [2](#0-1) 

4. Blocks' embedded QCs are extracted **without signature validation** [3](#0-2) 

5. Unvalidated blocks and QCs are persisted to consensusdb [4](#0-3) 

6. State sync executes to sync the ledger (this validates execution state but NOT consensus blocks) [5](#0-4) 

7. `storage.start()` reloads blocks and QCs from consensusdb (the unvalidated ones) [6](#0-5) 

8. `find_root()` locates the commit block and searches for its QC in the unvalidated quorum_certs list [7](#0-6) 

9. The `root_qc` from unvalidated sources is used to rebuild the block tree

10. `build()` accepts the unvalidated QC because it allows dummy values [8](#0-7) 

**Key Vulnerability Points:**

The `build()` function permits QCs with dummy execution state:
- `version == 0` (dummy version)
- `executed_state_id == ACCUMULATOR_PLACEHOLDER_HASH` (dummy state) [8](#0-7) 

The `insert_single_quorum_cert()` function only validates that QC block info matches using `match_ordered_only()`, which **does not check signatures or execution state**: [9](#0-8) 

The `match_ordered_only()` method only compares epoch, round, id, and timestamp—not version or executed_state_id: [10](#0-9) 

**Why Signature Validation is Missing:**

While `QuorumCert::verify()` exists and validates signatures: [11](#0-10) 

This method is **never called** on QCs extracted from retrieved blocks during the fast forward sync path. Normal proposal processing calls `ProposalMsg::verify()` which validates signatures, but the sync path bypasses this.

## Impact Explanation

**Severity: Critical** (Consensus Safety Violation)

This vulnerability breaks the fundamental consensus safety guarantee that all nodes must agree on a cryptographically verified chain. The impacts include:

1. **Consensus State Corruption**: The node's consensus layer operates on an unverified foundation. The root QC has no cryptographic proof that validators agreed on it.

2. **Safety Invariant Violation**: AptosBFT's safety property requires that committed blocks are certified by a quorum of validators. Accepting unverified QCs violates this invariant.

3. **Chain Inconsistency**: Different nodes could have different views of consensus history if they sync from different malicious peers, potentially leading to chain splits.

4. **Future Block Validation Impact**: New blocks build on the unverified root, propagating the corruption through the chain.

5. **Execution-Consensus Decoupling Attack**: The dummy state values (`version=0`, `PLACEHOLDER_HASH`) mean the consensus state is not properly linked to execution state, even though the ledger itself is correct after state sync.

This qualifies as **Critical Severity** under Aptos bug bounty criteria as it represents a consensus safety violation that could lead to network-wide inconsistencies.

## Likelihood Explanation

**Likelihood: Medium-High**

- **Attacker Requirements**: Attacker must control one or more peers that the victim contacts during block retrieval. This is achievable through network manipulation or by running malicious validator nodes.

- **Trigger Conditions**: Vulnerability triggers whenever a node falls behind and performs fast forward sync, which is a normal operational scenario (node restarts, network partitions, catching up after downtime).

- **Detection Difficulty**: The attack is subtle because state sync completes successfully and the ledger appears correct. Only the consensus layer's internal state is corrupted.

- **No Privileged Access Required**: The attack requires no validator keys or insider access—just the ability to respond to block retrieval requests with malicious data.

## Recommendation

**Immediate Fix**: Add signature validation for all quorum certificates extracted from blocks during fast forward sync, before persisting them to storage.

**Code Fix**:

In `consensus/src/block_storage/sync_manager.rs`, add validation after extracting QCs from blocks:

```rust
// After line 411, add:
let validator = /* obtain ValidatorVerifier from epoch_state */;
for qc in quorum_certs.iter().skip(1) { // Skip first as it's already validated highest_quorum_cert
    qc.verify(validator)
        .with_context(|| format!("Failed to verify QC from retrieved block: {}", qc))?;
}
```

**Alternative Fix**: Validate QCs during insertion:

In `consensus/src/block_storage/block_store.rs`, modify `insert_single_quorum_cert()`:

```rust
pub fn insert_single_quorum_cert(&self, qc: QuorumCert, validator: &ValidatorVerifier) -> anyhow::Result<()> {
    // Add signature verification
    if qc.certified_block().round() > 0 { // Skip genesis
        qc.verify(validator)
            .context("QC signature verification failed")?;
    }
    // ... rest of existing code
}
```

**Defense in Depth**: 
1. Validate block chains form valid parent-child relationships
2. Cross-reference retrieved blocks against ledger state when possible
3. Add metrics to detect QCs with dummy values being used as roots
4. Consider requiring explicit flag to allow dummy QCs only in development/testing

## Proof of Concept

**Setup**:
1. Run an Aptos network with honest validators
2. Set up a victim validator node
3. Set up an attacker-controlled peer node

**Attack Steps**:

```rust
// Attacker's malicious block retrieval response handler
async fn malicious_block_retrieval_handler(request: BlockRetrievalRequest) -> BlockRetrievalResponse {
    // Get the real blocks from storage
    let mut blocks = fetch_real_blocks_from_storage(request.block_id(), request.num_blocks());
    
    // Replace embedded QCs with dummy QCs
    for block in &mut blocks[1..] { // Skip first block to maintain chain
        let dummy_qc = create_dummy_qc(
            block.parent_id(),
            0, // version = 0
            *ACCUMULATOR_PLACEHOLDER_HASH, // dummy state
            /* No valid signatures */
        );
        block.replace_quorum_cert(dummy_qc);
    }
    
    BlockRetrievalResponse::new(BlockRetrievalStatus::Succeeded, blocks)
}

// Victim node performs fast_forward_sync
// After sync completes, check root_qc:
let root_qc = block_store.commit_root().qc();
assert_eq!(root_qc.certified_block().version(), 0); // VULNERABLE: Dummy version accepted
assert_eq!(root_qc.certified_block().executed_state_id(), *ACCUMULATOR_PLACEHOLDER_HASH); // VULNERABLE: Dummy state accepted
assert!(root_qc.ledger_info().get_num_voters() == 0); // VULNERABLE: No signatures!
```

**Verification**:
1. Observe that victim node completes state sync successfully
2. Observe that victim's ledger state is correct (state sync worked)
3. Observe that victim's consensus root QC has dummy values
4. Observe that victim's consensus root QC has no valid signatures
5. Demonstrate that the victim's consensus layer is operating on unverified state

## Notes

The vulnerability exists because the decoupled execution feature allows "ordered-only" blocks with dummy values during normal operation. However, the code fails to distinguish between:
- Legitimate ordered-only QCs created by validators with proper signatures
- Malicious dummy QCs injected by attackers without any signatures

The assertions in `build()` accept both cases equally, creating the security gap. The fix must preserve the decoupled execution feature while ensuring all QCs used as consensus roots have valid cryptographic proofs.

### Citations

**File:** consensus/src/recovery_manager.rs (L85-85)
```rust
        sync_info.verify(&self.epoch_state.verifier)?;
```

**File:** consensus/src/block_storage/sync_manager.rs (L394-403)
```rust
        let mut blocks = retriever
            .retrieve_blocks_in_range(
                highest_quorum_cert.certified_block().id(),
                num_blocks,
                target_block_retrieval_payload,
                highest_quorum_cert
                    .ledger_info()
                    .get_voters(&retriever.validator_addresses()),
            )
            .await?;
```

**File:** consensus/src/block_storage/sync_manager.rs (L405-411)
```rust
        let mut quorum_certs = vec![highest_quorum_cert.clone()];
        quorum_certs.extend(
            blocks
                .iter()
                .take(blocks.len() - 1)
                .map(|block| block.quorum_cert().clone()),
        );
```

**File:** consensus/src/block_storage/sync_manager.rs (L503-503)
```rust
        storage.save_tree(blocks.clone(), quorum_certs.clone())?;
```

**File:** consensus/src/block_storage/sync_manager.rs (L512-514)
```rust
        execution_client
            .sync_to_target(highest_commit_cert.ledger_info().clone())
            .await?;
```

**File:** consensus/src/persistent_liveness_storage.rs (L139-143)
```rust
        let commit_block_quorum_cert = quorum_certs
            .iter()
            .find(|qc| qc.certified_block().id() == commit_block.id())
            .ok_or_else(|| format_err!("No QC found for root: {}", commit_block.id()))?
            .clone();
```

**File:** consensus/src/persistent_liveness_storage.rs (L533-534)
```rust
        let blocks = raw_data.2;
        let quorum_certs: Vec<_> = raw_data.3;
```

**File:** consensus/src/block_storage/block_store.rs (L193-208)
```rust
        assert!(
            // decoupled execution allows dummy versions
            root_qc.certified_block().version() == 0
                || root_qc.certified_block().version() == root_metadata.version(),
            "root qc version {} doesn't match committed trees {}",
            root_qc.certified_block().version(),
            root_metadata.version(),
        );
        assert!(
            // decoupled execution allows dummy executed_state_id
            root_qc.certified_block().executed_state_id() == *ACCUMULATOR_PLACEHOLDER_HASH
                || root_qc.certified_block().executed_state_id() == root_metadata.accu_hash,
            "root qc state id {} doesn't match committed trees {}",
            root_qc.certified_block().executed_state_id(),
            root_metadata.accu_hash,
        );
```

**File:** consensus/src/block_storage/block_store.rs (L527-536)
```rust
                ensure!(
                    // decoupled execution allows dummy block infos
                    pipelined_block
                        .block_info()
                        .match_ordered_only(qc.certified_block()),
                    "QC for block {} has different {:?} than local {:?}",
                    qc.certified_block().id(),
                    qc.certified_block(),
                    pipelined_block.block_info()
                );
```

**File:** types/src/block_info.rs (L196-204)
```rust
    pub fn match_ordered_only(&self, executed_block_info: &BlockInfo) -> bool {
        self.epoch == executed_block_info.epoch
            && self.round == executed_block_info.round
            && self.id == executed_block_info.id
            && (self.timestamp_usecs == executed_block_info.timestamp_usecs
            // executed block info has changed its timestamp because it's a reconfiguration suffix
                || (self.timestamp_usecs > executed_block_info.timestamp_usecs
                    && executed_block_info.has_reconfiguration()))
    }
```

**File:** consensus/consensus-types/src/quorum_cert.rs (L119-148)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        let vote_hash = self.vote_data.hash();
        ensure!(
            self.ledger_info().ledger_info().consensus_data_hash() == vote_hash,
            "Quorum Cert's hash mismatch LedgerInfo"
        );
        // Genesis's QC is implicitly agreed upon, it doesn't have real signatures.
        // If someone sends us a QC on a fake genesis, it'll fail to insert into BlockStore
        // because of the round constraint.
        if self.certified_block().round() == 0 {
            ensure!(
                self.parent_block() == self.certified_block(),
                "Genesis QC has inconsistent parent block with certified block"
            );
            ensure!(
                self.certified_block() == self.ledger_info().ledger_info().commit_info(),
                "Genesis QC has inconsistent commit block with certified block"
            );
            ensure!(
                self.ledger_info().get_num_voters() == 0,
                "Genesis QC should not carry signatures"
            );
            return Ok(());
        }
        self.ledger_info()
            .verify_signatures(validator)
            .context("Fail to verify QuorumCert")?;
        self.vote_data.verify()?;
        Ok(())
    }
```
