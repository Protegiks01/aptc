# Audit Report

## Title
PostgreSQL Credential Leakage via Ready Server Health Check Endpoint Serialization

## Summary
The `HealthChecker` enum derives `Serialize` and is exposed through the ready server HTTP endpoint, leaking PostgreSQL connection strings containing plaintext passwords to any client that queries the `/` endpoint.

## Finding Description

The vulnerability exists in the local testnet's health checking system. The `HealthChecker` enum contains database connection strings with embedded credentials, and these are serialized to JSON and transmitted over HTTP without sanitization.

**Vulnerability Flow:**

1. The `HealthChecker` enum derives `Serialize` without any custom serialization logic: [1](#0-0) 

2. PostgreSQL connection strings are constructed with passwords when `--host-postgres-password` is provided: [2](#0-1) 

3. These connection strings (containing passwords) are stored in `HealthChecker::Postgres` and `HealthChecker::Processor` variants: [3](#0-2) [4](#0-3) 

4. All health checkers are collected and passed to the ready server: [5](#0-4) 

5. The ready server serializes these health checkers to JSON and sends them over HTTP: [6](#0-5) 

When a client queries `GET http://<bind_address>:8070/`, they receive JSON containing entries like:
```json
{
  "ready": [
    {
      "Postgres": "postgres://user:SECRET_PASSWORD@host:5432/db"
    },
    {
      "Processor": ["postgres://user:SECRET_PASSWORD@host:5432/db", "processor_name"]
    }
  ]
}
```

## Impact Explanation

This is a **Medium severity** information disclosure vulnerability per Aptos bug bounty criteria. While it affects local testnet tooling rather than production validators, it results in credential leakage with the following consequences:

- **Unauthorized Database Access**: Attackers can extract PostgreSQL credentials and connect to the database, potentially accessing or modifying indexer data
- **Credential Reuse Risk**: Developers may use similar passwords across environments, enabling lateral movement
- **Data Exfiltration**: The indexed blockchain data in the database could contain sensitive information depending on the testing scenario

The severity is Medium rather than Low because:
1. It exposes authentication credentials (not just metadata)
2. The leaked credentials enable concrete follow-up attacks
3. The ready server can be network-accessible when running in containers (binds to 0.0.0.0) or with `--bind-to`

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability is exploitable when:
1. Developer runs local testnet with `--with-indexer-api` and `--use-host-postgres`
2. Developer provides `--host-postgres-password <password>` (required for external DB connections)
3. Ready server is network-accessible (automatic in containers, or via `--bind-to 0.0.0.0`)
4. Attacker can reach the ready server endpoint

This scenario is common in containerized development environments where services default to binding 0.0.0.0 for accessibility. The ready server is explicitly designed to be queryable for health status, making it a natural target for reconnaissance.

## Recommendation

Implement custom serialization for `HealthChecker` that sanitizes sensitive fields:

```rust
// In health_checker.rs, replace the Serialize derive with a custom implementation

impl Serialize for HealthChecker {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        use serde::ser::SerializeMap;
        
        match self {
            HealthChecker::Http(url, name) => {
                let mut map = serializer.serialize_map(Some(1))?;
                map.serialize_entry("Http", &(url.as_str(), name))?;
                map.end()
            }
            HealthChecker::NodeApi(url) => {
                let mut map = serializer.serialize_map(Some(1))?;
                map.serialize_entry("NodeApi", url.as_str())?;
                map.end()
            }
            HealthChecker::DataServiceGrpc(url) => {
                let mut map = serializer.serialize_map(Some(1))?;
                map.serialize_entry("DataServiceGrpc", url.as_str())?;
                map.end()
            }
            HealthChecker::Postgres(_connection_string) => {
                let mut map = serializer.serialize_map(Some(1))?;
                map.serialize_entry("Postgres", "[REDACTED]")?;
                map.end()
            }
            HealthChecker::Processor(_connection_string, processor_name) => {
                let mut map = serializer.serialize_map(Some(1))?;
                map.serialize_entry("Processor", &("[REDACTED]", processor_name))?;
                map.end()
            }
            HealthChecker::IndexerApiMetadata(url) => {
                let mut map = serializer.serialize_map(Some(1))?;
                map.serialize_entry("IndexerApiMetadata", url.as_str())?;
                map.end()
            }
        }
    }
}
```

Alternatively, remove the `Serialize` derive entirely if the ready server doesn't need to expose health checker details to clients, instead only returning a simple ready/not-ready boolean status.

## Proof of Concept

**Steps to Reproduce:**

1. Start local testnet with external PostgreSQL:
```bash
aptos node run-local-testnet \
  --with-indexer-api \
  --use-host-postgres \
  --host-postgres-password "MySecretPassword123" \
  --bind-to 0.0.0.0
```

2. Query the ready server endpoint:
```bash
curl http://localhost:8070/
```

3. Observe the response contains plaintext credentials:
```json
{
  "ready": [
    {
      "Postgres": "postgres://postgres:MySecretPassword123@127.0.0.1:5432/local_testnet"
    },
    {
      "Processor": [
        "postgres://postgres:MySecretPassword123@127.0.0.1:5432/local_testnet",
        "default_processor"
      ]
    }
  ],
  "not_ready": []
}
```

4. Use the leaked credentials to connect:
```bash
psql "postgres://postgres:MySecretPassword123@127.0.0.1:5432/local_testnet"
```

**Notes**
This vulnerability only affects local testnet environments, not production validators. However, it represents a security best practice violation (credential exposure) that could impact developers using production-like credentials in testing, or in scenarios where the local testnet database contains sensitive test data. The fix is straightforward and should be implemented to prevent accidental credential leakage.

### Citations

**File:** crates/aptos/src/node/local_testnet/health_checker.rs (L24-42)
```rust
#[derive(Clone, Debug, Eq, Hash, PartialEq, Serialize)]
pub enum HealthChecker {
    /// Check that a HTTP API is up. The second param is the name of the HTTP service.
    Http(Url, String),
    /// Check that the node API is up. This is just a specific case of Http for extra
    /// guarantees around liveliness.
    NodeApi(Url),
    /// Check that a data service GRPC stream is up.
    DataServiceGrpc(Url),
    /// Check that a postgres instance is up.
    Postgres(String),
    /// Check that a processor is successfully processing txns. The first value is the
    /// postgres connection string. The second is the name of the processor. We check
    /// the that last_success_version in the processor_status table is present and > 0.
    Processor(String, String),
    /// Check that the indexer API is up and the metadata has been applied. We only use
    /// this one in the ready server.
    IndexerApiMetadata(Url),
}
```

**File:** crates/aptos/src/node/local_testnet/postgres.rs (L92-116)
```rust
    pub fn get_connection_string(&self, database: Option<&str>, external: bool) -> String {
        let password = match self.use_host_postgres {
            true => match &self.host_postgres_password {
                Some(password) => format!(":{}", password),
                None => "".to_string(),
            },
            false => "".to_string(),
        };
        let port = self.get_postgres_port(external);
        let database = match database {
            Some(database) => database,
            None => &self.postgres_database,
        };
        let host = match self.use_host_postgres {
            true => &self.host_postgres_host,
            false => match external {
                true => "127.0.0.1",
                false => POSTGRES_CONTAINER_NAME,
            },
        };
        format!(
            "postgres://{}{}@{}:{}/{}",
            self.postgres_user, password, host, port, database,
        )
    }
```

**File:** crates/aptos/src/node/local_testnet/postgres.rs (L210-214)
```rust
    fn get_health_checkers(&self) -> HashSet<HealthChecker> {
        hashset! {HealthChecker::Postgres(
            self.args.get_connection_string(None, true),
        )}
    }
```

**File:** crates/aptos/src/node/local_testnet/processors.rs (L155-166)
```rust
    fn get_health_checkers(&self) -> HashSet<HealthChecker> {
        let connection_string = match &self.config.db_config {
            DbConfig::PostgresConfig(postgres_config) => postgres_config.connection_string.clone(),
            DbConfig::ParquetConfig(_) => {
                panic!("Parquet is not supported in the localnet");
            },
        };
        hashset! {HealthChecker::Processor(
            connection_string,
            self.config.processor_config.name().to_string(),
        ) }
    }
```

**File:** crates/aptos/src/node/local_testnet/mod.rs (L352-363)
```rust
        let health_checkers: HashSet<HealthChecker> = managers
            .iter()
            .flat_map(|m| m.get_health_checkers())
            .collect();

        // The final manager we add is the ready server. This must happen last since
        // it use the health checkers from all the other services.
        managers.push(Box::new(ReadyServerManager::new(
            &self,
            bind_to,
            health_checkers.clone(),
        )?));
```

**File:** crates/aptos/src/node/local_testnet/ready_server.rs (L104-131)
```rust
#[derive(Serialize)]
struct ReadyData {
    pub ready: Vec<HealthChecker>,
    pub not_ready: Vec<HealthChecker>,
}

#[handler]
async fn root(health_checkers: Data<&HealthCheckers>) -> impl IntoResponse + use<> {
    let mut ready = vec![];
    let mut not_ready = vec![];
    for health_checker in &health_checkers.health_checkers {
        // Use timeout since some of these checks can take quite a while if the
        // underlying service is not ready. This is best effort of course, see the docs
        // for tokio::time::timeout for more information.
        match timeout(Duration::from_secs(3), health_checker.check()).await {
            Ok(Ok(())) => ready.push(health_checker.clone()),
            _ => {
                not_ready.push(health_checker.clone());
            },
        }
    }
    let status_code = if not_ready.is_empty() {
        StatusCode::OK
    } else {
        StatusCode::SERVICE_UNAVAILABLE
    };
    Json(ReadyData { ready, not_ready }).with_status(status_code)
}
```
