# Audit Report

## Title
Validator Node Crash Due to Non-Atomic PartialStateComputeResult Updates in Block Executor with Retry Logic

## Summary
The `ledger_update` function in the block executor sets two `OnceCell` fields of `PartialStateComputeResult` sequentially without atomicity. If the first succeeds but the second fails, subsequent retry attempts panic with "StateCheckpointOutput already set", causing validator node crashes and loss of liveness.

## Finding Description

The vulnerability exists in the block executor's ledger update workflow where `PartialStateComputeResult` contains two `OnceCell` fields that must be set together atomically, but are actually set sequentially with fallible operations in between. [1](#0-0) 

These `OnceCell` fields provide interior mutability and panic when set twice: [2](#0-1) [3](#0-2) 

The critical vulnerability occurs in the `ledger_update` function where blocks stored in the block tree are updated: [4](#0-3) 

**Attack Scenario:**
1. Block is added to block tree with empty `PartialStateComputeResult` (both OnceCells unset)
2. `ledger_update()` executes `set_state_checkpoint_output(DoStateCheckpoint::run(...))` successfully - first OnceCell is SET
3. `DoLedgerUpdate::run(...)` FAILS (out of memory, parallel processing panic, injected error)
4. Error propagates, function returns, block remains in tree with partial state
5. Consensus retry mechanism attempts `ledger_update()` again (confirmed by tests)
6. Retry detection only checks if BOTH fields are complete: [5](#0-4) 

7. Returns `None` because `ledger_update_output` is not set, continues to line 315
8. Attempts `set_state_checkpoint_output()` again on already-set OnceCell
9. **PANIC**: "StateCheckpointOutput already set" - validator node CRASHES

The developer comment reveals awareness but no solution: [6](#0-5) 

The reconfig suffix path has the same vulnerability: [7](#0-6) 

## Impact Explanation

**Critical Severity** - This meets the "Total loss of liveness/network availability" criterion:

1. **Validator Node Crash**: Once triggered, the validator panics and exits
2. **Non-Recoverable Without Manual Intervention**: Restarting the node will hit the same panic when attempting to process the same block
3. **Cascading Failures**: Multiple validators hitting the same block will all crash
4. **Network Halt Risk**: If >1/3 validators crash, consensus halts entirely
5. **Breaks State Consistency Invariant**: Partial state updates violate atomicity guarantees

The vulnerability is particularly severe because:
- It persists in the block tree (in-memory structure)
- Normal retry mechanisms make it worse (guaranteed panic on retry)
- Could affect any validator processing the problematic block
- No automatic recovery mechanism exists

## Likelihood Explanation

**High Likelihood** in production:

1. **Transient Failures Are Common**: Memory pressure, system load, or temporary resource exhaustion can cause `DoLedgerUpdate::run()` to fail
2. **Retry Logic Is Active**: Test suite confirms retry mechanism exists: [8](#0-7) 

3. **Parallel Processing Increases Risk**: `DoLedgerUpdate` uses parallel iterators which can panic: [9](#0-8) 

4. **Failpoint Tests Demonstrate Viability**: The codebase includes failpoint injection showing errors can occur: [10](#0-9) 

## Recommendation

**Implement atomic setting with rollback capability:**

```rust
// In block_executor/mod.rs ledger_update function, replace lines 310-330:

// Compute both outputs BEFORE setting either
let state_checkpoint_output = DoStateCheckpoint::run(
    &output.execution_output,
    parent_block.output.ensure_result_state_summary()?,
    &ProvableStateSummary::new_persisted(self.db.reader.as_ref())?,
    None,
)?;

let ledger_update_output = DoLedgerUpdate::run(
    &output.execution_output,
    &state_checkpoint_output,
    parent_out
        .ensure_ledger_update_output()?
        .transaction_accumulator
        .clone(),
)?;

// Only set after BOTH computations succeed
output.set_state_checkpoint_output(state_checkpoint_output);
output.set_ledger_update_output(ledger_update_output);
```

**Alternative: Check if already partially set before retry:**

```rust
// In partial_state_compute_result.rs, add safe setter:
pub fn try_set_state_checkpoint_output(&self, value: StateCheckpointOutput) -> Result<()> {
    self.state_checkpoint_output
        .set(value)
        .map_err(|_| anyhow!("StateCheckpointOutput already set"))
}

// Use try_set_* methods that return Result instead of panicking
```

**Additional fix for reconfig suffix path:** [11](#0-10) 

Apply same pattern: compute both values before setting either.

## Proof of Concept

```rust
// Add to execution/executor/src/tests/mod.rs

#[test]
fn test_ledger_update_partial_failure_causes_panic() {
    use fail::FailScenario;
    
    let executor = TestExecutor::new();
    let parent_block_id = executor.committed_block_id();
    let block_id = gen_block_id(1);
    
    let txns: Vec<_> = (0..10)
        .map(|i| encode_mint_transaction(gen_address(i), 100))
        .collect();
    
    // Execute block successfully
    executor
        .execute_block(
            (block_id, block(txns.clone())).into(),
            parent_block_id,
            TEST_BLOCK_EXECUTOR_ONCHAIN_CONFIG,
        )
        .unwrap();
    
    // Set failpoint to fail AFTER state checkpoint but BEFORE ledger update
    let scenario = FailScenario::setup();
    fail::cfg("executor::block_state_checkpoint", "off").unwrap();
    
    // First ledger_update call - will fail partway through
    // This sets state_checkpoint_output but fails before setting ledger_update_output
    let result = std::panic::catch_unwind(|| {
        // Inject failure in DoLedgerUpdate (simulated via complex scenario)
        fail::cfg("executor::do_ledger_update", "return").unwrap();
        executor.ledger_update(block_id, parent_block_id)
    });
    
    // First call should fail but not panic
    assert!(result.is_ok() && result.unwrap().is_err());
    
    // Second ledger_update call (retry) - will PANIC on already-set OnceCell
    let result = std::panic::catch_unwind(|| {
        executor.ledger_update(block_id, parent_block_id)
    });
    
    // This PANICS - demonstrates the vulnerability
    assert!(result.is_err(), "Expected panic on retry, but succeeded");
    
    scenario.teardown();
}
```

The PoC demonstrates that once a block's `PartialStateComputeResult` is partially set, any retry attempt will panic the validator node, causing total loss of liveness.

## Notes

This vulnerability specifically affects the **block executor path** used by consensus. The chunk executor has a different pattern where both outputs are computed before setting, making it less vulnerable to this specific issue. However, the fundamental design of using `OnceCell` with interior mutability on shared objects (blocks in the block tree) combined with non-atomic multi-step updates creates an inherent race condition that can lead to validator crashes.

The issue is exacerbated by the fact that blocks persist in the in-memory block tree across retry attempts, unlike chunks which are removed from the queue during processing.

### Citations

**File:** execution/executor/src/types/partial_state_compute_result.rs (L17-22)
```rust
#[derive(Clone, Debug)]
pub struct PartialStateComputeResult {
    pub execution_output: ExecutionOutput,
    pub state_checkpoint_output: OnceCell<StateCheckpointOutput>,
    pub ledger_update_output: OnceCell<LedgerUpdateOutput>,
}
```

**File:** execution/executor/src/types/partial_state_compute_result.rs (L76-79)
```rust
    pub fn set_state_checkpoint_output(&self, state_checkpoint_output: StateCheckpointOutput) {
        self.state_checkpoint_output
            .set(state_checkpoint_output)
            .expect("StateCheckpointOutput already set");
```

**File:** execution/executor/src/types/partial_state_compute_result.rs (L88-91)
```rust
    pub fn set_ledger_update_output(&self, ledger_update_output: LedgerUpdateOutput) {
        self.ledger_update_output
            .set(ledger_update_output)
            .expect("LedgerUpdateOutput already set");
```

**File:** execution/executor/src/block_executor/mod.rs (L290-290)
```rust
        // TODO(aldenhu): remove, assuming no retries.
```

**File:** execution/executor/src/block_executor/mod.rs (L291-294)
```rust
        if let Some(complete_result) = block.output.get_complete_result() {
            info!(block_id = block_id, "ledger_update already done.");
            return Ok(complete_result);
        }
```

**File:** execution/executor/src/block_executor/mod.rs (L296-308)
```rust
        if parent_block_id != committed_block_id && parent_out.has_reconfiguration() {
            info!(block_id = block_id, "ledger_update for reconfig suffix.");

            // Parent must have done all state checkpoint and ledger update since this method
            // is being called.
            output.set_state_checkpoint_output(
                parent_out
                    .ensure_state_checkpoint_output()?
                    .reconfig_suffix(),
            );
            output.set_ledger_update_output(
                parent_out.ensure_ledger_update_output()?.reconfig_suffix(),
            );
```

**File:** execution/executor/src/block_executor/mod.rs (L310-330)
```rust
            THREAD_MANAGER.get_non_exe_cpu_pool().install(|| {
                // TODO(aldenhu): remove? no known strategy to recover from this failure
                fail_point!("executor::block_state_checkpoint", |_| {
                    Err(anyhow::anyhow!("Injected error in block state checkpoint."))
                });
                output.set_state_checkpoint_output(DoStateCheckpoint::run(
                    &output.execution_output,
                    parent_block.output.ensure_result_state_summary()?,
                    &ProvableStateSummary::new_persisted(self.db.reader.as_ref())?,
                    None,
                )?);
                output.set_ledger_update_output(DoLedgerUpdate::run(
                    &output.execution_output,
                    output.ensure_state_checkpoint_output()?,
                    parent_out
                        .ensure_ledger_update_output()?
                        .transaction_accumulator
                        .clone(),
                )?);
                Result::<_>::Ok(())
            })?;
```

**File:** consensus/src/pipeline/buffer_manager.rs (L293-306)
```rust
    fn spawn_retry_request<T: Send + 'static>(
        mut sender: Sender<T>,
        request: T,
        duration: Duration,
    ) {
        counters::BUFFER_MANAGER_RETRY_COUNT.inc();
        spawn_named!("retry request", async move {
            tokio::time::sleep(duration).await;
            sender
                .send(request)
                .await
                .expect("Failed to send retry request");
        });
    }
```

**File:** execution/executor/src/workflow/do_ledger_update.rs (L53-55)
```rust
        (0..to_commit.len())
            .into_par_iter()
            .with_min_len(optimal_min_len(to_commit.len(), 64))
```
