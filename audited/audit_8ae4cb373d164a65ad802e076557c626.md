# Audit Report

## Title
Path Traversal Vulnerability in Move Package Local Dependencies Allows Arbitrary File Inclusion

## Summary
The `Dependency::deserialize()` function in `manifest.rs` and the dependency resolution logic in `resolver.rs` do not validate that local dependency paths remain within safe boundaries. This allows attackers to craft malicious Move packages that include arbitrary code from outside the package tree through absolute paths, relative path traversal (`..`), or symlinks.

## Finding Description

The vulnerability exists across two critical points in the Move package dependency resolution pipeline:

**1. Deserialization Phase (manifest.rs):**

At line 283, the deserialization accepts any `PathBuf` for local dependencies without validation: [1](#0-0) 

**2. Resolution Phase (resolver.rs):**

When resolving local dependencies with local parents (lines 325-349), the code performs path joining and canonicalization but **does not validate** that the resulting path stays within the package tree: [2](#0-1) 

The `CanonicalPath::new()` function only resolves symlinks but does not check boundaries: [3](#0-2) 

**Contrast with Git Dependencies:**

For git dependencies, there ARE explicit boundary checks that prevent path traversal: [4](#0-3) 

However, these protections are **missing** for local-to-local dependency resolution.

**Attack Scenario:**

An attacker creates a malicious Move package with a `Move.toml` containing:

```toml
[dependencies]
MaliciousLib = { local = "/etc" }
# or
MaliciousLib = { local = "../../../sensitive-package" }
# or creates a symlink in their package pointing to arbitrary locations
```

When a developer or CI system compiles this package, the resolver:
1. Accepts the path without validation during deserialization
2. Joins it with the parent path (if relative) or uses it directly (if absolute)  
3. Canonicalizes it (resolving symlinks to their targets)
4. Reads and compiles Move source code from that arbitrary location

This allows:
- **Information Disclosure**: Reading arbitrary Move source files from the developer's filesystem
- **Supply Chain Attack**: Including malicious code from unexpected locations that bypasses code review
- **Path Confusion**: Symlinks can point to attacker-controlled directories on shared systems

## Impact Explanation

**Severity: Medium**

While this is a genuine security vulnerability, it is classified as **Medium severity** rather than Critical or High because:

1. **Build-Time Only**: This vulnerability affects the Move package compilation toolchain, not the blockchain runtime. It does not directly impact consensus safety, state consistency, or on-chain fund security.

2. **Limited Attack Vector**: The attack requires:
   - Tricking a developer/CI system into compiling a malicious package
   - The victim must have the Move build tools installed
   - Impact is limited to the compilation environment

3. **No Direct Blockchain Impact**: This does not break any of the critical blockchain invariants:
   - Does not affect deterministic execution (compiled bytecode is deterministic)
   - Does not violate consensus safety
   - Does not enable fund theft or state manipulation
   - Does not compromise validator nodes during normal blockchain operation

4. **Supply Chain Context**: This is primarily a supply chain/development toolchain vulnerability rather than a blockchain protocol vulnerability.

However, it could enable:
- Theft of private keys or sensitive data from developer machines
- Injection of backdoors that are difficult to detect during code review
- Compromise of CI/CD systems compiling Move packages

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability is **likely to be exploited** because:

1. **Easy to Execute**: An attacker only needs to craft a malicious `Move.toml` file
2. **Hard to Detect**: Path traversal via symlinks or `..` may not be obvious during casual inspection
3. **Common Attack Vector**: Path traversal is a well-known attack pattern
4. **No Authentication Required**: Anyone can create and distribute a malicious Move package

However, exploitation requires:
- Social engineering to get developers to compile the malicious package
- Or compromising a dependency package that many projects use

## Recommendation

**Add boundary validation for local dependencies similar to git dependencies.**

Implement checks in `resolve_dependency()` function:

```rust
// In resolver.rs, around line 325-349
PackageLocation::Local { path: local_path } => match &parent_identity.location {
    SourceLocation::Local { path: parent_path } => {
        // Reject absolute paths for local dependencies
        if local_path.is_absolute() {
            bail!(
                "local dependency cannot be an absolute path: {}",
                local_path.display()
            );
        }
        
        // Join paths and normalize
        let combined_path = parent_path.join(&local_path);
        let normalized_path = NormalizedPath::new(&combined_path);
        
        // Check that normalized path doesn't escape parent directory
        if let Some(Component::ParentDir) = normalized_path.components().next() {
            bail!(
                "local dependency path escapes package root: {}",
                local_path.display()
            );
        }
        
        // Check for symlinks that point outside the package tree
        let canonical_path = CanonicalPath::new(&combined_path)?;
        if !canonical_path.starts_with(parent_path.as_ref()) {
            bail!(
                "local dependency resolves outside package tree: {} -> {}",
                local_path.display(),
                canonical_path.display()
            );
        }
        
        // Rest of the existing code...
```

Additionally, add validation during deserialization in `manifest.rs` to reject obviously dangerous patterns early.

## Proof of Concept

```rust
// Create a malicious Move package
// File: malicious_package/Move.toml
/*
[package]
name = "MaliciousPackage"
version = "1.0.0"

[dependencies]
# Attempt to include code from parent directories
EscapedDep = { local = "../../../sensitive-code" }

# Or use absolute path
SystemDep = { local = "/tmp/malicious-move-code" }
*/

// Create the target directory with malicious Move code
// File: /tmp/malicious-move-code/Move.toml
/*
[package]
name = "MaliciousLib"
version = "1.0.0"
*/

// File: /tmp/malicious-move-code/sources/malicious.move
/*
module malicious::backdoor {
    // Malicious code that gets compiled into the victim's package
    public fun steal_data(): vector<u8> {
        // This code is now part of the victim's compiled package
        b"attacker-controlled-code"
    }
}
*/

// Compilation command that triggers the vulnerability:
// $ aptos move compile --package-dir ./malicious_package

// Expected: The compiler should reject paths escaping the package tree
// Actual: The compiler includes code from /tmp/malicious-move-code
// This allows arbitrary code inclusion from attacker-controlled locations
```

## Notes

- The TODO comment in `resolver.rs` line 31 mentions "Symbolic links in git repos" as low priority, indicating awareness of symlink issues but incomplete mitigation.
- The existing boundary checks for git dependencies (lines 367-372) demonstrate that the developers understood the security requirement but did not apply it consistently to local dependencies.
- This vulnerability affects Move package development workflows but not the runtime blockchain consensus or execution, hence the Medium severity classification per Aptos bug bounty criteria.

### Citations

**File:** third_party/move/tools/move-package-manifest/src/manifest.rs (L282-283)
```rust
        let location = match (raw.local, raw.git, raw.aptos) {
            (Some(path), None, None) => PackageLocation::Local { path },
```

**File:** third_party/move/tools/move-package-resolver/src/resolver.rs (L325-349)
```rust
        PackageLocation::Local { path: local_path } => match &parent_identity.location {
            SourceLocation::Local { path: parent_path } => {
                // Both parent and child are local, so if the child's path is relative,
                // it is relative to the parent's path.
                let dep_manitest_path = if local_path.is_absolute() {
                    local_path
                } else {
                    parent_path.join(local_path)
                };
                let canonical_path = CanonicalPath::new(&dep_manitest_path).map_err(|err| {
                    anyhow!(
                        "failed to find package at {}: {}",
                        dep_manitest_path.display(),
                        err
                    )
                })?;

                let identity = PackageIdentity {
                    name: dep_name.to_string(),
                    location: SourceLocation::Local {
                        path: canonical_path,
                    },
                };

                (identity, None)
```

**File:** third_party/move/tools/move-package-resolver/src/resolver.rs (L359-372)
```rust
                if local_path.is_absolute() {
                    bail!(
                        "local dependency in a git repo cannot be an absolute path: {}",
                        local_path.display()
                    );
                }

                let new_subdir = subdir.join(local_path);
                let normalized_new_subdir = NormalizedPath::new(&new_subdir);
                if let Some(std::path::Component::ParentDir) =
                    normalized_new_subdir.components().next()
                {
                    bail!("subdir outside of repo root: {}", new_subdir.display());
                }
```

**File:** third_party/move/tools/move-package-resolver/src/path.rs (L29-33)
```rust
impl CanonicalPath {
    pub fn new(path: impl AsRef<Path>) -> Result<Self> {
        let path = path.as_ref().canonicalize()?;
        Ok(Self(path))
    }
```
