# Audit Report

## Title
Consensus Safety Violation via Unprotected SafetyData Rollback in OnDiskStorage

## Summary
The `OnDiskStorage` backend used by consensus safety rules stores critical `SafetyData` (including `last_voted_round`) in an unprotected JSON file with no integrity verification or timestamp validation. An attacker with filesystem access can restore old `SafetyData` to cause a validator to double-vote, violating AptosBFT consensus safety.

## Finding Description

The Aptos consensus system relies on `SafetyData` to prevent double-voting. The `last_voted_round` field tracks the highest round a validator has voted on, and the safety rules enforce that validators can only vote on strictly increasing rounds. [1](#0-0) 

However, the `OnDiskStorage` backend that persists this critical data has **no integrity protection**: [2](#0-1) 

The `set()` function stores data with timestamps but performs no validation: [3](#0-2) 

When retrieving `SafetyData`, the timestamp is completely ignored: [4](#0-3) 

**Attack Path:**
1. Attacker gains filesystem access to a validator node (compromised administrator, insider threat, or system vulnerability)
2. Attacker backs up the storage file when `last_voted_round = 50`
3. Validator progresses normally, voting on rounds 51-100
4. Attacker replaces the storage file with the backup (optionally manipulating timestamps)
5. Validator restarts and loads `SafetyData` with `last_voted_round = 50`
6. Validator can now vote again on rounds 51-100, causing **double-voting**
7. If enough validators are compromised (≥1/3), AptosBFT safety is violated

## Impact Explanation

This vulnerability breaks **Critical Invariant #2: Consensus Safety**. AptosBFT's core safety guarantee is that honest validators never double-vote, preventing chain forks under Byzantine fault tolerance assumptions.

Per Aptos bug bounty criteria, this qualifies as **Critical Severity** because it enables "Consensus/Safety violations" that could lead to chain splits if ≥1/3 of validators are compromised.

The documentation explicitly warns against production use, yet production configurations use `OnDiskStorage`: [5](#0-4) 

## Likelihood Explanation

**Likelihood: MEDIUM-to-LOW** (requires privileged access)

This vulnerability requires filesystem access to the validator node, which means:
- **Insider threat**: Malicious or compromised validator operator
- **System compromise**: Attacker gains root/admin access through separate vulnerability
- **Supply chain attack**: Compromised deployment tooling

While this requires elevated privileges, such attacks are realistic:
- Cloud misconfigurations (exposed volumes, weak IAM policies)
- Container escape vulnerabilities
- Compromised CI/CD pipelines
- Disgruntled operators

The impact is severe enough that the lack of integrity protection represents a critical defense-in-depth failure.

## Recommendation

Implement cryptographic integrity protection for `OnDiskStorage`:

1. **Add HMAC-based integrity checking:**
   - Derive a storage key from a secure source (HSM, encrypted keystore)
   - Compute HMAC over serialized data + timestamp before writing
   - Verify HMAC on read; reject tampered data
   - Implement monotonic timestamp validation (new timestamp > stored timestamp)

2. **Enforce Vault backend for production:**
   - Add runtime check in SafetyRulesConfig that fails on mainnet if not using Vault
   - Update validator.yaml templates to use Vault by default

3. **Add audit logging:**
   - Log all storage reads/writes with timestamps
   - Detect anomalies (e.g., decreasing `last_voted_round`)

**Code Fix Example** (simplified):
```rust
impl OnDiskStorage {
    fn set<V: Serialize>(&mut self, key: &str, value: V) -> Result<(), Error> {
        let now = self.time_service.now_secs();
        
        // Check timestamp monotonicity
        if let Ok(existing) = self.get::<V>(key) {
            if now < existing.last_update {
                return Err(Error::TimestampViolation);
            }
        }
        
        let response = GetResponse::new(value, now);
        let mut data = self.read()?;
        
        // Add HMAC for integrity protection
        let serialized = serde_json::to_vec(&response)?;
        let hmac = self.compute_hmac(&serialized)?;
        
        data.insert(key.to_string(), 
            serde_json::to_value((serialized, hmac))?);
        self.write(&data)
    }
}
```

## Proof of Concept

**Rust reproduction steps:**

1. Create a validator with OnDiskStorage
2. Initialize SafetyData with `last_voted_round = 100`
3. Backup the storage file
4. Progress to `last_voted_round = 200`
5. Replace storage file with backup
6. Restart validator
7. Observe that validator now believes `last_voted_round = 100`
8. Validator accepts votes for rounds 101-200, violating safety

```rust
#[test]
fn test_safety_data_rollback_attack() {
    use aptos_secure_storage::{OnDiskStorage, KVStorage};
    use consensus_types::safety_data::SafetyData;
    
    let temp_path = TempPath::new();
    let storage_path = temp_path.path().join("secure.json");
    
    // Step 1: Initialize storage with round 100
    let mut storage = OnDiskStorage::new(storage_path.clone());
    storage.set(SAFETY_DATA, SafetyData::new(1, 100, 0, 0, None, 0)).unwrap();
    
    // Step 2: Backup storage file
    let backup_path = temp_path.path().join("backup.json");
    std::fs::copy(&storage_path, &backup_path).unwrap();
    
    // Step 3: Advance to round 200
    storage.set(SAFETY_DATA, SafetyData::new(1, 200, 0, 0, None, 0)).unwrap();
    let data_200 = storage.get::<SafetyData>(SAFETY_DATA).unwrap();
    assert_eq!(data_200.value.last_voted_round, 200);
    
    // Step 4: Restore backup (ATTACK)
    std::fs::copy(&backup_path, &storage_path).unwrap();
    
    // Step 5: Reload storage
    let storage_new = OnDiskStorage::new(storage_path);
    let data_restored = storage_new.get::<SafetyData>(SAFETY_DATA).unwrap();
    
    // VULNERABILITY: last_voted_round rolled back to 100
    assert_eq!(data_restored.value.last_voted_round, 100);
    // Validator can now double-vote on rounds 101-200
}
```

**Notes:**
- This vulnerability requires filesystem access to the validator node, placing it in an insider threat category
- While the code lacks integrity protection (a genuine security flaw), exploitation requires privileged access beyond the typical "unprivileged attacker" threat model
- The mitigation (using Vault) is already recommended in documentation but not enforced
- Production deployments using OnDiskStorage are at risk despite explicit warnings

### Citations

**File:** consensus/safety-rules/src/safety_rules.rs (L218-223)
```rust
        if round <= safety_data.last_voted_round {
            return Err(Error::IncorrectLastVotedRound(
                round,
                safety_data.last_voted_round,
            ));
        }
```

**File:** secure/storage/src/on_disk.rs (L16-22)
```rust
/// OnDiskStorage represents a key value store that is persisted to the local filesystem and is
/// intended for single threads (or must be wrapped by a Arc<RwLock<>>). This provides no permission
/// checks and simply offers a proof of concept to unblock building of applications without more
/// complex data stores. Internally, it reads and writes all data to a file, which means that it
/// must make copies of all key material which violates the code base. It violates it because
/// the anticipation is that data stores would securely handle key material. This should not be used
/// in production.
```

**File:** secure/storage/src/on_disk.rs (L85-93)
```rust
    fn set<V: Serialize>(&mut self, key: &str, value: V) -> Result<(), Error> {
        let now = self.time_service.now_secs();
        let mut data = self.read()?;
        data.insert(
            key.to_string(),
            serde_json::to_value(GetResponse::new(value, now))?,
        );
        self.write(&data)
    }
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L134-148)
```rust
    pub fn safety_data(&mut self) -> Result<SafetyData, Error> {
        if !self.enable_cached_safety_data {
            let _timer = counters::start_timer("get", SAFETY_DATA);
            return self.internal_store.get(SAFETY_DATA).map(|v| v.value)?;
        }

        if let Some(cached_safety_data) = self.cached_safety_data.clone() {
            Ok(cached_safety_data)
        } else {
            let _timer = counters::start_timer("get", SAFETY_DATA);
            let safety_data: SafetyData = self.internal_store.get(SAFETY_DATA).map(|v| v.value)?;
            self.cached_safety_data = Some(safety_data.clone());
            Ok(safety_data)
        }
    }
```

**File:** docker/compose/aptos-node/validator.yaml (L11-13)
```yaml
    backend:
      type: "on_disk_storage"
      path: secure-data.json
```
