# Audit Report

## Title
Node-Checker TPS Verification Can Be Bypassed Through Untrusted API Response Manipulation

## Summary
The node-checker's TPS (transactions per second) verification relies on querying the target node's own API to determine transaction commitment status. A malicious node operator can return fabricated sequence numbers and timestamps through their API responses to inflate reported TPS metrics, bypassing performance requirements without cryptographic verification.

## Finding Description

The TPS checker performs performance verification by submitting transactions to a target node and measuring its processing rate. The vulnerability exists in how committed transaction counts are determined: [1](#0-0) 

The emitter queries the target node's API to check account sequence numbers, which indicate transaction commitment: [2](#0-1) 

The critical issue is in how committed transactions are counted. The emitter calculates committed transactions based on sequence numbers returned by the target node's API: [3](#0-2) 

Specifically, at line 453, the committed count is: `(*count - *start_seq_num)`, where `count` comes directly from the target node's API response without cryptographic verification.

The state information including timestamps is extracted from HTTP headers without verification: [4](#0-3) 

**Attack Path:**
1. Validator operator modifies their node's API endpoint to return fake data
2. When node-checker queries `/accounts/{address}`, node returns `sequence_number == end_seq_num` immediately
3. When checking expiration, node returns `timestamp_usecs < expiration_time` to prevent expiration marking
4. Emitter calculates: `rate.committed = fake_high_count / actual_time_elapsed`
5. Node passes TPS check: `rate.committed >= minimum_tps`

The rate calculation uses local time measurement (unmanipulable) but relies on untrusted committed counts (manipulable): [5](#0-4) 

## Impact Explanation

This constitutes a **High Severity** vulnerability per Aptos bug bounty criteria for "Significant protocol violations." 

A malicious validator operator can:
- Bypass performance requirements by faking TPS metrics
- Join the validator set with inadequate hardware
- Degrade overall network performance and throughput
- Potentially cause consensus liveness issues if many slow validators pass checks

While this doesn't directly break consensus safety, it undermines the network's performance guarantees and validator quality control mechanisms.

## Likelihood Explanation

**Likelihood: HIGH**

- Attack requires only modifying the operator's own node API responses
- No cryptographic barriers or consensus participation required  
- Simple HTTP response manipulation (sequence numbers, timestamps)
- Directly benefits malicious operators seeking to avoid hardware costs
- No detection mechanism exists in the current implementation

## Recommendation

Implement cryptographic verification of state data using state proofs:

1. **Require State Proofs**: Modify the client to request and verify Merkle proofs for account state
2. **Cross-Validation**: Query multiple independent nodes and compare results
3. **Ledger Info Verification**: Verify ledger info is signed by validator quorum certificates
4. **Transaction Confirmation**: Query transaction commitment from multiple sources

Example fix approach:
```rust
// In get_account_seq_num, add proof verification
pub async fn get_account_seq_num_with_proof(
    client: &RestClient,
    address: AccountAddress,
    trusted_state: &TrustedState,
) -> Result<(u64, u64)> {
    let response = client.get_account_with_proof(address).await?;
    
    // Verify the state proof against trusted ledger info
    response.verify_state_proof(trusted_state)?;
    
    Ok((
        response.inner().sequence_number(),
        response.state().timestamp_usecs,
    ))
}
```

Additionally, implement multi-node verification where TPS measurements query several independent nodes and require consensus on transaction commitment status.

## Proof of Concept

```rust
// Malicious node API handler returning fake high sequence numbers
async fn handle_get_account(address: AccountAddress) -> Response {
    // Instead of querying actual state, return fabricated data
    let fake_account = AccountResource::new(
        /* authentication_key */ ...,
        /* sequence_number */ u64::MAX - 1000, // Claim almost all txns committed
        /* coin_register_events */ ...,
    );
    
    // Also return old timestamp to prevent expiration
    let fake_timestamp = current_time_usecs() - 1000_000_000; // 1000s ago
    
    Response::new(fake_account)
        .with_header(X_APTOS_LEDGER_TIMESTAMP, fake_timestamp)
        .with_header(X_APTOS_LEDGER_VERSION, u64::MAX)
}

// This causes the node-checker to calculate:
// rate.committed = (fake_high_seq_num - start_seq) / actual_elapsed_time
// Result: Artificially inflated TPS that passes minimum requirements
```

## Notes

This vulnerability exists because the node-checker treats the target node as a trusted source of truth about its own state, without requiring cryptographic proofs. The Aptos blockchain provides state proof mechanisms through Jellyfish Merkle Trees, but the transaction emitter library doesn't utilize them for verification. The fix requires integrating state proof verification into the account querying logic.

### Citations

**File:** ecosystem/node-checker/src/checker/tps.rs (L141-152)
```rust
        let stats = emit_transactions_with_cluster(
            &cluster,
            &self.config.emit_config,
            self.config
                .emit_workload_configs
                .args_to_transaction_mix_per_phase(),
        )
        .await
        .map_err(TpsCheckerError::TransactionEmitterError)?;

        // AKA stats per second.
        let rate = stats.rate();
```

**File:** crates/transaction-emitter-lib/src/emitter/mod.rs (L1227-1252)
```rust
pub async fn get_account_seq_num(
    client: &RestClient,
    address: AccountAddress,
) -> Result<(u64, u64)> {
    let result = client.get_account_bcs(address).await;
    match &result {
        Ok(resp) => Ok((
            resp.inner().sequence_number(),
            Duration::from_micros(resp.state().timestamp_usecs).as_secs(),
        )),
        Err(e) => {
            // if account is not present, that is equivalent to sequence_number = 0
            if let RestError::Api(api_error) = e {
                if let AptosErrorCode::AccountNotFound = api_error.error.error_code {
                    return Ok((
                        0,
                        Duration::from_micros(api_error.state.as_ref().unwrap().timestamp_usecs)
                            .as_secs(),
                    ));
                }
            }
            result?;
            unreachable!()
        },
    }
}
```

**File:** crates/transaction-emitter-lib/src/emitter/submission_worker.rs (L436-484)
```rust
fn count_committed_expired_stats(
    account_to_start_and_end_seq_num: HashMap<AccountAddress, (u64, u64)>,
    latest_fetched_counts: HashMap<AccountAddress, u64>,
    account_to_orderless_txns: HashMap<AccountAddress, HashSet<HashValue>>,
    failed_orderless_txns: HashMap<AccountAddress, HashSet<HashValue>>,
) -> (usize, usize) {
    let (seq_num_committed, seq_num_failed) = account_to_start_and_end_seq_num
        .iter()
        .map(
            |(address, (start_seq_num, end_seq_num))| match latest_fetched_counts.get(address) {
                Some(count) => {
                    assert!(
                        *count <= *end_seq_num,
                        "{address} :: {count} > {end_seq_num}"
                    );
                    if *count >= *start_seq_num {
                        (
                            (*count - *start_seq_num) as usize,
                            (*end_seq_num - *count) as usize,
                        )
                    } else {
                        debug!(
                            "Stale sequence_number fetched for {}, start_seq_num {}, fetched {}",
                            address, start_seq_num, *count
                        );
                        (0, (*end_seq_num - *start_seq_num) as usize)
                    }
                },
                None => (0, (end_seq_num - start_seq_num) as usize),
            },
        )
        .fold(
            (0, 0),
            |(committed, expired), (cur_committed, cur_expired)| {
                (committed + cur_committed, expired + cur_expired)
            },
        );
    let total_orderless_txns: usize = account_to_orderless_txns
        .values()
        .map(|txns| txns.len())
        .sum();
    let failed_orderless_txns: usize = failed_orderless_txns.values().map(|txns| txns.len()).sum();
    let committed_orderless_txns = total_orderless_txns - failed_orderless_txns;

    (
        seq_num_committed + committed_orderless_txns,
        seq_num_failed + failed_orderless_txns,
    )
}
```

**File:** crates/aptos-rest-client/src/state.rs (L22-102)
```rust
impl State {
    pub fn from_headers(headers: &reqwest::header::HeaderMap) -> anyhow::Result<Self> {
        let maybe_chain_id = headers
            .get(X_APTOS_CHAIN_ID)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_version = headers
            .get(X_APTOS_LEDGER_VERSION)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_timestamp = headers
            .get(X_APTOS_LEDGER_TIMESTAMP)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_epoch = headers
            .get(X_APTOS_EPOCH)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_oldest_ledger_version = headers
            .get(X_APTOS_LEDGER_OLDEST_VERSION)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_block_height = headers
            .get(X_APTOS_BLOCK_HEIGHT)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let maybe_oldest_block_height = headers
            .get(X_APTOS_OLDEST_BLOCK_HEIGHT)
            .and_then(|h| h.to_str().ok())
            .and_then(|s| s.parse().ok());
        let cursor = headers
            .get(X_APTOS_CURSOR)
            .and_then(|h| h.to_str().ok())
            .map(|s| s.to_string());

        let state = if let (
            Some(chain_id),
            Some(version),
            Some(timestamp_usecs),
            Some(epoch),
            Some(oldest_ledger_version),
            Some(block_height),
            Some(oldest_block_height),
            cursor,
        ) = (
            maybe_chain_id,
            maybe_version,
            maybe_timestamp,
            maybe_epoch,
            maybe_oldest_ledger_version,
            maybe_block_height,
            maybe_oldest_block_height,
            cursor,
        ) {
            Self {
                chain_id,
                epoch,
                version,
                timestamp_usecs,
                oldest_ledger_version,
                block_height,
                oldest_block_height,
                cursor,
            }
        } else {
            anyhow::bail!(
                "Failed to build State from headers due to missing values in response. \
                Chain ID: {:?}, Version: {:?}, Timestamp: {:?}, Epoch: {:?}, \
                Oldest Ledger Version: {:?}, Block Height: {:?} Oldest Block Height: {:?}",
                maybe_chain_id,
                maybe_version,
                maybe_timestamp,
                maybe_epoch,
                maybe_oldest_ledger_version,
                maybe_block_height,
                maybe_oldest_block_height,
            )
        };

        Ok(state)
    }
```

**File:** crates/transaction-emitter-lib/src/emitter/stats.rs (L54-73)
```rust
impl TxnStats {
    pub fn rate(&self) -> TxnStatsRate {
        let window_secs = self.lasted.as_secs_f64();
        TxnStatsRate {
            submitted: (self.submitted as f64) / window_secs,
            committed: (self.committed as f64) / window_secs,
            expired: (self.expired as f64) / window_secs,
            failed_submission: (self.failed_submission as f64) / window_secs,
            latency: if self.latency_samples == 0 {
                0.0
            } else {
                (self.latency as f64) / (self.latency_samples as f64)
            },
            latency_samples: self.latency_samples,
            p50_latency: self.latency_buckets.percentile(50, 100),
            p70_latency: self.latency_buckets.percentile(70, 100),
            p90_latency: self.latency_buckets.percentile(90, 100),
            p99_latency: self.latency_buckets.percentile(99, 100),
        }
    }
```
