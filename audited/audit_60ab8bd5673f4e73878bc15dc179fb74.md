# Audit Report

## Title
Index Out-of-Bounds Panic in SecretShare Verification Due to Missing Length Validation

## Summary
The `SecretShareConfig::new()` constructor lacks validation that `verification_keys.len()` equals the number of validators in `ValidatorVerifier`, and `SecretShare::verify()` performs unchecked array access, potentially causing node crashes during consensus operations if the lengths mismatch.

## Finding Description

The vulnerability exists in the secret sharing implementation used for consensus operations. 

In `SecretShareConfig::new()`, there is no validation that the `verification_keys` vector length matches the number of validators in the `ValidatorVerifier`: [1](#0-0) 

The critical issue manifests in `SecretShare::verify()` where an index obtained from the validator verifier is used to access the `verification_keys` array without bounds checking. Note the explicit TODO comment acknowledging this missing check: [2](#0-1) 

The `get_id()` method retrieves the validator index from the `ValidatorVerifier`: [3](#0-2) 

When a `SecretShareMessage::Share` is received over the network, it goes through verification: [4](#0-3) 

The attack flow is:
1. During epoch initialization, if `verification_keys` is created with fewer elements than validators in `ValidatorVerifier` (due to a bug in DKG setup or edge case)
2. A validator at index `i >= verification_keys.len()` sends a legitimate `SecretShare` message
3. The message is verified in `secret_share_manager.rs`: [5](#0-4) 

4. This calls `share.verify(config)` which accesses `config.verification_keys[i]` where `i >= verification_keys.len()`
5. The array access panics, crashing the consensus node

The `ValidatorVerifier.len()` returns the number of validators: [6](#0-5) 

While the normal flow in epoch manager creates verification keys matching the validator count: [7](#0-6) 

The absence of validation in `SecretShareConfig::new()` means any bug in the setup path or edge case could create a mismatched configuration.

## Impact Explanation

**Critical Severity Assessment:**

This issue meets the **High Severity** criteria per the Aptos bug bounty program:
- **Validator node crashes** during consensus operations
- **Significant protocol violations** - nodes cannot participate in secret sharing consensus

If triggered, affected nodes would panic and crash during secret share verification, causing:
- Loss of consensus participation for affected validators
- Potential network liveness degradation if multiple validators crash
- Service disruption requiring node restart and investigation

This does not reach Critical severity because:
- It requires a precondition (mismatched config creation)
- It doesn't directly cause loss of funds or permanent state corruption
- It's recoverable through node restart

## Likelihood Explanation

**Medium Likelihood:**

The vulnerability requires a precondition - the `SecretShareConfig` must be created with `verification_keys.len()` < number of validators. This could occur through:

1. **DKG transcript malformation** - If the DKG transcript has incomplete verification keys
2. **Edge cases in epoch transitions** - Race conditions or partial updates during validator set changes  
3. **Implementation bugs** - Future code changes that incorrectly construct the config
4. **Version mismatches** - Different consensus participants with incompatible DKG setups

The explicit TODO comment confirms developers are aware of the missing validation, suggesting they recognize the risk. While not immediately exploitable by external attackers, the lack of defensive validation creates fragility in the consensus system.

## Recommendation

Add validation in two locations:

**1. In `SecretShareConfig::new()` - Add length validation:**

```rust
pub fn new(
    author: Author,
    epoch: u64,
    validator: Arc<ValidatorVerifier>,
    digest_key: DigestKey,
    msk_share: MasterSecretKeyShare,
    verification_keys: Vec<VerificationKey>,
    config: <FPTXWeighted as BatchThresholdEncryption>::ThresholdConfig,
    encryption_key: EncryptionKey,
) -> Result<Self, anyhow::Error> {
    // Validate verification_keys length matches validator count
    anyhow::ensure!(
        verification_keys.len() == validator.len(),
        "Verification keys length ({}) must equal validator count ({})",
        verification_keys.len(),
        validator.len()
    );
    
    Ok(Self {
        _author: author,
        _epoch: epoch,
        validator,
        digest_key,
        msk_share,
        verification_keys,
        config,
        encryption_key,
        weights: HashMap::new(),
    })
}
```

**2. In `SecretShare::verify()` - Add bounds check:**

```rust
pub fn verify(&self, config: &SecretShareConfig) -> anyhow::Result<()> {
    let index = config.get_id(self.author());
    
    // Bounds check before array access
    anyhow::ensure!(
        index < config.verification_keys.len(),
        "Validator index {} out of bounds (verification_keys.len = {})",
        index,
        config.verification_keys.len()
    );
    
    let decryption_key_share = self.share().clone();
    config.verification_keys[index]
        .verify_decryption_key_share(&self.metadata.digest, &decryption_key_share)?;
    Ok(())
}
```

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "index out of bounds")]
fn test_secret_share_verify_out_of_bounds() {
    use aptos_types::secret_sharing::{SecretShare, SecretShareConfig, SecretShareMetadata};
    use aptos_types::validator_verifier::{ValidatorVerifier, ValidatorConsensusInfo};
    use aptos_crypto::bls12381;
    use std::sync::Arc;
    
    // Create validator verifier with 3 validators
    let mut validator_infos = vec![];
    for i in 0..3 {
        let (private_key, public_key) = bls12381::PrivateKey::generate_for_testing();
        let address = AccountAddress::random();
        validator_infos.push(ValidatorConsensusInfo::new(address, public_key, 1));
    }
    let validator_verifier = Arc::new(ValidatorVerifier::new(validator_infos.clone()));
    
    // Create config with only 2 verification keys (mismatch!)
    let verification_keys = vec![/* only 2 keys */];
    let config = SecretShareConfig::new(
        validator_infos[0].address,
        1,
        validator_verifier.clone(),
        digest_key,
        msk_share,
        verification_keys, // Length 2
        threshold_config,
        encryption_key,
    );
    
    // Create share from validator at index 2
    let share = SecretShare::new(
        validator_infos[2].address, // Index 2
        metadata,
        secret_key_share,
    );
    
    // This will panic with index out of bounds!
    share.verify(&config).unwrap();
}
```

## Notes

While this vulnerability requires a precondition (mismatched configuration), the explicit TODO comment at line 78 acknowledging the missing bounds check demonstrates that this is a known defensive programming gap. The lack of validation violates the principle of defense-in-depth, making the consensus system fragile to potential bugs in the DKG setup or epoch transition logic. Adding both constructor validation and runtime bounds checking provides layered protection against configuration errors.

### Citations

**File:** types/src/secret_sharing.rs (L75-82)
```rust
    pub fn verify(&self, config: &SecretShareConfig) -> anyhow::Result<()> {
        let index = config.get_id(self.author());
        let decryption_key_share = self.share().clone();
        // TODO(ibalajiarun): Check index out of bounds
        config.verification_keys[index]
            .verify_decryption_key_share(&self.metadata.digest, &decryption_key_share)?;
        Ok(())
    }
```

**File:** types/src/secret_sharing.rs (L149-170)
```rust
    pub fn new(
        author: Author,
        epoch: u64,
        validator: Arc<ValidatorVerifier>,
        digest_key: DigestKey,
        msk_share: MasterSecretKeyShare,
        verification_keys: Vec<VerificationKey>,
        config: <FPTXWeighted as BatchThresholdEncryption>::ThresholdConfig,
        encryption_key: EncryptionKey,
    ) -> Self {
        Self {
            _author: author,
            _epoch: epoch,
            validator,
            digest_key,
            msk_share,
            verification_keys,
            config,
            encryption_key,
            weights: HashMap::new(),
        }
    }
```

**File:** types/src/secret_sharing.rs (L172-178)
```rust
    pub fn get_id(&self, peer: &Author) -> usize {
        *self
            .validator
            .address_to_validator_index()
            .get(peer)
            .expect("Peer should be in the index!")
    }
```

**File:** consensus/src/rand/secret_sharing/network_messages.rs (L28-38)
```rust
    pub fn verify(
        &self,
        epoch_state: &EpochState,
        config: &SecretShareConfig,
    ) -> anyhow::Result<()> {
        ensure!(self.epoch() == epoch_state.epoch);
        match self {
            SecretShareMessage::RequestShare(_) => Ok(()),
            SecretShareMessage::Share(share) => share.verify(config),
        }
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L218-226)
```rust
                    match bcs::from_bytes::<SecretShareMessage>(dec_msg.req.data()) {
                        Ok(msg) => {
                            if msg.verify(&epoch_state_clone, &config_clone).is_ok() {
                                let _ = tx.unbounded_send(SecretShareRpc {
                                    msg,
                                    protocol: dec_msg.protocol,
                                    response_sender: dec_msg.response_sender,
                                });
                            }
```

**File:** types/src/validator_verifier.rs (L515-517)
```rust
    pub fn len(&self) -> usize {
        self.validator_infos.len()
    }
```

**File:** consensus/src/epoch_manager.rs (L1080-1086)
```rust
        let pk_shares = (0..new_epoch_state.verifier.len())
            .map(|id| {
                transcript
                    .main
                    .get_public_key_share(&dkg_pub_params.pvss_config.wconfig, &Player { id })
            })
            .collect::<Vec<_>>();
```
