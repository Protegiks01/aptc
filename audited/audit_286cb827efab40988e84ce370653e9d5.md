# Audit Report

## Title
Race Condition in BlockSTM V1 Module Validation Flag Causes Non-Deterministic Consensus Failures

## Summary
A critical race condition exists in BlockSTM V1's parallel execution engine where the `skip_module_reads_validation` atomic flag uses `Ordering::Relaxed` for both stores and loads. This insufficient memory ordering allows concurrent worker threads to observe inconsistent flag states, causing non-deterministic module validation decisions that can lead to consensus divergence across validators.

## Finding Description

The vulnerability lies in the memory ordering semantics used for the `skip_module_reads_validation` shared atomic flag in BlockSTM V1's parallel execution engine.

**Vulnerable Code Locations:**

The flag is initialized as `true` (skip validation initially): [1](#0-0) 

When a transaction publishes modules, the flag is set to `false` using `Ordering::Relaxed`: [2](#0-1) 

Concurrently, validating threads load this flag with `Ordering::Relaxed` to determine whether to validate module reads: [3](#0-2) 

The validation logic short-circuits module validation if the flag is true: [4](#0-3) 

**The Race Condition:**

Multiple worker threads execute transactions in parallel: [5](#0-4) 

The code comment claims synchronization occurs through `validation_idx`: [6](#0-5) 

However, this claim is incorrect. The synchronization through `validation_idx` only establishes happens-before if a validating thread's `Acquire` load of `validation_idx` reads the value written by the publishing thread's `SeqCst` store. If a validation task is obtained based on a stale `validation_idx` value (before the publishing thread updates it), then the subsequent `Relaxed` load of `skip_module_reads_validation` has no synchronization with the `Relaxed` store, violating the Rust/C++ memory model's synchronization requirements.

**Execution Flow Demonstrating the Race:**

1. Transaction T2 finishes execution and is ready for validation
2. Worker Thread B obtains a ValidationTask for T2 (loads `validation_idx` with stale value)
3. Transaction T1 publishes modules and calls `record_validation_requirements()`:
   - Stores `false` to `skip_module_reads_validation` with `Ordering::Relaxed`
   - Updates `validation_idx` via `wake_dependencies_and_decrease_validation_idx()` [7](#0-6) 

4. Worker Thread B continues validation and loads `skip_module_reads_validation` with `Ordering::Relaxed`
5. **Thread B may observe the old value `true` because no synchronization exists between the Relaxed operations**
6. Thread B skips module validation even though modules were just published
7. T2 incorrectly validates and commits with potentially stale module reads

**Why This Breaks Consensus:**

Different validators (or the same validator at different times) executing the same block can produce different results based on race timing:
- **Scenario A (Race occurs)**: Validation thread observes flag=true, skips module validation, transaction validates incorrectly
- **Scenario B (No race)**: Validation thread observes flag=false, performs module validation, transaction correctly invalidates if reads are stale

This violates the fundamental consensus invariant: "All validators must produce identical state roots for identical blocks."

## Impact Explanation

This is a **Critical Severity** vulnerability (up to $1,000,000 per Aptos bug bounty program) because it causes:

1. **Consensus Safety Violations**: Different validators executing the same block can produce different state roots due to non-deterministic validation decisions. This is explicitly listed as a Critical impact in the Aptos bug bounty: "Different validators commit different blocks."

2. **Non-Deterministic Execution**: The same validator running the same block multiple times may produce different results, completely breaking determinism guarantees required for blockchain consensus.

3. **Invalid Transaction Commits**: Transactions with stale module reads can commit when they should have been invalidated and re-executed, leading to incorrect on-chain state that diverges across validators.

4. **Potential Chain Split**: If validators diverge on state roots, this can cause a permanent network partition requiring emergency intervention or hard forks to resolve, meeting the "Non-recoverable network partition" Critical impact criterion.

The vulnerability directly affects consensus safety, which is the highest severity category in the Aptos bug bounty program.

## Likelihood Explanation

**Likelihood: HIGH**

This race condition will occur frequently in production:

1. **Natural Occurrence**: The race happens during normal parallel execution whenever modules are published. No attacker action or special permissions are required - any transaction sender can publish modules.

2. **Timing Window**: The vulnerable window exists whenever:
   - A transaction finishes module publishing (microseconds to milliseconds)
   - Other transactions' validation checks are running concurrently (microseconds to milliseconds)
   
   On multi-core validator systems with high transaction throughput, concurrent execution and validation are the norm, making this race window frequently encountered.

3. **Module Publishing Frequency**: Module publishing occurs during:
   - Smart contract deployments by users
   - Protocol upgrades
   - Framework updates
   
   Even occasional module publishing triggers the vulnerability.

4. **BlockSTM V1 Still In Use**: BlockSTM V1 is still part of the codebase and can be configured: [8](#0-7) 

5. **Relaxed Atomics Provide No Synchronization**: `Ordering::Relaxed` provides zero synchronization guarantees between threads for different atomic variables. The happens-before relationship required for correctness is not established when validation tasks are obtained before the flag update.

## Recommendation

Replace `Ordering::Relaxed` with stronger memory ordering for the `skip_module_reads_validation` flag:

**Option 1 (Recommended)**: Use `Ordering::Release` for stores and `Ordering::Acquire` for loads:

```rust
// In record_validation_requirements (scheduler_wrapper.rs:87)
skip_module_reads_validation.store(false, Ordering::Release);

// In validate (executor.rs:1372)
skip_module_reads_validation.load(Ordering::Acquire)
```

This establishes a synchronize-with relationship: the Release store synchronizes-with the Acquire load, creating a happens-before edge that ensures all prior modifications (including module publications) are visible to the validating thread.

**Option 2**: Use `Ordering::SeqCst` for both operations for maximum safety:

```rust
skip_module_reads_validation.store(false, Ordering::SeqCst);
skip_module_reads_validation.load(Ordering::SeqCst)
```

Both options provide the necessary synchronization to prevent the race condition. Option 1 is more efficient while Option 2 provides stronger guarantees with minimal performance overhead given the infrequency of module publishing.

## Proof of Concept

A theoretical PoC demonstrating the race condition would require:

1. A multi-threaded test environment simulating BlockSTM V1 parallel execution
2. Transaction T1 that publishes a module
3. Transaction T2 that reads a module
4. Careful timing to observe T2's validation reading the stale flag value

The race condition is timing-dependent and may not manifest in every execution, which is precisely why it's dangerous in production - it leads to non-deterministic consensus behavior that's difficult to debug.

A concrete stress test could be constructed to increase the likelihood of observing the race by:
- Using multiple worker threads (8+)
- Executing blocks with frequent module publishing
- Adding instrumentation to log flag reads during validation
- Running repeatedly until the race manifests (stale flag=true observed after module publication)

However, the memory ordering issue is conclusively demonstrated by the code inspection above - the use of `Ordering::Relaxed` on separate atomic variables without proper synchronization is a well-known anti-pattern in concurrent programming that violates the Rust/C++ memory model's requirements for cross-thread visibility.

## Notes

1. This vulnerability only affects BlockSTM V1. BlockSTM V2 uses a different validation mechanism and doesn't use the `skip_module_reads_validation` flag at all.

2. The code comment claiming synchronization occurs through `validation_idx` is misleading. While `validation_idx` uses stronger ordering (`SeqCst`/`Acquire`), this only provides synchronization for operations on `validation_idx` itself, not for the separate `skip_module_reads_validation` atomic variable.

3. The final validation in `materialize_txn_commit` explicitly skips module validation (passes `true` for the flag), so it provides no safety net to catch this issue: [9](#0-8)

### Citations

**File:** aptos-move/block-executor/src/executor.rs (L810-815)
```rust
            && (skip_module_reads_validation
                || read_set.validate_module_reads(
                    global_module_cache,
                    versioned_cache.module_cache(),
                    None,
                ))
```

**File:** aptos-move/block-executor/src/executor.rs (L1043-1057)
```rust
        // Publish modules before we decrease validation index (in V1) so that validations observe
        // the new module writes as well.
        if last_input_output.publish_module_write_set(
            txn_idx,
            global_module_cache,
            versioned_cache,
            runtime_environment,
            &scheduler,
        )? {
            side_effect_at_commit = true;
        }

        if side_effect_at_commit {
            scheduler.wake_dependencies_and_decrease_validation_idx(txn_idx)?;
        }
```

**File:** aptos-move/block-executor/src/executor.rs (L1142-1154)
```rust
        if !Self::validate(
            txn_idx,
            last_input_output,
            shared_sync_params.global_module_cache,
            shared_sync_params.versioned_cache,
            // Module cache is not versioned (published at commit), so validation after
            // commit might observe later publishes (higher txn index) and be incorrect.
            // Hence, we skip the paranoid module validation after commit.
            // TODO(BlockSTMv2): Do the additional checking in sequential commit hook,
            // when modules have been published. Update the comment here as skipping
            // in V2 is needed for a different, code cache implementation related reason.
            true,
        ) {
```

**File:** aptos-move/block-executor/src/executor.rs (L1367-1373)
```rust
                    let valid = Self::validate(
                        txn_idx,
                        last_input_output,
                        global_module_cache,
                        versioned_cache,
                        skip_module_reads_validation.load(Ordering::Relaxed),
                    );
```

**File:** aptos-move/block-executor/src/executor.rs (L1895-1895)
```rust
        let skip_module_reads_validation = AtomicBool::new(true);
```

**File:** aptos-move/block-executor/src/executor.rs (L1922-1943)
```rust
        self.executor_thread_pool.scope(|s| {
            for worker_id in &worker_ids {
                s.spawn(|_| {
                    let environment = module_cache_manager_guard.environment();
                    let executor = {
                        let _init_timer = VM_INIT_SECONDS.start_timer();
                        E::init(
                            &environment.clone(),
                            base_view,
                            async_runtime_checks_enabled,
                        )
                    };

                    if let Err(err) = self.worker_loop(
                        &executor,
                        environment,
                        signature_verified_block,
                        &scheduler,
                        &skip_module_reads_validation,
                        &shared_sync_params,
                        num_workers,
                    ) {
```

**File:** aptos-move/block-executor/src/executor.rs (L2558-2573)
```rust
            let parallel_result = if self.config.local.blockstm_v2 {
                BLOCKSTM_VERSION_NUMBER.set(2);
                self.execute_transactions_parallel_v2(
                    signature_verified_block,
                    base_view,
                    transaction_slice_metadata,
                    module_cache_manager_guard,
                )
            } else {
                BLOCKSTM_VERSION_NUMBER.set(1);
                self.execute_transactions_parallel(
                    signature_verified_block,
                    base_view,
                    transaction_slice_metadata,
                    module_cache_manager_guard,
                )
```

**File:** aptos-move/block-executor/src/scheduler_wrapper.rs (L84-87)
```rust
            SchedulerWrapper::V1(_, skip_module_reads_validation) => {
                // Relaxed suffices as syncronization (reducing validation index) occurs after
                // setting the module read validation flag.
                skip_module_reads_validation.store(false, Ordering::Relaxed);
```
