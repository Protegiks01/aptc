# Audit Report

## Title
Authentication Bypass in Admin Service Mempool Parking Lot Endpoint on Non-Mainnet Networks

## Summary
The Aptos admin service automatically grants unauthenticated access to all endpoints, including the mempool parking lot endpoint, when `authentication_configs` is empty. This occurs by default on testnet, devnet, and custom networks, exposing sensitive transaction metadata about which accounts have pending transactions.

## Finding Description

The vulnerability exists in the authentication logic of the admin service request handler. When the `authentication_configs` vector is empty, the service unconditionally grants authentication to all requests: [1](#0-0) 

This authentication bypass allows unauthenticated access to the parking lot endpoint which exposes account addresses and their pending transaction counts: [2](#0-1) 

The parking lot endpoint returns data from the mempool's ParkingLotIndex, which contains tuples of account addresses and transaction counts for accounts with non-ready (parked) transactions: [3](#0-2) 

**Root Cause Configuration:**

The default configuration has an empty authentication vector: [4](#0-3) 

The admin service binds to all network interfaces by default, making it network-accessible: [5](#0-4) 

The configuration sanitizer only enforces authentication requirements for mainnet, explicitly allowing empty authentication configs on other networks: [6](#0-5) 

**Attack Path:**
1. Attacker identifies a testnet/devnet/custom network node running with default admin service configuration
2. Attacker sends HTTP GET request to `http://<node-ip>:9102/debug/mempool/parking-lot/addresses`
3. Service grants authentication due to empty `authentication_configs`
4. Endpoint returns BCS-serialized `Vec<(AccountAddress, u64)>` containing all parked transaction addresses and counts

**Information Disclosed:**
- Specific account addresses with pending transactions in the parking lot
- Number of parked transactions per account
- Real-time transaction activity patterns through continuous polling
- Identification of high-activity accounts for targeted analysis

## Impact Explanation

This issue qualifies as **Medium severity** per the Aptos bug bounty criteria for the following reasons:

**Privacy Violation**: The endpoint exposes which specific accounts are actively submitting transactions and experiencing sequence number gaps. This metadata can be used to:
- Build transaction activity profiles for targeted accounts
- Identify potential high-value targets (accounts with frequent transaction activity)
- Monitor business-critical transaction patterns on private testnets
- Correlate network activity with off-chain events

**Network-Wide Exposure**: The default binding to `0.0.0.0` exposes this endpoint to any network attacker who can reach port 9102, not just localhost-only access.

**Organizational Impact**: Many organizations run private testnet or devnet deployments for development and testing with sensitive business logic. Exposing transaction patterns from these networks could leak proprietary information.

While this doesn't directly cause fund loss or consensus violations (Critical severity), it represents an information disclosure vulnerability that could enable more sophisticated attacks or privacy violations, fitting the Medium severity category of "state inconsistencies requiring intervention" in terms of requiring security configuration changes.

## Likelihood Explanation

**Likelihood: HIGH** for non-mainnet deployments

- **Default Configuration**: Testnet and devnet nodes enable the admin service by default with empty authentication
- **Easy Exploitation**: Requires only a simple HTTP GET request, no authentication or complex setup
- **Wide Attack Surface**: Any node operator running default configurations on testnet/devnet is vulnerable
- **Discovery**: Admin service port (9102) is well-known and easily discoverable through port scanning
- **No Warning**: Node operators receive no explicit warning that debug endpoints are unauthenticated

The configuration optimizer automatically enables the admin service for non-mainnet chains: [7](#0-6) 

## Recommendation

**Immediate Fix**: Require authentication for admin service endpoints on ALL networks, not just mainnet, or at least bind to localhost by default.

**Option 1 - Enforce Authentication on All Networks:**
```rust
impl ConfigSanitizer for AdminServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();

        if node_config.admin_service.enabled == Some(true) 
            && node_config.admin_service.authentication_configs.is_empty() 
        {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Must enable authentication for AdminService on all networks. Set authentication_configs or disable the service.".into(),
            ));
        }

        Ok(())
    }
}
```

**Option 2 - Default to Localhost Binding:**
Change the default address from "0.0.0.0" to "127.0.0.1" to limit exposure to local-only access:
```rust
impl Default for AdminServiceConfig {
    fn default() -> Self {
        Self {
            enabled: None,
            address: "127.0.0.1".to_string(), // Changed from "0.0.0.0"
            port: 9102,
            authentication_configs: vec![],
            malloc_stats_max_len: 2 * 1024 * 1024,
        }
    }
}
```

**Option 3 - Require Explicit Opt-In:**
Remove the automatic authentication bypass and require explicit authentication even when empty, or add a separate `allow_unauthenticated` flag that must be explicitly set.

## Proof of Concept

**Setup Prerequisites:**
- Aptos node running on testnet or devnet with default admin service configuration
- Node IP address accessible to attacker

**Exploitation Steps:**

```bash
# 1. Identify target node
TARGET_NODE="testnet-node.example.com"
ADMIN_PORT=9102

# 2. Access parking lot endpoint without authentication
curl -v "http://${TARGET_NODE}:${ADMIN_PORT}/debug/mempool/parking-lot/addresses"

# Expected Response: 200 OK with BCS-serialized Vec<(AccountAddress, u64)>
# The response contains all account addresses with parked transactions and their counts

# 3. Decode BCS response to view actual data
# (Requires BCS deserialization library)
curl -s "http://${TARGET_NODE}:${ADMIN_PORT}/debug/mempool/parking-lot/addresses" | \
  bcs-decode-tool --type "Vec<(AccountAddress, u64)>" > parking_lot_data.json

# 4. Continuous monitoring to track transaction patterns
while true; do
  curl -s "http://${TARGET_NODE}:${ADMIN_PORT}/debug/mempool/parking-lot/addresses" \
    >> transaction_activity_log.txt
  sleep 5
done
```

**Rust Integration Test:**
```rust
#[tokio::test]
async fn test_unauthenticated_parking_lot_access() {
    // Start admin service with default config (empty authentication_configs)
    let mut node_config = NodeConfig::default();
    node_config.admin_service.enabled = Some(true);
    node_config.admin_service.authentication_configs = vec![]; // Empty
    
    let admin_service = AdminService::new(&node_config);
    
    // Create HTTP client
    let client = hyper::Client::new();
    
    // Attempt to access parking lot endpoint without authentication
    let uri = "http://127.0.0.1:9102/debug/mempool/parking-lot/addresses"
        .parse()
        .unwrap();
    
    let response = client.get(uri).await.unwrap();
    
    // Verify unauthenticated access succeeds
    assert_eq!(response.status(), StatusCode::OK);
    
    // Verify data is returned (BCS-serialized parking lot addresses)
    let body_bytes = hyper::body::to_bytes(response.into_body()).await.unwrap();
    let addresses: Vec<(AccountAddress, u64)> = bcs::from_bytes(&body_bytes).unwrap();
    
    // Successfully retrieved parking lot data without authentication
    println!("Retrieved {} parking lot entries without auth", addresses.len());
}
```

**Notes:**
- This vulnerability is **by design** for non-mainnet networks but represents a security risk for private deployments
- The sanitizer explicitly allows this behavior for testnet/devnet, indicating intentional design choice
- However, default network exposure (0.0.0.0 binding) combined with no authentication creates unnecessary risk
- Organizations running private testnets may not be aware of this exposure

### Citations

**File:** crates/aptos-admin-service/src/server/mod.rs (L154-156)
```rust
        let mut authenticated = false;
        if context.config.authentication_configs.is_empty() {
            authenticated = true;
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L230-241)
```rust
            (hyper::Method::GET, "/debug/mempool/parking-lot/addresses") => {
                let mempool_client_sender = context.mempool_client_sender.read().clone();
                if let Some(mempool_client_sender) = mempool_client_sender {
                    mempool::mempool_handle_parking_lot_address_request(req, mempool_client_sender)
                        .await
                } else {
                    Ok(reply_with_status(
                        StatusCode::NOT_FOUND,
                        "Mempool parking lot is not available.",
                    ))
                }
            },
```

**File:** mempool/src/core_mempool/index.rs (L652-657)
```rust
    pub(crate) fn get_addresses(&self) -> Vec<(AccountAddress, u64)> {
        self.data
            .iter()
            .map(|(addr, txns)| (*addr, txns.len() as u64))
            .collect::<Vec<(AccountAddress, u64)>>()
    }
```

**File:** config/src/config/admin_service_config.rs (L45-45)
```rust
            address: "0.0.0.0".to_string(),
```

**File:** config/src/config/admin_service_config.rs (L47-47)
```rust
            authentication_configs: vec![],
```

**File:** config/src/config/admin_service_config.rs (L67-77)
```rust
        if node_config.admin_service.enabled == Some(true) {
            if let Some(chain_id) = chain_id {
                if chain_id.is_mainnet()
                    && node_config.admin_service.authentication_configs.is_empty()
                {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Must enable authentication for AdminService on mainnet.".into(),
                    ));
                }
            }
```

**File:** config/src/config/admin_service_config.rs (L94-100)
```rust
            // Only enable the admin service if the chain is not mainnet
            let admin_service_enabled = if let Some(chain_id) = chain_id {
                !chain_id.is_mainnet()
            } else {
                false // We cannot determine the chain ID, so we disable the admin service
            };
            node_config.admin_service.enabled = Some(admin_service_enabled);
```
