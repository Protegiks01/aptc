# Audit Report

## Title
Bypass Mechanism Lacks Dedicated Metrics, Making Abuse Invisible to Automated Detection

## Summary
The faucet bypass mechanism allows requests with valid bypass credentials (auth tokens or allowlisted IPs) to skip rate limiting, but these bypass events are not tracked by any dedicated metrics. This makes bypass abuse invisible to automated abuse detection systems, enabling potential fund drainage attacks.

## Finding Description

When a request successfully bypasses rate limiting via `request_can_bypass()`, the following occurs: [1](#0-0) 

The bypass is only logged as an info message with no dedicated metric counter. Subsequently, the bypassed request skips all checker validation and completion steps: [2](#0-1) 

This means:
1. **No bypass-specific metrics exist** - The metrics module defines counters for rejections, response status, and histograms, but no bypass counter: [3](#0-2) 

2. **Rate limit counters not updated** - The checker's `complete()` method is skipped, so rate limit storage (Redis/memory) is never incremented for bypassed requests: [4](#0-3) 

3. **Rejection metrics don't fire** - Bypassed requests succeed without rejections, so the rejection counter is never incremented: [5](#0-4) 

**Attack Scenario:**
An attacker who obtains valid bypass credentials (through social engineering, misconfiguration, or insider access) can:
1. Make unlimited funding requests using the bypass token
2. Each request bypasses rate limits and successfully funds accounts
3. These requests appear only as generic HTTP 200 responses in `HISTOGRAM` and `RESPONSE_STATUS` metrics
4. Automated abuse detection systems monitoring rate limit exhaustion or unusual request patterns per IP/identifier will not detect this abuse
5. Only manual log inspection would reveal the pattern, which may not be timely

## Impact Explanation

This is **Medium severity** per Aptos bug bounty criteria:
- **Limited funds loss or manipulation**: An attacker with compromised bypass credentials can drain the faucet account balance by making unlimited funding requests
- The faucet holds real funds (mainnet) or valuable test tokens (testnet/devnet)
- Abuse remains invisible to automated monitoring systems that rely on:
  - Rate limit exhaustion metrics (`REJECTION_REASONS` with `UsageLimitExhausted`)
  - Request count anomalies per identifier
  - Storage-based abuse detection patterns

The impact is limited because:
- Attacker needs valid bypass credentials (not trivially obtainable)
- Only affects faucet funds, not core blockchain consensus or validator operations
- Can be detected through manual log analysis (though not in real-time)

## Likelihood Explanation

**Medium-High likelihood** of exploitation if bypass credentials are compromised:

**Attacker requirements:**
- Valid bypass token (AuthTokenBypasser) OR
- IP address in the allowlist (IpAllowlistBypasser)

**Feasibility:**
- Bypass tokens may be shared internally, leaked in configuration, or obtained through social engineering
- IP allowlists may be misconfigured to include broad ranges
- Once credentials are obtained, exploitation is trivial and undetectable by automated systems

**Real-world scenarios:**
- Contractor with bypass token access shares it publicly
- CI/CD pipeline leaks bypass token in logs
- IP allowlist misconfigured to include public IP ranges
- Former employee retains bypass token after leaving

## Recommendation

Add dedicated metrics for bypass events to enable proper monitoring and alerting:

```rust
// In crates/aptos-faucet/core/src/middleware/metrics.rs

static BYPASS_COUNTER: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "aptos_tap_bypass_count",
        "Number of requests that bypassed checkers/storage",
        &["bypasser_type", "source_ip"]
    )
    .unwrap()
});

pub fn record_bypass(bypasser_type: &str, source_ip: &str) {
    BYPASS_COUNTER
        .with_label_values(&[bypasser_type, source_ip])
        .inc();
}
```

Then in `fund.rs`, record the bypass event:

```rust
// After line 252, when bypass is successful
if bypasser.request_can_bypass(checker_data.clone()).await? {
    let bypasser_type = match bypasser {
        Bypasser::AuthTokenBypasser(_) => "auth_token",
        Bypasser::IpAllowlistBypasser(_) => "ip_allowlist",
    };
    
    record_bypass(bypasser_type, &source_ip.to_string());
    
    info!(
        "Allowing request from {} to bypass checks / storage via {}",
        source_ip, bypasser_type
    );
    return Ok((checker_data, true, permit));
}
```

Additionally:
1. Set up alerting on high bypass rates per IP/token
2. Implement bypass rate limiting (even bypass tokens should have reasonable limits)
3. Add audit logging for all bypass events with detailed metadata
4. Regular review of bypass credential usage patterns

## Proof of Concept

```rust
// Test demonstrating that bypassed requests don't increment metrics
// Place in crates/aptos-faucet/core/src/endpoints/fund.rs

#[cfg(test)]
mod bypass_metrics_test {
    use super::*;
    use crate::middleware::metrics::REJECTION_REASONS;
    
    #[tokio::test]
    async fn test_bypass_skips_rate_limit_metrics() {
        // Setup faucet with auth token bypasser
        let bypass_token = "test-bypass-token";
        let bypasser = AuthTokenBypasser::new(
            ListManagerConfig {
                list: vec![bypass_token.to_string()],
                ..Default::default()
            }
        ).unwrap();
        
        let components = FundApiComponents {
            bypassers: vec![Bypasser::from(bypasser)],
            checkers: vec![/* rate limiter checker */],
            funder: Arc::new(/* test funder */),
            return_rejections_early: false,
            concurrent_requests_semaphore: None,
        };
        
        // Make request with bypass token
        let mut header_map = HeaderMap::new();
        header_map.insert(
            AUTHORIZATION,
            format!("Bearer {}", bypass_token).parse().unwrap()
        );
        
        let initial_rejection_count = get_rejection_metric_count();
        
        // Fund account via bypass
        let result = components.fund_inner(
            fund_request,
            source_ip,
            &header_map,
            false,
            None
        ).await;
        
        assert!(result.is_ok());
        
        // Verify no rejection metrics were incremented
        let final_rejection_count = get_rejection_metric_count();
        assert_eq!(initial_rejection_count, final_rejection_count,
            "Bypassed requests should not increment rejection metrics");
        
        // Verify no bypass-specific metric exists (this will fail)
        // demonstrating the vulnerability
        // assert!(BYPASS_COUNTER.with_label_values(&["auth_token", "..."]).get() > 0);
    }
}
```

This test demonstrates that bypassed requests succeed without incrementing any abuse-detection metrics, making them invisible to automated monitoring systems.

---

## Notes

While the faucet is not part of the core blockchain consensus layer, it represents a funded account that can be drained through unmonitored bypass abuse. The lack of bypass metrics violates the observability invariant necessary for detecting and preventing abuse of privileged access mechanisms.

### Citations

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L244-259)
```rust
        // See if this request meets the criteria to bypass checkers / storage.
        for bypasser in &self.bypassers {
            if bypasser
                .request_can_bypass(checker_data.clone())
                .await
                .map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::BypasserError)
                })?
            {
                info!(
                    "Allowing request from {} to bypass checks / storage",
                    source_ip
                );
                return Ok((checker_data, true, permit));
            }
        }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L332-347)
```rust
        if !bypass {
            let response_is_500 = match &fund_result {
                Ok(_) => false,
                Err(e) => e.error_code.status().is_server_error(),
            };
            let complete_data = CompleteData {
                checker_data,
                txn_hashes: txn_hashes.clone(),
                response_is_500,
            };
            for checker in &self.checkers {
                checker.complete(complete_data.clone()).await.map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError)
                })?;
            }
        }
```

**File:** crates/aptos-faucet/core/src/middleware/metrics.rs (L11-44)
```rust
pub static HISTOGRAM: Lazy<HistogramVec> = Lazy::new(|| {
    register_histogram_vec!(
        "aptos_tap_requests",
        "Tap requests latency grouped by method, operation_id and status.",
        &["method", "operation_id", "status"]
    )
    .unwrap()
});

pub static RESPONSE_STATUS: Lazy<HistogramVec> = Lazy::new(|| {
    register_histogram_vec!(
        "aptos_tap_response_status",
        "Tap requests latency grouped by status code only.",
        &["status"]
    )
    .unwrap()
});

static REJECTION_REASONS: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "aptos_tap_rejection_reason_count",
        "Number of times the tap has returned the given rejection reason.",
        &["rejection_reason_code"]
    )
    .unwrap()
});

pub static NUM_OUTSTANDING_TRANSACTIONS: Lazy<IntGauge> = Lazy::new(|| {
    register_int_gauge!(
        "aptos_tap_num_outstanding_transactions",
        "Number of transactions we've submitted but have not been processed by the blockchain.",
    )
    .unwrap()
});
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L308-335)
```rust
    async fn complete(&self, data: CompleteData) -> Result<(), AptosTapError> {
        if !data.response_is_500 {
            return Ok(());
        }

        let mut conn = self
            .get_redis_connection()
            .await
            .map_err(|e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::StorageError))?;

        // Generate a key corresponding to this identifier and the current day. In the
        // JWT case we re-verify the JWT. This is inefficient, but these failures are
        // extremely rare so I don't refactor for now.
        let key_prefix = self.ratelimit_key_provider.ratelimit_key_prefix();
        let key_value = self
            .ratelimit_key_provider
            .ratelimit_key_value(&data.checker_data)
            .await?;
        let (key, _) = self.get_key_and_secs_until_next_day(key_prefix, &key_value);

        let _: () = conn.decr(&key, 1).await.map_err(|e| {
            AptosTapError::new_with_error_code(
                format!("Failed to decrement value for redis key {}: {}", key, e),
                AptosTapErrorCode::StorageError,
            )
        })?;
        Ok(())
    }
```

**File:** crates/aptos-faucet/core/src/endpoints/errors.rs (L100-109)
```rust
impl From<AptosTapError> for AptosTapErrorResponse {
    fn from(error: AptosTapError) -> Self {
        // We use this opportunity to bump metrics based on the specifics of
        // this response, since this function is only called right when we're
        // about to return this error to the client.
        bump_rejection_reason_counters(&error.rejection_reasons);
        let (status, retry_after) = error.status_and_retry_after();
        Self::Default(status, Json(error), retry_after)
    }
}
```
