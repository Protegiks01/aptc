# Audit Report

## Title
Missing fsync() in OnDiskStorage Enables Consensus Safety Violations After Crash

## Summary
The `OnDiskStorage` backend used for consensus safety rules persistence lacks `fsync()` calls, causing safety-critical data to be lost on system crashes. This enables validators to double-vote after restart, violating consensus safety guarantees.

## Finding Description

The Aptos consensus safety-rules system relies on persistent storage to maintain critical safety invariants like `last_voted_round`. The storage abstraction contract states "Any set function is expected to sync to the remote system before returning" [1](#0-0) , but `OnDiskStorage` violates this guarantee.

When a validator votes for a block, the flow is:
1. SafetyRules updates `last_voted_round` in `SafetyData` [2](#0-1) 
2. Calls `persistent_storage.set_safety_data()` to persist [3](#0-2) 
3. This eventually calls `OnDiskStorage::write()` [4](#0-3) 

The critical bug is in `OnDiskStorage::write()` which performs:
- Creates temp file
- Writes data via `file.write_all(&contents)?`
- Renames temp file to actual file
- Returns `Ok(())`

**But never calls `fsync()` or `sync_all()`** on the file or directory. This means data remains in OS page cache and is not guaranteed to reach physical storage before the function returns.

The README explicitly warns OnDiskStorage "should not be used in production" [5](#0-4) , yet production deployment configs use it for safety rules: [6](#0-5) [7](#0-6) 

**Attack Scenario:**
1. Validator node receives proposal for round R
2. SafetyRules validates and creates vote
3. Updates `last_voted_round = R` in memory
4. Calls `set_safety_data()` which succeeds and returns `Ok(())`
5. Data written to file system but only in OS buffer (not flushed to disk)
6. **System crash occurs** (power failure, kernel panic, OOM kill)
7. Node restarts and reads safety data from disk
8. `last_voted_round` is still at old value < R (pre-vote state)
9. Node can vote again for round R, potentially with different vote
10. **Consensus safety violation: double-voting in same round**

This directly violates the consensus safety invariant that prevents equivocation.

## Impact Explanation

**Critical Severity** - This vulnerability enables consensus safety violations, specifically:

1. **Consensus Safety Violation**: The "vote once per round" rule can be violated, allowing equivocation [8](#0-7) 

2. **Chain Splits**: If multiple validators experience crashes and double-vote differently, the network can form conflicting quorum certificates for the same round

3. **Byzantine Behavior from Honest Validators**: Honest validators become accidentally Byzantine through natural system crashes

4. **Affects All Nodes**: Any validator using OnDiskStorage (per deployment configs) is vulnerable

Per the Aptos Bug Bounty program, this qualifies as **Critical Severity** ($1M) under "Consensus/Safety violations" - the ability to break consensus safety guarantees through double-voting.

## Likelihood Explanation

**High Likelihood:**

1. **Natural Trigger**: System crashes (power failures, kernel panics, OOM) are common in production environments
2. **No Attacker Required**: Vulnerability triggers through normal operational events
3. **Default Configuration**: Production deployment configs use the vulnerable storage backend
4. **Window of Vulnerability**: The window between `write_all()` returning and OS buffer flush can be several seconds
5. **High Vote Frequency**: Validators vote frequently (every consensus round), maximizing exposure

The likelihood increases with:
- Number of validators using OnDiskStorage
- System instability (resource pressure, infrastructure issues)
- Frequency of crashes/restarts during operations

## Recommendation

**Immediate Fix**: Add `fsync()` calls to ensure durability before `write()` returns:

```rust
fn write(&self, data: &HashMap<String, Value>) -> Result<(), Error> {
    let contents = serde_json::to_vec(data)?;
    let mut file = File::create(self.temp_path.path())?;
    file.write_all(&contents)?;
    file.sync_all()?;  // ADD: Ensure data reaches disk
    fs::rename(&self.temp_path, &self.file_path)?;
    
    // ADD: Sync directory to ensure rename is durable
    let dir = File::open(self.file_path.parent().unwrap())?;
    dir.sync_all()?;
    
    Ok(())
}
```

**Long-term Solutions:**
1. **Deprecate OnDiskStorage for Production**: Update docs and configs to mandate Vault for consensus safety rules
2. **Add Durability Tests**: Create crash-recovery tests that verify safety data survives crashes
3. **Config Validation**: Add startup checks that reject OnDiskStorage for safety rules in production mode
4. **Metrics/Alerts**: Monitor storage backend type and alert if OnDiskStorage is used in production

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[test]
fn test_crash_causes_safety_violation() {
    use aptos_secure_storage::{OnDiskStorage, KVStorage};
    use consensus_types::safety_data::SafetyData;
    
    // Setup OnDiskStorage
    let temp_file = tempfile::NamedTempFile::new().unwrap();
    let mut storage = OnDiskStorage::new(temp_file.path().to_path_buf());
    
    // Initial state: last_voted_round = 5
    let initial_data = SafetyData::new(1, 5, 0, 0, None, 0);
    storage.set("safety_data", initial_data.clone()).unwrap();
    
    // Simulate voting for round 10
    let voted_data = SafetyData::new(1, 10, 0, 0, None, 0);
    storage.set("safety_data", voted_data.clone()).unwrap();
    // Function returns Ok, but data may still be in OS buffers
    
    // SIMULATE CRASH: Drop storage without allowing OS to flush
    drop(storage);
    std::process::Command::new("sync").status().ok(); // Try to flush
    
    // RESTART: Create new storage instance reading from disk
    let mut recovered_storage = OnDiskStorage::new(temp_file.path().to_path_buf());
    let recovered: SafetyData = recovered_storage.get("safety_data")
        .unwrap().value;
    
    // BUG: May read stale data (last_voted_round = 5 instead of 10)
    // This allows double-voting for rounds 6-10
    println!("Expected last_voted_round: 10");
    println!("Actual last_voted_round: {}", recovered.last_voted_round);
    
    // In practice, without fsync, this test may pass OR fail depending
    // on OS buffer flush timing, demonstrating the race condition
}
```

**Notes:**
- The actual manifestation of this bug requires real crash conditions (not just process termination)
- Testing requires crash injection tools or kernel-level fault injection
- The vulnerability is more easily demonstrated on systems under memory pressure where page cache is aggressively reclaimed
- Production validators using OnDiskStorage are at risk during any unclean shutdown scenario

### Citations

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L18-18)
```rust
/// Any set function is expected to sync to the remote system before returning.
```

**File:** consensus/consensus-types/src/safety_data.rs (L10-21)
```rust
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L92-92)
```rust
        self.persistent_storage.set_safety_data(safety_data)?;
```

**File:** secure/storage/src/on_disk.rs (L64-70)
```rust
    fn write(&self, data: &HashMap<String, Value>) -> Result<(), Error> {
        let contents = serde_json::to_vec(data)?;
        let mut file = File::create(self.temp_path.path())?;
        file.write_all(&contents)?;
        fs::rename(&self.temp_path, &self.file_path)?;
        Ok(())
    }
```

**File:** secure/storage/README.md (L37-42)
```markdown
- `OnDisk`: Similar to InMemory, the OnDisk secure storage implementation provides another
useful testing implementation: an on-disk storage engine, where the storage backend is
implemented using a single file written to local disk. In a similar fashion to the in-memory
storage, on-disk should not be used in production environments as it provides no security
guarantees (e.g., encryption before writing to disk). Moreover, OnDisk storage does not
currently support concurrent data accesses.
```

**File:** docker/compose/aptos-node/validator.yaml (L11-13)
```yaml
    backend:
      type: "on_disk_storage"
      path: secure-data.json
```

**File:** terraform/helm/aptos-node/files/configs/validator-base.yaml (L14-16)
```yaml
    backend:
      type: "on_disk_storage"
      path: secure-data.json
```

**File:** consensus/safety-rules/src/safety_rules.rs (L213-232)
```rust
    pub(crate) fn verify_and_update_last_vote_round(
        &self,
        round: Round,
        safety_data: &mut SafetyData,
    ) -> Result<(), Error> {
        if round <= safety_data.last_voted_round {
            return Err(Error::IncorrectLastVotedRound(
                round,
                safety_data.last_voted_round,
            ));
        }

        safety_data.last_voted_round = round;
        trace!(
            SafetyLogSchema::new(LogEntry::LastVotedRound, LogEvent::Update)
                .last_voted_round(safety_data.last_voted_round)
        );

        Ok(())
    }
```
