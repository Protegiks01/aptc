# Audit Report

## Title
Transaction History Bloat via Inadequate Storage Fee for Transaction Data in DiskSpacePricing V2

## Summary
The current gas pricing model (DiskSpacePricing V2) charges only IO gas (89 internal gas per byte) for transaction data storage but imposes **zero long-term storage fees** for transaction bytes. [1](#0-0)  This allows attackers to economically fill the ledger database with maximum-size (64KB) transactions at a cost of only ~0.00008378 APT per transaction, enabling denial-of-service attacks against archival nodes and causing excessive disk usage on regular nodes.

## Finding Description

### Gas Pricing Analysis
The `storage_io_per_transaction_byte_write` parameter charges 89 internal gas per byte for transaction data storage. [2](#0-1)  This IO gas is calculated and charged during transaction execution. [3](#0-2) [4](#0-3) 

With a gas scaling factor of 1,000,000, [5](#0-4)  this translates to 0.000089 external gas units per byte, or 5.832704 external gas for a 64KB transaction's data storage alone.

### Critical Vulnerability: Zero Storage Fees in V2
The `DiskSpacePricing` implementation has two versions. In V2 (active when `gas_feature_version >= 13` and `REFUNDABLE_BYTES` feature flag is enabled), the `legacy_storage_fee_for_transaction_storage` function **returns zero**. [1](#0-0) 

The current gas feature version is 45 (RELEASE_V1_41), [6](#0-5)  and the REFUNDABLE_BYTES feature flag (value 51) was introduced in V14. [7](#0-6) [8](#0-7) 

This means transaction data incurs **no long-term storage penalty**, only the IO cost of writing.

### Maximum Transaction Size
Transactions can be up to 64KB (65,536 bytes) in size. [9](#0-8)  The transaction size is extracted from the raw transaction bytes. [10](#0-9) 

### Pruning Mechanism
The ledger pruner maintains a default prune window of 90 million versions. [11](#0-10)  Pruning removes transactions that fall outside this window. [12](#0-11) 

However, **archival nodes disable pruning** to maintain full transaction history. [13](#0-12) 

### Attack Scenario
An attacker can exploit this by:

1. **Cost Calculation for 64KB Transaction:**
   - Intrinsic gas: 2,760,000 + (65,536 - 600) × 1,158 = 77,949,888 internal gas = 77.95 external gas
   - Transaction data IO: 65,536 × 89 = 5,832,704 internal gas = 5.83 external gas
   - Total: ~83.78 external gas units
   - At minimum gas price (100 octas/gas): 8,378 octas = 0.00008378 APT

2. **Disk Space Impact:**
   - Normal transactions (~1KB): 90M versions × 1KB ≈ 90 GB
   - Max-size transactions: 90M versions × 64KB ≈ 5.76 TB (64× increase)

3. **Economic Feasibility:**
   - Cost per GB: ~1.37 APT (~$13.70 at $10/APT)
   - Cost per TB: ~1,405 APT (~$14,050)
   - Cost to fill prune window: ~7,540 APT (~$75,400)

This breaks the **Resource Limits invariant**: "All operations must respect gas, storage, and computational limits." The gas pricing fails to adequately reflect long-term storage costs.

## Impact Explanation

**Medium Severity** per Aptos bug bounty criteria:

1. **Archival Nodes (Pruning Disabled):** Unbounded database growth leading to disk exhaustion and node crash. This causes "state inconsistencies requiring intervention" and partial network availability loss.

2. **Regular Nodes (Pruning Enabled):** Database stabilizes at 5.76 TB (64× larger than normal), potentially exceeding disk capacity on smaller nodes during the fill phase.

3. **Network-Wide Impact:** Sustained attacks could force node operators to increase storage provisioning or disable archival mode, reducing network data availability.

This does not qualify as Critical because it doesn't directly cause consensus safety violations, fund theft, or total network liveness loss. It's a resource exhaustion attack with measurable but bounded impact.

## Likelihood Explanation

**High Likelihood:**

1. **Low Attack Cost:** ~$14k/TB makes this economically feasible for determined attackers.
2. **No Special Privileges Required:** Any account with sufficient APT can execute this attack.
3. **Mempool Limits Bypassable:** Per-account limits (100 transactions) can be circumvented using multiple accounts.
4. **Archival Nodes Are Attractive Targets:** They cannot enable pruning without losing their archival purpose.
5. **No Rate Limiting on Transaction Size:** The system treats 1KB and 64KB transactions identically except for gas cost.

## Recommendation

**Immediate Fix:** Reintroduce storage fees for transaction data in DiskSpacePricing V2, or implement size-based pricing:

```rust
pub fn legacy_storage_fee_for_transaction_storage(
    &self,
    params: &TransactionGasParameters,
    txn_size: NumBytes,
) -> Fee {
    match self {
        Self::V1 => {
            txn_size
                .checked_sub(params.large_transaction_cutoff)
                .unwrap_or(NumBytes::zero())
                * params.legacy_storage_fee_per_transaction_byte
        },
        Self::V2 => {
            // FIX: Apply storage fee for transaction bytes
            // to prevent ledger bloat attacks
            let excess_bytes = txn_size
                .checked_sub(params.large_transaction_cutoff)
                .unwrap_or(NumBytes::zero());
            excess_bytes * params.storage_fee_per_state_byte
        },
    }
}
```

**Alternative Mitigation:** Implement dynamic transaction size limits based on recent network load, or charge progressive fees for larger transactions (e.g., quadratic pricing above a threshold).

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[test]
fn test_transaction_bloat_attack() {
    use aptos_gas_schedule::TransactionGasParameters;
    use aptos_types::transaction::SignedTransaction;
    use move_core_types::gas_algebra::NumBytes;
    
    let params = TransactionGasParameters::default();
    let max_txn_size = NumBytes::new(65536); // 64KB
    
    // Calculate IO gas cost only (V2 has zero storage fee)
    let io_gas = 89 * u64::from(max_txn_size); // internal gas
    let external_gas = io_gas / 1_000_000;
    let cost_octas = external_gas * 100; // min gas price
    let cost_apt = cost_octas as f64 / 100_000_000.0;
    
    println!("Cost per 64KB transaction: {} APT", cost_apt);
    
    // Calculate disk space for prune window
    let prune_window = 90_000_000_u64;
    let total_bytes = prune_window * 65536;
    let total_tb = total_bytes as f64 / (1024.0 * 1024.0 * 1024.0 * 1024.0);
    let total_cost = cost_apt * prune_window as f64;
    
    println!("Prune window size: {:.2} TB", total_tb);
    println!("Total cost to fill: {:.2} APT", total_cost);
    
    // Assert vulnerability exists
    assert!(cost_apt < 0.0001, "Transaction storage is too cheap");
    assert!(total_tb > 5.0, "Bloat potential is significant");
}
```

## Notes

This vulnerability was introduced when V14 removed transaction storage fees to simplify the fee model and focus on refundable state bytes. [8](#0-7)  However, this created an economic misalignment where the cost to store transaction data permanently (on archival nodes) or semi-permanently (in the prune window) doesn't reflect actual infrastructure costs. The IO gas charge covers only the immediate write cost, not ongoing storage burden.

### Citations

**File:** aptos-move/aptos-vm-types/src/storage/space_pricing.rs (L88-103)
```rust
    /// Calculates the storage fee for the transaction.
    pub fn legacy_storage_fee_for_transaction_storage(
        &self,
        params: &TransactionGasParameters,
        txn_size: NumBytes,
    ) -> Fee {
        match self {
            Self::V1 => {
                txn_size
                    .checked_sub(params.large_transaction_cutoff)
                    .unwrap_or(NumBytes::zero())
                    * params.legacy_storage_fee_per_transaction_byte
            },
            Self::V2 => 0.into(),
        }
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L22-22)
```rust
const GAS_SCALING_FACTOR: u64 = 1_000_000;
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L73-76)
```rust
            max_transaction_size_in_bytes: NumBytes,
            "max_transaction_size_in_bytes",
            64 * 1024
        ],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L137-141)
```rust
        [
            storage_io_per_transaction_byte_write: InternalGasPerByte,
            { RELEASE_V1_11.. => "storage_io_per_transaction_byte_write" },
            89,
        ],
```

**File:** aptos-move/aptos-vm-types/src/storage/io_pricing.rs (L289-294)
```rust
    pub fn io_gas_per_transaction(
        &self,
        txn_size: NumBytes,
    ) -> impl GasExpression<VMGasParameters, Unit = InternalGasUnit> + use<> {
        STORAGE_IO_PER_TRANSACTION_BYTE_WRITE * txn_size
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1112-1140)
```rust
    fn charge_change_set(
        &self,
        change_set: &mut impl ChangeSetInterface,
        gas_meter: &mut impl AptosGasMeter,
        txn_data: &TransactionMetadata,
        resolver: &impl AptosMoveResolver,
        module_storage: &impl AptosModuleStorage,
    ) -> Result<GasQuantity<Octa>, VMStatus> {
        gas_meter.charge_io_gas_for_transaction(txn_data.transaction_size())?;
        for event in change_set.events_iter() {
            gas_meter.charge_io_gas_for_event(event)?;
        }
        for (key, op_size) in change_set.write_set_size_iter() {
            gas_meter.charge_io_gas_for_write(key, &op_size)?;
        }

        let mut storage_refund = gas_meter.process_storage_fee_for_all(
            change_set,
            txn_data.transaction_size,
            txn_data.gas_unit_price,
            resolver.as_executor_view(),
            module_storage,
        )?;
        if !self.features().is_storage_deletion_refund_enabled() {
            storage_refund = 0.into();
        }

        Ok(storage_refund)
    }
```

**File:** aptos-move/aptos-gas-schedule/src/ver.rs (L33-35)
```rust
/// - V14
///   - Gas for type creation
///   - Storage Fee: Make state bytes refundable and remove the per slot free quota, gated by flag REFUNDABLE_BYTES
```

**File:** aptos-move/aptos-gas-schedule/src/ver.rs (L76-76)
```rust
pub const LATEST_GAS_FEATURE_VERSION: u64 = gas_feature_versions::RELEASE_V1_41;
```

**File:** types/src/on_chain_config/aptos_features.rs (L72-72)
```rust
    REFUNDABLE_BYTES = 51,
```

**File:** aptos-move/aptos-vm/src/transaction_metadata.rs (L63-63)
```rust
            transaction_size: (txn.raw_txn_bytes_len() as u64).into(),
```

**File:** config/src/config/storage_config.rs (L306-323)
```rust
pub const NO_OP_STORAGE_PRUNER_CONFIG: PrunerConfig = PrunerConfig {
    ledger_pruner_config: LedgerPrunerConfig {
        enable: false,
        prune_window: 0,
        batch_size: 0,
        user_pruning_window_offset: 0,
    },
    state_merkle_pruner_config: StateMerklePrunerConfig {
        enable: false,
        prune_window: 0,
        batch_size: 0,
    },
    epoch_snapshot_pruner_config: EpochSnapshotPrunerConfig {
        enable: false,
        prune_window: 0,
        batch_size: 0,
    },
};
```

**File:** config/src/config/storage_config.rs (L387-396)
```rust
impl Default for LedgerPrunerConfig {
    fn default() -> Self {
        LedgerPrunerConfig {
            enable: true,
            prune_window: 90_000_000,
            batch_size: 5_000,
            user_pruning_window_offset: 200_000,
        }
    }
}
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs (L162-176)
```rust
    fn set_pruner_target_db_version(&self, latest_version: Version) {
        assert!(self.pruner_worker.is_some());
        let min_readable_version = latest_version.saturating_sub(self.prune_window);
        self.min_readable_version
            .store(min_readable_version, Ordering::SeqCst);

        PRUNER_VERSIONS
            .with_label_values(&["ledger_pruner", "min_readable"])
            .set(min_readable_version as i64);

        self.pruner_worker
            .as_ref()
            .unwrap()
            .set_target_db_version(min_readable_version);
    }
```
