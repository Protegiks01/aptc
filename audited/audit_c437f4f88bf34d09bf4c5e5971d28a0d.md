# Audit Report

## Title
Consensus Liveness Failure: Invalid Signatures Cause Permanent Livelock in Signed Buffer Items

## Summary
In `try_advance_to_aggregated()`, the `BufferItem::Signed` state uses a cloned `SignatureAggregator` for verification, causing invalid signatures to never be filtered from the original item. This creates a permanent livelock where items with sufficient voting power but containing invalid signatures can never advance to aggregated state, preventing block commitment and causing consensus liveness failure. [1](#0-0) 

## Finding Description

The vulnerability stems from an asymmetry in how `try_advance_to_aggregated()` handles different buffer item states:

**For `BufferItem::Executed`:** The function calls `aggregate_and_verify()` on the original mutable `partial_commit_proof`, allowing `filter_invalid_signatures()` to permanently remove invalid signatures from the item. [2](#0-1) 

**For `BufferItem::Signed`:** The function clones the `partial_commit_proof` before calling `aggregate_and_verify()`, meaning any filtering of invalid signatures only affects the clone, not the original item that gets returned. [3](#0-2) 

The attack path exploits Aptos's optimistic signature verification mechanism, which is enabled by default: [4](#0-3) 

When optimistic verification is enabled, `CommitVote::verify()` uses `optimistic_verify()`, which only checks if the author is a known validator but does NOT cryptographically verify signatures unless the author is in the pessimistic verify set: [5](#0-4) [6](#0-5) 

**Exploitation Scenario:**

1. A `BufferItem` reaches `Signed` state with N valid signatures (voting power < quorum)
2. A Byzantine validator sends commit votes with valid author addresses but cryptographically invalid signatures
3. These votes pass `optimistic_verify()` and are added via `add_signature_if_matched()`: [7](#0-6) 

4. The item now has sufficient voting power (e.g., 5/5) but includes invalid signatures
5. `try_advance_to_aggregated()` is called:
   - `check_voting_power()` passes (5/5 voting power)
   - `aggregate_and_verify()` is called on a **clone**
   - Inside `aggregate_and_verify()`, cryptographic verification fails
   - `filter_invalid_signatures()` removes invalid signatures from the **clone**
   - After filtering: insufficient voting power (e.g., 4/5)
   - Returns `Err` [8](#0-7) 

6. The **original** `Signed` item (still containing all invalid signatures) is returned unchanged
7. This repeats indefinitely - the item can never advance to `Aggregated` state, blocking consensus

This violates the **Consensus Safety** invariant: "AptosBFT must prevent... liveness failures under < 1/3 Byzantine faults."

## Impact Explanation

**Severity: High** - Consensus liveness failure affecting block commitment.

This vulnerability allows a Byzantine validator (within the < 1/3 fault tolerance assumption) to permanently halt consensus by preventing specific blocks from being committed. While the blockchain may continue producing new blocks, affected blocks remain stuck in the pipeline, potentially causing:

- **Consensus stalling**: If the stuck block is a critical checkpoint or epoch transition
- **Resource exhaustion**: Accumulation of stuck items in memory
- **Validator node degradation**: Repeated verification attempts consuming CPU

This meets the High Severity criteria per Aptos bug bounty program: "Validator node slowdowns" and "Significant protocol violations."

## Likelihood Explanation

**Likelihood: High**

The attack requires:
1. Byzantine validator access (assumed available under < 1/3 fault model)
2. Optimistic signature verification enabled (default configuration)
3. Ability to send commit votes (standard network operation)

The exploit is:
- **Easily triggerable**: Byzantine validator simply sends commit votes with wrong signatures
- **Difficult to detect**: Appears as normal consensus behavior until aggregation fails
- **Persistent**: Once triggered, the livelock is permanent for affected blocks
- **No special timing required**: Can be executed at any time during normal operation

## Recommendation

Remove the `.clone()` call for the `Signed` state to ensure `aggregate_and_verify()` mutates the original `partial_commit_proof`, allowing invalid signatures to be permanently filtered:

**Fixed code for `try_advance_to_aggregated()`:**

```rust
Self::Signed(mut signed_item) => {  // Add 'mut' here
    if signed_item
        .partial_commit_proof
        .check_voting_power(validator, true)
        .is_ok()
    {
        let _time = counters::VERIFY_MSG
            .with_label_values(&["commit_vote_aggregate_and_verify"])
            .start_timer();
        if let Ok(commit_proof) = signed_item
            .partial_commit_proof
            // Remove .clone() here
            .aggregate_and_verify(validator)
            .map(|(ledger_info, aggregated_sig)| {
                LedgerInfoWithSignatures::new(ledger_info, aggregated_sig)
            })
        {
            return Self::Aggregated(Box::new(AggregatedItem {
                executed_blocks: signed_item.executed_blocks,
                commit_proof,
            }));
        }
    }
    Self::Signed(signed_item)
},
```

This makes the `Signed` state behavior consistent with the `Executed` state, where filtering persists across calls.

## Proof of Concept

The existing test demonstrates the issue is handled correctly for `Executed` state but there's no equivalent test for `Signed` state: [9](#0-8) 

To reproduce the vulnerability, add this test to `consensus/src/pipeline/buffer_item.rs`:

```rust
#[test]
fn test_signed_item_livelock_with_invalid_signatures() {
    let (validator_signers, validator_verifier) = create_validators();
    let pipelined_block = create_pipelined_block();
    let block_info = pipelined_block.block_info();
    let ledger_info = LedgerInfo::new(block_info.clone(), HashValue::zero());
    let ordered_proof = LedgerInfoWithSignatures::new(ledger_info.clone(), AggregateSignature::empty());
    
    // Create 4 valid signatures and 1 invalid
    let mut commit_votes = create_valid_commit_votes(validator_signers.clone(), ledger_info.clone());
    commit_votes[4] = CommitVote::new_with_signature(
        validator_signers[4].author(),
        ledger_info.clone(),
        bls12381::Signature::dummy_signature(), // Invalid signature
    );
    
    // Advance to Executed with 4 valid signatures (not enough for quorum of 5)
    let mut cached_votes = HashMap::new();
    for i in 0..4 {
        cached_votes.insert(commit_votes[i].author(), commit_votes[i].clone());
    }
    let ordered_item = BufferItem::new_ordered(
        vec![pipelined_block.clone()],
        ordered_proof,
        cached_votes,
    );
    
    let executed_item = ordered_item.advance_to_executed_or_aggregated(
        vec![pipelined_block.clone()],
        &validator_verifier,
        None,
        true,
    );
    
    // Advance to Signed
    let mut signed_item = executed_item.advance_to_signed(
        validator_signers[0].author(),
        validator_signers[0].sign(&ledger_info).unwrap(),
    );
    
    // Add the invalid signature (5th vote) - now has sufficient voting power
    signed_item.add_signature_if_matched(commit_votes[4].clone()).unwrap();
    
    // Try to advance - should fail due to invalid signature
    let result = signed_item.try_advance_to_aggregated(&validator_verifier);
    
    // BUG: Item remains in Signed state with 5 signatures (including invalid one)
    assert!(result.is_signed());
    if let BufferItem::Signed(ref item) = result {
        // The invalid signature is NOT removed - it still has 5 voters
        assert_eq!(item.partial_commit_proof.all_voters().count(), 5);
    }
    
    // Try again - still fails (livelock)
    let result2 = result.try_advance_to_aggregated(&validator_verifier);
    assert!(result2.is_signed());
    if let BufferItem::Signed(ref item) = result2 {
        // Still has 5 voters - no progress made
        assert_eq!(item.partial_commit_proof.all_voters().count(), 5);
    }
    
    // This will repeat forever - consensus liveness failure
}
```

**Expected behavior with fix:** After the first `try_advance_to_aggregated()` call, the invalid signature should be removed, leaving only 4 voters, and eventually allowing new valid signatures to bring it to quorum.

**Actual behavior:** The item remains stuck with 5 voters (including invalid) indefinitely.

## Notes

The vulnerability is specific to the `BufferItem::Signed` state due to the use of `.clone()` when calling `aggregate_and_verify()`. The `BufferItem::Executed` state correctly handles this scenario because it calls `aggregate_and_verify()` on the original mutable object. This asymmetry suggests the clone was likely added for borrow checker reasons but introduces the security flaw.

### Citations

**File:** consensus/src/pipeline/buffer_item.rs (L294-348)
```rust
    pub fn try_advance_to_aggregated(self, validator: &ValidatorVerifier) -> Self {
        match self {
            Self::Signed(signed_item) => {
                if signed_item
                    .partial_commit_proof
                    .check_voting_power(validator, true)
                    .is_ok()
                {
                    let _time = counters::VERIFY_MSG
                        .with_label_values(&["commit_vote_aggregate_and_verify"])
                        .start_timer();
                    if let Ok(commit_proof) = signed_item
                        .partial_commit_proof
                        .clone()
                        .aggregate_and_verify(validator)
                        .map(|(ledger_info, aggregated_sig)| {
                            LedgerInfoWithSignatures::new(ledger_info, aggregated_sig)
                        })
                    {
                        return Self::Aggregated(Box::new(AggregatedItem {
                            executed_blocks: signed_item.executed_blocks,
                            commit_proof,
                        }));
                    }
                }
                Self::Signed(signed_item)
            },
            Self::Executed(mut executed_item) => {
                if executed_item
                    .partial_commit_proof
                    .check_voting_power(validator, true)
                    .is_ok()
                {
                    let _time = counters::VERIFY_MSG
                        .with_label_values(&["commit_vote_aggregate_and_verify"])
                        .start_timer();

                    if let Ok(commit_proof) = executed_item
                        .partial_commit_proof
                        .aggregate_and_verify(validator)
                        .map(|(ledger_info, aggregated_sig)| {
                            LedgerInfoWithSignatures::new(ledger_info, aggregated_sig)
                        })
                    {
                        return Self::Aggregated(Box::new(AggregatedItem {
                            executed_blocks: executed_item.executed_blocks,
                            commit_proof,
                        }));
                    }
                }
                Self::Executed(executed_item)
            },
            _ => self,
        }
    }
```

**File:** consensus/src/pipeline/buffer_item.rs (L401-405)
```rust
            Self::Signed(signed) => {
                if signed.partial_commit_proof.data().commit_info() == target_commit_info {
                    signed.partial_commit_proof.add_signature(author, signature);
                    return Ok(());
                }
```

**File:** consensus/src/pipeline/buffer_item.rs (L607-759)
```rust
    // This tests the case where some of the commit votes are not correct
    #[test]
    fn test_buffer_item_bad_path_1() {
        let (validator_signers, validator_verifier) = create_validators();
        let pipelined_block = create_pipelined_block();
        let block_info = pipelined_block.block_info();
        let ledger_info = LedgerInfo::new(block_info.clone(), HashValue::zero());
        let ordered_proof =
            LedgerInfoWithSignatures::new(ledger_info.clone(), AggregateSignature::empty());
        let mut commit_votes =
            create_valid_commit_votes(validator_signers.clone(), ledger_info.clone());

        // Corrupting commit_votes[3], commit_votes[5]
        commit_votes[3] = CommitVote::new_with_signature(
            validator_signers[3].author(),
            ledger_info.clone(),
            bls12381::Signature::dummy_signature(),
        );
        commit_votes[5] = CommitVote::new_with_signature(
            validator_signers[5].author(),
            ledger_info.clone(),
            bls12381::Signature::dummy_signature(),
        );

        let mut partial_signatures = BTreeMap::new();
        partial_signatures.insert(
            validator_signers[0].author(),
            commit_votes[0].signature().clone(),
        );
        partial_signatures.insert(
            validator_signers[1].author(),
            commit_votes[1].signature().clone(),
        );
        partial_signatures.insert(
            validator_signers[2].author(),
            commit_votes[2].signature().clone(),
        );
        partial_signatures.insert(
            validator_signers[4].author(),
            commit_votes[4].signature().clone(),
        );
        partial_signatures.insert(
            validator_signers[6].author(),
            commit_votes[6].signature().clone(),
        );
        let li_with_sig = validator_verifier
            .aggregate_signatures(partial_signatures.iter())
            .unwrap();
        let commit_proof = LedgerInfoWithSignatures::new(ledger_info.clone(), li_with_sig);

        let mut cached_commit_votes = HashMap::new();
        cached_commit_votes.insert(commit_votes[0].author(), commit_votes[0].clone());
        cached_commit_votes.insert(commit_votes[1].author(), commit_votes[1].clone());
        let mut ordered_item = BufferItem::new_ordered(
            vec![pipelined_block.clone()],
            ordered_proof.clone(),
            cached_commit_votes,
        );

        ordered_item
            .add_signature_if_matched(commit_votes[2].clone())
            .unwrap();
        ordered_item
            .add_signature_if_matched(commit_votes[3].clone())
            .unwrap();

        assert_eq!(validator_verifier.pessimistic_verify_set().len(), 0);
        let mut executed_item = ordered_item.advance_to_executed_or_aggregated(
            vec![pipelined_block.clone()],
            &validator_verifier,
            None,
            true,
        );

        match executed_item {
            BufferItem::Executed(ref executed_item_inner) => {
                assert_eq!(executed_item_inner.executed_blocks, vec![
                    pipelined_block.clone()
                ]);
                assert_eq!(executed_item_inner.commit_info, block_info);
                assert_eq!(
                    executed_item_inner
                        .partial_commit_proof
                        .all_voters()
                        .count(),
                    4
                );
                assert_eq!(executed_item_inner.ordered_proof, ordered_proof);
            },
            _ => panic!("Expected executed item."),
        }

        executed_item
            .add_signature_if_matched(commit_votes[4].clone())
            .unwrap();

        let mut executed_item = executed_item.try_advance_to_aggregated(&validator_verifier);
        match executed_item {
            BufferItem::Executed(ref executed_item_inner) => {
                assert_eq!(executed_item_inner.executed_blocks, vec![
                    pipelined_block.clone()
                ]);
                assert_eq!(executed_item_inner.commit_info, block_info);
                assert_eq!(
                    executed_item_inner
                        .partial_commit_proof
                        .all_voters()
                        .count(),
                    4, // Commit_votes[3] is not correct and will be removed from the partial_commit_proof
                );
                assert_eq!(executed_item_inner.ordered_proof, ordered_proof);
            },
            _ => panic!("Expected executed item."),
        }
        assert_eq!(validator_verifier.pessimistic_verify_set().len(), 1);

        executed_item
            .add_signature_if_matched(commit_votes[5].clone())
            .unwrap();

        let mut executed_item = executed_item.try_advance_to_aggregated(&validator_verifier);
        match executed_item {
            BufferItem::Executed(ref executed_item_inner) => {
                assert_eq!(executed_item_inner.executed_blocks, vec![
                    pipelined_block.clone()
                ]);
                assert_eq!(executed_item_inner.commit_info, block_info);
                assert_eq!(
                    executed_item_inner
                        .partial_commit_proof
                        .all_voters()
                        .count(),
                    4, // Commit_votes[5] is not correct and will be removed from the partial_commit_proof
                );
                assert_eq!(executed_item_inner.ordered_proof, ordered_proof);
            },
            _ => panic!("Expected executed item."),
        }
        assert_eq!(validator_verifier.pessimistic_verify_set().len(), 2);

        executed_item
            .add_signature_if_matched(commit_votes[6].clone())
            .unwrap();
        let aggregated_item = executed_item.try_advance_to_aggregated(&validator_verifier);
        match aggregated_item {
            BufferItem::Aggregated(aggregated_item_inner) => {
                assert_eq!(aggregated_item_inner.executed_blocks, vec![pipelined_block]);
                assert_eq!(aggregated_item_inner.commit_proof, commit_proof);
            },
            _ => panic!("Expected aggregated item."),
        }
    }
}
```

**File:** config/src/config/consensus_config.rs (L382-382)
```rust
            optimistic_sig_verification: true,
```

**File:** types/src/validator_verifier.rs (L269-285)
```rust
    pub fn optimistic_verify<T: Serialize + CryptoHash>(
        &self,
        author: AccountAddress,
        message: &T,
        signature_with_status: &SignatureWithStatus,
    ) -> std::result::Result<(), VerifyError> {
        if self.get_public_key(&author).is_none() {
            return Err(VerifyError::UnknownAuthor);
        }
        if (!self.optimistic_sig_verification || self.pessimistic_verify_set.contains(&author))
            && !signature_with_status.is_verified()
        {
            self.verify(author, message, signature_with_status.signature())?;
            signature_with_status.set_verified();
        }
        Ok(())
    }
```

**File:** consensus/consensus-types/src/pipeline/commit_vote.rs (L103-113)
```rust
    pub fn verify(&self, sender: Author, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        ensure!(
            self.author() == sender,
            "Commit vote author {:?} doesn't match with the sender {:?}",
            self.author(),
            sender
        );
        validator
            .optimistic_verify(self.author(), &self.ledger_info, &self.signature)
            .context("Failed to verify Commit Vote")
    }
```

**File:** types/src/ledger_info.rs (L517-536)
```rust
    pub fn aggregate_and_verify(
        &mut self,
        verifier: &ValidatorVerifier,
    ) -> Result<(T, AggregateSignature), VerifyError> {
        let aggregated_sig = self.try_aggregate(verifier)?;

        match verifier.verify_multi_signatures(&self.data, &aggregated_sig) {
            Ok(_) => {
                // We are not marking all the signatures as "verified" here, as two malicious
                // voters can collude and create a valid aggregated signature.
                Ok((self.data.clone(), aggregated_sig))
            },
            Err(_) => {
                self.filter_invalid_signatures(verifier);

                let aggregated_sig = self.try_aggregate(verifier)?;
                Ok((self.data.clone(), aggregated_sig))
            },
        }
    }
```
