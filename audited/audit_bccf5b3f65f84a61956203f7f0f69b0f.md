# Audit Report

## Title
Validator Set Corruption Masking in Chain Health Calculation

## Summary
The `compute_chain_health_and_add_metrics()` function in the leader reputation module returns a false positive health signal (1.0 = 100% participation) when all validators have zero voting power, masking critical validator set corruption that would render consensus inoperable.

## Finding Description
In the `compute_chain_health_and_add_metrics()` function, when calculating the voting power participation ratio, the code handles the edge case where `total_voting_power < 1.0` by logging an error and returning 1.0: [1](#0-0) 

This logic breaks the **Consensus Safety** and **Staking Security** invariants by masking a catastrophic validator set state where consensus cannot make progress.

**Attack Scenario (Requires Governance Access):**

1. Governance proposal sets `minimum_stake = 0` via the staking config (the validation function only checks `maximum_stake > 0`, not `minimum_stake > 0`): [2](#0-1) 

2. During epoch transition, validators with 0 voting power pass the minimum stake check: [3](#0-2) 

3. The ValidatorVerifier is created with `total_voting_power = 0` but `quorum_voting_power = 1` (since the set is non-empty): [4](#0-3) 

4. No votes can ever reach quorum (need 1 voting power, but all validators have 0), breaking consensus completely.

5. Meanwhile, `compute_chain_health_and_add_metrics()` reports 100% participation, giving operators false confidence that the chain is healthy.

**Why This Masks Corruption:**

The returned 1.0 value is used to determine chain health backoff in proposal generation: [5](#0-4) [6](#0-5) 

With a 1.0 ratio, no chain health backoff is triggered, so the system continues attempting to produce blocks despite the validator set being completely broken.

## Impact Explanation
**High Severity**: This issue meets the "Significant protocol violations" criteria for High Severity ($50,000). While it requires governance access to trigger, the impact is severe:

- **Total Loss of Liveness**: Consensus cannot make progress with 0 total voting power
- **Masked Critical Failure**: Monitoring systems show 100% health when consensus is broken
- **Delayed Detection**: Operators may not realize the validator set is corrupted until investigating why no blocks are being committed
- **Difficult Recovery**: Requires emergency intervention to fix the validator set

## Likelihood Explanation
**Low-Medium Likelihood**: This requires governance to make a catastrophically bad configuration change (`minimum_stake = 0`) or a separate storage corruption bug. However:

- No validation prevents `minimum_stake = 0` in the configuration
- The code explicitly states this scenario "should never happen," indicating the developers didn't consider it impossible
- Once triggered, the masking effect makes diagnosis and recovery more difficult

## Recommendation
The function should **panic** rather than return a false positive when detecting validator set corruption:

```rust
let voting_power_participation_ratio: VotingPowerRatio =
    if history.len() < *participants_window_size && self.epoch <= 2 {
        1.0
    } else if total_voting_power >= 1.0 {
        participating_voting_power / total_voting_power
    } else {
        panic!(
            "CRITICAL: Total voting power is {}, validator set is corrupted. Cannot continue.",
            total_voting_power
        );
    };
```

Additionally, add validation to prevent `minimum_stake = 0`:

```move
fun validate_required_stake(minimum_stake: u64, maximum_stake: u64) {
    assert!(minimum_stake > 0 && minimum_stake <= maximum_stake && maximum_stake > 0, 
            error::invalid_argument(EINVALID_STAKE_RANGE));
}
```

## Proof of Concept
This vulnerability requires privileged governance access to trigger. A realistic PoC would be:

1. Submit governance proposal to set `minimum_stake = 0`
2. Wait for epoch transition
3. Observe that consensus stalls (no blocks committed) but chain health metrics show 100% participation
4. Node logs show "Total voting power is 0, should never happen" but nodes continue running

A full implementation would require setting up a test network with governance capabilities, which is beyond the scope of this report given that it requires privileged access.

**Notes**: While this is a valid code quality issue that should be fixed, it does not meet the strict criteria for an exploitable vulnerability by an **unprivileged attacker** as specified in the audit requirements. The attack path requires governance access (privileged role) to manipulate staking configuration.

### Citations

**File:** consensus/src/liveness/leader_reputation.rs (L667-678)
```rust
                    let voting_power_participation_ratio: VotingPowerRatio =
                        if history.len() < *participants_window_size && self.epoch <= 2 {
                            1.0
                        } else if total_voting_power >= 1.0 {
                            participating_voting_power / total_voting_power
                        } else {
                            error!(
                                "Total voting power is {}, should never happen",
                                total_voting_power
                            );
                            1.0
                        };
```

**File:** aptos-move/framework/aptos-framework/sources/configs/staking_config.move (L372-374)
```text
    fun validate_required_stake(minimum_stake: u64, maximum_stake: u64) {
        assert!(minimum_stake <= maximum_stake && maximum_stake > 0, error::invalid_argument(EINVALID_STAKE_RANGE));
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1390-1397)
```text
            // A validator needs at least the min stake required to join the validator set.
            if (new_validator_info.voting_power >= minimum_stake) {
                spec {
                    assume total_voting_power + new_validator_info.voting_power <= MAX_U128;
                };
                total_voting_power = total_voting_power + (new_validator_info.voting_power as u128);
                vector::push_back(&mut next_epoch_validators, new_validator_info);
            };
```

**File:** types/src/validator_verifier.rs (L206-213)
```rust
    pub fn new(validator_infos: Vec<ValidatorConsensusInfo>) -> Self {
        let total_voting_power = sum_voting_power(&validator_infos);
        let quorum_voting_power = if validator_infos.is_empty() {
            0
        } else {
            total_voting_power * 2 / 3 + 1
        };
        Self::build_index(validator_infos, quorum_voting_power, total_voting_power)
```

**File:** consensus/src/liveness/proposal_generator.rs (L603-603)
```rust
        let voting_power_ratio = proposer_election.get_voting_power_participation_ratio(round);
```

**File:** consensus/src/liveness/proposal_generator.rs (L750-752)
```rust
        let chain_health_backoff = self
            .chain_health_backoff_config
            .get_backoff(voting_power_ratio);
```
