# Audit Report

## Title
Zero X25519 Public Key Acceptance Enables Weak Encryption in Validator Network

## Summary
The Aptos Core codebase lacks validation for x25519 public keys, allowing validators to register on-chain with cryptographically invalid keys (specifically, the zero point/identity element). When other validators attempt to connect to a peer with a zero public key, the Diffie-Hellman key exchange produces predictable weak shared secrets, resulting in compromised session encryption and potential consensus disruption.

## Finding Description

The vulnerability exists across multiple components:

**1. Missing X25519 Public Key Validation**

The x25519::PublicKey type accepts any 32-byte array without validation for weak points: [1](#0-0) 

Unlike Ed25519 keys which are validated for small-order points, x25519 keys have no such checks: [2](#0-1) 

**2. Unvalidated On-Chain Network Address Updates**

Validators can update their network addresses (containing embedded x25519 keys) without cryptographic validation: [3](#0-2) 

**3. Weak Diffie-Hellman Operations**

The Noise handshake performs DH operations without checking for zero/weak public keys: [4](#0-3) [5](#0-4) 

**4. Key Extraction Without Validation**

Network addresses are parsed and keys extracted without validation: [6](#0-5) [7](#0-6) 

**Attack Path:**

1. A malicious or compromised validator operator crafts a network address containing a zero x25519 public key (all bytes set to 0x00)
2. Calls `update_network_and_fullnode_addresses()` to register this address on-chain
3. Other validators fetch the validator set and extract the zero public key
4. When establishing connections, honest validators perform `diffie_hellman(&zero_key)` which produces an all-zero shared secret
5. The HKDF key derivation, while still executed, operates on weak input material
6. Resulting session keys are predictable/weak, enabling potential traffic decryption or manipulation

The comparison at line 47 in validator_set.rs does not detect this weakness: [8](#0-7) 

If both the expected key and on-chain key are zero, the equality check passes without detecting the cryptographic invalidity.

## Impact Explanation

This vulnerability breaks the **Cryptographic Correctness** invariant and has **HIGH** severity impact:

1. **Weak Encryption**: Session keys derived from zero shared secrets are cryptographically weak, potentially enabling an attacker to decrypt or manipulate consensus messages, block proposals, or vote messages between validators.

2. **Consensus Disruption**: Connection failures or authentication errors due to zero keys could cause validators to be unable to participate in consensus, affecting network liveness.

3. **Targeted Attack Vector**: A malicious validator can selectively disrupt connections from specific peers while maintaining a presence in the validator set.

4. **Network-Wide Impact**: If multiple validators adopt zero keys (through compromise or coordination), this amplifies the attack surface.

This qualifies as **High Severity** per Aptos bug bounty criteria: "Significant protocol violations" and potential "Validator node slowdowns" leading to consensus degradation.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

- **Attacker Requirements**: Requires being a validator operator (either through legitimate stake or compromise of operator keys)
- **Complexity**: LOW - Attack is straightforward: construct network address with zero key bytes and call `update_network_and_fullnode_addresses()`
- **Detection**: The current implementation logs a mismatch metric but does not reject zero keys
- **Real-world Probability**: Moderate - requires either malicious validator participation or operator key compromise

## Recommendation

Implement validation for x25519 public keys to reject cryptographically weak points:

1. **Add X25519 Key Validation in Rust:**

Add a validation method to x25519::PublicKey that checks for zero point and low-order points. The x25519 zero point is all zeros, and there are known small-order points that should be rejected.

```rust
impl PublicKey {
    pub fn validate(&self) -> Result<(), CryptoMaterialError> {
        // Reject all-zero key (identity element)
        if self.0 == [0u8; 32] {
            return Err(CryptoMaterialError::ValidationError);
        }
        // Additional small-order point checks could be added
        Ok(())
    }
}
```

2. **Validate on Deserialization:**

Modify TryFrom implementations to call validate(): [9](#0-8) 

3. **Validate in Move Framework:**

Add a native Move function for x25519 public key validation (similar to Ed25519): [10](#0-9) 

Call this validation in `update_network_and_fullnode_addresses()` before accepting new network addresses.

4. **Validate in Network Address Parsing:**

Add validation when extracting noise protocol keys: [11](#0-10) 

## Proof of Concept

**Rust Test Demonstrating Weak DH with Zero Key:**

```rust
#[test]
fn test_zero_x25519_key_weak_dh() {
    use aptos_crypto::x25519::{PrivateKey, PublicKey};
    use aptos_crypto::traits::Uniform;
    
    // Create a zero public key (should be rejected but currently isn't)
    let zero_key = PublicKey::from([0u8; 32]);
    
    // Create a legitimate private key
    let mut rng = rand::thread_rng();
    let private_key = PrivateKey::generate(&mut rng);
    
    // Perform DH with zero key
    let shared_secret = private_key.diffie_hellman(&zero_key);
    
    // The shared secret will be all zeros - weak!
    assert_eq!(shared_secret, [0u8; 32]);
    
    println!("DH with zero key produced zero shared secret - WEAK!");
}
```

**Move Test for On-Chain Registration:**

```move
#[test(operator = @0x123, framework = @aptos_framework)]
fun test_zero_key_registration(operator: &signer, framework: &signer) {
    // Setup validator
    // ...
    
    // Craft network address with zero x25519 key
    let zero_key_bytes = x"0000000000000000000000000000000000000000000000000000000000000000";
    let network_addr = encode_network_address_with_key(zero_key_bytes);
    
    // This should FAIL but currently succeeds
    stake::update_network_and_fullnode_addresses(
        operator,
        validator_addr,
        network_addr,
        network_addr
    );
    
    // The zero key is now registered on-chain!
}
```

**Notes:**

The vulnerability represents a failure to validate cryptographic parameters at multiple layers. While Ed25519 keys used for consensus signatures are properly validated for small-order points, x25519 keys used for network encryption lack equivalent protections. This asymmetry creates a security gap that can be exploited to compromise validator network communications.

### Citations

**File:** crates/aptos-crypto/src/x25519.rs (L222-236)
```rust
impl std::convert::From<[u8; PUBLIC_KEY_SIZE]> for PublicKey {
    fn from(public_key_bytes: [u8; PUBLIC_KEY_SIZE]) -> Self {
        Self(public_key_bytes)
    }
}

impl std::convert::TryFrom<&[u8]> for PublicKey {
    type Error = traits::CryptoMaterialError;

    fn try_from(public_key_bytes: &[u8]) -> Result<Self, Self::Error> {
        let public_key_bytes: [u8; PUBLIC_KEY_SIZE] = public_key_bytes
            .try_into()
            .map_err(|_| traits::CryptoMaterialError::WrongLengthError)?;
        Ok(Self(public_key_bytes))
    }
```

**File:** aptos-move/framework/src/natives/cryptography/ed25519.rs (L67-82)
```rust
    // This deserialization only performs point-on-curve checks, so we check for small subgroup below
    // NOTE(Gas): O(1) cost: some arithmetic for converting to (X, Y, Z, T) coordinates
    let point = match CompressedEdwardsY(key_bytes_slice).decompress() {
        Some(point) => point,
        None => {
            return Ok(smallvec![Value::bool(false)]);
        },
    };

    // Check if the point lies on a small subgroup. This is required when using curves with a
    // small cofactor (e.g., in Ed25519, cofactor = 8).
    // NOTE(Gas): O(1) cost: multiplies the point by the cofactor
    context.charge(ED25519_PER_PUBKEY_SMALL_ORDER_CHECK * NumArgs::one())?;
    let valid = !point.is_small_order();

    Ok(smallvec![Value::bool(valid)])
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L955-971)
```text
    public entry fun update_network_and_fullnode_addresses(
        operator: &signer,
        pool_address: address,
        new_network_addresses: vector<u8>,
        new_fullnode_addresses: vector<u8>,
    ) acquires StakePool, ValidatorConfig {
        check_stake_permission(operator);
        assert_reconfig_not_in_progress();
        assert_stake_pool_exists(pool_address);
        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        assert!(signer::address_of(operator) == stake_pool.operator_address, error::unauthenticated(ENOT_OPERATOR));
        assert!(exists<ValidatorConfig>(pool_address), error::not_found(EVALIDATOR_CONFIG));
        let validator_info = borrow_global_mut<ValidatorConfig>(pool_address);
        let old_network_addresses = validator_info.network_addresses;
        validator_info.network_addresses = new_network_addresses;
        let old_fullnode_addresses = validator_info.fullnode_addresses;
        validator_info.fullnode_addresses = new_fullnode_addresses;
```

**File:** crates/aptos-crypto/src/noise.rs (L310-311)
```rust
        let dh_output = e.diffie_hellman(&rs);
        let k = mix_key(&mut ck, &dh_output)?;
```

**File:** crates/aptos-crypto/src/noise.rs (L327-328)
```rust
        let dh_output = self.private_key.diffie_hellman(&rs);
        let k = mix_key(&mut ck, &dh_output)?;
```

**File:** types/src/network_address/mod.rs (L400-405)
```rust
    pub fn find_noise_proto(&self) -> Option<x25519::PublicKey> {
        self.0.iter().find_map(|proto| match proto {
            Protocol::NoiseIK(pubkey) => Some(*pubkey),
            _ => None,
        })
    }
```

**File:** types/src/network_address/mod.rs (L643-645)
```rust
            "noise-ik" => Protocol::NoiseIK(x25519::PublicKey::from_encoded_string(
                args.next().ok_or(ParseError::UnexpectedEnd)?,
            )?),
```

**File:** config/src/config/network_config.rs (L498-504)
```rust
    pub fn from_addrs(role: PeerRole, addresses: Vec<NetworkAddress>) -> Peer {
        let keys: HashSet<x25519::PublicKey> = addresses
            .iter()
            .filter_map(NetworkAddress::find_noise_proto)
            .collect();
        Peer::new(addresses, keys, role)
    }
```

**File:** network/discovery/src/validator_set.rs (L44-57)
```rust
    fn find_key_mismatches(&self, onchain_keys: Option<&HashSet<x25519::PublicKey>>) {
        let mismatch = onchain_keys.map_or(0, |pubkeys| {
            if !pubkeys.contains(&self.expected_pubkey) {
                error!(
                    NetworkSchema::new(&self.network_context),
                    "Onchain pubkey {:?} differs from local pubkey {}",
                    pubkeys,
                    self.expected_pubkey
                );
                1
            } else {
                0
            }
        });
```
