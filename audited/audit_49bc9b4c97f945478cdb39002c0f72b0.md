# Audit Report

## Title
Version Tracking Corruption Due to Hardcoded BlockEpilogue Assumption in Test Infrastructure

## Summary
The `try_commit_block()` function in `api/test-context/src/test_context.rs` uses a hardcoded calculation `txns.len() + 1` to determine block size, assuming a BlockEpilogue transaction is always added. However, BlockEpilogue transactions are NOT created during epoch changes, leading to version number corruption when the test infrastructure is used to simulate epoch boundaries.

## Finding Description

The vulnerability exists in the block size calculation at line 940 of the test context file: [1](#0-0) 

The code assumes that exactly one BlockEpilogue transaction is always appended to the input transactions, calculating the block size as `txns.len() + 1`. However, the block executor's design explicitly prevents BlockEpilogue creation during epoch changes: [2](#0-1) 

The BlockOutput structure documents this behavior: [3](#0-2) 

**Attack Scenario:**

1. Test code creates a block with N user transactions
2. The `try_commit_block` function creates `txns` with 1 BlockMetadata + N user transactions = N+1 total
3. If a transaction triggers an epoch change (reconfiguration), the block executor does NOT create a BlockEpilogue
4. Pre-commit writes N+1 transactions to the database
5. The ledger info is created with version = `parent_version + (N+2)` 
6. Database only contains transactions up to `parent_version + (N+1)`
7. When `check_and_put_ledger_info` validates the root hash at the claimed version, it will fail or return an incorrect hash

This breaks **Invariant #4: State Consistency** - state transitions must be atomic and verifiable via Merkle proofs. The version mismatch corrupts the transaction accumulator and prevents proper state verification.

## Impact Explanation

**Severity: Test Infrastructure Issue (Does Not Meet Bounty Criteria)**

While this issue could corrupt test environments and cause misleading test results, it exists only in the test infrastructure code (`api/test-context`), not in production blockchain execution paths. The validation checklist explicitly excludes test files:

> "Vulnerability lies within the Aptos Core codebase (not tests or docs)"

The actual production block executor correctly uses `num_transactions_to_commit()`: [4](#0-3) 

## Likelihood Explanation

In test scenarios: **High** - Any test that simulates epoch changes using `try_commit_block()` would trigger this bug.

In production: **Not Applicable** - Production code does not use this test infrastructure.

## Recommendation

Replace the hardcoded calculation with the actual transaction count from the execution result:

```rust
self.new_ledger_info(
    &metadata, 
    result.root_hash(), 
    result.num_transactions_to_commit()
)
```

This ensures the version count matches the actual number of committed transactions, regardless of whether a BlockEpilogue was created.

## Proof of Concept

**Test Case (Rust):**

```rust
#[tokio::test]
async fn test_epoch_change_version_mismatch() {
    let mut context = new_test_context(...);
    
    // Create transaction that triggers epoch change
    let mut root = context.root_account().await;
    let reconfig_txn = create_reconfiguration_transaction(&mut root);
    
    // This should fail with version mismatch when epoch change occurs
    // because txns.len() + 1 != actual committed transactions
    context.try_commit_block(&[reconfig_txn]).await;
    
    // Verify version corruption
    let ledger_info = context.get_latest_ledger_info();
    let db_version = context.db.get_latest_version().unwrap();
    assert_ne!(ledger_info.version(), db_version); // Demonstrates the off-by-one error
}
```

---

## Notes

**This finding does NOT meet the validation criteria** because it exists in test infrastructure code (`api/test-context/src/test_context.rs`), not production blockchain code. While it could cause test failures and confusion during development, it does not represent an exploitable vulnerability in the Aptos blockchain itself.

The production block executor and consensus paths handle block commits correctly by using the actual execution results rather than hardcoded assumptions. No action required for production security, but fixing this in test infrastructure would improve test reliability.

### Citations

**File:** api/test-context/src/test_context.rs (L936-942)
```rust
            self.executor
                .commit_blocks(
                    vec![metadata.id()],
                    // BlockEpilogue is added on top of the input transactions.
                    self.new_ledger_info(&metadata, result.root_hash(), txns.len() + 1),
                )
                .unwrap();
```

**File:** aptos-move/block-executor/src/executor.rs (L2518-2529)
```rust
                    if !has_reconfig {
                        block_epilogue_txn = Some(self.gen_block_epilogue(
                            block_id,
                            signature_verified_block,
                            ret.iter(),
                            idx as TxnIndex,
                            block_limit_processor.get_block_end_info(),
                            module_cache_manager_guard.environment().features(),
                        )?);
                    } else {
                        info!("Reach epoch ending, do not append BlockEpilogue txn, block_id: {block_id:?}.");
                    }
```

**File:** types/src/transaction/block_output.rs (L14-16)
```rust
    // A BlockEpilogueTxn might be appended to the block.
    // This field will be None iff the input is not a block, or an epoch change is triggered.
    block_epilogue_txn: Option<T>,
```

**File:** execution/executor/src/block_executor/mod.rs (L349-357)
```rust
        let output = block.output.expect_complete_result();
        let num_txns = output.num_transactions_to_commit();
        if num_txns != 0 {
            let _timer = SAVE_TRANSACTIONS.start_timer();
            self.db
                .writer
                .pre_commit_ledger(output.as_chunk_to_commit(), false)?;
            TRANSACTIONS_SAVED.observe(num_txns as f64);
        }
```
