# Audit Report

## Title
TLS Downgrade Attack on Node-Checker SystemInformationProvider Allows False Hardware Metrics Injection

## Summary
The `SystemInformationProvider` in the node-checker service does not enforce HTTPS for connections to the `/system_information` endpoint. This allows man-in-the-middle attackers to intercept HTTP traffic and inject false hardware metrics, potentially allowing underpowered nodes to appear compliant with hardware requirements or causing legitimate nodes to fail validation checks.

## Finding Description

The node-checker service accepts user-provided URLs without validating the scheme (HTTP vs HTTPS). When a node operator submits their node for health checking via the `/check` API endpoint, the URL is passed directly to the `SystemInformationProvider` without TLS enforcement.

**Attack Flow:**

1. **User Input**: The `/check` API endpoint accepts a `node_url` query parameter from users [1](#0-0) 

2. **No Scheme Validation**: The URL is passed directly to `NodeAddress::new()` without any validation of whether it uses HTTPS [2](#0-1) 

3. **Client Creation Without TLS Enforcement**: The `get_metrics_client()` method creates a standard `reqwest::Client` without any HTTPS-only configuration [3](#0-2) 

4. **Unencrypted Request**: The `SystemInformationProvider` makes an HTTP GET request using whatever scheme was in the original URL [4](#0-3) 

5. **Metrics Used for Validation**: The `HardwareChecker` uses these metrics to validate CPU count and memory totals against minimum requirements [5](#0-4) 

The `/system_information` endpoint exposes critical hardware metrics including `cpu_count` and `memory_total` [6](#0-5) 

**Attack Scenario:**
- Attacker positions themselves as MITM on the network path
- Node operator checks their underpowered node using `http://mynode.example.com`
- Node-checker makes HTTP GET to `http://mynode.example.com:9101/system_information`
- Attacker intercepts response and injects: `{"cpu_count": "16", "memory_total": "64000000"}` (instead of actual `{"cpu_count": "4", "memory_total": "16000000"}`)
- `HardwareChecker` validates against these false metrics and reports the node as compliant

## Impact Explanation

This qualifies as **High severity** under the Aptos bug bounty criteria:
- **API integrity compromise**: The node-checker API can be manipulated to return false results
- **Validator node impact**: Underpowered nodes could receive false compliance reports, potentially leading operators to believe their nodes meet requirements when they don't, causing operational issues

However, I must note a critical limitation: **This vulnerability does NOT directly affect the core blockchain protocol**. The node-checker is an off-chain monitoring tool that doesn't control:
- Validator set membership (controlled by on-chain staking)
- Consensus participation (nodes participate based on on-chain validator set)
- State transitions or fund security

The actual impact is limited to providing false health check results to node operators using this service.

## Likelihood Explanation

**Likelihood: Medium-High**

The attack requires:
- MITM position between node-checker service and target node
- Target node operator using HTTP instead of HTTPS (or omitting scheme)
- No additional authentication or integrity checks

The likelihood is elevated because:
1. The code documentation suggests HTTP is acceptable [7](#0-6) 
2. The API example shows HTTP usage [8](#0-7) 
3. No warnings or validation enforce HTTPS

## Recommendation

**Enforce HTTPS-only connections for SystemInformationProvider:**

Add scheme validation in the API handler before creating `NodeAddress`, and configure the reqwest client to reject non-HTTPS connections when fetching sensitive metrics:

```rust
// In ecosystem/node-checker/src/server/api.rs, add after line 44:

// Validate that the node URL uses HTTPS
if node_url.0.scheme() != "https" {
    return Err(poem::Error::from((
        StatusCode::BAD_REQUEST,
        anyhow!(
            "Node URL must use HTTPS scheme for security. Received: {}",
            node_url.0.scheme()
        ),
    )));
}
```

Additionally, configure the metrics client to enforce HTTPS:

```rust
// In ecosystem/node-checker/src/configuration/node_address.rs, modify get_metrics_client:

pub fn get_metrics_client(&self, timeout: Duration) -> Result<reqwest::Client> {
    // Validate HTTPS scheme
    if self.url.scheme() != "https" {
        return Err(anyhow!(
            "Metrics client requires HTTPS URL, got: {}",
            self.url.scheme()
        ));
    }
    
    match self.metrics_port {
        Some(_) => Ok(reqwest::ClientBuilder::new()
            .timeout(timeout)
            .cookie_provider(self.cookie_store.clone())
            .https_only(true)  // Enforce HTTPS
            .build()
            .unwrap()),
        None => Err(anyhow!(
            "Cannot build metrics client without a metrics port"
        )),
    }
}
```

## Proof of Concept

```rust
// Test demonstrating HTTP vulnerability
// File: ecosystem/node-checker/tests/tls_downgrade_test.rs

#[tokio::test]
async fn test_http_url_accepted_for_system_information() {
    use url::Url;
    use ecosystem_node_checker::configuration::NodeAddress;
    use std::time::Duration;

    // Create a NodeAddress with HTTP URL (should be rejected but isn't)
    let http_url = Url::parse("http://insecure-node.example.com").unwrap();
    let node_address = NodeAddress::new(
        http_url.clone(),
        Some(8080),
        Some(9101),
        None,
        None,
    );

    // Get metrics client - currently succeeds even with HTTP
    let client_result = node_address.get_metrics_client(Duration::from_secs(5));
    assert!(client_result.is_ok(), "HTTP client should be rejected but is accepted");

    // If the client makes a request, it would be over unencrypted HTTP
    // allowing MITM attacks to inject false metrics
    let client = client_result.unwrap();
    assert_eq!(http_url.scheme(), "http", "Unencrypted HTTP scheme used");
}
```

## Notes

**Critical Limitation**: While this is a real implementation vulnerability in the node-checker service, it does NOT affect the core Aptos blockchain protocol. The node-checker is an off-chain monitoring tool that provides health check reports but does not:

- Control validator set membership (managed by on-chain staking contracts)
- Affect consensus participation (determined by on-chain validator set)
- Modify blockchain state or funds
- Break any of the 10 documented critical invariants (consensus safety, deterministic execution, etc.)

The vulnerability's scope is limited to the integrity of health check reports provided by this external monitoring service. While concerning for operational visibility, it does not constitute a core protocol vulnerability that could affect blockchain security, consensus, or fund safety.

### Citations

**File:** ecosystem/node-checker/src/server/api.rs (L34-35)
```rust
        /// The URL of the node to check, e.g. http://44.238.19.217 or http://fullnode.mysite.com
        node_url: Query<Url>,
```

**File:** ecosystem/node-checker/src/server/api.rs (L81-87)
```rust
        let target_node_address = NodeAddress::new(
            node_url.0,
            api_port.0,
            metrics_port.0,
            noise_port.0,
            public_key,
        );
```

**File:** ecosystem/node-checker/src/configuration/node_address.rs (L15-16)
```rust
    /// Target URL. This should include a scheme (e.g. http://). If there is no
    /// scheme, we will prepend http://.
```

**File:** ecosystem/node-checker/src/configuration/node_address.rs (L94-105)
```rust
    pub fn get_metrics_client(&self, timeout: Duration) -> Result<reqwest::Client> {
        match self.metrics_port {
            Some(_) => Ok(reqwest::ClientBuilder::new()
                .timeout(timeout)
                .cookie_provider(self.cookie_store.clone())
                .build()
                .unwrap()),
            None => Err(anyhow!(
                "Cannot build metrics client without a metrics port"
            )),
        }
    }
```

**File:** ecosystem/node-checker/src/provider/system_information.rs (L57-64)
```rust
    pub async fn get_data(&self) -> Result<SystemInformation, ProviderError> {
        let response = self
            .client
            .get(self.metrics_url.clone())
            .send()
            .await
            .with_context(|| format!("Failed to get data from {}", self.metrics_url))
            .map_err(|e| ProviderError::RetryableEndpointError("/system_information", e))?;
```

**File:** ecosystem/node-checker/src/checker/hardware.rs (L132-169)
```rust
    async fn check(
        &self,
        providers: &ProviderCollection,
    ) -> Result<Vec<CheckResult>, CheckerError> {
        let target_provider = get_provider!(
            providers.target_system_information_provider,
            self.config.common.required,
            SystemInformationProvider
        );

        let target_information = match target_provider.provide().await {
            Ok(info) => info,
            Err(e) => {
                return Ok(vec![Self::build_result(
                    "Failed to check build version".to_string(),
                    0,
                    format!("Failed to get system information from your node: {:#}", e),
                )])
            },
        };

        let check_results = vec![
            self.check_single_item(
                &target_information,
                CPU_COUNT_KEY,
                self.config.min_cpu_cores,
                "cores",
            ),
            self.check_single_item(
                &target_information,
                MEMORY_TOTAL_KEY,
                self.config.min_ram_gb * 1_000_000, // Convert from GB to KB
                "KB",
            ),
        ];

        Ok(check_results)
    }
```

**File:** crates/aptos-telemetry/src/system_information.rs (L14-28)
```rust
/// System information keys
const CPU_BRAND: &str = "cpu_brand";
const CPU_COUNT: &str = "cpu_count";
const CPU_CORE_COUNT: &str = "cpu_core_count";
const CPU_FREQUENCY: &str = "cpu_frequency";
const CPU_NAME: &str = "cpu_name";
const CPU_VENDOR_ID: &str = "cpu_vendor_id";
const DISK_AVAILABLE_SPACE: &str = "disk_available_space";
const DISK_COUNT: &str = "disk_count";
const DISK_FILE_SYSTEM: &str = "disk_file_system";
const DISK_NAME: &str = "disk_name";
const DISK_TOTAL_SPACE: &str = "disk_total_space";
const DISK_TYPE: &str = "disk_type";
const MEMORY_AVAILABLE: &str = "memory_available";
const MEMORY_TOTAL: &str = "memory_total";
```
