# Audit Report

## Title
Missing Event Verification in Indexer Allows Malicious Fullnode to Inject Fraudulent Staking Activities

## Summary
The Aptos indexer processes transaction events from remote fullnodes without verifying that the events match the cryptographically committed `event_root_hash` in the `TransactionInfo`. This allows a malicious fullnode to serve fake staking events that the indexer will record as legitimate, breaking data integrity guarantees and potentially misleading users, dApps, and governance participants.

## Finding Description

The Aptos blockchain cryptographically commits to all events emitted during transaction execution via the `event_root_hash` field in `TransactionInfo`. This hash is computed as a Merkle root of all event hashes and is included in the transaction accumulator that validators agree upon through consensus. [1](#0-0) 

The event root hash is computed during transaction execution by hashing each event and building a Merkle accumulator: [2](#0-1) 

When indexers connect to fullnodes via gRPC to retrieve transactions, the fullnode converts the data to protobuf format and includes both the events AND the `event_root_hash`: [3](#0-2) 

A verification function exists to check that events match the committed event_root_hash: [4](#0-3) 

**However, the indexer NEVER calls this verification function.** When processing staking events, the indexer directly extracts `event.data` and processes it without verification: [5](#0-4) 

The indexer parses event data and stores it in the database: [6](#0-5) 

**Attack Path:**
1. Attacker runs a malicious fullnode with modified local database or intercepts gRPC responses
2. Legitimate indexer connects to this fullnode via the standard gRPC protocol
3. Malicious fullnode modifies events in the response (e.g., changes staking amounts from 1000 to 1000000, or changes delegator addresses to attacker-controlled addresses)
4. Malicious fullnode sends the modified events along with the legitimate (unmodified) `event_root_hash`
5. Indexer receives the data and processes it WITHOUT verifying events against event_root_hash
6. Indexer stores fraudulent staking activities in its database
7. Users, dApps, and governance UIs query the indexer and receive fraudulent data

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program as a "Significant protocol violation."

**Concrete Impacts:**
- **Governance Manipulation**: If governance UIs display voting power based on fraudulent indexer data, users could be misled about proposal outcomes or validator influence
- **User Financial Harm**: Users delegating stake based on fraudulent reward distribution data could make suboptimal decisions
- **dApp Integrity**: DeFi protocols querying staking data could execute trades or loans based on incorrect collateral information
- **Ecosystem Trust**: The indexer is a critical infrastructure component - if it cannot be trusted to reflect on-chain state accurately, it undermines the entire ecosystem

While this doesn't directly steal funds or break consensus, it violates the fundamental guarantee that off-chain indexers should accurately reflect on-chain state. The cryptographic commitment (event_root_hash) is provided but never checked, making the security mechanism useless.

## Likelihood Explanation

**Likelihood: HIGH**

**Attacker Requirements:**
- Run a malicious fullnode (no special privileges required)
- Wait for legitimate indexers to connect (or advertise the fullnode to indexer operators)
- Modify events in gRPC responses (simple code modification)

**Feasibility:**
- Many indexer operators run separate indexer instances that connect to remote fullnodes for scalability
- The gRPC protocol is the standard way for indexers to retrieve transaction data
- No authentication or trust verification exists for fullnode-to-indexer connections
- The attack requires minimal technical sophistication - just modifying protobuf responses

**Detection Difficulty:**
- Indexer operators would not detect the attack without manually comparing their data to a trusted source
- No alerts or error logs would be generated since the indexer sees the data as valid
- The fraudulent data would persist in the indexer database and be served to all clients

## Recommendation

**Immediate Fix:** Add event verification after receiving transactions from gRPC:

```rust
// In the indexer transaction processing pipeline, after receiving transactions:
// File: ecosystem/indexer-grpc/indexer-grpc-cache-worker/src/worker.rs 
// or wherever transactions are processed from gRPC

use aptos_types::proof::accumulator::InMemoryEventAccumulator;
use aptos_crypto::hash::CryptoHash;

fn verify_transaction_events(
    events: &[ContractEvent],
    transaction_info: &TransactionInfo,
) -> anyhow::Result<()> {
    let event_hashes: Vec<_> = events.iter().map(CryptoHash::hash).collect();
    let computed_event_root_hash = InMemoryEventAccumulator::from_leaves(&event_hashes).root_hash();
    
    anyhow::ensure!(
        computed_event_root_hash == transaction_info.event_root_hash(),
        "Event verification failed: computed hash {:?} doesn't match TransactionInfo hash {:?}",
        computed_event_root_hash,
        transaction_info.event_root_hash()
    );
    
    Ok(())
}

// Call this function for every transaction before processing its events
```

**Long-term Solution:**
1. Add event verification as a required step in all indexer transaction processors
2. Add metrics/alerts when verification fails to detect malicious fullnodes
3. Implement fullnode reputation system to avoid connecting to nodes that serve invalid data
4. Consider using TransactionWithProof types that include explicit verification requirements
5. Add integration tests that simulate malicious fullnode behavior

## Proof of Concept

```rust
// PoC: Malicious Fullnode Serving Fake Events
// This demonstrates how a malicious fullnode could modify events without detection

// File: ecosystem/indexer-grpc/indexer-grpc-fullnode/src/convert.rs (modified)

pub fn convert_user_transaction_malicious(
    user_txn: &aptos_api_types::UserTransaction,
) -> transaction::Transaction {
    let mut converted = convert_user_transaction(user_txn);
    
    // Malicious modification: Change staking amounts in events
    if let Some(txn_data) = converted.txn_data.as_mut() {
        if let transaction::transaction::TxnData::User(user_data) = txn_data {
            for event in user_data.events.iter_mut() {
                if event.type_str.contains("AddStakeEvent") {
                    // Modify the event data JSON to change staking amount
                    let mut event_json: serde_json::Value = 
                        serde_json::from_str(&event.data).unwrap_or_default();
                    
                    if let Some(amount) = event_json.get_mut("amount_added") {
                        // Multiply staking amount by 1000x
                        if let Some(num) = amount.as_str() {
                            let original: u64 = num.parse().unwrap_or(0);
                            *amount = serde_json::Value::String((original * 1000).to_string());
                        }
                    }
                    
                    event.data = event_json.to_string();
                    // Note: event_root_hash in TransactionInfo remains unchanged
                    // Indexer will accept the fake event without verification
                }
            }
        }
    }
    
    converted
}

// Indexer will process this modified transaction and store fraudulent staking data
// Without event verification, there is no way for the indexer to detect the attack
```

**Test Steps:**
1. Deploy a modified fullnode with the malicious conversion code above
2. Configure an indexer to connect to this fullnode via gRPC
3. Submit legitimate staking transactions on the blockchain
4. Query the indexer's staking data - it will show 1000x inflated amounts
5. Query a trusted fullnode directly - it will show correct amounts
6. The divergence proves the indexer cannot be trusted

## Notes

This vulnerability exists specifically in the **gRPC-based indexer architecture** where indexers connect to remote fullnodes. The local indexer that reads directly from its own database is not affected, as that database has already been validated through consensus.

The verification function `verify_events_against_root_hash` exists in the codebase and is used in some contexts (like `TransactionWithProof.verify()`), but it is never called in the indexer's event processing pipeline. This suggests the vulnerability may be an oversight rather than an intentional design decision.

The impact extends beyond just staking events - ALL events processed by the indexer are vulnerable to this attack, including governance votes, token transfers, and smart contract events.

### Citations

**File:** types/src/transaction/mod.rs (L2037-2038)
```rust
    /// The root hash of Merkle Accumulator storing all events emitted during this transaction.
    event_root_hash: HashValue,
```

**File:** types/src/transaction/mod.rs (L2629-2643)
```rust
fn verify_events_against_root_hash(
    events: &[ContractEvent],
    transaction_info: &TransactionInfo,
) -> Result<()> {
    let event_hashes: Vec<_> = events.iter().map(CryptoHash::hash).collect();
    let event_root_hash = InMemoryEventAccumulator::from_leaves(&event_hashes).root_hash();
    ensure!(
        event_root_hash == transaction_info.event_root_hash(),
        "The event root hash calculated doesn't match that carried on the \
                         transaction info! Calculated hash {:?}, transaction info hash {:?}",
        event_root_hash,
        transaction_info.event_root_hash()
    );
    Ok(())
}
```

**File:** execution/executor/src/workflow/do_ledger_update.rs (L69-75)
```rust
                let event_hashes = txn_output
                    .events()
                    .iter()
                    .map(CryptoHash::hash)
                    .collect::<Vec<_>>();
                let event_root_hash =
                    InMemoryEventAccumulator::from_leaves(&event_hashes).root_hash();
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/convert.rs (L579-579)
```rust
        event_root_hash: transaction_info.event_root_hash.0.to_vec(),
```

**File:** crates/indexer/src/models/stake_models/delegator_activities.rs (L43-44)
```rust
            if let Some(staking_event) =
                StakeEvent::from_event(event_type.as_str(), &event.data, txn_version)?
```

**File:** crates/indexer/src/models/stake_models/delegator_activities.rs (L46-54)
```rust
                let activity = match staking_event {
                    StakeEvent::AddStakeEvent(inner) => DelegatedStakingActivity {
                        transaction_version: txn_version,
                        event_index,
                        delegator_address: standardize_address(&inner.delegator_address),
                        pool_address: standardize_address(&inner.pool_address),
                        event_type: event_type.clone(),
                        amount: u64_to_bigdecimal(inner.amount_added),
                    },
```
