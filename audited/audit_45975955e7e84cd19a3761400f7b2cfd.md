# Audit Report

## Title
JWT Node Type Downgrade via Self-Asserted Role Type Enables Telemetry Monitoring Evasion

## Summary
A legitimate validator can obtain a JWT with downgraded node_type (UnknownFullNode instead of Validator) by providing a false `role_type` in the authentication request. This allows validators to evade validator-specific monitoring, audit logging, and rate limiting in the telemetry service.

## Finding Description

The telemetry service authentication flow trusts the client-provided `role_type` field to determine which peer cache to validate against, rather than checking all available caches to determine the peer's true role. [1](#0-0) 

When a validator sends an `AuthRequest` with `role_type = RoleType::FullNode` (lying about their actual role), the server checks the `validator_fullnodes()` cache instead of the `validators()` cache. Since the validator's peer_id is not in the VFN cache, the server returns `PeerRole::Unknown`. [2](#0-1) 

With `PeerRole::Unknown` and the self-asserted `role_type = RoleType::FullNode`, the node_type determination logic assigns `NodeType::UnknownFullNode`: [3](#0-2) 

The JWT is then created with this downgraded node_type: [4](#0-3) 

This downgraded JWT causes different treatment in telemetry endpoints:

**Log Ingestion**: Unknown nodes route to a separate backend client: [5](#0-4) 

**Metrics Ingestion**: Unknown validators route to untrusted metrics clients: [6](#0-5) 

**Remote Config Access**: Unknown nodes cannot access remote configuration: [7](#0-6) 

## Impact Explanation

This vulnerability falls into the **Low Severity** category per Aptos bug bounty criteria as it:
- Does not affect on-chain security, consensus, or funds
- Only impacts off-chain telemetry monitoring and observability
- Constitutes a non-critical implementation bug in authentication logic

However, it enables:
1. **Monitoring Evasion**: Malicious validators can hide their identity in telemetry data, appearing as unknown nodes
2. **Rate Limit Bypass**: Validator-specific rate limits on telemetry backends can be evaded
3. **Audit Trail Corruption**: Validator behavior is logged incorrectly, hindering incident investigation
4. **Detection Evasion**: Automated alerting systems configured for validator-specific anomalies will not trigger

## Likelihood Explanation

**Likelihood: High** - The attack is trivial to execute:
- Requires only legitimate validator credentials (which the attacker already has)
- No cryptographic bypass needed
- Single field modification in authentication request
- No rate limiting or detection mechanisms in place

Any validator operator can deliberately misrepresent their role with minimal effort.

## Recommendation

**Fix the authentication logic to verify peer identity against all available caches**, not just the self-asserted role:

```rust
// In handle_auth function, replace lines 66-114 with:
let (epoch, peer_role) = match context.peers().validators().read().get(&body.chain_id) {
    Some((epoch, peer_set)) => {
        // First check validators cache
        if let Some(peer) = peer_set.get(&body.peer_id) {
            if !peer.keys.contains(&remote_public_key) {
                return Err(reject::custom(ServiceError::forbidden(
                    ServiceErrorCode::AuthError(AuthError::PeerPublicKeyNotFound, body.chain_id),
                )));
            }
            return Ok((*epoch, PeerRole::Validator));
        }
        
        // Then check validator fullnodes cache
        if let Some((_, vfn_peer_set)) = context.peers().validator_fullnodes().read().get(&body.chain_id) {
            if let Some(peer) = vfn_peer_set.get(&body.peer_id) {
                if !peer.keys.contains(&remote_public_key) {
                    return Err(reject::custom(ServiceError::forbidden(
                        ServiceErrorCode::AuthError(AuthError::PeerPublicKeyNotFound, body.chain_id),
                    )));
                }
                return Ok((*epoch, PeerRole::ValidatorFullNode));
            }
        }
        
        // Verify peer_id derivation for unknown peers
        let derived_remote_peer_id = 
            aptos_types::account_address::from_identity_public_key(&remote_public_key);
        if derived_remote_peer_id != body.peer_id {
            return Err(reject::custom(ServiceError::forbidden(
                ServiceErrorCode::AuthError(AuthError::PublicKeyMismatch, body.chain_id),
            )));
        }
        Ok((*epoch, PeerRole::Unknown))
    },
    None => Err(reject::custom(ServiceError::unauthorized(
        ServiceErrorCode::AuthError(AuthError::ValidatorSetUnavailable, body.chain_id),
    ))),
}?;
```

**Key changes**:
1. Always check validators cache first, regardless of self-asserted role_type
2. Then check validator_fullnodes cache
3. Only assign Unknown if peer is not found in any trusted cache
4. Remove trust in client-provided role_type for cache selection

## Proof of Concept

```rust
#[tokio::test]
async fn test_validator_downgrade_attack() {
    use crate::tests::test_context;
    use aptos_config::config::{Peer, PeerRole, PeerSet};
    use aptos_crypto::x25519;
    use std::collections::HashSet;
    
    let test_context = test_context::new_test_context().await;
    let chain_id = ChainId::new(25);
    let peer_id = PeerId::random();
    let private_key = x25519::PrivateKey::generate_for_testing();
    let public_key = private_key.public_key();
    
    // Add peer to validators cache as a legitimate validator
    {
        let mut validators = test_context.inner.peers().validators().write();
        let mut peer_set = PeerSet::new();
        peer_set.insert(peer_id, Peer {
            keys: HashSet::from([public_key]),
            role: PeerRole::Validator,
        });
        validators.insert(chain_id, (10, peer_set));
    }
    
    // Create AuthRequest with INCORRECT role_type (claiming to be FullNode)
    let mut prologue = [0u8; 1 + 32 + 32];
    prologue[0] = chain_id.id();
    prologue[1..33].copy_from_slice(peer_id.as_ref());
    prologue[33..65].copy_from_slice(test_context.inner.noise_config().public_key().as_slice());
    
    let (client_init_msg, _) = test_context.inner.noise_config()
        .create_client_init_message(&prologue, &mut rand::rngs::OsRng)
        .unwrap();
    
    let auth_request = AuthRequest {
        chain_id,
        peer_id,
        role_type: RoleType::FullNode, // LYING - actually a Validator
        server_public_key: test_context.inner.noise_config().public_key(),
        handshake_msg: client_init_msg,
        run_uuid: Uuid::default(),
    };
    
    // Perform authentication
    let response = handle_auth(test_context.inner.clone(), auth_request).await;
    assert!(response.is_ok());
    
    // Extract JWT and decode it
    let jwt = extract_jwt_from_response(response.unwrap());
    let decoded = test_context.inner.jwt_service().decode(&jwt).unwrap();
    
    // VULNERABILITY: Validator got downgraded to UnknownFullNode
    assert_eq!(decoded.claims.node_type, NodeType::UnknownFullNode);
    // Expected: NodeType::Validator
    
    // Now this validator can evade monitoring by using this JWT
    // Their logs go to unknown_logs_ingest_client
    // Their metrics go to untrusted_ingest_metrics_clients
    // Their metrics show role=unknown_fullnode instead of role=validator
}
```

## Notes

**Important Distinction**: An external attacker cannot modify an already-issued JWT because it is cryptographically signed by the telemetry server. The vulnerability lies in the authentication phase where the server trusts the client's self-asserted role to determine which cache to check, allowing validators to deliberately obtain downgraded JWTs during the initial authentication handshake.

### Citations

**File:** crates/aptos-telemetry-service/src/auth.rs (L66-70)
```rust
    let cache = if body.role_type == RoleType::Validator {
        context.peers().validators()
    } else {
        context.peers().validator_fullnodes()
    };
```

**File:** crates/aptos-telemetry-service/src/auth.rs (L72-114)
```rust
    let (epoch, peer_role) = match cache.read().get(&body.chain_id) {
        Some((epoch, peer_set)) => {
            match peer_set.get(&body.peer_id) {
                Some(peer) => {
                    let remote_public_key = &remote_public_key;
                    if !peer.keys.contains(remote_public_key) {
                        warn!("peer found in peer set but public_key is not found. request body: {}, role_type: {}, peer_id: {}, received public_key: {}", body.chain_id, body.role_type, body.peer_id, remote_public_key);
                        return Err(reject::custom(ServiceError::forbidden(
                            ServiceErrorCode::AuthError(
                                AuthError::PeerPublicKeyNotFound,
                                body.chain_id,
                            ),
                        )));
                    }
                    Ok((*epoch, peer.role))
                },
                None => {
                    // if not, verify that their peerid is constructed correctly from their public key
                    let derived_remote_peer_id =
                        aptos_types::account_address::from_identity_public_key(remote_public_key);
                    if derived_remote_peer_id != body.peer_id {
                        return Err(reject::custom(ServiceError::forbidden(
                            ServiceErrorCode::AuthError(
                                AuthError::PublicKeyMismatch,
                                body.chain_id,
                            ),
                        )));
                    } else {
                        Ok((*epoch, PeerRole::Unknown))
                    }
                },
            }
        },
        None => {
            warn!(
                "Validator set unavailable for Chain ID {}. Rejecting request.",
                body.chain_id
            );
            Err(reject::custom(ServiceError::unauthorized(
                ServiceErrorCode::AuthError(AuthError::ValidatorSetUnavailable, body.chain_id),
            )))
        },
    }?;
```

**File:** crates/aptos-telemetry-service/src/auth.rs (L116-135)
```rust
    let node_type = match peer_role {
        PeerRole::Validator => NodeType::Validator,
        PeerRole::ValidatorFullNode => NodeType::ValidatorFullNode,
        PeerRole::Unknown => match body.role_type {
            RoleType::Validator => NodeType::UnknownValidator,
            RoleType::FullNode => context
                .peers()
                .public_fullnodes()
                .get(&body.chain_id)
                .and_then(|peer_set| {
                    if peer_set.contains_key(&body.peer_id) {
                        Some(NodeType::PublicFullNode)
                    } else {
                        None
                    }
                })
                .unwrap_or(NodeType::UnknownFullNode),
        },
        _ => NodeType::Unknown,
    };
```

**File:** crates/aptos-telemetry-service/src/auth.rs (L137-151)
```rust
    let token = create_jwt_token(
        context.jwt_service(),
        body.chain_id,
        body.peer_id,
        node_type,
        epoch,
        body.run_uuid,
    )
    .map_err(|e| {
        error!("unable to create jwt token: {}", e);
        reject::custom(ServiceError::internal(ServiceErrorCode::AuthError(
            AuthError::from(e),
            body.chain_id,
        )))
    })?;
```

**File:** crates/aptos-telemetry-service/src/log_ingest.rs (L57-62)
```rust
    let client = match claims.node_type {
        NodeType::Unknown | NodeType::UnknownValidator | NodeType::UnknownFullNode => {
            &context.log_ingest_clients().unknown_logs_ingest_client
        },
        _ => &context.log_ingest_clients().known_logs_ingest_client,
    };
```

**File:** crates/aptos-telemetry-service/src/prometheus_push_metrics.rs (L80-85)
```rust
    let client = match claims.node_type {
        NodeType::UnknownValidator | NodeType::UnknownFullNode => {
            &context.metrics_client().untrusted_ingest_metrics_clients
        },
        _ => &context.metrics_client().ingest_metrics_client,
    };
```

**File:** crates/aptos-telemetry-service/src/remote_config.rs (L14-18)
```rust
        .and(with_auth(context.clone(), vec![
            NodeType::Validator,
            NodeType::ValidatorFullNode,
            NodeType::PublicFullNode,
        ]))
```
