# Audit Report

## Title
Protocol Negotiation Bypass Allows Unauthorized Access to Non-Negotiated Application Protocols

## Summary
The network layer fails to validate incoming messages against the negotiated protocol set established during connection handshake, allowing malicious peers to send messages on protocols they explicitly excluded during negotiation, bypassing protocol-level access control and potentially enabling attacks on experimental or feature-gated protocols.

## Finding Description

The Aptos network layer performs protocol negotiation during connection establishment via `perform_handshake()`, which computes the intersection of supported protocols between two peers. This negotiated set is stored in `ConnectionMetadata.application_protocols` as the security boundary for what protocols should be used on the connection. [1](#0-0) 

However, when processing incoming messages, the validation only checks if an `upstream_handler` exists for the protocol, completely ignoring the negotiated protocol set: [2](#0-1) 

This creates an asymmetry:
- **Outgoing messages**: Applications use `PeerMetadata.supports_protocol()` to check if a peer negotiated support for a protocol before sending [3](#0-2) 

- **Incoming messages**: No validation against `connection_metadata.application_protocols` occurs

**Attack Scenario:**

1. Node A registers handlers for protocols: `[ConsensusRpc, Mempool, Storage, ConsensusObserver]`
2. Node A advertises all protocols during handshake via `supported_protocols` [4](#0-3) 

3. Malicious Node B connects and advertises only: `[ConsensusRpc, Mempool, Storage]` (excludes ConsensusObserver)
4. `perform_handshake()` correctly computes intersection: `[ConsensusRpc, Mempool, Storage]`
5. This negotiated set is stored in `connection_metadata.application_protocols` [5](#0-4) 

6. Node B can now send `ConsensusObserver` messages, which Node A processes because `upstream_handlers` contains a handler for `ConsensusObserver`
7. Node A would never send ConsensusObserver messages to Node B (due to `supports_protocol()` check), but Node B can send them to Node A

This breaks the protocol negotiation security invariant: **A peer should only be able to use protocols that were mutually negotiated during handshake**.

**Real-World Impact:**

ConsensusObserver is a feature-gated protocol with conditional enablement: [6](#0-5) [7](#0-6) 

A malicious peer could exploit this to:
- Send ConsensusObserver messages to nodes that enabled the feature but wanted to restrict it to trusted peers
- Bypass protocol-level rate limiting or access control based on negotiated protocols  
- Attack experimental protocols that nodes expose for testing but don't want generally accessible
- Exploit protocol-specific vulnerabilities in handlers that assume the protocol was properly negotiated

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program as a "Significant protocol violation". It breaks the fundamental security guarantee of protocol negotiation - that peers can only communicate using mutually agreed protocols. 

The impact includes:
- **Protocol Access Control Bypass**: Attackers can access protocols they shouldn't have permission to use
- **Feature Flag Circumvention**: Feature-gated protocols like ConsensusObserver can be forcibly enabled by external peers
- **Attack Surface Expansion**: Experimental or beta protocols become exploitable by any peer, not just trusted ones
- **Asymmetric Communication**: The honest node cannot send to the attacker on certain protocols, but the attacker can send to the honest node, breaking protocol symmetry assumptions

While this doesn't directly cause consensus safety violations or fund loss, it significantly undermines the network's security architecture by breaking protocol-level access control.

## Likelihood Explanation

**Likelihood: High**

- **Ease of Exploitation**: Any peer connecting to the network can exploit this vulnerability with standard protocol messages
- **No Special Access Required**: No validator credentials, stake, or insider access needed
- **Deterministic**: The attack succeeds 100% of the time due to the missing validation
- **Widespread Exposure**: Every network connection is potentially vulnerable
- **Simple Attack**: Attacker only needs to:
  1. Connect to a target node
  2. Negotiate minimal protocols during handshake
  3. Send messages on non-negotiated protocols with registered handlers

The vulnerability is particularly dangerous because it's silent - no errors are logged when messages arrive on non-negotiated protocols, making detection difficult.

## Recommendation

Add validation in `handle_inbound_network_message()` to check that incoming messages use protocols that were negotiated during handshake:

```rust
fn handle_inbound_network_message(
    &mut self,
    message: NetworkMessage,
) -> Result<(), PeerManagerError> {
    match &message {
        NetworkMessage::DirectSendMsg(direct) => {
            // NEW: Validate protocol was negotiated
            if !self.connection_metadata.application_protocols.contains(direct.protocol_id) {
                warn!(
                    NetworkSchema::new(&self.network_context)
                        .connection_metadata(&self.connection_metadata),
                    protocol_id = ?direct.protocol_id,
                    "Received message on non-negotiated protocol from peer {}",
                    self.remote_peer_id().short_str()
                );
                counters::direct_send_messages(&self.network_context, "non_negotiated").inc();
                return Err(PeerManagerError::InvalidProtocol);
            }
            
            let data_len = direct.raw_msg.len();
            // ... rest of existing logic
        },
        NetworkMessage::RpcRequest(request) => {
            // NEW: Validate protocol was negotiated
            if !self.connection_metadata.application_protocols.contains(request.protocol_id) {
                warn!(
                    NetworkSchema::new(&self.network_context)
                        .connection_metadata(&self.connection_metadata),
                    protocol_id = ?request.protocol_id,
                    "Received RPC request on non-negotiated protocol from peer {}",
                    self.remote_peer_id().short_str()
                );
                counters::rpc_messages(&self.network_context, "non_negotiated").inc();
                return Err(PeerManagerError::InvalidProtocol);
            }
            
            // ... rest of existing logic
        },
        // ... other message types
    }
}
```

Additionally, consider:
1. **Disconnect violating peers**: Peers sending on non-negotiated protocols should be disconnected as malicious
2. **Security event logging**: Log protocol negotiation bypasses as security events
3. **Metrics**: Track non-negotiated protocol attempts for monitoring
4. **Test coverage**: Add tests verifying that non-negotiated protocols are rejected

## Proof of Concept

```rust
#[cfg(test)]
mod protocol_negotiation_bypass_test {
    use super::*;
    use aptos_config::network_id::NetworkId;
    use aptos_types::PeerId;
    
    #[tokio::test]
    async fn test_non_negotiated_protocol_accepted() {
        // Setup two peers
        let peer_a_id = PeerId::random();
        let peer_b_id = PeerId::random();
        
        // Peer A supports [ConsensusRpc, Mempool, ConsensusObserver]
        let mut peer_a_protocols = ProtocolIdSet::empty();
        peer_a_protocols.insert(ProtocolId::ConsensusRpcBcs);
        peer_a_protocols.insert(ProtocolId::MempoolDirectSend);
        peer_a_protocols.insert(ProtocolId::ConsensusObserver);
        
        // Peer B only advertises [ConsensusRpc, Mempool] - excludes ConsensusObserver
        let mut peer_b_protocols = ProtocolIdSet::empty();
        peer_b_protocols.insert(ProtocolId::ConsensusRpcBcs);
        peer_b_protocols.insert(ProtocolId::MempoolDirectSend);
        
        // Create handshake messages
        let peer_a_handshake = HandshakeMsg {
            supported_protocols: [(MessagingProtocolVersion::V1, peer_a_protocols)].into(),
            chain_id: ChainId::test(),
            network_id: NetworkId::Validator,
        };
        
        let peer_b_handshake = HandshakeMsg {
            supported_protocols: [(MessagingProtocolVersion::V1, peer_b_protocols)].into(),
            chain_id: ChainId::test(),
            network_id: NetworkId::Validator,
        };
        
        // Perform handshake - should negotiate only [ConsensusRpc, Mempool]
        let (_, negotiated_protocols) = peer_a_handshake
            .perform_handshake(&peer_b_handshake)
            .expect("Handshake should succeed");
        
        // Verify ConsensusObserver was NOT negotiated
        assert!(!negotiated_protocols.contains(ProtocolId::ConsensusObserver));
        assert!(negotiated_protocols.contains(ProtocolId::ConsensusRpcBcs));
        assert!(negotiated_protocols.contains(ProtocolId::MempoolDirectSend));
        
        // Create connection metadata with negotiated protocols
        let connection_metadata = ConnectionMetadata::new(
            peer_b_id,
            ConnectionId::default(),
            NetworkAddress::mock(),
            ConnectionOrigin::Inbound,
            MessagingProtocolVersion::V1,
            negotiated_protocols,
            PeerRole::Validator,
        );
        
        // Now Peer B can send ConsensusObserver messages despite not negotiating it
        let malicious_message = NetworkMessage::DirectSendMsg(DirectSendMsg {
            protocol_id: ProtocolId::ConsensusObserver, // Non-negotiated protocol!
            priority: Priority::default(),
            raw_msg: vec![0x01, 0x02, 0x03],
        });
        
        // This message would be accepted if ConsensusObserver handler is registered
        // because handle_inbound_network_message() doesn't check application_protocols
        
        // The vulnerability: connection_metadata.application_protocols does NOT contain
        // ConsensusObserver, but if an upstream_handler exists for it, the message
        // will be processed without error.
    }
}
```

## Notes

This vulnerability represents a fundamental breakdown in the network protocol negotiation security model. The protocol negotiation mechanism establishes a trust boundary and capability set for each connection, but this boundary is not enforced when processing incoming messages. This allows attackers to bypass access controls and potentially exploit experimental or vulnerable protocol handlers that nodes intended to restrict to trusted peers.

The fix requires adding a single validation check but has broad security implications for the entire protocol negotiation architecture. Any protocol-specific access control, rate limiting, or security assumptions based on the negotiated protocol set are currently ineffective for incoming messages.

### Citations

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L431-465)
```rust
    pub fn perform_handshake(
        &self,
        other: &HandshakeMsg,
    ) -> Result<(MessagingProtocolVersion, ProtocolIdSet), HandshakeError> {
        // verify that both peers are on the same chain
        if self.chain_id != other.chain_id {
            return Err(HandshakeError::InvalidChainId(
                other.chain_id,
                self.chain_id,
            ));
        }

        // verify that both peers are on the same network
        if self.network_id != other.network_id {
            return Err(HandshakeError::InvalidNetworkId(
                other.network_id,
                self.network_id,
            ));
        }

        // find the greatest common MessagingProtocolVersion where we both support
        // at least one common ProtocolId.
        for (our_handshake_version, our_protocols) in self.supported_protocols.iter().rev() {
            if let Some(their_protocols) = other.supported_protocols.get(our_handshake_version) {
                let common_protocols = our_protocols.intersect(their_protocols);

                if !common_protocols.is_empty() {
                    return Ok((*our_handshake_version, common_protocols));
                }
            }
        }

        // no intersection found
        Err(HandshakeError::NoCommonProtocols)
    }
```

**File:** network/framework/src/peer/mod.rs (L447-541)
```rust
    fn handle_inbound_network_message(
        &mut self,
        message: NetworkMessage,
    ) -> Result<(), PeerManagerError> {
        match &message {
            NetworkMessage::DirectSendMsg(direct) => {
                let data_len = direct.raw_msg.len();
                network_application_inbound_traffic(
                    self.network_context,
                    direct.protocol_id,
                    data_len as u64,
                );
                match self.upstream_handlers.get(&direct.protocol_id) {
                    None => {
                        counters::direct_send_messages(&self.network_context, UNKNOWN_LABEL).inc();
                        counters::direct_send_bytes(&self.network_context, UNKNOWN_LABEL)
                            .inc_by(data_len as u64);
                    },
                    Some(handler) => {
                        let key = (self.connection_metadata.remote_peer_id, direct.protocol_id);
                        let sender = self.connection_metadata.remote_peer_id;
                        let network_id = self.network_context.network_id();
                        let sender = PeerNetworkId::new(network_id, sender);
                        match handler.push(key, ReceivedMessage::new(message, sender)) {
                            Err(_err) => {
                                // NOTE: aptos_channel never returns other than Ok(()), but we might switch to tokio::sync::mpsc and then this would work
                                counters::direct_send_messages(
                                    &self.network_context,
                                    DECLINED_LABEL,
                                )
                                .inc();
                                counters::direct_send_bytes(&self.network_context, DECLINED_LABEL)
                                    .inc_by(data_len as u64);
                            },
                            Ok(_) => {
                                counters::direct_send_messages(
                                    &self.network_context,
                                    RECEIVED_LABEL,
                                )
                                .inc();
                                counters::direct_send_bytes(&self.network_context, RECEIVED_LABEL)
                                    .inc_by(data_len as u64);
                            },
                        }
                    },
                }
            },
            NetworkMessage::Error(error_msg) => {
                warn!(
                    NetworkSchema::new(&self.network_context)
                        .connection_metadata(&self.connection_metadata),
                    error_msg = ?error_msg,
                    "{} Peer {} sent an error message: {:?}",
                    self.network_context,
                    self.remote_peer_id().short_str(),
                    error_msg,
                );
            },
            NetworkMessage::RpcRequest(request) => {
                match self.upstream_handlers.get(&request.protocol_id) {
                    None => {
                        counters::direct_send_messages(&self.network_context, UNKNOWN_LABEL).inc();
                        counters::direct_send_bytes(&self.network_context, UNKNOWN_LABEL)
                            .inc_by(request.raw_request.len() as u64);
                    },
                    Some(handler) => {
                        let sender = self.connection_metadata.remote_peer_id;
                        let network_id = self.network_context.network_id();
                        let sender = PeerNetworkId::new(network_id, sender);
                        if let Err(err) = self
                            .inbound_rpcs
                            .handle_inbound_request(handler, ReceivedMessage::new(message, sender))
                        {
                            warn!(
                                NetworkSchema::new(&self.network_context)
                                    .connection_metadata(&self.connection_metadata),
                                error = %err,
                                "{} Error handling inbound rpc request: {}",
                                self.network_context,
                                err
                            );
                        }
                    },
                }
            },
            NetworkMessage::RpcResponse(_) => {
                // non-reference cast identical to this match case
                let NetworkMessage::RpcResponse(response) = message else {
                    unreachable!("NetworkMessage type changed between match and let")
                };
                self.outbound_rpcs.handle_inbound_response(response)
            },
        };
        Ok(())
    }
```

**File:** network/framework/src/application/metadata.rs (L55-71)
```rust
    /// Returns true iff the peer has advertised support for the given protocol
    pub fn supports_protocol(&self, protocol_id: ProtocolId) -> bool {
        self.connection_metadata
            .application_protocols
            .contains(protocol_id)
    }

    /// Returns true iff the peer has advertised support for at least
    /// one of the given protocols.
    pub fn supports_any_protocol(&self, protocol_ids: &[ProtocolId]) -> bool {
        let protocol_id_set = ProtocolIdSet::from_iter(protocol_ids);
        !self
            .connection_metadata
            .application_protocols
            .intersect(&protocol_id_set)
            .is_empty()
    }
```

**File:** network/framework/src/peer_manager/builder.rs (L410-432)
```rust
    pub fn add_service(
        &mut self,
        config: &NetworkServiceConfig,
    ) -> aptos_channel::Receiver<(PeerId, ProtocolId), ReceivedMessage> {
        // Register the direct send and rpc protocols
        self.transport_context()
            .add_protocols(&config.direct_send_protocols_and_preferences);
        self.transport_context()
            .add_protocols(&config.rpc_protocols_and_preferences);

        // Create the context and register the protocols
        let (network_notifs_tx, network_notifs_rx) = config.inbound_queue_config.build();
        let pm_context = self.peer_manager_context();
        for protocol in config
            .direct_send_protocols_and_preferences
            .iter()
            .chain(&config.rpc_protocols_and_preferences)
        {
            pm_context.add_upstream_handler(*protocol, network_notifs_tx.clone());
        }

        network_notifs_rx
    }
```

**File:** network/framework/src/transport/mod.rs (L307-332)
```rust
    // try to negotiate common aptosnet version and supported application protocols
    let (messaging_protocol, application_protocols) = handshake_msg
        .perform_handshake(&remote_handshake)
        .map_err(|err| {
            let err = format!(
                "handshake negotiation with peer {} failed: {}",
                remote_peer_id.short_str(),
                err
            );
            add_pp_addr(proxy_protocol_enabled, io::Error::other(err), &addr)
        })?;

    // return successful connection
    Ok(Connection {
        socket,
        metadata: ConnectionMetadata::new(
            remote_peer_id,
            CONNECTION_ID_GENERATOR.next(),
            addr,
            origin,
            messaging_protocol,
            application_protocols,
            peer_role,
        ),
    })
}
```

**File:** config/src/config/consensus_observer_config.rs (L11-14)
```rust
// Useful constants for enabling consensus observer on different node types
const ENABLE_ON_VALIDATORS: bool = true;
const ENABLE_ON_VALIDATOR_FULLNODES: bool = true;
const ENABLE_ON_PUBLIC_FULLNODES: bool = false;
```

**File:** aptos-node/src/network.rs (L336-358)
```rust
        // Register consensus observer (both client and server) with the network
        if node_config
            .consensus_observer
            .is_observer_or_publisher_enabled()
        {
            // Create the network handle for this network type
            let network_handle = register_client_and_service_with_network(
                &mut network_builder,
                network_id,
                &network_config,
                consensus_observer_network_configuration(node_config),
                false,
            );

            // Add the network handle to the set of handles
            if let Some(consensus_observer_network_handles) =
                &mut consensus_observer_network_handles
            {
                consensus_observer_network_handles.push(network_handle);
            } else {
                consensus_observer_network_handles = Some(vec![network_handle]);
            }
        }
```
