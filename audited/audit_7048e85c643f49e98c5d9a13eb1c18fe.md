# Audit Report

## Title
Insecure Temporary File Creation in Current Working Directory with World-Readable Permissions in OnDiskStorage

## Summary
The `OnDiskStorage::new_with_time_service()` function contains a flaw in its parent directory resolution logic that causes temporary files containing sensitive cryptographic material (validator consensus private keys) to be created in the current working directory with default system permissions when instantiated with relative file paths. This creates a window of vulnerability where local attackers could potentially read validator private keys. [1](#0-0) 

## Finding Description

When `OnDiskStorage` is instantiated with a simple filename (e.g., `"storage.db"`) or any path where `parent()` returns an empty path, the code attempts to determine the parent directory for temporary file creation. The problematic logic uses `map_or_else(PathBuf::new, |p| p.to_path_buf())`, which results in an empty `PathBuf` when the parent is either `None` or `Some("")`. [2](#0-1) 

This empty `PathBuf` is then passed to `TempPath::new_with_temp_dir()`, which creates a temporary file path by appending a random hex string to the empty directory path, resulting in a relative path that resolves to the current working directory. [3](#0-2) 

During write operations, this temporary file is created in the current working directory with default file permissions (typically `0o666 & !umask`, which on most Unix systems with standard umask of `0o022` results in `0o644` - world-readable). [4](#0-3) 

The `OnDiskStorage` is used by `PersistentSafetyStorage` to store highly sensitive cryptographic material, including validator consensus private keys (BLS12-381 keys). [5](#0-4) 

## Impact Explanation

This vulnerability constitutes **Medium Severity** under Aptos bug bounty criteria for the following reasons:

1. **Cryptographic Material Exposure**: Validator consensus private keys stored in temporary files could be read by local attackers during the brief window when the temp file exists (between creation and rename operations).

2. **Consensus Security Risk**: If a validator's consensus private key is compromised, an attacker could sign malicious blocks, participate in consensus as that validator, and potentially contribute to consensus safety violations if enough keys are compromised.

3. **State Inconsistency Potential**: Compromised validator keys could lead to equivocation or other consensus misbehavior requiring manual intervention to resolve.

However, the severity is mitigated by several factors:
- The code explicitly documents that OnDiskStorage "should not be used in production"
- Standard production deployments use `OnDiskStorageConfig` which converts relative paths to absolute paths before instantiation
- Exploitation requires local system access and specific misconfiguration scenarios [6](#0-5) [7](#0-6) 

## Likelihood Explanation

The likelihood of exploitation is **LOW** due to multiple required conditions:

1. **Non-Standard Usage Required**: Production validator configurations use `OnDiskStorageConfig::path()` which properly handles relative paths by joining them with `data_dir` (defaulting to `/opt/aptos/data`), resulting in absolute paths with proper parent directories. [8](#0-7) 

2. **Local Access Requirement**: The attacker must have local system access to read files in the current working directory of the validator process.

3. **Timing Window**: The temporary file exists only briefly during write operations, creating a narrow exploitation window.

4. **Explicit Warning**: The code contains clear documentation that OnDiskStorage is a proof-of-concept not intended for production use.

The vulnerability could realistically be triggered in:
- Development/testing environments where OnDiskStorage is directly instantiated with relative paths
- Custom deployment scripts that bypass the standard configuration layer
- Misconfigured systems where validators are run with insecure working directories

## Recommendation

**Primary Fix**: Ensure temporary files are always created in a secure, well-defined directory rather than relying on the input file path's parent directory. Modify the code to use the system temp directory or an explicitly configured secure temp directory when the parent directory is empty or uncertain.

```rust
fn new_with_time_service(file_path: PathBuf, time_service: TimeService) -> Self {
    if !file_path.exists() {
        File::create(&file_path)
            .unwrap_or_else(|_| panic!("Unable to create storage at path: {:?}", file_path));
    }

    // Use the file's parent if it exists and is not empty, otherwise use system temp
    let file_dir = file_path
        .parent()
        .and_then(|p| if p.as_os_str().is_empty() { None } else { Some(p) })
        .map(|p| p.to_path_buf())
        .unwrap_or_else(|| std::env::temp_dir());

    Self {
        file_path,
        temp_path: TempPath::new_with_temp_dir(file_dir),
        time_service,
    }
}
```

**Secondary Recommendations**:
1. Add explicit validation that rejects relative paths without parent directories
2. Set restrictive permissions (0o600) on temporary files containing sensitive data
3. Consider deprecating OnDiskStorage entirely in favor of VaultStorage for production use
4. Add runtime checks to ensure OnDiskStorage is not used in production validator nodes

## Proof of Concept

```rust
#[cfg(test)]
mod test_temp_file_vulnerability {
    use super::*;
    use std::fs;
    use std::path::PathBuf;
    
    #[test]
    fn test_relative_path_creates_temp_in_cwd() {
        // Create OnDiskStorage with a simple filename (relative path)
        let test_file = "test_storage.json";
        let storage = OnDiskStorage::new(PathBuf::from(test_file));
        
        // Perform a write operation which creates a temp file
        let mut data = std::collections::HashMap::new();
        data.insert("test_key".to_string(), serde_json::json!("test_value"));
        storage.write(&data).unwrap();
        
        // Verify the temp file path is relative (in CWD)
        let temp_path = storage.temp_path.path();
        assert!(temp_path.is_relative(), 
            "Temp file should be relative path but is: {:?}", temp_path);
        
        // Check that temp files can be created in CWD
        // This demonstrates the vulnerability: sensitive data in predictable CWD location
        
        // Cleanup
        fs::remove_file(test_file).ok();
    }
    
    #[test]
    fn test_temp_file_permissions() {
        use std::os::unix::fs::PermissionsExt;
        
        let test_file = "test_storage_perms.json";
        let storage = OnDiskStorage::new(PathBuf::from(test_file));
        
        // Write to create temp file
        let mut data = std::collections::HashMap::new();
        data.insert("sensitive_key".to_string(), 
            serde_json::json!("sensitive_validator_private_key_data"));
        storage.write(&data).unwrap();
        
        // Check file permissions on the final file
        let metadata = fs::metadata(test_file).unwrap();
        let permissions = metadata.permissions();
        let mode = permissions.mode();
        
        // On Unix, default permissions are typically 0o644 (world-readable)
        // This is insecure for sensitive cryptographic material
        println!("File permissions: {:o}", mode & 0o777);
        
        // Cleanup
        fs::remove_file(test_file).ok();
    }
}
```

## Notes

While this vulnerability technically exists in the codebase, its practical exploitability in production environments is significantly limited by the configuration layer that converts relative paths to absolute paths. The code explicitly documents that OnDiskStorage is not suitable for production use. However, the vulnerability represents a defense-in-depth failure: even "non-production" code handling sensitive cryptographic material should implement secure temporary file handling. The issue is particularly concerning for development, testing, and non-standard deployment scenarios where direct instantiation might occur.

### Citations

**File:** secure/storage/src/on_disk.rs (L16-22)
```rust
/// OnDiskStorage represents a key value store that is persisted to the local filesystem and is
/// intended for single threads (or must be wrapped by a Arc<RwLock<>>). This provides no permission
/// checks and simply offers a proof of concept to unblock building of applications without more
/// complex data stores. Internally, it reads and writes all data to a file, which means that it
/// must make copies of all key material which violates the code base. It violates it because
/// the anticipation is that data stores would securely handle key material. This should not be used
/// in production.
```

**File:** secure/storage/src/on_disk.rs (L40-44)
```rust
        // The parent will be one when only a filename is supplied. Therefore use the current
        // working directory provided by PathBuf::new().
        let file_dir = file_path
            .parent()
            .map_or_else(PathBuf::new, |p| p.to_path_buf());
```

**File:** secure/storage/src/on_disk.rs (L64-70)
```rust
    fn write(&self, data: &HashMap<String, Value>) -> Result<(), Error> {
        let contents = serde_json::to_vec(data)?;
        let mut file = File::create(self.temp_path.path())?;
        file.write_all(&contents)?;
        fs::rename(&self.temp_path, &self.file_path)?;
        Ok(())
    }
```

**File:** crates/aptos-temppath/src/lib.rs (L37-48)
```rust
    pub fn new_with_temp_dir(temp_dir: PathBuf) -> Self {
        let mut temppath = temp_dir;
        let mut rng = rand::thread_rng();
        let mut bytes = [0_u8; 16];
        rng.fill_bytes(&mut bytes);
        temppath.push(hex::encode(bytes));

        TempPath {
            path_buf: temppath,
            persist: false,
        }
    }
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L63-81)
```rust
    fn initialize_keys_and_accounts(
        internal_store: &mut Storage,
        author: Author,
        consensus_private_key: bls12381::PrivateKey,
    ) -> Result<(), Error> {
        let result = internal_store.set(CONSENSUS_KEY, consensus_private_key);
        // Attempting to re-initialize existing storage. This can happen in environments like
        // forge. Rather than be rigid here, leave it up to the developer to detect
        // inconsistencies or why they did not reset storage between rounds. Do not repeat the
        // checks again below, because it is just too strange to have a partially configured
        // storage.
        if let Err(aptos_secure_storage::Error::KeyAlreadyExists(_)) = result {
            warn!("Attempted to re-initialize existing storage");
            return Ok(());
        }

        internal_store.set(OWNER_ACCOUNT, author)?;
        Ok(())
    }
```

**File:** config/src/config/secure_backend_config.rs (L140-146)
```rust
    pub fn path(&self) -> PathBuf {
        if self.path.is_relative() {
            self.data_dir.join(&self.path)
        } else {
            self.path.clone()
        }
    }
```

**File:** config/src/config/secure_backend_config.rs (L162-173)
```rust
impl From<&SecureBackend> for Storage {
    fn from(backend: &SecureBackend) -> Self {
        match backend {
            SecureBackend::InMemoryStorage => Storage::from(InMemoryStorage::new()),
            SecureBackend::OnDiskStorage(config) => {
                let storage = Storage::from(OnDiskStorage::new(config.path()));
                if let Some(namespace) = &config.namespace {
                    Storage::from(Namespaced::new(namespace, Box::new(storage)))
                } else {
                    storage
                }
            },
```
