# Audit Report

## Title
Insufficient Path Validation in Storage Directory Configuration Allows Database Creation in Arbitrary System Locations

## Summary
The `config.storage.dir()` method returns a user-specified path without validation for directory traversal, system directory access, or world-writable locations. This allows malicious or misconfigured node configurations to create database files in dangerous locations such as `/etc`, `/tmp`, or other system directories, potentially leading to data corruption, denial of service, or information disclosure.

## Finding Description
The `initialize_dbs()` function in `fast_sync_storage_wrapper.rs` calls `config.storage.dir()` to obtain the storage directory path, which is then used to create a secondary database for fast sync operations. [1](#0-0) 

The `dir()` method in `StorageConfig` simply returns either an absolute path or joins a relative path with `data_dir`, without any validation: [2](#0-1) 

The path is then passed through to database opening operations where it's used to create directories: [3](#0-2) 

This eventually reaches RocksDB's `DB::open_cf()` which creates directories as needed: [4](#0-3) 

Critically, when `delete_on_restart` is enabled (which is true by default for hot state), the code performs `std::fs::remove_dir_all(&path)` on the configured path without validation: [5](#0-4) 

The `ConfigSanitizer` for `StorageConfig` validates `db_path_overrides` paths to ensure they are absolute, but does NOT validate the main `storage.dir` field: [6](#0-5) 

**Attack Scenarios:**
1. **System Directory Write**: Configuration with `storage.dir: /etc` causes database creation in `/etc/fast_sync_secondary/`, potentially corrupting system configuration
2. **Directory Traversal**: Relative paths like `../../../../tmp/malicious` escape the intended directory structure
3. **World-Writable Directory**: Using `/tmp` allows other users to read/tamper with blockchain state
4. **Delete on Restart**: Combined with malicious paths, the `delete_on_restart` flag could delete arbitrary directories

## Impact Explanation
This is a **Medium severity** vulnerability because:

1. **Limited by OS Permissions**: If the node runs as non-root (best practice), it cannot write to protected directories like `/etc`
2. **Requires Configuration Access**: The attacker needs ability to modify the node configuration file
3. **Potential for Significant Harm**:
   - **Denial of Service**: Filling system partitions with database files
   - **Data Loss**: `delete_on_restart` could remove important data
   - **Information Disclosure**: Databases in world-readable locations leak blockchain state
   - **System Instability**: Writing to system directories could corrupt node operation

Per Aptos Bug Bounty criteria, this qualifies as Medium severity: "State inconsistencies requiring intervention" and operational disruption requiring manual recovery.

## Likelihood Explanation
**Likelihood: Medium**

While this requires configuration file access (typically restricted to node operators), several realistic scenarios enable exploitation:

1. **Compromised Operator Credentials**: External attacker gains access to operator systems/credentials
2. **Misconfiguration**: Operator accidentally sets incorrect storage paths during deployment
3. **Supply Chain Attack**: Malicious configuration templates distributed to operators
4. **Development/Test Environments**: Less restrictive permissions allow exploitation
5. **Automated Deployment Tools**: Bugs in automation could generate malicious configs

The lack of validation violates defense-in-depth principles - even trusted input should be validated, especially when consequences include file system operations like `remove_dir_all()`.

## Recommendation
Add path validation in the `StorageConfig::sanitize()` method to reject dangerous paths:

```rust
impl ConfigSanitizer for StorageConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let config = &node_config.storage;
        
        // Validate main storage directory
        let storage_dir = config.dir();
        
        // Reject if not absolute path
        if !storage_dir.is_absolute() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!("Storage directory must be an absolute path: {:?}", storage_dir),
            ));
        }
        
        // Reject system directories
        let dangerous_prefixes = ["/etc", "/bin", "/sbin", "/usr", "/boot", "/sys", "/proc", "/dev"];
        for prefix in &dangerous_prefixes {
            if storage_dir.starts_with(prefix) {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("Storage directory cannot be in system directory: {:?}", storage_dir),
                ));
            }
        }
        
        // Reject /tmp (world-writable)
        if storage_dir.starts_with("/tmp") {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Storage directory cannot be in /tmp (world-writable)".to_string(),
            ));
        }
        
        // Canonicalize to prevent directory traversal
        if let Ok(canonical) = storage_dir.canonicalize() {
            if canonical != storage_dir {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("Storage directory contains symlinks or traversal: {:?}", storage_dir),
                ));
            }
        }
        
        // ... existing validation code ...
    }
}
```

Additionally, ensure the main `storage.dir` and `storage.data_dir` fields are validated during configuration loading, not just the override paths.

## Proof of Concept

**Setup malicious configuration:**
```yaml
# malicious_config.yaml
storage:
  dir: "/tmp/aptos_db"  # World-readable/writable location
  # OR
  dir: "/etc/aptos_db"  # System directory (requires root)
  # OR  
  dir: "../../../../tmp/escape"  # Directory traversal

state_sync:
  state_sync_driver:
    bootstrapping_mode: "ApplyTransactionOutputsFromGenesis"  # Fast sync mode
```

**Exploitation steps:**
1. Deploy node with malicious configuration file
2. Start node: `aptos-node -f malicious_config.yaml`
3. `initialize_dbs()` is called during startup
4. Database directories created in unintended location:
   - `/tmp/aptos_db/fast_sync_secondary/` (world-readable)
   - `/etc/aptos_db/fast_sync_secondary/` (if running as root)
5. On restart with `hot_state_config.delete_on_restart: true`, calls `std::fs::remove_dir_all()` on the malicious path

**Verification:**
```bash
# After node startup, check for database in wrong location
ls -la /tmp/aptos_db/fast_sync_secondary/
# OR
ls -la /etc/aptos_db/fast_sync_secondary/

# Check file permissions (if in /tmp)
# Other users can read blockchain state
```

**Result:** Database files created in system or world-writable directories, bypassing intended storage isolation and potentially exposing blockchain state or corrupting system directories.

## Notes
While node operators are typically trusted roles, defense-in-depth security principles require input validation even for trusted inputs. The inconsistency in the codebase—where `db_path_overrides` paths are validated but the main `storage.dir` is not—indicates this validation was likely intended but overlooked. The presence of dangerous operations like `remove_dir_all()` downstream makes path validation critical.

### Citations

**File:** storage/aptosdb/src/fast_sync_storage_wrapper.rs (L64-64)
```rust
        let mut db_dir = config.storage.dir();
```

**File:** storage/aptosdb/src/fast_sync_storage_wrapper.rs (L78-80)
```rust
            db_dir.push(SECONDARY_DB_DIR);
            let secondary_db = AptosDB::open(
                StorageDirPaths::from_path(db_dir.as_path()),
```

**File:** config/src/config/storage_config.rs (L459-465)
```rust
    pub fn dir(&self) -> PathBuf {
        if self.dir.is_relative() {
            self.data_dir.join(&self.dir)
        } else {
            self.dir.clone()
        }
    }
```

**File:** config/src/config/storage_config.rs (L682-798)
```rust
impl ConfigSanitizer for StorageConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        _chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let config = &node_config.storage;

        let ledger_prune_window = config
            .storage_pruner_config
            .ledger_pruner_config
            .prune_window;
        let state_merkle_prune_window = config
            .storage_pruner_config
            .state_merkle_pruner_config
            .prune_window;
        let epoch_snapshot_prune_window = config
            .storage_pruner_config
            .epoch_snapshot_pruner_config
            .prune_window;
        let user_pruning_window_offset = config
            .storage_pruner_config
            .ledger_pruner_config
            .user_pruning_window_offset;

        if ledger_prune_window < 50_000_000 {
            warn!("Ledger prune_window is too small, harming network data availability.");
        }
        if state_merkle_prune_window < 100_000 {
            warn!("State Merkle prune_window is too small, node might stop functioning.");
        }
        if epoch_snapshot_prune_window < 50_000_000 {
            warn!("Epoch snapshot prune_window is too small, harming network data availability.");
        }
        if user_pruning_window_offset > 1_000_000 {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "user_pruning_window_offset too large, so big a buffer is unlikely necessary. Set something < 1 million.".to_string(),
            ));
        }
        if user_pruning_window_offset > ledger_prune_window {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "user_pruning_window_offset is larger than the ledger prune window, the API will refuse to return any data.".to_string(),
            ));
        }

        if let Some(db_path_overrides) = config.db_path_overrides.as_ref() {
            if !config.rocksdb_configs.enable_storage_sharding {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "db_path_overrides is allowed only if sharding is enabled.".to_string(),
                ));
            }

            if let Some(ledger_db_path) = db_path_overrides.ledger_db_path.as_ref() {
                if !ledger_db_path.is_absolute() {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        format!(
                            "Path {ledger_db_path:?} in db_path_overrides is not an absolute path."
                        ),
                    ));
                }
            }

            if let Some(state_kv_db_path) = db_path_overrides.state_kv_db_path.as_ref() {
                if let Some(metadata_path) = state_kv_db_path.metadata_path.as_ref() {
                    if !metadata_path.is_absolute() {
                        return Err(Error::ConfigSanitizerFailed(
                            sanitizer_name,
                            format!("Path {metadata_path:?} in db_path_overrides is not an absolute path."),
                        ));
                    }
                }

                if let Err(e) = state_kv_db_path.get_shard_paths() {
                    return Err(Error::ConfigSanitizerFailed(sanitizer_name, e.to_string()));
                }
            }

            if let Some(state_merkle_db_path) = db_path_overrides.state_merkle_db_path.as_ref() {
                if let Some(metadata_path) = state_merkle_db_path.metadata_path.as_ref() {
                    if !metadata_path.is_absolute() {
                        return Err(Error::ConfigSanitizerFailed(
                            sanitizer_name,
                            format!("Path {metadata_path:?} in db_path_overrides is not an absolute path."),
                        ));
                    }
                }

                if let Err(e) = state_merkle_db_path.get_shard_paths() {
                    return Err(Error::ConfigSanitizerFailed(sanitizer_name, e.to_string()));
                }
            }

            if let Some(hot_state_merkle_db_path) =
                db_path_overrides.hot_state_merkle_db_path.as_ref()
            {
                if let Some(metadata_path) = hot_state_merkle_db_path.metadata_path.as_ref() {
                    if !metadata_path.is_absolute() {
                        return Err(Error::ConfigSanitizerFailed(
                            sanitizer_name,
                            format!("Path {metadata_path:?} in db_path_overrides is not an absolute path."),
                        ));
                    }
                }

                if let Err(e) = hot_state_merkle_db_path.get_shard_paths() {
                    return Err(Error::ConfigSanitizerFailed(sanitizer_name, e.to_string()));
                }
            }
        }

        Ok(())
    }
```

**File:** storage/aptosdb/src/state_merkle_db.rs (L717-721)
```rust
        if delete_on_restart {
            ensure!(!readonly, "Should not reset DB in read-only mode.");
            info!("delete_on_restart is true. Removing {path:?} entirely.");
            std::fs::remove_dir_all(&path).unwrap_or(());
        }
```

**File:** storage/aptosdb/src/state_merkle_db.rs (L731-737)
```rust
            DB::open_cf(
                &gen_rocksdb_options(state_merkle_db_config, env, false),
                path,
                name,
                gen_state_merkle_cfds(state_merkle_db_config, block_cache),
            )?
        })
```
