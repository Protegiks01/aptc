# Audit Report

## Title
Validator Network Topology Exposure via Inspection Service Configuration Endpoint

## Summary
The inspection service's `/configuration` endpoint exposes the complete NodeConfig including VFN (Validator Full Node) seed peer configurations that contain validator IP addresses, peer IDs, and public keys. When accidentally exposed to the public internet due to firewall misconfiguration, this enables attackers to map the validator network topology and launch targeted DDoS attacks on consensus-critical nodes.

## Finding Description

The `handle_configuration_request()` function in the inspection service exposes the entire NodeConfig using Debug formatting when `expose_configuration` is enabled: [1](#0-0) 

While the comment mentions that SilentDisplay/SilentDebug prevents leaking private keys, this protection does **not** extend to network topology information. The NodeConfig contains network configuration that includes seed peer addresses: [2](#0-1) 

VFNs (Validator Full Nodes) are configured with a private "vfn" network that contains seed peer addresses pointing to their validator. These seeds contain the validator's IP address, peer ID, public key, and port: [3](#0-2) 

The NetworkAddress type's Debug implementation delegates to Display, which exposes the complete address including IP addresses: [4](#0-3) [5](#0-4) 

The critical issue is that the ConfigSanitizer only prevents **mainnet validators** from exposing configuration, but does not protect VFNs or testnet validators: [6](#0-5) 

Furthermore, the ConfigOptimizer **automatically enables** `expose_configuration` for all non-mainnet chains (testnet, devnet): [7](#0-6) 

The inspection service binds to `0.0.0.0` by default, making it accessible from all network interfaces if not properly firewalled: [8](#0-7) 

**Attack Path:**
1. Attacker identifies a VFN or testnet validator with firewall misconfiguration exposing port 9101
2. Attacker sends HTTP GET request to `http://<target-ip>:9101/configuration`
3. Response contains the full NodeConfig including VFN network seeds
4. Attacker extracts validator IP addresses from the seeds field
5. Attacker repeats this for multiple VFNs to map the entire validator network topology
6. Attacker launches targeted DDoS attacks on extracted validator IP addresses
7. Consensus is disrupted as validators become unreachable

## Impact Explanation

This is a **HIGH severity** vulnerability per Aptos bug bounty criteria because it enables "Significant protocol violations" through:

1. **Validator Network Topology Disclosure**: Exposes IP addresses, peer IDs, and public keys of consensus-critical validator nodes
2. **Enables Targeted DDoS**: Attackers can map the entire validator network and launch coordinated attacks on specific validators
3. **Consensus Disruption**: Successful DDoS on sufficient validators (>1/3) can halt consensus and network liveness
4. **Wide Attack Surface**: Affects all VFNs (mainnet and testnet) and all testnet validators globally

The vulnerability does not reach Critical severity because:
- It requires a firewall misconfiguration (though this is common)
- It's an information disclosure that enables attacks rather than directly breaking consensus
- Network-level DoS is explicitly out of scope per bug bounty rules, but the information disclosure itself is in scope

However, the **combination** of automatic enablement on testnet, default binding to 0.0.0.0, and the high value of the exposed information (validator IPs) makes this a significant security risk.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

Factors increasing likelihood:
- **Automatic enablement**: ConfigOptimizer auto-enables for all testnet/devnet nodes without explicit user action
- **Default binding**: Inspection service binds to 0.0.0.0 by default, not 127.0.0.1
- **Common misconfiguration**: Firewall misconfigurations exposing internal services are prevalent
- **No authentication**: The endpoint requires no authentication or special access
- **Large attack surface**: Every VFN and testnet validator is potentially vulnerable

Factors decreasing likelihood:
- Mainnet validators are protected by sanitizer (but mainnet VFNs are not)
- Requires firewall misconfiguration (though common)
- Operators should follow security best practices

## Recommendation

**Immediate Fix:**

1. **Extend ConfigSanitizer to protect all production nodes:**

```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Verify that mainnet nodes (validators AND VFNs) do not expose configuration
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() && inspection_service_config.expose_configuration {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet nodes should not expose the node configuration!".to_string(),
                ));
            }
        }

        Ok(())
    }
}
```

2. **Change default binding address to localhost:**

```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "127.0.0.1".to_string(), // Changed from "0.0.0.0"
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
}
```

3. **Implement network address redaction in Debug output:**

```rust
// In handle_configuration_request, redact sensitive network information
pub fn handle_configuration_request(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    let (status_code, body) = if node_config.inspection_service.expose_configuration {
        // Clone and redact sensitive network information
        let mut sanitized_config = node_config.clone();
        sanitize_network_seeds(&mut sanitized_config);
        
        let encoded_configuration = format!("{:?}", sanitized_config);
        (StatusCode::OK, Body::from(encoded_configuration))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(CONFIGURATION_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}

fn sanitize_network_seeds(config: &mut NodeConfig) {
    // Redact VFN network seeds
    for network in &mut config.full_node_networks {
        if network.network_id.is_vfn_network() {
            network.seeds.clear();
            network.seed_addrs.clear();
        }
    }
    
    // Redact validator network seeds if present
    if let Some(validator_network) = &mut config.validator_network {
        validator_network.seeds.clear();
        validator_network.seed_addrs.clear();
    }
}
```

4. **Add warning in documentation** that inspection service should only be accessible from trusted networks.

## Proof of Concept

**Setup (Testnet VFN):**

1. Deploy a testnet VFN with configuration containing validator seeds:
```yaml
full_node_networks:
    - network_id:
    private: "vfn"
  seeds:
    VALIDATOR_PEER_ID:
      addresses:
      - "/ip4/10.0.1.100/tcp/6181/noise-ik/VALIDATOR_PUBKEY/handshake/0"
      role: "Validator"
```

2. ConfigOptimizer automatically enables `expose_configuration` for testnet

3. Firewall misconfiguration exposes port 9101 to internet

**Exploit:**

```bash
# Attacker queries the configuration endpoint
curl http://vfn-node.example.com:9101/configuration

# Response contains (excerpt):
# NodeConfig {
#   ...
#   full_node_networks: [
#     NetworkConfig {
#       network_id: Private("vfn"),
#       seeds: {
#         VALIDATOR_PEER_ID: Peer {
#           addresses: [
#             "/ip4/10.0.1.100/tcp/6181/noise-ik/VALIDATOR_PUBKEY/handshake/0"
#           ],
#           role: Validator
#         }
#       }
#     }
#   ]
#   ...
# }

# Attacker now knows:
# - Validator IP: 10.0.1.100
# - Validator Port: 6181
# - Validator Peer ID: VALIDATOR_PEER_ID
# - Validator Public Key: VALIDATOR_PUBKEY

# Attacker can now:
# 1. Target validator with DDoS at 10.0.1.100:6181
# 2. Query other VFNs to map entire validator network
# 3. Coordinate attacks on multiple validators to disrupt consensus
```

**Rust Test Demonstrating Exposure:**

```rust
#[tokio::test]
async fn test_vfn_seed_exposure() {
    // Create a VFN config with validator seeds
    let mut vfn_config = NodeConfig::get_default_vfn_config();
    
    // Add VFN network with validator seed
    let validator_peer_id = PeerId::random();
    let validator_address = NetworkAddress::from_str(
        "/ip4/192.168.1.100/tcp/6181/noise-ik/0x1234.../handshake/0"
    ).unwrap();
    
    let vfn_network = &mut vfn_config.full_node_networks[1]; // VFN network
    vfn_network.seeds.insert(
        validator_peer_id,
        Peer {
            addresses: vec![validator_address.clone()],
            keys: HashSet::new(),
            role: PeerRole::Validator,
        }
    );
    
    // Enable configuration endpoint (auto-enabled on testnet)
    vfn_config.inspection_service.expose_configuration = true;
    
    // Call the handler
    let (status, body, _) = handle_configuration_request(&vfn_config);
    
    // Verify the response contains the validator IP
    assert_eq!(status, StatusCode::OK);
    let body_string = body_to_string(body).await;
    
    // VULNERABILITY: The validator's IP address is exposed
    assert!(body_string.contains("192.168.1.100"));
    assert!(body_string.contains("6181"));
    assert!(body_string.contains(&validator_peer_id.to_string()));
}
```

## Notes

This vulnerability specifically affects the confidentiality of validator network topology rather than breaking consensus directly. However, the information disclosure enables secondary attacks (DDoS) that can disrupt consensus. The issue is exacerbated by:

1. Automatic enablement on testnet creating a false sense of security
2. Default binding to all interfaces (0.0.0.0) rather than localhost
3. Lack of authentication on the endpoint
4. Insufficient sanitizer coverage (only mainnet validators, not VFNs)

The vulnerability aligns with the "Validator node slowdowns" and "Significant protocol violations" categories in the High severity tier of the Aptos bug bounty program.

### Citations

**File:** crates/aptos-inspection-service/src/server/configuration.rs (L13-29)
```rust
pub fn handle_configuration_request(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    // Only return configuration if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_configuration {
        // We format the configuration using debug formatting. This is important to
        // prevent secret/private keys from being serialized and leaked (i.e.,
        // all secret keys are marked with SilentDisplay and SilentDebug).
        let encoded_configuration = format!("{:?}", node_config);
        (StatusCode::OK, Body::from(encoded_configuration))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(CONFIGURATION_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}
```

**File:** config/src/config/node_config.rs (L37-92)
```rust
pub struct NodeConfig {
    #[serde(default)]
    pub admin_service: AdminServiceConfig,
    #[serde(default)]
    pub api: ApiConfig,
    #[serde(default)]
    pub base: BaseConfig,
    #[serde(default)]
    pub consensus: ConsensusConfig,
    #[serde(default)]
    pub consensus_observer: ConsensusObserverConfig,
    #[serde(default)]
    pub dag_consensus: DagConsensusConfig,
    #[serde(default)]
    pub dkg: DKGConfig,
    #[serde(default)]
    pub execution: ExecutionConfig,
    #[serde(default)]
    pub failpoints: Option<HashMap<String, String>>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub full_node_networks: Vec<NetworkConfig>,
    #[serde(default)]
    pub indexer: IndexerConfig,
    #[serde(default)]
    pub indexer_grpc: IndexerGrpcConfig,
    #[serde(default)]
    pub indexer_table_info: IndexerTableInfoConfig,
    #[serde(default)]
    pub inspection_service: InspectionServiceConfig,
    #[serde(default)]
    pub jwk_consensus: JWKConsensusConfig,
    #[serde(default)]
    pub logger: LoggerConfig,
    #[serde(default)]
    pub mempool: MempoolConfig,
    #[serde(default)]
    pub netbench: Option<NetbenchConfig>,
    #[serde(default)]
    pub node_startup: NodeStartupConfig,
    #[serde(default)]
    pub peer_monitoring_service: PeerMonitoringServiceConfig,
    /// In a randomness stall, set this to be on-chain `RandomnessConfigSeqNum` + 1.
    /// Once enough nodes restarted with the new value, the chain should unblock with randomness disabled.
    #[serde(default)]
    pub randomness_override_seq_num: u64,
    #[serde(default)]
    pub state_sync: StateSyncConfig,
    #[serde(default)]
    pub storage: StorageConfig,
    #[serde(default)]
    pub transaction_filters: TransactionFiltersConfig,
    #[serde(default)]
    pub validator_network: Option<NetworkConfig>,
    #[serde(default)]
    pub indexer_db_config: InternalIndexerDBConfig,
}
```

**File:** docker/compose/aptos-node/fullnode.yaml (L14-23)
```yaml
full_node_networks:
- network_id:
    private: "vfn"
  listen_address: "/ip4/0.0.0.0/tcp/6181"
  seeds:
    00000000000000000000000000000000d58bc7bb154b38039bc9096ce04e1237:
      addresses:
      - "/ip4/<Validator IP Address>/tcp/6181/noise-ik/f0274c2774519281a8332d0bb9d8101bd58bc7bb154b38039bc9096ce04e1237/handshake/0"
      role: "Validator"

```

**File:** types/src/network_address/mod.rs (L523-527)
```rust
impl fmt::Debug for NetworkAddress {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        fmt::Display::fmt(self, f)
    }
}
```

**File:** types/src/network_address/mod.rs (L598-619)
```rust
impl fmt::Display for Protocol {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        use self::Protocol::*;
        match self {
            Ip4(addr) => write!(f, "/ip4/{}", addr),
            Ip6(addr) => write!(f, "/ip6/{}", addr),
            Dns(domain) => write!(f, "/dns/{}", domain),
            Dns4(domain) => write!(f, "/dns4/{}", domain),
            Dns6(domain) => write!(f, "/dns6/{}", domain),
            Tcp(port) => write!(f, "/tcp/{}", port),
            Memory(port) => write!(f, "/memory/{}", port),
            NoiseIK(pubkey) => write!(
                f,
                "/noise-ik/{}",
                pubkey
                    .to_encoded_string()
                    .expect("ValidCryptoMaterialStringExt::to_encoded_string is infallible")
            ),
            Handshake(version) => write!(f, "/handshake/{}", version),
        }
    }
}
```

**File:** config/src/config/inspection_service_config.rs (L26-37)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
}
```

**File:** config/src/config/inspection_service_config.rs (L45-69)
```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Verify that mainnet validators do not expose the configuration
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
        }

        Ok(())
    }
}
```

**File:** config/src/config/inspection_service_config.rs (L71-109)
```rust
impl ConfigOptimizer for InspectionServiceConfig {
    fn optimize(
        node_config: &mut NodeConfig,
        local_config_yaml: &Value,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<bool, Error> {
        let inspection_service_config = &mut node_config.inspection_service;
        let local_inspection_config_yaml = &local_config_yaml["inspection_service"];

        // Enable all endpoints for non-mainnet nodes (to aid debugging)
        let mut modified_config = false;
        if let Some(chain_id) = chain_id {
            if !chain_id.is_mainnet() {
                if local_inspection_config_yaml["expose_configuration"].is_null() {
                    inspection_service_config.expose_configuration = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_identity_information"].is_null() {
                    inspection_service_config.expose_identity_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_peer_information"].is_null() {
                    inspection_service_config.expose_peer_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_system_information"].is_null() {
                    inspection_service_config.expose_system_information = true;
                    modified_config = true;
                }
            }
        }

        Ok(modified_config)
    }
}
```
