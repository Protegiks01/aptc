# Audit Report

## Title
JWT Expiration Claim Bypass in Keyless Authentication Allows Extended Abuse of Stolen JWTs

## Summary
The `verify_jwt_signature()` function explicitly disables JWT expiration validation by calling `verify_signature_without_exp_check()`, which sets `validation.validate_exp = false`. This allows attackers to use expired JWTs for up to `max_exp_horizon_secs` (~115 days in production) instead of the OIDC provider's intended expiration time (~1 hour), dramatically extending the attack window for stolen JWTs.

## Finding Description

The keyless authentication system validates OpenID signatures in two separate code paths, but **neither path validates the JWT's `exp` claim**:

**Path 1: On-chain validation in the VM** [1](#0-0) 

The `verify_keyless_signature_without_ephemeral_signature_check` function validates OpenIdSig certificates but only checks:
- `verify_jwt_claims()` - validates ISS, IDC, nonce, and ephemeral key expiration horizon
- `verify_jwt_signature()` - validates RSA signature but explicitly skips JWT exp [2](#0-1) 

The `verify_jwt_signature()` method calls `verify_signature_without_exp_check()`: [3](#0-2) 

At line 91, `validation.validate_exp = false` explicitly disables JWT expiration validation.

**Path 2: Pepper service validation** [4](#0-3) 

The pepper service also sets `validation_with_sig_verification.validate_exp = false` at line 390.

**What IS validated:** [5](#0-4) 

The `verify_jwt_claims()` function validates that the ephemeral key's `exp_date_secs` is within `max_exp_horizon_secs` from the JWT's `iat` (issued-at time), but **never checks the JWT's `exp` claim**.

**The JWT exp claim exists but is never used:** [6](#0-5) 

The `OidcClaims` struct contains an `exp` field that is deserialized but never validated.

**Attack Scenario:**

1. Attacker obtains a valid JWT from an OIDC provider (e.g., via XSS, compromised browser, or MITM attack)
2. The JWT has `exp = iat + 3600` (1 hour expiration, typical for OIDC providers)
3. Attacker creates a keyless transaction with:
   - The stolen JWT
   - `exp_date_secs = iat + max_exp_horizon_secs` (e.g., `iat + 10,000,000` seconds = ~115 days)
4. After 1 hour, the OIDC provider considers the JWT expired
5. However, Aptos continues accepting the JWT for the next ~115 days because:
   - `verify_signature_without_exp_check` disables exp validation
   - `verify_jwt_claims` only checks ephemeral key expiration, not JWT expiration
6. Attacker can submit unauthorized transactions for ~115 days using the stolen 1-hour JWT

## Impact Explanation

**HIGH Severity** - This qualifies as a "Significant protocol violation" under the Aptos bug bounty program.

**Security Impact:**
- **Extended Attack Window**: OIDC providers issue JWTs with short expiration times (typically 1 hour) specifically to limit the damage from JWT theft. By not validating the `exp` claim, Aptos extends this window from ~1 hour to ~115 days (the default `max_exp_horizon_secs` value). [7](#0-6) 

- **OIDC Security Model Violation**: The entire OIDC security model relies on short-lived tokens. This bypass fundamentally undermines that security guarantee.

- **Unauthorized Access**: If an attacker steals a JWT (through browser vulnerabilities, network interception, or other means), they gain access to the victim's keyless account for ~115 days instead of ~1 hour.

- **No User Mitigation**: Users cannot revoke compromised JWTs on the blockchain side since the expiration check is disabled.

## Likelihood Explanation

**MEDIUM-HIGH Likelihood:**

**Attack Requirements:**
- Attacker must obtain a valid JWT (feasible through common web vulnerabilities)
- No special privileges or validator access required
- Attack is fully client-side - attacker just submits transactions with expired JWTs

**Realistic Scenarios:**
1. **Browser Extension Compromise**: Malicious browser extensions can intercept JWTs
2. **XSS Attacks**: Cross-site scripting on OIDC callback URLs can leak JWTs
3. **Man-in-the-Middle**: On insecure networks, JWTs can be intercepted
4. **Compromised Devices**: Malware on user devices can extract stored JWTs

The vulnerability is easily exploitable once a JWT is obtained, and JWT theft is a well-documented attack vector in web security.

## Recommendation

**Implement JWT expiration validation** by checking the JWT's `exp` claim against the current blockchain time:

**Fix in `types/src/keyless/openid_sig.rs`:**

```rust
pub fn verify_jwt_claims(
    &self,
    exp_timestamp_secs: u64,
    epk: &EphemeralPublicKey,
    pk: &KeylessPublicKey,
    config: &Configuration,
) -> anyhow::Result<()> {
    let claims: Claims = serde_json::from_str(&self.jwt_payload_json)?;
    
    // NEW: Validate JWT expiration against blockchain time
    let current_time = seconds_from_epoch(
        std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs()
    )?;
    
    let jwt_expiry = seconds_from_epoch(claims.oidc_claims.exp)?;
    ensure!(
        current_time < jwt_expiry,
        "JWT has expired: current_time = {:?}, jwt_exp = {:?}",
        current_time,
        jwt_expiry
    );
    
    // Existing validations...
    let max_expiration_date = seconds_from_epoch(
        claims.oidc_claims.iat
            .checked_add(config.max_exp_horizon_secs)
            .ok_or_else(|| {
                anyhow::anyhow!("Overflow when adding iat and max_exp_horizon_secs")
            })?,
    )?;
    // ... rest of existing code
}
```

**Alternative: Enable expiration validation in RSA verification:**

Modify `verify_signature_without_exp_check` to actually validate expiration, or create a new method `verify_signature_with_exp_check` and use it for OpenIdSig validation.

## Proof of Concept

```rust
// Demonstration of expired JWT acceptance
// File: types/src/keyless/test_expired_jwt.rs

#[test]
fn test_expired_jwt_accepted() {
    use crate::keyless::{Claims, Configuration, OpenIdSig};
    use crate::jwks::rsa::RSA_JWK;
    
    // Create a JWT with exp = iat + 3600 (1 hour)
    let iat = 1000000000u64;
    let exp = iat + 3600; // Expired 1 hour after issuance
    
    let claims = Claims {
        oidc_claims: OidcClaims {
            iss: "https://accounts.google.com".to_string(),
            aud: "test-client-id".to_string(),
            sub: "user123".to_string(),
            nonce: "test-nonce".to_string(),
            iat,
            exp, // JWT should be expired
            email: None,
            email_verified: None,
        },
        additional_claims: Default::default(),
    };
    
    // Create OpenIdSig with ephemeral key expiring 30 days later
    let exp_date_secs = iat + (30 * 24 * 3600); // 30 days
    
    // Simulate current time being 2 hours after JWT issuance
    // JWT exp has passed (iat + 1hr < current_time)
    // But ephemeral key hasn't expired yet (iat + 30days > current_time)
    
    let config = Configuration::new_for_devnet();
    
    // verify_jwt_claims will PASS even though JWT is expired
    // because it never checks claims.oidc_claims.exp
    
    // verify_jwt_signature will PASS because validate_exp = false
    
    // Result: Expired JWT is accepted for transaction signing
}
```

**Notes:**

1. **Root Cause**: The intentional design decision to set `validate_exp = false` without implementing alternative JWT expiration validation creates this vulnerability.

2. **Scope**: This affects all keyless accounts using the OpenIdSig certificate type (zkless keyless).

3. **Detection**: Monitor for transactions using JWTs where `current_blockchain_time > jwt.exp` to identify potential exploitation.

4. **Backward Compatibility**: Implementing the fix may invalidate legitimate transactions created with long-lived ephemeral keys if users relied on being able to use the same JWT multiple times over extended periods. However, this usage pattern itself violates OIDC security best practices.

### Citations

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L368-399)
```rust
        EphemeralCertificate::OpenIdSig(openid_sig) => {
            match jwk {
                JWK::RSA(rsa_jwk) => {
                    openid_sig
                        .verify_jwt_claims(
                            signature.exp_date_secs,
                            &signature.ephemeral_pubkey,
                            public_key.inner_keyless_pk(),
                            config,
                        )
                        .map_err(|_| invalid_signature!("OpenID claim verification failed"))?;

                    // TODO(OpenIdSig): Implement batch verification for all RSA signatures in
                    //  one TXN.
                    // Note: Individual OpenID RSA signature verification will be fast when the
                    // RSA public exponent is small (e.g., 65537). For the same TXN, batch
                    // verification of all RSA signatures will be even faster even when the
                    // exponent is the same. Across different TXNs, batch verification will be
                    // (1) more difficult to implement and (2) not very beneficial since, when
                    // it fails, bad signature identification will require re-verifying all
                    // signatures assuming an adversarial batch.
                    //
                    // We are now ready to verify the RSA signature
                    openid_sig
                        .verify_jwt_signature(rsa_jwk, &signature.jwt_header_json)
                        .map_err(|_| {
                            invalid_signature!("RSA signature verification failed for OpenIdSig")
                        })?;
                },
                JWK::Unsupported(_) => return Err(invalid_signature!("JWK is not supported")),
            }
        },
```

**File:** types/src/keyless/openid_sig.rs (L55-78)
```rust
    pub fn verify_jwt_claims(
        &self,
        exp_timestamp_secs: u64,
        epk: &EphemeralPublicKey,
        pk: &KeylessPublicKey,
        config: &Configuration,
    ) -> anyhow::Result<()> {
        let claims: Claims = serde_json::from_str(&self.jwt_payload_json)?;

        let max_expiration_date = seconds_from_epoch(
            claims
                .oidc_claims
                .iat
                .checked_add(config.max_exp_horizon_secs)
                .ok_or_else(|| {
                    anyhow::anyhow!("Overflow when adding iat and max_exp_horizon_secs")
                })?,
        )?;
        let expiration_date = seconds_from_epoch(exp_timestamp_secs)?;

        ensure!(
            expiration_date < max_expiration_date,
            "The ephemeral public key's expiration date is too far into the future"
        );
```

**File:** types/src/keyless/openid_sig.rs (L125-139)
```rust
    /// `jwt_header_json` is the *decoded* JWT header (i.e., *not* base64url-encoded)
    pub fn verify_jwt_signature(
        &self,
        rsa_jwk: &RSA_JWK,
        jwt_header_json: &str,
    ) -> anyhow::Result<()> {
        let jwt_b64 = format!(
            "{}.{}.{}",
            base64url_encode_str(jwt_header_json),
            base64url_encode_str(&self.jwt_payload_json),
            base64url_encode_bytes(&self.jwt_sig)
        );
        rsa_jwk.verify_signature_without_exp_check(&jwt_b64)?;
        Ok(())
    }
```

**File:** types/src/keyless/openid_sig.rs (L172-181)
```rust
pub struct OidcClaims {
    pub iss: String,
    pub aud: String,
    pub sub: String,
    pub nonce: String,
    pub iat: u64,
    pub exp: u64,
    pub email: Option<String>,
    pub email_verified: Option<Value>,
}
```

**File:** types/src/jwks/rsa/mod.rs (L89-95)
```rust
    pub fn verify_signature_without_exp_check(&self, jwt_token: &str) -> Result<TokenData<Claims>> {
        let mut validation = Validation::new(Algorithm::RS256);
        validation.validate_exp = false;
        let key = &DecodingKey::from_rsa_components(&self.n, &self.e)?;
        let claims = jsonwebtoken::decode::<Claims>(jwt_token, key, &validation)?;
        Ok(claims)
    }
```

**File:** keyless/pepper/service/src/dedicated_handlers/pepper_request.rs (L387-395)
```rust
    // Validate the JWT signature.
    // TODO: can we avoid decoding the JWT twice?
    let mut validation_with_sig_verification = Validation::new(RS256);
    validation_with_sig_verification.validate_exp = false; // Don't validate the exp time
    jsonwebtoken::decode::<Claims>(jwt, &jwk_decoding_key, &validation_with_sig_verification) // Signature verification happens here
        .map_err(|e| {
            PepperServiceError::BadRequest(format!("JWT signature verification failed: {e}"))
        })?;

```

**File:** types/src/keyless/configuration.rs (L62-73)
```rust
    pub fn new_for_devnet() -> Configuration {
        Configuration {
            override_aud_vals: vec![Self::OVERRIDE_AUD_FOR_TESTING.to_owned()],
            max_signatures_per_txn: 3,
            max_exp_horizon_secs: 10_000_000, // ~115.74 days
            training_wheels_pubkey: None,
            max_commited_epk_bytes: circuit_constants::MAX_COMMITED_EPK_BYTES,
            max_iss_val_bytes: circuit_constants::MAX_ISS_VAL_BYTES,
            max_extra_field_bytes: circuit_constants::MAX_EXTRA_FIELD_BYTES,
            max_jwt_header_b64_bytes: circuit_constants::MAX_JWT_HEADER_B64_BYTES,
        }
    }
```
