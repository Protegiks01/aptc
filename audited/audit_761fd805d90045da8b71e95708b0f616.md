# Audit Report

## Title
Lack of Ledger Device Authenticity Validation in CLI Initialization

## Summary
The `aptos_ledger::get_public_key()` function does not validate the authenticity of connected Ledger hardware wallet devices, allowing a malicious USB device to return attacker-controlled public keys during account initialization.

## Finding Description

The Aptos CLI's Ledger integration in `crates/aptos-ledger/src/lib.rs` and `crates/aptos/src/common/init.rs` lacks device attestation or certificate validation. The `open_ledger_transport()` function simply connects to the first USB HID device matching Ledger's vendor/product identifiers without verifying device authenticity. [1](#0-0) 

During initialization, `get_public_key()` is called with `display: false`, meaning the public key is not shown on the device screen for user verification: [2](#0-1) 

The retrieved public key is immediately trusted and used to derive the account address: [3](#0-2) 

**Attack Path:**
1. Attacker creates a malicious USB device that spoofs Ledger's USB identifiers
2. Device implements APDU protocol and responds with attacker-controlled Ed25519 public keys
3. User connects fake device and runs `aptos init --ledger`
4. CLI accepts the malicious public key without verification
5. User funds the derived account address
6. Attacker controls the private key and can sign transactions to steal funds

## Impact Explanation

This qualifies as **Medium severity** per the Aptos bug bounty criteria: "Limited funds loss or manipulation." Individual users who connect compromised devices would lose funds sent to the derived addresses. However, this does not affect:
- Blockchain consensus or validator operations
- On-chain state or smart contract execution  
- Network-wide security or other users
- Any of the 10 critical blockchain invariants

This is a client-side security issue, not a protocol-level vulnerability.

## Likelihood Explanation

**Likelihood: Low to Medium**

Requires:
- Physical access to replace user's Ledger device (supply chain attack or evil maid attack)
- Technical capability to create USB device spoofing Ledger identifiers
- User must initialize new profile with compromised device

However, supply chain attacks on hardware wallets are documented security concerns in the industry.

## Recommendation

Implement device attestation validation:

1. **Enable on-device confirmation during initialization:**
```rust
// In crates/aptos/src/common/init.rs, line 246
let public_key = aptos_ledger::get_public_key(
    derivation_path.as_str(),
    true,  // Set display to true for user verification
)
```

2. **Add Ledger device attestation (if supported by Ledger SDK):**
    - Verify device certificate chain against Ledger's root CA
    - Validate secure element attestation signatures
    - Implement challenge-response authentication

3. **Display security warnings:**
    - Warn users about fake device risks during initialization
    - Instruct users to verify public key on device screen
    - Recommend checking device authenticity indicators

## Proof of Concept

**Note:** A complete PoC requires hardware implementation and cannot be demonstrated as a Move test, as it involves USB device emulation at the operating system level.

**Conceptual PoC (Hardware Required):**

```rust
// Malicious USB device firmware pseudocode
// Responds to APDU commands with attacker-controlled keys

fn handle_apdu_get_public_key(derivation_path: &[u8]) -> Response {
    // Generate attacker-controlled keypair
    let attacker_private_key = load_attacker_key();
    let attacker_public_key = attacker_private_key.public_key();
    
    // Return as if from legitimate Ledger
    Response {
        status: 0x9000,  // SUCCESS
        data: encode_public_key(attacker_public_key)
    }
}
```

**Validation Checklist Assessment:**
- ✗ Cannot be demonstrated as Move test or pure Rust PoC (requires hardware)
- ✗ Does not break documented blockchain invariants (client-side issue only)
- ✗ Not exploitable without physical device access
- ✗ Outside core focus areas (consensus, execution, storage, governance, staking)

## Notes

While this represents a legitimate security concern for individual CLI users, it does not meet the strict criteria for blockchain protocol vulnerabilities as defined in the audit scope. This is a **client-side hardware security issue** rather than a consensus, execution, or state management vulnerability.

The issue is similar to excluded categories like "key theft" and does not affect blockchain operations, validator nodes, or network-wide security. Standard hardware wallet security relies on users maintaining physical control of their devices.

For inclusion in the bug bounty program, this would need evaluation under client application security criteria rather than core blockchain protocol security.

### Citations

**File:** crates/aptos-ledger/src/lib.rs (L510-525)
```rust
fn open_ledger_transport() -> Result<TransportNativeHID, AptosLedgerError> {
    // open connection to ledger
    // NOTE: ledger has to be unlocked
    let hidapi = match HidApi::new() {
        Ok(hidapi) => hidapi,
        Err(_err) => return Err(AptosLedgerError::DeviceNotFound),
    };

    // Open transport to the first device
    let transport = match TransportNativeHID::new(&hidapi) {
        Ok(transport) => transport,
        Err(_err) => return Err(AptosLedgerError::DeviceNotFound),
    };

    Ok(transport)
}
```

**File:** crates/aptos/src/common/init.rs (L245-264)
```rust
        let public_key = if self.is_hardware_wallet() {
            match aptos_ledger::get_public_key(
                derivation_path
                    .ok_or_else(|| {
                        CliError::UnexpectedError("Invalid derivation path".to_string())
                    })?
                    .as_str(),
                false,
            ) {
                Ok(pub_key_str) => pub_key_str,
                Err(err) => {
                    return Err(CliError::UnexpectedError(format!(
                        "Unexpected Ledger Error: {:?}",
                        err.to_string()
                    )))
                },
            }
        } else {
            private_key.clone().unwrap().public_key()
        };
```

**File:** crates/aptos/src/common/init.rs (L277-282)
```rust
        let derived_address = account_address_from_public_key(&public_key);
        let address = lookup_address(&client, derived_address, false).await?;

        profile_config.private_key = private_key;
        profile_config.public_key = Some(public_key);
        profile_config.account = Some(address);
```
