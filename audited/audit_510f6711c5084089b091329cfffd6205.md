# Audit Report

## Title
Zero Gas Amount Transactions Bypass Validation Under Malicious Governance-Configured Gas Parameters

## Summary
A governance-level configuration vulnerability allows the `min_transaction_gas_units` parameter to be set to zero without validation, enabling attackers to submit zero-fee transactions that consume validator resources while bypassing fee payments, constituting a critical denial-of-service vector.

## Finding Description

The Aptos blockchain's gas validation system relies on the `min_transaction_gas_units` parameter to establish the minimum gas required for any transaction. This parameter is configurable through on-chain governance but lacks validation during updates. [1](#0-0) [2](#0-1) 

The validation logic contains TODO comments indicating missing consistency checks, allowing arbitrary gas parameter values including zero: [3](#0-2) 

When `max_gas_amount` is set to 0 in a transaction, the gas validation in `check_gas` compares it against the calculated intrinsic gas: [4](#0-3) 

The intrinsic gas calculation depends on `min_transaction_gas_units`: [5](#0-4) 

**Attack Path:**

1. If governance sets `min_transaction_gas_units = 0` (either through compromise or misconfiguration)
2. Attacker submits transactions with `max_gas_amount = 0` and size ≤ 600 bytes
3. Transaction passes `check_gas` validation (intrinsic gas = 0, so 0 ≥ 0)
4. Gas meter initializes with balance = 0
5. Prologue execution begins and immediately fails with OUT_OF_GAS
6. Transaction status is determined as KEEP (not DISCARD): [6](#0-5) 

7. Transaction epilogue calculates gas_used = max_gas_amount - remaining_balance = 0 - 0 = 0
8. Transaction fee = 0 × gas_unit_price = 0
9. Transaction is committed on-chain with zero fees paid
10. Sequence number increments, consuming blockchain state [7](#0-6) 

## Impact Explanation

**Severity: Critical** (conditional on governance compromise/misconfiguration)

If exploited, this enables:

1. **Network-wide Denial of Service**: Attackers can flood the network with zero-cost transactions that consume validator CPU/memory during prologue execution
2. **Resource Exhaustion**: Each transaction executes until OUT_OF_GAS in prologue, consuming computational resources without payment
3. **State Bloat**: Transactions are KEPT on-chain (incrementing sequence numbers), permanently increasing blockchain state
4. **Economic Attack**: Complete bypass of the fee mechanism, violating the economic security model
5. **Validator Degradation**: Sustained attacks could exhaust validator resources, impacting liveness

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits" and the **Transaction Validation** invariant: "Prologue/epilogue checks must enforce all invariants."

## Likelihood Explanation

**Likelihood: LOW** (but impact is CRITICAL)

This vulnerability requires:
1. Governance compromise OR accidental misconfiguration during gas parameter updates
2. Setting `min_transaction_gas_units = 0`

While governance is trusted per the security model, the lack of validation creates a single point of failure. Historical precedents in blockchain governance show that:
- Parameter misconfiguration during upgrades has occurred
- Governance proposals with bugs have been passed
- The lack of programmatic bounds checking is a critical defense-in-depth failure

## Recommendation

Implement mandatory validation of gas parameters during governance updates:

```move
// In gas_schedule.move, add validation function
fun validate_gas_schedule(gas_schedule: &GasScheduleV2) {
    // Extract and validate min_transaction_gas_units
    let min_txn_gas = extract_param(gas_schedule, b"txn.min_transaction_gas_units");
    assert!(min_txn_gas >= MIN_SAFE_TRANSACTION_GAS, EINVALID_GAS_SCHEDULE);
    
    // Add other critical parameter validations
    // ...
}

// Call validation in set_for_next_epoch
public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    // ADD THIS VALIDATION
    validate_gas_schedule(&new_gas_schedule);
    
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    config_buffer::upsert(new_gas_schedule);
}
```

Additionally, add runtime checks in `check_gas`:

```rust
// In gas.rs, add explicit check for zero intrinsic gas
let total_rounded: Gas = (intrinsic_gas + keyless + slh_dsa_sha2_128s)
    .to_unit_round_up_with_params(txn_gas_params);

// ADD THIS CHECK
if total_rounded == Gas::zero() {
    speculative_warn!(
        log_context,
        "[VM] Zero intrinsic gas detected - possible gas parameter misconfiguration"
    );
    return Err(VMStatus::error(
        StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
        Some("Intrinsic gas cannot be zero".to_string()),
    ));
}

if txn_metadata.max_gas_amount() < total_rounded {
    // existing check...
}
```

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[test]
fn test_zero_gas_bypass_with_malicious_params() {
    // Setup: Modify gas params to have min_transaction_gas_units = 0
    let mut gas_params = AptosGasParameters::zeros();
    gas_params.vm.txn.min_transaction_gas_units = InternalGas::zero();
    
    // Create transaction with max_gas_amount = 0
    let txn = TransactionBuilder::new()
        .sender(account_address)
        .sequence_number(0)
        .payload(/* small payload < 600 bytes */)
        .max_gas_amount(0)  // Zero gas!
        .gas_unit_price(100)
        .build();
    
    // Execute transaction
    let output = vm.execute_user_transaction(&txn, &state_view);
    
    // Verify vulnerability:
    // 1. Transaction passes check_gas
    // 2. Fails during prologue with OUT_OF_GAS
    // 3. Status is Keep(OutOfGas), not Discard
    // 4. gas_used = 0, fee = 0
    assert_eq!(output.status(), TransactionStatus::Keep(ExecutionStatus::OutOfGas));
    assert_eq!(output.gas_used(), 0);
    assert_eq!(output.fee_statement().total_fee(), 0);
}
```

**Notes**: 
- This vulnerability is conditional on governance compromise or misconfiguration setting `min_transaction_gas_units = 0`
- Under normal mainnet parameters (`min_transaction_gas_units = 2,760,000`), the system correctly rejects `max_gas_amount = 0` transactions
- The core issue is the lack of validation in the gas schedule update mechanism, representing a defense-in-depth failure
- While governance is trusted, the absence of programmatic bounds checking creates systemic risk

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L43-50)
```text
    public(friend) fun initialize(aptos_framework: &signer, gas_schedule_blob: vector<u8>) {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));

        // TODO(Gas): check if gas schedule is consistent
        let gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        move_to<GasScheduleV2>(aptos_framework, gas_schedule);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/aptos-vm/src/gas.rs (L154-172)
```rust
    let intrinsic_gas = txn_gas_params
        .calculate_intrinsic_gas(raw_bytes_len)
        .evaluate(gas_feature_version, &gas_params.vm);
    let total_rounded: Gas =
        (intrinsic_gas + keyless + slh_dsa_sha2_128s).to_unit_round_up_with_params(txn_gas_params);
    if txn_metadata.max_gas_amount() < total_rounded {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; min {}, submitted {}",
                total_rounded,
                txn_metadata.max_gas_amount()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::MAX_GAS_UNITS_BELOW_MIN_TRANSACTION_GAS_UNITS,
            None,
        ));
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L301-310)
```rust
    pub fn calculate_intrinsic_gas(
        &self,
        transaction_size: NumBytes,
    ) -> impl GasExpression<VMGasParameters, Unit = InternalGasUnit> + use<> {
        let excess = transaction_size
            .checked_sub(self.large_transaction_cutoff)
            .unwrap_or_else(|| 0.into());

        MIN_TRANSACTION_GAS_UNITS + INTRINSIC_GAS_PER_BYTE * excess
    }
```

**File:** third_party/move/move-core/types/src/vm_status.rs (L224-231)
```rust
            VMStatus::ExecutionFailure {
                status_code: StatusCode::OUT_OF_GAS,
                ..
            }
            | VMStatus::Error {
                status_code: StatusCode::OUT_OF_GAS,
                ..
            } => Ok(KeptVMStatus::OutOfGas),
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L596-631)
```rust
        let txn_status = TransactionStatus::from_vm_status(
            error_vm_status.clone(),
            self.features(),
            self.gas_feature_version() >= RELEASE_V1_38,
        );

        match txn_status {
            TransactionStatus::Keep(status) => {
                // The transaction should be kept. Run the appropriate post transaction workflows
                // including epilogue. This runs a new session that ignores any side effects that
                // might abort the execution (e.g., spending additional funds needed to pay for
                // gas). Even if the previous failure occurred while running the epilogue, it
                // should not fail now. If it somehow fails here, there is no choice but to
                // discard the transaction.
                let output = self
                    .finish_aborted_transaction(
                        prologue_session_change_set,
                        gas_meter,
                        txn_data,
                        resolver,
                        module_storage,
                        serialized_signers,
                        status,
                        log_context,
                        change_set_configs,
                        traversal_context,
                    )
                    .unwrap_or_else(|status| discarded_output(status.status_code()));
                (error_vm_status, output)
            },
            TransactionStatus::Discard(status_code) => {
                let discarded_output = discarded_output(status_code);
                (error_vm_status, discarded_output)
            },
            TransactionStatus::Retry => unreachable!(),
        }
```
