# Audit Report

## Title
Bypasser Ordering Allows Privilege Escalation to Higher Funding Amounts via Weaker Authentication

## Summary
The Aptos faucet's bypasser system processes bypassers in configuration order with early-return logic, allowing attackers to exploit weaker bypassers (e.g., broad IP allowlist) to obtain privileged funding amounts (`maximum_amount_with_bypass`) intended only for stronger authentication mechanisms (e.g., specific auth tokens). This violates access control invariants and enables unauthorized fund access.

## Finding Description

The faucet implements bypassers to allow certain requests to skip rate limiting and validation checks. When multiple bypassers are configured, they are checked sequentially in configuration order, and the **first** bypasser that returns true grants full bypass privileges, including access to `maximum_amount_with_bypass`. [1](#0-0) 

The bypassers are built from configuration in the order specified, with no sorting or prioritization mechanism: [2](#0-1) 

When any bypasser returns true, the request receives `did_bypass_checkers=true`, which grants access to the higher `maximum_amount_with_bypass` value instead of the standard `maximum_amount`: [3](#0-2) 

The funding amount calculation uses this bypass flag to determine which maximum to apply: [4](#0-3) 

**Attack Scenario:**
An administrator configures:
- Bypasser 1: `IpAllowlist` with range `10.0.0.0/8` (intended for internal testing)
- Bypasser 2: `AuthToken` with specific tokens (intended for CI/CD systems requiring high limits)
- `maximum_amount = 100 OCTA` (standard users)
- `maximum_amount_with_bypass = 10,000 OCTA` (intended only for CI/CD)

An attacker from IP `10.0.0.50` can:
1. Send request without auth token
2. Match Bypasser 1 (IP allowlist) first
3. Receive `bypass=true` status
4. Obtain 10,000 OCTA instead of 100 OCTA
5. Bypasser 2 (auth token) is never evaluated

This violates the administrator's intent that only authenticated CI/CD systems receive higher limits.

## Impact Explanation

**Medium Severity** - This vulnerability enables **limited funds loss or manipulation**:

1. **Unauthorized Fund Access**: Attackers satisfying weaker bypasser criteria obtain funding amounts intended for stronger authentication
2. **Resource Exhaustion**: Faster depletion of faucet funds through repeated high-value requests
3. **Access Control Violation**: The system fails to enforce intended privilege separation between different bypasser types

The impact is limited to the faucet service and doesn't affect blockchain consensus, validator operations, or core protocol security. However, it represents a clear violation of access control invariants and can lead to measurable financial impact through unauthorized fund distribution.

## Likelihood Explanation

**High Likelihood** when specific conditions are met:

**Required Conditions:**
1. Administrator configures multiple bypassers (common in production deployments)
2. Weaker bypasser (e.g., IP allowlist) listed before stronger one (e.g., auth tokens)
3. `maximum_amount_with_bypass` configured higher than `maximum_amount` (documented feature)
4. Attacker can satisfy weaker bypasser criteria

**Likelihood Factors:**
- No documentation warns about bypasser ordering implications
- No code-level safeguards prevent this configuration
- Natural configuration tendency: admins often list "simpler" bypassers first
- IP allowlists are commonly used for internal testing environments

The vulnerability requires misconfiguration but arises from a design flaw rather than implementation error, making it likely to occur in real deployments.

## Recommendation

Implement a priority-based bypasser system with explicit privilege levels:

**Solution 1: Add Bypasser Priority Levels**
```rust
pub struct BypasserWithPriority {
    bypasser: Bypasser,
    max_amount_override: Option<u64>,
    priority: u8, // Higher number = higher priority
}
```

**Solution 2: Document Ordering Requirements**
Add explicit warnings in configuration documentation and code comments:
```rust
/// WARNING: Bypassers are evaluated in order. The FIRST bypasser that matches
/// will grant ALL bypass privileges including maximum_amount_with_bypass.
/// Configure stronger authentication bypassers (e.g., AuthToken) BEFORE
/// weaker ones (e.g., broad IP allowlists) to prevent privilege escalation.
pub bypassers: Vec<Bypasser>,
```

**Solution 3: Separate Bypass Privileges**
Allow each bypasser to specify its own funding limits:
```rust
pub struct BypasserConfig {
    bypasser_type: BypasserType,
    max_funding_amount: Option<u64>, // Specific limit for this bypasser
}
```

**Recommended Fix:** Implement Solution 1 + Solution 2 to provide both technical safeguards and clear documentation.

## Proof of Concept

```rust
// Integration test demonstrating the vulnerability
#[tokio::test]
async fn test_bypasser_ordering_privilege_escalation() -> Result<()> {
    // Setup: Configure IP allowlist BEFORE auth token
    let config = r#"
server_config:
  listen_address: "0.0.0.0"
  listen_port: 0
  api_path_base: ""

bypasser_configs:
  # Weaker bypasser listed first
  - type: IpAllowlist
    list:
      - "127.0.0.0/8"
  # Stronger bypasser listed second
  - type: AuthToken
    file_path: "/tmp/auth_tokens.txt"

checker_configs: []

funder_config:
  type: MintFunder
  node_url: "http://127.0.0.1:8080"
  chain_id: 4
  maximum_amount: 100            # Standard limit
  maximum_amount_with_bypass: 10000  # Privileged limit
  # ... other config
"#;

    make_auth_tokens_file(&["privileged_ci_token"])?;
    let (port, _handle) = start_server(config).await?;
    
    // Attack: Request from allowed IP WITHOUT auth token
    let fund_request = FundRequest {
        amount: Some(10000),
        address: Some(AccountAddress::random().to_string()),
        ..Default::default()
    };
    
    let response = reqwest::Client::new()
        .post(format!("http://127.0.0.1:{}/fund", port))
        .json(&fund_request)
        .send()
        .await?;
    
    // Vulnerability: Attacker receives 10000 OCTA without auth token
    // Expected: Should receive only 100 OCTA (maximum_amount)
    // Actual: Receives 10000 OCTA (maximum_amount_with_bypass)
    assert!(response.status().is_success());
    let result: FundResponse = response.json().await?;
    assert!(!result.txn_hashes.is_empty());
    
    // Verify the account received the privileged amount
    let balance = check_account_balance(fund_request.receiver().unwrap()).await?;
    assert_eq!(balance, 10000); // Got privileged amount without proper auth!
    
    Ok(())
}
```

**Notes:**

While the faucet is not a consensus-critical component, this vulnerability represents a clear security flaw in access control logic. The early-return pattern without priority ordering creates an exploitable condition where weaker authentication mechanisms can grant stronger privileges. Production deployments using multiple bypassers with different intended purposes are susceptible to unauthorized fund access and accelerated resource depletion.

### Citations

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L245-259)
```rust
        for bypasser in &self.bypassers {
            if bypasser
                .request_can_bypass(checker_data.clone())
                .await
                .map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::BypasserError)
                })?
            {
                info!(
                    "Allowing request from {} to bypass checks / storage",
                    source_ip
                );
                return Ok((checker_data, true, permit));
            }
        }
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L114-121)
```rust
        // Build Bypassers.
        let mut bypassers: Vec<Bypasser> = Vec::new();
        for bypasser_config in &self.bypasser_configs {
            let bypasser = bypasser_config.clone().build().with_context(|| {
                format!("Failed to build Bypasser with args: {:?}", bypasser_config)
            })?;
            bypassers.push(bypasser);
        }
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L176-185)
```rust
    pub fn get_maximum_amount(
        &self,
        // True if a Bypasser let the request bypass the Checkers.
        did_bypass_checkers: bool,
    ) -> Option<u64> {
        match (self.maximum_amount_with_bypass, did_bypass_checkers) {
            (Some(max), true) => Some(max),
            _ => self.maximum_amount,
        }
    }
```

**File:** crates/aptos-faucet/core/src/funder/mint.rs (L540-550)
```rust
    fn get_amount(&self, amount: Option<u64>, did_bypass_checkers: bool) -> u64 {
        match (
            amount,
            self.txn_config.get_maximum_amount(did_bypass_checkers),
        ) {
            (Some(amount), Some(maximum_amount)) => std::cmp::min(amount, maximum_amount),
            (Some(amount), None) => amount,
            (None, Some(maximum_amount)) => std::cmp::min(self.amount_to_fund, maximum_amount),
            (None, None) => self.amount_to_fund,
        }
    }
```
