# Audit Report

## Title
Consensus Persisting Phase Fails to Validate Commit Success, Causing State Inconsistency and Potential Liveness Failure

## Summary
The `PersistingPhase::process()` function unconditionally returns success even when block commits fail, causing the buffer manager to incorrectly update `highest_committed_round` and creating a dangerous state divergence between consensus layer tracking and actual storage state that can lead to validator liveness failure.

## Finding Description

The persisting phase processes batches of ordered blocks and is responsible for waiting for their commit operations to complete. However, it contains a critical flaw in error handling. [1](#0-0) 

The `wait_for_commit_ledger()` method ignores commit results: [2](#0-1) 

The commit_ledger pipeline stage can fail and return errors: [3](#0-2) 

Despite having dependency chains that propagate errors through `parent_block_commit_fut.await?`, the persisting phase never checks whether these commits actually succeeded. It unconditionally returns `Ok(last_block.round())` regardless of commit outcomes.

**Exploitation Path:**

1. Buffer manager sends batch of blocks [A, B, C] at rounds [10, 11, 12] to persisting phase
2. Block A commits successfully to storage (version 110)
3. Block B's commit fails (database error, disk full, corruption, etc.) at the executor level
4. Due to pipeline dependencies, Block C's commit also fails when awaiting parent
5. Persisting phase still returns `Ok(12)` - claiming success
6. Buffer manager updates `highest_committed_round = 12` [4](#0-3) 

7. Buffer manager cleans up `pending_commit_blocks` for rounds ≤ 12, removing tracking of failed blocks
8. System state is now inconsistent:
   - Storage layer: committed up to version 110 (round 10)
   - Consensus layer: believes committed up to round 12

The storage layer validates versions correctly: [5](#0-4) 

But the consensus layer's incorrect state prevents recovery. When subsequent blocks arrive, they depend on rounds 11-12 which failed to commit, creating a cascade of failures that halts consensus progress.

## Impact Explanation

**Severity: High** (potentially Critical if affecting multiple validators simultaneously)

This violates the **State Consistency** invariant: "State transitions must be atomic and verifiable via Merkle proofs." The consensus layer believes blocks are committed when they are not, breaking the fundamental assumption that committed rounds are durably persisted.

**Impact:**
- **Liveness Failure**: The affected validator cannot make progress. All subsequent commit attempts will fail due to missing parent blocks in storage, but the buffer manager believes those parents are committed and won't retry.
- **State Divergence**: Consensus metadata becomes inconsistent with storage reality, requiring node restart to recover.
- **Network Instability**: If multiple validators experience concurrent commit failures (e.g., during high I/O load, disk issues), the network could lose liveness until manual intervention.

The fail point injection capability confirms this is a realistic failure mode: [6](#0-5) 

## Likelihood Explanation

**Likelihood: Medium to High**

While this requires commit failures (database errors, disk full, I/O failures, corruption), these are realistic operational scenarios:
- High transaction throughput causing disk I/O saturation
- Storage resource exhaustion
- Database corruption from power failures
- Concurrent write conflicts in edge cases

The bug manifests automatically once a commit failure occurs—no attacker action is needed. Given the scale of Aptos validator operations, commit failures will eventually occur.

**Mitigation Factor**: The issue self-corrects on node restart as the buffer manager re-initializes from storage state. However, this requires manual intervention and causes service disruption.

## Recommendation

The persisting phase must check commit results and propagate errors:

```rust
async fn process(&self, req: PersistingRequest) -> PersistingResponse {
    let PersistingRequest {
        blocks,
        commit_ledger_info,
    } = req;

    for b in &blocks {
        if let Some(tx) = b.pipeline_tx().lock().as_mut() {
            tx.commit_proof_tx
                .take()
                .map(|tx| tx.send(commit_ledger_info.clone()));
        }
        // Check the result instead of ignoring it
        if let Some(fut) = b.pipeline_futs() {
            match fut.commit_ledger_fut.await {
                Ok(Ok(_)) => {}, // Success
                Ok(Err(e)) => {
                    error!("Block {} commit failed: {:?}", b.id(), e);
                    return Err(ExecutorError::InternalError {
                        error: format!("Commit failed for block {}: {:?}", b.id(), e)
                    });
                },
                Err(e) => {
                    error!("Block {} commit task error: {:?}", b.id(), e);
                    return Err(ExecutorError::InternalError {
                        error: format!("Commit task error for block {}: {:?}", b.id(), e)
                    });
                }
            }
        }
    }

    let response = Ok(blocks.last().expect("Blocks can't be empty").round());
    if commit_ledger_info.ledger_info().ends_epoch() {
        self.commit_msg_tx
            .send_epoch_change(EpochChangeProof::new(vec![commit_ledger_info], false))
            .await;
    }
    response
}
```

Additionally, modify `wait_for_commit_ledger()` to return the result:

```rust
pub async fn wait_for_commit_ledger(&self) -> Option<TaskResult<CommitLedgerResult>> {
    if let Some(fut) = self.pipeline_futs() {
        Some(fut.commit_ledger_fut.await)
    } else {
        None
    }
}
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_persisting_phase_commit_failure() {
    // Setup: Create blocks A, B, C with pipeline futures
    // Inject fail_point at executor::commit_blocks for block B
    fail::cfg("executor::commit_blocks", "return").unwrap();
    
    // Send PersistingRequest with blocks [A, B, C]
    let response = persisting_phase.process(request).await;
    
    // Bug: Response is Ok(C.round()) even though B and C failed
    assert!(response.is_ok());
    let returned_round = response.unwrap();
    assert_eq!(returned_round, block_c.round());
    
    // Verify actual storage state
    let committed_version = db.get_latest_ledger_info().version();
    assert!(committed_version < block_b_version); // Only A committed
    
    // State inconsistency: consensus thinks C committed, storage only has A
    // This causes liveness failure for subsequent blocks
}
```

**Notes:**

This vulnerability demonstrates a **version monotonicity guarantee violation** at the consensus-storage interface layer, not in storage itself. While the pipeline dependencies prevent true out-of-order persistence, the lack of error propagation creates phantom committed rounds that break consistency assumptions throughout the consensus stack.

### Citations

**File:** consensus/src/pipeline/persisting_phase.rs (L65-74)
```rust
        for b in &blocks {
            if let Some(tx) = b.pipeline_tx().lock().as_mut() {
                tx.commit_proof_tx
                    .take()
                    .map(|tx| tx.send(commit_ledger_info.clone()));
            }
            b.wait_for_commit_ledger().await;
        }

        let response = Ok(blocks.last().expect("Blocks can't be empty").round());
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L562-568)
```rust
    pub async fn wait_for_commit_ledger(&self) {
        // may be aborted (e.g. by reset)
        if let Some(fut) = self.pipeline_futs() {
            // this may be cancelled
            let _ = fut.commit_ledger_fut.await;
        }
    }
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L1085-1105)
```rust
    ) -> TaskResult<CommitLedgerResult> {
        let mut tracker = Tracker::start_waiting("commit_ledger", &block);
        parent_block_commit_fut.await?;
        pre_commit_fut.await?;
        let ledger_info_with_sigs = commit_proof_fut.await?;

        // it's committed as prefix
        if ledger_info_with_sigs.commit_info().id() != block.id() {
            return Ok(None);
        }

        tracker.start_working();
        let ledger_info_with_sigs_clone = ledger_info_with_sigs.clone();
        tokio::task::spawn_blocking(move || {
            executor
                .commit_ledger(ledger_info_with_sigs_clone)
                .map_err(anyhow::Error::from)
        })
        .await
        .expect("spawn blocking failed")?;
        Ok(Some(ledger_info_with_sigs))
```

**File:** consensus/src/pipeline/buffer_manager.rs (L968-973)
```rust
                Some(Ok(round)) = self.persisting_phase_rx.next() => {
                    // see where `need_backpressure()` is called.
                    self.pending_commit_votes = self.pending_commit_votes.split_off(&(round + 1));
                    self.highest_committed_round = round;
                    self.pending_commit_blocks = self.pending_commit_blocks.split_off(&(round + 1));
                },
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L522-537)
```rust
    fn get_and_check_commit_range(&self, version_to_commit: Version) -> Result<Option<Version>> {
        let old_committed_ver = self.ledger_db.metadata_db().get_synced_version()?;
        let pre_committed_ver = self.state_store.current_state_locked().version();
        ensure!(
            old_committed_ver.is_none() || version_to_commit >= old_committed_ver.unwrap(),
            "Version too old to commit. Committed: {:?}; Trying to commit with LI: {}",
            old_committed_ver,
            version_to_commit,
        );
        ensure!(
            pre_committed_ver.is_some() && version_to_commit <= pre_committed_ver.unwrap(),
            "Version too new to commit. Pre-committed: {:?}, Trying to commit with LI: {}",
            pre_committed_ver,
            version_to_commit,
        );
        Ok(old_committed_ver)
```

**File:** execution/executor/src/block_executor/mod.rs (L383-385)
```rust
        fail_point!("executor::commit_blocks", |_| {
            Err(anyhow::anyhow!("Injected error in commit_blocks.").into())
        });
```
