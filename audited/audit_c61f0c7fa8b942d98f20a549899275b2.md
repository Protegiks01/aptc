# Audit Report

## Title
Unvalidated Commit Proofs for Future Epochs Enable Consensus Safety Violations and Network Partition

## Summary
The consensus observer fails to validate commit proofs for future epochs before initiating state synchronization. An attacker can send a `CommitDecision` message with a future epoch number and an invalid/forged commit proof, which bypasses all cryptographic verification and causes nodes to synchronize to an invalid state, resulting in consensus failure and potential network partition.

## Finding Description

The vulnerability exists in the consensus observer's commit decision processing logic. When a `CommitDecision` message is received, the code only validates the commit proof if the decision is for the **current epoch**. For future epochs, validation is completely skipped. [1](#0-0) 

The critical flow is:

1. At line 468, the code checks if `commit_epoch == epoch_state.epoch` (current epoch)
2. Only then does it call `verify_commit_proof()` at line 470
3. If the commit is for a **future epoch**, this validation is skipped entirely
4. The code jumps to line 500+ where it checks if `epoch_changed || commit_round > last_block.round()`
5. At line 526, it calls `sync_to_commit(commit_decision, epoch_changed)` with the **unvalidated** commit decision [2](#0-1) 

The `sync_to_commit()` function receives this unvalidated commit decision and directly passes the commit proof to the execution client without any validation: [3](#0-2) 

At line 221, `commit_decision.commit_proof()` is passed to `sync_to_target()` without any signature verification. The state sync layer also does not validate the proof - it only checks version numbers: [4](#0-3) [5](#0-4) 

**Attack Scenario:**

1. Attacker observes current epoch E (e.g., epoch 100)
2. Attacker crafts a malicious `CommitDecision` with:
   - `epoch = E + 1` (future epoch 101)
   - Invalid/forged `commit_proof` (no valid BLS signatures)
   - Arbitrary `BlockInfo` (can claim any state root, version, timestamp)
3. Attacker sends this message to consensus observer nodes
4. Validation at line 470 is skipped (because 101 â‰  100)
5. Code proceeds to line 526 and calls `sync_to_commit()` with the invalid proof
6. State sync attempts to synchronize to the forged target
7. Different nodes may sync to different invalid states, causing consensus divergence

This breaks the **Consensus Safety** invariant (#2) and **State Consistency** invariant (#4).

## Impact Explanation

**Critical Severity** - This vulnerability enables:

1. **Consensus/Safety Violations**: Nodes can be tricked into syncing to invalid states with forged proofs, causing different nodes to have different views of the blockchain state. This directly violates the AptosBFT safety guarantee that less than 1/3 Byzantine nodes cannot cause chain splits.

2. **Non-recoverable Network Partition**: If multiple nodes sync to different invalid states based on forged proofs, the network can split into incompatible partitions. Nodes in different partitions will have conflicting state roots and cannot agree on block proposals, requiring manual intervention or a hardfork to recover.

3. **Loss of Liveness**: The consensus protocol can halt entirely if enough nodes synchronize to invalid states that don't match the actual committed blockchain state.

This qualifies for **Critical Severity** (up to $1,000,000) under the Aptos Bug Bounty program as it enables "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**High Likelihood** - The vulnerability is easily exploitable because:

1. **No Authentication Required**: Any network peer can send `CommitDecision` messages via the consensus observer protocol
2. **Simple Attack Vector**: Attacker only needs to set `epoch = current_epoch + 1` and provide any forged proof
3. **No Resource Requirements**: Attack requires no staking, validator access, or computational resources
4. **Wide Attack Surface**: All nodes running consensus observer are vulnerable
5. **Deterministic Bypass**: The validation check at line 468 deterministically fails for future epochs, guaranteeing the bypass

The TODO comment at line 497 explicitly acknowledges this issue: "TODO: identify the best way to handle an invalid commit decision for a future epoch." [6](#0-5) 

## Recommendation

The commit proof must be validated **before** calling `sync_to_commit()`, regardless of epoch. Since the current epoch state cannot validate future epoch proofs, the node should either:

**Option 1: Reject future epoch commits without validation**
```rust
// At line 468, after checking if commit_epoch == epoch_state.epoch
if commit_epoch > epoch_state.epoch {
    error!(
        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
            "Rejecting commit decision for future epoch {:?} (current epoch: {:?}). \
            Future epoch proofs cannot be validated without epoch state!",
            commit_epoch, epoch_state.epoch
        ))
    );
    increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
    return;
}
```

**Option 2: Fetch and validate with future epoch state (more complex)**
Before syncing to a future epoch commit, fetch the epoch state for that epoch from trusted sources, then validate the proof against that epoch state.

**Recommended Fix: Option 1** - Reject unvalidatable future epoch commits. If a node needs to sync across epochs, it should use the standard state sync mechanism which properly validates waypoints and epoch change proofs, not arbitrary unvalidated commit decisions.

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[tokio::test]
async fn test_unvalidated_future_epoch_commit_proof() {
    use aptos_types::{
        aggregate_signature::AggregateSignature,
        block_info::BlockInfo,
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
    };
    use crate::consensus_observer::network::observer_message::CommitDecision;

    // Create a forged commit proof with no valid signatures
    let current_epoch = 100;
    let future_epoch = current_epoch + 1;
    
    // Create arbitrary block info claiming any state
    let malicious_block_info = BlockInfo::new(
        future_epoch,
        999,  // arbitrary round
        HashValue::random(),  // forged block hash
        HashValue::random(),  // forged state root - attacker controlled!
        1000000,  // arbitrary version
        9999999999,  // arbitrary timestamp
        None,
    );
    
    // Create LedgerInfo with the malicious block info
    let malicious_ledger_info = LedgerInfo::new(
        malicious_block_info,
        HashValue::zero(),  // arbitrary consensus data hash
    );
    
    // Create an INVALID commit proof with empty/forged signatures
    let invalid_commit_proof = LedgerInfoWithSignatures::new(
        malicious_ledger_info,
        AggregateSignature::empty(),  // NO VALID SIGNATURES!
    );
    
    // Create commit decision with the invalid proof
    let malicious_commit_decision = CommitDecision::new(invalid_commit_proof);
    
    // Simulate processing this commit decision in consensus observer
    // The proof_block_info() will return our malicious block info
    assert_eq!(malicious_commit_decision.epoch(), future_epoch);
    
    // KEY ISSUE: When process_commit_decision_message() is called:
    // 1. Line 468 check fails: future_epoch (101) != current_epoch (100)
    // 2. Validation at line 470 is SKIPPED
    // 3. Code jumps to line 500+
    // 4. At line 526, sync_to_commit() is called with this UNVALIDATED proof
    // 5. State sync will attempt to sync to our forged state root!
    
    // VULNERABILITY: The invalid proof with no signatures is never validated
    // but is still used to initiate state synchronization
    
    // Expected: The proof should be validated and rejected
    // Actual: The proof bypasses all validation and reaches state sync
}
```

To fully demonstrate the attack, deploy this test in the consensus observer test suite and observe that:
1. The forged commit decision with future epoch bypasses `verify_commit_proof()`
2. The invalid proof reaches `sync_to_target()` without validation
3. State sync attempts to synchronize to the attacker-controlled state root

**Notes**

The vulnerability stems from an architectural flaw in how consensus observer handles epoch boundaries. The code assumes that commit decisions for future epochs will eventually be validated once the node transitions to that epoch, but this creates a dangerous window where unvalidated proofs can trigger state synchronization.

The TODO comment at line 497-498 explicitly acknowledges the lack of validation for future epoch commits, indicating this was a known gap in the implementation. However, the severity of allowing completely unvalidated proofs to drive state synchronization was likely underestimated.

This issue is particularly severe because:
- Consensus observers are designed to follow non-validating nodes that trust publisher nodes
- The attack bypasses the core BLS signature verification that ensures consensus safety
- Multiple nodes syncing to different forged states creates irrecoverable network splits

The fix is straightforward: reject all commit decisions that cannot be cryptographically validated with the current epoch state.

### Citations

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L466-495)
```rust
        // If the commit decision is for the current epoch, verify and process it
        let epoch_state = self.get_epoch_state();
        if commit_epoch == epoch_state.epoch {
            // Verify the commit decision
            if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify commit decision! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                        commit_decision.proof_block_info(),
                        peer_network_id,
                        error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
                return;
            }

            // Update the latency metrics for commit processing
            update_message_processing_latency_metrics(
                message_received_time,
                &peer_network_id,
                metrics::COMMIT_DECISION_LABEL,
            );

            // Update the pending blocks with the commit decision
            if self.process_commit_decision_for_pending_block(&commit_decision) {
                return; // The commit decision was successfully processed
            }
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L497-498)
```rust
        // TODO: identify the best way to handle an invalid commit decision
        // for a future epoch. In such cases, we currently rely on state sync.
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L500-527)
```rust
        // Otherwise, we failed to process the commit decision. If the commit
        // is for a future epoch or round, we need to state sync.
        let last_block = self.observer_block_data.lock().get_last_ordered_block();
        let epoch_changed = commit_epoch > last_block.epoch();
        if epoch_changed || commit_round > last_block.round() {
            // If we're waiting for state sync to transition into a new epoch,
            // we should just wait and not issue a new state sync request.
            if self.state_sync_manager.is_syncing_through_epoch() {
                info!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Already waiting for state sync to reach new epoch: {:?}. Dropping commit decision: {:?}!",
                        self.observer_block_data.lock().root().commit_info(),
                        commit_decision.proof_block_info()
                    ))
                );
                return;
            }

            // Otherwise, we should start the state sync process for the commit.
            // Update the block data (to the commit decision).
            self.observer_block_data
                .lock()
                .update_blocks_for_state_sync_commit(&commit_decision);

            // Start state syncing to the commit decision
            self.state_sync_manager
                .sync_to_commit(commit_decision, epoch_changed);
        }
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L190-258)
```rust
    pub fn sync_to_commit(&mut self, commit_decision: CommitDecision, epoch_changed: bool) {
        // Log that we're starting to sync to the commit decision
        info!(
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Started syncing to commit: {}!",
                commit_decision.proof_block_info()
            ))
        );

        // Get the commit decision epoch and round
        let commit_epoch = commit_decision.epoch();
        let commit_round = commit_decision.round();

        // Clone the required components for the state sync task
        let execution_client = self.execution_client.clone();
        let sync_notification_sender = self.state_sync_notification_sender.clone();

        // Spawn a task to sync to the commit decision
        let (abort_handle, abort_registration) = AbortHandle::new_pair();
        tokio::spawn(Abortable::new(
            async move {
                // Update the state sync metrics now that we're syncing to a commit
                metrics::set_gauge_with_label(
                    &metrics::OBSERVER_STATE_SYNC_EXECUTING,
                    metrics::STATE_SYNCING_TO_COMMIT,
                    1, // We're syncing to a commit decision
                );

                // Sync to the commit decision
                if let Err(error) = execution_client
                    .clone()
                    .sync_to_target(commit_decision.commit_proof().clone())
                    .await
                {
                    error!(
                        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                            "Failed to sync to commit decision: {:?}! Error: {:?}",
                            commit_decision, error
                        ))
                    );
                    return;
                }

                // Notify consensus observer that we've synced to the commit decision
                let state_sync_notification = StateSyncNotification::commit_sync_completed(
                    commit_decision.commit_proof().clone(),
                );
                if let Err(error) = sync_notification_sender.send(state_sync_notification) {
                    error!(
                        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                            "Failed to send state sync notification for commit decision epoch: {:?}, round: {:?}! Error: {:?}",
                            commit_epoch, commit_round, error
                        ))
                    );
                }

                // Clear the state sync metrics now that we're done syncing
                metrics::set_gauge_with_label(
                    &metrics::OBSERVER_STATE_SYNC_EXECUTING,
                    metrics::STATE_SYNCING_TO_COMMIT,
                    0, // We're no longer syncing to a commit decision
                );
            },
            abort_registration,
        ));

        // Save the sync task handle
        self.sync_to_commit_handle = Some((DropGuard::new(abort_handle), epoch_changed));
    }
```

**File:** consensus/src/state_computer.rs (L176-233)
```rust
    /// Synchronize to a commit that is not present locally.
    async fn sync_to_target(&self, target: LedgerInfoWithSignatures) -> Result<(), StateSyncError> {
        // Grab the logical time lock and calculate the target logical time
        let mut latest_logical_time = self.write_mutex.lock().await;
        let target_logical_time =
            LogicalTime::new(target.ledger_info().epoch(), target.ledger_info().round());

        // Before state synchronization, we have to call finish() to free the
        // in-memory SMT held by BlockExecutor to prevent a memory leak.
        self.executor.finish();

        // The pipeline phase already committed beyond the target block timestamp, just return.
        if *latest_logical_time >= target_logical_time {
            warn!(
                "State sync target {:?} is lower than already committed logical time {:?}",
                target_logical_time, *latest_logical_time
            );
            return Ok(());
        }

        // This is to update QuorumStore with the latest known commit in the system,
        // so it can set batches expiration accordingly.
        // Might be none if called in the recovery path, or between epoch stop and start.
        if let Some(inner) = self.state.read().as_ref() {
            let block_timestamp = target.commit_info().timestamp_usecs();
            inner
                .payload_manager
                .notify_commit(block_timestamp, Vec::new());
        }

        // Inject an error for fail point testing
        fail_point!("consensus::sync_to_target", |_| {
            Err(anyhow::anyhow!("Injected error in sync_to_target").into())
        });

        // Invoke state sync to synchronize to the specified target. Here, the
        // ChunkExecutor will process chunks and commit to storage. However, after
        // block execution and commits, the internal state of the ChunkExecutor may
        // not be up to date. So, it is required to reset the cache of the
        // ChunkExecutor in state sync when requested to sync.
        let result = monitor!(
            "sync_to_target",
            self.state_sync_notifier.sync_to_target(target).await
        );

        // Update the latest logical time
        *latest_logical_time = target_logical_time;

        // Similarly, after state synchronization, we have to reset the cache of
        // the BlockExecutor to guarantee the latest committed state is up to date.
        self.executor.reset()?;

        // Return the result
        result.map_err(|error| {
            let anyhow_error: anyhow::Error = error.into();
            anyhow_error.into()
        })
    }
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L262-318)
```rust
    pub async fn initialize_sync_target_request(
        &mut self,
        sync_target_notification: ConsensusSyncTargetNotification,
        latest_pre_committed_version: Version,
        latest_synced_ledger_info: LedgerInfoWithSignatures,
    ) -> Result<(), Error> {
        // Get the target sync version and latest committed version
        let sync_target_version = sync_target_notification
            .get_target()
            .ledger_info()
            .version();
        let latest_committed_version = latest_synced_ledger_info.ledger_info().version();

        // If the target version is old, return an error to consensus (something is wrong!)
        if sync_target_version < latest_committed_version
            || sync_target_version < latest_pre_committed_version
        {
            let error = Err(Error::OldSyncRequest(
                sync_target_version,
                latest_pre_committed_version,
                latest_committed_version,
            ));
            self.respond_to_sync_target_notification(sync_target_notification, error.clone())?;
            return error;
        }

        // If the committed version is at the target, return successfully
        if sync_target_version == latest_committed_version {
            info!(
                LogSchema::new(LogEntry::NotificationHandler).message(&format!(
                    "We're already at the requested sync target version: {} \
                (pre-committed version: {}, committed version: {})!",
                    sync_target_version, latest_pre_committed_version, latest_committed_version
                ))
            );
            let result = Ok(());
            self.respond_to_sync_target_notification(sync_target_notification, result.clone())?;
            return result;
        }

        // If the pre-committed version is already at the target, something has else gone wrong
        if sync_target_version == latest_pre_committed_version {
            let error = Err(Error::InvalidSyncRequest(
                sync_target_version,
                latest_pre_committed_version,
            ));
            self.respond_to_sync_target_notification(sync_target_notification, error.clone())?;
            return error;
        }

        // Save the request so we can notify consensus once we've hit the target
        let consensus_sync_request =
            ConsensusSyncRequest::new_with_target(sync_target_notification);
        self.consensus_sync_request = Arc::new(Mutex::new(Some(consensus_sync_request)));

        Ok(())
    }
```
