# Audit Report

## Title
Man-in-the-Middle Message Tampering in Remote Executor Network Communication Enabling Shard Execution Redirection

## Summary
The `NetworkMessage` struct in the remote executor service lacks cryptographic integrity protection (signatures, HMACs, or MACs), and gRPC connections use unencrypted HTTP without TLS. This allows man-in-the-middle attackers to modify the `message_type` field to redirect execution commands between shards or alter message payloads, violating deterministic execution invariants and causing state corruption or denial of service.

## Finding Description

The remote executor service uses a `NetworkMessage` protobuf structure for inter-shard communication that contains only raw data fields without any integrity verification: [1](#0-0) 

The gRPC network service establishes connections over plain HTTP (not HTTPS) without TLS: [2](#0-1) 

The server routes incoming messages to handlers based solely on the attacker-controlled `message_type` field: [3](#0-2) 

**Attack Scenario:**

1. The coordinator sends an `ExecuteBlock` command to shard 0 with `message_type="execute_command_0"`
2. MITM attacker intercepts the `NetworkMessage`
3. Attacker modifies `message_type` from `"execute_command_0"` to `"execute_command_1"`
4. Message is routed to shard 1 instead of shard 0
5. Shard 1 deserializes and executes transactions meant for shard 0

This breaks the **Deterministic Execution** invariant because:
- The sharded block executor partitions transactions assuming each shard executes its assigned sub-block
- Cross-shard execution violates state partitioning assumptions
- Different shards maintain different state key ranges
- Results returned to coordinator are associated with wrong shard IDs

The deserialization occurs with `.unwrap()` which panics on type mismatches: [4](#0-3) 

## Impact Explanation

This vulnerability meets **High Severity** criteria from the Aptos bug bounty program:

1. **Validator node slowdowns**: Deserialization failures from type confusion cause panics and service crashes
2. **Significant protocol violations**: Wrong-shard execution violates sharding invariants, corrupting execution results
3. **State inconsistencies**: Transactions executed on incorrect state partitions produce invalid state transitions

While the remote executor service appears primarily used in benchmarking infrastructure rather than production validators, the vulnerability exists in the codebase and would be exploitable if this feature were deployed across network boundaries. The attack enables:

- **Execution redirection**: Commands meant for one shard execute on another
- **Denial of Service**: Type confusion crashes services via deserialization panics  
- **Result corruption**: Coordinator receives results from wrong shards
- **State corruption**: Transactions access incorrect state partitions

## Likelihood Explanation

**Likelihood: Medium-to-Low** (depends on deployment context)

The vulnerability is **definitely exploitable** IF the remote executor service is deployed across untrusted network boundaries. Required conditions:

1. Remote executor service deployed with network-accessible endpoints (configurable via `remote_executor_addresses`)
2. Attacker achieves MITM position on network path between coordinator and executor shards
3. No additional network-level protections (VPNs, firewalls, network segmentation)

Current evidence suggests this feature is primarily used for benchmarking and not in production validator nodes. However, the configuration options exist for distributed deployment: [5](#0-4) 

If deployed in cloud environments across multiple machines or datacenters without proper network security, MITM attacks become feasible.

## Recommendation

Implement cryptographic integrity protection for `NetworkMessage`:

1. **Add TLS/mTLS**: Configure gRPC to use HTTPS with mutual TLS authentication
   - Use `tonic::transport::ServerTlsConfig` for server-side TLS
   - Use certificate-based mutual authentication between coordinator and shards

2. **Add message-level integrity protection**: 
   - Extend `NetworkMessage` to include HMAC or signature field
   - Sign messages using shared secret (HMAC) or private key (Ed25519 signature)
   - Verify integrity before routing to handlers

3. **Add authentication/authorization**:
   - Verify sender identity before processing messages
   - Enforce that only authorized coordinators can send to shards
   - Validate message type matches expected handler

**Example Fix (TLS configuration):**

```rust
// In GRPCNetworkMessageServiceClientWrapper::get_channel
async fn get_channel(remote_addr: String, tls_config: ClientTlsConfig) -> NetworkMessageServiceClient<Channel> {
    let conn = tonic::transport::Endpoint::new(format!("https://{}", remote_addr))
        .unwrap()
        .tls_config(tls_config)
        .unwrap()
        .connect_lazy();
    NetworkMessageServiceClient::new(conn).max_decoding_message_size(MAX_MESSAGE_SIZE)
}

// In GRPCNetworkMessageServiceServerWrapper::start_async  
Server::builder()
    .tls_config(ServerTlsConfig::new()
        .identity(Identity::from_pem(cert_pem, key_pem)))
    .unwrap()
    .timeout(std::time::Duration::from_millis(rpc_timeout_ms))
    .add_service(NetworkMessageServiceServer::new(self))
    // ... rest of configuration
```

## Proof of Concept

```rust
// Proof of concept demonstrating message tampering attack
// This would be integrated into execution/executor-service/tests/

use aptos_protos::remote_executor::v1::NetworkMessage;
use aptos_secure_net::grpc_network_service::GRPCNetworkMessageServiceClientWrapper;
use std::net::SocketAddr;
use tokio::runtime::Runtime;

#[test]
fn test_message_type_tampering_attack() {
    let rt = Runtime::new().unwrap();
    
    // Setup: Attacker intercepts NetworkMessage
    let legitimate_message = NetworkMessage {
        message: vec![1, 2, 3, 4], // Serialized ExecuteBlock for shard 0
        message_type: "execute_command_0".to_string(),
    };
    
    // Attack: Modify message_type to redirect to different shard
    let tampered_message = NetworkMessage {
        message: legitimate_message.message.clone(),
        message_type: "execute_command_1".to_string(), // Changed to shard 1!
    };
    
    // Result: Message originally meant for shard 0 is now routed to shard 1
    // The server will route based on message_type without verifying integrity
    assert_eq!(tampered_message.message_type, "execute_command_1");
    
    // This demonstrates that message_type can be arbitrarily modified
    // In a real attack, this would cause shard 1 to execute shard 0's transactions
}

#[test]  
fn test_type_confusion_dos_attack() {
    // Attack: Change message_type to incompatible handler
    let tampered_message = NetworkMessage {
        message: vec![/* ExecuteBlock serialized */],
        message_type: "remote_kv_request".to_string(), // Wrong type!
    };
    
    // When RemoteStateViewService tries to deserialize as RemoteKVRequest,
    // it will panic due to BCS deserialization failure at:
    // remote_state_view_service.rs:86 - let req: RemoteKVRequest = bcs::from_bytes(&message.data).unwrap();
    //
    // This demonstrates DoS via type confusion attacks
}
```

## Notes

While this vulnerability exists in the codebase, its practical exploitability depends heavily on deployment context. The remote executor service appears designed for trusted internal communication in benchmarking/testing scenarios rather than production deployment across untrusted networks. However, the lack of defense-in-depth (no integrity protection OR encryption) means any deployment outside a fully trusted network perimeter would be vulnerable. Implementing both TLS and message-level integrity protection provides defense-in-depth against both network-level and application-level attacks.

### Citations

**File:** protos/rust/src/pb/aptos.remote_executor.v1.rs (L8-13)
```rust
pub struct NetworkMessage {
    #[prost(bytes="vec", tag="1")]
    pub message: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag="2")]
    pub message_type: ::prost::alloc::string::String,
}
```

**File:** secure/net/src/grpc_network_service/mod.rs (L92-116)
```rust
impl NetworkMessageService for GRPCNetworkMessageServiceServerWrapper {
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
}
```

**File:** secure/net/src/grpc_network_service/mod.rs (L124-138)
```rust
    pub fn new(rt: &Runtime, remote_addr: SocketAddr) -> Self {
        Self {
            remote_addr: remote_addr.to_string(),
            remote_channel: rt
                .block_on(async { Self::get_channel(format!("http://{}", remote_addr)).await }),
        }
    }

    async fn get_channel(remote_addr: String) -> NetworkMessageServiceClient<Channel> {
        info!("Trying to connect to remote server at {:?}", remote_addr);
        let conn = tonic::transport::Endpoint::new(remote_addr)
            .unwrap()
            .connect_lazy();
        NetworkMessageServiceClient::new(conn).max_decoding_message_size(MAX_MESSAGE_SIZE)
    }
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L79-113)
```rust
impl CoordinatorClient<RemoteStateViewClient> for RemoteCoordinatorClient {
    fn receive_execute_command(&self) -> ExecutorShardCommand<RemoteStateViewClient> {
        match self.command_rx.recv() {
            Ok(message) => {
                let _rx_timer = REMOTE_EXECUTOR_TIMER
                    .with_label_values(&[&self.shard_id.to_string(), "cmd_rx"])
                    .start_timer();
                let bcs_deser_timer = REMOTE_EXECUTOR_TIMER
                    .with_label_values(&[&self.shard_id.to_string(), "cmd_rx_bcs_deser"])
                    .start_timer();
                let request: RemoteExecutionRequest = bcs::from_bytes(&message.data).unwrap();
                drop(bcs_deser_timer);

                match request {
                    RemoteExecutionRequest::ExecuteBlock(command) => {
                        let init_prefetch_timer = REMOTE_EXECUTOR_TIMER
                            .with_label_values(&[&self.shard_id.to_string(), "init_prefetch"])
                            .start_timer();
                        let state_keys = Self::extract_state_keys(&command);
                        self.state_view_client.init_for_block(state_keys);
                        drop(init_prefetch_timer);

                        let (sub_blocks, concurrency, onchain_config) = command.into();
                        ExecutorShardCommand::ExecuteSubBlocks(
                            self.state_view_client.clone(),
                            sub_blocks,
                            concurrency,
                            onchain_config,
                        )
                    },
                }
            },
            Err(_) => ExecutorShardCommand::Stop,
        }
    }
```

**File:** execution/executor-benchmark/src/main.rs (L204-230)
```rust
struct ShardingOpt {
    #[clap(long, default_value = "0")]
    num_executor_shards: usize,
    #[clap(long)]
    use_global_executor: bool,
    /// Gives an option to specify remote shard addresses. If specified, then we expect the number
    /// of remote addresses to be equal to 'num_executor_shards', and one coordinator address
    /// Address is specified as <IP>:<PORT>
    #[clap(long, num_args = 1..)]
    remote_executor_addresses: Option<Vec<SocketAddr>>,
    #[clap(long)]
    coordinator_address: Option<SocketAddr>,
    #[clap(long, default_value = "4")]
    max_partitioning_rounds: usize,
    #[clap(long, default_value = "0.90")]
    partitioner_cross_shard_dep_avoid_threshold: f32,
    #[clap(long)]
    partitioner_version: Option<String>,
    #[clap(long)]
    pre_partitioner: Option<String>,
    #[clap(long, default_value = "2.0")]
    load_imbalance_tolerance: f32,
    #[clap(long, default_value = "8")]
    partitioner_v2_num_threads: usize,
    #[clap(long, default_value = "64")]
    partitioner_v2_dashmap_num_shards: usize,
}
```
