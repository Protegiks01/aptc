# Audit Report

## Title
Unbounded Memory Consumption in RemoteStateViewService Due to Missing Server-Side Size Validation

## Summary
The `RemoteStateViewService::handle_message()` function deserializes `RemoteKVRequest` messages without validating the number of keys in the request, allowing an attacker to cause memory exhaustion and denial of service on validator nodes running sharded block execution.

## Finding Description

The remote state view service, used for sharded block execution, processes incoming `RemoteKVRequest` messages without enforcing size limits before deserialization. [1](#0-0) 

The `RemoteKVRequest` structure contains a `Vec<StateKey>` field that can contain an arbitrary number of state keys: [2](#0-1) 

While the client-side implementation enforces a batch size of 200 keys: [3](#0-2) [4](#0-3) 

**There is no corresponding server-side validation** to enforce this limit. The gRPC layer only enforces an 80MB maximum message size: [5](#0-4) [6](#0-5) 

Additionally, the network layer has **no authentication or authorization**: [7](#0-6) 

**Attack Path:**
1. Attacker crafts a malicious `RemoteKVRequest` with millions of `StateKey` entries (compressed within 80MB)
2. Sends the request to the gRPC endpoint
3. Server deserializes the entire message, allocating memory for the full vector
4. Multiple concurrent requests exhaust available memory
5. Validator node experiences severe performance degradation or crashes

This breaks the **Resource Limits** invariant (#9): "All operations must respect gas, storage, and computational limits."

## Impact Explanation

This vulnerability qualifies as **High Severity** per the Aptos bug bounty criteria:

- **Validator node slowdowns**: Memory exhaustion during BCS deserialization causes significant performance degradation
- **Potential DoS**: Multiple concurrent malicious requests can crash validator nodes
- **Critical path affected**: This service is used in the block execution workflow [8](#0-7) 

The vulnerability affects validator liveness and could disrupt consensus participation if exploited at scale.

## Likelihood Explanation

**Likelihood: Medium to High**

- No authentication required on the gRPC endpoint
- Attacker only needs network access to the service endpoint
- Client-side batch size limit can be trivially bypassed by a malicious actor
- The service is started as part of the remote executor client initialization [9](#0-8) 

While this service may be deployed on internal networks, defense-in-depth principles require server-side validation to match client-side constraints.

## Recommendation

Implement server-side validation to enforce the maximum batch size before deserialization:

```rust
pub fn handle_message(
    message: Message,
    state_view: Arc<RwLock<Option<Arc<S>>>>,
    kv_tx: Arc<Vec<Sender<Message>>>,
) {
    let _timer = REMOTE_EXECUTOR_TIMER
        .with_label_values(&["0", "kv_requests"])
        .start_timer();
    
    // Validate message size before deserialization
    const MAX_MESSAGE_SIZE_BYTES: usize = 10 * 1024 * 1024; // 10MB reasonable limit
    if message.data.len() > MAX_MESSAGE_SIZE_BYTES {
        error!("Received oversized KV request: {} bytes", message.data.len());
        return;
    }
    
    let bcs_deser_timer = REMOTE_EXECUTOR_TIMER
        .with_label_values(&["0", "kv_req_deser"])
        .start_timer();
    let req: RemoteKVRequest = match bcs::from_bytes(&message.data) {
        Ok(req) => req,
        Err(e) => {
            error!("Failed to deserialize KV request: {}", e);
            return;
        }
    };
    drop(bcs_deser_timer);

    let (shard_id, state_keys) = req.into();
    
    // Enforce maximum number of keys
    const MAX_KEYS_PER_REQUEST: usize = REMOTE_STATE_KEY_BATCH_SIZE; // 200
    if state_keys.len() > MAX_KEYS_PER_REQUEST {
        error!(
            "Received KV request with {} keys, exceeding limit of {}",
            state_keys.len(),
            MAX_KEYS_PER_REQUEST
        );
        return;
    }
    
    // ... rest of the function
}
```

Additionally, implement authentication on the gRPC service to ensure only authorized shards can send requests.

## Proof of Concept

```rust
use aptos_secure_net::network_controller::{Message, NetworkController};
use execution_executor_service::{RemoteKVRequest};
use aptos_types::{state_store::state_key::StateKey, block_executor::partitioner::ShardId};

#[test]
fn test_oversized_kv_request_dos() {
    // Create a malicious request with excessive keys
    let mut malicious_keys = Vec::new();
    
    // Generate 1 million tiny state keys (will compress well in BCS)
    for i in 0..1_000_000 {
        let key = StateKey::raw(vec![i as u8]);
        malicious_keys.push(key);
    }
    
    let malicious_request = RemoteKVRequest::new(
        ShardId::new(0),
        malicious_keys
    );
    
    let serialized = bcs::to_bytes(&malicious_request).unwrap();
    println!("Malicious message size: {} bytes", serialized.len());
    
    // This message, when sent to RemoteStateViewService::handle_message(),
    // will cause allocation of memory for 1 million StateKeys during 
    // deserialization, significantly exceeding the intended 200 key batch size.
    
    assert!(serialized.len() < 80 * 1024 * 1024); // Within gRPC limit
    
    // Send this message to the RemoteStateViewService endpoint
    // Multiple concurrent requests will exhaust memory and DoS the validator
}
```

## Notes

This vulnerability represents a critical defense-in-depth failure where client-side constraints are not enforced server-side. Even if the service is intended for internal use only, the lack of authentication combined with missing size validation creates a significant attack surface. The 80MB gRPC limit is insufficient protection, as compressed BCS-serialized data can expand significantly during deserialization, and the memory allocation happens before validation of the deserialized structure.

### Citations

**File:** execution/executor-service/src/remote_state_view_service.rs (L86-86)
```rust
        let req: RemoteKVRequest = bcs::from_bytes(&message.data).unwrap();
```

**File:** execution/executor-service/src/lib.rs (L68-71)
```rust
pub struct RemoteKVRequest {
    pub(crate) shard_id: ShardId,
    pub(crate) keys: Vec<StateKey>,
}
```

**File:** execution/executor-service/src/remote_state_view.rs (L27-27)
```rust
pub static REMOTE_STATE_KEY_BATCH_SIZE: usize = 200;
```

**File:** execution/executor-service/src/remote_state_view.rs (L136-144)
```rust
        state_keys
            .chunks(REMOTE_STATE_KEY_BATCH_SIZE)
            .map(|state_keys_chunk| state_keys_chunk.to_vec())
            .for_each(|state_keys| {
                let sender = kv_tx.clone();
                thread_pool.spawn(move || {
                    Self::send_state_value_request(shard_id, sender, state_keys);
                });
            });
```

**File:** secure/net/src/grpc_network_service/mod.rs (L23-23)
```rust
const MAX_MESSAGE_SIZE: usize = 1024 * 1024 * 80;
```

**File:** secure/net/src/grpc_network_service/mod.rs (L78-78)
```rust
                NetworkMessageServiceServer::new(self).max_decoding_message_size(MAX_MESSAGE_SIZE),
```

**File:** secure/net/src/grpc_network_service/mod.rs (L93-114)
```rust
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L261-267)
```rust
        if !get_remote_addresses().is_empty() {
            Ok(V::execute_block_sharded(
                &REMOTE_SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
```

**File:** execution/executor-service/src/remote_executor_client.rs (L121-132)
```rust
        let state_view_service = Arc::new(RemoteStateViewService::new(
            controller_mut_ref,
            remote_shard_addresses,
            None,
        ));

        let state_view_service_clone = state_view_service.clone();

        let join_handle = thread::Builder::new()
            .name("remote-state_view-service".to_string())
            .spawn(move || state_view_service_clone.start())
            .unwrap();
```
