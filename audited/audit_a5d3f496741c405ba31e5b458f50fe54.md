# Audit Report

## Title
Credential Exposure: AdminServiceConfig Serializes PasscodeSha256 Hashes to Logs and Config Files

## Summary
The `AdminServiceConfig` struct includes `PasscodeSha256` authentication hashes that are serialized and logged at node startup, potentially exposing authentication credentials in logs, backups, and exported configurations. This creates an unnecessary attack surface for offline brute-force attacks and unauthorized access to sensitive debugging endpoints.

## Finding Description

The `AdminServiceConfig` struct derives `Serialize` without any protective measures for the sensitive `PasscodeSha256` authentication hashes. [1](#0-0) 

The `AuthenticationConfig` enum, which contains the `PasscodeSha256(String)` variant holding SHA256 hashes of passcodes, also derives `Serialize` without redaction: [2](#0-1) 

When a node starts, the `log_all_configs()` method serializes the entire `NodeConfig` (including `AdminServiceConfig`) to JSON and logs each configuration section at INFO level: [3](#0-2) 

This method is called at node startup: [4](#0-3) 

Additionally, when configs are saved to disk via `PersistableConfig::save_config()`, the hashes are written in plaintext YAML: [5](#0-4) 

**Attack Flow:**
1. Node operator enables AdminService with PasscodeSha256 authentication on testnet or mainnet
2. Node startup triggers `log_all_configs()`, which logs the SHA256 hash at INFO level
3. Logs are sent to centralized logging systems, backup storage, or diagnostic reports
4. Attacker gains read access to logs through:
   - Compromised log aggregation service
   - Insecure backup storage
   - Insider access
   - Accidentally committed config files
5. Attacker extracts PasscodeSha256 hash from logs
6. If passcode is weak (common passwords, short length), attacker performs offline brute-force
7. With cracked passcode, attacker authenticates to AdminService endpoints to access sensitive debugging data

The AdminService authentication mechanism compares the SHA256 hash of the provided passcode with the stored hash: [6](#0-5) 

## Impact Explanation

This vulnerability represents a **Medium severity** credential exposure issue with the following impacts:

**Information Disclosure**: Unauthorized access to AdminService debugging endpoints reveals:
- CPU profiling data (`/profilez`)
- Thread dumps (`/threadz`)
- Memory statistics and profiles
- Consensus database contents (`/debug/consensus/consensusdb`)
- Quorum store database contents
- Block data dumps
- Mempool parking lot addresses

This information could help attackers understand validator node internals, performance characteristics, and potentially identify other vulnerabilities.

**Inconsistent Security Practices**: The codebase demonstrates established patterns for protecting sensitive credentials. For example, `IndexerConfig` implements custom `Debug` to redact database passwords: [7](#0-6) 

And `IdentityBlob` uses `skip_serializing_if` for private keys: [8](#0-7) 

The failure to apply similar protections to `PasscodeSha256` is inconsistent with the codebase's security standards.

Per Aptos bug bounty criteria, this qualifies as Medium severity due to the credential exposure creating attack surface for unauthorized access to sensitive validator information.

## Likelihood Explanation

This vulnerability has **HIGH likelihood** of occurrence in production environments:

1. **Common Practice**: Most production deployments send logs to centralized systems (Datadog, Splunk, CloudWatch, etc.)
2. **INFO Level Logging**: The `log_all_configs()` uses INFO level, which is typically enabled in production
3. **Backup Exposure**: Config files containing hashes are regularly backed up and may be stored in less secure locations
4. **Weak Passcodes**: Users often choose weak passcodes that are vulnerable to offline brute-force attacks
5. **Mainnet Requirement**: AdminService requires authentication on mainnet, meaning this issue affects production validators [9](#0-8) 

## Recommendation

Implement protection for `PasscodeSha256` hashes using one or both of the following approaches:

**Option 1: Skip Serialization**
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(rename_all = "snake_case")]
pub enum AuthenticationConfig {
    #[serde(skip_serializing)]
    PasscodeSha256(String),
}
```

**Option 2: Custom Debug Implementation** (Preferred)
```rust
#[derive(Clone, Deserialize, PartialEq, Eq, Serialize)]
#[serde(rename_all = "snake_case")]
pub enum AuthenticationConfig {
    PasscodeSha256(String),
}

impl Debug for AuthenticationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        match self {
            AuthenticationConfig::PasscodeSha256(_) => {
                write!(f, "PasscodeSha256(***REDACTED***)")
            }
        }
    }
}
```

**Option 3: Custom Serialize Implementation**
```rust
impl Serialize for AuthenticationConfig {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            AuthenticationConfig::PasscodeSha256(_) => {
                serializer.serialize_str("PasscodeSha256(***REDACTED***)")
            }
        }
    }
}
```

The recommended approach is Option 2 (custom Debug) combined with Option 3 (custom Serialize) to ensure hashes are never exposed in logs, debug output, or serialized configs.

## Proof of Concept

```rust
// test_admin_service_hash_exposure.rs
#[cfg(test)]
mod test {
    use aptos_config::config::{AdminServiceConfig, AuthenticationConfig, NodeConfig};

    #[test]
    fn test_passcode_hash_exposed_in_serialization() {
        // Create a config with PasscodeSha256 authentication
        let mut node_config = NodeConfig::default();
        node_config.admin_service = AdminServiceConfig {
            enabled: Some(true),
            authentication_configs: vec![
                AuthenticationConfig::PasscodeSha256(
                    "5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8".to_string() // SHA256("password")
                )
            ],
            ..Default::default()
        };

        // Serialize to JSON (as done in log_all_configs)
        let serialized = serde_json::to_string(&node_config.admin_service).unwrap();
        
        // VULNERABILITY: The hash is exposed in the serialized output
        assert!(serialized.contains("5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8"));
        println!("EXPOSED HASH IN JSON: {}", serialized);

        // Serialize to YAML (as done in save_config)
        let yaml_serialized = serde_yaml::to_string(&node_config.admin_service).unwrap();
        
        // VULNERABILITY: The hash is also exposed in YAML
        assert!(yaml_serialized.contains("5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8"));
        println!("EXPOSED HASH IN YAML: {}", yaml_serialized);
    }

    #[test]
    fn demonstrate_offline_brute_force() {
        // Attacker extracts this hash from logs
        let leaked_hash = "5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8";
        
        // Attacker attempts common passwords
        let common_passwords = vec!["password", "123456", "admin", "test"];
        
        for password in common_passwords {
            let computed_hash = sha256::digest(password);
            if computed_hash == leaked_hash {
                println!("CRACKED! The passcode is: {}", password);
                assert_eq!(password, "password");
                return;
            }
        }
    }
}
```

**Notes**

This vulnerability violates the principle of defense in depth by unnecessarily exposing authentication credentials. While SHA256 hashes are not reversible, they remain sensitive because:
1. Weak passcodes can be cracked through offline brute-force
2. The hashes themselves become authentication tokens that should be protected
3. Exposure creates compliance issues (PCI-DSS, SOC2, etc. require protection of authentication credentials)

The established patterns in the codebase for handling sensitive data (database passwords, private keys) should be consistently applied to all authentication credentials, including PasscodeSha256 hashes.

### Citations

**File:** config/src/config/admin_service_config.rs (L15-24)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct AdminServiceConfig {
    pub enabled: Option<bool>,
    pub address: String,
    pub port: u16,
    // If empty, will allow all requests without authentication. (Not allowed on mainnet.)
    pub authentication_configs: Vec<AuthenticationConfig>,
    pub malloc_stats_max_len: usize,
}
```

**File:** config/src/config/admin_service_config.rs (L26-39)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(rename_all = "snake_case")]
pub enum AuthenticationConfig {
    // This will allow authentication through query parameter.
    // e.g. `/profilez?passcode=abc`.
    //
    // To calculate sha256, use sha256sum tool, or other online tools.
    //
    // e.g.
    //
    // printf abc |sha256sum
    PasscodeSha256(String),
    // TODO(grao): Add SSL support if necessary.
}
```

**File:** config/src/config/admin_service_config.rs (L67-78)
```rust
        if node_config.admin_service.enabled == Some(true) {
            if let Some(chain_id) = chain_id {
                if chain_id.is_mainnet()
                    && node_config.admin_service.authentication_configs.is_empty()
                {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Must enable authentication for AdminService on mainnet.".into(),
                    ));
                }
            }
        }
```

**File:** config/src/config/node_config.rs (L97-111)
```rust
    pub fn log_all_configs(&self) {
        // Parse the node config as serde JSON
        let config_value =
            serde_json::to_value(self).expect("Failed to serialize the node config!");
        let config_map = config_value
            .as_object()
            .expect("Failed to get the config map!");

        // Log each config entry
        for (config_name, config_value) in config_map {
            let config_string =
                serde_json::to_string(config_value).expect("Failed to parse the config value!");
            info!("Using {} config: {}", config_name, config_string);
        }
    }
```

**File:** aptos-node/src/lib.rs (L697-698)
```rust
    // Log the node config at node startup
    node_config.log_all_configs();
```

**File:** config/src/config/persistable_config.rs (L22-29)
```rust
    /// Save the config to disk at the given output path
    fn save_config<P: AsRef<Path>>(&self, output_file: P) -> Result<(), Error> {
        // Serialize the config to a string
        let serialized_config = serde_yaml::to_vec(&self)
            .map_err(|e| Error::Yaml(output_file.as_ref().to_str().unwrap().to_string(), e))?;

        Self::write_file(serialized_config, output_file)
    }
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L158-174)
```rust
            for authentication_config in &context.config.authentication_configs {
                match authentication_config {
                    AuthenticationConfig::PasscodeSha256(passcode_sha256) => {
                        let query = req.uri().query().unwrap_or("");
                        let query_pairs: HashMap<_, _> =
                            url::form_urlencoded::parse(query.as_bytes()).collect();
                        let passcode: Option<String> =
                            query_pairs.get("passcode").map(|p| p.to_string());
                        if let Some(passcode) = passcode {
                            if sha256::digest(passcode) == *passcode_sha256 {
                                authenticated = true;
                            }
                        }
                    },
                }
            }
        };
```

**File:** config/src/config/indexer_config.rs (L92-100)
```rust
impl Debug for IndexerConfig {
    fn fmt(&self, f: &mut Formatter<'_>) -> std::fmt::Result {
        let postgres_uri = self.postgres_uri.as_ref().map(|u| {
            let mut parsed_url = url::Url::parse(u).expect("Invalid postgres uri");
            if parsed_url.password().is_some() {
                parsed_url.set_password(Some("*")).unwrap();
            }
            parsed_url.to_string()
        });
```

**File:** config/src/config/identity_config.rs (L24-37)
```rust
#[derive(Deserialize, Serialize)]
pub struct IdentityBlob {
    /// Optional account address. Used for validators and validator full nodes
    #[serde(skip_serializing_if = "Option::is_none")]
    pub account_address: Option<AccountAddress>,
    /// Optional account key. Only used for validators
    #[serde(skip_serializing_if = "Option::is_none")]
    pub account_private_key: Option<Ed25519PrivateKey>,
    /// Optional consensus key. Only used for validators
    #[serde(skip_serializing_if = "Option::is_none")]
    pub consensus_private_key: Option<bls12381::PrivateKey>,
    /// Network private key. Peer id is derived from this if account address is not present
    pub network_private_key: x25519::PrivateKey,
}
```
