# Audit Report

## Title
Faucet Service Gas Price Manipulation Leading to Denial of Service via Unvalidated API Response

## Summary
The aptos-workspace-server faucet service fetches gas unit prices from the node's `/estimate_gas_price` API endpoint without validating the returned values against reasonable bounds. An attacker who can manipulate the node API response can cause the faucet to request inflated gas prices that exceed the faucet account's balance, resulting in all transactions failing in prologue validation and causing complete faucet unavailability.

## Finding Description

The faucet service in `start_faucet()` initializes a `RunConfig` that sets `max_gas_amount=500_000` and `gas_unit_price_override=None`, causing the faucet to dynamically fetch gas prices from the connected node API. [1](#0-0) 

The `RunConfig::build_for_cli()` function hardcodes these parameters in the transaction submission configuration: [2](#0-1) 

When the faucet processes funding requests, it fetches the gas price through the `GasUnitPriceManager` without any validation: [3](#0-2) 

The fetched `gas_estimate` value is used directly to build transactions: [4](#0-3) 

**Attack Scenario:**

1. Attacker manipulates the `/estimate_gas_price` endpoint to return the maximum allowed gas price (`max_price_per_gas_unit = 10,000,000,000`)
2. The faucet caches this value for 30 seconds (per `gas_unit_price_ttl_secs`)
3. When building transactions, the faucet calculates required balance as: `max_gas_amount * gas_unit_price = 500,000 * 10,000,000,000 = 5,000,000,000,000 OCTA` (5,000 APT)
4. The delegated faucet account is created with only 100 APT balance: [5](#0-4) 

5. During transaction validation, the prologue checks if the sender has sufficient balance: [6](#0-5) 

6. Since `100 APT < 5,000 APT`, the transaction fails with `PROLOGUE_ECANT_PAY_GAS_DEPOSIT` error
7. The faucet error handling decrements the sequence number but cannot recover
8. All subsequent funding requests fail, causing complete faucet DoS

**Broken Invariant:** Resource Limits (#9) - The system fails to validate external gas price inputs against reasonable operational bounds, allowing unrealistic values that violate the implicit assumption that gas parameters should enable normal operation.

## Impact Explanation

This qualifies as **Medium Severity** per the Aptos bug bounty criteria ("State inconsistencies requiring intervention"). 

While this occurs in a development tool (workspace-server), the impact includes:
- **Complete faucet unavailability**: All funding requests fail, blocking development workflows
- **Persistent DoS**: The 30-second cache TTL means the attack persists across multiple requests
- **No automatic recovery**: Manual intervention required to reset or restart the faucet service
- **Potential for broader applicability**: The insecure code pattern in `GasUnitPriceManager` could be replicated in production contexts

The issue is particularly relevant in:
- Shared development server environments
- Cloud-based development platforms  
- Containerized setups where the faucet and node have different trust boundaries
- CI/CD pipelines using the workspace server

## Likelihood Explanation

The likelihood is **Medium to Low** depending on deployment context:

**In single-user local development** (typical use case): Low likelihood, as attacker needs localhost access to manipulate the node API.

**In shared/cloud development environments**: Medium likelihood, as:
- Multiple users may share infrastructure
- Container isolation may not prevent API manipulation
- Node process could be compromised through dependency vulnerabilities
- Network misconfigurations could expose the API endpoint

The attack is **trivially executable** once the attacker has the capability to manipulate the API response - no complex exploitation techniques required.

## Recommendation

Add validation bounds for gas prices fetched from external APIs. The faucet should reject gas prices that are unreasonably high relative to operational requirements.

**Recommended fix in `GasUnitPriceManager::get_gas_unit_price()`:**

```rust
pub async fn get_gas_unit_price(&self) -> Result<u64> {
    let now = Instant::now();
    
    // Check cache validity
    if let Some(last_updated) = *self.last_updated.read().await {
        if now.duration_since(last_updated) < self.cache_ttl {
            return Ok(self.gas_unit_price.load(Ordering::Acquire));
        }
    }
    
    let mut last_updated = self.last_updated.write().await;
    let new_price = self.fetch_gas_unit_price().await?;
    
    // SECURITY: Validate gas price is within reasonable operational bounds
    // Use a safety margin well below max_price_per_gas_unit to prevent
    // transactions from requiring unrealistic balance amounts
    const MAX_REASONABLE_GAS_PRICE: u64 = 100_000; // 1000x typical price
    if new_price > MAX_REASONABLE_GAS_PRICE {
        return Err(anyhow::anyhow!(
            "Gas price {} exceeds reasonable maximum {}", 
            new_price, 
            MAX_REASONABLE_GAS_PRICE
        ));
    }
    
    self.gas_unit_price.store(new_price, Ordering::Release);
    *last_updated = Some(now);
    
    info!(gas_unit_price = new_price, event = "gas_unit_price_updated");
    Ok(new_price)
}
```

Additionally, consider making the maximum reasonable gas price configurable via `TransactionSubmissionConfig` to support different deployment contexts.

## Proof of Concept

Create a test that demonstrates transaction failure with inflated gas prices:

```rust
#[tokio::test]
async fn test_inflated_gas_price_causes_transaction_failure() {
    // Setup: Create a faucet with a mock node API that returns inflated gas prices
    let mut mock_server = mockito::Server::new_async().await;
    
    // Mock the estimate_gas_price endpoint to return maximum allowed price
    let _mock = mock_server
        .mock("GET", "/v1/estimate_gas_price")
        .with_status(200)
        .with_header("content-type", "application/json")
        .with_body(r#"{
            "gas_estimate": 10000000000,
            "deprioritized_gas_estimate": 10000000000,
            "prioritized_gas_estimate": 10000000000
        }"#)
        .create_async()
        .await;
    
    // Create faucet configuration pointing to mock server
    let node_url = Url::parse(&mock_server.url()).unwrap();
    let faucet_config = RunConfig::build_for_cli(
        node_url,
        "127.0.0.1".to_string(),
        0,
        FunderKeyEnum::KeyFile(PathBuf::from("/tmp/test.key")),
        false,
        Some(ChainId::test()),
    );
    
    // Attempt to fund an account
    // Expected: Transaction fails with PROLOGUE_ECANT_PAY_GAS_DEPOSIT
    // because required balance (5000 APT) exceeds available balance (100 APT)
    let result = faucet_config.funder_config.build().await
        .unwrap()
        .fund(
            Some(100_000_000),
            AccountAddress::random(),
            None,
            false,
            false,
        )
        .await;
    
    // Verify transaction failed due to insufficient balance for inflated gas price
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("ECANT_PAY_GAS_DEPOSIT"));
}
```

**Notes**

This vulnerability demonstrates a defense-in-depth violation where external API inputs are trusted without validation. While the workspace-server operates in a local development context where the node API is typically trusted, modern development practices involving shared infrastructure, cloud environments, and containerization create scenarios where this trust assumption no longer holds. The fix is straightforward and prevents a category of denial-of-service attacks that could disrupt development workflows or be exploited in environments where the faucet and node have different trust boundaries.

### Citations

**File:** aptos-move/aptos-workspace-server/src/services/faucet.rs (L46-53)
```rust
        let faucet_run_config = RunConfig::build_for_cli(
            Url::parse(&format!("http://{}:{}", IP_LOCAL_HOST, api_port)).unwrap(),
            IP_LOCAL_HOST.to_string(),
            0,
            FunderKeyEnum::KeyFile(test_dir.join("mint.key")),
            false,
            None,
        );
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L285-294)
```rust
                transaction_submission_config: TransactionSubmissionConfig::new(
                    None,    // maximum_amount
                    None,    // maximum_amount_with_bypass
                    30,      // gas_unit_price_ttl_secs
                    None,    // gas_unit_price_override
                    500_000, // max_gas_amount
                    30,      // transaction_expiration_secs
                    35,      // wait_for_outstanding_txns_secs
                    false,   // wait_for_transactions
                ),
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L420-447)
```rust
    pub async fn get_gas_unit_price(&self) -> Result<u64> {
        let now = Instant::now();

        // If we're still within the TTL, just return the current value.
        if let Some(last_updated) = *self.last_updated.read().await {
            if now.duration_since(last_updated) < self.cache_ttl {
                return Ok(self.gas_unit_price.load(Ordering::Acquire));
            }
        }

        // We're beyond the TTL, update the value and last_updated.
        let mut last_updated = self.last_updated.write().await;
        let new_price = self.fetch_gas_unit_price().await?;
        self.gas_unit_price.store(new_price, Ordering::Release);
        *last_updated = Some(now);

        info!(gas_unit_price = new_price, event = "gas_unit_price_updated");
        Ok(new_price)
    }

    async fn fetch_gas_unit_price(&self) -> Result<u64> {
        Ok(self
            .api_client
            .estimate_gas_price()
            .await?
            .into_inner()
            .gas_estimate)
    }
```

**File:** crates/aptos-faucet/core/src/funder/mint.rs (L256-274)
```rust
    async fn get_gas_unit_price(&self) -> Result<u64, AptosTapError> {
        match self.txn_config.gas_unit_price_override {
            Some(gas_unit_price) => Ok(gas_unit_price),
            None => self
                .gas_unit_price_manager
                .get_gas_unit_price()
                .await
                .map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::AptosApiError)
                }),
        }
    }

    async fn get_transaction_factory(&self) -> Result<TransactionFactory, AptosTapError> {
        Ok(self
            .transaction_factory
            .clone()
            .with_gas_unit_price(self.get_gas_unit_price().await?))
    }
```

**File:** crates/aptos-faucet/core/src/funder/mint.rs (L286-299)
```rust
        // Create the account, wait for the response.
        self.process(
            &client,
            100_000_000_000,
            delegated_account
                .authentication_key()
                .clone()
                .account_address(),
            false,
            true,
            asset_name,
        )
        .await
        .context("Failed to create new account")?;
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L187-212)
```text
        // Check if the gas payer has enough balance to pay for the transaction
        let max_transaction_fee = txn_gas_price * txn_max_gas_units;
        if (!skip_gas_payment(
            is_simulation,
            gas_payer_address
        )) {
            assert!(
                permissioned_signer::check_permission_capacity_above(
                    gas_payer,
                    (max_transaction_fee as u256),
                    GasPermission {}
                ),
                error::permission_denied(PROLOGUE_PERMISSIONED_GAS_LIMIT_INSUFFICIENT)
            );
            if (features::operations_default_to_fa_apt_store_enabled()) {
                assert!(
                    aptos_account::is_fungible_balance_at_least(gas_payer_address, max_transaction_fee),
                    error::invalid_argument(PROLOGUE_ECANT_PAY_GAS_DEPOSIT)
                );
            } else {
                assert!(
                    coin::is_balance_at_least<AptosCoin>(gas_payer_address, max_transaction_fee),
                    error::invalid_argument(PROLOGUE_ECANT_PAY_GAS_DEPOSIT)
                );
            }
        };
```
