# Audit Report

## Title
Metadata Type Confusion Causes Panic in Indexer Queries Without Graceful Error Handling

## Summary
The `InternalIndexerDB::get_version()` function calls `expect_version()` on `MetadataValue`, which panics without graceful error handling if the metadata contains a non-version value. This can crash API queries and the indexer service when metadata corruption occurs.

## Finding Description
At [1](#0-0) , the `get_version()` function retrieves metadata and calls `expect_version()` to extract the version value. 

The `expect_version()` implementation at [2](#0-1)  explicitly panics with "Not version" if the metadata value is not a `Version` variant.

This function is called from critical paths:

1. **API Query Path**: The API context's `get_latest_internal_indexer_ledger_info()` at [3](#0-2)  calls through to `get_persisted_version()` at [4](#0-3) 

2. **Indexer Service Path**: The indexer service's `get_start_version()` at [5](#0-4)  calls `get_persisted_version()`, `get_state_version()`, `get_event_version()`, and `get_transaction_version()` during startup.

If metadata becomes corrupted (e.g., through disk corruption, schema evolution during upgrades, or a code bug), and a key expected to contain `MetadataValue::Version` instead contains `MetadataValue::StateSnapshotProgress`, the panic will:
- Crash individual API request handlers (returning 500 errors)
- Crash the indexer service thread during startup or operation

## Impact Explanation
This qualifies as **Medium Severity** per Aptos bug bounty criteria:
- **State inconsistencies requiring intervention**: Corrupted metadata causes service degradation
- **API crashes**: Individual API queries fail with panics
- **Validator node slowdowns**: Indexer service crashes prevent proper indexing

While this does not directly affect consensus or cause fund loss, it creates a denial-of-service condition for the indexer functionality, which is critical for API queries and blockchain data access.

## Likelihood Explanation
**Likelihood: LOW to MEDIUM**

The vulnerability requires pre-existing metadata corruption, which can occur through:
- **Disk corruption**: Hardware failures or filesystem issues (low probability but possible)
- **Schema evolution**: Enum definition changes during upgrades without proper migration (medium probability)
- **Concurrent write bugs**: Future code bugs that write wrong variant to a key (low probability with current code)

While the current code consistently writes correct metadata types at [6](#0-5) , the lack of defensive error handling makes the system fragile to corruption from any source.

## Recommendation
Replace panic-based unwrapping with Result-based error handling:

**In `storage/indexer_schemas/src/metadata.rs`**, change `expect_version()` to return `Result`:
```rust
pub fn expect_version(self) -> Result<Version> {
    match self {
        Self::Version(v) => Ok(v),
        _ => Err(anyhow::anyhow!(
            "Metadata type mismatch: expected Version variant, got {:?}", 
            std::mem::discriminant(&self)
        )),
    }
}
```

**In `storage/indexer/src/db_indexer.rs`**, update `get_version()` to propagate errors:
```rust
fn get_version(&self, key: &MetadataKey) -> Result<Option<Version>> {
    match self.db.get::<InternalIndexerMetadataSchema>(key)? {
        Some(v) => Ok(Some(v.expect_version()?)),
        None => Ok(None),
    }
}
```

This ensures graceful error handling instead of panics, allowing the system to log errors and potentially recover.

## Proof of Concept
```rust
#[test]
fn test_metadata_type_confusion_panic() {
    use aptos_db_indexer_schemas::metadata::{MetadataKey, MetadataValue, StateSnapshotProgress};
    use aptos_crypto::HashValue;
    use aptos_types::state_store::state_storage_usage::StateStorageUsage;
    
    // Create corrupted metadata with wrong variant
    let wrong_variant = MetadataValue::StateSnapshotProgress(
        StateSnapshotProgress::new(
            HashValue::zero(),
            StateStorageUsage::new_untracked(),
        )
    );
    
    // This will panic with "Not version"
    let _version = wrong_variant.expect_version();
    // Test would crash here, demonstrating the vulnerability
}
```

**Notes**
This vulnerability requires pre-existing metadata corruption to trigger. While there is no direct attack path for an unprivileged external attacker to corrupt the metadata, the lack of graceful error handling creates system fragility. The issue represents a defensive programming weakness that should be addressed to improve system resilience against unexpected data corruption scenarios.

### Citations

**File:** storage/indexer/src/db_indexer.rs (L287-292)
```rust
    fn get_version(&self, key: &MetadataKey) -> Result<Option<Version>> {
        Ok(self
            .db
            .get::<InternalIndexerMetadataSchema>(key)?
            .map(|v| v.expect_version()))
    }
```

**File:** storage/indexer/src/db_indexer.rs (L542-545)
```rust
        batch.put::<InternalIndexerMetadataSchema>(
            &MetadataKey::LatestVersion,
            &MetadataValue::Version(version - 1),
        )?;
```

**File:** storage/indexer_schemas/src/metadata.rs (L16-21)
```rust
    pub fn expect_version(self) -> Version {
        match self {
            Self::Version(v) => v,
            _ => panic!("Not version"),
        }
    }
```

**File:** api/src/context.rs (L319-328)
```rust
    pub fn get_latest_internal_indexer_ledger_info<E: ServiceUnavailableError>(
        &self,
    ) -> Result<LedgerInfo, E> {
        if let Some(indexer_reader) = self.indexer_reader.as_ref() {
            if indexer_reader.is_internal_indexer_enabled() {
                if let Some(mut latest_version) = indexer_reader
                    .get_latest_internal_indexer_ledger_version()
                    .map_err(|err| {
                        E::service_unavailable_with_code_no_info(err, AptosErrorCode::InternalError)
                    })?
```

**File:** storage/indexer/src/indexer_reader.rs (L54-58)
```rust
    fn get_latest_internal_indexer_ledger_version(&self) -> anyhow::Result<Option<Version>> {
        if let Some(db_indexer) = &self.db_indexer_reader {
            return Ok(db_indexer.indexer_db.get_persisted_version()?);
        }
        anyhow::bail!("DB indexer reader is not available")
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/internal_indexer_db_service.rs (L102-139)
```rust
        let start_version = self
            .db_indexer
            .indexer_db
            .get_persisted_version()?
            .map_or(0, |v| v + 1);

        if node_config.indexer_db_config.enable_statekeys() {
            let state_start_version = self
                .db_indexer
                .indexer_db
                .get_state_version()?
                .map_or(0, |v| v + 1);
            if start_version != state_start_version {
                panic!("Cannot start state indexer because the progress doesn't match.");
            }
        }

        if node_config.indexer_db_config.enable_transaction() {
            let transaction_start_version = self
                .db_indexer
                .indexer_db
                .get_transaction_version()?
                .map_or(0, |v| v + 1);
            if start_version != transaction_start_version {
                panic!("Cannot start transaction indexer because the progress doesn't match.");
            }
        }

        if node_config.indexer_db_config.enable_event() {
            let event_start_version = self
                .db_indexer
                .indexer_db
                .get_event_version()?
                .map_or(0, |v| v + 1);
            if start_version != event_start_version {
                panic!("Cannot start event indexer because the progress doesn't match.");
            }
        }
```
