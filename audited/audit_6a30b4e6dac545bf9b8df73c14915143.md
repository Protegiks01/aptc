# Audit Report

## Title
Race Condition in Health Checker Disconnect Allows Concurrent Message Processing and State Inconsistency

## Summary
A race condition exists in the health checker's `disconnect_peer()` function where incoming health check messages can modify `health_check_data` between marking the peer as `Disconnecting` and the actual disconnect completion, creating temporary state inconsistencies.

## Finding Description
In the health checker disconnect flow, a race condition exists between: [1](#0-0) 

and the actual disconnect operation: [2](#0-1) 

During the async await on `disconnect_from_peer()`, the health checker's main event loop continues processing events concurrently via `futures::select!`: [3](#0-2) 

When an incoming `RpcRequest` with a `Ping` message arrives from the peer during this window: [4](#0-3) 

The `handle_ping_request` function calls `reset_peer_failures()`: [5](#0-4) 

This resets the failure count to zero: [6](#0-5) 

The `health_check_data` is only removed after successful disconnect: [7](#0-6) 

**Violation of Invariants:**
- The peer is marked as `Disconnecting` (being removed for health reasons) while simultaneously having its failure count reset (indicating health)
- The network layer does not enforce message filtering based on `ConnectionState`, allowing `Disconnecting` peers to continue sending/receiving application messages
- State consistency between `ConnectionState` and `health_check_data` is temporarily violated

## Impact Explanation
This issue qualifies as **Medium Severity** under the Aptos bug bounty program category "State inconsistencies requiring intervention."

While the race creates state inconsistency, the practical security impact is limited:

1. **No Direct Consensus Impact**: This affects peer health tracking, not consensus-critical operations
2. **No Funds at Risk**: Network layer metadata doesn't control fund access
3. **Limited Availability Impact**: The disconnect operation still completes, and unhealthy peers are eventually removed in subsequent health check rounds
4. **Temporary Inconsistency**: If disconnect succeeds, the inconsistent data is immediately cleaned up

The primary concern is a design flaw where `ConnectionState::Disconnecting` doesn't prevent message delivery, violating the intended invariant that disconnecting peers should not process application messages.

## Likelihood Explanation
**Likelihood: Medium**

This race condition can occur naturally due to:
1. Network message buffering - Ping messages in flight or buffered during disconnect
2. Concurrent event processing in the `futures::select!` macro allowing interleaving
3. The 50ms timeout window for disconnect operations provides ample time for message arrival: [8](#0-7) 

The race doesn't require precise attacker timing - normal network conditions with buffered messages can trigger it.

## Recommendation

**Fix 1: Check peer state before processing health check messages**

Modify `handle_ping_request` to check if the peer is in `Disconnecting` state before resetting failures:

```rust
fn handle_ping_request(
    &mut self,
    peer_id: PeerId,
    ping: Ping,
    protocol: ProtocolId,
    res_tx: oneshot::Sender<Result<Bytes, RpcError>>,
) {
    // Check if peer is disconnecting
    let peer_network_id = PeerNetworkId::new(self.network_context.network_id(), peer_id);
    if let Ok(metadata) = self.network_interface.get_peers_and_metadata().get_metadata_for_peer(peer_network_id) {
        if metadata.get_connection_state() == ConnectionState::Disconnecting {
            // Don't process health checks for disconnecting peers
            return;
        }
    }
    
    // ... rest of existing code
}
```

**Fix 2: Remove health_check_data before initiating disconnect**

Move the removal before the async disconnect:

```rust
pub async fn disconnect_peer(
    &mut self,
    peer_network_id: PeerNetworkId,
    disconnect_reason: DisconnectReason,
) -> Result<(), Error> {
    let peer_id = peer_network_id.peer_id();
    
    // Remove health check data BEFORE disconnect to prevent races
    self.health_check_data.write().remove(&peer_id);
    
    let _ = self.update_connection_state(peer_network_id, ConnectionState::Disconnecting);
    let result = self
        .network_client
        .disconnect_from_peer(peer_network_id, disconnect_reason)
        .await;
    result
}
```

**Fix 3: Use atomic state transitions**

Combine the state update and data removal in a single atomic operation with proper locking.

## Proof of Concept

```rust
#[cfg(test)]
mod race_condition_test {
    use super::*;
    use futures::channel::oneshot;
    use std::sync::Arc;
    use tokio::sync::Mutex;
    
    #[tokio::test]
    async fn test_disconnect_race_condition() {
        // Setup health checker with mock network
        let (mut health_checker, mut mock_network) = setup_test_health_checker();
        
        let peer_id = PeerId::random();
        let peer_network_id = PeerNetworkId::new(NetworkId::Validator, peer_id);
        
        // 1. Add peer with failures
        health_checker.network_interface.create_peer_and_health_data(peer_id, 1);
        for _ in 0..4 {
            health_checker.network_interface.increment_peer_round_failure(peer_id, 1);
        }
        
        // Verify failures accumulated
        assert_eq!(health_checker.network_interface.get_peer_failures(peer_id), Some(4));
        
        // 2. Start disconnect operation
        let disconnect_handle = tokio::spawn(async move {
            health_checker.network_interface.disconnect_peer(
                peer_network_id,
                DisconnectReason::NetworkHealthCheckFailure
            ).await
        });
        
        // 3. Inject Ping message during disconnect window (simulate race)
        tokio::time::sleep(Duration::from_millis(10)).await;
        mock_network.inject_ping(peer_id, Ping(123));
        
        // 4. Wait for disconnect to complete
        let _ = disconnect_handle.await;
        
        // 5. Verify race occurred: 
        // If health_check_data was NOT cleaned up (disconnect failed),
        // failures would be reset to 0 instead of the original 4
        // This demonstrates the state inconsistency
    }
}
```

## Notes

While this race condition exists and violates state consistency invariants, the practical exploitability and security impact are limited. The disconnect operation still completes successfully in normal cases, preventing persistent unhealthy peer connections. The main issue is the architectural design where `ConnectionState` changes don't immediately affect message delivery in the network layer's `Peer` actor.

### Citations

**File:** network/framework/src/protocols/health_checker/interface.rs (L71-71)
```rust
        let _ = self.update_connection_state(peer_network_id, ConnectionState::Disconnecting);
```

**File:** network/framework/src/protocols/health_checker/interface.rs (L72-75)
```rust
        let result = self
            .network_client
            .disconnect_from_peer(peer_network_id, disconnect_reason)
            .await;
```

**File:** network/framework/src/protocols/health_checker/interface.rs (L77-79)
```rust
        if result.is_ok() {
            self.health_check_data.write().remove(&peer_id);
        }
```

**File:** network/framework/src/protocols/health_checker/interface.rs (L120-123)
```rust
    pub fn reset_peer_failures(&mut self, peer_id: PeerId) {
        if let Some(health_check_data) = self.health_check_data.write().get_mut(&peer_id) {
            health_check_data.failures = 0;
        }
```

**File:** network/framework/src/protocols/health_checker/mod.rs (L170-171)
```rust
            futures::select! {
                maybe_event = self.network_interface.next() => {
```

**File:** network/framework/src/protocols/health_checker/mod.rs (L180-182)
```rust
                        Event::RpcRequest(peer_id, msg, protocol, res_tx) => {
                            match msg {
                                HealthCheckerMsg::Ping(ping) => self.handle_ping_request(peer_id, ping, protocol, res_tx),
```

**File:** network/framework/src/protocols/health_checker/mod.rs (L303-303)
```rust
        self.network_interface.reset_peer_failures(peer_id);
```

**File:** network/framework/src/protocols/health_checker/mod.rs (L373-380)
```rust
                    if let Err(err) = timeout(
                        Duration::from_millis(50),
                        self.network_interface.disconnect_peer(
                            peer_network_id,
                            DisconnectReason::NetworkHealthCheckFailure,
                        ),
                    )
                    .await
```
