# Audit Report

## Title
TOCTOU Race Condition in Commit Notification Handler Causes Version-Timestamp Mismatch

## Summary
The `handle_committed_transactions()` function in `state-sync/state-sync-driver/src/utils.rs` fetches the pre-committed version and latest ledger info through two separate, non-atomic storage reads. Between these reads, a concurrent commit can update the state store to a new version while the ledger info remains at an older version, causing downstream components (mempool, storage service, event subscribers) to receive mismatched version and timestamp information.

## Finding Description

The vulnerability exists in the commit notification flow where `handle_committed_transactions()` performs two sequential reads from storage without atomicity guarantees: [1](#0-0) 

These two calls read from independent storage components:

1. `fetch_pre_committed_version()` reads from `state_store.current_state` (updated during `pre_commit_ledger`) [2](#0-1) 

2. `fetch_latest_synced_ledger_info()` reads from `metadata_db.latest_ledger_info` (updated during `commit_ledger` → `post_commit`) [3](#0-2) 

The commit process uses a two-phase protocol with separate locks:

**Pre-commit phase** updates the state store: [4](#0-3) 

**Commit phase** updates the ledger info in memory: [5](#0-4) 

The comment explicitly allows pre-committing and committing in concurrency: [6](#0-5) 

**Race Scenario:**
1. Version N-1 commits completely and sends commit notification
2. Version N pre-commits → `state_store.current_state` updates to version N
3. Handler processes N-1 notification:
   - `fetch_pre_committed_version()` returns N (pre-committed state)
   - `fetch_latest_synced_ledger_info()` returns ledger info for N-1
4. Handler passes version N with timestamp from version N-1 to:
   - Storage service via `notify_storage_service_of_committed_transactions(N)`
   - Mempool via `notify_mempool_of_committed_transactions(transactions, timestamp_N-1)`
   - Event subscribers via `notify_events(N, events)` [7](#0-6) 

This breaks the **State Consistency** invariant: components receive inconsistent version-timestamp pairs, causing:

- **Storage service**: Notified that version N is available when only N-1 was committed
- **Mempool**: Uses timestamp from N-1 for garbage collection decisions, potentially incorrectly expiring or retaining transactions
- **Event subscribers**: Receive events tagged with wrong version N instead of N-1, breaking version tracking

## Impact Explanation

This qualifies as **Medium Severity** under the Aptos bug bounty program ("State inconsistencies requiring intervention").

The mismatch causes operational inconsistencies across node components:

1. **Storage Service Inconsistency**: The storage service cache believes data up to version N is committed when only N-1 is fully committed with ledger info. This could cause the service to advertise availability of data that lacks committed ledger info metadata.

2. **Mempool Transaction Management**: Mempool's `gc_by_expiration_time()` uses the blockchain timestamp to determine which transactions have expired. With an incorrect (older) timestamp, mempool may:
   - Retain transactions that should have expired
   - Incorrectly calculate transaction lifetimes
   - Make wrong decisions about transaction prioritization

3. **Event Subscriber Confusion**: Event subscribers tracking versioning will associate events with incorrect versions, potentially causing:
   - Out-of-order event processing
   - Missed synchronization points
   - Application-level state inconsistencies

While this doesn't directly cause consensus violations or fund loss, it creates state inconsistencies across node subsystems that can accumulate and require manual intervention to resolve.

## Likelihood Explanation

**High likelihood** - This race condition can occur naturally during normal blockchain operation:

- No attacker action required
- Happens whenever a commit notification is processed concurrently with a new pre-commit
- Higher probability under high transaction throughput when commits happen rapidly
- All nodes are susceptible during normal operation
- The two-phase commit design explicitly allows concurrent pre-commit and commit operations

The race window is small (microseconds to milliseconds) but occurs frequently enough under load to manifest regularly.

## Recommendation

Implement atomic fetching of version and ledger info, or modify the commit notification to include the specific version being notified. Two approaches:

**Approach 1: Atomic Read (Recommended)**
```rust
// Add a new method to DbReader trait
fn get_committed_version_and_ledger_info(&self) -> Result<(Version, LedgerInfoWithSignatures)> {
    // Single atomic read of both values
    let ledger_info = self.get_latest_ledger_info()?;
    let version = ledger_info.ledger_info().version();
    Ok((version, ledger_info))
}

// Update handle_committed_transactions to use atomic read
pub async fn handle_committed_transactions<...>(...) {
    let (latest_synced_version, latest_synced_ledger_info) = 
        match storage.get_committed_version_and_ledger_info() {
            Ok((version, ledger_info)) => (version, ledger_info),
            Err(error) => {
                error!(...);
                return;
            }
        };
    // ... rest of function
}
```

**Approach 2: Pass Version in Notification**
Include the committed version in `CommittedTransactions` struct so the handler doesn't need to fetch it from storage.

**Approach 1 is preferred** as it ensures the version and ledger info are always consistent by reading them atomically from the committed ledger info itself.

## Proof of Concept

```rust
// Rust reproduction test (add to state-sync-driver/src/tests/)
#[tokio::test]
async fn test_toctou_race_in_commit_notifications() {
    use std::sync::Arc;
    use std::sync::atomic::{AtomicBool, Ordering};
    
    // Setup: Create mock storage where we can control read timing
    let storage = Arc::new(MockStorage::new());
    
    // Simulate the race:
    // 1. Set storage to version N-1 with matching ledger info
    storage.set_pre_committed_version(10);
    storage.set_ledger_info_version(10);
    
    // 2. Spawn handler that will read version first
    let race_flag = Arc::new(AtomicBool::new(false));
    let race_flag_clone = race_flag.clone();
    let storage_clone = storage.clone();
    
    let handle = tokio::spawn(async move {
        let version = storage_clone.get_pre_committed_version().unwrap();
        
        // Signal that we've read the version
        race_flag_clone.store(true, Ordering::SeqCst);
        
        // Wait a bit to simulate timing
        tokio::time::sleep(Duration::from_millis(10)).await;
        
        let ledger_info = storage_clone.get_latest_ledger_info().unwrap();
        
        (version, ledger_info.ledger_info().version())
    });
    
    // 3. After version is read, update state to version N
    while !race_flag.load(Ordering::SeqCst) {
        tokio::time::sleep(Duration::from_millis(1)).await;
    }
    
    storage.set_pre_committed_version(11);
    // Don't update ledger info yet (simulating pre-commit without commit)
    
    // 4. Verify mismatch
    let (fetched_version, ledger_info_version) = handle.await.unwrap();
    
    assert_eq!(fetched_version, 11, "Should read pre-committed version");
    assert_eq!(ledger_info_version, 10, "Should read old ledger info");
    assert_ne!(fetched_version, ledger_info_version, "RACE DETECTED: Version mismatch!");
}
```

## Notes

This vulnerability is triggered by the architectural decision to allow concurrent pre-committing and committing (two-phase protocol with separate locks). The race manifests during normal operation without requiring attacker action. The fix must ensure atomic consistency between the version and ledger info values used for notifications, either by reading them together from the committed ledger info, or by including version information directly in commit notifications.

### Citations

**File:** state-sync/state-sync-driver/src/utils.rs (L336-353)
```rust
    let (latest_synced_version, latest_synced_ledger_info) =
        match fetch_pre_committed_version(storage.clone()) {
            Ok(latest_synced_version) => match fetch_latest_synced_ledger_info(storage.clone()) {
                Ok(latest_synced_ledger_info) => (latest_synced_version, latest_synced_ledger_info),
                Err(error) => {
                    error!(LogSchema::new(LogEntry::SynchronizerNotification)
                        .error(&error)
                        .message("Failed to fetch latest synced ledger info!"));
                    return;
                },
            },
            Err(error) => {
                error!(LogSchema::new(LogEntry::SynchronizerNotification)
                    .error(&error)
                    .message("Failed to fetch latest synced version!"));
                return;
            },
        };
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L137-141)
```rust
    fn get_pre_committed_version(&self) -> Result<Option<Version>> {
        gauged_api("get_pre_committed_version", || {
            Ok(self.state_store.current_state_locked().version())
        })
    }
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L94-98)
```rust
    pub(crate) fn get_latest_ledger_info_option(&self) -> Option<LedgerInfoWithSignatures> {
        let ledger_info_ptr = self.latest_ledger_info.load();
        let ledger_info: &Option<_> = ledger_info_ptr.deref();
        ledger_info.clone()
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L46-49)
```rust
            // Pre-committing and committing in concurrency is allowed but not pre-committing at the
            // same time from multiple threads, the same for committing.
            // Consensus and state sync must hand over to each other after all pending execution and
            // committing complete.
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L68-72)
```rust
            self.state_store.buffered_state().lock().update(
                chunk.result_ledger_state_with_summary(),
                chunk.estimated_total_state_updates(),
                sync_commit || chunk.is_reconfig,
            )?;
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L662-669)
```rust
        if let Some(x) = ledger_info_with_sigs {
            self.ledger_db
                .metadata_db()
                .set_latest_ledger_info(x.clone());

            LEDGER_VERSION.set(x.ledger_info().version() as i64);
            NEXT_BLOCK_EPOCH.set(x.ledger_info().next_block_epoch() as i64);
        }
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L96-109)
```rust
        // Notify the storage service of the committed transactions
        storage_service_notification_handler
            .notify_storage_service_of_committed_transactions(latest_synced_version)
            .await?;

        // Notify mempool of the committed transactions
        mempool_notification_handler
            .notify_mempool_of_committed_transactions(transactions, blockchain_timestamp_usecs)
            .await?;

        // Notify the event subscription service of the events
        event_subscription_service
            .lock()
            .notify_events(latest_synced_version, events)?;
```
