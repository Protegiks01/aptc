# Audit Report

## Title
Unauthenticated Admin Service on Testnet Exposes Consensus State and Transaction Data

## Summary

The `optimize()` function in `admin_service_config.rs` automatically enables the admin service on all non-mainnet chains without authentication. [1](#0-0)  This service binds to `0.0.0.0` by default and exposes sensitive debugging endpoints that leak consensus state, pending transactions, and mempool data. [2](#0-1)  When testnet nodes handle real value or perform security-critical testing, this information disclosure enables front-running attacks, MEV extraction, and consensus analysis.

## Finding Description

The admin service configuration system has a **security-by-network-type** design flaw where authentication requirements only apply to mainnet:

1. **Automatic Enablement**: The `optimize()` function enables admin service by default for any `!chain_id.is_mainnet()` chain. [1](#0-0) 

2. **No Default Authentication**: The default `authentication_configs` is an empty vector, meaning no authentication. [2](#0-1) 

3. **Sanitizer Mainnet-Only**: The sanitizer only enforces authentication on mainnet, allowing testnet to run unauthenticated. [3](#0-2) 

4. **Authentication Bypass Logic**: When `authentication_configs` is empty, the service automatically sets `authenticated = true` without any checks. [4](#0-3) 

5. **Public Network Binding**: The service binds to `0.0.0.0:9102` by default, making it accessible from any network interface. [5](#0-4) 

**Exposed Sensitive Endpoints:**

- `/debug/consensus/consensusdb` - Exposes all consensus blocks, votes, quorum certificates, and timeout certificates [6](#0-5) 

- `/debug/consensus/block` - Extracts and returns full transaction contents from consensus blocks, including user transactions [7](#0-6) 

- `/debug/consensus/quorumstoredb` - Dumps quorum store batches containing pending transaction data [8](#0-7) 

- `/debug/mempool/parking-lot/addresses` - Reveals addresses with pending transactions in mempool [9](#0-8) 

**Attack Scenario:**
1. Attacker identifies testnet validator nodes handling pre-mainnet validation or bridged assets
2. Port scans discover open port 9102 (admin service)
3. Makes unauthenticated HTTP GET to `http://<testnet-node>:9102/debug/consensus/block`
4. Receives JSON response containing pending transaction data including signatures, payloads, and sequencing information
5. Uses information for front-running, MEV extraction, or privacy violations

## Impact Explanation

This qualifies as **Medium Severity** per Aptos bug bounty criteria for the following reasons:

**Information Disclosure Impact:**
- **Transaction Privacy Violation**: Exposes pending transaction contents before commitment, enabling front-running
- **Consensus Intelligence**: Reveals validator voting patterns, block proposals, and quorum certificates useful for planning consensus attacks
- **MEV Extraction**: Allows attackers to observe transaction ordering in the quorum store and exploit value extraction opportunities
- **Operational Security**: Leaks internal system state including mempool composition and consensus round information

**Conditional "Real Value" Scenario:**
The Medium severity applies specifically when testnet nodes handle:
- Pre-mainnet validation with actual staked assets
- Bridged testnet tokens with real-world value
- Security-critical testing of production transaction flows
- Staging environments mistakenly configured with testnet chain ID

In these scenarios, the information disclosure translates to **limited funds loss or manipulation**, meeting the Medium severity threshold.

## Likelihood Explanation

**High Likelihood in Target Scenarios:**

1. **Default Configuration**: The vulnerability is present in the default node configuration for all non-mainnet chains - no misconfiguration required

2. **Network Accessibility**: The `0.0.0.0` binding makes the service accessible from external networks unless firewalled at the infrastructure layer

3. **Discovery Simplicity**: Attackers can trivially scan common testnet node IP ranges for open port 9102

4. **No Authentication Required**: Exploitation requires only standard HTTP GET requests with no credentials

5. **Realistic Testnet Value Scenarios**: 
   - Projects commonly run "incentivized testnets" with token rewards
   - Bridge protocols may expose testnet endpoints handling wrapped mainnet assets
   - Security testing environments may use testnet chain IDs for convenience

**Mitigating Factors:**
- Legitimate testnet use (no real value) reduces impact to Low/Info severity
- Infrastructure-level firewalls may block external access to port 9102
- Documentation may warn against exposing admin service publicly

## Recommendation

**Immediate Fix - Enforce Authentication on All Networks:**

Modify the sanitizer to require authentication for admin service on ALL chains, not just mainnet: [10](#0-9) 

**Recommended Code Change:**
```rust
impl ConfigSanitizer for AdminServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();

        // SECURITY FIX: Require authentication on ALL networks when enabled
        if node_config.admin_service.enabled == Some(true) {
            if node_config.admin_service.authentication_configs.is_empty() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "AdminService requires authentication on all networks. Set authentication_configs or disable the service.".into(),
                ));
            }
        }

        Ok(())
    }
}
```

**Additional Hardening:**
1. Change default binding from `0.0.0.0` to `127.0.0.1` (localhost only)
2. Disable admin service by default on ALL networks (opt-in rather than opt-out)
3. Add rate limiting to admin service endpoints
4. Log all admin service access attempts for audit trails

## Proof of Concept

**Setup Testnet Node:**
```bash
# Start testnet node with default configuration
cargo run -p aptos-node -- --config testnet_node_config.yaml
```

**Exploit - Unauthenticated Access:**
```bash
# Dump consensus database without authentication
curl http://testnet-node-ip:9102/debug/consensus/consensusdb

# Extract pending transactions from blocks
curl "http://testnet-node-ip:9102/debug/consensus/block?bcs=false"

# Get mempool parking lot addresses
curl http://testnet-node-ip:9102/debug/mempool/parking-lot/addresses
```

**Expected Result:**
All endpoints return sensitive data without requiring any authentication, demonstrating the information disclosure vulnerability when testnet nodes handle real value or security-critical operations.

## Notes

**Scope Clarification:**
This vulnerability is rated Medium severity ONLY in the conditional scenario where testnet nodes handle real value or security-critical testing. For standard testnet usage (no real value), this would be Low/Informational severity as an operational security concern.

**Root Cause:**
The design assumes strict separation between mainnet (production) and testnet (no value), but real-world deployments often blur these boundaries during staging, security testing, and incentivized testnet programs. Security controls should not rely solely on network type for authentication decisions.

### Citations

**File:** config/src/config/admin_service_config.rs (L41-50)
```rust
impl Default for AdminServiceConfig {
    fn default() -> Self {
        Self {
            enabled: None,
            address: "0.0.0.0".to_string(),
            port: 9102,
            authentication_configs: vec![],
            malloc_stats_max_len: 2 * 1024 * 1024,
        }
    }
```

**File:** config/src/config/admin_service_config.rs (L59-82)
```rust
impl ConfigSanitizer for AdminServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();

        if node_config.admin_service.enabled == Some(true) {
            if let Some(chain_id) = chain_id {
                if chain_id.is_mainnet()
                    && node_config.admin_service.authentication_configs.is_empty()
                {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Must enable authentication for AdminService on mainnet.".into(),
                    ));
                }
            }
        }

        Ok(())
    }
}
```

**File:** config/src/config/admin_service_config.rs (L93-100)
```rust
        if node_config.admin_service.enabled.is_none() {
            // Only enable the admin service if the chain is not mainnet
            let admin_service_enabled = if let Some(chain_id) = chain_id {
                !chain_id.is_mainnet()
            } else {
                false // We cannot determine the chain ID, so we disable the admin service
            };
            node_config.admin_service.enabled = Some(admin_service_enabled);
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L154-157)
```rust
        let mut authenticated = false;
        if context.config.authentication_configs.is_empty() {
            authenticated = true;
        } else {
```

**File:** crates/aptos-admin-service/src/server/consensus/mod.rs (L130-156)
```rust
fn dump_consensus_db(consensus_db: &dyn PersistentLivenessStorage) -> anyhow::Result<String> {
    let mut body = String::new();

    let (last_vote, highest_tc, consensus_blocks, consensus_qcs) =
        consensus_db.consensus_db().get_data()?;

    body.push_str(&format!("Last vote: \n{last_vote:?}\n\n"));
    body.push_str(&format!("Highest tc: \n{highest_tc:?}\n\n"));
    body.push_str("Blocks: \n");
    for block in consensus_blocks {
        body.push_str(&format!(
            "[id: {:?}, author: {:?}, epoch: {}, round: {:02}, parent_id: {:?}, timestamp: {}, payload: {:?}]\n\n",
            block.id(),
            block.author(),
            block.epoch(),
            block.round(),
            block.parent_id(),
            block.timestamp_usecs(),
            block.payload(),
        ));
    }
    body.push_str("QCs: \n");
    for qc in consensus_qcs {
        body.push_str(&format!("{qc:?}\n\n"));
    }
    Ok(body)
}
```

**File:** crates/aptos-admin-service/src/server/consensus/mod.rs (L158-177)
```rust
fn dump_quorum_store_db(
    quorum_store_db: &dyn QuorumStoreStorage,
    digest: Option<HashValue>,
) -> anyhow::Result<String> {
    let mut body = String::new();

    if let Some(digest) = digest {
        body.push_str(&format!("{digest:?}:\n"));
        body.push_str(&format!(
            "{:?}",
            quorum_store_db.get_batch(&digest).map_err(Error::msg)?
        ));
    } else {
        for (digest, _batch) in quorum_store_db.get_all_batches()? {
            body.push_str(&format!("{digest:?}:\n"));
        }
    }

    Ok(body)
}
```

**File:** crates/aptos-admin-service/src/server/consensus/mod.rs (L179-215)
```rust
fn dump_blocks(
    consensus_db: &dyn PersistentLivenessStorage,
    quorum_store_db: &dyn QuorumStoreStorage,
    block_id: Option<HashValue>,
) -> anyhow::Result<String> {
    let mut body = String::new();

    let all_batches = quorum_store_db.get_all_batches()?;

    let (_, _, blocks, _) = consensus_db.consensus_db().get_data()?;

    for block in blocks {
        let id = block.id();
        if block_id.is_none() || id == block_id.unwrap() {
            body.push_str(&format!("Block ({id:?}): \n\n"));
            match extract_txns_from_block(&block, &all_batches) {
                Ok(txns) => {
                    body.push_str(&format!("{txns:?}"));
                },
                Err(e) => {
                    body.push_str(&format!("Not available: {e:?}"));
                },
            };
            body.push_str("\n\n");
        }
    }

    if body.is_empty() {
        if let Some(block_id) = block_id {
            body.push_str(&format!("Done, block ({block_id:?}) is not found."));
        } else {
            body.push_str("Done, no block is found.");
        }
    }

    Ok(body)
}
```

**File:** crates/aptos-admin-service/src/server/mempool/mod.rs (L12-38)
```rust
pub async fn mempool_handle_parking_lot_address_request(
    _req: Request<Body>,
    mempool_client_sender: MempoolClientSender,
) -> hyper::Result<Response<Body>> {
    match get_parking_lot_addresses(mempool_client_sender).await {
        Ok(addresses) => {
            info!("Finished getting parking lot addresses from mempool.");
            match bcs::to_bytes(&addresses) {
                Ok(addresses) => Ok(reply_with(vec![], addresses)),
                Err(e) => {
                    info!("Failed to bcs serialize parking lot addresses from mempool: {e:?}");
                    Ok(reply_with_status(
                        StatusCode::INTERNAL_SERVER_ERROR,
                        e.to_string(),
                    ))
                },
            }
        },
        Err(e) => {
            info!("Failed to get parking lot addresses from mempool: {e:?}");
            Ok(reply_with_status(
                StatusCode::INTERNAL_SERVER_ERROR,
                e.to_string(),
            ))
        },
    }
}
```
