# Audit Report

## Title
Feature Flag Bypass: Missing Variant Bytecode Verification Allows Enum Usage When `enable_enum_types` is Disabled

## Summary
The `FeatureVerifier` fails to check enum-related bytecode instructions (`PackVariant`, `UnpackVariant`, `TestVariant`, `MutBorrowVariantField`, `ImmBorrowVariantField`, and their generic variants) when the `enable_enum_types` feature flag is disabled. This allows modules to bypass feature flag enforcement by using variant bytecode operations on externally-defined enum types, even when on-chain governance has disabled enum functionality.

## Finding Description

The Move bytecode verifier's feature gating mechanism is inconsistent between different feature types. When examining the `FeatureVerifier` implementation, there is a critical asymmetry in how features are enforced:

**For `enable_function_values` feature** - all three layers are checked:
- Signature tokens: Rejects `SignatureToken::Function` types [1](#0-0) 

- Function handles: Rejects function attributes [2](#0-1) 

- Bytecode instructions: Rejects `PackClosure`, `PackClosureGeneric`, and `CallClosure` [3](#0-2) 

**For `enable_enum_types` feature** - only one layer is checked:
- Struct definitions: Rejects `StructFieldInformation::DeclaredVariants` [4](#0-3) 

- **Missing**: No verification of variant bytecode instructions (`PackVariant`, `PackVariantGeneric`, `UnpackVariant`, `UnpackVariantGeneric`, `TestVariant`, `TestVariantGeneric`, `MutBorrowVariantField`, `MutBorrowVariantFieldGeneric`, `ImmBorrowVariantField`, `ImmBorrowVariantFieldGeneric`)

These variant bytecode instructions are defined in the Move binary format: [5](#0-4) 

The verification flow shows that `FeatureVerifier` runs before type safety checks: [6](#0-5) 

**Attack Path:**
1. Module A publishes an enum type (e.g., `Color { Red, Blue, Green }`) when `enable_enum_types = true`
2. Governance disables `enable_enum_types` via on-chain governance to prevent new enum types [7](#0-6) 

3. Attacker publishes Module B containing:
   - No local `DeclaredVariants` struct definitions (bypasses struct definition check)
   - Variant bytecode instructions (`PackVariant`, `UnpackVariant`, etc.) referencing Module A's enum
   - These instructions pass through `verify_code()` unchecked [3](#0-2) 

4. Type safety verification passes because the external enum struct types are valid [8](#0-7) 

5. Module B successfully uses enum functionality despite the feature being disabled

## Impact Explanation

This vulnerability constitutes a **HIGH severity** issue under the Aptos bug bounty program for the following reasons:

1. **Significant Protocol Violation**: The feature flag system is a critical governance mechanism. Bypassing it undermines the protocol's ability to disable problematic features in response to discovered bugs or security issues.

2. **Governance Bypass**: On-chain governance decisions to disable features via `FeatureFlag::ENABLE_ENUM_TYPES` can be circumvented, violating the trust model that governance controls are enforceable.

3. **Consensus Risk**: During feature flag transitions or configuration drift scenarios, different validators might interpret module validity differently, potentially leading to state divergence.

4. **Security Model Violation**: Feature flags exist to enable/disable potentially risky functionality. Allowing bypass means security-critical features cannot be reliably disabled even after governance approval.

The production configuration explicitly gates enum types based on on-chain features: [9](#0-8) 

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability is readily exploitable because:

1. **Low Barrier to Entry**: Any module publisher can craft bytecode with variant instructions referencing external enums
2. **Clear Attack Vector**: The gap in verification is deterministic and reliable
3. **Realistic Scenario**: Governance may disable enum types if bugs are discovered in enum implementation, making bypass attacks practical
4. **No Special Privileges Required**: Standard module publication capabilities are sufficient

The main limiting factor is that external enum types must exist, but given Aptos's growing ecosystem, this is a realistic precondition.

## Recommendation

Add variant bytecode verification to `FeatureVerifier::verify_code()` to match the enforcement pattern used for function value bytecodes:

```rust
fn verify_code(&self, code: &[Bytecode], idx: Option<TableIndex>) -> PartialVMResult<()> {
    if !self.config.enable_function_values {
        for bc in code {
            if matches!(
                bc,
                Bytecode::PackClosure(..)
                    | Bytecode::PackClosureGeneric(..)
                    | Bytecode::CallClosure(..)
            ) {
                let mut err = PartialVMError::new(StatusCode::FEATURE_NOT_ENABLED);
                if let Some(idx) = idx {
                    err = err.at_index(IndexKind::FunctionDefinition, idx);
                }
                return Err(err.with_message("function value feature not enabled".to_string()));
            }
        }
    }
    
    // ADD THIS CHECK:
    if !self.config.enable_enum_types {
        for bc in code {
            if matches!(
                bc,
                Bytecode::PackVariant(..)
                    | Bytecode::PackVariantGeneric(..)
                    | Bytecode::UnpackVariant(..)
                    | Bytecode::UnpackVariantGeneric(..)
                    | Bytecode::TestVariant(..)
                    | Bytecode::TestVariantGeneric(..)
                    | Bytecode::MutBorrowVariantField(..)
                    | Bytecode::MutBorrowVariantFieldGeneric(..)
                    | Bytecode::ImmBorrowVariantField(..)
                    | Bytecode::ImmBorrowVariantFieldGeneric(..)
            ) {
                let mut err = PartialVMError::new(StatusCode::FEATURE_NOT_ENABLED);
                if let Some(idx) = idx {
                    err = err.at_index(IndexKind::FunctionDefinition, idx);
                }
                return Err(err.with_message("enum type feature not enabled".to_string()));
            }
        }
    }
    
    Ok(())
}
```

This ensures consistent feature gating across all enum-related operations, not just struct definitions.

## Proof of Concept

```rust
// Step 1: Create and publish Module A with enum when feature is enabled
module 0x1::module_a {
    enum Color {
        Red,
        Blue, 
        Green
    }
    
    public fun new_red(): Color {
        Color::Red
    }
}

// Step 2: Governance disables ENABLE_ENUM_TYPES feature flag
// (via on-chain governance proposal)

// Step 3: Craft malicious bytecode in Module B
// This would normally be blocked, but variant bytecode instructions
// are not checked by FeatureVerifier
module 0x1::module_b {
    use 0x1::module_a::Color;
    
    // This function compiles to PackVariant bytecode
    public fun create_color(): Color {
        Color::Blue  // Uses PackVariant instruction
    }
    
    // This function compiles to UnpackVariant bytecode
    public fun match_color(c: Color): u8 {
        match (c) {  // Uses UnpackVariant instruction
            Color::Red => 1,
            Color::Blue => 2,
            Color::Green => 3,
        }
    }
}

// Expected: Module B should be REJECTED because enum feature is disabled
// Actual: Module B is ACCEPTED because FeatureVerifier doesn't check variant bytecodes
// Impact: Feature flag bypass, governance decision undermined
```

The bytecode sequence for `create_color()` would include `PackVariant` instruction which passes through `FeatureVerifier::verify_code()` unchecked when `enable_enum_types = false`, violating the feature flag enforcement invariant.

### Citations

**File:** third_party/move/move-bytecode-verifier/src/features.rs (L77-82)
```rust
                        StructFieldInformation::DeclaredVariants(variants) => {
                            if !self.config.enable_enum_types {
                                return Err(PartialVMError::new(StatusCode::FEATURE_NOT_ENABLED)
                                    .at_index(IndexKind::StructDefinition, idx as u16)
                                    .with_message("enum type feature not enabled".to_string()));
                            }
```

**File:** third_party/move/move-bytecode-verifier/src/features.rs (L118-122)
```rust
                if !self.config.enable_function_values && !function_handle.attributes.is_empty() {
                    return Err(PartialVMError::new(StatusCode::FEATURE_NOT_ENABLED)
                        .at_index(IndexKind::FunctionDefinition, idx as u16)
                        .with_message("function value feature not enabled".to_string()));
                }
```

**File:** third_party/move/move-bytecode-verifier/src/features.rs (L139-157)
```rust
    fn verify_code(&self, code: &[Bytecode], idx: Option<TableIndex>) -> PartialVMResult<()> {
        if !self.config.enable_function_values {
            for bc in code {
                if matches!(
                    bc,
                    Bytecode::PackClosure(..)
                        | Bytecode::PackClosureGeneric(..)
                        | Bytecode::CallClosure(..)
                ) {
                    let mut err = PartialVMError::new(StatusCode::FEATURE_NOT_ENABLED);
                    if let Some(idx) = idx {
                        err = err.at_index(IndexKind::FunctionDefinition, idx);
                    }
                    return Err(err.with_message("function value feature not enabled".to_string()));
                }
            }
        }
        Ok(())
    }
```

**File:** third_party/move/move-bytecode-verifier/src/features.rs (L173-179)
```rust
    fn verify_signature_token(&self, tok: &SignatureToken) -> PartialVMResult<()> {
        if !self.config.enable_function_values && matches!(tok, SignatureToken::Function(..)) {
            Err(PartialVMError::new(StatusCode::FEATURE_NOT_ENABLED)
                .with_message("function value feature not enabled".to_string()))
        } else {
            Ok(())
        }
```

**File:** third_party/move/move-binary-format/src/file_format.rs (L1686-1695)
```rust
    PackVariant(StructVariantHandleIndex),

    #[group = "variant"]
    #[static_operands = "[struct_variant_inst_idx]"]
    #[description = "Generic version of `PackVariant`."]
    #[semantics = "See `PackVariant`."]
    #[runtime_check_epilogue = "See `PackVariant`."]
    #[gas_type_creation_tier_0 = "struct_ty"]
    #[gas_type_creation_tier_1 = "field_tys"]
    PackVariantGeneric(StructVariantInstantiationIndex),
```

**File:** third_party/move/move-bytecode-verifier/src/verifier.rs (L146-158)
```rust
        FeatureVerifier::verify_module(config, module)?;
        LimitsVerifier::verify_module(config, module)?;
        DuplicationChecker::verify_module(module)?;

        signature_v2::verify_module(config, module)?;

        InstructionConsistency::verify_module(module)?;
        constants::verify_module(module)?;
        friends::verify_module(module)?;

        RecursiveStructDefChecker::verify_module(module)?;
        InstantiationLoopChecker::verify_module(module)?;
        CodeUnitVerifier::verify_module(config, module)?;
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L145-194)
```rust
pub fn aptos_prod_verifier_config(gas_feature_version: u64, features: &Features) -> VerifierConfig {
    let sig_checker_v2_fix_script_ty_param_count =
        features.is_enabled(FeatureFlag::SIGNATURE_CHECKER_V2_SCRIPT_FIX);
    let sig_checker_v2_fix_function_signatures = gas_feature_version >= RELEASE_V1_34;
    let enable_enum_types = features.is_enabled(FeatureFlag::ENABLE_ENUM_TYPES);
    let enable_resource_access_control =
        features.is_enabled(FeatureFlag::ENABLE_RESOURCE_ACCESS_CONTROL);
    let enable_function_values = features.is_enabled(FeatureFlag::ENABLE_FUNCTION_VALUES);
    // Note: we reuse the `enable_function_values` flag to set various stricter limits on types.

    VerifierConfig {
        scope: VerificationScope::Everything,
        max_loop_depth: Some(5),
        max_generic_instantiation_length: Some(32),
        max_function_parameters: Some(128),
        max_basic_blocks: Some(1024),
        max_value_stack_size: 1024,
        max_type_nodes: if enable_function_values {
            Some(128)
        } else {
            Some(256)
        },
        max_push_size: Some(10000),
        max_struct_definitions: None,
        max_struct_variants: None,
        max_fields_in_struct: None,
        max_function_definitions: None,
        max_back_edges_per_function: None,
        max_back_edges_per_module: None,
        max_basic_blocks_in_script: None,
        max_per_fun_meter_units: Some(1000 * 80000),
        max_per_mod_meter_units: Some(1000 * 80000),
        _use_signature_checker_v2: true,
        sig_checker_v2_fix_script_ty_param_count,
        sig_checker_v2_fix_function_signatures,
        enable_enum_types,
        enable_resource_access_control,
        enable_function_values,
        max_function_return_values: if enable_function_values {
            Some(128)
        } else {
            None
        },
        max_type_depth: if enable_function_values {
            Some(20)
        } else {
            None
        },
    }
}
```

**File:** third_party/move/move-bytecode-verifier/src/type_safety.rs (L916-927)
```rust
        Bytecode::PackVariant(idx) => {
            let handle = verifier.resolver.struct_variant_handle_at(*idx)?;
            let struct_definition = verifier.resolver.struct_def_at(handle.struct_index)?;
            pack(
                verifier,
                meter,
                offset,
                struct_definition,
                Some(handle.variant),
                &Signature(vec![]),
            )?
        },
```
