# Audit Report

## Title
Missing Gas Schedule Parameter Validation Enables Network-Wide Liveness Failure

## Summary
The `generate_gas_upgrade_proposal()` function lacks validation to ensure all required gas parameters are present in the gas schedule before creating a governance proposal. Deploying an incomplete gas schedule causes all validators to fail transaction execution with `VM_STARTUP_FAILURE`, resulting in total network halt requiring hardfork recovery.

## Finding Description

The `generate_gas_upgrade_proposal()` function accepts a `GasScheduleV2` object and generates a governance proposal without validating parameter completeness. [1](#0-0) 

The function only validates transaction size and computes a hash diff, but does not verify that all required gas parameters exist in the schedule. [2](#0-1) 

The on-chain Move functions that process the proposal also lack completeness validation, with explicit TODO comments acknowledging this gap. [3](#0-2) [4](#0-3) 

The same TODO appears at multiple locations, indicating this validation gap was recognized but never implemented. [5](#0-4) 

**Attack Path:**
1. A governance proposal is created with an incomplete gas schedule missing critical parameters
2. Proposal passes governance voting and calls `set_for_next_epoch()` or `set_for_next_epoch_check_hash()`
3. The incomplete schedule is buffered and applied during epoch transition [6](#0-5) 
4. All subsequent transactions fail when the VM attempts to load gas parameters

The gas parameter loading uses `FromOnChainGasSchedule` trait, which returns an error if any required parameter is missing. [7](#0-6) [8](#0-7) 

This error is converted to `VM_STARTUP_FAILURE` during transaction validation. [9](#0-8) [10](#0-9) 

Since gas parameters are loaded in the validation path before transaction execution, ALL transactions (including governance proposals to fix the issue) are discarded, causing complete network halt.

## Impact Explanation

**Severity: CRITICAL** (up to $1,000,000 per bug bounty program)

This vulnerability qualifies as "Total loss of liveness/network availability" and "Non-recoverable network partition (requires hardfork)" because:

1. **Complete Network Halt**: All validators deterministically fail to execute ANY transaction with `VM_STARTUP_FAILURE`
2. **Self-Perpetuating**: Governance proposals to fix the issue cannot execute because they also require gas parameter loading during validation
3. **Requires Hardfork**: Recovery requires manual intervention using genesis transactions and database bootstrapping, coordinating all validators to restart with new waypoint
4. **Affects All Users**: No transactions can be processed - all transfers, contract calls, and governance operations are blocked
5. **Deterministic Failure**: All validators will exhibit identical behavior, maintaining consensus on the halted state

The existing test demonstrates this behavior by removing the "instr.add" parameter and verifying transactions are discarded with `VM_STARTUP_FAILURE`. [11](#0-10) 

## Likelihood Explanation

**Likelihood: LOW-MEDIUM**

This vulnerability can manifest through:

1. **Accidental Misconfiguration**: Developer error when generating gas schedules (copy-paste errors, incomplete parameter sets, script bugs)
2. **Software Bugs**: Automated gas schedule generation tools with bugs could produce incomplete schedules

The TODO comments at three locations in `gas_schedule.move` indicate developers were aware validation was needed but never implemented it, suggesting this was considered a real risk requiring defense-in-depth protection.

While governance participants are trusted, the missing validation creates risk when:
- Gas schedule generation tools contain bugs
- Copy-paste errors during manual schedule creation
- New feature versions add parameters that old tooling doesn't include
- Multiple governance participants fail to notice missing parameters during proposal review

The `diff()` function shows parameter deletions in proposal comments, which should alert reviewers, moderately reducing likelihood.

## Recommendation

Implement parameter completeness validation in multiple layers:

1. **In `generate_gas_upgrade_proposal()`**: Validate the new gas schedule against a canonical list of required parameters for the target feature version
2. **In Move framework**: Implement the TODO validation in `gas_schedule.move` at lines 47, 67, and 75 to check consistency before accepting proposals
3. **Add formal verification**: Use Move specifications to enforce gas schedule completeness as an invariant

Example validation logic:
```rust
// In generate_gas_upgrade_proposal()
fn validate_gas_schedule_completeness(schedule: &GasScheduleV2) -> Result<()> {
    let expected_params = AptosGasParameters::expected_parameter_names(schedule.feature_version);
    let actual_params: HashSet<_> = schedule.entries.iter().map(|(k, _)| k.as_str()).collect();
    
    for param in expected_params {
        if !actual_params.contains(param) {
            return Err(anyhow!("Missing required gas parameter: {}", param));
        }
    }
    Ok(())
}
```

## Proof of Concept

The vulnerability is demonstrated by the existing test case which removes a gas parameter and verifies that all subsequent transactions fail with `VM_STARTUP_FAILURE`. [11](#0-10) 

The test shows that when the "instr.add" parameter is removed from the gas schedule, transaction execution fails at the VM initialization stage, causing transactions to be discarded. This demonstrates the complete execution path from incomplete gas schedule to network halt.

## Notes

While governance participants are trusted roles, this vulnerability represents a critical gap in defense-in-depth protections. The explicit TODO comments at multiple locations indicate the developers recognized this validation should exist. Systems handling network-critical configuration should validate inputs even from trusted sources to prevent catastrophic failures from accidental errors or tool bugs.

### Citations

**File:** aptos-move/aptos-release-builder/src/components/gas.rs (L80-155)
```rust
pub fn generate_gas_upgrade_proposal(
    old_gas_schedule: Option<&GasScheduleV2>,
    new_gas_schedule: &GasScheduleV2,
    is_testnet: bool,
    next_execution_hash: Option<HashValue>,
    is_multi_step: bool,
) -> Result<Vec<(String, String)>> {
    let signer_arg = get_signer_arg(is_testnet, &next_execution_hash);
    let mut result = vec![];

    let writer = CodeWriter::new(Loc::default());

    emitln!(
        writer,
        "// Source commit hash: {}",
        aptos_build_info::get_git_hash()
    );
    emitln!(writer);

    emitln!(writer, "// Gas schedule upgrade proposal");

    let old_hash = match old_gas_schedule {
        Some(old_gas_schedule) => {
            let old_bytes = bcs::to_bytes(old_gas_schedule)?;
            let old_hash = hex::encode(Sha3_512::digest(old_bytes.as_slice()));
            emitln!(writer, "//");
            emitln!(writer, "// Old Gas Schedule Hash (Sha3-512): {}", old_hash);

            emit_gas_schedule_diff(&writer, old_gas_schedule, new_gas_schedule)?;

            Some(old_hash)
        },
        None => None,
    };
    emitln!(writer, "//");
    emit_full_gas_schedule(&writer, new_gas_schedule)?;

    let proposal = generate_governance_proposal(
        &writer,
        is_testnet,
        next_execution_hash,
        is_multi_step,
        &["aptos_framework::gas_schedule"],
        |writer| {
            let gas_schedule_blob = bcs::to_bytes(new_gas_schedule).unwrap();
            assert!(gas_schedule_blob.len() < 65536);

            emit!(writer, "let gas_schedule_blob: vector<u8> = ");
            generate_blob_as_hex_string(writer, &gas_schedule_blob);
            emitln!(writer, ";");
            emitln!(writer);

            match old_hash {
                Some(old_hash) => {
                    emitln!(
                        writer,
                        "gas_schedule::set_for_next_epoch_check_hash({}, x\"{}\", gas_schedule_blob);",
                        signer_arg,
                        old_hash,
                    );
                },
                None => {
                    emitln!(
                        writer,
                        "gas_schedule::set_for_next_epoch({}, gas_schedule_blob);",
                        signer_arg
                    );
                },
            }
            emitln!(writer, "aptos_governance::reconfigure({});", signer_arg);
        },
    );

    result.push(("gas-schedule".to_string(), proposal));
    Ok(result)
}
```

**File:** types/src/on_chain_config/gas_schedule.rs (L66-92)
```rust
    pub fn diff<'a>(old: &'a Self, new: &'a Self) -> BTreeMap<&'a str, DiffItem<u64>> {
        let mut old = old.to_btree_map_borrowed();
        let new = new.to_btree_map_borrowed();

        let mut diff = BTreeMap::new();
        for (param_name, new_val) in new {
            match old.entry(param_name) {
                btree_map::Entry::Occupied(entry) => {
                    let (param_name, old_val) = entry.remove_entry();

                    if old_val != new_val {
                        diff.insert(param_name, DiffItem::Modify { old_val, new_val });
                    }
                },
                btree_map::Entry::Vacant(entry) => {
                    let param_name = entry.into_key();
                    diff.insert(param_name, DiffItem::Add { new_val });
                },
            }
        }
        diff.extend(
            old.into_iter()
                .map(|(param_name, old_val)| (param_name, DiffItem::Delete { old_val })),
        );

        diff
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L43-50)
```text
    public(friend) fun initialize(aptos_framework: &signer, gas_schedule_blob: vector<u8>) {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));

        // TODO(Gas): check if gas schedule is consistent
        let gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        move_to<GasScheduleV2>(aptos_framework, gas_schedule);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L57-77)
```text
    public fun set_gas_schedule(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasSchedule, GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        chain_status::assert_genesis();

        if (exists<GasScheduleV2>(@aptos_framework)) {
            let gas_schedule = borrow_global_mut<GasScheduleV2>(@aptos_framework);
            let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
            assert!(new_gas_schedule.feature_version >= gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION));
            // TODO(Gas): check if gas schedule is consistent
            *gas_schedule = new_gas_schedule;
        }
        else {
            if (exists<GasSchedule>(@aptos_framework)) {
                _ = move_from<GasSchedule>(@aptos_framework);
            };
            let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
            // TODO(Gas): check if gas schedule is consistent
            move_to<GasScheduleV2>(aptos_framework, new_gas_schedule);
        };
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L135-145)
```text
    public(friend) fun on_new_epoch(framework: &signer) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(framework);
        if (config_buffer::does_exist<GasScheduleV2>()) {
            let new_gas_schedule = config_buffer::extract_v2<GasScheduleV2>();
            if (exists<GasScheduleV2>(@aptos_framework)) {
                *borrow_global_mut<GasScheduleV2>(@aptos_framework) = new_gas_schedule;
            } else {
                move_to(framework, new_gas_schedule);
            }
        }
    }
```

**File:** aptos-move/aptos-gas-schedule/src/traits.rs (L7-15)
```rust
pub trait FromOnChainGasSchedule: Sized {
    /// Constructs a value of this type from a map representation of the on-chain gas schedule.
    /// `None` should be returned when the gas schedule is missing some required entries.
    /// Unused entries should be safely ignored.
    fn from_on_chain_gas_schedule(
        gas_schedule: &BTreeMap<String, u64>,
        feature_version: u64,
    ) -> Result<Self, String>;
}
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L32-46)
```rust
        impl $crate::traits::FromOnChainGasSchedule for $params_name {
            #[allow(unused)]
            fn from_on_chain_gas_schedule(gas_schedule: &std::collections::BTreeMap<String, u64>, feature_version: u64) -> Result<Self, String> {
                let mut params = $params_name::zeros();

                $(
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        let name = format!("{}.{}", $prefix, key);
                        params.$name = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?.into();
                    }
                )*

                Ok(params)
            }
        }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L273-282)
```rust
pub(crate) fn get_or_vm_startup_failure<'a, T>(
    gas_params: &'a Result<T, String>,
    log_context: &AdapterLogSchema,
) -> Result<&'a T, VMStatus> {
    gas_params.as_ref().map_err(|err| {
        let msg = format!("VM Startup Failed. {}", err);
        speculative_error!(log_context, msg.clone());
        VMStatus::error(StatusCode::VM_STARTUP_FAILURE, Some(msg))
    })
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3250-3260)
```rust
        let vm_params = match self.gas_params(&log_context) {
            Ok(vm_params) => vm_params.vm.clone(),
            Err(err) => {
                return VMValidatorResult::new(Some(err.status_code()), 0);
            },
        };
        let storage_gas_params = match self.storage_gas_params(&log_context) {
            Ok(storage_params) => storage_params.clone(),
            Err(err) => {
                return VMValidatorResult::new(Some(err.status_code()), 0);
            },
```

**File:** aptos-move/e2e-move-tests/src/tests/missing_gas_parameter.rs (L8-28)
```rust
#[test]
fn missing_gas_parameter() {
    let mut h = MoveHarness::new();

    h.modify_gas_schedule_raw(|gas_schedule| {
        let idx = gas_schedule
            .entries
            .iter()
            .position(|(key, _val)| key == "instr.add")
            .unwrap();
        gas_schedule.entries.remove(idx);
    });

    // Load the code
    let acc = h.new_account_with_balance_at(AccountAddress::from_hex_literal("0xbeef").unwrap(), 0);
    let txn_status = h.publish_package(&acc, &common::test_dir_path("common.data/do_nothing"));
    assert!(matches!(
        txn_status,
        TransactionStatus::Discard(StatusCode::VM_STARTUP_FAILURE)
    ))
}
```
