# Audit Report

## Title
Namespace Collision Vulnerability in VaultStorage Enables Unauthorized Cryptographic Key Access

## Summary
The `VaultStorage` implementation in `secure/storage/src/vault.rs` uses a simple string replacement to transform namespaced key names for Vault's Transit backend, replacing all occurrences of `"/"` with `"__"`. This creates collisions where two logically distinct keys with different namespaces can map to the same Vault Transit key name, enabling unauthorized access to cryptographic keys across namespace boundaries.

## Finding Description

The vulnerability exists in the interaction between the `Namespaced` wrapper and `VaultStorage`'s key name transformation: [1](#0-0) [2](#0-1) 

The `Namespaced` wrapper constructs fully qualified key names using the format `"namespace/keyname"`: [3](#0-2) 

When these namespaced keys reach `VaultStorage`, the `crypto_name()` function transforms them for Vault's Transit backend by replacing ALL occurrences of `"/"` with `"__"`: [4](#0-3) 

This transformation is used across all cryptographic operations: [5](#0-4) [6](#0-5) 

**The collision occurs because:**

Using `str::replace()` replaces ALL occurrences of the separator, not just the namespace boundary. If either the namespace or key name contains the target separator (`"__"`), collisions occur:

**Collision Example 1:**
- Key A: namespace `"validator"`, keyname `"1__consensus"` → `"validator/1__consensus"` → `"validator__1__consensus"`
- Key B: namespace `"validator__1"`, keyname `"consensus"` → `"validator__1/consensus"` → `"validator__1__consensus"`
- **Both map to the same Vault Transit key: `"validator__1__consensus"`**

**Collision Example 2:**
- Key A: namespace `"safety"`, keyname `"rules__key"` → `"safety/rules__key"` → `"safety__rules__key"`
- Key B: namespace `"safety__rules"`, keyname `"key"` → `"safety__rules/key"` → `"safety__rules__key"`
- **Both map to the same Vault Transit key: `"safety__rules__key"`**

In a multi-tenant Vault deployment where different validators or services use different namespaces, a malicious or misconfigured service could choose a namespace that collides with another service's keys, gaining unauthorized access to cryptographic material including validator private keys and consensus safety rules.

## Impact Explanation

This vulnerability qualifies as **High Severity** under Aptos bug bounty criteria for the following reasons:

1. **Validator Node Security Compromise**: Unauthorized access to validator private keys could allow an attacker to:
   - Sign malicious blocks or votes
   - Compromise consensus safety if safety rules keys are accessed
   - Impersonate validators

2. **Access Control Violation**: The fundamental security invariant that namespace separation provides cryptographic key isolation is broken. Different logical entities (validators, services, components) that should have isolated key storage can access each other's keys.

3. **Consensus Protocol Impact**: If consensus-critical keys (validator signing keys, safety rules state) are compromised through namespace collision, it could lead to:
   - Safety violations in AptosBFT
   - Equivocation by validators
   - Chain splits or consensus deadlock

4. **Multi-Tenant Risk**: In production deployments where multiple validators or services share a Vault instance (common for cost efficiency or operational simplicity), this creates a cross-tenant security boundary violation.

While this requires specific preconditions (namespace misconfiguration or deliberate malicious namespace selection), the impact on validator security and potential consensus violations justifies High severity classification.

## Likelihood Explanation

**Likelihood: Medium to High** depending on deployment configuration:

**More Likely Scenarios:**
1. **Multi-tenant Vault deployments**: Organizations running multiple validators or services sharing a single Vault instance
2. **Namespace misconfiguration**: Accidental use of `"__"` in namespace names during setup
3. **Dynamic namespace generation**: If namespaces are programmatically generated and not properly validated

**Less Likely Scenarios:**
1. Single-tenant Vault per validator (but still vulnerable to internal service collisions)
2. Environments with strict namespace validation policies

**Attacker Requirements:**
- Ability to configure a namespace (e.g., deploying a new validator or service)
- Knowledge of target namespace/key structure
- Access to the shared Vault infrastructure

The likelihood increases significantly in production environments where operational complexity and multi-tenancy are common, making this a realistic attack vector.

## Recommendation

**Immediate Fix**: Replace the naive string replacement with a proper escaping mechanism that only transforms the namespace separator at the boundary, not within namespace or key names.

**Recommended Implementation:**

```rust
fn crypto_name(&self, name: &str) -> String {
    // Split only on the first occurrence to separate namespace from key
    // Then escape any "__" in the original parts before joining
    if let Some((namespace, key)) = name.split_once(NAMESPACE_SEPARATOR) {
        let escaped_ns = namespace.replace(TRANSIT_NAMESPACE_SEPARATOR, "___");
        let escaped_key = key.replace(TRANSIT_NAMESPACE_SEPARATOR, "___");
        format!("{}{}{}", escaped_ns, TRANSIT_NAMESPACE_SEPARATOR, escaped_key)
    } else {
        // No namespace, just escape the key
        name.replace(TRANSIT_NAMESPACE_SEPARATOR, "___")
    }
}
```

**Alternative Fix**: Use a different separator strategy:
- Use a separator that's guaranteed not to appear in namespace/key names (e.g., non-printable character)
- Implement base64 or hex encoding for the entire namespaced key
- Add validation to reject namespace/key names containing `"__"`

**Additional Hardening:**
1. Add validation in `Namespaced::new()` to reject namespaces containing `"__"`
2. Add validation in `VaultStorage` key creation to reject key names containing `"__"`
3. Add collision detection by maintaining a registry of transformed key names
4. Document the restriction in configuration files and validation logic

## Proof of Concept

```rust
#[cfg(test)]
mod namespace_collision_test {
    use super::*;
    use aptos_crypto::ed25519::Ed25519PrivateKey;
    use aptos_secure_storage::{Namespaced, Storage, VaultStorage};

    #[test]
    fn test_namespace_collision_vulnerability() {
        // Setup: Create a VaultStorage instance (requires running Vault for full test)
        // For demonstration, we'll show the key transformation collision
        
        let vault = VaultStorage::new(
            "http://localhost:8200".to_string(),
            "test-token".to_string(),
            None,
            None,
            true,
            None,
            None,
        );

        // Scenario 1: Two different namespaced keys
        // Key A: namespace "validator", key "1__consensus"
        let key_a = "validator/1__consensus";
        let transformed_a = vault.crypto_name(key_a);
        
        // Key B: namespace "validator__1", key "consensus"  
        let key_b = "validator__1/consensus";
        let transformed_b = vault.crypto_name(key_b);
        
        // VULNERABILITY: Both transform to the same Vault key
        assert_eq!(transformed_a, "validator__1__consensus");
        assert_eq!(transformed_b, "validator__1__consensus");
        assert_eq!(transformed_a, transformed_b); // COLLISION!
        
        println!("COLLISION DETECTED:");
        println!("Key A: {} -> {}", key_a, transformed_a);
        println!("Key B: {} -> {}", key_b, transformed_b);
        println!("Both keys map to the same Vault Transit key!");
        
        // In a real attack:
        // 1. Validator 1 creates key with namespace "validator", keyname "1__consensus"
        // 2. Attacker creates namespace "validator__1" and requests key "consensus"
        // 3. Attacker gains access to Validator 1's private key
        // 4. Attacker can now sign as Validator 1, compromising consensus
    }

    #[test]
    fn test_multiple_collision_vectors() {
        let vault = VaultStorage::new(
            "http://localhost:8200".to_string(),
            "test-token".to_string(),
            None,
            None,
            true,
            None,
            None,
        );

        // Test various collision scenarios
        let test_cases = vec![
            ("a/b__c", "a__b/c"),           // namespace vs key separator
            ("x/y__z__w", "x__y/z__w"),     // multiple separators
            ("safety/rules__key", "safety__rules/key"), // realistic names
        ];

        for (key1, key2) in test_cases {
            let transformed1 = vault.crypto_name(key1);
            let transformed2 = vault.crypto_name(key2);
            assert_eq!(transformed1, transformed2,
                "Collision: {} and {} both map to {}",
                key1, key2, transformed1);
        }
    }
}
```

**Notes:**
- This vulnerability is a design flaw in the namespace transformation logic that exists in production code
- It affects all cryptographic operations: key creation, signing, key export, and rotation
- The fix requires careful consideration to maintain backward compatibility with existing keys while preventing future collisions
- Immediate mitigation: Validate all namespace configurations to ensure they don't contain `"__"` and audit existing namespaces for potential collisions

### Citations

**File:** secure/storage/src/namespaced.rs (L11-11)
```rust
pub const NAMESPACE_SEPARATOR: &str = "/";
```

**File:** secure/storage/src/namespaced.rs (L45-47)
```rust
    fn namespaced(&self, name: &str) -> String {
        format!("{}{}{}", self.namespace, NAMESPACE_SEPARATOR, name)
    }
```

**File:** secure/storage/src/vault.rs (L24-24)
```rust
const TRANSIT_NAMESPACE_SEPARATOR: &str = "__";
```

**File:** secure/storage/src/vault.rs (L135-137)
```rust
    fn crypto_name(&self, name: &str) -> String {
        name.replace(NAMESPACE_SEPARATOR, TRANSIT_NAMESPACE_SEPARATOR)
    }
```

**File:** secure/storage/src/vault.rs (L194-203)
```rust
    fn create_key(&mut self, name: &str) -> Result<Ed25519PublicKey, Error> {
        let ns_name = self.crypto_name(name);
        match self.get_public_key(name) {
            Ok(_) => return Err(Error::KeyAlreadyExists(ns_name)),
            Err(Error::KeyNotSet(_)) => (/* Expected this for new keys! */),
            Err(e) => return Err(e),
        }

        self.client().create_ed25519_key(&ns_name, true)?;
        self.get_public_key(name).map(|v| v.public_key)
```

**File:** secure/storage/src/vault.rs (L206-209)
```rust
    fn export_private_key(&self, name: &str) -> Result<Ed25519PrivateKey, Error> {
        let name = self.crypto_name(name);
        Ok(self.client().export_ed25519_key(&name, None)?)
    }
```
