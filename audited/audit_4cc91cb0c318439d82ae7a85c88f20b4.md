# Audit Report

## Title
Signature Mismatch Vulnerability in Consensus Signing Phase Due to Missing LedgerInfo Verification

## Summary
The `SigningPhase::process()` method extracts a cached signature from `commit_vote_fut` without verifying that it corresponds to the `commit_ledger_info` in the current request. This allows signatures signed over one `LedgerInfo` to be incorrectly paired with a different `LedgerInfo`, breaking cryptographic correctness and causing invalid commit votes to be broadcast to validators.

## Finding Description

The vulnerability exists in the consensus pipeline's signing phase where cached signatures are reused without validation. The attack flow exploits a race condition in how `LedgerInfo` objects are constructed at different stages:

**Stage 1 - Pipeline Execution** [1](#0-0) 

During block execution, `sign_and_broadcast_commit_vote()` creates a `LedgerInfo` with a `consensus_data_hash` determined by whichever future completes first (`order_vote_rx`, `order_proof_fut`, or `commit_proof_fut`). When `order_vote_enabled` is false and `order_vote_rx` completes first, the `consensus_data_hash` is set to `HashValue::zero()`. [2](#0-1) 

**Stage 2 - Buffer Manager Processing** [3](#0-2) 

Later, when `advance_to_executed_or_aggregated()` is called, `generate_commit_ledger_info()` creates a different `LedgerInfo` where the `consensus_data_hash` always comes from `ordered_proof.ledger_info().consensus_data_hash()` when `order_vote_enabled` is false. [4](#0-3) 

**Stage 3 - Signature Misuse** [5](#0-4) 

When `SigningPhase::process()` receives a signing request, if cached pipeline futures exist, it extracts the signature from `commit_vote_fut` (signed over LedgerInfo_A with `HashValue::zero()`) without verifying it matches the `commit_ledger_info` in the request (LedgerInfo_B with `ordered_proof`'s hash). The signature is then returned paired with the wrong `LedgerInfo`.

**Stage 4 - Invalid Vote Creation** [6](#0-5) 

The buffer manager receives this mismatched signature and creates a `CommitVote` pairing signature_A (for LedgerInfo_A) with LedgerInfo_B. [7](#0-6) 

This violates the **Cryptographic Correctness** invariant: "BLS signatures, VRF, and hash operations must be secure" and the **Consensus Safety** invariant by producing cryptographically invalid commit votes.

## Impact Explanation

**Severity: High** (up to $50,000 per Aptos Bug Bounty criteria)

This qualifies as a **Significant Protocol Violation**:

1. **Consensus Liveness Degradation**: Invalid commit votes are rejected by other validators during signature verification [8](#0-7) , causing votes to be discarded and requiring retransmission. If multiple validators are affected simultaneously, this can significantly delay or prevent consensus rounds from completing.

2. **Resource Waste**: Validators spend CPU cycles generating, signing, broadcasting, and verifying cryptographically invalid commit votes, wasting network bandwidth and computational resources across the validator network.

3. **Cryptographic Integrity Violation**: The fundamental guarantee that signatures correspond to the data they claim to sign is broken, undermining trust in the consensus protocol's cryptographic foundations.

While other validators correctly reject these invalid votes (preventing safety violations), the liveness impact and protocol violation meet High severity criteria.

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability triggers through a race condition that can occur naturally during normal consensus operation:

1. **Configuration Dependency**: Only occurs when `order_vote_enabled` is false, which may be a common configuration in production deployments.

2. **Timing-Dependent**: The race window exists between when `order_vote_rx` is sent [9](#0-8)  and when `order_proof_fut` completes. Network latency variations or high validator load can widen this window.

3. **No Attacker Control Required**: Unlike vulnerabilities requiring specific malicious input, this race condition occurs naturally due to timing variations in consensus message propagation and processing.

4. **Deterministic Manifestation**: Once the race condition occurs (order vote received before order proof during pipeline execution), the invalid signature pairing is deterministic and guaranteed to happen.

## Recommendation

Add explicit verification in `SigningPhase::process()` to ensure the cached signature corresponds to the current `commit_ledger_info`:

```rust
async fn process(&self, req: SigningRequest) -> SigningResponse {
    let SigningRequest {
        ordered_ledger_info,
        commit_ledger_info,
        blocks,
    } = req;

    let signature_result = if let Some(fut) = blocks
        .last()
        .expect("Blocks can't be empty")
        .pipeline_futs()
    {
        fut.commit_vote_fut
            .clone()
            .await
            .and_then(|vote| {
                // CRITICAL FIX: Verify the cached vote's LedgerInfo matches the request
                if vote.ledger_info() != &commit_ledger_info {
                    return Err(TaskError::InternalError(Arc::new(anyhow::anyhow!(
                        "Cached commit vote LedgerInfo mismatch: expected {}, got {}",
                        commit_ledger_info.commit_info(),
                        vote.ledger_info().commit_info()
                    ))));
                }
                Ok(vote.signature().clone())
            })
            .map_err(|e| Error::InternalError(e.to_string()))
    } else {
        self.safety_rule_handle
            .sign_commit_vote(ordered_ledger_info, commit_ledger_info.clone())
    };

    SigningResponse {
        signature_result,
        commit_ledger_info,
    }
}
```

If the verification fails, the code should fall back to the safety rules path to generate a fresh signature for the correct `commit_ledger_info`.

## Proof of Concept

```rust
// Reproduction steps in Rust:
// This demonstrates the race condition leading to signature mismatch

#[tokio::test]
async fn test_signature_mismatch_race_condition() {
    // Setup: Create a test environment with order_vote_enabled = false
    let order_vote_enabled = false;
    
    // Step 1: Simulate pipeline execution where order_vote_rx completes first
    // In sign_and_broadcast_commit_vote, this sets consensus_data_hash to zero
    let consensus_data_hash_in_pipeline = HashValue::zero(); // From order_vote_rx
    let ledger_info_a = LedgerInfo::new(block_info.clone(), consensus_data_hash_in_pipeline);
    let signature_a = signer.sign(&ledger_info_a).unwrap();
    let cached_commit_vote = CommitVote::new_with_signature(author, ledger_info_a, signature_a);
    
    // Step 2: Simulate buffer manager creating partial_commit_proof
    // In generate_commit_ledger_info, this uses ordered_proof's hash (not zero)
    let consensus_data_hash_in_buffer = ordered_proof.ledger_info().consensus_data_hash();
    assert_ne!(consensus_data_hash_in_pipeline, consensus_data_hash_in_buffer);
    let ledger_info_b = LedgerInfo::new(block_info.clone(), consensus_data_hash_in_buffer);
    
    // Step 3: SigningPhase extracts signature from cached vote
    let extracted_signature = cached_commit_vote.signature().clone();
    
    // Step 4: Create CommitVote with mismatched signature and ledger info
    let invalid_commit_vote = CommitVote::new_with_signature(
        author,
        ledger_info_b, // Different LedgerInfo than what signature_a was signed for
        extracted_signature, // Signature for ledger_info_a
    );
    
    // Step 5: Verification fails - proves the signature mismatch
    let result = invalid_commit_vote.verify(author, &validator_verifier);
    assert!(result.is_err(), "Verification should fail due to signature mismatch");
    assert!(result.unwrap_err().to_string().contains("Failed to verify"));
}
```

## Notes

The vulnerability is rooted in an implicit assumption that `commit_vote_fut`'s `LedgerInfo` will always match the `commit_ledger_info` in the `SigningRequest`. This assumption is violated due to:

1. **Different Timing**: `commit_vote_fut` is created during pipeline execution, while `partial_commit_proof` is created later in buffer manager processing.

2. **Different Logic**: The consensus_data_hash derivation uses racing futures in one path versus deterministic ordered_proof lookup in the other.

3. **Missing Validation**: The else path (lines 90-91) properly validates through safety rules [10](#0-9) , but the if path (lines 84-88) skips all validation.

This represents a critical gap in defensive programming where cached cryptographic material is reused without verification of its validity for the current context.

### Citations

**File:** consensus/src/pipeline/pipeline_builder.rs (L978-1029)
```rust
    async fn sign_and_broadcast_commit_vote(
        ledger_update_fut: TaskFuture<LedgerUpdateResult>,
        order_vote_rx: oneshot::Receiver<()>,
        order_proof_fut: TaskFuture<WrappedLedgerInfo>,
        commit_proof_fut: TaskFuture<LedgerInfoWithSignatures>,
        signer: Arc<ValidatorSigner>,
        block: Arc<Block>,
        order_vote_enabled: bool,
        network_sender: Arc<NetworkSender>,
    ) -> TaskResult<CommitVoteResult> {
        let mut tracker = Tracker::start_waiting("sign_commit_vote", &block);
        let (compute_result, _, epoch_end_timestamp) = ledger_update_fut.await?;
        let mut consensus_data_hash = select! {
            Ok(_) = order_vote_rx => {
                HashValue::zero()
            }
            Ok(li) = order_proof_fut => {
                li.ledger_info().ledger_info().consensus_data_hash()
            }
            Ok(li) = commit_proof_fut => {
                li.ledger_info().consensus_data_hash()
            }
            else => {
                return Err(anyhow!("all receivers dropped"))?;
            }
        };
        if order_vote_enabled {
            consensus_data_hash = HashValue::zero();
        }
        tracker.start_working();

        let mut block_info = block.gen_block_info(
            compute_result.root_hash(),
            compute_result.last_version_or_0(),
            compute_result.epoch_state().clone(),
        );
        if let Some(timestamp) = epoch_end_timestamp {
            info!(
                "[Pipeline] update block timestamp from {} to epoch end timestamp {}",
                block_info.timestamp_usecs(),
                timestamp
            );
            block_info.change_timestamp(timestamp);
        }
        let ledger_info = LedgerInfo::new(block_info, consensus_data_hash);
        info!("[Pipeline] Signed ledger info {ledger_info}");
        let signature = signer.sign(&ledger_info).expect("Signing should succeed");
        let commit_vote = CommitVote::new_with_signature(signer.author(), ledger_info, signature);
        network_sender
            .broadcast_commit_vote(commit_vote.clone())
            .await;
        Ok(commit_vote)
```

**File:** consensus/src/pipeline/buffer_item.rs (L25-38)
```rust
fn generate_commit_ledger_info(
    commit_info: &BlockInfo,
    ordered_proof: &LedgerInfoWithSignatures,
    order_vote_enabled: bool,
) -> LedgerInfo {
    LedgerInfo::new(
        commit_info.clone(),
        if order_vote_enabled {
            HashValue::zero()
        } else {
            ordered_proof.ledger_info().consensus_data_hash()
        },
    )
}
```

**File:** consensus/src/pipeline/buffer_item.rs (L159-163)
```rust
                    let commit_ledger_info = generate_commit_ledger_info(
                        &commit_info,
                        &ordered_proof,
                        order_vote_enabled,
                    );
```

**File:** consensus/src/pipeline/buffer_item.rs (L207-211)
```rust
                let commit_vote = CommitVote::new_with_signature(
                    author,
                    partial_commit_proof.data().clone(),
                    signature,
                );
```

**File:** consensus/src/pipeline/signing_phase.rs (L79-92)
```rust
        let signature_result = if let Some(fut) = blocks
            .last()
            .expect("Blocks can't be empty")
            .pipeline_futs()
        {
            fut.commit_vote_fut
                .clone()
                .await
                .map(|vote| vote.signature().clone())
                .map_err(|e| Error::InternalError(e.to_string()))
        } else {
            self.safety_rule_handle
                .sign_commit_vote(ordered_ledger_info, commit_ledger_info.clone())
        };
```

**File:** consensus/src/pipeline/buffer_manager.rs (L694-731)
```rust
    async fn process_signing_response(&mut self, response: SigningResponse) {
        let SigningResponse {
            signature_result,
            commit_ledger_info,
        } = response;
        let signature = match signature_result {
            Ok(sig) => sig,
            Err(e) => {
                error!("Signing failed {:?}", e);
                return;
            },
        };
        info!(
            "Receive signing response {}",
            commit_ledger_info.commit_info()
        );
        // find the corresponding item, may not exist if a reset or aggregated happened
        let current_cursor = self
            .buffer
            .find_elem_by_key(self.signing_root, commit_ledger_info.commit_info().id());
        if current_cursor.is_some() {
            let item = self.buffer.take(&current_cursor);
            // it is possible that we already signed this buffer item (double check after the final integration)
            if item.is_executed() {
                // we have found the buffer item
                let mut signed_item = item.advance_to_signed(self.author, signature);
                let signed_item_mut = signed_item.unwrap_signed_mut();
                let commit_vote = signed_item_mut.commit_vote.clone();
                let commit_vote = Self::generate_commit_message(commit_vote);
                signed_item_mut.rb_handle = self
                    .do_reliable_broadcast(commit_vote)
                    .map(|handle| (Instant::now(), handle));
                self.buffer.set(&current_cursor, signed_item);
            } else {
                self.buffer.set(&current_cursor, item);
            }
        }
    }
```

**File:** consensus-types/src/pipeline/commit_vote.rs (L103-113)
```rust

```

**File:** consensus/src/round_manager.rs (L1683-1683)
```rust
                    let _ = tx.order_vote_tx.take().map(|tx| tx.send(()));
```

**File:** consensus/safety-rules/src/safety_rules.rs (L372-418)
```rust
    fn guarded_sign_commit_vote(
        &mut self,
        ledger_info: LedgerInfoWithSignatures,
        new_ledger_info: LedgerInfo,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;

        let old_ledger_info = ledger_info.ledger_info();

        if !old_ledger_info.commit_info().is_ordered_only()
            // When doing fast forward sync, we pull the latest blocks and quorum certs from peers
            // and store them in storage. We then compute the root ordered cert and root commit cert
            // from storage and start the consensus from there. But given that we are not storing the
            // ordered cert obtained from order votes in storage, instead of obtaining the root ordered cert
            // from storage, we set root ordered cert to commit certificate.
            // This means, the root ordered cert will not have a dummy executed_state_id in this case.
            // To handle this, we do not raise error if the old_ledger_info.commit_info() matches with
            // new_ledger_info.commit_info().
            && old_ledger_info.commit_info() != new_ledger_info.commit_info()
        {
            return Err(Error::InvalidOrderedLedgerInfo(old_ledger_info.to_string()));
        }

        if !old_ledger_info
            .commit_info()
            .match_ordered_only(new_ledger_info.commit_info())
        {
            return Err(Error::InconsistentExecutionResult(
                old_ledger_info.commit_info().to_string(),
                new_ledger_info.commit_info().to_string(),
            ));
        }

        // Verify that ledger_info contains at least 2f + 1 dostinct signatures
        if !self.skip_sig_verify {
            ledger_info
                .verify_signatures(&self.epoch_state()?.verifier)
                .map_err(|error| Error::InvalidQuorumCertificate(error.to_string()))?;
        }

        // TODO: add guarding rules in unhappy path
        // TODO: add extension check

        let signature = self.sign(&new_ledger_info)?;

        Ok(signature)
    }
```
