# Audit Report

## Title
Incomplete Transaction Hash Index Deletion During Database Truncation Leading to Orphaned Hash Entries

## Summary
During database truncation operations, the `delete_transaction_index_data()` function only processes up to 2 million transactions when deleting hash indices from `TransactionByHashSchema`, while `delete_transactions_and_transaction_summary_data()` deletes ALL transactions from `TransactionSchema` without limit. This inconsistency leaves orphaned hash entries pointing to deleted transactions, causing `get_transaction_by_hash()` to fail with `NotFound` errors.

## Finding Description
The vulnerability exists in the database truncation logic, which violates the **State Consistency** invariant that requires atomic state transitions. [1](#0-0) 

The `delete_transaction_index_data()` function retrieves only `MAX_COMMIT_PROGRESS_DIFFERENCE * 2 = 2,000,000` transactions to process for hash index deletion. [2](#0-1) 

However, the subsequent `delete_transactions_and_transaction_summary_data()` function deletes ALL transactions from the target version onwards without any limit: [3](#0-2) 

When `get_transaction_by_hash()` is called for a transaction beyond the first 2 million:
1. `get_transaction_version_by_hash()` successfully finds the version in `TransactionByHashSchema` (orphaned index entry)
2. `get_transaction_with_proof()` attempts to retrieve the transaction at that version
3. `get_transaction()` fails with `AptosDbError::NotFound` because the transaction was deleted from `TransactionSchema` [4](#0-3) [5](#0-4) [6](#0-5) [7](#0-6) 

Note that the normal pruning path in `TransactionPruner` is correctly implemented and calls both deletion functions properly: [8](#0-7) 

## Impact Explanation
**Medium Severity** - This issue causes state inconsistencies requiring intervention. Specifically:

- **API Failures**: Hash-based transaction lookups return unexpected `NotFound` errors for transactions that should exist according to the hash index
- **Database Integrity**: Violates the invariant that indices must remain synchronized with their underlying data
- **User Experience**: Breaks transaction history queries and API reliability for clients using hash-based lookups
- **Operational Impact**: Requires manual database cleanup or reindexing to fix the inconsistent state

This matches the Medium Severity category: "State inconsistencies requiring intervention" per the Aptos bug bounty program.

## Likelihood Explanation
**Low-Medium Likelihood** in production:

- Requires database truncation with > 2 million transactions to delete
- Truncation is an administrative operation performed during node maintenance/recovery
- Not triggered during normal operation (normal pruning path is correct)
- Requires privileged node operator access to execute truncation
- However, when it occurs, it definitively creates the described inconsistency

The bug is deterministic when triggered under the specified conditions.

## Recommendation
Modify `delete_transaction_index_data()` to process ALL transactions that will be deleted, not just the first 2 million. Options:

**Option 1**: Process transactions in batches until all are handled:
```rust
fn delete_transaction_index_data(
    ledger_db: &LedgerDb,
    transaction_store: &TransactionStore,
    start_version: Version,
    batch: &mut SchemaBatch,
) -> Result<()> {
    let mut current_version = start_version;
    loop {
        let transactions = ledger_db
            .transaction_db()
            .get_transaction_iter(current_version, MAX_COMMIT_PROGRESS_DIFFERENCE as usize * 2)?
            .collect::<Result<Vec<_>>>()?;
        
        let num_txns = transactions.len();
        if num_txns == 0 {
            break;
        }
        
        ledger_db
            .transaction_db()
            .prune_transaction_by_hash_indices(transactions.iter().map(|txn| txn.hash()), batch)?;
        
        let transactions = (current_version..=current_version + transactions.len() as u64 - 1)
            .zip(transactions)
            .collect::<Vec<_>>();
        transaction_store.prune_transaction_by_account(&transactions, batch)?;
        transaction_store.prune_transaction_summaries_by_account(&transactions, batch)?;
        
        current_version += num_txns as u64;
    }
    
    Ok(())
}
```

**Option 2**: Determine the actual range of transactions to delete and ensure complete processing:
```rust
fn delete_transaction_index_data(
    ledger_db: &LedgerDb,
    transaction_store: &TransactionStore,
    start_version: Version,
    batch: &mut SchemaBatch,
) -> Result<()> {
    // Determine the latest version first
    let latest_version = match ledger_db.transaction_db().db().iter::<TransactionSchema>()?.seek_to_last().next().transpose()? {
        Some((version, _)) => version,
        None => return Ok(()),
    };
    
    if latest_version < start_version {
        return Ok(());
    }
    
    // Process all transactions in batches
    let mut current_version = start_version;
    while current_version <= latest_version {
        let batch_size = std::cmp::min(
            MAX_COMMIT_PROGRESS_DIFFERENCE as usize * 2,
            (latest_version - current_version + 1) as usize
        );
        
        let transactions = ledger_db
            .transaction_db()
            .get_transaction_iter(current_version, batch_size)?
            .collect::<Result<Vec<_>>>()?;
        
        if transactions.is_empty() {
            break;
        }
        
        ledger_db
            .transaction_db()
            .prune_transaction_by_hash_indices(transactions.iter().map(|txn| txn.hash()), batch)?;
        
        let versioned_transactions = (current_version..current_version + transactions.len() as u64)
            .zip(transactions)
            .collect::<Vec<_>>();
        transaction_store.prune_transaction_by_account(&versioned_transactions, batch)?;
        transaction_store.prune_transaction_summaries_by_account(&versioned_transactions, batch)?;
        
        current_version += versioned_transactions.len() as u64;
    }
    
    Ok(())
}
```

## Proof of Concept

```rust
use aptos_storage_interface::DbReader;
use aptos_crypto::hash::CryptoHash;
use aptos_types::transaction::Version;

// Test demonstrating the vulnerability
#[test]
fn test_truncation_orphaned_hash_indices() {
    // Setup: Create a test database with > 2 million transactions
    let tmp_dir = TempPath::new();
    let db = AptosDB::new_for_test(&tmp_dir);
    
    // Commit 3 million transactions
    const NUM_TXNS: usize = 3_000_000;
    let mut all_txns = Vec::new();
    
    for i in 0..NUM_TXNS {
        let txn = create_test_transaction(i);
        all_txns.push(txn);
    }
    
    db.ledger_db.transaction_db()
        .commit_transactions(0, &all_txns, false)
        .unwrap();
    
    // Store hashes of transactions beyond 2M for verification
    let hash_at_2_5m = all_txns[2_500_000].hash();
    
    // Verify transaction is accessible via hash before truncation
    let version = db.ledger_db.transaction_db()
        .get_transaction_version_by_hash(&hash_at_2_5m, NUM_TXNS as Version)
        .unwrap();
    assert_eq!(version, Some(2_500_000));
    
    let txn = db.ledger_db.transaction_db()
        .get_transaction(2_500_000)
        .unwrap();
    assert_eq!(txn.hash(), hash_at_2_5m);
    
    // Trigger truncation to version 0 (delete all transactions)
    truncate_ledger_db(Arc::new(db.ledger_db.clone()), 0).unwrap();
    
    // BUG: Hash index still exists for transaction at 2.5M
    let orphaned_version = db.ledger_db.transaction_db()
        .get_transaction_version_by_hash(&hash_at_2_5m, NUM_TXNS as Version)
        .unwrap();
    assert_eq!(orphaned_version, Some(2_500_000)); // Hash index remains!
    
    // But transaction itself is deleted
    let result = db.ledger_db.transaction_db()
        .get_transaction(2_500_000);
    assert!(result.is_err()); // NotFound error
    
    // This breaks get_transaction_by_hash() API
    let result = db.get_transaction_by_hash(hash_at_2_5m, NUM_TXNS as Version, false);
    // Will fail with NotFound when trying to retrieve the transaction
    assert!(result.is_err());
}
```

## Notes
The vulnerability specifically affects the truncation code path, not the regular pruning operations. The `TransactionPruner` correctly calls both deletion functions in the proper order. This is a database maintenance operation bug that manifests during node recovery or manual database rollback scenarios.

### Citations

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L363-392)
```rust
fn delete_transaction_index_data(
    ledger_db: &LedgerDb,
    transaction_store: &TransactionStore,
    start_version: Version,
    batch: &mut SchemaBatch,
) -> Result<()> {
    let transactions = ledger_db
        .transaction_db()
        .get_transaction_iter(start_version, MAX_COMMIT_PROGRESS_DIFFERENCE as usize * 2)?
        .collect::<Result<Vec<_>>>()?;
    let num_txns = transactions.len();
    if num_txns > 0 {
        info!(
            start_version = start_version,
            latest_version = start_version + num_txns as u64 - 1,
            "Truncate transaction index data."
        );
        ledger_db
            .transaction_db()
            .prune_transaction_by_hash_indices(transactions.iter().map(|txn| txn.hash()), batch)?;

        let transactions = (start_version..=start_version + transactions.len() as u64 - 1)
            .zip(transactions)
            .collect::<Vec<_>>();
        transaction_store.prune_transaction_by_account(&transactions, batch)?;
        transaction_store.prune_transaction_summaries_by_account(&transactions, batch)?;
    }

    Ok(())
}
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L464-492)
```rust
fn delete_transactions_and_transaction_summary_data(
    transaction_db: &TransactionDb,
    start_version: Version,
    batch: &mut SchemaBatch,
) -> Result<()> {
    let mut iter = transaction_db.db().iter::<TransactionSchema>()?;
    iter.seek_to_last();
    if let Some((latest_version, _)) = iter.next().transpose()? {
        if latest_version >= start_version {
            info!(
                start_version = start_version,
                latest_version = latest_version,
                cf_name = TransactionSchema::COLUMN_FAMILY_NAME,
                "Truncate per version data."
            );
            for version in start_version..=latest_version {
                let transaction = transaction_db.get_transaction(version)?;
                batch.delete::<TransactionSchema>(&version)?;
                if let Some(signed_txn) = transaction.try_as_signed_user_txn() {
                    batch.delete::<TransactionSummariesByAccountSchema>(&(
                        signed_txn.sender(),
                        version,
                    ))?;
                }
            }
        }
    }
    Ok(())
}
```

**File:** storage/aptosdb/src/state_store/mod.rs (L107-107)
```rust
pub const MAX_COMMIT_PROGRESS_DIFFERENCE: u64 = 1_000_000;
```

**File:** storage/aptosdb/src/ledger_db/transaction_db.rs (L55-60)
```rust
    /// Returns signed transaction given its `version`.
    pub(crate) fn get_transaction(&self, version: Version) -> Result<Transaction> {
        self.db
            .get::<TransactionSchema>(&version)?
            .ok_or_else(|| AptosDbError::NotFound(format!("Txn {version}")))
    }
```

**File:** storage/aptosdb/src/ledger_db/transaction_db.rs (L73-83)
```rust
    /// Returns the version of a transaction given its hash.
    pub(crate) fn get_transaction_version_by_hash(
        &self,
        hash: &HashValue,
        ledger_version: Version,
    ) -> Result<Option<Version>> {
        Ok(match self.db.get::<TransactionByHashSchema>(hash)? {
            Some(version) if version <= ledger_version => Some(version),
            _ => None,
        })
    }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L232-245)
```rust
    fn get_transaction_by_hash(
        &self,
        hash: HashValue,
        ledger_version: Version,
        fetch_events: bool,
    ) -> Result<Option<TransactionWithProof>> {
        gauged_api("get_transaction_by_hash", || {
            self.ledger_db
                .transaction_db()
                .get_transaction_version_by_hash(&hash, ledger_version)?
                .map(|v| self.get_transaction_with_proof(v, ledger_version, fetch_events))
                .transpose()
        })
    }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L1068-1100)
```rust
    pub(super) fn get_transaction_with_proof(
        &self,
        version: Version,
        ledger_version: Version,
        fetch_events: bool,
    ) -> Result<TransactionWithProof> {
        self.error_if_ledger_pruned("Transaction", version)?;

        let proof = self
            .ledger_db
            .transaction_info_db()
            .get_transaction_info_with_proof(
                version,
                ledger_version,
                self.ledger_db.transaction_accumulator_db(),
            )?;

        let transaction = self.ledger_db.transaction_db().get_transaction(version)?;

        // If events were requested, also fetch those.
        let events = if fetch_events {
            Some(self.ledger_db.event_db().get_events_by_version(version)?)
        } else {
            None
        };

        Ok(TransactionWithProof {
            version,
            transaction,
            events,
            proof,
        })
    }
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/transaction_pruner.rs (L37-74)
```rust
    fn prune(&self, current_progress: Version, target_version: Version) -> Result<()> {
        let mut batch = SchemaBatch::new();
        let candidate_transactions =
            self.get_pruning_candidate_transactions(current_progress, target_version)?;
        self.ledger_db
            .transaction_db()
            .prune_transaction_by_hash_indices(
                candidate_transactions.iter().map(|(_, txn)| txn.hash()),
                &mut batch,
            )?;
        self.ledger_db.transaction_db().prune_transactions(
            current_progress,
            target_version,
            &mut batch,
        )?;
        self.transaction_store
            .prune_transaction_summaries_by_account(&candidate_transactions, &mut batch)?;
        batch.put::<DbMetadataSchema>(
            &DbMetadataKey::TransactionPrunerProgress,
            &DbMetadataValue::Version(target_version),
        )?;
        if let Some(indexer_db) = self.internal_indexer_db.as_ref() {
            if indexer_db.transaction_enabled() {
                let mut index_batch = SchemaBatch::new();
                self.transaction_store
                    .prune_transaction_by_account(&candidate_transactions, &mut index_batch)?;
                index_batch.put::<InternalIndexerMetadataSchema>(
                    &IndexerMetadataKey::TransactionPrunerProgress,
                    &IndexerMetadataValue::Version(target_version),
                )?;
                indexer_db.get_inner_db_ref().write_schemas(index_batch)?;
            } else {
                self.transaction_store
                    .prune_transaction_by_account(&candidate_transactions, &mut batch)?;
            }
        }
        self.ledger_db.transaction_db().write_schemas(batch)
    }
```
