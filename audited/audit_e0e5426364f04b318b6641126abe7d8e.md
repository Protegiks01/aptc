# Audit Report

## Title
Critical Network Liveness Failure Due to Unimplemented Cross-Shard Transaction Rollback Mechanism

## Summary
The Aptos sharded block executor lacks a complete rollback mechanism for cross-shard transactions. When a transaction on one shard aborts, the system panics instead of properly notifying dependent shards, causing network-wide deadlock and total loss of liveness.

## Finding Description

The cross-shard transaction execution protocol in Aptos uses a `CrossShardCommitSender` to coordinate state updates across shards. When a transaction successfully commits, it sends `RemoteTxnWriteMsg` messages to dependent shards via the `on_transaction_committed` callback. [1](#0-0) 

However, when a transaction needs to abort/rollback, the `on_execution_aborted` method is called by the block executor, which contains only an unimplemented `todo!()` macro: [2](#0-1) 

This causes a **panic** when any transaction aborts during sharded execution. The block executor explicitly calls this hook when transactions encounter fatal errors: [3](#0-2) 

**The Attack Flow:**

1. **Shard A** executes transactions with cross-shard dependencies on **Shard B**
2. For each dependency, a `RemoteStateValue` is created in **Waiting** state [4](#0-3) 
3. Transactions in **Shard A** block on `get_value()`, waiting for cross-shard data [5](#0-4) 
4. A transaction on **Shard B** encounters a fatal VM error and enters `ExecutionStatus::Abort` state [6](#0-5) 
5. The block executor calls `on_execution_aborted()` on the `CrossShardCommitSender`
6. **The shard immediately panics** due to the `todo!()` macro
7. **Shard A never receives abort notifications** and remains blocked indefinitely in the condvar wait
8. **Network-wide deadlock:** Block execution cannot complete, preventing consensus finalization

The protocol design anticipates sending `RemoteTxnWriteMsg` with `write_op: None` for aborted transactions: [7](#0-6) 

But this mechanism is never invoked because the implementation panics before any abort messages can be sent.

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under the Aptos bug bounty program because it causes:

1. **Total loss of liveness/network availability:** Once triggered, the sharded executor panics and dependent shards deadlock, preventing any further block execution
2. **Non-recoverable network partition:** The deadlock cannot be resolved without manual intervention (node restart)
3. **Consensus disruption:** Block finalization cannot proceed, halting the entire blockchain

The sharded block executor is used in production when configured via `num_executor_shards > 0`: [8](#0-7) 

## Likelihood Explanation

**Likelihood: HIGH in production environments using sharded execution**

The vulnerability triggers whenever:
- The sharded block executor is enabled (production configurations with `num_executor_shards > 0`)
- ANY transaction in any shard encounters `ExecutionStatus::Abort`

While the VM wrapper comments suggest `Abort` should only occur for system transactions (BlockMetadata, Genesis) that "should never fail," in practice:
- VM bugs or corrupted state can cause unexpected fatal errors
- Edge cases in Move bytecode execution may trigger abort conditions
- The defensive `todo!()` proves the developers anticipated this scenario

The `todo!()` macro itself proves this code path is reachableâ€”otherwise it would not be present. The fact it remains unimplemented in production-ready code indicates either:
1. Insufficient testing of error paths in sharded execution
2. Underestimation of the likelihood of transaction aborts

## Recommendation

Implement proper rollback notification by sending `RemoteTxnWriteMsg` with `write_op: None` to all dependent shards when a transaction aborts:

```rust
fn on_execution_aborted(&self, txn_idx: TxnIndex) {
    let global_txn_idx = txn_idx + self.index_offset;
    if let Some(edges) = self.dependent_edges.get(&global_txn_idx) {
        for (state_key, dependent_shard_ids) in edges.iter() {
            for (dependent_shard_id, round_id) in dependent_shard_ids.iter() {
                trace!("Sending abort notification for shard id {:?} and txn_idx: {:?}, state_key: {:?}, dependent shard id: {:?}", 
                    self.shard_id, global_txn_idx, state_key, dependent_shard_id);
                let message = RemoteTxnWriteMsg(RemoteTxnWrite::new(
                    state_key.clone(),
                    None, // None indicates transaction aborted
                ));
                if *round_id == GLOBAL_ROUND_ID {
                    self.cross_shard_client.send_global_msg(message);
                } else {
                    self.cross_shard_client.send_cross_shard_msg(
                        *dependent_shard_id,
                        *round_id,
                        message,
                    );
                }
            }
        }
    }
}
```

Additionally, ensure dependent shards properly handle `None` write operations by checking the value and handling abort semantics correctly in the transaction execution logic.

## Proof of Concept

```rust
#[test]
fn test_cross_shard_abort_deadlock() {
    use crate::sharded_block_executor::{
        cross_shard_client::{CrossShardClient, CrossShardCommitSender},
        messages::{CrossShardMsg, RemoteTxnWrite},
    };
    use aptos_types::block_executor::partitioner::{ShardId, RoundId};
    use std::sync::{Arc, Mutex};
    use std::collections::HashMap;
    
    // Create a mock cross-shard client that tracks sent messages
    struct MockCrossShardClient {
        messages: Arc<Mutex<Vec<(ShardId, RoundId, CrossShardMsg)>>>,
    }
    
    impl CrossShardClient for MockCrossShardClient {
        fn send_global_msg(&self, _msg: CrossShardMsg) {}
        fn send_cross_shard_msg(&self, shard_id: ShardId, round: RoundId, msg: CrossShardMsg) {
            self.messages.lock().unwrap().push((shard_id, round, msg));
        }
        fn receive_cross_shard_msg(&self, _current_round: RoundId) -> CrossShardMsg {
            unimplemented!()
        }
    }
    
    // Create a sub-block with cross-shard dependencies
    let sub_block = create_test_sub_block_with_dependencies();
    let mock_client = Arc::new(MockCrossShardClient {
        messages: Arc::new(Mutex::new(Vec::new())),
    });
    
    let commit_sender = CrossShardCommitSender::new(0, mock_client.clone(), &sub_block);
    
    // This should panic with "on_transaction_aborted not supported for sharded execution yet"
    // Instead of properly notifying dependent shards
    std::panic::catch_unwind(|| {
        commit_sender.on_execution_aborted(0);
    }).expect_err("Should panic with todo!()");
    
    // Verify no abort messages were sent to dependent shards
    assert!(mock_client.messages.lock().unwrap().is_empty(), 
            "No abort notifications sent - dependent shards will deadlock");
}
```

This test demonstrates that when `on_execution_aborted` is called, the system panics instead of notifying dependent shards, leaving them in a deadlocked state waiting for cross-shard values that will never arrive.

---

**Notes:**
The explicit `todo!()` macro indicates this is a known incomplete implementation rather than a hidden bug. However, the security impact remains **Critical** because:
- The code is reachable in production when sharded execution is enabled
- The failure mode causes immediate network-wide liveness loss
- The defensive nature of the `todo!()` suggests transaction aborts are anticipated but unhandled

This represents a critical gap between the protocol design (which includes abort handling via `write_op: None`) and the actual implementation (which panics on abort).

### Citations

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L138-147)
```rust
    fn on_transaction_committed(
        &self,
        txn_idx: TxnIndex,
        txn_output: &OnceCell<TransactionOutput>,
    ) {
        let global_txn_idx = txn_idx + self.index_offset;
        if self.dependent_edges.contains_key(&global_txn_idx) {
            self.send_remote_update_for_success(global_txn_idx, txn_output);
        }
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L149-151)
```rust
    fn on_execution_aborted(&self, _txn_idx: TxnIndex) {
        todo!("on_transaction_aborted not supported for sharded execution yet")
    }
```

**File:** aptos-move/block-executor/src/executor.rs (L2237-2240)
```rust
                ExecutionStatus::Abort(err) => {
                    if let Some(commit_hook) = &self.transaction_commit_hook {
                        commit_hook.on_execution_aborted(idx as TxnIndex);
                    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/remote_state_value.rs (L16-20)
```rust
    pub fn waiting() -> Self {
        Self {
            value_condition: Arc::new((Mutex::new(RemoteValueStatus::Waiting), Condvar::new())),
        }
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/remote_state_value.rs (L29-39)
```rust
    pub fn get_value(&self) -> Option<StateValue> {
        let (lock, cvar) = &*self.value_condition;
        let mut status = lock.lock().unwrap();
        while let RemoteValueStatus::Waiting = *status {
            status = cvar.wait(status).unwrap();
        }
        match &*status {
            RemoteValueStatus::Ready(value) => value.clone(),
            RemoteValueStatus::Waiting => unreachable!(),
        }
    }
```

**File:** aptos-move/aptos-vm/src/block_executor/vm_wrapper.rs (L99-114)
```rust
            // execute_single_transaction only returns an error when transactions that should never fail
            // (BlockMetadataTransaction and GenesisTransaction) return an error themselves.
            Err(err) => {
                if err.status_code() == StatusCode::SPECULATIVE_EXECUTION_ABORT_ERROR {
                    ExecutionStatus::SpeculativeExecutionAbortError(
                        err.message().cloned().unwrap_or_default(),
                    )
                } else if err.status_code()
                    == StatusCode::DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR
                {
                    ExecutionStatus::DelayedFieldsCodeInvariantError(
                        err.message().cloned().unwrap_or_default(),
                    )
                } else {
                    ExecutionStatus::Abort(err)
                }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/messages.rs (L13-18)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RemoteTxnWrite {
    state_key: StateKey,
    // The write op is None if the transaction is aborted.
    write_op: Option<WriteOp>,
}
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L256-276)
```rust
    fn execute_block_sharded<V: VMBlockExecutor>(
        partitioned_txns: PartitionedTransactions,
        state_view: Arc<CachedStateView>,
        onchain_config: BlockExecutorConfigFromOnchain,
    ) -> Result<Vec<TransactionOutput>> {
        if !get_remote_addresses().is_empty() {
            Ok(V::execute_block_sharded(
                &REMOTE_SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        } else {
            Ok(V::execute_block_sharded(
                &SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        }
    }
```
