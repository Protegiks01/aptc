# Audit Report

## Title
Race Condition in Faucet Sequence Number Management Causing Service Disruption via Wait Timeout Exploitation

## Summary
The Aptos faucet's `submit_transaction()` function contains a race condition where sequence numbers are unconditionally decremented on any error, including when transactions have already been accepted into mempool. This allows attackers to poison the faucet's sequence number state by triggering timeouts during the transaction wait phase, causing service disruption and repeated transaction failures.

## Finding Description

The vulnerability exists in the transaction submission flow where sequence numbers are managed incorrectly across error boundaries. The critical issue occurs in this sequence:

1. **Sequence Number Increment (Before Submission)**: When `sign_with_transaction_builder()` is called, it increments the LocalAccount's sequence number BEFORE the transaction is submitted. [1](#0-0) 

2. **Transaction Submission**: The signed transaction is passed to `submit_transaction()` with `wait_for_transactions=true`. [2](#0-1) 

3. **Two-Phase Submission with Race Window**: The function calls `submit_and_wait_bcs()` which has two distinct phases: [3](#0-2) 
   - Phase 1: `submit_bcs()` - Submits transaction to API and waits for mempool acceptance
   - Phase 2: `wait_for_signed_transaction_bcs()` - Polls for transaction completion

4. **Critical Race Condition**: If `submit_bcs()` succeeds (transaction is in mempool with sequence number N), but `wait_for_signed_transaction_bcs()` fails due to timeout or server lag, the error is propagated back. [4](#0-3) 

5. **Unconditional Sequence Number Decrement**: The error handler ALWAYS decrements the sequence number without checking whether the transaction was accepted into mempool. [5](#0-4) 

6. **Sequence Number Collision**: The transaction with sequence number N remains in mempool while the LocalAccount is rolled back to N-1. The next transaction will attempt to reuse sequence number N, causing an `InvalidSeqNumber` mempool rejection. [6](#0-5) 

**Attack Scenario**: An attacker can exploit this by submitting requests that increase the likelihood of timeout errors:
- Submit complex funding requests that take longer to process
- Make rapid concurrent requests to stress the system
- Exploit network conditions that cause server lag beyond the 60-second timeout threshold

Each successful exploitation corrupts the faucet's sequence number state, requiring manual intervention or automatic sequence number resynchronization.

## Impact Explanation

**High Severity** per Aptos bug bounty criteria:

1. **API Crashes**: Repeated sequence number conflicts cause the faucet service to fail processing legitimate requests. Each poisoned sequence number requires the faucet to detect and recover from the mismatch.

2. **Service Availability**: The faucet becomes unreliable and may stop processing requests entirely if the sequence number state becomes sufficiently corrupted. This affects all users attempting to obtain test tokens.

3. **Validator Node Slowdowns**: While the faucet itself is not part of consensus, persistent sequence number conflicts can cause increased mempool rejection rates and unnecessary resource consumption.

This meets the High severity category of "API crashes" and "Significant protocol violations" as sequence number management is a fundamental transaction ordering guarantee.

## Likelihood Explanation

**High Likelihood**:

- **Common Trigger Conditions**: Timeout and server lag errors are frequent in distributed systems, especially under load. The default 60-second timeout is not uncommon to exceed during network congestion or node synchronization delays.

- **No Special Privileges Required**: Any user can trigger this by simply submitting faucet requests. No authentication bypass or special access is needed.

- **Amplification**: A single successful exploitation corrupts the sequence number state, and subsequent legitimate requests will fail until recovery occurs.

- **Repeatable**: The vulnerability can be exploited repeatedly to maintain denial of service.

## Recommendation

The fix requires distinguishing between errors that occur before mempool acceptance versus after. The sequence number should only be decremented if the transaction was never accepted into mempool.

**Recommended Fix**:

Modify `submit_transaction()` to track whether the transaction reached mempool:

```rust
pub async fn submit_transaction(
    client: &Client,
    faucet_account: &RwLock<LocalAccount>,
    signed_transaction: SignedTransaction,
    receiver_address: &AccountAddress,
    wait_for_transactions: bool,
) -> Result<SignedTransaction, AptosTapError> {
    let (result, event_on_success, transaction_in_mempool) = if wait_for_transactions {
        // Try to submit first
        match client.submit_bcs(&signed_transaction).await {
            Ok(_) => {
                // Transaction is now in mempool, track this fact
                let wait_result = client.wait_for_signed_transaction_bcs(&signed_transaction).await
                    .map(|_| ())
                    .map_err(|e| {
                        AptosTapError::new_with_error_code(e, AptosTapErrorCode::TransactionFailed)
                    });
                (wait_result, "transaction_success", true)
            },
            Err(e) => {
                // Transaction never made it to mempool
                (Err(AptosTapError::new_with_error_code(e, AptosTapErrorCode::TransactionFailed)), 
                 "transaction_success", 
                 false)
            }
        }
    } else {
        let submit_result = client.submit_bcs(&signed_transaction).await
            .map(|_| ())
            .map_err(|e| {
                AptosTapError::new_with_error_code(e, AptosTapErrorCode::TransactionFailed)
            });
        let in_mempool = submit_result.is_ok();
        (submit_result, "transaction_submitted", in_mempool)
    };

    match result {
        Ok(_) => {
            info!(...);
            Ok(signed_transaction)
        },
        Err(e) => {
            // Only decrement if transaction never made it to mempool
            if !transaction_in_mempool {
                faucet_account.write().await.decrement_sequence_number();
            } else {
                // Transaction is in mempool but wait failed - log for monitoring
                warn!(
                    hash = signed_transaction.committed_hash(),
                    address = receiver_address,
                    event = "transaction_in_mempool_but_wait_failed",
                    error_message = format!("{:#}", e)
                );
            }
            Err(e)
        },
    }
}
```

Additionally, implement periodic sequence number synchronization with the on-chain state to recover from any state desynchronization.

## Proof of Concept

**Reproduction Steps**:

1. Deploy a faucet instance with `wait_for_transactions = true`
2. Configure a shorter timeout or introduce artificial network delays
3. Submit multiple concurrent faucet requests to increase system load
4. Monitor for `wait_for_signed_transaction_bcs()` timeout errors
5. Observe sequence number decrements in logs
6. Attempt subsequent faucet requests and observe `InvalidSeqNumber` errors from mempool
7. Query the on-chain account sequence number and compare with the faucet's LocalAccount state to confirm desynchronization

**Expected Outcome**: The faucet's local sequence number will be lower than the on-chain sequence number, and subsequent transactions will fail with sequence number conflicts until manual intervention or automatic recovery occurs.

**Notes**

The vulnerability stems from the fundamental design assumption that any error during `submit_and_wait_bcs()` means the transaction failed. However, the two-phase nature of this operation (submit + wait) creates a window where the transaction succeeds in the first phase but fails in the second, leading to incorrect state management. This is a classic race condition in distributed systems where asynchronous operations with partial success are not properly handled.

### Citations

**File:** sdk/src/types.rs (L354-368)
```rust
    pub fn sign_with_transaction_builder(&self, builder: TransactionBuilder) -> SignedTransaction {
        let raw_txn = if builder.has_nonce() {
            // Do not increment sequence number for orderless transactions.
            builder
                .sender(self.address())
                .sequence_number(u64::MAX)
                .build()
        } else {
            builder
                .sender(self.address())
                .sequence_number(self.increment_sequence_number())
                .build()
        };
        self.sign_transaction(raw_txn)
    }
```

**File:** crates/aptos-faucet/core/src/funder/transfer.rs (L218-231)
```rust
        let signed_transaction = self
            .faucet_account
            .write()
            .await
            .sign_with_transaction_builder(transaction_builder);

        submit_transaction(
            client,
            &self.faucet_account,
            signed_transaction,
            receiver_address,
            self.wait_for_transactions,
        )
        .await
```

**File:** crates/aptos-rest-client/src/lib.rs (L671-677)
```rust
    pub async fn submit_and_wait_bcs(
        &self,
        txn: &SignedTransaction,
    ) -> AptosResult<Response<TransactionOnChainData>> {
        self.submit_bcs(txn).await?;
        self.wait_for_signed_transaction_bcs(txn).await
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L750-870)
```rust
    async fn wait_for_transaction_by_hash_inner<F, Fut, T>(
        &self,
        hash: HashValue,
        expiration_timestamp_secs: u64,
        max_server_lag_wait: Option<Duration>,

        timeout_from_call: Option<Duration>,
        fetch: F,
    ) -> AptosResult<Response<T>>
    where
        F: Fn(HashValue) -> Fut,
        Fut: Future<Output = AptosResult<WaitForTransactionResult<T>>>,
    {
        // TODO: make this configurable
        const DEFAULT_DELAY: Duration = Duration::from_millis(500);
        let mut reached_mempool = false;
        let start = std::time::Instant::now();
        loop {
            let mut chain_timestamp_usecs = None;
            match fetch(hash).await {
                Ok(WaitForTransactionResult::Success(result)) => {
                    return Ok(result);
                },
                Ok(WaitForTransactionResult::FailedExecution(vm_status)) => {
                    return Err(anyhow!(
                        "Transaction committed on chain, but failed execution: {}",
                        vm_status
                    ))?;
                },
                Ok(WaitForTransactionResult::Pending(state)) => {
                    reached_mempool = true;
                    if expiration_timestamp_secs <= state.timestamp_usecs / 1_000_000 {
                        return Err(anyhow!("Transaction expired. It is guaranteed it will not be committed on chain.").into());
                    }
                    chain_timestamp_usecs = Some(state.timestamp_usecs);
                },
                Ok(WaitForTransactionResult::NotFound(error)) => {
                    if let RestError::Api(aptos_error_response) = error {
                        if let Some(state) = aptos_error_response.state {
                            if expiration_timestamp_secs <= state.timestamp_usecs / 1_000_000 {
                                if reached_mempool {
                                    return Err(anyhow!("Used to be pending and now not found. Transaction expired. It is guaranteed it will not be committed on chain.").into());
                                } else {
                                    // We want to know whether we ever got Pending state from the mempool,
                                    // to warn in case we didn't.
                                    // Unless we are calling endpoint that is a very large load-balanced pool of nodes,
                                    // we should always see pending after submitting a transaction.
                                    // (i.e. if we hit the node we submitted a transaction to,
                                    // it shouldn't return NotFound on the first call)
                                    //
                                    // At the end, when the expiration happens, we might get NotFound or Pending
                                    // based on whether GC run on the full node to remove expired transaction,
                                    // so that information is not useful. So we need to keep this variable as state.
                                    return Err(anyhow!("Transaction expired, without being seen in mempool. It is guaranteed it will not be committed on chain.").into());
                                }
                            }
                            chain_timestamp_usecs = Some(state.timestamp_usecs);
                        }
                    } else {
                        return Err(error);
                    }
                    sample!(
                        SampleRate::Duration(Duration::from_secs(30)),
                        debug!(
                            "Cannot yet find transaction in mempool on {:?}, continuing to wait.",
                            self.path_prefix_string(),
                        )
                    );
                },
                Err(err) => {
                    debug!("Fetching error, will retry: {}", err);
                },
            }

            if let Some(max_server_lag_wait_duration) = max_server_lag_wait {
                if aptos_infallible::duration_since_epoch().as_secs()
                    > expiration_timestamp_secs + max_server_lag_wait_duration.as_secs()
                {
                    return Err(anyhow!(
                        "Ledger on endpoint ({}) is more than {}s behind current time, timing out waiting for the transaction. Warning, transaction ({}) might still succeed.",
                        self.path_prefix_string(),
                        max_server_lag_wait_duration.as_secs(),
                        hash,
                    ).into());
                }
            }

            let elapsed = start.elapsed();
            if let Some(timeout_duration) = timeout_from_call {
                if elapsed > timeout_duration {
                    return Err(anyhow!(
                        "Timeout of {}s after calling wait_for_transaction reached. Warning, transaction ({}) might still succeed.",
                        timeout_duration.as_secs(),
                        hash,
                    ).into());
                }
            }

            if elapsed.as_secs() > 30 {
                sample!(
                    SampleRate::Duration(Duration::from_secs(30)),
                    debug!(
                        "Continuing to wait for transaction {}, ledger on endpoint ({}) is {}",
                        hash,
                        self.path_prefix_string(),
                        if let Some(timestamp_usecs) = chain_timestamp_usecs {
                            format!(
                                "{}s behind current time",
                                aptos_infallible::duration_since_epoch()
                                    .saturating_sub(Duration::from_micros(timestamp_usecs))
                                    .as_secs()
                            )
                        } else {
                            "unreachable".to_string()
                        },
                    )
                );
            }

            tokio::time::sleep(DEFAULT_DELAY).await;
        }
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L379-398)
```rust
    match result {
        Ok(_) => {
            info!(
                hash = signed_transaction.committed_hash(),
                address = receiver_address,
                event = event_on_success,
            );
            Ok(signed_transaction)
        },
        Err(e) => {
            faucet_account.write().await.decrement_sequence_number();
            warn!(
                hash = signed_transaction.committed_hash(),
                address = receiver_address,
                event = "transaction_failure",
                error_message = format!("{:#}", e)
            );
            Err(e)
        },
    }
```

**File:** api/src/transactions.rs (L1474-1477)
```rust
            MempoolStatusCode::InvalidSeqNumber => Err(AptosError::new_with_error_code(
                mempool_status.message,
                AptosErrorCode::SequenceNumberTooOld,
            )),
```
