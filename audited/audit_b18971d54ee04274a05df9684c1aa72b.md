# Audit Report

## Title
Silent Message Loss in GRPC Network Layer Due to Missing Client-Side Logging

## Summary
The GRPC client's `send_message()` function in the secure networking layer does not log successful message sends, while the GRPC server returns `Ok` even when no handler is registered for a message type. This creates a silent failure scenario where critical executor service messages can be lost without any client-side indication, potentially causing indefinite hangs in sharded block execution.

## Finding Description

The vulnerability exists in the interaction between the GRPC client and server implementations in the secure networking layer used by the executor service.

**Client-Side Silent Success:** [1](#0-0) 

The `send_message()` function receives an `Ok` response from the server but performs no logging whatsoever. This means successful sends are completely invisible in client-side logs.

**Server-Side Misleading Success:** [2](#0-1) 

The server logs an error when no handler is registered for a message type but still returns `Ok(Response::new(Empty {}))`. This misleads the client into believing the message was successfully delivered and processed.

**Critical Usage Context:** [3](#0-2) 

The outbound handler calls `send_message()` without checking for any indication of delivery failure or logging the operation.

**Executor Service Impact:** [4](#0-3) 

The remote executor client sends critical block execution commands through this network layer and expects responses. If these messages are silently lost, the executor blocks indefinitely. [5](#0-4) 

The coordinator client waits on `command_rx.recv()` for commands that may never arrive if silently dropped.

**Attack Scenarios:**

1. **Configuration Error**: Message type mismatch between coordinator and shard (e.g., "execute_command_0" vs "execute_command_1") causes server to reject messages but client believes they succeeded.

2. **Version Mismatch**: During rolling upgrades, different versions may use different message type naming conventions, causing silent message drops.

3. **Deployment Issues**: Handler registration failures or timing issues during service startup could result in unregistered handlers temporarily accepting and dropping messages.

In all cases, the client has no logs indicating messages were sent, making root cause analysis extremely difficult while the system hangs waiting for responses.

## Impact Explanation

This issue qualifies as **High Severity** under the Aptos bug bounty criteria:

- **Validator node slowdowns**: When executor service messages are silently lost, the coordinator blocks indefinitely waiting for execution results, effectively halting block processing.

- **Significant protocol violations**: The sharded block executor depends on reliable message delivery. Silent message loss violates this critical assumption, breaking the liveness guarantee of the execution layer.

While the server does log errors, operators troubleshooting a hung executor would need to correlate server logs across multiple nodes to identify the issue. The complete absence of client-side logging makes this extremely difficult, potentially leading to extended downtime.

The impact is amplified because this affects the **executor service**, which is critical for block execution. Any liveness failure in this component directly impacts the blockchain's ability to process transactions.

## Likelihood Explanation

This issue has **Medium to High likelihood** of occurring:

**Common Triggers:**
- Configuration errors during deployment (typos in message type names)
- Version mismatches during rolling upgrades
- Race conditions during service initialization
- Network controller setup errors

**Exacerbating Factors:**
- No compile-time checking of message type string consistency
- No runtime validation that message types match between client and server
- No client-side observability of message delivery
- Lack of acknowledgment protocol beyond GRPC transport layer

The executor service is deployed in production environments where configuration drift, version skew, and deployment errors are realistic operational concerns. The complete absence of client-side logging makes these issues extremely difficult to detect and diagnose before they cause production incidents.

## Recommendation

**Immediate Fix - Add Client-Side Logging:**

Add logging to the `send_message()` function in `secure/net/src/grpc_network_service/mod.rs`:

```rust
pub async fn send_message(
    &mut self,
    sender_addr: SocketAddr,
    message: Message,
    mt: &MessageType,
) {
    let request = tonic::Request::new(NetworkMessage {
        message: message.data,
        message_type: mt.get_type(),
    });
    
    // ADD: Log before sending
    info!(
        "Sending message type '{}' from {} to {}",
        mt.get_type(), sender_addr, self.remote_addr
    );
    
    match self.remote_channel.simple_msg_exchange(request).await {
        Ok(_) => {
            // ADD: Log successful send
            trace!(
                "Successfully sent message type '{}' from {} to {}",
                mt.get_type(), sender_addr, self.remote_addr
            );
        },
        Err(e) => {
            error!(
                "Error '{}' sending message type '{}' to {} from node {:?}",
                e, mt.get_type(), self.remote_addr, sender_addr
            );
            panic!(
                "Error '{}' sending message to {} on node {:?}",
                e, self.remote_addr, sender_addr
            );
        },
    }
}
```

**Better Fix - Return Error on Unregistered Handler:**

Modify the server to return an error when no handler is registered:

```rust
async fn simple_msg_exchange(
    &self,
    request: Request<NetworkMessage>,
) -> Result<Response<Empty>, Status> {
    let remote_addr = request.remote_addr();
    let network_message = request.into_inner();
    let msg = Message::new(network_message.message);
    let message_type = MessageType::new(network_message.message_type);

    if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
        handler.send(msg).unwrap();
        Ok(Response::new(Empty {}))
    } else {
        error!(
            "No handler registered for sender: {:?} and msg type {:?}",
            remote_addr, message_type
        );
        // CHANGE: Return error instead of Ok
        Err(Status::not_found(format!(
            "No handler registered for message type: {:?}",
            message_type
        )))
    }
}
```

**Best Fix - Add End-to-End Acknowledgment:**

Implement an application-level acknowledgment protocol where the server explicitly confirms message processing, not just receipt.

## Proof of Concept

```rust
#[cfg(test)]
mod silent_failure_test {
    use super::*;
    use aptos_config::utils;
    use std::{
        net::{IpAddr, Ipv4Addr, SocketAddr},
        thread,
        time::Duration,
    };
    use aptos_secure_net::network_controller::{Message, MessageType, NetworkController};

    #[test]
    fn test_silent_message_loss() {
        // Setup server without registering handler
        let server_port = utils::get_available_port();
        let server_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), server_port);
        let mut server_controller = NetworkController::new(
            "server".to_string(),
            server_addr,
            1000,
        );
        
        // Start server WITHOUT registering handler for "test_message"
        server_controller.start();
        
        // Setup client
        let client_port = utils::get_available_port();
        let client_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), client_port);
        let mut client_controller = NetworkController::new(
            "client".to_string(),
            client_addr,
            1000,
        );
        
        let sender = client_controller.create_outbound_channel(
            server_addr,
            "test_message".to_string(),
        );
        
        client_controller.start();
        
        // Wait for servers to be ready
        thread::sleep(Duration::from_millis(100));
        
        // Send message - this will appear to succeed but message is lost
        // Server logs error but returns Ok
        // Client receives Ok but logs NOTHING
        sender.send(Message::new(b"test data".to_vec())).unwrap();
        
        // Wait to see if message is received
        thread::sleep(Duration::from_millis(100));
        
        // Message is silently lost - server logged error, client logged nothing
        // In real scenario, client would hang waiting for response
        
        server_controller.shutdown();
        client_controller.shutdown();
    }
}
```

Run with `RUST_LOG=info` to observe that:
1. Server logs: `ERROR: No handler registered for sender: ... and msg type "test_message"`
2. Client logs: **NOTHING** - complete silence about the send operation
3. Message is lost but client has no indication

## Notes

This vulnerability specifically affects the **secure networking layer** (`secure/net/`) used by the executor service, not the main consensus networking stack. However, the executor service is critical for sharded block execution, making any liveness failures in this component a high-severity issue.

The combination of server-side acceptance without processing and client-side logging absence creates a perfect storm for silent failures that are extremely difficult to diagnose in production environments.

### Citations

**File:** secure/net/src/grpc_network_service/mod.rs (L93-115)
```rust
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
```

**File:** secure/net/src/grpc_network_service/mod.rs (L140-160)
```rust
    pub async fn send_message(
        &mut self,
        sender_addr: SocketAddr,
        message: Message,
        mt: &MessageType,
    ) {
        let request = tonic::Request::new(NetworkMessage {
            message: message.data,
            message_type: mt.get_type(),
        });
        // TODO: Retry with exponential backoff on failures
        match self.remote_channel.simple_msg_exchange(request).await {
            Ok(_) => {},
            Err(e) => {
                panic!(
                    "Error '{}' sending message to {} on node {:?}",
                    e, self.remote_addr, sender_addr
                );
            },
        }
    }
```

**File:** secure/net/src/network_controller/outbound_handler.rs (L155-160)
```rust
                grpc_clients
                    .get_mut(remote_addr)
                    .unwrap()
                    .send_message(*socket_addr, msg, message_type)
                    .await;
            }
```

**File:** execution/executor-service/src/remote_executor_client.rs (L193-206)
```rust
        for (shard_id, sub_blocks) in sub_blocks.into_iter().enumerate() {
            let senders = self.command_txs.clone();
            let execution_request = RemoteExecutionRequest::ExecuteBlock(ExecuteBlockCommand {
                sub_blocks,
                concurrency_level: concurrency_level_per_shard,
                onchain_config: onchain_config.clone(),
            });

            senders[shard_id]
                .lock()
                .unwrap()
                .send(Message::new(bcs::to_bytes(&execution_request).unwrap()))
                .unwrap();
        }
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L80-112)
```rust
    fn receive_execute_command(&self) -> ExecutorShardCommand<RemoteStateViewClient> {
        match self.command_rx.recv() {
            Ok(message) => {
                let _rx_timer = REMOTE_EXECUTOR_TIMER
                    .with_label_values(&[&self.shard_id.to_string(), "cmd_rx"])
                    .start_timer();
                let bcs_deser_timer = REMOTE_EXECUTOR_TIMER
                    .with_label_values(&[&self.shard_id.to_string(), "cmd_rx_bcs_deser"])
                    .start_timer();
                let request: RemoteExecutionRequest = bcs::from_bytes(&message.data).unwrap();
                drop(bcs_deser_timer);

                match request {
                    RemoteExecutionRequest::ExecuteBlock(command) => {
                        let init_prefetch_timer = REMOTE_EXECUTOR_TIMER
                            .with_label_values(&[&self.shard_id.to_string(), "init_prefetch"])
                            .start_timer();
                        let state_keys = Self::extract_state_keys(&command);
                        self.state_view_client.init_for_block(state_keys);
                        drop(init_prefetch_timer);

                        let (sub_blocks, concurrency, onchain_config) = command.into();
                        ExecutorShardCommand::ExecuteSubBlocks(
                            self.state_view_client.clone(),
                            sub_blocks,
                            concurrency,
                            onchain_config,
                        )
                    },
                }
            },
            Err(_) => ExecutorShardCommand::Stop,
        }
```
