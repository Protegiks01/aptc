# Audit Report

## Title
Genesis Ceremony DoS via Unverified BLS12-381 Proof-of-Possession in Rust Configuration Validation

## Summary
The genesis configuration parsing and validation in Rust does not cryptographically verify that a validator's `proof_of_possession` (PoP) corresponds to their `consensus_public_key`. This verification gap allows a malicious genesis participant to provide an invalid PoP that passes Rust-side validation but causes the entire genesis transaction to abort during Move execution, resulting in a non-recoverable denial-of-service that prevents network launch.

## Finding Description
The vulnerability exists in a critical gap between Rust-side configuration validation and Move-side cryptographic verification during the genesis ceremony.

**Rust Configuration Parsing (No Verification):** [1](#0-0) 

The `TryFrom<ValidatorConfiguration>` implementation simply converts the PoP to bytes without any cryptographic verification against the consensus public key.

**Rust Validation (Presence/Uniqueness Only):** [2](#0-1) 

The `validate_validators` function only checks that PoP exists and is unique across validators, but performs no cryptographic verification that it corresponds to the consensus public key.

**Move Execution (Where Verification Actually Happens):** [3](#0-2) [4](#0-3) 

The actual cryptographic verification occurs only during Move execution when `rotate_consensus_key` calls `bls12381::public_key_from_bytes_with_pop`, which internally verifies the PoP signature. [5](#0-4) 

**Attack Scenario:**
1. Malicious actor participates in genesis validator set
2. Provides valid BLS12-381 `consensus_public_key` (96 bytes)
3. Provides invalid `proof_of_possession` - either random 96 bytes or PoP for a different key
4. Rust validation passes (only checks presence and uniqueness)
5. Genesis Move execution reaches `stake::rotate_consensus_key`
6. PoP verification fails, transaction aborts with `EINVALID_PUBLIC_KEY` error
7. Entire network fails to launch - non-recoverable without restarting genesis ceremony [6](#0-5) 

This breaks the **Cryptographic Correctness** invariant: "BLS signatures, VRF, and hash operations must be secure" - the system accepts unverified cryptographic material during the critical genesis phase.

## Impact Explanation
**Critical Severity** per Aptos bug bounty criteria: **"Total loss of liveness/network availability"**

A single malicious genesis participant can prevent the blockchain from launching by providing an invalid PoP. This results in:
- Complete failure of genesis ceremony
- Network cannot start or reach block 1
- Requires full restart of genesis coordination with all participants
- No technical mitigation available - purely coordination overhead
- Wastes potentially weeks of genesis preparation

Unlike post-genesis validator operations where PoP verification prevents joining the validator set, genesis has no fallback mechanism. The abort of genesis Move execution is fatal to network launch.

## Likelihood Explanation
**High Likelihood** - This attack is trivial to execute:
- No sophisticated cryptographic knowledge required
- Any genesis participant can exploit (just needs a validator slot)
- No stake or collateral required (genesis participants are pre-selected)
- Attack succeeds with 100% certainty if invalid PoP is provided
- Detection only occurs at genesis execution time, after all configuration is finalized

The only barrier is social: attacker must be selected as genesis participant. For public or semi-permissioned networks, this is achievable. For test networks or development chains, this is nearly guaranteed to occur accidentally due to misconfiguration.

## Recommendation
Add cryptographic PoP verification during Rust-side validation in `validate_validators` function:

**Location:** `crates/aptos/src/genesis/mod.rs` in the `validate_validators` function

**Add after line 758:**
```rust
// Cryptographically verify PoP corresponds to consensus public key
if let (Some(consensus_key), Some(pop)) = 
    (validator.consensus_public_key.as_ref(), validator.proof_of_possession.as_ref()) {
    if let Err(e) = pop.verify(consensus_key) {
        errors.push(CliError::UnexpectedError(format!(
            "Validator {} has invalid proof-of-possession that does not verify against consensus public key: {}",
            name, e
        )));
    }
}
```

This ensures invalid PoPs are detected during configuration validation, providing immediate feedback to genesis participants rather than failing catastrophically during execution.

## Proof of Concept
**Scenario:** Malicious genesis participant provides mismatched PoP

**Step 1:** Generate valid BLS12-381 keypair and PoP:
```bash
# Generate validator keys
aptos genesis generate-keys --output-dir validator1

# This produces:
# - consensus_public_key: valid BLS12-381 public key
# - proof_of_possession: valid PoP for that key
```

**Step 2:** Create malicious operator configuration with mismatched PoP:
```yaml
# operator.yaml
consensus_public_key: "0x8064... [valid key from validator1]"
# Use PoP from a DIFFERENT key (validator2) or random bytes
consensus_proof_of_possession: "0x90ab... [PoP for different key]"
```

**Step 3:** Run genesis validation:
```bash
aptos genesis generate-genesis --local-repository-dir genesis
```

**Expected Result:** 
- Rust validation passes (only checks presence/uniqueness)
- Genesis Move execution aborts with error: `EINVALID_PUBLIC_KEY (0x10000B)`
- Network fails to launch

**Actual verification in code:** [7](#0-6) 

The native verification function shows that PoP must be a valid BLS signature on the public key bytes using domain separation tag `BLS_POP_BLS12381G2_XMD:SHA-256_SSWU_RO_POP_`. Providing a mismatched PoP will cause verification to fail with `BLST_ERROR`, which propagates to Move as `None` from `public_key_from_bytes_with_pop`, triggering the assertion failure.

## Notes
This vulnerability specifically affects the **genesis ceremony** phase. Post-genesis validator operations are protected because:
- `stake::initialize_validator` verifies PoP before accepting new validators
- `stake::rotate_consensus_key` verifies PoP before key rotation

However, genesis is a special case where Rust-side validation is the primary gate, and the lack of cryptographic verification creates a critical attack vector. The fix is straightforward: leverage the existing `ProofOfPossession::verify()` API during Rust validation to close this gap.

### Citations

**File:** crates/aptos-genesis/src/config.rs (L252-261)
```rust
        let consensus_pubkey = if let Some(consensus_public_key) = config.consensus_public_key {
            consensus_public_key.to_bytes().to_vec()
        } else {
            vec![]
        };
        let proof_of_possession = if let Some(pop) = config.proof_of_possession {
            pop.to_bytes().to_vec()
        } else {
            vec![]
        };
```

**File:** crates/aptos/src/genesis/mod.rs (L760-774)
```rust
            if validator.proof_of_possession.is_none() {
                errors.push(CliError::UnexpectedError(format!(
                    "Validator {} does not have a consensus proof of possession, though it's joining during genesis",
                    name
                )));
            }
            if !unique_consensus_pops
                .insert(validator.proof_of_possession.as_ref().unwrap().clone())
            {
                errors.push(CliError::UnexpectedError(format!(
                    "Validator {} has a repeated a consensus proof of possessions {}",
                    name,
                    validator.proof_of_possession.as_ref().unwrap()
                )));
            }
```

**File:** aptos-move/framework/aptos-framework/sources/genesis.move (L375-383)
```text
    fun initialize_validator(pool_address: address, validator: &ValidatorConfiguration) {
        let operator = &create_signer(validator.operator_address);

        stake::rotate_consensus_key(
            operator,
            pool_address,
            validator.consensus_pubkey,
            validator.proof_of_possession,
        );
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L67-68)
```text
    /// Invalid consensus public key
    const EINVALID_PUBLIC_KEY: u64 = 11;
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L926-931)
```text
        // Checks the public key has a valid proof-of-possession to prevent rogue-key attacks.
        let pubkey_from_pop = &bls12381::public_key_from_bytes_with_pop(
            new_consensus_pubkey,
            &proof_of_possession_from_bytes(proof_of_possession)
        );
        assert!(option::is_some(pubkey_from_pop), error::invalid_argument(EINVALID_PUBLIC_KEY));
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/bls12381.move (L115-123)
```text
    public fun public_key_from_bytes_with_pop(pk_bytes: vector<u8>, pop: &ProofOfPossession): Option<PublicKeyWithPoP> {
        if (verify_proof_of_possession_internal(pk_bytes, pop.bytes)) {
            option::some(PublicKeyWithPoP {
                bytes: pk_bytes
            })
        } else {
            option::none<PublicKeyWithPoP>()
        }
    }
```

**File:** crates/aptos-crypto/src/bls12381/bls12381_pop.rs (L54-74)
```rust
    pub fn verify(&self, pk: &PublicKey) -> Result<()> {
        // CRYPTONOTE(Alin): We call the signature verification function with pk_validate set to true
        // since we do not necessarily trust the PK we deserialized over the network whose PoP we are
        // verifying here.
        let result = self.pop.verify(
            true,
            &pk.to_bytes(),
            DST_BLS_POP_IN_G2,
            &[],
            &pk.pubkey,
            true,
        );
        if result == BLST_ERROR::BLST_SUCCESS {
            Ok(())
        } else {
            Err(anyhow!(
                "Proof-of-possession (PoP) did NOT verify: {:?}",
                result
            ))
        }
    }
```
