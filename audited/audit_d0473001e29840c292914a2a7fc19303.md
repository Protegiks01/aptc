# Audit Report

## Title
Function Type Ability Covariance Allows Type Safety Violation in Move VM Runtime

## Summary
The `Type::paranoid_check_assignable()` function incorrectly implements covariant subtyping for function abilities, allowing functions with additional abilities to be assigned where functions with fewer abilities are expected. This violates Move's type system invariant that function types with different ability sets are distinct, incompatible types. [1](#0-0) 

## Finding Description

The Move type system treats function types with different abilities as completely distinct types. This is explicitly documented in the `FunctionTag::to_canonical_string()` invariant: "If two function tags are different, they must have different canonical strings." [2](#0-1) 

However, the runtime type checking function `paranoid_check_assignable()` at line 590 checks function ability compatibility using `abilities.is_subset(*given_abilities)`, which implements **covariant** subtyping. This allows a function with abilities `{copy, store, drop}` to be assigned where a function with abilities `{store, drop}` is expected.

This covariant check is used throughout the runtime in critical type safety operations:

1. **Struct field packing** - When packing struct fields: [3](#0-2) 

2. **Closure invocation** - When calling closures: [4](#0-3) 

3. **Local variable storage** - When storing to local variables: [5](#0-4) 

The Move compiler and test suite explicitly demonstrate that function types with different abilities are incompatible. Test file `fv_as_keys.move` shows:
- Line 50-53: Checking existence with `||u64 has store` returns FALSE when stored type is `||u64 has store+drop`
- Line 57-60: Checking existence with `||u64 has store+drop+copy` returns FALSE when stored type is `||u64 has store+drop`
- Line 64-68: Borrowing with incorrect ability set is expected to FAIL [6](#0-5) 

This creates a **type system inconsistency** where:
1. The runtime allows assignment of incompatible function types during bytecode execution
2. But storage operations treat these as distinct, incompatible types
3. This violates the **Deterministic Execution** invariant - validators could potentially diverge if edge cases trigger different code paths

## Impact Explanation

**Severity: Medium** 

While this violates type safety, the actual exploitability is limited because:
- The Move bytecode verifier should prevent most invalid function type assignments at compile time
- Storage operations perform exact type matching, which would catch mismatches
- The covariant check is only used in runtime paranoid checks (not the primary verification path)

However, this could still lead to:
- **State inconsistencies** if the type mismatch causes unexpected behavior in edge cases
- **Potential consensus divergence** if different validators handle the type mismatch differently
- **VM implementation fragility** that could be exploited in combination with other bugs

This falls under the Medium severity category: "State inconsistencies requiring intervention."

## Likelihood Explanation

**Likelihood: Low to Medium**

The bytecode verifier should catch most type mismatches at compile time, making direct exploitation difficult. However:
- The paranoid checks are meant to catch verifier bugs and implementation errors
- Complex function type instantiation scenarios might bypass verifier checks
- Future changes to the type system could expose this inconsistency
- The issue is latent and could be triggered by other VM bugs

## Recommendation

Replace the covariant ability check with an **invariant** (exact equality) check for function types:

```rust
pub fn paranoid_check_assignable(&self, expected_ty: &Self) -> PartialVMResult<()> {
    let ok = match (expected_ty, self) {
        (
            Type::Function {
                args,
                results,
                abilities,
            },
            Type::Function {
                args: given_args,
                results: given_results,
                abilities: given_abilities,
            },
        ) => {
            // FIXED: Use exact equality for abilities instead of subset check
            args == given_args
                && results == given_results
                && abilities == given_abilities  // Changed from is_subset
        },
        (Type::Reference(ty), Type::Reference(given)) => {
            given.paranoid_check_assignable(ty)?;
            true
        },
        _ => expected_ty == self,
    };
    // ... rest unchanged
}
```

This ensures function types with different abilities are treated as incompatible, consistent with the type system invariant.

## Proof of Concept

The following Move code would demonstrate the type safety violation if deployed:

```move
module 0x1::exploit {
    struct FunctionContainer has key {
        // Field declared with specific abilities
        func: |u64| -> u64 has store
    }

    #[persistent]
    public fun make_persistent_func(): |u64| -> u64 has copy+store+drop {
        |x| x + 1
    }

    // This should fail type checking but might pass due to covariant check
    public fun pack_with_wrong_type(s: &signer) {
        let f = make_persistent_func(); // Has copy+store+drop
        
        // Packing attempts to assign {copy,store,drop} to {store} field
        // Runtime check: {store}.is_subset({copy,store,drop}) = TRUE
        let container = FunctionContainer { func: f };
        
        move_to(s, container);
    }
}
```

To test in Rust, modify the unit tests in `runtime_types.rs` to verify the behavior:

```rust
#[test]
fn test_function_ability_assignability() {
    let func_fewer = Type::Function {
        args: vec![],
        results: vec![],
        abilities: AbilitySet::singleton(Ability::Store),
    };
    
    let func_more = Type::Function {
        args: vec![],
        results: vec![],
        abilities: AbilitySet::PRIMITIVES, // Copy + Drop + Store
    };
    
    // This currently passes but violates type safety
    assert!(func_more.paranoid_check_assignable(&func_fewer).is_ok());
    
    // These should be incompatible types
    assert_ne!(func_fewer, func_more);
}
```

## Notes

The covariant ability check appears to be a design oversight rather than intentional behavior. The Move language specification and runtime implementation clearly treat function types with different abilities as distinct types, as evidenced by storage operations and the canonical string representation. The runtime paranoid checks should enforce this invariant strictly rather than allowing covariant assignment.

### Citations

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_types.rs (L573-606)
```rust
    #[cfg_attr(feature = "force-inline", inline(always))]
    pub fn paranoid_check_assignable(&self, expected_ty: &Self) -> PartialVMResult<()> {
        let ok = match (expected_ty, self) {
            (
                Type::Function {
                    args,
                    results,
                    abilities,
                },
                Type::Function {
                    args: given_args,
                    results: given_results,
                    abilities: given_abilities,
                },
            ) => {
                args == given_args
                    && results == given_results
                    && abilities.is_subset(*given_abilities)
            },
            (Type::Reference(ty), Type::Reference(given)) => {
                given.paranoid_check_assignable(ty)?;
                true
            },
            _ => expected_ty == self,
        };
        if !ok {
            let msg = format!(
                "Expected type {}, got {} which is not assignable ",
                expected_ty, self
            );
            return paranoid_failure!(msg);
        }
        Ok(())
    }
```

**File:** third_party/move/move-core/types/src/language_storage.rs (L321-346)
```rust
impl FunctionTag {
    /// Returns a canonical string representation of the function tag.
    ///
    /// INVARIANT: If two function tags are different, they must have different canonical strings.
    pub fn to_canonical_string(&self) -> String {
        let fmt_list = |l: &[FunctionParamOrReturnTag]| -> String {
            l.iter()
                .map(|t| t.to_canonical_string())
                .collect::<Vec<_>>()
                .join(", ")
        };
        // Note that we put returns in parentheses. This ensures that when functions used as type
        // arguments, there is no ambiguity in presence of multiple returns, e.g.,
        //
        //    0x1::a::A<||||>
        //
        // is ambiguous: is it a function that has zero arguments and returns a function ||, or is
        // it a function that takes || argument and returns nothing? In order to disambiguate, we
        // always add parentheses for returns.
        format!(
            "|{}|({}){}",
            fmt_list(&self.args),
            fmt_list(&self.results),
            self.abilities.display_postfix()
        )
    }
```

**File:** third_party/move/move-vm/runtime/src/runtime_type_checks.rs (L106-140)
```rust
fn verify_pack<'a>(
    operand_stack: &mut Stack,
    field_count: u16,
    field_tys: impl Iterator<Item = &'a Type>,
    output_ty: Type,
) -> PartialVMResult<()> {
    let ability = output_ty.abilities()?;

    // If the struct has a key ability, we expect all of its field to
    // have store ability but not key ability.
    let field_expected_abilities = if ability.has_key() {
        ability
            .remove(Ability::Key)
            .union(AbilitySet::singleton(Ability::Store))
    } else {
        ability
    };
    for (ty, expected_ty) in operand_stack
        .popn_tys(field_count)?
        .into_iter()
        .zip(field_tys)
    {
        // Fields ability should be a subset of the struct ability
        // because abilities can be weakened but not the other
        // direction.
        // For example, it is ok to have a struct that doesn't have a
        // copy capability where its field is a struct that has copy
        // capability but not vice versa.
        ty.paranoid_check_abilities(field_expected_abilities)?;
        // Similar, we use assignability for the value moved in the field
        ty.paranoid_check_assignable(expected_ty)?;
    }

    operand_stack.push_ty(output_ty)
}
```

**File:** third_party/move/move-vm/runtime/src/runtime_type_checks.rs (L272-280)
```rust
            Instruction::CallClosure(sig_idx) => {
                // For closure, we need to check the type of the closure on
                // top of the stack. The argument types are checked when the frame
                // is constructed in the interpreter, using the same code as for regular
                // calls.
                let (expected_ty, _) = ty_cache.get_signature_index_type(*sig_idx, frame)?;
                let given_ty = operand_stack.pop_ty()?;
                given_ty.paranoid_check_assignable(expected_ty)?;
            },
```

**File:** third_party/move/move-vm/runtime/src/runtime_type_checks.rs (L296-304)
```rust
            Instruction::StLoc(idx) => {
                let expected_ty = frame.local_ty_at(*idx as usize);
                let val_ty = operand_stack.pop_ty()?;
                // For store, use assignability
                val_ty.paranoid_check_assignable(expected_ty)?;
                if !frame.locals.is_invalid(*idx as usize)? {
                    expected_ty.paranoid_check_has_ability(Ability::Drop)?;
                }
            },
```

**File:** third_party/move/move-compiler-v2/transactional-tests/tests/no-v1-comparison/fv_as_keys.move (L48-68)
```text
  // check existence of a function value of type `|T|u64` with `T = ||u64 has store`
  // should return false due to T missing `drop`
  public fun test_not_exist_2(acc: &signer){
    let exist_res = exists<Wrapper<||u64 has store>>(signer::address_of(acc));
    assert!(!exist_res);
  }

  // check existence of a function value of type `|T|u64` with `T = ||u64 has store`
  // should return false due to T additionally having `copy`
  public fun test_not_exist_3(acc: &signer){
    let exist_res = exists<Wrapper<||u64 has store+drop+copy>>(signer::address_of(acc));
    assert!(!exist_res);
  }

  // borrow function value of type `|T|u64` with `T = ||u64 has store+copy+drop`
  // should fail due to T additionally having `copy`
  public fun test_bad_borrow_from(acc: &signer){
    let f = borrow_global<Wrapper<||u64 has store+copy+drop>>(signer::address_of(acc));
    assert!((f.fv)(test1) == 1);
    assert!((f.fv)(test2) == 2);
  }
```
