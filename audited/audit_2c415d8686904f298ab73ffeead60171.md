# Audit Report

## Title
Account Recreation Vulnerability Through Generic NotFound Errors and Missing Sequence Number Validation

## Summary
The Aptos storage layer uses generic `NotFound` errors that cannot distinguish between "account never created," "account deleted," or "storage corruption." When combined with the `DEFAULT_ACCOUNT_RESOURCE` feature flag, the `create_account_if_does_not_exist()` function lacks critical validation checks present in `create_resource_account()`, enabling silent account recreation with reset authentication keys and sequence numbers if Account resources become inaccessible.

## Finding Description

The vulnerability exists at the intersection of three components:

**1. Generic NotFound Errors (Storage Layer)**

The storage error types provide no contextual information about WHY an account state is not found: [1](#0-0) [2](#0-1) 

When the storage layer queries for an Account resource and it doesn't exist, it returns `Ok(None)` without distinguishing between different scenarios. [3](#0-2) 

**2. DEFAULT_ACCOUNT_RESOURCE Feature Flag Behavior**

When this feature is enabled, accounts are treated as "stateless" - they logically exist even without an Account resource: [4](#0-3) 

Functions that need the Account resource call `ensure_resource_exists()` which lazily creates it: [5](#0-4) 

**3. Missing Validation in create_account_if_does_not_exist()**

The critical flaw is that `create_account_if_does_not_exist()` has no safeguards: [6](#0-5) 

It blindly creates a new Account resource with default values: [7](#0-6) 

This contrasts sharply with `create_resource_account()` which DOES check for prior usage: [8](#0-7) 

**Attack Scenario:**

If an Account resource becomes inaccessible (storage corruption, database migration bug, unforeseen storage layer issue), and a function calls `ensure_resource_exists()`:

1. Storage query returns generic `NotFound` error
2. `create_account_if_does_not_exist()` checks `!resource_exists_at()` â†’ true
3. `create_account_unchecked()` creates NEW Account with:
   - `authentication_key = bcs::to_bytes(&address)` (RESET to original!)
   - `sequence_number = 0` (RESET!)
   - All other fields reset to defaults

**Impact:**
- **Authentication Bypass**: If account had rotated its auth key to 0xABC, it gets reset to original address-derived key, potentially allowing original key holder (who may have compromised/discarded key) to regain control
- **Replay Protection Broken**: Sequence number reset to 0 allows old transactions to be replayed
- **State Consistency Violation**: Account state completely reset despite transaction history existing

## Impact Explanation

This qualifies as **Medium Severity** per Aptos bug bounty criteria:
- "State inconsistencies requiring intervention" - Directly applicable
- Potentially **High Severity** if storage corruption is more likely than expected

The vulnerability breaks the **State Consistency** invariant: "State transitions must be atomic and verifiable via Merkle proofs." Account state can be silently corrupted and reset without detection.

While not directly fund-stealing, it creates authentication bypass conditions and replay vulnerabilities that could lead to unauthorized access and transaction replay attacks.

## Likelihood Explanation

**Likelihood: Low to Medium**

The vulnerability requires Account resources to become inaccessible, which should not occur in normal operation since:
- Account struct lacks `drop` ability (cannot be destroyed)
- No public `move_from<Account>` function exists
- Designed to be permanent once created

However, potential triggers exist:
1. **Storage corruption** from unforeseen bugs in RocksDB interaction or state pruning logic
2. **Database migration errors** during upgrades where Account resources not properly migrated
3. **State synchronization bugs** where nodes end up with inconsistent Account resource availability
4. **Future feature flag transitions** that create edge cases

The OriginatingAddress table (stored separately at @aptos_framework) would persist even if Account resources disappear, but `create_account_if_does_not_exist()` doesn't check it: [9](#0-8) 

## Recommendation

**Immediate Fix: Add sequence number validation to create_account_if_does_not_exist()**

Modify the function to match the safety checks in `create_resource_account()`:

```move
public fun create_account_if_does_not_exist(account_address: address) {
    if (!resource_exists_at(account_address)) {
        assert!(
            account_address != @vm_reserved && account_address != @aptos_framework && account_address != @aptos_token,
            error::invalid_argument(ECANNOT_RESERVED_ADDRESS)
        );
        
        // NEW: Check if account was previously used by querying OriginatingAddress table
        // or checking transaction history. For now, ensure sequence number is 0 if 
        // feature flag allows checking
        if (features::is_default_account_resource_enabled()) {
            // When stateless accounts are enabled, verify account hasn't been used
            // by checking if there's an OriginatingAddress mapping
            let auth_key_as_addr = from_bcs::to_address(bcs::to_bytes(&account_address));
            let address_map = &OriginatingAddress[@aptos_framework].address_map;
            assert!(
                !address_map.contains(auth_key_as_addr),
                error::invalid_state(EACCOUNT_ALREADY_USED)
            );
        };
        
        create_account_unchecked(account_address);
    }
}
```

**Enhanced Error Reporting:**

Extend `AptosDbError::NotFound` to include context:

```rust
pub enum AptosDbError {
    #[error("{0} not found. Context: {1}")]
    NotFound(String, NotFoundContext),
    // ... rest
}

pub enum NotFoundContext {
    NeverExisted,
    MayBePruned { min_version: Version },
    StorageError,
    Unknown,
}
```

This allows distinguishing between different NotFound scenarios and enables better diagnostics.

## Proof of Concept

```move
#[test_only]
module test_account_recreation {
    use aptos_framework::account;
    use std::signer;
    
    #[test(framework = @aptos_framework)]
    #[expected_failure(abort_code = 0x10010, location = aptos_framework::account)]
    fun test_account_recreation_protection(framework: &signer) {
        // Setup: Create account with rotated key
        let addr = @0x123;
        let original_account = account::create_account_for_test(addr);
        
        // Simulate account having executed transactions (sequence_number > 0)
        account::increment_sequence_number(addr);
        assert!(account::get_sequence_number(addr) == 1, 0);
        
        // Simulate Account resource disappearing (in real scenario: storage corruption)
        // This would require test-only functionality to forcibly remove the resource
        
        // Attempt to recreate account - should FAIL with EACCOUNT_ALREADY_USED
        // Currently, this would SUCCEED and create new account with seq_num = 0
        account::create_account_if_does_not_exist(addr);
        
        // Verify protection: sequence number should NOT be reset
        assert!(account::get_sequence_number(addr) == 1, 1);
    }
}
```

Note: Full PoC requires test-only functions to simulate Account resource deletion, which demonstrates the defensive gap but cannot be triggered in production without storage layer bugs.

## Notes

While Account resources cannot normally be deleted through Move code (no `drop` ability, no public `move_from`), this represents a critical defense-in-depth vulnerability. The lack of validation in `create_account_if_does_not_exist()` compared to `create_resource_account()` is an inconsistency that could have severe consequences if storage layer bugs or corruption occur.

The generic nature of NotFound errors at the storage layer prevents:
- Detection of the root cause when debugging
- Differentiation between benign (never created) and critical (corruption) scenarios
- Proper error handling and recovery procedures

This vulnerability violates the "fail-safe" principle - when uncertain about account state, the system should err on the side of safety rather than blindly recreating with default values.

### Citations

**File:** storage/storage-interface/src/errors.rs (L12-14)
```rust
    /// A requested item is not found.
    #[error("{0} not found.")]
    NotFound(String),
```

**File:** types/src/state_store/errors.rs (L7-10)
```rust
pub enum StateViewError {
    #[error("{0} not found.")]
    NotFound(String),
    /// Other non-classified error.
```

**File:** storage/aptosdb/src/state_kv_db.rs (L374-402)
```rust
    pub(crate) fn get_state_value_with_version_by_version(
        &self,
        state_key: &StateKey,
        version: Version,
    ) -> Result<Option<(Version, StateValue)>> {
        let mut read_opts = ReadOptions::default();

        // We want `None` if the state_key changes in iteration.
        read_opts.set_prefix_same_as_start(true);
        if !self.enabled_sharding() {
            let mut iter = self
                .db_shard(state_key.get_shard_id())
                .iter_with_opts::<StateValueSchema>(read_opts)?;
            iter.seek(&(state_key.clone(), version))?;
            Ok(iter
                .next()
                .transpose()?
                .and_then(|((_, version), value_opt)| value_opt.map(|value| (version, value))))
        } else {
            let mut iter = self
                .db_shard(state_key.get_shard_id())
                .iter_with_opts::<StateValueByKeyHashSchema>(read_opts)?;
            iter.seek(&(state_key.hash(), version))?;
            Ok(iter
                .next()
                .transpose()?
                .and_then(|((_, version), value_opt)| value_opt.map(|value| (version, value))))
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L276-284)
```text
    public fun create_account_if_does_not_exist(account_address: address) {
        if (!resource_exists_at(account_address)) {
            assert!(
                account_address != @vm_reserved && account_address != @aptos_framework && account_address != @aptos_token,
                error::invalid_argument(ECANNOT_RESERVED_ADDRESS)
            );
            create_account_unchecked(account_address);
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L305-335)
```text
    fun create_account_unchecked(new_address: address): signer {
        let new_account = create_signer(new_address);
        let authentication_key = bcs::to_bytes(&new_address);
        assert!(
            authentication_key.length() == 32,
            error::invalid_argument(EMALFORMED_AUTHENTICATION_KEY)
        );

        let guid_creation_num = 0;

        let guid_for_coin = guid::create(new_address, &mut guid_creation_num);
        let coin_register_events = event::new_event_handle<CoinRegisterEvent>(guid_for_coin);

        let guid_for_rotation = guid::create(new_address, &mut guid_creation_num);
        let key_rotation_events = event::new_event_handle<KeyRotationEvent>(guid_for_rotation);

        move_to(
            &new_account,
            Account {
                authentication_key,
                sequence_number: 0,
                guid_creation_num,
                coin_register_events,
                key_rotation_events,
                rotation_capability_offer: CapabilityOffer { for: option::none() },
                signer_capability_offer: CapabilityOffer { for: option::none() },
            }
        );

        new_account
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L337-350)
```text
    #[view]
    /// Returns whether an account exists at `addr`.
    ///
    /// When the `default_account_resource` feature flag is enabled:
    /// - Always returns true, indicating that any address can be treated as a valid account
    /// - This reflects a change in the account model where accounts are now considered to exist implicitly
    /// - The sequence number and other account properties will return default values (0) for addresses without an Account resource
    ///
    /// When the feature flag is disabled:
    /// - Returns true only if an Account resource exists at `addr`
    /// - This is the legacy behavior where accounts must be explicitly created
    public fun exists_at(addr: address): bool {
        features::is_default_account_resource_enabled() || exists<Account>(addr)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L404-410)
```text
    inline fun ensure_resource_exists(addr: address) {
        if (features::is_default_account_resource_enabled()) {
            create_account_if_does_not_exist(addr);
        } else {
            assert!(exists_at(addr), error::not_found(EACCOUNT_DOES_NOT_EXIST));
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L1044-1082)
```text
    fun update_auth_key_and_originating_address_table(
        originating_addr: address,
        account_resource: &mut Account,
        new_auth_key_vector: vector<u8>,
    ) acquires OriginatingAddress {
        let address_map = &mut OriginatingAddress[@aptos_framework].address_map;
        let curr_auth_key = from_bcs::to_address(account_resource.authentication_key);
        let new_auth_key = from_bcs::to_address(new_auth_key_vector);
        assert!(
            new_auth_key != curr_auth_key,
            error::invalid_argument(ENEW_AUTH_KEY_SAME_AS_CURRENT)
        );

        // Checks `OriginatingAddress[curr_auth_key]` is either unmapped, or mapped to `originating_address`.
        // If it's mapped to the originating address, removes that mapping.
        // Otherwise, abort if it's mapped to a different address.
        if (address_map.contains(curr_auth_key)) {
            // If account_a with address_a is rotating its keypair from keypair_a to keypair_b, we expect
            // the address of the account to stay the same, while its keypair updates to keypair_b.
            // Here, by asserting that we're calling from the account with the originating address, we enforce
            // the standard of keeping the same address and updating the keypair at the contract level.
            // Without this assertion, the dapps could also update the account's address to address_b (the address that
            // is programmatically related to keypaier_b) and update the keypair to keypair_b. This causes problems
            // for interoperability because different dapps can implement this in different ways.
            // If the account with address b calls this function with two valid signatures, it will abort at this step,
            // because address b is not the account's originating address.
            assert!(
                originating_addr == address_map.remove(curr_auth_key),
                error::not_found(EINVALID_ORIGINATING_ADDRESS)
            );
        };

        // Set `OriginatingAddress[new_auth_key] = originating_address`.
        assert!(
            !address_map.contains(new_auth_key),
            error::invalid_argument(ENEW_AUTH_KEY_ALREADY_MAPPED)
        );
        address_map.add(new_auth_key, originating_addr);

```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L1135-1142)
```text
            assert!(
                get_sequence_number(resource_addr) == 0,
                error::invalid_state(EACCOUNT_ALREADY_USED),
            );
            create_signer(resource_addr)
        } else {
            create_account_unchecked(resource_addr)
        };
```
