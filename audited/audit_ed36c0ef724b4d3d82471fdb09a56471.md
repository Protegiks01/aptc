# Audit Report

## Title
Unrecoverable Panic in Indexer Table Info Version Retrieval Causes Fullnode/Indexer Service Crash

## Summary
The `next_version()` function in the indexer's table info reader uses `.unwrap()` on a database operation that can fail, causing an unrecoverable panic instead of returning a proper error. This panic is reachable through gRPC API endpoints, allowing database errors to crash the fullnode/indexer service.

## Finding Description

The vulnerability exists in the `IndexerAsyncV2::next_version()` function which is designed to return the latest version from the indexer metadata. [1](#0-0) 

This function calls `.unwrap()` on the database `get()` operation, which returns a `Result<Option<MetadataValue>>`. If the database operation fails for any reason (I/O error, corruption, permission issues, etc.), the `.unwrap()` will panic instead of returning an error.

The vulnerability is exposed through the `IndexerReader` trait implementation in `IndexerReaders::get_latest_table_info_ledger_version()`: [2](#0-1) 

This function is called from multiple critical gRPC service endpoints:

1. **Fullnode ping endpoint**: [3](#0-2) 

2. **Stream coordinator**: [4](#0-3) 

Additionally, there's a second panic path in the same function where `expect_version()` is called: [5](#0-4) 

This will panic if the database contains an incorrect `MetadataValue` variant (e.g., `StateSnapshotProgress` instead of `Version`), which could occur due to database corruption or programming errors.

**Attack Path:**
1. Fullnode/indexer is running and serving gRPC requests
2. Database experiences transient or permanent failure (disk error, corruption, I/O timeout, etc.)
3. External client makes gRPC ping request or initiates data stream
4. Service calls `get_latest_table_info_ledger_version()` → `next_version()` → `.unwrap()` panics
5. Entire fullnode/indexer process crashes, requiring manual restart

This breaks the availability guarantee and proper error handling invariant. The function signature indicates it should return a `Version` directly, but internally it depends on fallible database operations that should return `Result<Version>`.

## Impact Explanation

This vulnerability qualifies as **High Severity** according to Aptos bug bounty criteria:

- **"API crashes"** is explicitly listed as High Severity (up to $50,000)
- The vulnerability causes the fullnode/indexer gRPC service to crash completely
- Service becomes unavailable until manually restarted
- Affects data indexing and query capabilities for ecosystem applications
- Can be triggered by natural database failures without attacker intervention

While this doesn't directly impact consensus safety or lead to loss of funds, it significantly degrades the availability and reliability of indexer infrastructure that applications depend on for querying blockchain data.

## Likelihood Explanation

**Likelihood: Medium to High**

This issue is likely to occur because:

1. **Database failures are not uncommon**: RocksDB operations can fail due to:
   - Disk I/O errors or disk full conditions
   - File system corruption
   - Permission issues
   - Network storage failures (if DB is on network-attached storage)
   - Database file corruption

2. **Multiple call sites**: The vulnerable function is called from at least two critical paths (ping endpoint and stream coordinator)

3. **No attacker action required**: This can be triggered by operational issues alone

4. **High traffic endpoints**: Ping and streaming endpoints may be called frequently by clients

The likelihood is not higher because:
- Modern systems have reliable storage
- Database failures are still relatively infrequent in well-maintained systems
- However, when they do occur, the impact is immediate and severe

## Recommendation

Replace the `.unwrap()` call with proper error handling by changing the function signature to return `Result<Version>`:

**Fixed implementation:**

```rust
pub fn next_version(&self) -> Result<Version> {
    let version = self.db
        .get::<IndexerMetadataSchema>(&MetadataKey::LatestVersion)?
        .map(|v| v.expect_version())
        .unwrap_or(0);
    Ok(version)
}
```

Or even better, handle the `expect_version()` panic as well:

```rust
pub fn next_version(&self) -> Result<Version> {
    match self.db.get::<IndexerMetadataSchema>(&MetadataKey::LatestVersion)? {
        Some(MetadataValue::Version(v)) => Ok(v),
        Some(_) => bail!("Invalid metadata value type for LatestVersion"),
        None => Ok(0),
    }
}
```

Then update the caller in `indexer_reader.rs`:

```rust
fn get_latest_table_info_ledger_version(&self) -> anyhow::Result<Option<Version>> {
    if let Some(table_info_reader) = &self.table_info_reader {
        return Ok(Some(table_info_reader.next_version()?));
    }
    anyhow::bail!("Table info reader is not available")
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_schemadb::DB;
    use std::path::PathBuf;
    
    #[test]
    #[should_panic(expected = "called `Result::unwrap()` on an `Err`")]
    fn test_next_version_panics_on_db_error() {
        // Create a temporary database
        let temp_dir = tempfile::tempdir().unwrap();
        let db_path = temp_dir.path().to_path_buf();
        
        let db = DB::open(
            db_path.clone(),
            "test_db",
            vec![IndexerMetadataSchema::COLUMN_FAMILY_NAME],
            &Default::default(),
        ).unwrap();
        
        let indexer = IndexerAsyncV2::new(db).unwrap();
        
        // Close and delete the database to simulate I/O error
        drop(indexer);
        std::fs::remove_dir_all(&db_path).unwrap();
        
        // Recreate indexer with corrupted/missing DB
        let db = DB::open(
            db_path,
            "test_db",
            vec![IndexerMetadataSchema::COLUMN_FAMILY_NAME],
            &Default::default(),
        ).unwrap();
        
        let indexer = IndexerAsyncV2::new(db).unwrap();
        
        // This will panic instead of returning an error
        let _ = indexer.next_version();
    }
    
    #[test]
    fn test_next_version_handles_errors_properly() {
        // This test would pass with the fixed implementation
        // showing proper error propagation instead of panic
        
        let temp_dir = tempfile::tempdir().unwrap();
        let db = DB::open(
            temp_dir.path(),
            "test_db",
            vec![IndexerMetadataSchema::COLUMN_FAMILY_NAME],
            &Default::default(),
        ).unwrap();
        
        let indexer = IndexerAsyncV2::new(db).unwrap();
        
        // With fixed implementation, this returns Result
        let result = indexer.next_version();
        assert!(result.is_ok() || result.is_err()); // Either is acceptable
        // The key is that it doesn't panic
    }
}
```

## Notes

Additional `.expect()` calls were found in related code paths that could also cause panics, particularly in `db_indexer.rs` during batch processing operations. While these are less critical as they occur during internal indexing rather than external API calls, they should also be reviewed and converted to proper error handling to improve system resilience.

The root cause is a mismatch between the function signature (returning `Version` directly) and its implementation (performing fallible operations). All database operations should be assumed fallible and handled with proper `Result` types throughout the indexer codebase.

### Citations

**File:** storage/indexer/src/db_v2.rs (L142-147)
```rust
    pub fn next_version(&self) -> Version {
        self.db
            .get::<IndexerMetadataSchema>(&MetadataKey::LatestVersion)
            .unwrap()
            .map_or(0, |v| v.expect_version())
    }
```

**File:** storage/indexer/src/indexer_reader.rs (L61-66)
```rust
    fn get_latest_table_info_ledger_version(&self) -> anyhow::Result<Option<Version>> {
        if let Some(table_info_reader) = &self.table_info_reader {
            return Ok(Some(table_info_reader.next_version()));
        }
        anyhow::bail!("Table info reader is not available")
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L219-224)
```rust
        let table_info_version = self
            .service_context
            .context
            .indexer_reader
            .as_ref()
            .and_then(|r| r.get_latest_table_info_ledger_version().ok().flatten());
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L534-540)
```rust
        let latest_table_info_version = self
            .context
            .indexer_reader
            .as_ref()
            .expect("Table info reader not set")
            .get_latest_table_info_ledger_version()?
            .expect("Table info ledger version not set");
```

**File:** storage/indexer_schemas/src/metadata.rs (L16-21)
```rust
    pub fn expect_version(self) -> Version {
        match self {
            Self::Version(v) => v,
            _ => panic!("Not version"),
        }
    }
```
