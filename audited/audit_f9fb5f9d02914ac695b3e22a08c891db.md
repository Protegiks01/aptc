# Audit Report

## Title
Insecure File Permissions for Cryptographic Private Keys Due to Umask Reliance and Incomplete Permission Setting

## Summary
Multiple code paths in Aptos Core write cryptographic private keys to disk without explicitly setting secure file permissions, instead relying on system umask or incomplete permission-setting mechanisms. This allows private keys (including validator keys, network identity keys, and genesis root keys) to be created with world-readable permissions on misconfigured systems, or to retain insecure permissions when overwriting existing files.

## Finding Description

The Aptos Core codebase contains three critical locations where private keys are written to disk with insufficient permission controls:

**1. CLI Key Generation Tool** [1](#0-0) 

The `save_to_file_confidential` method uses `OpenOptions::mode(0o600)` wrapped in `#[cfg(unix)]`, which has two critical flaws:
- On Unix systems, `mode()` only sets permissions when **creating new files**. When overwriting existing files with `.truncate(true)`, the existing file permissions are preserved.
- On Windows (non-Unix) systems, no explicit permissions are set at all, relying entirely on system defaults.

This function is called when saving validator keys, ed25519 keys, x25519 keys, and bls12381 keys through the CLI. [2](#0-1) [3](#0-2) 

**2. Identity Configuration Key Storage** [4](#0-3) 

The `save_private_key` function uses `File::create()` directly without **any** explicit permission setting, completely relying on the system's umask. This affects network identity keys (x25519) for full nodes. [5](#0-4) 

**3. Genesis Root Key Storage** [6](#0-5) 

The genesis initialization code writes the root/mint key using `File::create()` without explicit permissions.

**Exploitation Scenarios:**

**Attack Vector 1 - Insecure Umask:**
1. System administrator configures umask to 0022 (common default) or 0000 (misconfigured)
2. Validator operator generates keys using `aptos key generate` or starts node
3. For identity_config.rs and aptos-node/src/lib.rs: Keys are created with permissions 0o644 (world-readable with umask 0022)
4. Attacker with local access reads the private key file
5. Attacker can now impersonate the validator or manipulate consensus

**Attack Vector 2 - Pre-existing File with Insecure Permissions:**
1. Attacker pre-creates key file at target path with 0o644 permissions (or user accidentally creates one)
2. Validator operator runs `aptos key generate --output-file <path>` and confirms overwrite
3. New private key is written but **retains the insecure 0o644 permissions** from the existing file
4. Attacker reads the newly generated private key

**Attack Vector 3 - Windows Systems:**
1. Validator operator generates keys on Windows
2. No explicit permissions are set (Unix-only `#[cfg(unix)]`)
3. File created with default Windows ACLs, potentially world-readable
4. Any local user can access the private key

The codebase confirms no explicit permission fixing is performed post-creation, as verified by the absence of `set_permissions` calls throughout the repository.

## Impact Explanation

This vulnerability meets **HIGH to CRITICAL** severity criteria:

**CRITICAL Impact Scenarios:**
- **Validator Key Compromise**: Exposing validator signing keys enables an attacker to participate in consensus as that validator, potentially causing safety violations, double-signing, or equivocation attacks (Critical: Consensus/Safety violations)
- **Genesis Root Key Compromise**: Exposing the root/mint key allows arbitrary token minting and governance control (Critical: Loss of Funds)
- **Network Partition**: Compromised network identity keys enable man-in-the-middle attacks, potentially causing non-recoverable network splits (Critical: Network partition)

**HIGH Impact Scenarios:**
- **Network Identity Key Compromise**: Allows impersonation of validators in the P2P network, enabling message manipulation and targeted attacks on specific nodes (High: Significant protocol violations)

The vulnerability affects:
- All validators using CLI tools for key generation on systems with umask â‰¥ 0022
- All full nodes using auto-generated identity keys
- All genesis ceremonies
- All Windows deployments regardless of umask

## Likelihood Explanation

**High Likelihood** - This vulnerability is likely to occur in production:

1. **Common Misconfiguration**: Many Linux distributions default to umask 0022 (creating files as 0o644), making keys world-readable on multi-user systems
2. **Existing Files**: Operators may have pre-existing configuration files from previous installations
3. **Windows Deployments**: Any Windows-based validator has no permission protection at all
4. **No Warning**: The code provides no warning about insecure permissions
5. **Operational Reality**: Validators often run on multi-tenant cloud infrastructure or shared systems where local access by other processes/users is possible

The attacker requirements are minimal:
- Local file system access (read permission on the directory)
- No special privileges required
- No network access needed
- Timing: Any time after key generation

## Recommendation

Implement explicit permission setting for all private key file operations using `std::fs::set_permissions()` **after** file creation. This ensures correct permissions regardless of umask or existing file state.

**Fix for `save_to_file_confidential`:**

```rust
pub fn save_to_file_confidential(&self, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
    let mut opts = OpenOptions::new();
    #[cfg(unix)]
    opts.mode(0o600);
    write_to_file_with_opts(self.output_file.as_path(), name, bytes, &mut opts)?;
    
    // Explicitly set permissions after writing to ensure they're correct
    // even when overwriting existing files
    #[cfg(unix)]
    {
        use std::fs::Permissions;
        use std::os::unix::fs::PermissionsExt;
        std::fs::set_permissions(
            self.output_file.as_path(),
            Permissions::from_mode(0o600)
        ).map_err(|e| CliError::IO(name.to_string(), e))?;
    }
    
    #[cfg(windows)]
    {
        // Set Windows ACLs to restrict access to current user only
        // Use windows-acl crate or similar
    }
    
    Ok(())
}
```

**Fix for `save_private_key`:**

```rust
pub fn save_private_key(path: &PathBuf, key: &x25519::PrivateKey) -> anyhow::Result<()> {
    let parent_path = path.parent().unwrap();
    fs::create_dir_all(parent_path)?;
    
    // Create/overwrite file
    File::create(path)?.write_all(&key.to_bytes())?;
    
    // Explicitly set secure permissions
    #[cfg(unix)]
    {
        use std::os::unix::fs::PermissionsExt;
        fs::set_permissions(path, fs::Permissions::from_mode(0o600))?;
    }
    
    #[cfg(windows)]
    {
        // Set Windows ACLs to restrict access
    }
    
    Ok(())
}
```

Apply similar fixes to the genesis root key writing code.

## Proof of Concept

```rust
// PoC demonstrating the vulnerability
use std::fs::{File, OpenOptions};
use std::io::Write;
use std::os::unix::fs::PermissionsExt;

fn main() {
    // Simulate the vulnerable code path
    
    // Step 1: Create a file with insecure permissions (simulating pre-existing file)
    let key_path = "/tmp/test_validator.key";
    {
        let mut file = File::create(key_path).unwrap();
        file.write_all(b"old_insecure_key_12345").unwrap();
    }
    // Set insecure permissions on the existing file
    std::fs::set_permissions(key_path, std::fs::Permissions::from_mode(0o644)).unwrap();
    
    println!("Created file with permissions: {:o}", 
             std::fs::metadata(key_path).unwrap().permissions().mode() & 0o777);
    
    // Step 2: Simulate the vulnerable save_to_file_confidential behavior
    // This mimics the code in types.rs lines 1084-1089
    let mut opts = OpenOptions::new();
    opts.mode(0o600);  // Only affects NEW file creation
    let mut file = opts.write(true).create(true).truncate(true).open(key_path).unwrap();
    file.write_all(b"new_validator_private_key_SENSITIVE_DATA").unwrap();
    
    // Step 3: Check permissions - they remain 0o644!
    let metadata = std::fs::metadata(key_path).unwrap();
    let perms = metadata.permissions().mode() & 0o777;
    
    println!("After overwrite, permissions are: {:o}", perms);
    
    if perms == 0o644 {
        println!("VULNERABILITY CONFIRMED: Private key is world-readable!");
        println!("Any user can read: {}", std::fs::read_to_string(key_path).unwrap());
    }
    
    // Cleanup
    std::fs::remove_file(key_path).unwrap();
}
```

Run with: `cargo run` (on Unix systems)

Expected output:
```
Created file with permissions: 644
After overwrite, permissions are: 644
VULNERABILITY CONFIRMED: Private key is world-readable!
Any user can read: new_validator_private_key_SENSITIVE_DATA
```

## Notes

This vulnerability has been present across multiple code paths and affects different types of cryptographic keys. The root cause is a misunderstanding of `OpenOptions::mode()` behavior (only affects newly created files) and incomplete cross-platform permission handling. The fix requires explicit `set_permissions()` calls after file operations and proper Windows ACL handling for complete protection.

### Citations

**File:** crates/aptos/src/common/types.rs (L1084-1089)
```rust
    pub fn save_to_file_confidential(&self, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
        let mut opts = OpenOptions::new();
        #[cfg(unix)]
        opts.mode(0o600);
        write_to_file_with_opts(self.output_file.as_path(), name, bytes, &mut opts)
    }
```

**File:** crates/aptos/src/op/key.rs (L440-441)
```rust
            .save_to_file_confidential(key_name, &encoded_private_key)?;
        write_to_file(&public_key_file, key_name, &encoded_public_key)?;
```

**File:** crates/aptos/src/op/key.rs (L482-483)
```rust
            .save_to_file_confidential(key_name, &encoded_private_key)?;
        write_to_file(&public_key_file, key_name, &encoded_public_key)?;
```

**File:** config/src/config/identity_config.rs (L117-126)
```rust
    pub fn save_private_key(path: &PathBuf, key: &x25519::PrivateKey) -> anyhow::Result<()> {
        // Create the parent directory
        let parent_path = path.parent().unwrap();
        fs::create_dir_all(parent_path)?;

        // Save the private key to the specified path
        File::create(path)?
            .write_all(&key.to_bytes())
            .map_err(|error| error.into())
    }
```

**File:** config/src/config/config_optimizer.rs (L230-230)
```rust
                    Identity::save_private_key(&path, &config_key.private_key())?;
```

**File:** aptos-node/src/lib.rs (L620-621)
```rust
    let mut key_file = fs::File::create(aptos_root_key_path)?;
    key_file.write_all(&serialized_keys)?;
```
