# Audit Report

## Title
Integer Overflow in Anti-Replay Timestamp Conversion Enables Replay Attacks After Distant-Future Overflow

## Summary
The `AntiReplayTimestamps::now()` function performs an unchecked truncation of a u128 timestamp to u64, which will cause integer overflow approximately 584 million years in the future. After this overflow occurs, the anti-replay protection mechanism will be completely bypassed, allowing attackers to replay previously-captured handshake messages and cause denial-of-service through resource exhaustion. [1](#0-0) 

## Finding Description

The network handshake anti-replay protection mechanism relies on monotonically increasing timestamps to prevent replay attacks. However, the timestamp generation has a critical flaw in its type conversion: [2](#0-1) 

The `duration_since_epoch().as_millis()` call returns a u128 value representing milliseconds since Unix epoch. This is then truncated to u64 using the `as u64` cast. When the u128 value exceeds `u64::MAX` (approximately 584 million years from epoch, around year 586,500,000 CE), the truncation silently wraps around to small values.

**Developer Assumption:** [3](#0-2) 

The code comment acknowledges the u128-to-u64 conversion but incorrectly assumes "we will never use more than 8 bytes" - this assumption fails after the overflow point.

**Exploitation Mechanism:**

The anti-replay check compares timestamps using a strictly-increasing property: [4](#0-3) 

**Attack Scenario:**

1. **Pre-Overflow (Year ~586,499,999 CE)**: Attacker captures legitimate handshake messages with timestamps near `u64::MAX` (e.g., `u64::MAX - 10000 = 18,446,744,073,709,541,615`)

2. **Overflow Occurs**: New timestamps wrap to small values (0, 1000, 2000, etc.)

3. **Immediate Impact**: Legitimate connections are rejected because new wrapped timestamps (e.g., 1000) are less than stored pre-overflow timestamps (e.g., `u64::MAX - 5000`), causing denial-of-service

4. **Post-Overflow Exploitation**: After system stabilizes with small timestamp values (e.g., `last_timestamp = 5000`), attacker replays captured pre-overflow messages with large timestamps (e.g., `u64::MAX - 10000`)

5. **Bypass**: The check `(u64::MAX - 10000) <= 5000` evaluates to FALSE, so the message is NOT flagged as a replay

6. **Result**: Anti-replay protection is completely bypassed

The replay check occurs after expensive cryptographic operations: [5](#0-4) [6](#0-5) 

The DH operations in `parse_client_init_message` execute before the timestamp validation, allowing resource exhaustion even when replays are eventually detected.

## Impact Explanation

**Severity: High (Theoretical) / Low (Practical)**

If this overflow were to occur, the impact would be **High** per the Aptos bug bounty criteria:
- Complete bypass of anti-replay security control (significant protocol violation)
- Denial-of-service through resource exhaustion (validator node slowdowns)
- Undermines network security guarantees for peer authentication

However, the **practical impact is negligible** because:
- Requires approximately 584 million years to manifest
- Far exceeds any reasonable blockchain operational timeframe
- Human civilization and technology will have evolved beyond recognition

The vulnerability breaks the following invariants:
- **Cryptographic Correctness**: Anti-replay protection must function correctly
- **Resource Limits**: Expensive operations should be protected from replay attacks [7](#0-6) 

## Likelihood Explanation

**Likelihood: Effectively Zero in Practical Terms**

The overflow occurs when `duration_since_epoch().as_millis()` exceeds `u64::MAX`:
- `u64::MAX = 18,446,744,073,709,551,615` milliseconds
- This equals approximately **584,542,046 years** from Unix epoch
- Overflow year: ~586,500,000 CE

**Pre-conditions for exploitation:**
1. Aptos network must continuously operate for 584+ million years
2. Attacker must preserve captured handshake messages across geological timescales  
3. System must transition through the overflow boundary

**Reality check:**
- Aptos blockchain launched in 2022
- Expected operational lifetime: decades to centuries
- This vulnerability will never manifest in practice

The question explicitly asks about "timestamps far in the future," acknowledging this is a theoretical analysis rather than an immediate threat.

## Recommendation

While the practical risk is negligible, the code should handle potential overflow correctly for theoretical completeness and to match the intent expressed in the comments.

**Option 1: Use full u128 timestamps**
```rust
pub const TIMESTAMP_SIZE: usize = 16; // Change from 8 to 16

pub fn now() -> [u8; Self::TIMESTAMP_SIZE] {
    let now: u128 = duration_since_epoch().as_millis();
    now.to_le_bytes()
}
```

Then update the HashMap to use u128:
```rust
pub struct AntiReplayTimestamps(HashMap<x25519::PublicKey, u128>);
```

**Option 2: Add overflow detection**
```rust
pub fn now() -> [u8; Self::TIMESTAMP_SIZE] {
    let now_u128 = duration_since_epoch().as_millis();
    let now: u64 = now_u128.try_into()
        .expect("Timestamp overflow: system time exceeds u64::MAX milliseconds");
    now.to_le_bytes()
}
```

**Option 3: Document the limitation**
```rust
/// Note: This will overflow after ~584 million years from Unix epoch.
/// This is an accepted limitation as the network will not operate on 
/// geological timescales. If long-term operation is required, migrate
/// to u128 timestamps.
pub const TIMESTAMP_SIZE: usize = 8;
```

**Recommended approach**: Option 1 (u128 timestamps) provides the most robust solution with minimal overhead, or Option 3 if the team consciously accepts the limitation.

## Proof of Concept

A complete proof-of-concept cannot be implemented because it requires simulating 584 million years of time passage. However, the vulnerability can be demonstrated conceptually:

```rust
#[cfg(test)]
mod overflow_demonstration {
    use super::*;
    
    #[test]
    fn demonstrate_truncation_overflow() {
        // Simulate pre-overflow timestamp (near u64::MAX)
        let pre_overflow: u128 = u64::MAX as u128 - 10000;
        let pre_overflow_truncated: u64 = pre_overflow as u64;
        assert_eq!(pre_overflow_truncated, u64::MAX - 10000);
        
        // Simulate post-overflow timestamp (wraps around)
        let post_overflow: u128 = (u64::MAX as u128) + 5000;
        let post_overflow_truncated: u64 = post_overflow as u64;
        assert_eq!(post_overflow_truncated, 4999); // Wrapped to small value
        
        // Demonstrate replay bypass
        let mut timestamps = AntiReplayTimestamps::default();
        let test_key = x25519::PrivateKey::generate(&mut rand::rngs::OsRng).public_key();
        
        // Store post-overflow timestamp
        timestamps.store_timestamp(test_key, post_overflow_truncated);
        
        // Check if pre-overflow timestamp is detected as replay
        let is_replay = timestamps.is_replay(test_key, pre_overflow_truncated);
        
        // This should be false (not detected as replay) due to overflow
        // pre_overflow_truncated (u64::MAX - 10000) > post_overflow_truncated (4999)
        assert!(!is_replay, "Replay attack bypassed due to overflow");
    }
}
```

## Notes

This vulnerability is **technically valid** but has **zero practical impact** in any realistic operational timeframe. The analysis is provided in response to the explicit question about "timestamps far in the future" scenarios. 

The Aptos network will undergo numerous upgrades, migrations, and protocol changes over its operational lifetime (decades/centuries), making this distant-future overflow scenario purely academic. However, it does represent a logic flaw in the anti-replay mechanism that violates its security guarantees in theory, even if not in practice.

The broader Aptos codebase shows awareness of timestamp overflow concerns in other components: [8](#0-7) 

However, the network handshake code lacks similar protections.

### Citations

**File:** network/framework/src/noise/handshake.rs (L30-39)
```rust
/// In a mutually authenticated network, a client message is accompanied with a timestamp.
/// This is in order to prevent replay attacks, where the attacker does not know the client's static key,
/// but can still replay a handshake message in order to force a peer into performing a few Diffie-Hellman key exchange operations.
///
/// Thus, to prevent replay attacks a responder will always check if the timestamp is strictly increasing,
/// effectively considering it as a stateful counter.
///
/// If the client timestamp has been seen before, or is not strictly increasing,
/// we can abort the handshake early and avoid heavy Diffie-Hellman computations.
/// If the client timestamp is valid, we store it.
```

**File:** network/framework/src/noise/handshake.rs (L44-47)
```rust
    /// The timestamp is sent as a payload, so that it is encrypted.
    /// Note that a millisecond value is a 16-byte value in rust,
    /// but as we use it to store a duration since UNIX_EPOCH we will never use more than 8 bytes.
    pub const TIMESTAMP_SIZE: usize = 8;
```

**File:** network/framework/src/noise/handshake.rs (L50-55)
```rust
    pub fn now() -> [u8; Self::TIMESTAMP_SIZE] {
        let now: u64 = duration_since_epoch().as_millis() as u64; // (TIMESTAMP_SIZE)

        // e.g. [157, 126, 253, 97, 114, 1, 0, 0]
        now.to_le_bytes()
    }
```

**File:** network/framework/src/noise/handshake.rs (L59-65)
```rust
    pub fn is_replay(&self, pubkey: x25519::PublicKey, timestamp: u64) -> bool {
        if let Some(last_timestamp) = self.0.get(&pubkey) {
            &timestamp <= last_timestamp
        } else {
            false
        }
    }
```

**File:** network/framework/src/noise/handshake.rs (L361-364)
```rust
        let (remote_public_key, handshake_state, payload) = self
            .noise_config
            .parse_client_init_message(prologue, client_init_message)
            .map_err(|err| NoiseHandshakeError::ServerParseClient(remote_peer_short, err))?;
```

**File:** network/framework/src/noise/handshake.rs (L443-450)
```rust
            // check the timestamp is not a replay
            let mut anti_replay_timestamps = anti_replay_timestamps.write();
            if anti_replay_timestamps.is_replay(remote_public_key, client_timestamp) {
                return Err(NoiseHandshakeError::ServerReplayDetected(
                    remote_peer_short,
                    client_timestamp,
                ));
            }
```

**File:** crates/indexer/src/util.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use crate::models::property_map::{PropertyMap, TokenObjectPropertyMap};
use aptos_api_types::Address;
use bigdecimal::{BigDecimal, Signed, ToPrimitive, Zero};
use serde::{Deserialize, Deserializer};
use serde_json::Value;
use sha2::Digest;

// 9999-12-31 23:59:59, this is the max supported by Google BigQuery
pub const MAX_TIMESTAMP_SECS: i64 = 253_402_300_799;

/// Standardizes all addresses and table handles to be length 66 (0x-64 length hash)
pub fn standardize_address(handle: &str) -> String {
    format!("0x{:0>64}", &handle[2..])
}

pub fn hash_str(val: &str) -> String {
    hex::encode(sha2::Sha256::digest(val.as_bytes()))
}

pub fn truncate_str(val: &str, max_chars: usize) -> String {
    let mut trunc = val.to_string();
    trunc.truncate(max_chars);
    trunc
}

pub fn u64_to_bigdecimal(val: u64) -> BigDecimal {
    BigDecimal::from(val)
}

#[allow(dead_code)]
pub fn bigdecimal_to_u64(val: &BigDecimal) -> u64 {
    val.to_u64().expect("Unable to convert big decimal to u64")
}

pub fn ensure_not_negative(val: BigDecimal) -> BigDecimal {
    if val.is_negative() {
        return BigDecimal::zero();
    }
    val
}

pub fn parse_timestamp(ts: u64, version: i64) -> chrono::NaiveDateTime {
    let seconds = ts / 1000000;
    let ns = (ts % 1000000 * 1000).try_into().unwrap_or_else(|_| {
        panic!(
            "Could not get nanoseconds for timestamp {:?} for version {}",
            ts, version
```
