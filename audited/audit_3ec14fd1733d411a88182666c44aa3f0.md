# Audit Report

## Title
Indexer-gRPC Manager Accepts Unverified Transaction Data from Fullnodes Without Cryptographic Proof Validation

## Summary
The indexer-grpc-manager blindly trusts transaction data from configured fullnodes without performing any cryptographic verification (LedgerInfo validation, transaction accumulator proofs, or state root verification). A compromised or malicious fullnode can inject arbitrary fake transaction data that will be cached and served to downstream indexers, APIs, and applications.

## Finding Description

The indexer-grpc-manager system fetches transactions from fullnodes via the `GetTransactionsFromNode` gRPC endpoint and directly caches them without any cryptographic verification.

**Vulnerable Code Flow:**

1. **Transaction Fetching Without Verification**: The `DataManager` requests transactions from a fullnode and directly caches them: [1](#0-0) 

2. **Direct Caching of Unverified Data**: Received transactions are immediately stored in cache without any validation: [2](#0-1) 

3. **No Proof Structures in Protocol**: The protobuf definition shows transactions are sent without any cryptographic proofs: [3](#0-2) [4](#0-3) 

4. **Fullnode Selection Without Authentication**: Fullnodes are selected randomly from a configured list with no cryptographic authentication: [5](#0-4) 

5. **Unverified Data Served to Clients**: The cached transactions are served directly to downstream clients: [6](#0-5) 

**Attack Scenario:**
1. Attacker compromises a fullnode that the indexer-grpc-manager connects to (via software vulnerability, credential theft, or insider access)
2. The malicious fullnode returns fake transaction data via `GetTransactionsFromNode`
3. The manager caches this data without verification
4. Downstream indexers, APIs, and explorers consume this fake data
5. Users see incorrect balances, fake NFT transfers, or manipulated events
6. Applications making decisions based on this data operate on false information

## Impact Explanation

**Severity: Critical**

While this vulnerability does not directly affect on-chain consensus or validator operations, it represents a **Critical** severity issue for the following reasons:

1. **Complete Data Integrity Compromise**: All downstream systems (indexers, APIs, block explorers, wallet applications) that rely on the indexer-grpc infrastructure would serve and display false blockchain data.

2. **No Defense in Depth**: A single compromised fullnode compromises the entire indexer infrastructure. There are no secondary verification mechanisms.

3. **Bypass of All Blockchain Security Guarantees**: The indexer serves data that never went through consensus validation, completely bypassing the blockchain's cryptographic security model.

4. **Wide Impact Surface**: Applications consuming indexer data include:
   - Block explorers (showing false transaction history)
   - Wallet applications (displaying incorrect balances)
   - Analytics platforms (computing metrics from false data)
   - DEX frontends (showing manipulated trading data)
   - NFT marketplaces (displaying fake ownership)

5. **Trust Model Violation**: While the system assumes trusted fullnodes, defense-in-depth principles dictate that cryptographic proofs should be validated even for trusted components to detect compromise.

This falls under the **"Significant protocol violations"** (High Severity) category as it violates the fundamental guarantee that all served blockchain data should be cryptographically verifiable.

## Likelihood Explanation

**Likelihood: Medium-High**

1. **Fullnode Compromise**: Fullnodes are complex systems with large attack surfaces. Historical precedent shows that blockchain infrastructure components are regularly compromised through software vulnerabilities, supply chain attacks, or credential theft.

2. **No Cryptographic Barriers**: Once a fullnode is compromised, there are zero cryptographic barriers to injecting false data - the attacker simply needs to respond to gRPC requests with fake transaction protobufs.

3. **Static Configuration**: Fullnodes are statically configured in the manager's config file with no runtime authentication or proof of legitimacy, making misconfiguration or malicious node injection possible.

4. **No TLS/mTLS**: The codebase shows no TLS or mutual TLS authentication on the gRPC connections, making man-in-the-middle attacks feasible on network infrastructure.

5. **Centralized Trust**: All downstream indexers depend on this single point of trust, amplifying the impact of any compromise.

## Recommendation

**Implement Cryptographic Proof Verification**

The indexer-grpc-manager must validate all received transaction data against cryptographically signed LedgerInfo and verify transaction accumulator proofs. This ensures that even a compromised fullnode cannot inject data that wasn't part of the committed blockchain state.

**Recommended Fix:**

1. Modify the fullnode gRPC protocol to include `TransactionListWithProof` instead of raw transactions
2. Require fullnodes to provide signed `LedgerInfo` along with transaction data
3. Implement proof verification in the DataManager before caching
4. Add mutual TLS authentication for gRPC connections

**Example verification logic needed:**

```rust
// In data_manager.rs, before caching transactions:
fn verify_transactions_with_proof(
    transactions: Vec<Transaction>,
    proof: TransactionListProof,
    ledger_info: &LedgerInfo,
) -> Result<()> {
    // Verify LedgerInfo signatures
    verify_ledger_info_signatures(ledger_info)?;
    
    // Verify transaction accumulator proofs
    proof.verify(ledger_info, &transactions)?;
    
    Ok(())
}
```

This would require changes to:
- Protocol buffers to include proof structures
- Fullnode service to generate proofs
- Manager service to verify proofs before caching

The verification code already exists in the Aptos codebase for state-sync and should be reused: [7](#0-6) 

## Proof of Concept

**Setup:**
1. Configure indexer-grpc-manager with a test fullnode endpoint
2. Create a malicious gRPC server implementing the FullnodeData service
3. Have it return fake transaction data
4. Query the indexer-grpc-manager's API
5. Observe that fake transactions are served without validation

**Malicious Fullnode Mock (Rust):**

```rust
use aptos_protos::internal::fullnode::v1::{
    fullnode_data_server::FullnodeData,
    GetTransactionsFromNodeRequest,
    TransactionsFromNodeResponse,
    TransactionsOutput,
};
use aptos_protos::transaction::v1::Transaction;

struct MaliciousFullnode;

#[tonic::async_trait]
impl FullnodeData for MaliciousFullnode {
    async fn get_transactions_from_node(
        &self,
        request: Request<GetTransactionsFromNodeRequest>,
    ) -> Result<Response<Stream<TransactionsFromNodeResponse>>, Status> {
        // Return fake transaction with manipulated balance
        let fake_txn = Transaction {
            version: 12345,
            // ... fake transaction data showing false balance transfer
        };
        
        let response = TransactionsOutput {
            transactions: vec![fake_txn],
        };
        
        // Manager will cache this without verification
        Ok(Response::new(stream::once(response)))
    }
}
```

**Verification Steps:**
1. Start the malicious fullnode mock
2. Configure indexer-grpc-manager to connect to it
3. Query the manager's `get_transactions` API
4. Observe that fake transactions are returned
5. Check cache contents - fake data is stored
6. Query downstream indexer APIs - they serve the fake data

This demonstrates that there is no cryptographic verification preventing injection of arbitrary transaction data through a compromised or malicious fullnode.

---

**Notes:**

The vulnerability exists because the indexer-grpc system operates in a pure trust model without implementing defense-in-depth verification. While the system assumes fullnodes are trusted infrastructure, cryptographic proof validation should still be performed to detect compromise and maintain data integrity guarantees. The Aptos blockchain provides all necessary cryptographic primitives (LedgerInfo signatures, transaction accumulator proofs) that should be utilized by the indexer infrastructure to maintain end-to-end security.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L207-230)
```rust
            let request = GetTransactionsFromNodeRequest {
                starting_version: Some(cache.start_version + cache.transactions.len() as u64),
                transactions_count: Some(100000),
            };
            drop(cache);

            debug!(
                "Requesting transactions from fullnodes, starting_version: {}.",
                request.starting_version.unwrap()
            );
            let (address, mut fullnode_client) =
                self.metadata_manager.get_fullnode_for_request(&request);
            trace!("Fullnode ({address}) is picked for request.");
            let response = fullnode_client.get_transactions_from_node(request).await;
            if response.is_err() {
                warn!(
                    "Error when getting transactions from fullnode ({address}): {}",
                    response.err().unwrap()
                );
                tokio::time::sleep(Duration::from_millis(100)).await;
                continue;
            } else {
                trace!("Got success response from fullnode.");
            }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L257-266)
```rust
                match response_item {
                    Ok(r) => {
                        if let Some(response) = r.response {
                            match response {
                                Response::Data(data) => {
                                    trace!(
                                        "Putting data into cache, {} transaction(s).",
                                        data.transactions.len()
                                    );
                                    self.cache.write().await.put_transactions(data.transactions);
```

**File:** protos/proto/aptos/internal/fullnode/v1/fullnode_data.proto (L18-20)
```text
message TransactionsOutput {
  repeated aptos.transaction.v1.Transaction transactions = 1;
}
```

**File:** protos/proto/aptos/transaction/v1/transaction.proto (L40-72)
```text
message Transaction {
  aptos.util.timestamp.Timestamp timestamp = 1;
  uint64 version = 2 [jstype = JS_STRING];
  TransactionInfo info = 3;
  uint64 epoch = 4 [jstype = JS_STRING];
  uint64 block_height = 5 [jstype = JS_STRING];

  enum TransactionType {
    TRANSACTION_TYPE_UNSPECIFIED = 0;
    TRANSACTION_TYPE_GENESIS = 1;
    TRANSACTION_TYPE_BLOCK_METADATA = 2;
    TRANSACTION_TYPE_STATE_CHECKPOINT = 3;
    TRANSACTION_TYPE_USER = 4;
    // values 5-19 skipped for no reason
    TRANSACTION_TYPE_VALIDATOR = 20;
    TRANSACTION_TYPE_BLOCK_EPILOGUE = 21;
  }

  TransactionType type = 6;

  oneof txn_data {
    BlockMetadataTransaction block_metadata = 7;
    GenesisTransaction genesis = 8;
    StateCheckpointTransaction state_checkpoint = 9;
    UserTransaction user = 10;
    // value 11-19 skipped for no reason
    ValidatorTransaction validator = 21;
    // value 22 is used up below (all Transaction fields have to have different index), so going to 23
    BlockEpilogueTransaction block_epilogue = 23;
  }

  TransactionSizeInfo size_info = 22;
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L341-374)
```rust
    pub(crate) fn get_fullnode_for_request(
        &self,
        request: &GetTransactionsFromNodeRequest,
    ) -> (GrpcAddress, FullnodeDataClient<Channel>) {
        // TODO(grao): Double check the counters to see if we need a different way or additional
        // information.
        let mut rng = thread_rng();
        if let Some(fullnode) = self
            .fullnodes
            .iter()
            .filter(|fullnode| {
                fullnode
                    .recent_states
                    .back()
                    .is_some_and(|s| s.known_latest_version >= request.starting_version)
            })
            .choose(&mut rng)
            .map(|kv| (kv.key().clone(), kv.value().client.clone()))
        {
            COUNTER
                .with_label_values(&["get_fullnode_for_request__happy"])
                .inc();
            return fullnode;
        }

        COUNTER
            .with_label_values(&["get_fullnode_for_request__fallback"])
            .inc();
        self.fullnodes
            .iter()
            .choose(&mut rng)
            .map(|kv| (kv.key().clone(), kv.value().client.clone()))
            .unwrap()
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L129-146)
```rust
    async fn get_transactions(
        &self,
        request: Request<GetTransactionsRequest>,
    ) -> Result<Response<TransactionsResponse>, Status> {
        let request = request.into_inner();
        let transactions = self
            .data_manager
            .get_transactions(request.starting_version(), MAX_SIZE_BYTES_FROM_CACHE)
            .await
            .map_err(|e| Status::internal(format!("{e}")))?;

        Ok(Response::new(TransactionsResponse {
            transactions,
            chain_id: Some(self.chain_id),
            // Not used.
            processed_range: None,
        }))
    }
```

**File:** types/src/transaction/mod.rs (L1-5)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

#![allow(clippy::arc_with_non_send_sync)]

```
