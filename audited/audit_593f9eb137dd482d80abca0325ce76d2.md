# Audit Report

## Title
Insufficient Audit Logging in Peer Monitoring Service Enables Undetected Reconnaissance by Untrusted Peers

## Summary
The `LogEntry` enum in the peer monitoring service does not distinguish between requests from trusted versus untrusted peers, and the service lacks authorization checks entirely. This allows any network-authenticated peer (including potential adversaries) to repeatedly query sensitive network topology and node status information without detection, enabling reconnaissance attacks.

## Finding Description

The peer monitoring service in Aptos Core has a critical gap in its authorization and audit logging architecture. The vulnerability manifests in three layers:

**1. Missing Authorization Context in Request Handling**

The `PeerMonitoringServiceServer` receives the requesting peer's identity via `peer_network_id` [1](#0-0)  but discards this information when invoking the handler, passing only the `network_id` [2](#0-1) . The `Handler::call` method signature does not accept peer identity [3](#0-2) , making authorization checks architecturally impossible.

**2. Insufficient LogEntry Enum Variants**

The `LogEntry` enum contains only three variants [4](#0-3) :
- `PeerMonitoringServiceError`
- `ReceivedPeerMonitoringRequest`
- `SentPeerMonitoringResponse`

None distinguish between trusted peers (validators, known nodes) versus untrusted/unknown peers, nor do they capture authorization decisions or peer identity in access contexts.

**3. Unrestricted Information Disclosure**

The service exposes sensitive information without authorization checks [5](#0-4) :

- **NetworkInformation** [6](#0-5) : Connected peers with network addresses, peer IDs, roles (Validator/VFN/Unknown), and distance from validator set
- **NodeInformation** [7](#0-6) : Build version, highest synced epoch/version, ledger timestamps, storage bounds, and uptime

**Attack Scenario:**

1. Adversary completes Noise handshake authentication at network layer [8](#0-7) 
2. Adversary sends repeated `GetNetworkInformation` and `GetNodeInformation` requests
3. Service processes all requests without checking peer authorization [5](#0-4) 
4. Logs show only trace-level peer ID [9](#0-8)  but no authorization audit trail
5. Adversary builds complete network topology map, identifies validator nodes, tracks sync lag, and plans sophisticated attacks (consensus disruption, targeted DoS, eclipse attacks)

While network-layer authentication failures are logged with `SecurityEvent::NoiseHandshake` [10](#0-9) , there is no equivalent application-layer security logging for peer monitoring access patterns.

## Impact Explanation

This vulnerability qualifies as **Medium Severity** under the Aptos bug bounty criteria for the following reasons:

**Information Disclosure Enabling State Inconsistencies**: While the direct impact is information leakage, the intelligence gathered enables adversaries to:
- Identify which nodes are syncing slowly (potential targets for state fork attacks)
- Map network topology to plan eclipse attacks against specific validators
- Determine validator set composition for consensus-layer attacks
- Track node versions to exploit version-specific vulnerabilities

**Reconnaissance for Higher-Severity Attacks**: The lack of audit logging means network administrators cannot detect:
- Systematic reconnaissance by malicious actors
- Attempts to profile validator infrastructure
- Patterns indicating preparation for consensus attacks

**Violation of Defense-in-Depth Principle**: The peer monitoring service has access to `peers_and_metadata` [11](#0-10)  (which contains trusted peer information) but never uses it for authorization, creating a security gap where untrusted peers have identical access to trusted ones.

## Likelihood Explanation

**Likelihood: High**

- **Attacker Requirements**: Only requires network-layer authentication via Noise handshake, which any peer can complete
- **No Detection**: Current logging provides no visibility into reconnaissance patterns
- **Rate Limiting Gaps**: Only concurrent request limiting exists [12](#0-11)  (1000 concurrent), no per-peer rate limiting
- **Public Networks**: On public networks with `MaybeMutual` authentication mode [13](#0-12) , all connections are accepted regardless of trust status

## Recommendation

**1. Extend LogEntry Enum with Authorization Context:**

```rust
#[derive(Clone, Copy, Serialize)]
#[serde(rename_all = "snake_case")]
pub enum LogEntry {
    PeerMonitoringServiceError,
    ReceivedPeerMonitoringRequest,
    SentPeerMonitoringResponse,
    // New variants for authorization audit
    UnauthorizedAccessAttempt,
    TrustedPeerAccess,
    UntrustedPeerAccess,
}
```

**2. Pass Peer Identity to Handler:**

Modify `Handler::call` signature to accept `PeerId` and check trusted peer status:

```rust
pub fn call(
    &self,
    network_id: NetworkId,
    peer_id: PeerId,  // Add peer identity
    request: PeerMonitoringServiceRequest,
) -> Result<PeerMonitoringServiceResponse> {
    // Check authorization
    let is_trusted = self.peers_and_metadata
        .get_trusted_peers(&network_id)
        .map(|peers| peers.contains_key(&peer_id))
        .unwrap_or(false);
    
    // Log with authorization context
    let log_entry = if is_trusted {
        LogEntry::TrustedPeerAccess
    } else {
        LogEntry::UntrustedPeerAccess
    };
    
    info!(LogSchema::new(log_entry)
        .request(&request)
        .message(&format!("Peer: {:?}, Trusted: {}", peer_id, is_trusted)));
    
    // Optionally restrict sensitive requests to trusted peers only
    if !is_trusted && matches!(request, PeerMonitoringServiceRequest::GetNetworkInformation) {
        error!(LogSchema::new(LogEntry::UnauthorizedAccessAttempt)
            .request(&request)
            .message(&format!("Untrusted peer {:?} attempted restricted request", peer_id)));
        return Err(Error::InvalidRequest("Unauthorized".to_string()));
    }
    
    // ... rest of existing logic
}
```

**3. Add Per-Peer Rate Limiting:**

Track request patterns per peer to detect reconnaissance:

```rust
// In PeerMonitoringServiceServer
struct RequestRateLimiter {
    requests_per_peer: HashMap<PeerId, RequestTracker>,
}
```

## Proof of Concept

**Reconnaissance Attack Simulation:**

```rust
#[tokio::test]
async fn test_untrusted_peer_reconnaissance() {
    // Setup: Create peer monitoring server with mixed trusted/untrusted peers
    let (mut server, mut untrusted_client) = setup_test_environment();
    
    // Attack: Untrusted peer queries network information repeatedly
    for i in 0..100 {
        let request = PeerMonitoringServiceRequest::GetNetworkInformation;
        let response = untrusted_client.send_request(request).await.unwrap();
        
        match response {
            PeerMonitoringServiceResponse::NetworkInformation(info) => {
                // Adversary successfully maps network topology
                println!("Iteration {}: Discovered {} connected peers", i, info.connected_peers.len());
                println!("Validator distance: {}", info.distance_from_validators);
                
                for (peer_id, metadata) in &info.connected_peers {
                    println!("  Peer: {:?}, Role: {:?}, Address: {:?}", 
                        peer_id, metadata.peer_role, metadata.network_address);
                }
            },
            _ => panic!("Unexpected response"),
        }
    }
    
    // Verify: No authorization failures logged, all requests succeed
    let logs = get_service_logs();
    assert!(!logs.iter().any(|l| l.contains("unauthorized")));
    assert!(!logs.iter().any(|l| l.contains("UnauthorizedAccessAttempt")));
    
    // Attack Success: Untrusted peer obtained complete network map
    // without detection or rate limiting
}
```

**Expected Current Behavior:** All 100 requests succeed, only trace-level logs exist showing peer ID, no security alerts generated.

**Expected Behavior After Fix:** Requests are logged with peer trust status, untrusted peers may be rate-limited or denied sensitive information, security monitoring can detect reconnaissance patterns.

---

**Notes:**

The vulnerability exists because the peer monitoring service was designed for operational monitoring but lacks security-aware access control. While network-layer Noise authentication prevents anonymous access, it doesn't distinguish between trusted (validators, seed nodes) and untrusted (public fullnodes, potential adversaries) peers at the application layer. The missing audit logging makes it impossible to detect or investigate reconnaissance attacks that gather intelligence for subsequent consensus-layer or network-layer attacks.

### Citations

**File:** peer-monitoring-service/server/src/lib.rs (L88-88)
```rust
            let peer_network_id = network_request.peer_network_id;
```

**File:** peer-monitoring-service/server/src/lib.rs (L91-96)
```rust
            trace!(LogSchema::new(LogEntry::ReceivedPeerMonitoringRequest)
                .request(&peer_monitoring_service_request)
                .message(&format!(
                    "Received peer monitoring request. Peer: {:?}",
                    peer_network_id,
                )));
```

**File:** peer-monitoring-service/server/src/lib.rs (L101-101)
```rust
            let peers_and_metadata = self.peers_and_metadata.clone();
```

**File:** peer-monitoring-service/server/src/lib.rs (L114-117)
```rust
                    .call(
                        peer_network_id.network_id(),
                        peer_monitoring_service_request,
                    );
```

**File:** peer-monitoring-service/server/src/lib.rs (L155-159)
```rust
    pub fn call(
        &self,
        network_id: NetworkId,
        request: PeerMonitoringServiceRequest,
    ) -> Result<PeerMonitoringServiceResponse> {
```

**File:** peer-monitoring-service/server/src/lib.rs (L175-182)
```rust
        let response = match &request {
            PeerMonitoringServiceRequest::GetNetworkInformation => self.get_network_information(),
            PeerMonitoringServiceRequest::GetServerProtocolVersion => {
                self.get_server_protocol_version()
            },
            PeerMonitoringServiceRequest::GetNodeInformation => self.get_node_information(),
            PeerMonitoringServiceRequest::LatencyPing(request) => self.handle_latency_ping(request),
        };
```

**File:** peer-monitoring-service/server/src/logging.rs (L30-36)
```rust
#[derive(Clone, Copy, Serialize)]
#[serde(rename_all = "snake_case")]
pub enum LogEntry {
    PeerMonitoringServiceError,
    ReceivedPeerMonitoringRequest,
    SentPeerMonitoringResponse,
}
```

**File:** peer-monitoring-service/types/src/response.rs (L52-55)
```rust
pub struct NetworkInformationResponse {
    pub connected_peers: BTreeMap<PeerNetworkId, ConnectionMetadata>, // Connected peers
    pub distance_from_validators: u64, // The distance of the peer from the validator set
}
```

**File:** peer-monitoring-service/types/src/response.rs (L94-102)
```rust
#[derive(Clone, Debug, Default, Deserialize, Eq, PartialEq, Serialize)]
pub struct NodeInformationResponse {
    pub build_information: BTreeMap<String, String>, // The build information of the node
    pub highest_synced_epoch: u64,                   // The highest synced epoch of the node
    pub highest_synced_version: u64,                 // The highest synced version of the node
    pub ledger_timestamp_usecs: u64, // The latest timestamp of the blockchain (in microseconds)
    pub lowest_available_version: u64, // The lowest stored version of the node (in storage)
    pub uptime: Duration,            // The amount of time the peer has been running
}
```

**File:** network/framework/src/transport/mod.rs (L277-293)
```rust
    let (mut socket, remote_peer_id, peer_role) =
        ctxt.noise.upgrade_inbound(socket).await.map_err(|err| {
            if err.should_security_log() {
                sample!(
                    SampleRate::Duration(Duration::from_secs(15)),
                    warn!(
                        SecurityEvent::NoiseHandshake,
                        NetworkSchema::new(&ctxt.noise.network_context)
                            .network_address(&addr)
                            .connection_origin(&origin),
                        error = %err,
                    )
                );
            }
            let err = io::Error::other(err);
            add_pp_addr(proxy_protocol_enabled, err, &addr)
        })?;
```

**File:** config/src/config/peer_monitoring_config.rs (L26-26)
```rust
            max_concurrent_requests: 1000,
```

**File:** network/framework/src/noise/handshake.rs (L95-98)
```rust
    /// In `MaybeMutual` mode, the dialer authenticates the server and the server will allow all
    /// inbound connections from any peer but will mark connections as `Trusted` if the incoming
    /// connection is apart of its trusted peers set.
    MaybeMutual(Arc<PeersAndMetadata>),
```
