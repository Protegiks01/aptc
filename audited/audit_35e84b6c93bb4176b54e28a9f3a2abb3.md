# Audit Report

## Title
Missing Event Coordinate Validation in lookup_event_by_key() Allows Corrupted Database State to Return Wrong Events

## Summary
The `lookup_event_by_key()` function returns event coordinates `(version, index)` from the database index without validating that these coordinates point to the correct event. If database corruption occurs, the function can silently return coordinates pointing to a different valid event, causing critical functions like `get_raw_block_info_by_height()` to return incorrect block information.

## Finding Description

The vulnerability exists in the event retrieval path: [1](#0-0) 

This function reads coordinates from `EventByKeySchema` index and returns them without validation. The coordinates are then used to fetch events: [2](#0-1) 

The critical issue: after fetching the event at the returned coordinates, there is NO verification that the event's key and sequence number match the requested parameters. The `ContractEventV1` struct contains these fields that could be validated: [3](#0-2) 

**Attack Scenario:**

1. Database corruption (hardware failure, software bug, or tampering) causes `EventByKeySchema` entry for `(new_block_event_key, height=100)` to incorrectly point to `(version=2000, index=0)` instead of correct `(version=1000, index=0)`

2. `lookup_event_by_key()` reads corrupted index and returns `(2000, 0)` without validation

3. `get_event_by_version_and_index(2000, 0)` fetches whatever event exists at those coordinates

4. If a valid event exists at `(2000, 0)`, it's returned as the "correct" event for height 100

5. Critical function affected: [4](#0-3) 

This causes `get_raw_block_info_by_height()` to return wrong block information, breaking the **State Consistency** and **Deterministic Execution** invariants.

## Impact Explanation

**Medium Severity** - State inconsistencies requiring intervention:

- If different nodes experience different database corruption patterns, they could retrieve different block events for the same height
- This violates deterministic execution across validators
- Critical blockchain operations like block info retrieval return incorrect data
- The corruption is silent - no error is raised, allowing wrong state to propagate

The issue doesn't cause immediate consensus failure but creates state inconsistencies that require manual intervention to detect and correct.

## Likelihood Explanation

**Low to Medium Likelihood:**

- Modern databases include checksums to detect corruption
- For exploitation, corrupted coordinates must point to another valid event (not just any coordinates)
- Requires specific corruption patterns rather than random bit flips
- However, once corruption occurs in this specific pattern, the impact is guaranteed since no validation exists

The function's lack of defensive validation means ANY such corruption will silently return wrong data.

## Recommendation

Add validation in `get_event_by_key()` to verify the fetched event matches requested parameters:

```rust
pub fn get_event_by_key(
    &self,
    event_key: &EventKey,
    seq_num: u64,
    ledger_version: Version,
) -> Result<(Version, ContractEvent)> {
    let (version, index) = self.lookup_event_by_key(event_key, seq_num, ledger_version)?;
    let event = self.get_event_by_version_and_index(version, index)?;
    
    // Validate the event matches requested coordinates
    if let ContractEvent::V1(v1) = &event {
        if v1.key() != event_key || v1.sequence_number() != seq_num {
            return Err(AptosDbError::Other(format!(
                "Database corruption: Event at ({}, {}) has key={:?} seq={}, expected key={:?} seq={}",
                version, index, v1.key(), v1.sequence_number(), event_key, seq_num
            )));
        }
    }
    
    Ok((version, event))
}
```

This provides defense-in-depth against database corruption and makes failures loud rather than silent.

## Proof of Concept

```rust
#[test]
fn test_corrupted_event_coordinates() {
    // Setup: Create test database with events
    let db = setup_test_db();
    
    // Event 1: (key=K1, seq=10) at (version=100, index=0)
    // Event 2: (key=K2, seq=20) at (version=200, index=0)
    store_test_events(&db);
    
    // Simulate corruption: Manually corrupt EventByKeySchema
    // Make (K1, seq=10) point to (version=200, index=0) instead
    corrupt_event_index(&db, key1, 10, 200, 0);
    
    // Attempt to retrieve event for K1, seq=10
    let (version, event) = db.event_store
        .get_event_by_key(&key1, 10, 1000)
        .unwrap();
    
    // BUG: Returns event for K2 instead of K1!
    // Version is 200 (wrong), event has key=K2 (wrong)
    assert_eq!(version, 200);  // Should be 100
    assert_ne!(event.event_key().unwrap(), &key1);  // Returns K2's event!
    
    // Expected: Should return error about coordinate mismatch
    // Actual: Silently returns wrong event
}
```

## Notes

While the validation database checker exists for offline verification, runtime validation is missing: [5](#0-4) 

This offline validation confirms the integrity check should also exist in the runtime path for defense-in-depth against corruption.

### Citations

**File:** storage/aptosdb/src/event_store/mod.rs (L62-73)
```rust
    pub fn get_event_by_key(
        &self,
        event_key: &EventKey,
        seq_num: u64,
        ledger_version: Version,
    ) -> Result<(Version, ContractEvent)> {
        let (version, index) = self.lookup_event_by_key(event_key, seq_num, ledger_version)?;
        Ok((
            version,
            self.get_event_by_version_and_index(version, index)?,
        ))
    }
```

**File:** storage/aptosdb/src/event_store/mod.rs (L145-161)
```rust
    fn lookup_event_by_key(
        &self,
        event_key: &EventKey,
        seq_num: u64,
        ledger_version: Version,
    ) -> Result<(Version, u64)> {
        let indices = self.lookup_events_by_key(event_key, seq_num, 1, ledger_version)?;
        if indices.is_empty() {
            return Err(AptosDbError::NotFound(format!(
                "Event {} of seq num {}.",
                event_key, seq_num
            )));
        }
        let (_seq, version, index) = indices[0];

        Ok((version, index))
    }
```

**File:** types/src/contract_event.rs (L180-217)
```rust
pub struct ContractEventV1 {
    /// The unique key that the event was emitted to
    key: EventKey,
    /// The number of messages that have been emitted to the path previously
    sequence_number: u64,
    /// The type of the data
    type_tag: TypeTag,
    /// The data payload of the event
    #[serde(with = "serde_bytes")]
    event_data: Vec<u8>,
}

impl ContractEventV1 {
    pub fn new(
        key: EventKey,
        sequence_number: u64,
        type_tag: TypeTag,
        event_data: Vec<u8>,
    ) -> anyhow::Result<Self> {
        let event = Self {
            key,
            sequence_number,
            type_tag,
            event_data,
        };

        // Ensure size is "computable".
        event.size()?;
        Ok(event)
    }

    pub fn key(&self) -> &EventKey {
        &self.key
    }

    pub fn sequence_number(&self) -> u64 {
        self.sequence_number
    }
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L317-338)
```rust
    pub(super) fn get_raw_block_info_by_height(&self, block_height: u64) -> Result<BlockInfo> {
        if !self.skip_index_and_usage {
            let (first_version, new_block_event) = self.event_store.get_event_by_key(
                &new_block_event_key(),
                block_height,
                self.ensure_synced_version()?,
            )?;
            let new_block_event = bcs::from_bytes(new_block_event.event_data())?;
            Ok(BlockInfo::from_new_block_event(
                first_version,
                &new_block_event,
            ))
        } else {
            Ok(self
                .ledger_db
                .metadata_db()
                .get_block_info(block_height)?
                .ok_or_else(|| {
                    AptosDbError::NotFound(format!("BlockInfo not found at height {block_height}"))
                })?)
        }
    }
```

**File:** storage/aptosdb/src/db_debugger/validation.rs (L228-253)
```rust
fn verify_event_by_key(
    event_key: &EventKey,
    seq_num: u64,
    internal_indexer_db: &DB,
    expected_idx: usize,
    expected_version: u64,
) -> Result<()> {
    match internal_indexer_db.get::<EventByKeySchema>(&(*event_key, seq_num)) {
        Ok(None) => {
            panic!("Event not found in internal indexer db: {:?}", event_key);
        },
        Err(e) => {
            panic!("Error while fetching event: {:?}", e);
        },
        Ok(Some((version, idx))) => {
            assert!(idx as usize == expected_idx && version == expected_version);
            if version as usize % SAMPLE_RATE == 0 {
                println!(
                    "Processed {} at {:?}, {:?}",
                    version, event_key, expected_idx
                );
            }
        },
    }
    Ok(())
}
```
