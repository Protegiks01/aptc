# Audit Report

## Title
Block Retrieval Retry Logic Bypass via IdNotFound Status Enables Validator Sync Denial

## Summary
The `retrieve_block_chunk` function in the consensus sync manager returns immediately upon receiving any valid `BlockRetrievalResponse`, regardless of status. When a malicious validator responds with `BlockRetrievalStatus::IdNotFound`, the retry logic is completely bypassed, preventing the requesting validator from attempting to fetch blocks from other honest peers. This enables a single malicious validator to systematically prevent other validators from syncing when selected as the preferred peer.

## Finding Description

The vulnerability exists in the block retrieval retry mechanism. The `retrieve_block_chunk` function is responsible for fetching blocks from peers with automatic retry logic across multiple peers if the initial attempts fail. [1](#0-0) 

The critical flaw is that the function returns immediately for ANY `Ok(BlockRetrievalResponse)` without validating the response status. The `BlockRetrievalStatus` enum has four variants: [2](#0-1) 

When a peer responds with `IdNotFound` or `NotEnoughBlocks`, these are valid response structures that pass through as `Ok(result)`, causing immediate return and bypassing the retry loop that would attempt other peers.

The retry logic only activates for network-level errors (RpcError, timeout, deserialization failures), not for application-level failure statuses: [3](#0-2) 

The caller `retrieve_blocks` expects either `Succeeded` or `SucceededWithTarget` status and bails for any other status: [4](#0-3) 

**Attack Scenario:**
1. Honest validator V_h falls behind and needs to sync blocks
2. Malicious validator V_m is selected as the preferred peer (first peer attempted)
3. V_h sends `BlockRetrievalRequest` to V_m for missing blocks
4. V_m has the blocks but responds with `BlockRetrievalResponse { status: IdNotFound, blocks: [] }`
5. The response passes validation (internally consistent response): [5](#0-4) 

6. `retrieve_block_chunk` returns this response immediately without trying other peers
7. `retrieve_blocks` sees `IdNotFound` status and bails with error
8. V_h fails to sync and falls behind, unable to participate effectively in consensus
9. No higher-level retry mechanism exists - the sync must wait for the next `SyncInfo` message from a different peer: [6](#0-5) 

The test `test_rpc()` demonstrates returning `IdNotFound` but never validates that retry logic engages with other peers: [7](#0-6) 

The test only verifies RPC messaging works and `IdNotFound` is correctly parsed, not that the system retries with alternative peers.

## Impact Explanation

**Severity: Medium to High**

This vulnerability enables a single malicious validator to cause liveness degradation without requiring collusion or >1/3 stake control. When the malicious validator is selected as the preferred peer (which happens regularly due to validator rotation), it can systematically prevent honest validators from syncing.

**Impact Categories (per Aptos Bug Bounty):**

- **High Severity**: "Validator node slowdowns" - Affected validators experience significant sync delays, falling behind in consensus and missing proposal/voting opportunities
- **Medium Severity**: "State inconsistencies requiring intervention" - Validators may require manual intervention or wait for alternative sync paths

The attack doesn't directly violate consensus safety (no double-spend or chain split), but causes:
- **Liveness Degradation**: Affected validators can't catch up efficiently
- **Reduced Network Resilience**: Multiple affected validators reduce overall network health
- **Increased Sync Latency**: Validators must wait for alternative sync opportunities

## Likelihood Explanation

**Likelihood: Medium to High**

The vulnerability is **highly exploitable** because:

1. **Low Complexity**: Malicious validator only needs to return `IdNotFound` instead of blocks - trivial modification
2. **Frequent Opportunity**: Preferred peer selection ensures each validator gets regular opportunities to be the first peer contacted
3. **No Detection**: The malicious response appears legitimate (valid `BlockRetrievalResponse` structure)
4. **No Byzantine Threshold Required**: Single validator (<<1/3 stake) can exploit this

**Limiting Factors:**
- Requires validator-level access (not fully unprivileged)
- Affected validators eventually sync through alternative paths (SyncInfo from other peers)
- Detection possible through monitoring if sync failures correlate with specific peers

The vulnerability violates the expected behavior that block retrieval should try multiple peers when one peer cannot provide blocks.

## Recommendation

Modify `retrieve_block_chunk` to check the response status and only return immediately for successful statuses. For failure statuses (`IdNotFound`, `NotEnoughBlocks`), treat them as failed attempts and continue the retry loop:

**Fix in `consensus/src/block_storage/sync_manager.rs`:**

```rust
Some((peer, response)) = futures.next() => {
    match response {
        Ok(result) => {
            // Only return immediately for successful statuses
            match result.status() {
                BlockRetrievalStatus::Succeeded | 
                BlockRetrievalStatus::SucceededWithTarget => {
                    return Ok(result);
                },
                status => {
                    // Log failure status and continue retrying with other peers
                    warn!(
                        remote_peer = peer,
                        block_id = block_id,
                        status = ?status,
                        "Peer returned non-success status, trying other peers",
                    );
                    failed_attempt += 1;
                }
            }
        },
        e => {
            warn!(
                remote_peer = peer,
                block_id = block_id,
                "{:?}, Failed to fetch block",
                e,
            );
            failed_attempt += 1;
        },
    }
},
```

This ensures that when a peer returns `IdNotFound` or `NotEnoughBlocks`, the system continues retrying with other peers in the peer list, making the retry mechanism function as intended.

## Proof of Concept

```rust
#[tokio::test]
async fn test_block_retrieval_retries_on_id_not_found() {
    use consensus::block_storage::sync_manager::BlockRetriever;
    use consensus_types::block_retrieval::*;
    
    // Setup: 3 validators - 1 malicious, 2 honest
    let (mut malicious_peer, honest_peer_1, honest_peer_2) = setup_peers();
    
    // Malicious peer is selected as preferred peer (first to be tried)
    let mut retriever = BlockRetriever::new(
        network,
        malicious_peer.address,  // preferred peer
        vec![malicious_peer.address, honest_peer_1.address, honest_peer_2.address],
        max_blocks,
        pending_blocks,
    );
    
    // Setup malicious peer to respond with IdNotFound even though it has the blocks
    malicious_peer.set_response_handler(|req| {
        BlockRetrievalResponse::new(BlockRetrievalStatus::IdNotFound, vec![])
    });
    
    // Setup honest peers to respond correctly with blocks
    honest_peer_1.set_response_handler(|req| {
        let blocks = honest_peer_1.get_blocks(req.block_id(), req.num_blocks());
        BlockRetrievalResponse::new(BlockRetrievalStatus::Succeeded, blocks)
    });
    
    // Attempt to retrieve blocks
    let result = retriever.retrieve_blocks_in_range(
        target_block_id,
        num_blocks,
        TargetBlockRetrieval::TargetBlockId(genesis_id),
        vec![malicious_peer.address, honest_peer_1.address, honest_peer_2.address],
    ).await;
    
    // VULNERABILITY: Request fails even though honest peers have the blocks
    // Expected: Should retry with honest_peer_1 and succeed
    // Actual: Fails immediately after malicious_peer returns IdNotFound
    assert!(result.is_err());  // This demonstrates the vulnerability
    
    // After fix, this should succeed:
    // assert!(result.is_ok());
    // assert_eq!(result.unwrap().len(), num_blocks);
}
```

## Notes

The vulnerability is particularly concerning because:

1. **The test gap is real**: `test_rpc()` validates RPC messaging but not retry behavior on failure statuses
2. **Production code path**: This affects actual validator sync operations, not just test scenarios
3. **Design assumption violation**: The retry mechanism assumes network-level failures, not application-level status failures
4. **Compounding effect**: If multiple validators are affected, network-wide liveness degrades

The fix is straightforward and maintains backward compatibility while properly implementing the intended retry behavior across multiple peers when block retrieval fails.

### Citations

**File:** consensus/src/block_storage/sync_manager.rs (L726-738)
```rust
                    Some((peer, response)) = futures.next() => {
                        match response {
                            Ok(result) => return Ok(result),
                            e => {
                                warn!(
                                    remote_peer = peer,
                                    block_id = block_id,
                                    "{:?}, Failed to fetch block",
                                    e,
                                );
                                failed_attempt += 1;
                            },
                        }
```

**File:** consensus/src/block_storage/sync_manager.rs (L740-776)
```rust
                    _ = interval.tick() => {
                        // send batch request to a set of peers of size request_num_peers (or 1 for the first time)
                        let next_peers = if cur_retry < num_retries {
                            let first_attempt = cur_retry == 0;
                            cur_retry += 1;
                            self.pick_peers(
                                first_attempt,
                                &mut peers,
                                if first_attempt { 1 } else {request_num_peers}
                            )
                        } else {
                            Vec::new()
                        };

                        if next_peers.is_empty() && futures.is_empty() {
                            bail!("Couldn't fetch block")
                        }

                        for peer in next_peers {
                            debug!(
                                LogSchema::new(LogEvent::RetrieveBlock).remote_peer(peer),
                                block_id = block_id,
                                "Fetching {} blocks, retry {}, failed attempts {}",
                                retrieve_batch_size,
                                cur_retry,
                                failed_attempt
                            );
                            let remote_peer = peer;
                            let future = self.network.request_block(
                                request.clone(),
                                peer,
                                rpc_timeout,
                            );
                            futures.push(async move { (remote_peer, future.await) }.boxed());
                        }
                    }
                }
```

**File:** consensus/src/block_storage/sync_manager.rs (L836-860)
```rust
            match response {
                Ok(result) if matches!(result.status(), BlockRetrievalStatus::Succeeded) => {
                    // extend the result blocks
                    let batch = result.blocks().clone();
                    progress += batch.len() as u64;
                    last_block_id = batch.last().expect("Batch should not be empty").parent_id();
                    result_blocks.extend(batch);
                },
                Ok(result)
                    if matches!(result.status(), BlockRetrievalStatus::SucceededWithTarget) =>
                {
                    // if we found the target, end the loop
                    let batch = result.blocks().clone();
                    result_blocks.extend(batch);
                    break;
                },
                res => {
                    bail!(
                        "Failed to fetch block {}, for original start {}, returned status {:?}",
                        last_block_id,
                        block_id,
                        res
                    );
                },
            }
```

**File:** consensus/consensus-types/src/block_retrieval.rs (L170-179)
```rust
pub enum BlockRetrievalStatus {
    // Successfully fill in the request.
    Succeeded,
    // Can not find the block corresponding to block_id.
    IdNotFound,
    // Can not find enough blocks but find some.
    NotEnoughBlocks,
    // Successfully found the target,
    SucceededWithTarget,
}
```

**File:** consensus/src/network.rs (L301-313)
```rust
        // Verify response against retrieval request
        response
            .verify(retrieval_request, &self.validators)
            .map_err(|e| {
                error!(
                    SecurityEvent::InvalidRetrievedBlock,
                    request_block_response = response,
                    error = ?e,
                );
                e
            })?;

        Ok(response)
```

**File:** consensus/src/round_manager.rs (L878-906)
```rust
    async fn sync_up(&mut self, sync_info: &SyncInfo, author: Author) -> anyhow::Result<()> {
        let local_sync_info = self.block_store.sync_info();
        if sync_info.has_newer_certificates(&local_sync_info) {
            info!(
                self.new_log(LogEvent::ReceiveNewCertificate)
                    .remote_peer(author),
                "Local state {},\n remote state {}", local_sync_info, sync_info
            );
            // Some information in SyncInfo is ahead of what we have locally.
            // First verify the SyncInfo (didn't verify it in the yet).
            sync_info.verify(&self.epoch_state.verifier).map_err(|e| {
                error!(
                    SecurityEvent::InvalidSyncInfoMsg,
                    sync_info = sync_info,
                    remote_peer = author,
                    error = ?e,
                );
                VerifyError::from(e)
            })?;
            SYNC_INFO_RECEIVED_WITH_NEWER_CERT.inc();
            let result = self
                .block_store
                .add_certs(sync_info, self.create_block_retriever(author))
                .await;
            self.process_certificates().await?;
            result
        } else {
            Ok(())
        }
```

**File:** consensus/src/network_tests.rs (L824-826)
```rust
                let response =
                    BlockRetrievalResponse::new(BlockRetrievalStatus::IdNotFound, vec![]);
                let response = ConsensusMsg::BlockRetrievalResponse(Box::new(response));
```
