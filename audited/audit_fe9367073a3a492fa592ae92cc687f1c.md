# Audit Report

## Title
Unvalidated Randomness Threshold Percentages Enable Security Guarantee Degradation in DKG Configuration

## Summary
The `From<ReleaseFriendlyRandomnessConfig>` implementation for `OnChainRandomnessConfig` performs no validation on threshold percentages before calling `new_v1()` or `new_v2()`. Invalid threshold values can propagate through governance proposals to on-chain configuration, where the DKG system's fallback mechanism silently accepts them with degraded security parameters instead of rejecting the invalid configuration.

## Finding Description
The type conversion chain for randomness configuration lacks validation at every layer:

1. **Rust Type Conversion Layer**: The `From` implementation directly passes unvalidated percentage values to constructors. [1](#0-0) 

2. **Rust Constructor Layer**: The `new_v1()` and `new_v2()` functions perform no validation on percentage inputs before converting to `FixedPoint64`. [2](#0-1) 

3. **Move Constructor Layer**: The Move `new_v1()` and `new_v2()` functions also lack validation. [3](#0-2) 

4. **DKG Validation Point**: Validation only occurs when DKG attempts to use the thresholds, but failures trigger a fallback that accepts invalid values. [4](#0-3) 

When `DKGRoundingProfile::new()` validation fails (e.g., for secrecy < 33.33% or reconstruct > 66.67%), the system falls back to the `infallible()` method which accepts the invalid thresholds after minimal sanitization: [5](#0-4) 

The `infallible()` method only clamps values to [0,1] and ensures `reconstruct >= secrecy`, but does NOT enforce the critical security constraints that `secrecy > 1/3` and `reconstruct <= 2/3`.

**Attack Scenario:**
1. Governance proposal contains malicious/buggy randomness configuration: `secrecy=10%, reconstruct=20%`
2. Values pass through `From` trait conversion without validation
3. Move script generated by release builder calls `new_v1(create_from_rational(10, 100), create_from_rational(20, 100))`
4. Configuration stored on-chain with weak thresholds
5. At epoch boundary, DKG validation fails but fallback accepts values
6. DKG proceeds with 20% reconstruction threshold instead of required 67%
7. Small validator coalition (20% stake) can now reconstruct randomness, violating security assumptions

## Impact Explanation
This qualifies as **High Severity** under the "Significant protocol violations" category. The randomness beacon is a critical protocol component with specific security guarantees:
- Any validator subset ≤50% stake should NOT be able to reconstruct randomness
- Any validator subset >67% stake SHOULD be able to reconstruct randomness

By allowing invalid threshold configurations (e.g., 20% reconstruction), the vulnerability enables:
- Small validator coalitions to break randomness secrecy
- Potential randomness manipulation affecting all dependent applications
- Violation of the protocol's cryptographic correctness invariant

While this requires governance proposal passage (which includes the core team in trusted roles), the lack of validation violates defense-in-depth principles and could enable:
- Accidental misconfiguration
- Malicious proposals from compromised governance participants
- Future attack vectors as governance evolves

## Likelihood Explanation
**Medium-High Likelihood**. While requiring governance proposal passage, the conditions are realistic:
- No validation exists at any layer of the conversion pipeline
- The DKG fallback mechanism silently accepts invalid values rather than failing
- Configuration errors could occur accidentally during release preparation
- A determined attacker with sufficient stake could propose malicious configurations
- The validation failure is logged in `rounding_error` but DKG proceeds anyway

The fact that the system has an explicit `infallible()` fallback suggests the developers anticipated validation failures but chose graceful degradation over security guarantees.

## Recommendation
Implement validation at the type conversion boundary to fail fast on invalid configurations:

```rust
impl From<ReleaseFriendlyRandomnessConfig> for OnChainRandomnessConfig {
    fn from(value: ReleaseFriendlyRandomnessConfig) -> Self {
        match value {
            ReleaseFriendlyRandomnessConfig::Off => OnChainRandomnessConfig::Off,
            ReleaseFriendlyRandomnessConfig::V1 {
                secrecy_threshold_in_percentage,
                reconstruct_threshold_in_percentage,
            } => {
                // Validate thresholds meet security requirements
                assert!(
                    secrecy_threshold_in_percentage > 33,
                    "Secrecy threshold must be > 33%"
                );
                assert!(
                    reconstruct_threshold_in_percentage <= 67,
                    "Reconstruction threshold must be <= 67%"
                );
                assert!(
                    secrecy_threshold_in_percentage < reconstruct_threshold_in_percentage,
                    "Secrecy threshold must be less than reconstruction threshold"
                );
                
                OnChainRandomnessConfig::new_v1(
                    secrecy_threshold_in_percentage,
                    reconstruct_threshold_in_percentage,
                )
            },
            // Similar validation for V2...
        }
    }
}
```

Additionally, add validation in the Move layer: [6](#0-5) 

Add assertions before packing to reject invalid configurations at proposal execution time.

## Proof of Concept

```rust
#[test]
fn test_invalid_threshold_propagation() {
    use aptos_types::on_chain_config::{OnChainRandomnessConfig, ReleaseFriendlyRandomnessConfig};
    
    // Create config with invalid thresholds (below security requirements)
    let invalid_config = ReleaseFriendlyRandomnessConfig::V1 {
        secrecy_threshold_in_percentage: 10,  // Should be > 33
        reconstruct_threshold_in_percentage: 20,  // Should be > 67 for security
    };
    
    // This conversion succeeds without validation
    let on_chain_config = OnChainRandomnessConfig::from(invalid_config);
    
    // The config can now be used, but when DKG tries to use it:
    let validator_stakes = vec![1_000_000; 100]; // 100 equal validators
    let secrecy = on_chain_config.secrecy_threshold().unwrap();
    let reconstruct = on_chain_config.reconstruct_threshold().unwrap();
    
    let dkg_rounding = DKGRounding::new(
        &validator_stakes,
        secrecy,
        reconstruct,
        None,
    );
    
    // The rounding will use infallible() fallback
    // and accept the weak 20% reconstruction threshold
    assert!(dkg_rounding.rounding_error.is_some()); // Validation failed
    assert_eq!(
        dkg_rounding.profile.reconstruct_threshold_in_stake_ratio,
        U64F64::from_num(0.2)  // Weak 20% threshold accepted!
    );
}
```

## Notes
This vulnerability stems from trusting configuration inputs without validation, violating the defense-in-depth principle. While the DKG system attempts validation, its fallback mechanism prioritizes availability over security by accepting invalid parameters. The correct approach is rejecting invalid configurations at the earliest possible point—the type conversion boundary—preventing them from ever reaching on-chain state.

### Citations

**File:** aptos-move/aptos-release-builder/src/components/randomness_config.rs (L24-46)
```rust
impl From<ReleaseFriendlyRandomnessConfig> for OnChainRandomnessConfig {
    fn from(value: ReleaseFriendlyRandomnessConfig) -> Self {
        match value {
            ReleaseFriendlyRandomnessConfig::Off => OnChainRandomnessConfig::Off,
            ReleaseFriendlyRandomnessConfig::V1 {
                secrecy_threshold_in_percentage,
                reconstruct_threshold_in_percentage,
            } => OnChainRandomnessConfig::new_v1(
                secrecy_threshold_in_percentage,
                reconstruct_threshold_in_percentage,
            ),
            ReleaseFriendlyRandomnessConfig::V2 {
                secrecy_threshold_in_percentage,
                reconstruct_threshold_in_percentage,
                fast_path_secrecy_threshold_in_percentage,
            } => OnChainRandomnessConfig::new_v2(
                secrecy_threshold_in_percentage,
                reconstruct_threshold_in_percentage,
                fast_path_secrecy_threshold_in_percentage,
            ),
        }
    }
}
```

**File:** types/src/on_chain_config/randomness_config.rs (L101-136)
```rust
    pub fn new_v1(
        secrecy_threshold_in_percentage: u64,
        reconstruct_threshold_in_percentage: u64,
    ) -> Self {
        let secrecy_threshold = FixedPoint64MoveStruct::from_u64f64(
            U64F64::from_num(secrecy_threshold_in_percentage) / U64F64::from_num(100),
        );
        let reconstruction_threshold = FixedPoint64MoveStruct::from_u64f64(
            U64F64::from_num(reconstruct_threshold_in_percentage) / U64F64::from_num(100),
        );
        Self::V1(ConfigV1 {
            secrecy_threshold,
            reconstruction_threshold,
        })
    }

    pub fn new_v2(
        secrecy_threshold_in_percentage: u64,
        reconstruct_threshold_in_percentage: u64,
        fast_path_secrecy_threshold_in_percentage: u64,
    ) -> Self {
        let secrecy_threshold = FixedPoint64MoveStruct::from_u64f64(
            U64F64::from_num(secrecy_threshold_in_percentage) / U64F64::from_num(100),
        );
        let reconstruction_threshold = FixedPoint64MoveStruct::from_u64f64(
            U64F64::from_num(reconstruct_threshold_in_percentage) / U64F64::from_num(100),
        );
        let fast_path_secrecy_threshold = FixedPoint64MoveStruct::from_u64f64(
            U64F64::from_num(fast_path_secrecy_threshold_in_percentage) / U64F64::from_num(100),
        );
        Self::V2(ConfigV2 {
            secrecy_threshold,
            reconstruction_threshold,
            fast_path_secrecy_threshold,
        })
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/randomness_config.move (L92-115)
```text
    /// Create a `ConfigV1` variant.
    public fun new_v1(secrecy_threshold: FixedPoint64, reconstruction_threshold: FixedPoint64): RandomnessConfig {
        RandomnessConfig {
            variant: copyable_any::pack( ConfigV1 {
                secrecy_threshold,
                reconstruction_threshold
            } )
        }
    }

    /// Create a `ConfigV2` variant.
    public fun new_v2(
        secrecy_threshold: FixedPoint64,
        reconstruction_threshold: FixedPoint64,
        fast_path_secrecy_threshold: FixedPoint64,
    ): RandomnessConfig {
        RandomnessConfig {
            variant: copyable_any::pack( ConfigV2 {
                secrecy_threshold,
                reconstruction_threshold,
                fast_path_secrecy_threshold,
            } )
        }
    }
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L197-199)
```rust
        ensure!(secrecy_threshold_in_stake_ratio * U64F64::from_num(3) > U64F64::from_num(1));
        ensure!(secrecy_threshold_in_stake_ratio < reconstruct_threshold_in_stake_ratio);
        ensure!(reconstruct_threshold_in_stake_ratio * U64F64::from_num(3) <= U64F64::from_num(2));
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L254-282)
```rust
    pub fn infallible(
        validator_stakes: &Vec<u64>,
        mut secrecy_threshold_in_stake_ratio: U64F64,
        mut reconstruct_threshold_in_stake_ratio: U64F64,
        fast_secrecy_threshold_in_stake_ratio: Option<U64F64>,
    ) -> Self {
        let one = U64F64::from_num(1);
        secrecy_threshold_in_stake_ratio = min(one, secrecy_threshold_in_stake_ratio);
        reconstruct_threshold_in_stake_ratio = min(one, reconstruct_threshold_in_stake_ratio);
        reconstruct_threshold_in_stake_ratio = max(
            secrecy_threshold_in_stake_ratio,
            reconstruct_threshold_in_stake_ratio,
        );

        let stake_total = U64F64::from_num(validator_stakes.clone().into_iter().sum::<u64>());

        let estimated_weight_total = total_weight_upper_bound(
            validator_stakes,
            reconstruct_threshold_in_stake_ratio,
            secrecy_threshold_in_stake_ratio,
        );
        let stake_per_weight = stake_total / U64F64::from_num(estimated_weight_total);
        compute_profile_fixed_point(
            validator_stakes,
            stake_per_weight,
            secrecy_threshold_in_stake_ratio,
            fast_secrecy_threshold_in_stake_ratio,
        )
    }
```
