# Audit Report

## Title
Cross-Asset Resource Exhaustion via Shared Lock Contention and Queue Pollution in Faucet System

## Summary
The `update_sequence_numbers()` function in the Aptos faucet system uses a shared `RwLock` for all asset queues, combined with unbounded queue growth and missing cleanup logic. An attacker can flood one asset (e.g., "apt") with requests to exhaust resources, causing lock contention and degraded performance for all other assets (e.g., "btc", "usdc"), violating asset isolation guarantees.

## Finding Description

The faucet's per-asset queue system claims to ensure "requests for different assets don't interfere with each other" [1](#0-0) , but this isolation is broken by three critical flaws:

**Flaw 1: Shared Lock Contention**

All asset queues share a single `RwLock<HashMap<String, Vec<(AccountAddress, u64)>>>` [2](#0-1) . Every queue operation (add, check position, remove) acquires this lock [3](#0-2) . Heavy traffic on one asset causes lock contention affecting all assets.

**Flaw 2: Queue Pollution**

Requests are added to their asset's queue unconditionally [4](#0-3) , but only removed when at the front of the queue [5](#0-4) . If a request times out after the loop completes [6](#0-5)  without reaching the front, it remains in the queue permanently, never being cleaned up. The function still returns `Ok` [7](#0-6) , but the stale entry blocks future requests.

**Flaw 3: Unbounded Queue Growth**

No size limit is enforced before pushing to the queue [4](#0-3) , allowing unbounded memory consumption.

**Attack Path:**

1. Attacker sends 10,000 concurrent requests for asset "apt" with varying parameters
2. All requests enter `update_sequence_numbers()` and add themselves to the "apt" queue
3. Some requests at the back of the queue timeout (after `wait_for_outstanding_txns_secs * 2` iterations) without being removed
4. The "apt" queue is now polluted with stale entries and has 10,000 active requests contending for the lock
5. Legitimate user sends request for asset "btc"
6. The "btc" request must acquire the same `RwLock` to add itself to the "btc" queue
7. Due to heavy contention from "apt" requests, the "btc" request experiences severe delays
8. Memory consumption grows unboundedly as more requests flood "apt"

This violates the **Resource Limits** invariant (all operations must respect computational limits) and breaks asset isolation.

## Impact Explanation

**Medium Severity** - This qualifies as "State inconsistencies requiring intervention" per the bug bounty program:

- **Availability Impact**: Flooding one asset queue causes cross-contamination, degrading service for all assets requiring operator intervention to restart the faucet
- **Memory Exhaustion**: Unbounded queue growth can exhaust node memory
- **Queue Pollution**: Stale entries accumulate, requiring manual queue cleanup or service restart
- **Lock Contention DoS**: Shared lock becomes bottleneck affecting all asset processing

This doesn't directly affect consensus or validator nodes (limiting it to Medium), but does allow unprivileged attackers to degrade faucet availability system-wide through resource exhaustion on a single asset.

## Likelihood Explanation

**High Likelihood**: 
- No authentication required beyond standard faucet access
- Attack is trivial: just send many concurrent requests for one asset
- No rate limiting visible in the code path analyzed
- The faucet is a public-facing service expected to handle arbitrary user requests
- Queue pollution occurs naturally under load spikes even without malicious intent

## Recommendation

**Fix 1: Per-Asset Locks**
Replace the shared `RwLock<HashMap>` with per-asset locks to eliminate cross-asset contention:

```rust
// In MintFunder and TransferFunder
outstanding_requests: Arc<DashMap<String, Arc<RwLock<Vec<(AccountAddress, u64)>>>>>
```

**Fix 2: Bounded Queue with Cleanup**
Add queue size limits and cleanup logic:

```rust
const MAX_QUEUE_SIZE_PER_ASSET: usize = 100;

// Before line 241:
if queue.len() >= MAX_QUEUE_SIZE_PER_ASSET {
    return Err(AptosTapError::new(
        "Asset queue is full, try again later",
        AptosTapErrorCode::ServiceUnavailable,
    ));
}

// Add cleanup before line 305 (on timeout):
if set_outstanding {
    let mut requests_map = outstanding_requests.write().await;
    if let Some(queue) = requests_map.get_mut(asset_name) {
        queue.retain(|&k| k != request_key);
    }
}
```

**Fix 3: Periodic Queue Maintenance**
Implement background task to remove stale entries older than a timeout threshold.

## Proof of Concept

```rust
// Rust PoC demonstrating the attack
use tokio;
use std::sync::Arc;

async fn attack_scenario() {
    // Simulated faucet with MintFunder
    let faucet = setup_mint_funder().await;
    
    // Attack Phase 1: Queue pollution for "apt" asset
    let mut handles = vec![];
    for i in 0..10000 {
        let faucet_clone = faucet.clone();
        let handle = tokio::spawn(async move {
            let receiver = generate_random_address();
            // These will add to queue but many will timeout
            let _ = faucet_clone.fund(
                Some(1000000),
                receiver,
                Some("apt".to_string()),
                false,
                false
            ).await;
        });
        handles.push(handle);
    }
    
    // Let requests pile up
    tokio::time::sleep(tokio::time::Duration::from_secs(5)).await;
    
    // Attack Phase 2: Legitimate request for "btc" experiences delay
    let start = tokio::time::Instant::now();
    let btc_result = faucet.fund(
        Some(1000000),
        generate_random_address(),
        Some("btc".to_string()),
        false,
        false
    ).await;
    let elapsed = start.elapsed();
    
    // Expected: btc request takes 10+ seconds due to lock contention
    // Expected: apt queue has thousands of stale entries
    println!("BTC request took: {:?}", elapsed);
    assert!(elapsed > tokio::time::Duration::from_secs(10));
}
```

**Observable Evidence:**
1. Monitor the `outstanding_requests` HashMap size - it grows unboundedly
2. Monitor lock acquisition times - they increase linearly with queue size
3. Cross-asset requests experience degraded latency proportional to the attacked asset's queue size
4. Memory usage increases without bound under sustained load

## Notes

This vulnerability is particularly concerning because:

1. **Asset Isolation is a Security Property**: The documentation explicitly states assets should not interfere [1](#0-0) , making this a specification violation

2. **Both Funder Types Affected**: Both `MintFunder` [8](#0-7)  and `TransferFunder` [9](#0-8)  share this vulnerability

3. **No Built-in Mitigation**: No rate limiting, queue bounds, or cleanup mechanisms exist in the analyzed code paths

### Citations

**File:** crates/aptos-faucet/core/src/funder/common.rs (L199-202)
```rust
/// Each asset has its own independent queue: HashMap<String, Vec<(AccountAddress, u64)>>.
/// This ensures requests for different assets don't interfere with each other while maintaining
/// FIFO ordering within each asset. For single-asset funders (like TransferFunder), use
/// DEFAULT_ASSET_NAME. For multi-asset funders (like MintFunder), pass the specific asset name.
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L207-207)
```rust
    outstanding_requests: &RwLock<HashMap<String, Vec<(AccountAddress, u64)>>>,
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L232-232)
```rust
    for _ in 0..(wait_for_outstanding_txns_secs * 2) {
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L237-263)
```rust
                let mut requests_map = outstanding_requests.write().await;
                let queue = requests_map
                    .entry(asset_name.to_string())
                    .or_insert_with(Vec::new);
                queue.push(request_key);
                set_outstanding = true;
            }

            // Check if this request is at the front of the queue for this asset
            let requests_map = outstanding_requests.read().await;
            let is_at_front = if let Some(queue) = requests_map.get(asset_name) {
                queue.first() == Some(&request_key)
            } else {
                false
            };

            if is_at_front {
                // There might have been two requests with the same parameters, so we ensure that
                // we only pop off one of them. We do a read lock first since that is cheap,
                // followed by a write lock.
                drop(requests_map);
                let mut requests_map = outstanding_requests.write().await;
                if let Some(queue) = requests_map.get_mut(asset_name) {
                    if queue.first() == Some(&request_key) {
                        queue.remove(0);
                    }
                }
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L305-305)
```rust
    Ok((funder_seq, receiver_seq))
```

**File:** crates/aptos-faucet/core/src/funder/mint.rs (L218-218)
```rust
    outstanding_requests: RwLock<HashMap<String, Vec<(AccountAddress, u64)>>>,
```

**File:** crates/aptos-faucet/core/src/funder/transfer.rs (L121-121)
```rust
    outstanding_requests: RwLock<HashMap<String, Vec<(AccountAddress, u64)>>>,
```
