# Audit Report

## Title
Stack Overflow via Deeply Nested BooleanTransactionFilter in Indexer gRPC Service

## Summary
The indexer-grpc service allows clients to send transaction filters with arbitrary nesting depth. Due to the `no-recursion-limit` feature enabled in prost and lack of depth validation, an attacker can craft a deeply nested filter that causes stack overflow during parsing or evaluation, leading to service crashes.

## Finding Description

The indexer-grpc service accepts `GetTransactionsRequest` messages containing an optional `BooleanTransactionFilter`. This filter has a recursive structure where `LogicalNot` can contain another `BooleanTransactionFilter`, enabling arbitrary nesting like `NOT(NOT(NOT(...)))`. [1](#0-0) 

The filter validation only checks the total encoded protobuf size against `DEFAULT_MAX_TRANSACTION_FILTER_SIZE_BYTES` (10,000 bytes), but does NOT enforce a maximum nesting depth: [2](#0-1) [3](#0-2) 

The recursion happens in two places:

1. **During parsing** when converting from protobuf to Rust types (nested `new_from_proto` calls): [4](#0-3) 

2. **During evaluation** when matching filters against transactions: [5](#0-4) 

Critically, the Aptos codebase has **explicitly disabled** prost's default recursion protection: [6](#0-5) 

**Attack Scenario:**
1. Attacker constructs a filter with ~3000+ nested `NOT` operations (each adds ~2-3 bytes to protobuf encoding, staying under 10KB limit)
2. Sends `GetTransactionsRequest` with this filter to any indexer-grpc endpoint
3. During parsing, recursive `new_from_proto` calls overflow the stack (Rust default: ~2MB)
4. Alternatively, during filter evaluation against each transaction, recursive `matches()` calls overflow the stack
5. Service crashes with stack overflow error

## Impact Explanation

This qualifies as **High Severity** per Aptos bug bounty criteria:
- **API crashes**: The indexer-grpc service crashes completely, affecting all clients
- **Service unavailability**: Legitimate users cannot access historical transaction data
- **Repeated exploitation**: Attacker can repeatedly crash the service with minimal resources

While the indexer-grpc is not part of core consensus, it is a critical data access layer for ecosystem applications, wallets, and explorers. This is explicitly covered under "API crashes" in the High Severity category.

## Likelihood Explanation

**Likelihood: High**

- **No authentication required**: Any client can send requests to public indexer-grpc endpoints
- **Trivial to exploit**: Constructing the malicious filter requires basic protobuf knowledge
- **Deterministic**: The attack reliably crashes the service every time
- **Low cost**: Attacker needs minimal bandwidth (request is <10KB)
- **No detection**: The filter passes size validation and only fails during execution

## Recommendation

**Immediate Fix**: Add explicit recursion depth limit to `BooleanTransactionFilter::new_from_proto`:

```rust
const MAX_FILTER_DEPTH: usize = 100;

impl BooleanTransactionFilter {
    pub fn new_from_proto(
        proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
        max_filter_size: Option<usize>,
    ) -> Result<Self> {
        Self::new_from_proto_with_depth(proto_filter, max_filter_size, 0)
    }

    fn new_from_proto_with_depth(
        proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
        max_filter_size: Option<usize>,
        current_depth: usize,
    ) -> Result<Self> {
        ensure!(
            current_depth < MAX_FILTER_DEPTH,
            format!("Filter nesting depth exceeds maximum of {}", MAX_FILTER_DEPTH)
        );
        
        if let Some(max_filter_size) = max_filter_size {
            ensure!(
                proto_filter.encoded_len() <= max_filter_size,
                format!("Filter is too complicated...")
            );
        }
        
        // Pass depth+1 to all recursive calls
        // Update LogicalAnd::try_from, LogicalOr::try_from, LogicalNot::try_from
        // to accept and propagate depth parameter
        ...
    }
}
```

Apply similar depth tracking to `LogicalAnd`, `LogicalOr`, and `LogicalNot` implementations.

## Proof of Concept

```rust
use aptos_protos::indexer::v1::{BooleanTransactionFilter as ProtoBooleanTransactionFilter, boolean_transaction_filter::Filter};
use aptos_transaction_filter::BooleanTransactionFilter;
use prost::Message;

fn main() {
    // Create deeply nested NOT(NOT(NOT(...))) filter
    let mut filter = ProtoBooleanTransactionFilter {
        filter: Some(Filter::ApiFilter(/* simple leaf filter */)),
    };
    
    // Nest 3000 levels deep
    for _ in 0..3000 {
        filter = ProtoBooleanTransactionFilter {
            filter: Some(Filter::LogicalNot(Box::new(filter))),
        };
    }
    
    // Verify size is under 10KB limit
    assert!(filter.encoded_len() < 10_000);
    
    // This will cause stack overflow
    let result = BooleanTransactionFilter::new_from_proto(filter, Some(10_000));
    // Program crashes before reaching this point
}
```

## Notes

This vulnerability is distinct from the `MESSAGE_SIZE_LIMIT` constant mentioned in the security question. The `MESSAGE_SIZE_LIMIT` (15MB) is used for chunking **outgoing** transaction responses, not validating **incoming** filter requests. The actual vulnerability exploits `DEFAULT_MAX_TRANSACTION_FILTER_SIZE_BYTES` (10KB) which validates filter size but not nesting depth. The disabled `no-recursion-limit` feature in prost removes a critical defense layer that would normally prevent this attack.

### Citations

**File:** protos/proto/aptos/indexer/v1/filter.proto (L58-65)
```text
message BooleanTransactionFilter {
  oneof filter {
      APIFilter api_filter = 1;
      LogicalAndFilters logical_and = 2;
      LogicalOrFilters logical_or = 3;
      BooleanTransactionFilter logical_not = 4;
  }
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/constants.rs (L20-21)
```rust
// Default maximum size in bytes for transaction filters.
pub const DEFAULT_MAX_TRANSACTION_FILTER_SIZE_BYTES: usize = 10_000;
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L94-107)
```rust
    pub fn new_from_proto(
        proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
        max_filter_size: Option<usize>,
    ) -> Result<Self> {
        if let Some(max_filter_size) = max_filter_size {
            ensure!(
                proto_filter.encoded_len() <= max_filter_size,
                format!(
                    "Filter is too complicated. Max size: {} bytes, Actual size: {} bytes",
                    max_filter_size,
                    proto_filter.encoded_len()
                )
            );
        }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L345-357)
```rust
impl TryFrom<Box<aptos_protos::indexer::v1::BooleanTransactionFilter>> for LogicalNot {
    type Error = anyhow::Error;

    fn try_from(
        proto_filter: Box<aptos_protos::indexer::v1::BooleanTransactionFilter>,
    ) -> Result<Self> {
        Ok(Self {
            not: Box::new(BooleanTransactionFilter::new_from_proto(
                *proto_filter,
                None,
            )?),
        })
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L360-368)
```rust
impl Filterable<Transaction> for LogicalNot {
    fn validate_state(&self) -> Result<(), FilterError> {
        self.not.is_valid()
    }

    fn matches(&self, item: &Transaction) -> bool {
        !self.not.matches(item)
    }
}
```

**File:** Cargo.toml (L742-742)
```text
prost = { version = "0.13.4", features = ["no-recursion-limit"] }
```
