# Audit Report

## Title
Unstable Bytecode Bypass via CompilationMetadata Removal Allows Experimental Features on Mainnet

## Summary
The unstable bytecode protection mechanism in `check_versions()` and `reject_unstable_bytecode()` can be completely bypassed by removing the CompilationMetadata from compiled modules. This allows deployment of experimental compiler and language features to mainnet, potentially introducing untested code that could cause consensus splits or VM execution bugs.

## Finding Description

The Aptos codebase implements a multi-layered check to prevent unstable/experimental bytecode from being deployed to mainnet:

1. **Build-time warning** in `check_versions()` that checks if compiler or language versions are unstable [1](#0-0) 

2. **Runtime enforcement** in `reject_unstable_bytecode()` that rejects modules with `unstable: true` in their CompilationMetadata [2](#0-1) 

The `unstable()` methods themselves correctly identify experimental versions through exhaustive enum matching: [3](#0-2) [4](#0-3) 

**However, the critical vulnerability is in the enforcement logic.** The runtime check uses an `if let Some(metadata)` pattern that silently passes modules without CompilationMetadata: [5](#0-4) 

When `get_compilation_metadata(module)` returns `None`, the inner check never executes and the function returns `Ok(())`. The `get_compilation_metadata()` function returns `None` if the metadata key doesn't exist: [6](#0-5) 

**Attack Vector:**
1. Attacker compiles Move code using unstable CompilerVersion V2_1 or LanguageVersion V2_4/V2_5
2. The compiler embeds CompilationMetadata with `unstable: true`
3. Attacker deserializes the CompiledModule bytecode
4. Attacker removes the CompilationMetadata entry from the module's metadata vector
5. Attacker re-serializes and deploys to mainnet
6. `reject_unstable_bytecode()` passes because metadata is `None`
7. Unstable bytecode successfully deploys to mainnet

This breaks the **Deterministic Execution** invariant, as unstable features may behave non-deterministically across different node implementations or versions, potentially causing consensus splits.

## Impact Explanation

This is a **Medium to High severity** vulnerability:

**Medium Severity Impact ($10,000):**
- Bypasses critical safety control that prevents experimental code on mainnet
- Could introduce untested VM features that cause state inconsistencies
- Requires manual intervention to identify and remove malicious modules

**Potential High Severity Impact ($50,000):**
- If unstable features contain consensus bugs, could cause validator disagreements on state roots
- Could introduce non-deterministic behavior leading to chain splits
- Unstable language features (V2_4, V2_5) or compiler features (V2_1) may have unpatched vulnerabilities

The severity depends on what experimental features exist in the unstable versions and whether they could cause consensus violations.

## Likelihood Explanation

**Likelihood: High**

- Attack requires only basic bytecode manipulation (deserialize → modify → serialize)
- No privileged access needed - any user can publish modules
- The compiler always embeds metadata, so stripping it is straightforward
- No additional validation checks for CompilationMetadata presence
- Backward compatibility design (supporting old V1 modules without metadata) makes this exploitable

The attack is technically trivial for anyone familiar with Move bytecode format.

## Recommendation

**Require CompilationMetadata presence for all newly published modules on mainnet.**

Modify the `reject_unstable_bytecode()` function to require metadata existence:

```rust
fn reject_unstable_bytecode(&self, modules: &[CompiledModule]) -> VMResult<()> {
    if self.chain_id().is_mainnet() {
        for module in modules {
            // Require metadata to exist on mainnet
            let metadata = get_compilation_metadata(module).ok_or_else(|| {
                PartialVMError::new(StatusCode::CONSTRAINT_NOT_SATISFIED)
                    .with_message(
                        "modules published on mainnet must include compilation metadata".to_string()
                    )
                    .finish(Location::Undefined)
            })?;
            
            if metadata.unstable {
                return Err(PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                    .with_message(
                        "code marked unstable is not published on mainnet".to_string(),
                    )
                    .finish(Location::Undefined));
            }
        }
    }
    Ok(())
}
```

Apply the same fix to `reject_unstable_bytecode_for_script()`: [7](#0-6) 

**Alternative:** Add a feature flag that enforces metadata presence on mainnet while maintaining backward compatibility for existing modules through a genesis exception list.

## Proof of Concept

```rust
// Proof of Concept: Deploy unstable bytecode by stripping metadata
use move_binary_format::CompiledModule;
use move_core_types::metadata::Metadata;
use aptos_framework::{BuildOptions, BuiltPackage};
use move_model::metadata::{CompilerVersion, COMPILATION_METADATA_KEY};

#[test]
fn test_unstable_bytecode_bypass() {
    // 1. Build module with unstable compiler
    let package = BuiltPackage::build(
        test_package_path(),
        BuildOptions {
            compiler_version: Some(CompilerVersion::V2_1), // Unstable!
            ..Default::default()
        }
    ).unwrap();
    
    // 2. Extract and deserialize bytecode
    let original_code = package.extract_code()[0].clone();
    let mut module = CompiledModule::deserialize(&original_code).unwrap();
    
    // 3. Verify it has unstable metadata
    let original_metadata = module.metadata.iter()
        .find(|m| m.key == COMPILATION_METADATA_KEY.to_vec())
        .expect("Should have compilation metadata");
    let compilation_meta: CompilationMetadata = 
        bcs::from_bytes(&original_metadata.value).unwrap();
    assert!(compilation_meta.unstable); // Confirm it's marked unstable
    
    // 4. Strip the CompilationMetadata
    module.metadata.retain(|m| m.key != COMPILATION_METADATA_KEY.to_vec());
    
    // 5. Re-serialize
    let mut modified_code = vec![];
    module.serialize(&mut modified_code).unwrap();
    
    // 6. Attempt to publish on mainnet
    let mut harness = MoveHarness::new();
    harness.set_mainnet(); // Simulate mainnet
    let account = harness.new_account_at(AccountAddress::random());
    
    let result = harness.run_transaction_payload(
        &account,
        code_publish_package_txn(
            package_metadata,
            vec![modified_code], // Module without metadata
        ),
    );
    
    // Without the fix, this succeeds (bypassing unstable check)
    // With the fix, this should fail with CONSTRAINT_NOT_SATISFIED
    assert_success!(result); // Currently passes - this is the vulnerability!
}
```

## Notes

The vulnerability exists because the enforcement mechanism was designed for backward compatibility with legacy V1 compiler modules that don't have CompilationMetadata. However, this creates a security gap where modern modules can deliberately omit metadata to bypass safety checks.

The `check_versions()` function at lines 386-396 correctly identifies unstable versions, but it only produces a warning. The actual enforcement happens at runtime, where the missing metadata check allows the bypass.

Current unstable versions that could be exploited:
- CompilerVersion::V2_1 (marked unstable) [8](#0-7) 
- LanguageVersion::V2_4 and V2_5 (both marked unstable) [9](#0-8)

### Citations

**File:** aptos-move/framework/src/built_package.rs (L386-396)
```rust
        if effective_compiler_version.unstable() {
            error_writer.set_color(ColorSpec::new().set_fg(Some(Color::Yellow)))?;
            writeln!(
                &mut error_writer,
                "Warning: compiler version `{}` is experimental \
                and should not be used in production",
                effective_compiler_version
            )?;
            error_writer.reset()?;
        }
        if effective_language_version.unstable() {
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1742-1757)
```rust
    fn reject_unstable_bytecode(&self, modules: &[CompiledModule]) -> VMResult<()> {
        if self.chain_id().is_mainnet() {
            for module in modules {
                if let Some(metadata) = get_compilation_metadata(module) {
                    if metadata.unstable {
                        return Err(PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                            .with_message(
                                "code marked unstable is not published on mainnet".to_string(),
                            )
                            .finish(Location::Undefined));
                    }
                }
            }
        }
        Ok(())
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1760-1771)
```rust
    pub fn reject_unstable_bytecode_for_script(&self, script: &CompiledScript) -> VMResult<()> {
        if self.chain_id().is_mainnet() {
            if let Some(metadata) = get_compilation_metadata(script) {
                if metadata.unstable {
                    return Err(PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                        .with_message("script marked unstable cannot be run on mainnet".to_string())
                        .finish(Location::Script));
                }
            }
        }
        Ok(())
    }
```

**File:** third_party/move/move-model/src/metadata.rs (L17-21)
```rust
pub const LATEST_LANGUAGE_VERSION_VALUE: LanguageVersion = LanguageVersion::V2_5;

/// Only stable versions are allowed on production networks
pub const LATEST_STABLE_LANGUAGE_VERSION_VALUE: LanguageVersion = LanguageVersion::V2_3;
pub const LATEST_STABLE_LANGUAGE_VERSION: &str = LATEST_STABLE_LANGUAGE_VERSION_VALUE.to_str();
```

**File:** third_party/move/move-model/src/metadata.rs (L23-24)
```rust
pub const LATEST_STABLE_COMPILER_VERSION_VALUE: CompilerVersion = CompilerVersion::V2_0;
pub const LATEST_STABLE_COMPILER_VERSION: &str = LATEST_STABLE_COMPILER_VERSION_VALUE.to_str();
```

**File:** third_party/move/move-model/src/metadata.rs (L151-157)
```rust
    pub fn unstable(self) -> bool {
        match self {
            CompilerVersion::V1 => false,
            CompilerVersion::V2_0 => false,
            CompilerVersion::V2_1 => true,
        }
    }
```

**File:** third_party/move/move-model/src/metadata.rs (L288-294)
```rust
    pub const fn unstable(self) -> bool {
        use LanguageVersion::*;
        match self {
            V1 | V2_0 | V2_1 | V2_2 | V2_3 => false,
            V2_4 | V2_5 => true,
        }
    }
```

**File:** types/src/vm/module_metadata.rs (L311-317)
```rust
pub fn get_compilation_metadata(code: &impl CompiledCodeMetadata) -> Option<CompilationMetadata> {
    if let Some(data) = find_metadata(code.metadata(), COMPILATION_METADATA_KEY) {
        bcs::from_bytes::<CompilationMetadata>(&data.value).ok()
    } else {
        None
    }
}
```
