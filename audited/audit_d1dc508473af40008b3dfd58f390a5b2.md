# Audit Report

## Title
Gas Metering Bypass in Deeply Nested Generic Type Loading - Computational Cost Not Charged During Type Argument Processing

## Summary
The `metered_load_type()` function in the Move VM's lazy loader charges gas only for module loading, but not for the computational cost of recursively processing deeply nested generic type structures. This allows attackers to perform up to 128 type node processing operations while paying only for a single module load, creating a significant gas undercharging vulnerability.

## Finding Description

When loading type arguments for generic function calls, the Move VM processes nested generic types through a recursive descent in `create_ty_impl()`. However, gas is only charged for **module loading** (via `charge_dependency`), not for the **computational work** of processing the type structure itself. [1](#0-0) 

The `metered_load_type()` function calls `create_ty()` with a resolver closure that loads modules. For a deeply nested type like `Struct1<Struct2<Struct3<...>>>`, the recursive implementation processes each nesting level: [2](#0-1) 

At each recursion level (line 1479), `create_ty_impl` is called again, incrementing the node count (line 1447). However, gas charging via `charge_create_ty` is **completely absent** during this type loading phase.

The module loading gas charge uses `TraversalContext` to track visited modules, charging only once per unique module: [3](#0-2) 

**Attack Scenario**:
1. Attacker defines 20 nested generic structs in a single module (or reuses the same struct)
2. Calls an entry function with type argument `Struct<Struct<Struct<...<Struct>>>>` (depth 20, 128 nodes total)
3. During `load_ty_arg`, only **one** module charge occurs (O(1) gas)
4. But `create_ty_impl` executes **128** recursive processing steps (O(N) work)
5. The computational cost is 128x the gas charged

Type complexity limits are configured but still allow significant undercharging: [4](#0-3) 

Meanwhile, `charge_create_ty` IS called elsewhere (frame creation, function instantiation) but is missing during initial type argument loading: [5](#0-4) 

## Impact Explanation

**High Severity** - This meets the criteria for "Validator node slowdowns" and "Significant protocol violations":

1. **Computational DoS**: An attacker can craft transactions that perform O(max_ty_size) computational work while paying O(1) gas, with `max_ty_size = 128` allowing a 128:1 undercharging ratio.

2. **Amplification Vectors**:
   - Multiple type arguments per function call
   - Multiple function calls per transaction  
   - Repeated transactions in mempool
   - Each amplification multiplies the undercharged work

3. **Validator Impact**: Validators must process these complex types during transaction execution, consuming CPU cycles disproportionate to gas paid. At scale, this degrades validator performance.

4. **Invariant Violation**: Breaks the critical invariant "All operations must respect gas, storage, and computational limits" - computational work is not proportionally charged.

## Likelihood Explanation

**High Likelihood**:
- Attack is trivial to execute - requires only publishing a module with nested generic structs
- No special permissions or validator access required
- Type nesting is a standard Move feature, not requiring exotic bytecode
- Limits (`max_ty_depth=20`, `max_ty_size=128`) are high enough for meaningful exploitation
- Attack can be repeated across multiple transactions

## Recommendation

Add `charge_create_ty` call in `metered_load_type()` to charge gas proportional to the type complexity:

```rust
fn metered_load_type(
    &self,
    gas_meter: &mut impl DependencyGasMeter,
    traversal_context: &mut TraversalContext,
    tag: &TypeTag,
) -> PartialVMResult<Type> {
    let ty = self.runtime_environment()
        .vm_config()
        .ty_builder
        .create_ty(tag, |st| {
            self.metered_load_module(
                gas_meter,
                traversal_context,
                &ModuleId::new(st.address, st.module.to_owned()),
            )
            .and_then(|module| module.get_struct(&st.name))
            .map_err(|err| err.to_partial())
        })?;
    
    // Charge gas for type complexity
    if let Some(gas_meter) = gas_meter.as_gas_meter() {
        gas_meter.charge_create_ty(NumTypeNodes::new(ty.num_nodes() as u64))?;
    }
    
    Ok(ty)
}
```

**Note**: This requires extending `DependencyGasMeter` to expose `charge_create_ty`, or restructuring to accept a full `GasMeter` during type loading.

## Proof of Concept

```move
// Module defining nested generic structs
module 0xCAFE::nested {
    struct Level0<T> { value: T }
    struct Level1<T> { value: Level0<T> }
    struct Level2<T> { value: Level1<T> }
    struct Level3<T> { value: Level2<T> }
    // ... continue up to Level19 for max depth
    
    // Function with generic type parameter
    public entry fun exploit<T>() {
        // T can be Level19<Level18<...<Level0<u64>>>>
        // This forces type loading of deeply nested structure
    }
}

// Attack transaction:
// Call nested::exploit with type argument:
// Level19<Level18<Level17<...Level0<u64>>>>
// 
// Expected: Gas charged proportional to 20 nesting levels
// Actual: Gas charged only for module 0xCAFE::nested (once)
// Undercharging ratio: 20:1 (or 128:1 for maximally complex types)
```

**Rust reproduction**:
1. Publish module with 20 nested generic struct definitions
2. Submit transaction calling `exploit<deeply_nested_type>()`  
3. Monitor gas charged vs CPU time consumed during `load_ty_arg`
4. Observe O(depth) CPU work with O(1) gas charge

## Notes

Both `LazyLoader` and `EagerLoader` exhibit this vulnerability, though `EagerLoader` charges for transitive dependencies which partially mitigates the issue. The core problem is that type complexity metering (`charge_create_ty`) is deferred to later execution phases (frame creation, function instantiation) rather than being charged upfront during type argument loading where the computational work actually occurs.

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/loader/lazy.rs (L94-112)
```rust
    fn metered_load_type(
        &self,
        gas_meter: &mut impl DependencyGasMeter,
        traversal_context: &mut TraversalContext,
        tag: &TypeTag,
    ) -> PartialVMResult<Type> {
        self.runtime_environment()
            .vm_config()
            .ty_builder
            .create_ty(tag, |st| {
                self.metered_load_module(
                    gas_meter,
                    traversal_context,
                    &ModuleId::new(st.address, st.module.to_owned()),
                )
                .and_then(|module| module.get_struct(&st.name))
                .map_err(|err| err.to_partial())
            })
    }
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_types.rs (L1433-1491)
```rust
    fn create_ty_impl<F>(
        &self,
        ty_tag: &TypeTag,
        resolver: &mut F,
        count: &mut u64,
        depth: u64,
    ) -> PartialVMResult<Type>
    where
        F: FnMut(&StructTag) -> PartialVMResult<Arc<StructType>>,
    {
        use Type::*;
        use TypeTag as T;

        self.check(count, depth)?;
        *count += 1;
        Ok(match ty_tag {
            T::Bool => Bool,
            T::U8 => U8,
            T::U16 => U16,
            T::U32 => U32,
            T::U64 => U64,
            T::U128 => U128,
            T::U256 => U256,
            T::I8 => I8,
            T::I16 => I16,
            T::I32 => I32,
            T::I64 => I64,
            T::I128 => I128,
            T::I256 => I256,
            T::Address => Address,
            T::Signer => Signer,
            T::Vector(elem_ty_tag) => {
                let elem_ty = self.create_ty_impl(elem_ty_tag, resolver, count, depth + 1)?;
                Vector(triomphe::Arc::new(elem_ty))
            },
            T::Struct(struct_tag) => {
                let struct_ty = resolver(struct_tag.as_ref())?;

                if struct_ty.ty_params.is_empty() && struct_tag.type_args.is_empty() {
                    Struct {
                        idx: struct_ty.idx,
                        ability: AbilityInfo::struct_(struct_ty.abilities),
                    }
                } else {
                    let mut ty_args = vec![];
                    for ty_arg in &struct_tag.type_args {
                        let ty_arg = self.create_ty_impl(ty_arg, resolver, count, depth + 1)?;
                        ty_args.push(ty_arg);
                    }
                    Type::verify_ty_arg_abilities(struct_ty.ty_param_constraints(), &ty_args)?;
                    StructInstantiation {
                        idx: struct_ty.idx,
                        ty_args: triomphe::Arc::new(ty_args),
                        ability: AbilityInfo::generic_struct(
                            struct_ty.abilities,
                            struct_ty.phantom_ty_params_mask.clone(),
                        ),
                    }
                }
```

**File:** third_party/move/move-vm/runtime/src/module_traversal.rs (L70-85)
```rust
    pub fn visit_if_not_special_module_id(&mut self, module_id: &ModuleId) -> bool {
        let addr = module_id.address();
        if addr.is_special() {
            return false;
        }

        let name = module_id.name();
        if self.visited.contains_key(&(addr, name)) {
            false
        } else {
            let module_id = self.referenced_module_ids.alloc(module_id.clone());
            self.visited
                .insert((module_id.address(), module_id.name()), ());
            true
        }
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L266-274)
```rust
            max_ty_size: NumTypeNodes,
            { RELEASE_V1_15.. => "max_ty_size" },
            128,
        ],
        [
            max_ty_depth: NumTypeNodes,
            { RELEASE_V1_15.. => "max_ty_depth" },
            20,
        ],
```

**File:** third_party/move/move-vm/runtime/src/frame.rs (L175-203)
```rust
        let local_tys = if ty_args.is_empty() {
            // Function is not generic - avoid cloning types.
            for ty in function.local_tys() {
                gas_meter.charge_create_ty(NumTypeNodes::new(ty.num_nodes() as u64))?;
            }

            if RTTCheck::should_perform_checks(&function.function) {
                LocalTys::BorrowFromFunction
            } else {
                LocalTys::None
            }
        } else {
            // Try cached instantiated locals in frame cache. This way we instantiate only once per
            // usage of the function.
            let mut cache_borrow = frame_cache.borrow_mut();
            if let Some(local_ty_counts) = cache_borrow.instantiated_local_ty_counts.as_ref() {
                for cnt in local_ty_counts.iter() {
                    gas_meter.charge_create_ty(*cnt)?;
                }
            } else {
                let local_tys = function.local_tys();
                let mut local_ty_counts = Vec::with_capacity(local_tys.len());
                for ty in local_tys {
                    let cnt = NumTypeNodes::new(ty.num_nodes_in_subst(ty_args)? as u64);
                    gas_meter.charge_create_ty(cnt)?;
                    local_ty_counts.push(cnt);
                }
                cache_borrow.instantiated_local_ty_counts = Some(Rc::from(local_ty_counts));
            }
```
