# Audit Report

## Title
Missing Gas Parameter Bounds Validation Enables Resource Exhaustion and Network DoS

## Summary
The gas schedule update mechanism lacks bounds validation for gas parameters, allowing governance to set extreme values (including 0 or u64::MAX) that can cause network-wide denial of service or enable resource exhaustion attacks at minimal cost, violating the critical invariant that "all operations must respect gas, storage, and computational limits."

## Finding Description

The Aptos gas schedule system allows governance to update gas parameters through the `set_for_next_epoch` and `set_for_next_epoch_check_hash` functions without any bounds validation. [1](#0-0) [2](#0-1) [3](#0-2) 

The code contains explicit TODO comments acknowledging this missing validation. When gas parameters are loaded, they are converted from u64 to GasQuantity types without any bounds checking: [4](#0-3) 

Gas calculations use saturating arithmetic for safety: [5](#0-4) [6](#0-5) 

However, this creates two attack vectors:

**Attack Vector 1: Zero-Value Parameters Enable Resource Exhaustion**
If per-byte gas parameters are set to 0, operations involving large data become essentially free. For example, in table operations: [7](#0-6) 

If `add_box_per_byte_serialized` is 0, then `key_cost = 0 * num_bytes = 0`, allowing attackers to add arbitrarily large table entries for only the base cost, leading to storage exhaustion.

**Attack Vector 2: Extreme Values Cause Network-Wide DoS**
If gas parameters are set to u64::MAX, any multiplication saturates to u64::MAX, causing all transactions to immediately exceed their gas limit and fail, creating a network-wide DoS condition.

## Impact Explanation

This issue meets **High Severity** criteria per the Aptos bug bounty program:
- **Validator node slowdowns**: Resource exhaustion from zero-cost large operations would degrade validator performance
- **Significant protocol violations**: Breaks the fundamental invariant that operations must respect gas limits (Invariant #9)

While deterministic execution is maintained (all validators compute the same saturated values), the economic security model is completely broken, enabling either DoS or resource exhaustion attacks.

## Likelihood Explanation

**Likelihood: Medium to Low**

This vulnerability requires a governance proposal to pass with malicious or incorrect gas parameters. This could occur through:
1. **Governance compromise**: If governance is compromised through voting power manipulation
2. **Governance mistake**: Accidental submission of incorrect parameters during upgrades
3. **Malicious insider**: A malicious governance participant

While governance is generally trusted, defense-in-depth principles require bounds validation as explicitly noted in the TODO comments. Historical precedent shows governance mistakes occur in production blockchains.

## Recommendation

Implement comprehensive bounds validation for gas parameters in the `set_for_next_epoch` and related functions:

```move
// Add to gas_schedule.move
const EGAS_PARAM_OUT_OF_BOUNDS: u64 = 4;
const MIN_GAS_PARAM: u64 = 1;  // Prevent zero values
const MAX_GAS_PARAM: u64 = 18446744073709551; // MAX_U64 / 1000

public fun validate_gas_schedule(gas_schedule: &GasScheduleV2) {
    let i = 0;
    let len = vector::length(&gas_schedule.entries);
    while (i < len) {
        let entry = vector::borrow(&gas_schedule.entries, i);
        assert!(
            entry.val >= MIN_GAS_PARAM && entry.val <= MAX_GAS_PARAM,
            error::invalid_argument(EGAS_PARAM_OUT_OF_BOUNDS)
        );
        i = i + 1;
    };
}

public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    // Add validation here
    validate_gas_schedule(&new_gas_schedule);
    
    if (exists<GasScheduleV2>(@aptos_framework)) {
        // ... rest of function
    };
    config_buffer::upsert(new_gas_schedule);
}
```

## Proof of Concept

```move
#[test_only]
module aptos_framework::gas_schedule_exploit_test {
    use aptos_framework::gas_schedule;
    use std::vector;
    use std::string;
    
    #[test(framework = @aptos_framework)]
    #[expected_failure] // Should fail with current code, will fail with validation
    fun test_zero_gas_parameter_exploit(framework: &signer) {
        // Create malicious gas schedule with zero per-byte cost
        let entries = vector::empty();
        
        // Set table.add_box.per_byte_serialized to 0
        let key = string::utf8(b"table.add_box.per_byte_serialized");
        let malicious_entry = gas_schedule::GasEntry { key, val: 0 };
        vector::push_back(&mut entries, malicious_entry);
        
        let malicious_schedule = gas_schedule::GasScheduleV2 {
            feature_version: 100,
            entries,
        };
        
        let schedule_bytes = bcs::to_bytes(&malicious_schedule);
        
        // This should fail with proper validation but currently succeeds
        gas_schedule::set_for_next_epoch(framework, schedule_bytes);
        
        // With zero per-byte cost, attackers can add huge table entries
        // at minimal cost, exhausting validator storage
    }
    
    #[test(framework = @aptos_framework)]
    #[expected_failure]
    fun test_extreme_gas_parameter_dos(framework: &signer) {
        // Create gas schedule with u64::MAX values
        let entries = vector::empty();
        
        let key = string::utf8(b"table.add_box.base");
        let dos_entry = gas_schedule::GasEntry { key, val: 18446744073709551615 }; // u64::MAX
        vector::push_back(&mut entries, dos_entry);
        
        let dos_schedule = gas_schedule::GasScheduleV2 {
            feature_version: 100,
            entries,
        };
        
        let schedule_bytes = bcs::to_bytes(&dos_schedule);
        
        // This causes all table operations to fail due to immediate gas exhaustion
        gas_schedule::set_for_next_epoch(framework, schedule_bytes);
    }
}
```

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L47-47)
```text
        // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L67-67)
```text
            // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L75-75)
```text
            // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L38-42)
```rust
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        let name = format!("{}.{}", $prefix, key);
                        params.$name = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?.into();
                    }
                )*
```

**File:** third_party/move/move-core/types/src/gas_algebra.rs (L205-210)
```rust
impl<U> Add<GasQuantity<U>> for GasQuantity<U> {
    type Output = Self;

    fn add(self, rhs: Self) -> Self::Output {
        Self::new(self.val.saturating_add(rhs.val))
    }
```

**File:** third_party/move/move-core/types/src/gas_algebra.rs (L229-231)
```rust
fn mul_impl<U1, U2>(x: GasQuantity<U2>, y: GasQuantity<UnitDiv<U1, U2>>) -> GasQuantity<U1> {
    GasQuantity::new(x.val.saturating_mul(y.val))
}
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L412-412)
```rust
    let key_cost = ADD_BOX_PER_BYTE_SERIALIZED * NumBytes::new(key_bytes.len() as u64);
```
