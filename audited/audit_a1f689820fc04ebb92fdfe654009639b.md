# Audit Report

## Title
LRU Cache Shard Concentration Denial-of-Service via Historical Root Node Query Flooding

## Summary
The `shard()` function in `lru_node_cache.rs` assigns all Jellyfish Merkle Tree root nodes (empty nibble paths) to shard 0, creating a cache hotspot exploitable through historical version queries to degrade validator and API server performance.

## Finding Description

The LruNodeCache uses 256 shards to distribute cached nodes, with sharding determined by the first byte of the nibble path: [1](#0-0) 

Root nodes in the Jellyfish Merkle Tree are identified by empty nibble paths (zero-length byte arrays). Every tree traversal operation begins by accessing the root node at a specific version: [2](#0-1) [3](#0-2) 

When `nibble_path.bytes()` returns an empty array, the `shard()` function returns 0, concentrating all root nodes in a single shard. Each shard has a default capacity of 8,192 nodes: [4](#0-3) 

The caching hierarchy checks version cache first (only last 2 versions), then LRU cache, then disk: [5](#0-4) [6](#0-5) 

**Attack Scenario:**

1. Attacker sends REST API queries to many different historical versions within the pruning window (~1M versions)
2. Each query accesses the root node for that specific version via `get_root_node(version)`
3. Historical root nodes bypass version cache (which only holds last 2 versions) and are loaded into LRU shard 0
4. Shard 0 fills with 8,192 old root nodes, evicting any cached recent root nodes
5. Subsequent queries to recent versions not in version cache suffer cache misses on root node access
6. All queries experience increased disk I/O latency, degrading API and validator query performance

## Impact Explanation

This qualifies as **Medium severity** under "Validator node slowdowns" because:

- Validators and API servers executing historical state queries experience performance degradation
- Root node cache misses affect all tree traversal operations, multiplying the impact
- The attack is sustainable within the pruning window of ~1M versions
- However, it does NOT cause consensus violations, fund loss, or complete unavailability
- Version cache protects the most recent 2 versions from this attack
- Core consensus operations (block validation, transaction execution) primarily use current version

The vulnerability does not reach High severity because:
- It requires sustained API query load
- Rate limiting on API servers provides partial mitigation  
- Only affects query performance, not consensus correctness or state integrity

## Likelihood Explanation

**Likelihood: Medium-High**

The attack is practical because:
- Aptos REST API exposes historical state query endpoints with `ledger_version` parameter
- No special privileges required - any external user can query historical versions
- Attack can be executed remotely via public API endpoints
- Pruning window allows targeting ~1M historical versions

Limiting factors:
- API rate limiting may slow attack execution
- Requires sustained effort to maintain cache pollution
- Disk read costs affect attacker's API server resources too
- Version cache provides protection for most recent versions

## Recommendation

**Fix: Improve root node sharding distribution**

Modify the `shard()` function to distribute root nodes across shards based on version number instead of concentrating them in shard 0:

```rust
fn shard(nibble_path: &NibblePath, version: Version) -> u8 {
    let path_bytes = nibble_path.bytes();
    if path_bytes.is_empty() {
        // Distribute root nodes across shards by version
        (version % 256) as u8
    } else {
        path_bytes[0]
    }
}
```

Update all call sites to pass the version:
- `lru_node_cache.rs`: Update `get()` and `put()` to extract version from `NodeKey`
- Change signature: `fn shard(nibble_path: &NibblePath, version: Version) -> u8`

This distributes root nodes uniformly across all 256 shards based on version number, eliminating the concentration in shard 0.

**Alternative mitigations:**
1. Increase shard 0 capacity specifically for root nodes
2. Implement separate LRU cache for root nodes only
3. Add API-level rate limiting specifically for historical version queries
4. Extend version cache to hold more than 2 recent versions

## Proof of Concept

```rust
// Integration test demonstrating cache pollution
#[tokio::test]
async fn test_root_node_cache_pollution() {
    let (db, api) = setup_test_environment();
    
    // Step 1: Query many historical versions to pollute shard 0
    for version in (1000..10000).step_by(100) {
        let _ = api.get_account_resource_at_version(
            account_address, 
            "0x1::account::Account",
            version
        ).await;
    }
    
    // Step 2: Query recent version (should be slower due to cache pollution)
    let start = Instant::now();
    let _ = api.get_account_resource(account_address, "0x1::account::Account").await;
    let latency = start.elapsed();
    
    // Assert increased latency due to cache miss on root node
    assert!(latency > expected_cached_latency);
    
    // Verify shard 0 contains many old root nodes
    let cache_stats = db.get_lru_cache_stats();
    assert!(cache_stats.shard_0_root_nodes > 8000);
}
```

**Notes:**

This vulnerability stems from a design oversight where the sharding strategy doesn't account for the special nature of root nodes. While the version cache provides some protection, any workload accessing more than 2 historical versions becomes vulnerable to this cache pollution attack. The concentrated load on shard 0 represents both a performance bottleneck and a denial-of-service vector.

### Citations

**File:** storage/aptosdb/src/lru_node_cache.rs (L31-38)
```rust
    fn shard(nibble_path: &NibblePath) -> u8 {
        let path_bytes = nibble_path.bytes();
        if path_bytes.is_empty() {
            0
        } else {
            path_bytes[0]
        }
    }
```

**File:** storage/jellyfish-merkle/src/lib.rs (L837-840)
```rust
    fn get_root_node_option(&self, version: Version) -> Result<Option<Node<K>>> {
        let root_node_key = NodeKey::new_empty_path(version);
        self.reader.get_node_option(&root_node_key, "get_root")
    }
```

**File:** storage/jellyfish-merkle/src/node_type/mod.rs (L65-68)
```rust
    /// A shortcut to generate a node key consisting of a version and an empty nibble path.
    pub fn new_empty_path(version: Version) -> Self {
        Self::new(version, NibblePath::new_even(vec![]))
    }
```

**File:** config/src/config/storage_config.rs (L24-25)
```rust
// Lru cache will consume about 2G RAM based on this default value.
pub const DEFAULT_MAX_NUM_NODES_PER_LRU_CACHE_SHARD: usize = 1 << 13;
```

**File:** storage/aptosdb/src/state_merkle_db.rs (L856-897)
```rust
    fn get_node_option(&self, node_key: &NodeKey, tag: &str) -> Result<Option<Node>> {
        let start_time = Instant::now();
        if !self.cache_enabled() {
            let node_opt = self
                .db_by_key(node_key)
                .get::<JellyfishMerkleNodeSchema>(node_key)?;
            NODE_CACHE_SECONDS
                .observe_with(&[tag, "cache_disabled"], start_time.elapsed().as_secs_f64());
            return Ok(node_opt);
        }
        if let Some(node_cache) = self
            .version_caches
            .get(&node_key.get_shard_id())
            .unwrap()
            .get_version(node_key.version())
        {
            let node = node_cache.get(node_key).cloned();
            NODE_CACHE_SECONDS.observe_with(
                &[tag, "versioned_cache_hit"],
                start_time.elapsed().as_secs_f64(),
            );
            return Ok(node);
        }

        if let Some(lru_cache) = &self.lru_cache {
            if let Some(node) = lru_cache.get(node_key) {
                NODE_CACHE_SECONDS
                    .observe_with(&[tag, "lru_cache_hit"], start_time.elapsed().as_secs_f64());
                return Ok(Some(node));
            }
        }

        let node_opt = self
            .db_by_key(node_key)
            .get::<JellyfishMerkleNodeSchema>(node_key)?;
        if let Some(lru_cache) = &self.lru_cache {
            if let Some(node) = &node_opt {
                lru_cache.put(node_key.clone(), node.clone());
            }
        }
        NODE_CACHE_SECONDS.observe_with(&[tag, "cache_miss"], start_time.elapsed().as_secs_f64());
        Ok(node_opt)
```

**File:** storage/aptosdb/src/versioned_node_cache.rs (L35-35)
```rust
    pub(crate) const NUM_VERSIONS_TO_CACHE: usize = 2;
```
