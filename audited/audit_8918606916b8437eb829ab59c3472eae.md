# Audit Report

## Title
Fast Path Randomness Security Downgrade via Missing Threshold Validation

## Summary
The Aptos randomness configuration system allows `fast_path_secrecy_threshold` to be set lower than `secrecy_threshold` through governance proposals, creating a security downgrade path where attackers with insufficient stake for the main path can reconstruct randomness via the fast path. This violates the fundamental security guarantee that randomness remains secret from validator subsets below the secrecy threshold.

## Finding Description

The randomness system in Aptos V2 introduces a dual-path architecture with both a slow (main) path and a fast path for randomness generation. Each path has independent security thresholds configured through on-chain governance.

**The Missing Validation:**

The `new_v2` function in the Move randomness config module accepts three threshold parameters without validating their relationship: [1](#0-0) 

Similarly, the Rust implementation lacks this validation: [2](#0-1) 

The DKG rounding validation only checks basic mathematical properties but does NOT validate that `fast_secrecy_threshold >= secrecy_threshold`: [3](#0-2) 

The `is_valid_profile` function only ensures the fast path threshold is ≤ 100%, not that it's at least as secure as the main path: [4](#0-3) 

**Concurrent Execution Creates Vulnerability:**

The consensus layer runs both paths independently and concurrently. Whichever path reaches its threshold first produces the randomness decision: [5](#0-4) 

Each path has its own threshold check: [6](#0-5) 

**Attack Scenario:**

A malicious governance proposal sets:
- `secrecy_threshold_in_percentage = 50` (50% of stake)
- `reconstruct_threshold_in_percentage = 67` (67% of stake) 
- `fast_path_secrecy_threshold_in_percentage = 40` (40% of stake - LOWER than main path!)

This configuration passes through governance because no validation exists: [7](#0-6) 

An attacker controlling 45% of validator stake (below the 50% secrecy threshold):
1. Cannot reconstruct randomness on the main path (insufficient stake)
2. **CAN reconstruct randomness on the fast path** (exceeds 40% fast path threshold)
3. Since both paths run concurrently, the fast path completes first
4. Attacker obtains randomness before it should be revealed, breaking the secrecy guarantee

## Impact Explanation

**Critical Severity - Consensus/Safety Violation**

This vulnerability breaks the fundamental security invariant of the randomness system: that validator subsets with stake ≤ secrecy_threshold cannot reconstruct randomness. This directly impacts:

1. **On-chain randomness consumers**: Any protocol using Aptos randomness (lotteries, gaming, NFT distribution, leader election) can be manipulated by attackers with less stake than intended
2. **Consensus security**: The randomness system is critical for validator rotation and other consensus mechanisms
3. **Economic security**: Attackers can profit by biasing random outcomes (gambling protocols, auctions)
4. **Trust model violation**: Users expect randomness to be secure up to the advertised threshold, but the fast path creates a backdoor

This qualifies as a **Consensus/Safety violation** under the Critical severity category, as it allows manipulation of a consensus-critical component (randomness) with an attacker controlling less than the advertised security threshold.

## Likelihood Explanation

**High Likelihood**

1. **Governance is the attack vector**: Any malicious or compromised governance proposal can introduce this misconfiguration
2. **No technical barriers**: The attack requires no sophisticated exploit, just a configuration change
3. **Silent failure**: Validators would continue operating normally while the security downgrade is active
4. **Configuration complexity**: Operators might not notice the relationship between thresholds, especially if fast path thresholds are framed as "optimization" parameters
5. **Default values are safe but not enforced**: While defaults use 67% for fast path (safer than 50% main), nothing prevents changing this

## Recommendation

Add validation to ensure fast path security is never weaker than main path security:

**In Move (randomness_config.move):**
```move
public fun new_v2(
    secrecy_threshold: FixedPoint64,
    reconstruction_threshold: FixedPoint64,
    fast_path_secrecy_threshold: FixedPoint64,
): RandomnessConfig {
    // Add validation
    assert!(
        fixed_point64::greater_or_equal(fast_path_secrecy_threshold, secrecy_threshold),
        EFAST_PATH_WEAKER_THAN_MAIN_PATH
    );
    
    RandomnessConfig {
        variant: copyable_any::pack( ConfigV2 {
            secrecy_threshold,
            reconstruction_threshold,
            fast_path_secrecy_threshold,
        } )
    }
}
```

**In Rust (types/src/dkg/real_dkg/rounding/mod.rs):**
```rust
pub fn new(
    validator_stakes: &Vec<u64>,
    total_weight_min: usize,
    total_weight_max: usize,
    secrecy_threshold_in_stake_ratio: U64F64,
    reconstruct_threshold_in_stake_ratio: U64F64,
    fast_secrecy_threshold_in_stake_ratio: Option<U64F64>,
) -> anyhow::Result<Self> {
    ensure!(total_weight_min >= validator_stakes.len());
    ensure!(total_weight_max >= total_weight_min);
    ensure!(secrecy_threshold_in_stake_ratio * U64F64::from_num(3) > U64F64::from_num(1));
    ensure!(secrecy_threshold_in_stake_ratio < reconstruct_threshold_in_stake_ratio);
    ensure!(reconstruct_threshold_in_stake_ratio * U64F64::from_num(3) <= U64F64::from_num(2));
    
    // ADD THIS VALIDATION
    if let Some(fast_threshold) = fast_secrecy_threshold_in_stake_ratio {
        ensure!(
            fast_threshold >= secrecy_threshold_in_stake_ratio,
            "Fast path secrecy threshold must be at least as high as main path secrecy threshold"
        );
    }
    
    // ... rest of function
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod vulnerability_test {
    use super::*;
    use fixed::types::U64F64;

    #[test]
    #[should_panic(expected = "Fast path secrecy threshold must be at least as high")]
    fn test_fast_path_security_downgrade_rejected() {
        // This test demonstrates the vulnerability
        // Currently this would PASS (allowing the security downgrade)
        // After the fix, it should PANIC (rejecting the insecure config)
        
        let validator_stakes = vec![100_000_000; 100]; // 100 validators with equal stake
        
        let secrecy_threshold = U64F64::from_num(1) / U64F64::from_num(2); // 50%
        let reconstruct_threshold = U64F64::from_num(2) / U64F64::from_num(3); // 67%
        let fast_secrecy_threshold = U64F64::from_num(40) / U64F64::from_num(100); // 40% - INSECURE!
        
        // This should fail validation but currently succeeds
        let result = DKGRoundingProfile::new(
            &validator_stakes,
            validator_stakes.len(),
            1000,
            secrecy_threshold,
            reconstruct_threshold,
            Some(fast_secrecy_threshold), // This is LOWER than secrecy_threshold!
        );
        
        // Without the fix: result.is_ok() == true (VULNERABILITY)
        // With the fix: result.is_err() == true (SECURE)
        assert!(result.is_err(), "Should reject fast path threshold lower than main path");
    }
    
    #[test]
    fn test_attack_scenario() {
        // Demonstrate the attack: attacker with 45% stake
        let total_validators = 100;
        let validator_stakes = vec![100_000_000; total_validators];
        
        // Malicious config: fast path threshold at 40%, main at 50%
        let profile = DKGRoundingProfile::infallible(
            &validator_stakes,
            U64F64::from_num(50) / U64F64::from_num(100), // 50% main secrecy
            U64F64::from_num(67) / U64F64::from_num(100), // 67% reconstruction
            Some(U64F64::from_num(40) / U64F64::from_num(100)), // 40% fast secrecy - DOWNGRADE!
        );
        
        // Attacker controls 45 out of 100 validators (45% of stake)
        let attacker_weight: u64 = profile.validator_weights.iter().take(45).sum();
        let total_weight: u64 = profile.validator_weights.iter().sum();
        
        // On main path: 45% < 50%, cannot reconstruct (SECURE)
        assert!(
            attacker_weight < profile.reconstruct_threshold_in_weights,
            "Main path is secure against 45% attacker"
        );
        
        // On fast path: 45% > 40%, CAN reconstruct (VULNERABILITY!)
        assert!(
            attacker_weight >= profile.fast_reconstruct_threshold_in_weights.unwrap(),
            "Fast path allows 45% attacker to reconstruct - SECURITY BREACH!"
        );
    }
}
```

**Notes**

The vulnerability exists across three layers:
1. **Governance configuration layer**: No validation in Move or Rust config constructors
2. **DKG setup layer**: No validation in the rounding profile construction
3. **Consensus execution layer**: Both paths execute independently without cross-checking security levels

The default values (50% main, 67% fast) are secure, but the lack of enforcement means any governance proposal can introduce an insecure configuration. This is particularly dangerous because the fast path is presented as a performance optimization, and operators might not realize that lowering its threshold actually degrades overall security.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/randomness_config.move (L103-115)
```text
    public fun new_v2(
        secrecy_threshold: FixedPoint64,
        reconstruction_threshold: FixedPoint64,
        fast_path_secrecy_threshold: FixedPoint64,
    ): RandomnessConfig {
        RandomnessConfig {
            variant: copyable_any::pack( ConfigV2 {
                secrecy_threshold,
                reconstruction_threshold,
                fast_path_secrecy_threshold,
            } )
        }
    }
```

**File:** types/src/on_chain_config/randomness_config.rs (L117-136)
```rust
    pub fn new_v2(
        secrecy_threshold_in_percentage: u64,
        reconstruct_threshold_in_percentage: u64,
        fast_path_secrecy_threshold_in_percentage: u64,
    ) -> Self {
        let secrecy_threshold = FixedPoint64MoveStruct::from_u64f64(
            U64F64::from_num(secrecy_threshold_in_percentage) / U64F64::from_num(100),
        );
        let reconstruction_threshold = FixedPoint64MoveStruct::from_u64f64(
            U64F64::from_num(reconstruct_threshold_in_percentage) / U64F64::from_num(100),
        );
        let fast_path_secrecy_threshold = FixedPoint64MoveStruct::from_u64f64(
            U64F64::from_num(fast_path_secrecy_threshold_in_percentage) / U64F64::from_num(100),
        );
        Self::V2(ConfigV2 {
            secrecy_threshold,
            reconstruction_threshold,
            fast_path_secrecy_threshold,
        })
    }
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L187-199)
```rust
    pub fn new(
        validator_stakes: &Vec<u64>,
        total_weight_min: usize,
        total_weight_max: usize,
        secrecy_threshold_in_stake_ratio: U64F64,
        reconstruct_threshold_in_stake_ratio: U64F64,
        fast_secrecy_threshold_in_stake_ratio: Option<U64F64>,
    ) -> anyhow::Result<Self> {
        ensure!(total_weight_min >= validator_stakes.len());
        ensure!(total_weight_max >= total_weight_min);
        ensure!(secrecy_threshold_in_stake_ratio * U64F64::from_num(3) > U64F64::from_num(1));
        ensure!(secrecy_threshold_in_stake_ratio < reconstruct_threshold_in_stake_ratio);
        ensure!(reconstruct_threshold_in_stake_ratio * U64F64::from_num(3) <= U64F64::from_num(2));
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L285-293)
```rust
fn is_valid_profile(
    profile: &DKGRoundingProfile,
    reconstruct_threshold_in_stake_ratio: U64F64,
) -> bool {
    // ensure the reconstruction is below threshold, and the fast path threshold is valid
    profile.reconstruct_threshold_in_stake_ratio <= reconstruct_threshold_in_stake_ratio
        && (profile.fast_reconstruct_threshold_in_stake_ratio.is_none()
            || profile.fast_reconstruct_threshold_in_stake_ratio.unwrap() <= U64F64::from_num(1))
}
```

**File:** consensus/src/rand/rand_gen/rand_store.rs (L41-49)
```rust
    pub fn try_aggregate(
        self,
        rand_config: &RandConfig,
        rand_metadata: FullRandMetadata,
        decision_tx: Sender<Randomness>,
    ) -> Either<Self, RandShare<S>> {
        if self.total_weight < rand_config.threshold() {
            return Either::Left(self);
        }
```

**File:** consensus/src/rand/rand_gen/rand_store.rs (L261-277)
```rust
    pub fn add_rand_metadata(&mut self, rand_metadata: FullRandMetadata) {
        let rand_item = self
            .rand_map
            .entry(rand_metadata.round())
            .or_insert_with(|| RandItem::new(self.author, PathType::Slow));
        rand_item.add_metadata(&self.rand_config, rand_metadata.clone());
        rand_item.try_aggregate(&self.rand_config, self.decision_tx.clone());
        // fast path
        if let (Some(fast_rand_map), Some(fast_rand_config)) =
            (self.fast_rand_map.as_mut(), self.fast_rand_config.as_ref())
        {
            let fast_rand_item = fast_rand_map
                .entry(rand_metadata.round())
                .or_insert_with(|| RandItem::new(self.author, PathType::Fast));
            fast_rand_item.add_metadata(fast_rand_config, rand_metadata.clone());
            fast_rand_item.try_aggregate(fast_rand_config, self.decision_tx.clone());
        }
```

**File:** aptos-move/aptos-release-builder/src/components/randomness_config.rs (L99-126)
```rust
                ReleaseFriendlyRandomnessConfig::V2 {
                    secrecy_threshold_in_percentage,
                    reconstruct_threshold_in_percentage,
                    fast_path_secrecy_threshold_in_percentage,
                } => {
                    emitln!(writer, "let v2 = randomness_config::new_v2(");
                    emitln!(
                        writer,
                        "    fixed_point64::create_from_rational({}, 100),",
                        secrecy_threshold_in_percentage
                    );
                    emitln!(
                        writer,
                        "    fixed_point64::create_from_rational({}, 100),",
                        reconstruct_threshold_in_percentage
                    );
                    emitln!(
                        writer,
                        "    fixed_point64::create_from_rational({}, 100),",
                        fast_path_secrecy_threshold_in_percentage
                    );
                    emitln!(writer, ");");
                    emitln!(
                        writer,
                        "randomness_config::set_for_next_epoch({}, v2);",
                        signer_arg
                    );
                },
```
