# Audit Report

## Title
Information Leakage Through REST Client Error Messages in Rosetta API Account View Function

## Summary
The `view()` function in the Aptos Rosetta API's account module leaks internal infrastructure details through improperly sanitized REST client error messages. When HTTP-level errors occur (connection failures, timeouts, DNS errors), the full internal REST API URLs, including internal hostnames, ports, and network topology information, are exposed to external API clients.

## Finding Description

The vulnerability exists in the error propagation path starting at line 402 of the `view()` function: [1](#0-0) 

When `rest_client.view_bcs()` encounters HTTP-level errors (not API-level errors), it returns a `RestError::Http(StatusCode, reqwest::Error)`. The `reqwest::Error` type includes the full URL being accessed in its error message.

The error conversion implementation does not sanitize this information: [2](#0-1) 

The `{:#}` format specifier on the `reqwest::Error` includes the complete URL with all connection details. This converted error is then returned to external API clients through the Rosetta API response's `details` field: [3](#0-2) 

**Information Leaked:**
1. Internal REST API base URLs (e.g., `http://internal-fullnode.company.local:8080`)
2. Internal DNS names revealing network topology
3. Internal IP addresses and port numbers
4. Query parameters including specific ledger versions being accessed
5. Full API endpoint paths (e.g., `/v1/view?ledger_version=12345`)

**Attack Path:**
1. Attacker sends a legitimate Rosetta API request (e.g., `/account/balance`)
2. Internal fullnode becomes unreachable (network issue, node down, DNS failure, etc.)
3. REST client generates `reqwest::Error` containing full URL: `http://internal-node.company.local:8080/v1/view?ledger_version=12345`
4. Error is converted to `ApiError::InternalError(Some("Failed internal API call with HTTP code 503: error sending request for url (http://internal-node.company.local:8080/v1/view?ledger_version=12345): ..."))`
5. This detailed error message is returned to the attacker via the Rosetta API response

The REST client is initialized with user-configured URLs that often point to internal infrastructure: [4](#0-3) [5](#0-4) 

## Impact Explanation

This vulnerability is correctly classified as **Low severity** per the Aptos Bug Bounty program criteria: "Minor information leaks" (up to $1,000).

The leaked information provides reconnaissance value for attackers:
- Internal network topology and DNS naming conventions
- Infrastructure configuration details
- Specific ledger versions being queried by the service
- Internal port configurations

While this does not directly lead to fund loss, consensus violations, or service disruption, it violates information security best practices and can aid attackers in planning more sophisticated attacks against the infrastructure.

## Likelihood Explanation

This vulnerability has **HIGH likelihood** of exploitation because:
1. **No special permissions required** - Any external API client can trigger it
2. **Natural occurrence** - Happens automatically during network issues or fullnode maintenance
3. **Common scenarios** - Node restarts, network partitions, DNS failures, load balancer issues all trigger this
4. **Public exposure** - Rosetta APIs are typically exposed to external clients

The vulnerability will be exploited whenever backend infrastructure experiences connectivity issues, which is a normal operational occurrence.

## Recommendation

Sanitize error messages before exposing them to external clients. The REST client errors should be converted to generic error messages that do not include internal URLs or infrastructure details.

**Recommended fix for `error.rs`:** [6](#0-5) 

Replace the HTTP error conversion to remove URL details:

```rust
RestError::Http(status_code, _err) => ApiError::InternalError(Some(format!(
    "Failed internal API call with HTTP code {}",
    status_code
))),
```

Or alternatively, map it to a more specific error type:

```rust
RestError::Http(status_code, _err) => {
    if status_code.is_server_error() {
        ApiError::NodeIsOffline
    } else {
        ApiError::InternalError(Some("Failed to connect to node".to_string()))
    }
},
```

Similar sanitization should be applied to:
- `RestError::Timeout` - Don't include timeout details
- `RestError::UrlParse` - Don't include the malformed URL
- `RestError::Unknown` - Sanitize the anyhow error message

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_rest_client::error::RestError;
    use reqwest::StatusCode;
    
    #[test]
    fn test_rest_error_leaks_url() {
        // Simulate a connection error that includes URL
        let url_str = "http://internal-node.company.local:8080/v1/view?ledger_version=12345";
        let req_err = reqwest::Error::new(
            reqwest::error::Kind::Request,
            Some(url::Url::parse(url_str).unwrap())
        );
        
        let rest_error = RestError::Http(StatusCode::SERVICE_UNAVAILABLE, req_err);
        let api_error: ApiError = rest_error.into();
        
        // Verify the error contains internal URL
        match api_error {
            ApiError::InternalError(Some(msg)) => {
                assert!(msg.contains("internal-node.company.local"));
                assert!(msg.contains("8080"));
                println!("LEAKED ERROR MESSAGE: {}", msg);
            },
            _ => panic!("Expected InternalError with message"),
        }
    }
}
```

**Steps to reproduce in live environment:**
1. Configure Rosetta server with internal fullnode URL: `--rest-api-url http://internal-backend.local:8080`
2. Start Rosetta server
3. Stop the internal fullnode or block network connectivity
4. Send Rosetta API request: `POST /account/balance` with valid payload
5. Observe error response contains `internal-backend.local:8080` in the error details

## Notes

The vulnerability affects all Rosetta API endpoints that use the REST client:
- `/account/balance` (account.rs)
- `/block/*` (block.rs) 
- `/construction/metadata` (construction.rs)
- `/network/status` (network.rs)

All these endpoints use the same error conversion mechanism and are vulnerable to the same information leakage when the backend fullnode is unreachable or experiences connectivity issues.

### Citations

**File:** crates/aptos-rosetta/src/account.rs (L381-405)
```rust
pub async fn view<T: DeserializeOwned>(
    rest_client: &Client,
    version: u64,
    address: AccountAddress,
    module: &'static IdentStr,
    function: &'static IdentStr,
    type_args: Vec<TypeTag>,
    args: Vec<Vec<u8>>,
) -> ApiResult<T> {
    Ok(rest_client
        .view_bcs::<T>(
            &ViewFunction {
                module: ModuleId {
                    address,
                    name: module.into(),
                },
                function: function.into(),
                ty_args: type_args,
                args,
            },
            Some(version),
        )
        .await?
        .into_inner())
}
```

**File:** crates/aptos-rosetta/src/error.rs (L211-241)
```rust
    pub fn details(self) -> Option<ErrorDetails> {
        match self {
            ApiError::DeserializationFailed(inner) => inner,
            ApiError::InvalidTransferOperations(inner) => inner.map(|inner| inner.to_string()),
            ApiError::UnsupportedCurrency(inner) => inner,
            ApiError::UnsupportedSignatureCount(inner) => inner.map(|inner| inner.to_string()),
            ApiError::TransactionParseError(inner) => inner,
            ApiError::InvalidOperations(inner) => inner,
            ApiError::InternalError(inner) => inner,
            ApiError::CoinTypeFailedToBeFetched(inner) => inner,
            ApiError::AccountNotFound(inner) => inner,
            ApiError::ResourceNotFound(inner) => inner,
            ApiError::ModuleNotFound(inner) => inner,
            ApiError::StructFieldNotFound(inner) => inner,
            ApiError::VersionNotFound(inner) => inner,
            ApiError::TransactionNotFound(inner) => inner,
            ApiError::TableItemNotFound(inner) => inner,
            ApiError::BlockNotFound(inner) => inner,
            ApiError::VersionPruned(inner) => inner,
            ApiError::BlockPruned(inner) => inner,
            ApiError::InvalidInput(inner) => inner,
            ApiError::InvalidTransactionUpdate(inner) => inner,
            ApiError::SequenceNumberTooOld(inner) => inner,
            ApiError::VmError(inner) => inner,
            ApiError::MempoolIsFull(inner) => inner,
            ApiError::GasEstimationFailed(inner) => inner,
            ApiError::MaxGasFeeTooLow(inner) => inner,
            _ => None,
        }
        .map(|details| ErrorDetails { details })
    }
```

**File:** crates/aptos-rosetta/src/error.rs (L320-329)
```rust
            RestError::Bcs(_) => ApiError::DeserializationFailed(None),
            RestError::Json(_) => ApiError::DeserializationFailed(None),
            RestError::Http(status_code, err) => ApiError::InternalError(Some(format!(
                "Failed internal API call with HTTP code {}: {:#}",
                status_code, err
            ))),
            RestError::UrlParse(err) => ApiError::InternalError(Some(err.to_string())),
            RestError::Timeout(err) => ApiError::InternalError(Some(err.to_string())),
            RestError::Unknown(err) => ApiError::InternalError(Some(err.to_string())),
        }
```

**File:** crates/aptos-rosetta/src/main.rs (L277-286)
```rust
pub struct OnlineRemoteArgs {
    #[clap(flatten)]
    offline_args: OfflineArgs,
    /// URL for the Aptos REST API. e.g. https://fullnode.devnet.aptoslabs.com
    #[clap(long, default_value = "http://localhost:8080")]
    rest_api_url: url::Url,
    /// DEPRECATED: Owner addresses file as a YAML file with a list
    #[clap(long, value_parser)]
    owner_address_file: Option<PathBuf>,
}
```

**File:** crates/aptos-rosetta/src/main.rs (L293-294)
```rust
    fn rest_client(&self) -> Option<aptos_rest_client::Client> {
        Some(aptos_rest_client::Client::new(self.rest_api_url.clone()))
```
