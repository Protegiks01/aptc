# Audit Report

## Title
Insufficient Epoch Validation in OptQuorumStore Payloads Enables Consensus Liveness Attack via Fake Opt_batches

## Summary
The `verify_epoch()` function in optimistic block proposals only performs field-level validation on opt_batches without verifying their cryptographic authenticity or existence. A malicious block proposer can craft fake opt_batches with arbitrary epoch values that pass verification but cause execution failures, halting consensus.

## Finding Description

The vulnerability exists in the epoch validation logic for OptQuorumStore payloads. When `verify_well_formed()` is called on an optimistic block proposal, it invokes `verify_epoch()` to ensure all payload components match the block's epoch. [1](#0-0) 

For OptQuorumStore payloads, this delegates to `OptQuorumStorePayload::check_epoch()`: [2](#0-1) 

Which checks three batch types (inline_batches, opt_batches, and proofs): [3](#0-2) 

**Critical Issue**: For opt_batches (line 335), the check only verifies that `batch.epoch()` returns the expected epoch value. This epoch field is simply stored in the BatchInfo struct: [4](#0-3) 

Unlike ProofOfStore batches which have cryptographic multi-signatures binding the BatchInfo to specific validators, opt_batches are plain BatchInfo objects without any cryptographic proof. The only additional validation is that the author must be in the current validator set: [5](#0-4) 

**Attack Path:**
1. Malicious proposer creates an OptProposalMsg for epoch N
2. Constructs fake BatchInfo objects for opt_batches with:
   - `epoch = N` (to pass verify_epoch)
   - `author = any_valid_validator` (to pass verify_opt_batches)  
   - `digest = arbitrary_hash`
   - Other fields set arbitrarily
3. Includes these in OptQuorumStorePayload
4. The proposal passes all verifications because:
   - No signature check on opt_batches (only on proofs)
   - Epoch field matches block epoch ✓
   - Author is a valid validator ✓
5. Validators vote and certify the block
6. During execution, the payload manager attempts to fetch transactions: [6](#0-5) 

7. The batch reader tries to fetch from local storage, then from the claimed author: [7](#0-6) 

8. Since the batch never existed, `get_batch_from_local()` fails and `request_batch()` times out or fails
9. Execution fails with `ExecutorError`, halting consensus on an already-certified block

**Broken Invariants:**
- **Consensus Safety**: Certified blocks must be executable, but fake opt_batches cause execution failure
- **Deterministic Execution**: Validators cannot produce identical state when execution fails
- **Liveness**: Chain progress halts when execution cannot proceed on certified blocks

## Impact Explanation

**Critical Severity** - This vulnerability enables a consensus liveness attack:

- **Total Loss of Liveness**: A single malicious proposer (< 1/3 Byzantine tolerance) can create blocks that validators certify but cannot execute, halting chain progress
- **Certified Block Execution Failure**: Breaks the fundamental invariant that quorum-certified blocks must be executable
- **Network Partition**: Requires manual intervention or emergency hardfork to recover, as the chain is stuck on an unexecutable but certified block

This meets the Critical severity criteria per the Aptos bug bounty program: "Total loss of liveness/network availability" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**High Likelihood**:
- Any validator selected as block proposer can exploit this
- Attack requires no sophisticated cryptographic manipulation, just crafting fake BatchInfo objects
- No coordination with other validators needed (single Byzantine actor)
- AptosBFT is designed to tolerate < 1/3 Byzantine validators, making this a realistic threat model
- The attack is deterministic and repeatable

## Recommendation

Add cryptographic verification or existence proofs for opt_batches. Implement one of these solutions:

**Option 1: Require signatures on opt_batches**
Transform opt_batches to include validator signatures similar to ProofOfStore, binding the BatchInfo to its creator.

**Option 2: Verify batch existence before voting**
During proposal verification, check that all opt_batches exist in the local batch store or can be fetched from valid peers before validators vote:

```rust
pub(crate) fn verify_epoch(&self, epoch: u64) -> anyhow::Result<()> {
    match self {
        // ... existing cases ...
        Payload::OptQuorumStore(opt_quorum_store_payload) => {
            opt_quorum_store_payload.check_epoch(epoch)?;
            // NEW: Verify opt_batches actually exist
            opt_quorum_store_payload.verify_opt_batches_exist(batch_reader)?;
        },
    };
    Ok(())
}
```

**Option 3: Remove opt_batches entirely**
If opt_batches cannot be secured, remove this feature and require all batches to either be inline (with payload) or have ProofOfStore (with signatures).

## Proof of Concept

```rust
// Malicious proposer creates fake opt_batches
use aptos_consensus_types::{
    common::Payload,
    payload::{OptQuorumStorePayload, InlineBatches, OptBatches, ProofBatches, PayloadExecutionLimit},
    proof_of_store::BatchInfo,
    opt_block_data::OptBlockData,
};
use aptos_crypto::HashValue;
use aptos_types::PeerId;

fn create_malicious_proposal(
    epoch: u64,
    valid_validator: PeerId,
) -> OptBlockData {
    // Create fake opt_batches with arbitrary epoch
    let fake_batch_info = BatchInfo::new(
        valid_validator,           // Valid validator to pass verify_opt_batches
        BatchId::new(12345),
        epoch,                     // Set to match block epoch  
        0,                         // Expiration
        HashValue::random(),       // Fake digest - batch doesn't exist!
        100,                       // Fake num_txns
        1000,                      // Fake num_bytes
        0,                         // Gas bucket
    );
    
    let opt_batches: OptBatches<BatchInfo> = vec![fake_batch_info].into();
    
    let payload = Payload::OptQuorumStore(
        OptQuorumStorePayload::new(
            InlineBatches::from(vec![]),
            opt_batches,  // Fake batches that don't exist!
            ProofBatches::from(vec![]),
            PayloadExecutionLimit::None,
        )
    );
    
    // Create OptBlockData - this will pass verify_epoch() 
    // but fail during execution when trying to fetch the fake batches
    OptBlockData::new(
        vec![],
        payload,
        proposer,
        epoch,
        round,
        timestamp,
        parent_block_info,
        grandparent_qc,
    )
}

// The proposal passes verification:
// - verify_opt_batches: valid_validator is in validator set ✓  
// - verify_epoch: fake_batch_info.epoch == block.epoch ✓
// But execution fails when get_batch() cannot find the fake batch
```

## Notes

This vulnerability specifically affects the OptQuorumStore payload type's opt_batches component. The inline_batches component has digest verification binding transactions to the BatchInfo, and ProofOfStore batches have cryptographic signatures. Only opt_batches lack any form of cryptographic or existence binding, relying solely on field-level validation that can be trivially forged.

### Citations

**File:** consensus/consensus-types/src/opt_block_data.rs (L99-99)
```rust
        self.payload().verify_epoch(self.epoch())?;
```

**File:** consensus/consensus-types/src/common.rs (L558-571)
```rust
    pub fn verify_opt_batches<T: TBatchInfo>(
        verifier: &ValidatorVerifier,
        opt_batches: &OptBatches<T>,
    ) -> anyhow::Result<()> {
        let authors = verifier.address_to_validator_index();
        for batch in &opt_batches.batch_summary {
            ensure!(
                authors.contains_key(&batch.author()),
                "Invalid author {} for batch {}",
                batch.author(),
                batch.digest()
            );
        }
        Ok(())
```

**File:** consensus/consensus-types/src/common.rs (L664-666)
```rust
            Payload::OptQuorumStore(opt_quorum_store_payload) => {
                opt_quorum_store_payload.check_epoch(epoch)?;
            },
```

**File:** consensus/consensus-types/src/payload.rs (L327-344)
```rust
    pub fn check_epoch(&self, epoch: u64) -> anyhow::Result<()> {
        ensure!(
            self.inline_batches
                .iter()
                .all(|b| b.info().epoch() == epoch),
            "OptQS InlineBatch epoch doesn't match given epoch"
        );
        ensure!(
            self.opt_batches.iter().all(|b| b.epoch() == epoch),
            "OptQS OptBatch epoch doesn't match given epoch"
        );

        ensure!(
            self.proofs.iter().all(|b| b.epoch() == epoch),
            "OptQS Proof epoch doesn't match given epoch"
        );

        Ok(())
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L49-58)
```rust
pub struct BatchInfo {
    author: PeerId,
    batch_id: BatchId,
    epoch: u64,
    expiration: u64,
    digest: HashValue,
    num_txns: u64,
    num_bytes: u64,
    gas_bucket_start: u64,
}
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L601-636)
```rust
async fn process_optqs_payload<T: TDataInfo>(
    data_ptr: &BatchPointer<T>,
    batch_reader: Arc<dyn BatchReader>,
    block: &Block,
    ordered_authors: &[PeerId],
    additional_peers_to_request: Option<&BitVec>,
) -> ExecutorResult<Vec<SignedTransaction>> {
    let mut signers = Vec::new();
    if let Some(peers) = additional_peers_to_request {
        for i in peers.iter_ones() {
            if let Some(author) = ordered_authors.get(i) {
                signers.push(*author);
            }
        }
    }
    if let Some(author) = block.author() {
        signers.push(author);
    }

    let batches_and_responders = data_ptr
        .batch_summary
        .iter()
        .map(|summary| {
            let mut signers = signers.clone();
            signers.append(&mut summary.signers(ordered_authors));

            (summary.info().clone(), signers)
        })
        .collect();

    QuorumStorePayloadManager::request_and_wait_transactions(
        batches_and_responders,
        block.timestamp_usecs(),
        batch_reader,
    )
    .await
```

**File:** consensus/src/quorum_store/batch_store.rs (L684-710)
```rust
                let fut = async move {
                    let batch_digest = *batch_info.digest();
                    defer!({
                        inflight_requests_clone.lock().remove(&batch_digest);
                    });
                    // TODO(ibalajiarun): Support V2 batch
                    if let Ok(mut value) = batch_store.get_batch_from_local(&batch_digest) {
                        Ok(value.take_payload().expect("Must have payload"))
                    } else {
                        // Quorum store metrics
                        counters::MISSED_BATCHES_COUNT.inc();
                        let subscriber_rx = batch_store.subscribe(*batch_info.digest());
                        let payload = requester
                            .request_batch(
                                batch_digest,
                                batch_info.expiration(),
                                responders,
                                subscriber_rx,
                            )
                            .await?;
                        batch_store.persist(vec![PersistedValue::new(
                            batch_info.into(),
                            Some(payload.clone()),
                        )]);
                        Ok(payload)
                    }
                }
```
