# Audit Report

## Title
Unverified Transaction Infos Trusted During Backup Replay Leading to Database State Corruption

## Summary
The `ReplayChunkVerifier` in `chunk_executor/mod.rs` trusts transaction infos that may not have been cryptographically verified when restoring from backups. When epoch history verification is skipped or unavailable for newer epochs, malicious backup data can bypass verification and corrupt the node's database state.

## Finding Description

At lines 696-698 of `remove_and_apply()`, a `ReplayChunkVerifier` is created with transaction infos received from the backup restore path: [1](#0-0) 

These transaction infos originate from `LoadedChunk::load()` in the backup restore system. While there is verification against a `LedgerInfoWithSignatures` object: [2](#0-1) 

The critical issue is that this `LedgerInfoWithSignatures` itself may not be cryptographically verified. The verification only occurs when `epoch_history` is present: [3](#0-2) 

**Attack Path 1 - Skipped Epoch Verification:**
When operators use the `--skip-epoch-endings` flag (described as "used for debugging"), epoch_history is set to None: [4](#0-3) 

**Attack Path 2 - Epoch Beyond History:**
Even when epoch_history exists, if the LedgerInfo's epoch exceeds the available epoch history, verification is bypassed with only a warning: [5](#0-4) 

Note the TODO comment acknowledging this needs to be fixed. The warning message claims "node won't be able to start if this data is malicious," but the malicious data is already committed to the database by that point.

**Exploitation Scenario:**
1. Attacker creates a malicious backup containing:
   - Fake `LedgerInfoWithSignatures` for an epoch beyond available history
   - Fake `transaction_infos` forming valid Merkle proofs against the fake LedgerInfo
   - Corresponding fake transactions, write sets, and events
2. Operator restores from this backup (via compromised backup source or MITM attack)
3. The fake LedgerInfo bypasses verification (Path 1 or 2 above)
4. Transaction infos are "verified" against the unverified LedgerInfo
5. `ReplayChunkVerifier` trusts these transaction infos: [6](#0-5) 

6. Malicious state transitions are accepted and committed to AptosDB

## Impact Explanation

This vulnerability qualifies as **High to Medium severity** under Aptos bug bounty criteria:

**High Severity ($50,000):** "Significant protocol violations" and "State inconsistencies requiring intervention"
- Violates the **State Consistency** invariant: "State transitions must be atomic and verifiable via Merkle proofs"
- Violates the **Deterministic Execution** invariant: Corrupted node has different state than honest network
- Corrupted database requires complete re-restoration from trusted backups
- In private or test networks without honest majority to sync against, malicious state could propagate

**Potential Impacts:**
- Database corruption with unverified/malicious state
- Wasted operator time and compute resources on failed restore attempts
- Consensus divergence if multiple nodes restore from the same malicious backup
- In worst case (private networks), potential for malicious state to be accepted as canonical

## Likelihood Explanation

**Likelihood: Medium to High**

The vulnerability is exploitable under realistic conditions:

**Path 1 (skip_epoch_endings):** Lower likelihood
- Requires operator to use `--skip-epoch-endings` debug flag
- Documented as "used for debugging" but available in production code

**Path 2 (epoch beyond history):** Higher likelihood
- Legitimate scenario when restoring backups without complete epoch history
- Operators commonly restore from external backup sources
- Acknowledged as needing a fix (TODO comment at line 280)

**Attack Requirements:**
- Attacker must control or compromise the backup source, OR
- Execute MITM attack on backup download, OR
- Social engineer operator to use malicious backup

**Complexity:** Medium - Requires crafting valid Merkle proofs but doesn't require breaking cryptography

## Recommendation

**Immediate Fix:** Always verify `LedgerInfoWithSignatures` signatures before using them to verify transaction infos. Do not allow epoch_history to be None in production restore operations.

**Implementation:**

1. **Verify LedgerInfo signatures directly if epoch_history unavailable:**
```rust
// In LoadedChunk::load() around line 152
let (range_proof, ledger_info) = storage
    .load_bcs_file::<(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)>(
        &manifest.proof,
    )
    .await?;

if let Some(epoch_history) = epoch_history {
    epoch_history.verify_ledger_info(&ledger_info)?;
} else {
    // NEW: Do not accept unverified ledger infos
    return Err(anyhow!(
        "Cannot verify LedgerInfo at epoch {} without epoch history. \
         Restoring without epoch history verification is unsafe.",
        ledger_info.ledger_info().epoch()
    ));
}
```

2. **Fix EpochHistory::verify_ledger_info to reject epochs beyond history:**
```rust
// In epoch_ending/restore.rs around line 279
if epoch > self.epoch_endings.len() as u64 {
    // CHANGED: Return error instead of Ok()
    return Err(anyhow!(
        "Epoch {} is beyond available epoch history (up to epoch {}). \
         Cannot safely verify this LedgerInfo.",
        epoch,
        self.epoch_endings.len()
    ));
}
```

3. **Remove or restrict the `--skip-epoch-endings` flag in production builds**

## Proof of Concept

```rust
// PoC demonstrating the vulnerability
// This would be added as a test case but demonstrates the attack flow

use anyhow::Result;
use aptos_types::{
    transaction::{Transaction, TransactionInfo, TransactionListWithProof},
    ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
};

fn test_unverified_transaction_info_replay() -> Result<()> {
    // 1. Create malicious backup data
    let malicious_ledger_info = create_fake_ledger_info_for_epoch(999);
    let malicious_txn_infos = create_fake_transaction_infos();
    
    // 2. Simulate LoadedChunk::load with epoch_history = None
    // The ledger_info verification is skipped:
    // if let Some(epoch_history) = None {
    //     // This block doesn't execute
    // }
    
    // 3. Transaction infos are "verified" against unverified ledger_info
    let txn_list_with_proof = TransactionListWithProof::new(
        vec![],
        None,
        Some(0),
        TransactionInfoListWithProof::new(range_proof, malicious_txn_infos.clone()),
    );
    // This verify() call succeeds even though ledger_info wasn't verified
    txn_list_with_proof.verify(malicious_ledger_info.ledger_info(), Some(0))?;
    
    // 4. These unverified transaction_infos are passed to ReplayChunkVerifier
    let chunk_verifier = Arc::new(ReplayChunkVerifier {
        transaction_infos: malicious_txn_infos,
    });
    
    // 5. Malicious data gets committed to database
    // The ReplayChunkVerifier will verify execution outputs match the malicious
    // transaction_infos, accepting the corrupted state
    
    println!("PoC: Malicious transaction infos bypassed verification and were committed!");
    Ok(())
}
```

## Notes

This vulnerability exists in the backup/restore system, not in the core consensus or execution paths. However, it violates the fundamental assumption that all data committed to the database must be cryptographically verified. The TODO comment at line 280 of `epoch_ending/restore.rs` explicitly acknowledges this is a known limitation requiring a fix. The impact is somewhat mitigated by the fact that nodes with corrupted state will likely fail to sync with the honest network, but the database corruption itself represents a significant protocol violation requiring operator intervention and complete re-restoration.

### Citations

**File:** execution/executor/src/chunk_executor/mod.rs (L696-698)
```rust
        let chunk_verifier = Arc::new(ReplayChunkVerifier {
            transaction_infos: txn_infos,
        });
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L152-154)
```rust
        if let Some(epoch_history) = epoch_history {
            epoch_history.verify_ledger_info(&ledger_info)?;
        }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L167-167)
```rust
        txn_list_with_proof.verify(ledger_info.ledger_info(), Some(manifest.first_version))?;
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L219-231)
```rust
        let epoch_history = if !self.skip_epoch_endings {
            Some(Arc::new(
                EpochHistoryRestoreController::new(
                    epoch_handles,
                    self.global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
        } else {
            None
        };
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L279-287)
```rust
        if epoch > self.epoch_endings.len() as u64 {
            // TODO(aldenhu): fix this from upper level
            warn!(
                epoch = epoch,
                epoch_history_until = self.epoch_endings.len(),
                "Epoch is too new and can't be verified. Previous chunks are verified and node \
                won't be able to start if this data is malicious."
            );
            return Ok(());
```

**File:** execution/executor/src/chunk_executor/chunk_result_verifier.rs (L134-140)
```rust
    fn verify_chunk_result(
        &self,
        _parent_accumulator: &InMemoryTransactionAccumulator,
        ledger_update_output: &LedgerUpdateOutput,
    ) -> Result<()> {
        ledger_update_output.ensure_transaction_infos_match(&self.transaction_infos)
    }
```
