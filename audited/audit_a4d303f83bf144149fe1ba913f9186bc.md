# Audit Report

## Title
Path Traversal Vulnerability in Backup Restore FileHandle Processing

## Summary
The `TransactionChunk` struct in the backup manifest system stores `FileHandle` references without validation, allowing path traversal attacks during restore operations. An attacker with access to backup storage can craft malicious manifests containing FileHandles with path traversal sequences (e.g., `"../../etc/passwd"`) to read arbitrary files on the filesystem during backup restoration. [1](#0-0) 

## Finding Description

The vulnerability exists in the backup/restore subsystem's handling of `FileHandle` references within manifest files. 

**FileHandle Type Definition:**
`FileHandle` is defined as a simple type alias for `String` with no inherent validation. [2](#0-1) 

**Vulnerable Deserialization Path:**
When manifests are loaded during restore operations, the `TransactionChunk` struct is deserialized from JSON without validating the `transactions` and `proof` FileHandle fields. [3](#0-2) 

**Exploitation in LocalFs Storage:**
When the restore process attempts to read data referenced by FileHandles, the `LocalFs::open_for_read` method directly joins the FileHandle with the backup directory path without validation: [4](#0-3) 

**Attack Execution Flow:**
1. Attacker crafts a malicious `TransactionBackup` manifest with path traversal sequences in FileHandles (e.g., `"../../../../etc/passwd"`)
2. Manifest is placed in backup storage or provided to operator
3. During restore, `LoadedChunk::load()` calls `storage.open_for_read(&manifest.transactions)` [5](#0-4) 

4. The path join operation `self.dir.join(file_handle)` creates a path like `/backup/dir/../../../../etc/passwd`
5. When opened, the OS resolves this to `/etc/passwd`, allowing arbitrary file reads

**Broken Security Guarantee:**
This violates the **Access Control** invariant - the backup restore process should only access files within designated backup storage, not arbitrary filesystem locations.

## Impact Explanation

This vulnerability qualifies as **Medium Severity** per Aptos bug bounty criteria:

- **Unauthorized File Access**: Attackers can read sensitive files accessible to the restore process, including private keys, configuration files, database files, or other credentials
- **No Direct Fund Loss**: Does not directly lead to theft or minting of funds
- **State/Configuration Exposure**: Could expose validator private keys or configuration that enables further attacks
- **Limited Scope**: Affects only the node performing the restore operation, not network-wide

The impact is constrained because it requires specific conditions but could serve as a stepping stone for more severe attacks if validator keys or other critical data are exposed.

## Likelihood Explanation

**Likelihood: Medium-Low**

**Required Attacker Capabilities:**
- Write access to backup storage (S3 bucket, local filesystem, cloud storage), OR
- Ability to social engineer an operator into using a malicious manifest

**Realistic Attack Scenarios:**
1. **Misconfigured Backup Storage**: Publicly writable or insufficiently secured cloud storage buckets
2. **Compromised Storage Credentials**: Leaked AWS/GCP credentials with write access to backup locations
3. **Insider Threat**: Malicious employee/contractor with backup storage access
4. **Supply Chain Compromise**: Compromised backup tooling that injects malicious manifests

While backup storage is typically trusted infrastructure controlled by validator operators, defense-in-depth principles dictate that deserialized external input should always be validated. Real-world misconfigurations and credential leaks make this a realistic attack vector.

## Recommendation

Implement FileHandle validation to prevent path traversal attacks:

**1. Add validation function:**
```rust
fn validate_file_handle(file_handle: &str, allowed_base: &Path) -> Result<()> {
    let path = Path::new(file_handle);
    
    // Reject absolute paths
    ensure!(!path.is_absolute(), "FileHandle must not be absolute path");
    
    // Reject path traversal components
    for component in path.components() {
        ensure!(
            !matches!(component, std::path::Component::ParentDir),
            "FileHandle must not contain '..' components"
        );
    }
    
    // Optionally verify resolved path is within allowed base
    let resolved = allowed_base.join(file_handle);
    let canonical_base = allowed_base.canonicalize()?;
    if let Ok(canonical) = resolved.canonicalize() {
        ensure!(
            canonical.starts_with(&canonical_base),
            "FileHandle resolves outside allowed directory"
        );
    }
    
    Ok(())
}
```

**2. Validate in `LocalFs::open_for_read`:**
```rust
async fn open_for_read(
    &self,
    file_handle: &FileHandleRef,
) -> Result<Box<dyn AsyncRead + Send + Unpin>> {
    // Validate before use
    validate_file_handle(file_handle, &self.dir)?;
    
    let path = self.dir.join(file_handle);
    let file = OpenOptions::new()
        .read(true)
        .open(&path)
        .await
        .err_notes(&path)?;
    Ok(Box::new(file))
}
```

**3. Apply validation in other storage implementations** (CommandAdapter) to prevent similar issues with cloud storage URIs.

## Proof of Concept

```rust
// File: storage/backup/backup-cli/src/storage/local_fs/test_path_traversal.rs
#[cfg(test)]
mod path_traversal_tests {
    use super::*;
    use std::fs;
    use tempfile::TempDir;
    use tokio::io::AsyncReadExt;

    #[tokio::test]
    async fn test_path_traversal_vulnerability() {
        // Setup: Create backup directory with a file
        let temp_dir = TempDir::new().unwrap();
        let backup_dir = temp_dir.path().join("backups");
        fs::create_dir_all(&backup_dir).unwrap();
        
        // Create a sensitive file outside backup directory  
        let sensitive_file = temp_dir.path().join("sensitive.txt");
        fs::write(&sensitive_file, b"SECRET_DATA").unwrap();
        
        // Create LocalFs storage pointing to backup directory
        let storage = LocalFs::new(backup_dir.clone());
        
        // Attempt path traversal attack
        let malicious_handle = "../sensitive.txt";
        
        // This SHOULD fail but currently succeeds - demonstrating vulnerability
        let result = storage.open_for_read(malicious_handle).await;
        
        if let Ok(mut file) = result {
            let mut contents = String::new();
            file.read_to_string(&mut contents).await.unwrap();
            assert_eq!(contents, "SECRET_DATA");
            println!("VULNERABILITY CONFIRMED: Read file outside backup directory!");
        }
    }
    
    #[tokio::test]
    async fn test_malicious_manifest_exploitation() {
        let temp_dir = TempDir::new().unwrap();
        let backup_dir = temp_dir.path().join("backups");
        fs::create_dir_all(&backup_dir).unwrap();
        
        // Simulate sensitive system file
        let etc_dir = temp_dir.path().join("etc");
        fs::create_dir_all(&etc_dir).unwrap();
        fs::write(etc_dir.join("passwd"), b"root:x:0:0:root:/root:/bin/bash").unwrap();
        
        let storage = Arc::new(LocalFs::new(backup_dir.clone()));
        
        // Craft malicious TransactionChunk
        let malicious_chunk = TransactionChunk {
            first_version: 0,
            last_version: 100,
            transactions: "../../etc/passwd".to_string(), // Path traversal
            proof: "legitimate_backup/proof.proof".to_string(),
            format: TransactionChunkFormat::V1,
        };
        
        // Attempt to load chunk - will read /etc/passwd
        let result = LoadedChunk::load(malicious_chunk, &storage, None).await;
        
        // Demonstrates vulnerability exists
        match result {
            Ok(_) => println!("Successfully loaded data from outside backup directory!"),
            Err(e) => println!("Error (expected in fixed version): {}", e),
        }
    }
}
```

## Notes

- This vulnerability affects all storage backends (LocalFs and CommandAdapter) but impacts vary by implementation
- The `ShellSafeName` validation used for creating new FileHandles does prevent path traversal, but this validation is not applied to deserialized FileHandles from manifests
- CommandAdapter's external commands may have their own path handling that could mitigate or exacerbate the issue depending on the specific command implementation
- Similar vulnerabilities may exist in other manifest types (`EpochEndingBackup`, `StateSnapshotBackup`) that also contain FileHandle fields and should be audited [6](#0-5)

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/manifest.rs (L20-34)
```rust
pub struct TransactionChunk {
    pub first_version: Version,
    pub last_version: Version,
    /// Repeated `len(record) + record`, where `record` is BCS serialized tuple
    /// `(Transaction, TransactionInfo)`
    pub transactions: FileHandle,
    /// BCS serialized `(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)`.
    /// The `TransactionAccumulatorRangeProof` links the transactions to the
    /// `LedgerInfoWithSignatures`, and the `LedgerInfoWithSignatures` can be verified by the
    /// signatures it carries, against the validator set in the epoch. (Hence proper
    /// `EpochEndingBackup` is needed for verification.)
    pub proof: FileHandle,
    #[serde(default = "default_to_v0")]
    pub format: TransactionChunkFormat,
}
```

**File:** storage/backup/backup-cli/src/storage/mod.rs (L36-41)
```rust
/// URI pointing to a file in a backup storage, like "s3:///bucket/path/file".
/// These are created by the storage when `create_for_write()`, stored in manifests by the backup
/// controller, and passed back to the storage when `open_for_read()` by the restore controller
/// to retrieve a file referred to in the manifest.
pub type FileHandle = String;
pub type FileHandleRef = str;
```

**File:** storage/backup/backup-cli/src/storage/mod.rs (L51-59)
```rust
impl ShellSafeName {
    const PATTERN: &'static str = r"\A[a-zA-Z0-9][a-zA-Z0-9._-]{2,126}\z";

    fn sanitize(name: &str) -> Result<()> {
        static RE: Lazy<Regex> = Lazy::new(|| Regex::new(ShellSafeName::PATTERN).unwrap());
        ensure!(RE.is_match(name), "Illegal name: {}", name,);
        Ok(())
    }
}
```

**File:** storage/backup/backup-cli/src/utils/storage_ext.rs (L35-37)
```rust
    async fn load_json_file<T: DeserializeOwned>(&self, file_handle: &FileHandleRef) -> Result<T> {
        Ok(serde_json::from_slice(&self.read_all(file_handle).await?)?)
    }
```

**File:** storage/backup/backup-cli/src/storage/local_fs/mod.rs (L98-109)
```rust
    async fn open_for_read(
        &self,
        file_handle: &FileHandleRef,
    ) -> Result<Box<dyn AsyncRead + Send + Unpin>> {
        let path = self.dir.join(file_handle);
        let file = OpenOptions::new()
            .read(true)
            .open(&path)
            .await
            .err_notes(&path)?;
        Ok(Box::new(file))
    }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L100-105)
```rust
    async fn load(
        manifest: TransactionChunk,
        storage: &Arc<dyn BackupStorage>,
        epoch_history: Option<&Arc<EpochHistory>>,
    ) -> Result<Self> {
        let mut file = BufReader::new(storage.open_for_read(&manifest.transactions).await?);
```
