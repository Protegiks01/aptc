# Audit Report

## Title
Database Metadata Corruption via Integer Underflow in Backup Restore with Empty Transaction Arrays

## Summary
The `save_transactions()` function in `restore_utils.rs` performs unchecked arithmetic (`first_version + txns.len() as u64 - 1`) that underflows when `txns` is empty, writing invalid version metadata to the database. This corrupts critical commit progress tracking used by consensus and state synchronization.

## Finding Description

The vulnerability exists in the backup restore flow where empty transaction arrays can be passed to `save_transactions()`, causing integer underflow when calculating `last_version`. [1](#0-0) 

When `txns.len() == 0`, the calculation becomes `first_version + 0 - 1 = first_version - 1`. If `first_version == 0`, this causes underflow to `u64::MAX` in release mode (or panic in debug mode). Even when `first_version > 0`, the result is logically incorrect since `last_version < first_version` violates the ledger version ordering invariant.

The same underflow occurs in `save_transactions_impl()`: [2](#0-1) 

This invalid `last_version` is then written to critical database metadata: [3](#0-2) 

**Attack Path:**

The vulnerability is triggered during backup restore when transaction chunks are filtered by version ranges. In the restore flow: [4](#0-3) 

After draining transactions beyond `target_version` (lines 475-483) and before `global_first_version` (lines 486-495), the arrays can become empty when `global_first_version > target_version + 1`. The code then calculates `num_to_save` at line 500, which can be 0 when `last_version + 1 == first_version`, and proceeds to call `save_transactions()` with empty arrays at line 508.

These metadata keys are critical for database synchronization: [5](#0-4) 

The corrupted metadata breaks **State Consistency** (Invariant #4), as version tracking becomes invalid, and impacts consensus safety by causing nodes to have inconsistent views of ledger progress.

## Impact Explanation

This is **Medium Severity** per Aptos bug bounty criteria as it causes "state inconsistencies requiring intervention":

1. **Database Corruption**: Writing `u64::MAX` or `first_version - 1` as the commit progress creates invalid database state
2. **State Sync Failures**: Nodes attempting to sync will read corrupted version metadata, causing synchronization failures
3. **Consensus Disruption**: Validators rely on accurate version tracking for consensus participation; corrupted metadata can cause nodes to diverge
4. **Restore Operation Failures**: The backup restore process itself may fail or produce an unusable database
5. **Potential Chain Halt**: If multiple nodes restore from the same corrupted backup, consensus could stall

The impact is limited to nodes performing backup restore operations, not the entire network, which prevents it from reaching Critical severity.

## Likelihood Explanation

**Likelihood: Medium**

This vulnerability occurs under specific but realistic conditions:

1. **Trigger Condition**: Requires backup restore with version ranges where `global_first_version > target_version + 1`, causing transaction arrays to become empty after filtering
2. **Deployment Context**: Backup restore is a standard operational procedure for:
   - New validator node setup
   - Disaster recovery
   - Database migration
   - State snapshot restoration
3. **Detection**: The corruption may not be immediately obvious, manifesting later as state sync failures or consensus issues
4. **Exploitability**: While not directly exploitable by external attackers, operators performing legitimate backup restores can inadvertently trigger this bug

## Recommendation

Add validation to prevent calling the function with empty transaction arrays. The fix should be applied in two locations:

**Option 1: Early return in `save_transactions()`**
```rust
pub(crate) fn save_transactions(
    state_store: Arc<StateStore>,
    ledger_db: Arc<LedgerDb>,
    first_version: Version,
    txns: &[Transaction],
    // ... other parameters
) -> Result<()> {
    // Add validation at the start
    if txns.is_empty() {
        return Ok(());
    }
    // ... rest of function
}
```

**Option 2: Check before calling in the restore flow**
```rust
// In restore.rs around line 498
if first_version < first_to_replay {
    let num_to_save = (min(first_to_replay, last_version + 1) - first_version) as usize;
    
    // Add guard to skip empty saves
    if num_to_save > 0 && first_version <= last_version {
        let txns_to_save: Vec<_> = txns.drain(..num_to_save).collect();
        // ... rest of save logic
    }
}
```

Both fixes should be implemented for defense in depth. Additionally, use checked arithmetic to prevent underflow:

```rust
let last_version = first_version.checked_add(txns.len() as u64)
    .and_then(|v| v.checked_sub(1))
    .ok_or_else(|| AptosDbError::Other("Invalid version calculation".to_string()))?;
```

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    
    #[test]
    #[should_panic(expected = "underflow")]
    fn test_empty_transactions_underflow() {
        // This test demonstrates the underflow with empty transactions
        let first_version: u64 = 0;
        let txns: Vec<Transaction> = vec![]; // Empty array
        
        // This calculation will underflow in debug mode
        let last_version = first_version + txns.len() as u64 - 1;
        
        // In release mode without overflow checks, last_version would be u64::MAX
        assert_eq!(last_version, u64::MAX);
    }
    
    #[test]
    fn test_restore_with_empty_chunk() {
        // Scenario: restore with global_first_version > target_version + 1
        let mut first_version = 100;
        let mut last_version = 200;
        let target_version = 150;
        let global_first_version = 160;
        
        let mut txns = vec![/* 101 transactions from 100 to 200 */];
        
        // Drain transactions beyond target_version
        if target_version < last_version {
            let num_to_keep = (target_version - first_version + 1) as usize; // 51
            txns.drain(num_to_keep..);
            last_version = target_version; // Now 150
        }
        
        // Drain transactions before global_first_version
        if global_first_version > first_version {
            let num_to_remove = (global_first_version - first_version) as usize; // 60
            txns.drain(..num_to_remove); // This empties the array since num_to_remove > num_to_keep
            first_version = global_first_version; // Now 160
        }
        
        // At this point: first_version=160, last_version=150, txns is empty
        // The invariant first_version <= last_version is violated
        assert!(txns.is_empty());
        assert!(first_version > last_version);
        
        // Attempting to calculate num_to_save would cause issues
        let first_to_replay = 170;
        if first_version < first_to_replay { // 160 < 170, true
            // This would result in num_to_save = (min(170, 151) - 160) = (151 - 160) 
            // which would underflow or be negative
        }
    }
}
```

**Notes:**

The vulnerability specifically affects the backup restore code path, not the normal transaction commit flow. The regular `DbWriter::save_transactions` interface has an early return for empty chunks [6](#0-5) , but the lower-level `restore_utils::save_transactions()` used by the backup restore handler lacks this protection [7](#0-6) .

### Citations

**File:** storage/aptosdb/src/backup/restore_utils.rs (L166-166)
```rust
        let last_version = first_version + txns.len() as u64 - 1;
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L279-279)
```rust
    let last_version = first_version + txns.len() as u64 - 1;
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L280-291)
```rust
    ledger_db_batch
        .ledger_metadata_db_batches
        .put::<DbMetadataSchema>(
            &DbMetadataKey::LedgerCommitProgress,
            &DbMetadataValue::Version(last_version),
        )?;
    ledger_db_batch
        .ledger_metadata_db_batches
        .put::<DbMetadataSchema>(
            &DbMetadataKey::OverallCommitProgress,
            &DbMetadataValue::Version(last_version),
        )?;
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L475-527)
```rust
                    if target_version < last_version {
                        let num_to_keep = (target_version - first_version + 1) as usize;
                        txns.drain(num_to_keep..);
                        persisted_aux_info.drain(num_to_keep..);
                        txn_infos.drain(num_to_keep..);
                        event_vecs.drain(num_to_keep..);
                        write_sets.drain(num_to_keep..);
                        last_version = target_version;
                    }

                    // remove the txns that are before the global_first_version
                    if global_first_version > first_version {
                        let num_to_remove = (global_first_version - first_version) as usize;

                        txns.drain(..num_to_remove);
                        persisted_aux_info.drain(..num_to_remove);
                        txn_infos.drain(..num_to_remove);
                        event_vecs.drain(..num_to_remove);
                        write_sets.drain(..num_to_remove);
                        first_version = global_first_version;
                    }

                    // identify txns to be saved before the first_to_replay version
                    if first_version < first_to_replay {
                        let num_to_save =
                            (min(first_to_replay, last_version + 1) - first_version) as usize;
                        let txns_to_save: Vec<_> = txns.drain(..num_to_save).collect();
                        let persisted_aux_info_to_save: Vec<_> =
                            persisted_aux_info.drain(..num_to_save).collect();
                        let txn_infos_to_save: Vec<_> = txn_infos.drain(..num_to_save).collect();
                        let event_vecs_to_save: Vec<_> = event_vecs.drain(..num_to_save).collect();
                        let write_sets_to_save = write_sets.drain(..num_to_save).collect();
                        tokio::task::spawn_blocking(move || {
                            restore_handler.save_transactions(
                                first_version,
                                &txns_to_save,
                                &persisted_aux_info_to_save,
                                &txn_infos_to_save,
                                &event_vecs_to_save,
                                write_sets_to_save,
                            )
                        })
                        .await??;
                        let last_saved = first_version + num_to_save as u64 - 1;
                        TRANSACTION_SAVE_VERSION.set(last_saved as i64);
                        info!(
                            version = last_saved,
                            accumulative_tps = ((last_saved - global_first_version + 1) as f64
                                / start.elapsed().as_secs_f64())
                                as u64,
                            "Transactions saved."
                        );
                    }
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L76-83)
```rust
    pub(crate) fn get_synced_version(&self) -> Result<Option<Version>> {
        get_progress(&self.db, &DbMetadataKey::OverallCommitProgress)
    }

    pub(crate) fn get_ledger_commit_progress(&self) -> Result<Version> {
        get_progress(&self.db, &DbMetadataKey::LedgerCommitProgress)?
            .ok_or_else(|| AptosDbError::NotFound("No LedgerCommitProgress in db.".to_string()))
    }
```

**File:** storage/storage-interface/src/lib.rs (L615-617)
```rust
        if ledger_info_with_sigs.is_none() && chunk.is_empty() {
            return Ok(());
        }
```

**File:** storage/aptosdb/src/backup/restore_handler.rs (L78-99)
```rust
    pub fn save_transactions(
        &self,
        first_version: Version,
        txns: &[Transaction],
        persisted_aux_info: &[PersistedAuxiliaryInfo],
        txn_infos: &[TransactionInfo],
        events: &[Vec<ContractEvent>],
        write_sets: Vec<WriteSet>,
    ) -> Result<()> {
        restore_utils::save_transactions(
            self.state_store.clone(),
            self.ledger_db.clone(),
            first_version,
            txns,
            persisted_aux_info,
            txn_infos,
            events,
            write_sets,
            None,
            false,
        )
    }
```
