# Audit Report

## Title
Silent Token Renewal Failure Causes Unpredictable Validator Panic During Critical Consensus Operations

## Summary
VaultStorage's automatic token renewal mechanism silently fails and logs errors without halting execution, allowing the validator to continue with an expired token. When this expired token is subsequently used during critical consensus operations (voting, timeouts, proposal signing), Vault returns HTTP 403 errors that trigger an intentional panic in SafetyRules, causing immediate validator halt without graceful degradation or recovery.

## Finding Description

The vulnerability exists in the interaction between VaultStorage's token renewal logic and SafetyRules' error handling:

**Stage 1 - Silent Renewal Failure:** [1](#0-0) 

The `client()` method attempts automatic token renewal but only logs failures without propagating errors or halting execution. When `client.renew_token_self()` fails (network timeout, Vault unavailability, max TTL reached, etc.), the error is logged but the expired token continues to be used.

**Stage 2 - Critical Operations Trigger Storage Access:** [2](#0-1) [3](#0-2) 

All consensus signing operations (`guarded_sign_timeout_with_qc`, `guarded_construct_and_sign_vote_two_chain`, `guarded_construct_and_sign_order_vote`) access `persistent_storage.safety_data()` which performs VaultStorage operations.

**Stage 3 - Expired Token Causes Permission Denial:** [4](#0-3) 

When VaultStorage attempts operations with an expired token, Vault returns HTTP 403, which is converted to `Error::PermissionDenied`.

**Stage 4 - Unconditional Panic Halts Validator:** [5](#0-4) 

When SafetyRules receives `PermissionDenied`, it triggers an intentional panic to "alert an operator." This immediately crashes the validator process during consensus operations, with no recovery mechanism.

## Impact Explanation

**High Severity** - This issue causes validator node halts during critical consensus operations, meeting the High Severity criteria of "Validator node slowdowns" and "Significant protocol violations" per the Aptos Bug Bounty program.

**Specific Impacts:**
1. **Complete Validator Halt**: The panic crashes the validator process during voting, timeout signing, or proposal operations
2. **No Graceful Degradation**: Unlike errors caught by MetricsSafetyRules retry logic, panics cannot be caught or recovered
3. **Unpredictable Timing**: Silent renewal failures create a time bomb - the validator appears healthy until the next consensus operation
4. **Network Liveness Risk**: Multiple validators using Vault with similar token configurations could halt simultaneously if Vault becomes unavailable
5. **Requires Manual Intervention**: Operators must manually restart validators and renew tokens

The retry mechanism in MetricsSafetyRules only handles specific error types: [6](#0-5) 

Panics cannot be caught by this retry logic, making validator halt unrecoverable.

## Likelihood Explanation

**High Likelihood** - Token renewal can fail due to multiple realistic operational scenarios:

1. **Network Partitions**: Temporary network issues between validator and Vault service
2. **Vault Unavailability**: Vault maintenance, crashes, or resource exhaustion
3. **Token Max TTL**: Vault tokens have maximum TTL limits that may be reached despite renewal attempts
4. **Configuration Errors**: Incorrect `renew_ttl_secs` values or insufficient token permissions
5. **Certificate Expiration**: SSL/TLS certificate issues blocking HTTPS connections

These are common operational scenarios in production blockchain infrastructure. The silent failure mode means operators may not realize tokens are failing to renew until validators start panicking.

## Recommendation

**Immediate Fix**: Fail fast on token renewal failures instead of silent logging:

```rust
fn client(&self) -> Result<&Client, Error> {
    if self.renew_ttl_secs.is_some() {
        let now = self.time_service.now_secs();
        let next_renewal = self.next_renewal.load(Ordering::Relaxed);
        if now >= next_renewal {
            // Critical: renewal failure should be fatal
            let ttl = self.client.renew_token_self(self.renew_ttl_secs)
                .map_err(|e| {
                    aptos_logger::error!("Token renewal failed: {}", e);
                    Error::InternalError(format!("Token renewal failed: {}", e))
                })?;
            
            let next_renewal = now + (ttl as u64) / 2;
            self.next_renewal.store(next_renewal, Ordering::Relaxed);
        }
    }
    Ok(&self.client)
}
```

**Long-term Solutions**:
1. Implement retry logic with exponential backoff for renewal failures
2. Add health check endpoint that monitors token validity
3. Emit metrics/alerts when renewal fails
4. Support fallback storage backends for critical consensus keys
5. Implement graceful degradation (read-only mode) instead of panic

## Proof of Concept

```rust
#[test]
fn test_token_expiration_causes_validator_halt() {
    use aptos_secure_storage::{Storage, VaultStorage};
    use aptos_safety_rules::{PersistentSafetyStorage, SafetyRules, TSafetyRules};
    use aptos_types::validator_signer::ValidatorSigner;
    
    // Setup VaultStorage with auto-renewal
    let mut vault_storage = Storage::from(VaultStorage::new(
        "http://127.0.0.1:8200".to_string(),
        "expired_token".to_string(), // Use an expired or invalid token
        None,
        Some(300), // Enable auto-renewal
        true,
        None,
        None,
    ));
    
    let signer = ValidatorSigner::from_int(0);
    let waypoint = test_utils::validator_signers_to_waypoint(&[&signer]);
    
    // Initialize storage - this works with valid token
    let storage = PersistentSafetyStorage::initialize(
        vault_storage,
        signer.author(),
        signer.private_key().clone(),
        waypoint,
        true,
    );
    
    let mut safety_rules = SafetyRules::new(storage, false);
    
    // Simulate network partition - token renewal will fail silently
    // Block network access to Vault here...
    
    // Wait for token to expire
    std::thread::sleep(std::time::Duration::from_secs(310));
    
    // Attempt consensus operation - THIS WILL PANIC
    let vote_proposal = create_test_vote_proposal();
    let result = safety_rules.construct_and_sign_vote_two_chain(&vote_proposal, None);
    
    // Expected: Validator panics with "A permission error was thrown"
    // Actual: Should handle gracefully or fail fast during renewal
    assert!(result.is_err()); // Will never reach here due to panic
}
```

## Notes

The panic behavior is **intentional** per code comments, designed to "fail fast and alert operators." However, the VULNERABILITY is the **silent renewal failure** that creates unpredictable delayed panics. The system should either:
- Fail immediately when renewal fails (current recommendation)
- Retry with backoff and eventually fail if all retries exhausted  
- Implement circuit breaker pattern with graceful degradation

The current design violates the principle of "fail fast" by allowing silent failures that manifest as panics during critical consensus operations.

### Citations

**File:** secure/storage/src/vault.rs (L68-84)
```rust
    // Made into an accessor so we can get auto-renewal
    fn client(&self) -> &Client {
        if self.renew_ttl_secs.is_some() {
            let now = self.time_service.now_secs();
            let next_renewal = self.next_renewal.load(Ordering::Relaxed);
            if now >= next_renewal {
                let result = self.client.renew_token_self(self.renew_ttl_secs);
                if let Ok(ttl) = result {
                    let next_renewal = now + (ttl as u64) / 2;
                    self.next_renewal.store(next_renewal, Ordering::Relaxed);
                } else if let Err(e) = result {
                    aptos_logger::error!("Unable to renew lease: {}", e.to_string());
                }
            }
        }
        &self.client
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L19-51)
```rust
    pub(crate) fn guarded_sign_timeout_with_qc(
        &mut self,
        timeout: &TwoChainTimeout,
        timeout_cert: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;
        let mut safety_data = self.persistent_storage.safety_data()?;
        self.verify_epoch(timeout.epoch(), &safety_data)?;
        if !self.skip_sig_verify {
            timeout
                .verify(&self.epoch_state()?.verifier)
                .map_err(|e| Error::InvalidTimeout(e.to_string()))?;
        }
        if let Some(tc) = timeout_cert {
            self.verify_tc(tc)?;
        }

        self.safe_to_timeout(timeout, timeout_cert, &safety_data)?;
        if timeout.round() < safety_data.last_voted_round {
            return Err(Error::IncorrectLastVotedRound(
                timeout.round(),
                safety_data.last_voted_round,
            ));
        }
        if timeout.round() > safety_data.last_voted_round {
            self.verify_and_update_last_vote_round(timeout.round(), &mut safety_data)?;
        }
        self.update_highest_timeout_round(timeout, &mut safety_data);
        self.persistent_storage.set_safety_data(safety_data)?;

        let signature = self.sign(&timeout.signing_format())?;
        Ok(signature)
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L53-95)
```rust
    pub(crate) fn guarded_construct_and_sign_vote_two_chain(
        &mut self,
        vote_proposal: &VoteProposal,
        timeout_cert: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<Vote, Error> {
        // Exit early if we cannot sign
        self.signer()?;

        let vote_data = self.verify_proposal(vote_proposal)?;
        if let Some(tc) = timeout_cert {
            self.verify_tc(tc)?;
        }
        let proposed_block = vote_proposal.block();
        let mut safety_data = self.persistent_storage.safety_data()?;

        // if already voted on this round, send back the previous vote
        // note: this needs to happen after verifying the epoch as we just check the round here
        if let Some(vote) = safety_data.last_vote.clone() {
            if vote.vote_data().proposed().round() == proposed_block.round() {
                return Ok(vote);
            }
        }

        // Two voting rules
        self.verify_and_update_last_vote_round(
            proposed_block.block_data().round(),
            &mut safety_data,
        )?;
        self.safe_to_vote(proposed_block, timeout_cert)?;

        // Record 1-chain data
        self.observe_qc(proposed_block.quorum_cert(), &mut safety_data);
        // Construct and sign vote
        let author = self.signer()?.author();
        let ledger_info = self.construct_ledger_info_2chain(proposed_block, vote_data.hash())?;
        let signature = self.sign(&ledger_info)?;
        let vote = Vote::new_with_signature(vote_data, author, ledger_info, signature);

        safety_data.last_vote = Some(vote.clone());
        self.persistent_storage.set_safety_data(safety_data)?;

        Ok(vote)
    }
```

**File:** secure/storage/src/error.rs (L56-64)
```rust
impl From<aptos_vault_client::Error> for Error {
    fn from(error: aptos_vault_client::Error) -> Self {
        match error {
            aptos_vault_client::Error::NotFound(_, key) => Self::KeyNotSet(key),
            aptos_vault_client::Error::HttpError(403, _, _) => Self::PermissionDenied,
            _ => Self::InternalError(format!("{}", error)),
        }
    }
}
```

**File:** consensus/safety-rules/src/error.rs (L78-99)
```rust
impl From<aptos_secure_storage::Error> for Error {
    fn from(error: aptos_secure_storage::Error) -> Self {
        match error {
            aptos_secure_storage::Error::PermissionDenied => {
                // If a storage error is thrown that indicates a permission failure, we
                // want to panic immediately to alert an operator that something has gone
                // wrong. For example, this error is thrown when a storage (e.g., vault)
                // token has expired, so it makes sense to fail fast and require a token
                // renewal!
                panic!(
                    "A permission error was thrown: {:?}. Maybe the storage token needs to be renewed?",
                    error
                );
            },
            aptos_secure_storage::Error::KeyVersionNotFound(_, _)
            | aptos_secure_storage::Error::KeyNotSet(_) => {
                Self::SecureStorageMissingDataError(error.to_string())
            },
            _ => Self::SecureStorageUnexpectedError(error.to_string()),
        }
    }
}
```

**File:** consensus/src/metrics_safety_rules.rs (L71-85)
```rust
    fn retry<T, F: FnMut(&mut Box<dyn TSafetyRules + Send + Sync>) -> Result<T, Error>>(
        &mut self,
        mut f: F,
    ) -> Result<T, Error> {
        let result = f(&mut self.inner);
        match result {
            Err(Error::NotInitialized(_))
            | Err(Error::IncorrectEpoch(_, _))
            | Err(Error::WaypointOutOfDate(_, _, _, _)) => {
                self.perform_initialize()?;
                f(&mut self.inner)
            },
            _ => result,
        }
    }
```
