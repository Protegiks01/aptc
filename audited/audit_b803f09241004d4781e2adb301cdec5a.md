# Audit Report

## Title
Client-Side Denial of Service via Assertion Panic in REST API Ledger Information Parsing

## Summary
The `get_ledger_information()` function in the Aptos REST client contains production assertions that compare ledger state values from HTTP response headers against values from the BCS-encoded response body. A malicious or compromised fullnode can send inconsistent data between these two sources, causing the assertions to fail and panic, resulting in a client-side denial of service affecting the Move package resolver, Aptos CLI, Rosetta server, and other critical client tools.

## Finding Description

When `resolve_network_version()` queries a fullnode for ledger information, it ultimately calls `get_ledger_information()` in the REST client. [1](#0-0) 

The `get_ledger_information()` function retrieves ledger state from two independent sources:
1. HTTP response headers (via `State::from_headers()`)
2. BCS-encoded response body (via `IndexResponseBcs` deserialization)

After constructing a `State` object from the BCS body, the function contains four assertions that validate consistency between these two sources: [2](#0-1) 

These are production assertions (`assert_eq!`, not `debug_assert_eq!`) that always execute, even in release builds.

**Attack Vector:**

A malicious fullnode operator can craft responses where the HTTP headers and BCS body contain different values. For example:
- HTTP header: `X-Aptos-Ledger-Version: 1000`
- BCS body field: `ledger_version: 2000`

When the client processes this response, the assertion `assert_eq!(response.inner().version, response.state().version)` will evaluate to `assert_eq!(2000, 1000)`, causing a panic that crashes the client.

**Affected Code Paths:**

The vulnerability affects multiple production services:
- **Move Package Resolver**: Used during `aptos move compile` with on-chain dependencies [3](#0-2) 
- **Aptos CLI**: Used to retrieve chain ID for various commands [4](#0-3) 
- **Aptos Rosetta**: Used during server startup to validate chain ID [5](#0-4) 

## Impact Explanation

This vulnerability qualifies as **Medium Severity** under the Aptos bug bounty program criteria ("API crashes"). 

The impact includes:
- **Client Tool Unavailability**: Developers cannot compile Move packages with on-chain dependencies
- **CLI Crashes**: Aptos CLI commands fail when querying malicious fullnodes
- **Service Disruption**: Rosetta servers cannot start if connected to a malicious fullnode
- **Ecosystem Impact**: Any service using the REST client library is vulnerable to crashes

This does **not** affect:
- Consensus or validator operations (client-side only)
- Blockchain state integrity
- Fund security

The vulnerability is limited to client-side denial of service and does not compromise the network itself.

## Likelihood Explanation

**Likelihood: Medium**

Prerequisites for exploitation:
1. Attacker operates a fullnode (trivial - anyone can run one)
2. Victim client connects to the malicious fullnode (requires social engineering, DNS hijacking, or MitM)
3. Client calls `get_ledger_information()` (happens during normal operations)

The attack is straightforward to execute once the victim connects to a malicious fullnode. Realistic attack scenarios include:
- Compromised public fullnode endpoints
- Phishing campaigns directing users to malicious fullnodes
- BGP hijacking or DNS poisoning attacks
- Man-in-the-middle attacks on unencrypted connections

The low complexity and high impact on developer tools makes this a valid security concern.

## Recommendation

Replace the production assertions with proper error handling that returns a `Result` instead of panicking:

```rust
pub async fn get_ledger_information(&self) -> AptosResult<Response<State>> {
    let response = self.get_index_bcs().await?.map(|r| State {
        chain_id: r.chain_id,
        epoch: r.epoch.into(),
        version: r.ledger_version.into(),
        timestamp_usecs: r.ledger_timestamp.into(),
        oldest_ledger_version: r.oldest_ledger_version.into(),
        oldest_block_height: r.oldest_block_height.into(),
        block_height: r.block_height.into(),
        cursor: None,
    });
    
    // Validate consistency between header state and body state
    let inner = response.inner();
    let state = response.state();
    
    if inner.chain_id != state.chain_id {
        return Err(anyhow::anyhow!(
            "Inconsistent chain_id: header={}, body={}", 
            state.chain_id, inner.chain_id
        ).into());
    }
    if inner.epoch != state.epoch {
        return Err(anyhow::anyhow!(
            "Inconsistent epoch: header={}, body={}", 
            state.epoch, inner.epoch
        ).into());
    }
    if inner.version != state.version {
        return Err(anyhow::anyhow!(
            "Inconsistent version: header={}, body={}", 
            state.version, inner.version
        ).into());
    }
    if inner.block_height != state.block_height {
        return Err(anyhow::anyhow!(
            "Inconsistent block_height: header={}, body={}", 
            state.block_height, inner.block_height
        ).into());
    }

    Ok(response)
}
```

This allows callers to handle the error gracefully instead of crashing, and provides clear error messages for debugging.

## Proof of Concept

```rust
use aptos_rest_client::Client;
use httpmock::prelude::*;
use std::str::FromStr;
use url::Url;

#[tokio::test]
async fn test_inconsistent_ledger_response_panic() {
    // Start mock server
    let server = MockServer::start();
    
    // Mock response with inconsistent values
    server.mock(|when, then| {
        when.method(GET).path("/");
        then.status(200)
            .header("Content-Type", "application/x-bcs")
            .header("X-Aptos-Chain-Id", "1")
            .header("X-Aptos-Ledger-Version", "1000")  // Header says 1000
            .header("X-Aptos-Ledger-Timestamp", "1234567890")
            .header("X-Aptos-Epoch", "5")
            .header("X-Aptos-Ledger-Oldest-Version", "0")
            .header("X-Aptos-Block-Height", "100")
            .header("X-Aptos-Oldest-Block-Height", "0")
            .body({
                // BCS-encode IndexResponseBcs with ledger_version=2000
                let response = IndexResponseBcs {
                    chain_id: 1,
                    epoch: U64::from(5),
                    ledger_version: U64::from(2000),  // Body says 2000 - MISMATCH!
                    oldest_ledger_version: U64::from(0),
                    ledger_timestamp: U64::from(1234567890),
                    node_role: RoleType::FullNode,
                    oldest_block_height: U64::from(0),
                    block_height: U64::from(100),
                };
                bcs::to_bytes(&response).unwrap()
            });
    });
    
    let client = Client::new(Url::from_str(&server.base_url()).unwrap());
    
    // This will panic due to assertion failure:
    // assert_eq!(2000, 1000) fails
    let result = client.get_ledger_information().await;
    
    // In current implementation, this line is never reached because of panic
    // With the fix, result would be Err(...) instead
    assert!(result.is_err());
}
```

The test demonstrates that when a fullnode sends a ledger version of 1000 in the header but 2000 in the BCS body, the current implementation panics. With the recommended fix, it would return an error instead.

## Notes

While the security question specifically asks about `into_inner().version`, the actual vulnerability occurs in the `get_ledger_information()` function that produces the `Response<State>` object, not in the `into_inner()` or `.version` access themselves. However, this is the root cause of why `resolve_network_version()` can panic when processing malicious fullnode responses, making it directly relevant to the security question about safe response handling.

### Citations

**File:** third_party/move/tools/move-package-resolver/src/lock.rs (L96-97)
```rust
                let client = aptos_rest_client::Client::new(fullnode_url.clone());
                let version = client.get_ledger_information().await?.into_inner().version;
```

**File:** crates/aptos-rest-client/src/lib.rs (L408-411)
```rust
        assert_eq!(response.inner().chain_id, response.state().chain_id);
        assert_eq!(response.inner().epoch, response.state().epoch);
        assert_eq!(response.inner().version, response.state().version);
        assert_eq!(response.inner().block_height, response.state().block_height);
```

**File:** third_party/move/tools/move-package-resolver/src/resolver.rs (L193-193)
```rust
            let network_version = package_lock.resolve_network_version(fullnode_url).await?;
```

**File:** crates/aptos/src/common/utils.rs (L314-318)
```rust
    let state = rest_client
        .get_ledger_information()
        .await
        .map_err(|err| CliError::ApiError(err.to_string()))?
        .into_inner();
```

**File:** crates/aptos-rosetta/src/lib.rs (L126-134)
```rust
        assert_eq!(
            chain_id.id(),
            client
                .get_ledger_information()
                .await
                .expect("Should successfully get ledger information from Rest API on bootstap")
                .into_inner()
                .chain_id,
            "Failed to match Rosetta chain Id to upstream server"
```
