# Audit Report

## Title
Integer Sign Conversion Vulnerability in Rosetta API Transfer Validation Allows Incorrect Balance Updates

## Summary
The Rosetta API's `Transfer::extract_transfer` function contains a critical validation flaw where negative deposit amounts and positive withdraw amounts are not rejected, allowing integer sign conversion to cause wrap-around when casting from `i128` to `u64`. This can result in transactions being constructed with drastically incorrect transfer amounts (e.g., -100 becoming 18446744073709551516), leading to unintended balance updates on-chain. [1](#0-0) 

## Finding Description
The vulnerability exists in the Rosetta API transaction construction flow. The `CoinWithdraw` event amount is defined as `u64`, but during Rosetta API processing, amounts undergo sign conversions that lack proper validation. [2](#0-1) 

The critical flaw occurs in these steps:

1. **Parsing**: Withdraw and deposit amounts are parsed from user-provided strings directly into `i128` without validating their signs.

2. **Insufficient Validation**: The check at line 2905 validates that `-withdraw_value == deposit_value`, but does NOT validate that:
   - `withdraw_value` is negative (≤ 0)
   - `deposit_value` is positive (≥ 0)

3. **Missing Range Check**: Line 2913 only checks if `deposit_value > u64::MAX`, but does NOT check if `deposit_value` is negative.

4. **Unsafe Cast**: Line 2919 performs `deposit_value as u64` without validating that `deposit_value ≥ 0`.

**Attack Scenario:**
An attacker crafts malicious Rosetta API operations:
- `withdraw_amount.value = "100"` (positive, violating semantics)
- `deposit_amount.value = "-100"` (negative, violating semantics)

This passes all validation checks:
- Line 2905: `-(100) = -100 == -100` ✓ (passes)
- Line 2913: `-100 > u64::MAX` is false ✓ (passes, no error thrown)
- Line 2919: `(-100i128) as u64 = 18446744073709551516` (wraps due to two's complement)

The resulting `Transfer` object contains `amount = 18446744073709551516` instead of the intended `100`, violating the invariant that transfer amounts must match the user's intent. [3](#0-2) 

The properly constructed withdraw operation (shown above) formats amounts as negative strings, but the parsing logic doesn't enforce this convention, allowing malformed inputs to bypass validation.

## Impact Explanation
**Severity: High** (up to $50,000 per Aptos Bug Bounty)

This vulnerability can lead to:

1. **Fund Loss**: Services using the Rosetta API for transaction construction could create transactions that transfer massively incorrect amounts, draining user accounts if they have sufficient balance.

2. **State Inconsistency**: Balance updates would occur with amounts vastly different from what was requested, violating transaction validation invariants.

3. **API Service Compromise**: Attackers could exploit automated systems (exchanges, wallets) that rely on the Rosetta API, causing them to construct malicious transactions.

The impact qualifies as High severity because:
- It causes significant protocol violations (incorrect balance updates)
- It can lead to limited fund loss (dependent on victim balance and signature)
- It affects transaction validation guarantees

While not Critical severity, this is not merely an "API crash" - it actively enables construction of financially dangerous transactions.

## Likelihood Explanation
**Likelihood: Medium-High**

Exploitation requirements:
1. Attacker can influence operations sent to Rosetta API (e.g., compromised service, malicious frontend)
2. Victim signs the resulting transaction without careful verification
3. Victim has sufficient balance for the wrapped amount

Likelihood is elevated because:
- Rosetta API is widely used by exchanges and custodial services
- Automated transaction construction may not include secondary validation
- Users typically trust amounts shown in UIs, not raw transaction data
- The bug is in production code with no visible safeguards

## Recommendation
Add explicit sign validation before the conversion:

```rust
// After line 2902, add:
// Validate that withdraw amount is negative or zero
if withdraw_value > 0 {
    return Err(ApiError::InvalidTransferOperations(Some(
        "Withdraw amount must be negative or zero",
    )));
}

// Validate that deposit amount is positive
if deposit_value <= 0 {
    return Err(ApiError::InvalidTransferOperations(Some(
        "Deposit amount must be positive",
    )));
}

// Additional safety: validate deposit_value is within u64 range
if deposit_value < 0 || deposit_value > u64::MAX as i128 {
    return Err(ApiError::InvalidTransferOperations(Some(
        "Transfer amount must be between 0 and u64::MAX",
    )));
}
```

This ensures the semantic meaning of withdraw (negative) and deposit (positive) operations is enforced before any conversions occur.

## Proof of Concept
```rust
#[test]
fn test_sign_conversion_vulnerability() {
    // Malicious operations with reversed signs
    let operations = vec![
        Operation {
            operation_identifier: OperationIdentifier { index: 0 },
            operation_type: "withdraw".to_string(),
            status: Some("success".to_string()),
            account: Some(AccountIdentifier::base_account(
                AccountAddress::from_hex_literal("0xA").unwrap()
            )),
            amount: Some(Amount {
                value: "100".to_string(),  // POSITIVE withdraw (invalid!)
                currency: native_coin(),
            }),
            metadata: None,
        },
        Operation {
            operation_identifier: OperationIdentifier { index: 1 },
            operation_type: "deposit".to_string(),
            status: Some("success".to_string()),
            account: Some(AccountIdentifier::base_account(
                AccountAddress::from_hex_literal("0xB").unwrap()
            )),
            amount: Some(Amount {
                value: "-100".to_string(),  // NEGATIVE deposit (invalid!)
                currency: native_coin(),
            }),
            metadata: None,
        },
    ];

    let server_context = /* initialize context */;
    
    // This should fail but currently passes validation
    let transfer = Transfer::extract_transfer(&server_context, &operations).unwrap();
    
    // The amount is now 18446744073709551516 instead of 100!
    assert_eq!(transfer.amount.0, 18446744073709551516u64);
    // Expected: should have failed with "Deposit amount must be positive"
}
```

**Notes**

This vulnerability stems from insufficient validation of semantic constraints (withdraw = negative, deposit = positive) during Rosetta API transaction parsing. While overflow-checks are enabled in release mode (preventing direct integer overflow panics), the sign validation gap allows semantically incorrect operations to pass validation, leading to catastrophic wrap-around during the final `i128` to `u64` cast. The issue specifically relates to how the `CoinWithdraw` event's `amount` field (u64) is processed through external API layers that perform sign conversions without proper safeguards.

### Citations

**File:** types/src/account_config/events/coin_withdraw.rs (L16-20)
```rust
pub struct CoinWithdraw {
    pub coin_type: String,
    pub account: AccountAddress,
    pub amount: u64,
}
```

**File:** crates/aptos-rosetta/src/types/objects.rs (L324-342)
```rust
    pub fn withdraw(
        operation_index: u64,
        status: Option<OperationStatusType>,
        account: AccountIdentifier,
        currency: Currency,
        amount: u64,
    ) -> Operation {
        Operation::new(
            OperationType::Withdraw,
            operation_index,
            status,
            account,
            Some(Amount {
                value: format!("-{}", amount),
                currency,
            }),
            None,
        )
    }
```

**File:** crates/aptos-rosetta/src/types/objects.rs (L2899-2919)
```rust
        let withdraw_value = i128::from_str(&withdraw_amount.value)
            .map_err(|_| ApiError::InvalidTransferOperations(Some("Withdraw amount is invalid")))?;
        let deposit_value = i128::from_str(&deposit_amount.value)
            .map_err(|_| ApiError::InvalidTransferOperations(Some("Deposit amount is invalid")))?;

        // We can't create or destroy coins, they must be negatives of each other
        if -withdraw_value != deposit_value {
            return Err(ApiError::InvalidTransferOperations(Some(
                "Withdraw amount must be equal to negative of deposit amount",
            )));
        }

        // We converted to u128 to ensure no loss of precision in comparison,
        // but now we actually have to check it's a u64
        if deposit_value > u64::MAX as i128 {
            return Err(ApiError::InvalidTransferOperations(Some(
                "Transfer amount must not be greater than u64 max",
            )));
        }

        let transfer_amount = deposit_value as u64;
```
