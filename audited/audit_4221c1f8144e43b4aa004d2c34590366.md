# Audit Report

## Title
Network Private Keys Exposed in INFO-Level Logs via log_all_configs()

## Summary
The `log_all_configs()` function in `node_config.rs` serializes and logs the entire node configuration at INFO level without redacting sensitive cryptographic material. This results in x25519 network private keys being logged in plaintext (hex-encoded format), exposing them to anyone with access to node logs, log aggregation systems, or disk storage.

## Finding Description

The vulnerability exists in the configuration logging mechanism that executes at node startup. [1](#0-0) 

The function serializes the entire `NodeConfig` structure to JSON and logs each field separately. The `NodeConfig` contains `validator_network` and `full_node_networks` fields of type `NetworkConfig`. [2](#0-1) 

Each `NetworkConfig` contains an `identity` field that can hold cryptographic keys. [3](#0-2) 

The `Identity` enum supports multiple variants, including `Identity::FromConfig` which directly embeds the private key in the configuration. [4](#0-3) 

The `IdentityFromConfig` struct contains a `ConfigKey<x25519::PrivateKey>` which wraps the network private key. [5](#0-4) 

The `ConfigKey<T>` struct implements standard serde serialization without any redaction. [6](#0-5) 

The underlying `x25519::PrivateKey` uses the `SerializeKey` derive macro. [7](#0-6) 

When serialized in human-readable format (like JSON), the `SerializeKey` macro calls `to_encoded_string()`. [8](#0-7) 

This function converts the private key to hex format with "0x" prefix. [9](#0-8) 

The function is invoked at node startup in the main execution path. [10](#0-9) 

**Attack Path:**
1. Node operator starts an Aptos validator or fullnode with `Identity::FromConfig` containing a network private key
2. At startup, `log_all_configs()` is called and logs all configuration at INFO level
3. The network private key is serialized as `"0x{64-character-hex-string}"` in the logs
4. An attacker gains access to logs via:
   - Compromised log aggregation service (e.g., Splunk, ELK, CloudWatch)
   - Direct disk access to log files
   - Log file exposure through misconfigured permissions
   - Backup system compromise
5. Attacker extracts the x25519 private key from logs
6. Attacker can now impersonate the validator node in the network layer, performing man-in-the-middle attacks on consensus messages

## Impact Explanation

This vulnerability qualifies as **HIGH severity** under the Aptos Bug Bounty program criteria for the following reasons:

**Significant Protocol Violations:**
- Violates the **Cryptographic Correctness** invariant by exposing cryptographic secrets that must remain confidential
- The x25519 private key is used for Noise protocol authentication in the network layer, which is critical for secure validator-to-validator communication
- Compromise of this key allows network-level impersonation attacks

**Validator Node Compromise:**
- An attacker with the network private key can impersonate a validator node's network identity
- This enables man-in-the-middle attacks on consensus messages between validators
- Could lead to consensus disruption or observation of private consensus communications
- Affects the security of the mutual authentication mechanism in validator networks

**Potential for Consensus Impact:**
- While not a direct consensus safety violation, compromised network keys undermine the trust assumptions of the P2P network layer
- Could enable sophisticated attacks during consensus message propagation
- May allow adversaries to interfere with block propagation or voting message delivery

The vulnerability does not directly lead to fund theft or consensus safety breaks, but it significantly weakens the security posture of validator nodes by exposing critical network authentication credentials.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is **highly likely** to be exploited in production environments because:

1. **Automatic Occurrence:** The vulnerability triggers automatically on every node startup without any additional attacker action required. Simply starting a node with `Identity::FromConfig` exposes the keys.

2. **Common Configuration Pattern:** The `Identity::FromConfig` variant is commonly used in:
   - Development and testing environments
   - Simplified deployment configurations
   - Quick-start guides and documentation examples
   - Nodes where key management infrastructure is not available

3. **Widespread Log Access:** INFO-level logs are typically:
   - Sent to centralized log aggregation systems
   - Stored in plain text on disk
   - Included in diagnostic bundles shared with support teams
   - Backed up to long-term storage
   - Potentially accessible to multiple team members

4. **Realistic Attack Scenarios:**
   - **Log Service Compromise:** Third-party log aggregation services (Datadog, Splunk, CloudWatch) are common targets
   - **Insider Threat:** System administrators or support personnel with legitimate log access
   - **Backup Exposure:** Backups containing logs may have weaker access controls
   - **Misconfiguration:** Log directories with overly permissive file permissions
   - **Container Logs:** In containerized deployments, logs may be accessible through orchestration platforms

5. **No Warning or Mitigation:** There is no warning in the code, documentation, or logs that private keys are being exposed. Operators are unaware this is happening.

## Recommendation

Implement proper secret redaction in the logging mechanism. There are several approaches:

**Option 1: Redact at Serialization Level (Recommended)**

Add a custom `Serialize` implementation for sensitive config types that redacts secrets:

```rust
// In config/src/config/identity_config.rs
impl Serialize for IdentityFromConfig {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        use serde::ser::SerializeStruct;
        let mut state = serializer.serialize_struct("IdentityFromConfig", 2)?;
        state.serialize_field("key", "<REDACTED>")?;
        state.serialize_field("peer_id", &self.peer_id)?;
        state.end()
    }
}
```

**Option 2: Filter Before Logging**

Add a sanitization pass before logging:

```rust
// In config/src/config/node_config.rs
pub fn log_all_configs(&self) {
    let mut config_value = serde_json::to_value(self)
        .expect("Failed to serialize the node config!");
    
    // Redact sensitive fields
    self.redact_secrets(&mut config_value);
    
    let config_map = config_value.as_object()
        .expect("Failed to get the config map!");

    for (config_name, config_value) in config_map {
        let config_string = serde_json::to_string(config_value)
            .expect("Failed to parse the config value!");
        info!("Using {} config: {}", config_name, config_string);
    }
}

fn redact_secrets(&self, value: &mut serde_json::Value) {
    if let Some(obj) = value.as_object_mut() {
        // Redact validator_network identity
        if let Some(validator_net) = obj.get_mut("validator_network") {
            if let Some(identity) = validator_net.get_mut("identity") {
                if let Some(from_config) = identity.get_mut("from_config") {
                    from_config.as_object_mut().unwrap()
                        .insert("key".to_string(), json!("<REDACTED>"));
                }
            }
        }
        // Redact full_node_networks identities
        if let Some(full_node_nets) = obj.get_mut("full_node_networks").and_then(|v| v.as_array_mut()) {
            for net in full_node_nets {
                if let Some(identity) = net.get_mut("identity") {
                    if let Some(from_config) = identity.get_mut("from_config") {
                        from_config.as_object_mut().unwrap()
                            .insert("key".to_string(), json!("<REDACTED>"));
                    }
                }
            }
        }
    }
}
```

**Option 3: Use serde skip_serializing attribute**

Mark sensitive fields with `#[serde(skip_serializing)]` or use a custom serializer that always returns a redacted value.

**Additional Measures:**
1. Add documentation warnings about `Identity::FromConfig` security implications
2. Encourage use of `Identity::FromStorage` in production environments
3. Add a startup warning log when `Identity::FromConfig` is detected
4. Implement log scanning to detect accidentally exposed keys in existing logs

## Proof of Concept

```rust
// File: config/src/config/node_config_test.rs (add to existing test file)

#[cfg(test)]
mod secret_leakage_tests {
    use super::*;
    use aptos_crypto::{x25519, Uniform};
    use aptos_logger::{Level, Logger};
    use rand::{rngs::StdRng, SeedableRng};
    use std::sync::Arc;
    
    #[test]
    fn test_log_all_configs_exposes_private_keys() {
        // Initialize logger to capture INFO logs
        let logger = Logger::builder()
            .level(Level::Info)
            .build();
        
        // Create a test node config with a private key
        let mut rng = StdRng::from_seed([0u8; 32]);
        let private_key = x25519::PrivateKey::generate(&mut rng);
        let private_key_hex = hex::encode(private_key.to_bytes());
        
        let mut node_config = NodeConfig::default();
        
        // Set up validator network with Identity::FromConfig
        let peer_id = from_identity_public_key(private_key.public_key());
        node_config.validator_network = Some(NetworkConfig {
            identity: Identity::from_config(private_key.clone(), peer_id),
            network_id: NetworkId::Validator,
            ..NetworkConfig::default()
        });
        
        // Serialize config as log_all_configs does
        let config_value = serde_json::to_value(&node_config)
            .expect("Failed to serialize the node config!");
        let config_json = serde_json::to_string_pretty(&config_value).unwrap();
        
        // Verify that the private key appears in the serialized config
        // The key will be in format "0x{hex}"
        let expected_key_in_logs = format!("0x{}", private_key_hex);
        
        assert!(
            config_json.contains(&expected_key_in_logs),
            "VULNERABILITY CONFIRMED: Private key {} found in serialized config!\n\nConfig excerpt:\n{}",
            expected_key_in_logs,
            config_json
        );
        
        println!("ðŸš¨ SECURITY ISSUE: Network private key exposed in logs!");
        println!("   Key: {}", expected_key_in_logs);
        println!("   This key would be visible to anyone with access to INFO-level logs");
    }
    
    #[test]
    fn test_identity_from_storage_does_not_expose_key() {
        // Create config with Identity::FromStorage
        let mut node_config = NodeConfig::default();
        node_config.validator_network = Some(NetworkConfig {
            identity: Identity::from_storage(
                "validator_network_key".to_string(),
                "validator_peer_id".to_string(),
                SecureBackend::InMemoryStorage,
            ),
            network_id: NetworkId::Validator,
            ..NetworkConfig::default()
        });
        
        let config_value = serde_json::to_value(&node_config)
            .expect("Failed to serialize the node config!");
        let config_json = serde_json::to_string_pretty(&config_value).unwrap();
        
        // Verify no "0x" prefixed hex strings that look like keys
        let has_potential_key = config_json.lines()
            .any(|line| line.contains("\"0x") && line.len() > 70);
        
        assert!(
            !has_potential_key,
            "Identity::FromStorage configuration should not contain key material"
        );
        
        println!("âœ“ Identity::FromStorage does not expose keys in config");
    }
}
```

**Steps to reproduce:**
1. Add the above test to `config/src/config/node_config.rs` or create a new test file
2. Run: `cargo test test_log_all_configs_exposes_private_keys -- --nocapture`
3. Observe that the test confirms the private key appears in the serialized JSON
4. Start an actual node with a config using `Identity::FromConfig` and check INFO logs
5. Search logs for strings matching pattern `0x[0-9a-f]{64}` to find exposed keys

## Notes

While the `x25519::PrivateKey` uses `SilentDebug` and `SilentDisplay` derives to prevent accidental exposure through debug printing [7](#0-6) , these protections do **not** apply to JSON serialization used by `log_all_configs()`. The serialization path explicitly converts keys to hex strings via `to_encoded_string()`.

The issue is not present when using `Identity::FromStorage` or `Identity::FromFile` because those variants only store references (file paths or storage keys), not the actual private key material. However, `Identity::FromConfig` is commonly used in development, testing, and simplified deployments, making this a realistic attack vector.

This vulnerability also affects the `IdentityBlob` struct which contains multiple private keys (account, consensus, and network keys) and can be serialized. [11](#0-10)

### Citations

**File:** config/src/config/node_config.rs (L37-92)
```rust
pub struct NodeConfig {
    #[serde(default)]
    pub admin_service: AdminServiceConfig,
    #[serde(default)]
    pub api: ApiConfig,
    #[serde(default)]
    pub base: BaseConfig,
    #[serde(default)]
    pub consensus: ConsensusConfig,
    #[serde(default)]
    pub consensus_observer: ConsensusObserverConfig,
    #[serde(default)]
    pub dag_consensus: DagConsensusConfig,
    #[serde(default)]
    pub dkg: DKGConfig,
    #[serde(default)]
    pub execution: ExecutionConfig,
    #[serde(default)]
    pub failpoints: Option<HashMap<String, String>>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub full_node_networks: Vec<NetworkConfig>,
    #[serde(default)]
    pub indexer: IndexerConfig,
    #[serde(default)]
    pub indexer_grpc: IndexerGrpcConfig,
    #[serde(default)]
    pub indexer_table_info: IndexerTableInfoConfig,
    #[serde(default)]
    pub inspection_service: InspectionServiceConfig,
    #[serde(default)]
    pub jwk_consensus: JWKConsensusConfig,
    #[serde(default)]
    pub logger: LoggerConfig,
    #[serde(default)]
    pub mempool: MempoolConfig,
    #[serde(default)]
    pub netbench: Option<NetbenchConfig>,
    #[serde(default)]
    pub node_startup: NodeStartupConfig,
    #[serde(default)]
    pub peer_monitoring_service: PeerMonitoringServiceConfig,
    /// In a randomness stall, set this to be on-chain `RandomnessConfigSeqNum` + 1.
    /// Once enough nodes restarted with the new value, the chain should unblock with randomness disabled.
    #[serde(default)]
    pub randomness_override_seq_num: u64,
    #[serde(default)]
    pub state_sync: StateSyncConfig,
    #[serde(default)]
    pub storage: StorageConfig,
    #[serde(default)]
    pub transaction_filters: TransactionFiltersConfig,
    #[serde(default)]
    pub validator_network: Option<NetworkConfig>,
    #[serde(default)]
    pub indexer_db_config: InternalIndexerDBConfig,
}
```

**File:** config/src/config/node_config.rs (L97-111)
```rust
    pub fn log_all_configs(&self) {
        // Parse the node config as serde JSON
        let config_value =
            serde_json::to_value(self).expect("Failed to serialize the node config!");
        let config_map = config_value
            .as_object()
            .expect("Failed to get the config map!");

        // Log each config entry
        for (config_name, config_value) in config_map {
            let config_string =
                serde_json::to_string(config_value).expect("Failed to parse the config value!");
            info!("Using {} config: {}", config_name, config_string);
        }
    }
```

**File:** config/src/config/network_config.rs (L55-73)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct NetworkConfig {
    /// Maximum backoff delay for connecting outbound to peers
    pub max_connection_delay_ms: u64,
    /// Base for outbound connection backoff
    pub connection_backoff_base: u64,
    /// Rate to check connectivity to connected peers
    pub connectivity_check_interval_ms: u64,
    /// Size of all network channels
    pub network_channel_size: usize,
    /// Choose a protocol to discover and dial out to other peers on this network.
    /// `DiscoveryMethod::None` disables discovery and dialing out (unless you have
    /// seed peers configured).
    pub discovery_method: DiscoveryMethod,
    /// Same as `discovery_method` but allows for multiple
    pub discovery_methods: Vec<DiscoveryMethod>,
    /// Identity of this network
    pub identity: Identity,
```

**File:** config/src/config/identity_config.rs (L23-37)
```rust
/// A single struct for reading / writing to a file for identity across configs
#[derive(Deserialize, Serialize)]
pub struct IdentityBlob {
    /// Optional account address. Used for validators and validator full nodes
    #[serde(skip_serializing_if = "Option::is_none")]
    pub account_address: Option<AccountAddress>,
    /// Optional account key. Only used for validators
    #[serde(skip_serializing_if = "Option::is_none")]
    pub account_private_key: Option<Ed25519PrivateKey>,
    /// Optional consensus key. Only used for validators
    #[serde(skip_serializing_if = "Option::is_none")]
    pub consensus_private_key: Option<bls12381::PrivateKey>,
    /// Network private key. Peer id is derived from this if account address is not present
    pub network_private_key: x25519::PrivateKey,
}
```

**File:** config/src/config/identity_config.rs (L65-91)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
#[serde(rename_all = "snake_case", tag = "type")]
pub enum Identity {
    FromConfig(IdentityFromConfig),
    FromStorage(IdentityFromStorage),
    FromFile(IdentityFromFile),
    None,
}

impl Identity {
    pub fn from_config(key: x25519::PrivateKey, peer_id: PeerId) -> Self {
        let key = ConfigKey::new(key);
        Identity::FromConfig(IdentityFromConfig {
            key,
            peer_id,
            source: IdentitySource::UserProvided,
        })
    }

    pub fn from_config_auto_generated(key: x25519::PrivateKey, peer_id: PeerId) -> Self {
        let key = ConfigKey::new(key);
        Identity::FromConfig(IdentityFromConfig {
            key,
            peer_id,
            source: IdentitySource::AutoGenerated,
        })
    }
```

**File:** config/src/config/identity_config.rs (L129-139)
```rust
/// The identity is stored within the config.
#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
#[serde(deny_unknown_fields)]
pub struct IdentityFromConfig {
    #[serde(flatten)]
    pub key: ConfigKey<x25519::PrivateKey>,
    pub peer_id: PeerId,

    #[serde(skip)]
    pub source: IdentitySource,
}
```

**File:** config/src/keys.rs (L25-29)
```rust
#[derive(Debug, Deserialize, Serialize)]
pub struct ConfigKey<T: PrivateKey + Serialize> {
    #[serde(bound(deserialize = "T: Deserialize<'de>"))]
    key: T,
}
```

**File:** crates/aptos-crypto/src/x25519.rs (L66-68)
```rust
#[derive(DeserializeKey, SilentDisplay, SilentDebug, SerializeKey)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Clone))]
pub struct PrivateKey(x25519_dalek::StaticSecret);
```

**File:** crates/aptos-crypto-derive/src/lib.rs (L185-211)
```rust
#[proc_macro_derive(SerializeKey)]
pub fn serialize_key(source: TokenStream) -> TokenStream {
    let ast: DeriveInput = syn::parse(source).expect("Incorrect macro input");
    let name = &ast.ident;
    let name_string = find_key_name(&ast, name.to_string());
    quote! {
        impl ::serde::Serialize for #name {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: ::serde::Serializer,
            {
                if serializer.is_human_readable() {
                    self.to_encoded_string()
                        .map_err(<S::Error as ::serde::ser::Error>::custom)
                        .and_then(|str| serializer.serialize_str(&str[..]))
                } else {
                    // See comment in deserialize_key.
                    serializer.serialize_newtype_struct(
                        #name_string,
                        serde_bytes::Bytes::new(&ValidCryptoMaterial::to_bytes(self).as_slice()),
                    )
                }
            }
        }
    }
    .into()
}
```

**File:** crates/aptos-crypto/src/traits/mod.rs (L101-104)
```rust
    /// A function to encode into hex-string after serializing.
    fn to_encoded_string(&self) -> Result<String> {
        Ok(format!("0x{}", ::hex::encode(self.to_bytes())))
    }
```

**File:** aptos-node/src/lib.rs (L690-698)
```rust
pub fn setup_environment_and_start_node(
    mut node_config: NodeConfig,
    remote_log_rx: Option<mpsc::Receiver<TelemetryLog>>,
    logger_filter_update_job: Option<LoggerFilterUpdater>,
    api_port_tx: Option<oneshot::Sender<u16>>,
    indexer_grpc_port_tx: Option<oneshot::Sender<u16>>,
) -> anyhow::Result<AptosHandle> {
    // Log the node config at node startup
    node_config.log_all_configs();
```
