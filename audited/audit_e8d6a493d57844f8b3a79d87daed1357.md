# Audit Report

## Title
Incorrect Balance Reporting in Rosetta API: Pending Inactive Stake Includes Operator Commission

## Summary
The Rosetta API's `get_stake_balances()` function returns the total `pending_inactive` stake amount without separating the staker's portion from the operator's commission. This causes users querying their `pending_inactive_stake` balance to receive inflated values that include the operator's unlocked commission, violating the invariant that balance queries must return accurate per-recipient amounts.

## Finding Description

The vulnerability exists in the balance reporting logic for staking contracts in the Rosetta API. When stake is unlocked in a staking contract, the system follows this flow: [1](#0-0) 

The `request_commission_internal` function extracts operator commission from active stake and unlocks it to `pending_inactive`. Similarly, when stakers unlock their stake: [2](#0-1) 

Both operator commission and staker withdrawals are tracked separately using the staking contract's internal distribution pool mechanism. However, they both reside in the same `stake_pool.pending_inactive` field on the underlying StakePool resource.

The critical issue occurs in the Rosetta API implementation: [3](#0-2) 

When a user queries their `pending_inactive_stake` balance, the API returns `stake_pool.pending_inactive` directly, which is the TOTAL pending_inactive amount including both the staker's unlocked stake AND the operator's unlocked commission. The API does not consult the staking contract's distribution pool to determine the staker's actual share.

This is confirmed by the fact that `staking_contract_amounts` explicitly excludes `pending_inactive` from its calculations: [4](#0-3) 

The distribution pool tracks shares for each recipient, but there is no public view function to query these shares, leaving the Rosetta API unable to properly separate staker and operator portions.

Additionally, `pending_inactive` stake continues earning rewards during the lockup period: [5](#0-4) 

These rewards increase the `pending_inactive` amount further, compounding the reporting error.

## Impact Explanation

This vulnerability qualifies as **High Severity** based on the Aptos bug bounty criteria for "Significant protocol violations" because:

1. **Systematic Balance Misreporting**: The Rosetta API is the primary interface used by exchanges, wallets, and block explorers to query Aptos blockchain data. Incorrect balance reporting affects the entire ecosystem of tools relying on this API.

2. **User Trust Impact**: Users querying their pending inactive stake see inflated balances that include operator commission they don't own. This can lead to:
   - Failed withdrawal attempts when users try to withdraw based on incorrect balances
   - Accounting discrepancies at exchanges
   - Loss of user trust when reported balances don't match actual withdrawable amounts

3. **Developer Acknowledgment**: The TODO comment at line 342 indicates developers are aware of potential calculation issues, suggesting this is a known problem area requiring fixes. [6](#0-5) 

4. **Incomplete Commission Reporting**: The converse issue also exists - when querying `is_commission()`, the API only returns commission from active stake, missing commission that has already been unlocked to pending_inactive. [7](#0-6) 

## Likelihood Explanation

This vulnerability occurs with **100% probability** for any staking contract where:
1. The operator has requested commission (moving it to `pending_inactive`)
2. The staker has unlocked stake (also moving it to `pending_inactive`)
3. Either party queries their balance via the Rosetta API

Given that commission requests and stake unlocking are normal operations in staking contracts, this affects a significant portion of staking contract users. The vulnerability is not exploitable for fund theft, but it causes systematic incorrect reporting for legitimate balance queries.

## Recommendation

The root issue is that the staking contract module provides no view function to query distribution pool shares. The fix requires two changes:

1. **Add a view function to staking_contract.move** to query distribution pool balances:

```move
#[view]
public fun get_distribution_balance(
    staker: address, 
    operator: address, 
    recipient: address
): u64 acquires Store {
    assert_staking_contract_exists(staker, operator);
    let staking_contracts = &borrow_global<Store>(staker).staking_contracts;
    let staking_contract = simple_map::borrow(staking_contracts, &operator);
    let distribution_pool = &staking_contract.distribution_pool;
    
    // Get current pending_inactive from stake pool
    let (_, _, _, pending_inactive) = stake::get_stake(staking_contract.pool_address);
    
    // Return recipient's share of the distribution pool
    pool_u64::balance(distribution_pool, recipient)
}
```

2. **Update the Rosetta API** to call this new view function instead of reading `stake_pool.pending_inactive` directly:

```rust
} else if owner_account.is_pending_inactive_stake() {
    // Query the staker's actual share from the distribution pool
    let distribution_balance = view::<u64>(
        rest_client,
        version,
        AccountAddress::ONE,
        ident_str!(STAKING_CONTRACT_MODULE),
        ident_str!("get_distribution_balance"),
        vec![],
        vec![
            bcs::to_bytes(&owner_address)?,
            bcs::to_bytes(&operator_address)?,
            bcs::to_bytes(&owner_address)?, // recipient is the staker
        ],
    ).await?;
    requested_balance = Some(distribution_balance.to_string());
}
```

Similarly, update the commission query to include pending_inactive commission.

## Proof of Concept

To demonstrate this issue, create a Move test that:

1. Creates a staking contract with 10% commission
2. Adds 1000 coins of stake  
3. Allows it to earn 200 coins in rewards (total: 1200)
4. Operator requests commission: 10% of 200 = 20 coins unlocked to pending_inactive
5. Staker unlocks 500 coins to pending_inactive
6. Now `pending_inactive` = 520 coins (20 operator + 500 staker)
7. Query via Rosetta API for staker's `pending_inactive_stake`: returns 520 (incorrect, should be 500)
8. Query via Rosetta API for `commission`: returns 0 (incorrect, should be 20)

The on-chain distribution pool correctly tracks that operator owns 20 and staker owns 500, but the Rosetta API cannot access this information and returns the combined total for the staker's balance query.

## Notes

While this vulnerability does not enable direct fund theft (the on-chain distribution pool enforcement prevents unauthorized withdrawals), it represents a critical failure in the API layer that exchanges and wallets rely upon for accurate balance information. The systematic nature of the misreporting across all affected staking contracts elevates this to High severity as a significant protocol violation in the external interface layer.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/staking_contract.move (L674-726)
```text
    fun request_commission_internal(
        operator: address,
        staking_contract: &mut StakingContract,
        add_distribution_events: &mut EventHandle<AddDistributionEvent>,
        request_commission_events: &mut EventHandle<RequestCommissionEvent>
    ): u64 {
        // Unlock just the commission portion from the stake pool.
        let (total_active_stake, accumulated_rewards, commission_amount) =
            get_staking_contract_amounts_internal(staking_contract);
        staking_contract.principal = total_active_stake - commission_amount;

        // Short-circuit if there's no commission to pay.
        if (commission_amount == 0) {
            return 0
        };

        // Add a distribution for the operator.
        add_distribution(
            operator,
            staking_contract,
            operator,
            commission_amount,
            add_distribution_events
        );

        // Request to unlock the commission from the stake pool.
        // This won't become fully unlocked until the stake pool's lockup expires.
        stake::unlock_with_cap(commission_amount, &staking_contract.owner_cap);

        let pool_address = staking_contract.pool_address;
        if (std::features::module_event_migration_enabled()) {
            emit(
                RequestCommission {
                    operator,
                    pool_address,
                    accumulated_rewards,
                    commission_amount
                }
            );
        } else {
            emit_event(
                request_commission_events,
                RequestCommissionEvent {
                    operator,
                    pool_address,
                    accumulated_rewards,
                    commission_amount
                }
            );
        };

        commission_amount
    }
```

**File:** aptos-move/framework/aptos-framework/sources/staking_contract.move (L730-793)
```text
    public entry fun unlock_stake(
        staker: &signer, operator: address, amount: u64
    ) acquires Store, BeneficiaryForOperator {
        // Short-circuit if amount is 0.
        if (amount == 0) return;

        let staker_address = signer::address_of(staker);
        assert_staking_contract_exists(staker_address, operator);

        let store = borrow_global_mut<Store>(staker_address);
        let staking_contract =
            simple_map::borrow_mut(&mut store.staking_contracts, &operator);

        // Force distribution of any already inactive stake.
        distribute_internal(
            staker_address,
            operator,
            staking_contract,
            &mut store.distribute_events
        );

        // For simplicity, we request commission to be paid out first. This avoids having to ensure to staker doesn't
        // withdraw into the commission portion.
        let commission_paid =
            request_commission_internal(
                operator,
                staking_contract,
                &mut store.add_distribution_events,
                &mut store.request_commission_events
            );

        // If there's less active stake remaining than the amount requested (potentially due to commission),
        // only withdraw up to the active amount.
        let (active, _, _, _) = stake::get_stake(staking_contract.pool_address);
        if (active < amount) {
            amount = active;
        };
        staking_contract.principal = staking_contract.principal - amount;

        // Record a distribution for the staker.
        add_distribution(
            operator,
            staking_contract,
            staker_address,
            amount,
            &mut store.add_distribution_events
        );

        // Request to unlock the distribution amount from the stake pool.
        // This won't become fully unlocked until the stake pool's lockup expires.
        stake::unlock_with_cap(amount, &staking_contract.owner_cap);

        let pool_address = staking_contract.pool_address;
        if (std::features::module_event_migration_enabled()) {
            emit(
                UnlockStake { pool_address, operator, amount, commission_paid }
            );
        } else {
            emit_event(
                &mut store.unlock_stake_events,
                UnlockStakeEvent { pool_address, operator, amount, commission_paid }
            );
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/staking_contract.move (L1056-1072)
```text
    /// Calculate accumulated rewards and commissions since last update.
    fun get_staking_contract_amounts_internal(
        staking_contract: &StakingContract
    ): (u64, u64, u64) {
        // Pending_inactive is not included in the calculation because pending_inactive can only come from:
        // 1. Outgoing commissions. This means commission has already been extracted.
        // 2. Stake withdrawals from stakers. This also means commission has already been extracted as
        // request_commission_internal is called in unlock_stake
        let (active, _, pending_active, _) =
            stake::get_stake(staking_contract.pool_address);
        let total_active_stake = active + pending_active;
        let accumulated_rewards = total_active_stake - staking_contract.principal;
        let commission_amount =
            accumulated_rewards * staking_contract.commission_percentage / 100;

        (total_active_stake, accumulated_rewards, commission_amount)
    }
```

**File:** crates/aptos-rosetta/src/types/misc.rs (L342-344)
```rust
        // TODO: I think all of these are off, probably need to recalculate all of them
        // see the get_staking_contract_amounts_internal function in staking_contract.move for more
        // information on why commission is only subtracted from active and total stake
```

**File:** crates/aptos-rosetta/src/types/misc.rs (L354-356)
```rust
        } else if owner_account.is_pending_inactive_stake() {
            // pending_inactive will not have commission because commission has already been extracted
            requested_balance = Some(stake_pool.pending_inactive.to_string());
```

**File:** crates/aptos-rosetta/src/types/misc.rs (L361-362)
```rust
        } else if owner_account.is_commission() {
            requested_balance = Some(commission_amount.to_string());
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1700-1706)
```text
        let rewards_pending_inactive = distribute_rewards(
            &mut stake_pool.pending_inactive,
            num_successful_proposals,
            num_total_proposals,
            rewards_rate,
            rewards_rate_denominator
        );
```
