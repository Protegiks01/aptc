# Audit Report

## Title
Byzantine Peers Can Manipulate Peer Monitoring Metrics to Influence Peer Selection in State Sync, Consensus Observer, and Mempool

## Summary
Byzantine peers can manipulate `distance_from_validators` and `average_ping_latency_secs` measurements in the peer monitoring system to gain preferential selection for state sync requests, consensus observer subscriptions, and mempool transaction forwarding. While sanity checks prevent the most egregious claims (distance=0 or 1 without proper validator/VFN credentials), Byzantine peers can still claim artificially low distances (>1) and game latency measurements by prioritizing ping responses over actual data requests. This leads to temporary performance degradation as honest nodes waste resources on Byzantine peers before the peer scoring system eventually penalizes them.

## Finding Description

The peer monitoring system collects two critical metrics used for peer selection across multiple subsystems:

1. **`distance_from_validators`**: The claimed hop distance from the validator set
2. **`average_ping_latency_secs`**: The measured round-trip latency for ping requests

**Distance Manipulation Vulnerability:**

When a node receives a `NetworkInformationResponse` from a peer, sanity checks are performed: [1](#0-0) 

These checks verify that:
- If distance=0, the peer must be a validator
- If distance=1, the peer must be a VFN
- Otherwise, distance must be ≤ MAX_DISTANCE_FROM_VALIDATORS (100)

**However, there's a critical gap**: A Byzantine peer at actual distance=10 from validators can claim distance=2 or 3, and this will pass validation since the checks only enforce role requirements for distances 0 and 1.

When the node calculates its own distance, it trusts peer-reported distances: [2](#0-1) 

The node's distance becomes `min(peer_distances) + 1`, allowing Byzantine peers to propagate false distance claims throughout the network.

**Latency Gaming Vulnerability:**

The latency measurement uses round-trip time for `LatencyPing` requests: [3](#0-2) 

A Byzantine peer can prioritize `LatencyPing` responses (responding instantly) while deliberately delaying actual data requests. The server trivially echoes the ping counter, so a Byzantine server can implement fast-path handling for pings while slow-pathing data requests, making the latency metric unreliable as a predictor of actual data transfer performance.

**Impact on Peer Selection:**

These manipulated metrics directly influence peer selection in three critical subsystems:

1. **State Sync**: Peers are selected by distance first, then latency [4](#0-3) 

2. **Consensus Observer**: Same distance-then-latency prioritization [5](#0-4) 

3. **Mempool**: Transaction forwarding prioritizes by distance, then latency [6](#0-5) 

**Attack Scenario:**

1. Byzantine peer at actual distance=8 claims distance=2 in `NetworkInformationResponse`
2. Sanity checks pass (distance=2 is valid for non-validator/VFN peers)
3. Byzantine peer responds instantly to `LatencyPing` but slowly to data requests
4. Honest nodes calculate their distance as 3 (min peer distance + 1)
5. Byzantine peer appears optimal (low distance + low latency)
6. Byzantine peer gets preferentially selected for state sync, consensus observation, and mempool forwarding
7. Byzantine peer delays actual responses, causing timeouts and retries
8. Eventually, peer scoring system penalizes the Byzantine peer (0.95x multiplier per timeout) [7](#0-6) 

9. After enough penalties, Byzantine peer is ignored (score < 25.0)

## Impact Explanation

This vulnerability qualifies as **High Severity** per Aptos bug bounty criteria ("Validator node slowdowns" - up to $50,000):

- **Performance Degradation**: Honest nodes waste time and resources querying Byzantine peers before timeouts trigger fallback to other peers
- **Amplification with Multiple Attackers**: Multiple colluding Byzantine peers all claiming low distance can significantly slow state sync, consensus observation, and transaction propagation
- **Cascading Distance Pollution**: False distance claims propagate through the network as nodes calculate their distance based on peer-reported values
- **Not Consensus-Breaking**: The vulnerability does NOT violate consensus safety as proof verification catches invalid data, and the system eventually recovers through peer scoring

The impact is bounded by:
- Sanity checks preventing distance=0/1 claims without proper credentials
- Peer scoring system eventually penalizing and ignoring bad actors
- Proof verification catching invalid data

However, the initial impact window before penalties accumulate can cause measurable performance degradation across the network.

## Likelihood Explanation

**Likelihood: High**

- **Low Attack Complexity**: Byzantine peer simply needs to return false distance values in `NetworkInformationResponse` and prioritize `LatencyPing` responses
- **No Special Access Required**: Any network peer can connect and send these responses
- **Current Validation Gap**: The sanity checks don't verify distance claims > 1 against actual network topology
- **Measurable Impact**: Before peer scoring kicks in, Byzantine peers will receive preferential selection
- **Amplification Possible**: Multiple Byzantine peers can coordinate to maximize impact

## Recommendation

**Short-term Mitigation:**

1. **Strengthen Distance Validation**: Add cross-validation of distance claims by tracking connected peers' distances and detecting inconsistencies
2. **Separate Latency Metrics**: Measure latency for actual data requests separately from `LatencyPing` to detect gaming
3. **Faster Penalty Accumulation**: Reduce timeout tolerance for peers claiming low distance/latency to more quickly identify misbehaving peers

**Long-term Fix:**

Implement cryptographic attestation for distance claims where peers provide proof of validator connectivity through signed validator statements. For distances > 1, peers should provide a chain of signatures proving their path to validators.

Example validation enhancement:

```rust
// In network_info.rs, add additional validation for distance > 1
fn validate_distance_with_topology(
    peer_network_id: &PeerNetworkId,
    distance: u64,
    connected_peers: &BTreeMap<PeerNetworkId, ConnectionMetadata>,
) -> bool {
    if distance > 1 {
        // Verify at least one connected peer has distance == (claimed_distance - 1)
        // This prevents peers from claiming arbitrarily low distances
        let has_valid_upstream = connected_peers.values().any(|metadata| {
            // Check if any connected peer could plausibly be upstream
            // Implementation requires tracking peer distances
            true // Placeholder
        });
        return has_valid_upstream;
    }
    true
}
```

Additionally, implement weighted latency tracking that considers both ping latency and actual data request latency, with higher weight on data request latency since that's what actually matters for performance.

## Proof of Concept

```rust
// Conceptual PoC demonstrating the vulnerability
// This would be integrated into peer-monitoring-service/server tests

#[test]
fn test_byzantine_distance_manipulation() {
    // Setup: Create a Byzantine peer at actual distance 8 from validators
    let byzantine_peer = create_test_peer(PeerRole::Unknown);
    let actual_distance = 8u64;
    
    // Attack: Byzantine peer claims distance = 2 in NetworkInformationResponse
    let falsified_distance = 2u64;
    let network_info_response = NetworkInformationResponse {
        connected_peers: Default::default(),
        distance_from_validators: falsified_distance,
    };
    
    // Victim: Honest node receives the response
    let mut network_info_state = NetworkInfoState::new(
        create_test_node_config(RoleType::FullNode),
        TimeService::mock()
    );
    
    // Process response with falsified distance
    network_info_state.handle_monitoring_service_response(
        &byzantine_peer,
        create_test_peer_metadata(PeerRole::Unknown),
        PeerMonitoringServiceRequest::GetNetworkInformation,
        PeerMonitoringServiceResponse::NetworkInformation(network_info_response),
        0.0,
    );
    
    // Verify: The falsified distance passes validation (distance=2 is valid for Unknown peers)
    let stored_response = network_info_state.get_latest_network_info_response();
    assert!(stored_response.is_some());
    assert_eq!(stored_response.unwrap().distance_from_validators, falsified_distance);
    
    // Impact: Honest node calculates its own distance as falsified_distance + 1 = 3
    // when actual distance should be actual_distance + 1 = 9
    // This causes the honest node to believe it's much closer to validators than reality
}

#[test]
fn test_latency_gaming() {
    // Setup: Byzantine peer responds quickly to pings but slowly to data
    let byzantine_peer = create_test_peer(PeerRole::Unknown);
    
    // Attack: Byzantine peer responds to LatencyPing in 10ms
    let ping_latency = 0.010; // 10ms
    record_latency_ping(&mut latency_state, ping_latency);
    
    // Victim perceives low latency
    assert!(latency_state.get_average_latency_ping_secs().unwrap() < 0.050);
    
    // Reality: Byzantine peer takes 5000ms for actual data requests
    // This is detected only through timeouts and peer scoring penalties
    // By which time the node has already wasted time on the Byzantine peer
}
```

## Notes

- The vulnerability exists in the trust model of the peer monitoring system, which assumes peers report honest metrics
- The sanity checks provide partial protection but have a validation gap for distance values > 1
- The peer scoring system provides eventual mitigation but doesn't prevent initial exploitation
- This affects state sync, consensus observer, and mempool—three critical subsystems for node operation
- The issue does NOT compromise consensus safety or data integrity, as cryptographic proofs are still verified
- Multiple Byzantine peers can coordinate to amplify the performance impact before penalties accumulate

### Citations

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L118-141)
```rust
        let is_valid_depth = match network_info_response.distance_from_validators {
            0 => {
                // Verify the peer is a validator and has the correct network id
                let peer_is_validator = peer_metadata.get_connection_metadata().role.is_validator();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_validator_network(), // We're a validator
                    RoleType::FullNode => network_id.is_vfn_network(),        // We're a VFN
                };
                peer_is_validator && peer_has_correct_network
            },
            1 => {
                // Verify the peer is a VFN and has the correct network id
                let peer_is_vfn = peer_metadata.get_connection_metadata().role.is_vfn();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_vfn_network(), // We're a validator
                    RoleType::FullNode => network_id.is_public_network(), // We're a VFN or PFN
                };
                peer_is_vfn && peer_has_correct_network
            },
            distance_from_validators => {
                // The distance must be less than or equal to the max
                distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS
            },
        };
```

**File:** peer-monitoring-service/server/src/lib.rs (L283-293)
```rust
    fn handle_latency_ping(
        &self,
        latency_ping_request: &LatencyPingRequest,
    ) -> Result<PeerMonitoringServiceResponse, Error> {
        let latency_ping_response = LatencyPingResponse {
            ping_counter: latency_ping_request.ping_counter,
        };
        Ok(PeerMonitoringServiceResponse::LatencyPing(
            latency_ping_response,
        ))
    }
```

**File:** peer-monitoring-service/server/src/lib.rs (L322-333)
```rust
    let mut min_peer_distance_from_validators = MAX_DISTANCE_FROM_VALIDATORS;
    for peer_metadata in connected_peers_and_metadata.values() {
        if let Some(ref latest_network_info_response) = peer_metadata
            .get_peer_monitoring_metadata()
            .latest_network_info_response
        {
            min_peer_distance_from_validators = min(
                min_peer_distance_from_validators,
                latest_network_info_response.distance_from_validators,
            );
        }
    }
```

**File:** state-sync/aptos-data-client/src/utils.rs (L31-43)
```rust
    // Group peers and latency weights by validator distance, i.e., distance -> [(peer, latency weight)]
    let mut peers_and_latencies_by_distance = BTreeMap::new();
    for peer in peers {
        if let Some((distance, latency)) =
            get_distance_and_latency_for_peer(&peers_and_metadata, peer)
        {
            let latency_weight = convert_latency_to_weight(latency);
            peers_and_latencies_by_distance
                .entry(distance)
                .or_insert_with(Vec::new)
                .push((peer, latency_weight));
        }
    }
```

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L286-312)
```rust
    // Group peers and latencies by validator distance, i.e., distance -> [(peer, latency)]
    let mut unsupported_peers = Vec::new();
    let mut peers_and_latencies_by_distance = BTreeMap::new();
    for (peer_network_id, peer_metadata) in peers_and_metadata {
        // Verify that the peer supports consensus observer
        if !supports_consensus_observer(peer_metadata) {
            unsupported_peers.push(*peer_network_id);
            continue; // Skip the peer
        }

        // Get the distance and latency for the peer
        let distance = get_distance_for_peer(peer_network_id, peer_metadata);
        let latency = get_latency_for_peer(peer_network_id, peer_metadata);

        // If the distance is not found, use the maximum distance
        let distance =
            distance.unwrap_or(aptos_peer_monitoring_service_types::MAX_DISTANCE_FROM_VALIDATORS);

        // If the latency is not found, use a large latency
        let latency = latency.unwrap_or(MAX_PING_LATENCY_SECS);

        // Add the peer and latency to the distance group
        peers_and_latencies_by_distance
            .entry(distance)
            .or_insert_with(Vec::new)
            .push((*peer_network_id, OrderedFloat(latency)));
    }
```

**File:** mempool/src/shared_mempool/priority.rs (L103-115)
```rust
        // Otherwise, compare by peer distance from the validators.
        // This avoids badly configured/connected peers (e.g., broken VN-VFN connections).
        let distance_ordering =
            compare_validator_distance(monitoring_metadata_a, monitoring_metadata_b);
        if !distance_ordering.is_eq() {
            return distance_ordering; // Only return if it's not equal
        }

        // Otherwise, compare by peer ping latency (the lower the better)
        let latency_ordering = compare_ping_latency(monitoring_metadata_a, monitoring_metadata_b);
        if !latency_ordering.is_eq() {
            return latency_ordering; // Only return if it's not equal
        }
```

**File:** state-sync/aptos-data-client/src/peer_states.rs (L41-44)
```rust
const MALICIOUS_MULTIPLIER: f64 = 0.8;
/// Ignore a peer when their score dips below this threshold.
const IGNORE_PEER_THRESHOLD: f64 = 25.0;

```
