# Audit Report

## Title
Critical Panic in Secret Share Aggregation Due to Uninitialized Weights HashMap

## Summary
The `SecretShareAggregator::retain()` function and `add_share_with_metadata()` function contain `.expect()` calls that attempt to look up validator weights from a HashMap that is always empty. This causes guaranteed panics when secret shares from other validators arrive before a node processes its own self-share, leading to validator node crashes and consensus liveness failures.

## Finding Description

The vulnerability exists in the secret sharing subsystem used for randomness generation in Aptos consensus. The issue stems from an incomplete implementation where:

1. **Empty Weights HashMap**: The `SecretShareConfig` struct contains a `weights` field initialized as an empty HashMap that is never populated. [1](#0-0) 

2. **Inconsistent Weight Retrieval**: Two methods exist for retrieving weights:
   - `get_peer_weight()` returns a hardcoded value of `1` for any peer
   - `get_peer_weights()` returns the empty `weights` HashMap [2](#0-1) 

3. **Panic in add_share_with_metadata**: When adding the self share, the code attempts to look up the author's weight from the empty HashMap with an `.expect()` that will always panic if called. [3](#0-2) 

4. **Panic in retain()**: The `retain()` function recalculates total weight by looking up each existing share author's weight in the empty HashMap, which panics on any existing shares. [4](#0-3) 

**Attack Scenario:**

The panic occurs naturally due to network timing, without requiring any malicious action:

1. Validator A processes block B at round R, derives self-share, and broadcasts it
2. Validator B is slower and hasn't processed block B yet  
3. Validator B receives A's share via the network, which gets added via `add_share()` with weight=1 [5](#0-4) 

4. The share is stored in the `PendingMetadata` aggregator [6](#0-5) 

5. Validator B finally processes block B and calls `add_self_share()` [7](#0-6) 

6. `add_self_share()` retrieves the empty weights HashMap via `get_peer_weights()` [8](#0-7) 

7. Calls `add_share_with_metadata()` which attempts to get the self author's weight from the empty HashMap → **PANIC at line 164**

8. OR if line 164 somehow didn't execute, `retain()` is called at line 168, which attempts to recalculate weights for existing shares (like A's share) from the empty HashMap → **PANIC at line 79**

## Impact Explanation

**Severity: High** (up to $50,000 per Aptos Bug Bounty)

This vulnerability causes:

- **Validator Node Crashes**: Any validator that receives shares from faster peers before processing its own block will panic and crash
- **Consensus Liveness Degradation**: Multiple validators crashing simultaneously reduces the active validator set, potentially approaching the 2/3 threshold needed for liveness
- **Deterministic Failure**: The panic is guaranteed whenever the timing conditions are met, making it reproducible
- **Network-Wide Impact**: In a network with variable processing speeds, many validators could crash when processing the same round

This qualifies as **High Severity** under "Validator node slowdowns" and "Significant protocol violations" categories. While it doesn't directly cause consensus safety violations or permanent fund loss, it severely impacts network availability and validator operations.

## Likelihood Explanation

**Likelihood: High**

The vulnerability is highly likely to occur because:

1. **Normal Operation Trigger**: It requires only network timing differences, which are common in distributed systems
2. **No Malicious Action Required**: Any validator can inadvertently trigger this on other validators simply by being faster
3. **Guaranteed Crash**: Once the timing condition is met, the panic is deterministic
4. **Common Scenario**: In any heterogeneous network, validators will have different processing speeds due to hardware, network latency, or load variations

The only reason this might not have been observed in production is if:
- The secret sharing feature is not yet enabled in mainnet
- All validators process blocks at very similar speeds
- The code path is rarely exercised

## Recommendation

**Fix 1: Populate the weights HashMap properly**

Modify `SecretShareConfig` to populate weights from the `ValidatorVerifier`:

```rust
pub fn new(
    author: Author,
    epoch: u64,
    validator: Arc<ValidatorVerifier>,
    digest_key: DigestKey,
    msk_share: MasterSecretKeyShare,
    verification_keys: Vec<VerificationKey>,
    config: <FPTXWeighted as BatchThresholdEncryption>::ThresholdConfig,
    encryption_key: EncryptionKey,
) -> Self {
    // Populate weights from validator verifier
    let weights: HashMap<Author, u64> = validator
        .get_ordered_account_addresses_iter()
        .map(|addr| (*addr, 1u64)) // Use actual voting power if available
        .collect();
    
    Self {
        _author: author,
        _epoch: epoch,
        validator,
        digest_key,
        msk_share,
        verification_keys,
        config,
        encryption_key,
        weights,
    }
}
```

**Fix 2: Use get_peer_weight() consistently**

Alternatively, modify `retain()` to use the consistent `get_peer_weight()` method:

```rust
fn retain(&mut self, metadata: &SecretShareMetadata, config: &SecretShareConfig) {
    self.shares.retain(|_, share| share.metadata == *metadata);
    self.total_weight = self
        .shares
        .keys()
        .map(|author| config.get_peer_weight(author))
        .sum();
}
```

And update `add_share_with_metadata()` similarly:

```rust
let share_weight = share_weights.get(share.author())
    .copied()
    .unwrap_or_else(|| config.get_peer_weight(share.author()));
```

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_types::validator_verifier::ValidatorVerifier;
    use std::sync::Arc;
    
    #[test]
    #[should_panic(expected = "Author must exist for weight")]
    fn test_retain_panic_on_empty_weights() {
        // Setup
        let author1 = Author::random();
        let author2 = Author::random();
        
        // Create a SecretShareConfig with empty weights
        let validator = Arc::new(ValidatorVerifier::new(vec![]));
        let config = SecretShareConfig::new(
            author1,
            1,
            validator,
            DigestKey::default(),
            MasterSecretKeyShare::default(),
            vec![],
            ThresholdConfig::default(),
            EncryptionKey::default(),
        );
        
        // Create an aggregator and add a share
        let mut aggregator = SecretShareAggregator::new(author1);
        let share = SecretShare::new(
            author2,
            SecretShareMetadata::default(),
            SecretKeyShare::default(),
        );
        aggregator.add_share(share, 1);
        
        // This will panic because weights HashMap is empty
        let weights = config.get_peer_weights();
        aggregator.retain(&SecretShareMetadata::default(), weights);
        // PANIC occurs here
    }
}
```

**Notes:**
- This vulnerability affects consensus liveness by causing validator crashes during normal randomness generation operations
- The root cause is incomplete implementation where the weighted secret sharing infrastructure was partially built but weights are never populated
- Fix requires either populating the weights HashMap from the validator set or consistently using the `get_peer_weight()` method throughout
- The validator set change angle mentioned in the security question is somewhat of a red herring - the issue exists regardless of validator set changes because the weights HashMap is always empty

### Citations

**File:** types/src/secret_sharing.rs (L145-169)
```rust
    weights: HashMap<Author, u64>,
}

impl SecretShareConfig {
    pub fn new(
        author: Author,
        epoch: u64,
        validator: Arc<ValidatorVerifier>,
        digest_key: DigestKey,
        msk_share: MasterSecretKeyShare,
        verification_keys: Vec<VerificationKey>,
        config: <FPTXWeighted as BatchThresholdEncryption>::ThresholdConfig,
        encryption_key: EncryptionKey,
    ) -> Self {
        Self {
            _author: author,
            _epoch: epoch,
            validator,
            digest_key,
            msk_share,
            verification_keys,
            config,
            encryption_key,
            weights: HashMap::new(),
        }
```

**File:** types/src/secret_sharing.rs (L196-202)
```rust
    pub fn get_peer_weight(&self, _peer: &Author) -> u64 {
        1
    }

    pub fn get_peer_weights(&self) -> &HashMap<Author, u64> {
        &self.weights
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L74-81)
```rust
    fn retain(&mut self, metadata: &SecretShareMetadata, weights: &HashMap<Author, u64>) {
        self.shares.retain(|_, share| share.metadata == *metadata);
        self.total_weight = self
            .shares
            .keys()
            .map(|author| weights.get(author).expect("Author must exist for weight"))
            .sum();
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L108-113)
```rust
    fn add_share(&mut self, share: SecretShare, share_weight: u64) -> anyhow::Result<()> {
        match self {
            SecretShareItem::PendingMetadata(aggr) => {
                aggr.add_share(share, share_weight);
                Ok(())
            },
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L162-164)
```rust
        let share_weight = *share_weights
            .get(share.author())
            .expect("Author must exist in weights");
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L242-242)
```rust
        let peer_weights = self.secret_share_config.get_peer_weights();
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L142-148)
```rust
        {
            let mut secret_share_store = self.secret_share_store.lock();
            secret_share_store.update_highest_known_round(block.round());
            secret_share_store
                .add_self_share(self_secret_share.clone())
                .expect("Add self dec share should succeed");
        }
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L310-320)
```rust
            SecretShareMessage::Share(share) => {
                info!(LogSchema::new(LogEvent::ReceiveSecretShare)
                    .author(self.author)
                    .epoch(share.epoch())
                    .round(share.metadata().round)
                    .remote_peer(*share.author()));

                if let Err(e) = self.secret_share_store.lock().add_share(share) {
                    warn!("[SecretShareManager] Failed to add share: {}", e);
                }
            },
```
