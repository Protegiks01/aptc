# Audit Report

## Title
Missing Database-Level Limit Enforcement on State Value Chunk Queries Leading to Potential DoS

## Summary
State value chunk APIs (`get_state_value_chunk_with_proof`, `get_state_value_chunk_iter`) lack the standard `error_if_too_many_requested` validation that other database APIs enforce, violating the "last line of defense" principle against large queries and potentially enabling resource exhaustion attacks.

## Finding Description

The Aptos storage layer defines `MAX_REQUEST_LIMIT` as a protection mechanism against excessive queries [1](#0-0) , with most database reader methods enforcing this limit before performing expensive operations.

However, state value chunk APIs fail to implement this protection:

**Missing Validation**: The `get_state_value_chunk_with_proof` method in the database reader lacks the `error_if_too_many_requested` check [2](#0-1) , unlike other APIs such as `get_transactions` [3](#0-2) , `get_account_ordered_transactions` [4](#0-3) , and similar methods.

**Expensive Operations Without Protection**: The unchecked API performs costly operations including:
1. Iteration over potentially thousands of state values [5](#0-4) 
2. Merkle proof generation via `get_value_range_proof` [6](#0-5) , which calls `get_with_proof` requiring tree traversal [7](#0-6) 

**Current Protection Insufficient**: While the state-sync service limits requests to `max_state_chunk_size` (4,000 by default) [8](#0-7) , this application-layer protection can be bypassed by direct database access or bugs in the state-sync validation logic [9](#0-8) .

## Impact Explanation

This qualifies as **Medium Severity** (up to $10,000) under the Aptos bug bounty program due to potential for validator node resource exhaustion. An attacker could exploit this by:

1. Sending numerous concurrent state-sync requests with maximum chunk sizes
2. Forcing nodes to repeatedly iterate over 4,000 state values and generate Merkle proofs
3. Causing CPU exhaustion from proof generation and memory pressure from value collection

While individual requests are bounded by the state-sync limit, the lack of database-level enforcement violates defense-in-depth principles and could enable resource exhaustion under sustained attack.

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability is exploitable through the state-sync interface, which is exposed to network peers. However, exploitation requires:
- Sustained request volume to exhaust resources
- Bypassing any rate limiting in the state-sync service
- Network-level access to send state-sync requests

The lack of database-level validation means any future API consumers would also be vulnerable without implementing their own limits.

## Recommendation

Add `error_if_too_many_requested` validation to state value chunk APIs for defense-in-depth:

```rust
fn get_state_value_chunk_with_proof(
    &self,
    version: Version,
    first_index: usize,
    chunk_size: usize,
) -> Result<StateValueChunkWithProof> {
    gauged_api("get_state_value_chunk_with_proof", || {
        error_if_too_many_requested(chunk_size as u64, MAX_REQUEST_LIMIT)?;
        self.error_if_state_merkle_pruned("State merkle", version)?;
        self.state_store
            .get_value_chunk_with_proof(version, first_index, chunk_size)
    })
}
```

Similarly update `get_state_value_chunk_iter` and ensure all state-related query APIs enforce consistent limits.

## Proof of Concept

```rust
use aptos_storage_interface::DbReader;

// Attacker sends request with large chunk_size
// This bypasses database-level validation
let chunk_size = 50_000; // Exceeds MAX_REQUEST_LIMIT
let result = db.get_state_value_chunk_with_proof(version, 0, chunk_size);

// Without error_if_too_many_requested, this proceeds to:
// 1. Create iterator over 50,000 items
// 2. Collect all values into memory
// 3. Generate Merkle proof
// All without the standard MAX_REQUEST_LIMIT check
```

**Notes**

The vulnerability exists at the database layer where the standard `MAX_REQUEST_LIMIT` protection is missing for state value chunk operations. While the state-sync service provides some protection via configuration limits, this violates the "last line of defense" design principle explicitly stated in the codebase and could enable DoS attacks or allow bugs in higher-layer validation to become exploitable.

### Citations

**File:** storage/storage-interface/src/lib.rs (L56-58)
```rust
// This is last line of defense against large queries slipping through external facing interfaces,
// like the API and State Sync, etc.
pub const MAX_REQUEST_LIMIT: u64 = 20_000;
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L177-177)
```rust
            error_if_too_many_requested(limit, MAX_REQUEST_LIMIT)?;
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L274-276)
```rust
        gauged_api("get_transactions", || {
            error_if_too_many_requested(limit, MAX_REQUEST_LIMIT)?;

```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L880-891)
```rust
    fn get_state_value_chunk_with_proof(
        &self,
        version: Version,
        first_index: usize,
        chunk_size: usize,
    ) -> Result<StateValueChunkWithProof> {
        gauged_api("get_state_value_chunk_with_proof", || {
            self.error_if_state_merkle_pruned("State merkle", version)?;
            self.state_store
                .get_value_chunk_with_proof(version, first_index, chunk_size)
        })
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L1089-1091)
```rust
        let state_key_values: Vec<(StateKey, StateValue)> = self
            .get_value_chunk_iter(version, first_index, chunk_size)?
            .collect::<Result<Vec<_>>>()?;
```

**File:** storage/aptosdb/src/state_store/mod.rs (L1131-1131)
```rust
        let proof = self.get_value_range_proof(last_key, version)?;
```

**File:** storage/jellyfish-merkle/src/lib.rs (L806-806)
```rust
        let (account, proof) = self.get_with_proof(rightmost_key_to_prove, version)?;
```

**File:** config/src/config/state_sync_config.rs (L25-25)
```rust
const MAX_STATE_CHUNK_SIZE: u64 = 4000;
```

**File:** state-sync/storage-service/server/src/storage.rs (L909-911)
```rust
        let expected_num_state_values = inclusive_range_len(start_index, end_index)?;
        let max_num_state_values = self.config.max_state_chunk_size;
        let num_state_values_to_fetch = min(expected_num_state_values, max_num_state_values);
```
