# Audit Report

## Title
RuntimeEnvironment Configuration Mismatch Causes Consensus Divergence Through Inconsistent Visibility Checks

## Summary
Different validators can use different `RuntimeEnvironment` configurations via node-local static variables, causing them to execute identical bytecode differently. Specifically, validators with different `paranoid_type_verification` settings will apply different cross-module visibility enforcement rules, leading to divergent transaction outcomes and consensus failure.

## Finding Description

The `RuntimeEnvironment` used by validators is partially configured through node-local static variables rather than being entirely derived from on-chain consensus state. This creates a critical consensus vulnerability.

**Root Cause:**

The production VM configuration function `aptos_prod_vm_config()` reads from static `OnceCell` variables to determine runtime behavior: [1](#0-0) 

These static variables are set from the node's local `ExecutionConfig`: [2](#0-1) 

The `paranoid_type_verification` field defaults to `true` but is only enforced for mainnet: [3](#0-2) 

**Critical Impact - Execution Divergence:**

The `paranoid_type_checks` configuration determines which `RuntimeTypeCheck` implementation is used during bytecode execution: [4](#0-3) 

When executing cross-module function calls, the visibility check is invoked: [5](#0-4) 

`FullRuntimeTypeCheck` enforces strict visibility rules and rejects unauthorized calls: [6](#0-5) 

However, `NoRuntimeTypeCheck` bypasses all checks: [7](#0-6) 

**Attack Scenario:**

1. On testnet (or mainnet with bypassed sanitizer), Validator A configures `paranoid_type_verification: true`
2. Validator B configures `paranoid_type_verification: false`  
3. Attacker submits transaction calling a private function from another module
4. Validator A rejects the transaction (visibility check fails)
5. Validator B accepts and executes the transaction (no visibility check)
6. Validators compute different state roots → **consensus failure**

## Impact Explanation

This is a **Critical** severity vulnerability meeting the "Consensus/Safety violations" category:

- **Breaks Deterministic Execution Invariant**: Identical blocks produce different state roots across validators
- **Causes Chain Splits**: Validators with different configurations cannot reach consensus
- **Testnet Impact**: Immediately exploitable as sanitizer doesn't enforce configuration uniformity
- **Mainnet Risk**: Exploitable if validator bypasses sanitizer through binary modification or initialization race conditions
- **Non-Recoverable**: Requires hard fork to resolve consensus divergence once triggered

The vulnerability directly violates the core consensus requirement that all validators must execute transactions identically.

## Likelihood Explanation

**Testnet: HIGH**
- No enforcement of paranoid_type_verification configuration
- Validators can legitimately configure different values
- Attack requires only crafting transaction with visibility violation
- No validator collusion needed

**Mainnet: MEDIUM**  
- Sanitizer enforces paranoid_type_verification=true
- Requires malicious validator to bypass sanitizer
- Static variable uses `OnceCell` - first setter wins, creating race condition risk
- Modified binaries could call `set_paranoid_type_checks(false)` before normal initialization

## Recommendation

**Immediate Fix:**

1. **Remove static configuration variables** - All VM configuration must derive from on-chain consensus state or be hardcoded
2. **Make paranoid checks mandatory** - Remove the ability to disable safety checks in production

**Code Fix:**

```rust
// In aptos-move/aptos-vm-environment/src/prod_configs.rs
pub fn aptos_prod_vm_config(
    chain_id: ChainId,
    gas_feature_version: u64,
    features: &Features,
    timed_features: &TimedFeatures,
    ty_builder: TypeBuilder,
) -> VMConfig {
    // REMOVE: let paranoid_type_checks = get_paranoid_type_checks();
    // HARDCODE: Always enable for consensus safety
    let paranoid_type_checks = true;
    
    // REMOVE: let paranoid_ref_checks = get_paranoid_ref_checks();
    let paranoid_ref_checks = false; // Or derive from features
    
    // ... rest of function
}
```

3. **Add consensus-critical configuration validation** - Hash all execution-affecting configurations and include in block proposals
4. **Deprecate node-local VM configuration** - Move all execution parameters to on-chain governance

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[test]
fn test_runtime_environment_divergence() {
    use aptos_vm_environment::prod_configs::set_paranoid_type_checks;
    use move_core_types::account_address::AccountAddress;
    
    // Simulate two validators with different configurations
    
    // Validator A: paranoid checks enabled
    set_paranoid_type_checks(true);
    let env_a = AptosEnvironment::new(&state_view);
    
    // Validator B: paranoid checks disabled  
    // (In real scenario, this would be a different validator node)
    set_paranoid_type_checks(false);
    let env_b = AptosEnvironment::new(&state_view);
    
    // Create transaction calling private function cross-module
    let txn = create_transaction_calling_private_function();
    
    // Execute on both validators
    let result_a = execute_transaction(&env_a, txn.clone());
    let result_b = execute_transaction(&env_b, txn.clone());
    
    // Validator A rejects, Validator B accepts
    assert!(result_a.is_err()); // Visibility check fails
    assert!(result_b.is_ok());  // No check performed
    
    // Different state roots → consensus failure
    assert_ne!(result_a.state_root(), result_b.state_root());
}
```

## Notes

The vulnerability extends beyond `paranoid_type_checks` to other static configuration variables (`paranoid_ref_checks`, `layout_caches`, `enable_debugging`) that similarly affect execution behavior. All node-local configuration affecting transaction execution must be eliminated to ensure consensus safety.

The issue is particularly severe because:
1. It's not immediately visible - divergence only occurs for specific transaction types
2. Testnet explicitly allows configuration mismatch
3. The static variable pattern (`OnceCell`) is inherently non-deterministic across nodes
4. No runtime validation exists to detect configuration mismatches between validators

### Citations

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L205-208)
```rust
    let paranoid_type_checks = get_paranoid_type_checks();
    let paranoid_ref_checks = get_paranoid_ref_checks();
    let enable_layout_caches = get_layout_caches();
    let enable_debugging = get_debugging_enabled();
```

**File:** aptos-node/src/utils.rs (L53-56)
```rust
pub fn set_aptos_vm_configurations(node_config: &NodeConfig) {
    set_layout_caches(node_config.execution.layout_caches_enabled);
    set_paranoid_type_checks(node_config.execution.paranoid_type_verification);
    set_async_runtime_checks(node_config.execution.async_runtime_checks);
```

**File:** config/src/config/execution_config.rs (L176-181)
```rust
                if !execution_config.paranoid_type_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_type_verification must be enabled for mainnet nodes!".into(),
                    ));
                }
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L267-278)
```rust
        match (
            paranoid_type_checks,
            optimize_trusted_code,
            paranoid_ref_checks,
        ) {
            (true, true, false) => execute_main!(UntrustedOnlyRuntimeTypeCheck, NoRuntimeRefCheck),
            (true, false, false) => execute_main!(FullRuntimeTypeCheck, NoRuntimeRefCheck),
            (true, true, true) => execute_main!(UntrustedOnlyRuntimeTypeCheck, FullRuntimeRefCheck),
            (true, false, true) => execute_main!(FullRuntimeTypeCheck, FullRuntimeRefCheck),
            (false, _, false) => execute_main!(NoRuntimeTypeCheck, NoRuntimeRefCheck),
            (false, _, true) => execute_main!(NoRuntimeTypeCheck, FullRuntimeRefCheck),
        }
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L502-507)
```rust
                    RTTCheck::check_call_visibility(
                        &current_frame.function,
                        &function,
                        CallType::Regular,
                    )
                    .map_err(|err| set_err_info!(current_frame, err))?;
```

**File:** third_party/move/move-vm/runtime/src/runtime_type_checks.rs (L246-252)
```rust
    #[cfg_attr(feature = "force-inline", inline(always))]
    fn check_cross_module_regular_call_visibility(
        _caller: &LoadedFunction,
        _callee: &LoadedFunction,
    ) -> PartialVMResult<()> {
        Ok(())
    }
```

**File:** third_party/move/move-vm/runtime/src/runtime_type_checks.rs (L945-981)
```rust
    fn check_cross_module_regular_call_visibility(
        caller: &LoadedFunction,
        callee: &LoadedFunction,
    ) -> PartialVMResult<()> {
        if callee.is_private() {
            let msg = format!(
                "Function {}::{} cannot be called because it is private",
                callee.module_or_script_id(),
                callee.name()
            );
            return Err(
                PartialVMError::new_invariant_violation(msg).with_sub_status(EPARANOID_FAILURE)
            );
        }

        if callee.is_friend() {
            let callee_module = callee.owner_as_module().map_err(|err| err.to_partial())?;
            if !caller
                .module_id()
                .is_some_and(|id| callee_module.friends.contains(id))
            {
                let msg = format!(
                    "Function {}::{} cannot be called because it has friend visibility, but {} \
                     is not {}'s friend",
                    callee.module_or_script_id(),
                    callee.name(),
                    caller.module_or_script_id(),
                    callee.module_or_script_id()
                );
                return Err(
                    PartialVMError::new_invariant_violation(msg).with_sub_status(EPARANOID_FAILURE)
                );
            }
        }

        Ok(())
    }
```
