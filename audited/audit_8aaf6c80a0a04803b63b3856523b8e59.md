# Audit Report

## Title
Client Retry Logic Can Amplify Resource Exhaustion When Code Invariant Errors Occur in Delayed Field Processing

## Summary
Client applications using the Aptos REST API automatically retry transactions that fail with `DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR` because this error maps to HTTP 500, which is classified as retriable. When such errors occur due to bugs in delayed field materialization, the retry mechanism creates a resource exhaustion loop where transactions repeatedly pass mempool validation but fail during block execution, consuming CPU, memory, and disk space through excessive logging.

## Finding Description

The `code_invariant_error()` function creates errors with status code `DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR` when invariant violations occur during delayed field processing [1](#0-0) . These errors can be triggered by various internal consistency failures in derived string snapshot handling [2](#0-1) .

During block execution, when a transaction encounters this error in parallel execution, it triggers a `PanicError` that aborts parallel execution [3](#0-2) . In sequential execution fallback, the error causes a `FatalBlockExecutorError` with alert logging [4](#0-3) .

When the `discard_failed_blocks` configuration is enabled, a single transaction with this error causes ALL transactions in the block to be discarded with the same error code [5](#0-4) .

The critical issue is that **mempool validation only performs prologue checks** (signatures, sequence numbers, gas) and does not execute transactions [6](#0-5) . Code invariant errors occur during execution when delayed fields are materialized, so problematic transactions pass mempool validation and enter the transaction pool.

Client applications using the REST API treat HTTP 500 errors as retriable [7](#0-6) . The `RestApiReliableTransactionSubmitter` implements exponential backoff retry with configurable `max_retries` [8](#0-7) .

**Attack Flow:**
1. A transaction triggers a code invariant error during execution (due to a bug in delayed field handling)
2. Transaction fails with `DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR`
3. Client receives HTTP 500 response
4. Client automatically retries the transaction
5. Transaction passes mempool validation again (error only occurs at execution)
6. Steps 1-5 repeat until retry limit reached
7. Each execution attempt consumes resources and generates error logs

## Impact Explanation

This issue qualifies as **Medium Severity** because:

1. **Resource Exhaustion**: Each retry attempt triggers parallel execution, sequential fallback, error logging via `alert!` macro, and console error printing [9](#0-8) , consuming CPU, memory, and disk space.

2. **Amplification Effect**: With `discard_failed_blocks` enabled, one problematic transaction causes all transactions in the block to fail. If multiple clients retry simultaneously, this creates cascading retries affecting validator performance.

3. **Limited Direct Exploitability**: The vulnerability requires a pre-existing bug in delayed field materialization that triggers code invariant errors. However, such bugs represent implementation flaws that should trigger this exact scenario.

This does not qualify as High or Critical severity because it requires an underlying bug to manifest and retry logic has built-in limits (max_retries, timeout duration).

## Likelihood Explanation

**Likelihood: Medium-Low**

The vulnerability activates only when:
1. A bug exists in delayed field/resource group handling that violates internal invariants
2. User transactions can trigger this bug during execution
3. Clients implement retry logic for HTTP 500 errors (common practice)

While code invariant errors "should never happen," the existence of the error handling infrastructure acknowledges they can occur. The codebase comment explicitly notes this status code represents "general invariant violations beyond delayed fields, due to the convenience of handling such issues with asserts" [10](#0-9) .

## Recommendation

Implement **non-retriable error classification** for code invariant errors:

1. **Server-side**: Return HTTP 400 (Bad Request) or a custom status code (e.g., 422 Unprocessable Entity) for `DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR` instead of HTTP 500, signaling clients not to retry.

2. **Client-side**: Update retry logic to explicitly exclude `DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR` from retriable errors:

```rust
// In crates/aptos-rest-client/src/error.rs
impl FaucetClientError {
    pub fn is_retriable(&self) -> bool {
        match self.inner.kind {
            Kind::HttpStatus(status) => {
                // Don't retry code invariant errors (422) or client errors (400-499)
                (500..=599).contains(&status) && status != 422
            },
            // ... rest unchanged
        }
    }
}
```

3. **Rate Limiting**: Implement mempool-level rate limiting for transactions from addresses that repeatedly fail with invariant errors.

4. **Monitoring**: Add metrics tracking code invariant error frequency to detect and address underlying bugs quickly.

## Proof of Concept

While a full PoC requires triggering an actual code invariant error (which would represent a separate bug), the retry behavior can be demonstrated:

```rust
// Pseudo-code demonstrating the retry loop
// This would require an actual bug in delayed field handling to trigger

use aptos_rest_client::Client;
use aptos_types::transaction::SignedTransaction;

async fn demonstrate_retry_amplification() {
    let client = Client::new(/* ... */);
    let txn = create_transaction_that_triggers_invariant_error(); // Hypothetical
    
    // Client retry logic (from RestApiReliableTransactionSubmitter)
    for attempt in 0..max_retries {
        match client.submit_bcs(&txn).await {
            Ok(_) => {
                // Transaction submitted to mempool (passes validation)
                match client.wait_for_transaction(/* ... */).await {
                    Ok(result) if result.status_code == 500 => {
                        // DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR occurred
                        // Client retries, creating resource exhaustion loop
                        continue;
                    }
                    _ => break,
                }
            }
            Err(e) if is_retriable(&e) => continue,
            _ => break,
        }
    }
}
```

**Notes:**

This vulnerability is contingent on the existence of triggerable code invariant errors in the delayed field implementation. The core issue is that the error handling and retry architecture assumes such errors should be retried, when they actually represent bugs that retrying cannot fix. While I cannot demonstrate a concrete exploit without identifying a specific triggerable invariant violation, the architectural flaw exists: client retry logic lacks proper classification of non-retriable error types, allowing resource amplification when internal consistency failures occur.

### Citations

**File:** third_party/move/move-vm/types/src/delayed_values/error.rs (L11-19)
```rust
pub fn code_invariant_error<M: std::fmt::Debug>(message: M) -> PartialVMError {
    let msg = format!(
        "Delayed logic code invariant broken (there is a bug in the code), {:?}",
        message
    );
    println!("ERROR: {}", msg);
    PartialVMError::new(StatusCode::DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR)
        .with_message(msg)
}
```

**File:** third_party/move/move-vm/types/src/delayed_values/derived_string_snapshot.rs (L45-94)
```rust
pub fn u128_to_u64(value: u128) -> PartialVMResult<u64> {
    u64::try_from(value).map_err(|_| code_invariant_error("Cannot cast u128 into u64".to_string()))
}

pub fn from_utf8_bytes<T: FromStr>(bytes: Vec<u8>) -> PartialVMResult<T> {
    String::from_utf8(bytes)
        .map_err(|e| code_invariant_error(format!("Unable to convert bytes to string: {}", e)))?
        .parse::<T>()
        .map_err(|_| code_invariant_error("Unable to parse string".to_string()))
}

pub fn u64_to_fixed_size_utf8_bytes(value: u64, length: usize) -> PartialVMResult<Vec<u8>> {
    let result = format!("{:0>width$}", value, width = length)
        .to_string()
        .into_bytes();
    if result.len() != length {
        return Err(code_invariant_error(format!(
            "u64_to_fixed_size_utf8_bytes: width mismatch: value: {value}, length: {length}, result: {result:?}"
        )));
    }
    Ok(result)
}

pub fn bytes_to_string(bytes: Vec<u8>) -> Value {
    Value::struct_(Struct::pack(vec![Value::vector_u8(bytes)]))
}

pub fn bytes_and_width_to_derived_string_struct(
    bytes: Vec<u8>,
    width: usize,
) -> PartialVMResult<Value> {
    // We need to create DerivedStringSnapshot struct that serializes to exactly match given `width`.

    let value_width = bcs_size_of_byte_array(bytes.len());
    // padding field takes at list 1 byte (empty vector)
    if value_width + 1 > width {
        return Err(code_invariant_error(format!(
            "DerivedStringSnapshot size issue: no space left for padding: value_width: {value_width}, width: {width}"
        )));
    }

    // We assume/assert that padding never exceeds length that requires more than 1 byte for size:
    // (otherwise it complicates the logic to fill until the exact width, as padding can never be serialized into 129 bytes
    // (vec[0; 127] serializes into 128 bytes, and vec[0; 128] serializes into 130 bytes))
    let padding_len = width - value_width - 1;
    if size_u32_as_uleb128(padding_len) > 1 {
        return Err(code_invariant_error(format!(
            "DerivedStringSnapshot size issue: padding expected to be too large: value_width: {value_width}, width: {width}, padding_len: {padding_len}"
        )));
    }
```

**File:** aptos-move/block-executor/src/executor.rs (L161-166)
```rust
            ExecutionStatus::DelayedFieldsCodeInvariantError(msg) => {
                Err(code_invariant_error(format!(
                    "[Execution] At txn {}, failed with DelayedFieldsCodeInvariantError: {:?}",
                    txn_idx, msg
                )))
            },
```

**File:** aptos-move/block-executor/src/executor.rs (L2250-2257)
```rust
                ExecutionStatus::DelayedFieldsCodeInvariantError(msg) => {
                    if let Some(commit_hook) = &self.transaction_commit_hook {
                        commit_hook.on_execution_aborted(idx as TxnIndex);
                    }
                    alert!("Sequential execution DelayedFieldsCodeInvariantError error by transaction {}: {}", idx as TxnIndex, msg);
                    return Err(SequentialBlockExecutionError::ErrorToReturn(
                        BlockExecutionError::FatalBlockExecutorError(code_invariant_error(msg)),
                    ));
```

**File:** aptos-move/block-executor/src/executor.rs (L2648-2663)
```rust
        if self.config.local.discard_failed_blocks {
            // We cannot execute block, discard everything (including block metadata and validator transactions)
            // (TODO: maybe we should add fallback here to first try BlockMetadataTransaction alone)
            let error_code = match sequential_error {
                BlockExecutionError::FatalBlockExecutorError(_) => {
                    StatusCode::DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR
                },
                BlockExecutionError::FatalVMError(_) => {
                    StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR
                },
            };
            let ret = (0..signature_verified_block.num_txns())
                .map(|_| E::Output::discard_output(error_code))
                .collect();
            return Ok(BlockOutput::new(ret, None));
        }
```

**File:** mempool/src/shared_mempool/tasks.rs (L486-504)
```rust
    // Track latency: VM validation
    let vm_validation_timer = counters::PROCESS_TXN_BREAKDOWN_LATENCY
        .with_label_values(&[counters::VM_VALIDATION_LABEL])
        .start_timer();
    let validation_results = VALIDATION_POOL.install(|| {
        transactions
            .par_iter()
            .map(|t| {
                let result = smp.validator.read().validate_transaction(t.0.clone());
                // Pre-compute the hash and length if the transaction is valid, before locking mempool
                if result.is_ok() {
                    t.0.committed_hash();
                    t.0.txn_bytes_len();
                }
                result
            })
            .collect::<Vec<_>>()
    });
    vm_validation_timer.stop_and_record();
```

**File:** crates/aptos-rest-client/src/error.rs (L39-53)
```rust
    pub fn is_retriable(&self) -> bool {
        match self.inner.kind {
            // internal server errors are retriable
            Kind::HttpStatus(status) => (500..=599).contains(&status),
            Kind::Timeout | Kind::StaleResponse | Kind::NeedSync => true,
            Kind::RpcResponse
            | Kind::Request
            | Kind::ChainId
            | Kind::Batch
            | Kind::Decode
            | Kind::InvalidProof
            | Kind::StateStore
            | Kind::Unknown => false,
        }
    }
```

**File:** crates/transaction-emitter-lib/src/emitter/transaction_executor.rs (L54-90)
```rust
    async fn submit_check_and_retry(
        &self,
        txn: &SignedTransaction,
        counters: &CounterState,
        run_seed: u64,
    ) -> Result<()> {
        for i in 0..self.max_retries {
            sample!(
                SampleRate::Duration(Duration::from_secs(60)),
                debug!(
                    "Running reliable/retriable fetching, current state: {}",
                    counters.show_detailed()
                )
            );

            // All transactions from the same sender, need to be submitted to the same client
            // in the same retry round, so that they are not placed in parking lot.
            // Do so by selecting a client via seeded random selection.
            let seed = [
                i.to_le_bytes().to_vec(),
                run_seed.to_le_bytes().to_vec(),
                txn.sender().to_vec(),
            ]
            .concat();
            let mut seeded_rng = StdRng::from_seed(*aptos_crypto::HashValue::sha3_256_of(&seed));
            let rest_client = self.random_rest_client_from_rng(&mut seeded_rng);
            let mut failed_submit = false;
            let mut failed_wait = false;
            let result = submit_and_check(
                rest_client,
                txn,
                self.retry_after,
                i == 0,
                &mut failed_submit,
                &mut failed_wait,
            )
            .await;
```

**File:** third_party/move/move-core/types/src/vm_status.rs (L860-866)
```rust
    // Note: This status is created both from third_party (move) and block executor
    // (aptos-move in the adapter). In the later case, it can now also represent more
    // general invariant violations beyond delayed fields, due to the convenience of
    // handling such issues with asserts (e.g. by falling back to sequential execution).
    // TODO: can be audited and broken down into specific types, once implementation
    // is also not duplicated.
    DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR = 2023,
```
