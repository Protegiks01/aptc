# Audit Report

## Title
Governance Can Set UTF-8 Validation Gas Parameters to Zero Enabling Validator Resource Exhaustion

## Summary
The `gas_schedule::set_for_next_epoch()` function lacks validation to prevent gas parameters from being set to zero. This allows governance proposals to set `string_check_utf8_base` and `string_check_utf8_per_byte` to zero, making UTF-8 validation free. Attackers can then spam validators with transactions containing large byte vectors requiring UTF-8 validation, consuming significant CPU resources without paying corresponding gas costs, leading to validator slowdowns.

## Finding Description

The vulnerability exists in the gas schedule update mechanism that lacks validation for individual gas parameter values.

**Missing Validation in Gas Schedule Updates:**

The `set_for_next_epoch()` function only validates that the gas schedule blob is non-empty and the feature version is not decreasing: [1](#0-0) 

Notice the TODO comment indicating missing consistency checks: [2](#0-1) 

**Gas Parameter Loading Without Zero-Checks:**

When loading gas parameters from the on-chain schedule, values are extracted directly without validation: [3](#0-2) 

The macro simply converts values using `.into()` with no minimum value validation.

**UTF-8 Validation Gas Charging:**

The native UTF-8 validation function charges gas based on these parameters: [4](#0-3) 

If both `STRING_CHECK_UTF8_BASE` and `STRING_CHECK_UTF8_PER_BYTE` evaluate to zero (loaded from on-chain parameters), the total cost becomes zero.

**Attack Scenario:**

1. A governance proposal is submitted (either maliciously or due to error) that sets:
   - `move_stdlib.string.check_utf8.base = 0`
   - `move_stdlib.string.check_utf8.per_byte = 0`

2. The proposal passes governance voting and is applied via `set_for_next_epoch()` without validation

3. Attackers create transactions that repeatedly call `string::utf8()` or `string::try_utf8()` with large byte vectors (e.g., 1MB each)

4. The UTF-8 validation executes `std::str::from_utf8()` which performs O(n) scanning of all bytes to verify valid UTF-8 encoding

5. Validators consume significant CPU time for this validation while the attacker pays zero gas for the operation (only paying for vector operations and transaction base cost)

6. Multiple attackers can amplify this effect, causing validator slowdowns across the network

## Impact Explanation

**Severity: HIGH** - Validator node slowdowns

This qualifies as High severity per the Aptos bug bounty program for the following reasons:

1. **Validator Resource Exhaustion**: UTF-8 validation involves byte-by-byte scanning to verify encoding validity, multi-byte character boundary checks, and validation logic - all CPU-intensive operations. With zero gas cost, attackers create an asymmetric attack where minimal gas expenditure causes significant validator CPU consumption.

2. **Network-Wide Impact**: All validators processing these transactions would experience the slowdown, affecting network performance and potentially causing block production delays.

3. **Low Attack Cost**: After the gas parameters are set to zero (through governance), any user can exploit this without special privileges or resources beyond standard transaction submission.

4. **Amplification Potential**: Multiple coordinated attackers could submit many such transactions in parallel, amplifying the resource exhaustion effect.

The impact is limited to slowdowns rather than complete unavailability because validators would still process transactions, just more slowly, and other gas limits (transaction maximum gas, block gas limits) would eventually stop individual transactions.

## Likelihood Explanation

**Likelihood: MEDIUM**

The likelihood is medium because:

**Factors Increasing Likelihood:**
- The validation gap exists in production code with TODO comments indicating it was known but not implemented
- Gas schedule updates are expected to happen periodically as the network evolves
- Automated gas parameter generation tooling could contain bugs that generate zero values
- No runtime safeguards exist - if zero values are set, they become active immediately at the next epoch

**Factors Decreasing Likelihood:**
- Requires a governance proposal to pass, which involves community review and voting
- Malicious governance participants would need sufficient voting power
- Accidental zero values in gas schedules would likely be caught during proposal review

However, defense-in-depth principles dictate that programmatic validation should exist regardless of governance review processes, as humans can make mistakes or tooling can have bugs.

## Recommendation

Add validation to `gas_schedule::set_for_next_epoch()` to ensure critical gas parameters cannot be set to zero:

```move
public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    
    // ADD: Validate that critical gas parameters are not zero
    validate_gas_schedule_consistency(&new_gas_schedule);
    
    config_buffer::upsert(new_gas_schedule);
}

const EINVALID_GAS_PARAMETER_VALUE: u64 = 4;

fun validate_gas_schedule_consistency(schedule: &GasScheduleV2) {
    let entries = &schedule.entries;
    let i = 0;
    let len = vector::length(entries);
    
    // List of critical parameters that must not be zero
    let critical_params = vector[
        string::utf8(b"move_stdlib.string.check_utf8.base"),
        string::utf8(b"move_stdlib.string.check_utf8.per_byte"),
        // Add other critical parameters as needed
    ];
    
    while (i < len) {
        let entry = vector::borrow(entries, i);
        let j = 0;
        while (j < vector::length(&critical_params)) {
            if (&entry.key == vector::borrow(&critical_params, j)) {
                assert!(entry.val > 0, error::invalid_argument(EINVALID_GAS_PARAMETER_VALUE));
            };
            j = j + 1;
        };
        i = i + 1;
    };
}
```

Additionally, apply the same validation to `set_for_next_epoch_check_hash()`.

## Proof of Concept

```rust
// In aptos-move/e2e-tests/src/tests/
#[test]
fn test_zero_gas_utf8_validation_exploit() {
    use aptos_types::account_address::AccountAddress;
    use move_core_types::value::MoveValue;
    
    let mut executor = FakeExecutor::from_head_genesis();
    
    // Step 1: Governance sets UTF-8 validation gas to zero
    executor.override_one_gas_param("move_stdlib.string.check_utf8.base", 0);
    executor.override_one_gas_param("move_stdlib.string.check_utf8.per_byte", 0);
    
    // Step 2: Create attacker account
    let attacker = executor.create_raw_account();
    
    // Step 3: Submit transaction that validates large UTF-8 strings
    let script = r#"
        script {
            use std::string;
            use std::vector;
            
            fun main() {
                let i = 0;
                // Attempt to validate 100 strings of 100KB each = 10MB total
                while (i < 100) {
                    let bytes = vector::empty<u8>();
                    let j = 0;
                    while (j < 100000) {
                        vector::push_back(&mut bytes, 65); // 'A' character
                        j = j + 1;
                    };
                    // This UTF-8 validation should cost zero gas
                    let _ = string::try_utf8(bytes);
                    i = i + 1;
                };
            }
        }
    "#;
    
    // Step 4: Execute and measure gas
    let txn = executor.create_script_transaction(
        attacker.address(),
        script.as_bytes(),
        vec![],
        vec![],
    );
    
    let output = executor.execute_transaction(txn);
    
    // The gas used should be minimal (only vector ops and transaction overhead)
    // while the validator performed expensive UTF-8 validation on 10MB of data
    println!("Gas used: {:?}", output.gas_used());
    
    // In a real attack, this transaction would consume significant CPU time
    // on validators while paying minimal gas, creating an asymmetric cost attack
}
```

**Notes:**

The vulnerability stems from the incomplete implementation of gas schedule validation. While storage gas configurations have validation preventing zero values [5](#0-4) , the general gas schedule lacks equivalent safeguards. The TODO comments throughout the codebase indicate this validation was intended but never implemented, creating a security gap exploitable through governance parameter manipulation.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L47-47)
```text
        // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L34-45)
```rust
            fn from_on_chain_gas_schedule(gas_schedule: &std::collections::BTreeMap<String, u64>, feature_version: u64) -> Result<Self, String> {
                let mut params = $params_name::zeros();

                $(
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        let name = format!("{}.{}", $prefix, key);
                        params.$name = gas_schedule.get(&name).cloned().ok_or_else(|| format!("Gas parameter {} does not exist. Feature version: {}.", name, feature_version))?.into();
                    }
                )*

                Ok(params)
            }
```

**File:** aptos-move/framework/move-stdlib/src/natives/string.rs (L37-55)
```rust
fn native_check_utf8(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    debug_assert!(args.len() == 1);
    let s_arg = safely_pop_arg!(args, VectorRef);
    let s_ref = s_arg.as_bytes_ref();

    context.charge(
        STRING_CHECK_UTF8_BASE
            + STRING_CHECK_UTF8_PER_BYTE * NumBytes::new(s_ref.as_slice().len() as u64),
    )?;

    let ok = std::str::from_utf8(s_ref.as_slice()).is_ok();
    // TODO: extensible native cost tables

    Ok(smallvec![Value::bool(ok)])
}
```

**File:** aptos-move/framework/aptos-framework/sources/storage_gas.move (L345-347)
```text
    public fun new_usage_gas_config(target_usage: u64, read_curve: GasCurve, create_curve: GasCurve, write_curve: GasCurve): UsageGasConfig {
        assert!(target_usage > 0, error::invalid_argument(EZERO_TARGET_USAGE));
        assert!(target_usage <= MAX_U64 / BASIS_POINT_DENOMINATION, error::invalid_argument(ETARGET_USAGE_TOO_BIG));
```
