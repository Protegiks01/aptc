# Audit Report

## Title
VaultStorage get_public_key() Lacks Cryptographic Validation Against Private Key

## Summary
The `VaultStorage::get_public_key()` function blindly trusts Vault's response without verifying that the returned public key cryptographically derives from the corresponding private key, unlike the alternative `CryptoKVStorage` implementation which does validate.

## Finding Description
The `VaultStorage::get_public_key()` implementation retrieves public keys from Vault without cryptographic validation: [1](#0-0) 

This implementation simply reads the Ed25519 key from Vault's transit backend and returns the latest version based on version number comparison. It does not export the private key and derive the public key to validate correctness.

In contrast, the `CryptoKVStorage` implementation provides validation by deriving the public key from the private key: [2](#0-1) 

**Attack Scenario:**
If Vault is compromised (via MITM attack on Vault API, Vault software vulnerability, or infrastructure compromise), an attacker could manipulate the `read_ed25519_key()` responses to return incorrect public keys while maintaining correct private keys internally. This would cause:

1. **Validator Registration Issues**: During initial setup, when `create_key()` calls `get_public_key()` to retrieve the key for on-chain registration, a wrong public key could be registered: [3](#0-2) 

2. **Key Identity Confusion**: Operators relying on `get_public_key()` for key management would receive incorrect information about their validator's identity.

**Mitigation Path:**
While SafetyRules has validation via `consensus_sk_by_pk()` that checks private key derivation during initialization: [4](#0-3) 

This validation only occurs in specific consensus paths and doesn't cover all usage scenarios of `get_public_key()`.

## Impact Explanation
This qualifies as **Medium Severity** under the Aptos bug bounty criteria because:

- **State Inconsistencies**: A compromised Vault could cause validators to register with incorrect public keys, requiring operational intervention to correct the mismatch
- **Availability Impact**: Validators would be unable to participate in consensus due to signature verification failures
- **Defense-in-Depth Violation**: The lack of validation violates cryptographic correctness principles, making the system vulnerable if Vault is compromised

While Vault is generally trusted infrastructure, defense-in-depth principles require validating cryptographic material from external systems, especially when the alternative implementation (`CryptoKVStorage`) already demonstrates the correct pattern.

## Likelihood Explanation
**Medium likelihood** because:

- Vault compromise requires either software vulnerabilities, MITM attacks, or infrastructure access
- However, Vault is a common attack target as a central secrets management system
- The vulnerability silently accepts incorrect keys without any validation
- Operators may not detect the issue until signatures fail during consensus participation

## Recommendation
Modify `VaultStorage::get_public_key()` to validate the returned public key matches the private key derivation:

```rust
fn get_public_key(&self, name: &str) -> Result<PublicKeyResponse, Error> {
    let name = self.crypto_name(name);
    
    // Get the public key from Vault
    let resp = self.client().read_ed25519_key(&name)?;
    let mut last_key = resp.first().ok_or(Error::KeyNotSet(name.clone()))?;
    for key in &resp {
        last_key = if last_key.version > key.version {
            last_key
        } else {
            key
        }
    }
    
    // Validate by exporting private key and deriving public key
    let private_key = self.client().export_ed25519_key(&name, Some(last_key.version))?;
    let derived_public_key = private_key.public_key();
    
    // Verify the public key matches
    if derived_public_key != last_key.value {
        return Err(Error::InternalError(format!(
            "Public key mismatch: Vault returned {:?} but private key derives {:?}",
            last_key.value, derived_public_key
        )));
    }

    Ok(PublicKeyResponse {
        last_update: DateTime::parse_from_rfc3339(&last_key.creation_time)?.timestamp() as u64,
        public_key: last_key.value.clone(),
    })
}
```

This matches the validation pattern used in `consensus_sk_by_pk()` and provides defense-in-depth against Vault compromise or data corruption.

## Proof of Concept
```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_crypto::ed25519::Ed25519PrivateKey;
    use aptos_crypto::PrivateKey;
    
    #[test]
    fn test_vault_public_key_validation() {
        // This test demonstrates that VaultStorage does not validate
        // public keys against private keys, unlike CryptoKVStorage
        
        // Setup: Create a VaultStorage instance (requires running Vault)
        let vault = VaultStorage::new(
            "http://localhost:8200".to_string(),
            "test-token".to_string(),
            None,
            None,
            false,
            None,
            None,
        );
        
        // Import a known private key
        let private_key = Ed25519PrivateKey::generate_for_testing();
        let expected_public_key = private_key.public_key();
        
        vault.import_private_key("test_key", private_key).unwrap();
        
        // Get the public key - this should match the private key
        let response = vault.get_public_key("test_key").unwrap();
        
        // Currently passes because Vault stores correctly
        assert_eq!(response.public_key, expected_public_key);
        
        // However, if Vault were compromised and returned a different
        // public key, VaultStorage would accept it without validation
        // (This cannot be tested without mocking Vault responses)
    }
}
```

**Notes:**
- The vulnerability exists in the VaultStorage implementation's lack of validation
- This creates an inconsistency with CryptoKVStorage which does validate
- SafetyRules provides partial mitigation via `consensus_sk_by_pk()` validation
- The fix should add validation to match CryptoKVStorage's defensive approach
- This improves defense-in-depth against Vault compromise or data corruption scenarios

### Citations

**File:** secure/storage/src/vault.rs (L194-204)
```rust
    fn create_key(&mut self, name: &str) -> Result<Ed25519PublicKey, Error> {
        let ns_name = self.crypto_name(name);
        match self.get_public_key(name) {
            Ok(_) => return Err(Error::KeyAlreadyExists(ns_name)),
            Err(Error::KeyNotSet(_)) => (/* Expected this for new keys! */),
            Err(e) => return Err(e),
        }

        self.client().create_ed25519_key(&ns_name, true)?;
        self.get_public_key(name).map(|v| v.public_key)
    }
```

**File:** secure/storage/src/vault.rs (L234-250)
```rust
    fn get_public_key(&self, name: &str) -> Result<PublicKeyResponse, Error> {
        let name = self.crypto_name(name);
        let resp = self.client().read_ed25519_key(&name)?;
        let mut last_key = resp.first().ok_or(Error::KeyNotSet(name))?;
        for key in &resp {
            last_key = if last_key.version > key.version {
                last_key
            } else {
                key
            }
        }

        Ok(PublicKeyResponse {
            last_update: DateTime::parse_from_rfc3339(&last_key.creation_time)?.timestamp() as u64,
            public_key: last_key.value.clone(),
        })
    }
```

**File:** secure/storage/src/crypto_kv_storage.rs (L59-67)
```rust
    fn get_public_key(&self, name: &str) -> Result<PublicKeyResponse, Error> {
        let response = self.get(name)?;
        let key: Ed25519PrivateKey = response.value;

        Ok(PublicKeyResponse {
            last_update: response.last_update,
            public_key: key.public_key(),
        })
    }
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L106-132)
```rust
    pub fn consensus_sk_by_pk(
        &self,
        pk: bls12381::PublicKey,
    ) -> Result<bls12381::PrivateKey, Error> {
        let _timer = counters::start_timer("get", CONSENSUS_KEY);
        let pk_hex = hex::encode(pk.to_bytes());
        let explicit_storage_key = format!("{}_{}", CONSENSUS_KEY, pk_hex);
        let explicit_sk = self
            .internal_store
            .get::<bls12381::PrivateKey>(explicit_storage_key.as_str())
            .map(|v| v.value);
        let default_sk = self.default_consensus_sk();
        let key = match (explicit_sk, default_sk) {
            (Ok(sk_0), _) => sk_0,
            (Err(_), Ok(sk_1)) => sk_1,
            (Err(_), Err(_)) => {
                return Err(Error::ValidatorKeyNotFound("not found!".to_string()));
            },
        };
        if key.public_key() != pk {
            return Err(Error::SecureStorageMissingDataError(format!(
                "Incorrect sk saved for {:?} the expected pk",
                pk
            )));
        }
        Ok(key)
    }
```
