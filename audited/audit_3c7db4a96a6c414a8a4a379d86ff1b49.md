# Audit Report

## Title
Unvalidated Sharding Configuration in Checkpoint Creation Leads to Silent Data Loss or Checkpoint Failure

## Summary
The checkpoint creation command accepts a user-provided `sharding_config` parameter without validating whether it matches the actual sharding configuration of the source database. This can result in either silent creation of incomplete/malformed checkpoints (when source is sharded but checkpoint uses non-sharded config) or checkpoint creation failure via panic (when source is non-sharded but checkpoint uses sharded config).

## Finding Description

The `run()` function in the checkpoint debugger tool accepts a `sharding_config` CLI parameter that controls how the checkpoint is created. [1](#0-0) 

The sharding configuration is a simple boolean flag without any validation logic: [2](#0-1) 

This parameter is passed directly to `AptosDB::create_checkpoint()` which uses it to determine which database components to checkpoint: [3](#0-2) 

**Attack Scenario 1: Silent Incomplete Checkpoint (High Severity)**

When the source database was created WITH sharding enabled, but the checkpoint command is run WITH `--enable-storage-sharding=false`:

1. `LedgerDb::create_checkpoint()` opens the source DB with `sharding=false`, which only accesses the metadata database [4](#0-3) 

2. Since `sharding=false`, it skips checkpointing individual ledger shard databases (event_db, transaction_db, etc.) [5](#0-4) 

3. The checkpoint creation skips `StateKvDb::create_checkpoint()` entirely (16 shards of state data) and only checkpoints the non-hot StateMerkleDb

**Result**: The checkpoint appears to succeed but is missing critical data including all ledger shards, all StateKvDb shards, and hot StateMerkleDb shards. This breaks the **State Consistency** invariant as the checkpoint cannot be used to restore a functional database.

**Attack Scenario 2: Checkpoint Creation Panic (Medium Severity)**

When the source database was created WITHOUT sharding, but the checkpoint command is run WITH `--enable-storage-sharding=true`:

1. The code attempts to open shard databases that don't exist
2. The opening operations use `.unwrap()` or `.unwrap_or_else(|e| panic!(...))` causing immediate panic [6](#0-5) 

**Root Cause**: There is no stored metadata indicating whether a database was created with sharding enabled, and no validation is performed to detect mismatches between the user-provided configuration and the actual database structure.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty criteria for the following reasons:

1. **State Inconsistency Requiring Intervention**: Creating an incomplete checkpoint that appears valid but is missing critical data represents a state inconsistency. If operators rely on this checkpoint for disaster recovery, they would discover data loss only during restoration.

2. **Significant Protocol Violation**: The checkpoint mechanism is a critical backup/safety feature. Its silent failure violates the expected guarantee that checkpoints are complete, atomic snapshots of the database state.

3. **Operational Impact**: This can affect validator node operations where checkpoints are used as safety measures before destructive operations (as seen in the truncate command) [7](#0-6) 

The impact includes:
- **Unrecoverable data loss** if an incomplete checkpoint is used for restoration
- **Operational disruption** if checkpoint creation panics during critical backup operations
- **Silent corruption** that won't be discovered until disaster recovery is needed

## Likelihood Explanation

The likelihood is **Medium to High** because:

1. **Easy to Trigger**: Any operator with access to the `aptos-db-tool` can trigger this by simply using the wrong `--enable-storage-sharding` flag value

2. **Realistic Scenario**: Operators may not know the sharding configuration of an existing database, especially when dealing with databases created by different versions or configurations

3. **No Safety Guards**: There are no warnings, validation checks, or auto-detection mechanisms to prevent the misconfiguration

4. **Common Usage Pattern**: The checkpoint command is used in production scenarios for backups and as a safety measure before destructive operations like truncation

## Recommendation

Implement validation to detect and enforce that the checkpoint sharding configuration matches the source database structure. The fix should:

1. **Add Auto-Detection**: Detect the sharding configuration from the filesystem by checking for the presence of shard directories
2. **Add Validation**: Verify that the user-provided configuration matches the detected configuration
3. **Fail Fast**: Return an error with a clear message if there's a mismatch, rather than creating an invalid checkpoint or panicking

**Proposed Fix** (in `checkpoint/mod.rs`):

```rust
pub fn run(self) -> Result<()> {
    ensure!(!self.output_dir.exists(), "Output dir already exists.");
    fs::create_dir_all(&self.output_dir)?;
    
    // Detect actual sharding configuration from source database
    let actual_sharding = detect_sharding_config(&self.db_dir)?;
    let requested_sharding = self.db_dir.sharding_config.enable_storage_sharding;
    
    // Validate configuration match
    ensure!(
        actual_sharding == requested_sharding,
        "Sharding configuration mismatch: database was created with sharding={}, but checkpoint requested sharding={}. Use --enable-storage-sharding={} to match the source database configuration.",
        actual_sharding,
        requested_sharding,
        actual_sharding
    );
    
    let sharding_config = self.db_dir.sharding_config.clone();
    AptosDB::create_checkpoint(
        self.db_dir,
        self.output_dir,
        sharding_config.enable_storage_sharding,
    )
}

fn detect_sharding_config(db_dir: &Path) -> Result<bool> {
    // Check for presence of sharded directory structure
    let state_kv_db_folder = db_dir.join("state_kv_db");
    if state_kv_db_folder.exists() {
        // Check if shard directories exist
        let shard_0_exists = state_kv_db_folder.join("shard_0").exists();
        return Ok(shard_0_exists);
    }
    
    // Fallback: check ledger_db structure
    let ledger_db_folder = db_dir.join("ledger_db");
    if ledger_db_folder.exists() {
        let event_db_exists = ledger_db_folder.join("event_db").exists();
        return Ok(event_db_exists);
    }
    
    // If neither exists, assume non-sharded (legacy)
    Ok(false)
}
```

## Proof of Concept

**Prerequisites**: An AptosDB instance created with sharding enabled

**Step 1**: Create a sharded database
```bash
# Start a node with default config (sharding enabled by default)
aptos-node --config validator.yaml
# Let it sync some data, then stop it
```

**Step 2**: Attempt to create checkpoint with wrong sharding config
```bash
# Try to checkpoint WITH sharding disabled (wrong config)
aptos-db-tool debug checkpoint \
  --db-dir /path/to/db \
  --output-dir /path/to/checkpoint \
  # Note: NOT passing --enable-storage-sharding flag (defaults to false)
```

**Expected Vulnerable Behavior**: The command succeeds and creates a checkpoint, but the checkpoint is incomplete (missing shard data)

**Step 3**: Verify incomplete checkpoint
```bash
# Check checkpoint directory structure
ls -la /path/to/checkpoint/
# You'll see only metadata databases, missing:
# - state_kv_db/shard_* directories
# - ledger_db/event_db, transaction_db, etc.
# - hot_state_merkle_db/
```

**Reverse PoC** (panic scenario):

**Step 1**: Create a non-sharded database (legacy mode)
```bash
# Modify config to disable sharding
echo "enable_storage_sharding: false" > test_config.yaml
aptos-node --config test_config.yaml
```

**Step 2**: Attempt checkpoint with sharding enabled
```bash
aptos-db-tool debug checkpoint \
  --db-dir /path/to/non_sharded_db \
  --output-dir /path/to/checkpoint \
  --enable-storage-sharding
```

**Expected Vulnerable Behavior**: The command panics when trying to open non-existent shard directories

### Citations

**File:** storage/aptosdb/src/db_debugger/checkpoint/mod.rs (L20-29)
```rust
    pub fn run(self) -> Result<()> {
        ensure!(!self.output_dir.exists(), "Output dir already exists.");
        fs::create_dir_all(&self.output_dir)?;
        let sharding_config = self.db_dir.sharding_config.clone();
        AptosDB::create_checkpoint(
            self.db_dir,
            self.output_dir,
            sharding_config.enable_storage_sharding,
        )
    }
```

**File:** storage/aptosdb/src/db_debugger/mod.rs (L17-21)
```rust
#[derive(Parser, Clone)]
pub struct ShardingConfig {
    #[clap(long)]
    enable_storage_sharding: bool,
}
```

**File:** storage/aptosdb/src/db/mod.rs (L172-205)
```rust
    pub fn create_checkpoint(
        db_path: impl AsRef<Path>,
        cp_path: impl AsRef<Path>,
        sharding: bool,
    ) -> Result<()> {
        let start = Instant::now();

        info!(sharding = sharding, "Creating checkpoint for AptosDB.");

        LedgerDb::create_checkpoint(db_path.as_ref(), cp_path.as_ref(), sharding)?;
        if sharding {
            StateKvDb::create_checkpoint(db_path.as_ref(), cp_path.as_ref())?;
            StateMerkleDb::create_checkpoint(
                db_path.as_ref(),
                cp_path.as_ref(),
                sharding,
                /* is_hot = */ true,
            )?;
        }
        StateMerkleDb::create_checkpoint(
            db_path.as_ref(),
            cp_path.as_ref(),
            sharding,
            /* is_hot = */ false,
        )?;

        info!(
            db_path = db_path.as_ref(),
            cp_path = cp_path.as_ref(),
            time_ms = %start.elapsed().as_millis(),
            "Made AptosDB checkpoint."
        );
        Ok(())
    }
```

**File:** storage/aptosdb/src/ledger_db/mod.rs (L311-343)
```rust
    pub(crate) fn create_checkpoint(
        db_root_path: impl AsRef<Path>,
        cp_root_path: impl AsRef<Path>,
        sharding: bool,
    ) -> Result<()> {
        let rocksdb_configs = RocksdbConfigs {
            enable_storage_sharding: sharding,
            ..Default::default()
        };
        let env = None;
        let block_cache = None;
        let ledger_db = Self::new(
            db_root_path,
            rocksdb_configs,
            env,
            block_cache,
            /*readonly=*/ false,
        )?;
        let cp_ledger_db_folder = cp_root_path.as_ref().join(LEDGER_DB_FOLDER_NAME);

        info!(
            sharding = sharding,
            "Creating ledger_db checkpoint at: {cp_ledger_db_folder:?}"
        );

        std::fs::remove_dir_all(&cp_ledger_db_folder).unwrap_or(());
        if sharding {
            std::fs::create_dir_all(&cp_ledger_db_folder).unwrap_or(());
        }

        ledger_db
            .metadata_db()
            .create_checkpoint(Self::metadata_db_path(cp_root_path.as_ref(), sharding))?;
```

**File:** storage/aptosdb/src/ledger_db/mod.rs (L345-367)
```rust
        if sharding {
            ledger_db
                .event_db()
                .create_checkpoint(cp_ledger_db_folder.join(EVENT_DB_NAME))?;
            ledger_db
                .persisted_auxiliary_info_db()
                .create_checkpoint(cp_ledger_db_folder.join(PERSISTED_AUXILIARY_INFO_DB_NAME))?;
            ledger_db
                .transaction_accumulator_db()
                .create_checkpoint(cp_ledger_db_folder.join(TRANSACTION_ACCUMULATOR_DB_NAME))?;
            ledger_db
                .transaction_auxiliary_data_db()
                .create_checkpoint(cp_ledger_db_folder.join(TRANSACTION_AUXILIARY_DATA_DB_NAME))?;
            ledger_db
                .transaction_db()
                .create_checkpoint(cp_ledger_db_folder.join(TRANSACTION_DB_NAME))?;
            ledger_db
                .transaction_info_db()
                .create_checkpoint(cp_ledger_db_folder.join(TRANSACTION_INFO_DB_NAME))?;
            ledger_db
                .write_set_db()
                .create_checkpoint(cp_ledger_db_folder.join(WRITE_SET_DB_NAME))?;
        }
```

**File:** storage/aptosdb/src/state_merkle_db.rs (L651-653)
```rust
                .unwrap_or_else(|e| {
                    panic!("Failed to open state merkle db shard {shard_id}: {e:?}.")
                });
```

**File:** storage/aptosdb/src/db_debugger/truncate/mod.rs (L57-61)
```rust
            AptosDB::create_checkpoint(
                &self.db_dir,
                backup_checkpoint_dir,
                self.sharding_config.enable_storage_sharding,
            )?;
```
