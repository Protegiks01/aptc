# Audit Report

## Title
Unverified Future-Epoch Commit Decisions Enable Malicious State Sync Targets in Consensus Observer

## Summary
The `new_with_target()` function and the broader consensus observer implementation fail to validate signature authenticity on sync target notifications when processing commit decisions from future epochs. This allows malicious consensus observer peers to inject arbitrary, forged ledger info targets that bypass cryptographic verification, potentially causing consensus safety violations and network partitions.

## Finding Description

The vulnerability exists in a multi-step attack path where signature verification is bypassed for future-epoch commit decisions:

**Step 1: Missing Verification for Future Epochs**
When a consensus observer node receives a commit decision message, it only verifies signatures if the commit is for the **current epoch**. [1](#0-0) 

For future-epoch commits, verification is explicitly skipped with a TODO comment acknowledging this gap. [2](#0-1) 

**Step 2: Unverified Target Propagation**
The unverified commit decision is then passed directly to state sync. [3](#0-2) 

This flows through the execution client. [4](#0-3) 

**Step 3: No Validation in State Sync Driver**
The `new_with_target()` function performs no validation—it simply wraps the notification. [5](#0-4) 

The `initialize_sync_target_request()` function only validates **version ordering**, not cryptographic signatures. [6](#0-5) 

**Step 4: Missing Cryptographic Infrastructure**
The state-sync-driver has no access to epoch state or validator verifiers needed for signature verification—confirmed by zero matches for these components in the notification handlers file.

**Attack Scenario:**
1. Malicious consensus observer peer crafts a `CommitDecision` for epoch N+1 with forged signatures
2. The commit decision contains a `LedgerInfoWithSignatures` pointing to an invalid/malicious state root
3. Victim node receives this via `process_commit_decision_message()`
4. Since the epoch is in the future, signature verification is skipped
5. The forged target is passed to state sync without validation
6. State sync attempts to synchronize to the malicious target
7. Different nodes may receive different forged targets, causing consensus splits

## Impact Explanation

This vulnerability achieves **Critical Severity** under the Aptos bug bounty program:

- **Consensus Safety Violations**: Violates the fundamental invariant that "AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine." Malicious peers can inject conflicting sync targets to different nodes, causing them to diverge.

- **Non-recoverable Network Partition**: If different subsets of nodes sync to different forged targets, the network can split into irreconcilable forks, potentially requiring a hard fork to resolve.

- **Cryptographic Correctness Violation**: Bypasses the BLS signature verification that is supposed to ensure only properly signed ledger info from 2f+1 validators can drive state transitions.

The impact is amplified because consensus observer nodes are designed to participate in the network without running full consensus, making them attractive targets for compromise. A single malicious observer peer can attack multiple victim observers simultaneously.

## Likelihood Explanation

**High Likelihood** for the following reasons:

1. **Low Attack Complexity**: An attacker only needs to:
   - Run a consensus observer node (no validator stake required)
   - Craft a forged `CommitDecision` for a future epoch
   - Send it to victim observer nodes via normal P2P messaging

2. **No Special Privileges Required**: The attacker is an unprivileged network peer, not a validator or consensus participant.

3. **Persistent Vulnerability Window**: The TODO comment indicates this is a known implementation gap without a clear timeline for resolution.

4. **Multiple Attack Vectors**: The vulnerability can be exploited during normal epoch transitions, making it blend with legitimate protocol behavior.

5. **Scalable Attack**: A single malicious node can target multiple victims simultaneously.

## Recommendation

Implement signature verification for all commit decisions, regardless of epoch, before passing targets to state sync:

```rust
// In consensus_observer.rs::process_commit_decision_message()
fn process_commit_decision_message(
    &mut self,
    peer_network_id: PeerNetworkId,
    message_received_time: Instant,
    commit_decision: CommitDecision,
) {
    // ... existing checks ...

    // Get the epoch state (may need to fetch future epoch state from storage/network)
    let epoch_state = if commit_epoch == self.get_epoch_state().epoch {
        self.get_epoch_state()
    } else {
        // Fetch epoch state for future epoch from storage or request from peers
        match self.get_epoch_state_for_epoch(commit_epoch) {
            Ok(epoch_state) => epoch_state,
            Err(error) => {
                error!("Cannot verify future epoch commit without epoch state: {:?}", error);
                return; // Reject unverifiable future-epoch commits
            }
        }
    };

    // ALWAYS verify commit decision before processing
    if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
        error!(
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Failed to verify commit decision! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                commit_decision.proof_block_info(),
                peer_network_id,
                error
            ))
        );
        increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
        return;
    }

    // ... rest of processing ...
}
```

Additionally, add defensive validation in `initialize_sync_target_request()` if epoch state is available, or document the trust assumption that consensus has already verified the target.

## Proof of Concept

```rust
// Proof of Concept: Rust integration test demonstrating the vulnerability
#[tokio::test]
async fn test_unverified_future_epoch_sync_target() {
    // Setup: Create a consensus observer node
    let (observer, mut observer_rx) = setup_consensus_observer();
    let malicious_peer = create_malicious_peer();
    
    // Step 1: Craft a forged commit decision for future epoch
    let current_epoch = observer.get_epoch_state().epoch;
    let future_epoch = current_epoch + 1;
    
    // Create a LedgerInfo with arbitrary/malicious state root
    let malicious_state_root = HashValue::random();
    let forged_ledger_info = LedgerInfo::new(
        BlockInfo::new(
            future_epoch,
            100, // round
            HashValue::random(), // block id
            malicious_state_root,
            0, // version
            0, // timestamp
            None, // next_epoch_state
        ),
        HashValue::zero(),
    );
    
    // Create INVALID signatures (empty signature set)
    let forged_commit_proof = LedgerInfoWithSignatures::new(
        forged_ledger_info,
        AggregateSignature::empty(), // Invalid: no actual validator signatures!
    );
    
    let forged_commit_decision = CommitDecision::new(forged_commit_proof);
    
    // Step 2: Send forged commit decision from malicious peer
    let message = ConsensusObserverMessage::CommitDecision(forged_commit_decision.clone());
    observer.process_message(malicious_peer.peer_id(), message);
    
    // Step 3: Verify the attack succeeds
    // Check that state sync was invoked with the unverified target
    let sync_notification = observer_rx.recv().await.expect("Should receive sync notification");
    
    match sync_notification {
        StateSyncNotification::CommitSyncStarted(target) => {
            // VULNERABILITY: State sync accepted unverified target!
            assert_eq!(target.ledger_info().executed_state_id(), malicious_state_root);
            println!("VULNERABILITY CONFIRMED: Unverified malicious target accepted!");
        },
        _ => panic!("Expected CommitSyncStarted notification"),
    }
    
    // Impact: The node will now attempt to sync to a forged/malicious state,
    // potentially causing consensus split if different nodes receive different targets
}
```

**Notes:**
- This vulnerability is particularly dangerous because it affects consensus observer nodes, which are designed to be lightweight participants
- The TODO comment in the code acknowledges this gap but provides no immediate solution
- The attack requires no special privileges—any network peer can exploit it
- Multiple nodes can be targeted simultaneously with different forged targets to maximize network disruption

### Citations

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L468-482)
```rust
        if commit_epoch == epoch_state.epoch {
            // Verify the commit decision
            if let Err(error) = commit_decision.verify_commit_proof(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify commit decision! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                        commit_decision.proof_block_info(),
                        peer_network_id,
                        error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::COMMIT_DECISION_LABEL);
                return;
            }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L497-498)
```rust
        // TODO: identify the best way to handle an invalid commit decision
        // for a future epoch. In such cases, we currently rely on state sync.
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L524-526)
```rust
            // Start state syncing to the commit decision
            self.state_sync_manager
                .sync_to_commit(commit_decision, epoch_changed);
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L219-222)
```rust
                if let Err(error) = execution_client
                    .clone()
                    .sync_to_target(commit_decision.commit_proof().clone())
                    .await
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L156-158)
```rust
    pub fn new_with_target(sync_target_notification: ConsensusSyncTargetNotification) -> Self {
        ConsensusSyncRequest::SyncTarget(sync_target_notification)
    }
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L261-318)
```rust
    /// Initializes the sync target request received from consensus
    pub async fn initialize_sync_target_request(
        &mut self,
        sync_target_notification: ConsensusSyncTargetNotification,
        latest_pre_committed_version: Version,
        latest_synced_ledger_info: LedgerInfoWithSignatures,
    ) -> Result<(), Error> {
        // Get the target sync version and latest committed version
        let sync_target_version = sync_target_notification
            .get_target()
            .ledger_info()
            .version();
        let latest_committed_version = latest_synced_ledger_info.ledger_info().version();

        // If the target version is old, return an error to consensus (something is wrong!)
        if sync_target_version < latest_committed_version
            || sync_target_version < latest_pre_committed_version
        {
            let error = Err(Error::OldSyncRequest(
                sync_target_version,
                latest_pre_committed_version,
                latest_committed_version,
            ));
            self.respond_to_sync_target_notification(sync_target_notification, error.clone())?;
            return error;
        }

        // If the committed version is at the target, return successfully
        if sync_target_version == latest_committed_version {
            info!(
                LogSchema::new(LogEntry::NotificationHandler).message(&format!(
                    "We're already at the requested sync target version: {} \
                (pre-committed version: {}, committed version: {})!",
                    sync_target_version, latest_pre_committed_version, latest_committed_version
                ))
            );
            let result = Ok(());
            self.respond_to_sync_target_notification(sync_target_notification, result.clone())?;
            return result;
        }

        // If the pre-committed version is already at the target, something has else gone wrong
        if sync_target_version == latest_pre_committed_version {
            let error = Err(Error::InvalidSyncRequest(
                sync_target_version,
                latest_pre_committed_version,
            ));
            self.respond_to_sync_target_notification(sync_target_notification, error.clone())?;
            return error;
        }

        // Save the request so we can notify consensus once we've hit the target
        let consensus_sync_request =
            ConsensusSyncRequest::new_with_target(sync_target_notification);
        self.consensus_sync_request = Arc::new(Mutex::new(Some(consensus_sync_request)));

        Ok(())
    }
```
