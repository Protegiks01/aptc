# Audit Report

## Title
Non-Deterministic Leader Election Due to Database Query Failure Fallback in `extract_epoch_proposers()`

## Summary
The `extract_epoch_proposers()` function in `EpochManager` silently falls back to using only the current epoch's proposers when the database query for historical epoch data fails. This creates inconsistent leader election across validators, causing them to disagree on the valid proposer for each round, leading to consensus liveness failures.

## Finding Description

The vulnerability exists in the `extract_epoch_proposers()` function which is responsible for building the historical proposer map used by the leader reputation system. [1](#0-0) 

When `get_epoch_ending_ledger_infos()` fails at line 428-430 or when `extract_epoch_to_proposers()` fails at line 437, the code falls back to returning only the current epoch's proposers at line 439-444. This fallback is silent except for an error log.

**How the vulnerability manifests:**

1. During epoch initialization, validators call `create_proposer_election()` which invokes `extract_epoch_proposers()`: [2](#0-1) 

2. Different validators may experience the database query failure at different times or not at all due to:
   - Database pruning differences (validators can have different pruning configurations)
   - Storage I/O errors
   - Race conditions during epoch transitions
   - Missing historical epoch data

3. This creates inconsistent `epoch_to_proposers` maps across validators:
   - Successful validators: `{epoch-N: [...], ..., epoch: [...]}`
   - Failed validators: `{epoch: [...]}`

4. The `LeaderReputation` system uses this map to filter historical NewBlockEvents when computing reputation weights. The `history_iter()` function explicitly filters events based on whether their epoch exists in the map: [3](#0-2) 

5. Validators with incomplete `epoch_to_proposers` data will filter out all historical events from previous epochs (line 325), resulting in different reputation weight calculations.

6. Different reputation weights lead to different leader selections via `choose_index()`. Even with the same deterministic seed, different weight vectors produce different indices: [4](#0-3) 

7. When proposals arrive, validators validate the proposer using `is_valid_proposer()`: [5](#0-4) 

8. Validators with different leader election results will reject proposals that others accept, causing consensus to stall as the network cannot reach agreement on valid blocks.

**Invariant Violation:**
This violates the consensus requirement that all validators must deterministically agree on who the valid proposer is for any given round, which is fundamental to AptosBFT consensus.

## Impact Explanation

**Severity: Medium**

This vulnerability causes **state inconsistencies requiring intervention** and **consensus liveness failures**, meeting the Medium severity criteria in the Aptos bug bounty program under "Limited Protocol Violations."

**Impact Details:**
- **Consensus Liveness Failure**: Validators cannot reach consensus because they disagree on valid proposers, causing block production to halt
- **Network Availability Impact**: The blockchain stops making progress until the inconsistency is resolved
- **No Safety Violation**: Does not cause double-spending, forks, or fund loss because proposals are still cryptographically validated
- **Requires Manual Intervention**: Operators must restart validators or manually synchronize database state to recover

The impact is limited to Medium (not High or Critical) because:
- No fund loss or theft occurs
- No permanent network partition (recoverable with restarts)
- No consensus safety violations (no conflicting blocks committed)
- Network degradation rather than complete failure

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability is likely to occur in production because:

1. **No Malicious Action Required**: The bug can trigger naturally during normal operation
2. **Common Trigger Conditions**:
   - Database pruning operations that remove historical ledger infos (validators can have different pruning configurations)
   - Storage hardware failures or I/O errors
   - Validators starting at slightly different times during epoch transitions
   - Missing historical epoch data in the database

3. **Increased Risk During**:
   - Epoch boundaries (when historical data is fetched)
   - Network upgrades (when validators restart)
   - Storage maintenance operations

4. **Silent Failure**: The error is only logged, not exposed to operators or halting the process, making it hard to detect before consensus failures occur

5. **No Synchronization Mechanism**: There is no peer-to-peer validation to ensure all validators successfully constructed the same `epoch_to_proposers` map during epoch initialization.

The vulnerability becomes more likely as:
- The network ages and database pruning becomes more aggressive
- The validator set grows (more opportunity for inconsistency)
- Historical window sizes increase (more epochs to fetch, configured by `use_history_from_previous_epoch_max_count`)

## Recommendation

Add explicit validation to ensure all validators have successfully fetched the same historical epoch data before proceeding with epoch initialization. Options include:

1. **Fail-safe approach**: If historical epoch data cannot be fetched, abort epoch initialization and force manual intervention rather than silently falling back to incomplete data.

2. **Consensus-based verification**: Add a handshake mechanism where validators verify they have the same `epoch_to_proposers` map before starting the new epoch.

3. **Minimum data requirement**: Require all validators to have at least the minimum historical data configured by `use_history_from_previous_epoch_max_count`, and halt if this cannot be satisfied.

4. **Storage guarantees**: Ensure that epoch ending ledger infos are never pruned while they are within the `use_history_from_previous_epoch_max_count` window.

Example fix for the fail-safe approach:

```rust
fn extract_epoch_proposers(...) -> Result<HashMap<u64, Vec<AccountAddress>>> {
    // ... existing code ...
    if epoch_state.epoch > first_epoch_to_consider {
        self.storage
            .aptos_db()
            .get_epoch_ending_ledger_infos(first_epoch_to_consider - 1, epoch_state.epoch)
            .map_err(Into::into)
            .and_then(|proof| {
                ensure!(...);
                extract_epoch_to_proposers(proof, epoch_state.epoch, &proposers, needed_rounds)
            })
            // Remove the unwrap_or_else fallback - propagate the error instead
    } else {
        Ok(HashMap::from([(epoch_state.epoch, proposers)]))
    }
}
```

Then handle the error at the caller site by aborting epoch initialization with a clear error message.

## Proof of Concept

This vulnerability can be demonstrated by:

1. Setting up two validators with different database pruning configurations
2. Ensuring one validator has pruned historical epochs that the other still has
3. Triggering an epoch transition
4. Observing that the validators compute different `epoch_to_proposers` maps
5. Observing that they subsequently disagree on the valid proposer for each round
6. Observing consensus failure as proposals are rejected by some validators but accepted by others

The code paths confirmed through static analysis are sufficient to demonstrate the vulnerability without requiring a full integration test, as the logic is deterministic and the failure mode is clear from the code structure.

### Citations

**File:** consensus/src/epoch_manager.rs (L361-366)
```rust
                let epoch_to_proposers = self.extract_epoch_proposers(
                    epoch_state,
                    use_history_from_previous_epoch_max_count,
                    proposers,
                    (window_size + seek_len) as u64,
                );
```

**File:** consensus/src/epoch_manager.rs (L409-448)
```rust
    fn extract_epoch_proposers(
        &self,
        epoch_state: &EpochState,
        use_history_from_previous_epoch_max_count: u32,
        proposers: Vec<AccountAddress>,
        needed_rounds: u64,
    ) -> HashMap<u64, Vec<AccountAddress>> {
        // Genesis is epoch=0
        // First block (after genesis) is epoch=1, and is the only block in that epoch.
        // It has no votes, so we skip it unless we are in epoch 1, as otherwise it will
        // skew leader elections for exclude_round number of rounds.
        let first_epoch_to_consider = std::cmp::max(
            if epoch_state.epoch == 1 { 1 } else { 2 },
            epoch_state
                .epoch
                .saturating_sub(use_history_from_previous_epoch_max_count as u64),
        );
        // If we are considering beyond the current epoch, we need to fetch validators for those epochs
        if epoch_state.epoch > first_epoch_to_consider {
            self.storage
                .aptos_db()
                .get_epoch_ending_ledger_infos(first_epoch_to_consider - 1, epoch_state.epoch)
                .map_err(Into::into)
                .and_then(|proof| {
                    ensure!(
                        proof.ledger_info_with_sigs.len() as u64
                            == (epoch_state.epoch - (first_epoch_to_consider - 1))
                    );
                    extract_epoch_to_proposers(proof, epoch_state.epoch, &proposers, needed_rounds)
                })
                .unwrap_or_else(|err| {
                    error!(
                        "Couldn't create leader reputation with history across epochs, {:?}",
                        err
                    );
                    HashMap::from([(epoch_state.epoch, proposers)])
                })
        } else {
            HashMap::from([(epoch_state.epoch, proposers)])
        }
```

**File:** consensus/src/liveness/leader_reputation.rs (L297-326)
```rust
    fn history_iter<'a>(
        history: &'a [NewBlockEvent],
        epoch_to_candidates: &'a HashMap<u64, Vec<Author>>,
        window_size: usize,
        from_stale_end: bool,
    ) -> impl Iterator<Item = &'a NewBlockEvent> {
        let sub_history = if from_stale_end {
            let start = if history.len() > window_size {
                history.len() - window_size
            } else {
                0
            };

            &history[start..]
        } else {
            if let (Some(first), Some(last)) = (history.first(), history.last()) {
                assert!((first.epoch(), first.round()) >= (last.epoch(), last.round()));
            }
            let end = if history.len() > window_size {
                window_size
            } else {
                history.len()
            };

            &history[..end]
        };
        sub_history
            .iter()
            .filter(move |&meta| epoch_to_candidates.contains_key(&meta.epoch()))
    }
```

**File:** consensus/src/liveness/leader_reputation.rs (L696-733)
```rust
    fn get_valid_proposer_and_voting_power_participation_ratio(
        &self,
        round: Round,
    ) -> (Author, VotingPowerRatio) {
        let target_round = round.saturating_sub(self.exclude_round);
        let (sliding_window, root_hash) = self.backend.get_block_metadata(self.epoch, target_round);
        let voting_power_participation_ratio =
            self.compute_chain_health_and_add_metrics(&sliding_window, round);
        let mut weights =
            self.heuristic
                .get_weights(self.epoch, &self.epoch_to_proposers, &sliding_window);
        let proposers = &self.epoch_to_proposers[&self.epoch];
        assert_eq!(weights.len(), proposers.len());

        // Multiply weights by voting power:
        let stake_weights: Vec<u128> = weights
            .iter_mut()
            .enumerate()
            .map(|(i, w)| *w as u128 * self.voting_powers[i] as u128)
            .collect();

        let state = if self.use_root_hash {
            [
                root_hash.to_vec(),
                self.epoch.to_le_bytes().to_vec(),
                round.to_le_bytes().to_vec(),
            ]
            .concat()
        } else {
            [
                self.epoch.to_le_bytes().to_vec(),
                round.to_le_bytes().to_vec(),
            ]
            .concat()
        };

        let chosen_index = choose_index(stake_weights, state);
        (proposers[chosen_index], voting_power_participation_ratio)
```

**File:** consensus/src/liveness/proposer_election.rs (L14-16)
```rust
    fn is_valid_proposer(&self, author: Author, round: Round) -> bool {
        self.get_valid_proposer(round) == author
    }
```
