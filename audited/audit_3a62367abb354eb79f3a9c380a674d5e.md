# Audit Report

## Title
Persistent Network Key Mismatch Allows Indefinite Consensus Participation with Outdated Keys

## Summary
When `ValidatorSetStream` detects a network key mismatch via `find_key_mismatches()`, there is a race condition of up to 5 seconds, and more critically, a persistent vulnerability where validators with mismatched network keys can continue participating in consensus indefinitely over existing connections. The `close_stale_connections()` function only validates peer_id presence, not key correctness, allowing stale network keys to persist.

## Finding Description

The vulnerability exists in the network discovery and connectivity management layer. When a validator's network addresses are rotated on-chain (containing new x25519 public keys), but the validator node has not updated its local configuration: [1](#0-0) 

The `find_key_mismatches()` function detects the mismatch between the local `expected_pubkey` and on-chain keys, but only logs an error and sets a metric - it takes no action to prevent consensus participation. [2](#0-1) 

The updated peer set is sent to the connectivity manager, which processes it asynchronously. [3](#0-2) 

The `check_connectivity()` function runs on a periodic ticker (default 5 seconds), creating a race window. [4](#0-3) 

More critically, the `close_stale_connections()` function only checks if the peer_id exists in the trusted peers set: [5](#0-4) 

This check at line 490 validates peer_id presence but **never validates that the connection's public key matches the current trusted key** for that peer_id. When a validator's network keys change but remains in the validator set, existing connections persist indefinitely with outdated keys.

During the Noise handshake, keys are validated once: [6](#0-5) 

But this validation only occurs during initial connection establishment. Existing connections are never re-validated against updated trusted keys.

Meanwhile, consensus messages use the peer_id from the established connection metadata: [7](#0-6) 

The verification uses the peer_id from the network connection, which was established with the old key, allowing the validator to continue participating in consensus.

## Impact Explanation

**Severity: Medium to High**

This vulnerability breaks the invariant that validators should only participate in the network with currently trusted, validated keys. While consensus BLS signatures remain valid (as they're separate from network keys), the issue creates several security concerns:

1. **Network Integrity Violation**: Validators can maintain connectivity using keys that are no longer trusted on-chain
2. **Liveness Risk**: When existing connections eventually drop, they cannot be re-established (new handshakes fail), leading to validator isolation
3. **Configuration Drift**: The system tolerates indefinite key mismatches, masking operational errors that could indicate compromise
4. **Partial Network Partition**: Validators with key mismatches can communicate over existing connections but cannot establish new ones, creating an asymmetric network topology

This falls under **High Severity** per Aptos bug bounty criteria as it represents a "Significant protocol violation" that can lead to validator node operational issues and potential liveness degradation.

## Likelihood Explanation

**Likelihood: Medium**

This vulnerability occurs whenever:
1. An operator rotates validator network addresses on-chain via `stake::update_network_and_fullnode_addresses()`
2. The changes take effect at the next epoch transition via `reconfiguration::reconfigure()`
3. The local validator node configuration is not updated to match [8](#0-7) 

This is a realistic operational scenario during key rotation procedures, especially in automated deployment environments where configuration synchronization may lag behind on-chain updates.

## Recommendation

Implement key validation in `close_stale_connections()` to verify that connected peers' public keys match the current trusted keys:

```rust
async fn close_stale_connections(&mut self) {
    if let Some(trusted_peers) = self.get_trusted_peers() {
        let stale_peers = self
            .connected
            .iter()
            .filter_map(|(peer_id, metadata)| {
                // Check if peer_id is no longer in trusted set
                if !trusted_peers.contains_key(peer_id) {
                    return Some(*peer_id);
                }
                
                // NEW: Validate that connection's public key matches trusted key
                if let Some(trusted_peer) = trusted_peers.get(peer_id) {
                    // Get connection's public key from metadata
                    if let Some(conn_pubkey) = metadata.remote_public_key() {
                        if !trusted_peer.keys.contains(&conn_pubkey) {
                            warn!(
                                NetworkSchema::new(&self.network_context)
                                    .remote_peer(peer_id),
                                "Connection has outdated public key, closing"
                            );
                            return Some(*peer_id);
                        }
                    }
                }
                
                // Existing server-only auth logic...
                None
            });
        
        // Close stale connections...
    }
}
```

Additionally, make `find_key_mismatches()` immediately terminate the validator process or disable consensus participation when a critical mismatch is detected:

```rust
fn find_key_mismatches(&self, onchain_keys: Option<&HashSet<x25519::PublicKey>>) {
    let mismatch = onchain_keys.map_or(0, |pubkeys| {
        if !pubkeys.contains(&self.expected_pubkey) {
            error!(
                NetworkSchema::new(&self.network_context),
                "CRITICAL: Local network key mismatch detected! \
                 Onchain pubkeys: {:?}, Local pubkey: {}. \
                 Validator cannot safely participate in consensus.",
                pubkeys,
                self.expected_pubkey
            );
            // Critical: Halt consensus participation
            std::process::exit(1); // Or disable consensus module
        }
        0
    });
    // metric update...
}
```

## Proof of Concept

```rust
// Rust integration test demonstrating the vulnerability

#[tokio::test]
async fn test_key_mismatch_race_condition() {
    // 1. Setup validator with network key K1
    let key_k1 = x25519::PrivateKey::generate(&mut rng);
    let pubkey_k1 = key_k1.public_key();
    let peer_id = account_address::from_identity_public_key(pubkey_k1);
    
    // 2. Establish connection with another validator
    let connection = establish_connection(peer_id, pubkey_k1).await;
    assert!(connection.is_established());
    
    // 3. Rotate keys on-chain to K2
    let key_k2 = x25519::PrivateKey::generate(&mut rng);
    let pubkey_k2 = key_k2.public_key();
    rotate_network_keys_onchain(peer_id, pubkey_k2).await;
    
    // 4. Trigger reconfiguration
    trigger_reconfiguration().await;
    
    // 5. Verify find_key_mismatches() detects mismatch but doesn't stop node
    // (Metric NETWORK_KEY_MISMATCH should be set to 1)
    assert_eq!(get_key_mismatch_metric(peer_id), 1);
    
    // 6. Verify existing connection persists
    tokio::time::sleep(Duration::from_secs(10)).await; // Past connectivity check interval
    assert!(connection.is_established(), "Connection should persist despite key mismatch");
    
    // 7. Verify consensus messages can still be sent
    let vote_msg = create_vote_msg(peer_id);
    let result = send_consensus_msg(connection, vote_msg).await;
    assert!(result.is_ok(), "Consensus participation continues with mismatched keys");
    
    // 8. Verify new connection attempts fail
    let new_connection_result = establish_connection(peer_id, pubkey_k1).await;
    assert!(new_connection_result.is_err(), "New connections should fail with old key");
}
```

**Notes**

The vulnerability has two distinct phases:
1. **Race window** (0-5 seconds): Between reconfiguration notification and the next `check_connectivity()` tick
2. **Persistent phase** (indefinite): Existing connections remain valid indefinitely because `close_stale_connections()` never validates connection keys against current trusted keys

The separation of network keys (x25519 for Noise protocol) and consensus keys (BLS12-381 for signing) means consensus message signatures remain cryptographically valid, but the network layer's trust model is violated. This is a protocol-level vulnerability in the connectivity management layer that undermines the security guarantees of the Noise handshake protocol.

### Citations

**File:** network/discovery/src/validator_set.rs (L44-66)
```rust
    fn find_key_mismatches(&self, onchain_keys: Option<&HashSet<x25519::PublicKey>>) {
        let mismatch = onchain_keys.map_or(0, |pubkeys| {
            if !pubkeys.contains(&self.expected_pubkey) {
                error!(
                    NetworkSchema::new(&self.network_context),
                    "Onchain pubkey {:?} differs from local pubkey {}",
                    pubkeys,
                    self.expected_pubkey
                );
                1
            } else {
                0
            }
        });

        NETWORK_KEY_MISMATCH
            .with_label_values(&[
                self.network_context.role().as_str(),
                self.network_context.network_id().as_str(),
                self.network_context.peer_id().short_str().as_str(),
            ])
            .set(mismatch);
    }
```

**File:** network/discovery/src/lib.rs (L141-166)
```rust
        while let Some(update) = source_stream.next().await {
            if let Ok(update) = update {
                trace!(
                    NetworkSchema::new(&network_context),
                    "{} Sending update: {:?}",
                    network_context,
                    update
                );
                let request = ConnectivityRequest::UpdateDiscoveredPeers(discovery_source, update);
                if let Err(error) = update_channel.try_send(request) {
                    inc_by_with_context(&DISCOVERY_COUNTS, &network_context, "send_failure", 1);
                    warn!(
                        NetworkSchema::new(&network_context),
                        "{} Failed to send update {:?}", network_context, error
                    );
                }
            } else {
                warn!(
                    NetworkSchema::new(&network_context),
                    "{} {} Discovery update failed {:?}",
                    &network_context,
                    discovery_source,
                    update
                );
            }
        }
```

**File:** network/framework/src/connectivity_manager/mod.rs (L415-427)
```rust
        let ticker = self.time_service.interval(self.connectivity_check_interval);
        tokio::pin!(ticker);

        info!(
            NetworkSchema::new(&self.network_context),
            "{} Starting ConnectivityManager actor", self.network_context
        );

        loop {
            self.event_id = self.event_id.wrapping_add(1);
            futures::select! {
                _ = ticker.select_next_some() => {
                    self.check_connectivity(&mut pending_dials).await;
```

**File:** network/framework/src/connectivity_manager/mod.rs (L484-503)
```rust
    async fn close_stale_connections(&mut self) {
        if let Some(trusted_peers) = self.get_trusted_peers() {
            // Identify stale peer connections
            let stale_peers = self
                .connected
                .iter()
                .filter(|(peer_id, _)| !trusted_peers.contains_key(peer_id))
                .filter_map(|(peer_id, metadata)| {
                    // If we're using server only auth, we need to not evict unknown peers
                    // TODO: We should prevent `Unknown` from discovery sources
                    if !self.mutual_authentication
                        && metadata.origin == ConnectionOrigin::Inbound
                        && (metadata.role == PeerRole::ValidatorFullNode
                            || metadata.role == PeerRole::Unknown)
                    {
                        None
                    } else {
                        Some(*peer_id) // The peer is stale
                    }
                });
```

**File:** config/src/config/network_config.rs (L41-41)
```rust
pub const CONNECTIVITY_CHECK_INTERVAL_MS: u64 = 5000;
```

**File:** network/framework/src/noise/handshake.rs (L488-500)
```rust
    fn authenticate_inbound(
        remote_peer_short: ShortHexStr,
        peer: &Peer,
        remote_public_key: &x25519::PublicKey,
    ) -> Result<PeerRole, NoiseHandshakeError> {
        if !peer.keys.contains(remote_public_key) {
            return Err(NoiseHandshakeError::UnauthenticatedClientPubkey(
                remote_peer_short,
                hex::encode(remote_public_key.as_slice()),
            ));
        }
        Ok(peer.role)
    }
```

**File:** consensus/src/round_manager.rs (L107-145)
```rust
impl UnverifiedEvent {
    pub fn verify(
        self,
        peer_id: PeerId,
        validator: &ValidatorVerifier,
        proof_cache: &ProofCache,
        quorum_store_enabled: bool,
        self_message: bool,
        max_num_batches: usize,
        max_batch_expiry_gap_usecs: u64,
    ) -> Result<VerifiedEvent, VerifyError> {
        let start_time = Instant::now();
        Ok(match self {
            UnverifiedEvent::ProposalMsg(p) => {
                if !self_message {
                    p.verify(peer_id, validator, proof_cache, quorum_store_enabled)?;
                    counters::VERIFY_MSG
                        .with_label_values(&["proposal"])
                        .observe(start_time.elapsed().as_secs_f64());
                }
                VerifiedEvent::ProposalMsg(p)
            },
            UnverifiedEvent::OptProposalMsg(p) => {
                if !self_message {
                    p.verify(peer_id, validator, proof_cache, quorum_store_enabled)?;
                    counters::VERIFY_MSG
                        .with_label_values(&["opt_proposal"])
                        .observe(start_time.elapsed().as_secs_f64());
                }
                VerifiedEvent::OptProposalMsg(p)
            },
            UnverifiedEvent::VoteMsg(v) => {
                if !self_message {
                    v.verify(peer_id, validator)?;
                    counters::VERIFY_MSG
                        .with_label_values(&["vote"])
                        .observe(start_time.elapsed().as_secs_f64());
                }
                VerifiedEvent::VoteMsg(v)
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L954-969)
```text
    /// Update the network and full node addresses of the validator. This only takes effect in the next epoch.
    public entry fun update_network_and_fullnode_addresses(
        operator: &signer,
        pool_address: address,
        new_network_addresses: vector<u8>,
        new_fullnode_addresses: vector<u8>,
    ) acquires StakePool, ValidatorConfig {
        check_stake_permission(operator);
        assert_reconfig_not_in_progress();
        assert_stake_pool_exists(pool_address);
        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        assert!(signer::address_of(operator) == stake_pool.operator_address, error::unauthenticated(ENOT_OPERATOR));
        assert!(exists<ValidatorConfig>(pool_address), error::not_found(EVALIDATOR_CONFIG));
        let validator_info = borrow_global_mut<ValidatorConfig>(pool_address);
        let old_network_addresses = validator_info.network_addresses;
        validator_info.network_addresses = new_network_addresses;
```
