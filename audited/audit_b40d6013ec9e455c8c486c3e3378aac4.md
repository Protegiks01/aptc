# Audit Report

## Title
BlockSTM Read-Before-Write Bypass: `read_state_value` Fails to Capture Module Reads in Parallel Execution

## Summary
The `read_state_value` method in `LatestView` bypasses BlockSTM's read tracking mechanism when enforcing read-before-write semantics for module writes. This causes reads to not be captured in `CapturedReads`, breaking BlockSTM's dependency validation and potentially leading to incorrect transaction ordering in parallel execution.

## Finding Description

The `StateStorageView` trait defines `read_state_value` with the explicit purpose of enforcing read-before-write for module writes: [1](#0-0) 

This method is called during module write conversion to register a read to the database: [2](#0-1) 

However, the implementation in `LatestView` for parallel execution **completely bypasses** BlockSTM's read tracking: [3](#0-2) 

This implementation calls `self.base_view.get_state_value()` which reads from the underlying storage layer, **not** from the multi-version hashmap (MVHashMap). Critically, it does **not** capture this read in the `CapturedReads` structure that BlockSTM uses for validation.

Compare this to proper read handling in `get_resource_state_value_impl`, which goes through `state.read_cached_data_by_kind`: [4](#0-3) 

And properly captures the read for validation: [5](#0-4) 

The `CapturedReads` structure is what BlockSTM uses during validation to detect conflicts: [6](#0-5) 

**The Exploit Path:**

1. Transaction A (index 10) publishes module M
2. Transaction B (index 20) also publishes module M
3. Both execute in parallel and call `read_state_value(module_state_key)` during `convert_modules_into_write_ops`
4. Both reads bypass MVHashMap and go to `base_view`, reading the pre-block state
5. **Neither read is captured in `CapturedReads.data_reads`**
6. Transaction A commits, writing module M to MVHashMap
7. Transaction B validates: The validation calls `validate_data_reads`: [7](#0-6) 

8. Since the `read_state_value` read was never captured, validation doesn't detect that the module state key changed from None to M
9. Transaction B may incorrectly validate or miss the dependency on transaction A

## Impact Explanation

This is a **HIGH severity** vulnerability:

1. **Protocol Violation**: Breaks BlockSTM's fundamental read-before-write invariant and dependency tracking mechanism
2. **Deterministic Execution Risk**: Different validators might execute the same block differently if validation behaves inconsistently
3. **Consensus Safety**: Violates the invariant that "all validators must produce identical state roots for identical blocks" if the missing read tracking causes divergent validation decisions
4. **Silent Failure**: The read appears to happen (no error), but enforcement is bypassed, making this a subtle correctness issue

Per Aptos Bug Bounty criteria, this qualifies as HIGH severity: "Significant protocol violations" in the parallel execution engine that could affect consensus determinism.

## Likelihood Explanation

**High Likelihood:**
- Occurs whenever multiple transactions in the same block publish/modify the same module
- Requires no special privileges - any user can submit module publish transactions
- The code path is exercised in normal blockchain operation
- The vulnerability is architectural, not dependent on specific timing or race conditions

**Triggering Conditions:**
- Two or more transactions in the same block write to the same module state key
- Parallel execution is enabled (standard in production)
- No special transaction parameters needed

## Recommendation

Fix the `read_state_value` implementation in `LatestView` to properly capture the read through BlockSTM's MVHashMap and read tracking mechanism:

```rust
fn read_state_value(&self, state_key: &Self::Key) -> Result<(), StateViewError> {
    // Use the proper read path that captures reads in CapturedReads
    self.get_resource_state_value_impl(
        state_key,
        UnknownOrLayout::Unknown,
        ReadKind::Exists
    )
    .map_err(|e| StateViewError::Unknown(format!("{:?}", e)))?;
    Ok(())
}
```

This ensures that:
1. The read goes through MVHashMap to check for writes from earlier transactions
2. The read is captured in `CapturedReads` for validation
3. BlockSTM's dependency tracking correctly detects conflicts
4. Read-before-write semantics are actually enforced

## Proof of Concept

Create two transactions in the same block that both publish the same module:

```rust
// Transaction A (index 5)
module 0xABCD::TestModule {
    public fun foo() {}
}

// Transaction B (index 10) - same module
module 0xABCD::TestModule {
    public fun bar() {}
}

// Expected: Transaction B should detect dependency on A during validation
// Actual: The read_state_value call doesn't capture the read, potentially
//         missing the dependency
```

**Validation Steps:**
1. Submit both transactions in the same block
2. Enable BlockSTM parallel execution
3. Observe that both transactions call `read_state_value` on the module state key
4. Verify that these reads are NOT present in `CapturedReads.data_reads`
5. Check that validation doesn't properly detect the read-write dependency
6. This violates the stated invariant that `read_state_value` "enforces read-before-write"

### Citations

**File:** aptos-move/aptos-vm-types/src/resolver.rs (L148-149)
```rust
    /// Reads the state value from the DB. Used to enforce read-before-write for module writes.
    fn read_state_value(&self, state_key: &Self::Key) -> Result<(), StateViewError>;
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/write_op_converter.rs (L110-123)
```rust
            // Enforce read-before-write:
            //   Modules can live in global cache, and so the DB may not see a module read even
            //   when it gets republished. This violates read-before-write property. Here, we on
            //   purpose enforce this by registering a read to the DB directly.
            //   Note that we also do it here so that in case of storage errors, only a  single
            //   transaction fails (e.g., if doing this read before commit in block executor we
            //   have no way to alter the transaction outputs at that point).
            self.remote.read_state_value(&state_key).map_err(|err| {
                let msg = format!(
                    "Error when enforcing read-before-write for module {}::{}: {:?}",
                    addr, name, err
                );
                PartialVMError::new(StatusCode::STORAGE_ERROR).with_message(msg)
            })?;
```

**File:** aptos-move/block-executor/src/view.rs (L669-673)
```rust
                    return self.captured_reads.borrow_mut().capture_data_read(
                        key.clone(),
                        DataRead::from_value_with_layout(version, value),
                        &target_kind,
                    );
```

**File:** aptos-move/block-executor/src/view.rs (L1538-1544)
```rust
        let mut ret = state.read_cached_data_by_kind(
            self.txn_idx,
            state_key,
            kind,
            layout.clone(),
            &|value, layout| self.patch_base_value(value, layout),
        )?;
```

**File:** aptos-move/block-executor/src/view.rs (L1799-1802)
```rust
    fn read_state_value(&self, state_key: &Self::Key) -> Result<(), StateViewError> {
        self.base_view.get_state_value(state_key)?;
        Ok(())
    }
```

**File:** aptos-move/block-executor/src/captured_reads.rs (L546-547)
```rust
pub(crate) struct CapturedReads<T: Transaction, K, DC, VC, S> {
    data_reads: HashMap<T::Key, DataRead<T::Value>>,
```

**File:** aptos-move/block-executor/src/executor.rs (L808-809)
```rust
        read_set.validate_data_reads(versioned_cache.data(), idx_to_validate)
            && read_set.validate_group_reads(versioned_cache.group_data(), idx_to_validate)
```
