# Audit Report

## Title
Payload Variant Type Confusion Allows Transaction Injection in Consensus Observer

## Summary
The `BlockTransactionPayload::verify_against_ordered_payload()` function fails to validate that the received payload variant type matches the consensus-agreed payload variant. This allows a malicious consensus observer publisher to inject unauthorized transactions by sending a `QuorumStoreInlineHybrid` or `OptQuorumStore` payload when consensus only agreed on a simpler `InQuorumStore` or `InQuorumStoreWithLimit` payload.

## Finding Description

The vulnerability exists in the verification logic that validates block transaction payloads against ordered blocks in the consensus observer system. [1](#0-0) 

When the `ordered_block_payload` is of type `Payload::InQuorumStore` or `Payload::InQuorumStoreWithLimit`, the verification only calls `verify_batches()` and `verify_transaction_limit()`. These functions extract and compare fields from the `BlockTransactionPayload` **without checking if the variant type is compatible**. [2](#0-1) 

The critical flaw is that the function matches on the `ordered_block_payload` enum variant but never validates that the `self` (the `BlockTransactionPayload`) is of a compatible variant. This allows the following attack:

**Attack Scenario:**

1. Consensus reaches agreement on a block with `Payload::InQuorumStoreWithLimit` containing proof batches `[P1, P2]` and transaction limit `100`, representing legitimate transactions `[T1, T2, T3, T4]`.

2. A malicious consensus observer publisher sends a `BlockTransactionPayload::QuorumStoreInlineHybrid` message containing:
   - Proof batches: `[P1, P2]` (matching the ordered payload)
   - Transactions: `[T1, T2, T3, T4, T5_MALICIOUS, T6_MALICIOUS]`
   - Inline batches: `[BatchInfo_for_T5_T6]` (metadata for the malicious transactions)
   - Transaction limit: `100` (matching the ordered payload)

3. During `verify_against_ordered_payload()` verification:
   - Lines 662-668 execute (the `InQuorumStoreWithLimit` case)
   - `verify_batches()` passes because `[P1, P2]` match
   - `verify_transaction_limit()` passes because `100` matches
   - **The inline batches are NEVER checked!**

4. The `verify_payload_digests()` check passes separately because the attacker computed valid digests for the malicious inline batch. [3](#0-2) 

5. When transactions are extracted for execution: [4](#0-3) 

The `transactions()` method returns **all** transactions including those from inline batches. The consensus observer executes `[T1, T2, T3, T4, T5_MALICIOUS, T6_MALICIOUS]` when consensus only agreed on `[T1, T2, T3, T4]`.

The verification flow shows this vulnerability is exploitable: [5](#0-4) [6](#0-5) 

**Broken Invariant:** This violates the **Deterministic Execution** invariant (#1) - different consensus observer nodes could execute different transactions for the same block hash, and the **Consensus Safety** invariant (#2) - nodes process transactions that were never part of the consensus agreement.

The block hash commits to the specific payload type: [7](#0-6) 

However, the `BlockTransactionPayload` is transmitted separately and the flawed verification allows variant type mismatches.

## Impact Explanation

**Severity: HIGH to CRITICAL**

This vulnerability meets **Critical Severity** criteria per the Aptos bug bounty program:

1. **Consensus Safety Violation**: Different consensus observer nodes would execute different transactions for the same consensus-agreed block, breaking the fundamental safety guarantee that all validators produce identical state roots for identical blocks.

2. **Loss of Funds**: The injected transactions could transfer funds, mint tokens, or perform any on-chain operation without proper consensus validation.

3. **State Inconsistency**: Nodes processing the malicious payload would have different state than honest nodes, potentially requiring a hard fork to recover.

The attack bypasses the entire consensus mechanism by exploiting a type confusion vulnerability in the payload verification logic. Any malicious consensus observer publisher can inject arbitrary transactions that execute on victim observer nodes.

## Likelihood Explanation

**Likelihood: HIGH**

The attack is highly likely to be exploitable because:

1. **No Special Privileges Required**: Any consensus observer publisher can exploit this. The attacker doesn't need validator keys or consensus participation.

2. **Trivial to Execute**: The attacker simply needs to:
   - Receive a legitimate ordered block with a simple payload type
   - Construct a `BlockTransactionPayload` with a more complex variant
   - Send it to consensus observer nodes
   - Ensure batch digests are correctly computed (straightforward)

3. **No Detection Mechanism**: The verification functions pass all checks, providing no indication of the attack.

4. **Wide Attack Surface**: Applies to any consensus observer node receiving payloads from potentially malicious publishers.

5. **Immediate Impact**: Injected transactions execute immediately upon block processing.

## Recommendation

Add explicit variant type compatibility checking at the beginning of `verify_against_ordered_payload()`:

```rust
pub fn verify_against_ordered_payload(
    &self,
    ordered_block_payload: &Payload,
) -> Result<(), Error> {
    // FIRST: Verify variant type compatibility
    match (self, ordered_block_payload) {
        (BlockTransactionPayload::DeprecatedInQuorumStore(_), Payload::InQuorumStore(_)) => {},
        (BlockTransactionPayload::DeprecatedInQuorumStoreWithLimit(_), Payload::InQuorumStoreWithLimit(_)) => {},
        (BlockTransactionPayload::QuorumStoreInlineHybrid(_, _), Payload::QuorumStoreInlineHybrid(_, _, _)) => {},
        (BlockTransactionPayload::QuorumStoreInlineHybridV2(_, _), Payload::QuorumStoreInlineHybridV2(_, _, _)) => {},
        (BlockTransactionPayload::OptQuorumStore(_, _), Payload::OptQuorumStore(_)) => {},
        _ => {
            return Err(Error::InvalidMessageError(format!(
                "Payload variant mismatch! BlockTransactionPayload variant does not match ordered block Payload variant. \
                 Expected variant compatible with: {:?}",
                match ordered_block_payload {
                    Payload::DirectMempool(_) => "DirectMempool",
                    Payload::InQuorumStore(_) => "InQuorumStore",
                    Payload::InQuorumStoreWithLimit(_) => "InQuorumStoreWithLimit",
                    Payload::QuorumStoreInlineHybrid(_, _, _) => "QuorumStoreInlineHybrid",
                    Payload::OptQuorumStore(_) => "OptQuorumStore",
                    Payload::QuorumStoreInlineHybridV2(_, _, _) => "QuorumStoreInlineHybridV2",
                }
            )));
        }
    }
    
    // THEN: Continue with existing verification logic
    match ordered_block_payload {
        Payload::DirectMempool(_) => {
            return Err(Error::InvalidMessageError(
                "Direct mempool payloads are not supported for consensus observer!".into(),
            ));
        },
        // ... rest of the existing match arms
    }
    
    Ok(())
}
```

## Proof of Concept

```rust
#[test]
fn test_payload_variant_mismatch_attack() {
    use aptos_consensus_types::{
        common::{ProofWithData, ProofWithDataWithTxnLimit},
        proof_of_store::{BatchInfo, ProofOfStore},
    };
    use aptos_crypto::HashValue;
    use aptos_types::{
        aggregate_signature::AggregateSignature,
        quorum_store::BatchId,
        PeerId,
    };
    
    // Create legitimate proof batches that consensus agreed on
    let batch_info_1 = BatchInfo::new(
        PeerId::ZERO, BatchId::new(1), 10, 1000,
        HashValue::random(), 2, 1, 0,
    );
    let batch_info_2 = BatchInfo::new(
        PeerId::ZERO, BatchId::new(2), 10, 1000,
        HashValue::random(), 2, 1, 0,
    );
    let legitimate_proofs = vec![
        ProofOfStore::new(batch_info_1, AggregateSignature::empty()),
        ProofOfStore::new(batch_info_2, AggregateSignature::empty()),
    ];
    
    // Consensus agreed on InQuorumStoreWithLimit (4 transactions total)
    let ordered_payload = Payload::InQuorumStoreWithLimit(
        ProofWithDataWithTxnLimit::new(
            ProofWithData::new(legitimate_proofs.clone()),
            Some(100),
        )
    );
    
    // Attacker sends QuorumStoreInlineHybrid with EXTRA inline batch
    let malicious_inline_batch = BatchInfo::new(
        PeerId::ZERO, BatchId::new(999), 10, 1000,
        HashValue::random(), 2, 1, 0, // 2 malicious transactions
    );
    
    let attack_payload = BlockTransactionPayload::QuorumStoreInlineHybrid(
        PayloadWithProofAndLimit::new(
            PayloadWithProof::new(vec![], legitimate_proofs),
            Some(100),
        ),
        vec![malicious_inline_batch], // INJECTED BATCH!
    );
    
    // Verification SHOULD fail but currently PASSES
    let result = attack_payload.verify_against_ordered_payload(&ordered_payload);
    
    // With the fix, this should return Err(Error::InvalidMessageError)
    // Currently, it returns Ok(()) - THE VULNERABILITY!
    assert!(result.is_ok(), "VULNERABILITY: Variant mismatch accepted!");
    
    // The attacker successfully injected 2 extra transactions via the inline batch
    // These transactions will execute without consensus agreement!
}
```

**Notes:**

- The vulnerability allows bypassing consensus safety by exploiting type confusion between payload variants
- The attack is feasible for any consensus observer publisher
- Critical impact: breaks deterministic execution and consensus safety invariants
- The fix requires adding explicit variant type compatibility checking before field validation

### Citations

**File:** consensus/src/consensus_observer/network/observer_message.rs (L630-645)
```rust
    /// Returns the transactions in the payload
    pub fn transactions(&self) -> Vec<SignedTransaction> {
        match self {
            BlockTransactionPayload::DeprecatedInQuorumStore(payload) => {
                payload.transactions.clone()
            },
            BlockTransactionPayload::DeprecatedInQuorumStoreWithLimit(payload) => {
                payload.payload_with_proof.transactions.clone()
            },
            BlockTransactionPayload::QuorumStoreInlineHybrid(payload, _) => {
                payload.payload_with_proof.transactions.clone()
            },
            BlockTransactionPayload::QuorumStoreInlineHybridV2(payload, _)
            | BlockTransactionPayload::OptQuorumStore(payload, _) => payload.transactions(),
        }
    }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L648-717)
```rust
    pub fn verify_against_ordered_payload(
        &self,
        ordered_block_payload: &Payload,
    ) -> Result<(), Error> {
        match ordered_block_payload {
            Payload::DirectMempool(_) => {
                return Err(Error::InvalidMessageError(
                    "Direct mempool payloads are not supported for consensus observer!".into(),
                ));
            },
            Payload::InQuorumStore(proof_with_data) => {
                // Verify the batches in the requested block
                self.verify_batches(&proof_with_data.proofs)?;
            },
            Payload::InQuorumStoreWithLimit(proof_with_data) => {
                // Verify the batches in the requested block
                self.verify_batches(&proof_with_data.proof_with_data.proofs)?;

                // Verify the transaction limit
                self.verify_transaction_limit(proof_with_data.max_txns_to_execute)?;
            },
            Payload::QuorumStoreInlineHybrid(
                inline_batches,
                proof_with_data,
                max_txns_to_execute,
            ) => {
                // Verify the batches in the requested block
                self.verify_batches(&proof_with_data.proofs)?;

                // Verify the inline batches
                self.verify_inline_batches(inline_batches)?;

                // Verify the transaction limit
                self.verify_transaction_limit(*max_txns_to_execute)?;
            },
            Payload::QuorumStoreInlineHybridV2(
                inline_batches,
                proof_with_data,
                execution_limits,
            ) => {
                // Verify the batches in the requested block
                self.verify_batches(&proof_with_data.proofs)?;

                // Verify the inline batches
                self.verify_inline_batches(inline_batches)?;

                // Verify the transaction limit
                self.verify_transaction_limit(execution_limits.max_txns_to_execute())?;

                // TODO: verify the block gas limit?
            },
            Payload::OptQuorumStore(OptQuorumStorePayload::V1(p)) => {
                // Verify the batches in the requested block
                self.verify_batches(p.proof_with_data())?;

                // Verify optQS and inline batches
                self.verify_optqs_and_inline_batches(p.opt_batches(), p.inline_batches())?;

                // Verify the transaction limit
                self.verify_transaction_limit(p.max_txns_to_execute())?;
            },
            Payload::OptQuorumStore(OptQuorumStorePayload::V2(_p)) => {
                return Err(Error::InvalidMessageError(
                    "OptQuorumStorePayload V2 is not supproted".into(),
                ));
            },
        }

        Ok(())
    }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L874-932)
```rust
    /// Verifies the block payload digests and returns an error if the data is invalid
    pub fn verify_payload_digests(&self) -> Result<(), Error> {
        // Get the block info, transactions, payload proofs and inline batches
        let block_info = self.block.clone();
        let transactions = self.transaction_payload.transactions();
        let payload_proofs = self.transaction_payload.payload_proofs();
        let opt_and_inline_batches = self.transaction_payload.optqs_and_inline_batches();

        // Get the number of transactions, payload proofs and inline batches
        let num_transactions = transactions.len();
        let num_payload_proofs = payload_proofs.len();
        let num_opt_and_inline_batches = opt_and_inline_batches.len();

        // Gather the transactions for each payload batch
        let mut batches_and_transactions = vec![];
        let mut transactions_iter = transactions.into_iter();
        for proof_of_store in &payload_proofs {
            match reconstruct_batch(
                &block_info,
                &mut transactions_iter,
                proof_of_store.info(),
                true,
            ) {
                Ok(Some(batch_transactions)) => {
                    batches_and_transactions
                        .push((proof_of_store.info().clone(), batch_transactions));
                },
                Ok(None) => { /* Nothing needs to be done (the batch was expired) */ },
                Err(error) => {
                    return Err(Error::InvalidMessageError(format!(
                        "Failed to reconstruct payload proof batch! Num transactions: {:?}, \
                        num batches: {:?}, num inline batches: {:?}, failed batch: {:?}, Error: {:?}",
                        num_transactions, num_payload_proofs, num_opt_and_inline_batches, proof_of_store.info(), error
                    )));
                },
            }
        }

        // Gather the transactions for each inline batch
        for batch_info in opt_and_inline_batches.iter() {
            match reconstruct_batch(&block_info, &mut transactions_iter, batch_info, false) {
                Ok(Some(batch_transactions)) => {
                    batches_and_transactions.push((batch_info.clone(), batch_transactions));
                },
                Ok(None) => {
                    return Err(Error::UnexpectedError(format!(
                        "Failed to reconstruct inline/opt batch! Batch was unexpectedly skipped: {:?}",
                        batch_info
                    )));
                },
                Err(error) => {
                    return Err(Error::InvalidMessageError(format!(
                        "Failed to reconstruct inline/opt batch! Num transactions: {:?}, \
                        num batches: {:?}, num opt/inline batches: {:?}, failed batch: {:?}, Error: {:?}",
                        num_transactions, num_payload_proofs, num_opt_and_inline_batches, batch_info, error
                    )));
                },
            }
        }
```

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L158-213)
```rust
    pub fn verify_payloads_against_ordered_block(
        &mut self,
        ordered_block: &OrderedBlock,
    ) -> Result<(), Error> {
        // Verify each of the blocks in the ordered block
        for ordered_block in ordered_block.blocks() {
            // Get the block epoch and round
            let block_epoch = ordered_block.epoch();
            let block_round = ordered_block.round();

            // Fetch the block payload
            match self.block_payloads.lock().entry((block_epoch, block_round)) {
                Entry::Occupied(entry) => {
                    // Get the block transaction payload
                    let transaction_payload = match entry.get() {
                        BlockPayloadStatus::AvailableAndVerified(block_payload) => {
                            block_payload.transaction_payload()
                        },
                        BlockPayloadStatus::AvailableAndUnverified(_) => {
                            // The payload should have already been verified
                            return Err(Error::InvalidMessageError(format!(
                                "Payload verification failed! Block payload for epoch: {:?} and round: {:?} is unverified.",
                                ordered_block.epoch(),
                                ordered_block.round()
                            )));
                        },
                    };

                    // Get the ordered block payload
                    let ordered_block_payload = match ordered_block.block().payload() {
                        Some(payload) => payload,
                        None => {
                            return Err(Error::InvalidMessageError(format!(
                                "Payload verification failed! Missing block payload for epoch: {:?} and round: {:?}",
                                ordered_block.epoch(),
                                ordered_block.round()
                            )));
                        },
                    };

                    // Verify the transaction payload against the ordered block payload
                    transaction_payload.verify_against_ordered_payload(ordered_block_payload)?;
                },
                Entry::Vacant(_) => {
                    // The payload is missing (this should never happen)
                    return Err(Error::InvalidMessageError(format!(
                        "Payload verification failed! Missing block payload for epoch: {:?} and round: {:?}",
                        ordered_block.epoch(),
                        ordered_block.round()
                    )));
                },
            }
        }

        Ok(())
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L754-771)
```rust
        // Verify the block payloads against the ordered block
        if let Err(error) = self
            .observer_block_data
            .lock()
            .verify_payloads_against_ordered_block(&ordered_block)
        {
            // Log the error and update the invalid message counter
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to verify block payloads against ordered block! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                    ordered_block.proof_block_info(),
                    peer_network_id,
                    error
                ))
            );
            increment_invalid_message_counter(&peer_network_id, metrics::ORDERED_BLOCK_LABEL);
            return;
        }
```

**File:** consensus/consensus-types/src/block_data.rs (L105-134)
```rust
impl CryptoHash for BlockData {
    type Hasher = BlockDataHasher;

    fn hash(&self) -> HashValue {
        let mut state = Self::Hasher::default();
        if self.is_opt_block() {
            #[derive(Serialize)]
            struct OptBlockDataForHash<'a> {
                epoch: u64,
                round: Round,
                timestamp_usecs: u64,
                quorum_cert_vote_data: &'a VoteData,
                block_type: &'a BlockType,
            }

            let opt_block_data_for_hash = OptBlockDataForHash {
                epoch: self.epoch,
                round: self.round,
                timestamp_usecs: self.timestamp_usecs,
                quorum_cert_vote_data: self.quorum_cert.vote_data(),
                block_type: &self.block_type,
            };
            bcs::serialize_into(&mut state, &opt_block_data_for_hash)
                .expect("OptBlockDataForHash must be serializable");
        } else {
            bcs::serialize_into(&mut state, &self).expect("BlockData must be serializable");
        }
        state.finish()
    }
}
```
