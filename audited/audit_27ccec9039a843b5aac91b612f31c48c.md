# Audit Report

## Title
Peer Scoring Bypass via Response Context Loss in Compression Validation

## Summary
The `send_request_to_peer_and_decode()` function in `state-sync/aptos-data-client/src/client.rs` separates the response context from the storage response at line 737 using `into_parts()`. When compression validation fails (lines 738-748), the function returns early without calling the response callback, causing the peer scoring system to fail to penalize peers sending malformed responses.

## Finding Description

The Aptos data client maintains a peer scoring system to track the quality of responses from network peers and filter out unreliable ones. When a peer sends a bad response, the system should call `response_callback.notify_bad_response()` to update the peer's score, eventually causing low-scoring peers to be ignored. [1](#0-0) 

After separating the context and response at line 737, if the compression validation fails (requested compressed but got uncompressed, or vice versa), the function returns an error immediately. The `context` containing the `response_callback` is dropped without being used, so the peer is never penalized.

This contrasts with the correct error handling later in the function: [2](#0-1) 

Where the callback is properly invoked before returning an error.

The peer scoring system is designed to penalize bad peers: [3](#0-2) 

**Attack Path:**
1. Malicious peer identifies compression setting expected by requester
2. Peer sends response with opposite compression setting (compressed when uncompressed expected, or vice versa)
3. Validation at lines 738-748 fails and returns early
4. Context with callback is dropped - peer score never updated
5. Peer repeats attack without penalty, evading the scoring system

## Impact Explanation

This issue falls into **Medium Severity** according to Aptos bug bounty criteria as it represents a "significant protocol violation" of the peer reputation system, though it does not directly cause funds loss or consensus issues.

**Impact:**
- Malicious peers can evade the peer scoring/reputation system
- State synchronization quality degradation as bad peers aren't filtered
- Increased bandwidth and computational waste from repeated bad responses
- Potential for coordinated attacks by multiple malicious peers to impair state sync for new nodes
- Impacts network reliability and decentralization (new validators struggle to sync)

While this doesn't directly threaten consensus safety or funds, the peer scoring system is a critical component of state sync reliability. Compromising it could impact the network's ability to onboard new validators and maintain decentralization.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is easily exploitable:
- No special privileges required - any network peer can exploit it
- Simple attack vector - just send responses with incorrect compression flag
- No complex timing or race conditions needed
- Attacker can repeat indefinitely without detection
- Low cost to attacker (just network bandwidth)

The only limitation is that the attacker must be selected as a peer to serve data requests, but the data client's multi-peer selection strategy means malicious peers will frequently be chosen.

## Recommendation

The response callback must be invoked before any early returns after `into_parts()` is called. The fix is to call `context.response_callback.notify_bad_response()` with an appropriate error type before returning:

```rust
let (context, storage_response) = storage_response.into_parts();
if request.use_compression && !storage_response.is_compressed() {
    context
        .response_callback
        .notify_bad_response(ResponseError::InvalidData);
    return Err(Error::InvalidResponse(format!(
        "Requested compressed data, but the response was uncompressed! Response: {:?}",
        storage_response.get_label()
    )));
} else if !request.use_compression && storage_response.is_compressed() {
    context
        .response_callback
        .notify_bad_response(ResponseError::InvalidData);
    return Err(Error::InvalidResponse(format!(
        "Requested uncompressed data, but the response was compressed! Response: {:?}",
        storage_response.get_label()
    )));
}
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_compression_mismatch_penalizes_peer() {
    use aptos_storage_service_types::responses::{StorageServiceResponse, DataResponse};
    
    // Setup: Create a data client and mock peer
    let (data_client, _poller) = create_test_data_client();
    let peer = create_mock_peer();
    
    // Track initial peer score
    let initial_score = data_client.get_peer_states().get_score(&peer);
    
    // Step 1: Attacker sends response with wrong compression
    // Request asks for compressed=true but response is uncompressed
    let request = StorageServiceRequest::new(
        DataRequest::GetStorageServerSummary,
        true, // use_compression = true
    );
    
    let bad_response = StorageServiceResponse::RawResponse(
        DataResponse::StorageServerSummary(StorageServerSummary::default())
    );
    // Note: response is RawResponse (uncompressed) but request wanted compression
    
    // Step 2: Send request (will fail compression validation)
    let result = data_client
        .send_request_to_peer_and_decode::<StorageServerSummary, _>(
            peer,
            request,
            5000,
        )
        .await;
    
    // Step 3: Verify error is returned
    assert!(result.is_err());
    assert!(matches!(result.unwrap_err(), Error::InvalidResponse(_)));
    
    // Step 4: VULNERABILITY - Verify peer score was NOT updated
    let final_score = data_client.get_peer_states().get_score(&peer);
    
    // This assertion SHOULD FAIL but currently PASSES due to the bug
    // The peer score should have decreased but it remains the same
    assert_eq!(initial_score, final_score, 
        "BUG: Peer score unchanged despite sending invalid response!");
    
    // Expected behavior: final_score < initial_score
    // Actual behavior: final_score == initial_score (callback never called)
}
```

The PoC demonstrates that a peer sending responses with incorrect compression is not penalized, allowing them to repeatedly send bad responses without their score being affected.

**Notes:**
- The vulnerability is specific to the compression validation error path after `into_parts()` is called
- Other error paths correctly invoke the callback (e.g., type mismatch at line 758-760)
- The fix is straightforward: ensure all error paths after `into_parts()` call the callback before returning

### Citations

**File:** state-sync/aptos-data-client/src/client.rs (L737-748)
```rust
        let (context, storage_response) = storage_response.into_parts();
        if request.use_compression && !storage_response.is_compressed() {
            return Err(Error::InvalidResponse(format!(
                "Requested compressed data, but the response was uncompressed! Response: {:?}",
                storage_response.get_label()
            )));
        } else if !request.use_compression && storage_response.is_compressed() {
            return Err(Error::InvalidResponse(format!(
                "Requested uncompressed data, but the response was compressed! Response: {:?}",
                storage_response.get_label()
            )));
        }
```

**File:** state-sync/aptos-data-client/src/client.rs (L756-761)
```rust
                Err(err) => {
                    context
                        .response_callback
                        .notify_bad_response(ResponseError::InvalidPayloadDataType);
                    Err(err.into())
                },
```

**File:** state-sync/aptos-data-client/src/client.rs (L1240-1246)
```rust
impl ResponseCallback for AptosNetResponseCallback {
    fn notify_bad_response(&self, error: ResponseError) {
        let error_type = ErrorType::from(error);
        self.data_client
            .notify_bad_response(self.id, self.peer, &self.request, error_type);
    }
}
```
