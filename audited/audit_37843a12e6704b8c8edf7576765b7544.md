# Audit Report

## Title
Consensus Observer Pending Block Drop Attack via Unvalidated BlockPayload Round Numbers

## Summary
A malicious network peer can send BlockPayload messages with artificially high round numbers to force consensus observer nodes to incorrectly drop all legitimate pending blocks, causing a denial of service and preventing the observer from processing new blocks.

## Finding Description

The consensus observer system processes BlockPayload and OrderedBlock messages separately from network peers. The vulnerability exists in how BlockPayload messages are validated before being used to remove pending blocks. [1](#0-0) 

The `BlockPayload` structure contains a `BlockInfo` (with epoch and round fields) and a `BlockTransactionPayload` (with ProofOfStore batch data). The critical issue is that the `BlockInfo` epoch and round values are **not cryptographically bound** to the ProofOfStore signatures. [2](#0-1) 

The `verify_payload_signatures()` method only verifies the ProofOfStore signatures on transaction batches, which are signed by validators. However, ProofOfStore signatures are on `BatchInfo` structures: [3](#0-2) 

The `BatchInfo` contains batch metadata (author, batch_id, epoch, expiration, digest, etc.) but **does not include the block round number**. This means an attacker can:

1. Take valid ProofOfStore data from any legitimate block
2. Create a new BlockPayload with an artificially high round number in the BlockInfo
3. Send this crafted payload to an observer node

The attack succeeds because in the BlockPayload processing flow: [4](#0-3) 

The `process_block_payload_message()` function extracts the epoch and round from the BlockPayload's BlockInfo (lines 362-364), verifies the payload digests and signatures (which pass because the ProofOfStore is legitimate), and then calls `order_ready_pending_block()` with the **unvalidated** round number (line 436). [5](#0-4) 

This leads to: [6](#0-5) 

Which calls the vulnerable function: [7](#0-6) 

At lines 210-212, the function splits blocks at `received_payload_round + 1`. Then at lines 231-239, **all blocks before the malicious round are dropped** with only an info log, without any validation that the round number is legitimate.

The dropped blocks include legitimate pending OrderedBlocks that arrived earlier and are waiting for their payloads. When the attacker sends a payload with round 9999 while legitimate blocks are at rounds 100-110, all those legitimate blocks are silently discarded.

## Impact Explanation

**Severity: High**

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria for the following reasons:

1. **Validator Node Slowdowns**: Affected consensus observer nodes will repeatedly drop legitimate blocks and fail to make progress, causing significant operational degradation.

2. **Significant Protocol Violations**: The attack violates the expected behavior of the consensus observer protocol, where legitimate blocks should be processed in order and not arbitrarily discarded based on unvalidated peer messages.

3. **Denial of Service**: While not a complete network failure, this attack can render individual observer nodes unable to track consensus, forcing them to rely on state sync recovery mechanisms and degrading their ability to serve their intended purpose.

The impact is limited to consensus observer nodes (not full validators), preventing this from reaching Critical severity. However, observer nodes are critical infrastructure for applications, wallets, and services that need to monitor the blockchain without running full validator nodes.

## Likelihood Explanation

**Likelihood: High**

The attack is highly likely to succeed because:

1. **Low Barrier to Entry**: Any network peer can send BlockPayload messages to observer nodes. No special privileges, stake, or validator access is required.

2. **Readily Available Materials**: An attacker can obtain valid ProofOfStore data from any public block on the network. These signatures are meant to be public and verifiable.

3. **No Rate Limiting**: The code does not appear to implement specific rate limiting or reputation tracking for BlockPayload messages from specific peers.

4. **Simple Exploitation**: The attack requires only:
   - Crafting a BlockPayload with a high round number (e.g., 999999)
   - Reusing valid ProofOfStore from any legitimate block
   - Sending the message to target observer nodes

5. **Repeatable**: The attacker can send multiple such payloads to continuously disrupt observer nodes.

## Recommendation

**Immediate Fix**: Add validation to ensure that BlockPayload messages can only be processed if they correspond to known OrderedBlock messages, or implement strict bounds checking on round numbers.

**Option 1: Validate Against Expected Blocks**
Before calling `order_ready_pending_block()`, verify that an OrderedBlock exists for the given epoch and round:

```rust
// In process_block_payload_message(), before line 436:
// Only process ready blocks if we have a corresponding ordered block or pending block
let has_corresponding_block = self.observer_block_data
    .lock()
    .existing_pending_block_for_round(block_epoch, block_round);
    
if verified_payload && has_corresponding_block {
    self.order_ready_pending_block(block_epoch, block_round).await;
}
```

**Option 2: Implement Round Bounds Checking**
In `remove_ready_block()`, add validation that the received round is within reasonable bounds:

```rust
// In pending_blocks.rs, at the start of remove_ready_block():
// Validate that the round is not suspiciously far in the future
let max_expected_round = self.blocks_without_payloads
    .last_key_value()
    .map(|((_, round), _)| round + MAX_ROUND_LOOKAHEAD)
    .unwrap_or(received_payload_round);
    
if received_payload_round > max_expected_round {
    warn!(
        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
            "Rejecting payload with suspiciously high round: {:?}, max expected: {:?}",
            received_payload_round, max_expected_round
        ))
    );
    return None;
}
```

**Option 3: Cryptographically Bind BlockInfo to Payloads**
The most robust solution is to ensure BlockPayload messages include a signature over the complete BlockInfo (including round), not just the ProofOfStore batches. This would require protocol-level changes but provides the strongest guarantee.

## Proof of Concept

```rust
// This PoC demonstrates how an attacker crafts a malicious BlockPayload

use aptos_types::block_info::BlockInfo;
use aptos_crypto::HashValue;
use consensus_observer::network::observer_message::{BlockPayload, BlockTransactionPayload};

// Attacker creates a BlockInfo with artificially high round
let malicious_block_info = BlockInfo::new(
    10,                          // current epoch
    999999,                      // artificially high round
    HashValue::random(),         // block id
    HashValue::random(),         // executed state id
    0,                          // version
    1000000000,                 // timestamp
    None,                       // next epoch state
);

// Attacker reuses valid ProofOfStore from a legitimate block
// (obtained by observing network traffic or querying a public node)
let legitimate_transaction_payload = /* obtained from real block */;

// Create the malicious payload
let malicious_payload = BlockPayload::new(
    malicious_block_info,
    legitimate_transaction_payload
);

// Send to observer node - the verification will pass:
// 1. verify_payload_digests() checks transaction hashes match batches ✓
// 2. verify_payload_signatures() checks ProofOfStore signatures ✓
// 3. order_ready_pending_block(10, 999999) is called
// 4. All pending blocks with rounds < 999999 are dropped

// Result: Observer node drops all legitimate pending blocks
```

**Test Scenario:**
1. Observer node has pending blocks for rounds 100-110 waiting for payloads
2. Attacker sends BlockPayload with round=999999 and valid ProofOfStore
3. All pending blocks (rounds 100-110) are dropped from pending_block_store
4. When legitimate payloads arrive for rounds 100-110, the corresponding OrderedBlocks are already gone
5. Observer node cannot process these blocks and falls behind

## Notes

The vulnerability exists specifically in the consensus observer component, which is used by nodes that want to follow consensus without participating as full validators. While this limits the impact compared to a vulnerability in core consensus, observer nodes are still critical infrastructure for the Aptos ecosystem.

The root cause is the architectural decision to process BlockPayload and OrderedBlock messages independently, combined with insufficient validation of the BlockInfo fields in BlockPayload messages. The ProofOfStore signature verification provides authenticity for the transaction batches but does not validate the block metadata (epoch, round, block ID) claimed in the BlockInfo.

### Citations

**File:** consensus/src/consensus_observer/network/observer_message.rs (L841-852)
```rust
pub struct BlockPayload {
    block: BlockInfo,
    transaction_payload: BlockTransactionPayload,
}

impl BlockPayload {
    pub fn new(block: BlockInfo, transaction_payload: BlockTransactionPayload) -> Self {
        Self {
            block,
            transaction_payload,
        }
    }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L962-981)
```rust
    pub fn verify_payload_signatures(&self, epoch_state: &EpochState) -> Result<(), Error> {
        // Create a dummy proof cache to verify the proofs
        let proof_cache = ProofCache::new(1);

        // Verify each of the proof signatures (in parallel)
        let payload_proofs = self.transaction_payload.payload_proofs();
        let validator_verifier = &epoch_state.verifier;
        payload_proofs
            .par_iter()
            .with_min_len(2)
            .try_for_each(|proof| proof.verify(validator_verifier, &proof_cache))
            .map_err(|error| {
                Error::InvalidMessageError(format!(
                    "Failed to verify the payload proof signatures! Error: {:?}",
                    error
                ))
            })?;

        Ok(()) // All proofs are correctly signed
    }
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L49-58)
```rust
pub struct BatchInfo {
    author: PeerId,
    batch_id: BatchId,
    epoch: u64,
    expiration: u64,
    digest: HashValue,
    num_txns: u64,
    num_bytes: u64,
    gas_bucket_start: u64,
}
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L341-353)
```rust
    async fn order_ready_pending_block(&mut self, block_epoch: u64, block_round: Round) {
        // Remove any ready pending block
        let pending_block_with_metadata = self
            .observer_block_data
            .lock()
            .remove_ready_pending_block(block_epoch, block_round);

        // Process the ready ordered block (if it exists)
        if let Some(pending_block_with_metadata) = pending_block_with_metadata {
            self.process_ordered_block(pending_block_with_metadata)
                .await;
        }
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L355-438)
```rust
    /// Processes the block payload message
    async fn process_block_payload_message(
        &mut self,
        peer_network_id: PeerNetworkId,
        message_received_time: Instant,
        block_payload: BlockPayload,
    ) {
        // Get the epoch and round for the block
        let block_epoch = block_payload.epoch();
        let block_round = block_payload.round();

        // Determine if the payload is behind the last ordered block, or if it already exists
        let last_ordered_block = self.observer_block_data.lock().get_last_ordered_block();
        let payload_out_of_date =
            (block_epoch, block_round) <= (last_ordered_block.epoch(), last_ordered_block.round());
        let payload_exists = self
            .observer_block_data
            .lock()
            .existing_payload_entry(&block_payload);

        // If the payload is out of date or already exists, ignore it
        if payload_out_of_date || payload_exists {
            // Update the metrics for the dropped block payload
            update_metrics_for_dropped_block_payload_message(peer_network_id, &block_payload);
            return;
        }

        // Update the metrics for the received block payload
        update_metrics_for_block_payload_message(peer_network_id, &block_payload);

        // Verify the block payload digests
        if let Err(error) = block_payload.verify_payload_digests() {
            // Log the error and update the invalid message counter
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Failed to verify block payload digests! Ignoring block: {:?}, from peer: {:?}. Error: {:?}",
                    block_payload.block(), peer_network_id,
                    error
                ))
            );
            increment_invalid_message_counter(&peer_network_id, metrics::BLOCK_PAYLOAD_LABEL);
            return;
        }

        // If the payload is for the current epoch, verify the proof signatures
        let epoch_state = self.get_epoch_state();
        let verified_payload = if block_epoch == epoch_state.epoch {
            // Verify the block proof signatures
            if let Err(error) = block_payload.verify_payload_signatures(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify block payload signatures! Ignoring block: {:?}, from peer: {:?}. Error: {:?}",
                        block_payload.block(), peer_network_id, error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::BLOCK_PAYLOAD_LABEL);
                return;
            }

            true // We have successfully verified the signatures
        } else {
            false // We can't verify the signatures yet
        };

        // Update the latency metrics for block payload processing
        update_message_processing_latency_metrics(
            message_received_time,
            &peer_network_id,
            metrics::BLOCK_PAYLOAD_LABEL,
        );

        // Update the payload store with the payload
        self.observer_block_data
            .lock()
            .insert_block_payload(block_payload, verified_payload);

        // Check if there are blocks that were missing payloads but are
        // now ready because of the new payload. Note: this should only
        // be done if the payload has been verified correctly.
        if verified_payload {
            self.order_ready_pending_block(block_epoch, block_round)
                .await;
        }
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L244-254)
```rust
    pub fn remove_ready_pending_block(
        &mut self,
        received_payload_epoch: u64,
        received_payload_round: Round,
    ) -> Option<Arc<PendingBlockWithMetadata>> {
        self.pending_block_store.remove_ready_block(
            received_payload_epoch,
            received_payload_round,
            &mut self.block_payload_store,
        )
    }
```

**File:** consensus/src/consensus_observer/observer/pending_blocks.rs (L200-256)
```rust
    pub fn remove_ready_block(
        &mut self,
        received_payload_epoch: u64,
        received_payload_round: Round,
        block_payload_store: &mut BlockPayloadStore,
    ) -> Option<Arc<PendingBlockWithMetadata>> {
        // Calculate the round at which to split the blocks
        let split_round = received_payload_round.saturating_add(1);

        // Split the blocks at the epoch and round
        let mut blocks_at_higher_rounds = self
            .blocks_without_payloads
            .split_off(&(received_payload_epoch, split_round));

        // Check if the last block is ready (this should be the only ready block).
        // Any earlier blocks are considered out-of-date and will be dropped.
        let mut ready_block = None;
        if let Some((epoch_and_round, pending_block)) = self.blocks_without_payloads.pop_last() {
            // If all payloads exist for the block, then the block is ready
            if block_payload_store.all_payloads_exist(pending_block.ordered_block().blocks()) {
                ready_block = Some(pending_block);
            } else {
                // Otherwise, check if we're still waiting for higher payloads for the block
                let last_pending_block_round = pending_block.ordered_block().last_block().round();
                if last_pending_block_round > received_payload_round {
                    blocks_at_higher_rounds.insert(epoch_and_round, pending_block);
                }
            }
        }

        // Check if any out-of-date blocks are going to be dropped
        if !self.blocks_without_payloads.is_empty() {
            info!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Dropped {:?} out-of-date pending blocks before epoch and round: {:?}",
                    self.blocks_without_payloads.len(),
                    (received_payload_epoch, received_payload_round)
                ))
            );
        }

        // TODO: optimize this flow!

        // Clear all blocks from the pending block stores
        self.clear_missing_blocks();

        // Update the pending block stores to only include the blocks at higher rounds
        self.blocks_without_payloads = blocks_at_higher_rounds;
        for pending_block in self.blocks_without_payloads.values() {
            let first_block = pending_block.ordered_block().first_block();
            self.blocks_without_payloads_by_hash
                .insert(first_block.id(), pending_block.clone());
        }

        // Return the ready block (if one exists)
        ready_block
    }
```
