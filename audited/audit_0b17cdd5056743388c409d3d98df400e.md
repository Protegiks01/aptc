# Audit Report

## Title
Missing Validation in EventFilter Deserialization Allows Invalid Filter States in Indexer-gRPC Service

## Summary
The `EventFilter` struct in the indexer-grpc transaction filtering system implements validation logic requiring at least one field to be set, but this validation is never enforced during deserialization from protobuf or JSON, allowing creation of invalid filter states that match all events instead of none.

## Finding Description

The `EventFilter` struct has a `validate_state()` method that enforces the invariant that at least one of `data_substring_filter` or `struct_type` must be set: [1](#0-0) 

However, this validation is **never called** during the deserialization process. The filter is created via two paths, neither of which performs validation:

1. **Protobuf conversion path**: The `From<aptos_protos::indexer::v1::EventFilter>` implementation directly copies fields without validation: [2](#0-1) 

2. **Serde deserialization path**: The auto-generated serde code creates the struct with potentially None values without validation: [3](#0-2) 

The `BooleanTransactionFilter::new_from_proto()` method, which is the entry point for client-provided filters, only validates size but does NOT call `is_valid()`: [4](#0-3) 

When an `EventFilter` with both fields as `None` is used, its `matches()` method returns `true` for ANY event because both optional checks are skipped: [5](#0-4) 

This invalid filter state propagates to transaction filtering where it incorrectly matches all transactions containing events.

## Impact Explanation

**Severity: Low** (Non-critical implementation bug)

This issue affects the indexer-grpc data service, which is an **auxiliary ecosystem service** for serving historical transaction data, NOT a core blockchain protocol component. The impact is limited to:

1. **Client-side filtering**: Clients sending invalid filters receive incorrect query results (only transactions with events), affecting only their own queries
2. **Server-side configuration**: If an operator misconfigures `txns_to_strip_filter` with an empty EventFilter, all clients receive stripped transaction data

However, this does NOT affect:
- Validator nodes or consensus operation
- Blockchain state or execution
- Fund security or transaction validity
- Core protocol invariants

The indexer-grpc service is explicitly in the `ecosystem/` directory and serves as a data query layer above the core protocol. Even complete failure of this service does not compromise blockchain security.

## Likelihood Explanation

**Likelihood: Low to Medium**

For client-side attacks: Trivial to execute (send empty filter), but only affects the attacker's own queries.

For server-side misconfiguration: Requires operator access to modify configuration files, making it an operational concern rather than a security vulnerability exploitable by external attackers.

## Recommendation

Add validation enforcement at deserialization boundaries:

```rust
impl BooleanTransactionFilter {
    pub fn new_from_proto(
        proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
        max_filter_size: Option<usize>,
    ) -> Result<Self> {
        if let Some(max_filter_size) = max_filter_size {
            ensure!(
                proto_filter.encoded_len() <= max_filter_size,
                format!(/*...*/)
            );
        }
        let filter = match proto_filter.filter.ok_or(anyhow!(/*...*/))? {
            // ... existing conversion logic ...
        };
        
        // ADD VALIDATION HERE
        filter.is_valid()
            .map_err(|e| anyhow!("Filter validation failed: {}", e))?;
        
        Ok(filter)
    }
}
```

Additionally, implement custom serde deserialize with validation for EventFilter or use the builder pattern exclusively with validation in the `build()` method.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_protos::transaction::v1::{Event, MoveType, move_type::Content, MoveStructTag};
    
    #[test]
    fn test_empty_event_filter_matches_all_events() {
        // Create an invalid EventFilter with both fields as None
        // This should fail validation but doesn't during deserialization
        let invalid_filter = EventFilter {
            data_substring_filter: None,
            struct_type: None,
            data_substring_finder: OnceCell::new(),
        };
        
        // Validation correctly identifies this as invalid
        assert!(invalid_filter.validate_state().is_err());
        
        // But the filter incorrectly matches ANY event
        let test_event = Event {
            r#type: Some(MoveType {
                content: Some(Content::Struct(MoveStructTag {
                    address: "0x1".to_string(),
                    module: "test".to_string(),
                    name: "TestEvent".to_string(),
                    generic_type_params: vec![],
                })),
            }),
            data: "test data".to_string(),
            ..Default::default()
        };
        
        // BUG: This should return false but returns true!
        assert_eq!(invalid_filter.matches(&test_event), true);
        
        // This causes incorrect transaction filtering
        let events = vec![test_event];
        assert_eq!(invalid_filter.matches_vec(&events), true);
    }
    
    #[test]
    fn test_protobuf_deserialization_bypasses_validation() {
        // Simulate client sending empty EventFilter via protobuf
        let proto_filter = aptos_protos::indexer::v1::EventFilter {
            struct_type: None,
            data_substring_filter: None,
        };
        
        // Conversion succeeds without validation
        let filter: EventFilter = proto_filter.into();
        
        // Filter is invalid but was created successfully
        assert!(filter.validate_state().is_err());
        
        // Filter incorrectly matches everything
        let test_event = Event::default();
        assert_eq!(filter.matches(&test_event), true);
    }
}
```

---

**Note**: While this is a genuine implementation bug that violates the intended filtering semantics, it does **not** qualify as a security vulnerability under the strict criteria provided. The indexer-grpc service is an auxiliary data service in the ecosystem layer, not part of the core blockchain consensus, execution, or state management protocols. No critical invariants related to consensus safety, deterministic execution, state consistency, or fund security are violated. This would be classified as a **Low severity** non-critical bug rather than a security vulnerability warranting bounty payout.

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/event.rs (L44-51)
```rust
impl From<aptos_protos::indexer::v1::EventFilter> for EventFilter {
    fn from(proto_filter: aptos_protos::indexer::v1::EventFilter) -> Self {
        Self {
            data_substring_filter: proto_filter.data_substring_filter,
            struct_type: proto_filter.struct_type.map(|f| f.into()),
            data_substring_finder: OnceCell::new(),
        }
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/event.rs (L65-68)
```rust
    fn validate_state(&self) -> Result<(), FilterError> {
        if self.data_substring_filter.is_none() && self.struct_type.is_none() {
            return Err(Error::msg("At least one of data or struct_type must be set").into());
        };
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/event.rs (L76-99)
```rust
    fn matches(&self, item: &Event) -> bool {
        if let Some(struct_type_filter) = &self.struct_type {
            if let Some(Content::Struct(struct_tag)) =
                &item.r#type.as_ref().and_then(|t| t.content.as_ref())
            {
                if !struct_type_filter.matches(struct_tag) {
                    return false;
                }
            } else {
                return false;
            }
        }

        if let Some(data_substring_filter) = self.data_substring_filter.as_ref() {
            let finder = self
                .data_substring_finder
                .get_or_init(|| Finder::new(data_substring_filter).into_owned());
            if finder.find(item.data.as_bytes()).is_none() {
                return false;
            }
        }

        true
    }
```

**File:** protos/rust/src/pb/aptos.indexer.v1.serde.rs (L662-665)
```rust
                Ok(EventFilter {
                    struct_type: struct_type__,
                    data_substring_filter: data_substring_filter__,
                })
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L94-127)
```rust
    pub fn new_from_proto(
        proto_filter: aptos_protos::indexer::v1::BooleanTransactionFilter,
        max_filter_size: Option<usize>,
    ) -> Result<Self> {
        if let Some(max_filter_size) = max_filter_size {
            ensure!(
                proto_filter.encoded_len() <= max_filter_size,
                format!(
                    "Filter is too complicated. Max size: {} bytes, Actual size: {} bytes",
                    max_filter_size,
                    proto_filter.encoded_len()
                )
            );
        }
        Ok(
            match proto_filter
                .filter
                .ok_or(anyhow!("Oneof is not set in BooleanTransactionFilter."))?
            {
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::ApiFilter(
                    api_filter,
                ) => TryInto::<APIFilter>::try_into(api_filter)?.into(),
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::LogicalAnd(
                    logical_and,
                ) => BooleanTransactionFilter::And(logical_and.try_into()?),
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::LogicalOr(
                    logical_or,
                ) => BooleanTransactionFilter::Or(logical_or.try_into()?),
                aptos_protos::indexer::v1::boolean_transaction_filter::Filter::LogicalNot(
                    logical_not,
                ) => BooleanTransactionFilter::Not(logical_not.try_into()?),
            },
        )
    }
```
