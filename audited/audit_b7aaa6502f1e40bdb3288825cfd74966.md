# Audit Report

## Title
WeightedVUF Implementation Switching Causes Unrecoverable Consensus Split Due to Incompatible Proof Serialization

## Summary
The WeightedVUF system lacks versioning and migration logic, making it impossible to switch between PinkasWUF and BlsWUF implementations without causing consensus splits. Proofs, proof shares, and augmented keys from one implementation cannot be validated by another implementation due to fundamentally incompatible serialization formats.

## Finding Description

The Aptos randomness system uses a WeightedVUF trait with two implementations: PinkasWUF (currently active) and BlsWUF. The active implementation is selected via a compile-time type alias: [1](#0-0) 

**Incompatible Type Definitions:**

PinkasWUF defines: [2](#0-1) 

BlsWUF defines: [3](#0-2) 

**Critical Incompatibilities:**
1. **Proof types**: `Vec<(Player, G2Projective)>` vs `G1Projective` - completely different structures
2. **ProofShare types**: `G2Projective` vs `Vec<G1Projective>` - different group elements and structure
3. **AugmentedPubKeyShare types**: `(RandomizedPKs, Vec<DealtPubKeyShare>)` vs `Vec<DealtPubKeyShare>` - different tuple structure

**Failure Points During Upgrade:**

1. **Persisted Keys Become Invalid**: Augmented key pairs are stored using BCS serialization without version tags: [4](#0-3) 

2. **In-Flight Shares Fail Deserialization**: RandShare messages are serialized/deserialized assuming a single WVUF type: [5](#0-4) 

3. **Share Verification Fails**: The verification logic expects specific proof types: [6](#0-5) 

If nodes upgrade to a different WVUF implementation, they cannot deserialize old keys from storage, cannot validate shares from nodes running the old implementation, and cannot communicate their own shares to old nodes. This breaks the consensus invariant that all validators must agree on randomness.

## Impact Explanation

**Critical Severity** - Consensus Split & Network Partition

When an upgrade changes the WVUF implementation:
1. **Immediate consensus split**: Nodes running different implementations cannot validate each other's randomness shares
2. **Epoch transition failure**: Stored keys from previous epochs become undeserializable 
3. **Non-recoverable without hardfork**: No migration path exists; requires coordinated rollback or hardfork
4. **Randomness system failure**: Consensus cannot proceed without working randomness generation

This qualifies as Critical Severity under "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)" per the Aptos bug bounty criteria.

## Likelihood Explanation

**High Likelihood** during any WVUF implementation upgrade:

1. **Legitimate upgrade scenarios**:
   - Performance improvements (BlsWUF has simpler verification)
   - Security enhancements in one implementation
   - Bug fixes requiring implementation switch

2. **No warning or prevention**:
   - Type alias change appears safe at compile time
   - No runtime version checks
   - No migration documentation or tooling

3. **Rollout challenges**:
   - Even coordinated rollouts fail because nodes at different upgrade stages cannot communicate
   - Gradual rollouts are impossible

The vulnerability is architectural, not dependent on specific attacker actions, making it highly likely to manifest during any upgrade attempt.

## Recommendation

Implement a versioned WVUF system with migration support:

**Step 1**: Add version field to all serialized structures:
```rust
#[derive(Serialize, Deserialize)]
pub struct VersionedProof {
    version: u8,
    proof_data: Vec<u8>,
}
```

**Step 2**: Support multiple implementations simultaneously:
```rust
pub enum WVUFImpl {
    Pinkas(PinkasProof),
    Bls(BlsProof),
}
```

**Step 3**: Add migration epoch in RandomnessConfig:
```rust
pub struct RandomnessConfigMoveStruct {
    // ... existing fields
    pub wvuf_version: u8,
    pub migration_epoch: Option<u64>,
}
```

**Step 4**: During migration epoch, validate both old and new proof formats. After migration completes, reject old format.

**Step 5**: Add version compatibility check in share verification: [7](#0-6) 

This requires updating the verify_share method to check version compatibility before attempting deserialization.

## Proof of Concept

```rust
// Reproduction steps:

// 1. Start network with PinkasWUF
// types/src/randomness.rs:
pub type WVUF = weighted_vuf::pinkas::PinkasWUF;

// 2. Generate and persist keys at epoch N
let augmented_key_pair = WVUF::augment_key_pair(&vuf_pp, sk, pk, &mut rng);
rand_storage.save_key_pair_bytes(epoch, bcs::to_bytes(&augmented_key_pair)?)?;

// 3. Switch implementation
// types/src/randomness.rs:
pub type WVUF = weighted_vuf::bls::BlsWUF;  // CHANGED

// 4. Attempt to recover keys - FAILS
let (stored_epoch, key_bytes) = rand_storage.get_key_pair_bytes()?.unwrap();
// This will fail with deserialization error because:
// - Stored: (Scalar, Vec<DealtSecretKeyShare>), (RandomizedPKs, Vec<DealtPubKeyShare>)
// - Expected: Vec<Scalar>, Vec<DealtPubKeyShare>
let (augmented_key_pair, _) = bcs::from_bytes::<(
    <BlsWUF as WeightedVUF>::AugmentedSecretKeyShare,
    <BlsWUF as WeightedVUF>::AugmentedPubKeyShare,
)>(&key_bytes)?; // ERROR: type mismatch

// 5. Network split occurs:
// - Nodes with BlsWUF cannot validate Pinkas shares
// - Nodes with PinkasWUF cannot validate Bls shares  
// - RandShare::verify() fails for cross-implementation messages
// - Consensus cannot reach agreement on randomness
```

Expected result: Deserialization error, consensus split, network partition.

## Notes

This vulnerability is inherent in the design of having multiple incompatible WeightedVUF implementations without versioning. While the current system works fine with a single implementation, any future upgrade attempt will trigger a catastrophic failure. The issue affects the core consensus randomness mechanism, making it a critical architectural flaw that must be addressed before any WVUF implementation changes are considered.

### Citations

**File:** types/src/randomness.rs (L11-11)
```rust
pub type WVUF = weighted_vuf::pinkas::PinkasWUF;
```

**File:** crates/aptos-dkg/src/weighted_vuf/pinkas/mod.rs (L64-80)
```rust
impl WeightedVUF for PinkasWUF {
    type AugmentedPubKeyShare = (RandomizedPKs, Self::PubKeyShare);
    type AugmentedSecretKeyShare = (Scalar, Self::SecretKeyShare);
    // /// Note: Our BLS PKs are currently in G_1.
    // type BlsPubKey = bls12381::PublicKey;
    // type BlsSecretKey = bls12381::PrivateKey;

    type Delta = RandomizedPKs;
    type Evaluation = Gt;
    /// Naive aggregation by concatenation. It is an open problem to get constant-sized aggregation.
    type Proof = Vec<(Player, Self::ProofShare)>;
    type ProofShare = G2Projective;
    type PubKey = pvss::dealt_pub_key::g2::DealtPubKey;
    type PubKeyShare = Vec<pvss::dealt_pub_key_share::g2::DealtPubKeyShare>;
    type PublicParameters = PublicParameters;
    type SecretKey = pvss::dealt_secret_key::g1::DealtSecretKey;
    type SecretKeyShare = Vec<pvss::dealt_secret_key_share::g1::DealtSecretKeyShare>;
```

**File:** crates/aptos-dkg/src/weighted_vuf/bls/mod.rs (L37-48)
```rust
impl WeightedVUF for BlsWUF {
    type AugmentedPubKeyShare = Self::PubKeyShare;
    type AugmentedSecretKeyShare = Self::SecretKeyShare;
    type Delta = ();
    type Evaluation = G1Projective;
    type Proof = Self::Evaluation;
    type ProofShare = Vec<G1Projective>;
    type PubKey = pvss::dealt_pub_key::g2::DealtPubKey;
    type PubKeyShare = Vec<pvss::dealt_pub_key_share::g2::DealtPubKeyShare>;
    type PublicParameters = PublicParameters;
    type SecretKey = Scalar;
    type SecretKeyShare = Vec<Scalar>;
```

**File:** consensus/src/epoch_manager.rs (L1114-1121)
```rust
            self.rand_storage
                .save_key_pair_bytes(
                    new_epoch,
                    bcs::to_bytes(&(augmented_key_pair.clone(), fast_augmented_key_pair.clone()))
                        .map_err(NoRandomnessReason::KeyPairSerializationError)?,
                )
                .map_err(NoRandomnessReason::KeyPairPersistError)?;
            (augmented_key_pair, fast_augmented_key_pair)
```

**File:** consensus/src/rand/rand_gen/network_messages.rs (L78-91)
```rust
    fn from_network_message(msg: ConsensusMsg) -> anyhow::Result<Self> {
        match msg {
            ConsensusMsg::RandGenMessage(msg) => Ok(bcs::from_bytes(&msg.data)?),
            _ => bail!("unexpected consensus message type {:?}", msg),
        }
    }

    #[allow(clippy::unwrap_used)]
    fn into_network_message(self) -> ConsensusMsg {
        ConsensusMsg::RandGenMessage(RandGenMessage {
            epoch: self.epoch(),
            data: bcs::to_bytes(&self).unwrap(),
        })
    }
```

**File:** consensus/src/rand/rand_gen/types.rs (L52-81)
```rust
    fn verify(
        &self,
        rand_config: &RandConfig,
        rand_metadata: &RandMetadata,
        author: &Author,
    ) -> anyhow::Result<()> {
        let index = *rand_config
            .validator
            .address_to_validator_index()
            .get(author)
            .ok_or_else(|| anyhow!("Share::verify failed with unknown author"))?;
        let maybe_apk = &rand_config.keys.certified_apks[index];
        if let Some(apk) = maybe_apk.get() {
            WVUF::verify_share(
                &rand_config.vuf_pp,
                apk,
                bcs::to_bytes(&rand_metadata)
                    .map_err(|e| anyhow!("Serialization failed: {}", e))?
                    .as_slice(),
                &self.share,
            )?;
        } else {
            bail!(
                "[RandShare] No augmented public key for validator id {}, {}",
                index,
                author
            );
        }
        Ok(())
    }
```
