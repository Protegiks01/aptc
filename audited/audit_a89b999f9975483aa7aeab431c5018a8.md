# Audit Report

## Title
Multi-Agent Transaction Length Mismatch Allows Mempool DoS via Signature Verification Bypass

## Summary
The `TransactionAuthenticator::verify()` method does not validate that the number of secondary signer addresses matches the number of secondary signer authenticators in multi-agent transactions. This allows attackers to craft invalid transactions that pass signature verification and mempool admission but fail during prologue execution, enabling a denial-of-service attack on the network.

## Finding Description
In multi-agent transactions, the `TransactionAuthenticator::MultiAgent` variant contains two vectors:
- `secondary_signer_addresses: Vec<AccountAddress>` 
- `secondary_signers: Vec<AccountAuthenticator>`

These vectors should have equal length, with each address corresponding to one authenticator. However, the signature verification logic does not enforce this invariant. [1](#0-0) 

The verification only iterates through `secondary_signers` and verifies each signature against the message containing all `secondary_signer_addresses`. It never checks that the lengths match. This means:

1. A transaction with 3 addresses but only 2 authenticators will pass signature verification
2. The transaction can be added to mempool since it has valid signatures  
3. During execution, `TransactionMetadata` construction extracts mismatched lengths: [2](#0-1) 

4. The prologue receives mismatched vectors and aborts: [3](#0-2) 

The API layer does check this in one location, but this check can be bypassed by submitting transactions directly to mempool: [4](#0-3) 

Additionally, the test transaction referenced in the security question only validates the happy path with matching lengths, not the error case: [5](#0-4) 

## Impact Explanation
This is a **Medium severity** vulnerability per Aptos bug bounty criteria. It enables:

1. **Mempool Pollution**: Attackers can flood mempool with invalid transactions that appear valid
2. **Resource Exhaustion**: Each invalid transaction consumes validator CPU during prologue execution before being rejected
3. **Network Bandwidth Waste**: Invalid transactions propagate through the P2P network before rejection
4. **No Gas Charge**: Since prologue fails, attackers don't pay gas for these failed transactions, enabling low-cost repeated attacks

The vulnerability does not directly violate consensus safety or cause fund loss, but it allows "state inconsistencies requiring intervention" (mempool cleanup) and resource exhaustion attacks, qualifying as Medium severity.

## Likelihood Explanation
This vulnerability is **highly likely** to be exploited because:
- It requires no privileged access
- Attack is trivial: craft BCS-serialized transaction with mismatched vector lengths
- No cost to attacker (failed transactions don't charge gas)
- Can be automated and repeated at scale
- Difficult to rate-limit since transactions have valid signatures

## Recommendation
Add length validation in `TransactionAuthenticator::verify()` before signature verification:

```rust
Self::MultiAgent {
    sender,
    secondary_signer_addresses,
    secondary_signers,
} => {
    // Add length check
    if secondary_signer_addresses.len() != secondary_signers.len() {
        return Err(Error::msg(
            "Secondary signer addresses and authenticators length mismatch"
        ));
    }
    
    let message = RawTransactionWithData::new_multi_agent(
        raw_txn.clone(),
        secondary_signer_addresses.clone(),
    );
    sender.verify(&message)?;
    for signer in secondary_signers {
        signer.verify(&message)?;
    }
    Ok(())
},
```

Similarly for `FeePayer` variant. Additionally, add test cases covering length mismatches to the test transaction suite.

## Proof of Concept
```rust
#[test]
fn test_multi_agent_length_mismatch_rejected() {
    use aptos_types::transaction::*;
    use aptos_crypto::ed25519::*;
    
    let sender_key = Ed25519PrivateKey::generate_for_testing();
    let secondary_key1 = Ed25519PrivateKey::generate_for_testing();
    let secondary_key2 = Ed25519PrivateKey::generate_for_testing();
    
    let sender_addr = AccountAddress::random();
    let secondary_addr1 = AccountAddress::random();
    let secondary_addr2 = AccountAddress::random();
    let secondary_addr3 = AccountAddress::random();
    
    let raw_txn = RawTransaction::new_script(
        sender_addr,
        0,
        Script::new(vec![], vec![], vec![]),
        1000,
        1,
        1000,
        ChainId::test(),
    );
    
    // Create message with 3 addresses
    let message = RawTransactionWithData::new_multi_agent(
        raw_txn.clone(),
        vec![secondary_addr1, secondary_addr2, secondary_addr3],
    );
    
    // But only 2 authenticators
    let sender_auth = AccountAuthenticator::ed25519(
        sender_key.public_key(),
        sender_key.sign(&message).unwrap(),
    );
    let secondary_auth1 = AccountAuthenticator::ed25519(
        secondary_key1.public_key(), 
        secondary_key1.sign(&message).unwrap(),
    );
    let secondary_auth2 = AccountAuthenticator::ed25519(
        secondary_key2.public_key(),
        secondary_key2.sign(&message).unwrap(),
    );
    
    // This should be rejected but currently passes signature verification
    let authenticator = TransactionAuthenticator::multi_agent(
        sender_auth,
        vec![secondary_addr1, secondary_addr2, secondary_addr3],
        vec![secondary_auth1, secondary_auth2],
    );
    
    // Currently this passes when it should fail
    assert!(authenticator.verify(&raw_txn).is_err(), 
        "Should reject mismatched lengths in signature verification");
}
```

### Citations

**File:** types/src/transaction/authenticator.rs (L225-239)
```rust
            Self::MultiAgent {
                sender,
                secondary_signer_addresses,
                secondary_signers,
            } => {
                let message = RawTransactionWithData::new_multi_agent(
                    raw_txn.clone(),
                    secondary_signer_addresses.clone(),
                );
                sender.verify(&message)?;
                for signer in secondary_signers {
                    signer.verify(&message)?;
                }
                Ok(())
            },
```

**File:** aptos-move/aptos-vm/src/transaction_metadata.rs (L48-54)
```rust
            secondary_signers: txn.authenticator().secondary_signer_addresses(),
            secondary_authentication_proofs: txn
                .authenticator()
                .secondary_signers()
                .iter()
                .map(|account_auth| account_auth.authentication_proof())
                .collect(),
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L385-389)
```text
        let num_secondary_signers = vector::length(&secondary_signer_addresses);
        assert!(
            vector::length(&secondary_signer_public_key_hashes) == num_secondary_signers,
            error::invalid_argument(PROLOGUE_ESECONDARY_KEYS_ADDRESSES_COUNT_MISMATCH),
        );
```

**File:** api/types/src/transaction.rs (L2141-2143)
```rust
        } else if self.secondary_signers.len() != self.secondary_signer_addresses.len() {
            bail!("MultiAgent signatures don't match addresses length")
        }
```

**File:** ecosystem/indexer-grpc/indexer-test-transactions/src/json_transactions/generated_transactions.rs (L94-97)
```rust
pub const IMPORTED_MAINNET_TXNS_103958588_MULTI_AGENTS: &[u8] = include_bytes!(concat!(
    env!("CARGO_MANIFEST_DIR"),
    "/src/json_transactions/imported_mainnet_txns/103958588_multi_agents.json"
));
```
