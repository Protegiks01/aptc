# Audit Report

## Title
Timeout Equivocation Vulnerability: Validator Can Sign Multiple Conflicting Timeouts for Same Round

## Summary
The `guarded_sign_timeout_with_qc()` function in the consensus safety rules contains a critical logic gap that allows a validator to sign multiple different timeout messages for the same round, enabling equivocation. When `timeout.round() == last_voted_round`, neither the error condition nor the update condition is triggered, allowing repeated signatures on conflicting timeout content. [1](#0-0) 

## Finding Description
The vulnerability exists in the round comparison logic that validates timeout signing requests. The code checks two conditions:

1. **Line 37-42**: Returns error if `timeout.round() < last_voted_round`
2. **Line 43-45**: Updates `last_voted_round` if `timeout.round() > last_voted_round`

When `timeout.round() == last_voted_round`, **neither condition is satisfied**, causing the function to proceed to signing without error and without preventing the duplicate signature. [2](#0-1) 

The timeout signature is computed over `TimeoutSigningRepr` which includes the `hqc_round` extracted from the quorum certificate. Since different `TwoChainTimeout` messages for the same round can contain different quorum certificates (with different `hqc_round` values), this allows signing conflicting content: [3](#0-2) 

This contrasts sharply with the voting logic, which explicitly handles the equal-round case by returning the cached previous vote: [4](#0-3) 

However, the `SafetyData` structure only stores `highest_timeout_round` (the round number) but **not** the actual timeout message itself, preventing similar idempotent behavior: [5](#0-4) 

The `verify_and_update_last_vote_round` function would correctly reject equal rounds if called, but it's not called when rounds are equal: [6](#0-5) 

## Impact Explanation
This vulnerability represents a **High Severity** protocol violation according to Aptos bug bounty criteria ("Significant protocol violations").

**Consensus Safety Impact:**
- Enables validator equivocation by signing multiple conflicting timeout messages for the same round
- Violates the fundamental BFT assumption that honest validators do not equivocate
- Different validators could receive different timeout signatures from the same validator for the same round
- Could contribute to consensus safety violations when combined with other Byzantine behaviors
- Breaks the "Consensus Safety" invariant: "AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine"

**Attack Scenario:**
1. Validator's `last_voted_round` = 99
2. First timeout request arrives for round 100 with QC for round 98 (hqc_round = 98)
   - Condition `100 > 99` is true → updates `last_voted_round = 100`
   - Signs timeout with signature over `(epoch, 100, 98)`
3. Second timeout request arrives for round 100 with QC for round 99 (hqc_round = 99)
   - Condition `100 == 100` → neither if-branch executes
   - Signs **second timeout** with signature over `(epoch, 100, 99)` ← **EQUIVOCATION**
4. Validator has now signed two conflicting timeout messages for round 100

The safety rules component is designed as the last line of defense and should prevent equivocation regardless of bugs or race conditions in higher consensus layers.

## Likelihood Explanation
**Moderate to High Likelihood**

While this requires the consensus layer to call `sign_timeout_with_qc()` multiple times for the same round with different QCs, several realistic scenarios can trigger this:

1. **Race conditions** in the round manager when processing concurrent timeout events
2. **Bugs in consensus logic** that cause retry attempts with updated QCs
3. **Network message reordering** causing multiple timeout signing requests
4. **State synchronization edge cases** during recovery or catch-up

The round manager has some protections at higher layers, but these are not foolproof and the safety rules should enforce this invariant regardless: [7](#0-6) 

Defense-in-depth is critical for consensus systems, and this gap in the safety rules layer is exploitable when higher-layer protections fail.

## Recommendation
**Fix Option 1 (Idempotent behavior - Preferred):**
Store the last signed timeout in `SafetyData` and return it when asked to sign the same round again, matching the voting logic:

```rust
// In SafetyData struct, add:
pub last_timeout: Option<(TwoChainTimeout, bls12381::Signature)>,

// In guarded_sign_timeout_with_qc(), add before line 37:
if let Some((last_timeout_msg, last_sig)) = &safety_data.last_timeout {
    if last_timeout_msg.round() == timeout.round() {
        return Ok(last_sig.clone());
    }
}

// After line 47, add:
safety_data.last_timeout = Some((timeout.clone(), signature.clone()));
```

**Fix Option 2 (Strict rejection):**
Reject equal rounds entirely by changing the condition:

```rust
// Line 37: Change from < to <=
if timeout.round() <= safety_data.last_voted_round {
    return Err(Error::IncorrectLastVotedRound(
        timeout.round(),
        safety_data.last_voted_round,
    ));
}
// Remove the second if block (lines 43-45) since it's now redundant
self.verify_and_update_last_vote_round(timeout.round(), &mut safety_data)?;
```

**Option 1 is preferred** because it matches the voting behavior and provides better user experience by avoiding spurious errors in edge cases.

## Proof of Concept

```rust
#[test]
fn test_timeout_equivocation_vulnerability() {
    use crate::{test_utils, SafetyRules};
    use aptos_consensus_types::{
        quorum_cert::QuorumCert,
        timeout_2chain::TwoChainTimeout,
    };
    use aptos_types::validator_verifier::random_validator_verifier;

    // Setup validator and safety rules
    let (signers, validator_verifier) = random_validator_verifier(4, None, false);
    let signer = &signers[0];
    let mut safety_rules = test_utils::test_safety_rules(signer);

    // Create two different QCs for different rounds
    let qc_round_98 = test_utils::make_genesis_qc(&validator_verifier);
    let qc_round_99 = test_utils::make_qc_for_round(99, &validator_verifier);

    let epoch = 1;
    let round = 100;

    // First timeout with QC for round 98
    let timeout_1 = TwoChainTimeout::new(epoch, round, qc_round_98);
    let sig_1 = safety_rules
        .sign_timeout_with_qc(&timeout_1, None)
        .expect("First timeout should succeed");

    // Second timeout for SAME round but with different QC (round 99)
    let timeout_2 = TwoChainTimeout::new(epoch, round, qc_round_99);
    let sig_2 = safety_rules
        .sign_timeout_with_qc(&timeout_2, None)
        .expect("BUG: Second timeout for same round should fail but succeeds!");

    // Verify that both signatures are valid but DIFFERENT
    assert_ne!(timeout_1.hqc_round(), timeout_2.hqc_round(), 
        "QCs have different rounds");
    assert_ne!(sig_1, sig_2, 
        "EQUIVOCATION: Signed two different messages for same round!");

    // Both signatures verify against different content
    assert!(signer.verify(&timeout_1.signing_format(), &sig_1).is_ok());
    assert!(signer.verify(&timeout_2.signing_format(), &sig_2).is_ok());
    
    // But they're for the same round - this is equivocation!
    assert_eq!(timeout_1.round(), timeout_2.round());
}
```

**Expected behavior:** The second `sign_timeout_with_qc()` call should either return an error or return the same signature as the first call.

**Actual behavior:** Both calls succeed with different signatures, allowing equivocation.

### Citations

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L19-51)
```rust
    pub(crate) fn guarded_sign_timeout_with_qc(
        &mut self,
        timeout: &TwoChainTimeout,
        timeout_cert: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;
        let mut safety_data = self.persistent_storage.safety_data()?;
        self.verify_epoch(timeout.epoch(), &safety_data)?;
        if !self.skip_sig_verify {
            timeout
                .verify(&self.epoch_state()?.verifier)
                .map_err(|e| Error::InvalidTimeout(e.to_string()))?;
        }
        if let Some(tc) = timeout_cert {
            self.verify_tc(tc)?;
        }

        self.safe_to_timeout(timeout, timeout_cert, &safety_data)?;
        if timeout.round() < safety_data.last_voted_round {
            return Err(Error::IncorrectLastVotedRound(
                timeout.round(),
                safety_data.last_voted_round,
            ));
        }
        if timeout.round() > safety_data.last_voted_round {
            self.verify_and_update_last_vote_round(timeout.round(), &mut safety_data)?;
        }
        self.update_highest_timeout_round(timeout, &mut safety_data);
        self.persistent_storage.set_safety_data(safety_data)?;

        let signature = self.sign(&timeout.signing_format())?;
        Ok(signature)
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L68-74)
```rust
        // if already voted on this round, send back the previous vote
        // note: this needs to happen after verifying the epoch as we just check the round here
        if let Some(vote) = safety_data.last_vote.clone() {
            if vote.vote_data().proposed().round() == proposed_block.round() {
                return Ok(vote);
            }
        }
```

**File:** consensus/consensus-types/src/timeout_2chain.rs (L66-72)
```rust
    pub fn signing_format(&self) -> TimeoutSigningRepr {
        TimeoutSigningRepr {
            epoch: self.epoch(),
            round: self.round(),
            hqc_round: self.hqc_round(),
        }
    }
```

**File:** consensus/consensus-types/src/safety_data.rs (L9-21)
```rust
#[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```

**File:** consensus/safety-rules/src/safety_rules.rs (L213-231)
```rust
    pub(crate) fn verify_and_update_last_vote_round(
        &self,
        round: Round,
        safety_data: &mut SafetyData,
    ) -> Result<(), Error> {
        if round <= safety_data.last_voted_round {
            return Err(Error::IncorrectLastVotedRound(
                round,
                safety_data.last_voted_round,
            ));
        }

        safety_data.last_voted_round = round;
        trace!(
            SafetyLogSchema::new(LogEntry::LastVotedRound, LogEvent::Update)
                .last_voted_round(safety_data.last_voted_round)
        );

        Ok(())
```

**File:** consensus/src/round_manager.rs (L1045-1077)
```rust
            let (is_nil_vote, mut timeout_vote) = match self.round_state.vote_sent() {
                Some(vote) if vote.vote_data().proposed().round() == round => {
                    (vote.vote_data().is_for_nil(), vote)
                },
                _ => {
                    // Didn't vote in this round yet, generate a backup vote
                    let nil_block = self
                        .proposal_generator
                        .generate_nil_block(round, self.proposer_election.clone())?;
                    info!(
                        self.new_log(LogEvent::VoteNIL),
                        "Planning to vote for a NIL block {}", nil_block
                    );
                    counters::VOTE_NIL_COUNT.inc();
                    let nil_vote = self.vote_block(nil_block).await?;
                    (true, nil_vote)
                },
            };

            if !timeout_vote.is_timeout() {
                let timeout = timeout_vote.generate_2chain_timeout(
                    self.block_store.highest_quorum_cert().as_ref().clone(),
                );
                let signature = self
                    .safety_rules
                    .lock()
                    .sign_timeout_with_qc(
                        &timeout,
                        self.block_store.highest_2chain_timeout_cert().as_deref(),
                    )
                    .context("[RoundManager] SafetyRules signs 2-chain timeout")?;
                timeout_vote.add_2chain_timeout(timeout, signature);
            }
```
