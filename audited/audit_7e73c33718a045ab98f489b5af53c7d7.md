# Audit Report

## Title
Unbounded Memory Growth in Mempool Broadcast Tracking Due to Missing Cleanup of Ancient Expired Messages

## Summary
The `BroadcastInfo.sent_messages` map in the mempool lacks a mechanism to remove very old expired broadcast entries based on absolute age. A malicious peer that never sends ACKs can cause indefinite accumulation of expired message entries, leading to memory exhaustion and node degradation.

## Finding Description
The `BroadcastInfo` struct tracks broadcast messages sent to peers in a `BTreeMap<MempoolMessageId, SystemTime>` called `sent_messages`. [1](#0-0) 

When broadcasts are sent, entries are added to this map with timestamps. [2](#0-1) 

The code has three removal mechanisms:
1. **ACK received**: Entry is removed when acknowledgment arrives [3](#0-2) 
2. **Transactions committed**: Filter removes messages whose transactions are no longer in mempool [4](#0-3) 
3. **Peer disconnect**: Entire sync state is cleared [5](#0-4) 

However, there is a critical flaw in the expiry handling logic. Messages expire after `shared_mempool_ack_timeout_ms` (default 2000ms). [6](#0-5) 

The expiry check loop identifies expired messages but does NOT remove them from the map: [7](#0-6) 

The loop only sets `expired_message_id` to track which messages are expired (line 436), without removing them. Only ONE expired message is selected for rebroadcast per cycle via `std::cmp::max`: [8](#0-7) 

**Critical issue**: The `pending_broadcasts` counter only counts **non-expired** messages (line 438), and the limit check uses this counter. [9](#0-8) 

**Attack scenario**:
1. Malicious peer connects but never sends ACKs
2. Victim node sends 20 broadcasts (M1-M20) reaching `max_broadcasts_per_peer` limit (default 20) [10](#0-9) 
3. All 20 expire after 2 seconds → `pending_broadcasts = 0` (all expired)
4. Next broadcast cycle: ONE expired message (M20) is rebroadcast, timestamp updated via insert
5. Now `pending_broadcasts = 1`, so fresh broadcasts can occur → M21 sent
6. `sent_messages` now contains 21 entries: M1-M19 (expired, stale), M20 (fresh), M21 (fresh)
7. Process repeats: old expired entries (M1-M19) accumulate, never removed
8. If transactions aren't committed (e.g., spam transactions), the filter doesn't remove them
9. `sent_messages` grows unbounded → memory exhaustion

The broadcast interval is very short (10ms), enabling rapid accumulation: [11](#0-10) 

## Impact Explanation
This is a **High Severity** vulnerability under Aptos bug bounty criteria, specifically matching the "Validator Node Slowdowns (High)" category which explicitly includes "DoS through resource exhaustion":

- **Validator node slowdowns**: As `sent_messages` grows, memory consumption increases, causing node performance degradation affecting consensus participation
- **Potential node crashes**: Unbounded memory growth can lead to OOM (Out Of Memory) conditions
- **Network availability impact**: If multiple nodes are targeted simultaneously, overall network throughput degrades
- **No funds loss**: This is a resource exhaustion attack, not direct theft
- **No consensus violation**: AptosBFT safety is not broken, but liveness may be affected

The attack is realistic because:
- Any network peer can trigger it without special privileges
- The attacker only needs to connect and withhold ACKs
- Default configuration is vulnerable (2s timeout, 10ms broadcast interval, 20 pending limit)
- Both validators and fullnodes are affected
- The vulnerability can be amplified by multiple malicious peers connecting simultaneously

## Likelihood Explanation
**Likelihood: High**

The attack is trivial to execute:
1. Connect as a network peer (no authentication required for initial connection)
2. Simply don't respond with ACKs to broadcast messages
3. Optionally send spam transactions to prevent garbage collection
4. Wait for memory to accumulate over time

Factors increasing likelihood:
- Default mempool configuration is vulnerable out-of-the-box
- Broadcast interval is very short (10ms) enabling rapid accumulation
- No monitoring alerts exist for `sent_messages` size growth
- Attack requires no special resources, timing precision, or validator access
- Multiple peers can amplify the attack simultaneously
- The bug affects all node types (validators, VFNs, PFNs)

Factors that might reduce impact but don't prevent exploitation:
- Peer disconnection timeout may eventually trigger, but by then significant memory damage is done
- Transaction garbage collection helps but doesn't prevent accumulation if attacker continuously sends spam
- Memory growth is gradual, making it harder to detect initially

## Recommendation
Implement an absolute age-based cleanup mechanism for expired broadcast entries. Add a periodic cleanup task that removes entries older than a reasonable threshold (e.g., 10x the ACK timeout):

```rust
// In determine_broadcast_batch, add cleanup of ancient expired messages
let cleanup_threshold = Duration::from_millis(
    self.mempool_config.shared_mempool_ack_timeout_ms * 10
);

state.broadcast_info.sent_messages.retain(|_message_id, sent_time| {
    SystemTime::now()
        .duration_since(*sent_time)
        .map(|age| age < cleanup_threshold)
        .unwrap_or(false)
});
```

Additionally, consider:
1. Adding metrics/alerts for `sent_messages` map size per peer
2. Implementing a hard cap on `sent_messages` size independent of expiry status
3. More aggressive cleanup when transactions are garbage collected from mempool

## Proof of Concept
The vulnerability can be demonstrated by:

1. Connecting a test peer to an Aptos node
2. Triggering broadcasts by submitting transactions
3. Not sending ACK responses for broadcast messages
4. Monitoring memory growth in the mempool process over time
5. Observing that `sent_messages` map grows without bound as new broadcasts occur while old expired entries remain

A minimal Rust test would create a mock peer, send broadcasts without ACKs, advance time past expiry, trigger new broadcasts, and verify that old expired entries remain in the map while new ones are added.

## Notes
This is a protocol-level resource exhaustion bug in the mempool broadcast tracking implementation, not a network-level DoS attack. The Aptos bug bounty framework explicitly categorizes "DoS through resource exhaustion" causing "Validator Node Slowdowns" as valid HIGH severity impacts. The vulnerability exploits missing cleanup logic in the code rather than overwhelming network bandwidth, making it a legitimate protocol bug within scope.

### Citations

**File:** mempool/src/shared_mempool/types.rs (L456-464)
```rust
#[derive(Clone, Debug)]
pub struct BroadcastInfo {
    // Sent broadcasts that have not yet received an ack.
    pub sent_messages: BTreeMap<MempoolMessageId, SystemTime>,
    // Broadcasts that have received a retry ack and are pending a resend.
    pub retry_messages: BTreeSet<MempoolMessageId>,
    // Whether broadcasting to this peer is in backoff mode, e.g. broadcasting at longer intervals.
    pub backoff_mode: bool,
}
```

**File:** mempool/src/shared_mempool/network.rs (L194-199)
```rust
        for peer in to_disable {
            // All other nodes have their state immediately restarted anyways, so let's free them
            if sync_states.remove(peer).is_some() {
                counters::active_upstream_peers(&peer.network_id()).dec();
            }
        }
```

**File:** mempool/src/shared_mempool/network.rs (L315-315)
```rust
        if let Some(sent_timestamp) = sync_state.broadcast_info.sent_messages.remove(&message_id) {
```

**File:** mempool/src/shared_mempool/network.rs (L400-410)
```rust
        state.broadcast_info.sent_messages = state
            .broadcast_info
            .sent_messages
            .clone()
            .into_iter()
            .filter(|(message_id, _batch)| {
                !mempool
                    .timeline_range_of_message(message_id.decode())
                    .is_empty()
            })
            .collect::<BTreeMap<MempoolMessageId, SystemTime>>();
```

**File:** mempool/src/shared_mempool/network.rs (L426-449)
```rust
        let mut pending_broadcasts = 0;
        let mut expired_message_id = None;

        // Find earliest message in timeline index that expired.
        // Note that state.broadcast_info.sent_messages is ordered in decreasing order in the timeline index
        for (message, sent_time) in state.broadcast_info.sent_messages.iter() {
            let deadline = sent_time.add(Duration::from_millis(
                self.mempool_config.shared_mempool_ack_timeout_ms,
            ));
            if SystemTime::now().duration_since(deadline).is_ok() {
                expired_message_id = Some(message);
            } else {
                pending_broadcasts += 1;
            }

            // The maximum number of broadcasts sent to a single peer that are pending a response ACK at any point.
            // If the number of un-ACK'ed un-expired broadcasts reaches this threshold, we do not broadcast anymore
            // and wait until an ACK is received or a sent broadcast expires.
            // This helps rate-limit egress network bandwidth and not overload a remote peer or this
            // node's network sender.
            if pending_broadcasts >= self.mempool_config.max_broadcasts_per_peer {
                return Err(BroadcastError::TooManyPendingBroadcasts(peer));
            }
        }
```

**File:** mempool/src/shared_mempool/network.rs (L450-453)
```rust
        let retry_message_id = state.broadcast_info.retry_messages.iter().next_back();

        let (message_id, transactions, metric_label) =
            match std::cmp::max(expired_message_id, retry_message_id) {
```

**File:** mempool/src/shared_mempool/network.rs (L629-633)
```rust
        state
            .broadcast_info
            .sent_messages
            .insert(message_id, send_time);
        Ok(state.broadcast_info.sent_messages.len())
```

**File:** config/src/config/mempool_config.rs (L111-111)
```rust
            shared_mempool_tick_interval_ms: 10,
```

**File:** config/src/config/mempool_config.rs (L115-115)
```rust
            shared_mempool_ack_timeout_ms: 2_000,
```

**File:** config/src/config/mempool_config.rs (L117-117)
```rust
            max_broadcasts_per_peer: 20,
```
