# Audit Report

## Title
Staking Lockup Bypass in Vesting Contracts Due to Uninitialized Lockup Period

## Summary
Vesting contracts create underlying stake pools with `locked_until_secs = 0` and never initialize the staking lockup period. For INACTIVE stake pools (typical for vesting contracts), this allows shareholders to immediately withdraw vested coins by exploiting an edge case in `withdraw_with_cap`, completely bypassing the intended staking lockup mechanism.

## Finding Description

The vesting contract system implements two-tier locking: **vesting lockup** (controls when coins can be unlocked according to schedule) and **staking lockup** (controls when unlocked coins can be withdrawn). The CLI documentation explicitly states: "The unlocked vested tokens and staking rewards are still subject to the staking lockup and cannot be withdrawn until after the lockup expires."

However, this guarantee is violated due to the following issue:

**Root Cause**: When a vesting contract is created, it initializes a stake pool that starts with `locked_until_secs = 0`. [1](#0-0) 

The vesting contract creation flow never calls `reset_lockup()` or `increase_lockup()` to set an actual lockup period: [2](#0-1) 

**No Automatic Renewal**: For ACTIVE validators, the lockup is automatically renewed during epoch transitions. However, vesting contracts typically create INACTIVE stake pools that never join the validator set: [3](#0-2) 

This automatic renewal only applies to validators in the active set, not INACTIVE stake pools.

**Edge Case Exploitation**: When shareholders call `distribute()` on a vesting contract, it eventually calls `withdraw_with_cap()`, which contains an edge case for INACTIVE validators: [4](#0-3) 

This edge case immediately moves `pending_inactive` to `inactive` if:
1. The validator status is INACTIVE (true for typical vesting contracts)
2. Current time >= `locked_until_secs` (always true when `locked_until_secs = 0`)

**Attack Flow**:
1. Admin creates vesting contract → underlying stake pool has `locked_until_secs = 0`
2. Vesting period passes, shareholder calls `vest()` → moves vested coins to `pending_inactive`
3. Shareholder immediately calls `distribute()` → edge case triggers, `pending_inactive` moves to `inactive` and is withdrawn
4. Shareholder receives vested coins without any staking lockup delay

## Impact Explanation

**Severity: HIGH** - Significant Protocol Violation

This vulnerability violates a core security guarantee of the vesting system. According to Aptos bug bounty criteria, this qualifies as HIGH severity because:

1. **Protocol Violation**: The documented two-tier locking mechanism is completely bypassed for the staking lockup component
2. **Premature Fund Access**: Shareholders can access vested funds immediately after they vest, without waiting for any staking lockup period to expire
3. **Affects All Vesting Contracts**: Any vesting contract that doesn't manually call `reset_lockup()` after creation is vulnerable
4. **Breaks Documented Behavior**: The CLI explicitly documents that unlocked coins are "still subject to staking lockup", which is false

This falls under "Significant protocol violations" in the HIGH severity category.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to be exploited because:

1. **No Special Permissions Required**: Any shareholder in a vesting contract can trigger the exploit by calling standard public entry functions (`vest()` and `distribute()`)
2. **Easy to Execute**: The attack requires only two transaction calls with no complex timing or state manipulation
3. **Affects Common Configuration**: Most vesting contracts don't join the validator set, leaving them in INACTIVE state where the vulnerability applies
4. **Natural User Flow**: Shareholders would naturally call `vest()` followed by `distribute()` to claim their vested tokens, unknowingly exploiting the vulnerability

The only mitigation would be if administrators proactively call `reset_lockup()` after creating vesting contracts, but the code provides no indication this is necessary.

## Recommendation

**Immediate Fix**: Initialize or reset the staking lockup when creating vesting contracts.

Add a call to reset the lockup period in the `create_vesting_contract` function:

```move
// In vesting.move, after line 601:
let pool_address = staking_contract::create_staking_contract_with_coins(
    &contract_signer, operator, voter, grant, commission_percentage, contract_creation_seed);

// ADD THIS:
let vesting_contract_signer = &get_vesting_account_signer_internal_from_cap(&contract_signer_cap);
staking_contract::reset_lockup(vesting_contract_signer, operator);
```

This ensures that newly created vesting contracts have their lockup period set to the standard recurring lockup duration, enforcing the intended staking lockup mechanism.

**Alternative Fix**: Document this behavior and provide clear guidance that administrators must call `reset_lockup()` immediately after creating vesting contracts. However, this is error-prone and less secure than automatically initializing the lockup.

## Proof of Concept

```move
#[test_only]
module test_address::vesting_lockup_bypass_test {
    use aptos_framework::vesting;
    use aptos_framework::timestamp;
    use aptos_framework::coin;
    use aptos_framework::aptos_coin::AptosCoin;
    use std::vector;
    use std::fixed_point32;
    
    #[test(aptos_framework = @aptos_framework, admin = @0x123, shareholder = @0x456)]
    public entry fun test_lockup_bypass(
        aptos_framework: &signer,
        admin: &signer,
        shareholder: &signer,
    ) {
        // Setup: Initialize framework and create test accounts
        // (Framework initialization code omitted for brevity)
        
        // Create vesting schedule: vest 100% after 1 month
        let schedule = vector::singleton(fixed_point32::create_from_rational(1, 1));
        let start_time = timestamp::now_seconds() + 86400; // Start tomorrow
        let vesting_schedule = vesting::create_vesting_schedule(schedule, start_time, 2592000); // 30 days period
        
        // Create vesting contract with 1,000,000 coins
        let grant_amount = 1000000;
        let shareholders = vector::singleton(@0x456);
        let grant_coins = coin::withdraw<AptosCoin>(admin, grant_amount);
        
        let contract_addr = vesting::create_vesting_contract(
            admin,
            &shareholders,
            simple_map::create(),
            vesting_schedule,
            @0x789, // withdrawal address
            @0xabc, // operator
            @0xdef, // voter
            10, // 10% commission
            vector::empty(),
        );
        
        // Fast forward past vesting start + 1 period
        timestamp::fast_forward_seconds(86400 + 2592000 + 1);
        
        // Shareholder calls vest() - this unlocks vested coins
        vesting::vest(contract_addr);
        
        // Shareholder immediately calls distribute() - should wait for lockup to expire
        // BUT due to the bug, coins are immediately available
        vesting::distribute(contract_addr);
        
        // ASSERTION: Shareholder should have received coins immediately
        // In a correct implementation, this should fail because lockup hasn't expired
        let shareholder_balance = coin::balance<AptosCoin>(@0x456);
        assert!(shareholder_balance == grant_amount, 0); // Coins received without lockup!
    }
}
```

**Test Execution**: This test demonstrates that vested coins can be withdrawn immediately after vesting, without respecting any staking lockup period, confirming the vulnerability.

## Notes

This vulnerability exists at the intersection of three system components:
- Vesting contract initialization that doesn't set lockup
- INACTIVE stake pools that don't receive automatic lockup renewal
- Edge case in `withdraw_with_cap` designed for validator exit scenarios

The fix should be implemented in the vesting contract creation to ensure all vesting contracts properly initialize their staking lockup period.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L700-705)
```text
        move_to(owner, StakePool {
            active: coin::zero<AptosCoin>(),
            pending_active: coin::zero<AptosCoin>(),
            pending_inactive: coin::zero<AptosCoin>(),
            inactive: coin::zero<AptosCoin>(),
            locked_until_secs: 0,
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1177-1181)
```text
        if (get_validator_state(pool_address) == VALIDATOR_STATUS_INACTIVE &&
            timestamp::now_seconds() >= stake_pool.locked_until_secs) {
            let pending_inactive_stake = coin::extract_all(&mut stake_pool.pending_inactive);
            coin::merge(&mut stake_pool.inactive, pending_inactive_stake);
        };
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1444-1449)
```text
            if (stake_pool.locked_until_secs <= reconfig_start_secs) {
                spec {
                    assume now_secs + recurring_lockup_duration_secs <= MAX_U64;
                };
                stake_pool.locked_until_secs = now_secs + recurring_lockup_duration_secs;
            };
```

**File:** aptos-move/framework/aptos-framework/sources/vesting.move (L544-657)
```text
    /// Create a vesting contract with a given configurations.
    public fun create_vesting_contract(
        admin: &signer,
        shareholders: &vector<address>,
        buy_ins: SimpleMap<address, Coin<AptosCoin>>,
        vesting_schedule: VestingSchedule,
        withdrawal_address: address,
        operator: address,
        voter: address,
        commission_percentage: u64,
        // Optional seed used when creating the staking contract account.
        contract_creation_seed: vector<u8>,
    ): address acquires AdminStore {
        check_vest_permission(admin);
        assert!(
            !system_addresses::is_reserved_address(withdrawal_address),
            error::invalid_argument(EINVALID_WITHDRAWAL_ADDRESS),
        );
        assert_account_is_registered_for_apt(withdrawal_address);
        assert!(vector::length(shareholders) > 0, error::invalid_argument(ENO_SHAREHOLDERS));
        assert!(
            simple_map::length(&buy_ins) == vector::length(shareholders),
            error::invalid_argument(ESHARES_LENGTH_MISMATCH),
        );

        // Create a coins pool to track shareholders and shares of the grant.
        let grant = coin::zero<AptosCoin>();
        let grant_amount = 0;
        let grant_pool = pool_u64::create(MAXIMUM_SHAREHOLDERS);
        vector::for_each_ref(shareholders, |shareholder| {
            let shareholder: address = *shareholder;
            let (_, buy_in) = simple_map::remove(&mut buy_ins, &shareholder);
            let buy_in_amount = coin::value(&buy_in);
            coin::merge(&mut grant, buy_in);
            pool_u64::buy_in(
                &mut grant_pool,
                shareholder,
                buy_in_amount,
            );
            grant_amount = grant_amount + buy_in_amount;
        });
        assert!(grant_amount > 0, error::invalid_argument(EZERO_GRANT));

        // If this is the first time this admin account has created a vesting contract, initialize the admin store.
        let admin_address = signer::address_of(admin);
        if (!exists<AdminStore>(admin_address)) {
            move_to(admin, AdminStore {
                vesting_contracts: vector::empty<address>(),
                nonce: 0,
                create_events: new_event_handle<CreateVestingContractEvent>(admin),
            });
        };

        // Initialize the vesting contract in a new resource account. This allows the same admin to create multiple
        // pools.
        let (contract_signer, contract_signer_cap) = create_vesting_contract_account(admin, contract_creation_seed);
        let pool_address = staking_contract::create_staking_contract_with_coins(
            &contract_signer, operator, voter, grant, commission_percentage, contract_creation_seed);

        // Add the newly created vesting contract's address to the admin store.
        let contract_address = signer::address_of(&contract_signer);
        let admin_store = borrow_global_mut<AdminStore>(admin_address);
        vector::push_back(&mut admin_store.vesting_contracts, contract_address);
        if (std::features::module_event_migration_enabled()) {
            emit(
                CreateVestingContract {
                    operator,
                    voter,
                    withdrawal_address,
                    grant_amount,
                    vesting_contract_address: contract_address,
                    staking_pool_address: pool_address,
                    commission_percentage,
                },
            );
        } else {
            emit_event(
                &mut admin_store.create_events,
                CreateVestingContractEvent {
                    operator,
                    voter,
                    withdrawal_address,
                    grant_amount,
                    vesting_contract_address: contract_address,
                    staking_pool_address: pool_address,
                    commission_percentage,
                },
            );
        };

        move_to(&contract_signer, VestingContract {
            state: VESTING_POOL_ACTIVE,
            admin: admin_address,
            grant_pool,
            beneficiaries: simple_map::create<address, address>(),
            vesting_schedule,
            withdrawal_address,
            staking: StakingInfo { pool_address, operator, voter, commission_percentage },
            remaining_grant: grant_amount,
            signer_cap: contract_signer_cap,
            update_operator_events: new_event_handle<UpdateOperatorEvent>(&contract_signer),
            update_voter_events: new_event_handle<UpdateVoterEvent>(&contract_signer),
            reset_lockup_events: new_event_handle<ResetLockupEvent>(&contract_signer),
            set_beneficiary_events: new_event_handle<SetBeneficiaryEvent>(&contract_signer),
            unlock_rewards_events: new_event_handle<UnlockRewardsEvent>(&contract_signer),
            vest_events: new_event_handle<VestEvent>(&contract_signer),
            distribute_events: new_event_handle<DistributeEvent>(&contract_signer),
            terminate_events: new_event_handle<TerminateEvent>(&contract_signer),
            admin_withdraw_events: new_event_handle<AdminWithdrawEvent>(&contract_signer),
        });

        simple_map::destroy_empty(buy_ins);
        contract_address
    }
```
