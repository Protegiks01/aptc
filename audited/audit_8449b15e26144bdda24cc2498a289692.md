# Audit Report

## Title
Gas Undercharging in Vector Push Operations for Large Vectors

## Summary
The `charge_vec_push_back()` function in the production gas meter charges a flat base cost plus the size of the pushed value, but does not account for the computational cost of vector reallocation when pushing to large vectors. This allows transactions to perform O(n) work while paying O(1) gas.

## Finding Description

The production gas metering implementation charges only a constant `VEC_PUSH_BACK_BASE` cost when pushing to vectors: [1](#0-0) 

During VM execution, when the `VecPushBack` bytecode instruction is executed, gas is charged before the actual push: [2](#0-1) 

The actual push operation delegates to Rust's standard `Vec::push()`, which performs reallocation when capacity is exceeded: [3](#0-2) 

When a Rust `Vec` reaches capacity and a new element is pushed, it reallocates memory (typically doubling capacity) and copies all existing elements to the new buffer. This operation has O(n) complexity where n is the current vector size, but the gas charged remains constant regardless of vector size.

The memory tracking wrapper adds heap memory charges for the pushed value only: [4](#0-3) 

**Attack Scenario:**
1. Create a vector and grow it to a large size (limited by the 1MB memory quota)
2. Continue pushing elements, triggering periodic reallocations
3. Each reallocation copies all existing elements (O(n) work)
4. Gas charged remains constant (O(1) cost)

## Impact Explanation

This issue qualifies as **Medium severity** under the Aptos bug bounty criteria, as it represents a resource metering inaccuracy. However, the practical impact is significantly limited by the 1MB memory quota per transaction: [5](#0-4) 

The memory quota of 10,000,000 abstract value units effectively caps the maximum vector size achievable in a single transaction. For a vector of u64 values, this limits the vector to approximately 1.25 million elements. While reallocation of such a vector requires copying ~10MB of data, modern CPUs can perform this operation in microseconds, making the actual performance impact negligible.

**Critical limitation:** This does NOT break consensus because all validators execute identical bytecode deterministically and experience the same undercharging. There is no safety violation or state divergence.

## Likelihood Explanation

**Likelihood: High** - Any transaction sender can exploit this by creating large vectors and pushing elements. No special permissions or validator access required.

**Impact: Low-Medium** - The computational overhead is bounded by the memory quota and does not cause significant validator slowdowns in practice. The memory copy operations involved (~10MB max) are trivial for modern hardware.

## Recommendation

Modify the gas charging formula to account for amortized reallocation costs or charge based on current vector capacity. One approach:

```rust
fn charge_vec_push_back(&mut self, val: impl ValueView) -> PartialVMResult<()> {
    // Base cost plus cost proportional to value size
    let base_cost = VEC_PUSH_BACK_BASE;
    
    // Add amortized cost for potential reallocation
    // This accounts for the O(n) copy that occurs when capacity is exceeded
    let amortized_cost = self.algebra.charge_execution(base_cost)?;
    
    // Consider vector size in gas calculation for large vectors
    // (implementation would need access to vector size)
    
    amortized_cost
}
```

A more accurate approach would require tracking vector capacity and charging proportionally when reallocation occurs.

## Proof of Concept

```move
module attacker::gas_exploit {
    use std::vector;
    
    public entry fun exploit() {
        // Create a large vector (limited by 1MB memory quota)
        let v = vector::empty<u64>();
        
        // Grow vector to near memory limit
        let i = 0;
        while (i < 1_000_000) {
            vector::push_back(&mut v, i);
            i = i + 1;
        };
        
        // Continue pushing - each reallocation copies 1M+ elements
        // but charges constant gas
        let j = 0;
        while (j < 100) {
            vector::push_back(&mut v, 999999);
            j = j + 1;
        };
    }
}
```

**Notes:**

While this vulnerability exists in theory, **the practical security impact does not meet the threshold for a valid bug bounty submission** because:

1. The 1MB memory quota strictly bounds the maximum impact per transaction
2. Memory copy operations of ~10MB are negligible on modern validator hardware
3. No consensus safety violation occurs (all validators execute identically)
4. No funds are at risk
5. No meaningful validator slowdown is achieved

This represents a **gas pricing accuracy issue** rather than a critical security vulnerability. The undercharging factor is real but the absolute impact is too small to affect network security or validator performance meaningfully.

### Citations

**File:** aptos-move/aptos-gas-meter/src/meter.rs (L517-520)
```rust
    #[inline]
    fn charge_vec_push_back(&mut self, _val: impl ValueView) -> PartialVMResult<()> {
        self.algebra.charge_execution(VEC_PUSH_BACK_BASE)
    }
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L2992-2999)
```rust
                    Instruction::VecPushBack(si) => {
                        let elem = interpreter.operand_stack.pop()?;
                        let vec_ref = interpreter.operand_stack.pop_as::<VectorRef>()?;
                        let (_, ty_count) = frame_cache.get_signature_index_type(*si, self)?;
                        gas_meter.charge_create_ty(ty_count)?;
                        gas_meter.charge_vec_push_back(&elem)?;
                        vec_ref.push_back(elem)?;
                    },
```

**File:** third_party/move/move-vm/types/src/values/values_impl.rs (L3723-3747)
```rust
    pub fn push_back(&self, e: Value) -> PartialVMResult<()> {
        let c = self.0.container();

        match c {
            Container::VecU8(r) => r.borrow_mut().push(e.value_as()?),
            Container::VecU16(r) => r.borrow_mut().push(e.value_as()?),
            Container::VecU32(r) => r.borrow_mut().push(e.value_as()?),
            Container::VecU64(r) => r.borrow_mut().push(e.value_as()?),
            Container::VecU128(r) => r.borrow_mut().push(e.value_as()?),
            Container::VecU256(r) => r.borrow_mut().push(e.value_as()?),
            Container::VecI8(r) => r.borrow_mut().push(e.value_as()?),
            Container::VecI16(r) => r.borrow_mut().push(e.value_as()?),
            Container::VecI32(r) => r.borrow_mut().push(e.value_as()?),
            Container::VecI64(r) => r.borrow_mut().push(e.value_as()?),
            Container::VecI128(r) => r.borrow_mut().push(e.value_as()?),
            Container::VecI256(r) => r.borrow_mut().push(e.value_as()?),
            Container::VecBool(r) => r.borrow_mut().push(e.value_as()?),
            Container::VecAddress(r) => r.borrow_mut().push(e.value_as()?),
            Container::Vec(r) => r.borrow_mut().push(e),
            Container::Locals(_) | Container::Struct(_) => unreachable!(),
        }

        self.0.mark_dirty();
        Ok(())
    }
```

**File:** aptos-move/aptos-memory-usage-tracker/src/lib.rs (L608-617)
```rust
    fn charge_vec_push_back(&mut self, val: impl ValueView) -> PartialVMResult<()> {
        self.use_heap_memory(
            self.vm_gas_params()
                .misc
                .abs_val
                .abstract_packed_size(&val)?,
        )?;

        self.base.charge_vec_push_back(val)
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

//! This module defines all the gas parameters for transactions, along with their initial values
//! in the genesis and a mapping between the Rust representation and the on-chain gas schedule.

use crate::{
    gas_schedule::VMGasParameters,
    ver::gas_feature_versions::{
        RELEASE_V1_10, RELEASE_V1_11, RELEASE_V1_12, RELEASE_V1_13, RELEASE_V1_15, RELEASE_V1_26,
        RELEASE_V1_41,
    },
};
use aptos_gas_algebra::{
    AbstractValueSize, Fee, FeePerByte, FeePerGasUnit, FeePerSlot, Gas, GasExpression,
    GasScalingFactor, GasUnit, NumModules, NumSlots, NumTypeNodes,
};
use move_core_types::gas_algebra::{
    InternalGas, InternalGasPerArg, InternalGasPerByte, InternalGasUnit, NumBytes, ToUnitWithParams,
};

const GAS_SCALING_FACTOR: u64 = 1_000_000;

crate::gas_schedule::macros::define_gas_parameters!(
    TransactionGasParameters,
    "txn",
    VMGasParameters => .txn,
    [
        // The flat minimum amount of gas required for any transaction.
        // Charged at the start of execution.
        // It is variable to charge more for more expensive authenticators, e.g., keyless
        [
            min_transaction_gas_units: InternalGas,
            "min_transaction_gas_units",
            2_760_000
        ],
        // Any transaction over this size will be charged an additional amount per byte.
        [
            large_transaction_cutoff: NumBytes,
            "large_transaction_cutoff",
            600
        ],
        // The units of gas that to be charged per byte over the `large_transaction_cutoff` in addition to
        // `min_transaction_gas_units` for transactions whose size exceeds `large_transaction_cutoff`.
        [
            intrinsic_gas_per_byte: InternalGasPerByte,
            "intrinsic_gas_per_byte",
            1_158
        ],
        // ~5 microseconds should equal one unit of computational gas. We bound the maximum
```
