# Audit Report

## Title
Critical Write-Set Verification Bypass in Transaction Restore Allows Arbitrary State Corruption

## Summary
The transaction restore mechanism in `storage/backup/backup-cli/src/backup_types/transaction/restore.rs` fails to cryptographically verify that write-sets loaded from backup storage match their corresponding `state_change_hash` values in `TransactionInfo` objects. This allows a malicious backup storage provider to inject arbitrary state modifications that will be applied to the blockchain database without detection, breaking the fundamental state consistency guarantee.

## Finding Description

The vulnerability exists in the `LoadedChunk::load` function which reads transaction data from backup storage. The function performs the following operations: [1](#0-0) 

The function reads transactions, transaction_infos, events, and **write_sets** from the backup file. It then verifies the data: [2](#0-1) 

However, the verification only covers transactions and events. The `TransactionListWithProof::verify` method checks: [3](#0-2) 

This verification **does not include write_sets**. The `TransactionInfo` structure contains a `state_change_hash` field that represents the hash of the write_set: [4](#0-3) 

Despite this hash being cryptographically verified as part of the transaction accumulator proof, the actual write_set data loaded from storage is **never compared** against this hash.

The unverified write_sets are then used in two paths:

1. **Direct save path**: Write_sets are saved directly to the database: [5](#0-4) 

2. **Replay path**: When `VerifyExecutionMode::NoVerify` is used (the default in production): [6](#0-5) 

The chunk executor skips re-execution verification: [7](#0-6) 

And applies write_sets directly: [8](#0-7) 

The verifier only checks that transaction_infos match, not write_sets: [9](#0-8) 

**Attack Scenario:**
1. Attacker compromises backup storage or provides malicious backup data
2. Attacker crafts backup with correct transactions, transaction_infos, events, and proofs (these pass verification)
3. Attacker includes malicious write_sets that **do not** match the `state_change_hash` values
4. Node restores from this backup
5. Malicious write_sets are applied to the database without verification
6. Node's state is corrupted with arbitrary modifications (mint tokens, transfer balances, modify validator set, etc.)

## Impact Explanation

**Critical Severity** - This vulnerability qualifies for the highest severity category ($1,000,000) under the Aptos bug bounty program because it enables:

1. **Consensus/Safety Violations**: Different nodes restoring from the same malicious backup could receive different write_sets on repeated reads, leading to state divergence and consensus splits across the network.

2. **Loss of Funds**: Malicious write_sets can arbitrarily modify account balances, mint tokens, or transfer funds without authorization.

3. **State Consistency Violation**: Breaks the fundamental invariant that "State transitions must be atomic and verifiable via Merkle proofs" - the Merkle proofs verify the state_change_hash, but the actual write_sets applied don't match.

4. **Deterministic Execution Violation**: Breaks the invariant that "All validators must produce identical state roots for identical blocks" - validators restoring from malicious backups will have corrupted state.

The vulnerability affects any node performing database restoration from backups, which is a critical operational procedure for:
- Bootstrapping new validator nodes
- Recovering from hardware failures
- Archival node synchronization

## Likelihood Explanation

**High Likelihood** - The attack is realistic and feasible:

1. **Attack Surface**: Any node operator using backup/restore functionality is vulnerable
2. **Attacker Capabilities**: Requires either:
   - Compromise of backup storage infrastructure
   - Man-in-the-middle position to modify backup data during transit
   - Operation of a malicious backup service provider
3. **No Special Privileges Required**: Does not require validator credentials or consensus participation
4. **Silent Failure**: The vulnerability produces no warnings or errors - malicious write_sets are silently accepted
5. **Production Impact**: The code path is actively used in production via `db-tool` and restoration workflows

## Recommendation

**Immediate Fix**: Add write_set verification in `LoadedChunk::load`:

```rust
// After line 167, add write_set verification:
for (write_set, txn_info) in write_sets.iter().zip(txn_infos.iter()) {
    let computed_hash = CryptoHash::hash(write_set);
    ensure!(
        computed_hash == txn_info.state_change_hash(),
        "Write set hash mismatch at version {}. Expected: {:?}, Computed: {:?}",
        txn_info.transaction_hash(),
        txn_info.state_change_hash(),
        computed_hash
    );
}
```

The proper verification already exists in `TransactionOutput::ensure_match_transaction_info`: [10](#0-9) 

This same verification logic should be applied during the restore process before write_sets are persisted or replayed.

**Alternative Fix**: Always use `VerifyExecutionMode::Verify` instead of `NoVerify` during restore, which would re-execute transactions and verify outputs match. However, this is computationally expensive and the direct hash verification is more efficient.

## Proof of Concept

```rust
// Malicious BackupStorage implementation
struct MaliciousBackupStorage {
    inner: Arc<dyn BackupStorage>,
    malicious_write_sets: HashMap<FileHandle, Vec<WriteSet>>,
}

#[async_trait]
impl BackupStorage for MaliciousBackupStorage {
    async fn open_for_read(&self, file_handle: &FileHandleRef) -> Result<Box<dyn AsyncRead + Send + Unpin>> {
        // Intercept transaction chunk files
        if file_handle.contains("transactions") {
            // Return modified stream with malicious write_sets
            return Ok(Box::new(self.create_malicious_stream(file_handle).await?));
        }
        // Pass through proof files unchanged (they will verify correctly)
        self.inner.open_for_read(file_handle).await
    }
    
    // ... other methods proxy to inner
}

// The malicious stream replaces write_sets in the BCS-encoded records
// while keeping transactions, events, and transaction_infos intact.
// Since write_sets are never verified against state_change_hash,
// arbitrary state modifications will be applied to the database.
```

To demonstrate:
1. Create a backup with valid transaction data
2. Modify the backup to replace write_sets with malicious versions (e.g., minting tokens)
3. Keep all proofs and transaction_infos unchanged
4. Restore from the modified backup
5. Observe that malicious write_sets are applied without any verification failure

## Notes

This vulnerability specifically addresses the security question about "malicious storage returning different data on repeated reads." While the code doesn't explicitly read the same handle multiple times in a single restore operation, the core issue is that **write_sets are never verified against their cryptographic commitments** (`state_change_hash`), allowing malicious storage to provide arbitrary write_set data that will be blindly accepted and applied to the blockchain state.

The `state_change_hash` field in `TransactionInfo` exists precisely to prevent this type of attack - it cryptographically commits to the write_set content. However, the restore code fails to enforce this commitment, creating a critical security gap in the backup/restore workflow.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L105-137)
```rust
        let mut file = BufReader::new(storage.open_for_read(&manifest.transactions).await?);
        let mut txns = Vec::new();
        let mut persisted_aux_info = Vec::new();
        let mut txn_infos = Vec::new();
        let mut event_vecs = Vec::new();
        let mut write_sets = Vec::new();

        while let Some(record_bytes) = file.read_record_bytes().await? {
            let (txn, aux_info, txn_info, events, write_set): (
                _,
                PersistedAuxiliaryInfo,
                _,
                _,
                WriteSet,
            ) = match manifest.format {
                TransactionChunkFormat::V0 => {
                    let (txn, txn_info, events, write_set) = bcs::from_bytes(&record_bytes)?;
                    (
                        txn,
                        PersistedAuxiliaryInfo::None,
                        txn_info,
                        events,
                        write_set,
                    )
                },
                TransactionChunkFormat::V1 => bcs::from_bytes(&record_bytes)?,
            };
            txns.push(txn);
            persisted_aux_info.push(aux_info);
            txn_infos.push(txn_info);
            event_vecs.push(events);
            write_sets.push(write_set);
        }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L147-167)
```rust
        let (range_proof, ledger_info) = storage
            .load_bcs_file::<(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)>(
                &manifest.proof,
            )
            .await?;
        if let Some(epoch_history) = epoch_history {
            epoch_history.verify_ledger_info(&ledger_info)?;
        }

        // make a `TransactionListWithProof` to reuse its verification code.
        let txn_list_with_proof =
            TransactionListWithProofV2::new(TransactionListWithAuxiliaryInfos::new(
                TransactionListWithProof::new(
                    txns,
                    Some(event_vecs),
                    Some(manifest.first_version),
                    TransactionInfoListWithProof::new(range_proof, txn_infos),
                ),
                persisted_aux_info,
            ));
        txn_list_with_proof.verify(ledger_info.ledger_info(), Some(manifest.first_version))?;
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L507-516)
```rust
                        tokio::task::spawn_blocking(move || {
                            restore_handler.save_transactions(
                                first_version,
                                &txns_to_save,
                                &persisted_aux_info_to_save,
                                &txn_infos_to_save,
                                &event_vecs_to_save,
                                write_sets_to_save,
                            )
                        })
```

**File:** types/src/transaction/mod.rs (L1898-1908)
```rust
        let write_set_hash = CryptoHash::hash(self.write_set());
        ensure!(
            write_set_hash == txn_info.state_change_hash(),
            "{}: version:{}, write_set_hash:{:?}, expected:{:?}, write_set: {:?}, expected(if known): {:?}",
            ERR_MSG,
            version,
            write_set_hash,
            txn_info.state_change_hash(),
            self.write_set,
            expected_write_set,
        );
```

**File:** types/src/transaction/mod.rs (L2040-2042)
```rust
    /// The hash value summarizing all changes caused to the world state by this transaction.
    /// i.e. hash of the output write set.
    state_change_hash: HashValue,
```

**File:** types/src/transaction/mod.rs (L2295-2350)
```rust
    pub fn verify(
        &self,
        ledger_info: &LedgerInfo,
        first_transaction_version: Option<Version>,
    ) -> Result<()> {
        // Verify the first transaction versions match
        ensure!(
            self.get_first_transaction_version() == first_transaction_version,
            "First transaction version ({:?}) doesn't match given version ({:?}).",
            self.get_first_transaction_version(),
            first_transaction_version,
        );

        // Verify the lengths of the transactions and transaction infos match
        ensure!(
            self.proof.transaction_infos.len() == self.get_num_transactions(),
            "The number of TransactionInfo objects ({}) does not match the number of \
             transactions ({}).",
            self.proof.transaction_infos.len(),
            self.get_num_transactions(),
        );

        // Verify the transaction hashes match those of the transaction infos
        self.transactions
            .par_iter()
            .zip_eq(self.proof.transaction_infos.par_iter())
            .map(|(txn, txn_info)| {
                let txn_hash = CryptoHash::hash(txn);
                ensure!(
                    txn_hash == txn_info.transaction_hash(),
                    "The hash of transaction does not match the transaction info in proof. \
                     Transaction hash: {:x}. Transaction hash in txn_info: {:x}.",
                    txn_hash,
                    txn_info.transaction_hash(),
                );
                Ok(())
            })
            .collect::<Result<Vec<_>>>()?;

        // Verify the transaction infos are proven by the ledger info.
        self.proof
            .verify(ledger_info, self.get_first_transaction_version())?;

        // Verify the events if they exist.
        if let Some(event_lists) = &self.events {
            ensure!(
                event_lists.len() == self.get_num_transactions(),
                "The length of event_lists ({}) does not match the number of transactions ({}).",
                event_lists.len(),
                self.get_num_transactions(),
            );
            event_lists
                .into_par_iter()
                .zip_eq(self.proof.transaction_infos.par_iter())
                .map(|(events, txn_info)| verify_events_against_root_hash(events, txn_info))
                .collect::<Result<Vec<_>>>()?;
```

**File:** storage/db-tool/src/restore.rs (L102-110)
```rust
                        TransactionRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                            None, /* epoch_history */
                            VerifyExecutionMode::NoVerify,
                        )
                        .run()
                        .await?;
```

**File:** execution/executor/src/chunk_executor/mod.rs (L562-575)
```rust
            let next_begin = if verify_execution_mode.should_verify() {
                self.verify_execution(
                    transactions,
                    persisted_aux_info,
                    transaction_infos,
                    write_sets,
                    event_vecs,
                    batch_begin,
                    batch_end,
                    verify_execution_mode,
                )?
            } else {
                batch_end
            };
```

**File:** execution/executor/src/chunk_executor/mod.rs (L675-686)
```rust
        .map(|(txn, persisted_aux_info, txn_info, write_set, events)| {
            (
                txn,
                persisted_aux_info,
                TransactionOutput::new(
                    write_set,
                    events,
                    txn_info.gas_used(),
                    TransactionStatus::Keep(txn_info.status().clone()),
                    TransactionAuxiliaryData::default(), // No auxiliary data if transaction is not executed through VM
                ),
            )
```

**File:** execution/executor/src/chunk_executor/chunk_result_verifier.rs (L134-140)
```rust
    fn verify_chunk_result(
        &self,
        _parent_accumulator: &InMemoryTransactionAccumulator,
        ledger_update_output: &LedgerUpdateOutput,
    ) -> Result<()> {
        ledger_update_output.ensure_transaction_infos_match(&self.transaction_infos)
    }
```
