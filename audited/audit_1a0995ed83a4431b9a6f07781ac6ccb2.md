# Audit Report

## Title
Guard Type is Incorrectly Send-Safe, Enabling Undefined Behavior Through Cross-Thread Access

## Summary
The `Guard<'a, T>` struct in `explicit_sync_wrapper.rs` is automatically `Send` due to its field being a reference to a `Sync` type, but this violates the single-threaded access model that `ExplicitSyncWrapper` is designed to enforce. This allows Guards to be sent across threads and enables multiple Guards to provide concurrent mutable access to the same data, causing undefined behavior.

## Finding Description

The `ExplicitSyncWrapper` is designed for parallel algorithms that can prove sequential access to shared data, as stated in its documentation [1](#0-0) . 

The `Guard` struct holds a reference to an `ExplicitSyncWrapper` [2](#0-1) .

The critical issue arises from the unconditional `Sync` implementation [3](#0-2) . This makes `&ExplicitSyncWrapper<T>` automatically `Send`, which in turn makes `Guard<'a, T>` automatically `Send` regardless of `T`.

The `acquire()` method provides no mutual exclusionâ€”it simply creates a new Guard with acquire fence semantics [4](#0-3) . Nothing prevents multiple Guards from being created simultaneously.

The `dereference_mut()` method returns a mutable reference to the underlying data using unsafe code [5](#0-4) , which Guards can access through `DerefMut` [6](#0-5) .

This creates multiple soundness violations:

1. **Memory Ordering Violation**: If a Guard is sent to another thread, the acquire fence executes on one thread while the release fence (in Drop) executes on another, breaking the synchronization model.

2. **Aliasing Violation**: Multiple Guards can exist simultaneously, each providing mutable access to the same data, violating Rust's aliasing rules and causing undefined behavior.

In the block executor, `ExplicitSyncWrapper` is used for critical shared state including `final_results`, `block_limit_processor`, and `maybe_block_epilogue_txn_idx` [7](#0-6) . These are accessed by multiple worker threads running in parallel [8](#0-7) .

While the current implementation uses scheduler locks to coordinate access [9](#0-8) , the type system does not enforce these guarantees, making the code fragile and susceptible to bugs.

## Impact Explanation

This is a **High Severity** soundness bug. While not directly exploitable by external attackers, it creates undefined behavior that could lead to:

1. **Consensus Violations**: If triggered, undefined behavior in the block executor could cause different validators to produce different state roots for the same block, violating the **Deterministic Execution** invariant and potentially causing chain splits.

2. **State Corruption**: Concurrent mutable access to `final_results` or `block_limit_processor` could corrupt execution results, leading to incorrect transaction outcomes.

3. **Non-Deterministic Behavior**: Undefined behavior is inherently non-deterministic, which is catastrophic for blockchain consensus where all validators must reach identical results.

The bug could be triggered by:
- Future code refactoring that inadvertently sends Guards across threads
- Accidental acquisition of multiple Guards in error-handling paths
- Optimization attempts that introduce concurrent access patterns

## Likelihood Explanation

**Current Likelihood: Low** - The existing code appears to use proper synchronization through scheduler locks, preventing this bug from manifesting.

**Future Likelihood: Medium-High** - The type system does not prevent misuse, making this a latent bug that could be triggered by:
- Code maintenance and refactoring
- Performance optimizations
- New features that interact with the block executor
- Subtle bugs in error handling or edge cases

The fact that the type incorrectly advertises itself as `Send`-safe means developers could reasonably assume it's safe to send Guards across threads, leading to accidental misuse.

## Recommendation

Make `Guard` explicitly `!Send` by adding a `PhantomData` marker:

```rust
use std::marker::PhantomData;

pub struct Guard<'a, T> {
    lock: &'a ExplicitSyncWrapper<T>,
    _not_send: PhantomData<*mut ()>,  // Ensures Guard is !Send and !Sync
}
```

Update the `acquire()` method:

```rust
pub fn acquire(&self) -> Guard<'_, T> {
    atomic::fence(atomic::Ordering::Acquire);
    Guard { 
        lock: self,
        _not_send: PhantomData,
    }
}
```

This prevents Guards from being sent to other threads at compile time, enforcing the single-threaded access model that `ExplicitSyncWrapper` is designed for.

## Proof of Concept

```rust
use std::sync::Arc;
use std::thread;
use aptos_block_executor::explicit_sync_wrapper::ExplicitSyncWrapper;

fn demonstrate_unsoundness() {
    // Shared wrapper containing a vector
    let wrapper = Arc::new(ExplicitSyncWrapper::new(vec![1, 2, 3]));
    let wrapper_clone = wrapper.clone();
    
    // Acquire first guard
    let mut guard1 = wrapper.acquire();
    
    // Send guard1 to another thread
    let handle = thread::spawn(move || {
        let v1 = guard1.deref_mut();
        v1.push(4);  // Mutable access on thread B
    });
    
    // Meanwhile, acquire another guard on the original thread
    let mut guard2 = wrapper_clone.acquire();
    let v2 = guard2.deref_mut();  // Concurrent mutable access - UB!
    v2.push(5);
    
    handle.join().unwrap();
    
    // Result is non-deterministic due to data race
}

// This compiles today but should not - Guard should be !Send
```

This demonstrates that `Guard` being `Send` enables undefined behavior through concurrent mutable access to the same data. The fix (adding `PhantomData<*mut ()>`) would make this code fail to compile, preventing the bug at compile time.

### Citations

**File:** aptos-move/block-executor/src/explicit_sync_wrapper.rs (L10-18)
```rust
// Parallel algorithms often guarantee a sequential use of certain
// data structures, or parts of the data-structures (like elements of
// a vector).  The rust compiler can not prove the safety of even
// slightly complex parallel algorithms.

/// ExplicitSyncWrapper is meant to be used in parallel algorithms
/// where we can prove that there will be no concurrent access to the
/// underlying object (or its elements).  Use with caution - only when
/// the safety can be proven.
```

**File:** aptos-move/block-executor/src/explicit_sync_wrapper.rs (L24-26)
```rust
pub struct Guard<'a, T> {
    lock: &'a ExplicitSyncWrapper<T>,
}
```

**File:** aptos-move/block-executor/src/explicit_sync_wrapper.rs (L35-38)
```rust
    pub fn acquire(&self) -> Guard<'_, T> {
        atomic::fence(atomic::Ordering::Acquire);
        Guard { lock: self }
    }
```

**File:** aptos-move/block-executor/src/explicit_sync_wrapper.rs (L60-62)
```rust
    pub fn dereference_mut<'a>(&self) -> &'a mut T {
        unsafe { &mut *self.value.get() }
    }
```

**File:** aptos-move/block-executor/src/explicit_sync_wrapper.rs (L83-87)
```rust
impl<T> DerefMut for Guard<'_, T> {
    fn deref_mut(&mut self) -> &mut T {
        self.lock.dereference_mut()
    }
}
```

**File:** aptos-move/block-executor/src/explicit_sync_wrapper.rs (L95-95)
```rust
unsafe impl<T> Sync for ExplicitSyncWrapper<T> {}
```

**File:** aptos-move/block-executor/src/executor.rs (L96-98)
```rust
    block_limit_processor: &'a ExplicitSyncWrapper<BlockGasLimitProcessor<T>>,
    final_results: &'a ExplicitSyncWrapper<Vec<E::Output>>,
    maybe_block_epilogue_txn_idx: &'a ExplicitSyncWrapper<Option<TxnIndex>>,
```

**File:** aptos-move/block-executor/src/executor.rs (L1335-1361)
```rust
            while scheduler.should_coordinate_commits() {
                while let Some((txn_idx, incarnation)) = scheduler.try_commit() {
                    if txn_idx + 1 == num_txns as u32
                        && matches!(
                            scheduler_task,
                            SchedulerTask::ExecutionTask(_, _, ExecutionTaskType::Execution)
                        )
                    {
                        return Err(PanicOr::from(code_invariant_error(
                            "All transactions can be committed, can't have execution task",
                        )));
                    }

                    self.prepare_and_queue_commit_ready_txn(
                        txn_idx,
                        incarnation,
                        num_txns as u32,
                        executor,
                        block,
                        num_workers,
                        runtime_environment,
                        scheduler_wrapper,
                        shared_sync_params,
                    )?;
                }
                scheduler.queueing_commits_mark_done();
            }
```

**File:** aptos-move/block-executor/src/executor.rs (L1765-1786)
```rust
        self.executor_thread_pool.scope(|s| {
            for worker_id in &worker_ids {
                s.spawn(|_| {
                    let environment = module_cache_manager_guard.environment();
                    let executor = {
                        let _init_timer = VM_INIT_SECONDS.start_timer();
                        E::init(
                            &environment.clone(),
                            shared_sync_params.base_view,
                            async_runtime_checks_enabled,
                        )
                    };

                    if let Err(err) = self.worker_loop_v2(
                        &executor,
                        signature_verified_block,
                        environment,
                        *worker_id,
                        num_workers,
                        &scheduler,
                        &shared_sync_params,
                    ) {
```
