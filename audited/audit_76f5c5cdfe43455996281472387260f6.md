# Audit Report

## Title
Gas Bypass via Disabled ChargeInvariantViolation Feature Flag Enables DoS Attacks

## Summary
When the `ChargeInvariantViolation` feature flag is disabled, transactions that trigger Move VM invariant violations are discarded without charging gas fees, allowing attackers who can trigger such violations to perform DoS attacks by consuming validator computational resources without payment.

## Finding Description

The Aptos VM implements a feature flag `ChargeInvariantViolation` that controls whether transactions triggering invariant violations should be kept in blocks and charged gas, or discarded without gas charges. [1](#0-0) 

When this feature flag is **disabled**, the transaction status determination logic in `TransactionStatus::from_vm_status()` treats invariant violations as `Discard` status, which results in zero gas charges: [2](#0-1) 

The discarded output creates an empty VMOutput with no state changes and no gas charged.

However, by the time an invariant violation is detected during transaction execution, validators have already expended significant computational resources:

1. **Mempool validation**: Running the prologue to validate signatures, balances, and sequence numbers [3](#0-2) 

2. **Block execution**: Re-running prologue, executing the main transaction payload up to the point of invariant violation [4](#0-3) 

3. **Failure handling**: Processing the error through `failed_transaction_cleanup()` [5](#0-4) 

The code itself contains an explicit warning about this DoS risk: [6](#0-5) 

Invariant violations can occur during runtime through paranoid type checks, which are **enabled by default** in production: [7](#0-6) 

These runtime checks validate type safety constraints that should have been verified at bytecode verification time, but may fail due to:
- Edge cases in complex type system features (closures, enums, function values)
- Discrepancies between verifier and runtime expectations  
- Bugs in the bytecode verifier or VM implementation

The test suite confirms this behavior: [8](#0-7) 

## Impact Explanation

**Severity: Critical**

This vulnerability enables **Denial of Service attacks** where malicious actors can:

1. Craft or discover transactions that pass mempool validation but trigger invariant violations during block execution
2. Flood the network with such transactions
3. Consume validator computational resources (CPU, memory, I/O) without paying gas fees
4. Degrade network performance or cause validator nodes to fall behind
5. Potentially cause total loss of liveness if all validators are overwhelmed

The impact qualifies as **Critical Severity** under Aptos Bug Bounty criteria because it can lead to:
- **Total loss of liveness/network availability**: Validators overwhelmed with free processing
- **Significant protocol violation**: Gas metering invariant broken (all operations must charge gas)
- **Resource exhaustion attack**: Computational resources consumed without payment

The attack requires **no privileged access** - any transaction sender can exploit this if they can trigger invariant violations.

## Likelihood Explanation

**Likelihood: Medium-High (when feature flag is disabled)**

Current State:
- The `ChargeInvariantViolation` flag is **enabled by default** at genesis [9](#0-8) 

- This mitigates the immediate risk

However, the vulnerability becomes exploitable if:

1. **Governance disables the flag**: The feature flag can be toggled through on-chain governance proposals, which could happen intentionally or through a malicious governance attack

2. **Invariant violations can be triggered**: While these represent VM bugs rather than normal execution paths, the existence of paranoid runtime checks indicates the developers anticipated potential edge cases. Historical examples of type system bugs in complex VMs (e.g., Java, .NET) suggest such triggers may exist.

The explicit DoS warning in the production code indicates the Aptos developers recognized this as a real threat, not just a theoretical concern.

## Recommendation

**Recommendation 1: Make ChargeInvariantViolation non-disableable**

Remove the ability to disable this feature flag through governance. Make invariant violation gas charging mandatory:

```rust
// In types/src/transaction/mod.rs, remove the feature flag check:
Err(code) => {
    if code.status_type() == StatusType::InvariantViolation {
        // Always keep and charge for invariant violations
        Self::Keep(ExecutionStatus::MiscellaneousError(Some(code)))
    } else {
        Self::Discard(code)
    }
}
```

**Recommendation 2: Add governance safety check**

If the flag must remain configurable, add additional validation in the feature flag change proposal system to warn or block disabling this critical security feature.

**Recommendation 3: Document the security implications**

Add explicit security documentation warning governance participants about the DoS risk of disabling this flag.

## Proof of Concept

While a complete PoC requires discovering a specific transaction that triggers invariant violations (which represents a separate VM bug), the mechanism can be demonstrated through the existing test: [10](#0-9) 

This test shows:
1. With flag enabled: Invariant violation → Transaction kept and gas charged
2. With flag disabled: Invariant violation → Transaction discarded, zero gas charged
3. The test uses fault injection (`fail::cfg`) to simulate invariant violations, demonstrating the mechanism works as described

For a production exploit, an attacker would need to identify transactions that legitimately trigger paranoid check failures or other invariant violations without artificial fault injection. The existence of paranoid runtime checks and the explicit DoS warning suggest such cases may exist in edge cases of the type system implementation.

### Citations

**File:** types/src/transaction/mod.rs (L1639-1647)
```rust
            Err(code) => {
                if code.status_type() == StatusType::InvariantViolation
                    && features.is_enabled(FeatureFlag::CHARGE_INVARIANT_VIOLATION)
                {
                    Self::Keep(ExecutionStatus::MiscellaneousError(Some(code)))
                } else {
                    Self::Discard(code)
                }
            },
```

**File:** aptos-move/aptos-vm/src/errors.rs (L307-309)
```rust
pub(crate) fn discarded_output(status_code: StatusCode) -> VMOutput {
    VMOutput::empty_with_status(TransactionStatus::Discard(status_code))
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L561-632)
```rust
    pub(crate) fn failed_transaction_cleanup(
        &self,
        prologue_session_change_set: SystemSessionChangeSet,
        error_vm_status: VMStatus,
        gas_meter: &mut impl AptosGasMeter,
        txn_data: &TransactionMetadata,
        resolver: &impl AptosMoveResolver,
        module_storage: &impl AptosModuleStorage,
        serialized_signers: &SerializedSigners,
        log_context: &AdapterLogSchema,
        change_set_configs: &ChangeSetConfigs,
        traversal_context: &mut TraversalContext,
    ) -> (VMStatus, VMOutput) {
        if self.gas_feature_version() >= 12 {
            // Check if the gas meter's internal counters are consistent.
            //
            // Since we are already in the failure epilogue, there is not much we can do
            // other than logging the inconsistency.
            //
            // This is a tradeoff. We have to either
            //   1. Continue to calculate the gas cost based on the numbers we have.
            //   2. Discard the transaction.
            //
            // Option (2) does not work, since it would enable DoS attacks.
            // Option (1) is not ideal, but optimistically, it should allow the network
            // to continue functioning, less the transactions that run into this problem.
            if let Err(err) = gas_meter.algebra().check_consistency() {
                println!(
                    "[aptos-vm][gas-meter][failure-epilogue] {}",
                    err.message()
                        .unwrap_or("No message found -- this should not happen.")
                );
            }
        }

        let txn_status = TransactionStatus::from_vm_status(
            error_vm_status.clone(),
            self.features(),
            self.gas_feature_version() >= RELEASE_V1_38,
        );

        match txn_status {
            TransactionStatus::Keep(status) => {
                // The transaction should be kept. Run the appropriate post transaction workflows
                // including epilogue. This runs a new session that ignores any side effects that
                // might abort the execution (e.g., spending additional funds needed to pay for
                // gas). Even if the previous failure occurred while running the epilogue, it
                // should not fail now. If it somehow fails here, there is no choice but to
                // discard the transaction.
                let output = self
                    .finish_aborted_transaction(
                        prologue_session_change_set,
                        gas_meter,
                        txn_data,
                        resolver,
                        module_storage,
                        serialized_signers,
                        status,
                        log_context,
                        change_set_configs,
                        traversal_context,
                    )
                    .unwrap_or_else(|status| discarded_output(status.status_code()));
                (error_vm_status, output)
            },
            TransactionStatus::Discard(status_code) => {
                let discarded_output = discarded_output(status_code);
                (error_vm_status, discarded_output)
            },
            TransactionStatus::Retry => unreachable!(),
        }
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1982-2117)
```rust
    fn execute_user_transaction_impl(
        &self,
        resolver: &impl AptosMoveResolver,
        code_storage: &impl AptosCodeStorage,
        txn: &SignedTransaction,
        txn_data: TransactionMetadata,
        is_approved_gov_script: bool,
        log_context: &AdapterLogSchema,
        gas_meter: &mut impl AptosGasMeter,
        mut trace_recorder: impl TraceRecorder,
    ) -> (VMStatus, VMOutput) {
        let _timer = VM_TIMER.timer_with_label("AptosVM::execute_user_transaction_impl");

        let traversal_storage = TraversalStorage::new();
        let mut traversal_context = TraversalContext::new(&traversal_storage);

        // Revalidate the transaction.
        let mut prologue_session = PrologueSession::new(self, &txn_data, resolver);
        let initial_gas = gas_meter.balance();
        let serialized_signers = unwrap_or_discard!(prologue_session.execute(|session| {
            self.validate_signed_transaction(
                session,
                code_storage,
                txn,
                &txn_data,
                log_context,
                is_approved_gov_script,
                &mut traversal_context,
                gas_meter,
            )
        }));

        if self.features().is_account_abstraction_enabled()
            || self.features().is_derivable_account_abstraction_enabled()
        {
            let max_aa_gas = unwrap_or_discard!(self.gas_params(log_context))
                .vm
                .txn
                .max_aa_gas;
            if max_aa_gas < txn_data.max_gas_amount() {
                // Reset initial gas after validation with max_aa_gas.
                unwrap_or_discard!(gas_meter
                    .inject_balance(txn_data.max_gas_amount().checked_sub(max_aa_gas).unwrap()));
            }
        } else {
            assert_eq!(initial_gas, gas_meter.balance());
        }

        let storage_gas_params = unwrap_or_discard!(self.storage_gas_params(log_context));
        let change_set_configs = &storage_gas_params.change_set_configs;
        let (prologue_change_set, mut user_session) = unwrap_or_discard!(prologue_session
            .into_user_session(self, &txn_data, resolver, change_set_configs, code_storage,));

        let should_create_account_resource_timer =
            VM_TIMER.timer_with_label("AptosVM::create_account_resource_lazily");
        let should_create_account_resource = unwrap_or_discard!(should_create_account_resource(
            &txn_data,
            self.features(),
            resolver,
            code_storage
        ));
        if should_create_account_resource {
            unwrap_or_discard!(
                user_session.execute(|session| create_account_if_does_not_exist(
                    session,
                    code_storage,
                    gas_meter,
                    txn.sender(),
                    &mut traversal_context,
                ))
            );
        }
        drop(should_create_account_resource_timer);

        let payload_timer =
            VM_TIMER.timer_with_label("AptosVM::execute_user_transaction_impl [payload]");

        // `validate_signed_transaction` function already discards the transactions with `TransactionPayloadInner` type payload if the
        // corresponding feature flag (`TransactionPayloadV2`) is disabled. Therefore, we don't need to check the feature flag here again.
        let executable = match txn.executable_ref() {
            Ok(executable) => executable,
            Err(_) => return unwrap_or_discard!(Err(deprecated_module_bundle!())),
        };
        let multisig_address = txn.multisig_address();
        let result = if let Some(multisig_address) = multisig_address {
            self.execute_multisig_transaction(
                resolver,
                code_storage,
                user_session,
                &serialized_signers,
                &prologue_change_set,
                gas_meter,
                &mut traversal_context,
                &txn_data,
                executable,
                multisig_address,
                log_context,
                change_set_configs,
                &mut trace_recorder,
            )
        } else {
            self.execute_script_or_entry_function(
                resolver,
                code_storage,
                user_session,
                &serialized_signers,
                gas_meter,
                &mut traversal_context,
                &txn_data,
                executable,
                log_context,
                change_set_configs,
                &mut trace_recorder,
            )
        };
        drop(payload_timer);

        let gas_usage = txn_data
            .max_gas_amount()
            .checked_sub(gas_meter.balance())
            .expect("Balance should always be less than or equal to max gas amount set");
        TXN_GAS_USAGE.observe(u64::from(gas_usage) as f64);

        let (vm_status, mut output) = result.unwrap_or_else(|err| {
            self.on_user_transaction_execution_failure(
                prologue_change_set,
                err,
                resolver,
                code_storage,
                &serialized_signers,
                &txn_data,
                log_context,
                gas_meter,
                change_set_configs,
                &mut traversal_context,
            )
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3282-3299)
```rust
        let (counter_label, result) = match self.validate_signed_transaction(
            &mut session,
            module_storage,
            &txn,
            &txn_data,
            &log_context,
            is_approved_gov_script,
            &mut TraversalContext::new(&storage),
            &mut gas_meter,
        ) {
            Err(err) if err.status_code() != StatusCode::SEQUENCE_NUMBER_TOO_NEW => (
                "failure",
                VMValidatorResult::new(Some(err.status_code()), 0),
            ),
            _ => (
                "success",
                VMValidatorResult::new(None, txn.gas_unit_price()),
            ),
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L51-52)
```rust
pub fn get_paranoid_type_checks() -> bool {
    PARANOID_TYPE_CHECKS.get().cloned().unwrap_or(true)
```

**File:** aptos-move/e2e-testsuite/src/tests/invariant_violation.rs (L13-61)
```rust
#[test]
fn invariant_violation_error() {
    let _scenario = fail::FailScenario::setup();
    fail::cfg("aptos_vm::execute_script_or_entry_function", "100%return").unwrap();

    ::aptos_logger::Logger::init_for_testing();

    let mut executor = FakeExecutor::from_head_genesis();

    let sender = executor.create_raw_account_data(1_000_000, 10);
    let receiver = executor.create_raw_account_data(100_000, 10);
    executor.add_account_data(&sender);
    executor.add_account_data(&receiver);

    let transfer_amount = 1_000;
    let txn = peer_to_peer_txn(sender.account(), receiver.account(), 10, transfer_amount, 0);

    // execute transaction
    let output = executor.execute_transaction(txn.clone());

    // CHARGE_INVARIANT_VIOLATION enabled at genesis so this txn is kept.
    assert_eq!(
        output.status(),
        &TransactionStatus::Keep(ExecutionStatus::MiscellaneousError(Some(
            StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR
        ))),
    );

    // Disable the CHARGE_INVARIANT_VIOLATION flag.
    executor.exec("features", "change_feature_flags_internal", vec![], vec![
        MoveValue::Signer(AccountAddress::ONE)
            .simple_serialize()
            .unwrap(),
        MoveValue::Vector(vec![]).simple_serialize().unwrap(),
        MoveValue::Vector(vec![MoveValue::U64(
            FeatureFlag::CHARGE_INVARIANT_VIOLATION as u64,
        )])
        .simple_serialize()
        .unwrap(),
    ]);

    let output = executor.execute_transaction(txn);

    // With CHARGE_INVARIANT_VIOLATION disabled this transaction will be discarded.
    assert_eq!(
        output.status(),
        &TransactionStatus::Discard(DiscardedVMStatus::UNKNOWN_INVARIANT_VIOLATION_ERROR),
    );
}
```

**File:** types/src/on_chain_config/aptos_features.rs (L194-194)
```rust
            FeatureFlag::CHARGE_INVARIANT_VIOLATION,
```
