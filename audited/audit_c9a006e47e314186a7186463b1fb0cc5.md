# Audit Report

## Title
State Sync Event Notification Version Mismatch Vulnerability

## Summary
The state sync commit post-processor notifies event subscribers with incorrect version information. When processing `ChunkCommitNotification` objects, the system fetches the current `latest_synced_version` from storage instead of using the actual version of the events, causing events to be tagged with versions from later committed chunks. This leads to notification version mismatches and potential consensus coordination failures.

## Finding Description

The vulnerability occurs in the state sync event notification pipeline due to a race condition between chunk commits and notification processing: [1](#0-0) 

The `ChunkCommitNotification` structure contains events and transactions but **does not include version information** about which blockchain versions these events correspond to. [2](#0-1) 

The committer task commits chunks sequentially and sends `ChunkCommitNotification` objects to a buffered channel. Multiple notifications can queue up in this channel before being processed. [3](#0-2) 

The commit post-processor receives notifications from the queue and calls `handle_committed_transactions`. [4](#0-3) 

The critical flaw is at lines 336-353: `handle_committed_transactions` fetches `latest_synced_version` from storage **after** the chunk has been committed. If multiple chunks have been committed while notifications were queued, this version will be from a later chunk than the events actually belong to. [5](#0-4) 

The mismatched version is then passed to `notify_events()`, which stores events in subscriber buffers with the incorrect version. [6](#0-5) 

For reconfiguration events, this causes `notify_reconfiguration_subscribers()` to fetch on-chain configurations from the wrong version. [7](#0-6) 

At line 289, `read_on_chain_configs` creates a state view at the mismatched version and fetches epoch configurations that don't correspond to the actual reconfiguration event.

**Exploitation Scenario:**
1. Chunk 1 (versions 100-199) containing a new epoch event at version 199 is committed to storage
2. Chunk 2 (versions 200-299) is committed to storage  
3. Chunk 3 (versions 300-399) is committed to storage
4. Commit post-processor now processes Chunk 1's notification (from queue)
5. Fetches `latest_synced_version` = 399 (current storage state from Chunk 3)
6. Calls `notify_events(399, events_from_versions_100_199)`
7. For the epoch change event, calls `read_on_chain_configs(399)` 
8. Subscribers receive epoch change event labeled as version 399 with configs from version 399, but the actual epoch change occurred at version 199
9. This creates a 200-version mismatch between the event and its associated on-chain state

## Impact Explanation

This is a **HIGH severity** vulnerability per Aptos bug bounty criteria for the following reasons:

1. **Protocol Violation**: Breaks the state consistency invariant - event notifications carry incorrect version metadata, causing state coordination failures between components.

2. **Consensus Risk**: If consensus or validators subscribe to reconfiguration events and act on mismatched epoch configurations (wrong validator set, wrong voting thresholds), this could lead to consensus safety violations or liveness failures.

3. **Node Reliability**: Subscribers expecting version coherence may crash or malfunction when receiving events with versions that don't match the actual blockchain state at event emission.

4. **State Sync Coordination Failure**: The event notification system is designed to coordinate state changes across node components. Version mismatches violate this coordination, potentially causing components to operate on inconsistent views of blockchain state.

While this doesn't directly cause fund loss, it creates **significant protocol violations** that can cascade into consensus issues, qualifying as High severity.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability will occur naturally during normal operations when:
- A node is syncing state rapidly (common during catch-up or initial sync)
- Multiple chunks are processed in quick succession
- The commit post-processor channel buffer contains multiple pending notifications
- No malicious intent required - it's a design flaw in the notification pipeline

The vulnerability is **guaranteed to trigger** whenever the commit rate exceeds the notification processing rate and the channel buffer size (`max_pending_data_chunks`) allows multiple notifications to queue. This is a realistic scenario for validators syncing large amounts of state or during network congestion.

## Recommendation

The fix requires including version information in `ChunkCommitNotification` and using it instead of fetching from storage:

**1. Update `ChunkCommitNotification` structure:** [1](#0-0) 

Add fields:
```rust
pub struct ChunkCommitNotification {
    pub subscribable_events: Vec<ContractEvent>,
    pub committed_transactions: Vec<Transaction>,
    pub reconfiguration_occurred: bool,
    pub first_version: Version,  // ADD THIS
    pub last_version: Version,   // ADD THIS
}
```

**2. Update `make_chunk_commit_notification` to include versions:** [8](#0-7) 

**3. Update `handle_committed_transactions` to use the version from the notification:** [4](#0-3) 

Change to accept `last_version` as parameter and use it instead of fetching from storage.

**4. Update call sites to pass the version from notification:** [9](#0-8) 

This ensures events are always tagged with the correct version they were emitted at, maintaining version coherence across the notification system.

## Proof of Concept

**Reproduction Steps:**

1. Configure a validator node with `max_pending_data_chunks` set to a high value (e.g., 100) to allow notification queueing
2. Set up the node to sync from genesis, ensuring a large backlog of chunks to process
3. Instrument the code to log:
   - Version range when `ChunkCommitNotification` is created (from ExecutionOutput)
   - Version fetched in `handle_committed_transactions`
   - Version passed to `notify_events()`
4. Start state sync and observe the logs

**Expected Evidence of Vulnerability:**
```
[Chunk 1] Creating notification for events at versions 0-99
[Chunk 2] Creating notification for events at versions 100-199  
[Chunk 3] Creating notification for events at versions 200-299
[Post-Processor] Processing Chunk 1 notification
[Post-Processor] Fetched latest_synced_version = 299
[Post-Processor] Calling notify_events(299, events_from_0-99)  // MISMATCH!
```

This demonstrates that events from versions 0-99 are being tagged with version 299, a clear version mismatch that violates the state consistency invariant.

## Notes

This vulnerability is architectural in nature and stems from the separation of concerns between the committer (which knows the version) and the commit post-processor (which processes notifications asynchronously). The lack of version metadata in `ChunkCommitNotification` forces the post-processor to query storage, which may have advanced beyond the notification's actual version. The fix requires threading version information through the entire pipeline to maintain version coherence.

### Citations

**File:** execution/executor-types/src/lib.rs (L266-272)
```rust
/// A structure that holds relevant information about a chunk that was committed.
#[derive(Clone)]
pub struct ChunkCommitNotification {
    pub subscribable_events: Vec<ContractEvent>,
    pub committed_transactions: Vec<Transaction>,
    pub reconfiguration_occurred: bool,
}
```

**File:** state-sync/state-sync-driver/src/storage_synchronizer.rs (L690-780)
```rust
/// Spawns a dedicated committer that commits executed (but pending) chunks
fn spawn_committer<ChunkExecutor: ChunkExecutorTrait + 'static>(
    chunk_executor: Arc<ChunkExecutor>,
    error_notification_sender: mpsc::UnboundedSender<ErrorNotification>,
    mut committer_listener: mpsc::Receiver<NotificationMetadata>,
    mut commit_post_processor_notifier: mpsc::Sender<ChunkCommitNotification>,
    pending_data_chunks: Arc<AtomicU64>,
    runtime: Option<Handle>,
    storage: Arc<dyn DbReader>,
) -> JoinHandle<()> {
    // Create a committer
    let committer = async move {
        while let Some(notification_metadata) = committer_listener.next().await {
            // Start the commit timer
            let _timer = metrics::start_timer(
                &metrics::STORAGE_SYNCHRONIZER_LATENCIES,
                metrics::STORAGE_SYNCHRONIZER_COMMIT_CHUNK,
            );

            // Commit the executed chunk
            let result = commit_chunk(chunk_executor.clone()).await;

            // Notify the commit post-processor of the committed chunk
            match result {
                Ok(notification) => {
                    // Log the successful commit
                    info!(
                        LogSchema::new(LogEntry::StorageSynchronizer).message(&format!(
                            "Committed a new transaction chunk! \
                                    Transaction total: {:?}, event total: {:?}",
                            notification.committed_transactions.len(),
                            notification.subscribable_events.len()
                        ))
                    );

                    // Update the synced version metrics
                    utils::update_new_synced_metrics(
                        storage.clone(),
                        notification.committed_transactions.len(),
                    );

                    // Update the synced epoch metrics
                    let reconfiguration_occurred = notification.reconfiguration_occurred;
                    utils::update_new_epoch_metrics(storage.clone(), reconfiguration_occurred);

                    // Update the metrics for the data notification commit post-process latency
                    metrics::observe_duration(
                        &metrics::DATA_NOTIFICATION_LATENCIES,
                        metrics::NOTIFICATION_CREATE_TO_COMMIT_POST_PROCESS,
                        notification_metadata.creation_time,
                    );

                    // Notify the commit post-processor of the committed chunk
                    if let Err(error) = send_and_monitor_backpressure(
                        &mut commit_post_processor_notifier,
                        metrics::STORAGE_SYNCHRONIZER_COMMIT_POST_PROCESSOR,
                        notification,
                    )
                    .await
                    {
                        // Send an error notification to the driver (we failed to notify the commit post-processor)
                        let error = format!(
                            "Failed to notify the commit post-processor! Error: {:?}",
                            error
                        );
                        handle_storage_synchronizer_error(
                            notification_metadata,
                            error,
                            &error_notification_sender,
                            &pending_data_chunks,
                        )
                        .await;
                    }
                },
                Err(error) => {
                    // Send an error notification to the driver (we failed to commit the chunk)
                    let error = format!("Failed to commit executed chunk! Error: {:?}", error);
                    handle_storage_synchronizer_error(
                        notification_metadata,
                        error,
                        &error_notification_sender,
                        &pending_data_chunks,
                    )
                    .await;
                },
            };
        }
    };

    // Spawn the committer
    spawn(runtime, committer)
```

**File:** state-sync/state-sync-driver/src/storage_synchronizer.rs (L783-824)
```rust
/// Spawns a dedicated commit post-processor that handles commit notifications
fn spawn_commit_post_processor<
    MempoolNotifier: MempoolNotificationSender,
    StorageServiceNotifier: StorageServiceNotificationSender,
>(
    mut commit_post_processor_listener: mpsc::Receiver<ChunkCommitNotification>,
    event_subscription_service: Arc<Mutex<EventSubscriptionService>>,
    mempool_notification_handler: MempoolNotificationHandler<MempoolNotifier>,
    storage_service_notification_handler: StorageServiceNotificationHandler<StorageServiceNotifier>,
    pending_data_chunks: Arc<AtomicU64>,
    runtime: Option<Handle>,
    storage: Arc<dyn DbReader>,
) -> JoinHandle<()> {
    // Create a commit post-processor
    let commit_post_processor = async move {
        while let Some(notification) = commit_post_processor_listener.next().await {
            // Start the commit post-process timer
            let _timer = metrics::start_timer(
                &metrics::STORAGE_SYNCHRONIZER_LATENCIES,
                metrics::STORAGE_SYNCHRONIZER_COMMIT_POST_PROCESS,
            );

            // Handle the committed transaction notification (e.g., notify mempool)
            let committed_transactions = CommittedTransactions {
                events: notification.subscribable_events,
                transactions: notification.committed_transactions,
            };
            utils::handle_committed_transactions(
                committed_transactions,
                storage.clone(),
                mempool_notification_handler.clone(),
                event_subscription_service.clone(),
                storage_service_notification_handler.clone(),
            )
            .await;
            decrement_pending_data_chunks(pending_data_chunks.clone());
        }
    };

    // Spawn the commit post-processor
    spawn(runtime, commit_post_processor)
}
```

**File:** state-sync/state-sync-driver/src/utils.rs (L325-371)
```rust
pub async fn handle_committed_transactions<
    M: MempoolNotificationSender,
    S: StorageServiceNotificationSender,
>(
    committed_transactions: CommittedTransactions,
    storage: Arc<dyn DbReader>,
    mempool_notification_handler: MempoolNotificationHandler<M>,
    event_subscription_service: Arc<Mutex<EventSubscriptionService>>,
    storage_service_notification_handler: StorageServiceNotificationHandler<S>,
) {
    // Fetch the latest synced version and ledger info from storage
    let (latest_synced_version, latest_synced_ledger_info) =
        match fetch_pre_committed_version(storage.clone()) {
            Ok(latest_synced_version) => match fetch_latest_synced_ledger_info(storage.clone()) {
                Ok(latest_synced_ledger_info) => (latest_synced_version, latest_synced_ledger_info),
                Err(error) => {
                    error!(LogSchema::new(LogEntry::SynchronizerNotification)
                        .error(&error)
                        .message("Failed to fetch latest synced ledger info!"));
                    return;
                },
            },
            Err(error) => {
                error!(LogSchema::new(LogEntry::SynchronizerNotification)
                    .error(&error)
                    .message("Failed to fetch latest synced version!"));
                return;
            },
        };

    // Handle the commit notification
    if let Err(error) = CommitNotification::handle_transaction_notification(
        committed_transactions.events,
        committed_transactions.transactions,
        latest_synced_version,
        latest_synced_ledger_info,
        mempool_notification_handler,
        event_subscription_service,
        storage_service_notification_handler,
    )
    .await
    {
        error!(LogSchema::new(LogEntry::SynchronizerNotification)
            .error(&error)
            .message("Failed to handle a transaction commit notification!"));
    }
}
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L75-112)
```rust
    pub async fn handle_transaction_notification<
        M: MempoolNotificationSender,
        S: StorageServiceNotificationSender,
    >(
        events: Vec<ContractEvent>,
        transactions: Vec<Transaction>,
        latest_synced_version: Version,
        latest_synced_ledger_info: LedgerInfoWithSignatures,
        mut mempool_notification_handler: MempoolNotificationHandler<M>,
        event_subscription_service: Arc<Mutex<EventSubscriptionService>>,
        mut storage_service_notification_handler: StorageServiceNotificationHandler<S>,
    ) -> Result<(), Error> {
        // Log the highest synced version and timestamp
        let blockchain_timestamp_usecs = latest_synced_ledger_info.ledger_info().timestamp_usecs();
        debug!(
            LogSchema::new(LogEntry::NotificationHandler).message(&format!(
                "Notifying the storage service, mempool and the event subscription service of version: {:?} and timestamp: {:?}.",
                latest_synced_version, blockchain_timestamp_usecs
            ))
        );

        // Notify the storage service of the committed transactions
        storage_service_notification_handler
            .notify_storage_service_of_committed_transactions(latest_synced_version)
            .await?;

        // Notify mempool of the committed transactions
        mempool_notification_handler
            .notify_mempool_of_committed_transactions(transactions, blockchain_timestamp_usecs)
            .await?;

        // Notify the event subscription service of the events
        event_subscription_service
            .lock()
            .notify_events(latest_synced_version, events)?;

        Ok(())
    }
```

**File:** state-sync/inter-component/event-notifications/src/lib.rs (L264-307)
```rust
    fn notify_reconfiguration_subscribers(&mut self, version: Version) -> Result<(), Error> {
        if self.reconfig_subscriptions.is_empty() {
            return Ok(()); // No reconfiguration subscribers!
        }

        let new_configs = self.read_on_chain_configs(version)?;
        for (_, reconfig_subscription) in self.reconfig_subscriptions.iter_mut() {
            reconfig_subscription.notify_subscriber_of_configs(version, new_configs.clone())?;
        }

        Ok(())
    }

    /// Fetches the configs on-chain at the specified version.
    /// Note: We cannot assume that all configs will exist on-chain. As such, we
    /// must fetch each resource one at a time. Reconfig subscribers must be able
    /// to handle on-chain configs not existing in a reconfiguration notification.
    fn read_on_chain_configs(
        &self,
        version: Version,
    ) -> Result<OnChainConfigPayload<DbBackedOnChainConfig>, Error> {
        let db_state_view = &self
            .storage
            .read()
            .reader
            .state_view_at_version(Some(version))
            .map_err(|error| {
                Error::UnexpectedErrorEncountered(format!(
                    "Failed to create account state view {:?}",
                    error
                ))
            })?;
        let epoch = ConfigurationResource::fetch_config(&db_state_view)
            .ok_or_else(|| {
                Error::UnexpectedErrorEncountered("Configuration resource does not exist!".into())
            })?
            .epoch();

        // Return the new on-chain config payload (containing all found configs at this version).
        Ok(OnChainConfigPayload::new(
            epoch,
            DbBackedOnChainConfig::new(self.storage.read().reader.clone(), version),
        ))
    }
```

**File:** state-sync/inter-component/event-notifications/src/lib.rs (L310-331)
```rust
impl EventNotificationSender for EventSubscriptionService {
    fn notify_events(&mut self, version: Version, events: Vec<ContractEvent>) -> Result<(), Error> {
        if events.is_empty() {
            return Ok(()); // No events!
        }

        // Notify event subscribers and check if a reconfiguration event was processed
        let reconfig_event_processed = self.notify_event_subscribers(version, events)?;

        // If a reconfiguration event was found, also notify the reconfig subscribers
        // of the new configuration values.
        if reconfig_event_processed {
            self.notify_reconfiguration_subscribers(version)
        } else {
            Ok(())
        }
    }

    fn notify_initial_configs(&mut self, version: Version) -> Result<(), Error> {
        self.notify_reconfiguration_subscribers(version)
    }
}
```

**File:** execution/executor-types/src/state_compute_result.rs (L146-156)
```rust
    pub fn make_chunk_commit_notification(&self) -> ChunkCommitNotification {
        ChunkCommitNotification {
            subscribable_events: self
                .execution_output
                .subscribable_events
                .get(Some("wait_for_subscribable_events"))
                .clone(),
            committed_transactions: self.execution_output.to_commit.transactions.clone(),
            reconfiguration_occurred: self.execution_output.next_epoch_state.is_some(),
        }
    }
```
