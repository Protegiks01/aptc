# Audit Report

## Title
UnequivocalProposerElection State Inconsistency During Blockchain Reorganizations

## Summary
The `already_proposed` state in `UnequivocalProposerElection` is not reset during blockchain reorganizations, causing nodes to incorrectly reject valid proposals on new chain branches as equivocation attempts. This leads to validation errors and potential liveness issues for affected nodes.

## Finding Description

The `UnequivocalProposerElection` component wraps the proposer election mechanism to prevent equivocation by tracking proposals per round. It maintains an in-memory `already_proposed` field that stores the last seen proposal's round and block hash: [1](#0-0) 

When validating proposals, the system checks if a proposer has already submitted a different block for the same round: [2](#0-1) 

The critical issue occurs during blockchain reorganizations. When a node performs state synchronization via `BlockStore::rebuild()`, the block storage is reconstructed but the `UnequivocalProposerElection` instance persists with stale state: [3](#0-2) 

The `UnequivocalProposerElection` is created once per epoch during `RoundManager` initialization: [4](#0-3) 

**Attack Scenario:**

1. Node is following chain branch A at round 10
2. For round 11, the valid proposer broadcasts block X
3. Node receives and validates block X via `is_valid_proposal()`, updating `already_proposed = (11, hash(X))`
4. Network partition or sync event causes node to reorganize to chain branch B
5. On branch B, round 11 has a different valid block Y (same proposer, different content due to different parent/payload/timestamp)
6. Node performs state sync → `rebuild()` reconstructs block storage but `already_proposed` remains `(11, hash(X))`
7. Node receives block Y for round 11 from branch B
8. `is_valid_proposal()` compares: `round 11 == already_proposed.0` ✓ but `hash(Y) != already_proposed.1` ✗
9. Returns `false`, triggering rejection at proposal validation: [5](#0-4) 

The node incorrectly identifies legitimate block Y as an equivocation attempt and refuses to process it, despite it being the valid proposal for round 11 on the canonical chain branch B.

## Impact Explanation

**Severity: Medium**

This vulnerability meets the **Medium severity** criteria per Aptos bug bounty program: "State inconsistencies requiring intervention."

**Impact Details:**
- **Node Liveness**: Affected nodes cannot progress on the new chain branch, stuck at the reorganization point
- **Validation Failures**: Legitimate proposals are rejected as false equivocation attempts
- **Manual Intervention Required**: Node operators must restart or manually reset consensus state to recover
- **Consensus View Divergence**: Node's internal state becomes inconsistent with the actual chain state

**Does NOT qualify for Higher Severity because:**
- Does not cause fund loss or theft
- Does not break overall network consensus (only affects individual nodes)
- Does not cause permanent network partition
- No direct consensus safety violation (Byzantine agreement still holds for non-affected nodes)

## Likelihood Explanation

**Likelihood: Medium**

**Factors Increasing Likelihood:**
- Blockchain reorganizations occur naturally during:
  - Network partitions and recovery
  - State synchronization from peers
  - Fast-forward sync operations
  - Fork resolution scenarios
- Window of vulnerability extends to all rounds seen before reorganization
- No malicious actor required - purely a protocol design flaw

**Factors Decreasing Likelihood:**
- Requires specific timing: node must see proposal for round N on one branch, then reorg to different branch with different proposal for same round N
- Only affects rounds where different valid proposals exist on different branches
- Within-epoch reorganizations are less common than across-epoch transitions
- Buffer manager limits (~20 rounds) reduce the window

**Real-world Scenario:**
During network congestion or temporary partitions, validators may build on different branches briefly before consensus converges. Nodes performing catch-up sync during these periods are susceptible to this issue.

## Recommendation

Add a reset mechanism to `UnequivocalProposerElection` that clears the `already_proposed` state during blockchain reorganizations.

**Fix Implementation:**

Add a reset method to `UnequivocalProposerElection`:

```rust
impl UnequivocalProposerElection {
    pub fn reset_to_round(&self, round: Round) {
        let mut already_proposed = self.already_proposed.lock();
        // Reset to a round before the new chain's starting point
        already_proposed.0 = round;
        already_proposed.1 = HashValue::zero();
    }
}
```

Call this method during `BlockStore::rebuild()`:

```rust
pub async fn rebuild(
    &self,
    root: RootInfo,
    root_metadata: RootMetadata,
    blocks: Vec<Block>,
    quorum_certs: Vec<QuorumCert>,
) {
    // Existing rebuild logic...
    
    // Reset proposer election state to the new root round
    if let Some(round_manager) = &self.round_manager {
        round_manager.proposer_election.reset_to_round(root.commit_root_block.round());
    }
    
    // Continue with existing logic...
}
```

**Alternative Solution:**
Reset `already_proposed` to track only proposals after the highest committed round, ensuring reorganized chain state takes precedence over stale in-memory tracking.

## Proof of Concept

```rust
#[test]
fn test_reorg_causes_false_equivocation_detection() {
    use aptos_consensus_types::{
        block::{block_test_utils::certificate_for_genesis, Block},
        common::Payload,
    };
    use aptos_types::validator_signer::ValidatorSigner;
    use std::{collections::HashMap, sync::Arc};

    // Setup
    let validator = ValidatorSigner::random([0u8; 32]);
    let author = validator.author();
    let genesis_qc = certificate_for_genesis();
    
    let pe = UnequivocalProposerElection::new(Arc::new(
        MockProposerElection::new(HashMap::from([(11, author)]))
    ));

    // Step 1: Node sees proposal X for round 11 on chain branch A
    let proposal_x = Block::new_proposal(
        Payload::empty(false, true),
        11,
        1, // timestamp
        genesis_qc.clone(),
        &validator,
        Vec::new(),
    ).unwrap();
    
    // Validate proposal X - this updates already_proposed to (11, hash(X))
    assert!(pe.is_valid_proposal(&proposal_x));
    
    // Step 2: Blockchain reorganization occurs (BlockStore::rebuild called)
    // In real code, rebuild happens but UnequivocalProposerElection is NOT reset
    
    // Step 3: Node receives proposal Y for round 11 on chain branch B
    // (different block content due to different parent/timestamp on new branch)
    let proposal_y = Block::new_proposal(
        Payload::empty(false, true),
        11,
        2, // different timestamp = different block hash
        genesis_qc.clone(),
        &validator,
        Vec::new(),
    ).unwrap();
    
    // BUG: Proposal Y is VALID on branch B, but gets rejected as equivocation
    // because already_proposed still has (11, hash(X)) from branch A
    assert!(!pe.is_valid_proposal(&proposal_y)); // Should be true, but returns false!
    
    // This demonstrates the vulnerability:
    // A legitimate proposal on the new chain branch is incorrectly rejected
}
```

**Reproduction Steps:**
1. Deploy a local testnet with multiple validators
2. Induce a temporary network partition creating two branches
3. Have a node observe a proposal for round N on branch A
4. Trigger state sync to switch the node to branch B (different proposal for round N)
5. Observe the node reject the valid branch B proposal as equivocation
6. Verify via logs showing `InvalidConsensusProposal` error with "Multiple proposals" message

**Notes**

This vulnerability specifically affects the equivocation detection mechanism, not the overall consensus safety. The AptosBFT protocol itself remains secure, but individual nodes may experience operational issues during reorganization scenarios. The fix is straightforward and requires coordinating the reset of `UnequivocalProposerElection` state with `BlockStore::rebuild()` operations to maintain consistency between in-memory tracking and actual chain state.

### Citations

**File:** consensus/src/liveness/unequivocal_proposer_election.rs (L18-21)
```rust
pub struct UnequivocalProposerElection {
    proposer_election: Arc<dyn ProposerElection + Send + Sync>,
    already_proposed: Mutex<(Round, HashValue)>,
}
```

**File:** consensus/src/liveness/unequivocal_proposer_election.rs (L46-87)
```rust
    pub fn is_valid_proposal(&self, block: &Block) -> bool {
        block.author().is_some_and(|author| {
            let valid_author = self.is_valid_proposer(author, block.round());
            if !valid_author {
                warn!(
                    SecurityEvent::InvalidConsensusProposal,
                    "Proposal is not from valid author {}, expected {} for round {} and id {}",
                    author,
                    self.get_valid_proposer(block.round()),
                    block.round(),
                    block.id()
                );

                return false;
            }
            let mut already_proposed = self.already_proposed.lock();
            // detect if the leader proposes more than once in this round
            match block.round().cmp(&already_proposed.0) {
                Ordering::Greater => {
                    already_proposed.0 = block.round();
                    already_proposed.1 = block.id();
                    true
                },
                Ordering::Equal => {
                    if already_proposed.1 != block.id() {
                        error!(
                            SecurityEvent::InvalidConsensusProposal,
                            "Multiple proposals from {} for round {}: {} and {}",
                            author,
                            block.round(),
                            already_proposed.1,
                            block.id()
                        );
                        false
                    } else {
                        true
                    }
                },
                Ordering::Less => false,
            }
        })
    }
```

**File:** consensus/src/block_storage/block_store.rs (L352-395)
```rust
    pub async fn rebuild(
        &self,
        root: RootInfo,
        root_metadata: RootMetadata,
        blocks: Vec<Block>,
        quorum_certs: Vec<QuorumCert>,
    ) {
        info!(
            "Rebuilding block tree. root {:?}, blocks {:?}, qcs {:?}",
            root,
            blocks.iter().map(|b| b.id()).collect::<Vec<_>>(),
            quorum_certs
                .iter()
                .map(|qc| qc.certified_block().id())
                .collect::<Vec<_>>()
        );
        let max_pruned_blocks_in_mem = self.inner.read().max_pruned_blocks_in_mem();

        // Rollover the previous highest TC from the old tree to the new one.
        let prev_2chain_htc = self
            .highest_2chain_timeout_cert()
            .map(|tc| tc.as_ref().clone());
        let _ = Self::build(
            root,
            root_metadata,
            blocks,
            quorum_certs,
            prev_2chain_htc,
            self.execution_client.clone(),
            Arc::clone(&self.storage),
            max_pruned_blocks_in_mem,
            Arc::clone(&self.time_service),
            self.vote_back_pressure_limit,
            self.payload_manager.clone(),
            self.order_vote_enabled,
            self.window_size,
            self.pending_blocks.clone(),
            self.pipeline_builder.clone(),
            Some(self.inner.clone()),
        )
        .await;

        self.try_send_for_execution().await;
    }
```

**File:** consensus/src/round_manager.rs (L369-369)
```rust
            proposer_election: Arc::new(UnequivocalProposerElection::new(proposer_election)),
```

**File:** consensus/src/round_manager.rs (L1195-1200)
```rust
        ensure!(
            self.proposer_election.is_valid_proposal(&proposal),
            "[RoundManager] Proposer {} for block {} is not a valid proposer for this round or created duplicate proposal",
            author,
            proposal,
        );
```
