# Audit Report

## Title
Integer Underflow DoS in Transaction Filter Address Standardization

## Summary
The `standardize_address` function in the indexer-grpc transaction filter lacks input validation, allowing attackers to crash the indexer-grpc data service by providing addresses longer than 64 hexadecimal characters. Additionally, the function fails to validate that inputs contain only valid hexadecimal characters, potentially creating invalid address strings.

## Finding Description

The `standardize_address` function contains two critical flaws:

**1. Integer Underflow Leading to Panic** [1](#0-0) 

When processing non-special addresses, the function calculates padding as `64 - trimmed.len()`. If an attacker provides an address string with more than 64 characters (after removing the "0x" prefix), this subtraction underflows:
- In debug builds: immediate panic from integer underflow
- In release builds: wraps to a very large number, then panics when attempting to slice beyond `ZEROS` bounds

**2. Missing Hexadecimal Validation**

The function only validates hexadecimal characters in the special address path (lines 19-20), and even then, only for the last character. For non-special addresses, it blindly accepts any string, allowing characters like 'g', 'z', '!', etc. [2](#0-1) 

**Attack Vector**

Filters are created from protobuf messages sent by clients via gRPC: [3](#0-2) 

The `From` trait implementation calls `standardize_address` directly without validation. The `validate_state` method only checks that at least one filter field is set, but performs no address format validation: [4](#0-3) 

The indexer-grpc service uses these filters to strip or match transactions: [5](#0-4) [6](#0-5) 

## Impact Explanation

This vulnerability meets **High Severity** criteria per the Aptos bug bounty program due to causing **API crashes**. 

**Impact:**
- **Denial of Service**: Complete crash of the indexer-grpc data service
- **Service Disruption**: All clients depending on transaction indexing and querying are affected
- **No Authentication Required**: Any client can send the malicious request
- **Immediate Effect**: Single malformed gRPC request triggers the crash
- **Recovery Required**: Service restart needed to restore functionality

While this does not affect consensus, validator operations, or blockchain state (which continue operating normally), it disrupts the critical indexing infrastructure that applications rely on for blockchain data access.

## Likelihood Explanation

**Likelihood: High**

- **Attack Complexity: Trivial** - Requires only a single malformed gRPC request
- **Attacker Requirements: None** - No special privileges, credentials, or resources needed
- **Discovery: Easy** - The vulnerability is in straightforward integer arithmetic with no bounds checking
- **Exploitation: Immediate** - No timing windows, race conditions, or complex state manipulation required

Any user or application sending a `GetTransactionsRequest` with a filter containing a sender address exceeding 64 characters will trigger the crash.

## Recommendation

**Immediate Fix:**

Add input validation to prevent both the underflow and invalid hex characters:

```rust
pub fn standardize_address(address: &str) -> Result<String, String> {
    // Remove "0x" prefix if it exists
    let trimmed = address.strip_prefix("0x").unwrap_or(address);
    
    // Validate length (Aptos addresses are 32 bytes = 64 hex chars max)
    if trimmed.len() > 64 {
        return Err(format!("Address too long: {} characters (max 64)", trimmed.len()));
    }
    
    // Validate all characters are valid hexadecimal
    if !trimmed.chars().all(|c| c.is_ascii_hexdigit()) {
        return Err("Address contains non-hexadecimal characters".to_string());
    }
    
    // Check if the address is a special address
    if let Some(last_char) = trimmed.chars().last() {
        if trimmed[..trimmed.len().saturating_sub(1)]
            .chars()
            .all(|c| c == '0')
            && last_char <= 'f'
        {
            // Return special addresses in short format
            let mut result = String::with_capacity(3);
            result.push_str("0x");
            result.push(last_char);
            return Ok(result);
        }
    }
    
    // Return non-special addresses in long format
    let mut result = String::with_capacity(66);
    result.push_str("0x");
    result.push_str(&ZEROS[..64 - trimmed.len()]);
    result.push_str(trimmed);
    Ok(result)
}
```

**Update Call Sites:**

Modify the `From` implementations to handle validation errors: [7](#0-6) 

Add proper error propagation or filter out invalid addresses during construction.

## Proof of Concept

```rust
#[cfg(test)]
mod exploit_tests {
    use super::*;

    #[test]
    #[should_panic(expected = "attempt to subtract with overflow")]
    fn test_long_address_causes_panic() {
        // Create an address with 100 hex characters (exceeds 64 limit)
        let malicious_address = format!("0x{}", "a".repeat(100));
        
        // This will panic due to integer underflow
        let _ = standardize_address(&malicious_address);
    }

    #[test]
    fn test_non_hex_characters_accepted() {
        // Non-hexadecimal characters are accepted without validation
        let invalid_address = "0xGGGGGGGGGGGGGGGG"; // 'G' is not a hex digit
        let result = standardize_address(invalid_address);
        
        // Result contains invalid hex characters
        assert_eq!(
            result,
            "0x000000000000000000000000000000000000000000000000GGGGGGGGGGGGGGGG"
        );
        
        // This is an invalid address that could cause issues downstream
    }
    
    #[test]
    fn test_grpc_filter_construction_panics() {
        use aptos_protos::indexer::v1::UserTransactionFilter as ProtoFilter;
        use crate::filters::UserTransactionFilter;
        
        // Simulate attacker sending a gRPC request with long address
        let malicious_proto = ProtoFilter {
            sender: Some(format!("0x{}", "f".repeat(100))),
            payload_filter: None,
        };
        
        // Converting from proto to filter will panic
        // This is what happens in the gRPC service
        let _filter: UserTransactionFilter = malicious_proto.into();
        // ^ This line panics and crashes the service
    }
}
```

**Exploitation Steps:**

1. Attacker crafts a gRPC `GetTransactionsRequest` with a `UserTransactionFilter`
2. Sets the `sender` field to a string with >64 hex characters (e.g., "0x" + 100 'a's)
3. Sends the request to the indexer-grpc data service endpoint
4. Service attempts to create filter via `From` trait implementation
5. `standardize_address` is called and panics on line 33
6. Service crashes, denying service to all users

**Notes**

This vulnerability exists in the indexer-grpc transaction filtering subsystem, which provides read-only query capabilities for blockchain data. While it does not affect core consensus, execution, or validator operations, the bug bounty program explicitly categorizes "API crashes" as High Severity vulnerabilities worth up to $50,000. The indexer infrastructure is critical for applications and services that query blockchain state, making this a significant availability issue despite not impacting the blockchain's core security properties.

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/utils.rs (L10-36)
```rust
pub fn standardize_address(address: &str) -> String {
    // Remove "0x" prefix if it exists
    let trimmed = address.strip_prefix("0x").unwrap_or(address);

    // Check if the address is a special address by seeing if the first 31 bytes are zero and the last byte is smaller than 0b10000
    if let Some(last_char) = trimmed.chars().last() {
        if trimmed[..trimmed.len().saturating_sub(1)]
            .chars()
            .all(|c| c == '0')
            && last_char.is_ascii_hexdigit()
            && last_char <= 'f'
        {
            // Return special addresses in short format
            let mut result = String::with_capacity(3);
            result.push_str("0x");
            result.push(last_char);
            return result;
        }
    }

    // Return non-special addresses in long format
    let mut result = String::with_capacity(66);
    result.push_str("0x");
    result.push_str(&ZEROS[..64 - trimmed.len()]);
    result.push_str(trimmed);
    result
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L38-46)
```rust
impl UserTransactionFilter {
    fn get_standardized_sender(&self) -> &Option<String> {
        self.standardized_sender.get_or_init(|| {
            self.sender
                .clone()
                .map(|address| standardize_address(&address))
        })
    }
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L48-61)
```rust
impl From<aptos_protos::indexer::v1::UserTransactionFilter> for UserTransactionFilter {
    fn from(proto_filter: aptos_protos::indexer::v1::UserTransactionFilter) -> Self {
        Self {
            standardized_sender: OnceCell::with_value(
                proto_filter
                    .sender
                    .as_ref()
                    .map(|address| standardize_address(address)),
            ),
            sender: proto_filter.sender,
            payload: proto_filter.payload_filter.map(|f| f.into()),
        }
    }
}
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L72-80)
```rust
impl Filterable<Transaction> for UserTransactionFilter {
    #[inline]
    fn validate_state(&self) -> Result<(), FilterError> {
        if self.sender.is_none() && self.payload.is_none() {
            return Err(Error::msg("At least one of sender or payload must be set").into());
        };
        self.payload.is_valid()?;
        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs (L75-82)
```rust
pub struct RawDataServerWrapper {
    pub redis_client: Arc<redis::Client>,
    pub file_store_config: IndexerGrpcFileStoreConfig,
    pub data_service_response_channel_size: usize,
    pub txns_to_strip_filter: BooleanTransactionFilter,
    pub cache_storage_format: StorageFormat,
    in_memory_cache: Arc<InMemoryCache>,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/service.rs (L188-203)
```rust
        let cache_storage_format = self.cache_storage_format;
        let request_metadata = Arc::new(request_metadata);
        let txns_to_strip_filter = self.txns_to_strip_filter.clone();
        let in_memory_cache = self.in_memory_cache.clone();
        tokio::spawn({
            let request_metadata = request_metadata.clone();
            async move {
                data_fetcher_task(
                    redis_client,
                    file_store_operator,
                    cache_storage_format,
                    request_metadata,
                    transactions_count,
                    tx,
                    txns_to_strip_filter,
                    current_version,
```
