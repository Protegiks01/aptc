# Audit Report

## Title
Backup Restore Accepts Unverified Malicious State Without Mandatory Trusted Waypoints

## Summary
The backup restore system in `storage/backup/backup-cli` accepts tampered backup data without cryptographic verification when trusted waypoints are not provided. An attacker who intercepts backup data in transit can inject a completely fabricated blockchain state starting from genesis, which will be restored without signature verification, potentially compromising validator nodes in disaster recovery scenarios.

## Finding Description

The vulnerability exists in the epoch ending restore logic where the first `LedgerInfoWithSignatures` (epoch 0 genesis) is accepted without any cryptographic verification if no trusted waypoint is provided. [1](#0-0) 

In the `preheat_impl` method, when processing each `LedgerInfo`:
- If a trusted waypoint exists for that version, only the waypoint hash is checked (line 129-135)
- Otherwise, if a previous `LedgerInfo` exists, signatures are verified using the previous epoch's validator set (line 136-146)
- **However**, for the very first `LedgerInfo` (epoch 0), when `previous_li` is `None` and no trusted waypoint is provided, **neither condition evaluates to true**, and the `LedgerInfo` is accepted without any verification [2](#0-1) 

The `previous_li` variable starts as `None`, so the first genesis `LedgerInfo` in a backup has no chain of trust unless a trusted waypoint is explicitly provided.

The `TrustedWaypointOpt` is optional (a `Vec` that can be empty): [3](#0-2) 

While the documentation mentions using trusted waypoints to "confirm the backup is compatible", it does not indicate this is **mandatory for security**, leading operators to believe they are optional.

**Attack Scenario:**

1. **Backup Interception**: Attacker performs man-in-the-middle attack on backup storage communication or compromises the backup storage backend
2. **Malicious Backup Creation**: Attacker creates a fake backup with:
   - Fabricated genesis `LedgerInfo` (epoch 0) with attacker-controlled validator set
   - Subsequent epoch `LedgerInfo`s signed by the fake validator set
   - State snapshots containing malicious Move modules or incorrect state
   - All internally consistent (proofs match the fake LedgerInfos)
3. **Restore Without Waypoints**: Operator runs restore command without trusted waypoints:
   ```bash
   aptos-debugger aptos-db restore bootstrap-db \
     --target-db-dir /opt/aptos/data \
     --local-fs-dir /backup/storage
   # NO --trust-waypoint argument!
   ```
4. **Acceptance Without Verification**: The fake genesis is accepted without signature checks
5. **Compromised State**: Node starts with fake validator set, malicious state, potentially including Move modules that could steal funds or break invariants

## Impact Explanation

This is assessed as **Medium to High Severity** based on the Aptos bug bounty criteria:

**Medium Severity Factors:**
- Single validator restore: Limited impact as the compromised node cannot participate in the legitimate network's consensus due to validator set mismatch
- Requires operator error (not providing trusted waypoints)
- "State inconsistencies requiring intervention" - the restored database contains unverified state

**High Severity Factors (Disaster Recovery Scenario):**
- Multiple validators restore from compromised backup during network disaster recovery without trusted waypoints
- A fake network could be established with attacker-controlled validator set
- "Significant protocol violations" - the backup/restore protocol's integrity guarantees are completely bypassed
- Full nodes serving queries could return fabricated state data to users

**Why Not Critical:**
- Does not directly cause "Loss of Funds" in operational network (compromised node cannot participate in real consensus)
- Does not cause "Consensus/Safety violations" of the legitimate network
- Requires both infrastructure compromise AND operator error

## Likelihood Explanation

**Moderate Likelihood** in practice:

1. **Attack Feasibility**: 
   - Requires compromise of backup infrastructure (MitM on storage connections or backend breach)
   - Backup data typically travels over network connections that could be intercepted
   - Cloud storage misconfigurations are common

2. **Operator Error Probability**:
   - Documentation does not emphasize that trusted waypoints are security-critical
   - During disaster recovery, operators may skip "optional" parameters
   - No technical enforcement - restore succeeds without waypoints

3. **Detection Difficulty**:
   - Compromised single validator will fail to sync and appear as node malfunction
   - In disaster recovery, if multiple validators use same compromised backup, the fake network may appear valid

## Recommendation

**Immediate Fix - Mandatory Waypoint Validation:**

1. Make trusted waypoints mandatory for epoch ending restoration:

```rust
// In storage/backup/backup-cli/src/utils/mod.rs
#[derive(Clone, Parser)]
pub struct TrustedWaypointOpt {
    #[clap(
        long,
        required = true,  // ADD THIS
        help = "(REQUIRED FOR SECURITY) Trusted waypoints must be provided to cryptographically \
        verify the backup integrity. At minimum, provide the genesis waypoint. \
        Without trusted waypoints, the backup can be completely forged by an attacker. \
        ...(rest of help text)..."
    )]
    pub trust_waypoint: Vec<Waypoint>,
}
```

2. Add runtime validation in `EpochEndingRestoreController::preheat_impl`:

```rust
// After line 88, add validation:
if next_epoch == 0 && self.trusted_waypoints.get(&0).is_none() {
    return Err(anyhow!(
        "SECURITY: Genesis waypoint (version 0) is required when restoring from epoch 0. \
        Without it, the backup cannot be cryptographically verified and may be forged."
    ));
}
```

3. Update documentation to emphasize security implications:
   - Add prominent warnings in backup/restore documentation
   - Include examples showing proper waypoint usage
   - Document the security model clearly

**Long-term Enhancements:**

1. Implement cryptographic signing of backup metadata by the source node
2. Add backup integrity checksums independent of ledger state
3. Implement multi-signature verification for critical backups
4. Add audit logging for restores performed without trusted waypoints

## Proof of Concept

**Demonstration Steps:**

1. Create a fake backup structure with fabricated genesis:

```rust
// Create fake genesis LedgerInfo with attacker's validator set
let fake_validator_verifier = ValidatorVerifier::new(attacker_validator_set);
let fake_genesis = create_fake_genesis_ledger_info();

// Create fake epoch ending backup manifest
let fake_manifest = EpochEndingBackup {
    first_epoch: 0,
    last_epoch: 10,
    waypoints: vec![Waypoint::new_epoch_boundary(&fake_genesis.ledger_info())?],
    chunks: vec![/* fake chunk data */],
};

// Write to backup storage
storage.save_json_file("epoch_ending.manifest", &fake_manifest).await?;
```

2. Attempt restore without trusted waypoint:

```bash
aptos-debugger aptos-db restore bootstrap-db \
  --target-db-dir /tmp/restored_db \
  --local-fs-dir /tmp/fake_backup
# Expected: Should fail with security error
# Actual: Succeeds and accepts fake data
```

3. Verify the fake data was accepted:

```rust
let restored_db = AptosDB::open(...)?;
let genesis_li = restored_db.get_epoch_ending_ledger_info(0)?;
// This will be the fake LedgerInfo with attacker's validator set
assert!(genesis_li == fake_genesis); // This will pass!
```

**Expected Behavior vs. Actual:**
- Expected: Restore should **fail** with error requiring trusted waypoint
- Actual: Restore **succeeds** and accepts unverified fake data

## Notes

**Defense-in-Depth Considerations:**
- The consensus protocol provides partial protection - a single compromised node cannot break the legitimate network's consensus
- However, this should not be relied upon as the primary security control for backup integrity
- The backup/restore system should provide strong security guarantees independently

**Operational Impact:**
- This vulnerability is most critical during disaster recovery when multiple validators restore simultaneously
- Single validator compromises are less severe but still problematic for full nodes serving queries

**Root Cause:**
- The design assumes trusted waypoints are optional convenience features rather than security-critical
- No enforcement mechanism prevents restoration without cryptographic verification
- Unclear documentation about security implications

### Citations

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L88-90)
```rust
        let mut previous_li: Option<&LedgerInfoWithSignatures> = None;
        let mut ledger_infos = Vec::new();

```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L129-147)
```rust
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
                }
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L331-346)
```rust
#[derive(Clone, Default, Parser)]
pub struct TrustedWaypointOpt {
    #[clap(
        long,
        help = "(multiple) When provided, an epoch ending LedgerInfo at the waypoint version will be \
        checked against the hash in the waypoint, but signatures on it are NOT checked. \
        Use this for two purposes: \
        1. set the genesis or the latest waypoint to confirm the backup is compatible. \
        2. set waypoints at versions where writeset transactions were used to overwrite the \
        validator set, so that the signature check is skipped. \
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
    )]
    pub trust_waypoint: Vec<Waypoint>,
}
```
