# Audit Report

## Title
Missing Bounds Validation on SampleRate::Duration Causes Excessive Logging in Consensus Hot Paths

## Summary
The `SampleRate::Duration` enum in the Aptos logger lacks bounds checking on sub-second duration values. When durations less than 1 second are provided, the `as_secs()` conversion truncates them to 0, causing the sampling logic to trigger on every invocation instead of at the intended rate. This issue is present in multiple consensus code paths, including order vote processing and quorum store operations, where it can cause excessive logging during high-throughput scenarios.

## Finding Description
The vulnerability exists in the `sample_duration` function which converts the Duration to seconds before performing the sampling check: [1](#0-0) 

At line 63, `rate.as_secs()` truncates any duration less than 1 second to 0. The sampling condition at line 72 then becomes `now.saturating_sub(last_sample) >= 0`, which is always true since `saturating_sub` never returns negative values. This completely disables the sampling mechanism.

The codebase contains multiple instances where sub-second durations are used in consensus-critical paths:

1. **Order Vote Processing** - 200ms sampling for missing block logging: [2](#0-1) 

2. **Quorum Store Batch Processing** - 500ms sampling for garbage collection: [3](#0-2) 

3. **Proof Manager Back Pressure** - 200ms sampling for back pressure logging: [4](#0-3) 

During high-throughput consensus operations, these code paths execute frequently. The order vote processing path is triggered when processing `OrderVoteMsg` network messages: [5](#0-4) 

When the sampling is disabled, every invocation attempts to log, serialize log entries, and send them through the logging channel. While logs may eventually be dropped when the channel fills, the CPU cycles spent preparing and attempting to send thousands of logs per second degrades validator performance. [6](#0-5) 

## Impact Explanation
This qualifies as **Low Severity** per the Aptos Bug Bounty criteria as a non-critical implementation bug that causes performance degradation rather than consensus violations or funds loss.

During high-throughput scenarios (1000+ TPS), these consensus code paths can be hit hundreds of times per second. Without proper sampling:
- Excessive CPU cycles spent on log serialization and preparation
- Disk I/O pressure from attempting to write every log entry
- Potential disk space exhaustion from log volume
- Performance degradation affecting validator's ability to keep up with consensus rounds

While this doesn't break consensus safety or cause funds loss, it can degrade validator performance during critical high-load periods, potentially affecting network liveness if multiple validators are impacted.

## Likelihood Explanation
**High likelihood** - The vulnerable code with sub-second durations is already present in production consensus code. During normal high-throughput operations or network stress conditions, these code paths execute frequently without requiring any specific attacker action. The issue manifests automatically when:
- Order votes arrive before blocks (common during network latency)
- Quorum store processes batches rapidly (normal operation at high TPS)
- Back pressure conditions are reached (high load scenarios)

## Recommendation
Add bounds validation to reject or correct sub-second durations. Modify the `sample_duration` function to enforce a minimum duration:

```rust
fn sample_duration(rate: &Duration, last_sample: &AtomicU64) -> bool {
    // Enforce minimum 1 second sampling rate to prevent truncation to 0
    let rate = rate.as_secs().max(1);
    let now = SystemTime::now()
        .duration_since(SystemTime::UNIX_EPOCH)
        .expect("SystemTime before UNIX EPOCH!")
        .as_secs();

    last_sample
        .fetch_update(Ordering::SeqCst, Ordering::SeqCst, |last_sample| {
            if now.saturating_sub(last_sample) >= rate {
                Some(now)
            } else {
                None
            }
        })
        .is_ok()
}
```

Alternatively, use millisecond precision throughout:

```rust
fn sample_duration(rate: &Duration, last_sample: &AtomicU64) -> bool {
    let rate_millis = rate.as_millis() as u64;
    let now_millis = SystemTime::now()
        .duration_since(SystemTime::UNIX_EPOCH)
        .expect("SystemTime before UNIX EPOCH!")
        .as_millis() as u64;

    last_sample
        .fetch_update(Ordering::SeqCst, Ordering::SeqCst, |last_sample| {
            if now_millis.saturating_sub(last_sample) >= rate_millis {
                Some(now_millis)
            } else {
                None
            }
        })
        .is_ok()
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test_duration_truncation {
    use super::*;
    use std::time::Duration;

    #[test]
    fn test_sub_second_duration_disables_sampling() {
        // Create sampling with 200ms duration (as used in consensus code)
        let sampling = Sampling::new(SampleRate::Duration(Duration::from_millis(200)));
        
        // Call sample() multiple times in quick succession
        let mut sample_count = 0;
        for _ in 0..100 {
            if sampling.sample() {
                sample_count += 1;
            }
        }
        
        // With proper 200ms sampling, we should get 1-2 samples max in a tight loop
        // But due to truncation to 0 seconds, EVERY call returns true
        assert!(sample_count > 50, 
            "Expected most samples to pass due to 0-second truncation, got {}", 
            sample_count);
    }

    #[test]
    fn test_one_second_duration_works_correctly() {
        // Create sampling with 1 second duration
        let sampling = Sampling::new(SampleRate::Duration(Duration::from_secs(1)));
        
        let mut sample_count = 0;
        for _ in 0..100 {
            if sampling.sample() {
                sample_count += 1;
            }
        }
        
        // With proper 1 second sampling, tight loop should only sample once
        assert_eq!(sample_count, 1, 
            "Expected exactly 1 sample with 1-second rate, got {}", 
            sample_count);
    }
}
```

**Notes:**
- This vulnerability is present in production code and activates automatically during high-throughput operations
- The impact is limited to performance degradation rather than consensus safety violations
- Multiple consensus components are affected by the same root cause
- The fix requires updating either the validation logic or switching to millisecond precision

### Citations

**File:** crates/aptos-logger/src/sample.rs (L62-79)
```rust
    fn sample_duration(rate: &Duration, last_sample: &AtomicU64) -> bool {
        let rate = rate.as_secs();
        // Seconds since Unix Epoch
        let now = SystemTime::now()
            .duration_since(SystemTime::UNIX_EPOCH)
            .expect("SystemTime before UNIX EPOCH!")
            .as_secs();

        last_sample
            .fetch_update(Ordering::SeqCst, Ordering::SeqCst, |last_sample| {
                if now.saturating_sub(last_sample) >= rate {
                    Some(now)
                } else {
                    None
                }
            })
            .is_ok()
    }
```

**File:** consensus/src/round_manager.rs (L1968-1974)
```rust
                sample!(
                    SampleRate::Duration(Duration::from_millis(200)),
                    info!(
                        "Ordered certificate created without block in block store: {:?}",
                        verified_qc.certified_block()
                    );
                );
```

**File:** consensus/src/round_manager.rs (L2169-2170)
```rust
                        VerifiedEvent::OrderVoteMsg(order_vote_msg) => {
                            monitor!("process_order_vote", self.process_order_vote_msg(*order_vote_msg).await)
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L252-255)
```rust
        sample!(
            SampleRate::Duration(Duration::from_millis(500)),
            self.gc_expired_batch_summaries_without_proofs()
        );
```

**File:** consensus/src/quorum_store/proof_manager.rs (L249-257)
```rust
            sample!(
                SampleRate::Duration(Duration::from_millis(200)),
                info!(
                    "Quorum store is back pressured with {} txns, limit: {}, proofs: {}, limit: {}",
                    self.remaining_total_txn_num,
                    self.back_pressure_total_txn_limit,
                    self.remaining_total_proof_num,
                    self.back_pressure_total_proof_limit
                );
```

**File:** crates/aptos-logger/src/aptos_logger.rs (L556-563)
```rust
        if let Some(sender) = &self.sender {
            if sender
                .try_send(LoggerServiceEvent::LogEntry(entry))
                .is_err()
            {
                STRUCT_LOG_QUEUE_ERROR_COUNT.inc();
            }
        }
```
