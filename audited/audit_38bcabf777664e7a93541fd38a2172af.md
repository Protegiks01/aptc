# Audit Report

## Title
Unverified Peer-Advertised Ledger Info Allows Waypoint Bypass During Node Bootstrapping

## Summary
The global data summary aggregation in state sync accepts `synced_ledger_info` from peers without cryptographic signature verification, allowing malicious peers to inject fake ledger information with arbitrary version numbers. This unverified data is subsequently used in critical bootstrapping decisions, specifically waypoint satisfiability checks, potentially allowing nodes to bypass waypoint verification or sync to invalid blockchain states.

## Finding Description

The vulnerability exists in the state sync data aggregation pipeline where peer-advertised ledger information is collected and used without proper cryptographic validation.

**Attack Flow:**

1. **Unverified Data Collection**: When peers send their `StorageServerSummary`, the `synced_ledger_info` field (a `LedgerInfoWithSignatures`) is directly aggregated into the global data summary without signature verification. [1](#0-0) 

2. **Global Summary Caching**: This unverified data becomes part of the global summary returned by `get_global_data_summary()`: [2](#0-1) 

3. **Driver Usage**: The driver retrieves this summary during progress checks: [3](#0-2) 

4. **Vulnerable Waypoint Check**: The bootstrapper uses the highest advertised ledger info version (from unverified peer data) to determine waypoint satisfiability: [4](#0-3) [5](#0-4) 

**Exploitation Scenario:**

A malicious peer crafts a `StorageServerSummary` with:
- A `synced_ledger_info` containing an arbitrarily high version number (e.g., version 1,000,000)
- Invalid or fabricated BLS signatures that were never produced by validator quorum
- Incorrect epoch, state root, or other metadata

This fake ledger info is:
- Accepted without signature verification during aggregation
- Selected as the "highest" advertised ledger info due to its inflated version
- Used to determine that a node's waypoint is "satisfiable" even when no legitimate peer has actually reached that version

**Security Invariants Broken:**

1. **Cryptographic Correctness**: `LedgerInfoWithSignatures` must have valid quorum signatures before being trusted. The signatures prove validator consensus on that ledger state. Using unverified ledger info violates this invariant.

2. **Waypoint Security**: Waypoints are cryptographic commitments that ensure nodes bootstrap to the correct chain state. The waypoint check can be bypassed by fake high-version advertisements.

3. **State Sync Trust Model**: The protocol assumes advertised data reflects legitimate blockchain state. Accepting unverified ledger info breaks this assumption.

## Impact Explanation

This is a **High Severity** vulnerability per the Aptos bug bounty criteria:

- **Significant Protocol Violation**: Waypoint verification is a core security mechanism. Bypassing it represents a fundamental protocol violation.

- **Bootstrapping Integrity Compromise**: New nodes or nodes recovering from downtime may bootstrap to incorrect states or accept invalid sync targets based on fake advertisements.

- **No Privileged Access Required**: Any peer on the network can exploit this by simply advertising a malicious storage summary.

- **Affects Critical Code Path**: The bootstrapper is essential for bringing new nodes online and recovering existing nodes.

The vulnerability does not directly lead to consensus safety violations or fund theft (preventing Critical severity), but it compromises the integrity of the bootstrapping process, which is a significant protocol-level issue warranting High severity classification.

## Likelihood Explanation

**Likelihood: Medium to High**

Factors increasing likelihood:
- **Easy to Exploit**: Attacker only needs to be a network peer and send crafted peer advertisements
- **No Authentication Barrier**: The storage service accepts summaries from any connected peer
- **Persistent Impact**: Once fake data enters the global summary, it influences bootstrapping decisions until refreshed

Factors potentially limiting impact:
- **Multiple Peers**: Honest peers also advertise data, potentially diluting malicious advertisements
- **Waypoint Age**: Older waypoints are more likely to have legitimate peer coverage
- **Later Verification**: Actual sync operations may fail when fetching non-existent data, though damage to bootstrapping logic already occurred

However, during critical bootstrapping phases (new node joining, network partitions healing), even a single malicious peer can cause confusion or incorrect state transitions.

## Recommendation

**Immediate Fix: Verify Signatures Before Aggregation**

Before including peer-advertised `synced_ledger_info` in the global data summary, verify its cryptographic signatures using the known validator set for that epoch.

Implementation approach:

1. **Lazy Verification During Aggregation**: In `calculate_global_data_summary()`, verify each `synced_ledger_info` before including it:
   - Obtain the appropriate `EpochState` for the ledger info's epoch
   - Call `epoch_state.verify(synced_ledger_info)` to validate signatures
   - Only include ledger infos that pass verification
   - Log and penalize peers providing invalid ledger infos

2. **Early Verification During Polling**: Alternatively, verify immediately when receiving `StorageServerSummary` in the poller, before storing in peer state.

3. **Peer Scoring**: Update peer scores to heavily penalize (using `ErrorType::Malicious`) peers that send ledger infos with invalid signatures.

**Example verification pattern** (based on existing verification code in the codebase): [6](#0-5) 

The verification requires access to epoch state information. The data client should maintain a mapping of known epoch states (derived from verified epoch-ending ledger infos) and use them to validate advertised synced ledger infos before aggregation.

**Defense in Depth**: Additionally, any critical usage of advertised data should include validation at the point of use, not just during aggregation. The waypoint satisfiability check should include an additional safety assertion.

## Proof of Concept

```rust
// Proof of Concept: Malicious Peer Advertising Fake Ledger Info
// This would be added as a test in state-sync/aptos-data-client/src/peer_states.rs

#[cfg(test)]
mod vulnerability_tests {
    use super::*;
    use aptos_types::{
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
        block_info::BlockInfo,
        aggregate_signature::AggregateSignature,
    };

    #[test]
    fn test_unverified_ledger_info_injection() {
        // Setup: Create peer states with default config
        let config = Arc::new(AptosDataClientConfig::default());
        let peer_states = PeerStates::new(config.clone());
        
        // Attacker: Create a fake ledger info with high version but invalid signatures
        let fake_block_info = BlockInfo::new(
            999,  // fake epoch
            0,    // round
            HashValue::zero(),
            HashValue::zero(),
            999_999,  // fake high version
            0,
            None,
        );
        let fake_ledger_info = LedgerInfo::new(fake_block_info, HashValue::zero());
        
        // Create LedgerInfoWithSignatures with empty (invalid) signatures
        let fake_ledger_info_with_sigs = LedgerInfoWithSignatures::new(
            fake_ledger_info,
            AggregateSignature::empty(), // Invalid signature!
        );
        
        // Malicious peer advertises this fake data
        let malicious_peer = create_random_peer_network_id();
        let mut fake_summary = create_storage_summary(0);
        fake_summary.data_summary.synced_ledger_info = Some(fake_ledger_info_with_sigs.clone());
        
        // Vulnerability: This unverified data is accepted
        peer_states.update_summary(malicious_peer, fake_summary);
        
        // Calculate global summary - fake data is included without verification
        let global_summary = peer_states.calculate_global_data_summary();
        
        // Assert: The fake ledger info is now in the global summary
        let highest_advertised = global_summary
            .advertised_data
            .highest_synced_ledger_info()
            .expect("Should have advertised ledger info");
        
        // The fake version is used despite invalid signatures
        assert_eq!(highest_advertised.ledger_info().version(), 999_999);
        
        // This fake data would now be used in waypoint satisfiability checks
        // without signature verification, allowing waypoint bypass
        println!("VULNERABILITY CONFIRMED: Fake ledger info with version {} accepted without signature verification", 
                 highest_advertised.ledger_info().version());
    }
}
```

**Expected Behavior (after fix):** The test should fail after implementing signature verification, as the fake ledger info with invalid signatures should be rejected during aggregation or peer state update.

## Notes

This vulnerability is particularly concerning because `LedgerInfoWithSignatures` is designed as a cryptographically-authenticated data structure. The entire point of including signatures is to prove validator consensus. By accepting these structures without verification, the protocol undermines its own security model.

The fix requires careful consideration of epoch state management, as verification needs access to the correct validator set for each epoch. However, this information should be available from already-verified epoch-ending ledger infos stored locally.

Related code paths that properly verify ledger info signatures exist throughout the codebase (consensus, continuous syncer, epoch change verification), demonstrating that signature verification is both feasible and expected. The peer state aggregation is an oversight in this otherwise well-secured system.

### Citations

**File:** state-sync/aptos-data-client/src/peer_states.rs (L374-378)
```rust
            if let Some(synced_ledger_info) = summary.data_summary.synced_ledger_info.as_ref() {
                advertised_data
                    .synced_ledger_infos
                    .push(synced_ledger_info.clone());
            }
```

**File:** state-sync/aptos-data-client/src/client.rs (L931-933)
```rust
    fn get_global_data_summary(&self) -> GlobalDataSummary {
        self.global_summary_cache.load().clone().deref().clone()
    }
```

**File:** state-sync/state-sync-driver/src/driver.rs (L671-673)
```rust
        // Fetch the global data summary and verify we have active peers
        let global_data_summary = self.aptos_data_client.get_global_data_summary();
        if global_data_summary.is_empty() {
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L894-902)
```rust
        let highest_advertised_ledger_info = global_data_summary
            .advertised_data
            .highest_synced_ledger_info()
            .ok_or_else(|| {
                Error::UnsatisfiableWaypoint(
                    "Unable to check waypoint satisfiability! No highest advertised ledger info found in the network!".into(),
                )
            })?;
        let highest_advertised_version = highest_advertised_ledger_info.ledger_info().version();
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L905-914)
```rust
        if highest_advertised_version < waypoint_version {
            Err(Error::UnsatisfiableWaypoint(
                format!(
                    "The waypoint is not satisfiable! No advertised version higher than our waypoint! Highest version: {:?}, waypoint version: {:?}.",
                    highest_advertised_version, waypoint_version
                )
            ))
        } else {
            Ok(())
        }
```

**File:** types/src/epoch_state.rs (L88-95)
```rust

```
