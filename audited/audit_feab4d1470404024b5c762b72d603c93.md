# Audit Report

## Title
TSafetyRules Trait Allows Volatile Storage Leading to Consensus Safety Violations on Non-Mainnet Networks

## Summary
The `TSafetyRules` trait interface does not enforce persistent storage durability requirements, allowing implementations to use volatile storage (`InMemoryStorage`) that loses critical `SafetyData` on crashes. While mainnet validators are protected by config sanitizers, testnet and private network validators can use volatile storage by default, enabling double-voting and equivocation after process restarts.

## Finding Description

The `TSafetyRules` trait defines the safety rules interface but contains no contract requirements for persistent storage durability. [1](#0-0) 

Critical consensus safety data is stored in `SafetyData`, which tracks voting history to prevent equivocation: [2](#0-1) 

The `SafetyRules` implementation uses `PersistentSafetyStorage`, which wraps a generic `Storage` backend: [3](#0-2) 

The `Storage` enum includes `InMemoryStorage` as a valid variant: [4](#0-3) 

`InMemoryStorage` explicitly states it should not be used in production and stores everything in a volatile `HashMap`: [5](#0-4) 

The critical safety rule prevents double-voting by checking `last_voted_round`: [6](#0-5) 

**The Vulnerability:**

The `SafetyRulesConfig` defaults to `InMemoryStorage`: [7](#0-6) 

While mainnet validators are protected by a config sanitizer: [8](#0-7) 

This sanitizer **only checks mainnet**, leaving testnet, devnet, and private network validators unprotected. A validator using `InMemoryStorage` loses all `SafetyData` on crash/restart, resetting `last_voted_round` to 0, allowing double-voting in previously voted rounds.

**Attack Scenario:**
1. Testnet validator uses default config â†’ `InMemoryStorage`
2. Validator votes in round 10 for block A (`last_voted_round = 10`)
3. Validator crashes (OOM, panic, node restart)
4. `InMemoryStorage` cleared, `SafetyData` resets (`last_voted_round = 0`)
5. Validator can now vote in round 10 for conflicting block B
6. **BFT safety invariant violated** - equivocation enables chain splits

## Impact Explanation

**Severity: MEDIUM** (does not meet Critical criteria due to limited scope)

This violates the **Consensus Safety** invariant: "AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine." However, the impact is constrained because:

1. **Mainnet is protected** by config sanitizers - Critical severity requires production network impact
2. **Requires validator misconfiguration** - Not exploitable by fully unprivileged attacker
3. **Affects testnet/devnet primarily** - Lower value networks

The vulnerability enables state inconsistencies requiring intervention (Medium severity per bug bounty criteria), but on non-production networks. If exploited on a production private network or if sanitizers are bypassed, impact escalates to Critical.

## Likelihood Explanation

**Likelihood: MEDIUM**

- The **default config uses `InMemoryStorage`**, making misconfiguration easy
- Testnet/devnet validators may use defaults without realizing the implications
- Validator crashes are common (OOM, panic, maintenance restarts)
- However, production networks (mainnet) have explicit protections
- Sophisticated validators typically use proper storage backends

The likelihood increases for:
- New validator operators on testnets
- Development/testing environments promoted to quasi-production
- Private networks without proper configuration review

## Recommendation

**1. Enforce storage durability at the trait level:**

Add a trait method or associated type to declare storage durability requirements. Document that implementations MUST use persistent storage for production.

**2. Extend sanitizer to all networks where validators matter:**

```rust
// In SafetyRulesConfig::sanitize()
if node_type.is_validator() && safety_rules_config.backend.is_in_memory() {
    return Err(Error::ConfigSanitizerFailed(
        sanitizer_name,
        "The secure backend should not be set to in memory storage for validators on any network!".to_string(),
    ));
}
```

**3. Change default to safe fallback:**

```rust
impl Default for SafetyRulesConfig {
    fn default() -> Self {
        Self {
            backend: SecureBackend::OnDiskStorage(OnDiskStorageConfig::default()),
            // ... rest unchanged
        }
    }
}
```

**4. Add compile-time documentation:**

Add `#[doc]` attributes to `TSafetyRules` trait explicitly stating: "Implementations MUST use persistent storage to maintain SafetyData across restarts. Volatile storage implementations MUST NOT be used in validator configurations."

## Proof of Concept

```rust
// Demonstrates the vulnerability - validator double-voting after crash
#[cfg(test)]
mod safety_violation_poc {
    use super::*;
    use aptos_crypto::bls12381;
    use aptos_secure_storage::InMemoryStorage;
    
    #[test]
    fn test_double_vote_after_inmemory_storage_loss() {
        // Validator 1: Create with InMemoryStorage
        let storage1 = Storage::from(InMemoryStorage::new());
        let consensus_key = bls12381::PrivateKey::generate(&mut rand::thread_rng());
        let mut safety_storage1 = PersistentSafetyStorage::initialize(
            storage1,
            Author::random(),
            consensus_key.clone(),
            Waypoint::default(),
            true,
        );
        
        // Simulate voting in round 10
        let mut safety_data = safety_storage1.safety_data().unwrap();
        safety_data.last_voted_round = 10;
        safety_storage1.set_safety_data(safety_data.clone()).unwrap();
        
        assert_eq!(safety_storage1.safety_data().unwrap().last_voted_round, 10);
        
        // CRASH: Validator restarts, InMemoryStorage is lost
        drop(safety_storage1);
        
        // Validator restarts with new InMemoryStorage instance
        let storage2 = Storage::from(InMemoryStorage::new());
        let mut safety_storage2 = PersistentSafetyStorage::initialize(
            storage2,
            Author::random(),
            consensus_key,
            Waypoint::default(),
            true,
        );
        
        // Safety data is RESET - last_voted_round is now 0!
        let new_safety_data = safety_storage2.safety_data().unwrap();
        assert_eq!(new_safety_data.last_voted_round, 0);
        
        // Validator can now vote AGAIN in round 10
        // This violates BFT safety - double voting enabled!
        let mut updated_data = new_safety_data;
        updated_data.last_voted_round = 10;
        
        // This should fail but succeeds because safety data was lost
        assert!(safety_storage2.set_safety_data(updated_data).is_ok());
    }
}
```

## Notes

While this vulnerability demonstrates a **design flaw in the trait interface contract**, its exploitability is limited by:

1. **Mainnet protection**: Config sanitizers prevent `InMemoryStorage` on mainnet validators [9](#0-8) 

2. **Configuration requirement**: Exploitation requires validator operator to misconfigure their node (though default config enables this)

3. **Scope limitation**: Primarily affects testnet/devnet rather than production mainnet

The vulnerability **does not meet the "unprivileged attacker" requirement** from the validation checklist, as it requires validator-level configuration access. However, it represents a **genuine safety risk** for non-mainnet deployments and violates interface design best practices by not enforcing critical durability requirements at the type level.

For these reasons, this finding is classified as **MEDIUM severity** rather than Critical, despite breaking consensus safety invariants in specific deployment scenarios.

### Citations

**File:** consensus/safety-rules/src/t_safety_rules.rs (L19-62)
```rust
/// Interface for SafetyRules
pub trait TSafetyRules {
    /// Provides the internal state of SafetyRules for monitoring / debugging purposes. This does
    /// not include sensitive data like private keys.
    fn consensus_state(&mut self) -> Result<ConsensusState, Error>;

    /// Initialize SafetyRules using an Epoch ending LedgerInfo, this should map to what was
    /// provided in consensus_state. It will be used to initialize the ValidatorSet.
    /// This uses a EpochChangeProof because there's a possibility that consensus migrated to a
    /// new epoch but SafetyRules did not.
    fn initialize(&mut self, proof: &EpochChangeProof) -> Result<(), Error>;

    /// As the holder of the private key, SafetyRules also signs proposals or blocks.
    /// A Block is a signed BlockData along with some additional metadata.
    fn sign_proposal(&mut self, block_data: &BlockData) -> Result<bls12381::Signature, Error>;

    /// Sign the timeout together with highest qc for 2-chain protocol.
    fn sign_timeout_with_qc(
        &mut self,
        timeout: &TwoChainTimeout,
        timeout_cert: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<bls12381::Signature, Error>;

    /// Attempts to vote for a given proposal following the 2-chain protocol.
    fn construct_and_sign_vote_two_chain(
        &mut self,
        vote_proposal: &VoteProposal,
        timeout_cert: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<Vote, Error>;

    /// Attempts to create an order vote for a block given the quroum certificate for the block.
    fn construct_and_sign_order_vote(
        &mut self,
        order_vote_proposal: &OrderVoteProposal,
    ) -> Result<OrderVote, Error>;

    /// As the holder of the private key, SafetyRules also signs a commit vote.
    /// This returns the signature for the commit vote.
    fn sign_commit_vote(
        &mut self,
        ledger_info: LedgerInfoWithSignatures,
        new_ledger_info: LedgerInfo,
    ) -> Result<bls12381::Signature, Error>;
}
```

**File:** consensus/consensus-types/src/safety_data.rs (L8-21)
```rust
/// Data structure for safety rules to ensure consensus safety.
#[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L16-28)
```rust
/// SafetyRules needs an abstract storage interface to act as a common utility for storing
/// persistent data to local disk, cloud, secrets managers, or even memory (for tests)
/// Any set function is expected to sync to the remote system before returning.
///
/// Note: cached_safety_data is a local in-memory copy of SafetyData. As SafetyData should
/// only ever be used by safety rules, we maintain an in-memory copy to avoid issuing reads
/// to the internal storage if the SafetyData hasn't changed. On writes, we update the
/// cache and internal storage.
pub struct PersistentSafetyStorage {
    enable_cached_safety_data: bool,
    cached_safety_data: Option<SafetyData>,
    internal_store: Storage,
}
```

**File:** secure/storage/src/storage.rs (L17-23)
```rust
#[enum_dispatch(KVStorage, CryptoStorage)]
pub enum Storage {
    VaultStorage(VaultStorage),
    InMemoryStorage(InMemoryStorage),
    NamespacedStorage(Namespaced<Box<Storage>>),
    OnDiskStorage(OnDiskStorage),
}
```

**File:** secure/storage/src/in_memory.rs (L9-18)
```rust
/// InMemoryStorage represents a key value store that is purely in memory and intended for single
/// threads (or must be wrapped by a Arc<RwLock<>>). This provides no permission checks and simply
/// is a proof of concept to unblock building of applications without more complex data stores.
/// Internally, it retains all data, which means that it must make copies of all key material which
/// violates the code base. It violates it because the anticipation is that data stores would
/// securely handle key material. This should not be used in production.
#[derive(Default)]
pub struct InMemoryStorage {
    data: HashMap<String, Vec<u8>>,
    time_service: TimeService,
```

**File:** consensus/safety-rules/src/safety_rules.rs (L213-232)
```rust
    pub(crate) fn verify_and_update_last_vote_round(
        &self,
        round: Round,
        safety_data: &mut SafetyData,
    ) -> Result<(), Error> {
        if round <= safety_data.last_voted_round {
            return Err(Error::IncorrectLastVotedRound(
                round,
                safety_data.last_voted_round,
            ));
        }

        safety_data.last_voted_round = round;
        trace!(
            SafetyLogSchema::new(LogEntry::LastVotedRound, LogEvent::Update)
                .last_voted_round(safety_data.last_voted_round)
        );

        Ok(())
    }
```

**File:** config/src/config/safety_rules_config.rs (L36-49)
```rust
impl Default for SafetyRulesConfig {
    fn default() -> Self {
        Self {
            backend: SecureBackend::InMemoryStorage,
            logger: LoggerConfig::default(),
            service: SafetyRulesService::Local,
            test: None,
            // Default value of 30 seconds for a timeout
            network_timeout_ms: 30_000,
            enable_cached_safety_data: true,
            initial_safety_rules_config: InitialSafetyRulesConfig::None,
        }
    }
}
```

**File:** config/src/config/safety_rules_config.rs (L85-96)
```rust
        if let Some(chain_id) = chain_id {
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }
```
