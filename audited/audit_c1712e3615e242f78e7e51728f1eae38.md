# Audit Report

## Title
Symbolic Link Following Vulnerability in LocalFs Backup Storage Leading to Arbitrary File Write

## Summary
The `LocalFs::create_for_write()` method in the backup storage implementation follows symbolic links without validation, allowing an attacker with write access to the backup directory to redirect file writes to arbitrary system locations, potentially achieving Remote Code Execution.

## Finding Description
The `BackupStorage::create_for_write()` trait implementation in `LocalFs` constructs file paths and opens them using `OpenOptions::new().write(true).create_new(true).open()` without performing symlink validation or using the `O_NOFOLLOW` flag. [1](#0-0) 

On Unix systems, the `create_new(true)` option uses the `O_CREAT | O_EXCL` flags, which check whether the **target** file exists after following symlinks. If an attacker places a dangling symbolic link (pointing to a non-existent file) at the expected backup file path, the operation will follow the symlink and create the target file at an arbitrary location.

**Attack Path:**
1. Attacker gains write access to the backup directory or a subdirectory created by `create_backup()`
2. Attacker creates a dangling symlink: `backup_dir/epoch_123/malicious.chunk â†’ /etc/cron.d/evil_job`
3. When the backup coordinator calls `create_for_write("epoch_123", "malicious.chunk")`, the code:
   - Constructs path: `backup_dir/epoch_123/malicious.chunk`
   - Calls `OpenOptions::open()` which follows the symlink
   - Creates `/etc/cron.d/evil_job` with backup data content
4. If the attacker can control or predict backup data format, they achieve arbitrary file write with controlled content

The vulnerability exists because there is no path canonicalization or symlink validation before file creation, unlike other parts of the codebase that explicitly use `std::fs::canonicalize()` for security-critical operations.

## Impact Explanation
**Severity: HIGH** (approaching Critical in specific scenarios)

According to Aptos bug bounty criteria:
- **Critical Impact**: "Remote Code Execution on validator node" - If a validator operator uses `LocalFs` for backups and an attacker can write to the backup directory, this enables RCE through file overwrites (e.g., cron jobs, systemd services, authorized_keys).
- **High Impact**: "Validator node slowdowns" / "Significant protocol violations" - Arbitrary file writes could disrupt validator operations.

The impact is HIGH rather than CRITICAL because:
1. LocalFs is documented as "mainly for tests" [2](#0-1) 
2. Production deployments use CommandAdapter with cloud storage [3](#0-2) 
3. Kubernetes deployments use `readOnlyRootFilesystem: true` [4](#0-3) 

However, the db-tool CLI still exposes LocalFs functionality for manual operations, creating a viable attack surface for operator-level compromises.

## Likelihood Explanation
**Likelihood: LOW-MEDIUM**

Required conditions:
1. **Write access to backup directory**: Attacker needs filesystem write permissions (insider threat, compromised operator account, or container escape)
2. **LocalFs usage**: Operator must use `--local-fs-dir` flag instead of cloud storage
3. **Predictable filenames**: Backup filenames follow patterns like `epoch_{number}`, `transaction_{version_range}.chunk`, making prediction feasible
4. **Timing**: Symlinks must be placed before `create_for_write()` calls

While LocalFs is not used in standard production deployments, operators performing manual backups/restores or testing environments remain vulnerable. The requirement for pre-existing filesystem access reduces likelihood but doesn't eliminate the threat model of privilege escalation after initial compromise.

## Recommendation
Implement symlink protection using one of these approaches:

**Option 1: Use O_NOFOLLOW flag (Unix-specific)**
```rust
async fn create_for_write(
    &self,
    backup_handle: &BackupHandleRef,
    name: &ShellSafeName,
) -> Result<(FileHandle, Box<dyn AsyncWrite + Send + Unpin>)> {
    let file_handle = Path::new(backup_handle)
        .join(name.as_ref())
        .path_to_string()?;
    let abs_path = self.dir.join(&file_handle);
    
    let mut opts = OpenOptions::new();
    opts.write(true).create_new(true);
    
    #[cfg(unix)]
    {
        use std::os::unix::fs::OpenOptionsExt;
        opts.custom_flags(libc::O_NOFOLLOW);
    }
    
    let file = opts.open(&abs_path).await.err_notes(&abs_path)?;
    Ok((file_handle.path_to_string()?, Box::new(file)))
}
```

**Option 2: Validate parent directory doesn't contain symlinks**
```rust
// Before file creation, canonicalize the parent path and verify it's within backup directory
let abs_path = self.dir.join(&file_handle);
let parent = abs_path.parent().ok_or_else(|| anyhow!("Invalid path"))?;
let canonical_parent = tokio::fs::canonicalize(parent).await?;
let canonical_dir = tokio::fs::canonicalize(&self.dir).await?;

if !canonical_parent.starts_with(&canonical_dir) {
    bail!("Path traversal detected: attempted to write outside backup directory");
}
```

**Option 3: Disable LocalFs in production builds** (most secure)
```rust
#[cfg(not(feature = "local-fs-backup"))]
compile_error!("LocalFs backup storage is disabled in production builds");
```

## Proof of Concept
```rust
#[cfg(test)]
mod symlink_attack_test {
    use super::*;
    use std::os::unix::fs as unix_fs;
    use tempfile::TempDir;
    use tokio::io::AsyncWriteExt;
    
    #[tokio::test]
    async fn test_symlink_following_vulnerability() {
        // Setup: Create backup directory and target directory
        let backup_dir = TempDir::new().unwrap();
        let target_dir = TempDir::new().unwrap();
        let target_file = target_dir.path().join("malicious_target");
        
        let storage = LocalFs::new(backup_dir.path().to_path_buf());
        
        // Create backup handle (directory)
        let backup_name = ShellSafeName::from_str("test_backup").unwrap();
        let handle = storage.create_backup(&backup_name).await.unwrap();
        
        // Attacker: Create dangling symlink in backup directory
        let symlink_path = backup_dir.path().join(&handle).join("evil.chunk");
        unix_fs::symlink(&target_file, &symlink_path).unwrap();
        
        // Trigger vulnerability: create_for_write follows symlink
        let file_name = ShellSafeName::from_str("evil.chunk").unwrap();
        let (_, mut writer) = storage.create_for_write(&handle, &file_name).await.unwrap();
        
        // Write arbitrary content
        writer.write_all(b"* * * * * root /tmp/evil.sh\n").await.unwrap();
        writer.shutdown().await.unwrap();
        
        // Verify: File was created at symlink target, not in backup directory
        assert!(target_file.exists(), "Symlink was followed - VULNERABILITY CONFIRMED");
        assert_eq!(
            std::fs::read_to_string(&target_file).unwrap(),
            "* * * * * root /tmp/evil.sh\n"
        );
    }
}
```

## Notes
While this vulnerability exists in the codebase, its practical exploitability is limited by:
1. LocalFs being marked for testing purposes
2. Production using cloud storage backends
3. Container security contexts in Kubernetes deployments

However, the vulnerability remains valid because:
- The code is still accessible through CLI tools for manual operations
- Defense-in-depth principle requires protection even for "test-only" code paths
- Operators running local backups/restores are at risk
- No warning prevents production use of LocalFs

The fix should be implemented regardless of current deployment practices to prevent future misconfigurations and meet security best practices.

### Citations

**File:** storage/backup/backup-cli/src/storage/local_fs/mod.rs (L80-96)
```rust
    async fn create_for_write(
        &self,
        backup_handle: &BackupHandleRef,
        name: &ShellSafeName,
    ) -> Result<(FileHandle, Box<dyn AsyncWrite + Send + Unpin>)> {
        let file_handle = Path::new(backup_handle)
            .join(name.as_ref())
            .path_to_string()?;
        let abs_path = self.dir.join(&file_handle).path_to_string()?;
        let file = OpenOptions::new()
            .write(true)
            .create_new(true)
            .open(&abs_path)
            .await
            .err_notes(&abs_path)?;
        Ok((file_handle, Box::new(file)))
    }
```

**File:** storage/backup/backup-cli/src/storage/mod.rs (L219-222)
```rust
    #[clap(
        long,
        help = "Select the LocalFs backup storage type, which is used mainly for tests."
    )]
```

**File:** terraform/helm/fullnode/templates/backup.yaml (L69-70)
```yaml
        - "--command-adapter-config"
        - "/opt/aptos/etc/{{ .config.location }}.yaml"
```

**File:** terraform/helm/fullnode/templates/backup.yaml (L90-91)
```yaml
        securityContext:
          readOnlyRootFilesystem: true
```
