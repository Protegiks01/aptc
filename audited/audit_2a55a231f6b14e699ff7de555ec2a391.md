# Audit Report

## Title
Lack of Duplicate Validator Detection in Rotating Proposer Election Enables Unfair Proposer Slot Allocation

## Summary
The `RotatingProposer::new()` function does not validate that the proposers vector contains unique `Author` entries. If duplicate validators exist in the proposer set, the same validator would receive multiple proposer slots within the rotation cycle, violating consensus fairness assumptions and enabling disproportionate block proposal opportunities. [1](#0-0) 

## Finding Description

The `RotatingProposer::new()` constructor accepts a `proposers: Vec<Author>` parameter and stores it directly without any validation for duplicate entries. The proposer selection logic in `get_valid_proposer()` uses modulo arithmetic to index into this vector: [2](#0-1) 

This implementation calculates the proposer index as `((round / contiguous_rounds) % proposers.len())`, which means each position in the proposers vector receives an equal number of proposer opportunities. If the same `Author` appears multiple times in the vector (e.g., `[A, B, A, C]`), that validator receives proportionally more proposer slots.

The proposers vector originates from the epoch state's validator verifier: [3](#0-2) 

The `get_ordered_account_addresses_iter()` method iterates directly over the `validator_infos` vector without deduplication: [4](#0-3) 

While the on-chain Move code contains validation logic in `join_validator_set_internal()` to prevent duplicate validators: [5](#0-4) 

The Rust consensus layer lacks defensive validation. This creates a vulnerability if:
1. The on-chain validation contains a bypass or logic error
2. State corruption occurs during epoch transitions
3. The `ValidatorSet` to `ValidatorVerifier` conversion introduces duplicates
4. Genesis initialization contains duplicate validators

**Attack Scenario:**
If an attacker can introduce duplicate `Author` entries into the `ValidatorSet` (through exploitation of an on-chain bug, state corruption, or malicious governance action), they would gain multiple proposer slots. For example, with `proposers = [A, B, A, C, A]` and `contiguous_rounds = 1`:
- Validator A: 3/5 slots (60% of proposals)
- Validator B: 1/5 slots (20% of proposals)
- Validator C: 1/5 slots (20% of proposals)

This violates the fairness invariant that proposer opportunities should be distributed according to voting power, not arbitrary vector positions.

## Impact Explanation

**Medium Severity** - This issue qualifies as Medium severity under the Aptos bug bounty program for the following reasons:

1. **Fairness Violation**: Breaks the consensus fairness invariant that validators should receive proposer slots proportional to their voting power, not their count in the proposer vector.

2. **Griefing Potential**: A validator with duplicate entries could propose more blocks than warranted, potentially censoring transactions or causing liveness degradation for honest validators.

3. **State Inconsistency**: Creates divergence between expected proposer distribution (based on voting power) and actual proposer distribution (based on vector position count).

4. **Requires Prerequisite Condition**: Cannot be directly exploited without first bypassing on-chain validations or causing state corruption, making it a defense-in-depth weakness rather than a direct attack vector.

The impact does not reach High or Critical severity because:
- Does not directly break consensus safety (no double-signing or equivocation)
- Does not cause immediate loss of funds or network partition
- Requires an upstream bug or state corruption to manifest
- Affected validators can still participate in consensus

## Likelihood Explanation

**Low to Medium Likelihood** - The likelihood is constrained by several factors:

**Barriers to Exploitation:**
1. On-chain validation in `stake.move` actively prevents duplicate pool addresses from joining the validator set
2. Each account can only create one `StakePool` resource
3. The `get_validator_state()` check ensures an address isn't already active or pending
4. Sequential `validator_index` assignment during epoch transitions maintains uniqueness

**Potential Trigger Conditions:**
1. **Logic Bug**: Undiscovered bug in Move validation logic that allows bypass
2. **Race Condition**: Concurrent validator registration exploiting atomicity gaps
3. **State Corruption**: Database corruption or malicious node operator tampering with local state
4. **Genesis Misconfiguration**: Duplicate validators in initial genesis configuration
5. **Governance Attack**: Malicious proposal that manipulates validator set directly

The issue is more likely during:
- Network upgrades and epoch transitions
- Genesis initialization on testnets
- Emergency validator set reconfigurations

## Recommendation

Add defensive validation in `RotatingProposer::new()` to detect and reject duplicate validators:

```rust
pub fn new(proposers: Vec<Author>, contiguous_rounds: u32) -> Result<Self> {
    // Validate no duplicate proposers
    let mut seen = HashSet::new();
    for proposer in &proposers {
        if !seen.insert(*proposer) {
            return Err(anyhow::anyhow!(
                "Duplicate proposer detected: {}. Proposer list must contain unique validators.",
                proposer
            ));
        }
    }
    
    // Validate non-empty proposer list
    if proposers.is_empty() {
        return Err(anyhow::anyhow!("Proposer list cannot be empty"));
    }
    
    Ok(Self {
        proposers,
        contiguous_rounds,
    })
}
```

Additionally, add validation in `ValidatorVerifier::new()` to catch duplicates at the source:

```rust
pub fn new(validator_infos: Vec<ValidatorConsensusInfo>) -> Self {
    // Check for duplicate addresses
    let mut seen_addresses = HashSet::new();
    for info in &validator_infos {
        assert!(
            seen_addresses.insert(info.address),
            "Duplicate validator address detected: {}. Validator set must contain unique addresses.",
            info.address
        );
    }
    
    let total_voting_power = sum_voting_power(&validator_infos);
    let quorum_voting_power = if validator_infos.is_empty() {
        0
    } else {
        total_voting_power * 2 / 3 + 1
    };
    Self::build_index(validator_infos, quorum_voting_power, total_voting_power)
}
```

These defensive checks implement defense-in-depth, catching any upstream bugs or state corruption before they affect consensus fairness.

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_types::account_address::AccountAddress;

    #[test]
    #[should_panic(expected = "Duplicate proposer detected")]
    fn test_duplicate_proposers_rejected() {
        let validator_a = AccountAddress::from_hex_literal("0xa").unwrap();
        let validator_b = AccountAddress::from_hex_literal("0xb").unwrap();
        
        // Create proposer list with duplicate validator A
        let proposers = vec![validator_a, validator_b, validator_a];
        
        // This should panic due to duplicate detection
        let _ = RotatingProposer::new(proposers, 1);
    }
    
    #[test]
    fn test_duplicate_causes_unfair_distribution() {
        let validator_a = AccountAddress::from_hex_literal("0xa").unwrap();
        let validator_b = AccountAddress::from_hex_literal("0xb").unwrap();
        let validator_c = AccountAddress::from_hex_literal("0xc").unwrap();
        
        // Current implementation ALLOWS duplicates (vulnerability)
        let proposers = vec![validator_a, validator_b, validator_a, validator_c];
        let proposer = RotatingProposer::new(proposers, 1);
        
        // Count proposals for each validator over 100 rounds
        let mut proposals_a = 0;
        let mut proposals_b = 0;
        let mut proposals_c = 0;
        
        for round in 0..100 {
            let selected = proposer.get_valid_proposer(round);
            if selected == validator_a {
                proposals_a += 1;
            } else if selected == validator_b {
                proposals_b += 1;
            } else if selected == validator_c {
                proposals_c += 1;
            }
        }
        
        // Validator A gets ~50% (2/4 slots), B and C each get ~25% (1/4 slots)
        // This demonstrates the fairness violation
        assert!(proposals_a > proposals_b);
        assert!(proposals_a > proposals_c);
        assert_eq!(proposals_b, proposals_c);
        
        println!("Validator A proposals: {} (expected 25, got ~50)", proposals_a);
        println!("Validator B proposals: {} (expected 25)", proposals_b);
        println!("Validator C proposals: {} (expected 25)", proposals_c);
    }
}
```

This PoC demonstrates that:
1. The current implementation accepts duplicate proposers without validation
2. Duplicate entries cause unfair proposer slot distribution
3. A validator with multiple entries receives proportionally more proposals than their voting power warrants

## Notes

While the on-chain Move validation SHOULD prevent duplicate validators under normal operation, the Rust consensus layer lacks defensive validation. This represents a defense-in-depth weakness where upstream bugs, state corruption, or configuration errors would not be caught before affecting consensus fairness. The recommended fix adds explicit validation at both the `ValidatorVerifier` and `RotatingProposer` levels to ensure duplicate detection regardless of how the proposer list is constructed.

### Citations

**File:** consensus/src/liveness/rotating_proposer_election.rs (L27-32)
```rust
    pub fn new(proposers: Vec<Author>, contiguous_rounds: u32) -> Self {
        Self {
            proposers,
            contiguous_rounds,
        }
    }
```

**File:** consensus/src/liveness/rotating_proposer_election.rs (L36-39)
```rust
    fn get_valid_proposer(&self, round: Round) -> Author {
        self.proposers
            [((round / u64::from(self.contiguous_rounds)) % self.proposers.len() as u64) as usize]
    }
```

**File:** consensus/src/epoch_manager.rs (L292-298)
```rust
        let proposers = epoch_state
            .verifier
            .get_ordered_account_addresses_iter()
            .collect::<Vec<_>>();
        match &onchain_config.proposer_election_type() {
            ProposerElectionType::RotatingProposer(contiguous_rounds) => {
                Arc::new(RotatingProposer::new(proposers, *contiguous_rounds))
```

**File:** types/src/validator_verifier.rs (L510-512)
```rust
    pub fn get_ordered_account_addresses_iter(&self) -> impl Iterator<Item = AccountAddress> + '_ {
        self.validator_infos.iter().map(|info| info.address)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1067-1070)
```text
        assert!(
            get_validator_state(pool_address) == VALIDATOR_STATUS_INACTIVE,
            error::invalid_state(EALREADY_ACTIVE_VALIDATOR),
        );
```
