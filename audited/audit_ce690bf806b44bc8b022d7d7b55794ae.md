# Audit Report

## Title
Storage Fee Bypass via Error Suppression in Abort Hook Path Allows Resources to be Stored with Zero Deposits

## Summary
When a transaction fails and triggers the abort hook for lazy account creation, errors during storage fee charging are suppressed rather than propagated. This allows resources to be committed to state with placeholder metadata (zero deposits) instead of correctly charged deposit amounts, violating the storage fee invariant and causing loss of network funds.

## Finding Description

The vulnerability exists in the `failed_transaction_cleanup_and_keep_vm_status` function where storage fee charging errors are caught and logged but not propagated. [1](#0-0) 

The normal flow for storage fee charging works as follows:

1. **WriteOps are created with placeholder metadata** - When resources are created, they initially have zero deposits that must be updated during fee charging: [2](#0-1) 

2. **Fee charging updates metadata** - The `charge_refund_write_op_v2` function uses `prev_materialized_size()` to calculate correct fees and update metadata with deposit amounts: [3](#0-2) 

3. **Size calculation via prev_materialized_size** - This function calls `get_resource_state_value_size()` which can return storage errors: [4](#0-3) 

4. **Error propagation path** - Storage errors are properly mapped and propagated: [5](#0-4) [6](#0-5) 

5. **Iterator error handling** - Errors from the iterator are properly propagated in the normal success path: [7](#0-6) 

**The Critical Flaw:** In the abort hook path, when `charge_change_set` returns an error (including errors from `prev_materialized_size()`), it is suppressed. The change set with **unupdated placeholder metadata** is still passed forward and committed: [8](#0-7) 

The change set is then finalized and returned as VMOutput that gets applied to state: [9](#0-8) 

## Impact Explanation

This qualifies as **Medium to High Severity** under Aptos bug bounty criteria:

1. **Limited Funds Loss** (Medium): Storage fees are not collected when this occurs, representing lost revenue for the network. Resources stored with zero deposits will refund zero on deletion instead of the actual deposit amount.

2. **State Inconsistencies** (Medium): The state contains resources with incorrect metadata (deposits = 0) that don't match the actual storage used.

3. **Violates Critical Invariants**: Breaks the storage fee model where "deposits charged = deposits refunded on deletion" and the Resource Limits invariant requiring all operations to respect storage limits.

While the impact per occurrence may be limited to a single account creation (~1-2 KB of storage), this represents a fundamental violation of the storage fee mechanism that could accumulate over time if storage errors occur frequently.

## Likelihood Explanation

**Likelihood: Low to Medium**

This vulnerability can occur when:
1. A transaction fails (common)
2. Lazy account creation is needed (moderately common)
3. A storage error occurs during `get_resource_state_value_size()` (uncommon but possible)

Storage errors can result from:
- Database I/O failures
- State corruption
- Network issues during state synchronization
- Resource exhaustion at the storage layer

While not directly attacker-controlled, these are legitimate production scenarios. The vulnerability is deterministic once the conditions are met - if a storage error occurs during fee charging in the abort hook, the resource will be committed with zero deposits.

The additional validation check at lines 773-784 may catch some cases, but can be bypassed when `gas_unit_price == 0` and `default_account_resource` is enabled.

## Recommendation

**Fix: Propagate storage fee charging errors instead of suppressing them**

The error should be propagated to abort the entire transaction rather than committing a change set with incorrect metadata:

```rust
// In failed_transaction_cleanup_and_keep_vm_status(), replace lines 743-754:

let mut abort_hook_session_change_set =
    abort_hook_session.finish(change_set_configs, module_storage)?;

// Propagate the error instead of suppressing it
self.charge_change_set(
    &mut abort_hook_session_change_set,
    gas_meter,
    txn_data,
    resolver,
    module_storage,
)?; // Use ? operator to propagate errors

let fee_statement =
    AptosVM::fee_statement_from_gas_meter(txn_data, gas_meter, ZERO_STORAGE_REFUND);
```

**Alternative Fix: Use a separate error handling strategy**

If error suppression is intentional for fault tolerance, ensure metadata is validated before committing:

```rust
if let Err(err) = self.charge_change_set(...) {
    // If fee charging fails, discard the change set entirely
    // rather than committing it with incorrect metadata
    warn!(*log_context, "Fee charging failed: {:?}. Discarding abort hook change set.", err);
    (prologue_session_change_set, fee_statement)
} else {
    (abort_hook_session_change_set, fee_statement)
}
```

## Proof of Concept

This vulnerability requires injecting a storage error, which is difficult in a pure Move test. A Rust integration test would be needed:

```rust
// Pseudo-code for Rust test (would need actual test infrastructure)
#[test]
fn test_storage_error_during_abort_hook_fee_charging() {
    // Setup: Create a mock resolver that returns storage errors
    let mut mock_resolver = MockResolver::new();
    mock_resolver.set_storage_error_on_size_query(true);
    
    // Create a transaction that will fail (e.g., abort in user code)
    let failed_txn = create_failing_transaction();
    
    // Execute with lazy account creation enabled
    let vm = AptosVM::new(...);
    let output = vm.execute_user_transaction(...);
    
    // Verify: The account resource was created
    assert!(output.write_set().contains_account_resource());
    
    // Vulnerability: The metadata has zero deposits despite storage usage
    let metadata = output.write_set().get_metadata_for_account();
    assert_eq!(metadata.slot_deposit(), 0); // Should be > 0
    assert_eq!(metadata.bytes_deposit(), 0); // Should be > 0
    
    // Impact: Future deletion refunds nothing
    let refund = calculate_deletion_refund(metadata);
    assert_eq!(refund, 0); // Lost funds for the network
}
```

**Notes**

The vulnerability is confirmed through code analysis but requires environmental error conditions (storage errors) to trigger. While not directly exploitable by an attacker through crafted transactions, it represents a real production risk that violates critical storage fee invariants. The error suppression pattern at the identified location is the only place in the codebase where `charge_change_set` errors are not propagated, making this a targeted code smell that should be addressed.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L743-754)
```rust
            if let Err(err) = self.charge_change_set(
                &mut abort_hook_session_change_set,
                gas_meter,
                txn_data,
                resolver,
                module_storage,
            ) {
                info!(
                    *log_context,
                    "Failed during charge_change_set: {:?}. Most likely exceeded gas limited.", err,
                );
            };
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L786-798)
```rust
            (abort_hook_session_change_set, fee_statement)
        } else {
            let fee_statement =
                AptosVM::fee_statement_from_gas_meter(txn_data, gas_meter, ZERO_STORAGE_REFUND);
            (prologue_session_change_set, fee_statement)
        };

        let mut epilogue_session = EpilogueSession::on_user_session_failure(
            self,
            txn_data,
            resolver,
            previous_session_change_set,
        );
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L821-821)
```rust
        epilogue_session.finish(fee_statement, status, change_set_configs, module_storage)
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/write_op_converter.rs (L67-69)
```rust
                // The deposit on the metadata is a placeholder (0), it will be updated later when
                // storage fee is charged.
                new_slot_metadata = Some(StateValueMetadata::placeholder(&current_time));
```

**File:** aptos-move/aptos-vm-types/src/storage/space_pricing.rs (L178-180)
```rust
                op.metadata_mut.maybe_upgrade();
                op.metadata_mut.set_slot_deposit(slot_deposit);
                op.metadata_mut.set_bytes_deposit(target_bytes_deposit);
```

**File:** aptos-move/aptos-vm-types/src/abstract_write_op.rs (L79-81)
```rust
                Write(_) | WriteWithDelayedFields(_) => {
                    executor_view.get_resource_state_value_size(state_key)?
                },
```

**File:** aptos-move/aptos-vm-types/src/resolver.rs (L228-234)
```rust
    fn get_resource_state_value_size(&self, state_key: &Self::Key) -> PartialVMResult<u64> {
        self.get_state_value(state_key).map_or_else(
            |e| Err(map_storage_error(state_key, e)),
            |maybe_state_value| {
                Ok(maybe_state_value.map_or(0, |state_value| state_value.size() as u64))
            },
        )
```

**File:** aptos-move/aptos-vm-types/src/resolver.rs (L245-250)
```rust
fn map_storage_error<E: std::fmt::Debug>(state_key: &StateKey, e: E) -> PartialVMError {
    PartialVMError::new(StatusCode::STORAGE_ERROR).with_message(format!(
        "Unexpected storage error for resource at {:?}: {:?}",
        state_key, e
    ))
}
```

**File:** aptos-move/aptos-gas-meter/src/traits.rs (L187-190)
```rust
            let ChargeAndRefund { charge, refund } = pricing.charge_refund_write_op(
                params,
                res.map_err(|err| err.finish(Location::Undefined))?,
            );
```
