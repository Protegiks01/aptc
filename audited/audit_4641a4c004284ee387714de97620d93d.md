# Audit Report

## Title
Version Check Bypass in Metadata Extraction Allows Version 5 Modules to Exploit Version 6+ Features

## Summary
The `get_metadata_from_compiled_code()` function clears struct and function attributes for version 5 modules during validation, but the `get_metadata()` function used at runtime does not perform this clearing. This inconsistency allows version 5 modules to bypass version restrictions and use features (view functions, resource groups) that should only be available in version 6+, potentially causing storage corruption and state inconsistencies.

## Finding Description
The Aptos codebase defines `METADATA_V1_MIN_FILE_FORMAT_VERSION = 6`, indicating that V1 metadata (including struct and function attributes) should only exist in modules with bytecode version 6 or higher. [1](#0-0) 

However, there are two separate functions that extract metadata from compiled modules with different behaviors:

**Function 1: `get_metadata_from_compiled_code()`** - Used during module publishing validation, clears attributes for version 5: [2](#0-1) 

The code explicitly clears `struct_attributes` and `fun_attributes` for version 5 modules, with a comment stating "this should have been gated in the verify module metadata." Crucially, the `error_map` field is NOT cleared.

**Function 2: `get_metadata()`** - Used at runtime for resource groups, view functions, and error extraction, does NOT clear any attributes: [3](#0-2) 

This function deserializes and caches metadata without any version-based clearing logic.

**Exploitation Path:**

1. Attacker publishes a version 5 module with V1 metadata containing resource group or view function attributes
2. During validation, `verify_module_metadata_for_module_publishing()` calls `get_metadata_from_compiled_code()`: [4](#0-3) 

3. Attributes are cleared, so the module passes validation with empty attribute maps
4. The raw bytecode (containing uncleared metadata) is stored on-chain
5. At runtime, when accessing resources, `get_resource_group_member_from_metadata()` calls `get_metadata()`: [5](#0-4) 

6. The attributes are NOT cleared, so resource group membership is detected
7. Resources are fetched from resource group storage instead of regular storage: [6](#0-5) 

8. Similarly, view function validation uses `get_metadata()`: [7](#0-6) [8](#0-7) 

This allows version 5 functions marked as `#[view]` to be called via the view function API, bypassing the version 6 requirement.

## Impact Explanation
This vulnerability represents a **High Severity** issue per Aptos bug bounty criteria as it constitutes a "Significant protocol violation":

1. **Protocol Invariant Violation**: Version 5 modules explicitly should not have V1 metadata features. Allowing this violates the documented version constraint.

2. **Storage Inconsistencies**: Resources marked with `#[resource_group_member]` in version 5 modules will be stored/retrieved from resource group storage instead of regular resource storage, potentially causing:
   - Data corruption if the resource group container doesn't exist
   - Incorrect gas charging (resource groups have different gas costs)
   - State inconsistencies between validators

3. **Validation Bypass**: Resource group validation checks (scope validation, container existence) are skipped during publishing because attributes are cleared, but the attributes become active at runtime. This bypasses critical safety checks: [9](#0-8) 

4. **Deterministic Execution Risk**: If validators run different code versions or process upgrades asynchronously, some may clear attributes at runtime while others don't, leading to consensus divergence and different state roots for identical transactions.

## Likelihood Explanation
**High Likelihood** - The attack is straightforward to execute:
- No special privileges required (any user can publish modules)
- Modules can be crafted with standard Move compiler tools by manipulating bytecode version
- The vulnerability is deterministic and reproducible
- No race conditions or timing dependencies

The code comment explicitly acknowledges this should have been prevented in validation, indicating developers are aware of the gap.

## Recommendation
Reject version 5 modules with V1 metadata entirely during publishing validation:

```rust
pub fn verify_module_metadata_for_module_publishing(
    module: &CompiledModule,
    features: &Features,
) -> Result<(), MetaDataValidationError> {
    // Add version check before processing metadata
    if module.version() < METADATA_V1_MIN_FILE_FORMAT_VERSION {
        if find_metadata(module.metadata(), APTOS_METADATA_KEY_V1).is_some() {
            return Err(MetaDataValidationError::Malformed(
                MalformedError::UnknownKey(APTOS_METADATA_KEY_V1.to_vec())
            ));
        }
    }
    
    // Existing validation logic...
}
```

This ensures version 5 modules cannot have V1 metadata at all, eliminating the inconsistency between validation and runtime.

## Proof of Concept
```rust
// Compile this Move module with version 6 to get V1 metadata
module 0x1::exploit {
    use std::string::String;
    
    #[resource_group_member(group = 0x1::exploit::MyGroup)]
    struct MaliciousResource has key {
        value: u64
    }
    
    #[resource_group(scope = global)]
    struct MyGroup has key {
        dummy: u64
    }
}

// Then manually modify the compiled bytecode to change version from 6 to 5
// The module will pass publishing validation (attributes cleared)
// But at runtime, resources will be treated as resource group members
// This can cause storage corruption or incorrect resource access patterns
```

Testing steps:
1. Compile module with Move compiler (generates version 6 bytecode with V1 metadata)
2. Use binary editor to change bytecode version field from 6 to 5  
3. Publish the module - validation passes because `get_metadata_from_compiled_code()` clears attributes
4. Attempt to store/access `MaliciousResource` - runtime uses `get_metadata()` which finds the resource_group_member attribute
5. Observe that resource operations target resource group storage instead of regular storage
6. This causes state inconsistency as resource group validation was bypassed during publishing

### Citations

**File:** types/src/vm/module_metadata.rs (L40-40)
```rust
pub const METADATA_V1_MIN_FILE_FORMAT_VERSION: u32 = 6;
```

**File:** types/src/vm/module_metadata.rs (L199-230)
```rust
pub fn get_metadata(md: &[Metadata]) -> Option<Arc<RuntimeModuleMetadataV1>> {
    if let Some(data) = find_metadata(md, APTOS_METADATA_KEY_V1) {
        V1_METADATA_CACHE.with(|ref_cell| {
            let mut cache = ref_cell.borrow_mut();
            if let Some(meta) = cache.get(&data.value) {
                meta.clone()
            } else {
                let meta = bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value)
                    .ok()
                    .map(Arc::new);
                cache.put(data.value.clone(), meta.clone());
                meta
            }
        })
    } else if let Some(data) = find_metadata(md, APTOS_METADATA_KEY) {
        V0_METADATA_CACHE.with(|ref_cell| {
            let mut cache = ref_cell.borrow_mut();
            if let Some(meta) = cache.get(&data.value) {
                meta.clone()
            } else {
                let meta = bcs::from_bytes::<RuntimeModuleMetadata>(&data.value)
                    .ok()
                    .map(RuntimeModuleMetadata::upgrade)
                    .map(Arc::new);
                cache.put(data.value.clone(), meta.clone());
                meta
            }
        })
    } else {
        None
    }
}
```

**File:** types/src/vm/module_metadata.rs (L287-308)
```rust
pub fn get_metadata_from_compiled_code(
    code: &impl CompiledCodeMetadata,
) -> Option<RuntimeModuleMetadataV1> {
    if let Some(data) = find_metadata(code.metadata(), APTOS_METADATA_KEY_V1) {
        let mut metadata = bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value).ok();
        // Clear out metadata for v5, since it shouldn't have existed in the first place and isn't
        // being used. Note, this should have been gated in the verify module metadata.
        if code.version() == 5 {
            if let Some(metadata) = metadata.as_mut() {
                metadata.struct_attributes.clear();
                metadata.fun_attributes.clear();
            }
        }
        metadata
    } else if let Some(data) = find_metadata(code.metadata(), APTOS_METADATA_KEY) {
        // Old format available, upgrade to new one on the fly
        let data_v0 = bcs::from_bytes::<RuntimeModuleMetadata>(&data.value).ok()?;
        Some(data_v0.upgrade())
    } else {
        None
    }
}
```

**File:** types/src/vm/module_metadata.rs (L452-456)
```rust
    let metadata = if let Some(metadata) = get_metadata_from_compiled_code(module) {
        metadata
    } else {
        return Ok(());
    };
```

**File:** aptos-move/aptos-vm/src/data_cache.rs (L50-60)
```rust
pub fn get_resource_group_member_from_metadata(
    struct_tag: &StructTag,
    metadata: &[Metadata],
) -> Option<StructTag> {
    let metadata = get_metadata(metadata)?;
    metadata
        .struct_attributes
        .get(struct_tag.name.as_ident_str().as_str())?
        .iter()
        .find_map(|attr| attr.get_resource_group_member())
}
```

**File:** aptos-move/aptos-vm/src/data_cache.rs (L105-120)
```rust
        let resource_group = get_resource_group_member_from_metadata(struct_tag, metadata);
        if let Some(resource_group) = resource_group {
            let key = StateKey::resource_group(address, &resource_group);
            let buf =
                self.resource_group_view
                    .get_resource_from_group(&key, struct_tag, maybe_layout)?;

            let first_access = self.accessed_groups.borrow_mut().insert(key.clone());
            let group_size = if first_access {
                self.resource_group_view.resource_group_size(&key)?.get()
            } else {
                0
            };

            let buf_size = resource_size(&buf);
            Ok((buf, buf_size + group_size as usize))
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2760-2773)
```rust
            let metadata = get_metadata(&func.owner_as_module()?.metadata);

            let arguments = view_function::validate_view_function(
                session,
                &loader,
                gas_meter,
                traversal_context,
                arguments,
                func_name.as_ident_str(),
                &func,
                metadata.as_ref().map(Arc::as_ref),
                vm.features().is_enabled(FeatureFlag::STRUCT_CONSTRUCTORS),
            )
            .map_err(|e| e.finish(Location::Module(module_id)))?;
```

**File:** aptos-move/aptos-vm/src/verifier/view_function.rs (L19-31)
```rust
pub fn determine_is_view(
    module_metadata: Option<&RuntimeModuleMetadataV1>,
    fun_name: &IdentStr,
) -> bool {
    if let Some(data) = module_metadata {
        data.fun_attributes
            .get(fun_name.as_str())
            .map(|attrs| attrs.iter().any(|attr| attr.is_view_function()))
            .unwrap_or_default()
    } else {
        false
    }
}
```

**File:** aptos-move/aptos-vm/src/verifier/resource_groups.rs (L119-124)
```rust
    let (new_groups, mut new_members) =
        if let Some(metadata) = get_metadata_from_compiled_code(new_module) {
            extract_resource_group_metadata(&metadata)?
        } else {
            (BTreeMap::new(), BTreeMap::new())
        };
```
