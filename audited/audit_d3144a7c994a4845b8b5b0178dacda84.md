# Audit Report

## Title
Unverified REST API Responses Enable Selective Validator Hiding in Discovery Process

## Summary
The REST-based validator discovery mechanism in `poll_next()` accepts ValidatorSet responses from configured REST endpoints without cryptographic verification or completeness checks. A compromised or malicious REST endpoint can selectively omit validators, causing targeted node isolation during the critical bootstrap phase.

## Finding Description

The `RestStream::poll_next()` function retrieves the ValidatorSet from a configured REST endpoint without any validation: [1](#0-0) 

The REST client simply deserializes the BCS response without verification: [2](#0-1) 

The returned ValidatorSet is passed directly to `extract_validator_set_updates()` without checking completeness: [3](#0-2) 

**Attack Propagation:**

1. Node operator configures REST discovery (common during bootstrap when "genesis is significantly far behind"): [4](#0-3) 

2. Malicious REST endpoint returns ValidatorSet with specific validators omitted
3. ConnectivityManager receives incomplete peer set with `DiscoverySource::Rest`
4. During bootstrap, before OnChain discovery becomes operational, this is the sole source of validator information
5. Node attempts connections only to the subset provided, becoming isolated from omitted validators

**Multi-Source Mitigation (Partial):**

While the system supports multiple discovery sources with priority ordering (OnChain > File > Rest): [5](#0-4) 

The vulnerability window exists when:
- Only REST discovery is configured (valid per test usage): [6](#0-5) 
- During initial bootstrap before OnChain discovery receives reconfiguration events
- The REST endpoint is the primary/sole operational source

## Impact Explanation

**High Severity** per bug bounty criteria:
- **Validator node slowdowns**: Isolated nodes have degraded connectivity, affecting consensus participation
- **Significant protocol violations**: Reduces network resilience against Byzantine attacks as stated in the security question
- **Consensus impact**: Selective isolation can prevent honest validators from participating effectively, approaching Byzantine fault threshold

If multiple nodes are configured with the same compromised REST endpoint, coordinated isolation can partition the network, potentially violating the "< 1/3 Byzantine" safety assumption of AptosBFT.

## Likelihood Explanation

**Medium-High Likelihood:**

**Factors increasing likelihood:**
- REST discovery is documented for bootstrap scenarios when "genesis is significantly far behind"
- Fullnodes commonly use REST discovery to connect to validator networks
- No cryptographic verification means any compromised endpoint can inject false data
- HTTP URLs (no HTTPS enforcement) enable MITM attacks
- Node operators may trust infrastructure providers whose endpoints get compromised

**Factors decreasing likelihood:**
- Requires node operator to configure specific REST URL
- Most production deployments likely use both OnChain + REST discovery
- HTTPS provides transport security (though not data authenticity)

**Realistic attack scenarios:**
1. **Infrastructure compromise**: Legitimate REST endpoint gets compromised
2. **MITM if HTTP used**: Network attacker modifies responses in transit
3. **Malicious infrastructure provider**: Trusted provider turns malicious

## Recommendation

**Implement state proof verification for REST API responses:**

```rust
// In network/discovery/src/rest.rs, modify poll_next():

fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
    futures::ready!(self.interval.as_mut().poll_next(cx));

    let response = block_on(self.rest_client.get_account_resource_with_proof::<ValidatorSet>(
        AccountAddress::ONE,
        "0x1::stake::ValidatorSet",
    ));
    
    Poll::Ready(match response {
        Ok(response_with_proof) => {
            // Verify state proof against known root hash
            if let Err(e) = verify_state_proof(&response_with_proof) {
                info!("REST discovery: state proof verification failed: {:?}", e);
                return Some(Err(DiscoveryError::InvalidProof(e)));
            }
            
            let validator_set = response_with_proof.into_inner();
            Some(Ok(extract_validator_set_updates(
                self.network_context,
                validator_set,
            )))
        },
        Err(err) => {
            info!("Failed to retrieve validator set by REST discovery {:?}", err);
            Some(Err(DiscoveryError::Rest(err)))
        },
    })
}
```

**Alternative mitigation:**
- Document that REST discovery requires trusted endpoints
- Enforce HTTPS-only URLs in configuration validation
- Add completeness checks comparing REST data against cached OnChain state
- Emit alerts when REST and OnChain sources significantly diverge

## Proof of Concept

```rust
// Create malicious REST server that omits specific validators
use actix_web::{web, App, HttpResponse, HttpServer};
use aptos_types::on_chain_config::ValidatorSet;

#[actix_web::main]
async fn main() -> std::io::Result<()> {
    HttpServer::new(|| {
        App::new()
            .route("/v1/accounts/0x1/resource/0x1::stake::ValidatorSet", 
                   web::get().to(malicious_validator_set))
    })
    .bind("127.0.0.1:8080")?
    .run()
    .await
}

async fn malicious_validator_set() -> HttpResponse {
    // Create ValidatorSet omitting target validators
    let mut full_set = get_real_validator_set(); // From legitimate source
    let omitted_validators = vec![target_validator_1, target_validator_2];
    
    // Remove specific validators to isolate them
    full_set.retain(|v| !omitted_validators.contains(&v.account_address()));
    
    // Return incomplete set in BCS format
    let bcs_data = bcs::to_bytes(&full_set).unwrap();
    HttpResponse::Ok()
        .content_type("application/x-bcs")
        .body(bcs_data)
}

// Configure victim node with malicious REST endpoint:
// discovery_method = { Rest = { url = "http://127.0.0.1:8080", interval_secs = 1 } }
// 
// Result: Node only connects to subset of validators, isolated from omitted ones
```

---

**Notes:**

This vulnerability exists but has **limited exploitability** because it requires the node operator to configure a compromised REST endpoint. However, it represents a genuine security weakness: REST API responses lack cryptographic verification, violating defense-in-depth principles. Production deployments should use both OnChain and REST discovery, with OnChain as the authoritative source.

### Citations

**File:** network/discovery/src/rest.rs (L42-68)
```rust
    fn poll_next(mut self: Pin<&mut Self>, cx: &mut Context<'_>) -> Poll<Option<Self::Item>> {
        // Wait for delay, or add the delay for next call
        futures::ready!(self.interval.as_mut().poll_next(cx));

        // Retrieve the onchain resource at the interval
        // TODO there should be a better way than converting this to a blocking call
        let response = block_on(self.rest_client.get_account_resource_bcs::<ValidatorSet>(
            AccountAddress::ONE,
            "0x1::stake::ValidatorSet",
        ));
        Poll::Ready(match response {
            Ok(inner) => {
                let validator_set = inner.into_inner();
                Some(Ok(extract_validator_set_updates(
                    self.network_context,
                    validator_set,
                )))
            },
            Err(err) => {
                info!(
                    "Failed to retrieve validator set by REST discovery {:?}",
                    err
                );
                Some(Err(DiscoveryError::Rest(err)))
            },
        })
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L1209-1221)
```rust
    pub async fn get_account_resource_bcs<T: DeserializeOwned>(
        &self,
        address: AccountAddress,
        resource_type: &str,
    ) -> AptosResult<Response<T>> {
        let url = self.build_path(&format!(
            "accounts/{}/resource/{}",
            address.to_hex(),
            resource_type
        ))?;
        let response = self.get_bcs(url).await?;
        Ok(response.and_then(|inner| bcs::from_bytes(&inner))?)
    }
```

**File:** network/discovery/src/validator_set.rs (L108-150)
```rust
pub(crate) fn extract_validator_set_updates(
    network_context: NetworkContext,
    node_set: ValidatorSet,
) -> PeerSet {
    let is_validator = network_context.network_id().is_validator_network();

    // Decode addresses while ignoring bad addresses
    node_set
        .into_iter()
        .map(|info| {
            let peer_id = *info.account_address();
            let config = info.into_config();

            let addrs = if is_validator {
                config
                    .validator_network_addresses()
                    .map_err(anyhow::Error::from)
            } else {
                config
                    .fullnode_network_addresses()
                    .map_err(anyhow::Error::from)
            }
            .map_err(|err| {
                inc_by_with_context(&DISCOVERY_COUNTS, &network_context, "read_failure", 1);

                warn!(
                    NetworkSchema::new(&network_context),
                    "OnChainDiscovery: Failed to parse any network address: peer: {}, err: {}",
                    peer_id,
                    err
                )
            })
            .unwrap_or_default();

            let peer_role = if is_validator {
                PeerRole::Validator
            } else {
                PeerRole::ValidatorFullNode
            };
            (peer_id, Peer::from_addrs(peer_role, addrs))
        })
        .collect()
}
```

**File:** network/builder/src/builder.rs (L379-385)
```rust
                DiscoveryMethod::Rest(rest_discovery) => DiscoveryChangeListener::rest(
                    self.network_context,
                    conn_mgr_reqs_tx.clone(),
                    rest_discovery.url.clone(),
                    Duration::from_secs(rest_discovery.interval_secs),
                    self.time_service.clone(),
                ),
```

**File:** network/framework/src/connectivity_manager/mod.rs (L139-144)
```rust
pub enum DiscoverySource {
    OnChainValidatorSet,
    File,
    Rest,
    Config,
}
```

**File:** testsuite/smoke-test/src/network.rs (L156-159)
```rust
    network_config.discovery_method = DiscoveryMethod::Rest(RestDiscovery {
        url: rest_endpoint,
        interval_secs: 1,
    });
```
