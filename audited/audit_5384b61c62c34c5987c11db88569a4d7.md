# Audit Report

## Title
Missing Validation Allows Zero Minimum Stake in Genesis Configuration Leading to Costless Validator Set Formation

## Summary
The genesis configuration validation logic fails to enforce `minimum_stake > 0`, allowing the creation of networks where validators can join the active set with zero economic security. This violates the fundamental economic security model of proof-of-stake consensus.

## Finding Description

The Aptos genesis creation process lacks critical validation to ensure `minimum_stake` is greater than zero. This vulnerability exists across multiple validation layers:

**Layer 1: Rust Genesis Configuration Validation**

The `validate_genesis_config` function only validates that `min_stake <= max_stake` but never checks if `min_stake > 0`: [1](#0-0) 

**Layer 2: Move Framework Staking Configuration**

The `validate_required_stake` function in the staking configuration module similarly only validates the relationship between minimum and maximum stake, but not the absolute minimum value: [2](#0-1) 

This validation is called during genesis initialization: [3](#0-2) 

**Layer 3: Validator Joining Logic**

When validators attempt to join the validator set during genesis, the `join_validator_set_internal` function checks if `voting_power >= minimum_stake`: [4](#0-3) 

If `minimum_stake = 0`, this assertion becomes `voting_power >= 0`, which is trivially true for any `u64` value, allowing validators with zero stake to join.

**Attack Execution Path:**

1. Network operator creates genesis layout with `min_stake: 0` and `max_stake: 1`
2. The Layout struct accepts this configuration: [5](#0-4) 

3. Validators are configured with `stake_amount: 0`
4. Rust validation passes (0 <= 1): [6](#0-5) 

5. Move validation passes (0 <= 1 && 1 > 0)
6. Validators with zero stake successfully join during genesis initialization: [7](#0-6) 

7. Network launches with validators having no economic security

**Invariant Violations:**

This breaks multiple critical invariants:
- **Staking Security**: "Validator rewards and penalties must be calculated correctly" - validators with zero stake have no economic penalty for misbehavior
- **Governance Integrity**: "Voting power must be correctly calculated from stake" - voting power should not exist without stake
- **Consensus Safety**: Economic security model assumes validators have skin in the game

## Impact Explanation

**Severity: Critical** (per Aptos Bug Bounty criteria)

This vulnerability enables:

1. **Consensus Safety Violations**: Validators with zero stake have no economic disincentive against Byzantine behavior, potentially enabling double-spending or chain reorganizations

2. **Costless 51% Attack**: A malicious actor could create a network with multiple zero-stake validators they control, achieving consensus majority with zero capital investment

3. **Governance Manipulation**: Zero-stake validators could participate in on-chain governance voting without economic commitment

4. **Reputation Damage**: If exploited on a testnet or private network, it could mislead users about the security guarantees of Aptos-based networks

This meets the **Critical Severity** category: "Consensus/Safety violations" - the fundamental assumption of PoS economic security is violated.

## Likelihood Explanation

**Likelihood: Low (but Impact: Critical)**

While the code vulnerability exists, exploitation requires **privileged access** to genesis creation:

- **Mainnet**: Only Aptos Foundation controls genesis (trusted actor per threat model)
- **Testnets**: Controlled by Aptos Labs or authorized operators
- **Private Networks**: Controlled by network deployer

However, this represents a **defense-in-depth failure**:
1. Compromised genesis creation tools could introduce this misconfiguration
2. Malicious actors could deploy scam networks targeting unsophisticated users
3. Automated deployment pipelines might accept invalid configurations
4. Future governance mechanisms allowing parameter updates would inherit this flaw

The lack of validation violates the principle of "secure by default" and creates unnecessary risk surface.

## Recommendation

Add explicit validation requiring `minimum_stake > 0` at all validation layers:

**Rust Layer (aptos-move/vm-genesis/src/lib.rs):**
```rust
fn validate_genesis_config(genesis_config: &GenesisConfiguration) {
    assert!(
        genesis_config.min_stake > 0,
        "Minimum stake must be greater than 0"
    );
    assert!(
        genesis_config.min_stake <= genesis_config.max_stake,
        "Min stake must be smaller than or equal to max stake"
    );
    // ... rest of validations
}
```

**Move Layer (staking_config.move):**
```move
fun validate_required_stake(minimum_stake: u64, maximum_stake: u64) {
    assert!(
        minimum_stake > 0, 
        error::invalid_argument(EZERO_MINIMUM_STAKE)  // Add new error code
    );
    assert!(
        minimum_stake <= maximum_stake && maximum_stake > 0, 
        error::invalid_argument(EINVALID_STAKE_RANGE)
    );
}
```

**Additional Recommendation:**
Add a reasonable lower bound (e.g., 1 million APT) rather than just > 0 to ensure meaningful economic security: [8](#0-7) 

## Proof of Concept

**Step 1: Create malicious genesis layout (layout.yaml):**
```yaml
root_key: null
users: ["validator1", "validator2", "validator3"]
chain_id: 99
allow_new_validators: false
epoch_duration_secs: 7200
is_test: true
min_stake: 0                    # ← Malicious value
min_voting_threshold: 100000000000000
max_stake: 100000000000000000
recurring_lockup_duration_secs: 86400
required_proposer_stake: 100000000000000
rewards_apy_percentage: 10
voting_duration_secs: 43200
voting_power_increase_limit: 20
```

**Step 2: Create validator configurations with zero stake:**
```yaml
# validator1.yaml
owner_account_address: "0x..."
stake_amount: 0    # ← Zero stake
join_during_genesis: true
# ... other fields
```

**Step 3: Generate genesis:**
```bash
aptos genesis generate-genesis --local-repository-dir ./genesis --output-dir ./genesis-output
```

**Expected Result**: Genesis generation succeeds despite zero minimum stake, creating a network where validators have no economic security.

**Validation Test**: The following Move test demonstrates the lack of validation:

```move
#[test(aptos_framework = @aptos_framework)]
fun test_zero_minimum_stake_accepted(aptos_framework: signer) {
    // This should fail but currently passes
    staking_config::initialize(
        &aptos_framework,
        0,      // minimum_stake = 0 (should be rejected)
        1000,   // maximum_stake
        86400,  // recurring_lockup_duration_secs
        true,   // allow_validator_set_change
        10,     // rewards_rate
        100,    // rewards_rate_denominator
        20      // voting_power_increase_limit
    );
    // If we reach here, zero minimum stake was accepted
}
```

## Notes

- This vulnerability requires control over genesis creation, which is a privileged operation
- The immediate risk is limited to testnet deployments and private networks
- However, the lack of validation represents a defense-in-depth failure that should be addressed
- The default value of `100_000_000_000_000` (1M APT) provides adequate protection when using default configurations
- Manual configuration without proper validation could inadvertently introduce this vulnerability

### Citations

**File:** aptos-move/vm-genesis/src/lib.rs (L405-409)
```rust
fn validate_genesis_config(genesis_config: &GenesisConfiguration) {
    assert!(
        genesis_config.min_stake <= genesis_config.max_stake,
        "Min stake must be smaller than or equal to max stake"
    );
```

**File:** aptos-move/framework/aptos-framework/sources/configs/staking_config.move (L93-106)
```text
    public(friend) fun initialize(
        aptos_framework: &signer,
        minimum_stake: u64,
        maximum_stake: u64,
        recurring_lockup_duration_secs: u64,
        allow_validator_set_change: bool,
        rewards_rate: u64,
        rewards_rate_denominator: u64,
        voting_power_increase_limit: u64,
    ) {
        system_addresses::assert_aptos_framework(aptos_framework);

        // This can fail genesis but is necessary so that any misconfigurations can be corrected before genesis succeeds
        validate_required_stake(minimum_stake, maximum_stake);
```

**File:** aptos-move/framework/aptos-framework/sources/configs/staking_config.move (L372-374)
```text
    fun validate_required_stake(minimum_stake: u64, maximum_stake: u64) {
        assert!(minimum_stake <= maximum_stake && maximum_stake > 0, error::invalid_argument(EINVALID_STAKE_RANGE));
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1072-1076)
```text
        let config = staking_config::get();
        let (minimum_stake, maximum_stake) = staking_config::get_required_stake(&config);
        let voting_power = get_next_epoch_voting_power(stake_pool);
        assert!(voting_power >= minimum_stake, error::invalid_argument(ESTAKE_TOO_LOW));
        assert!(voting_power <= maximum_stake, error::invalid_argument(ESTAKE_TOO_HIGH));
```

**File:** crates/aptos-genesis/src/config.rs (L50-51)
```rust
    /// Minimum stake to be in the validator set
    pub min_stake: u64,
```

**File:** crates/aptos-genesis/src/config.rs (L116-116)
```rust
            min_stake: 100_000_000_000_000,
```

**File:** crates/aptos/src/genesis/mod.rs (L701-706)
```rust
        if validator.stake_amount < layout.min_stake {
            errors.push(CliError::UnexpectedError(format!(
                "Validator {} has stake {} under the min stake {}",
                name, validator.stake_amount, layout.min_stake
            )));
        }
```

**File:** aptos-move/framework/aptos-framework/sources/genesis.move (L375-391)
```text
    fun initialize_validator(pool_address: address, validator: &ValidatorConfiguration) {
        let operator = &create_signer(validator.operator_address);

        stake::rotate_consensus_key(
            operator,
            pool_address,
            validator.consensus_pubkey,
            validator.proof_of_possession,
        );
        stake::update_network_and_fullnode_addresses(
            operator,
            pool_address,
            validator.network_addresses,
            validator.full_node_network_addresses,
        );
        stake::join_validator_set_internal(operator, pool_address);
    }
```
