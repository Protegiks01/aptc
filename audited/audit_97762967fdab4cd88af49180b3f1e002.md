# Audit Report

## Title
Incomplete Network Configuration Validation in sanitize_fullnode_network_configs() Enables Eclipse Attacks and Resource Exhaustion

## Summary
The `sanitize_fullnode_network_configs()` function only validates the `network_id` field of each `NetworkConfig`, failing to validate critical security parameters including seed peer addresses, listen addresses, and resource limits. This allows malicious configurations to pass validation, potentially enabling eclipse attacks and denial-of-service conditions.

## Finding Description

The configuration sanitizer in `sanitize_fullnode_network_configs()` performs minimal validation: [1](#0-0) 

This function only checks:
1. Fullnode networks are not empty for fullnodes
2. Each network_id is not a validator network
3. Each network_id is unique

However, the `NetworkConfig` struct contains numerous security-critical fields that are completely unvalidated: [2](#0-1) 

**Unvalidated fields include:**
- `listen_address` - Could specify malicious IPs or privileged ports
- `seed_addrs`/`seeds` - Could point to attacker-controlled peers
- `max_frame_size` - Could be set below the 64-byte minimum causing runtime panics
- `max_message_size` - Could be set to extreme values causing memory exhaustion
- `max_inbound_connections`/`max_outbound_connections` - Could be set to 0 (DoS) or extreme values
- Rate limiting configurations - Could be disabled or set ineffectively

While some runtime validation exists (e.g., `verify_seeds()` checks address format), this occurs during network building, not during configuration sanitization: [3](#0-2) 

The runtime validation in `OutboundStream::new` will panic if `max_frame_size` is invalid: [4](#0-3) 

**Attack Scenario:**
1. Attacker crafts a malicious configuration with attacker-controlled seed peer addresses
2. Fullnode operator obtains this configuration (e.g., from community resources, documentation, or social engineering)
3. Configuration passes sanitization because only `network_id` is validated
4. Node starts and connects exclusively to attacker-controlled peers (eclipse attack)
5. Attacker feeds false blockchain data, censors transactions, or performs man-in-the-middle attacks

**Alternative Attack Scenarios:**
- Setting `max_frame_size` to 32 bytes causes immediate panic at runtime
- Setting `max_inbound_connections` to 0 prevents all inbound connections
- Setting `max_message_size` to `usize::MAX` enables memory exhaustion attacks

## Impact Explanation

**Primary Impact - Eclipse Attacks (High Severity):**
Eclipse attacks can lead to:
- False transaction confirmations (users believe transactions succeeded when they didn't)
- Censorship of transactions
- State inconsistencies requiring manual intervention
- Potential loss of funds if users rely on false state information

This meets **Medium Severity** criteria per the bug bounty program: "State inconsistencies requiring intervention"

**Secondary Impact - Denial of Service (Medium Severity):**
- Runtime panics from invalid parameters prevent node startup
- Resource exhaustion from extreme values degrades node performance
- Connection limit manipulation prevents normal P2P operation

## Likelihood Explanation

**Likelihood: Medium**

The attack requires:
1. Node operator to obtain and use a malicious configuration file
2. Operator trust in the configuration source (community docs, forums, etc.)
3. No additional out-of-band verification of seed peer identities

While this requires operator error, several factors increase likelihood:
- Fullnode operators often copy configurations from documentation or community sources
- The sanitizer passing the configuration provides false assurance of safety
- Other config sanitizers enforce mainnet security requirements (e.g., `ExecutionConfig` requires paranoid verification), establishing expectation that sanitizer validates security-critical parameters
- No warnings are provided about unvalidated seed addresses

The attack does not require validator access or on-chain actions - only the ability to distribute a malicious configuration file.

## Recommendation

Enhance `sanitize_fullnode_network_configs()` to validate all security-critical `NetworkConfig` parameters:

```rust
fn sanitize_fullnode_network_configs(
    node_config: &NodeConfig,
    node_type: NodeType,
    _chain_id: Option<ChainId>,
) -> Result<(), Error> {
    let sanitizer_name = FULLNODE_NETWORKS_SANITIZER_NAME.to_string();
    let fullnode_networks = &node_config.full_node_networks;

    // Existing checks...
    if fullnode_networks.is_empty() && !node_type.is_validator() {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name.clone(),
            "Fullnode networks cannot be empty for fullnodes!".into(),
        ));
    }

    let mut fullnode_network_ids = HashSet::new();
    for fullnode_network_config in fullnode_networks {
        let network_id = fullnode_network_config.network_id;

        // Existing network_id checks...
        if network_id.is_validator_network() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name.clone(),
                "Fullnode network configs cannot include a validator network!".into(),
            ));
        }

        if !fullnode_network_ids.insert(network_id) {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name.clone(),
                format!("Each fullnode network config must be unique! Found duplicate: {}", network_id),
            ));
        }

        // NEW: Validate seed addresses
        fullnode_network_config.verify_seeds().map_err(|e| {
            Error::ConfigSanitizerFailed(
                sanitizer_name.clone(),
                format!("Invalid seed configuration: {}", e),
            )
        })?;

        // NEW: Validate frame size
        const MIN_FRAME_SIZE: usize = 64 + 100; // FRAME_OVERHEAD_BYTES + buffer
        if fullnode_network_config.max_frame_size < MIN_FRAME_SIZE {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name.clone(),
                format!("max_frame_size ({}) must be at least {} bytes", 
                    fullnode_network_config.max_frame_size, MIN_FRAME_SIZE),
            ));
        }

        // NEW: Validate message size compatibility
        if fullnode_network_config.max_message_size > 
           fullnode_network_config.max_frame_size * 255 {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name.clone(),
                "max_message_size incompatible with max_frame_size".into(),
            ));
        }

        // NEW: Validate connection limits
        const MAX_REASONABLE_CONNECTIONS: usize = 10000;
        if fullnode_network_config.max_inbound_connections > MAX_REASONABLE_CONNECTIONS {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name.clone(),
                format!("max_inbound_connections ({}) exceeds reasonable limit", 
                    fullnode_network_config.max_inbound_connections),
            ));
        }
    }

    Ok(())
}
```

Additionally, consider adding warnings or documentation about seed peer verification for community-provided configurations.

## Proof of Concept

```rust
#[cfg(test)]
mod test_incomplete_validation {
    use super::*;
    use crate::config::{NetworkConfig, NodeConfig, PeerSet, Peer, PeerRole};
    use crate::network_id::NetworkId;
    use aptos_types::network_address::NetworkAddress;
    use aptos_types::PeerId;
    use std::collections::HashMap;
    use std::str::FromStr;

    #[test]
    fn test_malicious_seeds_pass_sanitization() {
        // Create a config with attacker-controlled seed peers
        let mut seeds = HashMap::new();
        let attacker_peer_id = PeerId::random();
        
        // Malicious seed with valid format but attacker-controlled address
        let attacker_seed = Peer {
            addresses: vec![
                NetworkAddress::from_str(
                    "/dns/attacker.evil.com/tcp/6182/noise-ik/0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef/handshake/0"
                ).unwrap()
            ],
            keys: Default::default(),
            role: PeerRole::Upstream,
        };
        seeds.insert(attacker_peer_id, attacker_seed);

        let node_config = NodeConfig {
            full_node_networks: vec![NetworkConfig {
                network_id: NetworkId::Public,
                seeds,
                ..Default::default()
            }],
            ..Default::default()
        };

        // This SHOULD fail but currently passes
        let result = sanitize_fullnode_network_configs(
            &node_config,
            NodeType::PublicFullnode,
            Some(ChainId::testnet()),
        );
        
        // Currently passes - demonstrates the vulnerability
        assert!(result.is_ok(), "Malicious seeds incorrectly pass validation!");
    }

    #[test]
    fn test_invalid_frame_size_passes_sanitization() {
        let node_config = NodeConfig {
            full_node_networks: vec![NetworkConfig {
                network_id: NetworkId::Public,
                max_frame_size: 32, // Too small, will cause panic at runtime
                ..Default::default()
            }],
            ..Default::default()
        };

        // This SHOULD fail but currently passes
        let result = sanitize_fullnode_network_configs(
            &node_config,
            NodeType::PublicFullnode,
            Some(ChainId::testnet()),
        );
        
        assert!(result.is_ok(), "Invalid frame size incorrectly passes validation!");
        // Node would panic later when OutboundStream::new is called
    }

    #[test]
    fn test_zero_connection_limit_passes() {
        let node_config = NodeConfig {
            full_node_networks: vec![NetworkConfig {
                network_id: NetworkId::Public,
                max_inbound_connections: 0, // Prevents all connections
                ..Default::default()
            }],
            ..Default::default()
        };

        let result = sanitize_fullnode_network_configs(
            &node_config,
            NodeType::PublicFullnode,
            Some(ChainId::testnet()),
        );
        
        assert!(result.is_ok(), "Zero connection limit incorrectly passes validation!");
    }
}
```

**Notes:**
- The vulnerability exists in the incomplete validation logic of the config sanitizer
- While exploitation requires operator error (using malicious configs), the sanitizer's failure to validate creates a security gap
- Other config sanitizers (e.g., ExecutionConfig) enforce mainnet security requirements, establishing that sanitizers should validate security-critical parameters
- The most serious impact is eclipse attacks via malicious seed addresses, which could lead to state inconsistencies and false transaction confirmations
- Secondary impacts include runtime panics and resource exhaustion from invalid parameter values

### Citations

**File:** config/src/config/config_sanitizer.rs (L112-154)
```rust
fn sanitize_fullnode_network_configs(
    node_config: &NodeConfig,
    node_type: NodeType,
    _chain_id: Option<ChainId>,
) -> Result<(), Error> {
    let sanitizer_name = FULLNODE_NETWORKS_SANITIZER_NAME.to_string();
    let fullnode_networks = &node_config.full_node_networks;

    // Verify that the fullnode network configs are not empty for fullnodes
    if fullnode_networks.is_empty() && !node_type.is_validator() {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name,
            "Fullnode networks cannot be empty for fullnodes!".into(),
        ));
    }

    // Check each fullnode network config and ensure uniqueness
    let mut fullnode_network_ids = HashSet::new();
    for fullnode_network_config in fullnode_networks {
        let network_id = fullnode_network_config.network_id;

        // Verify that the fullnode network config is not a validator network config
        if network_id.is_validator_network() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Fullnode network configs cannot include a validator network!".into(),
            ));
        }

        // Verify that the fullnode network config is unique
        if !fullnode_network_ids.insert(network_id) {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                format!(
                    "Each fullnode network config must be unique! Found duplicate: {}",
                    network_id
                ),
            ));
        }
    }

    Ok(())
}
```

**File:** config/src/config/network_config.rs (L55-126)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct NetworkConfig {
    /// Maximum backoff delay for connecting outbound to peers
    pub max_connection_delay_ms: u64,
    /// Base for outbound connection backoff
    pub connection_backoff_base: u64,
    /// Rate to check connectivity to connected peers
    pub connectivity_check_interval_ms: u64,
    /// Size of all network channels
    pub network_channel_size: usize,
    /// Choose a protocol to discover and dial out to other peers on this network.
    /// `DiscoveryMethod::None` disables discovery and dialing out (unless you have
    /// seed peers configured).
    pub discovery_method: DiscoveryMethod,
    /// Same as `discovery_method` but allows for multiple
    pub discovery_methods: Vec<DiscoveryMethod>,
    /// Identity of this network
    pub identity: Identity,
    // TODO: Add support for multiple listen/advertised addresses in config.
    /// The address that this node is listening on for new connections.
    pub listen_address: NetworkAddress,
    /// Select this to enforce that both peers should authenticate each other, otherwise
    /// authentication only occurs for outgoing connections.
    pub mutual_authentication: bool,
    /// ID of the network to differentiate between networks
    pub network_id: NetworkId,
    /// Number of threads to run for networking
    pub runtime_threads: Option<usize>,
    /// Overrides for the size of the inbound and outbound buffers for each peer.
    /// NOTE: The defaults are None, so socket options are not called. Change to Some values with
    /// caution. Experiments have shown that relying on Linux's default tcp auto-tuning can perform
    /// better than setting these. In particular, for larger values to take effect, the
    /// `net.core.rmem_max` and `net.core.wmem_max` sysctl values may need to be increased. On a
    /// vanilla GCP machine, these are set to 212992. Without increasing the sysctl values and
    /// setting a value will constrain the buffer size to the sysctl value. (In contrast, default
    /// auto-tuning can increase beyond these values.)
    pub inbound_rx_buffer_size_bytes: Option<u32>,
    pub inbound_tx_buffer_size_bytes: Option<u32>,
    pub outbound_rx_buffer_size_bytes: Option<u32>,
    pub outbound_tx_buffer_size_bytes: Option<u32>,
    /// Addresses of initial peers to connect to. In a mutual_authentication network,
    /// we will extract the public keys from these addresses to set our initial
    /// trusted peers set.  TODO: Replace usage in configs with `seeds` this is for backwards compatibility
    pub seed_addrs: HashMap<PeerId, Vec<NetworkAddress>>,
    /// The initial peers to connect to prior to onchain discovery
    pub seeds: PeerSet,
    /// The maximum size of an inbound or outbound request frame
    pub max_frame_size: usize,
    /// Enables proxy protocol on incoming connections to get original source addresses
    pub enable_proxy_protocol: bool,
    /// Interval to send healthcheck pings to peers
    pub ping_interval_ms: u64,
    /// Timeout until a healthcheck ping is rejected
    pub ping_timeout_ms: u64,
    /// Number of failed healthcheck pings until a peer is marked unhealthy
    pub ping_failures_tolerated: u64,
    /// Maximum number of outbound connections, limited by ConnectivityManager
    pub max_outbound_connections: usize,
    /// Maximum number of outbound connections, limited by PeerManager
    pub max_inbound_connections: usize,
    /// Inbound rate limiting configuration, if not specified, no rate limiting
    pub inbound_rate_limit_config: Option<RateLimitConfig>,
    /// Outbound rate limiting configuration, if not specified, no rate limiting
    pub outbound_rate_limit_config: Option<RateLimitConfig>,
    /// The maximum size of an inbound or outbound message (it may be divided into multiple frame)
    pub max_message_size: usize,
    /// The maximum number of parallel message deserialization tasks that can run (per application)
    pub max_parallel_deserialization_tasks: Option<usize>,
    /// Whether or not to enable latency aware peer dialing
    pub enable_latency_aware_dialing: bool,
}
```

**File:** network/builder/src/builder.rs (L473-474)
```rust
fn merge_seeds(config: &NetworkConfig) -> PeerSet {
    config.verify_seeds().expect("Seeds must be well formed");
```

**File:** network/framework/src/protocols/stream/mod.rs (L226-243)
```rust
    pub fn new(
        max_frame_size: usize,
        max_message_size: usize,
        stream_tx: Sender<MultiplexMessage>,
    ) -> Self {
        // Calculate the effective max frame size (subtracting overhead)
        let max_frame_size = max_frame_size
            .checked_sub(FRAME_OVERHEAD_BYTES)
            .expect("Frame size too small, overhead exceeds frame size!");

        // Ensure that the max message size can be supported with the given frame size
        assert!(
            (max_frame_size * (u8::MAX as usize)) >= max_message_size,
            "Stream only supports {} chunks! Frame size {}, message size {}.",
            u8::MAX,
            max_frame_size,
            max_message_size
        );
```
