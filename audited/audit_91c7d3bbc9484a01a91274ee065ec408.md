# Audit Report

## Title
Faucet Allows Funding of Framework Reserved System Addresses Leading to Permanent Fund Loss

## Summary
The Aptos faucet does not validate that receiver addresses are system/framework reserved addresses before funding them. Attackers can drain faucet funds by requesting transfers to framework reserved addresses (0x2, 0x4-0xA, 0xA550C18) where accounts can be created but funds become permanently locked due to absence of private keys.

## Finding Description
The `FundApiComponents::preprocess_request()` function validates the receiver address but does not check whether it is a system or framework reserved address. [1](#0-0) 

The receiver address is obtained by parsing user input without any validation against system addresses. [2](#0-1) 

According to the Aptos framework, addresses 0x1 through 0xA are explicitly defined as framework reserved addresses. [3](#0-2) 

However, the Move framework's account creation logic only prevents account creation at three specific addresses: `@vm_reserved` (0x0), `@aptos_framework` (0x1), and `@aptos_token` (0x3). [4](#0-3) 

This means addresses 0x2, 0x4, 0x5, 0x6, 0x7, 0x8, 0x9, 0xA, and the core_resources address (0xA550C18) are NOT blocked from account creation, despite being reserved for system use. [5](#0-4) 

**Attack Path:**
1. Attacker submits funding request to address 0x2 (or other unblocked reserved address)
2. Request passes through `preprocess_request()` with no system address validation
3. `TransferFunder` calls `aptos_account::transfer()` which attempts to create account at 0x2 [6](#0-5) 
4. Account creation succeeds (0x2 not in blocked list)
5. Faucet funds are transferred to 0x2
6. Since 0x2 is a system address without known private keys, funds are permanently locked
7. Attacker repeats within rate limits to drain faucet

This violates **Access Control Invariant #8**: "System addresses (@aptos_framework, @core_resources) must be protected" - the faucet should never fund system/framework reserved addresses.

## Impact Explanation
**Critical Severity** - This meets the "Loss of Funds" category per Aptos bug bounty criteria. The vulnerability allows:

1. **Direct fund drainage**: Attackers can repeatedly request funding to framework reserved addresses, draining testnet/devnet faucet resources
2. **Permanent fund loss**: Funds sent to system addresses (0x2, 0x4-0xA, 0xA550C18) are unrecoverable as no one possesses private keys for these addresses
3. **System address pollution**: Creating user accounts at framework reserved addresses could interfere with future protocol upgrades or governance operations that expect these addresses to be clean
4. **Rate limit exploitation**: Even with rate limiting, the cumulative effect across multiple IPs/requests leads to significant fund depletion

While this primarily affects testnet/devnet faucets (not mainnet user funds), it represents a critical operational vulnerability that wastes resources and could cause service disruption.

## Likelihood Explanation
**High Likelihood** - This vulnerability is:
- **Trivial to exploit**: Requires only a simple API call with a system address (e.g., `{"address": "0x2"}`)
- **No special privileges needed**: Any user with internet access can submit requests
- **Difficult to detect**: Legitimate-looking funding requests to valid addresses
- **Not currently prevented**: No validation exists in the codebase
- **Repeatable**: Can be executed multiple times within rate limit constraints

The only barriers are existing rate limiters (IP-based, captcha, etc.), which can be circumvented through standard techniques (IP rotation, solving captchas).

## Recommendation
Add explicit validation in `FundApiComponents::preprocess_request()` to reject requests funding system or framework reserved addresses:

```rust
// After line 235 in preprocess_request(), add:
use aptos_sdk::types::account_address::AccountAddress;

// Check if receiver is a framework reserved address that should not be funded
if is_framework_reserved_or_system_address(&receiver) {
    return Err(AptosTapError::new(
        "Cannot fund system or framework reserved addresses".to_string(),
        AptosTapErrorCode::InvalidRequest,
    ));
}

// Helper function to check system addresses
fn is_framework_reserved_or_system_address(addr: &AccountAddress) -> bool {
    let addr_hex = format!("{:#x}", addr);
    // Check framework reserved (0x1-0xA)
    matches!(addr_hex.as_str(), 
        "0x0" | "0x1" | "0x2" | "0x3" | "0x4" | "0x5" | 
        "0x6" | "0x7" | "0x8" | "0x9" | "0xa" | "0xA"
    ) || addr_hex == "0xa550c18" // core_resources
}
```

Alternatively, integrate with the Move framework's `system_addresses::is_framework_reserved_address()` function if accessible from Rust.

## Proof of Concept

**Step 1: Setup**
```bash
# Start local testnet with faucet
aptos node run-local-testnet --with-faucet
```

**Step 2: Exploit**
```bash
# Request funding to framework reserved address 0x2
curl -X POST "http://localhost:8081/fund" \
  -H "Content-Type: application/json" \
  -d '{"address": "0x2", "amount": 100000000}'

# Verify account created at 0x2
aptos account list --account 0x2

# Repeat for other reserved addresses
for addr in 0x4 0x5 0x6 0x7 0x8 0x9 0xa 0xa550c18; do
  curl -X POST "http://localhost:8081/fund" \
    -H "Content-Type: application/json" \
    -d "{\"address\": \"$addr\", \"amount\": 100000000}"
done

# Check faucet balance depletion
aptos account list --account <FAUCET_ADDRESS>
```

**Expected Result**: Faucet successfully creates accounts and transfers funds to all framework reserved addresses, permanently locking those funds as no private keys exist for system addresses.

**Notes**
This vulnerability is specific to faucet operations and does not affect mainnet consensus or user funds directly. However, it represents a critical operational security issue that wastes testnet resources and could enable denial-of-service against faucet infrastructure. The fix is straightforward: add address validation to explicitly reject system/framework reserved addresses in the faucet's preprocessing logic.

### Citations

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L55-76)
```rust
    pub fn receiver(&self) -> Option<AccountAddress> {
        if let Some(auth_key) = self.auth_key.as_ref() {
            return match AccountAddress::from_hex_literal(auth_key) {
                Ok(auth_key) => Some(auth_key),
                Err(_) => AccountAddress::from_hex(auth_key).ok(),
            };
        }
        if let Some(address) = self.address.as_ref() {
            return match AccountAddress::from_hex_literal(address) {
                Ok(address) => Some(address),
                Err(_) => AccountAddress::from_hex(address).ok(),
            };
        }
        if let Some(pub_key) = self.pub_key.as_ref() {
            return match Ed25519PublicKey::from_encoded_string(pub_key) {
                Ok(pub_key) => Some(AuthenticationKey::ed25519(&pub_key).account_address()),
                Err(_) => None,
            };
        }
        None
    }
}
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L227-235)
```rust
        let receiver = match fund_request.receiver() {
            Some(receiver) => receiver,
            None => {
                return Err(AptosTapError::new(
                    "Account address, auth key, or pub key must be provided and valid".to_string(),
                    AptosTapErrorCode::InvalidRequest,
                ))
            },
        };
```

**File:** aptos-move/framework/aptos-framework/sources/system_addresses.move (L44-56)
```text
    /// Return true if `addr` is 0x0 or under the on chain governance's control.
    public fun is_framework_reserved_address(addr: address): bool {
        is_aptos_framework_address(addr) ||
            addr == @0x2 ||
            addr == @0x3 ||
            addr == @0x4 ||
            addr == @0x5 ||
            addr == @0x6 ||
            addr == @0x7 ||
            addr == @0x8 ||
            addr == @0x9 ||
            addr == @0xa
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L276-283)
```text
    public fun create_account_if_does_not_exist(account_address: address) {
        if (!resource_exists_at(account_address)) {
            assert!(
                account_address != @vm_reserved && account_address != @aptos_framework && account_address != @aptos_token,
                error::invalid_argument(ECANNOT_RESERVED_ADDRESS)
            );
            create_account_unchecked(account_address);
        }
```

**File:** aptos-move/framework/src/aptos.rs (L190-210)
```rust
static NAMED_ADDRESSES: Lazy<BTreeMap<String, NumericalAddress>> = Lazy::new(|| {
    let mut result = BTreeMap::new();
    let zero = NumericalAddress::parse_str("0x0").unwrap();
    let one = NumericalAddress::parse_str("0x1").unwrap();
    let three = NumericalAddress::parse_str("0x3").unwrap();
    let four = NumericalAddress::parse_str("0x4").unwrap();
    let seven = NumericalAddress::parse_str("0x7").unwrap();
    let ten = NumericalAddress::parse_str("0xA").unwrap();
    let resources = NumericalAddress::parse_str("0xA550C18").unwrap();
    result.insert("std".to_owned(), one);
    result.insert("aptos_std".to_owned(), one);
    result.insert("aptos_framework".to_owned(), one);
    result.insert("aptos_token".to_owned(), three);
    result.insert("aptos_token_objects".to_owned(), four);
    result.insert("aptos_experimental".to_owned(), seven);
    result.insert("aptos_fungible_asset".to_owned(), ten);
    result.insert("core_resources".to_owned(), resources);
    result.insert("vm".to_owned(), zero);
    result.insert("vm_reserved".to_owned(), zero);
    result
});
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L82-97)
```text
    public entry fun transfer(source: &signer, to: address, amount: u64) {
        if (!account::exists_at(to)) {
            create_account(to)
        };

        if (features::operations_default_to_fa_apt_store_enabled()) {
            fungible_transfer_only(source, to, amount)
        } else {
            // Resource accounts can be created without registering them to receive APT.
            // This conveniently does the registration if necessary.
            if (!coin::is_account_registered<AptosCoin>(to)) {
                coin::register<AptosCoin>(&create_signer(to));
            };
            coin::transfer<AptosCoin>(source, to, amount)
        }
    }
```
