# Audit Report

## Title
BIBECiphertext Replay Attack Enabling Resource Exhaustion and Duplicate Transaction Execution

## Summary
The encrypted transaction processing pipeline contains a critical logic flaw in replay protection. The `TransactionPayload::replay_protection_nonce()` method fails to handle the `EncryptedPayload` variant, forcing all encrypted transactions to use sequence number-based replay protection even when they contain nonce-based replay protection data. Combined with ciphertext verification that only validates sender address (not sequence number), this allows the same ciphertext to be replayed across multiple transactions, causing duplicate execution and resource exhaustion.

## Finding Description

The vulnerability exists due to a logic bug in `types/src/transaction/mod.rs` where `TransactionPayload::replay_protection_nonce()` returns `None` for encrypted payloads: [1](#0-0) 

The method uses a wildcard pattern `_ => None` which matches the `EncryptedPayload` variant, even though `EncryptedPayload` contains an `extra_config` field with potential `replay_protection_nonce`: [2](#0-1) 

This forces `RawTransaction::replay_protector()` to always use sequence numbers for encrypted transactions: [3](#0-2) 

Meanwhile, ciphertext verification only validates against sender address, not sequence number: [4](#0-3) [5](#0-4) 

The transaction deduplicator uses `(sender, replay_protector)` as the deduplication key: [6](#0-5) 

Since encrypted transactions with different sequence numbers have different `replay_protector` values (`SequenceNumber(100)` vs `SequenceNumber(101)`), they bypass deduplication even with identical ciphertexts.

**Attack Flow:**
1. Alice creates encrypted transaction T1 (sequence 100, ciphertext C)
2. T1 executes, decrypting to (executable E, decryption_nonce N)
3. Attacker copies ciphertext C and creates T2 (sequence 101, same ciphertext C)
4. T2 passes verification (sender matches in `PayloadAssociatedData`)
5. T2 bypasses deduplication (different `replay_protector`)
6. T2 decrypts to same (E, N) and executes again

The decryption pipeline confirms that decryption produces a nonce: [7](#0-6) 

However, there is no validation in `transaction_validation.move` or `nonce_validation.move` to check if the `decryption_nonce` has been used before. The nonce validation system only checks the `replay_protection_nonce` from `TransactionExtraConfig`, which encrypted payloads don't expose due to the bug in `replay_protection_nonce()`.

## Impact Explanation

This qualifies as **Medium Severity** per Aptos bug bounty criteria:

**Duplicate Transaction Execution:** The same encrypted transaction payload executes multiple times with different sequence numbers. For fund transfer transactions, this causes:
- Unintended repeated transfers
- Account balance manipulation
- Limited funds loss

**Resource Exhaustion:** Each replayed ciphertext forces validators to perform expensive operations shown in the decryption pipeline: [8](#0-7) 

These include digest computation, key derivation, threshold secret reconstruction, and pairing-based decryption operations.

**State Inconsistencies:** Multiple executions of identical payloads with different sequence numbers create state inconsistencies requiring manual intervention.

This matches the Medium severity criteria: "Limited funds loss or manipulation" and "State inconsistencies requiring manual intervention."

## Likelihood Explanation

**Likelihood: High (when feature is enabled)**

The attack is trivially executable:
1. All encrypted transactions are publicly visible on-chain
2. Ciphertext can be copied without cryptographic knowledge
3. No special privileges required
4. Attack works deterministically

The prerequisite is that encrypted transaction submission must be enabled: [9](#0-8) [10](#0-9) 

While currently disabled by default, this remains a valid security vulnerability that would be exploitable when the feature is enabled.

## Recommendation

Fix `TransactionPayload::replay_protection_nonce()` to handle the `EncryptedPayload` variant:

```rust
pub fn replay_protection_nonce(&self) -> Option<u64> {
    match self {
        Self::Payload(TransactionPayloadInner::V1 { extra_config, .. }) => {
            extra_config.replay_protection_nonce()
        },
        Self::EncryptedPayload(encrypted_payload) => {
            encrypted_payload.extra_config().replay_protection_nonce()
        },
        _ => None,
    }
}
```

Additionally, consider binding ciphertext verification to sequence number or implementing validation of the `decryption_nonce` field to prevent replays.

## Proof of Concept

The vulnerability can be demonstrated by:
1. Creating an encrypted transaction with sequence N
2. Observing successful decryption and execution
3. Creating a new transaction with sequence N+1 but reusing the same ciphertext
4. Verifying that both transactions pass validation and execute the same payload

The core issue is evident in the code structure where `TransactionPayload::replay_protection_nonce()` doesn't access `EncryptedPayload.extra_config`, causing replay protection to always use sequence numbers instead of nonces for encrypted transactions.

### Citations

**File:** types/src/transaction/mod.rs (L579-585)
```rust
    pub fn replay_protector(&self) -> ReplayProtector {
        if let Some(nonce) = self.payload.replay_protection_nonce() {
            ReplayProtector::Nonce(nonce)
        } else {
            ReplayProtector::SequenceNumber(self.sequence_number)
        }
    }
```

**File:** types/src/transaction/mod.rs (L801-808)
```rust
    pub fn replay_protection_nonce(&self) -> Option<u64> {
        match self {
            Self::Payload(TransactionPayloadInner::V1 { extra_config, .. }) => {
                extra_config.replay_protection_nonce()
            },
            _ => None,
        }
    }
```

**File:** types/src/transaction/encrypted_payload.rs (L29-31)
```rust
pub struct PayloadAssociatedData {
    sender: AccountAddress,
}
```

**File:** types/src/transaction/encrypted_payload.rs (L42-64)
```rust
pub enum EncryptedPayload {
    Encrypted {
        ciphertext: Ciphertext,
        extra_config: TransactionExtraConfig,
        payload_hash: HashValue,
    },
    FailedDecryption {
        ciphertext: Ciphertext,
        extra_config: TransactionExtraConfig,
        payload_hash: HashValue,
        eval_proof: EvalProof,
    },
    Decrypted {
        ciphertext: Ciphertext,
        extra_config: TransactionExtraConfig,
        payload_hash: HashValue,
        eval_proof: EvalProof,

        // decrypted things
        executable: TransactionExecutable,
        decryption_nonce: u64,
    },
}
```

**File:** types/src/transaction/encrypted_payload.rs (L147-150)
```rust
    pub fn verify(&self, sender: AccountAddress) -> anyhow::Result<()> {
        let associated_data = PayloadAssociatedData::new(sender);
        self.ciphertext().verify(&associated_data)
    }
```

**File:** consensus/src/txn_hash_and_authenticator_deduper.rs (L44-54)
```rust
        for (i, txn) in transactions.iter().enumerate() {
            match seen.get(&(txn.sender(), txn.replay_protector())) {
                None => {
                    seen.insert((txn.sender(), txn.replay_protector()), i);
                },
                Some(first_index) => {
                    is_possible_duplicate = true;
                    possible_duplicates[*first_index] = true;
                    possible_duplicates[i] = true;
                },
            }
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L92-113)
```rust
        let (digest, proofs_promise) =
            FPTXWeighted::digest(&digest_key, &txn_ciphertexts, encryption_round)?;

        let metadata = SecretShareMetadata::new(
            block.epoch(),
            block.round(),
            block.timestamp_usecs(),
            block.id(),
            digest.clone(),
        );

        let derived_key_share = FPTXWeighted::derive_decryption_key_share(&msk_share, &digest)?;
        derived_self_key_share_tx
            .send(Some(SecretShare::new(
                author,
                metadata.clone(),
                derived_key_share,
            )))
            .expect("must send properly");

        // TODO(ibalajiarun): improve perf
        let proofs = FPTXWeighted::eval_proofs_compute_all(&proofs_promise, &digest_key);
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L121-148)
```rust
        let decrypted_txns = encrypted_txns
            .into_par_iter()
            .zip(txn_ciphertexts)
            .map(|(mut txn, ciphertext)| {
                let eval_proof = proofs.get(&ciphertext.id()).expect("must exist");
                if let Ok(payload) = FPTXWeighted::decrypt_individual::<DecryptedPayload>(
                    &decryption_key.key,
                    &ciphertext,
                    &digest,
                    &eval_proof,
                ) {
                    let (executable, nonce) = payload.unwrap();
                    txn.payload_mut()
                        .as_encrypted_payload_mut()
                        .map(|p| {
                            p.into_decrypted(eval_proof, executable, nonce)
                                .expect("must happen")
                        })
                        .expect("must exist");
                } else {
                    txn.payload_mut()
                        .as_encrypted_payload_mut()
                        .map(|p| p.into_failed_decryption(eval_proof).expect("must happen"))
                        .expect("must exist");
                }
                txn
            })
            .collect();
```

**File:** config/src/config/api_config.rs (L92-92)
```rust
    pub allow_encrypted_txns_submission: bool,
```

**File:** config/src/config/api_config.rs (L145-145)
```rust
            allow_encrypted_txns_submission: false,
```
