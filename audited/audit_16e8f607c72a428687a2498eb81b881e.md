# Audit Report

## Title
Pending Transaction Batch Exposure via Unauthenticated Admin Service Endpoint Enables MEV Attacks

## Summary
The admin service endpoint `/debug/consensus/quorumstoredb` exposes full transaction batch contents including sender addresses, payloads, gas prices, and sequence numbers for pending (uncommitted) transactions stored in the QuorumStoreDB. On testnet/devnet networks with default configuration, this endpoint is publicly accessible without authentication, enabling attackers to analyze pending transactions for front-running, sandwich attacks, and MEV extraction opportunities. [1](#0-0) 

## Finding Description

### Transaction Flow and Exposure Chain

**1. Batch Creation and Persistence:**

When validators create transaction batches from mempool or receive batches from peers, these batches contain full `SignedTransaction` objects with complete transaction details. These batches are immediately persisted to QuorumStoreDB BEFORE consensus commits them. [2](#0-1) 

The conversion from `Batch` to `PersistedValue` explicitly includes the full transaction payload: [3](#0-2) 

These batches are then persisted to the database with their full transaction payloads: [4](#0-3) 

**2. Data Structure Exposure:**

The `PersistedValue` struct stores both metadata and the actual transaction payloads: [5](#0-4) 

Each `SignedTransaction` contains a `RawTransaction` with sensitive details: [6](#0-5) 

The Debug implementation exposes all these fields: [7](#0-6) 

**3. Admin Endpoint Exposure:**

The admin service exposes this data through the `/debug/consensus/quorumstoredb` endpoint, which retrieves batches and formats them using Debug: [8](#0-7) 

**4. Authentication Bypass on Testnet/Devnet:**

The critical vulnerability lies in the authentication configuration. When `authentication_configs` is empty (the default), all requests are automatically authenticated: [9](#0-8) 

On testnet/devnet, the admin service is enabled by default with empty authentication: [10](#0-9) 

The service binds to all network interfaces (0.0.0.0) by default, making it publicly accessible: [11](#0-10) 

**5. Attack Window:**

Batches remain in QuorumStoreDB from creation until they expire or are committed, creating an attack window of seconds to minutes: [12](#0-11) 

### Exploitation Path

1. Attacker monitors testnet/devnet validator nodes (or misconfigured mainnet nodes) on port 9102
2. Attacker queries `/debug/consensus/quorumstoredb?digest=<hash>` or enumerates batches
3. Attacker retrieves full transaction details including:
   - Sender addresses
   - Transaction payloads (function calls, arguments)
   - Gas prices (indicating transaction value/urgency)
   - Sequence numbers
4. Attacker analyzes transactions for profitable opportunities:
   - Large DEX swaps → sandwich attack
   - Liquidation transactions → front-run
   - Arbitrage transactions → copy strategy
5. Attacker submits competing transactions to extract MEV

## Impact Explanation

**Severity: HIGH (Information Disclosure Enabling MEV)**

This vulnerability qualifies as HIGH severity under the Aptos bug bounty program because it represents a significant protocol violation of transaction privacy expectations and enables:

1. **MEV Extraction**: Attackers can front-run, sandwich, or copy profitable transactions
2. **Privacy Violation**: User transaction strategies and positions are exposed before execution
3. **Market Manipulation**: Knowledge of pending large transactions enables market manipulation
4. **Testnet/Devnet Risk**: Real strategies are often tested on testnet before mainnet deployment, exposing them to analysis

**Scope Limitations:**
- Mainnet is protected by default (admin service disabled)
- Mainnet has enforced authentication requirements if enabled
- Primary impact is on testnet/devnet with default configuration
- Mainnet exploitation requires operator misconfiguration

However, the vulnerability remains HIGH because:
- Testnet/devnet nodes are production systems for testing
- Operator misconfiguration on mainnet is a realistic threat
- The information exposed is highly sensitive regardless of network [13](#0-12) 

## Likelihood Explanation

**Likelihood: HIGH on testnet/devnet, MEDIUM on mainnet**

**Testnet/Devnet (HIGH):**
- Admin service enabled by default
- No authentication configured by default
- Publicly accessible on 0.0.0.0:9102
- Attackers can trivially scan and access endpoints

**Mainnet (MEDIUM):**
- Admin service disabled by default
- ConfigSanitizer enforces authentication if enabled
- Requires operator error: enabling service without configuring authentication
- Some operators may enable for debugging and forget to secure it

**Attacker Requirements:**
- Network access to validator node port 9102 (typically available)
- Knowledge of batch digests (can enumerate via get_all_batches)
- Simple HTTP GET requests (low technical barrier)

## Recommendation

**Immediate Mitigations:**

1. **Remove Transaction Payloads from Admin Endpoint Response:**

Modify `dump_quorum_store_db()` to only expose batch metadata, not transaction payloads:

```rust
fn dump_quorum_store_db(
    quorum_store_db: &dyn QuorumStoreStorage,
    digest: Option<HashValue>,
) -> anyhow::Result<String> {
    let mut body = String::new();

    if let Some(digest) = digest {
        body.push_str(&format!("{digest:?}:\n"));
        if let Ok(Some(batch)) = quorum_store_db.get_batch(&digest) {
            // Only expose metadata, not transaction payloads
            body.push_str(&format!(
                "Batch Metadata: author={:?}, epoch={}, expiration={}, num_txns={}, num_bytes={}\n",
                batch.author(),
                batch.epoch(),
                batch.expiration(),
                batch.num_txns(),
                batch.num_bytes()
            ));
            // DO NOT expose: batch.payload()
        }
    } else {
        for (digest, batch) in quorum_store_db.get_all_batches()? {
            body.push_str(&format!("{digest:?}: author={:?}, num_txns={}\n", 
                batch.author(), batch.num_txns()));
        }
    }

    Ok(body)
}
```

2. **Enforce Authentication on All Networks:**

Update ConfigOptimizer to require authentication even on testnet/devnet:

```rust
impl ConfigOptimizer for AdminServiceConfig {
    fn optimize(
        node_config: &mut NodeConfig,
        _local_config_yaml: &Value,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<bool, Error> {
        let mut modified_config = false;

        // Always require authentication if enabled, even on testnet
        if node_config.admin_service.enabled == Some(true) 
            && node_config.admin_service.authentication_configs.is_empty() {
            return Err(Error::ConfigSanitizerFailed(
                Self::get_sanitizer_name(),
                "Must enable authentication for AdminService on all networks.".into(),
            ));
        }

        // ... rest of optimization logic
    }
}
```

3. **Bind to Localhost by Default:**

Change default binding to localhost instead of all interfaces:

```rust
impl Default for AdminServiceConfig {
    fn default() -> Self {
        Self {
            enabled: None,
            address: "127.0.0.1".to_string(), // Changed from "0.0.0.0"
            port: 9102,
            authentication_configs: vec![],
            malloc_stats_max_len: 2 * 1024 * 1024,
        }
    }
}
```

4. **Add Rate Limiting:**

Implement rate limiting on admin endpoints to prevent mass enumeration attacks.

5. **Audit Logging:**

Log all admin endpoint access for security monitoring.

## Proof of Concept

**Test Environment:** Aptos testnet/devnet node with default configuration

**Step 1: Start a testnet validator node with default admin service configuration**

**Step 2: Query the admin endpoint (assuming batch digest is known or enumerated):**

```bash
# Get all batch digests (enumerate)
curl http://validator-ip:9102/debug/consensus/quorumstoredb

# Get specific batch with full transaction details
curl http://validator-ip:9102/debug/consensus/quorumstoredb?digest=0x1234567890abcdef...

# Response exposes full transaction details:
# SignedTransaction { 
#   raw_txn: RawTransaction {
#     sender: 0xabcd...,
#     sequence_number: 123,
#     payload: EntryFunction {
#       module: 0x1::coin,
#       function: "transfer",
#       ty_args: [0x1::aptos_coin::AptosCoin],
#       args: [0x5678..., 1000000000]  // Reveals: transfer 1000 APT to address
#     },
#     max_gas_amount: 100000,
#     gas_unit_price: 100,  // High gas = urgent/valuable transaction
#     expiration_timestamp_secs: 1234567890,
#     chain_id: Testnet
#   },
#   authenticator: ...
# }
```

**Step 3: Analyze exposed transaction data:**
- Identify large DEX swaps by payload arguments
- Identify high-value transactions by gas price
- Identify liquidation opportunities
- Submit competing front-running transaction to mempool

**Expected Result:** Full transaction details are exposed, enabling MEV extraction strategies.

**Notes:**
- This PoC works on testnet/devnet with default configuration
- On mainnet, requires admin service to be explicitly enabled without authentication (misconfiguration)
- Batch digests can be obtained by monitoring consensus messages or enumerating via get_all_batches endpoint

### Citations

**File:** crates/aptos-admin-service/src/server/consensus/mod.rs (L40-72)
```rust
pub async fn handle_dump_quorum_store_db_request(
    req: Request<Body>,
    quorum_store_db: Arc<dyn QuorumStoreStorage>,
) -> hyper::Result<Response<Body>> {
    let query = req.uri().query().unwrap_or("");
    let query_pairs: HashMap<_, _> = url::form_urlencoded::parse(query.as_bytes()).collect();

    let digest: Option<HashValue> = match query_pairs.get("digest") {
        Some(val) => match val.parse() {
            Ok(val) => Some(val),
            Err(err) => return Ok(reply_with_status(StatusCode::BAD_REQUEST, err.to_string())),
        },
        None => None,
    };

    info!("Dumping quorum store db.");

    match spawn_blocking(move || dump_quorum_store_db(quorum_store_db.as_ref(), digest)).await {
        Ok(result) => {
            info!("Finished dumping quorum store db.");
            let headers: Vec<(_, HeaderValue)> =
                vec![(CONTENT_LENGTH, HeaderValue::from(result.len()))];
            Ok(reply_with(headers, result))
        },
        Err(e) => {
            info!("Failed to dump quorum store db: {e:?}");
            Ok(reply_with_status(
                StatusCode::INTERNAL_SERVER_ERROR,
                e.to_string(),
            ))
        },
    }
}
```

**File:** crates/aptos-admin-service/src/server/consensus/mod.rs (L158-176)
```rust
fn dump_quorum_store_db(
    quorum_store_db: &dyn QuorumStoreStorage,
    digest: Option<HashValue>,
) -> anyhow::Result<String> {
    let mut body = String::new();

    if let Some(digest) = digest {
        body.push_str(&format!("{digest:?}:\n"));
        body.push_str(&format!(
            "{:?}",
            quorum_store_db.get_batch(&digest).map_err(Error::msg)?
        ));
    } else {
        for (digest, _batch) in quorum_store_db.get_all_batches()? {
            body.push_str(&format!("{digest:?}:\n"));
        }
    }

    Ok(body)
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L228-244)
```rust
        let mut persist_requests = vec![];
        for batch in batches.into_iter() {
            // TODO: maybe don't message batch generator if the persist is unsuccessful?
            if let Err(e) = self
                .sender_to_batch_generator
                .send(BatchGeneratorCommand::RemoteBatch(batch.clone()))
                .await
            {
                warn!("Failed to send batch to batch generator: {}", e);
            }
            persist_requests.push(batch.into());
        }
        counters::RECEIVED_BATCH_COUNT.inc_by(persist_requests.len() as u64);
        if author != self.my_peer_id {
            counters::RECEIVED_REMOTE_BATCH_COUNT.inc_by(persist_requests.len() as u64);
        }
        self.persist_and_send_digests(persist_requests, approx_created_ts_usecs);
```

**File:** consensus/src/quorum_store/types.rs (L21-25)
```rust
#[derive(Clone, Eq, Deserialize, Serialize, PartialEq, Debug)]
pub struct PersistedValue<T> {
    info: T,
    maybe_payload: Option<Vec<SignedTransaction>>,
}
```

**File:** consensus/src/quorum_store/types.rs (L406-413)
```rust
impl<T: TBatchInfo> From<Batch<T>> for PersistedValue<T> {
    fn from(value: Batch<T>) -> Self {
        let Batch {
            batch_info,
            payload,
        } = value;
        PersistedValue::new(batch_info, Some(payload.into_transactions()))
    }
```

**File:** consensus/src/quorum_store/batch_store.rs (L488-528)
```rust
    fn persist_inner(
        &self,
        batch_info: BatchInfoExt,
        persist_request: PersistedValue<BatchInfoExt>,
    ) -> Option<SignedBatchInfo<BatchInfoExt>> {
        assert!(
            &batch_info == persist_request.batch_info(),
            "Provided batch info doesn't match persist request batch info"
        );
        match self.save(&persist_request) {
            Ok(needs_db) => {
                trace!("QS: sign digest {}", persist_request.digest());
                if needs_db {
                    if !batch_info.is_v2() {
                        let persist_request =
                            persist_request.try_into().expect("Must be a V1 batch");
                        #[allow(clippy::unwrap_in_result)]
                        self.db
                            .save_batch(persist_request)
                            .expect("Could not write to DB");
                    } else {
                        #[allow(clippy::unwrap_in_result)]
                        self.db
                            .save_batch_v2(persist_request)
                            .expect("Could not write to DB")
                    }
                }
                if !batch_info.is_v2() {
                    self.generate_signed_batch_info(batch_info.info().clone())
                        .ok()
                        .map(|inner| inner.into())
                } else {
                    self.generate_signed_batch_info(batch_info).ok()
                }
            },
            Err(e) => {
                debug!("QS: failed to store to cache {:?}", e);
                None
            },
        }
    }
```

**File:** consensus/src/quorum_store/batch_store.rs (L530-539)
```rust
    pub fn update_certified_timestamp(&self, certified_time: u64) {
        trace!("QS: batch reader updating time {:?}", certified_time);
        self.last_certified_time
            .fetch_max(certified_time, Ordering::SeqCst);

        let expired_keys = self.clear_expired_payload(certified_time);
        if let Err(e) = self.db.delete_batches(expired_keys) {
            debug!("Error deleting batches: {:?}", e)
        }
    }
```

**File:** types/src/transaction/mod.rs (L179-205)
```rust
pub struct RawTransaction {
    /// Sender's address.
    sender: AccountAddress,

    /// Sequence number of this transaction. This must match the sequence number
    /// stored in the sender's account at the time the transaction executes.
    sequence_number: u64,

    /// The transaction payload, e.g., a script to execute.
    payload: TransactionPayload,

    /// Maximal total gas to spend for this transaction.
    max_gas_amount: u64,

    /// Price to be paid per gas unit.
    gas_unit_price: u64,

    /// Expiration timestamp for this transaction, represented
    /// as seconds from the Unix Epoch. If the current blockchain timestamp
    /// is greater than or equal to this time, then the transaction has
    /// expired and will be discarded. This can be set to a large value far
    /// in the future to indicate that a transaction does not expire.
    expiration_timestamp_secs: u64,

    /// Chain ID of the Aptos network this transaction is intended for.
    chain_id: ChainId,
}
```

**File:** types/src/transaction/mod.rs (L1092-1103)
```rust
impl Debug for SignedTransaction {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "SignedTransaction {{ \n \
             {{ raw_txn: {:#?}, \n \
             authenticator: {:#?}, \n \
             }} \n \
             }}",
            self.raw_txn, self.authenticator
        )
    }
```

**File:** crates/aptos-admin-service/src/server/mod.rs (L154-174)
```rust
        let mut authenticated = false;
        if context.config.authentication_configs.is_empty() {
            authenticated = true;
        } else {
            for authentication_config in &context.config.authentication_configs {
                match authentication_config {
                    AuthenticationConfig::PasscodeSha256(passcode_sha256) => {
                        let query = req.uri().query().unwrap_or("");
                        let query_pairs: HashMap<_, _> =
                            url::form_urlencoded::parse(query.as_bytes()).collect();
                        let passcode: Option<String> =
                            query_pairs.get("passcode").map(|p| p.to_string());
                        if let Some(passcode) = passcode {
                            if sha256::digest(passcode) == *passcode_sha256 {
                                authenticated = true;
                            }
                        }
                    },
                }
            }
        };
```

**File:** config/src/config/admin_service_config.rs (L41-50)
```rust
impl Default for AdminServiceConfig {
    fn default() -> Self {
        Self {
            enabled: None,
            address: "0.0.0.0".to_string(),
            port: 9102,
            authentication_configs: vec![],
            malloc_stats_max_len: 2 * 1024 * 1024,
        }
    }
```

**File:** config/src/config/admin_service_config.rs (L59-82)
```rust
impl ConfigSanitizer for AdminServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();

        if node_config.admin_service.enabled == Some(true) {
            if let Some(chain_id) = chain_id {
                if chain_id.is_mainnet()
                    && node_config.admin_service.authentication_configs.is_empty()
                {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Must enable authentication for AdminService on mainnet.".into(),
                    ));
                }
            }
        }

        Ok(())
    }
}
```

**File:** config/src/config/admin_service_config.rs (L84-106)
```rust
impl ConfigOptimizer for AdminServiceConfig {
    fn optimize(
        node_config: &mut NodeConfig,
        _local_config_yaml: &Value,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<bool, Error> {
        let mut modified_config = false;

        if node_config.admin_service.enabled.is_none() {
            // Only enable the admin service if the chain is not mainnet
            let admin_service_enabled = if let Some(chain_id) = chain_id {
                !chain_id.is_mainnet()
            } else {
                false // We cannot determine the chain ID, so we disable the admin service
            };
            node_config.admin_service.enabled = Some(admin_service_enabled);

            modified_config = true; // The config was modified
        }

        Ok(modified_config)
    }
```
