# Audit Report

## Title
Version Regression Vulnerability in Table Info Indexer Service During Shutdown

## Summary
The `TableInfoService::run()` function can regress the indexer's tracked version to 1 when the service is aborted while `get_highest_known_version()` is waiting for the ledger to catch up, causing the transactions array to be empty and triggering a persistent database version regression.

## Finding Description

The vulnerability exists in the main processing loop of the table info indexer service. When the service is aborted during a critical timing window, the following sequence occurs:

1. **Abort during version waiting**: The `get_highest_known_version()` function waits in a loop until `ledger_version >= current_version`. [1](#0-0)  If the abort flag is set during this wait, the loop breaks early and returns whatever `ledger_version` value was last retrieved, which may be less than `current_version`.

2. **Empty transaction batch**: When `get_batches()` is called with a `ledger_version < current_version`, the while loop condition fails immediately [2](#0-1)  and an empty batches vector is returned.

3. **Zero last_version**: When transactions array is empty, `last_version` defaults to 0. [3](#0-2) 

4. **Version regression**: The `current_version` is set to `last_version + 1 = 0 + 1 = 1`. [4](#0-3) 

5. **Persistent database corruption**: Most critically, `process_transactions_in_parallel()` is called with empty transactions, which sets `end_version = 0` [5](#0-4)  and then persists this regression to the database via `update_next_version(0 + 1)`. [6](#0-5) 

This breaks the monotonically increasing version invariant expected by the indexer system.

## Impact Explanation

**Severity: Medium** - This qualifies as "State inconsistencies requiring intervention" per the Aptos bug bounty criteria.

**Scope Limitation**: This vulnerability affects the **indexer service only**, not the core Aptos consensus, execution, or validator operations. The indexer is an auxiliary off-chain service for data querying and does not impact:
- Blockchain consensus or safety
- Transaction execution or validation  
- Validator operations or staking
- User funds or on-chain state

**Actual Impact**:
- The indexer's database version tracking regresses to version 1
- Requires manual operator intervention to reset and re-synchronize the indexer
- Causes temporary data unavailability or incorrect table info queries
- No impact on blockchain operation itself

## Likelihood Explanation

**Likelihood: Medium to Low**

This vulnerability can occur when:
1. The service is gracefully shut down (`abort()` is called) during the specific timing window when `get_highest_known_version()` is waiting for the ledger to catch up
2. The service is restarted with a `request_start_version` higher than the current ledger version

**Limitations**:
- Requires operator-level access to call `abort()` - not exploitable by external attackers
- Primarily an operational/implementation issue rather than an attacker-exploitable vulnerability
- Occurs during service lifecycle events (startup/shutdown) rather than normal operation
- Does not affect the core blockchain or validator nodes

## Recommendation

Add a guard to prevent version regression when transactions array is empty:

```rust
// In the main loop of run() function, after line 119:
let last_version = transactions
    .last()
    .map(|txn| txn.version)
    .unwrap_or(self.current_version.load(Ordering::SeqCst).saturating_sub(1));

// Alternatively, add a check before processing:
if transactions.is_empty() {
    info!("No transactions to process, skipping iteration");
    continue;
}
```

Additionally, add validation in `process_transactions_in_parallel()`:

```rust
// At the start of process_transactions_in_parallel():
if transactions.is_empty() {
    return vec![];  // Don't update database if no transactions processed
}
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_version_regression_on_abort() {
    // Setup: Create TableInfoService with high initial version
    let service = TableInfoService::new(
        context,
        10000, // request_start_version
        4,     // parser_task_count
        100,   // parser_batch_size
        None,  // no backup
        indexer_async_v2,
    );
    
    // Simulate the abort during get_highest_known_version()
    // by spawning the run loop and aborting it when current_version > ledger_version
    let service_clone = Arc::new(service);
    let handle = tokio::spawn({
        let svc = service_clone.clone();
        async move { svc.run().await }
    });
    
    // Wait briefly then abort while get_highest_known_version is waiting
    tokio::time::sleep(Duration::from_millis(5)).await;
    service_clone.abort();
    
    // Allow the service to process the abort
    tokio::time::sleep(Duration::from_millis(50)).await;
    
    // Verify: Check if database version regressed to 1
    let next_version = service_clone.indexer_async_v2.next_version();
    assert_ne!(next_version, 1, "Version should not regress to 1");
}
```

## Notes

While this is a valid implementation bug that violates the version monotonicity invariant, its security impact is **limited to the indexer service** and does **not affect core blockchain security**. The vulnerability:

- Is **not exploitable by external attackers** (requires operator access)
- Does **not impact consensus, execution, or on-chain state**
- Represents an **operational issue** rather than a critical security vulnerability
- Can be mitigated through proper shutdown procedures and startup validation

The classification as Medium severity is appropriate given it causes state inconsistencies requiring manual intervention, but operators should note this affects auxiliary indexing infrastructure only.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs (L116-119)
```rust
            let last_version = transactions
                .last()
                .map(|txn| txn.version)
                .unwrap_or_default();
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs (L189-190)
```rust
            self.current_version
                .store(last_version + 1, Ordering::SeqCst);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs (L252-255)
```rust
        let last_version = transactions
            .last()
            .map(|txn| txn.version)
            .unwrap_or_default();
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs (L302-304)
```rust
                self.indexer_async_v2
                    .update_next_version(end_version + 1)
                    .unwrap();
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs (L373-373)
```rust
        while num_fetches < self.parser_task_count && start_version <= ledger_version {
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs (L499-501)
```rust
        while ledger_version == 0 || self.current_version.load(Ordering::SeqCst) > ledger_version {
            if self.aborted.load(Ordering::SeqCst) {
                break;
```
