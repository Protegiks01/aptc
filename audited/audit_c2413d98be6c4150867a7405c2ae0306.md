# Audit Report

## Title
Deterministic RNG Seed Reuse in DKG InputSecret Generation Enables Retroactive Secret Computation in smoke-test Mode

## Summary
When the `smoke-test` feature is enabled, the DKG manager generates InputSecrets using a deterministic RNG seeded with the validator's account address. Since validator addresses are public on-chain and the same seed is reused across all DKG sessions, an attacker can retroactively compute all past InputSecrets and predict all future ones, completely compromising the security of PVSS dealings and DKG sessions. [1](#0-0) 

## Finding Description
The `setup_deal_broadcast` function in the DKG manager creates a fresh RNG for each DKG session. When the `smoke-test` compilation feature is enabled, this RNG is seeded deterministically with the validator's account address, which is public information stored on-chain. [1](#0-0) 

The critical flaw is that:
1. Each DKG session creates a NEW RNG instance with the SAME seed (validator address)
2. The first random value generated from this RNG becomes the InputSecret
3. Therefore, all InputSecrets for the same validator across different epochs are IDENTICAL
4. An attacker who knows the validator's address (public information) can reproduce the exact InputSecret by simulating the RNG initialization

The InputSecret is the core secret in the PVSS dealing protocol, used as the constant term of the Shamir secret sharing polynomial. Compromising it allows an attacker to:
- Retroactively compute all past InputSecrets from that validator
- Predict all future InputSecrets
- Break the confidentiality of the PVSS protocol
- Compromise the security of the on-chain randomness beacon

This breaks the **Cryptographic Correctness** invariant: "BLS signatures, VRF, and hash operations must be secure." [2](#0-1) 

## Impact Explanation
**Severity: High (conditional on misconfiguration)**

If the `smoke-test` feature were enabled in a production validator (through misconfiguration, wrong Docker image, or build error), the impact would be **Critical** per bug bounty criteria:

- **Significant Protocol Violation**: Complete break of DKG cryptographic security
- **Consensus Impact**: Compromised randomness beacon affects leader election and validator selection
- **Network-wide Effect**: Any validator running with this feature enabled exposes their DKG secrets

The vulnerability enables:
1. **Retroactive secret computation**: All past InputSecrets can be recomputed from public data
2. **Future secret prediction**: All future InputSecrets are predictable
3. **Historical compromise**: Past DKG sessions are retroactively compromised
4. **Randomness manipulation**: On-chain randomness can be predicted/manipulated

However, this requires the `smoke-test` feature to be explicitly enabled at compile time, which is intended only for testing. [3](#0-2) [4](#0-3) 

## Likelihood Explanation
**Likelihood: Low (requires misconfiguration)**

The `smoke-test` feature is:
- Not enabled by default
- Clearly named as testing-only
- Not included in standard production builds
- Requires explicit opt-in via `--features smoke-test` [5](#0-4) 

However, misconfiguration scenarios exist:
1. Operator uses `validator-testing` Docker image instead of `validator` image
2. Build script error includes wrong features
3. Test binary accidentally deployed to production
4. CI/CD pipeline misconfiguration

The vulnerability is exacerbated by:
- No runtime warning when smoke-test mode is active
- No detection mechanism for this misconfiguration
- Deterministic behavior appears normal during operation

## Recommendation

**Immediate Fix**: Remove the deterministic seeding entirely from production code. The smoke-test feature should only be used in isolated test environments, never in any validator binary.

**Short-term Fix**: Add explicit runtime checks and warnings:

```rust
let mut rng = if cfg!(feature = "smoke-test") {
    // Add runtime warning
    error!(
        "[SECURITY WARNING] DKG running in INSECURE smoke-test mode with deterministic RNG! \
         DO NOT USE IN PRODUCTION. InputSecrets are PREDICTABLE from validator address."
    );
    // Optionally add environment variable check to prevent accidental usage
    if std::env::var("APTOS_ALLOW_INSECURE_DKG").is_err() {
        panic!("Refusing to run DKG in smoke-test mode without APTOS_ALLOW_INSECURE_DKG=1");
    }
    StdRng::from_seed(self.my_addr.into_bytes())
} else {
    StdRng::from_rng(thread_rng()).unwrap()
};
```

**Long-term Fix**: Refactor to separate test-only code paths:
- Move smoke-test RNG seeding to test-only modules
- Use dependency injection for RNG in tests
- Ensure production binaries cannot compile with deterministic seeding

**Build System Fix**: Add CI checks to verify production builds never enable smoke-test feature.

## Proof of Concept

```rust
// Proof of Concept: Computing a validator's InputSecret from their public address
use rand::{SeedableRng, prelude::StdRng};
use aptos_crypto::Uniform;
use move_core_types::account_address::AccountAddress;

fn main() {
    // Attacker knows the validator's address (public on-chain information)
    let validator_addr = AccountAddress::from_hex_literal("0x1234...").unwrap();
    
    // Reproduce the exact RNG initialization used in smoke-test mode
    let mut rng = StdRng::from_seed(validator_addr.into_bytes());
    
    // Generate the InputSecret - this is IDENTICAL to what the validator generated
    let compromised_secret = <aptos_types::dkg::real_dkg::RealDKG as aptos_types::dkg::DKGTrait>::InputSecret::generate(&mut rng);
    
    // Attacker now knows the secret that was supposed to be private
    println!("Compromised InputSecret: {:?}", compromised_secret.get_secret_a());
    
    // This works for:
    // 1. All past DKG sessions from this validator (retroactive compromise)
    // 2. All future DKG sessions from this validator (predictive attack)
    // 3. All epochs - the seed never changes
}
```

To verify in a test environment:
1. Build aptos-node with `--features smoke-test`
2. Deploy a validator with a known address
3. Observe DKG transcripts generated
4. Run the PoC to compute the InputSecret
5. Verify the computed secret matches the one used in transcripts

---

**Notes:**
- This vulnerability is **conditional** on the `smoke-test` feature being enabled, which should never occur in production
- The primary concern is that NO runtime safeguards prevent this misconfiguration
- The deterministic RNG seeding is a dangerous code pattern even if only used in testing
- Production validators use `thread_rng()` which is secure and does not exhibit seed reuse
- The vulnerability demonstrates the answer to the security question: YES, seed reuse enables retroactive secret computation when the smoke-test feature is active

### Citations

**File:** dkg/src/dkg_manager/mod.rs (L325-330)
```rust
        let mut rng = if cfg!(feature = "smoke-test") {
            StdRng::from_seed(self.my_addr.into_bytes())
        } else {
            StdRng::from_rng(thread_rng()).unwrap()
        };
        let input_secret = DKG::InputSecret::generate(&mut rng);
```

**File:** crates/aptos-crypto/src/input_secret.rs (L73-81)
```rust
impl Uniform for InputSecret {
    fn generate<R>(rng: &mut R) -> Self
    where
        R: RngCore + CryptoRng,
    {
        let a = random_scalar(rng);

        InputSecret { a }
    }
```

**File:** dkg/Cargo.toml (L52-53)
```text
[features]
smoke-test = []
```

**File:** aptos-node/Cargo.toml (L98-98)
```text
smoke-test = ["aptos-jwk-consensus/smoke-test", "aptos-dkg-runtime/smoke-test"]
```

**File:** docker/builder/build-node.sh (L6-7)
```shellscript
PROFILE=${PROFILE:-release}
FEATURES=${FEATURES:-""}
```
