# Audit Report

## Title
NAT64 Well-Known Prefix Bypass in Faucet IP Blocklist and Rate Limiting

## Summary
The faucet's IP-based security controls (blocklist, rate limiting, and allowlist) do not handle IPv4-IPv6 address translation, specifically the NAT64 well-known prefix (64:ff9b::/96). This allows attackers to bypass IP blocklists and evade rate limits by alternating between their IPv4 address and its NAT64-encoded IPv6 representation, treating them as distinct identities.

## Finding Description

The faucet implements multiple IP-based security controls that all suffer from the same fundamental flaw: they treat IPv4 and IPv6 addresses as completely separate address spaces without recognizing that a single physical client can be represented by both address types. [1](#0-0) 

The `IpBlocklistChecker` handles IPv4 and IPv6 addresses separately, checking each against its respective list. The underlying `IpRangeManager` maintains distinct lists: [2](#0-1) [3](#0-2) 

The NAT64 well-known prefix (64:ff9b::/96) defined in RFC 6052 allows embedding IPv4 addresses into IPv6 address space. For example, IPv4 address `192.0.2.33` maps to IPv6 address `64:ff9b::192.0.2.33` (or `64:ff9b::c000:221` in hexadecimal).

**Attack Scenario 1: Blocklist Bypass**
1. Administrator blocklists malicious IPv4 address `203.0.113.45`
2. Attacker connects using NAT64-encoded address `64:ff9b::203.0.113.45`
3. Faucet receives IPv6 address, checks only `ipv6_list`
4. Request allowed since NAT64 address not in IPv6 blocklist

**Attack Scenario 2: Rate Limit Evasion**

The same vulnerability affects rate limiting. The memory-based rate limiter uses the source IP directly as a key: [4](#0-3) [5](#0-4) 

The Redis-based rate limiter when using IP mode has the same issue: [6](#0-5) 

1. User exhausts daily limit (e.g., 10 requests) from IPv4 address `198.51.100.7`
2. User switches to NAT64-encoded `64:ff9b::198.51.100.7`
3. Treated as new IP, gets another 10 requests
4. Rate limit effectively doubled (or more with repeated switching)

**Attack Scenario 3: Allowlist Mismatch**

The IP allowlist bypasser has the inverse problem: [7](#0-6) 

Legitimate users with IPv4 addresses in the allowlist won't receive bypass privileges when connecting via NAT64, causing unexpected denials.

## Impact Explanation

This vulnerability falls under **Medium Severity** per the Aptos bug bounty criteria for "Limited funds loss or manipulation":

1. **Faucet Fund Exhaustion**: Attackers can obtain more tokens than intended by evading rate limits, potentially exhausting faucet funds faster than expected
2. **Security Control Bypass**: IP-based blocklists become ineffective, allowing previously banned users to continue abusing the service
3. **Service Availability**: Accelerated fund depletion could reduce faucet availability for legitimate users

The impact is limited because:
- The faucet is an auxiliary service, not a core blockchain component
- No impact on consensus, execution, storage, or validator operations  
- Faucet likely has additional protective measures (CAPTCHA, account-based limits)
- Typically dispenses testnet tokens or limited mainnet amounts

This does not constitute Critical or High severity as it doesn't affect validator nodes, consensus safety, or result in significant loss of mainnet funds.

## Likelihood Explanation

**High Likelihood** - This vulnerability is easily exploitable:

1. **Public Knowledge**: NAT64 well-known prefix is documented in RFC 6052 and widely known
2. **No Special Requirements**: Attacker only needs ability to control source IP addressing
3. **Multiple Vectors**: Works through actual NAT64 gateways, proxy servers, or VPN services
4. **Trivial Execution**: Simple address translation, no complex timing or race conditions
5. **Multiple Components Affected**: Works against blocklist, both rate limiters, and allowlist

The only factor reducing likelihood is that IPv6 adoption may be limited in some networks, but NAT64 is specifically designed for IPv4-IPv6 transition scenarios.

## Recommendation

Implement IPv4-IPv6 address normalization that recognizes NAT64 and IPv4-mapped IPv6 addresses. Add a helper function to extract the canonical IPv4 address when present:

```rust
// In crates/aptos-faucet/core/src/common/ip_range_manager.rs

use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};

impl IpRangeManager {
    /// Extracts IPv4 address from NAT64 (64:ff9b::/96) or IPv4-mapped (::ffff:/96) IPv6 addresses
    fn normalize_ip(ip: &IpAddr) -> IpAddr {
        match ip {
            IpAddr::V6(ipv6) => {
                // Check for NAT64 well-known prefix 64:ff9b::/96
                if let Some(ipv4) = Self::extract_nat64_ipv4(ipv6) {
                    return IpAddr::V4(ipv4);
                }
                // Check for IPv4-mapped IPv6 (::ffff:x.x.x.x)
                if let Some(ipv4) = ipv6.to_ipv4_mapped() {
                    return IpAddr::V4(ipv4);
                }
                IpAddr::V6(*ipv6)
            }
            IpAddr::V4(_) => *ip,
        }
    }

    fn extract_nat64_ipv4(ipv6: &Ipv6Addr) -> Option<Ipv4Addr> {
        let segments = ipv6.segments();
        // Check for 64:ff9b::/96 prefix
        if segments[0] == 0x0064 && segments[1] == 0xff9b 
            && segments[2] == 0 && segments[3] == 0 
            && segments[4] == 0 {
            // Extract IPv4 from last 32 bits
            let octets = [
                (segments[6] >> 8) as u8,
                (segments[6] & 0xff) as u8,
                (segments[7] >> 8) as u8,
                (segments[7] & 0xff) as u8,
            ];
            return Some(Ipv4Addr::from(octets));
        }
        None
    }

    pub fn contains_ip(&self, ip: &IpAddr) -> bool {
        let normalized = Self::normalize_ip(ip);
        match normalized {
            IpAddr::V4(ipv4) => self.ipv4_list.contains(&ipv4),
            IpAddr::V6(ipv6) => self.ipv6_list.contains(&ipv6),
        }
    }
}
```

Update all IP-based security components to use the normalized address:
- `IpBlocklistChecker`: Normalize before checking lists
- `MemoryRatelimitChecker`: Use normalized IP as cache key  
- `RedisRatelimitChecker`: Use normalized IP for Redis keys
- `IpAllowlistBypasser`: Normalize before checking allowlist

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};

    #[test]
    fn test_nat64_blocklist_bypass() {
        // Create a blocklist with IPv4 address
        let mut config_content = "192.0.2.33/32\n".to_string();
        let temp_file = std::env::temp_dir().join("blocklist_test.txt");
        std::fs::write(&temp_file, config_content).unwrap();
        
        let manager = IpRangeManager::new(IpRangeManagerConfig {
            file: temp_file.clone(),
        }).unwrap();

        // IPv4 address should be blocked
        let ipv4 = IpAddr::V4(Ipv4Addr::new(192, 0, 2, 33));
        assert!(manager.contains_ip(&ipv4), "IPv4 should be in blocklist");

        // NAT64-encoded version should also be blocked but currently isn't
        let nat64_segments = [0x0064, 0xff9b, 0, 0, 0, 0, 0xc000, 0x0221];
        let nat64_ipv6 = IpAddr::V6(Ipv6Addr::from(nat64_segments));
        
        // This assertion will FAIL, demonstrating the vulnerability
        assert!(
            manager.contains_ip(&nat64_ipv6),
            "NAT64-encoded IPv6 should be blocked but isn't - VULNERABILITY"
        );
        
        std::fs::remove_file(temp_file).unwrap();
    }

    #[test]
    fn test_rate_limit_evasion() {
        use std::collections::HashMap;
        
        // Simulate rate limiter tracking
        let mut ip_counts: HashMap<String, u32> = HashMap::new();
        
        let ipv4 = IpAddr::V4(Ipv4Addr::new(198, 51, 100, 7));
        let nat64_segments = [0x0064, 0xff9b, 0, 0, 0, 0, 0xc633, 0x6407];
        let nat64_ipv6 = IpAddr::V6(Ipv6Addr::from(nat64_segments));
        
        // User makes 10 requests from IPv4 (reaches limit)
        let ipv4_key = ipv4.to_string();
        ip_counts.insert(ipv4_key.clone(), 10);
        
        // User switches to NAT64-encoded IPv6
        let ipv6_key = nat64_ipv6.to_string();
        
        // These are treated as different IPs - VULNERABILITY
        assert_ne!(ipv4_key, ipv6_key, "Different keys allow rate limit bypass");
        assert!(!ip_counts.contains_key(&ipv6_key), "NAT64 IP has no history");
    }
}
```

## Notes

This vulnerability affects only the faucet service, which is an auxiliary component separate from core blockchain operations. While it represents a real security flaw allowing abuse of IP-based controls, it does not impact consensus, execution, state management, or validator operations. The severity is appropriately categorized as Medium due to the limited scope of potential funds loss and the availability of additional protective measures (CAPTCHA, account-based limits) that may partially mitigate the issue.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/ip_blocklist.rs (L27-51)
```rust
    async fn check(
        &self,
        data: CheckerData,
        _dry_run: bool,
    ) -> Result<Vec<RejectionReason>, AptosTapError> {
        match &data.source_ip {
            IpAddr::V4(source_ip) => {
                if self.manager.ipv4_list.contains(source_ip) {
                    return Ok(vec![RejectionReason::new(
                        format!("IP {} is in blocklist", source_ip),
                        RejectionReasonCode::IpInBlocklist,
                    )]);
                }
            },
            IpAddr::V6(source_ip) => {
                if self.manager.ipv6_list.contains(source_ip) {
                    return Ok(vec![RejectionReason::new(
                        format!("IP {} is in blocklist", source_ip),
                        RejectionReasonCode::IpInBlocklist,
                    )]);
                }
            },
        }
        Ok(vec![])
    }
```

**File:** crates/aptos-faucet/core/src/common/ip_range_manager.rs (L18-21)
```rust
pub struct IpRangeManager {
    pub ipv4_list: IpRange<Ipv4Net>,
    pub ipv6_list: IpRange<Ipv6Net>,
}
```

**File:** crates/aptos-faucet/core/src/common/ip_range_manager.rs (L55-60)
```rust
    pub fn contains_ip(&self, ip: &IpAddr) -> bool {
        match ip {
            IpAddr::V4(ipv4) => self.ipv4_list.contains(ipv4),
            IpAddr::V6(ipv6) => self.ipv6_list.contains(ipv6),
        }
    }
```

**File:** crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs (L37-37)
```rust
    pub ip_to_requests_today: Mutex<LruCache<IpAddr, u32>>,
```

**File:** crates/aptos-faucet/core/src/checkers/memory_ratelimit.rs (L77-77)
```rust
        let requests_today = ip_to_requests_today.get_or_insert_mut(data.source_ip, || 1);
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L44-51)
```rust
    pub async fn ratelimit_key_value(&self, data: &CheckerData) -> Result<String, AptosTapError> {
        match self {
            RatelimitKeyProvider::Ip => Ok(data.source_ip.to_string()),
            RatelimitKeyProvider::Jwt(jwt_verifier) => {
                jwt_verifier.validate_jwt(data.headers.clone()).await
            },
        }
    }
```

**File:** crates/aptos-faucet/core/src/bypasser/ip_allowlist.rs (L26-28)
```rust
    async fn request_can_bypass(&self, data: CheckerData) -> Result<bool> {
        Ok(self.manager.contains_ip(&data.source_ip))
    }
```
