# Audit Report

## Title
Indexer Creates Inconsistent Fungible Token Data When FungibleAssetSupply Not Present in Transaction Batch

## Summary
The `TokenDataV2::get_v2_from_write_resource` function in the indexer incorrectly marks fungible tokens as non-fungible when processing transactions that write `ObjectCore` and `TokenV2` resources without the corresponding `FungibleAssetMetadata` and `FungibleAssetSupply` resources. This creates permanent inconsistencies in the indexer database that misrepresent the actual on-chain token state.

## Finding Description

The vulnerability exists in the token metadata aggregation logic. The `parse_v2_token()` function builds a metadata helper that accumulates resource data only from write resources present in the current batch of transactions being processed. [1](#0-0) 

For each transaction, the function performs three passes through write set changes:
1. First pass: Collects `ObjectCore` resources [2](#0-1) 

2. Second pass: Collects other resources like `FungibleAssetMetadata` and `FungibleAssetSupply` [3](#0-2) 

3. Third pass: Creates token data entries using the accumulated metadata [4](#0-3) 

The critical flaw is in `TokenDataV2::get_v2_from_write_resource`, which uses nested conditionals to determine if a token is fungible: [5](#0-4) 

The code only sets `is_fungible_v2 = Some(true)` when BOTH `fungible_asset_metadata` AND `fungible_asset_supply` exist in the metadata helper. If `FungibleAssetMetadata` exists but `FungibleAssetSupply` is missing, the token defaults to non-fungible with incorrect values: `is_fungible_v2 = Some(false)`, `decimals = 0`, `supply = BigDecimal::zero()`, `maximum = None`.

**Attack Scenario:**

1. **Batch 1** (Block 100): User creates a fungible token at address `0x123`
   - Writes: `ObjectCore`, `TokenV2`, `FungibleAssetMetadata`, `FungibleAssetSupply`
   - Indexer correctly marks it: `is_fungible_v2 = true`, `decimals = 8`, `supply = 1000000`

2. **Batch 2** (Block 200): Object transferred or token metadata updated
   - Writes: `ObjectCore` (owner changed) and `TokenV2` (description updated)  
   - Does NOT write: `FungibleAssetMetadata` or `FungibleAssetSupply` (unchanged)
   - Metadata helper has entry for `0x123` but with `fungible_asset_metadata = None`, `fungible_asset_supply = None`
   - Indexer incorrectly marks it: `is_fungible_v2 = false`, `decimals = 0`, `supply = 0`

3. Database update corrupts current state: [6](#0-5) 

The `on_conflict` clause updates ALL fields including `is_fungible_v2` and `decimals`, permanently corrupting the indexer's view of the token.

This occurs because unchanged Move resources are not re-written to the blockchain in subsequent transactions. When a fungible token's object is transferred or its token metadata is updated, only those specific resources are written - the `FungibleAssetMetadata` and `FungibleAssetSupply` resources remain unchanged and are not included in the transaction's write set. [7](#0-6) 

## Impact Explanation

This is a **High severity** indexer data corruption issue that affects applications relying on the Aptos indexer for token information. While it does not affect on-chain state or consensus, it creates significant downstream impacts:

1. **Data Integrity Violation**: The indexer permanently misrepresents fungible tokens as non-fungible, violating the core invariant that indexed data must accurately reflect blockchain state

2. **Application Failures**: DApps, wallets, and exchanges querying the indexer will receive incorrect token type information, potentially causing:
   - Incorrect balance displays (showing 0 instead of actual balance)
   - Failed token operations (treating fungible tokens as NFTs)
   - Wrong decimal calculations for price and quantity displays

3. **Systematic Impact**: This affects ALL fungible tokens that undergo transfers or metadata updates, making it a systematic rather than isolated issue

Under the Aptos bug bounty criteria, this qualifies as **High Severity** due to:
- Significant protocol violations (indexer is expected to provide accurate blockchain data)
- Potential for limited funds loss or manipulation (applications making decisions based on wrong data)
- State inconsistencies requiring manual intervention to correct the indexer database

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability triggers automatically during normal token operations:

1. **Token Transfers**: Any fungible token transfer writes `ObjectCore` (owner change) but not `FungibleAssetMetadata`/`FungibleAssetSupply`
2. **Token Metadata Updates**: Updating token name or description writes `TokenV2` and `ObjectCore` but not fungible asset resources
3. **Frequency**: Every transferred or updated fungible token in production will eventually trigger this bug

No malicious intent is required - this is a systematic flaw in the indexer's resource aggregation logic that affects all fungible token operations.

## Recommendation

The fix requires checking if a token was previously marked as fungible and preserving that state. The metadata helper should indicate when fungible asset information is unavailable rather than defaulting to non-fungible:

**Recommended Fix:**

```rust
// In TokenDataV2::get_v2_from_write_resource

// Check if this is a fungible token by presence of FungibleAssetMetadata
let is_fungible_asset = if let Some(metadata) = token_v2_metadata.get(&token_data_id) {
    metadata.fungible_asset_metadata.is_some()
} else {
    false
};

// Only populate fungible data if BOTH metadata and supply are present
// Otherwise, skip creating a new entry to avoid overwriting correct existing data
if is_fungible_asset {
    let metadata = token_v2_metadata.get(&token_data_id).unwrap();
    let fa_metadata = metadata.fungible_asset_metadata.as_ref();
    let fa_supply = metadata.fungible_asset_supply.as_ref();
    
    // Both must be present to update fungible asset fields
    if fa_metadata.is_none() || fa_supply.is_none() {
        // Fungible token but incomplete data in this transaction
        // Return None to avoid creating incorrect historical record
        return Ok(None);
    }
}
```

Alternatively, query the existing database state to preserve previously set `is_fungible_v2` and `decimals` values when fungible asset resources are not present in the current transaction.

## Proof of Concept

**Setup:**
1. Create fungible token with all resources at block 100
2. Transfer the token at block 200 (writes only ObjectCore, not fungible asset resources)
3. Query indexer - token incorrectly shows as non-fungible

**Indexer Processing Trace:**

Block 100 - Token Creation:
- Write Resources: `0x1::object::ObjectCore`, `0x4::token::Token`, `0x1::fungible_asset::Metadata`, `0x1::fungible_asset::Supply`
- Metadata Helper: All resources present
- Database: `is_fungible_v2 = true`, `decimals = 8`, `supply = 1000000` ✓

Block 200 - Token Transfer:
- Write Resources: `0x1::object::ObjectCore` (owner: 0xOLD → 0xNEW)
- Metadata Helper: Only object core present, `fungible_asset_metadata = None`, `fungible_asset_supply = None`
- Line 93-94 check fails: `fungible_asset_metadata.is_some()` = false OR `fungible_asset_supply.is_some()` = false
- Database: `is_fungible_v2 = false`, `decimals = 0`, `supply = 0` ✗ WRONG

**Verification:**
Query `current_token_datas_v2` table after block 200 shows incorrect values, while on-chain state remains correct. This demonstrates the indexer-blockchain state divergence.

## Notes

**Important Clarifications:**

1. **Scope**: This is an indexer-only vulnerability. The blockchain state, consensus, and Move VM execution remain correct and unaffected. Only the indexer's PostgreSQL database contains incorrect data.

2. **On-Chain vs Off-Chain**: The vulnerability does NOT affect:
   - Blockchain state (Merkle trees remain correct)
   - Consensus (validators unaffected)
   - Smart contract execution (Move code uses on-chain state, not indexer)
   - Transaction validation or gas metering

3. **Impact Boundary**: The impact is limited to applications and services that query the indexer API for token information. Direct on-chain queries would return correct data.

4. **Aptos Fungible Asset Framework**: The Move framework creates both `Metadata` and `Supply` resources together during token creation, but subsequent operations (transfers, metadata updates) only write changed resources, triggering this bug. [8](#0-7)

### Citations

**File:** crates/indexer/src/processors/token_processor.rs (L738-756)
```rust
                .on_conflict(token_data_id)
                .do_update()
                .set((
                    collection_id.eq(excluded(collection_id)),
                    token_name.eq(excluded(token_name)),
                    maximum.eq(excluded(maximum)),
                    supply.eq(excluded(supply)),
                    largest_property_version_v1.eq(excluded(largest_property_version_v1)),
                    token_uri.eq(excluded(token_uri)),
                    description.eq(excluded(description)),
                    token_properties.eq(excluded(token_properties)),
                    token_standard.eq(excluded(token_standard)),
                    is_fungible_v2.eq(excluded(is_fungible_v2)),
                    last_transaction_version.eq(excluded(last_transaction_version)),
                    last_transaction_timestamp.eq(excluded(last_transaction_timestamp)),
                    inserted_at.eq(excluded(inserted_at)),
                    decimals.eq(excluded(decimals)),
                )),
            Some(" WHERE current_token_datas_v2.last_transaction_version <= excluded.last_transaction_version "),
```

**File:** crates/indexer/src/processors/token_processor.rs (L1072-1072)
```rust
    let mut token_v2_metadata_helper: TokenV2AggregatedDataMapping = HashMap::new();
```

**File:** crates/indexer/src/processors/token_processor.rs (L1093-1114)
```rust
            for wsc in user_txn.info.changes.iter() {
                if let WriteSetChange::WriteResource(wr) = wsc {
                    if let Some(object) =
                        ObjectWithMetadata::from_write_resource(wr, txn_version).unwrap()
                    {
                        token_v2_metadata_helper.insert(
                            standardize_address(&wr.address.to_string()),
                            TokenV2AggregatedData {
                                aptos_collection: None,
                                fixed_supply: None,
                                object,
                                unlimited_supply: None,
                                property_map: None,
                                transfer_event: None,
                                token: None,
                                fungible_asset_metadata: None,
                                fungible_asset_supply: None,
                                fungible_asset_store: None,
                            },
                        );
                    }
                }
```

**File:** crates/indexer/src/processors/token_processor.rs (L1118-1162)
```rust
            for wsc in user_txn.info.changes.iter() {
                if let WriteSetChange::WriteResource(wr) = wsc {
                    let address = standardize_address(&wr.address.to_string());
                    if let Some(aggregated_data) = token_v2_metadata_helper.get_mut(&address) {
                        if let Some(fixed_supply) =
                            FixedSupply::from_write_resource(wr, txn_version).unwrap()
                        {
                            aggregated_data.fixed_supply = Some(fixed_supply);
                        }
                        if let Some(unlimited_supply) =
                            UnlimitedSupply::from_write_resource(wr, txn_version).unwrap()
                        {
                            aggregated_data.unlimited_supply = Some(unlimited_supply);
                        }
                        if let Some(aptos_collection) =
                            AptosCollection::from_write_resource(wr, txn_version).unwrap()
                        {
                            aggregated_data.aptos_collection = Some(aptos_collection);
                        }
                        if let Some(property_map) =
                            PropertyMap::from_write_resource(wr, txn_version).unwrap()
                        {
                            aggregated_data.property_map = Some(property_map);
                        }
                        if let Some(token) = TokenV2::from_write_resource(wr, txn_version).unwrap()
                        {
                            aggregated_data.token = Some(token);
                        }
                        if let Some(fungible_asset_metadata) =
                            FungibleAssetMetadata::from_write_resource(wr, txn_version).unwrap()
                        {
                            aggregated_data.fungible_asset_metadata = Some(fungible_asset_metadata);
                        }
                        if let Some(fungible_asset_supply) =
                            FungibleAssetSupply::from_write_resource(wr, txn_version).unwrap()
                        {
                            aggregated_data.fungible_asset_supply = Some(fungible_asset_supply);
                        }
                        if let Some(fungible_asset_store) =
                            FungibleAssetStore::from_write_resource(wr, txn_version).unwrap()
                        {
                            aggregated_data.fungible_asset_store = Some(fungible_asset_store);
                        }
                    }
                }
```

**File:** crates/indexer/src/processors/token_processor.rs (L1345-1353)
```rust
                        if let Some((token_data, current_token_data)) =
                            TokenDataV2::get_v2_from_write_resource(
                                resource,
                                txn_version,
                                wsc_index,
                                txn_timestamp,
                                &token_v2_metadata_helper,
                            )
                            .unwrap()
```

**File:** crates/indexer/src/models/token_models/v2_token_datas.rs (L76-153)
```rust
    pub fn get_v2_from_write_resource(
        write_resource: &APIWriteResource,
        txn_version: i64,
        write_set_change_index: i64,
        txn_timestamp: chrono::NaiveDateTime,
        token_v2_metadata: &TokenV2AggregatedDataMapping,
    ) -> anyhow::Result<Option<(Self, CurrentTokenDataV2)>> {
        if let Some(inner) = &TokenV2::from_write_resource(write_resource, txn_version)? {
            let token_data_id = standardize_address(&write_resource.address.to_string());
            // Get maximum, supply, and is fungible from fungible asset if this is a fungible token
            let (mut maximum, mut supply, mut decimals, mut is_fungible_v2) =
                (None, BigDecimal::zero(), 0, Some(false));
            // Get token properties from 0x4::property_map::PropertyMap
            let mut token_properties = serde_json::Value::Null;
            if let Some(metadata) = token_v2_metadata.get(&token_data_id) {
                let fungible_asset_metadata = metadata.fungible_asset_metadata.as_ref();
                let fungible_asset_supply = metadata.fungible_asset_supply.as_ref();
                if let Some(metadata) = fungible_asset_metadata {
                    if let Some(fa_supply) = fungible_asset_supply {
                        maximum = fa_supply.get_maximum();
                        supply = fa_supply.current.clone();
                        decimals = metadata.decimals as i64;
                        is_fungible_v2 = Some(true);
                    }
                }
                token_properties = metadata
                    .property_map
                    .as_ref()
                    .map(|m| m.inner.clone())
                    .unwrap_or(token_properties);
            } else {
                // ObjectCore should not be missing, returning from entire function early
                return Ok(None);
            }

            let collection_id = inner.get_collection_address();
            let token_name = inner.get_name_trunc();
            let token_uri = inner.get_uri_trunc();

            Ok(Some((
                Self {
                    transaction_version: txn_version,
                    write_set_change_index,
                    token_data_id: token_data_id.clone(),
                    collection_id: collection_id.clone(),
                    token_name: token_name.clone(),
                    maximum: maximum.clone(),
                    supply: supply.clone(),
                    largest_property_version_v1: None,
                    token_uri: token_uri.clone(),
                    token_properties: token_properties.clone(),
                    description: inner.description.clone(),
                    token_standard: TokenStandard::V2.to_string(),
                    is_fungible_v2,
                    transaction_timestamp: txn_timestamp,
                    decimals,
                },
                CurrentTokenDataV2 {
                    token_data_id,
                    collection_id,
                    token_name,
                    maximum,
                    supply,
                    largest_property_version_v1: None,
                    token_uri,
                    token_properties,
                    description: inner.description.clone(),
                    token_standard: TokenStandard::V2.to_string(),
                    is_fungible_v2,
                    last_transaction_version: txn_version,
                    last_transaction_timestamp: txn_timestamp,
                    decimals,
                },
            )))
        } else {
            Ok(None)
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/fungible_asset.move (L280-349)
```text
    public fun add_fungibility(
        constructor_ref: &ConstructorRef,
        maximum_supply: Option<u128>,
        name: String,
        symbol: String,
        decimals: u8,
        icon_uri: String,
        project_uri: String
    ): Object<Metadata> {
        assert!(
            !constructor_ref.can_generate_delete_ref(),
            error::invalid_argument(EOBJECT_IS_DELETABLE)
        );
        let metadata_object_signer = &constructor_ref.generate_signer();
        assert!(
            name.length() <= MAX_NAME_LENGTH,
            error::out_of_range(ENAME_TOO_LONG)
        );
        assert!(
            symbol.length() <= MAX_SYMBOL_LENGTH,
            error::out_of_range(ESYMBOL_TOO_LONG)
        );
        assert!(decimals <= MAX_DECIMALS, error::out_of_range(EDECIMALS_TOO_LARGE));
        assert!(
            icon_uri.length() <= MAX_URI_LENGTH,
            error::out_of_range(EURI_TOO_LONG)
        );
        assert!(
            project_uri.length() <= MAX_URI_LENGTH,
            error::out_of_range(EURI_TOO_LONG)
        );
        move_to(
            metadata_object_signer,
            Metadata { name, symbol, decimals, icon_uri, project_uri }
        );

        event::emit(
            Creation {
                metadata: signer::address_of(metadata_object_signer),
                name,
                symbol,
                decimals,
                icon_uri,
                project_uri,
                maximum_supply
            }
        );

        if (default_to_concurrent_fungible_supply()) {
            let unlimited = maximum_supply.is_none();
            move_to(
                metadata_object_signer,
                ConcurrentSupply {
                    current: if (unlimited) {
                        aggregator_v2::create_unbounded_aggregator()
                    } else {
                        aggregator_v2::create_aggregator(
                            maximum_supply.extract()
                        )
                    }
                }
            );
        } else {
            move_to(
                metadata_object_signer,
                Supply { current: 0, maximum: maximum_supply }
            );
        };

        constructor_ref.object_from_constructor_ref<Metadata>()
```
