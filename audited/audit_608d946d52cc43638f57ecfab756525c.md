# Audit Report

## Title
Sharded Block Executor: Unauthenticated Cross-Shard Messages Enable Cache Poisoning and Validator Execution Corruption

## Summary
The sharded block executor's `RemoteTxnWrite` message handling lacks authentication and validation, allowing a compromised shard or network attacker to send arbitrary state values to other shards. The receiving shard blindly accepts these values without verifying message authenticity or correctness, enabling cache poisoning attacks that corrupt validator execution and violate deterministic execution guarantees.

## Finding Description

The sharded block executor enables parallel transaction execution across multiple shards that communicate cross-shard dependencies via `RemoteTxnWrite` messages. When a shard completes a transaction that writes to state keys needed by other shards, it sends these writes via the `CrossShardClient` interface.

**Critical Flaw: No Message Validation**

The `RemoteTxnWrite` constructor accepts arbitrary state keys and write operations without validation: [1](#0-0) 

When these messages are received, the `CrossShardCommitReceiver` directly applies them to the `CrossShardStateView` without any authentication or validation: [2](#0-1) 

The `CrossShardStateView::set_value()` method stores the received value without verifying its correctness: [3](#0-2) 

**Attack Vector 1: Cache Poisoning**

A malicious shard can send `RemoteTxnWrite` messages with legitimate state keys (those expected by the receiving shard) but with INCORRECT write values. The receiving shard will accept these poisoned values and use them during transaction execution: [4](#0-3) 

The poisoned `CrossShardStateView` is then used as the state view for block execution, causing transactions to read incorrect state values. This violates the deterministic execution invariant - the compromised validator will compute different transaction outputs than honest validators.

**Attack Vector 2: Denial of Service**

A malicious shard can send `RemoteTxnWrite` with state keys NOT in the receiving shard's expected dependencies. This triggers a panic at the `.unwrap()` call, crashing the receiving shard: [5](#0-4) 

**No Authentication in Transport Layer**

In remote execution mode, shards communicate via `NetworkController` over gRPC without any visible authentication mechanism: [6](#0-5) 

Messages are simply BCS-serialized and sent over the network. Any process capable of reaching the shard endpoints can send malicious messages.

**Contrast with Legitimate Sending Path**

The legitimate sending path in `CrossShardCommitSender::send_remote_update_for_success()` only sends state keys that are in the transaction's dependency graph: [7](#0-6) 

However, the receiving side performs NO validation that incoming messages actually come from legitimate sources or contain correct values.

## Impact Explanation

**Critical Severity** - This vulnerability meets multiple Critical severity criteria from the Aptos bug bounty:

1. **Consensus Safety Violation**: A compromised shard can cause its validator to compute incorrect state roots, violating the fundamental invariant that "all validators must produce identical state roots for identical blocks." While this doesn't directly cause a chain split (as other validators remain unaffected), it corrupts validator execution and could lead to validator exclusion or network instability.

2. **Loss of Validator Liveness**: The DoS attack vector allows crashing all shards of a target validator by sending unexpected state keys, causing complete loss of that validator's ability to participate in consensus.

3. **State Consistency Violation**: Cache poisoning causes transactions to execute with incorrect dependency values, breaking the atomic state transition guarantee.

The vulnerability is particularly severe because:
- It operates at the execution layer, before consensus voting
- A single compromised shard process can corrupt the entire validator
- There's no cryptographic protection or audit trail
- The attack is silent - poisoned values are indistinguishable from legitimate ones

## Likelihood Explanation

**High Likelihood** in production deployments using remote sharded execution:

1. **Attack Surface**: Sharded execution is designed for performance-critical validators. If remote mode is enabled (when `get_remote_addresses()` returns shard addresses), shards communicate over network: [8](#0-7) 

2. **Threat Scenarios**:
   - **Compromised Shard Process**: RCE vulnerability in a shard process, supply chain attack, or malware
   - **Network-Level Attack**: MITM on inter-shard communication if not properly isolated
   - **Misconfiguration**: Shard endpoints exposed to unauthorized network segments

3. **No Authentication**: The `NetworkController` implementation shows no authentication or authorization checks, only basic message serialization.

4. **Realistic Attacker Model**: A compromised shard is more realistic than full validator compromise, as shards may run with elevated privileges, have larger attack surfaces (network-facing), or be deployed on less hardened infrastructure.

## Recommendation

**Implement Cryptographic Message Authentication:**

1. **Add Message Authentication Codes**: Each `RemoteTxnWrite` should include a signature from the sending shard, verified by the receiving shard using a shared secret or public key infrastructure.

2. **Validate State Key Authorization**: The receiving shard should verify that:
   - The state key is in its expected dependencies (already enforced by panic, but should be explicit error)
   - The sending shard is authorized to provide this value (based on transaction partitioning)

3. **Add Message Sequence Numbers**: Include monotonic sequence numbers to prevent replay attacks and detect missing messages.

**Example Fix for CrossShardCommitReceiver:**

```rust
impl CrossShardCommitReceiver {
    pub fn start<S: StateView + Sync + Send>(
        cross_shard_state_view: Arc<CrossShardStateView<S>>,
        cross_shard_client: Arc<dyn CrossShardClient>,
        round: RoundId,
        expected_dependencies: &HashSet<StateKey>, // NEW: explicit validation
        authenticator: &MessageAuthenticator,      // NEW: cryptographic verification
    ) {
        loop {
            let msg = cross_shard_client.receive_cross_shard_msg(round);
            match msg {
                RemoteTxnWriteMsg(txn_commit_msg) => {
                    // NEW: Verify message authenticity
                    if !authenticator.verify(&txn_commit_msg) {
                        error!("Unauthenticated cross-shard message rejected");
                        continue;
                    }
                    
                    let (state_key, write_op) = txn_commit_msg.take();
                    
                    // NEW: Explicit validation instead of panic
                    if !expected_dependencies.contains(&state_key) {
                        error!("Unexpected state key in cross-shard message: {:?}", state_key);
                        continue;
                    }
                    
                    cross_shard_state_view
                        .set_value(&state_key, write_op.and_then(|w| w.as_state_value()));
                },
                CrossShardMsg::StopMsg => {
                    break;
                },
            }
        }
    }
}
```

4. **Network-Level Isolation**: Ensure shard-to-shard communication occurs over authenticated TLS channels with mutual authentication.

## Proof of Concept

```rust
// PoC demonstrating cache poisoning attack
// This test would be added to aptos-move/aptos-vm/tests/sharded_block_executor_tests.rs

#[test]
fn test_cross_shard_cache_poisoning_attack() {
    use aptos_vm::sharded_block_executor::{
        messages::{CrossShardMsg, RemoteTxnWrite},
        cross_shard_state_view::CrossShardStateView,
    };
    use aptos_types::{
        state_store::state_key::StateKey,
        write_set::WriteOp,
    };
    use std::collections::HashSet;
    
    // Setup: Create a cross-shard state view expecting a specific state key
    let legitimate_key = StateKey::raw(b"account_balance");
    let mut expected_keys = HashSet::new();
    expected_keys.insert(legitimate_key.clone());
    
    let state_view = CrossShardStateView::new(expected_keys, &MockStateView);
    
    // ATTACK: Malicious shard sends WRONG value for legitimate key
    // Legitimate value: 1000 tokens
    // Malicious value: 1000000 tokens (inflated balance)
    let legitimate_value = StateValue::from(vec![0, 0, 0, 0, 0, 0, 3, 232]); // 1000
    let malicious_value = StateValue::from(vec![0, 0, 0, 0, 0, 15, 66, 64]); // 1000000
    
    let malicious_msg = RemoteTxnWrite::new(
        legitimate_key.clone(),
        Some(WriteOp::legacy_modification(malicious_value.clone())),
    );
    
    // The receiving shard accepts the poisoned value without validation
    let (key, write_op) = malicious_msg.take();
    state_view.set_value(&key, write_op.and_then(|w| w.as_state_value()));
    
    // Verify: Transaction execution now uses the POISONED value
    let retrieved = state_view.get_state_value(&legitimate_key).unwrap();
    assert_eq!(retrieved, Some(malicious_value)); // Poison successful!
    
    // Impact: Transactions depending on this value will execute incorrectly
    // e.g., transfer checks would pass with inflated balance
    // This breaks deterministic execution across validators
}

#[test]
fn test_cross_shard_dos_via_unexpected_key() {
    // ATTACK: Send RemoteTxnWrite with unexpected state key
    let expected_key = StateKey::raw(b"expected");
    let unexpected_key = StateKey::raw(b"malicious_unexpected");
    
    let mut expected_keys = HashSet::new();
    expected_keys.insert(expected_key);
    
    let state_view = CrossShardStateView::new(expected_keys, &MockStateView);
    
    let malicious_msg = RemoteTxnWrite::new(
        unexpected_key.clone(),
        Some(WriteOp::legacy_modification(StateValue::from(vec![1, 2, 3]))),
    );
    
    let (key, write_op) = malicious_msg.take();
    
    // This will PANIC and crash the receiving shard
    // Calling .unwrap() on None because unexpected_key is not in cross_shard_data
    let result = std::panic::catch_unwind(|| {
        state_view.set_value(&key, write_op.and_then(|w| w.as_state_value()));
    });
    
    assert!(result.is_err()); // Shard crashed - DoS successful
}
```

---

**Notes:**

This vulnerability exists in the core sharded execution mechanism and affects any validator using remote sharded execution mode. The lack of message authentication between shards is a critical design flaw that violates the principle of "never trust, always verify" in distributed systems. Even though shards are expected to be controlled by the same operator, defense-in-depth requires cryptographic protection against compromised components.

### Citations

**File:** aptos-move/aptos-vm/src/sharded_block_executor/messages.rs (L20-26)
```rust
impl RemoteTxnWrite {
    pub fn new(state_key: StateKey, write_op: Option<WriteOp>) -> Self {
        Self {
            state_key,
            write_op,
        }
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L34-38)
```rust
                RemoteTxnWriteMsg(txn_commit_msg) => {
                    let (state_key, write_op) = txn_commit_msg.take();
                    cross_shard_state_view
                        .set_value(&state_key, write_op.and_then(|w| w.as_state_value()));
                },
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L114-122)
```rust
        for (state_key, write_op) in write_set.expect_write_op_iter() {
            if let Some(dependent_shard_ids) = edges.get(state_key) {
                for (dependent_shard_id, round_id) in dependent_shard_ids.iter() {
                    trace!("Sending remote update for success for shard id {:?} and txn_idx: {:?}, state_key: {:?}, dependent shard id: {:?}", self.shard_id, txn_idx, state_key, dependent_shard_id);
                    let message = RemoteTxnWriteMsg(RemoteTxnWrite::new(
                        state_key.clone(),
                        Some(write_op.clone()),
                    ));
                    if *round_id == GLOBAL_ROUND_ID {
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_state_view.rs (L49-56)
```rust
    pub fn set_value(&self, state_key: &StateKey, state_value: Option<StateValue>) {
        self.cross_shard_data
            .get(state_key)
            .unwrap()
            .set_value(state_value);
        // uncomment the following line to debug waiting count
        // trace!("waiting count for shard id {} is {}", self.shard_id, self.waiting_count());
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_executor_service.rs (L115-126)
```rust
        let cross_shard_state_view = Arc::new(CrossShardStateView::create_cross_shard_state_view(
            state_view,
            &transactions,
        ));

        let cross_shard_state_view_clone = cross_shard_state_view.clone();
        let cross_shard_client_clone = cross_shard_client.clone();

        let aggr_overridden_state_view = Arc::new(AggregatorOverriddenStateView::new(
            cross_shard_state_view.as_ref(),
            TOTAL_SUPPLY_AGGR_BASE_VAL,
        ));
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L55-59)
```rust
    fn send_cross_shard_msg(&self, shard_id: ShardId, round: RoundId, msg: CrossShardMsg) {
        let input_message = bcs::to_bytes(&msg).unwrap();
        let tx = self.message_txs[shard_id][round].lock().unwrap();
        tx.send(Message::new(input_message)).unwrap();
    }
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L261-268)
```rust
        if !get_remote_addresses().is_empty() {
            Ok(V::execute_block_sharded(
                &REMOTE_SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        } else {
```
