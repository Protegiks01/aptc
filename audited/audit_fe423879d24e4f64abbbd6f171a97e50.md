# Audit Report

## Title
Byzantine Transaction Filter Evasion via Encrypted Inline Transactions

## Summary
Byzantine proposers can bypass the `block_transaction_filter` by including inline transactions with `EncryptedPayload` that remain in the `Encrypted` state during filter checks. The filter's inability to inspect encrypted transaction content allows denied transactions to pass validation and execute after decryption.

## Finding Description

The transaction filtering mechanism in Aptos consensus is designed to reject blocks containing specific inline transactions based on configurable rules (e.g., denying transactions from specific senders, calling specific entry functions, etc.). However, the filter implementation contains a critical flaw when handling `EncryptedPayload` transactions. [1](#0-0) 

When the filter attempts to match an encrypted transaction against deny rules for entry functions, it calls `payload.executable_ref()` to access the encrypted content. However, this method only succeeds if the payload is in the `Decrypted` state: [2](#0-1) 

For transactions in the `Encrypted` state (not yet decrypted), `executable_ref()` returns an error, causing the filter to return `false` (no match). This means deny rules targeting specific entry functions will **not match** encrypted transactions, even if the encrypted content contains the denied entry function.

**Attack Flow:**

1. Byzantine proposer creates inline transactions containing `EncryptedPayload` in `Encrypted` state with denied entry functions inside
2. Block proposal passes `ProposalMsg.verify()` because inline batch digests are computed correctly from the encrypted form [3](#0-2) 

3. In `process_proposal()`, `check_denied_inline_transactions()` is called: [4](#0-3) 

4. The filter extracts inline transactions using `get_inline_transactions()`: [5](#0-4) 

5. For each encrypted transaction, filter matching fails because `executable_ref()` returns `Err`, so deny rules don't match
6. Encrypted transactions pass the filter check
7. Block is accepted and inserted into block store
8. During pipeline execution, transactions are decrypted: [6](#0-5) 

9. Decrypted transactions containing denied entry functions are executed, bypassing the filter

## Impact Explanation

This vulnerability represents a **High Severity** issue as it enables significant protocol violations:

- **Filter Bypass**: Byzantine proposers can completely bypass transaction filtering for any rule that inspects transaction content (entry functions, module addresses, etc.)
- **Governance Violations**: Filters configured to enforce governance decisions (e.g., blocking specific contract calls during emergencies) can be circumvented
- **Consensus Integrity**: Different validators may accept/reject blocks inconsistently if filtering rules are not uniformly enforced
- **Security Policy Violations**: Any security policy implemented via transaction filters becomes ineffective against encrypted transactions

This qualifies as a "Significant protocol violation" under the High Severity category (up to $50,000) in the Aptos bug bounty program.

## Likelihood Explanation

**Likelihood: Medium-to-High**

**Requirements for exploitation:**
- Byzantine validator proposer (no additional privileges needed beyond being a validator)
- Knowledge of encrypted transaction format (publicly documented)
- Active transaction filter rules that the attacker wants to bypass

**Ease of exploitation:**
- Straightforward to craft encrypted transactions with specific content
- No cryptographic breaks required - the vulnerability is in the logic flow
- Can be executed by any validator acting as proposer for their round

**Practical scenarios:**
- Governance emergency measures using filters to block specific transactions
- Network operators attempting to filter malicious contract calls
- Temporary restrictions on specific entry functions during upgrades

## Recommendation

**Immediate Fix:** Modify the filter logic to handle encrypted transactions more securely. There are two approaches:

**Option 1 (Conservative):** Deny all encrypted inline transactions when filtering is enabled:

```rust
// In transaction_filter.rs, matches_entry_function():
TransactionPayload::EncryptedPayload(payload) => {
    // If transaction is still encrypted, conservatively deny it if we're trying
    // to match specific entry functions (because we cannot inspect the content)
    if payload.is_encrypted() {
        return true; // Match deny rules conservatively
    }
    if let Ok(executable) = payload.executable_ref() {
        match executable {
            TransactionExecutableRef::Script(_) | TransactionExecutableRef::Empty => false,
            TransactionExecutableRef::EntryFunction(entry_function) => {
                compare_entry_function(entry_function, address, module_name, function)
            },
        }
    } else {
        true // Conservative: match deny rules if we cannot inspect content
    }
}
```

**Option 2 (Preferred):** Require inline transactions to be decrypted before filter checks:

1. Modify `check_denied_inline_transactions()` to decrypt encrypted transactions first
2. Or enforce that inline batches cannot contain encrypted transactions
3. Add validation in `verify_inline_batches()` to reject encrypted inline transactions [7](#0-6) 

**Additional hardening:**
- Add explicit checks for encrypted transactions in all filter matchers
- Log warnings when encrypted transactions are encountered in inline batches
- Consider requiring decryption before inline batch inclusion at the protocol level

## Proof of Concept

```rust
#[cfg(test)]
mod encrypted_filter_bypass_poc {
    use super::*;
    use aptos_types::transaction::{
        SignedTransaction, TransactionPayload, RawTransaction,
        encrypted_payload::EncryptedPayload,
    };
    use aptos_crypto::{ed25519::Ed25519PrivateKey, PrivateKey, Uniform};
    use move_core_types::account_address::AccountAddress;
    
    #[test]
    fn test_encrypted_transaction_bypasses_filter() {
        // Setup: Create a filter that denies a specific entry function
        let denied_address = AccountAddress::random();
        let denied_module = "target_module".to_string();
        let denied_function = "forbidden_function".to_string();
        
        let filter = BlockTransactionFilter::empty()
            .add_entry_function_filter(
                false, // deny
                denied_address,
                denied_module.clone(),
                denied_function.clone(),
            );
        
        // Create an encrypted transaction (in Encrypted state, not Decrypted)
        // In reality, this would contain the denied entry function after decryption
        let encrypted_payload = EncryptedPayload::Encrypted {
            ciphertext: /* encrypted form of denied entry function */,
            extra_config: TransactionExtraConfig::default(),
            payload_hash: HashValue::random(),
        };
        
        let raw_txn = RawTransaction::new(
            AccountAddress::random(),
            0,
            TransactionPayload::EncryptedPayload(encrypted_payload),
            0,
            0,
            0,
            ChainId::test(),
        );
        
        let private_key = Ed25519PrivateKey::generate_for_testing();
        let signed_txn = SignedTransaction::new(
            raw_txn,
            private_key.public_key(),
            private_key.sign(&raw_txn).unwrap(),
        );
        
        // Test: The filter should deny this transaction but doesn't
        let block_id = HashValue::random();
        let block_author = Some(AccountAddress::random());
        let allows = filter.allows_transaction(
            block_id,
            block_author,
            1, // epoch
            1000, // timestamp
            &signed_txn,
        );
        
        // VULNERABILITY: The encrypted transaction passes the filter
        // even though it contains a denied entry function
        assert!(allows, "Encrypted transaction bypassed the filter!");
        
        // After decryption (in the pipeline), the denied entry function
        // would be executed, violating the filter rules
    }
}
```

## Notes

This vulnerability specifically affects the block transaction filter's ability to inspect and filter encrypted inline transactions. The core issue is the asymmetry between when filtering occurs (before decryption) and when transaction content becomes available (after decryption in the pipeline).

The filter implementation correctly handles encrypted transactions that are **already decrypted** (in `Decrypted` state), but fails for transactions in `Encrypted` state, which is the state they would be in when included in block proposals by Byzantine validators.

### Citations

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L362-373)
```rust
        TransactionPayload::EncryptedPayload(payload) => {
            if let Ok(executable) = payload.executable_ref() {
                match executable {
                    TransactionExecutableRef::Script(_) | TransactionExecutableRef::Empty => false,
                    TransactionExecutableRef::EntryFunction(entry_function) => {
                        compare_entry_function(entry_function, address, module_name, function)
                    },
                }
            } else {
                false
            }
        },
```

**File:** types/src/transaction/encrypted_payload.rs (L82-87)
```rust
    pub fn executable_ref(&self) -> Result<TransactionExecutableRef<'_>> {
        let Self::Decrypted { executable, .. } = self else {
            bail!("Transaction is encrypted");
        };
        Ok(executable.as_ref())
    }
```

**File:** consensus/consensus-types/src/common.rs (L541-556)
```rust
    pub fn verify_inline_batches<'a, T: TBatchInfo + 'a>(
        inline_batches: impl Iterator<Item = (&'a T, &'a Vec<SignedTransaction>)>,
    ) -> anyhow::Result<()> {
        for (batch, payload) in inline_batches {
            // TODO: Can cloning be avoided here?
            let computed_digest = BatchPayload::new(batch.author(), payload.clone()).hash();
            ensure!(
                computed_digest == *batch.digest(),
                "Hash of the received inline batch doesn't match the digest value for batch {:?}: {} != {}",
                batch,
                computed_digest,
                batch.digest()
            );
        }
        Ok(())
    }
```

**File:** consensus/src/round_manager.rs (L1202-1214)
```rust
        // If the proposal contains any inline transactions that need to be denied
        // (e.g., due to filtering) drop the message and do not vote for the block.
        if let Err(error) = self
            .block_store
            .check_denied_inline_transactions(&proposal, &self.block_txn_filter_config)
        {
            counters::REJECTED_PROPOSAL_DENY_TXN_COUNT.inc();
            bail!(
                "[RoundManager] Proposal for block {} contains denied inline transactions: {}. Dropping proposal!",
                proposal.id(),
                error
            );
        }
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L308-347)
```rust
    fn check_denied_inline_transactions(
        &self,
        block: &Block,
        block_txn_filter_config: &BlockTransactionFilterConfig,
    ) -> anyhow::Result<()> {
        // If the filter is disabled, return early
        if !block_txn_filter_config.is_enabled() {
            return Ok(());
        }

        // Get the inline transactions for the block proposal
        let inline_transactions = get_inline_transactions(block);
        if inline_transactions.is_empty() {
            return Ok(());
        }

        // Fetch the block metadata
        let block_id = block.id();
        let block_author = block.author();
        let block_epoch = block.epoch();
        let block_timestamp = block.timestamp_usecs();

        // Identify any denied inline transactions
        let block_transaction_filter = block_txn_filter_config.block_transaction_filter();
        let denied_inline_transactions = block_transaction_filter.get_denied_block_transactions(
            block_id,
            block_author,
            block_epoch,
            block_timestamp,
            inline_transactions,
        );
        if !denied_inline_transactions.is_empty() {
            return Err(anyhow::anyhow!(
                "Inline transactions for QuorumStorePayload denied by block transaction filter: {:?}",
                denied_inline_transactions
            ));
        }

        Ok(()) // No transactions were denied
    }
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L567-599)
```rust
/// Extracts and returns all inline transactions from the payload in the given block
fn get_inline_transactions(block: &Block) -> Vec<SignedTransaction> {
    // If the block has no payload, return an empty vector
    let Some(payload) = block.payload() else {
        return vec![];
    };

    // Fetch the inline transactions from the payload
    match payload {
        Payload::QuorumStoreInlineHybrid(inline_batches, ..) => {
            // Flatten the inline batches and return the transactions
            inline_batches
                .iter()
                .flat_map(|(_batch_info, txns)| txns.clone())
                .collect()
        },
        Payload::QuorumStoreInlineHybridV2(inline_batches, ..) => {
            // Flatten the inline batches and return the transactions
            inline_batches
                .iter()
                .flat_map(|(_batch_info, txns)| txns.clone())
                .collect()
        },
        Payload::OptQuorumStore(OptQuorumStorePayload::V1(p)) => p.inline_batches().transactions(),
        Payload::OptQuorumStore(OptQuorumStorePayload::V2(_p)) => {
            error!("OptQSPayload V2 is not expected");
            Vec::new()
        },
        _ => {
            vec![] // Other payload types do not have inline transactions
        },
    }
}
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L121-148)
```rust
        let decrypted_txns = encrypted_txns
            .into_par_iter()
            .zip(txn_ciphertexts)
            .map(|(mut txn, ciphertext)| {
                let eval_proof = proofs.get(&ciphertext.id()).expect("must exist");
                if let Ok(payload) = FPTXWeighted::decrypt_individual::<DecryptedPayload>(
                    &decryption_key.key,
                    &ciphertext,
                    &digest,
                    &eval_proof,
                ) {
                    let (executable, nonce) = payload.unwrap();
                    txn.payload_mut()
                        .as_encrypted_payload_mut()
                        .map(|p| {
                            p.into_decrypted(eval_proof, executable, nonce)
                                .expect("must happen")
                        })
                        .expect("must exist");
                } else {
                    txn.payload_mut()
                        .as_encrypted_payload_mut()
                        .map(|p| p.into_failed_decryption(eval_proof).expect("must happen"))
                        .expect("must exist");
                }
                txn
            })
            .collect();
```
