# Audit Report

## Title
Cross-Shard Dependency Bypass via Type-Parameterized State Key Mismatch in Sharded Block Executor

## Summary
The sharded block executor relies on statically-analyzed read/write hints to determine cross-shard dependencies, but these hints are incomplete for generic functions. Specifically, `coin::transfer<CoinType>` is analyzed with hardcoded hints for `AptosCoin`, causing transactions involving custom coin types to read stale cross-shard state from `base_view` instead of waiting for updates from other shards, violating the deterministic execution invariant.

## Finding Description
The vulnerability exists in the interaction between static transaction analysis and runtime execution:

**Static Analysis Phase:**
The `get_read_write_hints()` function pattern-matches transaction entry functions to return pre-computed read/write hints. [1](#0-0) 

For ANY call to `0x1::coin::transfer` (regardless of type parameter), it returns: [2](#0-1) 

This includes `aptos_coin_info_location()` which creates a SPECIFIC state key for `CoinInfo<AptosCoin>`: [3](#0-2) 

**Partitioning Phase:**
The partitioner builds cross-shard dependencies based on these static hints: [4](#0-3) 

**Execution Phase:**
The `CrossShardStateView` is populated ONLY with state keys from `required_edges`: [5](#0-4) 

When a transaction reads a state key during execution: [6](#0-5) 

If the key is NOT in `cross_shard_data`, it immediately reads from `base_view` without waiting for cross-shard updates.

**The Exploit:**
The Move implementation of `coin::transfer<CoinType>` is generic and acquires `CoinInfo` for the specific `CoinType`: [7](#0-6) 

For `coin::transfer<CustomCoin>`, the actual execution reads `CoinInfo<CustomCoin>`, but the static hints only include `CoinInfo<AptosCoin>`. This causes:
1. Partitioner thinks dependency is on `CoinInfo<AptosCoin>` (wrong key)
2. `CoinInfo<CustomCoin>` is NOT added to `cross_shard_data`
3. Transaction reads stale `CoinInfo<CustomCoin>` from `base_view`
4. Execution proceeds with incorrect state, violating deterministic execution

## Impact Explanation
**Critical Severity** - This is a **Consensus/Safety violation**:

1. **Deterministic Execution Violation**: Different validator nodes may execute transactions in different shard orders due to timing, causing them to read different values for `CoinInfo<CustomCoin>`. This leads to different transaction outputs and different state roots, breaking consensus.

2. **State Inconsistency**: A transaction in Shard B reading stale `CoinInfo<CustomCoin>` while Shard A has updated it causes the transaction to execute with pre-update state, leading to incorrect balances, supply calculations, or other state corruption.

3. **Consensus Divergence**: Validators that execute Shard A before Shard B will have correct state, while those executing in parallel will have incorrect state, potentially causing irrecoverable chain splits requiring a hard fork.

This meets the Critical Severity threshold: "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation
**High Likelihood** for several reasons:

1. **No Type Parameter Validation**: The static analysis performs simple string matching on module/function names without considering type parameters, making the bug trigger automatically for any non-AptosCoin transfer.

2. **Sharded Execution is Production Code**: The sharded executor is actively used in the executor workflow: [8](#0-7) 

3. **Custom Coins are Common**: The Aptos ecosystem supports custom fungible assets, and users regularly create and transfer custom coin types.

4. **No Runtime Validation**: There's no validation that enforces transactions only read state keys declared in their hints, allowing the mismatch to go undetected until consensus failure.

## Recommendation
Implement one of these fixes:

**Option 1: Restrict Sharded Execution to Fully-Analyzed Transactions**
```rust
// In get_read_write_hints():
(AccountAddress::ONE, "coin", "transfer") => {
    // Only return hints if transferring AptosCoin specifically
    // Check type parameter matches AptosCoin
    if is_aptos_coin_transfer(func) {
        let receiver_address = bcs::from_bytes(&func.args()[0]).unwrap();
        rw_set_for_coin_transfer(sender_address, receiver_address, true)
    } else {
        // Return empty hints to exclude from sharding
        empty_rw_set()
    }
},
```

**Option 2: Extract Type Parameters and Generate Correct Hints**
```rust
// Extract CoinType from transaction and generate correct CoinInfo location
(AccountAddress::ONE, "coin", "transfer") => {
    let coin_type = extract_type_parameter(func, 0)?;
    let receiver_address = bcs::from_bytes(&func.args()[0]).unwrap();
    rw_set_for_coin_transfer_generic(sender_address, receiver_address, coin_type, true)
},
```

**Option 3: Runtime Validation**
Add validation in `CrossShardStateView::get_state_value()` to panic if a transaction reads a key that's not in `cross_shard_data` AND not in a whitelist of globally-safe keys, forcing developers to fix incomplete static analysis.

## Proof of Concept
```rust
// Reproduction scenario (conceptual - would need full test harness):

// 1. Create custom coin type CustomCoin
// 2. Submit two transactions in separate shards:
//    - T1 (Shard A): coin::transfer<CustomCoin>(alice, bob, 100)
//      Writes: CoinInfo<CustomCoin>, CoinStore<CustomCoin>@alice, CoinStore<CustomCoin>@bob
//    
//    - T2 (Shard B): coin::transfer<CustomCoin>(carol, dave, 50)  
//      Should read: CoinInfo<CustomCoin> (to check decimals, supply, etc.)
//      Actually reads from: base_view (stale value)

// 3. Execute shards in parallel
// 4. T2 executes with stale CoinInfo<CustomCoin> before T1's update arrives
// 5. T2 produces incorrect output (e.g., wrong supply calculation)
// 6. Validators get different state roots depending on execution order
// 7. Consensus fails or chain splits

// Key assertion to verify vulnerability:
// In CrossShardStateView::get_state_value(), add logging:
fn get_state_value(&self, state_key: &StateKey) -> Result<Option<StateValue>, StateViewError> {
    if let Some(value) = self.cross_shard_data.get(state_key) {
        return Ok(value.get_value());
    }
    // BUG: Reading from base_view for key not in cross_shard_data!
    // This should block if there are cross-shard writers for this key
    eprintln!("WARNING: Reading {} from base_view - potential stale data!", state_key);
    self.base_view.get_state_value(state_key)
}
```

## Notes
This vulnerability demonstrates a fundamental architectural issue: static analysis of generic Move functions requires type parameter resolution, which the current implementation doesn't perform. The hardcoded hints for `AptosCoin` are only correct for that specific instantiation, not for the generic `coin::transfer<CoinType>` function family. Until proper type-aware static analysis is implemented or sharded execution is restricted to non-generic transactions, this consensus vulnerability remains exploitable.

### Citations

**File:** types/src/transaction/analyzed_transaction.rs (L169-175)
```rust

pub fn current_ts_location() -> StorageLocation {
    StorageLocation::Specific(StateKey::on_chain_config::<CurrentTimeMicroseconds>().unwrap())
}

pub fn features_location() -> StorageLocation {
    StorageLocation::Specific(StateKey::on_chain_config::<Features>().unwrap())
```

**File:** types/src/transaction/analyzed_transaction.rs (L195-220)
```rust
pub fn rw_set_for_coin_transfer(
    sender_address: AccountAddress,
    receiver_address: AccountAddress,
    receiver_exists: bool,
) -> (Vec<StorageLocation>, Vec<StorageLocation>) {
    let mut write_hints = vec![
        account_resource_location(sender_address),
        coin_store_location(sender_address),
    ];
    if sender_address != receiver_address {
        write_hints.push(coin_store_location(receiver_address));
    }
    if !receiver_exists {
        // If the receiver doesn't exist, we create the receiver account, so we need to write the
        // receiver account resource.
        write_hints.push(account_resource_location(receiver_address));
    }

    let read_hints = vec![
        current_ts_location(),
        features_location(),
        aptos_coin_info_location(),
        chain_id_location(),
        transaction_fee_burn_cap_location(),
    ];
    (read_hints, write_hints)
```

**File:** types/src/transaction/analyzed_transaction.rs (L246-269)
```rust
        let process_entry_function = |func: &EntryFunction,
                                      sender_address: AccountAddress|
         -> (Vec<StorageLocation>, Vec<StorageLocation>) {
            match (
                *func.module().address(),
                func.module().name().as_str(),
                func.function().as_str(),
            ) {
                (AccountAddress::ONE, "coin", "transfer") => {
                    let receiver_address = bcs::from_bytes(&func.args()[0]).unwrap();
                    rw_set_for_coin_transfer(sender_address, receiver_address, true)
                },
                (AccountAddress::ONE, "aptos_account", "transfer") => {
                    let receiver_address = bcs::from_bytes(&func.args()[0]).unwrap();
                    rw_set_for_coin_transfer(sender_address, receiver_address, false)
                },
                (AccountAddress::ONE, "aptos_account", "create_account") => {
                    let receiver_address = bcs::from_bytes(&func.args()[0]).unwrap();
                    rw_set_for_create_account(sender_address, receiver_address)
                },
                _ => todo!(
                    "Only coin transfer and create account transactions are supported for now"
                ),
            }
```

**File:** execution/block-partitioner/src/v2/state.rs (L301-321)
```rust
        // Build required edges.
        let write_set = self.write_sets[ori_txn_idx].read().unwrap();
        let read_set = self.read_sets[ori_txn_idx].read().unwrap();
        for &key_idx in write_set.iter().chain(read_set.iter()) {
            let tracker_ref = self.trackers.get(&key_idx).unwrap();
            let tracker = tracker_ref.read().unwrap();
            if let Some(txn_idx) = tracker
                .finalized_writes
                .range(..ShardedTxnIndexV2::new(round_id, shard_id, 0))
                .last()
            {
                let src_txn_idx = ShardedTxnIndex {
                    txn_index: *self.final_idxs_by_pre_partitioned[txn_idx.pre_partitioned_txn_idx]
                        .read()
                        .unwrap(),
                    shard_id: txn_idx.shard_id(),
                    round_id: txn_idx.round_id(),
                };
                deps.add_required_edge(src_txn_idx, tracker.storage_location.clone());
            }
        }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_state_view.rs (L58-71)
```rust
    pub fn create_cross_shard_state_view(
        base_view: &'a S,
        transactions: &[TransactionWithDependencies<AnalyzedTransaction>],
    ) -> CrossShardStateView<'a, S> {
        let mut cross_shard_state_key = HashSet::new();
        for txn in transactions {
            for (_, storage_locations) in txn.cross_shard_dependencies.required_edges_iter() {
                for storage_location in storage_locations {
                    cross_shard_state_key.insert(storage_location.clone().into_state_key());
                }
            }
        }
        CrossShardStateView::new(cross_shard_state_key, base_view)
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_state_view.rs (L77-82)
```rust
    fn get_state_value(&self, state_key: &StateKey) -> Result<Option<StateValue>, StateViewError> {
        if let Some(value) = self.cross_shard_data.get(state_key) {
            return Ok(value.get_value());
        }
        self.base_view.get_state_value(state_key)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L1137-1146)
```text
    /// Transfers `amount` of coins `CoinType` from `from` to `to`.
    public entry fun transfer<CoinType>(
        from: &signer, to: address, amount: u64
    ) acquires CoinConversionMap, CoinInfo {
        let fa =
            primary_fungible_store::withdraw(
                from, ensure_paired_metadata<CoinType>(), amount
            );
        primary_fungible_store::deposit(to, fa);
    }
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L256-276)
```rust
    fn execute_block_sharded<V: VMBlockExecutor>(
        partitioned_txns: PartitionedTransactions,
        state_view: Arc<CachedStateView>,
        onchain_config: BlockExecutorConfigFromOnchain,
    ) -> Result<Vec<TransactionOutput>> {
        if !get_remote_addresses().is_empty() {
            Ok(V::execute_block_sharded(
                &REMOTE_SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        } else {
            Ok(V::execute_block_sharded(
                &SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        }
    }
```
