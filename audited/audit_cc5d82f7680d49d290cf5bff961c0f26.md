# Audit Report

## Title
StorageServiceMessage Bandwidth Amplification via Unlimited Valid Request Exploitation

## Summary
The storage service lacks rate limiting for valid requests, allowing attackers to exhaust bandwidth by sending multiple concurrent large valid requests across all networks, causing validator node slowdowns and potential consensus participation degradation.

## Finding Description

The storage service protocol suffers from a bandwidth amplification vulnerability where valid requests are not rate-limited at the application layer. The `RequestModerator` only tracks and penalizes peers for sending INVALID requests (requests that cannot be serviced), while VALID requests face no per-peer bandwidth limits beyond concurrent RPC count. [1](#0-0) 

The validation logic only increments the invalid request counter when a request cannot be serviced, but does not track or limit the cumulative bandwidth consumed by valid requests. [2](#0-1) 

Each storage service request can return up to 40 MiB of data (max_network_chunk_bytes_v2): [3](#0-2) 

The network layer's default configuration has NO rate limiting enabled: [4](#0-3) [5](#0-4) 

The RPC layer limits concurrent requests to only 100 per peer connection: [6](#0-5) 

The storage service is registered on ALL networks (validator, VFN, public): [7](#0-6) 

**Attack Path:**
1. Attacker connects multiple malicious peers to the victim validator node
2. Each peer sends 100 concurrent VALID storage service RPC requests (e.g., `GetTransactionDataWithProof` for large transaction ranges)
3. Each request returns up to 40 MiB of response data
4. Total bandwidth per peer: 100 requests Ã— 40 MiB = 4 GB
5. With 10 malicious peers: 40 GB of bandwidth consumption
6. Requests remain valid because they request data that exists and can be serviced
7. The `RequestModerator` never penalizes these peers because requests are valid
8. Network bandwidth is exhausted, causing validator slowdowns

## Impact Explanation

This vulnerability constitutes **High Severity** per Aptos bug bounty criteria:

- **Validator node slowdowns**: Bandwidth exhaustion directly causes validator nodes to slow down in processing legitimate requests, potentially affecting consensus participation
- **Significant protocol violations**: Violates the documented invariant #9 - "Resource Limits: All operations must respect gas, storage, and computational limits" - where bandwidth is a critical computational resource that must be bounded

The vulnerability breaks the resource limits invariant because:
1. No per-peer bandwidth accounting exists for valid requests
2. No global bandwidth limits protect against multiple malicious peers
3. Large response sizes (40 MiB) amplify the impact
4. Attack is sustainable as long as peer connections remain active

## Likelihood Explanation

**Likelihood: HIGH**

The attack is highly likely because:
1. **Low barrier to entry**: Any network peer can connect and send storage service requests
2. **No special privileges required**: Attacker doesn't need validator access or special credentials
3. **Trivial to execute**: Simply connecting multiple peers and sending concurrent RPC requests
4. **Hard to detect**: Valid requests appear legitimate to the request moderator
5. **No automatic mitigation**: System doesn't automatically block or rate-limit valid request bandwidth
6. **Persistent attack**: Can be sustained indefinitely as long as connections are maintained

The only mitigation is manually enabling network-layer rate limiting, which is disabled by default and requires operator intervention.

## Recommendation

Implement multi-layered rate limiting for storage service requests:

**1. Add per-peer bandwidth tracking in RequestModerator:**
- Track cumulative bytes sent per peer over a time window
- Implement bandwidth quotas (e.g., 100 MB/s per peer)
- Temporarily block peers exceeding bandwidth limits (similar to invalid request blocking)

**2. Enable network-layer rate limiting by default:**
- Set reasonable default values for `inbound_rate_limit_config` and `outbound_rate_limit_config`
- Apply rate limits to all network types (validator, VFN, public)

**3. Add global bandwidth limits:**
- Implement global bandwidth accounting across all peers
- Apply backpressure when total outbound bandwidth exceeds thresholds
- Prioritize critical protocols (consensus) over storage service when under load

**4. Implement request-size-aware limits:**
- Consider the expected response size when accepting requests
- Reject or defer requests that would exceed bandwidth quotas

## Proof of Concept

```rust
// Proof of Concept: Bandwidth Amplification Attack
// This demonstrates how an attacker can exhaust bandwidth with valid requests

use aptos_config::network_id::{NetworkId, PeerNetworkId};
use aptos_storage_service_types::{
    requests::{DataRequest, StorageServiceRequest},
};
use aptos_types::PeerId;
use std::sync::Arc;

#[tokio::test]
async fn test_bandwidth_amplification_attack() {
    // Setup: Create a storage service server with default config
    let storage_service_config = StorageServiceConfig::default();
    
    // Attack: Create 10 malicious peers
    let num_malicious_peers = 10;
    let max_concurrent_rpcs = 100; // From constants::MAX_CONCURRENT_INBOUND_RPCS
    let max_response_size = 40 * 1024 * 1024; // 40 MiB (max_network_chunk_bytes_v2)
    
    for peer_id in 0..num_malicious_peers {
        let malicious_peer = PeerNetworkId::new(NetworkId::Public, PeerId::random());
        
        // Send 100 concurrent valid storage service requests
        for request_id in 0..max_concurrent_rpcs {
            // Request large transaction data range (valid request)
            let request = StorageServiceRequest::new(
                DataRequest::get_transaction_data_with_proof(
                    /* proof_version */ 1000000,
                    /* start_version */ request_id * 1000,
                    /* end_version */ (request_id + 1) * 1000,
                    /* include_events */ true,
                    /* max_response_bytes */ max_response_size as u64,
                ),
                /* use_compression */ false,
            );
            
            // This request is VALID (assuming the data exists)
            // RequestModerator will NOT block it
            // Response can be up to 40 MiB
        }
    }
    
    // Result: Total bandwidth consumption
    let total_bandwidth = num_malicious_peers * max_concurrent_rpcs * max_response_size;
    assert_eq!(total_bandwidth, 40 * 1024 * 1024 * 1024); // 40 GB
    
    // Impact: Validator node bandwidth is exhausted
    // - Legitimate storage sync requests fail or timeout
    // - Validator slows down or becomes unresponsive
    // - Consensus participation may be affected
}
```

**Notes:**
- The vulnerability exploits the lack of bandwidth-based rate limiting for valid storage service requests
- The `RequestModerator` only penalizes invalid requests, allowing unlimited bandwidth consumption through valid requests
- Network-layer rate limiting is disabled by default, providing no protection
- The attack is amplified by large response sizes (40 MiB) and cross-network exposure
- Mitigation requires enabling rate limiting and implementing application-layer bandwidth tracking

### Citations

**File:** state-sync/storage-service/server/src/moderator.rs (L134-195)
```rust
    pub fn validate_request(
        &self,
        peer_network_id: &PeerNetworkId,
        request: &StorageServiceRequest,
    ) -> Result<(), Error> {
        // Validate the request and time the operation
        let validate_request = || {
            // If the peer is being ignored, return an error
            if let Some(peer_state) = self.unhealthy_peer_states.get(peer_network_id) {
                if peer_state.is_ignored() {
                    return Err(Error::TooManyInvalidRequests(format!(
                        "Peer is temporarily ignored. Unable to handle request: {:?}",
                        request
                    )));
                }
            }

            // Get the latest storage server summary
            let storage_server_summary = self.cached_storage_server_summary.load();

            // Verify the request is serviceable using the current storage server summary
            if !storage_server_summary.can_service(
                &self.aptos_data_client_config,
                self.time_service.clone(),
                request,
            ) {
                // Increment the invalid request count for the peer
                let mut unhealthy_peer_state = self
                    .unhealthy_peer_states
                    .entry(*peer_network_id)
                    .or_insert_with(|| {
                        // Create a new unhealthy peer state (this is the first invalid request)
                        let max_invalid_requests =
                            self.storage_service_config.max_invalid_requests_per_peer;
                        let min_time_to_ignore_peers_secs =
                            self.storage_service_config.min_time_to_ignore_peers_secs;
                        let time_service = self.time_service.clone();

                        UnhealthyPeerState::new(
                            max_invalid_requests,
                            min_time_to_ignore_peers_secs,
                            time_service,
                        )
                    });
                unhealthy_peer_state.increment_invalid_request_count(peer_network_id);

                // Return the validation error
                return Err(Error::InvalidRequest(format!(
                    "The given request cannot be satisfied. Request: {:?}, storage summary: {:?}",
                    request, storage_server_summary
                )));
            }

            Ok(()) // The request is valid
        };
        utils::execute_and_time_duration(
            &metrics::STORAGE_REQUEST_VALIDATION_LATENCY,
            Some((peer_network_id, request)),
            None,
            validate_request,
            None,
        )
```

**File:** config/src/config/state_sync_config.rs (L17-21)
```rust
const SERVER_MAX_MESSAGE_SIZE: usize = 10 * 1024 * 1024; // 10 MiB

// The maximum message size per state sync message (for v2 data requests)
const CLIENT_MAX_MESSAGE_SIZE_V2: usize = 20 * 1024 * 1024; // 20 MiB (used for v2 data requests)
const SERVER_MAX_MESSAGE_SIZE_V2: usize = 40 * 1024 * 1024; // 40 MiB (used for v2 data requests)
```

**File:** config/src/config/network_config.rs (L117-119)
```rust
    pub inbound_rate_limit_config: Option<RateLimitConfig>,
    /// Outbound rate limiting configuration, if not specified, no rate limiting
    pub outbound_rate_limit_config: Option<RateLimitConfig>,
```

**File:** config/src/config/network_config.rs (L158-159)
```rust
            inbound_rate_limit_config: None,
            outbound_rate_limit_config: None,
```

**File:** network/framework/src/constants.rs (L13-15)
```rust
pub const MAX_CONCURRENT_OUTBOUND_RPCS: u32 = 100;
/// Limit on concurrent Inbound RPC requests before backpressure is applied
pub const MAX_CONCURRENT_INBOUND_RPCS: u32 = 100;
```

**File:** aptos-node/src/network.rs (L380-388)
```rust
        // Register the storage service (both client and server) with the network
        let storage_service_network_handle = register_client_and_service_with_network(
            &mut network_builder,
            network_id,
            &network_config,
            storage_service_network_configuration(node_config),
            true,
        );
        storage_service_network_handles.push(storage_service_network_handle);
```
