# Audit Report

## Title
Event Type Confusion in Quorum Store Message Filtering Allows V2 Messages to Bypass Security Checks

## Summary
The `filter_quorum_store_events()` function in `consensus/src/epoch_manager.rs` only validates V1 quorum store message types (BatchMsg, SignedBatchInfo, ProofOfStoreMsg) but does not check V2 variants (BatchMsgV2, SignedBatchInfoMsgV2, ProofOfStoreMsgV2). This event type confusion allows V2 messages to bypass filtering logic designed to prevent quorum store messages from being processed when quorum store is disabled, violating consensus safety invariants.

## Finding Description

The vulnerability exists in the message filtering pipeline of the Aptos consensus layer. When consensus messages arrive, they must pass through `filter_quorum_store_events()` which enforces that quorum store messages are only processed when `quorum_store_enabled` is true. [1](#0-0) 

The filter only matches three V1 event types, but the `UnverifiedEvent` enum contains six quorum store variants: [2](#0-1) 

The three V2 variants (BatchMsgV2, SignedBatchInfoMsgV2, ProofOfStoreMsgV2) fall through to the catch-all pattern `_ => Ok(true)`, bypassing the quorum store validation entirely.

These V2 messages are actively used in production code: [3](#0-2) [4](#0-3) 

The vulnerability is compounded by incomplete network routing that currently drops V2 messages: [5](#0-4) 

When network routing is corrected to handle V2 messages (which will be necessary for quorum store V2 to function), these messages will bypass the filter and be processed even when `quorum_store_enabled = false`, violating the critical security invariant that quorum store messages should only be processed when explicitly enabled.

## Impact Explanation

**Medium Severity** - This creates state inconsistencies requiring intervention:

1. **Consensus Safety Risk**: If V2 messages are processed when quorum store is disabled, nodes may diverge on block validation since some will process batches while others reject them
2. **Protocol Violation**: The filter exists to enforce that quorum store operations only occur when properly configured; bypassing it breaks this security boundary
3. **Recovery Mode Confusion**: During recovery mode, V2 messages would still be processed instead of being silently filtered, potentially corrupting recovery state

The impact is currently limited by the network layer dropping V2 messages, but this is a latent vulnerability that will manifest when V2 routing is implemented, causing immediate consensus issues.

## Likelihood Explanation

**High Likelihood** once V2 routing is fixed:

1. **Active Code Paths**: V2 message sending is already implemented and conditionally enabled via `config.enable_batch_v2`
2. **Inevitable Fix**: The network routing bug will need to be fixed for quorum store V2 to function
3. **Easy to Overlook**: A developer fixing the network routing may not realize the filter also needs updating
4. **No Warning**: The catch-all pattern silently allows V2 messages through without any error or warning

## Recommendation

Update `filter_quorum_store_events()` to include all V2 quorum store event types:

```rust
fn filter_quorum_store_events(
    &mut self,
    peer_id: AccountAddress,
    event: &UnverifiedEvent,
) -> anyhow::Result<bool> {
    match event {
        UnverifiedEvent::BatchMsg(_)
        | UnverifiedEvent::BatchMsgV2(_)
        | UnverifiedEvent::SignedBatchInfo(_)
        | UnverifiedEvent::SignedBatchInfoMsgV2(_)
        | UnverifiedEvent::ProofOfStoreMsg(_)
        | UnverifiedEvent::ProofOfStoreMsgV2(_) => {
            if self.quorum_store_enabled {
                Ok(true)
            } else if self.recovery_mode {
                Ok(false)
            } else {
                Err(anyhow::anyhow!(
                    "Quorum store is not enabled locally, but received msg from sender: {}",
                    peer_id,
                ))
            }
        },
        _ => Ok(true),
    }
}
```

Additionally, update the network routing logic to handle V2 messages: [6](#0-5) 

And update `check_epoch()` to include V2 variants: [7](#0-6) 

## Proof of Concept

```rust
// Test demonstrating the vulnerability
#[test]
fn test_v2_messages_bypass_filter() {
    use consensus::epoch_manager::EpochManager;
    use consensus::round_manager::UnverifiedEvent;
    use aptos_types::account_address::AccountAddress;
    
    let mut epoch_manager = /* initialize with quorum_store_enabled = false */;
    let peer_id = AccountAddress::random();
    
    // Create a V2 quorum store message
    let batch_msg_v2 = UnverifiedEvent::BatchMsgV2(
        Box::new(BatchMsg::new(vec![/* batch data */]))
    );
    
    // This should return an error since quorum store is disabled
    // BUT it returns Ok(true) due to the catch-all pattern
    let result = epoch_manager.filter_quorum_store_events(peer_id, &batch_msg_v2);
    
    // Expected: Err("Quorum store is not enabled...")
    // Actual: Ok(true) - BYPASS!
    assert!(result.is_ok() && result.unwrap() == true);
    
    // For comparison, V1 message correctly returns error
    let batch_msg_v1 = UnverifiedEvent::BatchMsg(
        Box::new(BatchMsg::new(vec![/* batch data */]))
    );
    let result_v1 = epoch_manager.filter_quorum_store_events(peer_id, &batch_msg_v1);
    assert!(result_v1.is_err()); // Correctly rejected
}
```

**Notes**

This vulnerability demonstrates classic event type confusion where new variants of existing message types bypass security checks designed for the original variants. The separation between V1 and V2 message types was not properly propagated through all security-critical code paths, creating a dangerous inconsistency that will manifest as soon as V2 messages are properly routed through the network layer.

### Citations

**File:** consensus/src/epoch_manager.rs (L1632-1654)
```rust
        match msg {
            ConsensusMsg::ProposalMsg(_)
            | ConsensusMsg::OptProposalMsg(_)
            | ConsensusMsg::SyncInfo(_)
            | ConsensusMsg::VoteMsg(_)
            | ConsensusMsg::RoundTimeoutMsg(_)
            | ConsensusMsg::OrderVoteMsg(_)
            | ConsensusMsg::CommitVoteMsg(_)
            | ConsensusMsg::CommitDecisionMsg(_)
            | ConsensusMsg::BatchMsg(_)
            | ConsensusMsg::BatchRequestMsg(_)
            | ConsensusMsg::SignedBatchInfo(_)
            | ConsensusMsg::ProofOfStoreMsg(_) => {
                let event: UnverifiedEvent = msg.into();
                if event.epoch()? == self.epoch() {
                    return Ok(Some(event));
                } else {
                    monitor!(
                        "process_different_epoch_consensus_msg",
                        self.process_different_epoch(event.epoch()?, peer_id)
                    )?;
                }
            },
```

**File:** consensus/src/epoch_manager.rs (L1694-1716)
```rust
    fn filter_quorum_store_events(
        &mut self,
        peer_id: AccountAddress,
        event: &UnverifiedEvent,
    ) -> anyhow::Result<bool> {
        match event {
            UnverifiedEvent::BatchMsg(_)
            | UnverifiedEvent::SignedBatchInfo(_)
            | UnverifiedEvent::ProofOfStoreMsg(_) => {
                if self.quorum_store_enabled {
                    Ok(true) // This states that we shouldn't filter out the event
                } else if self.recovery_mode {
                    Ok(false) // This states that we should filter out the event, but without an error
                } else {
                    Err(anyhow::anyhow!(
                        "Quorum store is not enabled locally, but received msg from sender: {}",
                        peer_id,
                    ))
                }
            },
            _ => Ok(true), // This states that we shouldn't filter out the event
        }
    }
```

**File:** consensus/src/round_manager.rs (L89-103)
```rust
#[derive(Debug, Serialize, Clone)]
pub enum UnverifiedEvent {
    ProposalMsg(Box<ProposalMsg>),
    VoteMsg(Box<VoteMsg>),
    RoundTimeoutMsg(Box<RoundTimeoutMsg>),
    OrderVoteMsg(Box<OrderVoteMsg>),
    SyncInfo(Box<SyncInfo>),
    BatchMsg(Box<BatchMsg<BatchInfo>>),
    BatchMsgV2(Box<BatchMsg<BatchInfoExt>>),
    SignedBatchInfo(Box<SignedBatchInfoMsg<BatchInfo>>),
    SignedBatchInfoMsgV2(Box<SignedBatchInfoMsg<BatchInfoExt>>),
    ProofOfStoreMsg(Box<ProofOfStoreMsg<BatchInfo>>),
    ProofOfStoreMsgV2(Box<ProofOfStoreMsg<BatchInfoExt>>),
    OptProposalMsg(Box<OptProposalMsg>),
}
```

**File:** consensus/src/quorum_store/batch_generator.rs (L494-500)
```rust
                            if self.config.enable_batch_v2 {
                                network_sender.broadcast_batch_msg_v2(batches).await;
                            } else {
                                let batches = batches.into_iter().map(|batch| {
                                    batch.try_into().expect("Cannot send V2 batch with flag disabled")
                                }).collect();
                                network_sender.broadcast_batch_msg(batches).await;
```

**File:** consensus/src/quorum_store/proof_coordinator.rs (L485-497)
```rust
                                    if proofs_iter.peek().is_some_and(|p| p.info().is_v2()) {
                                        let proofs: Vec<_> = proofs_iter.collect();
                                        network_sender.broadcast_proof_of_store_msg_v2(proofs).await;
                                    } else {
                                        let proofs: Vec<_> = proofs_iter.map(|proof| {
                                            let (info, sig) = proof.unpack();
                                            ProofOfStore::new(info.info().clone(), sig)
                                        }).collect();
                                        network_sender.broadcast_proof_of_store_msg(proofs).await;
                                    }
                                } else {
                                    let proofs: Vec<_> = proofs_iter.collect();
                                    network_sender.send_proof_of_store_msg_to_self(proofs).await;
```

**File:** consensus/src/network.rs (L822-841)
```rust
                    match msg {
                        quorum_store_msg @ (ConsensusMsg::SignedBatchInfo(_)
                        | ConsensusMsg::BatchMsg(_)
                        | ConsensusMsg::ProofOfStoreMsg(_)) => {
                            Self::push_msg(
                                peer_id,
                                quorum_store_msg,
                                &self.quorum_store_messages_tx,
                            );
                        },
                        // Remove after migration to use rpc.
                        ConsensusMsg::CommitVoteMsg(commit_vote) => {
                            let (tx, _rx) = oneshot::channel();
                            let req_with_callback =
                                IncomingRpcRequest::CommitRequest(IncomingCommitRequest {
                                    req: CommitMessage::Vote(*commit_vote),
                                    protocol: RPC[0],
                                    response_sender: tx,
                                });
                            if let Err(e) = self.rpc_tx.push(
```
