# Audit Report

## Title
Missing Epoch Validation in JWK Consensus Allows Replay of Historical On-Chain States Across Epoch Boundaries

## Summary
The JWK consensus system fails to validate the `epoch` field when processing `ObservedJWKsUpdated` events, allowing historical events from previous epochs to be processed by the current epoch's consensus manager. This creates a defensive programming gap where validators can temporarily operate with stale JWK state during state sync catchup operations.

## Finding Description

The JWK consensus system maintains local state synchronized with on-chain JWK updates through `ObservedJWKsUpdated` events. Each event contains an `epoch` field to indicate which epoch the update occurred in. [1](#0-0) 

However, both JWK consensus manager implementations explicitly ignore this epoch field when processing events:

**IssuerLevelConsensusManager** destructures the event and discards the epoch field: [2](#0-1) 

**KeyLevelConsensusManager** exhibits identical behavior: [3](#0-2) 

The `EpochManager` forwards all events to the current epoch's manager without epoch validation: [4](#0-3) 

This contrasts with RPC message handling, which explicitly validates epoch before processing: [5](#0-4) 

The `reset_with_on_chain_state` functions accept incoming state without version or epoch monotonicity checks: [6](#0-5) [7](#0-6) 

**Attack Vector:**

During state sync catchup, when a validator processes historical blocks from epoch N while operating in epoch N+1, the event notification system delivers old `ObservedJWKsUpdated` events: [8](#0-7) 

These historical events are forwarded to the current epoch's JWK consensus manager, which processes them without validating they belong to the current epoch, potentially causing temporary state rollback.

## Impact Explanation

**Severity: Medium**

This vulnerability enables temporary state consistency violations:

- **Temporary State Inconsistency**: Validators processing state sync catchup can have their JWK consensus state temporarily rolled back to historical values, creating a window where their local state diverges from the current on-chain authoritative state.

- **Potential Security Window**: If keyless authentication transaction validation uses the local JWK consensus state (rather than always querying on-chain storage), this could create a window where revoked or rotated keys are temporarily accepted.

- **Validator State Divergence**: Different validators might process historical events at different times during catchup, leading to temporary JWK state divergence across the validator set.

The impact is limited because:
- The on-chain authoritative state remains correct
- The inconsistency is temporary and self-correcting
- Recovery occurs naturally through subsequent event processing or reconfiguration

This qualifies as **Medium Severity** under bug bounty criteria: "State inconsistencies requiring manual intervention" and "Limited protocol violations."

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability triggers during normal operational scenarios:

1. **State Sync Catchup** (Primary Trigger): When a validator catches up after being offline or joins the network, it processes historical blocks. The event notification system delivers all events from these blocks, including old `ObservedJWKsUpdated` events from previous epochs, to the current epoch's manager.

2. **Event Buffer During Epoch Transition**: Events buffered in the `EventNotificationListener` channel during epoch transitions could be delivered to the new epoch's manager.

The vulnerability is realistic but requires specific timing conditions. The defensive programming gap is evident from the contrast between RPC message validation (which checks epoch) and event processing (which does not).

## Recommendation

Add epoch validation in `EpochManager::process_onchain_event`:

```rust
fn process_onchain_event(&mut self, notification: EventNotification) -> Result<()> {
    let EventNotification {
        subscribed_events, ..
    } = notification;
    for event in subscribed_events {
        if let Ok(jwk_event) = ObservedJWKsUpdated::try_from(&event) {
            // Validate epoch before forwarding
            if Some(jwk_event.epoch) == self.epoch_state.as_ref().map(|s| s.epoch) {
                if let Some(tx) = self.jwk_updated_event_txs.as_ref() {
                    let _ = tx.push((), jwk_event);
                }
            }
        }
    }
    Ok(())
}
```

Additionally, consider adding monotonicity checks in `reset_with_on_chain_state` to reject state updates that decrease version numbers for the same issuer.

## Proof of Concept

No executable proof of concept was provided. A complete PoC would require:
1. Setting up a test network with JWK consensus enabled
2. Committing JWK updates in epoch N
3. Transitioning to epoch N+1 with updated JWKs
4. Simulating state sync catchup where epoch N events are replayed
5. Demonstrating that the epoch N+1 manager processes epoch N events and temporarily rolls back state

## Notes

The vulnerability is valid as a defensive programming issueâ€”the epoch field exists specifically to prevent cross-epoch confusion, yet it's completely ignored in event processing while being validated in RPC processing. However, the practical security impact may be limited depending on how keyless authentication transaction validation queries JWK data (local state vs. on-chain storage). The lack of a concrete PoC demonstrating actual security impact (beyond temporary state inconsistency) limits the severity assessment to Medium rather than High.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L119-124)
```text
    #[event]
    /// When `ObservedJWKs` is updated, this event is sent to resync the JWK consensus state in all validators.
    struct ObservedJWKsUpdated has drop, store {
        epoch: u64,
        jwks: AllProvidersJWKs,
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L140-143)
```rust
                jwk_updated = jwk_updated_rx.select_next_some() => {
                    let ObservedJWKsUpdated { jwks, .. } = jwk_updated;
                    this.reset_with_on_chain_state(jwks)
                },
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L231-292)
```rust
    pub fn reset_with_on_chain_state(&mut self, on_chain_state: AllProvidersJWKs) -> Result<()> {
        info!(
            epoch = self.epoch_state.epoch,
            "reset_with_on_chain_state starting."
        );
        let onchain_issuer_set: HashSet<Issuer> = on_chain_state
            .entries
            .iter()
            .map(|entry| entry.issuer.clone())
            .collect();
        let local_issuer_set: HashSet<Issuer> = self.states_by_issuer.keys().cloned().collect();

        for issuer in local_issuer_set.difference(&onchain_issuer_set) {
            info!(
                epoch = self.epoch_state.epoch,
                op = "delete",
                issuer = issuer.clone(),
                "reset_with_on_chain_state"
            );
        }

        self.states_by_issuer
            .retain(|issuer, _| onchain_issuer_set.contains(issuer));
        for on_chain_provider_jwks in on_chain_state.entries {
            let issuer = on_chain_provider_jwks.issuer.clone();
            let locally_cached = self
                .states_by_issuer
                .get(&on_chain_provider_jwks.issuer)
                .and_then(|s| s.on_chain.as_ref());
            if locally_cached == Some(&on_chain_provider_jwks) {
                // The on-chain update did not touch this provider.
                // The corresponding local state does not have to be reset.
                info!(
                    epoch = self.epoch_state.epoch,
                    op = "no-op",
                    issuer = issuer,
                    "reset_with_on_chain_state"
                );
            } else {
                let old_value = self.states_by_issuer.insert(
                    on_chain_provider_jwks.issuer.clone(),
                    PerProviderState::new(on_chain_provider_jwks),
                );
                let op = if old_value.is_some() {
                    "update"
                } else {
                    "insert"
                };
                info!(
                    epoch = self.epoch_state.epoch,
                    op = op,
                    issuer = issuer,
                    "reset_with_on_chain_state"
                );
            }
        }
        info!(
            epoch = self.epoch_state.epoch,
            "reset_with_on_chain_state finished."
        );
        Ok(())
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L234-263)
```rust
    pub fn reset_with_on_chain_state(&mut self, on_chain_state: AllProvidersJWKs) -> Result<()> {
        info!(
            epoch = self.epoch_state.epoch,
            "reset_with_on_chain_state starting."
        );

        let new_onchain_jwks = on_chain_state.indexed().context(
            "KeyLevelJWKManager::reset_with_on_chain_state failed at onchain state indexing",
        )?;
        // for an existing state entry (iss, kid) -> state, discard it unless `new_onchain_jwks[iss].version == self.onchain_jwks[iss].version`.
        self.states_by_key.retain(|(issuer, _), _| {
            new_onchain_jwks
                .get(issuer)
                .map(|jwks| jwks.version)
                .unwrap_or_default()
                == self
                    .onchain_jwks
                    .get(issuer)
                    .map(|jwks| jwks.version)
                    .unwrap_or_default()
        });

        self.onchain_jwks = new_onchain_jwks;

        info!(
            epoch = self.epoch_state.epoch,
            "reset_with_on_chain_state finished."
        );
        Ok(())
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L417-420)
```rust
                jwk_updated = jwk_updated_rx.select_next_some() => {
                    let ObservedJWKsUpdated { jwks, .. } = jwk_updated;
                    this.reset_with_on_chain_state(jwks)
                },
```

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L94-105)
```rust
    fn process_rpc_request(
        &mut self,
        peer_id: Author,
        rpc_request: IncomingRpcRequest,
    ) -> Result<()> {
        if Some(rpc_request.msg.epoch()) == self.epoch_state.as_ref().map(|s| s.epoch) {
            if let Some(tx) = &self.jwk_rpc_msg_tx {
                let _ = tx.push(peer_id, (peer_id, rpc_request));
            }
        }
        Ok(())
    }
```

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L108-120)
```rust
    fn process_onchain_event(&mut self, notification: EventNotification) -> Result<()> {
        let EventNotification {
            subscribed_events, ..
        } = notification;
        for event in subscribed_events {
            if let Ok(jwk_event) = ObservedJWKsUpdated::try_from(&event) {
                if let Some(tx) = self.jwk_updated_event_txs.as_ref() {
                    let _ = tx.push((), jwk_event);
                }
            }
        }
        Ok(())
    }
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L106-110)
```rust
        // Notify the event subscription service of the events
        event_subscription_service
            .lock()
            .notify_events(latest_synced_version, events)?;

```
