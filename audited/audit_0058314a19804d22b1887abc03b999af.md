# Audit Report

## Title
Executor Shard Indefinite Blocking Due to Missing Response Validation in Remote State Value Retrieval

## Summary
The `RemoteKVResponse` handling in the executor service lacks validation to ensure all requested state keys receive responses. When state keys are fetched in batches from the coordinator, if any batch response is incomplete or lost, executor shards will block indefinitely waiting for missing values, halting block execution permanently.

## Finding Description

The vulnerability exists in the remote state value retrieval mechanism used by sharded block execution. When an executor shard needs state values, it requests them in batches of 200 keys from the coordinator. [1](#0-0) 

Each requested key is immediately inserted with a "Waiting" status: [2](#0-1) 

The keys are then split into chunks and sent as separate `RemoteKVRequest` messages: [3](#0-2) 

When responses arrive, the `RemoteStateValueReceiver` processes them without validating that all requested keys are present: [4](#0-3) 

**Critical Issue**: There is no validation that `response.inner.len()` matches the number of requested keys, nor any timeout mechanism.

When a transaction attempts to read a state value that was never set, it blocks indefinitely on a condition variable: [5](#0-4) 

**Triggering Conditions**:

1. **Server Thread Panic**: The coordinator processes requests with multiple `.unwrap()` calls that can panic if state retrieval fails: [6](#0-5) 

If `get_state_value()` returns an error for any key in a batch, the thread panics without sending a response.

2. **Network Loss**: gRPC message loss or channel failures can cause responses to never arrive.

3. **Malicious Modification**: An attacker with code access could manually construct partial responses.

**Impact Cascade**:
- Keys remain in "Waiting" state forever
- Transactions accessing those keys block indefinitely  
- Executor shard never completes execution
- Coordinator blocks waiting for shard results: [7](#0-6) 

- **Entire block execution halts permanently**

This breaks the **Deterministic Execution** and **State Consistency** invariants, as different shards may complete execution at different times or hang entirely.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria:

- **Validator node slowdowns**: When executor shards block, validator nodes cannot process blocks, causing severe performance degradation
- **Significant protocol violations**: Violates the liveness guarantee of the consensus protocol
- **Partial loss of availability**: Affected validator nodes cannot participate in block execution

While not reaching Critical severity (no fund loss, no permanent network partition requiring hardfork), the impact is substantial as it can halt block processing on affected nodes until manual intervention.

## Likelihood Explanation

The likelihood is **Medium to High**:

**Realistic Triggering Scenarios**:
1. **State Corruption/Errors**: If the coordinator's `StateView` encounters any error (corrupted state, missing data, database issues), `get_state_value()` returns `Err`, causing the `.unwrap()` to panic
2. **Network Instability**: Temporary network issues during the critical window when responses are being sent
3. **Resource Exhaustion**: If the coordinator runs out of memory or threads while processing batched requests

**Required Conditions**:
- Sharded block execution is enabled (production feature)
- At least one batch request encounters an error or loss
- No timeout protection exists in the current implementation

**Attack Complexity**: Low - does not require attacker action; natural system failures can trigger it.

## Recommendation

Implement comprehensive validation and timeout mechanisms:

```rust
// In RemoteStateValueReceiver::handle_message()
fn handle_message(
    shard_id: ShardId,
    message: Message,
    state_view: Arc<RwLock<RemoteStateView>>,
    expected_keys: Arc<DashMap<StateKey, ()>>, // Track pending keys
) {
    let response: RemoteKVResponse = bcs::from_bytes(&message.data).unwrap();
    let state_view_lock = state_view.read().unwrap();
    
    // VALIDATION: Check response completeness
    for (state_key, state_value) in response.inner {
        if state_view_lock.has_state_key(&state_key) {
            state_view_lock.set_state_value(&state_key, state_value);
            expected_keys.remove(&state_key);
        } else {
            warn!("Received unexpected state key in response: {:?}", state_key);
        }
    }
    
    // Check for missing keys and set them to None after timeout
    if !expected_keys.is_empty() {
        warn!("Response missing {} expected keys", expected_keys.len());
        // Set missing keys to None to unblock waiters
        for key in expected_keys.iter() {
            state_view_lock.set_state_value(key.key(), None);
        }
    }
}

// In RemoteStateValue::get_value() - add timeout
pub fn get_value(&self) -> Option<StateValue> {
    let (lock, cvar) = &*self.value_condition;
    let mut status = lock.lock().unwrap();
    
    let timeout = Duration::from_secs(30);
    let result = cvar.wait_timeout_while(
        status,
        timeout,
        |s| matches!(s, RemoteValueStatus::Waiting)
    ).unwrap();
    
    status = result.0;
    
    if result.1.timed_out() {
        panic!("Timeout waiting for remote state value");
    }
    
    match &*status {
        RemoteValueStatus::Ready(value) => value.clone(),
        RemoteValueStatus::Waiting => unreachable!(),
    }
}
```

Additionally, improve error handling in the coordinator: [6](#0-5) 

Replace `.unwrap()` with proper error handling that still sends a response (with None values for failed keys).

## Proof of Concept

```rust
// Rust integration test demonstrating the vulnerability
#[test]
fn test_executor_shard_blocks_on_missing_response() {
    use std::sync::{Arc, Mutex};
    use std::thread;
    use std::time::Duration;
    
    // Setup: Create RemoteStateView with keys in Waiting state
    let state_view = Arc::new(RwLock::new(RemoteStateView::new()));
    let keys: Vec<StateKey> = (0..200)
        .map(|i| StateKey::raw(format!("key_{}", i).as_bytes().to_vec()))
        .collect();
    
    // Insert all keys with Waiting status
    for key in &keys {
        state_view.read().unwrap().insert_state_key(key.clone());
    }
    
    // Simulate partial response - only set first 100 keys
    let partial_response: Vec<(StateKey, Option<StateValue>)> = keys
        .iter()
        .take(100)
        .map(|k| (k.clone(), Some(StateValue::new_legacy(vec![1, 2, 3].into()))))
        .collect();
    
    for (key, value) in partial_response {
        state_view.read().unwrap().set_state_value(&key, value);
    }
    
    // Try to access a key that was NOT in the response (key_150)
    let state_view_clone = state_view.clone();
    let blocked = Arc::new(Mutex::new(false));
    let blocked_clone = blocked.clone();
    
    let handle = thread::spawn(move || {
        let key = StateKey::raw("key_150".as_bytes().to_vec());
        // This will block indefinitely!
        let _ = state_view_clone.read().unwrap().get_state_value(&key);
        *blocked_clone.lock().unwrap() = true;
    });
    
    // Wait to see if the thread completes
    thread::sleep(Duration::from_secs(5));
    
    // Verify the thread is still blocked
    assert_eq!(*blocked.lock().unwrap(), false, 
               "Thread should be blocked waiting for missing state value");
    
    // In production, this would hang the executor shard indefinitely
}
```

**Notes**:
- The vulnerability requires no attacker action and can occur naturally through system failures
- The 80MB gRPC message size limit means responses for large state key sets will exceed limits, but this typically causes total failure rather than partial responses
- The most realistic exploitation path is through coordinator state retrieval errors causing thread panics
- Current implementation has no timeout protection at any level of the remote state value retrieval pipeline

### Citations

**File:** execution/executor-service/src/remote_state_view.rs (L27-27)
```rust
pub static REMOTE_STATE_KEY_BATCH_SIZE: usize = 200;
```

**File:** execution/executor-service/src/remote_state_view.rs (L51-55)
```rust
    pub fn insert_state_key(&self, state_key: StateKey) {
        self.state_values
            .entry(state_key)
            .or_insert(RemoteStateValue::waiting());
    }
```

**File:** execution/executor-service/src/remote_state_view.rs (L136-144)
```rust
        state_keys
            .chunks(REMOTE_STATE_KEY_BATCH_SIZE)
            .map(|state_keys_chunk| state_keys_chunk.to_vec())
            .for_each(|state_keys| {
                let sender = kv_tx.clone();
                thread_pool.spawn(move || {
                    Self::send_state_value_request(shard_id, sender, state_keys);
                });
            });
```

**File:** execution/executor-service/src/remote_state_view.rs (L266-271)
```rust
        response
            .inner
            .into_iter()
            .for_each(|(state_key, state_value)| {
                state_view_lock.set_state_value(&state_key, state_value);
            });
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/remote_state_value.rs (L29-38)
```rust
    pub fn get_value(&self) -> Option<StateValue> {
        let (lock, cvar) = &*self.value_condition;
        let mut status = lock.lock().unwrap();
        while let RemoteValueStatus::Waiting = *status {
            status = cvar.wait(status).unwrap();
        }
        match &*status {
            RemoteValueStatus::Ready(value) => value.clone(),
            RemoteValueStatus::Waiting => unreachable!(),
        }
```

**File:** execution/executor-service/src/remote_state_view_service.rs (L95-107)
```rust
        let resp = state_keys
            .into_iter()
            .map(|state_key| {
                let state_value = state_view
                    .read()
                    .unwrap()
                    .as_ref()
                    .unwrap()
                    .get_state_value(&state_key)
                    .unwrap();
                (state_key, state_value)
            })
            .collect_vec();
```

**File:** execution/executor-service/src/remote_executor_client.rs (L163-172)
```rust
    fn get_output_from_shards(&self) -> Result<Vec<Vec<Vec<TransactionOutput>>>, VMStatus> {
        trace!("RemoteExecutorClient Waiting for results");
        let mut results = vec![];
        for rx in self.result_rxs.iter() {
            let received_bytes = rx.recv().unwrap().to_bytes();
            let result: RemoteExecutionResult = bcs::from_bytes(&received_bytes).unwrap();
            results.push(result.inner?);
        }
        Ok(results)
    }
```
