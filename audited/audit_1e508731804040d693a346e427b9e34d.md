# Audit Report

## Title
Information Disclosure via Serialized Error Messages in Storage Service Network Protocol

## Summary
The storage service's `Error` enum serializes internal error messages containing filesystem paths, database details, and RocksDB error information, then transmits them to network peers (including untrusted public full nodes) via BCS serialization. This enables reconnaissance attacks by revealing server internal structure.

## Finding Description

The vulnerability exists in the error handling flow of the state-sync storage service:

**Step 1: Internal errors are converted to strings with detailed information** [1](#0-0) 

When `AptosDbError` occurs (which can include RocksDB errors with filesystem paths), it's converted to `Error::StorageErrorEncountered` using `.to_string()`, preserving all internal details. [2](#0-1) 

Similarly, `anyhow::Error` (which can contain full error chains) is converted using `.to_string()`.

**Step 2: RocksDB errors contain filesystem paths** [3](#0-2) 

RocksDB errors (including `IOError` which often contains filesystem paths) are converted to `AptosDbError` by calling `rocksdb_err.to_string()`, which preserves the full error message including any path information.

**Step 3: Errors are converted to network-serializable format** [4](#0-3) 

Internal `Error` types are converted to `StorageServiceError::InternalError(error.to_string())` which is then sent to network peers.

**Step 4: Errors are serialized and transmitted** [5](#0-4) 

The `StorageServiceMessage` containing the error is serialized using BCS and sent as network response.

**Step 5: All network peers (including untrusted) can receive these errors** [6](#0-5) 

The request moderator only ignores public network peers after they exceed the invalid request threshold - but they still receive error responses before being ignored. Validators and VFNs always receive responses.

## Impact Explanation

Per the Aptos bug bounty program, this falls under **Low Severity** (up to $1,000) as a "Minor information leak." 

While the leaked information (database paths, internal structure, RocksDB details) could aid attackers in reconnaissance, it does not directly cause:
- Loss of funds
- Consensus violations  
- State inconsistencies
- Network availability issues

The information disclosure is limited to implementation details that may help plan future attacks but doesn't directly compromise system security.

## Likelihood Explanation

**High likelihood** - Any network peer can trigger this by:
1. Connecting as a public full node
2. Sending requests that cause storage errors (e.g., requesting non-existent data, causing timeouts)
3. Receiving detailed error messages in responses

No special access or conditions are required beyond network connectivity.

## Recommendation

Sanitize error messages before sending them to network peers by removing internal implementation details:

```rust
impl From<aptos_storage_interface::AptosDbError> for Error {
    fn from(error: aptos_storage_interface::AptosDbError) -> Self {
        // Sanitize error message - only include error type, not details
        Error::StorageErrorEncountered(
            match error {
                AptosDbError::NotFound(_) => "Data not found".to_string(),
                AptosDbError::TooManyRequested(_, _) => "Too many items requested".to_string(),
                AptosDbError::MissingRootError(_) => "Missing state root".to_string(),
                _ => "Storage error occurred".to_string(),
            }
        )
    }
}

impl From<anyhow::Error> for Error {
    fn from(_error: anyhow::Error) -> Self {
        // Don't leak error chain details
        Error::UnexpectedErrorEncountered("Internal error occurred".to_string())
    }
}
```

## Proof of Concept

```rust
// This test demonstrates that error messages with internal details
// are serialized and could be sent to network peers
#[test]
fn test_error_serialization_leaks_internal_details() {
    use state_sync_storage_service_server::error::Error;
    use aptos_storage_interface::AptosDbError;
    
    // Simulate a RocksDB error with filesystem path
    let db_error = AptosDbError::OtherRocksDbError(
        "IO error: No such file or directory: /var/lib/aptos/db/ledger.sst".to_string()
    );
    
    // Convert to storage service error
    let server_error = Error::from(db_error);
    
    // Serialize (as would happen when sending to network peer)
    let serialized = bcs::to_bytes(&server_error).unwrap();
    
    // Deserialize on receiving side
    let deserialized: Error = bcs::from_bytes(&serialized).unwrap();
    
    // Verify that filesystem path is included in the error message
    match deserialized {
        Error::StorageErrorEncountered(msg) => {
            assert!(msg.contains("/var/lib/aptos/db/"));
            println!("Leaked internal path: {}", msg);
        },
        _ => panic!("Wrong error type"),
    }
}
```

**Notes:**
- This is a valid information disclosure vulnerability but falls under Low Severity per Aptos bounty criteria
- The serialized `Error` enum exposes internal implementation details through the `String` fields in each variant
- Mitigation requires sanitizing error messages before network transmission while preserving enough information for legitimate debugging

### Citations

**File:** state-sync/storage-service/server/src/error.rs (L37-40)
```rust
impl From<anyhow::Error> for Error {
    fn from(error: anyhow::Error) -> Self {
        Error::UnexpectedErrorEncountered(error.to_string())
    }
```

**File:** state-sync/storage-service/server/src/error.rs (L43-46)
```rust
impl From<aptos_storage_interface::AptosDbError> for Error {
    fn from(error: aptos_storage_interface::AptosDbError) -> Self {
        Error::StorageErrorEncountered(error.to_string())
    }
```

**File:** storage/schemadb/src/lib.rs (L389-407)
```rust
fn to_db_err(rocksdb_err: rocksdb::Error) -> AptosDbError {
    match rocksdb_err.kind() {
        ErrorKind::Incomplete => AptosDbError::RocksDbIncompleteResult(rocksdb_err.to_string()),
        ErrorKind::NotFound
        | ErrorKind::Corruption
        | ErrorKind::NotSupported
        | ErrorKind::InvalidArgument
        | ErrorKind::IOError
        | ErrorKind::MergeInProgress
        | ErrorKind::ShutdownInProgress
        | ErrorKind::TimedOut
        | ErrorKind::Aborted
        | ErrorKind::Busy
        | ErrorKind::Expired
        | ErrorKind::TryAgain
        | ErrorKind::CompactionTooLarge
        | ErrorKind::ColumnFamilyDropped
        | ErrorKind::Unknown => AptosDbError::OtherRocksDbError(rocksdb_err.to_string()),
    }
```

**File:** state-sync/storage-service/server/src/handler.rs (L196-202)
```rust
        process_result.map_err(|error| match error {
            Error::InvalidRequest(error) => StorageServiceError::InvalidRequest(error),
            Error::TooManyInvalidRequests(error) => {
                StorageServiceError::TooManyInvalidRequests(error)
            },
            error => StorageServiceError::InternalError(error.to_string()),
        })
```

**File:** state-sync/storage-service/server/src/network.rs (L106-112)
```rust
    pub fn send(self, response: Result<StorageServiceResponse>) {
        let msg = StorageServiceMessage::Response(response);
        let result = bcs::to_bytes(&msg)
            .map(Bytes::from)
            .map_err(RpcError::BcsError);
        let _ = self.response_tx.send(result);
    }
```

**File:** state-sync/storage-service/server/src/moderator.rs (L49-68)
```rust
    /// Note: we only ignore peers on the public network.
    pub fn increment_invalid_request_count(&mut self, peer_network_id: &PeerNetworkId) {
        // Increment the invalid request count
        self.invalid_request_count += 1;

        // If the peer is a PFN and has sent too many invalid requests, start ignoring it
        if self.ignore_start_time.is_none()
            && peer_network_id.network_id().is_public_network()
            && self.invalid_request_count >= self.max_invalid_requests
        {
            // TODO: at some point we'll want to terminate the connection entirely

            // Start ignoring the peer
            self.ignore_start_time = Some(self.time_service.now());

            // Log the fact that we're now ignoring the peer
            warn!(LogSchema::new(LogEntry::RequestModeratorIgnoredPeer)
                .peer_network_id(peer_network_id)
                .message("Ignoring peer due to too many invalid requests!"));
        }
```
