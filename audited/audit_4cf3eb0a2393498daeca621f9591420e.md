# Audit Report

## Title
SSRF Vulnerability via Localhost/Loopback Address Registration in Node Health Checker

## Summary
The `extract_network_address` function in the node-checker client and the validator address registration system lack validation to prevent localhost and loopback addresses. This enables a Server-Side Request Forgery (SSRF) attack where malicious validators can register localhost addresses on-chain, causing the Node Health Checker (NHC) service to connect to its own internal services instead of the validator's actual node.

## Finding Description

The vulnerability exists across three layers of the Aptos node-checker infrastructure:

**1. On-Chain Address Registration (No Validation)**

The `initialize_validator` and `update_network_and_fullnode_addresses` functions accept arbitrary network addresses without validating against localhost or loopback addresses. [1](#0-0) [2](#0-1) 

**2. Address Extraction (No Localhost Check)**

The `extract_network_address` function converts NetworkAddress to URL without checking if the resolved IP is a loopback address (127.0.0.0/8, ::1, localhost DNS). [3](#0-2) 

**3. NHC Server (No Input Validation)**

The NHC API endpoint accepts the `node_url` parameter directly without validating against localhost/loopback addresses before establishing connections. [4](#0-3) 

**Attack Flow:**

1. Malicious validator calls `stake::update_network_and_fullnode_addresses` with a crafted address like `/ip4/127.0.0.1/tcp/6180/noise-ik/<pubkey>/handshake/1` or `/dns/localhost/tcp/6180/...`
2. Node-checker client reads validator addresses from on-chain ValidatorSet data
3. `extract_network_address` converts the address to `http://127.0.0.1` without validation
4. Node-checker client sends this URL to NHC as a query parameter: `GET /check_node?node_url=http://127.0.0.1&...`
5. NHC creates a NodeAddress and attempts HTTP connections to localhost on the NHC server itself
6. NHC connects to its own internal services, exposing them to enumeration/exploitation [5](#0-4) [6](#0-5) 

The NodeAddress struct directly uses the provided URL to create HTTP clients without localhost validation: [7](#0-6) 

## Impact Explanation

**Medium Severity** per Aptos bug bounty criteria:

1. **SSRF Attack Surface**: Attackers can force the NHC service to connect to arbitrary localhost ports, potentially accessing:
   - Internal admin interfaces not exposed to the public internet
   - Internal monitoring/metrics endpoints
   - Database interfaces running on localhost
   - Other internal microservices

2. **State Inconsistencies**: False health check results would be recorded in BigQuery and on-chain validator reputation systems, as the NHC would be checking its own services rather than actual validator nodes.

3. **Information Disclosure**: Error messages from localhost connections could reveal internal service configurations, port numbers, and software versions.

4. **Bypass of Network Security Controls**: Firewalls and network segmentation protecting internal services are bypassed since connections originate from the trusted NHC server itself.

While this doesn't directly affect blockchain consensus or steal funds, it represents a significant infrastructure security vulnerability that could facilitate further attacks on the node-checker infrastructure.

## Likelihood Explanation

**High Likelihood:**

1. **Low Attack Barrier**: Any validator can register network addresses on-chain through standard staking operations - no special privileges required beyond being a registered validator.

2. **Easy Execution**: The attack requires only a single on-chain transaction to `stake::update_network_and_fullnode_addresses` with a localhost address.

3. **No Detection Mechanisms**: Currently no validation or monitoring exists to detect localhost addresses in validator configurations.

4. **Automatic Triggering**: Once registered, the node-checker automatically processes these addresses periodically, triggering the SSRF without further attacker interaction.

## Recommendation

Implement multi-layered validation to reject localhost and loopback addresses:

**Layer 1: Add validation in `extract_network_address`:**

```rust
pub fn extract_network_address(network_address: &NetworkAddress) -> Result<(Url, u16)> {
    let mut socket_addrs = network_address
        .to_socket_addrs()
        .with_context(|| format!("Failed to parse network address as SocketAddr..."))?;
    let socket_addr = socket_addrs
        .next()
        .ok_or_else(|| anyhow::anyhow!("No socket address found"))?;
    
    match socket_addr {
        SocketAddr::V4(addr) => {
            // Reject localhost and loopback addresses
            let ip = addr.ip();
            if ip.is_loopback() || ip.is_private() || ip.is_unspecified() {
                return Err(anyhow::anyhow!(
                    "Localhost, loopback, and private IP addresses are not allowed: {}",
                    ip
                ));
            }
            Ok((
                Url::parse(&format!("http://{}", ip))
                    .context("Failed to parse address as URL")?,
                addr.port(),
            ))
        },
        SocketAddr::V6(addr) => {
            let ip = addr.ip();
            if ip.is_loopback() || ip.is_unspecified() {
                return Err(anyhow::anyhow!(
                    "Localhost and loopback IPv6 addresses are not allowed: {}",
                    addr
                ));
            }
            Err(anyhow::anyhow!(
                "We do not support IPv6 addresses: {}",
                addr
            ))
        },
    }
}
```

**Layer 2: Add validation in NHC API endpoint:**

```rust
#[oai(path = "/check", method = "get")]
async fn check(
    &self,
    node_url: Query<Url>,
    // ... other parameters
) -> poem::Result<Json<CheckSummary>> {
    // Validate URL host is not localhost/loopback
    if let Some(host) = node_url.0.host_str() {
        if host == "localhost" 
            || host == "127.0.0.1" 
            || host.starts_with("127.")
            || host == "::1"
            || host == "0.0.0.0"
            || host == "::" {
            return Err(poem::Error::from((
                StatusCode::BAD_REQUEST,
                anyhow!("Localhost and loopback addresses are not allowed"),
            )));
        }
    }
    
    // Continue with existing logic...
}
```

**Layer 3: Consider on-chain validation** (optional, but defense-in-depth):

Add a native function or Move module to validate network addresses before storing them in ValidatorConfig. This prevents malicious addresses from being registered in the first place.

## Proof of Concept

**Step 1: Register a malicious validator address (Move transaction)**

```move
script {
    use aptos_framework::stake;
    use std::vector;
    
    fun exploit_ssrf(operator: &signer) {
        let pool_address = @0x123; // Validator pool address
        
        // Craft localhost address: /ip4/127.0.0.1/tcp/6180/noise-ik/<pubkey>/handshake/1
        // This would be BCS-encoded NetworkAddress bytes
        let malicious_fullnode_address = vector::empty<u8>();
        // ... append BCS-encoded localhost NetworkAddress ...
        
        stake::update_network_and_fullnode_addresses(
            operator,
            pool_address,
            vector::empty<u8>(), // Keep network_addresses unchanged
            malicious_fullnode_address // Inject localhost as fullnode address
        );
    }
}
```

**Step 2: Trigger node-checker**

When the node-checker runs:
```bash
fn-check-client check-validator-fullnodes \
    --node-address https://mainnet.aptoslabs.com \
    --nhc-address http://nhc-service.internal:8080 \
    --nhc-baseline-config-name devnet_fullnode
```

**Step 3: Observe SSRF**

The node-checker will:
1. Extract `http://127.0.0.1` from the on-chain address
2. Send request: `GET http://nhc-service.internal:8080/check_node?node_url=http://127.0.0.1&api_port=8080&...`
3. NHC will attempt to connect to `http://127.0.0.1:8080` on the NHC server itself
4. Any service running on NHC's localhost:8080 becomes accessible to the attacker through error messages and health check responses

**Expected Result**: NHC connects to its own localhost services, bypassing network security controls and potentially exposing internal infrastructure details.

---

## Notes

This vulnerability demonstrates a classic SSRF attack vector where user-controlled input (validator-registered network addresses) is used to make server-side requests without adequate validation. The multi-hop nature (on-chain storage → node-checker client → NHC service) makes it particularly insidious as each component assumes the previous layer has validated the input.

The fix must be implemented at multiple layers to provide defense-in-depth, as relying on a single validation point could be bypassed through encoding tricks, DNS rebinding, or other SSRF bypass techniques.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L670-692)
```text
    public entry fun initialize_validator(
        account: &signer,
        consensus_pubkey: vector<u8>,
        proof_of_possession: vector<u8>,
        network_addresses: vector<u8>,
        fullnode_addresses: vector<u8>,
    ) acquires AllowedValidators {
        check_stake_permission(account);
        // Checks the public key has a valid proof-of-possession to prevent rogue-key attacks.
        let pubkey_from_pop = &bls12381::public_key_from_bytes_with_pop(
            consensus_pubkey,
            &proof_of_possession_from_bytes(proof_of_possession)
        );
        assert!(option::is_some(pubkey_from_pop), error::invalid_argument(EINVALID_PUBLIC_KEY));

        initialize_owner(account);
        move_to(account, ValidatorConfig {
            consensus_pubkey,
            network_addresses,
            fullnode_addresses,
            validator_index: 0,
        });
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L956-995)
```text
        operator: &signer,
        pool_address: address,
        new_network_addresses: vector<u8>,
        new_fullnode_addresses: vector<u8>,
    ) acquires StakePool, ValidatorConfig {
        check_stake_permission(operator);
        assert_reconfig_not_in_progress();
        assert_stake_pool_exists(pool_address);
        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        assert!(signer::address_of(operator) == stake_pool.operator_address, error::unauthenticated(ENOT_OPERATOR));
        assert!(exists<ValidatorConfig>(pool_address), error::not_found(EVALIDATOR_CONFIG));
        let validator_info = borrow_global_mut<ValidatorConfig>(pool_address);
        let old_network_addresses = validator_info.network_addresses;
        validator_info.network_addresses = new_network_addresses;
        let old_fullnode_addresses = validator_info.fullnode_addresses;
        validator_info.fullnode_addresses = new_fullnode_addresses;

        if (std::features::module_event_migration_enabled()) {
            event::emit(
                UpdateNetworkAndFullnodeAddresses {
                    pool_address,
                    old_network_addresses,
                    new_network_addresses,
                    old_fullnode_addresses,
                    new_fullnode_addresses,
                },
            );
        } else {
            event::emit_event(
                &mut stake_pool.update_network_and_fullnode_addresses_events,
                UpdateNetworkAndFullnodeAddressesEvent {
                    pool_address,
                    old_network_addresses,
                    new_network_addresses,
                    old_fullnode_addresses,
                    new_fullnode_addresses,
                },
            );
        };
    }
```

**File:** ecosystem/node-checker/fn-check-client/src/helpers.rs (L12-30)
```rust
pub fn extract_network_address(network_address: &NetworkAddress) -> Result<(Url, u16)> {
    let mut socket_addrs = network_address
        .to_socket_addrs()
        .with_context(|| format!("Failed to parse network address as SocketAddr, this might imply that the domain name doesn't resolve to an IP: {}", network_address))?;
    let socket_addr = socket_addrs
        .next()
        .ok_or_else(|| anyhow::anyhow!("No socket address found"))?;
    match socket_addr {
        SocketAddr::V4(addr) => Ok((
            Url::parse(&format!("http://{}", addr.ip()))
                .context("Failed to parse address as URL")?,
            addr.port(),
        )),
        SocketAddr::V6(addr) => Err(anyhow::anyhow!(
            "We do not not support IPv6 addresses: {}",
            addr
        )),
    }
}
```

**File:** ecosystem/node-checker/src/server/api.rs (L81-92)
```rust
        let target_node_address = NodeAddress::new(
            node_url.0,
            api_port.0,
            metrics_port.0,
            noise_port.0,
            public_key,
        );

        let complete_evaluation_result = baseline_configuration
            .runner
            .run(&target_node_address)
            .await;
```

**File:** ecosystem/node-checker/fn-check-client/src/get_vfns.rs (L115-131)
```rust
                let (node_url, noise_port) = match extract_network_address(&vfn_address) {
                    Ok(result) => result,
                    Err(e) => {
                        invalid_node_address_results
                            .entry(*account_address)
                            .or_insert_with(Vec::new)
                            .push(SingleCheck::new(
                                SingleCheckResult::IncompleteNetworkAddress(
                                    IncompleteNetworkAddress {
                                        message: format!("{:#}", e),
                                    },
                                ),
                                None,
                            ));
                        continue;
                    },
                };
```

**File:** ecosystem/node-checker/fn-check-client/src/check.rs (L199-202)
```rust
        let mut params = HashMap::new();
        params.insert("node_url", node_url.to_string());
        params.insert("api_port", api_port.to_string());
        params.insert("noise_port", noise_port.to_string());
```

**File:** ecosystem/node-checker/src/configuration/node_address.rs (L107-115)
```rust
    pub fn get_api_client(&self, timeout: Duration) -> Result<AptosRestClient> {
        let client = reqwest::ClientBuilder::new()
            .timeout(timeout)
            .cookie_provider(self.cookie_store.clone())
            .build()
            .unwrap();

        Ok(AptosRestClient::from((client, self.get_api_url()?)))
    }
```
