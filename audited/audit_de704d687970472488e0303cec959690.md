# Audit Report

## Title
CompilationMetadata Deserialization Bypass Allows Unstable Bytecode Deployment to Mainnet

## Summary
An attacker can deploy bytecode compiled with experimental (unstable) compiler and language versions to mainnet by manipulating the `unstable` flag in `CompilationMetadata`. The VM's validation logic only checks the boolean flag without independently verifying it matches the actual compiler/language version strings, enabling a complete bypass of the mainnet stability protection mechanism.

## Finding Description

The Aptos blockchain enforces a critical security policy: code compiled with unstable (experimental) compiler or language versions must not be deployed to mainnet. This policy is implemented through the `CompilationMetadata` struct and validation in `AptosVM::reject_unstable_bytecode()`. [1](#0-0) 

The `CompilationMetadata` struct contains three fields: an `unstable` boolean flag and two free-form version strings. When properly constructed via the `new()` method, the unstable flag is correctly set based on whether the compiler or language versions are unstable: [2](#0-1) 

However, the struct derives `Deserialize` without custom validation, meaning it can be deserialized with arbitrary field values that don't match the invariant that `unstable` should equal `compiler_version.unstable() || language_version.unstable()`.

The mainnet validation check only examines the boolean flag: [3](#0-2) 

The check at line 1746 only validates `metadata.unstable` without parsing or validating the `compiler_version` and `language_version` strings against their claimed stability status.

**Attack Path:**

1. Attacker compiles Move code using an unstable compiler version (e.g., `CompilerVersion::V2_1`) or unstable language version (e.g., `LanguageVersion::V2_5`)

2. The compiler correctly generates bytecode with `CompilationMetadata` where `unstable: true`

3. Attacker deserializes the compiled module bytecode

4. Attacker modifies the `CompilationMetadata` to set `unstable: false` while keeping version strings like `"2.1-unstable"` or `"2.5-unstable"`

5. Attacker re-serializes the modified bytecode and submits it for deployment to mainnet

6. The `reject_unstable_bytecode()` check passes because `metadata.unstable == false`

7. Unstable bytecode is successfully deployed to mainnet, bypassing the intended protection

The version string fields are never independently validated during deployment: [4](#0-3) 

This code only verifies the metadata can be deserialized, not that its contents are internally consistent.

## Impact Explanation

This vulnerability constitutes a **High Severity** issue per Aptos bug bounty criteria as it represents a **significant protocol violation**.

The security boundary being bypassed is explicitly documented in the code: [5](#0-4) 

Unstable versions include experimental features that have not undergone full production testing: [6](#0-5) 

The consequences include:

1. **Deployment of untested compiler implementations** with potential code generation bugs
2. **Experimental language features** (public structs in V2.4, runtime assertion checking in V2.5) that may have undiscovered security vulnerabilities
3. **Consensus risk** if unstable features exhibit non-deterministic behavior across different node implementations
4. **Undermining production stability guarantees** that mainnet provides to users and developers

## Likelihood Explanation

**Likelihood: High**

The attack requires only:
- Basic knowledge of BCS serialization/deserialization
- Ability to compile Move code
- No privileged access or validator cooperation
- Standard transaction submission capability

The vulnerability is deterministic and always succeeds because:
1. There is no validation linking the `unstable` flag to version strings
2. The check happens during normal module publication flow
3. No additional cryptographic or consensus barriers exist

## Recommendation

Add validation during metadata deserialization to ensure the `unstable` flag matches the stability status of the version strings. Implement a custom deserializer or add a validation check:

**Option 1: Add validation in `check_metadata_format()`:**

```rust
// In types/src/vm/module_metadata.rs, modify check_metadata_format()
} else if data.key == *COMPILATION_METADATA_KEY {
    if compilation_key_exist {
        return Err(MalformedError::DuplicateKey);
    }
    compilation_key_exist = true;
    let metadata = bcs::from_bytes::<CompilationMetadata>(&data.value)
        .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
    
    // NEW: Validate consistency
    let compiler_version = CompilerVersion::from_str(&metadata.compiler_version)
        .map_err(|e| MalformedError::DeserializedError(data.key.clone(), 
            bcs::Error::Custom(e.to_string())))?;
    let language_version = LanguageVersion::from_str(&metadata.language_version)
        .map_err(|e| MalformedError::DeserializedError(data.key.clone(),
            bcs::Error::Custom(e.to_string())))?;
    
    let expected_unstable = compiler_version.unstable() || language_version.unstable();
    if metadata.unstable != expected_unstable {
        return Err(MalformedError::DeserializedError(
            data.key.clone(),
            bcs::Error::Custom(format!(
                "unstable flag mismatch: got {}, expected {} based on versions {} and {}",
                metadata.unstable, expected_unstable, 
                metadata.compiler_version, metadata.language_version
            ))
        ));
    }
}
```

**Option 2: Add a validation method to `CompilationMetadata`:**

```rust
// In third_party/move/move-model/src/metadata.rs
impl CompilationMetadata {
    pub fn validate(&self) -> anyhow::Result<()> {
        let compiler_version = self.compiler_version()?;
        let language_version = self.language_version()?;
        let expected_unstable = compiler_version.unstable() || language_version.unstable();
        
        if self.unstable != expected_unstable {
            bail!(
                "CompilationMetadata validation failed: unstable flag is {} but should be {} \
                 based on compiler version {} and language version {}",
                self.unstable,
                expected_unstable,
                self.compiler_version,
                self.language_version
            );
        }
        Ok(())
    }
}
```

Then call this validation in `check_metadata_format()` and `reject_unstable_bytecode()`.

## Proof of Concept

```rust
use move_binary_format::CompiledModule;
use move_model::metadata::{CompilationMetadata, CompilerVersion, LanguageVersion};
use move_core_types::metadata::Metadata;

fn exploit_unstable_bypass() {
    // Step 1: Create metadata as if compiled with unstable version
    let unstable_metadata = CompilationMetadata::new(
        CompilerVersion::V2_1,  // Unstable compiler
        LanguageVersion::V2_5,  // Unstable language
    );
    
    // Verify it's correctly marked as unstable
    assert_eq!(unstable_metadata.unstable, true);
    assert_eq!(unstable_metadata.compiler_version, "2.1-unstable");
    assert_eq!(unstable_metadata.language_version, "2.5-unstable");
    
    // Step 2: Serialize the metadata
    let serialized = bcs::to_bytes(&unstable_metadata).unwrap();
    
    // Step 3: Deserialize and modify the unstable flag
    let mut malicious_metadata: CompilationMetadata = 
        bcs::from_bytes(&serialized).unwrap();
    malicious_metadata.unstable = false;  // LIE about stability
    
    // Step 4: Re-serialize the malicious metadata
    let malicious_serialized = bcs::to_bytes(&malicious_metadata).unwrap();
    
    // Step 5: Create module metadata with the malicious data
    let metadata = Metadata {
        key: b"compilation_metadata".to_vec(),
        value: malicious_serialized,
    };
    
    // This metadata would pass reject_unstable_bytecode() on mainnet
    // because metadata.unstable == false
    // but it claims to be compiled with unstable versions:
    assert_eq!(malicious_metadata.unstable, false);  // Passes mainnet check
    assert_eq!(malicious_metadata.compiler_version, "2.1-unstable");  // Actually unstable!
    assert_eq!(malicious_metadata.language_version, "2.5-unstable");  // Actually unstable!
    
    println!("EXPLOIT SUCCESS: Unstable bytecode with falsified metadata");
    println!("Would bypass mainnet check despite being compiled with:");
    println!("  Compiler: {}", malicious_metadata.compiler_version);
    println!("  Language: {}", malicious_metadata.language_version);
}
```

## Notes

This vulnerability exists because `CompilationMetadata` treats the `unstable` flag as the source of truth rather than deriving it from the version strings during validation. The fix should ensure the flag always matches the stability status of the versions, making it impossible to lie about stability while preserving version information for debugging and auditing purposes.

### Citations

**File:** third_party/move/move-model/src/metadata.rs (L49-62)
```rust
#[derive(Debug, Clone, Serialize, Deserialize, Default)]
pub struct CompilationMetadata {
    /// A flag indicating whether, at time of creation, the compilation
    /// result was considered as unstable. Unstable code may have restrictions
    /// for deployment on production networks. This flag is true if either the
    /// compiler or language versions are unstable.
    pub unstable: bool,
    /// The version of the compiler, as a string. See
    /// `CompilationVersion::from_str` for supported version strings.
    pub compiler_version: String,
    /// The version of the language, as a string. See
    /// `LanguageVersion::from_str` for supported version strings.
    pub language_version: String,
}
```

**File:** third_party/move/move-model/src/metadata.rs (L64-71)
```rust
impl CompilationMetadata {
    pub fn new(compiler_version: CompilerVersion, language_version: LanguageVersion) -> Self {
        Self {
            compiler_version: compiler_version.to_string(),
            language_version: language_version.to_string(),
            unstable: compiler_version.unstable() || language_version.unstable(),
        }
    }
```

**File:** third_party/move/move-model/src/metadata.rs (L286-294)
```rust
    /// Whether the language version is unstable. An unstable version
    /// should not be allowed on production networks.
    pub const fn unstable(self) -> bool {
        use LanguageVersion::*;
        match self {
            V1 | V2_0 | V2_1 | V2_2 | V2_3 => false,
            V2_4 | V2_5 => true,
        }
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1742-1757)
```rust
    fn reject_unstable_bytecode(&self, modules: &[CompiledModule]) -> VMResult<()> {
        if self.chain_id().is_mainnet() {
            for module in modules {
                if let Some(metadata) = get_compilation_metadata(module) {
                    if metadata.unstable {
                        return Err(PartialVMError::new(StatusCode::UNSTABLE_BYTECODE_REJECTED)
                            .with_message(
                                "code marked unstable is not published on mainnet".to_string(),
                            )
                            .finish(Location::Undefined));
                    }
                }
            }
        }
        Ok(())
    }
```

**File:** types/src/vm/module_metadata.rs (L270-276)
```rust
        } else if data.key == *COMPILATION_METADATA_KEY {
            if compilation_key_exist {
                return Err(MalformedError::DuplicateKey);
            }
            compilation_key_exist = true;
            bcs::from_bytes::<CompilationMetadata>(&data.value)
                .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
```
