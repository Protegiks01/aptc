# Audit Report

## Title
Missing SecurityEvent Variants for Validator State Root Divergence Detection

## Summary
The `SecurityEvent` enum lacks dedicated variants for detecting when different validators produce conflicting state root hashes for the same block, preventing proper security monitoring of execution non-determinism and state corruption attacks.

## Finding Description

The Aptos consensus protocol relies on **deterministic execution** as a critical invariant: all honest validators must produce identical state roots (`executed_state_id`) when executing the same block. [1](#0-0) 

When validators execute blocks, they include the computed state root in the `BlockInfo` structure, which becomes part of their vote. [2](#0-1) 

The consensus vote aggregation mechanism groups votes by their `LedgerInfo` digest. If validators produce different state roots for the same block, their votes will have different digests and be grouped separately. [3](#0-2) 

**The Security Gap:**

While the system detects when a SINGLE validator equivocates (votes twice with different values), there is NO `SecurityEvent` for when DIFFERENT validators disagree on execution results. [4](#0-3) 

Evidence of state divergence detection exists in regular error logs:
- [5](#0-4) 
- [6](#0-5) 
- [7](#0-6) 

However, these use standard logging (`error!`, `warn!`) rather than `SecurityEvent`, making them invisible to security monitoring systems specifically watching for Byzantine behavior.

## Impact Explanation

This represents a **Medium Severity** monitoring gap rather than a directly exploitable vulnerability. While it doesn't enable direct attacks, it significantly impairs the network's ability to detect and respond to:

1. **Execution non-determinism bugs** in the Move VM that could lead to consensus splits
2. **State corruption attacks** where malicious actors attempt to corrupt validator databases
3. **Subtle Byzantine behavior** where validators diverge in their execution results

The impact on observability is critical because consensus failures from state divergence appear identical to network partitions or validator unavailability, making root cause analysis extremely difficult.

## Likelihood Explanation

This monitoring gap affects ALL consensus operations continuously. Any occurrence of:
- Move VM bugs causing non-deterministic execution
- Memory corruption in validator state databases  
- Sophisticated attacks targeting execution consistency

...will go undetected by security event monitoring systems, delaying incident response and potentially masking critical security issues.

## Recommendation

Add new `SecurityEvent` variants to comprehensively detect state divergence:

```rust
pub enum SecurityEvent {
    // ... existing variants ...
    
    /// Different validators produced different state roots for the same block
    ValidatorStateDivergence,
    
    /// Re-execution produced a different state root than initial execution  
    ExecutionNonDeterminism,
    
    /// State checkpoint verification failed due to root hash mismatch
    StateCheckpointMismatch,
}
```

Update the affected code locations to use these security events:
- In `pipelined_block.rs` when re-inserting execution results with different root hashes
- In `do_state_checkpoint.rs` when known state checkpoints don't match computed values
- In vote aggregation logic to detect when multiple validators vote for the same block with different state roots

## Proof of Concept

While this is a monitoring gap rather than an exploitable vulnerability, detection failure can be demonstrated:

1. Introduce a non-deterministic operation in the Move VM (e.g., timestamp-dependent computation)
2. Execute the same block on two validators  
3. Observe that votes fail to aggregate into a QC
4. Note that no `SecurityEvent` is logged - only standard error logs appear
5. Security monitoring systems watching `SecurityEvent` logs remain unaware of the critical execution divergence

The proof requires modifying Move VM internals to create non-determinism, which is beyond the scope of normal testing but demonstrates the monitoring blind spot.

---

**Notes:**

This finding represents a defense-in-depth gap rather than a directly exploitable vulnerability. The Aptos consensus protocol's safety properties prevent divergent states from being committed, but the lack of proper security event logging makes detecting and diagnosing the ROOT CAUSE of consensus failures significantly more difficult. Given the critical nature of deterministic execution to Byzantine fault tolerance, this monitoring gap should be addressed to improve the network's security posture and incident response capabilities.

### Citations

**File:** crates/aptos-logger/src/security.rs (L23-82)
```rust
#[derive(Clone, Copy, Debug, Serialize, Deserialize)]
#[serde(rename_all = "snake_case")]
pub enum SecurityEvent {
    //
    // Mempool
    //
    /// Mempool received a transaction from another peer with an invalid signature
    InvalidTransactionMempool,

    /// Mempool received an invalid network event
    InvalidNetworkEventMempool,

    // Consensus
    // ---------
    /// Consensus received an invalid message (not well-formed, invalid vote data or incorrect signature)
    ConsensusInvalidMessage,

    /// Consensus received an equivocating vote
    ConsensusEquivocatingVote,

    /// Consensus received an equivocating order vote
    ConsensusEquivocatingOrderVote,

    /// Consensus received an invalid proposal
    InvalidConsensusProposal,

    /// Consensus received an invalid new round message
    InvalidConsensusRound,

    /// Consensus received an invalid sync info message
    InvalidSyncInfoMsg,

    /// A received block is invalid
    InvalidRetrievedBlock,

    /// A block being committed or executed is invalid
    InvalidBlock,

    // State-Sync
    // ----------
    /// Invalid chunk of transactions received
    StateSyncInvalidChunk,

    // Health Checker
    // --------------
    /// HealthChecker received an invalid network event
    InvalidNetworkEventHC,

    /// HealthChecker received an invalid message
    InvalidHealthCheckerMsg,

    // Network
    // -------
    /// Network received an invalid message from a remote peer
    InvalidNetworkEvent,

    /// A failed noise handshake that's either a clear bug or indicates some
    /// security issue.
    NoiseHandshake,
}
```

**File:** types/src/block_info.rs (L24-44)
```rust
/// This structure contains all the information needed for tracking a block
/// without having access to the block or its execution output state. It
/// assumes that the block is the last block executed within the ledger.
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct BlockInfo {
    /// The epoch to which the block belongs.
    epoch: u64,
    /// The consensus protocol is executed in rounds, which monotonically increase per epoch.
    round: Round,
    /// The identifier (hash) of the block.
    id: HashValue,
    /// The accumulator root hash after executing this block.
    executed_state_id: HashValue,
    /// The version of the latest transaction after executing this block.
    version: Version,
    /// The timestamp this block was proposed by a proposer.
    timestamp_usecs: u64,
    /// An optional field containing the next epoch info
    next_epoch_state: Option<EpochState>,
}
```

**File:** consensus/src/pending_votes.rs (L273-330)
```rust
    /// Insert a vote and if the vote is valid, return a QuorumCertificate preferentially over a
    /// TimeoutCertificate if either can can be formed
    pub fn insert_vote(
        &mut self,
        vote: &Vote,
        validator_verifier: &ValidatorVerifier,
    ) -> VoteReceptionResult {
        // derive data from vote
        let li_digest = vote.ledger_info().hash();

        //
        // 1. Has the author already voted for this round?
        //

        if let Some((previously_seen_vote, previous_li_digest)) =
            self.author_to_vote.get(&vote.author())
        {
            // is it the same vote?
            if &li_digest == previous_li_digest {
                // we've already seen an equivalent vote before
                let new_timeout_vote = vote.is_timeout() && !previously_seen_vote.is_timeout();
                if !new_timeout_vote {
                    // it's not a new timeout vote
                    return VoteReceptionResult::DuplicateVote;
                }
            } else {
                // we have seen a different vote for the same round
                error!(
                    SecurityEvent::ConsensusEquivocatingVote,
                    remote_peer = vote.author(),
                    vote = vote,
                    previous_vote = previously_seen_vote
                );

                return VoteReceptionResult::EquivocateVote;
            }
        }

        //
        // 2. Store new vote (or update, in case it's a new timeout vote)
        //

        self.author_to_vote
            .insert(vote.author(), (vote.clone(), li_digest));

        //
        // 3. Let's check if we can create a QC
        //

        let len = self.li_digest_to_votes.len() + 1;
        // obtain the ledger info with signatures associated to the vote's ledger info
        let (hash_index, status) = self.li_digest_to_votes.entry(li_digest).or_insert_with(|| {
            (
                len,
                VoteStatus::NotEnoughVotes(SignatureAggregator::new(vote.ledger_info().clone())),
            )
        });

```

**File:** consensus/consensus-types/src/pipelined_block.rs (L311-324)
```rust
        if let Some(previous) = self.execution_summary.get() {
            if previous.root_hash == execution_summary.root_hash
                || previous.root_hash == *ACCUMULATOR_PLACEHOLDER_HASH
            {
                warn!(
                    "Skipping re-inserting execution result, from {:?} to {:?}",
                    previous, execution_summary
                );
            } else {
                error!(
                    "Re-inserting execution result with different root hash: from {:?} to {:?}",
                    previous, execution_summary
                );
            }
```

**File:** execution/executor/src/workflow/do_state_checkpoint.rs (L64-71)
```rust
            if let Some(idx) = last_checkpoint_index {
                ensure!(
                    known[idx] == Some(state_summary.last_checkpoint().root_hash()),
                    "Root hash mismatch with known hashes passed in. {:?} vs {:?}",
                    known[idx],
                    Some(&state_summary.last_checkpoint().root_hash()),
                );
            }
```

**File:** consensus/src/block_storage/block_store.rs (L201-208)
```rust
        assert!(
            // decoupled execution allows dummy executed_state_id
            root_qc.certified_block().executed_state_id() == *ACCUMULATOR_PLACEHOLDER_HASH
                || root_qc.certified_block().executed_state_id() == root_metadata.accu_hash,
            "root qc state id {} doesn't match committed trees {}",
            root_qc.certified_block().executed_state_id(),
            root_metadata.accu_hash,
        );
```
