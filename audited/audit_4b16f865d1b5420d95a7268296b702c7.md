# Audit Report

## Title
Authorization Header Scheme Validation Bypass in Aptos Faucet Authentication

## Summary
The Aptos faucet's `AuthTokenChecker.check()` function does not validate the authentication scheme in the Authorization header, allowing attackers to use arbitrary prefixes (e.g., `Malicious <token>`, `foo <token>`) instead of the RFC 6750-compliant `Bearer <token>` format, while still successfully authenticating if they possess a valid token.

## Finding Description

The `AuthTokenChecker.check()` function extracts authentication tokens from the Authorization header using a flawed parsing approach that does not validate the authentication scheme prefix. [1](#0-0) 

The code splits the header value by whitespace and extracts the second element without verifying that the first element is "Bearer" (case-insensitive or otherwise), as required by RFC 6750 for Bearer token authentication. This same vulnerability exists in multiple locations: [2](#0-1)  and [3](#0-2) 

Despite the error message explicitly stating the expected format is `'Bearer <token>'`, [4](#0-3)  the code accepts any scheme prefix, enabling requests with headers like:
- `Authorization: Bearer <token>` ✓
- `Authorization: bearer <token>` ✓  
- `Authorization: Malicious <token>` ✓
- `Authorization: foo <token>` ✓

In contrast, the Aptos telemetry service correctly implements case-insensitive scheme validation: [5](#0-4)  with comprehensive test coverage validating both valid and invalid scheme prefixes. [6](#0-5) 

**Attack Scenario:**
1. Attacker obtains a valid faucet authentication token (e.g., through social engineering or insider access)
2. Attacker sends request: `Authorization: Foo <valid_token>` instead of `Authorization: Bearer <valid_token>`
3. Token is extracted and validated successfully against the allow-list
4. Security monitoring systems expecting "Bearer" tokens miss the authentication attempt
5. Attacker successfully accesses faucet while evading detection in audit logs

## Impact Explanation

This vulnerability does **not** meet the severity criteria for the Aptos bug bounty program:

- **Critical Severity**: Not applicable - does not affect consensus, validator operations, fund security, or network availability
- **High Severity**: Not applicable - does not cause validator slowdowns, API crashes, or violations of the Aptos blockchain protocol
- **Medium Severity**: Not applicable - does not cause fund loss, manipulation, or state inconsistencies
- **Low Severity**: Applicable - this is a non-critical implementation bug causing HTTP standard non-compliance

The faucet is an auxiliary testnet service, not a consensus-critical component. While the vulnerability enables bypassing external security monitoring and violates HTTP RFC 6750, the attacker still requires a valid token from the configured allow-list. This does not break any of the documented Aptos invariants (consensus safety, execution determinism, state consistency, governance integrity, etc.).

## Likelihood Explanation

**High likelihood** that attackers with valid tokens could exploit this for monitoring evasion, but **low likelihood** of significant security impact because:
- The token itself remains validated against the allow-list
- The faucet is a testnet service, not protecting mainnet assets
- Attack requires pre-existing possession of a valid authentication token
- Impact limited to audit trail evasion and HTTP standard non-compliance

## Recommendation

Implement proper case-insensitive Bearer scheme validation matching the pattern used in the telemetry service:

```rust
const BEARER: &str = "BEARER ";

let auth_header = data
    .headers
    .get(AUTHORIZATION)
    .and_then(|v| v.to_str().ok())
    .ok_or_else(|| /* error */)?;

if !auth_header
    .get(..BEARER.len())
    .unwrap_or_default()
    .eq_ignore_ascii_case(BEARER)
{
    return Ok(vec![RejectionReason::new(
        "Authorization header must use Bearer scheme".to_string(),
        RejectionReasonCode::AuthTokenInvalid,
    )]);
}

let auth_token = auth_header
    .get(BEARER.len()..)
    .unwrap_or_default();
```

Apply this fix to:
- `crates/aptos-faucet/core/src/checkers/auth_token.rs`
- `crates/aptos-faucet/core/src/firebase_jwt.rs`
- `crates/aptos-faucet/core/src/bypasser/auth_token.rs`

## Proof of Concept

```bash
# Normal request with proper Bearer token
curl -X POST http://faucet:8081/mint \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer valid_token_from_allowlist" \
  -d '{"amount": 10000}'
# Expected: Success (200 OK)

# Attack: Malformed scheme bypasses monitoring but still authenticates
curl -X POST http://faucet:8081/mint \
  -H "Content-Type: application/json" \
  -H "Authorization: Malicious valid_token_from_allowlist" \
  -d '{"amount": 10000}'
# Expected (current): Success (200 OK) - scheme not validated
# Expected (after fix): Failure (400) - invalid scheme rejected

# Attack: Lowercase scheme
curl -X POST http://faucet:8081/mint \
  -H "Content-Type: application/json" \
  -H "Authorization: bearer valid_token_from_allowlist" \
  -d '{"amount": 10000}'
# Expected (current): Success (200 OK)
# Expected (after fix): Success (200 OK) - case-insensitive validation
```

## Notes

While this is a legitimate code quality issue violating HTTP standards and creating inconsistent security implementation across the Aptos codebase, it does **not** meet the severity threshold for a valid vulnerability report per the strict validation criteria. The bug does not break any documented Aptos invariants, does not affect consensus or blockchain security, and does not enable direct authentication bypass (valid token still required). This would classify as **Low severity** under the bug bounty program criteria.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/auth_token.rs (L42-46)
```rust
        let auth_token = match data
            .headers
            .get(AUTHORIZATION)
            .and_then(|v| v.to_str().ok())
            .and_then(|v| v.split_whitespace().nth(1))
```

**File:** crates/aptos-faucet/core/src/checkers/auth_token.rs (L49-52)
```rust
            None => return Ok(vec![RejectionReason::new(
                "Either the Authorization header is missing or it is not in the form of 'Bearer <token>'".to_string(),
                RejectionReasonCode::AuthTokenInvalid,
            )]),
```

**File:** crates/aptos-faucet/core/src/firebase_jwt.rs (L91-94)
```rust
    match headers
        .get(AUTHORIZATION)
        .and_then(|v| v.to_str().ok())
        .and_then(|v| v.split_whitespace().nth(1))
```

**File:** crates/aptos-faucet/core/src/bypasser/auth_token.rs (L38-42)
```rust
        let auth_token = match data
            .headers
            .get(AUTHORIZATION)
            .and_then(|v| v.to_str().ok())
            .and_then(|v| v.split_whitespace().nth(1))
```

**File:** crates/aptos-telemetry-service/src/jwt_auth.rs (L91-94)
```rust
    if !auth_header
        .get(..BEARER.len())
        .unwrap_or_default()
        .eq_ignore_ascii_case(BEARER)
```

**File:** crates/aptos-telemetry-service/src/jwt_auth.rs (L114-147)
```rust
    async fn jwt_from_header_valid_bearer() {
        assert_eq!(
            jwt_from_header(Some("Bearer token".into())).await.unwrap(),
            "token"
        );

        assert_eq!(
            jwt_from_header(Some("bearer token".into())).await.unwrap(),
            "token"
        );

        assert_eq!(
            jwt_from_header(Some("BEARER token".into())).await.unwrap(),
            "token"
        );
    }

    #[tokio::test]
    async fn jwt_from_header_invalid_bearer() {
        let jwt = jwt_from_header(None).await;
        assert!(jwt.is_err());

        let jwt = jwt_from_header(Some("Bear token".into())).await;
        assert!(jwt.is_err());

        let jwt = jwt_from_header(Some("".into())).await;
        assert!(jwt.is_err());

        let jwt = jwt_from_header(Some("Bear".into())).await;
        assert!(jwt.is_err());

        let jwt = jwt_from_header(Some("BEARER: token".into())).await;
        assert!(jwt.is_err());
    }
```
