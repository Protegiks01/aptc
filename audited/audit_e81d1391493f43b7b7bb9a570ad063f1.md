# Audit Report

## Title
Equivocation Injection via Unvalidated Backup Restoration Allows Byzantine State Divergence

## Summary
The transaction backup and restore system fails to validate that `LedgerInfoWithSignatures` originates from the canonical committed chain. When performing one-shot transaction restores without epoch history, only cryptographic signature validity and Merkle proof correctness are checked. This allows backups containing transactions from equivocating blocks (blocks with valid Byzantine signatures but rejected by consensus) to be restored, resulting in nodes with state divergent from the canonical blockchain.

## Finding Description

The vulnerability exists in the backup restoration flow for transaction chunks. The `TransactionChunk` structure includes a proof field containing a `TransactionAccumulatorRangeProof` and `LedgerInfoWithSignatures` that links transactions to a ledger state. [1](#0-0) 

During backup creation, the system reads directly from the local database without validating that the data represents the canonical chain: [2](#0-1) 

The critical flaw occurs during restoration. When one-shot transaction restore is performed, the `epoch_history` parameter is explicitly set to `None`: [3](#0-2) 

This causes the epoch history validation to be skipped: [4](#0-3) 

The only verification performed is the `TransactionListWithProof::verify()` call: [5](#0-4) 

This verification only checks Merkle proof correctness and that transaction hashes match the provided `LedgerInfo`, but does NOT validate that the `LedgerInfo` is from the canonical chain: [6](#0-5) 

Even when `epoch_history` is provided, the validation only checks signature validity against the validator set, not whether the block was actually committed by honest consensus: [7](#0-6) 

**Attack Scenario:**
1. Byzantine validators sign an equivocating block at some height/round (this violates BFT assumptions but is possible with protocol bugs or <1/3 Byzantine + some honest validators accidentally signing)
2. A compromised/Byzantine node stores this equivocating block in its database
3. The node creates a backup containing transactions from the equivocating branch
4. An honest operator restores from this backup without proper trusted waypoints
5. The restored node has state divergent from the canonical chain that honest nodes agreed upon

**Invariant Violations:**
- **Consensus Safety**: Allows restoration of blocks that consensus rejected, breaking the fundamental guarantee that committed state is agreed upon by >2/3 validators
- **State Consistency**: Creates state divergence where different nodes have different historical states despite appearing to be at the same version

## Impact Explanation

This vulnerability meets **Critical Severity** criteria under multiple categories:

1. **Consensus/Safety Violations**: The core issue directly violates consensus safety guarantees by allowing rejected Byzantine state to be restored and treated as canonical.

2. **Non-recoverable Network Partition**: If multiple nodes restore from such backups, they will have divergent state. When attempting to sync or participate in consensus, this divergence may require a hard fork to resolve, especially if the equivocating state has different transaction outputs, balances, or validator sets.

3. **Loss of Funds**: If the equivocating branch contains different transaction outcomes (e.g., different payment recipients, different smart contract states), funds could effectively be lost or misdirected when users interact with the divergent state.

The documentation explicitly states that waypoint validation is NOT performed for one-shot transaction restores: [8](#0-7) 

## Likelihood Explanation

**Likelihood: Medium to Low** (but impact is Critical)

Prerequisites for exploitation:
1. Equivocating blocks with valid signatures must exist (requires Byzantine validators or consensus bugs)
2. A node with these blocks in its database must create a backup
3. Operators must restore without sufficient trusted waypoints

While Byzantine validators are assumed to be <1/3 and well-controlled, the vulnerability is realistic because:
- Consensus bugs could temporarily allow equivocation
- Compromised validator nodes could be modified to store rejected blocks
- Backup distribution channels may not be fully trusted
- Operators performing disaster recovery may not use proper waypoints
- The system design assumes database integrity but doesn't enforce it during restore

The severity warrants Critical classification despite moderate likelihood because:
- The impact is catastrophic (state divergence, potential network partition)
- The vulnerability is systemic, not requiring race conditions
- Detection may be delayed until significant divergence occurs
- Recovery requires manual intervention or hard fork

## Recommendation

Implement mandatory canonical chain validation during transaction backup restoration:

1. **Require Trusted Waypoints**: Make trusted waypoints mandatory for all transaction restores, not optional. The restore should fail if waypoints cannot verify the ledger info chain.

2. **Add Canonicality Checks**: During restore, validate that each `LedgerInfoWithSignatures` can be linked to a trusted anchor (genesis or waypoint) through a verified epoch change chain.

3. **Implement Chain Verification**: Before accepting any restore, verify that the provided ledger infos form a valid chain with proper epoch transitions and that no gaps or inconsistencies exist.

4. **Add Backup Metadata Signing**: Include a cryptographic signature from the backup creator and verify it against a trusted validator set to establish backup provenance.

**Code Fix Example** (conceptual):

```rust
// In LoadedChunk::load(), enforce epoch_history requirement:
pub async fn load(
    manifest: TransactionChunk,
    storage: &Arc<dyn BackupStorage>,
    epoch_history: Option<&Arc<EpochHistory>>,
) -> Result<Self> {
    // ... existing code ...
    
    let (range_proof, ledger_info) = storage
        .load_bcs_file::<(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)>(
            &manifest.proof,
        )
        .await?;
    
    // MANDATORY VALIDATION - do not make optional
    let epoch_history = epoch_history.ok_or_else(|| 
        anyhow!("Epoch history is required to validate ledger info authenticity")
    )?;
    epoch_history.verify_ledger_info(&ledger_info)?;
    
    // ... rest of verification ...
}
```

Additionally, in `EpochHistory::verify_ledger_info()`, add explicit checks that the ledger info represents a canonical block:

```rust
pub fn verify_ledger_info(&self, li_with_sigs: &LedgerInfoWithSignatures) -> Result<()> {
    // ... existing checks ...
    
    // Require that for non-genesis, non-waypoint epochs, 
    // we must have verified the complete chain from a trusted root
    ensure!(
        epoch == 0 || self.trusted_waypoints.contains_key(&li_with_sigs.ledger_info().version()),
        "Cannot verify ledger info authenticity without trusted waypoint at epoch {}. \
         This may indicate an equivocating block that was not canonically committed.",
        epoch
    );
    
    // ... rest of verification ...
}
```

## Proof of Concept

```rust
// Proof of Concept - Demonstrating the vulnerability
// This would be implemented as a test in the backup-cli crate

#[tokio::test]
async fn test_equivocation_injection_via_restore() {
    // Step 1: Setup - Create two conflicting blocks at the same height
    let (byzantine_validators, byzantine_verifier) = 
        random_validator_verifier(3, None, true); // 3 Byzantine validators
    let (honest_validators, honest_verifier) = 
        random_validator_verifier(7, None, true); // 7 honest validators
    
    let epoch = 5;
    let version = 1000;
    
    // Canonical block - signed by honest validators
    let canonical_ledger_info = create_test_ledger_info(
        epoch, 
        version,
        HashValue::from_u64(0x1111), // canonical state root
        &honest_validators
    );
    
    // Equivocating block - signed by Byzantine validators
    // Same version, different state root (equivocation!)
    let equivocating_ledger_info = create_test_ledger_info(
        epoch,
        version, 
        HashValue::from_u64(0x2222), // different state root!
        &byzantine_validators
    );
    
    // Step 2: Create backup with equivocating block
    let backup_storage = create_temp_backup_storage().await;
    let byzantine_txns = create_test_transactions(version, 100);
    
    // Create TransactionChunk with equivocating proof
    let chunk = create_chunk_with_proof(
        byzantine_txns,
        equivocating_ledger_info, // Using equivocating ledger info!
        version,
    ).await;
    
    // Step 3: Attempt restore WITHOUT epoch history (one-shot mode)
    let restore_db = create_empty_test_db().await;
    let restore_controller = TransactionRestoreController::new(
        test_opt(),
        test_global_opt(),
        backup_storage.clone(),
        None, // No epoch history - vulnerability trigger!
        VerifyExecutionMode::NoVerify,
    );
    
    // Step 4: Restore succeeds even though block is equivocating!
    let result = restore_controller.run().await;
    assert!(result.is_ok(), "Restore should succeed (vulnerability)");
    
    // Step 5: Verify that restored state differs from canonical chain
    let restored_state_root = get_state_root(&restore_db, version).await;
    assert_eq!(
        restored_state_root,
        HashValue::from_u64(0x2222), // Equivocating state!
    );
    assert_ne!(
        restored_state_root, 
        HashValue::from_u64(0x1111), // Not the canonical state!
    );
    
    println!("VULNERABILITY CONFIRMED: Node restored Byzantine state divergent from canonical chain");
}
```

**Notes:**
- This vulnerability requires Byzantine validator signatures or consensus protocol bugs to manifest in production
- The impact is severe because it breaks fundamental blockchain consistency guarantees
- Current deployment practices may mitigate this if operators always use proper waypoints, but the code does not enforce this
- The backup system should be fail-secure: it should refuse to restore without proper validation rather than proceeding with weak checks

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/manifest.rs (L20-34)
```rust
pub struct TransactionChunk {
    pub first_version: Version,
    pub last_version: Version,
    /// Repeated `len(record) + record`, where `record` is BCS serialized tuple
    /// `(Transaction, TransactionInfo)`
    pub transactions: FileHandle,
    /// BCS serialized `(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)`.
    /// The `TransactionAccumulatorRangeProof` links the transactions to the
    /// `LedgerInfoWithSignatures`, and the `LedgerInfoWithSignatures` can be verified by the
    /// signatures it carries, against the validator set in the epoch. (Hence proper
    /// `EpochEndingBackup` is needed for verification.)
    pub proof: FileHandle,
    #[serde(default = "default_to_v0")]
    pub format: TransactionChunkFormat,
}
```

**File:** storage/aptosdb/src/backup/backup_handler.rs (L113-137)
```rust
    pub fn get_transaction_range_proof(
        &self,
        first_version: Version,
        last_version: Version,
    ) -> Result<(TransactionAccumulatorRangeProof, LedgerInfoWithSignatures)> {
        ensure!(
            last_version >= first_version,
            "Bad transaction range: [{}, {}]",
            first_version,
            last_version
        );
        let num_transactions = last_version - first_version + 1;
        let ledger_metadata_db = self.ledger_db.metadata_db();
        let epoch = ledger_metadata_db.get_epoch(last_version)?;
        let ledger_info = ledger_metadata_db.get_latest_ledger_info_in_epoch(epoch)?;
        let accumulator_proof = self
            .ledger_db
            .transaction_accumulator_db()
            .get_transaction_range_proof(
                Some(first_version),
                num_transactions,
                ledger_info.ledger_info().version(),
            )?;
        Ok((accumulator_proof, ledger_info))
    }
```

**File:** storage/db-tool/src/restore.rs (L102-110)
```rust
                        TransactionRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                            None, /* epoch_history */
                            VerifyExecutionMode::NoVerify,
                        )
                        .run()
                        .await?;
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L152-154)
```rust
        if let Some(epoch_history) = epoch_history {
            epoch_history.verify_ledger_info(&ledger_info)?;
        }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L167-167)
```rust
        txn_list_with_proof.verify(ledger_info.ledger_info(), Some(manifest.first_version))?;
```

**File:** types/src/proof/definition.rs (L910-925)
```rust
    pub fn verify(
        &self,
        ledger_info: &LedgerInfo,
        first_transaction_info_version: Option<Version>,
    ) -> Result<()> {
        let txn_info_hashes: Vec<_> = self
            .transaction_infos
            .iter()
            .map(CryptoHash::hash)
            .collect();
        self.ledger_info_to_transaction_infos_proof.verify(
            ledger_info.transaction_accumulator_hash(),
            first_transaction_info_version,
            &txn_info_hashes,
        )
    }
```

**File:** types/src/epoch_state.rs (L41-50)
```rust
    fn verify(&self, ledger_info: &LedgerInfoWithSignatures) -> anyhow::Result<()> {
        ensure!(
            self.epoch == ledger_info.ledger_info().epoch(),
            "LedgerInfo has unexpected epoch {}, expected {}",
            ledger_info.ledger_info().epoch(),
            self.epoch
        );
        ledger_info.verify_signatures(&self.verifier)?;
        Ok(())
    }
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L341-343)
```rust
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
```
