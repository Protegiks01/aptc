# Audit Report

## Title
Non-Atomic Version Reads in OldSyncRequest Validation Cause Incorrect Error Classification and Consensus Sync Failures

## Summary
The state-sync driver validates consensus sync target requests by performing two separate, non-atomic storage reads to fetch pre-committed and committed versions. Due to separate locks that explicitly allow concurrent pre-commit and commit operations, these reads can observe inconsistent state where committed_version > pre_committed_version, violating storage invariants. This causes incorrect OldSyncRequest error responses to consensus, leading to validator panics at epoch transitions.

## Finding Description

The consensus sync target validation performs two separate storage reads that are not protected by a common lock: [1](#0-0) 

These reads access different storage locations:
1. **Pre-committed version** is read from the state store's current state: [2](#0-1) 

2. **Committed version** is read from the ledger metadata database: [3](#0-2) 

The storage system uses **two separate locks** that explicitly allow concurrent pre-commit and commit operations: [4](#0-3) 

The comments confirm this design choice: [5](#0-4) 

**Storage Invariant**: The storage system enforces that `pre_committed_version >= committed_version`: [6](#0-5) 

**Race Condition Scenario**:
1. Thread A (sync handler) reads pre_committed_version = 100
2. Thread B executes pre_commit_ledger(), advancing state_store to version 110
3. Thread B executes commit_ledger(), advancing metadata_db to version 110
4. Thread A reads committed_version = 110
5. Thread A observes impossible state: (pre_committed=100, committed=110)

The validation logic then incorrectly evaluates this inconsistent state: [7](#0-6) 

This returns an OldSyncRequest error that propagates back to consensus.

## Impact Explanation

**HIGH Severity** per Aptos bug bounty criteria (Validator Node Slowdowns/Crashes - up to $50,000):

1. **Validator Panics at Epoch Transitions**: When consensus receives the incorrect OldSyncRequest error during epoch transitions, the validator panics: [8](#0-7) 

The `.expect("Failed to sync to new epoch")` causes immediate validator termination, disrupting network consensus participation.

2. **Consensus Coordination Failures**: The incorrect error response breaks the consensus/state-sync handover protocol. State-sync signals that a valid future sync target is "old", causing:
   - Failed epoch transitions
   - Validators falling behind the network
   - Disruption of consensus participation

3. **Observable Storage Invariant Violations**: The error message contains impossible state (committed > pre_committed), exposing internal consistency violations: [9](#0-8) 

## Likelihood Explanation

**HIGH Likelihood**: This race condition occurs naturally during normal validator operations:

- **No attacker required**: The race happens between legitimate concurrent operations (commits and sync request handling)
- **Common during normal operation**: Consensus frequently commits new blocks while state-sync processes sync requests
- **Wide race window**: The window exists between the two storage reads, which involves multiple function calls and can span significant time
- **High throughput amplifies risk**: More frequent commits increase the probability of observing inconsistent state
- **Critical during epoch transitions**: Sync-to-target operations are essential during epoch changes, when this bug causes validator panics

The separate lock design explicitly enables concurrent pre-commit and commit operations, making this race condition an inherent property of the current architecture rather than a rare edge case.

## Recommendation

Implement atomic version reads by:

1. **Add a combined read method** to the storage interface that returns both versions under a single consistent snapshot:
```rust
fn get_version_snapshot(&self) -> Result<(Option<Version>, Option<Version>)> {
    // Return (pre_committed_version, committed_version) atomically
}
```

2. **Use a read lock** that spans both version reads to ensure consistency

3. **Refactor validation** to use the atomic read:
```rust
let (latest_pre_committed_version, latest_committed_version) = 
    utils::fetch_version_snapshot(self.storage.clone())?;
```

This ensures the validation logic operates on consistent state that respects the storage invariant.

## Proof of Concept

While a complete executable PoC would require complex multi-threaded test infrastructure, the vulnerability can be demonstrated through the following trace:

**Thread 1 (Sync Handler)**:
1. Receives consensus sync target notification for version 105
2. Calls `fetch_pre_committed_version()` → reads 100 from state_store
3. **CONTEXT SWITCH**

**Thread 2 (Commit Handler)**:
1. Executes `pre_commit_ledger()` with chunk up to version 110
2. Updates state_store to version 110
3. Executes `commit_ledger(110)`  
4. Updates metadata_db to version 110

**Thread 1 (Continued)**:
1. Calls `fetch_latest_synced_ledger_info()` → reads 110 from metadata_db
2. Has observed state: (pre_committed=100, committed=110)
3. Validation: `105 < 110 || 105 < 100` = TRUE
4. Returns `OldSyncRequest(105, 100, 110)` error
5. Error propagates to consensus
6. `epoch_manager.rs:565` panics: "Failed to sync to new epoch"

The race window is confirmed by the explicit design choice to allow concurrent pre-commit and commit operations using separate locks.

### Citations

**File:** state-sync/state-sync-driver/src/driver.rs (L413-417)
```rust
        let latest_pre_committed_version =
            utils::fetch_pre_committed_version(self.storage.clone())?;
        let latest_synced_ledger_info =
            utils::fetch_latest_synced_ledger_info(self.storage.clone())?;
        let latest_committed_version = latest_synced_ledger_info.ledger_info().version();
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L137-141)
```rust
    fn get_pre_committed_version(&self) -> Result<Option<Version>> {
        gauged_api("get_pre_committed_version", || {
            Ok(self.state_store.current_state_locked().version())
        })
    }
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L76-78)
```rust
    pub(crate) fn get_synced_version(&self) -> Result<Option<Version>> {
        get_progress(&self.db, &DbMetadataKey::OverallCommitProgress)
    }
```

**File:** storage/aptosdb/src/db/mod.rs (L34-37)
```rust
    /// This is just to detect concurrent calls to `pre_commit_ledger()`
    pre_commit_lock: std::sync::Mutex<()>,
    /// This is just to detect concurrent calls to `commit_ledger()`
    commit_lock: std::sync::Mutex<()>,
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L46-49)
```rust
            // Pre-committing and committing in concurrency is allowed but not pre-committing at the
            // same time from multiple threads, the same for committing.
            // Consensus and state sync must hand over to each other after all pending execution and
            // committing complete.
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L531-536)
```rust
        ensure!(
            pre_committed_ver.is_some() && version_to_commit <= pre_committed_ver.unwrap(),
            "Version too new to commit. Pre-committed: {:?}, Trying to commit with LI: {}",
            pre_committed_ver,
            version_to_commit,
        );
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L276-283)
```rust
        if sync_target_version < latest_committed_version
            || sync_target_version < latest_pre_committed_version
        {
            let error = Err(Error::OldSyncRequest(
                sync_target_version,
                latest_pre_committed_version,
                latest_committed_version,
            ));
```

**File:** consensus/src/epoch_manager.rs (L558-565)
```rust
        self.execution_client
            .sync_to_target(ledger_info.clone())
            .await
            .context(format!(
                "[EpochManager] State sync to new epoch {}",
                ledger_info
            ))
            .expect("Failed to sync to new epoch");
```

**File:** state-sync/state-sync-driver/src/error.rs (L39-40)
```rust
    #[error("Received an old sync request for version {0}, but our pre-committed version is: {1} and committed version: {2}")]
    OldSyncRequest(Version, Version, Version),
```
