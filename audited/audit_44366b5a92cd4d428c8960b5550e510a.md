# Audit Report

## Title
DAG Consensus Creates Proposals with Empty Payloads on QuorumStore Batch Retrieval Errors

## Summary
The DAG consensus implementation (`DagDriver`) silently falls back to creating proposals with empty payloads when `QuorumStoreError` occurs during batch retrieval, instead of aborting proposal creation. This causes transaction processing to halt while consensus continues, resulting in liveness degradation and potential consensus divergence.

## Finding Description

In the DAG consensus driver's `enter_new_round()` method, when `pull_payload()` fails with a `QuorumStoreError` (due to timeout, channel failure, or other batch retrieval issues), the error is caught and logged, but instead of aborting proposal creation, the code falls back to creating a Node with an empty payload: [1](#0-0) 

The error handling pattern uses a `match` expression where the `Err(e)` branch creates an empty payload using `Payload::empty()` rather than propagating the error. This Node is then saved to storage and broadcast to other validators: [2](#0-1) 

The `QuorumStoreError` can occur in several realistic scenarios during batch retrieval: [3](#0-2) 

Critically, the Node verification logic does not validate that payloads are non-empty: [4](#0-3) 

This breaks the **Deterministic Execution** invariant because different validators may experience batch retrieval failures at different times due to network conditions, potentially creating divergent proposals. It also violates the **Liveness** guarantee as transactions are not processed even though consensus continues.

**Attack Scenario:**
1. Network partition or QuorumStore overload causes timeout in `pull_payload()`
2. Error is caught at line 282 and logged at line 283
3. Empty payload created at lines 284-290 instead of aborting
4. Node with empty payload created and broadcast
5. Other validators accept the Node (no payload validation in `verify()`)
6. Chain continues consensus but stops processing transactions
7. Silent failure - only visible in logs, not surfaced to operators

## Impact Explanation

**High Severity** - This qualifies as "Significant protocol violations" under the bug bounty program:

1. **Liveness Degradation**: Transaction throughput drops to zero while consensus continues, causing blockchain to appear functional but not process any user transactions

2. **Silent Failure**: The error is only logged with `error!()`, not surfaced through monitoring or alerting systems, making it difficult for operators to detect

3. **Non-Deterministic Behavior**: Failure depends on timing, network conditions, and QuorumStore state, making it hard to reproduce and debug

4. **Potential Consensus Divergence**: If different validators fail at different times, they may create different proposals (some with transactions, some empty), risking consensus safety

This differs from the regular consensus path (Jolteon/AptosBFT) which properly propagates errors: [5](#0-4) 

## Likelihood Explanation

**Medium to High** - This can occur in production through:

1. **Network Timeouts**: The `pull_timeout_ms` parameter can be exceeded during network congestion or partitions
2. **Channel Backpressure**: The `consensus_to_quorum_store_sender` channel can become full or closed
3. **QuorumStore Overload**: High transaction volume can cause batch retrieval delays
4. **Transient Failures**: Temporary network issues between consensus and QuorumStore components

The DAG consensus is enabled via on-chain configuration: [6](#0-5) 

## Recommendation

Change the error handling to propagate errors rather than falling back to empty payloads. The code should match the behavior of the regular consensus path:

```rust
let (validator_txns, payload) = self
    .payload_client
    .pull_payload(
        PayloadPullParameters { /* ... */ },
        sys_payload_filter,
    )
    .await
    .context("Failed to retrieve payload for DAG node")?;  // Propagate error
```

This requires changing the return type of `enter_new_round()` to `anyhow::Result<()>` and handling errors at the call site to abort proposal creation when batch retrieval fails.

Additionally, consider adding payload validation in `Node::verify()`:

```rust
pub fn verify(&self, sender: Author, verifier: &ValidatorVerifier) -> anyhow::Result<()> {
    // ... existing checks ...
    
    // Validate payload is not empty for rounds > 1
    if node_round > 1 {
        ensure!(!self.payload.is_empty(), "node payload cannot be empty");
    }
    
    Ok(())
}
```

## Proof of Concept

To reproduce, inject a failure in the QuorumStore client:

```rust
// In consensus/src/payload_client/user/quorum_store_client.rs
// Add before pull_internal() call:

#[cfg(test)]
pub async fn pull_with_injected_failure(
    &self,
    params: PayloadPullParameters,
) -> anyhow::Result<Payload, QuorumStoreError> {
    // Simulate timeout
    Err(anyhow::anyhow!("Simulated QuorumStore timeout").into())
}

// Then in DAG driver test:
#[tokio::test]
async fn test_empty_payload_on_quorum_store_error() {
    let (dag_driver, mock_payload_client) = setup_test_dag_driver();
    
    // Inject QuorumStore error
    mock_payload_client.set_should_fail(true);
    
    // Trigger round
    dag_driver.enter_new_round(1).await;
    
    // Verify node was created with empty payload
    let node = dag_driver.storage.get_pending_node().unwrap();
    assert!(node.payload().is_empty(), "Node should have empty payload on error");
    
    // This demonstrates the vulnerability: proposal created despite error
}
```

The fail point already exists for testing: [7](#0-6) 

## Notes

This vulnerability is specific to the DAG consensus implementation. The regular AptosBFT consensus (Jolteon) properly propagates `QuorumStoreError` and aborts proposal generation when batch retrieval fails, as shown in the `ProposalGenerator` implementation. The DAG consensus should follow the same error handling pattern to maintain consistency and safety guarantees.

### Citations

**File:** consensus/src/dag/dag_driver.rs (L259-292)
```rust
        let (validator_txns, payload) = match self
            .payload_client
            .pull_payload(
                PayloadPullParameters {
                    max_poll_time: Duration::from_millis(
                        self.payload_config.payload_pull_max_poll_time_ms,
                    ),
                    max_txns: PayloadTxnsSize::new(max_txns, max_size_bytes),
                    max_txns_after_filtering: max_txns,
                    soft_max_txns_after_filtering: max_txns,
                    max_inline_txns: PayloadTxnsSize::new(100, 100 * 1024),
                    maybe_optqs_payload_pull_params: None,
                    user_txn_filter: payload_filter,
                    pending_ordering: false,
                    pending_uncommitted_blocks: 0,
                    recent_max_fill_fraction: 0.0,
                    block_timestamp: self.time_service.now_unix_time(),
                },
                sys_payload_filter,
            )
            .await
        {
            Ok(payload) => payload,
            Err(e) => {
                error!("error pulling payload: {}", e);
                (
                    vec![],
                    Payload::empty(
                        self.quorum_store_enabled,
                        self.allow_batches_without_pos_in_proposal,
                    ),
                )
            },
        };
```

**File:** consensus/src/dag/dag_driver.rs (L304-317)
```rust
        let new_node = Node::new(
            self.epoch_state.epoch,
            new_round,
            self.author,
            timestamp,
            validator_txns,
            payload,
            strong_links,
            Extensions::empty(),
        );
        self.storage
            .save_pending_node(&new_node)
            .expect("node must be saved");
        self.broadcast_node(new_node);
```

**File:** consensus/src/payload_client/user/quorum_store_client.rs (L76-86)
```rust
        match monitor!(
            "pull_payload",
            timeout(Duration::from_millis(self.pull_timeout_ms), callback_rcv).await
        ) {
            Err(_) => {
                Err(anyhow::anyhow!("[consensus] did not receive GetBlockResponse on time").into())
            },
            Ok(resp) => match resp.map_err(anyhow::Error::from)?? {
                GetPayloadResponse::GetPayloadResponse(payload) => Ok(payload),
            },
        }
```

**File:** consensus/src/payload_client/user/quorum_store_client.rs (L103-105)
```rust
        fail_point!("consensus::pull_payload", |_| {
            Err(anyhow::anyhow!("Injected error in pull_payload").into())
        });
```

**File:** consensus/src/dag/types.rs (L301-345)
```rust
    pub fn verify(&self, sender: Author, verifier: &ValidatorVerifier) -> anyhow::Result<()> {
        ensure!(
            sender == *self.author(),
            "Author {} doesn't match sender {}",
            self.author(),
            sender
        );
        // TODO: move this check to rpc process logic to delay it as much as possible for performance
        ensure!(self.digest() == self.calculate_digest(), "invalid digest");

        let node_round = self.metadata().round();

        ensure!(node_round > 0, "current round cannot be zero");

        if node_round == 1 {
            ensure!(self.parents().is_empty(), "invalid parents for round 1");
            return Ok(());
        }

        let prev_round = node_round - 1;
        // check if the parents' round is the node's round - 1
        ensure!(
            self.parents()
                .iter()
                .all(|parent| parent.metadata().round() == prev_round),
            "invalid parent round"
        );

        // Verification of the certificate is delayed until we need to fetch it
        ensure!(
            verifier
                .check_voting_power(
                    self.parents()
                        .iter()
                        .map(|parent| parent.metadata().author()),
                    true,
                )
                .is_ok(),
            "not enough parents to satisfy voting power"
        );

        // TODO: validate timestamp

        Ok(())
    }
```

**File:** consensus/src/liveness/proposal_generator.rs (L652-672)
```rust
        let (validator_txns, mut payload) = self
            .payload_client
            .pull_payload(
                PayloadPullParameters {
                    max_poll_time: self.quorum_store_poll_time.saturating_sub(proposal_delay),
                    max_txns: max_block_txns,
                    max_txns_after_filtering: max_block_txns_after_filtering,
                    soft_max_txns_after_filtering: max_txns_from_block_to_execute
                        .unwrap_or(max_block_txns_after_filtering),
                    max_inline_txns: self.max_inline_txns,
                    maybe_optqs_payload_pull_params,
                    user_txn_filter: payload_filter,
                    pending_ordering,
                    pending_uncommitted_blocks: pending_blocks.len(),
                    recent_max_fill_fraction: max_fill_fraction,
                    block_timestamp: timestamp,
                },
                validator_txn_filter,
            )
            .await
            .context("Fail to retrieve payload")?;
```

**File:** consensus/src/epoch_manager.rs (L1293-1293)
```rust
        if consensus_config.is_dag_enabled() {
```
