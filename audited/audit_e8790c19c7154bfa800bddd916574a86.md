# Audit Report

## Title
Missing Bounds Check and Validation in SecretShareConfig Allows Validator Node Crashes via Out-of-Bounds Array Access

## Summary
The `SecretShareConfig` constructor accepts a `verification_keys` vector without validating its length against the number of validators. When processing incoming secret shares, the verification logic directly accesses this array using a validator index without bounds checking, which can cause validator nodes to panic and crash during consensus operations.

## Finding Description
The secret sharing system in Aptos consensus uses verification keys to validate decryption key shares from validators. The vulnerability exists in two locations:

1. **Missing validation during construction**: [1](#0-0) 

The `SecretShareConfig::new()` constructor accepts `verification_keys: Vec<VerificationKey>` without any validation. It does not check:
- Whether `verification_keys.len()` matches the validator count
- Whether `verification_keys.len()` matches `config.get_threshold_config().n`
- Whether the keys are properly aligned with validator indices

2. **Unchecked array access during verification**: [2](#0-1) 

The `SecretShare::verify()` method retrieves a validator index and directly accesses `config.verification_keys[index]` without bounds checking. The code even contains a TODO comment explicitly acknowledging this missing check: `// TODO(ibalajiarun): Check index out of bounds`.

This verification is called when processing incoming messages from peers: [3](#0-2) 

And during reliable broadcast share aggregation: [4](#0-3) 

**Attack Scenario:**

If the `verification_keys` array is constructed with fewer elements than the number of validators (due to implementation bugs, race conditions during epoch transitions, or validator set changes), when a validator receives a share from a peer whose index exceeds the array bounds, the node will panic and crash.

## Impact Explanation
This vulnerability qualifies as **High Severity** per Aptos bug bounty criteria because it causes:

1. **Validator node crashes**: When the out-of-bounds access occurs, the node panics and stops processing consensus messages, leading to validator node unavailability.

2. **Liveness degradation**: If multiple validators crash due to this issue during epoch transitions or validator set changes, the network may experience reduced liveness or temporary consensus delays.

3. **Potential consensus disruption**: In edge cases where verification keys are misaligned (not just missing), legitimate shares could be rejected while accepting shares verified against wrong keys, potentially affecting consensus integrity.

While this does not directly cause loss of funds or permanent consensus safety violations, it represents a significant protocol violation that can cause validator node slowdowns and temporary unavailability, meeting the High Severity criteria.

## Likelihood Explanation
The likelihood is **Medium** because:

1. **Requires specific conditions**: The vulnerability is triggered when `verification_keys.len() < number_of_validators` during config construction, which could occur during:
   - Epoch transitions with validator set changes
   - Implementation bugs in DKG transcript processing
   - Race conditions in config initialization

2. **Not directly attacker-controlled**: An external attacker cannot directly manipulate the `verification_keys` array, but can trigger the vulnerability by sending shares if the misconfiguration exists.

3. **Known issue**: The TODO comment indicates developers are aware of the missing bounds check, suggesting it may be encountered in practice.

## Recommendation
Add comprehensive validation in both the constructor and the verification method:

```rust
impl SecretShareConfig {
    pub fn new(
        author: Author,
        epoch: u64,
        validator: Arc<ValidatorVerifier>,
        digest_key: DigestKey,
        msk_share: MasterSecretKeyShare,
        verification_keys: Vec<VerificationKey>,
        config: <FPTXWeighted as BatchThresholdEncryption>::ThresholdConfig,
        encryption_key: EncryptionKey,
    ) -> anyhow::Result<Self> {
        let num_validators = validator.len();
        anyhow::ensure!(
            verification_keys.len() == num_validators,
            "verification_keys length {} does not match validator count {}",
            verification_keys.len(),
            num_validators
        );
        
        Ok(Self {
            _author: author,
            _epoch: epoch,
            validator,
            digest_key,
            msk_share,
            verification_keys,
            config,
            encryption_key,
            weights: HashMap::new(),
        })
    }
}

impl SecretShare {
    pub fn verify(&self, config: &SecretShareConfig) -> anyhow::Result<()> {
        let index = config.get_id(self.author());
        anyhow::ensure!(
            index < config.verification_keys.len(),
            "Validator index {} out of bounds for verification_keys array of length {}",
            index,
            config.verification_keys.len()
        );
        let decryption_key_share = self.share().clone();
        config.verification_keys[index]
            .verify_decryption_key_share(&self.metadata.digest, &decryption_key_share)?;
        Ok(())
    }
}
```

## Proof of Concept
```rust
#[cfg(test)]
mod tests {
    use super::*;
    use aptos_types::validator_verifier::ValidatorVerifier;
    use std::sync::Arc;
    
    #[test]
    #[should_panic(expected = "index out of bounds")]
    fn test_verification_keys_out_of_bounds() {
        // Create a validator verifier with 4 validators
        let validator_verifier = create_validator_verifier_with_n_validators(4);
        
        // Create config with only 2 verification keys (insufficient)
        let verification_keys = vec![
            create_test_verification_key(0),
            create_test_verification_key(1),
        ];
        
        let config = SecretShareConfig::new(
            Author::random(),
            1,
            Arc::new(validator_verifier),
            create_test_digest_key(),
            create_test_msk_share(),
            verification_keys, // Only 2 keys for 4 validators
            create_test_threshold_config(3, 4),
            create_test_encryption_key(),
        );
        
        // Create a share from validator at index 3 (out of bounds)
        let share = create_test_secret_share_from_validator(3);
        
        // This will panic with out of bounds error
        let _ = share.verify(&config);
    }
}
```

**Notes**

The vulnerability stems from missing defensive validation at the configuration construction boundary and missing bounds checking at the array access point. While the `verification_keys` are typically sourced from trusted DKG transcripts, the lack of validation creates a fragile system where implementation bugs, race conditions, or edge cases during validator set changes could trigger node crashes. The explicit TODO comment in the code confirms this is a known gap that should be addressed.

### Citations

**File:** types/src/secret_sharing.rs (L75-82)
```rust
    pub fn verify(&self, config: &SecretShareConfig) -> anyhow::Result<()> {
        let index = config.get_id(self.author());
        let decryption_key_share = self.share().clone();
        // TODO(ibalajiarun): Check index out of bounds
        config.verification_keys[index]
            .verify_decryption_key_share(&self.metadata.digest, &decryption_key_share)?;
        Ok(())
    }
```

**File:** types/src/secret_sharing.rs (L148-170)
```rust
impl SecretShareConfig {
    pub fn new(
        author: Author,
        epoch: u64,
        validator: Arc<ValidatorVerifier>,
        digest_key: DigestKey,
        msk_share: MasterSecretKeyShare,
        verification_keys: Vec<VerificationKey>,
        config: <FPTXWeighted as BatchThresholdEncryption>::ThresholdConfig,
        encryption_key: EncryptionKey,
    ) -> Self {
        Self {
            _author: author,
            _epoch: epoch,
            validator,
            digest_key,
            msk_share,
            verification_keys,
            config,
            encryption_key,
            weights: HashMap::new(),
        }
    }
```

**File:** consensus/src/rand/secret_sharing/network_messages.rs (L28-38)
```rust
    pub fn verify(
        &self,
        epoch_state: &EpochState,
        config: &SecretShareConfig,
    ) -> anyhow::Result<()> {
        ensure!(self.epoch() == epoch_state.epoch);
        match self {
            SecretShareMessage::RequestShare(_) => Ok(()),
            SecretShareMessage::Share(share) => share.verify(config),
        }
    }
```

**File:** consensus/src/rand/secret_sharing/reliable_broadcast_state.rs (L44-52)
```rust
    fn add(&self, peer: Author, share: Self::Response) -> anyhow::Result<Option<()>> {
        ensure!(share.author() == &peer, "Author does not match");
        ensure!(
            share.metadata() == &self.secret_share_metadata,
            "Metadata does not match: local {:?}, received {:?}",
            self.secret_share_metadata,
            share.metadata()
        );
        share.verify(&self.secret_share_config)?;
```
