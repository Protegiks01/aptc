# Audit Report

## Title
Consensus Observer Pending Block Store Garbage Collection Selection Bias Enables Permanent Memory Exhaustion via Future Epoch Blocks

## Summary
The consensus observer's pending block store uses epoch-round tuple ordering for garbage collection, creating a critical bias where blocks claiming to be from future epochs are never removed. A Byzantine validator can exploit this by sending blocks with arbitrarily high epoch numbers, permanently occupying all 150 storage slots and preventing legitimate blocks from being processed.

## Finding Description

The consensus observer's pending block store maintains a `BTreeMap<(u64, Round), Arc<PendingBlockWithMetadata>>` where blocks are keyed by their (epoch, round) tuple. [1](#0-0) 

When the store reaches its capacity limit (`max_num_pending_blocks`, defaulting to 150), garbage collection is triggered. [2](#0-1) 

The garbage collection mechanism removes blocks using `pop_first()`, which removes entries with the **smallest** (epoch, round) tuple from the BTreeMap. [3](#0-2) 

**The critical flaw is in the validation logic before block insertion:**

When an ordered block message is received, the only epoch-related validation checks whether the block is **not older** than the last ordered block using `<=` comparison. [4](#0-3) 

There is **no upper bound check** on the epoch number. The `verify_ordered_blocks()` function only validates block structure and chaining, not epoch bounds. [5](#0-4) 

Blocks are inserted into the pending store without epoch validation: [6](#0-5) 

**Attack Propagation Path:**

1. Byzantine validator sends ordered blocks claiming to be from epoch 999,999,999
2. Blocks pass `verify_ordered_blocks()` structural validation (only checks structure)
3. Blocks pass `block_out_of_date` check since `(999999999, round) > (current_epoch, round)`
4. Blocks are inserted into `pending_block_store`
5. When garbage collection triggers, `pop_first()` removes blocks with the **lowest** epoch numbers
6. Legitimate blocks from current epoch get removed first because `(current_epoch, round) < (999999999, round)`
7. Attacker's future epoch blocks persist indefinitely

**Why blocks aren't removed:**

Epoch validation only occurs in `process_ordered_block()` when blocks are being processed (after payloads arrive): [7](#0-6) 

Attacker blocks from future epochs never reach this validation because they're waiting for payloads that will never arrive for non-existent epochs. There is no timeout-based expiry mechanism - only size-based garbage collection.

## Impact Explanation

**Severity: Medium**

This vulnerability enables a **Denial of Service** attack against consensus observer nodes with the following impacts:

1. **Resource Exhaustion**: Attacker permanently occupies all 150 pending block slots with invalid future epoch blocks
2. **Consensus Observer Unavailability**: Legitimate blocks cannot be stored in the pending block store, preventing the consensus observer from functioning
3. **Degraded Validator Fullnode Performance**: Validator fullnodes (VFNs) have consensus observer enabled by default, so this attack impacts their block processing capability [8](#0-7) 
4. **Network-Wide Impact**: An attacker can target multiple VFNs simultaneously with minimal resources

This qualifies as **Medium Severity** under the Aptos bug bounty criteria: "State inconsistencies requiring manual intervention" - the pending block store becomes permanently polluted, requiring node restart to clear.

## Likelihood Explanation

**Likelihood: Medium to High**

**CRITICAL CORRECTION to original claim:** The original claim stated "Any network peer can send ordered block messages" - this is **incorrect**. Only subscribed peers can send messages that will be accepted: [9](#0-8) 

**Corrected Attack Requirements:**
- **Requires being a subscribed peer**: Attacker must be a validator or VFN that the consensus observer has subscribed to
- **Byzantine validators are realistic**: Consensus observers subscribe to validators, and Byzantine validators (up to 1/3) are expected adversaries in the threat model
- **Low complexity**: Once subscribed, attacker only needs to craft ordered blocks with valid structure but inflated epoch numbers
- **Low cost**: Attack requires minimal bandwidth - sending 150 blocks once permanently occupies the store
- **No cryptographic bypass needed**: Blocks don't need valid signatures until processing stage, which never occurs

The attack is moderately likely because:
1. Consensus observer is enabled by default on validator fullnodes
2. Byzantine validators being selected for subscription is a realistic threat scenario
3. The vulnerability triggers deterministically with any future epoch value
4. No rate limiting prevents multiple future-epoch blocks from the same peer

## Recommendation

Add epoch validation before inserting blocks into the pending store. In `process_ordered_block_message()` (around line 673-676), add:

```rust
// Verify the block epoch is not from the future
let epoch_state = self.get_epoch_state();
if first_block.epoch() > epoch_state.epoch {
    error!(
        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
            "Received ordered block from future epoch! Current epoch: {}, Block epoch: {}. Ignoring: {:?}",
            epoch_state.epoch,
            first_block.epoch(),
            ordered_block.proof_block_info()
        ))
    );
    increment_invalid_message_counter(&peer_network_id, metrics::ORDERED_BLOCK_LABEL);
    return;
}
```

Alternatively, implement timeout-based expiry for pending blocks to prevent indefinite accumulation.

## Proof of Concept

This vulnerability can be demonstrated with a Rust unit test that:
1. Creates a pending block store with max 10 blocks
2. Inserts 5 blocks from current epoch (e.g., epoch 5)
3. Inserts 10 blocks from future epoch (e.g., epoch 999999)
4. Observes that garbage collection removes current epoch blocks, not future epoch blocks
5. Verifies that only future epoch blocks remain in the store

The test would be added to `consensus/src/consensus_observer/observer/pending_blocks.rs` test module, following the pattern of existing tests like `test_garbage_collect_pending_blocks`.

## Notes

- This is a **protocol logic vulnerability**, not a network DoS attack (which would be out of scope)
- The vulnerability exploits a flaw in the garbage collection algorithm's ordering assumption
- Byzantine validators being subscribed to is part of the expected threat model (up to 1/3 Byzantine is tolerated)
- The impact is limited to VFNs running consensus observer, not validators participating in consensus itself
- The fix is straightforward: validate epoch bounds before insertion into pending store

### Citations

**File:** consensus/src/consensus_observer/observer/pending_blocks.rs (L67-67)
```rust
    blocks_without_payloads: BTreeMap<(u64, Round), Arc<PendingBlockWithMetadata>>,
```

**File:** consensus/src/consensus_observer/observer/pending_blocks.rs (L178-179)
```rust
            if let Some((oldest_epoch_round, pending_block)) =
                self.blocks_without_payloads.pop_first()
```

**File:** config/src/config/consensus_observer_config.rs (L72-72)
```rust
            max_num_pending_blocks: 150, // 150 blocks (sufficient for existing production networks)
```

**File:** config/src/config/consensus_observer_config.rs (L119-128)
```rust
            NodeType::ValidatorFullnode => {
                if ENABLE_ON_VALIDATOR_FULLNODES
                    && !observer_manually_set
                    && !publisher_manually_set
                {
                    // Enable both the observer and the publisher for VFNs
                    consensus_observer_config.observer_enabled = true;
                    consensus_observer_config.publisher_enabled = true;
                    modified_config = true;
                }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L578-594)
```rust
        // Verify the message is from the peers we've subscribed to
        if let Err(error) = self
            .subscription_manager
            .verify_message_for_subscription(peer_network_id)
        {
            // Update the rejected message counter
            increment_rejected_message_counter(&peer_network_id, &message);

            // Log the error and return
            warn!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Received message that was not from an active subscription! Error: {:?}",
                    error,
                ))
            );
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L679-680)
```rust
        let block_out_of_date =
            first_block_epoch_round <= (last_ordered_block.epoch(), last_ordered_block.round());
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L710-712)
```rust
            self.observer_block_data
                .lock()
                .insert_pending_block(pending_block_with_metadata);
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L729-752)
```rust
        if ordered_block.proof_block_info().epoch() == epoch_state.epoch {
            if let Err(error) = ordered_block.verify_ordered_proof(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify ordered proof! Ignoring: {:?}, from peer: {:?}. Error: {:?}",
                        ordered_block.proof_block_info(),
                        peer_network_id,
                        error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::ORDERED_BLOCK_LABEL);
                return;
            }
        } else {
            // Drop the block and log an error (the block should always be for the current epoch)
            error!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Received ordered block for a different epoch! Ignoring: {:?}",
                    ordered_block.proof_block_info()
                ))
            );
            return;
        };
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L227-266)
```rust
    pub fn verify_ordered_blocks(&self) -> Result<(), Error> {
        // Verify that we have at least one ordered block
        if self.blocks.is_empty() {
            return Err(Error::InvalidMessageError(
                "Received empty ordered block!".to_string(),
            ));
        }

        // Verify the last block ID matches the ordered proof block ID
        if self.last_block().id() != self.proof_block_info().id() {
            return Err(Error::InvalidMessageError(
                format!(
                    "Last ordered block ID does not match the ordered proof ID! Number of blocks: {:?}, Last ordered block ID: {:?}, Ordered proof ID: {:?}",
                    self.blocks.len(),
                    self.last_block().id(),
                    self.proof_block_info().id()
                )
            ));
        }

        // Verify the blocks are correctly chained together (from the last block to the first)
        let mut expected_parent_id = None;
        for block in self.blocks.iter().rev() {
            if let Some(expected_parent_id) = expected_parent_id {
                if block.id() != expected_parent_id {
                    return Err(Error::InvalidMessageError(
                        format!(
                            "Block parent ID does not match the expected parent ID! Block ID: {:?}, Expected parent ID: {:?}",
                            block.id(),
                            expected_parent_id
                        )
                    ));
                }
            }

            expected_parent_id = Some(block.parent_id());
        }

        Ok(())
    }
```
