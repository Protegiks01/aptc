# Audit Report

## Title
EventFilter Excludes Validator Transactions, Preventing Delegators from Monitoring Staking Rewards

## Summary
The `EventFilter` implementation in the indexer-grpc transaction filter system hardcodes a `return false` for Validator transactions, making it impossible for delegators to use event filters to monitor staking reward distributions (`DistributeRewardsEvent`). Since these events are emitted in Validator transactions during DKG-based epoch reconfigurations, delegators attempting to filter for staking events receive zero results, effectively hiding validator performance and commission information.

## Finding Description

The transaction filter system provides an `EventFilter` that allows clients to filter transactions by the events they contain. However, in the filter matching logic, Validator transactions are unconditionally rejected without checking their events: [1](#0-0) 

When the transaction type is `TxnData::Validator(_)`, the code immediately returns `false` at line 474, bypassing event checking entirely. This means Validator transactions can never match an `EventFilter`, regardless of their event content.

The problem is critical because staking reward events are emitted in Validator transactions. During epoch transitions with DKG enabled (the production configuration), the reconfiguration process works as follows: [2](#0-1) 

The `stake::on_new_epoch()` function is called during reconfiguration, which distributes rewards and emits `DistributeRewardsEvent`: [3](#0-2) 

When DKG is enabled, this reconfiguration completes via a Validator transaction that finishes the DKG process: [4](#0-3) 

Real-world evidence confirms this: the test transaction file shows `DistributeRewardsEvent` emitted in a `TRANSACTION_TYPE_VALIDATOR` transaction during epoch 16643→16644 transition.

The filter is applied server-side when streaming transactions: [5](#0-4) 

And the filter originates from the client's request: [6](#0-5) 

## Impact Explanation

This issue qualifies as **High Severity** under the Aptos bug bounty program for the following reasons:

1. **Information Hiding**: Delegators attempting to monitor validator performance, staking rewards, or commission changes using the expected API (EventFilter) receive zero results. This breaks transparency guarantees essential to the staking system.

2. **Validator Exploitation Vector**: Malicious validators operating their own indexer-grpc services could:
   - Instruct delegators to use EventFilter for monitoring rewards (knowing it won't work)
   - Claim "no rewards were distributed" when queries return empty results
   - Hide poor performance or commission changes from delegators

3. **Significant Protocol Violation**: The indexer-grpc API promises event-based filtering, but silently fails for a critical use case (staking rewards). This violates the expected behavior of the filtering system.

4. **Systemic Impact**: All delegators using EventFilter to monitor staking rewards across the entire network are affected. This is not a corner case—it's a fundamental misalignment between the API design and the blockchain's transaction structure.

## Likelihood Explanation

**Likelihood: High**

1. **Common Use Case**: Monitoring staking rewards is a primary concern for delegators. Using EventFilter to query for `DistributeRewardsEvent` is the natural and expected approach.

2. **Undocumented Behavior**: There is no documentation warning that EventFilter doesn't work for Validator transactions. Developers would reasonably expect it to work for all transaction types that emit events.

3. **Production Configuration**: DKG is enabled in production Aptos networks, meaning all staking reward events are emitted in Validator transactions that the EventFilter silently excludes.

4. **No Warning or Error**: When EventFilter returns zero results, clients receive no indication that the filter is fundamentally incompatible with the query—they simply see "no matching transactions."

## Recommendation

Remove the hardcoded exclusion of Validator transactions from EventFilter matching logic. Validator transactions contain events just like other transaction types and should be checked against the event filter criteria:

```rust
APIFilter::EventFilter(events_filter) => {
    if let Some(txn_data) = &txn.txn_data {
        let events = match txn_data {
            TxnData::BlockMetadata(bm) => &bm.events,
            TxnData::Genesis(g) => &g.events,
            TxnData::StateCheckpoint(_) => return false,
            TxnData::User(u) => &u.events,
            // FIX: Check Validator transaction events instead of returning false
            TxnData::Validator(v) => &v.events,
            TxnData::BlockEpilogue(_) => return false,
        };
        events_filter.matches_vec(events)
    } else {
        false
    }
}
```

Similarly, BlockEpilogue transactions should also be checked if they contain events, though they currently don't appear to emit events in practice.

## Proof of Concept

```rust
// PoC demonstrating the issue
use aptos_transaction_filter::{BooleanTransactionFilter, EventFilterBuilder, MoveStructTagFilterBuilder, Filterable};
use aptos_protos::transaction::v1::Transaction;

#[test]
fn test_validator_transaction_event_filter_bug() {
    // Create a filter for DistributeRewardsEvent
    let event_filter = EventFilterBuilder::default()
        .struct_type(
            MoveStructTagFilterBuilder::default()
                .address("0x1")
                .module("stake")
                .name("DistributeRewardsEvent")
                .build()
                .unwrap()
        )
        .build()
        .unwrap();
    
    let filter = BooleanTransactionFilter::from(event_filter);
    
    // Load a real Validator transaction containing DistributeRewardsEvent
    // (from the test file: 5523474016_validator_txn.json)
    let validator_txn: Transaction = load_test_validator_transaction();
    
    // BUG: This returns false even though the transaction contains DistributeRewardsEvent!
    assert_eq!(filter.matches(&validator_txn), false, 
        "EventFilter incorrectly rejects Validator transactions with matching events");
    
    // Verify the transaction actually contains the event we're looking for
    if let Some(TxnData::Validator(v)) = &validator_txn.txn_data {
        let has_distribute_rewards = v.events.iter().any(|e| {
            e.r#type.as_ref()
                .and_then(|t| t.content.as_ref())
                .map(|c| matches!(c, Content::Struct(s) if 
                    s.address == "0x1" && 
                    s.module == "stake" && 
                    s.name == "DistributeRewardsEvent"))
                .unwrap_or(false)
        });
        assert!(has_distribute_rewards, "Transaction should contain DistributeRewardsEvent");
    }
    
    // Expected behavior: filter.matches() should return TRUE, not FALSE
}
```

**Reproduction Steps:**
1. Query an indexer-grpc service with an EventFilter for `0x1::stake::DistributeRewardsEvent`
2. Observe that no Validator transactions are returned, even during epoch transitions
3. Query the same range without a filter and verify Validator transactions with DistributeRewardsEvent exist
4. Confirm the discrepancy demonstrates the bug

## Notes

While this issue doesn't directly result in fund loss or consensus violation, it represents a significant violation of the transparency and information availability guarantees that underpin delegator trust in the staking system. The hardcoded exclusion appears to be an oversight rather than intentional design, as there's no documentation or code comment explaining why Validator transactions should be excluded from event filtering.

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/boolean_transaction_filter.rs (L467-482)
```rust
            APIFilter::EventFilter(events_filter) => {
                if let Some(txn_data) = &txn.txn_data {
                    let events = match txn_data {
                        TxnData::BlockMetadata(bm) => &bm.events,
                        TxnData::Genesis(g) => &g.events,
                        TxnData::StateCheckpoint(_) => return false,
                        TxnData::User(u) => &u.events,
                        TxnData::Validator(_) => return false,
                        TxnData::BlockEpilogue(_) => return false,
                    };
                    events_filter.matches_vec(events)
                } else {
                    false
                }
            },
        }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration.move (L133-134)
```text
        // Call stake to compute the new validator set and distribute rewards and transaction fees.
        stake::on_new_epoch();
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1738-1748)
```text
        if (std::features::module_event_migration_enabled()) {
            event::emit(DistributeRewards { pool_address, rewards_amount });
        } else {
            event::emit_event(
                &mut stake_pool.distribute_rewards_events,
                DistributeRewardsEvent {
                    pool_address,
                    rewards_amount,
                },
            );
        };
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L46-61)
```text
    public(friend) fun finish(framework: &signer) {
        system_addresses::assert_aptos_framework(framework);
        dkg::try_clear_incomplete_session(framework);
        consensus_config::on_new_epoch(framework);
        execution_config::on_new_epoch(framework);
        gas_schedule::on_new_epoch(framework);
        std::version::on_new_epoch(framework);
        features::on_new_epoch(framework);
        jwk_consensus_config::on_new_epoch(framework);
        jwks::on_new_epoch(framework);
        keyless_account::on_new_epoch(framework);
        randomness_config_seqnum::on_new_epoch(framework);
        randomness_config::on_new_epoch(framework);
        randomness_api_v0_config::on_new_epoch(framework);
        reconfiguration::reconfigure();
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L175-182)
```rust
                let pb_txns = if let Some(ref filter) = filter {
                    pb_txns
                        .into_iter()
                        .filter(|txn| filter.matches(txn))
                        .collect::<Vec<_>>()
                } else {
                    pb_txns
                };
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/localnet_data_service.rs (L64-71)
```rust
        let filter = if let Some(proto_filter) = r.transaction_filter {
            Some(parse_transaction_filter(
                proto_filter,
                self.service_context.max_transaction_filter_size_bytes,
            )?)
        } else {
            None
        };
```
