# Audit Report

## Title
Storage Fee Bypass for Orderless Transaction Nonce Insertions on Failed Transactions

## Summary
When orderless transactions fail during execution, the nonce inserted during prologue validation is persisted to blockchain state without charging storage fees, enabling attackers to bloat the global nonce table at zero cost.

## Finding Description

In the Aptos VM transaction execution flow, when a transaction fails after prologue execution, the system must clean up and charge appropriate fees. However, there is a critical discrepancy in how storage fees are charged depending on whether account creation is needed.

For orderless transactions (using nonce-based replay protection), the prologue calls `check_and_insert_nonce` which modifies the global `NonceHistory` resource at `@aptos_framework`, inserting the transaction's nonce into persistent state. [1](#0-0) 

The prologue executes with `UnmeteredGasMeter`, meaning no gas or storage fees are charged during this phase: [2](#0-1) 

When `gas_feature_version >= 1`, prologue state changes are captured in a `SystemSessionChangeSet`: [3](#0-2) 

**The Critical Bug:** In `finish_aborted_transaction`, when account creation is NOT needed, the prologue changes (including nonce insertions) are passed through without charging storage fees: [4](#0-3) 

This contrasts with the account creation branch, which properly calls `charge_change_set()`: [5](#0-4) 

The `charge_change_set()` function processes storage fees via `process_storage_fee_for_all`, which is bypassed in the non-account-creation path: [6](#0-5) 

The prologue changes are then passed to the epilogue session, which includes them in the final VMOutput without corresponding storage fees in the fee statement: [7](#0-6) 

**Attack Path:**
1. Attacker creates an account (one-time setup)
2. Submits orderless transaction with nonce N that will fail execution (e.g., entry function that aborts)
3. Prologue validates transaction and inserts nonce into `NonceHistory` without charging storage fees
4. Transaction execution fails during user session
5. Since account exists, `finish_aborted_transaction` takes the else branch (lines 787-791)
6. Fee statement created without calling `charge_change_set()` on prologue changes
7. Transaction is committed with nonce marked as used, but no storage fee charged
8. Attacker repeats with different nonces, bloating the nonce table at zero cost

## Impact Explanation

**Severity: Medium** (per Aptos Bug Bounty criteria)

This vulnerability enables two related attacks:

1. **State Bloat Attack:** Attackers can insert unlimited nonces into the global `NonceHistory` table without paying storage fees, consuming blockchain state storage at zero cost. Each nonce insertion adds entries to both the `nonces_ordered_by_exp_time` and `nonce_to_exp_time_map` data structures within the bucketed table.

2. **Storage Fee Bypass:** This violates the fundamental blockchain invariant that all state modifications must pay appropriate storage fees. The unpaid storage fees represent a loss to the network's economic model.

While this doesn't directly lead to fund theft or consensus violations, it represents "State inconsistencies" through unmetered state growth and "Limited funds loss" through unpaid storage fees. The impact is limited to orderless transactions when they fail and the sender account already exists, but is unbounded within those constraints.

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability is exploitable under the following conditions:
- Orderless transactions feature must be enabled (controlled by on-chain feature flag)
- Attacker's account must already exist (trivial - create once, exploit indefinitely)
- Transaction must fail during execution, not during prologue (easy to craft - just call a function that aborts)

Once orderless transactions are enabled on the network, exploitation is straightforward and requires no special privileges. The attacker simply crafts transactions that will fail predictably (e.g., calling an entry function designed to abort or assert false) while using different nonces each time. There are no rate limits or economic disincentives since the storage fees are bypassed.

## Recommendation

Modify `finish_aborted_transaction` to charge storage fees for prologue changes in both code paths. Specifically, in the else branch (lines 787-791), call `charge_change_set()` on the `prologue_session_change_set` before creating the fee statement:

```rust
} else {
    // Charge storage fees for prologue changes even when account creation is not needed
    let mut changeable_prologue_changes = prologue_session_change_set;
    if let Err(err) = self.charge_change_set(
        &mut changeable_prologue_changes,
        gas_meter,
        txn_data,
        resolver,
        module_storage,
    ) {
        info!(
            *log_context,
            "Failed during charge_change_set for prologue: {:?}. Most likely exceeded gas limit.", err,
        );
    }
    
    let fee_statement =
        AptosVM::fee_statement_from_gas_meter(txn_data, gas_meter, ZERO_STORAGE_REFUND);
    (changeable_prologue_changes, fee_statement)
};
```

This ensures consistent storage fee charging regardless of whether account creation is needed.

## Proof of Concept

A proof of concept would involve:
1. Enabling the orderless transactions feature flag in a test environment
2. Creating an account with sufficient gas
3. Submitting multiple orderless transactions with different nonces that call an entry function designed to abort
4. Observing that each transaction's nonce is inserted into the `NonceHistory` table
5. Verifying that the storage fees charged do not include costs for the nonce insertions
6. Demonstrating state bloat through unlimited nonce insertions at minimal cost

The vulnerability can be demonstrated by comparing gas costs between:
- A successful orderless transaction (which doesn't insert nonces in prologue, or charges properly)
- A failed orderless transaction with an existing account (which bypasses storage fees)
- A failed orderless transaction requiring account creation (which charges storage fees)

The discrepancy in storage fee charging between the latter two scenarios confirms the vulnerability.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/nonce_validation.move (L195-202)
```text
        // Insert the (address, nonce) pair in the bucket.
        let nonce_key_with_exp_time = NonceKeyWithExpTime {
            txn_expiration_time,
            sender_address,
            nonce,
        };
        bucket.nonces_ordered_by_exp_time.add(nonce_key_with_exp_time, true);
        bucket.nonce_to_exp_time_map.add(nonce_key, txn_expiration_time);
```

**File:** aptos-move/aptos-vm/src/transaction_validation.rs (L123-123)
```rust
    let mut gas_meter = UnmeteredGasMeter;
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/user_transaction_sessions/prologue.rs (L59-80)
```rust
        if vm.gas_feature_version() >= 1 {
            // Create a new session so that the data cache is flushed.
            // This is to ensure we correctly charge for loading certain resources, even if they
            // have been previously cached in the prologue.
            //
            // TODO(Gas): Do this in a better way in the future, perhaps without forcing the data cache to be flushed.
            // By releasing resource group cache, we start with a fresh slate for resource group
            // cost accounting.

            let change_set = session.finish_with_squashed_change_set(
                change_set_configs,
                module_storage,
                false,
            )?;
            let prologue_session_change_set =
                SystemSessionChangeSet::new(change_set.clone(), change_set_configs)?;

            resolver.release_resource_group_cache();
            Ok((
                prologue_session_change_set,
                UserSession::new(vm, txn_meta, resolver, change_set),
            ))
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L743-754)
```rust
            if let Err(err) = self.charge_change_set(
                &mut abort_hook_session_change_set,
                gas_meter,
                txn_data,
                resolver,
                module_storage,
            ) {
                info!(
                    *log_context,
                    "Failed during charge_change_set: {:?}. Most likely exceeded gas limited.", err,
                );
            };
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L787-791)
```rust
        } else {
            let fee_statement =
                AptosVM::fee_statement_from_gas_meter(txn_data, gas_meter, ZERO_STORAGE_REFUND);
            (prologue_session_change_set, fee_statement)
        };
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L793-798)
```rust
        let mut epilogue_session = EpilogueSession::on_user_session_failure(
            self,
            txn_data,
            resolver,
            previous_session_change_set,
        );
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1128-1134)
```rust
        let mut storage_refund = gas_meter.process_storage_fee_for_all(
            change_set,
            txn_data.transaction_size,
            txn_data.gas_unit_price,
            resolver.as_executor_view(),
            module_storage,
        )?;
```
