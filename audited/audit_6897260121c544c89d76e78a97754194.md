# Audit Report

## Title
TOCTOU Race Condition in Internal Indexer Ledger Info Causes API State Inconsistency

## Summary
The `get_latest_internal_indexer_ledger_info()` function contains a Time-of-Check-Time-of-Use (TOCTOU) race condition that allows the API to return a ledger version higher than what the internal indexer has processed. This causes state inconsistencies where the API advertises a ledger version as available, but subsequent queries at that version fail when routed through the indexer.

## Finding Description
The vulnerability exists in the interaction between the indexer version clamping logic and the block info retrieval in `api/src/context.rs`. [1](#0-0) 

The function performs these steps:
1. Retrieves the latest internal indexer ledger version (e.g., version 100)
2. Calls `get_latest_storage_ledger_info()` to get the storage version and clamps to `min(indexer_version, storage_version)` (e.g., min(100, 110) = 100)
3. Calls `get_block_info_by_version(latest_version)` with the clamped version

However, inside `get_block_info_by_version()`, the function `to_api_block_info()` has a critical flaw: [2](#0-1) 

The `to_api_block_info()` function retrieves the CURRENT committed version from storage at line 381, which may have advanced beyond the clamped version due to concurrent block commits. When determining the block's last version, if there is no next block (the queried version is in the latest block), it uses this CURRENT committed version as the block's end version (line 396), rather than respecting the clamped value.

This creates a scenario where:
- The indexer has processed up to version 100
- The API returns LedgerInfo with version 115 (the current committed version at the time of `to_api_block_info()` execution)
- Client applications receive version 115 as the latest available version
- When clients query resources/state at version 115 with db_sharding enabled, the request routes through the indexer [3](#0-2) 

The indexer validates the requested version: [4](#0-3) 

The `ensure_cover_ledger_version()` check fails because the indexer only has data up to version 100: [5](#0-4) 

This violates the **State Consistency** invariant: the API provides conflicting information about ledger version availability across different endpoints.

## Impact Explanation
This vulnerability falls under **Medium Severity** per the Aptos bug bounty program: "State inconsistencies requiring intervention."

**Impact:**
1. **API Inconsistency**: Different API calls return conflicting ledger versions
2. **Client Application Failures**: Applications that rely on `get_latest_ledger_info()` followed by state queries will encounter unexpected "ledger version too new" errors
3. **Service Degradation**: When db_sharding is enabled, affected queries fail despite the API advertising those versions as available
4. **Information Disclosure**: Attackers can detect internal indexer lag by monitoring for these inconsistencies
5. **Potential DoS**: Repeated failures can impact API-dependent services

The issue does not directly cause consensus violations or fund loss, but creates operational inconsistencies that undermine the API's reliability guarantee that the advertised ledger version is queryable.

## Likelihood Explanation
**Likelihood: HIGH**

This vulnerability occurs naturally under normal operating conditions:
- **No attacker action required**: The race condition happens due to concurrent storage updates
- **Common scenario**: Internal indexers often lag behind storage during high transaction throughput
- **Persistent condition**: Once indexer lag exists, every API call during active block production can trigger this
- **Easy to observe**: Any API consumer can detect this by calling `get_latest_ledger_info()` followed by resource queries
- **Configuration dependent**: More likely when db_sharding is enabled (forces queries through indexer)

The vulnerability requires no special privileges, authentication, or coordination. It naturally manifests whenever:
1. Internal indexer is enabled and lagging
2. Storage is actively committing new blocks
3. API calls occur during the race window between clamping and block info retrieval

## Recommendation
**Fix the TOCTOU race condition by passing the clamped storage version as an upper bound to block info retrieval.**

Modify `get_latest_internal_indexer_ledger_info()` to store the storage version at the time of clamping and use it consistently:

```rust
pub fn get_latest_internal_indexer_ledger_info<E: ServiceUnavailableError>(
    &self,
) -> Result<LedgerInfo, E> {
    if let Some(indexer_reader) = self.indexer_reader.as_ref() {
        if indexer_reader.is_internal_indexer_enabled() {
            if let Some(mut latest_version) = indexer_reader
                .get_latest_internal_indexer_ledger_version()
                .map_err(|err| {
                    E::service_unavailable_with_code_no_info(err, AptosErrorCode::InternalError)
                })?
            {
                // Get storage version and clamp
                let storage_ledger_info = self.get_latest_storage_ledger_info()?;
                let last_storage_version = storage_ledger_info.ledger_version.0;
                latest_version = std::cmp::min(latest_version, last_storage_version);
                
                // If clamped to storage version, return storage ledger info directly
                // to avoid the race condition in get_block_info_by_version
                if latest_version == last_storage_version {
                    return Ok(storage_ledger_info);
                }
                
                // Otherwise, use the indexer version
                let (_, block_end_version, new_block_event) = self
                    .db
                    .get_block_info_by_version(latest_version)
                    .map_err(|_| {
                        E::service_unavailable_with_code_no_info(
                            "Failed to get block",
                            AptosErrorCode::InternalError,
                        )
                    })?;
                let (oldest_version, oldest_block_height) =
                    self.get_oldest_version_and_block_height()?;
                return Ok(LedgerInfo::new_ledger_info(
                    &self.chain_id(),
                    new_block_event.epoch(),
                    block_end_version,
                    oldest_version,
                    oldest_block_height,
                    new_block_event.height(),
                    new_block_event.proposed_time(),
                ));
            }
        }
    }
    Err(E::service_unavailable_with_code_no_info(
        "Indexer reader doesn't exist",
        AptosErrorCode::InternalError,
    ))
}
```

Alternatively, modify `to_api_block_info()` to accept an optional upper bound for the committed version to prevent returning versions beyond the clamped value.

## Proof of Concept

```rust
#[cfg(test)]
mod test_indexer_race_condition {
    use super::*;
    use std::sync::{Arc, Mutex};
    use std::thread;
    use std::time::Duration;

    #[test]
    fn test_indexer_storage_version_inconsistency() {
        // Setup: Create a context with internal indexer enabled
        // Indexer is at version 100
        // Storage is at version 110
        
        let context = setup_test_context_with_indexer_lag(100, 110);
        
        // Thread 1: Continuously commit new blocks to storage
        let storage_thread = thread::spawn(move || {
            // Simulate continuous block commits
            for _ in 0..10 {
                commit_new_block_to_storage(); // Advances storage to 111, 112, etc.
                thread::sleep(Duration::from_millis(10));
            }
        });
        
        // Thread 2: Call get_latest_ledger_info repeatedly
        let versions_returned = Arc::new(Mutex::new(Vec::new()));
        let versions_clone = versions_returned.clone();
        
        let api_thread = thread::spawn(move || {
            for _ in 0..20 {
                let ledger_info = context.get_latest_ledger_info::<BasicError>().unwrap();
                versions_clone.lock().unwrap().push(ledger_info.version());
                thread::sleep(Duration::from_millis(5));
            }
        });
        
        storage_thread.join().unwrap();
        api_thread.join().unwrap();
        
        let versions = versions_returned.lock().unwrap();
        
        // Verify inconsistency: Some versions returned should be > 110
        // even though indexer is stuck at 100
        let max_version = versions.iter().max().unwrap();
        assert!(*max_version > 110, "Race condition should cause version > storage at clamp time");
        
        // Verify subsequent queries fail
        for version in versions.iter() {
            if *version > 100 {
                // This should fail when db_sharding is enabled
                let result = context.get_resources_by_pagination(
                    test_address(),
                    None,
                    *version,
                    100
                );
                assert!(result.is_err(), "Query should fail: indexer only has version 100");
                assert!(result.unwrap_err().to_string().contains("ledger version too new"));
            }
        }
    }
}
```

**Notes:**
- The vulnerability is most easily reproduced in environments with high block production rate and indexer lag
- Enable db_sharding in node config to force queries through the indexer path
- Monitor API responses for ledger versions that exceed the internal indexer's processed version
- The race window is small but occurs frequently under normal operation when indexer is lagging

### Citations

**File:** api/src/context.rs (L319-368)
```rust
    pub fn get_latest_internal_indexer_ledger_info<E: ServiceUnavailableError>(
        &self,
    ) -> Result<LedgerInfo, E> {
        if let Some(indexer_reader) = self.indexer_reader.as_ref() {
            if indexer_reader.is_internal_indexer_enabled() {
                if let Some(mut latest_version) = indexer_reader
                    .get_latest_internal_indexer_ledger_version()
                    .map_err(|err| {
                        E::service_unavailable_with_code_no_info(err, AptosErrorCode::InternalError)
                    })?
                {
                    // The internal indexer version can be ahead of the storage committed version since it syncs to db's latest synced version
                    let last_storage_version =
                        self.get_latest_storage_ledger_info()?.ledger_version.0;
                    latest_version = std::cmp::min(latest_version, last_storage_version);
                    let (_, block_end_version, new_block_event) = self
                        .db
                        .get_block_info_by_version(latest_version)
                        .map_err(|_| {
                            E::service_unavailable_with_code_no_info(
                                "Failed to get block",
                                AptosErrorCode::InternalError,
                            )
                        })?;
                    let (oldest_version, oldest_block_height) =
                        self.get_oldest_version_and_block_height()?;
                    return Ok(LedgerInfo::new_ledger_info(
                        &self.chain_id(),
                        new_block_event.epoch(),
                        block_end_version,
                        oldest_version,
                        oldest_block_height,
                        new_block_event.height(),
                        new_block_event.proposed_time(),
                    ));
                } else {
                    // Indexer doesn't have data yet as DB is boostrapping.
                    return Err(E::service_unavailable_with_code_no_info(
                        "DB is bootstrapping",
                        AptosErrorCode::InternalError,
                    ));
                }
            }
        }

        Err(E::service_unavailable_with_code_no_info(
            "Indexer reader doesn't exist",
            AptosErrorCode::InternalError,
        ))
    }
```

**File:** api/src/context.rs (L477-496)
```rust
        let account_iter = if !db_sharding_enabled(&self.node_config) {
            Box::new(
                self.db
                    .get_prefixed_state_value_iterator(
                        &StateKeyPrefix::from(address),
                        prev_state_key,
                        version,
                    )?
                    .map(|item| item.map_err(|err| anyhow!(err.to_string()))),
            )
        } else {
            self.indexer_reader
                .as_ref()
                .ok_or_else(|| format_err!("Indexer reader doesn't exist"))?
                .get_prefixed_state_value_iterator(
                    &StateKeyPrefix::from(address),
                    prev_state_key,
                    version,
                )?
        };
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L374-405)
```rust
    pub(super) fn to_api_block_info(
        &self,
        block_height: u64,
        block_info: BlockInfo,
    ) -> Result<(Version, Version, NewBlockEvent)> {
        // N.b. Must use committed_version because if synced version is used, we won't be able
        // to tell the end of the latest block.
        let committed_version = self.get_latest_ledger_info_version()?;
        ensure!(
            block_info.first_version() <= committed_version,
            "block first version {} > committed version {committed_version}",
            block_info.first_version(),
        );

        // TODO(grao): Consider return BlockInfo instead of NewBlockEvent.
        let new_block_event = self
            .ledger_db
            .event_db()
            .expect_new_block_event(block_info.first_version())?;

        let last_version = match self.get_raw_block_info_by_height(block_height + 1) {
            Ok(next_block_info) => next_block_info.first_version() - 1,
            Err(AptosDbError::NotFound(..)) => committed_version,
            Err(err) => return Err(err),
        };

        Ok((
            block_info.first_version(),
            last_version,
            bcs::from_bytes(new_block_event.event_data())?,
        ))
    }
```

**File:** storage/indexer/src/db_indexer.rs (L163-172)
```rust
    pub fn ensure_cover_ledger_version(&self, ledger_version: Version) -> Result<()> {
        let indexer_latest_version = self.get_persisted_version()?;
        if let Some(indexer_latest_version) = indexer_latest_version {
            if indexer_latest_version >= ledger_version {
                return Ok(());
            }
        }

        bail!("ledger version too new")
    }
```

**File:** storage/indexer/src/db_indexer.rs (L614-629)
```rust
    pub fn get_prefixed_state_value_iterator(
        &self,
        key_prefix: &StateKeyPrefix,
        cursor: Option<&StateKey>,
        ledger_version: Version,
    ) -> Result<impl Iterator<Item = anyhow::Result<(StateKey, StateValue)>> + '_ + use<'_>> {
        self.indexer_db
            .ensure_cover_ledger_version(ledger_version)?;
        PrefixedStateValueIterator::new(
            self.main_db_reader.clone(),
            self.indexer_db.get_inner_db_ref(),
            key_prefix.clone(),
            cursor.cloned(),
            ledger_version,
        )
    }
```
