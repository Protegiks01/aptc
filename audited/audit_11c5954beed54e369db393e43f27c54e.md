# Audit Report

## Title
Integer Overflow in Epoch Ending Manifest Validation Allows Malicious JSON to Bypass Verification and Crash Restore Process

## Summary
The epoch ending backup manifest verification contains multiple integer overflow vulnerabilities that allow an attacker to craft malicious JSON that passes deserialization and all validation checks, but causes a panic during the restore process. This breaks the security guarantee that manifest validation should reject malformed backups before processing.

## Finding Description

The vulnerability exists in the `EpochEndingBackup::verify()` method which performs validation of the manifest structure after JSON deserialization. [1](#0-0) 

The critical flaw is at the waypoint count validation where integer overflow in release mode causes the check to pass with invalid values. Specifically, when `first_epoch = 0` and `last_epoch = u64::MAX`, the expression `self.last_epoch - self.first_epoch + 1` overflows from `u64::MAX + 1` to `0`, matching an empty waypoints vector.

A second overflow occurs in chunk range validation where `next_epoch = chunk.last_epoch + 1` overflows when `chunk.last_epoch = u64::MAX`. [2](#0-1) 

The subtraction `next_epoch - 1` at line 61 then underflows from `0 - 1` to `u64::MAX`, incorrectly matching `self.last_epoch`.

**Attack Path:**

1. Attacker crafts malicious manifest JSON:
   ```json
   {
     "first_epoch": 0,
     "last_epoch": 18446744073709551615,
     "waypoints": [],
     "chunks": [{
       "first_epoch": 0,
       "last_epoch": 18446744073709551615,
       "ledger_infos": "empty_chunk_file"
     }]
   }
   ```

2. The manifest is loaded via `load_json_file()` and successfully deserialized. [3](#0-2) 

3. `manifest.verify()` passes all checks due to integer overflows

4. The `preheat_impl()` function processes the manifest with an empty waypoint iterator and returns an empty `ledger_infos` vector. [4](#0-3) 

5. The `run_impl()` method attempts to access the first element and panics with "Epoch ending backup can't be empty." [5](#0-4) 

This bypasses the security invariant that manifest verification should catch all malformed manifests before they can cause issues during processing.

## Impact Explanation

This vulnerability qualifies as **High Severity** according to Aptos bug bounty criteria because it causes "API crashes" in a critical system component.

**Security Impact:**
- **Denial of Service**: The restore process crashes with a panic, preventing successful backup restoration
- **Validation Bypass**: Malformed manifests that should be rejected pass all security checks
- **Disaster Recovery Failure**: Node operators cannot restore nodes from compromised backups, impacting availability during critical recovery scenarios

**Scope:**
- Affects all nodes attempting to restore from epoch ending backups
- Both restore and verify modes are impacted
- No direct impact on consensus, funds, or live validator operations
- Does not corrupt state or cause persistent damage

While this doesn't directly affect consensus or cause fund loss, it represents a significant protocol violation where security validation logic can be bypassed through integer overflow, and it prevents critical disaster recovery operations.

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability is easily exploitable if an attacker can provide a malicious manifest file. This requires:

1. **Attack Surface**: The manifest must be controlled by or accessible to the attacker
   - Compromised backup storage system
   - Man-in-the-middle during manifest transmission
   - Malicious node operator intentionally creating invalid backups

2. **Complexity**: The attack is trivial once the attacker has manifest control
   - Simple JSON with specific numeric values
   - No cryptographic or consensus knowledge required
   - Deterministically triggers the vulnerability

3. **Detection**: The attack is difficult to detect before execution
   - Passes all validation checks
   - Only fails during actual processing
   - No anomalous patterns in the JSON structure

While backup storage is typically trusted infrastructure, supply chain attacks, insider threats, or storage compromises make this a realistic attack vector. The ease of exploitation and significant operational impact make this a concerning vulnerability.

## Recommendation

**Immediate Fix:** Add overflow-checked arithmetic to all epoch range calculations in the verify method:

```rust
pub fn verify(&self) -> Result<()> {
    // Check number of waypoints with overflow protection
    ensure!(
        self.first_epoch <= self.last_epoch,
        "first_epoch must be <= last_epoch"
    );
    
    let expected_waypoints = self.last_epoch
        .checked_sub(self.first_epoch)
        .and_then(|diff| diff.checked_add(1))
        .ok_or_else(|| anyhow!("Epoch range calculation overflows"))?;
    
    ensure!(
        expected_waypoints == self.waypoints.len() as u64,
        "Expected {} waypoints, found {}",
        expected_waypoints,
        self.waypoints.len()
    );
    
    // Check chunk ranges with overflow protection
    ensure!(!self.chunks.is_empty(), "No chunks.");
    let mut next_epoch = self.first_epoch;
    for chunk in &self.chunks {
        ensure!(
            chunk.first_epoch == next_epoch,
            "Chunk ranges not continuous. Expected: {}, actual: {}",
            next_epoch,
            chunk.first_epoch,
        );
        ensure!(
            chunk.last_epoch >= chunk.first_epoch,
            "Invalid chunk range [{}, {}]",
            chunk.first_epoch,
            chunk.last_epoch,
        );
        next_epoch = chunk.last_epoch
            .checked_add(1)
            .ok_or_else(|| anyhow!("Chunk range calculation overflows"))?;
    }
    
    let final_epoch = next_epoch
        .checked_sub(1)
        .ok_or_else(|| anyhow!("Final epoch calculation underflows"))?;
    
    ensure!(
        final_epoch == self.last_epoch,
        "Last epoch mismatch: {} vs {}",
        final_epoch,
        self.last_epoch
    );
    
    Ok(())
}
```

**Additional Hardening:**
1. Add explicit sanity checks for reasonable epoch ranges (e.g., reject if `last_epoch - first_epoch > MAX_REASONABLE_EPOCHS`)
2. Add early validation that `ledger_infos` is non-empty in `preheat_impl()` before returning
3. Consider using saturating arithmetic or explicit overflow checks in debug builds
4. Add fuzzing tests specifically targeting integer boundary conditions

## Proof of Concept

```rust
#[cfg(test)]
mod overflow_vulnerability_test {
    use super::*;
    use crate::backup_types::epoch_ending::manifest::{EpochEndingBackup, EpochEndingChunk};
    use crate::storage::FileHandle;
    
    #[test]
    fn test_integer_overflow_bypasses_validation() {
        // Create malicious manifest exploiting integer overflow
        let malicious_manifest = EpochEndingBackup {
            first_epoch: 0,
            last_epoch: u64::MAX,
            waypoints: vec![], // Empty, but should require u64::MAX+1 waypoints
            chunks: vec![EpochEndingChunk {
                first_epoch: 0,
                last_epoch: u64::MAX,
                ledger_infos: FileHandle::new("empty_chunk"),
            }],
        };
        
        // This should FAIL but currently PASSES due to overflow
        // Expected: last_epoch - first_epoch + 1 = u64::MAX + 1 (overflow to 0)
        // Actual: 0 == waypoints.len() (0) -> true
        let verify_result = malicious_manifest.verify();
        
        assert!(verify_result.is_ok(), 
            "Vulnerability confirmed: manifest with overflow passes verification");
        
        // Demonstrate the overflow calculation
        let calculated = u64::MAX.wrapping_sub(0).wrapping_add(1);
        assert_eq!(calculated, 0, "Overflow causes calculation to wrap to 0");
        assert_eq!(calculated, malicious_manifest.waypoints.len() as u64,
            "Zero waypoints incorrectly match overflowed calculation");
    }
    
    #[test]
    fn test_chunk_range_overflow() {
        let manifest = EpochEndingBackup {
            first_epoch: 0,
            last_epoch: u64::MAX,
            waypoints: vec![],
            chunks: vec![EpochEndingChunk {
                first_epoch: 0,
                last_epoch: u64::MAX,
                ledger_infos: FileHandle::new("chunk"),
            }],
        };
        
        // Verify passes due to overflow in chunk validation
        assert!(manifest.verify().is_ok());
        
        // Demonstrate: next_epoch = u64::MAX + 1 = 0 (overflow)
        // Then: next_epoch - 1 = 0 - 1 = u64::MAX (underflow)
        // Incorrectly matches last_epoch
        let next_epoch_after_chunk = u64::MAX.wrapping_add(1);
        assert_eq!(next_epoch_after_chunk, 0);
        
        let final_check = next_epoch_after_chunk.wrapping_sub(1);
        assert_eq!(final_check, u64::MAX);
        assert_eq!(final_check, manifest.last_epoch);
    }
}
```

**To demonstrate the full attack:**

1. Create a test file with the malicious manifest JSON
2. Use the backup-cli restore command with this manifest
3. Observe that verification passes but restore panics
4. Apply the recommended fix with `checked_add`/`checked_sub`
5. Verify the manifest is now correctly rejected with overflow error

## Notes

This vulnerability demonstrates a critical lesson in secure systems programming: integer overflow in validation logic can completely bypass security checks. While Rust provides excellent memory safety guarantees, arithmetic overflow in release mode still requires explicit handling through checked operations.

The vulnerability is particularly insidious because it passes all type checking, deserialization, and even the validation logic's structural checksâ€”only failing when the system attempts to process the logically invalid data. This highlights the importance of overflow-safe arithmetic in all validation and security-critical code paths.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/manifest.rs (L29-38)
```rust
    pub fn verify(&self) -> Result<()> {
        // check number of waypoints
        ensure!(
            self.first_epoch <= self.last_epoch
                && self.last_epoch - self.first_epoch + 1 == self.waypoints.len() as u64,
            "Malformed manifest. first epoch: {}, last epoch {}, num waypoints {}",
            self.first_epoch,
            self.last_epoch,
            self.waypoints.len(),
        );
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/manifest.rs (L56-65)
```rust
            next_epoch = chunk.last_epoch + 1;
        }

        // check last epoch in chunk matches manifest
        ensure!(
            next_epoch - 1 == self.last_epoch, // okay to -1 because chunks is not empty.
            "Last epoch in chunks: {}, in manifest: {}",
            next_epoch - 1,
            self.last_epoch,
        );
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L80-158)
```rust
    async fn preheat_impl(&self) -> Result<EpochEndingRestorePreheatData> {
        let manifest: EpochEndingBackup =
            self.storage.load_json_file(&self.manifest_handle).await?;
        manifest.verify()?;

        let mut next_epoch = manifest.first_epoch;
        let mut waypoint_iter = manifest.waypoints.iter();

        let mut previous_li: Option<&LedgerInfoWithSignatures> = None;
        let mut ledger_infos = Vec::new();

        let mut past_target = false;
        for chunk in &manifest.chunks {
            if past_target {
                break;
            }

            let lis = self.read_chunk(&chunk.ledger_infos).await?;
            ensure!(
                chunk.first_epoch + lis.len() as u64 == chunk.last_epoch + 1,
                "Number of items in chunks doesn't match that in manifest. \
                first_epoch: {}, last_epoch: {}, items in chunk: {}",
                chunk.first_epoch,
                chunk.last_epoch,
                lis.len(),
            );

            for li in lis {
                if li.ledger_info().version() > self.target_version {
                    past_target = true;
                    break;
                }

                ensure!(
                    li.ledger_info().epoch() == next_epoch,
                    "LedgerInfo epoch not expected. Expected: {}, actual: {}.",
                    li.ledger_info().epoch(),
                    next_epoch,
                );
                let wp_manifest = waypoint_iter.next().ok_or_else(|| {
                    anyhow!("More LedgerInfo's found than waypoints in manifest.")
                })?;
                let wp_li = Waypoint::new_epoch_boundary(li.ledger_info())?;
                ensure!(
                    *wp_manifest == wp_li,
                    "Waypoints don't match. In manifest: {}, In chunk: {}",
                    wp_manifest,
                    wp_li,
                );
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
                }
                ledger_infos.push(li);
                previous_li = ledger_infos.last();
                next_epoch += 1;
            }
        }

        Ok(EpochEndingRestorePreheatData {
            manifest,
            ledger_infos,
        })
    }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L213-216)
```rust
        let first_li = preheat_data
            .ledger_infos
            .first()
            .expect("Epoch ending backup can't be empty.");
```
