# Audit Report

## Title
Integer Overflow in Transaction Backup Manifest Verification Leading to Node Crash

## Summary
The `verify()` function in `TransactionBackup` performs unchecked integer arithmetic that causes a panic when processing a single-chunk manifest with `last_version = u64::MAX`. This allows an attacker to crash nodes during backup restoration operations by providing a malicious backup manifest.

## Finding Description

The vulnerability exists in the `verify()` function of `TransactionBackup` [1](#0-0) 

When a backup manifest contains a single chunk spanning the maximum version range, the verification logic performs: `next_version = chunk.last_version + 1` at line 76. [2](#0-1) 

If `chunk.last_version = u64::MAX`, this addition causes integer overflow. The Aptos codebase has `overflow-checks = true` enabled in release builds [3](#0-2) , which means this overflow will panic and crash the node.

**Why Single Chunk Matters**: With multiple chunks, the maximum `last_version` for any chunk except the last must be less than `u64::MAX` to allow subsequent chunks (since `next_version = last_version + 1` must be valid for the next chunk's `first_version`). However, with a single chunk, no such constraint exists - the chunk can legitimately span from `first_version` to `u64::MAX`, triggering the overflow during verification.

The malicious manifest is loaded from external backup storage during restoration operations [4](#0-3) 

A second overflow point exists in `LoadedChunk::load()` which also performs `manifest.last_version + 1` [5](#0-4) 

## Impact Explanation

This vulnerability meets **Medium severity** criteria per the Aptos bug bounty program:
- **State inconsistencies requiring intervention**: Node crashes during backup restoration prevent disaster recovery operations and require manual intervention to recover
- **Availability impact**: Targeted nodes attempting backup restoration become unavailable
- **Operational disruption**: Prevents legitimate backup/restore operations, a critical operational capability for validators

This does not reach High/Critical severity because:
- Does not affect consensus or active validator operations
- Does not cause fund loss or safety violations
- Only impacts backup restoration path, not normal transaction processing

## Likelihood Explanation

**High likelihood** in practice:
- Backup manifests are loaded from external storage (cloud storage, local files) that may be compromised
- No authentication or integrity checks on manifest structure before `verify()` is called
- Attack requires only JSON file manipulation, no cryptographic operations
- Single malicious manifest file can affect any node attempting restoration
- Disaster recovery scenarios (when backups are most critical) are prime targets

## Recommendation

Add explicit validation to prevent version ranges that would cause overflow:

```rust
pub fn verify(&self) -> Result<()> {
    // Check version range validity
    ensure!(
        self.first_version <= self.last_version,
        "Bad version range: [{}, {}]",
        self.first_version,
        self.last_version,
    );
    
    // NEW: Validate last_version is not maximum to prevent overflow
    ensure!(
        self.last_version < Version::MAX,
        "last_version cannot be Version::MAX ({}), maximum allowed is {}",
        Version::MAX,
        Version::MAX - 1
    );

    // Check chunk ranges
    ensure!(!self.chunks.is_empty(), "No chunks.");

    let mut next_version = self.first_version;
    for chunk in &self.chunks {
        ensure!(
            chunk.first_version == next_version,
            "Chunk ranges not continuous. Expected first version: {}, actual: {}.",
            next_version,
            chunk.first_version,
        );
        ensure!(
            chunk.last_version >= chunk.first_version,
            "Chunk range invalid. [{}, {}]",
            chunk.first_version,
            chunk.last_version,
        );
        
        // Use checked arithmetic
        next_version = chunk.last_version.checked_add(1)
            .ok_or_else(|| anyhow!("Version overflow: chunk.last_version too large"))?;
    }

    ensure!(
        next_version - 1 == self.last_version,
        "Last version in chunks: {}, in manifest: {}",
        next_version - 1,
        self.last_version,
    );

    Ok(())
}
```

## Proof of Concept

Create a malicious backup manifest JSON file:

```json
{
  "first_version": 0,
  "last_version": 18446744073709551615,
  "chunks": [
    {
      "first_version": 0,
      "last_version": 18446744073709551615,
      "transactions": {"name": "dummy_transactions"},
      "proof": {"name": "dummy_proof"},
      "format": "V1"
    }
  ]
}
```

Rust test demonstrating the panic:

```rust
#[test]
#[should_panic(expected = "overflow")]
fn test_manifest_overflow_single_chunk() {
    use aptos_types::transaction::Version;
    
    let manifest = TransactionBackup {
        first_version: 0,
        last_version: Version::MAX,
        chunks: vec![TransactionChunk {
            first_version: 0,
            last_version: Version::MAX,
            transactions: FileHandle { name: "txns".to_string() },
            proof: FileHandle { name: "proof".to_string() },
            format: TransactionChunkFormat::V1,
        }],
    };
    
    // This will panic due to overflow at line 76
    manifest.verify().unwrap();
}
```

**Expected behavior**: Node panics with integer overflow error during `verify()`.

**Actual impact**: Any node attempting to restore from this malicious backup will crash, preventing disaster recovery and causing denial of service during restoration operations.

## Notes

This vulnerability specifically exploits the lack of cross-chunk validation when only a single chunk is present. The security question correctly identified that single-chunk manifests bypass certain validation that would catch this issue with multiple chunks. The overflow-checks configuration confirms this is exploitable in production environments.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/manifest.rs (L50-88)
```rust
    pub fn verify(&self) -> Result<()> {
        // check number of waypoints
        ensure!(
            self.first_version <= self.last_version,
            "Bad version range: [{}, {}]",
            self.first_version,
            self.last_version,
        );

        // check chunk ranges
        ensure!(!self.chunks.is_empty(), "No chunks.");

        let mut next_version = self.first_version;
        for chunk in &self.chunks {
            ensure!(
                chunk.first_version == next_version,
                "Chunk ranges not continuous. Expected first version: {}, actual: {}.",
                next_version,
                chunk.first_version,
            );
            ensure!(
                chunk.last_version >= chunk.first_version,
                "Chunk range invalid. [{}, {}]",
                chunk.first_version,
                chunk.last_version,
            );
            next_version = chunk.last_version + 1;
        }

        // check last version in chunk matches manifest
        ensure!(
            next_version - 1 == self.last_version, // okay to -1 because chunks is not empty.
            "Last version in chunks: {}, in manifest: {}",
            next_version - 1,
            self.last_version,
        );

        Ok(())
    }
```

**File:** Cargo.toml (L921-923)
```text
[profile.release]
debug = true
overflow-checks = true
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L139-145)
```rust
        ensure!(
            manifest.first_version + (txns.len() as Version) == manifest.last_version + 1,
            "Number of items in chunks doesn't match that in manifest. first_version: {}, last_version: {}, items in chunk: {}",
            manifest.first_version,
            manifest.last_version,
            txns.len(),
        );
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L347-353)
```rust
        let manifest_stream = manifest_handle_stream
            .map(move |hdl| {
                let storage = storage.clone();
                async move { storage.load_json_file(&hdl).await.err_notes(&hdl) }
            })
            .buffered_x(con * 3, con)
            .and_then(|m: TransactionBackup| future::ready(m.verify().map(|_| m)));
```
