# Audit Report

## Title
Consensus Divergence via Forward-Incompatible MultisigTransactionPayload Enum Extension

## Summary
Extending the `MultisigTransactionPayload` enum with new variants creates a consensus-breaking vulnerability where validators running old code cannot deserialize transactions containing new variants stored on-chain, leading to divergent execution results and violation of the deterministic execution invariant.

## Finding Description

The `MultisigTransactionPayload` enum is designed for extensibility, as noted in the code comments [1](#0-0) , but lacks forward-compatibility guarantees in its deserialization mechanism.

The vulnerability manifests through the following chain:

1. **Storage Mechanism**: Multisig transaction payloads are serialized using BCS and stored on-chain as raw bytes in the `MultisigAccount.transactions` table [2](#0-1) 

2. **Validation Phase**: During transaction prologue, payload validation only performs byte-level hash comparisons without deserializing the payload structure [3](#0-2) . This means both old and new validators successfully validate and reach consensus on including the transaction in a block.

3. **Execution Phase**: During execution (post-consensus), the payload is retrieved and deserialized [4](#0-3) . When BCS encounters an unknown enum variant index, deserialization fails with `FAILED_TO_DESERIALIZE_ARGUMENT` [5](#0-4) .

4. **Divergent Outcomes**: The deserialization error results in a `Keep` status with `MiscellaneousError` on old nodes, while new nodes successfully deserialize and execute (or fail with different errors like `FEATURE_UNDER_GATING` [6](#0-5) ). Different execution outcomes produce different state roots, breaking consensus.

**Attack Scenario:**
1. Network upgrade adds `Script` variant to `MultisigTransactionPayload` (variant index 1)
2. Validators partially upgrade - some running new code, others on old code
3. User on upgraded node creates multisig transaction with `Script` payload
4. Payload serialized with variant index 1, stored on-chain via `create_transaction`
5. All validators agree to include transaction during consensus (validation passes)
6. During execution:
   - Old validators: Deserialization fails → `FAILED_TO_DESERIALIZE_ARGUMENT`
   - New validators: Deserialization succeeds → Different execution path
7. Validators produce different state roots → **Consensus divergence**

## Impact Explanation

**Severity: Critical** - This qualifies for Critical severity under Aptos bug bounty criteria as a "Consensus/Safety violation" requiring a hard fork to resolve.

The vulnerability breaks the **Deterministic Execution** invariant: "All validators must produce identical state roots for identical blocks." Once triggered, validators cannot achieve consensus on subsequent blocks, leading to:

- Chain split requiring coordinated hard fork
- Network partition between old and new validator sets  
- Loss of liveness until all validators upgrade
- Potential for double-spending during the split window

The consensus.yaml serialization format confirms `MultisigTransactionPayload` is consensus-critical [7](#0-6) .

## Likelihood Explanation

**Likelihood: High** when enum extension is attempted without proper coordination.

The code explicitly documents the intent to extend this enum [1](#0-0) , and there's already infrastructure for Script payload handling (currently gated). The vulnerability is triggered by normal user operations - any multisig owner can create a transaction with the new variant once code is deployed.

Factors increasing likelihood:
- Developers have stated intent to extend the enum
- No feature flag coordination mechanism for enum variants
- Payload deserialization happens post-consensus, making the issue non-obvious
- Standard BCS enum serialization provides backward but not forward compatibility

## Recommendation

Implement a versioned payload wrapper that maintains forward compatibility:

```rust
#[derive(Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub struct MultisigTransactionPayloadWrapper {
    version: u8,
    payload: Vec<u8>,
}

impl MultisigTransactionPayloadWrapper {
    pub fn try_deserialize(&self) -> Result<MultisigTransactionPayload, Error> {
        match self.version {
            0 => bcs::from_bytes(&self.payload),
            _ => Err(Error::UnsupportedVersion(self.version))
        }
    }
}
```

Additionally:
1. Feature-gate new enum variants so they can only be stored on-chain after all validators upgrade
2. Add version checks during payload storage to prevent creating payloads unsupported by current network
3. Implement graceful degradation - unknown variants could be treated as opaque blobs that can be validated but not executed until support is added
4. Document enum extension protocol requiring coordinated upgrades

## Proof of Concept

```rust
// This PoC demonstrates the deserialization incompatibility
// Requires modifying MultisigTransactionPayload to add Script variant

#[test]
fn test_enum_extension_consensus_break() {
    // Simulate old node's enum definition
    #[derive(Serialize, Deserialize)]
    enum OldMultisigTransactionPayload {
        EntryFunction(EntryFunction),
    }
    
    // Simulate new node's enum definition  
    #[derive(Serialize, Deserialize)]
    enum NewMultisigTransactionPayload {
        EntryFunction(EntryFunction),
        Script(Script), // New variant
    }
    
    // Create payload with new variant
    let new_payload = NewMultisigTransactionPayload::Script(Script::new(...));
    let serialized = bcs::to_bytes(&new_payload).unwrap();
    
    // Old node tries to deserialize
    let result = bcs::from_bytes::<OldMultisigTransactionPayload>(&serialized);
    
    // This will fail because variant index 1 doesn't exist in old enum
    assert!(result.is_err());
    // Error: "unknown variant"
    
    // This proves old nodes cannot deserialize new variants,
    // causing execution divergence post-consensus
}
```

To reproduce in actual codebase:
1. Add `Script(Script)` variant to `MultisigTransactionPayload` [8](#0-7) 
2. Deploy to subset of validators
3. Create multisig transaction with Script payload on upgraded node
4. Observe deserialization failure on non-upgraded validators during execution
5. Verify different transaction outcomes producing different state roots

**Notes**: This vulnerability represents a **forward compatibility failure** in enum-based serialization. While old transactions remain deserializable on new nodes (backward compatibility), new transactions with extended variants cannot be deserialized on old nodes. This is a critical design flaw for consensus-critical data structures that will be extended over time, requiring either coordinated hard forks for every enum extension or a more flexible versioning scheme.

### Citations

**File:** types/src/transaction/multisig.rs (L19-20)
```rust
// We use an enum here for extensibility so we can add Script payload support
// in the future for example.
```

**File:** types/src/transaction/multisig.rs (L21-24)
```rust
#[derive(Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub enum MultisigTransactionPayload {
    EntryFunction(EntryFunction),
}
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L149-151)
```text
    struct MultisigTransaction has copy, drop, store {
        payload: Option<vector<u8>>,
        payload_hash: Option<vector<u8>>,
```

**File:** aptos-move/framework/aptos-framework/sources/multisig_account.move (L1163-1169)
```text
        if (option::is_some(&transaction.payload_hash)) {
            let payload_hash = option::borrow(&transaction.payload_hash);
            assert!(
                sha3_256(payload) == *payload_hash,
                error::invalid_argument(EPAYLOAD_DOES_NOT_MATCH_HASH),
            );
        };
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1232-1238)
```rust
            TransactionExecutableRef::Script(_) => {
                let s = VMStatus::error(
                    StatusCode::FEATURE_UNDER_GATING,
                    Some("Multisig transaction does not support script payload".to_string()),
                );
                return Ok((s, discarded_output(StatusCode::FEATURE_UNDER_GATING)));
            },
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1274-1277)
```rust
        let deserialization_error = || {
            PartialVMError::new(StatusCode::FAILED_TO_DESERIALIZE_ARGUMENT)
                .finish(Location::Undefined)
        };
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1280-1281)
```rust
        let payload = bcs::from_bytes::<MultisigTransactionPayload>(&payload_bytes)
            .map_err(|_| deserialization_error())?;
```

**File:** testsuite/generate-format/tests/staged/consensus.yaml (L856-861)
```yaml
MultisigTransactionPayload:
  ENUM:
    0:
      EntryFunction:
        NEWTYPE:
          TYPENAME: EntryFunction
```
