# Audit Report

## Title
Rosetta API Returns Incomplete Block Data Due to Stale Currency Context Leading to Silent Operation Dropping

## Summary
The `RosettaContext` created at server startup contains a static `currencies` HashSet that never updates. When new Fungible Assets (FAs) or Coins are deployed on-chain after the Rosetta server starts, transactions involving these new currencies have their operations silently dropped from block responses, violating the Rosetta specification and causing data loss for indexers and integrations.

## Finding Description

The `with_context()` function [1](#0-0)  clones a `RosettaContext` for each request. This context is created once during server bootstrap [2](#0-1)  and contains a static `currencies` HashSet that includes only currencies known at startup time [3](#0-2) .

The vulnerability manifests in two critical parsing paths:

**1. Write Set Parsing for CoinStore Operations:**

When parsing successful transactions, the code attempts to find matching currencies [4](#0-3) . If a currency is not found in `server_context.currencies`, the function returns `Ok(vec![])`, silently dropping all operations for that currency.

**2. Fungible Asset Store Parsing:**

For fungible asset operations, the preprocessing step [5](#0-4)  only adds currencies to `store_to_currency` if they exist in `server_context.currencies`. Later, when parsing changes [6](#0-5) , if the currency is not found, operations are silently skipped.

**Attack Scenario:**

1. Rosetta server starts with initial currency set (APT, USDC)
2. A user deploys a new Fungible Asset on-chain (permissionless operation)
3. Transactions involving the new FA are processed by the blockchain normally
4. When Rosetta parses these transactions, it cannot find the FA in its stale currency list
5. Operations (deposits/withdrawals) are silently dropped from the block response
6. Indexers and wallets querying Rosetta receive incomplete block data
7. Account balances for the new FA are missing from balance queries [7](#0-6) 

This breaks the **State Consistency** invariant as the Rosetta API's view of blockchain state diverges from actual on-chain state, and violates the Rosetta specification requirement that blocks contain complete transaction data.

## Impact Explanation

This qualifies as **Medium Severity** under "State inconsistencies requiring intervention":

- **Data Loss**: Operations involving new currencies are permanently lost from Rosetta's block history
- **Index Corruption**: Exchanges, wallets, and analytics platforms relying on Rosetta for indexing will have incomplete transaction histories
- **Balance Query Failures**: Users cannot query balances for newly deployed currencies [8](#0-7) 
- **Transaction Construction Failures**: The construction API rejects transactions with unsupported currencies [9](#0-8) 
- **Compliance Risk**: Services using Rosetta for regulatory reporting may have incomplete records

While this doesn't affect consensus or core blockchain operation, it creates significant data integrity issues for the entire ecosystem of integrations relying on Rosetta.

## Likelihood Explanation

**Likelihood: HIGH**

- Fungible Assets are designed to be permissionlessly deployable on Aptos
- Rosetta servers are typically long-running services (weeks/months)
- New tokens launch regularly on active blockchains
- No automatic refresh mechanism exists for the currency list
- The issue is deterministic and guaranteed to occur once new currencies are deployed
- Default configuration only includes APT and USDC, making the issue likely for any production deployment

## Recommendation

Implement a dynamic currency discovery mechanism or periodic refresh:

**Option 1: Dynamic Currency Discovery**
Modify the parsing logic to handle unknown currencies gracefully by attempting to fetch metadata on-demand from the blockchain when an unknown currency is encountered, then cache it in the context.

**Option 2: Periodic Currency List Refresh**
Add a background task that periodically queries the blockchain for newly registered Fungible Assets and updates the `RosettaContext.currencies` field with thread-safe synchronization (e.g., `Arc<RwLock<HashSet<Currency>>>`).

**Option 3: Configuration-Based Manual Updates**
Document the limitation clearly and provide an API endpoint or configuration reload mechanism to update the currency list without restarting the server.

**Immediate Mitigation:**
Add warning logs when unknown currencies are encountered instead of silently dropping operations, and return partial block data with a metadata flag indicating incomplete parsing.

## Proof of Concept

```rust
// Integration test demonstrating the vulnerability
#[tokio::test]
async fn test_stale_currency_context_drops_operations() {
    // 1. Start Rosetta server with only APT currency
    let currencies = HashSet::from([native_coin()]);
    let context = RosettaContext::new(
        Some(Arc::new(rest_client)),
        ChainId::test(),
        Some(Arc::new(block_cache)),
        currencies
    ).await;
    
    // 2. Deploy a new Fungible Asset on-chain
    // (This would be a real FA deployment transaction)
    let new_fa_address = AccountAddress::from_hex_literal("0xNEWFA").unwrap();
    
    // 3. Submit a transfer transaction using the new FA
    // (Transaction succeeds on-chain and is included in a block)
    
    // 4. Query the block through Rosetta
    let block_response = block(
        BlockRequest {
            network_identifier: NetworkIdentifier::default(),
            block_identifier: Some(PartialBlockIdentifier {
                index: Some(block_height),
                hash: None,
            }),
            metadata: None,
        },
        context
    ).await.unwrap();
    
    // 5. VULNERABILITY: Operations for the new FA are missing
    // Expected: 2 operations (withdraw + deposit)
    // Actual: 0 operations (silently dropped)
    assert_eq!(block_response.block.transactions[0].operations.len(), 0);
    // Should be 2 but operations were silently dropped!
}
```

## Notes

The vulnerability is confirmed in the production code path where currencies are validated during operation parsing. The silent dropping behavior (returning empty vectors instead of errors) makes this particularly dangerous as consuming applications receive no indication that data is missing. The issue affects both the `/block` endpoint and `/account/balance` endpoint, impacting all downstream consumers of Rosetta data.

### Citations

**File:** crates/aptos-rosetta/src/common.rs (L49-53)
```rust
pub fn with_context(
    context: RosettaContext,
) -> impl Filter<Extract = (RosettaContext,), Error = Infallible> + Clone {
    warp::any().map(move || context.clone())
}
```

**File:** crates/aptos-rosetta/src/lib.rs (L43-52)
```rust
pub struct RosettaContext {
    /// A rest client to connect to a fullnode
    rest_client: Option<Arc<aptos_rest_client::Client>>,
    /// ChainId of the chain to connect to
    pub chain_id: ChainId,
    /// Block index cache
    pub block_cache: Option<Arc<BlockRetriever>>,
    /// Set of supported currencies
    pub currencies: HashSet<Currency>,
}
```

**File:** crates/aptos-rosetta/src/lib.rs (L151-157)
```rust
        let context = RosettaContext::new(
            rest_client.clone(),
            chain_id,
            block_cache,
            supported_currencies,
        )
        .await;
```

**File:** crates/aptos-rosetta/src/types/objects.rs (L1382-1408)
```rust
        (AccountAddress::ONE, COIN_MODULE, COIN_STORE_RESOURCE, 1) => {
            if let Some(type_tag) = struct_tag.type_args.first() {
                // Find the currency and parse it accordingly
                let maybe_currency = find_coin_currency(&server_context.currencies, type_tag);

                if let Some(currency) = maybe_currency {
                    parse_coinstore_changes(
                        currency.clone(),
                        type_tag.to_canonical_string(),
                        version,
                        address,
                        data,
                        events,
                        operation_index,
                    )
                } else {
                    Ok(vec![])
                }
            } else {
                warn!(
                    "Failed to parse coinstore {} at version {}",
                    struct_tag.to_canonical_string(),
                    version
                );
                Ok(vec![])
            }
        },
```

**File:** crates/aptos-rosetta/src/types/objects.rs (L1491-1499)
```rust
                    (AccountAddress::ONE, FUNGIBLE_ASSET_MODULE, FUNGIBLE_STORE_RESOURCE) => {
                        parse_fungible_store_metadata(
                            &server_context.currencies,
                            version,
                            address,
                            bytes,
                            store_to_currency,
                        );
                    },
```

**File:** crates/aptos-rosetta/src/types/objects.rs (L2154-2170)
```rust
/// Parses fungible store direct changes, for withdraws and deposits
///
/// Note that, we don't know until we introspect the change, which fa it is
fn parse_fungible_store_changes(
    object_to_owner: &HashMap<AccountAddress, AccountAddress>,
    store_to_currency: &HashMap<AccountAddress, Currency>,
    address: AccountAddress,
    events: &[ContractEvent],
    mut operation_index: u64,
) -> ApiResult<Vec<Operation>> {
    let mut operations = vec![];

    // Find the fungible asset currency association
    let maybe_currency = store_to_currency.get(&address);
    if maybe_currency.is_none() {
        return Ok(operations);
    }
```

**File:** crates/aptos-rosetta/src/account.rs (L119-123)
```rust
    let currencies_to_lookup = if let Some(currencies) = maybe_filter_currencies {
        currencies.into_iter().collect()
    } else {
        server_context.currencies.clone()
    };
```

**File:** crates/aptos-rosetta/src/account.rs (L301-379)
```rust
async fn get_base_balances(
    rest_client: &Client,
    owner_address: AccountAddress,
    version: u64,
    currencies_to_lookup: HashSet<Currency>,
) -> ApiResult<Vec<Amount>> {
    let mut balances = vec![];

    // Retrieve the fungible asset balances and the coin balances
    for currency in currencies_to_lookup.iter() {
        match *currency {
            // FA only
            Currency {
                metadata:
                    Some(CurrencyMetadata {
                        move_type: None,
                        fa_address: Some(ref fa_address),
                    }),
                ..
            } => {
                let response = view::<Vec<u64>>(
                    rest_client,
                    version,
                    AccountAddress::ONE,
                    ident_str!(PRIMARY_FUNGIBLE_STORE_MODULE),
                    ident_str!(BALANCE_FUNCTION),
                    vec![TypeTag::Struct(Box::new(StructTag {
                        address: AccountAddress::ONE,
                        module: ident_str!(OBJECT_MODULE).into(),
                        name: ident_str!(OBJECT_CORE_RESOURCE).into(),
                        type_args: vec![],
                    }))],
                    vec![
                        bcs::to_bytes(&owner_address).unwrap(),
                        bcs::to_bytes(&AccountAddress::from_str(fa_address).unwrap()).unwrap(),
                    ],
                )
                .await?;
                let fa_balance = response.first().copied().unwrap_or(0);
                balances.push(Amount {
                    value: fa_balance.to_string(),
                    currency: currency.clone(),
                })
            },
            // Coin or Coin and FA combined
            Currency {
                metadata:
                    Some(CurrencyMetadata {
                        move_type: Some(ref coin_type),
                        fa_address: _,
                    }),
                ..
            } => {
                if let Ok(type_tag) = parse_type_tag(coin_type) {
                    let response = view::<Vec<u64>>(
                        rest_client,
                        version,
                        AccountAddress::ONE,
                        ident_str!(COIN_MODULE),
                        ident_str!(BALANCE_FUNCTION),
                        vec![type_tag],
                        vec![bcs::to_bytes(&owner_address)?],
                    )
                    .await?;
                    let coin_balance = response.first().copied().unwrap_or(0);
                    balances.push(Amount {
                        value: coin_balance.to_string(),
                        currency: currency.clone(),
                    })
                }
            },
            _ => {
                // None for both, means we can't look it up anyways / it's invalid
            },
        }
    }

    Ok(balances)
}
```

**File:** crates/aptos-rosetta/src/construction.rs (L876-898)
```rust
    // Grab currency accordingly

    let maybe_currency = find_fa_currency(&server_context.currencies, metadata);

    if let Some(currency) = maybe_currency {
        operations.push(Operation::withdraw(
            0,
            None,
            AccountIdentifier::base_account(sender),
            currency.clone(),
            amount,
        ));
        operations.push(Operation::deposit(
            1,
            None,
            AccountIdentifier::base_account(receiver),
            currency.clone(),
            amount,
        ));
        Ok(operations)
    } else {
        Err(ApiError::UnsupportedCurrency(Some(metadata.to_string())))
    }
```
