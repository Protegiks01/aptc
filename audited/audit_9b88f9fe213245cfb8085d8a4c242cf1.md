# Audit Report

## Title
Persistent Storage Corruption During DKG Initialization Prevents Validator Consensus Participation

## Summary
The `start_dkg_runtime()` function can leave the validator's persistent safety storage in a partially initialized state if panics occur during `EpochManager::new()` or `NetworkTask::new()` construction. This corrupted storage state persists across node restarts and prevents the validator from participating in consensus, causing network liveness degradation.

## Finding Description

The vulnerability exists in the DKG runtime initialization path where constructors can panic after partially writing to persistent storage, leaving it in an inconsistent state that is mistakenly accepted as valid on subsequent restarts.

**Vulnerable Code Path:** [1](#0-0) 

The `start_dkg_runtime()` function calls `EpochManager::new()` which internally calls `storage(safety_rules_config)`: [2](#0-1) 

The `storage()` function can panic at multiple points during initialization: [3](#0-2) 

Most critically, `PersistentSafetyStorage::initialize()` performs multiple writes with `.expect()` calls that can panic: [4](#0-3) 

**The Corruption Scenario:**

1. During initialization, `initialize_keys_and_accounts()` successfully writes `CONSENSUS_KEY` and `OWNER_ACCOUNT` to storage
2. Subsequently, `set_safety_data()` or `set_waypoint()` fails (due to I/O errors, disk full, permissions) and panics via `.expect()`
3. The panic causes stack unwinding - the runtime is dropped but storage has been partially written
4. On node restart, the `storage()` function checks if storage is already initialized: [5](#0-4) 

5. Since `OWNER_ACCOUNT` exists, `storage.author()` returns `Ok`, and the incomplete storage is accepted
6. The validator's consensus EpochManager uses the same storage function: [6](#0-5) 

7. When consensus SafetyRules attempts to verify proposals, it calls `safety_data()` which fails because `SAFETY_DATA` is missing: [7](#0-6) 

8. The validator cannot participate in consensus, remaining permanently broken until manual intervention

**Invariant Violations:**

- **State Consistency**: Storage initialization should be atomic - either fully complete or not at all
- **Consensus Safety**: Validators must be able to participate in consensus to maintain network liveness
- **Deterministic Execution**: All validators should reach consistent operational states across restarts

## Impact Explanation

This vulnerability meets **High Severity** criteria per the Aptos bug bounty program:

- **"Validator node slowdowns"**: The affected validator cannot participate in consensus at all, which is more severe than a slowdown
- **"Significant protocol violations"**: The validator violates consensus protocol by being unable to vote or sign proposals

If multiple validators encounter this issue (due to similar environmental conditions like disk failures, insufficient permissions, or resource exhaustion), it could escalate to **Critical Severity**:

- **"Total loss of liveness/network availability"**: If enough validators (>1/3) are affected, the network cannot reach consensus

The corruption persists across restarts and requires manual intervention (storage reset or reconfiguration) to recover, making this a serious availability issue.

## Likelihood Explanation

**Likelihood: Medium to High**

This issue can occur under several realistic scenarios:

1. **Disk I/O errors**: Transient or permanent disk failures during initialization
2. **Disk full conditions**: Storage write succeeds initially but fails later due to space exhaustion
3. **Permission issues**: Filesystem permissions change between writes
4. **Resource exhaustion**: OOM or other resource limits during initialization
5. **Concurrent access**: Race conditions if multiple processes access storage
6. **Configuration errors**: Missing or invalid safety rules configuration

Validators running in cloud environments, containerized deployments, or systems with strict resource limits are particularly susceptible. The issue is more likely during:
- Initial validator setup
- Node restarts after crashes
- Software upgrades
- Infrastructure migrations

## Recommendation

Implement atomic storage initialization with proper rollback on failure:

```rust
// In safety_rules_manager.rs, storage() function
pub fn storage(config: &SafetyRulesConfig) -> PersistentSafetyStorage {
    let backend = &config.backend;
    let internal_storage: Storage = backend.into();
    if let Err(error) = internal_storage.available() {
        panic!("Storage is not available: {:?}", error);
    }

    if let Some(test_config) = &config.test {
        // ... test config path ...
    } else {
        let storage = PersistentSafetyStorage::new(internal_storage, config.enable_cached_safety_data);
        
        // Check if storage is fully initialized by verifying all required keys
        if storage.author().is_ok() 
            && storage.safety_data().is_ok() 
            && storage.waypoint().is_ok() {
            // Storage is complete, return it
            return storage;
        }
        
        // Storage is incomplete or uninitialized
        if matches!(config.initial_safety_rules_config, InitialSafetyRulesConfig::None) {
            panic!("Safety rules storage is not initialized, provide an initial safety rules config");
        }
        
        // Attempt initialization with proper error handling
        let identity_blob = config
            .initial_safety_rules_config
            .identity_blob()
            .ok_or_else(|| "No identity blob in initial safety rules config")?;
        let waypoint = config.initial_safety_rules_config.waypoint();
        
        let backend = &config.backend;
        let internal_storage: Storage = backend.into();
        
        // Use Result instead of expect() to handle errors gracefully
        match PersistentSafetyStorage::try_initialize(
            internal_storage,
            identity_blob.account_address.ok_or("AccountAddress needed")?,
            identity_blob.consensus_private_key.ok_or("Consensus key needed")?,
            waypoint,
            config.enable_cached_safety_data,
        ) {
            Ok(storage) => storage,
            Err(e) => {
                // Clean up partial writes before panicking
                // Or return Result instead of panicking
                error!("Failed to initialize storage: {:?}", e);
                panic!("Storage initialization failed: {:?}", e);
            }
        }
    }
}
```

Additionally, modify `PersistentSafetyStorage::initialize()` to return `Result` instead of using `.expect()`, and implement transactional storage writes if the backend supports it.

## Proof of Concept

```rust
#[test]
fn test_storage_corruption_on_partial_initialization() {
    use aptos_secure_storage::{InMemoryStorage, KVStorage, Storage};
    use aptos_types::waypoint::Waypoint;
    use aptos_crypto::bls12381::PrivateKey;
    use aptos_consensus_types::common::Author;
    
    // Create a mock storage that fails on the second set() call
    struct FailingStorage {
        inner: InMemoryStorage,
        call_count: std::sync::Arc<std::sync::atomic::AtomicUsize>,
    }
    
    impl KVStorage for FailingStorage {
        fn set<T: Serialize>(&mut self, key: &str, value: T) -> Result<(), Error> {
            let count = self.call_count.fetch_add(1, std::sync::atomic::Ordering::SeqCst);
            if count >= 2 {
                // Fail after CONSENSUS_KEY and OWNER_ACCOUNT are written
                return Err(Error::InternalError("Simulated I/O failure".to_string()));
            }
            self.inner.set(key, value)
        }
        
        fn get<T: DeserializeOwned>(&self, key: &str) -> Result<GetResponse<T>, Error> {
            self.inner.get(key)
        }
        // ... implement other methods ...
    }
    
    // First initialization attempt - fails after partial writes
    let storage = FailingStorage { 
        inner: InMemoryStorage::new(),
        call_count: Arc::new(AtomicUsize::new(0)),
    };
    
    let author = Author::random();
    let key = PrivateKey::generate_for_testing();
    let waypoint = Waypoint::default();
    
    let result = std::panic::catch_unwind(|| {
        PersistentSafetyStorage::initialize(
            Storage::from(storage),
            author,
            key,
            waypoint,
            false,
        )
    });
    
    assert!(result.is_err(), "Expected panic during initialization");
    
    // Second attempt - storage.author() succeeds but safety_data() fails
    let storage2 = InMemoryStorage::new();
    // Manually write only OWNER_ACCOUNT (simulating partial state)
    storage2.set(OWNER_ACCOUNT, author).unwrap();
    
    let partial_storage = PersistentSafetyStorage::new(Storage::from(storage2), false);
    
    assert!(partial_storage.author().is_ok(), "Author should be present");
    assert!(partial_storage.safety_data().is_err(), "SafetyData should be missing");
    
    // This incomplete storage would be accepted by storage() function
    // and cause consensus failures later
}
```

**Notes:**

The vulnerability is triggered when storage writes fail during initialization after partial data has already been persisted. The `storage()` function's check at line 48 only verifies `OWNER_ACCOUNT` exists, not the complete initialization state. This allows incomplete storage to be accepted on restart, causing consensus operations to fail when they attempt to access missing data like `SAFETY_DATA` or `WAYPOINT`.

The same storage initialization code is shared between DKG (`dkg/src/epoch_manager.rs`), consensus (`consensus/src/epoch_manager.rs`), and JWK consensus, meaning this vulnerability affects all these critical components. The impact is particularly severe because the corrupted state persists across restarts and requires manual intervention to resolve.

### Citations

**File:** dkg/src/lib.rs (L26-56)
```rust
pub fn start_dkg_runtime(
    my_addr: AccountAddress,
    safety_rules_config: &SafetyRulesConfig,
    network_client: NetworkClient<DKGMessage>,
    network_service_events: NetworkServiceEvents<DKGMessage>,
    reconfig_events: ReconfigNotificationListener<DbBackedOnChainConfig>,
    dkg_start_events: EventNotificationListener,
    vtxn_pool: VTxnPoolState,
    rb_config: ReliableBroadcastConfig,
    randomness_override_seq_num: u64,
) -> Runtime {
    let runtime = aptos_runtimes::spawn_named_runtime("dkg".into(), Some(4));
    let (self_sender, self_receiver) = aptos_channels::new(1_024, &counters::PENDING_SELF_MESSAGES);
    let dkg_network_client = DKGNetworkClient::new(network_client);

    let dkg_epoch_manager = EpochManager::new(
        safety_rules_config,
        my_addr,
        reconfig_events,
        dkg_start_events,
        self_sender,
        dkg_network_client,
        vtxn_pool,
        rb_config,
        randomness_override_seq_num,
    );
    let (network_task, network_receiver) = NetworkTask::new(network_service_events, self_receiver);
    runtime.spawn(network_task.start());
    runtime.spawn(dkg_epoch_manager.start(network_receiver));
    runtime
}
```

**File:** dkg/src/epoch_manager.rs (L66-92)
```rust
    pub fn new(
        safety_rules_config: &SafetyRulesConfig,
        my_addr: AccountAddress,
        reconfig_events: ReconfigNotificationListener<P>,
        dkg_start_events: EventNotificationListener,
        self_sender: aptos_channels::Sender<Event<DKGMessage>>,
        network_sender: DKGNetworkClient<NetworkClient<DKGMessage>>,
        vtxn_pool: VTxnPoolState,
        rb_config: ReliableBroadcastConfig,
        randomness_override_seq_num: u64,
    ) -> Self {
        Self {
            my_addr,
            epoch_state: None,
            reconfig_events,
            dkg_start_events,
            dkg_rpc_msg_tx: None,
            dkg_manager_close_tx: None,
            self_sender,
            network_sender,
            vtxn_pool,
            dkg_start_event_tx: None,
            rb_config,
            randomness_override_seq_num,
            key_storage: storage(safety_rules_config),
        }
    }
```

**File:** consensus/safety-rules/src/safety_rules_manager.rs (L21-103)
```rust
pub fn storage(config: &SafetyRulesConfig) -> PersistentSafetyStorage {
    let backend = &config.backend;
    let internal_storage: Storage = backend.into();
    if let Err(error) = internal_storage.available() {
        panic!("Storage is not available: {:?}", error);
    }

    if let Some(test_config) = &config.test {
        let author = test_config.author;
        let consensus_private_key = test_config
            .consensus_key
            .as_ref()
            .expect("Missing consensus key in test config")
            .private_key();
        let waypoint = test_config.waypoint.expect("No waypoint in config");

        PersistentSafetyStorage::initialize(
            internal_storage,
            author,
            consensus_private_key,
            waypoint,
            config.enable_cached_safety_data,
        )
    } else {
        let storage =
            PersistentSafetyStorage::new(internal_storage, config.enable_cached_safety_data);

        let mut storage = if storage.author().is_ok() {
            storage
        } else if !matches!(
            config.initial_safety_rules_config,
            InitialSafetyRulesConfig::None
        ) {
            let identity_blob = config
                .initial_safety_rules_config
                .identity_blob()
                .expect("No identity blob in initial safety rules config");
            let waypoint = config.initial_safety_rules_config.waypoint();

            let backend = &config.backend;
            let internal_storage: Storage = backend.into();
            PersistentSafetyStorage::initialize(
                internal_storage,
                identity_blob
                    .account_address
                    .expect("AccountAddress needed for safety rules"),
                identity_blob
                    .consensus_private_key
                    .expect("Consensus key needed for safety rules"),
                waypoint,
                config.enable_cached_safety_data,
            )
        } else {
            panic!(
                "Safety rules storage is not initialized, provide an initial safety rules config"
            )
        };

        // Ensuring all the overriding consensus keys are in the storage.
        let timer = Instant::now();
        for blob in config
            .initial_safety_rules_config
            .overriding_identity_blobs()
            .unwrap_or_default()
        {
            if let Some(sk) = blob.consensus_private_key {
                let pk_hex = hex::encode(PublicKey::from(&sk).to_bytes());
                let storage_key = format!("{}_{}", CONSENSUS_KEY, pk_hex);
                match storage.internal_store().set(storage_key.as_str(), sk) {
                    Ok(_) => {
                        info!("Setting {storage_key} succeeded.");
                    },
                    Err(e) => {
                        warn!("Setting {storage_key} failed with internal store set error: {e}");
                    },
                }
            }
        }
        info!("Overriding key work time: {:?}", timer.elapsed());

        storage
    }
}
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L33-61)
```rust
    pub fn initialize(
        mut internal_store: Storage,
        author: Author,
        consensus_private_key: bls12381::PrivateKey,
        waypoint: Waypoint,
        enable_cached_safety_data: bool,
    ) -> Self {
        // Initialize the keys and accounts
        Self::initialize_keys_and_accounts(&mut internal_store, author, consensus_private_key)
            .expect("Unable to initialize keys and accounts in storage");

        // Create the new persistent safety storage
        let safety_data = SafetyData::new(1, 0, 0, 0, None, 0);
        let mut persisent_safety_storage = Self {
            enable_cached_safety_data,
            cached_safety_data: Some(safety_data.clone()),
            internal_store,
        };

        // Initialize the safety data and waypoint
        persisent_safety_storage
            .set_safety_data(safety_data)
            .expect("Unable to initialize safety data");
        persisent_safety_storage
            .set_waypoint(&waypoint)
            .expect("Unable to initialize waypoint");

        persisent_safety_storage
    }
```

**File:** consensus/src/epoch_manager.rs (L209-210)
```rust
        let safety_rules_manager = SafetyRulesManager::new(sr_config);
        let key_storage = safety_rules_manager::storage(sr_config);
```

**File:** consensus/safety-rules/src/safety_rules.rs (L63-68)
```rust
    pub(crate) fn verify_proposal(
        &mut self,
        vote_proposal: &VoteProposal,
    ) -> Result<VoteData, Error> {
        let proposed_block = vote_proposal.block();
        let safety_data = self.persistent_storage.safety_data()?;
```
