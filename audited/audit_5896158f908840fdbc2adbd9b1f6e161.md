# Audit Report

## Title
V2 Fungible Token Storage ID Collision Causing Balance Misreporting in Indexer Database

## Summary
The indexer incorrectly uses the fungible asset metadata address as the `storage_id` for V2 fungible tokens instead of the FungibleStore object address. This causes primary key collisions when a single owner has multiple FungibleStore objects referencing the same metadata, resulting in data loss and incorrect balance reporting in the `current_token_ownerships_v2` table.

## Finding Description

The vulnerability exists in the `get_ft_v2_from_write_resource` function where `storage_id` is set to the metadata address rather than the FungibleStore address: [1](#0-0) 

The Aptos fungible asset framework allows creating multiple `FungibleStore` objects at different addresses that all reference the same `Metadata` object: [2](#0-1) 

The primary key for `current_token_ownerships_v2` includes `storage_id`: [3](#0-2) 

**Attack Scenario:**
1. User deploys a Move contract that creates two FungibleStore objects at addresses `0x111` and `0x222`, both referencing the same fungible asset metadata at `0xABC`
2. User mints 1000 tokens to Store 1 (`0x111`)
3. User mints 500 tokens to Store 2 (`0x222`)
4. Indexer processes Store 1 → Creates entry: `(0xABC, 0, owner, 0xABC, amount=1000)`
5. Indexer processes Store 2 → Tries to insert: `(0xABC, 0, owner, 0xABC, amount=500)`
6. Primary key collision occurs; upsert logic updates amount to 500: [4](#0-3) 

7. **Result**: Indexer shows balance of 500 instead of 1500 (1000+500), losing Store 1's balance information

This breaks the indexer's data integrity invariant: the indexed state should accurately reflect the on-chain state.

## Impact Explanation

**Severity: Medium (per Aptos bug bounty criteria)**

This vulnerability causes **state inconsistencies in the indexer database**, fitting the Medium severity category of "State inconsistencies requiring intervention." While on-chain funds remain secure and blockchain consensus is unaffected, the issue has significant practical impact:

1. **Incorrect Balance Reporting**: Wallets, explorers, and dApps querying the indexer receive wrong balance information
2. **Silent Data Loss**: No errors are raised; data is silently overwritten during upsert operations
3. **User Confusion**: Users see incorrect balances in UIs, potentially leading to incorrect financial decisions
4. **Analytics Corruption**: Token supply calculations and holder statistics become inaccurate

**Important Note**: This is an **indexer-only** vulnerability. On-chain balances, consensus, and fund security are NOT affected. The blockchain operates correctly; only the off-chain indexing service provides incorrect data.

## Likelihood Explanation

**Likelihood: Medium**

While most users utilize "primary stores" (one deterministic store per owner-metadata pair), the vulnerability is exploitable in these scenarios:

1. **Custom Contracts**: Any contract using `fungible_asset::create_store()` can create multiple stores for the same metadata
2. **Advanced DeFi**: Protocols might use multiple stores to isolate assets for different purposes (e.g., collateral vs. liquid holdings)
3. **Existing Usage**: The framework explicitly supports this pattern, as evidenced by the `create_store` function design

The vulnerability triggers automatically whenever multiple stores exist—no special attack is needed beyond normal contract deployment and token operations.

## Recommendation

**Fix**: Change `storage_id` to use the FungibleStore object address instead of the metadata address.

In `get_ft_v2_from_write_resource`, replace line 384:

```rust
// BEFORE (VULNERABLE):
let storage_id = token_data_id.clone();

// AFTER (FIXED):
let storage_id = resource.address.clone();
```

This ensures each FungibleStore object gets a unique entry in the database, properly tracking all stores separately.

**File to modify:** [5](#0-4) 

## Proof of Concept

```move
module poc_addr::fungible_collision {
    use std::string;
    use std::option;
    use aptos_framework::object::{Self, Object};
    use aptos_framework::fungible_asset::{Self, Metadata, FungibleStore};
    
    /// Create metadata and two stores for the same owner
    public entry fun create_collision(creator: &signer) {
        // Create fungible asset metadata
        let constructor_ref = &object::create_named_object(creator, b"TEST_FA");
        fungible_asset::add_fungibility(
            constructor_ref,
            option::none(),
            string::utf8(b"Test FA"),
            string::utf8(b"TFA"),
            8,
            string::utf8(b""),
            string::utf8(b""),
        );
        let metadata = object::object_from_constructor_ref<Metadata>(constructor_ref);
        let mint_ref = fungible_asset::generate_mint_ref(constructor_ref);
        
        // Create Store 1 for owner
        let store1_constructor = &object::create_object_from_account(creator);
        let store1: Object<FungibleStore> = fungible_asset::create_store(
            store1_constructor, 
            metadata
        );
        
        // Create Store 2 for same owner
        let store2_constructor = &object::create_object_from_account(creator);
        let store2: Object<FungibleStore> = fungible_asset::create_store(
            store2_constructor,
            metadata
        );
        
        // Mint 1000 to Store 1
        let fa1 = fungible_asset::mint(&mint_ref, 1000);
        fungible_asset::deposit(store1, fa1);
        
        // Mint 500 to Store 2  
        let fa2 = fungible_asset::mint(&mint_ref, 500);
        fungible_asset::deposit(store2, fa2);
        
        // On-chain: User owns 1500 tokens total (1000 + 500)
        // In Indexer: Shows only 500 due to PK collision
    }
}
```

**Verification Steps:**
1. Deploy and execute the above contract
2. Query the indexer's `current_token_ownerships_v2` table
3. Observe only ONE entry exists with `amount=500` (or 1000, depending on processing order)
4. Expected: TWO entries with distinct `storage_id` values showing 1000 and 500 respectively

## Notes

This vulnerability is specific to the **indexer service** and does not affect the blockchain's consensus, execution, or on-chain state. The blockchain correctly maintains all balances; only the off-chain indexing database contains incorrect data. The severity is limited to data quality issues in querying services rather than core blockchain security.

### Citations

**File:** crates/indexer/src/models/token_models/v2_token_ownerships.rs (L60-61)
```rust
#[diesel(primary_key(token_data_id, property_version_v1, owner_address, storage_id))]
#[diesel(table_name = current_token_ownerships_v2)]
```

**File:** crates/indexer/src/models/token_models/v2_token_ownerships.rs (L381-384)
```rust
            if let Some(metadata) = token_v2_metadata.get(&resource.address) {
                let object_core = &metadata.object.object_core;
                let token_data_id = inner.metadata.get_reference_address();
                let storage_id = token_data_id.clone();
```

**File:** aptos-move/framework/aptos-framework/sources/fungible_asset.move (L880-903)
```text
    public fun create_store<T: key>(
        constructor_ref: &ConstructorRef, metadata: Object<T>
    ): Object<FungibleStore> {
        let store_obj = &constructor_ref.generate_signer();
        move_to(
            store_obj,
            FungibleStore { metadata: metadata.convert(), balance: 0, frozen: false }
        );

        if (is_untransferable(metadata)) {
            constructor_ref.set_untransferable();
        };

        if (default_to_concurrent_fungible_balance()) {
            move_to(
                store_obj,
                ConcurrentFungibleBalance {
                    balance: aggregator_v2::create_unbounded_aggregator()
                }
            );
        };

        constructor_ref.object_from_constructor_ref<FungibleStore>()
    }
```

**File:** crates/indexer/src/processors/token_processor.rs (L778-792)
```rust
                .on_conflict((token_data_id, property_version_v1, owner_address, storage_id))
                .do_update()
                .set((
                    amount.eq(excluded(amount)),
                    table_type_v1.eq(excluded(table_type_v1)),
                    token_properties_mutated_v1.eq(excluded(token_properties_mutated_v1)),
                    is_soulbound_v2.eq(excluded(is_soulbound_v2)),
                    token_standard.eq(excluded(token_standard)),
                    is_fungible_v2.eq(excluded(is_fungible_v2)),
                    last_transaction_version.eq(excluded(last_transaction_version)),
                    last_transaction_timestamp.eq(excluded(last_transaction_timestamp)),
                    inserted_at.eq(excluded(inserted_at)),
                    non_transferrable_by_owner.eq(excluded(non_transferrable_by_owner)),
                )),
            Some(" WHERE current_token_ownerships_v2.last_transaction_version <= excluded.last_transaction_version "),
```
