# Audit Report

## Title
Genesis Transaction Missing from TransactionByHashSchema After Fast Sync to Higher Version

## Summary
In fast sync mode, when a node fast syncs to a version higher than 0 (genesis), the genesis transaction is never indexed in the `TransactionByHashSchema` of the fast sync database, making it unlookable by hash via the `get_transaction_by_hash` API. This breaks the invariant that all committed transactions should be retrievable by their hash.

## Finding Description

The vulnerability occurs due to an incomplete bootstrap process in fast sync mode. When the `FastSyncStorageWrapper` initializes two databases:

1. **temporary_db_with_genesis**: Properly bootstrapped with full genesis via `maybe_apply_genesis` [1](#0-0) 

2. **fast_sync_db** (main database): Only receives genesis ledger info metadata via `commit_genesis_ledger_info` [2](#0-1) 

The `commit_genesis_ledger_info` method only writes ledger metadata without transaction data: [3](#0-2) 

When the node fast syncs to a target version greater than 0, the `finalize_state_snapshot` method is invoked, which explicitly validates that only a **single** transaction output is processed: [4](#0-3) 

This single transaction corresponds only to the target version, not genesis (version 0). The `save_transactions` call writes only the target version transaction: [5](#0-4) 

The `put_transaction` method that writes to `TransactionByHashSchema` is never called for the genesis transaction in the fast sync database: [6](#0-5) 

After fast sync completes, the `FastSyncStorageWrapper` permanently switches to using the fast_sync_db, abandoning the temporary_db_with_genesis: [7](#0-6) 

Any subsequent API call to `get_transaction_by_hash` with the genesis transaction hash will query the empty `TransactionByHashSchema` and return `None`: [8](#0-7) 

## Impact Explanation

This constitutes a **Medium severity** vulnerability per the Aptos bug bounty criteria as it causes "state inconsistencies requiring intervention."

**Specific impacts:**
- API clients calling `get_transaction_by_hash` with the genesis transaction hash receive incorrect `None` responses
- Blockchain indexers and explorers cannot retrieve genesis transaction details by hash
- Archive nodes lose historical transaction lookup capability for the most critical transaction
- Violates the state consistency invariant that all committed transactions must be retrievable

This does not directly cause funds loss or consensus violations, but creates data availability issues that could affect applications relying on full transaction history.

## Likelihood Explanation

**Likelihood: High**

This issue occurs automatically in the following common scenario:
1. Node is configured with fast sync mode (`BootstrappingMode::DownloadLatestStates`)
2. Node bootstraps from an empty database
3. Network has advanced beyond version 0 (always true in production)
4. Node fast syncs to the latest version (e.g., version 1,000,000+)

This is the **default** behavior for new full nodes joining the network, making the issue highly likely to affect production deployments.

## Recommendation

Modify the fast sync initialization to ensure the genesis transaction is properly written to the fast_sync_db. Add this logic after `commit_genesis_ledger_info` in `aptos-node/src/storage.rs`:

```rust
// After line 93, add:
if fast_sync_db
    .get_latest_ledger_info_option()
    .expect("should returns Ok results")
    .is_none()
{
    fast_sync_db.commit_genesis_ledger_info(&ledger_info)?;
    
    // Copy genesis transaction data from temporary DB to fast sync DB
    let genesis_txn = db_arc.get_temporary_db_with_genesis()
        .get_transaction(0)?;
    let genesis_txn_info = db_arc.get_temporary_db_with_genesis()
        .get_transaction_info_iterator(0, 1)?
        .next()
        .transpose()?.unwrap();
    
    // Write genesis transaction to fast sync DB
    let mut batch = SchemaBatch::new();
    fast_sync_db.ledger_db.transaction_db().put_transaction(
        0,
        &genesis_txn,
        false, // don't skip index
        &mut batch,
    )?;
    fast_sync_db.ledger_db.transaction_db().write_schemas(batch)?;
}
```

Alternatively, modify `commit_genesis_ledger_info` to accept and store the full genesis transaction, not just the ledger info metadata.

## Proof of Concept

This Rust test demonstrates the vulnerability:

```rust
#[test]
fn test_fast_sync_genesis_transaction_missing() {
    use aptos_db::AptosDB;
    use aptos_storage_interface::DbReader;
    use aptos_temppath::TempPath;
    use aptos_types::transaction::Transaction;
    
    // Create temporary paths for the two databases
    let temp_genesis_db_path = TempPath::new();
    let fast_sync_db_path = TempPath::new();
    
    // Create and bootstrap temporary DB with genesis
    let genesis_txn = aptos_vm_genesis::test_genesis_transaction();
    let temp_db = AptosDB::new_for_test(&temp_genesis_db_path);
    let db_rw = DbReaderWriter::new(temp_db);
    
    // Bootstrap with full genesis
    let waypoint = generate_waypoint::<AptosVMBlockExecutor>(&db_rw, &genesis_txn).unwrap();
    maybe_bootstrap::<AptosVMBlockExecutor>(&db_rw, &genesis_txn, waypoint).unwrap();
    
    // Get genesis transaction hash
    let genesis_hash = genesis_txn.hash();
    
    // Verify genesis transaction is retrievable in temporary DB
    let genesis_from_temp = db_rw.reader.get_transaction_by_hash(
        genesis_hash, 
        0, 
        false
    ).unwrap();
    assert!(genesis_from_temp.is_some(), "Genesis should be in temporary DB");
    
    // Create fast sync DB and only commit genesis ledger info (mimicking fast sync)
    let fast_sync_db = AptosDB::new_for_test(&fast_sync_db_path);
    let genesis_li = db_rw.reader.get_epoch_ending_ledger_info(0).unwrap();
    fast_sync_db.commit_genesis_ledger_info(&genesis_li).unwrap();
    
    // Try to retrieve genesis transaction by hash from fast sync DB
    let genesis_from_fast_sync = fast_sync_db.get_transaction_by_hash(
        genesis_hash,
        0,
        false
    ).unwrap();
    
    // This assertion FAILS - genesis transaction is not retrievable by hash!
    assert!(
        genesis_from_fast_sync.is_none(), 
        "BUG: Genesis transaction is missing from fast sync DB!"
    );
}
```

**Notes**

This vulnerability specifically affects nodes using fast sync mode when bootstrapping to versions higher than genesis. The temporary database correctly contains the genesis transaction with proper indexing, but the fast sync database (which becomes the primary database after bootstrap) lacks this critical mapping. This creates an inconsistency where the genesis transaction exists in the ledger but cannot be retrieved via the standard hash-based lookup API, breaking assumptions made by indexers, explorers, and other infrastructure components that rely on complete transaction history.

### Citations

**File:** aptos-node/src/storage.rs (L76-77)
```rust
            let temp_db = fast_sync_db_wrapper.get_temporary_db_with_genesis();
            maybe_apply_genesis(&DbReaderWriter::from_arc(temp_db), node_config)?;
```

**File:** aptos-node/src/storage.rs (L86-93)
```rust
            if fast_sync_db
                .get_latest_ledger_info_option()
                .expect("should returns Ok results")
                .is_none()
            {
                // it means the DB is empty and we need to
                // commit the genesis ledger info to the DB.
                fast_sync_db.commit_genesis_ledger_info(&ledger_info)?;
```

**File:** storage/aptosdb/src/db/mod.rs (L207-219)
```rust
    pub fn commit_genesis_ledger_info(&self, genesis_li: &LedgerInfoWithSignatures) -> Result<()> {
        let ledger_metadata_db = self.ledger_db.metadata_db();
        let current_epoch = ledger_metadata_db
            .get_latest_ledger_info_option()
            .map_or(0, |li| li.ledger_info().next_block_epoch());
        ensure!(
            genesis_li.ledger_info().epoch() == current_epoch && current_epoch == 0,
            "Genesis ledger info epoch is not 0"
        );
        let mut ledger_batch = SchemaBatch::new();
        ledger_metadata_db.put_ledger_info(genesis_li, &mut ledger_batch)?;
        ledger_metadata_db.write_schemas(ledger_batch)
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L133-145)
```rust
            // Ensure the output with proof only contains a single transaction output and info
            let num_transaction_outputs = output_with_proof.get_num_outputs();
            let num_transaction_infos = output_with_proof.proof.transaction_infos.len();
            ensure!(
                num_transaction_outputs == 1,
                "Number of transaction outputs should == 1, but got: {}",
                num_transaction_outputs
            );
            ensure!(
                num_transaction_infos == 1,
                "Number of transaction infos should == 1, but got: {}",
                num_transaction_infos
            );
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L206-213)
```rust
    for (idx, txn) in txns.iter().enumerate() {
        ledger_db.transaction_db().put_transaction(
            first_version + idx as Version,
            txn,
            /*skip_index=*/ false,
            &mut ledger_db_batch.transaction_db_batches,
        )?;
    }
```

**File:** storage/aptosdb/src/ledger_db/transaction_db.rs (L148-163)
```rust
        let transaction_hash = transaction.hash();

        if let Some(signed_txn) = transaction.try_as_signed_user_txn() {
            let txn_summary = IndexedTransactionSummary::V1 {
                sender: signed_txn.sender(),
                replay_protector: signed_txn.replay_protector(),
                version,
                transaction_hash,
            };
            batch.put::<TransactionSummariesByAccountSchema>(
                &(signed_txn.sender(), version),
                &txn_summary,
            )?;
        }
        batch.put::<TransactionByHashSchema>(&transaction_hash, &version)?;
        batch.put::<TransactionSchema>(&version, transaction)?;
```

**File:** storage/aptosdb/src/fast_sync_storage_wrapper.rs (L126-132)
```rust
    pub(crate) fn get_aptos_db_read_ref(&self) -> &AptosDB {
        if self.is_fast_sync_bootstrap_finished() {
            self.db_for_fast_sync.as_ref()
        } else {
            self.temporary_db_with_genesis.as_ref()
        }
    }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L232-244)
```rust
    fn get_transaction_by_hash(
        &self,
        hash: HashValue,
        ledger_version: Version,
        fetch_events: bool,
    ) -> Result<Option<TransactionWithProof>> {
        gauged_api("get_transaction_by_hash", || {
            self.ledger_db
                .transaction_db()
                .get_transaction_version_by_hash(&hash, ledger_version)?
                .map(|v| self.get_transaction_with_proof(v, ledger_version, fetch_events))
                .transpose()
        })
```
