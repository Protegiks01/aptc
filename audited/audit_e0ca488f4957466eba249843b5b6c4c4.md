# Audit Report

## Title
Cross-Resource-Group Conflict Detection Bypass in Granular Mode Enables Consensus Violations

## Summary
In granular resource group conflict mode, the block executor fails to detect conflicts between transactions that read resource group container metadata (tracked as `Resource(K)`) and transactions that write to resource group members (tracked as `Group(K, Tag)`). This allows non-deterministic parallel execution, violating the fundamental consensus invariant that all validators must produce identical state roots for identical blocks.

## Finding Description

The Aptos block executor supports two conflict detection modes for resource groups: coarse-grained (all accesses to the same group conflict) and granular (only same-tag accesses conflict). In granular mode (`use_granular_resource_group_conflicts: true`), a critical mismatch exists between how reads and writes are tracked:

**Write Tracking:** When a transaction writes to a resource group, only the modified member tags are recorded in the write summary: [1](#0-0) 

Notice that when `WriteResourceGroup` is encountered, only `InputOutputKey::Group(state_key, tag)` entries are added—the container's `Resource(state_key)` is NOT tracked.

**Read Tracking:** When a transaction reads resource group container metadata (existence, size, or metadata) via `TResourceView` methods, it's tracked as a container read: [2](#0-1) 

This calls `get_resource_state_value_impl` which reads from `data_reads` (not `group_reads`), resulting in `Resource(state_key)` being added to the read summary: [3](#0-2) 

**Conflict Detection Failure:** The conflict detection uses HashSet intersection based on enum equality: [4](#0-3) 

Since `InputOutputKey::Resource(K)` and `InputOutputKey::Group(K, Tag)` are different enum variants with derived `Eq` and `Hash`: [5](#0-4) 

They will NEVER be equal, even when `K` is identical. In granular mode, the summaries are not collapsed: [6](#0-5) 

**Attack Scenario:**
1. Transaction A reads resource group container metadata at key K (e.g., `resource_exists(&K)` or `get_resource_state_value_metadata(&K)`) → records `Resource(K)` read
2. Transaction B writes to a member of the same resource group (key K, tag T1) → records `Group(K, T1)` write  
3. Transactions execute in parallel with no detected conflict
4. Transaction A commits with potentially stale metadata (e.g., thinks group doesn't exist when it does)
5. Different validators may execute in different orders, producing different state roots
6. **Consensus safety violation**

## Impact Explanation

This is a **Critical** severity vulnerability per Aptos bug bounty criteria:

- **Consensus/Safety violations**: This directly breaks the fundamental invariant that all validators must produce identical state roots for identical blocks. When validators execute the same block in parallel, they may produce different outputs depending on execution order.

- **Non-deterministic execution**: The parallel block executor (BlockSTM) is designed to ensure deterministic results despite parallel execution. This bug allows two conflicting transactions to execute in parallel without conflict detection, leading to non-deterministic state.

- **Chain fork potential**: If different validators commit different state roots for the same block, it could lead to chain splits requiring manual intervention or hard fork to resolve.

The vulnerability affects core consensus correctness, warranting the maximum Critical severity classification.

## Likelihood Explanation

**High likelihood** - This vulnerability can be triggered in normal operation:

- Resource groups are a core Aptos feature used extensively in the framework (e.g., coin stores, NFT collections)
- Granular conflict mode is designed for performance optimization and will likely be enabled in production
- Any transaction that checks resource group existence/metadata alongside concurrent writes triggers the bug
- No special privileges required—any transaction sender can trigger this
- The bug is deterministic and reproducible given the right transaction ordering

The only limiting factor is that granular mode must be enabled via on-chain configuration. Once enabled, the vulnerability is easily exploitable through normal transaction submission.

## Recommendation

The root cause is that resource group writes don't record the container-level access. The fix should ensure that in granular mode, either:

**Option 1 (Recommended):** Record both container and member-level accesses in write summaries:

```rust
// In get_write_summary() at aptos-move/aptos-vm/src/block_executor/mod.rs
AbstractResourceWriteOp::WriteResourceGroup(write) => {
    // Record container-level write for conflict detection with metadata reads
    writes.insert(InputOutputKey::Resource(state_key.clone()));
    
    // Record member-level writes for granular conflict detection
    for tag in write.inner_ops().keys() {
        writes.insert(InputOutputKey::Group(state_key.clone(), tag.clone()));
    }
},
```

**Option 2:** Collapse resource group conflicts when metadata/container-level operations are detected:

```rust
// In ReadWriteSummary
pub fn has_container_reads(&self) -> bool {
    self.reads.iter().any(|k| matches!(k, InputOutputKey::Resource(_)))
}

// In accumulate_fee_statement
let rw_summary = if self.block_gas_limit_type.use_granular_resource_group_conflicts()
    && !txn_read_write_summary.has_container_reads() {
    txn_read_write_summary
} else {
    txn_read_write_summary.collapse_resource_group_conflicts()
}
```

Option 1 is preferred as it maintains granularity while ensuring correctness.

## Proof of Concept

```rust
// Test case to add to aptos-move/block-executor/src/limit_processor.rs

#[test]
fn test_conflict_limit_granular_resource_groups_container_vs_member() {
    let block_gas_limit = BlockGasLimitType::ComplexLimitV1 {
        effective_block_gas_limit: 1000,
        execution_gas_effective_multiplier: 1,
        io_gas_effective_multiplier: 1,
        conflict_penalty_window: 8,
        use_module_publishing_block_conflict: false,
        block_output_limit: None,
        include_user_txn_size_in_block_output: true,
        add_block_limit_outcome_onchain: false,
        use_granular_resource_group_conflicts: true,
    };

    let mut processor = TestProcessor::new(block_gas_limit, None, 10);

    // Transaction 1: Read container metadata (e.g., resource_exists)
    processor.accumulate_fee_statement(
        execution_fee(10),
        Some(ReadWriteSummary::new(
            to_map(&[InputOutputKey::Resource(1)]), // Reading container
            to_map(&[]),
        )),
        None,
    );
    assert_eq!(1, processor.compute_conflict_multiplier(8));

    // Transaction 2: Write to group member
    processor.accumulate_fee_statement(
        execution_fee(10),
        Some(ReadWriteSummary::new(
            to_map(&[InputOutputKey::Group(1, 1)]),
            to_map(&[InputOutputKey::Group(1, 1)]), // Writing member
        )),
        None,
    );
    
    // BUG: No conflict detected! Should be 2, but is 1
    // Resource(1) and Group(1, 1) don't conflict in granular mode
    assert_eq!(1, processor.compute_conflict_multiplier(8));
    
    // This demonstrates the vulnerability: a read of container metadata
    // and a write to a group member don't conflict, allowing non-deterministic
    // parallel execution
}
```

This test demonstrates that `Resource(1)` reads and `Group(1, 1)` writes do not conflict in granular mode, even though they access the same resource group container.

### Citations

**File:** aptos-move/aptos-vm/src/block_executor/mod.rs (L149-152)
```rust
                AbstractResourceWriteOp::WriteResourceGroup(write) => {
                    for tag in write.inner_ops().keys() {
                        writes.insert(InputOutputKey::Group(state_key.clone(), tag.clone()));
                    }
```

**File:** aptos-move/block-executor/src/view.rs (L1652-1664)
```rust
    fn get_resource_state_value_metadata(
        &self,
        state_key: &Self::Key,
    ) -> PartialVMResult<Option<StateValueMetadata>> {
        self.get_resource_state_value_impl(state_key, UnknownOrLayout::Unknown, ReadKind::Metadata)
            .map(|res| {
                if let ReadResult::Metadata(v) = res {
                    v
                } else {
                    unreachable!("Read result must be Metadata kind")
                }
            })
    }
```

**File:** aptos-move/block-executor/src/captured_reads.rs (L1207-1210)
```rust
        for (key, read) in &self.data_reads {
            if let DataRead::Versioned(_, _, _) = read {
                ret.insert(InputOutputKey::Resource(key.clone()));
            }
```

**File:** aptos-move/block-executor/src/types.rs (L11-16)
```rust
#[derive(Eq, Hash, PartialEq, Debug)]
pub enum InputOutputKey<K, T> {
    Resource(K),
    Group(K, T),
    DelayedField(DelayedFieldID),
}
```

**File:** aptos-move/block-executor/src/types.rs (L31-33)
```rust
    pub fn conflicts_with_previous(&self, previous: &Self) -> bool {
        !self.reads.is_disjoint(&previous.writes)
    }
```

**File:** aptos-move/block-executor/src/limit_processor.rs (L82-89)
```rust
            let rw_summary = if self
                .block_gas_limit_type
                .use_granular_resource_group_conflicts()
            {
                txn_read_write_summary
            } else {
                txn_read_write_summary.collapse_resource_group_conflicts()
            };
```
