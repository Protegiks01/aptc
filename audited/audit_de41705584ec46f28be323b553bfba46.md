# Audit Report

## Title
Double-Signing Vulnerability in JWK Per-Key Consensus Allows Validator Equivocation

## Summary
The `maybe_start_consensus()` function in `KeyLevelConsensusManager` fails to check if a validator has already signed a different update for the same `(issuer, kid, base_version)` triple. This allows validators to unintentionally equivocate by signing multiple conflicting JWK updates for the same base version, violating consensus safety.

## Finding Description

The vulnerability exists in the consensus state management and deduplication logic. The consensus state is stored in a HashMap keyed only by `(Issuer, KID)`, not by `(Issuer, KID, base_version)`: [1](#0-0) 

When `maybe_start_consensus()` is called, it checks if consensus has already started by looking up the state using only `(issuer, kid)`: [2](#0-1) 

The critical flaw is that this check only compares whether `my_proposal.observed.to_upsert == update.to_upsert`. It **never verifies** if `my_proposal.observed.base_version == update.base_version`. 

When the check fails (different `to_upsert` values), the function proceeds to sign the new update: [3](#0-2) 

And then overwrites the previous state: [4](#0-3) 

**Attack Scenario:**

1. On-chain state for issuer "Alice" is at version 5
2. **Time T1:** Validator V's JWK observer fetches `JWK_A` for `kid="key1"` from the OIDC provider
   - Creates `KeyLevelUpdate{issuer="Alice", base_version=5, kid="key1", to_upsert=Some(JWK_A)}`
   - Signs it and stores in `states_by_key[("Alice", "key1")]`
   - When peer P1 requests this validator's observation, it receives the signed update with `JWK_A`

3. **Time T2:** Before the on-chain state updates, the observer fetches `JWK_B` for `kid="key1"` (due to network instability, OIDC provider key rotation, or caching issues)
   - Creates `KeyLevelUpdate{issuer="Alice", base_version=5, kid="key1", to_upsert=Some(JWK_B)}`
   - The check finds existing state in `states_by_key[("Alice", "key1")]`
   - Compares `to_upsert`: `JWK_A != JWK_B` â†’ returns `false`
   - `consensus_already_started = false`
   - **Signs the new update** (equivocation!)
   - Overwrites `states_by_key[("Alice", "key1")]` with new proposal containing `JWK_B`
   - When peer P2 requests this validator's observation, it receives the signed update with `JWK_B`

4. **Result:** Validator V has now signed TWO different updates for the same `(issuer="Alice", kid="key1", base_version=5)` triple

The JWK observer is triggered periodically (every 10 seconds): [5](#0-4) 

When peers request observations via RPC, they receive whatever is currently in the validator's state: [6](#0-5) 

Since the state gets overwritten, different peers requesting at different times will receive different signed observations from the same validator for the same base version.

**Which Invariant is Broken:**

This violates the "Consensus Safety" invariant: validators must not equivocate by signing conflicting values. The JWK consensus protocol assumes validators sign at most one update per `(issuer, kid, base_version)` triple. When different peers collect different signed observations, they may form different quorums around conflicting JWK values, leading to consensus divergence.

## Impact Explanation

**Critical Severity - Consensus/Safety Violation**

This qualifies as Critical under the Aptos bug bounty program because it causes a **Consensus/Safety violation**:

- Different validators may collect different signed observations from the equivocating validator
- Multiple conflicting quorums could form for the same `(issuer, kid, base_version)` triple
- Different nodes may commit different `QuorumCertifiedUpdate` transactions to the blockchain
- This could lead to consensus divergence where validators disagree on the correct chain state
- In the worst case, this requires a hard fork or manual intervention to resolve

The vulnerability affects the core consensus mechanism for JWK updates, which is critical infrastructure for keyless authentication in Aptos. A consensus split in this system could prevent proper validation of keyless transactions across the network.

## Likelihood Explanation

**High Likelihood**

This vulnerability has a high likelihood of occurrence because:

1. **No malicious intent required**: Even honest validators will equivocate due to this bug
2. **Frequent trigger conditions**: 
   - JWK observers poll OIDC providers every 10 seconds
   - Network instability when fetching from external OIDC providers is common
   - OIDC providers can update their keys between observation cycles
   - HTTP caching at various layers can cause inconsistent responses
3. **Race condition window**: Between observation cycles, if the OIDC provider's response changes before on-chain state updates, equivocation occurs
4. **No protective mechanisms**: There is no validation, monitoring, or alerting for this condition

The bug can be triggered during normal validator operation without any attack.

## Recommendation

Add a base version check to prevent signing conflicting updates. Two approaches:

**Option 1: Add explicit base_version validation**

```rust
fn maybe_start_consensus(&mut self, update: KeyLevelUpdate) -> Result<()> {
    let consensus_already_started = match self
        .states_by_key
        .get(&(update.issuer.clone(), update.kid.clone()))
        .cloned()
    {
        Some(ConsensusState::InProgress { my_proposal, .. })
        | Some(ConsensusState::Finished { my_proposal, .. }) => {
            // Check BOTH base_version and to_upsert
            my_proposal.observed.base_version == update.base_version &&
            my_proposal.observed.to_upsert == update.to_upsert
        },
        _ => false,
    };

    if consensus_already_started {
        return Ok(());
    }

    // Prevent equivocation: reject if we already signed a different value for this base_version
    if let Some(ConsensusState::InProgress { my_proposal, .. })
    | Some(ConsensusState::Finished { my_proposal, .. }) = self
        .states_by_key
        .get(&(update.issuer.clone(), update.kid.clone()))
    {
        if my_proposal.observed.base_version == update.base_version {
            bail!(
                "Refusing to sign different update for same base_version. \
                 issuer={:?}, kid={:?}, base_version={}, \
                 existing_to_upsert={:?}, new_to_upsert={:?}",
                String::from_utf8(update.issuer.clone()),
                String::from_utf8(update.kid.clone()),
                update.base_version,
                my_proposal.observed.to_upsert,
                update.to_upsert
            );
        }
    }

    // Continue with signing...
    let issuer_level_repr = update
        .try_as_issuer_level_repr()
        .context("initiate_key_level_consensus failed at repr conversion")?;
    let signature = self
        .consensus_key
        .sign(&issuer_level_repr)
        .context("crypto material error occurred during signing")?;
    
    // ... rest of function
}
```

**Option 2: Include base_version in the state key**

Change the HashMap key to include base_version:
```rust
states_by_key: HashMap<(Issuer, KID, u64), ConsensusState<ObservedKeyLevelUpdate>>
```

And update all access patterns accordingly. This is a more invasive change but provides stronger guarantees.

## Proof of Concept

```rust
#[cfg(test)]
mod equivocation_test {
    use super::*;
    use aptos_crypto::{bls12381::PrivateKey, Uniform};
    use aptos_types::{
        account_address::AccountAddress,
        epoch_state::EpochState,
        jwks::{jwk::JWK, rsa::RSA_JWK, KeyLevelUpdate, ProviderJWKsIndexed},
        validator_verifier::ValidatorVerifier,
    };
    use std::sync::Arc;

    #[test]
    fn test_double_signing_vulnerability() {
        // Setup
        let consensus_key = Arc::new(PrivateKey::generate_for_testing());
        let my_addr = AccountAddress::random();
        let epoch_state = Arc::new(EpochState::empty());
        
        let mut manager = KeyLevelConsensusManager::new(
            consensus_key.clone(),
            my_addr,
            epoch_state.clone(),
            // ... setup reliable broadcast, vtxn_pool ...
        );

        // Set on-chain state at version 5
        let issuer = b"issuer-alice".to_vec();
        let kid = b"key1".to_vec();
        let mut onchain_jwks = ProviderJWKsIndexed::new(issuer.clone());
        onchain_jwks.version = 5;
        manager.onchain_jwks.insert(issuer.clone(), onchain_jwks);

        // First observation: JWK_A
        let jwk_a = JWK::RSA(RSA_JWK::new_256_aqab("key1", "modulus_A"));
        let update_a = KeyLevelUpdate {
            issuer: issuer.clone(),
            base_version: 5,
            kid: kid.clone(),
            to_upsert: Some(jwk_a.clone()),
        };
        
        // Sign first update
        manager.maybe_start_consensus(update_a.clone()).unwrap();
        
        // Get the first signature
        let state_1 = manager.states_by_key.get(&(issuer.clone(), kid.clone())).unwrap();
        let signature_1 = match state_1 {
            ConsensusState::InProgress { my_proposal, .. } => my_proposal.signature.clone(),
            _ => panic!("Expected InProgress state"),
        };

        // Second observation: JWK_B (different JWK, SAME base_version)
        let jwk_b = JWK::RSA(RSA_JWK::new_256_aqab("key1", "modulus_B"));
        let update_b = KeyLevelUpdate {
            issuer: issuer.clone(),
            base_version: 5, // SAME base_version!
            kid: kid.clone(),
            to_upsert: Some(jwk_b.clone()),
        };
        
        // BUG: This should fail but doesn't!
        manager.maybe_start_consensus(update_b.clone()).unwrap();
        
        // Get the second signature
        let state_2 = manager.states_by_key.get(&(issuer.clone(), kid.clone())).unwrap();
        let signature_2 = match state_2 {
            ConsensusState::InProgress { my_proposal, .. } => my_proposal.signature.clone(),
            _ => panic!("Expected InProgress state"),
        };

        // Verify equivocation occurred
        assert_ne!(jwk_a, jwk_b, "JWKs should be different");
        assert_ne!(signature_1, signature_2, "Signatures should be different");
        
        // Both signatures are valid for the same (issuer, kid, base_version=5)
        // This is EQUIVOCATION!
        println!("VULNERABILITY CONFIRMED: Validator signed two different updates for:");
        println!("  issuer: {:?}", String::from_utf8(issuer));
        println!("  kid: {:?}", String::from_utf8(kid));
        println!("  base_version: 5");
        println!("  First update: {:?}", jwk_a);
        println!("  Second update: {:?}", jwk_b);
    }
}
```

**Expected Behavior:** The second `maybe_start_consensus()` call should reject signing a different update for the same base_version.

**Actual Behavior:** The second call succeeds, creating two different signed updates for the same `(issuer, kid, base_version)` triple, demonstrating equivocation.

---

## Notes

The vulnerability is particularly concerning because:

1. It affects the JWK consensus mechanism, which is critical for keyless authentication security in Aptos
2. It can occur during normal operation without malicious validators
3. The equivocation is not detected or logged, making it difficult to diagnose
4. The state overwrite behavior means even the equivocating validator loses track of its first signature
5. This violates the fundamental consensus safety property that validators must not sign conflicting values

The fix should be implemented urgently as this is a critical consensus safety issue.

### Citations

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L59-59)
```rust
    states_by_key: HashMap<(Issuer, KID), ConsensusState<ObservedKeyLevelUpdate>>,
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L180-190)
```rust
        let consensus_already_started = match self
            .states_by_key
            .get(&(update.issuer.clone(), update.kid.clone()))
            .cloned()
        {
            Some(ConsensusState::InProgress { my_proposal, .. })
            | Some(ConsensusState::Finished { my_proposal, .. }) => {
                my_proposal.observed.to_upsert == update.to_upsert
            },
            _ => false,
        };
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L196-202)
```rust
        let issuer_level_repr = update
            .try_as_issuer_level_repr()
            .context("initiate_key_level_consensus failed at repr conversion")?;
        let signature = self
            .consensus_key
            .sign(&issuer_level_repr)
            .context("crypto material error occurred during signing")?;
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L216-228)
```rust
        self.states_by_key.insert(
            (update.issuer.clone(), update.kid.clone()),
            ConsensusState::InProgress {
                my_proposal: ObservedKeyLevelUpdate {
                    author: self.my_addr,
                    observed: update,
                    signature,
                },
                abort_handle_wrapper: QuorumCertProcessGuard {
                    handle: abort_handle,
                },
            },
        );
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L287-299)
```rust
                    ConsensusState::InProgress { my_proposal, .. }
                    | ConsensusState::Finished { my_proposal, .. } => Ok(
                        JWKConsensusMsg::ObservationResponse(ObservedUpdateResponse {
                            epoch: self.epoch_state.epoch,
                            update: ObservedUpdate {
                                author: self.my_addr,
                                observed: my_proposal
                                    .observed
                                    .try_as_issuer_level_repr()
                                    .context("process_peer_request failed with repr conversion")?,
                                signature: my_proposal.signature.clone(),
                            },
                        }),
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L399-399)
```rust
                        Duration::from_secs(10),
```
