# Audit Report

## Title
NodeConfig Sanitization Bypass via Unsanitized `skip_config_sanitizer` Field Enables Supply Chain Attack

## Summary
The `NodeStartupConfig.skip_config_sanitizer` field, which controls whether configuration sanitization runs, is itself never sanitized. This creates a meta-vulnerability where an attacker who compromises the deployment pipeline can inject this flag into configuration files, bypassing all mainnet security checks including failpoint restrictions, paranoid verification requirements, and authentication enforcement.

## Finding Description

The NodeConfig sanitization system has a critical design flaw: several fields in `NodeConfig` do not implement `ConfigSanitizer` and are never validated, most critically the `node_startup` field containing `skip_config_sanitizer`. [1](#0-0) 

The sanitizer implementation explicitly checks this flag and returns early if it's set to `true`: [2](#0-1) 

However, `NodeStartupConfig` does NOT implement `ConfigSanitizer`: [3](#0-2) 

This means an attacker who compromises the deployment pipeline (CI/CD, configuration management tools, Docker image builds) can inject a malicious config that bypasses all sanitization:

```yaml
node_startup:
  skip_config_sanitizer: true
failpoints:
  consensus::fail_before_commit: "return"
execution:
  paranoid_hot_potato_verification: false
  paranoid_type_verification: false
admin_service:
  enabled: true
  authentication_configs: []
```

This would bypass critical mainnet safeguards including:
- Failpoint restrictions that normally prevent them on mainnet
- Paranoid verification requirements for Move execution
- Authentication requirements for admin endpoints
- Secure backend requirements for validators [4](#0-3) [5](#0-4) [6](#0-5) 

The test suite even demonstrates this bypass capability: [7](#0-6) 

**Additional Unsanitized Fields:**
Beyond `node_startup`, the following NodeConfig fields also lack ConfigSanitizer implementations:
- `consensus_observer` - affects consensus observation behavior
- `transaction_filters` - controls transaction filtering in consensus and execution  
- `dkg`, `indexer`, `indexer_table_info`, `jwk_consensus`, `peer_monitoring_service`
- `randomness_override_seq_num` - affects consensus randomness

This reveals a systemic issue: the sanitization architecture is not comprehensive and relies on manual enumeration of fields to check.

## Impact Explanation

**Critical Severity** - This vulnerability enables multiple attack vectors:

1. **Consensus Safety Violations**: By setting `skip_config_sanitizer: true` and disabling paranoid verifications, an attacker could potentially cause non-deterministic execution across validators, breaking consensus safety guarantees.

2. **Denial of Service**: Enabling failpoints on mainnet would allow crashing validators at specific code points, causing network-wide liveness failures.

3. **Authentication Bypass**: Disabling admin service authentication requirements would expose privileged endpoints to unauthorized access.

4. **Supply Chain Amplification**: A single compromise of deployment infrastructure (Ansible playbooks, Terraform configs, Docker base images) affects all nodes deployed from that source.

However, this requires **privileged access** to deployment infrastructure, not just network-level access.

## Likelihood Explanation

**Likelihood: Medium to Low**

While the technical vulnerability is real, exploitation requires:
- Compromise of deployment/CI-CD pipeline OR
- Malicious insider with deployment access OR  
- Successful PR injection that adds unsanitized fields

This is within the threat model of supply chain attacks, but requires significant attacker capabilities beyond just network access. The impact is amplified if the compromise affects widely-used deployment templates or base images.

## Recommendation

Implement comprehensive sanitization validation:

```rust
// In config/src/config/node_startup_config.rs, add:
impl ConfigSanitizer for NodeStartupConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        
        // Prevent skip_config_sanitizer on mainnet
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() && node_config.node_startup.skip_config_sanitizer {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "skip_config_sanitizer cannot be enabled on mainnet nodes!".into(),
                ));
            }
        }
        
        Ok(())
    }
}
```

Then add to `config_sanitizer.rs`:
```rust
NodeStartupConfig::sanitize(node_config, node_type, chain_id)?;
```

**Additional Recommendations:**
1. Implement `ConfigSanitizer` for ALL NodeConfig fields
2. Add compile-time checks to ensure all fields are sanitized (using procedural macros)
3. Add integrity checks to config files (signatures, checksums)
4. Separate test-only flags from production configs

## Proof of Concept

Create a malicious config file `malicious_mainnet.yaml`:

```yaml
base:
  role: validator
  data_dir: "./data"
  
node_startup:
  skip_config_sanitizer: true  # Bypass all sanitization
  
execution:
  paranoid_hot_potato_verification: false  # Would normally fail on mainnet
  paranoid_type_verification: false         # Would normally fail on mainnet
  
failpoints:
  consensus::fail_before_commit: "return"  # Would normally fail on mainnet

admin_service:
  enabled: true
  authentication_configs: []  # Would normally fail on mainnet
```

Load and verify bypass:
```rust
use aptos_config::config::{NodeConfig, ConfigSanitizer};
use aptos_config::config::node_config_loader::NodeType;
use aptos_types::chain_id::ChainId;

// This should fail but will succeed due to skip_config_sanitizer
let node_config = NodeConfig::load_from_path("malicious_mainnet.yaml").unwrap();

// Verify the dangerous settings are active
assert!(node_config.node_startup.skip_config_sanitizer);
assert!(!node_config.execution.paranoid_hot_potato_verification);
assert!(node_config.failpoints.is_some());

// Sanitization was bypassed!
NodeConfig::sanitize(&node_config, NodeType::Validator, Some(ChainId::mainnet())).unwrap();
```

The config loads successfully despite containing settings that should be forbidden on mainnet, demonstrating the sanitization bypass.

---

## Notes

This vulnerability represents a **defense-in-depth failure** rather than a directly exploitable bug by unprivileged attackers. It requires compromise of deployment infrastructure, which is within the supply chain attack threat model but requires significant attacker capabilities. The primary concern is that a single compromise of deployment tooling can propagate dangerous configurations across many nodes without detection by the sanitization system.

### Citations

**File:** config/src/config/node_config.rs (L35-92)
```rust
#[derive(Clone, Debug, Default, Deserialize, PartialEq, Serialize)]
#[serde(deny_unknown_fields)]
pub struct NodeConfig {
    #[serde(default)]
    pub admin_service: AdminServiceConfig,
    #[serde(default)]
    pub api: ApiConfig,
    #[serde(default)]
    pub base: BaseConfig,
    #[serde(default)]
    pub consensus: ConsensusConfig,
    #[serde(default)]
    pub consensus_observer: ConsensusObserverConfig,
    #[serde(default)]
    pub dag_consensus: DagConsensusConfig,
    #[serde(default)]
    pub dkg: DKGConfig,
    #[serde(default)]
    pub execution: ExecutionConfig,
    #[serde(default)]
    pub failpoints: Option<HashMap<String, String>>,
    #[serde(default, skip_serializing_if = "Vec::is_empty")]
    pub full_node_networks: Vec<NetworkConfig>,
    #[serde(default)]
    pub indexer: IndexerConfig,
    #[serde(default)]
    pub indexer_grpc: IndexerGrpcConfig,
    #[serde(default)]
    pub indexer_table_info: IndexerTableInfoConfig,
    #[serde(default)]
    pub inspection_service: InspectionServiceConfig,
    #[serde(default)]
    pub jwk_consensus: JWKConsensusConfig,
    #[serde(default)]
    pub logger: LoggerConfig,
    #[serde(default)]
    pub mempool: MempoolConfig,
    #[serde(default)]
    pub netbench: Option<NetbenchConfig>,
    #[serde(default)]
    pub node_startup: NodeStartupConfig,
    #[serde(default)]
    pub peer_monitoring_service: PeerMonitoringServiceConfig,
    /// In a randomness stall, set this to be on-chain `RandomnessConfigSeqNum` + 1.
    /// Once enough nodes restarted with the new value, the chain should unblock with randomness disabled.
    #[serde(default)]
    pub randomness_override_seq_num: u64,
    #[serde(default)]
    pub state_sync: StateSyncConfig,
    #[serde(default)]
    pub storage: StorageConfig,
    #[serde(default)]
    pub transaction_filters: TransactionFiltersConfig,
    #[serde(default)]
    pub validator_network: Option<NetworkConfig>,
    #[serde(default)]
    pub indexer_db_config: InternalIndexerDBConfig,
}
```

**File:** config/src/config/config_sanitizer.rs (L39-71)
```rust
impl ConfigSanitizer for NodeConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        // If config sanitization is disabled, don't do anything!
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }

        // Sanitize all of the sub-configs
        AdminServiceConfig::sanitize(node_config, node_type, chain_id)?;
        ApiConfig::sanitize(node_config, node_type, chain_id)?;
        BaseConfig::sanitize(node_config, node_type, chain_id)?;
        ConsensusConfig::sanitize(node_config, node_type, chain_id)?;
        DagConsensusConfig::sanitize(node_config, node_type, chain_id)?;
        ExecutionConfig::sanitize(node_config, node_type, chain_id)?;
        sanitize_failpoints_config(node_config, node_type, chain_id)?;
        sanitize_fullnode_network_configs(node_config, node_type, chain_id)?;
        IndexerGrpcConfig::sanitize(node_config, node_type, chain_id)?;
        InspectionServiceConfig::sanitize(node_config, node_type, chain_id)?;
        LoggerConfig::sanitize(node_config, node_type, chain_id)?;
        MempoolConfig::sanitize(node_config, node_type, chain_id)?;
        NetbenchConfig::sanitize(node_config, node_type, chain_id)?;
        StateSyncConfig::sanitize(node_config, node_type, chain_id)?;
        StorageConfig::sanitize(node_config, node_type, chain_id)?;
        InternalIndexerDBConfig::sanitize(node_config, node_type, chain_id)?;
        sanitize_validator_network_config(node_config, node_type, chain_id)?;

        Ok(()) // All configs passed validation
    }
}
```

**File:** config/src/config/config_sanitizer.rs (L73-109)
```rust
/// Sanitize the failpoints config according to the node role and chain ID
fn sanitize_failpoints_config(
    node_config: &NodeConfig,
    _node_type: NodeType,
    chain_id: Option<ChainId>,
) -> Result<(), Error> {
    let sanitizer_name = FAILPOINTS_SANITIZER_NAME.to_string();
    let failpoints = &node_config.failpoints;

    // Verify that failpoints are not enabled in mainnet
    let failpoints_enabled = are_failpoints_enabled();
    if let Some(chain_id) = chain_id {
        if chain_id.is_mainnet() && failpoints_enabled {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Failpoints are not supported on mainnet nodes!".into(),
            ));
        }
    }

    // Ensure that the failpoints config is populated appropriately
    if let Some(failpoints) = failpoints {
        if failpoints_enabled && failpoints.is_empty() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Failpoints are enabled, but the failpoints config is empty?".into(),
            ));
        } else if !failpoints_enabled && !failpoints.is_empty() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Failpoints are disabled, but the failpoints config is not empty!".into(),
            ));
        }
    }

    Ok(())
}
```

**File:** config/src/config/config_sanitizer.rs (L212-239)
```rust
    fn test_disable_config_sanitizer() {
        // Create a default node config (with sanitization enabled)
        let mut node_config = NodeConfig::default();

        // Set a bad node config for mainnet
        node_config.execution.paranoid_hot_potato_verification = false;

        // Sanitize the config and verify the sanitizer fails
        let error =
            NodeConfig::sanitize(&node_config, NodeType::Validator, Some(ChainId::mainnet()))
                .unwrap_err();
        assert!(matches!(error, Error::ConfigSanitizerFailed(_, _)));

        // Create a node config with the sanitizer disabled
        let mut node_config = NodeConfig {
            node_startup: NodeStartupConfig {
                skip_config_sanitizer: true,
                ..Default::default()
            },
            ..Default::default()
        };

        // Set a bad node config for mainnet
        node_config.execution.paranoid_hot_potato_verification = false;

        // Sanitize the config and verify the sanitizer passes
        NodeConfig::sanitize(&node_config, NodeType::Validator, Some(ChainId::mainnet())).unwrap();
    }
```

**File:** config/src/config/node_startup_config.rs (L6-21)
```rust
#[derive(Clone, Copy, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct NodeStartupConfig {
    pub skip_config_optimizer: bool, // Whether or not to skip the config optimizer at startup
    pub skip_config_sanitizer: bool, // Whether or not to skip the config sanitizer at startup
}

#[allow(clippy::derivable_impls)] // Derive default manually (this is safer than guessing defaults)
impl Default for NodeStartupConfig {
    fn default() -> Self {
        Self {
            skip_config_optimizer: false,
            skip_config_sanitizer: false,
        }
    }
}
```

**File:** config/src/config/execution_config.rs (L157-186)
```rust
impl ConfigSanitizer for ExecutionConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let execution_config = &node_config.execution;

        // If this is a mainnet node, ensure that additional verifiers are enabled
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() {
                if !execution_config.paranoid_hot_potato_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_hot_potato_verification must be enabled for mainnet nodes!"
                            .into(),
                    ));
                }
                if !execution_config.paranoid_type_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_type_verification must be enabled for mainnet nodes!".into(),
                    ));
                }
            }
        }

        Ok(())
    }
```

**File:** config/src/config/admin_service_config.rs (L59-80)
```rust
impl ConfigSanitizer for AdminServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();

        if node_config.admin_service.enabled == Some(true) {
            if let Some(chain_id) = chain_id {
                if chain_id.is_mainnet()
                    && node_config.admin_service.authentication_configs.is_empty()
                {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "Must enable authentication for AdminService on mainnet.".into(),
                    ));
                }
            }
        }

        Ok(())
```
