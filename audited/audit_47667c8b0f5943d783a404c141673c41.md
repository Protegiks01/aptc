# Audit Report

## Title
Network Discovery Pubkey Mismatch Causes Validator Isolation Due to Lack of Configuration Validation

## Summary
The `setup_discovery()` function extracts a pubkey from the local `identity_key` configuration, but this key can differ from the on-chain registered key in the validator set. When this mismatch occurs, other validators authenticate against the on-chain key while the affected validator presents its local key during the Noise handshake, causing authentication failures and complete network isolation.

## Finding Description

The vulnerability exists in how validator network keys are validated between local configuration and on-chain registration. The system fails to enforce consistency between these two sources of truth, leading to a critical availability failure.

**The Flow:**

1. In `setup_discovery()`, the pubkey is extracted from the local configuration's `identity_key`: [1](#0-0) 

2. This `expected_pubkey` is used by the validator set discovery stream to detect mismatches: [2](#0-1) 

3. However, the mismatch detection only logs an error and sets a metric - **it does not prevent the system from continuing with mismatched keys**: [3](#0-2) 

4. Meanwhile, other validators discover peers from the on-chain validator set and update their trusted peers: [4](#0-3) 

5. When validators attempt to connect, the Noise handshake validates the remote peer's public key against the trusted peers set (which contains the on-chain key): [5](#0-4) 

6. The authentication check fails if the presented key doesn't match the on-chain registered key: [6](#0-5) 

**How the Mismatch Occurs:**

The on-chain validator configuration update function has no validation that the provided network addresses contain keys matching the validator's local identity: [7](#0-6) 

This allows scenarios where:
- A validator operator updates on-chain addresses with new keys but forgets to update local config
- Configuration files are restored from backup with old keys while on-chain has newer keys
- Initial setup uses mismatched keys due to operator error

## Impact Explanation

**Severity: High**

This issue causes complete validator isolation, meeting the High severity criterion of "Validator node slowdowns" and "Significant protocol violations" from the Aptos bug bounty program. 

**Concrete Impact:**
- The affected validator cannot accept ANY inbound connections from other validators
- Other validators waste resources repeatedly attempting failed connections
- The validator is excluded from consensus participation
- Network decentralization is reduced
- In worst case, if multiple validators have this issue simultaneously, consensus could be jeopardized

This is not a Critical severity issue because:
- It doesn't directly cause fund loss
- It doesn't break consensus safety (assuming <1/3 validators affected)
- It's operator-recoverable by fixing the configuration

## Likelihood Explanation

**Likelihood: Medium-High**

This is highly likely to occur in real-world operations because:

1. **Key Rotation Scenarios**: Operators performing key rotation must update both on-chain config and local node config in sync - any desynchronization causes this issue
2. **Multi-Environment Deployments**: Configuration management across development, staging, and production environments increases risk of mismatches
3. **Disaster Recovery**: Backup restoration procedures may inadvertently restore old keys while on-chain state has newer keys
4. **Human Error**: Initial validator setup involves multiple configuration steps where keys can be mismatched

The system provides **insufficient protection** against this common operational error:
- No pre-flight validation when updating on-chain config
- No startup validation that local keys match on-chain registration
- Only passive monitoring through metrics that may not trigger immediate alerts

## Recommendation

Implement multi-layered validation to prevent and detect key mismatches:

**1. Startup Validation (Critical)**
Add validation in the network builder that checks the local identity key matches the on-chain registered key:

```rust
// In NetworkBuilder::create() after discovery setup
fn validate_identity_key_matches_onchain(
    &self,
    identity_key: &x25519::PrivateKey,
    reconfig_subscription_service: &mut EventSubscriptionService,
) -> Result<(), Error> {
    let local_pubkey = identity_key.public_key();
    
    // Fetch current on-chain validator set
    let validator_set = fetch_current_validator_set(reconfig_subscription_service)?;
    
    // Find this validator's entry
    if let Some(validator_info) = validator_set.get(&self.network_context.peer_id()) {
        let onchain_keys = extract_pubkeys_from_addresses(&validator_info.network_addresses)?;
        
        if !onchain_keys.contains(&local_pubkey) {
            return Err(Error::IdentityKeyMismatch {
                local_key: local_pubkey,
                onchain_keys,
            });
        }
    }
    
    Ok(())
}
```

**2. On-Chain Validation (Recommended)**
Modify the `update_network_and_fullnode_addresses` function to validate address format and extract keys:

```move
public entry fun update_network_and_fullnode_addresses(
    operator: &signer,
    pool_address: address,
    new_network_addresses: vector<u8>,
    new_fullnode_addresses: vector<u8>,
) acquires StakePool, ValidatorConfig {
    // Existing checks...
    
    // NEW: Validate that addresses are well-formed and extractable
    assert!(
        validate_network_addresses(&new_network_addresses),
        error::invalid_argument(EINVALID_NETWORK_ADDRESSES)
    );
    
    // Rest of function...
}
```

**3. Runtime Monitoring Enhancement**
Upgrade the mismatch detection from passive logging to active alerting:

```rust
// In ValidatorSetStream::find_key_mismatches
if !pubkeys.contains(&self.expected_pubkey) {
    error!(/* ... */);
    
    // NEW: Trigger critical alert
    emit_critical_alert(CriticalAlert::IdentityKeyMismatch {
        expected: self.expected_pubkey,
        onchain: pubkeys.clone(),
    });
    
    // NEW: Consider refusing to start if mismatch detected
    return Err(DiscoveryError::IdentityKeyMismatch);
}
```

## Proof of Concept

```rust
// Rust integration test demonstrating the vulnerability
#[tokio::test]
async fn test_pubkey_mismatch_causes_connection_failure() {
    use aptos_crypto::x25519::{PrivateKey, PublicKey};
    use aptos_types::validator_info::ValidatorInfo;
    
    // Setup: Create two validators
    let mut rng = rand::thread_rng();
    
    // Validator A has identity_key_local but registers identity_key_onchain
    let identity_key_local = PrivateKey::generate(&mut rng);
    let pubkey_local = identity_key_local.public_key();
    
    let identity_key_onchain = PrivateKey::generate(&mut rng); // Different!
    let pubkey_onchain = identity_key_onchain.public_key();
    
    let validator_a_id = aptos_types::account_address::from_identity_public_key(pubkey_local);
    
    // Validator A registers on-chain with pubkey_onchain
    let onchain_address = NetworkAddress::mock()
        .append_prod_protos(pubkey_onchain, HANDSHAKE_VERSION);
    let validator_config = ValidatorConfig::new(
        consensus_key,
        bcs::to_bytes(&vec![onchain_address]).unwrap(),
        vec![],
        0,
    );
    
    // Validator B discovers Validator A via on-chain discovery
    // Gets pubkey_onchain in its trusted peers
    let validator_b = setup_validator_with_trusted_peers(
        validator_a_id,
        vec![pubkey_onchain], // B expects this key
    );
    
    // Validator A starts with identity_key_local
    let validator_a = setup_validator_with_identity(
        identity_key_local, // But A uses this key!
    );
    
    // Test: Validator B attempts to dial Validator A
    let connection_result = validator_b
        .dial_peer(validator_a_id, validator_a.listen_address())
        .await;
    
    // Expected: Connection fails with UnauthenticatedClientPubkey error
    assert!(matches!(
        connection_result,
        Err(NoiseHandshakeError::UnauthenticatedClientPubkey(..))
    ));
    
    // Validator A is isolated - cannot participate in consensus
    assert_eq!(validator_a.get_connected_peers().len(), 0);
}
```

## Notes

This vulnerability represents a critical gap in operational safety. While the system correctly detects the mismatch through the `find_key_mismatches()` function [2](#0-1) , it fails to prevent the validator from operating in this broken state.

The root cause is the lack of validation when updating on-chain validator configuration [7](#0-6)  and the absence of startup validation that local identity matches on-chain registration.

This is particularly dangerous because:
1. The failure mode is silent - the validator appears to start successfully
2. Metrics may not be actively monitored
3. The impact compounds over time as other validators repeatedly fail to connect
4. Recovery requires manual intervention and configuration synchronization

### Citations

**File:** network/builder/src/builder.rs (L363-370)
```rust
                    let identity_key = config.identity_key();
                    let pubkey = identity_key.public_key();
                    DiscoveryChangeListener::validator_set(
                        self.network_context,
                        conn_mgr_reqs_tx.clone(),
                        pubkey,
                        reconfig_events,
                    )
```

**File:** network/discovery/src/validator_set.rs (L44-66)
```rust
    fn find_key_mismatches(&self, onchain_keys: Option<&HashSet<x25519::PublicKey>>) {
        let mismatch = onchain_keys.map_or(0, |pubkeys| {
            if !pubkeys.contains(&self.expected_pubkey) {
                error!(
                    NetworkSchema::new(&self.network_context),
                    "Onchain pubkey {:?} differs from local pubkey {}",
                    pubkeys,
                    self.expected_pubkey
                );
                1
            } else {
                0
            }
        });

        NETWORK_KEY_MISMATCH
            .with_label_values(&[
                self.network_context.role().as_str(),
                self.network_context.network_id().as_str(),
                self.network_context.peer_id().short_str().as_str(),
            ])
            .set(mismatch);
    }
```

**File:** network/discovery/src/validator_set.rs (L76-81)
```rust
        // Ensure that the public key matches what's onchain for this peer
        self.find_key_mismatches(
            peer_set
                .get(&self.network_context.peer_id())
                .map(|peer| &peer.keys),
        );
```

**File:** network/framework/src/connectivity_manager/mod.rs (L986-1000)
```rust
            // For each peer, union all of the pubkeys from each discovery source
            // to generate the new eligible peers set.
            let new_eligible = self.discovered_peers.read().get_eligible_peers();

            // Swap in the new eligible peers set
            if let Err(error) = self
                .peers_and_metadata
                .set_trusted_peers(&self.network_context.network_id(), new_eligible)
            {
                error!(
                    NetworkSchema::new(&self.network_context),
                    error = %error,
                    "Failed to update trusted peers set"
                );
            }
```

**File:** network/framework/src/noise/handshake.rs (L372-377)
```rust
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
```

**File:** network/framework/src/noise/handshake.rs (L488-500)
```rust
    fn authenticate_inbound(
        remote_peer_short: ShortHexStr,
        peer: &Peer,
        remote_public_key: &x25519::PublicKey,
    ) -> Result<PeerRole, NoiseHandshakeError> {
        if !peer.keys.contains(remote_public_key) {
            return Err(NoiseHandshakeError::UnauthenticatedClientPubkey(
                remote_peer_short,
                hex::encode(remote_public_key.as_slice()),
            ));
        }
        Ok(peer.role)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L955-971)
```text
    public entry fun update_network_and_fullnode_addresses(
        operator: &signer,
        pool_address: address,
        new_network_addresses: vector<u8>,
        new_fullnode_addresses: vector<u8>,
    ) acquires StakePool, ValidatorConfig {
        check_stake_permission(operator);
        assert_reconfig_not_in_progress();
        assert_stake_pool_exists(pool_address);
        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        assert!(signer::address_of(operator) == stake_pool.operator_address, error::unauthenticated(ENOT_OPERATOR));
        assert!(exists<ValidatorConfig>(pool_address), error::not_found(EVALIDATOR_CONFIG));
        let validator_info = borrow_global_mut<ValidatorConfig>(pool_address);
        let old_network_addresses = validator_info.network_addresses;
        validator_info.network_addresses = new_network_addresses;
        let old_fullnode_addresses = validator_info.fullnode_addresses;
        validator_info.fullnode_addresses = new_fullnode_addresses;
```
