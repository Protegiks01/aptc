# Audit Report

## Title
Weak Execution State Validation in create_merged_with_executed_state Enables Consensus Fork Under Non-Deterministic Execution

## Summary
The `create_merged_with_executed_state()` function uses `match_ordered_only()` validation which only checks epoch/round/id/timestamp matching, not execution state consistency. This allows multiple QuorumCerts with identical vote_data but different executed states to be created when non-deterministic execution or Byzantine behavior produces conflicting commit proofs, causing irrecoverable consensus forks.

## Finding Description
The vulnerability exists in the consensus pipeline's handling of commit proofs during the decoupled execution model. The system violates the **Deterministic Execution** invariant by failing to detect and reject execution state mismatches. [1](#0-0) 

The `match_ordered_only()` validation only verifies ordering fields match: [2](#0-1) 

When an `OrderedItem` receives a commit proof before execution, it accepts any commit proof matching these fields, even with different execution states: [3](#0-2) 

The safety rules also use weak validation when signing commit votes: [4](#0-3) 

**Attack Scenario:**
1. Block B at round R is ordered across the network
2. Due to non-deterministic execution bug, Validator Set 1 executes B → `state_root_X`, Validator Set 2 → `state_root_Y`
3. Set 1 (2f+1 validators) aggregates signatures for `commit_proof_1` with `state_root_X`
4. Set 2 (different 2f+1 validators) aggregates signatures for `commit_proof_2` with `state_root_Y`
5. Node A receives `commit_proof_1`, calls `create_merged_with_executed_state()` → creates `QC_A` with `state_root_X`
6. Node B receives `commit_proof_2`, calls `create_merged_with_executed_state()` → creates `QC_B` with `state_root_Y`
7. Both QCs have identical vote_data (same epoch/round/id/timestamp) but different execution states
8. Network permanently forks - different nodes commit different state roots for the same block

The commit proof verification only checks signatures, not execution state correctness: [5](#0-4) 

## Impact Explanation
**Critical Severity** - This violates consensus safety, causing:
- **Non-recoverable network partition** requiring hard fork
- Different nodes maintain conflicting state roots for identical blocks
- Permanent chain split across validator subsets
- Breaks the fundamental invariant: "All validators must produce identical state roots for identical blocks"

This meets the Critical Severity criteria: "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation
**Likelihood: Medium-High**

While this requires a non-determinism bug in execution or Byzantine behavior (>1/3 validators), such bugs have occurred in production blockchains:
- Timestamp handling differences
- Floating point operations
- Random number generation
- Concurrency issues in execution

The weak validation amplifies the impact of any non-determinism bug from "execution mismatch" to "permanent consensus fork". The system should detect and halt rather than silently accepting conflicting states.

## Recommendation
Add strict execution state validation:

```rust
pub fn create_merged_with_executed_state(
    &self,
    executed_ledger_info: LedgerInfoWithSignatures,
) -> anyhow::Result<QuorumCert> {
    let self_commit_info = self.commit_info();
    let executed_commit_info = executed_ledger_info.ledger_info().commit_info();
    
    // Strict validation: require FULL match including execution state
    ensure!(
        self_commit_info.epoch() == executed_commit_info.epoch()
            && self_commit_info.round() == executed_commit_info.round()
            && self_commit_info.id() == executed_commit_info.id()
            && self_commit_info.timestamp_usecs() == executed_commit_info.timestamp_usecs(),
        "Basic ordering fields must match"
    );
    
    // NEW: Verify execution states match if both are non-dummy
    if !self_commit_info.is_ordered_only() && !executed_commit_info.is_ordered_only() {
        ensure!(
            self_commit_info.executed_state_id() == executed_commit_info.executed_state_id()
                && self_commit_info.version() == executed_commit_info.version(),
            "Execution state mismatch detected: self={:?}, executed={:?}",
            self_commit_info,
            executed_commit_info
        );
    }
    
    Ok(Self::new(self.vote_data.clone(), executed_ledger_info))
}
```

Similarly, fix `buffer_item.rs` to require exact match for `OrderedItem`: [6](#0-5) 

When a commit proof arrives for an ordered item, validate execution state matches local execution result.

## Proof of Concept
```rust
// Conceptual PoC - demonstrates the validation gap
#[test]
fn test_execution_state_mismatch_accepted() {
    // Create ordered block info with placeholder execution
    let ordered_block_info = BlockInfo::new(
        1, // epoch
        10, // round  
        HashValue::random(),
        *ACCUMULATOR_PLACEHOLDER_HASH, // placeholder
        0, // version
        1000,
        None,
    );
    
    let vote_data = VoteData::new(ordered_block_info.clone(), ordered_block_info.clone());
    let ordered_li = LedgerInfo::new(ordered_block_info.clone(), vote_data.hash());
    
    // Create two DIFFERENT executed states for the same block
    let executed_block_info_1 = BlockInfo::new(
        1, 10, ordered_block_info.id(),
        HashValue::random(), // state_root_X
        100, 1000, None,
    );
    
    let executed_block_info_2 = BlockInfo::new(
        1, 10, ordered_block_info.id(),
        HashValue::random(), // state_root_Y (DIFFERENT!)
        100, 1000, None,
    );
    
    // Both pass match_ordered_only despite different execution states
    assert!(ordered_block_info.match_ordered_only(&executed_block_info_1));
    assert!(ordered_block_info.match_ordered_only(&executed_block_info_2));
    
    // This allows creating two different QCs for the same vote_data
    // with different execution states - CONSENSUS FORK!
}
```

## Notes
This vulnerability demonstrates inadequate error detection for non-deterministic execution. The system should fail-fast and halt upon detecting execution state mismatches, not silently accept them. The weak `match_ordered_only` validation was designed for decoupled execution's placeholder-to-real-state transition, but lacks safeguards against conflicting real execution states.

### Citations

**File:** consensus/consensus-types/src/quorum_cert.rs (L150-163)
```rust
    pub fn create_merged_with_executed_state(
        &self,
        executed_ledger_info: LedgerInfoWithSignatures,
    ) -> anyhow::Result<QuorumCert> {
        let self_commit_info = self.commit_info();
        let executed_commit_info = executed_ledger_info.ledger_info().commit_info();
        ensure!(
            self_commit_info.match_ordered_only(executed_commit_info),
            "Block info from QC and executed LI need to match, {:?} and {:?}",
            self_commit_info,
            executed_commit_info
        );
        Ok(Self::new(self.vote_data.clone(), executed_ledger_info))
    }
```

**File:** types/src/block_info.rs (L196-204)
```rust
    pub fn match_ordered_only(&self, executed_block_info: &BlockInfo) -> bool {
        self.epoch == executed_block_info.epoch
            && self.round == executed_block_info.round
            && self.id == executed_block_info.id
            && (self.timestamp_usecs == executed_block_info.timestamp_usecs
            // executed block info has changed its timestamp because it's a reconfiguration suffix
                || (self.timestamp_usecs > executed_block_info.timestamp_usecs
                    && executed_block_info.has_reconfiguration()))
    }
```

**File:** consensus/src/pipeline/buffer_item.rs (L146-149)
```rust
                if let Some(commit_proof) = commit_proof {
                    // We have already received the commit proof in fast forward sync path,
                    // we can just use that proof and proceed to aggregated
                    assert_eq!(commit_proof.commit_info().clone(), commit_info);
```

**File:** consensus/src/pipeline/buffer_item.rs (L272-286)
```rust
            Self::Ordered(ordered_item) => {
                let ordered = *ordered_item;
                assert!(ordered
                    .ordered_proof
                    .commit_info()
                    .match_ordered_only(commit_proof.commit_info()));
                // can't aggregate it without execution, only store the signatures
                debug!(
                    "{} received commit decision in ordered stage",
                    commit_proof.commit_info()
                );
                Self::Ordered(Box::new(OrderedItem {
                    commit_proof: Some(commit_proof),
                    ..ordered
                }))
```

**File:** consensus/safety-rules/src/safety_rules.rs (L395-403)
```rust
        if !old_ledger_info
            .commit_info()
            .match_ordered_only(new_ledger_info.commit_info())
        {
            return Err(Error::InconsistentExecutionResult(
                old_ledger_info.commit_info().to_string(),
                new_ledger_info.commit_info().to_string(),
            ));
        }
```

**File:** consensus/consensus-types/src/pipeline/commit_decision.rs (L49-59)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        ensure!(
            !self.ledger_info.commit_info().is_ordered_only(),
            "Unexpected ordered only commit info"
        );
        // We do not need to check the author because as long as the signature tree
        // is valid, the message should be valid.
        self.ledger_info
            .verify_signatures(validator)
            .context("Failed to verify Commit Decision")
    }
```
