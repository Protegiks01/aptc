# Audit Report

## Title
Panic-Based Denial of Service in Transaction Filter via Invalid TransactionType Enum Conversion

## Summary
The `TransactionRootFilter::matches()` method in the indexer-grpc transaction filter implementation uses an unsafe `.expect()` call when converting transaction type values, causing the service to panic and crash when encountering transactions with invalid type field values. This creates a denial-of-service vulnerability affecting the indexer-grpc data service availability.

## Finding Description

The vulnerability exists in the `Filterable<Transaction>` trait implementation for `TransactionRootFilter`. [1](#0-0) 

When filtering transactions by type, the code attempts to convert the raw `i32` transaction type field to the `TransactionType` enum using `try_from()`. The `TransactionType` enum only defines specific valid values (0, 1, 2, 3, 4, 20, 21), leaving gaps (5-19, 22+, and negative values) as invalid. [2](#0-1) 

The transaction type is stored as a raw `i32` field in the protobuf definition. [3](#0-2) 

**Attack Path:**
1. A malformed transaction with an invalid type field value (e.g., 5, 100, -1) enters the system through data corruption or malicious injection
2. The transaction gets stored in the indexer cache's `DataManager`
3. A client subscribes to the indexer-grpc service with a `BooleanTransactionFilter` containing a `TransactionRootFilter` that checks transaction types
4. The `InMemoryCache::get_data()` method processes cached transactions and calls `filter.matches(transaction)` [4](#0-3) 
5. The filter delegates to `TransactionRootFilter::matches()`, which calls `TransactionType::try_from(item.r#type).expect("Invalid transaction type")`
6. The conversion fails for the invalid type value, `try_from` returns an error, and `.expect()` causes a **panic**
7. The panic crashes the indexer-grpc service thread, causing service unavailability

## Impact Explanation

This vulnerability qualifies as **High Severity** according to Aptos bug bounty criteria:
- **API Crashes**: The indexer-grpc data service is a critical API component that provides transaction data to dApps, wallets, and infrastructure. A panic causes immediate service termination
- **Availability Impact**: All clients depending on the indexer service lose access to historical and real-time transaction data
- **Service Disruption**: The service requires manual restart and will continue crashing if the malformed transaction remains in the cache window

While this doesn't affect consensus or validator operations, it directly impacts the Aptos ecosystem's data availability layer, which many applications depend on for functionality.

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability can be triggered through:
1. **Data Corruption**: Storage or network errors could corrupt the transaction type field
2. **Malicious Injection**: If an attacker can influence transaction data before it reaches the indexer (through cache poisoning or upstream data source manipulation)
3. **Implementation Bugs**: Bugs in transaction serialization/deserialization could produce invalid type values

The attack requires:
- A malformed transaction with invalid type field to exist in the system
- A client to subscribe with a `TransactionRootFilter` that checks transaction types (common use case)
- The malformed transaction to be within the cache window when filtering occurs

Given that transaction type filtering is a common indexer query pattern, and data corruption or serialization bugs can occur in complex distributed systems, this vulnerability has a realistic probability of being triggered.

## Recommendation

Replace the unsafe `.expect()` call with proper error handling that returns `false` (transaction doesn't match) instead of panicking:

```rust
fn matches(&self, item: &Transaction) -> bool {
    if !self
        .success
        .matches_opt(&item.info.as_ref().map(|i| i.success))
    {
        return false;
    }

    if let Some(txn_type) = &self.txn_type {
        // Safe conversion - return false instead of panicking on invalid types
        match TransactionType::try_from(item.r#type) {
            Ok(item_txn_type) => {
                if txn_type != &item_txn_type {
                    return false;
                }
            }
            Err(_) => {
                // Invalid transaction type - treat as non-matching
                // Could also log a warning here for monitoring
                return false;
            }
        }
    }

    true
}
```

**Alternative approach**: Add validation at the data ingestion layer to reject transactions with invalid type fields before they enter the cache, preventing the issue upstream.

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_protos::transaction::v1::{Transaction, TransactionInfo};
    
    #[test]
    #[should_panic(expected = "Invalid transaction type")]
    fn test_invalid_transaction_type_causes_panic() {
        // Create a TransactionRootFilter that checks for User transactions
        let filter = TransactionRootFilter {
            success: None,
            txn_type: Some(TransactionType::User),
        };
        
        // Create a malformed transaction with invalid type = 100
        // (valid values are: 0, 1, 2, 3, 4, 20, 21)
        let malformed_txn = Transaction {
            version: 12345,
            r#type: 100,  // Invalid value - not in TransactionType enum
            info: Some(TransactionInfo {
                success: true,
                ..Default::default()
            }),
            txn_data: None,
            ..Default::default()
        };
        
        // This will panic with "Invalid transaction type"
        filter.matches(&malformed_txn);
    }
    
    #[test]
    fn test_gaps_in_transaction_type_enum() {
        let filter = TransactionRootFilter {
            success: None,
            txn_type: Some(TransactionType::User),
        };
        
        // Test various invalid values in the gaps
        let invalid_values = vec![
            5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19,  // Gap between 4 and 20
            22, 23, 100, 255,  // Values beyond defined range
            -1,  // Negative value
        ];
        
        for invalid_type in invalid_values {
            let malformed_txn = Transaction {
                version: 12345,
                r#type: invalid_type,
                info: Some(TransactionInfo {
                    success: true,
                    ..Default::default()
                }),
                txn_data: None,
                ..Default::default()
            };
            
            // Each of these will panic
            let _ = std::panic::catch_unwind(|| {
                filter.matches(&malformed_txn);
            }).expect_err(&format!("Should panic on invalid type {}", invalid_type));
        }
    }
}
```

## Notes

This vulnerability is specific to the indexer-grpc service and does not affect consensus, validator operations, or on-chain state. However, it represents a critical availability issue for the Aptos data infrastructure layer that applications depend on. The fix is straightforward and should be applied wherever `TransactionType::try_from()` conversions occur to ensure defensive programming against malformed data.

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/transaction_root.rs (L67-73)
```rust
        if let Some(txn_type) = &self.txn_type {
            if txn_type
                != &TransactionType::try_from(item.r#type).expect("Invalid transaction type")
            {
                return false;
            }
        }
```

**File:** protos/rust/src/pb/aptos.transaction.v1.rs (L51-52)
```rust
    #[prost(enumeration="transaction::TransactionType", tag="6")]
    pub r#type: i32,
```

**File:** protos/rust/src/pb/aptos.transaction.v1.rs (L60-71)
```rust
    #[derive(Clone, Copy, Debug, PartialEq, Eq, Hash, PartialOrd, Ord, ::prost::Enumeration)]
    #[repr(i32)]
    pub enum TransactionType {
        Unspecified = 0,
        Genesis = 1,
        BlockMetadata = 2,
        StateCheckpoint = 3,
        User = 4,
        /// values 5-19 skipped for no reason
        Validator = 20,
        BlockEpilogue = 21,
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/in_memory_cache.rs (L88-93)
```rust
                if let Some(transaction) = data_manager.get_data(version).as_ref() {
                    // NOTE: We allow 1 more txn beyond the size limit here, for simplicity.
                    if filter.is_none() || filter.as_ref().unwrap().matches(transaction) {
                        total_bytes += transaction.encoded_len();
                        result.push(transaction.as_ref().clone());
                    }
```
