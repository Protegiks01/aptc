# Audit Report

## Title
Server-Side Request Forgery (SSRF) via Uncontrolled Redirect Following in Node-Checker HTTP Client

## Summary
The node-checker service accepts user-provided URLs and creates HTTP clients without disabling redirect following, allowing attackers to redirect requests to internal endpoints, cloud metadata services, or malicious servers, potentially exposing sensitive information and enabling lateral movement attacks.

## Finding Description

The node-checker's `get_api_client()` and `get_metrics_client()` functions create `reqwest::Client` instances without configuring redirect policies. [1](#0-0) 

By default, reqwest follows HTTP redirects automatically (up to 10 redirects). The node-checker accepts user-provided URLs through its `/check` endpoint without IP filtering or validation beyond basic URL format checks. [2](#0-1) 

When the node-checker makes requests to user-supplied endpoints, these clients are used to fetch metrics and API data. [3](#0-2)  The underlying reqwest client makes GET requests that will automatically follow redirects. [4](#0-3) 

**Attack Path:**
1. Attacker sends request to node-checker's `/check` endpoint with `node_url` pointing to attacker-controlled server
2. Node-checker creates HTTP client with cookie storage enabled but no redirect protection
3. Node-checker makes GET requests to attacker's server for `/metrics`, `/`, `/system_information` endpoints
4. Attacker's server responds with HTTP 301/302/307/308 redirects to:
   - Internal network addresses (192.168.x.x, 10.x.x.x, 127.0.0.1)
   - Cloud metadata endpoints (169.254.169.254 for AWS/GCP/Azure credentials)
   - Other internal services accessible from node-checker server
5. reqwest client automatically follows redirects, exposing internal resources
6. Cookies are included in redirected requests due to enabled cookie store [5](#0-4) 

## Impact Explanation

This vulnerability qualifies as **Medium severity** per Aptos bug bounty criteria, but affects infrastructure rather than blockchain consensus:

- **Information Disclosure**: Access to internal network services, cloud metadata (AWS credentials, instance data), and internal API responses
- **Cookie Leakage**: Session cookies could be exfiltrated to attacker-controlled domains via redirects
- **Network Reconnaissance**: Port scanning and service discovery within internal networks
- **Lateral Movement**: Potential springboard for further attacks on internal infrastructure

However, this does NOT directly impact:
- Blockchain consensus or validator operations
- Move VM execution or smart contract safety
- On-chain state or transaction validation
- Fund security or token economics

The node-checker is a diagnostic/monitoring tool in the ecosystem layer, not a critical consensus component.

## Likelihood Explanation

**Likelihood: Medium-High**

- Node-checker services are often publicly accessible for community node operators to check their nodes
- Exploitation requires only HTTP requests with malicious URLs
- No authentication or special privileges needed
- Attack is trivial to execute (single HTTP request)
- Detection may be difficult as legitimate health checks also make external requests

## Recommendation

Disable automatic redirect following in HTTP clients:

```rust
pub fn get_metrics_client(&self, timeout: Duration) -> Result<reqwest::Client> {
    match self.metrics_port {
        Some(_) => Ok(reqwest::ClientBuilder::new()
            .timeout(timeout)
            .cookie_provider(self.cookie_store.clone())
            .redirect(reqwest::redirect::Policy::none())  // Disable redirects
            .build()
            .unwrap()),
        None => Err(anyhow!(
            "Cannot build metrics client without a metrics port"
        )),
    }
}

pub fn get_api_client(&self, timeout: Duration) -> Result<AptosRestClient> {
    let client = reqwest::ClientBuilder::new()
        .timeout(timeout)
        .cookie_provider(self.cookie_store.clone())
        .redirect(reqwest::redirect::Policy::none())  // Disable redirects
        .build()
        .unwrap();

    Ok(AptosRestClient::from((client, self.get_api_url()?)))
}
```

Additionally, implement URL validation to block requests to:
- Private IP ranges (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16)
- Loopback addresses (127.0.0.0/8, ::1)
- Link-local addresses (169.254.0.0/16)
- Cloud metadata endpoints

## Proof of Concept

```rust
// File: ecosystem/node-checker/tests/ssrf_test.rs
use reqwest;
use warp::Filter;

#[tokio::test]
async fn test_ssrf_via_redirect() {
    // Start malicious server that redirects to internal endpoint
    let malicious = warp::get()
        .map(|| {
            warp::http::Response::builder()
                .status(301)
                .header("Location", "http://169.254.169.254/latest/meta-data/")
                .body("")
        });
    
    tokio::spawn(warp::serve(malicious).run(([127, 0, 0, 1], 8888)));
    
    // Create node-checker client (vulnerable version)
    let client = reqwest::ClientBuilder::new()
        .timeout(std::time::Duration::from_secs(5))
        .build()
        .unwrap();
    
    // Attempt request to malicious server
    let response = client.get("http://127.0.0.1:8888/metrics")
        .send()
        .await
        .unwrap();
    
    // Verify redirect was followed to metadata endpoint
    assert_eq!(response.url().host_str(), Some("169.254.169.254"));
    println!("SSRF successful - accessed cloud metadata endpoint via redirect");
}
```

**Notes:**

While this is a legitimate SSRF vulnerability, it affects the node-checker monitoring tool rather than core blockchain components (consensus, execution, storage, governance, staking). The security impact is limited to the infrastructure layer and does not directly compromise blockchain safety, liveness, or economic security.

### Citations

**File:** ecosystem/node-checker/src/configuration/node_address.rs (L96-100)
```rust
            Some(_) => Ok(reqwest::ClientBuilder::new()
                .timeout(timeout)
                .cookie_provider(self.cookie_store.clone())
                .build()
                .unwrap()),
```

**File:** ecosystem/node-checker/src/configuration/node_address.rs (L107-115)
```rust
    pub fn get_api_client(&self, timeout: Duration) -> Result<AptosRestClient> {
        let client = reqwest::ClientBuilder::new()
            .timeout(timeout)
            .cookie_provider(self.cookie_store.clone())
            .build()
            .unwrap();

        Ok(AptosRestClient::from((client, self.get_api_url()?)))
    }
```

**File:** ecosystem/node-checker/src/server/api.rs (L29-87)
```rust
    #[oai(path = "/check", method = "get")]
    async fn check(
        &self,
        /// The ID of the baseline node configuration to use for the evaluation, e.g. devnet_fullnode
        baseline_configuration_id: Query<String>,
        /// The URL of the node to check, e.g. http://44.238.19.217 or http://fullnode.mysite.com
        node_url: Query<Url>,
        /// If given, we will assume the metrics service is available at the given port.
        metrics_port: Query<Option<u16>>,
        /// If given, we will assume the API is available at the given port.
        api_port: Query<Option<u16>>,
        /// If given, we will assume that clients can communicate with your node via noise at the given port.
        noise_port: Query<Option<u16>>,
        /// A public key for the node, e.g. 0x44fd1324c66371b4788af0b901c9eb8088781acb29e6b8b9c791d5d9838fbe1f.
        /// This is only necessary for certain checkers, e.g. HandshakeChecker.
        public_key: Query<Option<String>>,
    ) -> poem::Result<Json<CheckSummary>> {
        // Ensure the public key, if given, is in a valid format.
        let public_key = match public_key.0 {
            Some(public_key) => match x25519::PublicKey::from_encoded_string(&public_key) {
                Ok(public_key) => Some(public_key),
                Err(e) => {
                    return Err(poem::Error::from((
                        StatusCode::BAD_REQUEST,
                        anyhow!("Invalid public key \"{}\": {:#}", public_key, e),
                    )))
                },
            },
            None => None,
        };

        let baseline_configuration = self
            .baseline_configurations
            .0
            .get(&baseline_configuration_id.0)
            .context(format!(
                "Baseline configuration {} does not exist",
                baseline_configuration_id.0
            ))
            .map_err(|e| poem::Error::from((StatusCode::BAD_REQUEST, e)))?;

        // Within a single NHC run we want to use the same client so that cookies
        // can be collected and used. This is important because the nodes we're
        // talking to might be a behind a LB that does cookie based sticky routing.
        // If we don't do this, we can get read inconsistency, e.g. where we read
        // that the node has transaction version X, but then we fail to retrieve the
        // transaction at the version because the LB routes us to a different node.
        // In this function, which comprises a single NHC run, we build a NodeAddress
        // for the target and use that throughout the request. Further functions
        // deeper down might clone these structs, but that is fine, because the
        // important part, the CookieStore (Jar) is in an Arc, so each time we clone
        // the struct we're just cloning the reference to the same jar.
        let target_node_address = NodeAddress::new(
            node_url.0,
            api_port.0,
            metrics_port.0,
            noise_port.0,
            public_key,
        );
```

**File:** ecosystem/node-checker/src/provider/metrics.rs (L59-66)
```rust
    pub async fn get_scrape(&self) -> Result<Scrape, ProviderError> {
        let response = self
            .client
            .get(self.metrics_url.clone())
            .send()
            .await
            .with_context(|| format!("Failed to get data from {}", self.metrics_url))
            .map_err(|e| ProviderError::RetryableEndpointError("/metrics", e))?;
```

**File:** crates/aptos-rest-client/src/lib.rs (L1683-1685)
```rust
    async fn get<T: DeserializeOwned>(&self, url: Url) -> AptosResult<Response<T>> {
        self.json(self.inner.get(url).send().await?).await
    }
```
