# Audit Report

## Title
Gas Parameter Override in Transaction Simulation Misleads Users About Transaction Feasibility

## Summary
The `simulate_transaction()` endpoint in `api/src/transactions.rs` allows gas parameter overrides that create a mismatch between validated simulation parameters and user's original transaction parameters. This causes simulations to succeed with valid overridden parameters while the user's actual transaction would be rejected by `check_gas()` validation, misleading users about transaction feasibility.

## Finding Description
The vulnerability exists in the transaction simulation flow where gas parameters can be overridden before validation: [1](#0-0) 

When `estimate_max_gas_amount` or `estimate_gas_unit_price` query parameters are set to true, the API calculates new gas parameters and creates a modified `SignedTransaction`: [2](#0-1) 

The problem occurs in this sequence:

1. User creates a transaction with potentially invalid gas parameters (e.g., `gas_unit_price` below `min_price_per_gas_unit`, or `max_gas_amount` exceeding `maximum_number_of_gas_units`)
2. User calls `/transactions/simulate` with estimation flags enabled
3. API overrides gas parameters to valid values calculated from account balance and system limits
4. Simulation runs with **overridden parameters** and passes `check_gas()` validation: [3](#0-2) 

5. The `check_gas()` function validates the **modified** parameters, not the original ones
6. Simulation succeeds and returns positive results
7. User believes their **original** transaction is valid
8. User submits original transaction with invalid parameters
9. Transaction is rejected by `check_gas()` validation during actual execution

The validation checks that would reject invalid parameters include: [4](#0-3) [5](#0-4) [6](#0-5) 

## Impact Explanation
This qualifies as **Medium severity** per Aptos bug bounty criteria for the following reasons:

1. **Misleading Transaction Feasibility**: Users receive false positives from simulation, believing their transactions will succeed when they will actually be rejected
2. **Potential Financial Loss**: Users may waste gas fees submitting transactions that fail validation
3. **dApp Integration Issues**: Applications relying on simulation for transaction previews will show incorrect results to end users
4. **Violation of Invariant #7**: "Transaction Validation: Prologue/epilogue checks must enforce all invariants" - The simulation validates different parameters than actual execution would

While this doesn't cause direct fund theft or consensus violations, it creates state inconsistencies in user expectations and can lead to limited financial losses through wasted gas fees.

## Likelihood Explanation
**High likelihood** of occurrence because:

1. **Public API Endpoint**: Any user can access `/transactions/simulate` without special permissions
2. **Common Use Case**: Gas estimation is a standard operation that many users and dApps perform regularly
3. **No Warning Mechanism**: The API does not warn users when parameters are overridden or indicate that simulation used different values than the original transaction
4. **Easy to Trigger**: Simply setting `estimate_max_gas_amount=true` or `estimate_gas_unit_price=true` triggers the override behavior

Specific exploitation scenarios:
- **Scenario 1**: User sets `gas_unit_price = 0` (or below minimum), simulates with `estimate_gas_unit_price=true`, gets success, then submits with `gas_unit_price = 0` which fails validation
- **Scenario 2**: User sets `max_gas_amount = 10000000` (above maximum), simulates with `estimate_max_gas_amount=true`, gets success with capped value, then submits with `max_gas_amount = 10000000` which fails validation
- **Scenario 3**: User sets `max_gas_amount = 10` (below intrinsic cost), simulates with override, gets success with calculated value, then submits with `max_gas_amount = 10` which fails validation

## Recommendation
Implement parameter validation **before** applying overrides, and add warnings to simulation responses:

1. **Pre-validation Check**: Before overriding parameters, validate the original transaction's gas parameters and include validation results in the simulation response
2. **Response Enhancement**: Add fields to the simulation response indicating:
   - Whether gas parameters were overridden
   - Original vs. overridden values
   - Validation warnings if original parameters would be rejected
3. **Documentation Update**: Clearly document that gas estimation overrides create a different transaction than what the user signed

Example fix for the simulation endpoint:

```rust
// After line 617 in api/src/transactions.rs, add:
// Validate original parameters first
let original_validation_result = validate_gas_parameters(
    &signed_transaction,
    &gas_params,
    &context
);

// ... existing override logic ...

// Include validation info in response
if original_validation_result.is_err() {
    // Add warning to simulation output
    warn!("Original transaction parameters would be rejected: {:?}", 
          original_validation_result);
}
```

The response should include structured information about parameter overrides so users understand they need to update their transaction parameters before submission.

## Proof of Concept

```bash
# Step 1: Create a transaction with invalid gas_unit_price (below minimum)
# Assume min_price_per_gas_unit = 100
curl -X POST https://fullnode.mainnet.aptoslabs.com/v1/transactions/simulate?estimate_gas_unit_price=true \
  -H "Content-Type: application/json" \
  -d '{
    "sender": "0x1",
    "sequence_number": "0",
    "max_gas_amount": "1000",
    "gas_unit_price": "50",  # INVALID: below minimum
    "expiration_timestamp_secs": "9999999999",
    "payload": {
      "type": "entry_function_payload",
      "function": "0x1::coin::transfer",
      "type_arguments": ["0x1::aptos_coin::AptosCoin"],
      "arguments": ["0x2", "100"]
    },
    "signature": {
      "type": "ed25519_signature",
      "public_key": "0x00...",
      "signature": "0x00..."  # Invalid signature for simulation
    }
  }'

# Result: Simulation SUCCEEDS because gas_unit_price is overridden to estimated value (e.g., 100)

# Step 2: Submit the same transaction with original invalid parameters
curl -X POST https://fullnode.mainnet.aptoslabs.com/v1/transactions \
  -H "Content-Type: application/json" \
  -d '{
    "sender": "0x1",
    "sequence_number": "0",
    "max_gas_amount": "1000",
    "gas_unit_price": "50",  # INVALID: below minimum
    ...
    "signature": {
      "type": "ed25519_signature",
      "public_key": "0x...",
      "signature": "0x..."  # Valid signature this time
    }
  }'

# Result: Transaction REJECTED with error:
# "Gas unit price below minimum bound" (StatusCode::GAS_UNIT_PRICE_BELOW_MIN_BOUND)
```

The user was misled by the simulation succeeding, but their actual transaction fails validation.

## Notes
This vulnerability specifically affects the transaction simulation API's gas parameter override logic. The core issue is that `override_gas_parameters()` creates a new transaction with modified parameters that get validated, while the user's original parameters remain unvalidated. This breaks the expectation that simulation accurately predicts actual execution behavior.

### Citations

**File:** api/src/transactions.rs (L584-730)
```rust
    async fn simulate_transaction(
        &self,
        accept_type: AcceptType,
        /// If set to true, the max gas value in the transaction will be ignored
        /// and the maximum possible gas will be used
        estimate_max_gas_amount: Query<Option<bool>>,
        /// If set to true, the gas unit price in the transaction will be ignored
        /// and the estimated value will be used
        estimate_gas_unit_price: Query<Option<bool>>,
        /// If set to true, the transaction will use a higher price than the original
        /// estimate.
        estimate_prioritized_gas_unit_price: Query<Option<bool>>,
        data: SubmitTransactionPost,
    ) -> SimulateTransactionResult<Vec<UserTransaction>> {
        data.verify()
            .context("Simulated transaction invalid")
            .map_err(|err| {
                SubmitTransactionError::bad_request_with_code_no_info(
                    err,
                    AptosErrorCode::InvalidInput,
                )
            })?;
        fail_point_poem("endpoint_simulate_transaction")?;
        if !self.context.node_config.api.transaction_simulation_enabled {
            return Err(api_disabled("Simulate transaction"));
        }
        self.context
            .check_api_output_enabled("Simulate transaction", &accept_type)?;

        let api = self.clone();
        let context = self.context.clone();
        api_spawn_blocking(move || {
            let ledger_info = context.get_latest_ledger_info()?;
            let mut signed_transaction = api.get_signed_transaction(&ledger_info, data)?;

            // Confirm the API simulation filter allows the transaction
            let api_filter = &context.node_config.transaction_filters.api_filter;
            if api_filter.is_enabled()
                && !api_filter
                    .transaction_filter()
                    .allows_transaction(&signed_transaction)
            {
                return Err(SubmitTransactionError::forbidden_with_code(
                    "Transaction not allowed by simulation filter",
                    AptosErrorCode::InvalidInput,
                    &ledger_info,
                ));
            }

            let estimated_gas_unit_price = match (
                estimate_gas_unit_price.0.unwrap_or_default(),
                estimate_prioritized_gas_unit_price.0.unwrap_or_default(),
            ) {
                (_, true) => {
                    let gas_estimation = context.estimate_gas_price(&ledger_info)?;
                    // The prioritized gas estimate should always be set, but if it's not use the gas estimate
                    Some(
                        gas_estimation
                            .prioritized_gas_estimate
                            .unwrap_or(gas_estimation.gas_estimate),
                    )
                },
                (true, false) => Some(context.estimate_gas_price(&ledger_info)?.gas_estimate),
                (false, false) => None,
            };

            // If estimate max gas amount is provided, we will just make it the maximum value
            let estimated_max_gas_amount = if estimate_max_gas_amount.0.unwrap_or_default() {
                // Retrieve max possible gas units
                let (_, gas_params) = context.get_gas_schedule(&ledger_info)?;
                let min_number_of_gas_units =
                    u64::from(gas_params.vm.txn.min_transaction_gas_units)
                        / u64::from(gas_params.vm.txn.gas_unit_scaling_factor);
                let max_number_of_gas_units =
                    u64::from(gas_params.vm.txn.maximum_number_of_gas_units);

                // Retrieve account balance to determine max gas available, right now this is using
                // a view function, but we may want to re-evaluate this based on performance
                let (_, _, state_view) = context
                    .state_view::<BasicErrorWith404>(Option::None)
                    .map_err(|err| {
                        SubmitTransactionError::bad_request_with_code_no_info(
                            err,
                            AptosErrorCode::InvalidInput,
                        )
                    })?;
                let output = AptosVM::execute_view_function(
                    &state_view,
                    ModuleId::new(AccountAddress::ONE, ident_str!("coin").into()),
                    ident_str!("balance").into(),
                    vec![AptosCoinType::type_tag()],
                    vec![signed_transaction.sender().to_vec()],
                    context.node_config.api.max_gas_view_function,
                );
                let values = output.values.map_err(|status| {
                    let (err_string, vm_error_code) =
                        convert_view_function_error(&status, &state_view, &context);
                    SubmitTransactionError::bad_request_with_optional_vm_status_and_ledger_info(
                        anyhow::anyhow!(err_string),
                        AptosErrorCode::InvalidInput,
                        vm_error_code,
                        Some(&ledger_info),
                    )
                })?;
                let balance: u64 = bcs::from_bytes(&values[0]).map_err(|err| {
                    SubmitTransactionError::bad_request_with_code_no_info(
                        err,
                        AptosErrorCode::InvalidInput,
                    )
                })?;

                let gas_unit_price =
                    estimated_gas_unit_price.unwrap_or_else(|| signed_transaction.gas_unit_price());

                // With 0 gas price, we set it to max gas units, since we can't divide by 0
                let max_account_gas_units = if gas_unit_price == 0 {
                    balance
                } else {
                    balance / gas_unit_price
                };

                // To give better error messaging, we should not go below the minimum number of gas units
                let max_account_gas_units =
                    std::cmp::max(min_number_of_gas_units, max_account_gas_units);

                // Minimum of the max account and the max total needs to be used for estimation
                Some(std::cmp::min(
                    max_account_gas_units,
                    max_number_of_gas_units,
                ))
            } else {
                None
            };

            // If there is an estimation of either, replace the values
            if estimated_max_gas_amount.is_some() || estimated_gas_unit_price.is_some() {
                signed_transaction = override_gas_parameters(
                    &signed_transaction,
                    estimated_max_gas_amount,
                    estimated_gas_unit_price,
                );
            }

            api.simulate(&accept_type, ledger_info, signed_transaction)
        })
        .await
    }
```

**File:** api/src/transactions.rs (L1904-1923)
```rust
fn override_gas_parameters(
    signed_txn: &SignedTransaction,
    max_gas_amount: Option<u64>,
    gas_unit_price: Option<u64>,
) -> SignedTransaction {
    let payload = signed_txn.payload();

    let raw_txn = RawTransaction::new(
        signed_txn.sender(),
        signed_txn.sequence_number(),
        payload.clone(),
        max_gas_amount.unwrap_or_else(|| signed_txn.max_gas_amount()),
        gas_unit_price.unwrap_or_else(|| signed_txn.gas_unit_price()),
        signed_txn.expiration_timestamp_secs(),
        signed_txn.chain_id(),
    );

    // TODO: Check that signature is null, this would just be helpful for downstream use
    SignedTransaction::new_signed_transaction(raw_txn, signed_txn.authenticator())
}
```

**File:** aptos-move/aptos-vm/src/gas.rs (L70-250)
```rust
pub(crate) fn check_gas(
    gas_params: &AptosGasParameters,
    gas_feature_version: u64,
    resolver: &impl AptosMoveResolver,
    module_storage: &impl ModuleStorage,
    txn_metadata: &TransactionMetadata,
    features: &Features,
    is_approved_gov_script: bool,
    log_context: &AdapterLogSchema,
) -> Result<(), VMStatus> {
    let txn_gas_params = &gas_params.vm.txn;
    let raw_bytes_len = txn_metadata.transaction_size;

    if is_approved_gov_script {
        let max_txn_size_gov = if gas_feature_version >= RELEASE_V1_13 {
            gas_params.vm.txn.max_transaction_size_in_bytes_gov
        } else {
            MAXIMUM_APPROVED_TRANSACTION_SIZE_LEGACY.into()
        };

        if txn_metadata.transaction_size > max_txn_size_gov
            // Ensure that it is only the approved payload that exceeds the
            // maximum. The (unknown) user input should be restricted to the original
            // maximum transaction size.
            || txn_metadata.transaction_size
                > txn_metadata.script_size + txn_gas_params.max_transaction_size_in_bytes
        {
            speculative_warn!(
                log_context,
                format!(
                    "[VM] Governance transaction size too big {} payload size {}",
                    txn_metadata.transaction_size, txn_metadata.script_size,
                ),
            );
            return Err(VMStatus::error(
                StatusCode::EXCEEDED_MAX_TRANSACTION_SIZE,
                None,
            ));
        }
    } else if txn_metadata.transaction_size > txn_gas_params.max_transaction_size_in_bytes {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Transaction size too big {} (max {})",
                txn_metadata.transaction_size, txn_gas_params.max_transaction_size_in_bytes
            ),
        );
        return Err(VMStatus::error(
            StatusCode::EXCEEDED_MAX_TRANSACTION_SIZE,
            None,
        ));
    }

    // The submitted max gas units that the transaction can consume is greater than the
    // maximum number of gas units bound that we have set for any
    // transaction.
    if txn_metadata.max_gas_amount() > txn_gas_params.maximum_number_of_gas_units {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; max {}, submitted {}",
                txn_gas_params.maximum_number_of_gas_units,
                txn_metadata.max_gas_amount()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::MAX_GAS_UNITS_EXCEEDS_MAX_GAS_UNITS_BOUND,
            None,
        ));
    }

    // The submitted transactions max gas units needs to be at least enough to cover the
    // intrinsic cost of the transaction as calculated against the size of the
    // underlying `RawTransaction`.
    let keyless = if txn_metadata.is_keyless() {
        KEYLESS_BASE_COST.evaluate(gas_feature_version, &gas_params.vm)
    } else {
        InternalGas::zero()
    };
    let slh_dsa_sha2_128s = if txn_metadata.is_slh_dsa_sha2_128s() {
        SLH_DSA_SHA2_128S_BASE_COST.evaluate(gas_feature_version, &gas_params.vm)
    } else {
        InternalGas::zero()
    };
    let intrinsic_gas = txn_gas_params
        .calculate_intrinsic_gas(raw_bytes_len)
        .evaluate(gas_feature_version, &gas_params.vm);
    let total_rounded: Gas =
        (intrinsic_gas + keyless + slh_dsa_sha2_128s).to_unit_round_up_with_params(txn_gas_params);
    if txn_metadata.max_gas_amount() < total_rounded {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; min {}, submitted {}",
                total_rounded,
                txn_metadata.max_gas_amount()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::MAX_GAS_UNITS_BELOW_MIN_TRANSACTION_GAS_UNITS,
            None,
        ));
    }

    // The submitted gas price is less than the minimum gas unit price set by the VM.
    // NB: MIN_PRICE_PER_GAS_UNIT may equal zero, but need not in the future. Hence why
    // we turn off the clippy warning.
    #[allow(clippy::absurd_extreme_comparisons)]
    let below_min_bound = txn_metadata.gas_unit_price() < txn_gas_params.min_price_per_gas_unit;
    if below_min_bound {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; min {}, submitted {}",
                txn_gas_params.min_price_per_gas_unit,
                txn_metadata.gas_unit_price()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::GAS_UNIT_PRICE_BELOW_MIN_BOUND,
            None,
        ));
    }

    // The submitted gas price is greater than the maximum gas unit price set by the VM.
    if txn_metadata.gas_unit_price() > txn_gas_params.max_price_per_gas_unit {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; max {}, submitted {}",
                txn_gas_params.max_price_per_gas_unit,
                txn_metadata.gas_unit_price()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::GAS_UNIT_PRICE_ABOVE_MAX_BOUND,
            None,
        ));
    }

    // If this is for a potentially new account, ensure there's enough gas to cover storage, execution, and IO costs.
    // TODO: This isn't the cleaning code, thus we localize it just here and will remove it
    // once accountv2 is available and we no longer need to create accounts.
    let gas_unit_price: u64 = txn_metadata.gas_unit_price().into();
    if crate::aptos_vm::should_create_account_resource(
        txn_metadata,
        features,
        resolver,
        module_storage,
    )? && (gas_unit_price != 0 || !features.is_default_account_resource_enabled())
    {
        let max_gas_amount: u64 = txn_metadata.max_gas_amount().into();
        let pricing = DiskSpacePricing::new(gas_feature_version, features);
        let storage_fee_per_account_create: u64 = pricing
            .hack_estimated_fee_for_account_creation(txn_gas_params)
            .into();

        let expected = gas_unit_price * 10
            + if features.is_new_account_default_to_fa_store() {
                1
            } else {
                2
            } * storage_fee_per_account_create;
        let actual = gas_unit_price * max_gas_amount;
        if actual < expected {
            speculative_warn!(
                log_context,
                format!(
                    "[VM] Insufficient gas for account creation; min {}, submitted {}",
                    expected, actual,
                ),
            );
            return Err(VMStatus::error(
                StatusCode::MAX_GAS_UNITS_BELOW_MIN_TRANSACTION_GAS_UNITS,
                None,
            ));
        }
    }

    Ok(())
}
```
