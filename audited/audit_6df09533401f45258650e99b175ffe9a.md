# Audit Report

## Title
Network-Wide Consensus Halt via Zero Window Size in On-Chain Configuration

## Summary
A malicious or buggy governance proposal can set the execution pool `window_size` parameter to `Some(0)` in the `OnChainConsensusConfig`, causing all consensus nodes to panic during normal block processing. This results in an immediate, network-wide consensus halt requiring a hard fork to recover.

## Finding Description

The vulnerability exists in the `calculate_window_start_round()` utility function which contains an assertion that panics when `window_size` is zero: [1](#0-0) 

This function is called in three critical consensus paths:

1. **Block Insertion Path**: Every time a block is inserted into the BlockStore during normal consensus operation: [2](#0-1) 

The call flows through: [3](#0-2) 

2. **Fast Forward Sync Path**: During state synchronization between validators: [4](#0-3) 

3. **Recovery Path**: During node startup and recovery: [5](#0-4) 

The `window_size` parameter originates from the `OnChainConsensusConfig` which is updatable through governance: [6](#0-5) 

The configuration is passed directly to BlockStore without validation: [7](#0-6) 

**Critical Gap**: There is NO validation preventing `window_size` from being set to `Some(0)`:

- The Move governance code only validates that the config bytes are non-empty, not their content: [8](#0-7) 

- The Rust deserialization performs no value validation: [9](#0-8) 

- The `window_size()` accessor simply returns the value without validation: [10](#0-9) 

**Attack Scenario**:
1. Malicious governance proposal sets `OnChainConsensusConfig::V5` with `window_size: Some(0)`
2. Proposal passes through governance voting
3. Configuration is applied at next epoch boundary via `on_new_epoch()`
4. All validators load the new configuration simultaneously
5. When any validator attempts to insert the first block after epoch transition, `BlockStore::insert_block()` is called
6. The call chain reaches `calculate_window_start_round(round, 0)` which panics
7. All validators crash simultaneously
8. Network consensus halts completely

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under Aptos bug bounty criteria because it causes:

1. **Non-recoverable network partition requiring hardfork**: Once the malicious configuration is activated at an epoch boundary, all validators will panic upon the first block insertion. Recovery requires either:
   - Emergency hardfork to revert the configuration
   - Manual coordination to roll back all validator nodes before the bad epoch
   - Both scenarios require extraordinary intervention by the Aptos Foundation

2. **Total loss of liveness/network availability**: The entire Aptos network stops producing blocks. No transactions can be processed, no blocks can be committed, and the blockchain becomes completely inoperable.

3. **Deterministic, simultaneous failure**: Unlike partial network failures, this affects ALL validators at the same moment (first block insertion after epoch change), making recovery coordination extremely difficult.

The vulnerability breaks the **Consensus Safety** invariant (all validators must maintain liveness) and the **Resource Limits** invariant (operations should gracefully handle edge cases, not panic).

## Likelihood Explanation

**Likelihood: Medium to High**

The attack requires a malicious or buggy governance proposal to pass, which has these factors:

**Increasing likelihood**:
- No validation exists at any layer (Move, Rust deserialization, or runtime)
- Default enabled window size is `Some(1)`, making `Some(0)` appear like a valid "optimization" [11](#0-10) 

- Governance proposals are BCS-encoded binary data, making accidental typos possible
- The panic is immediate and deterministic once the configuration activates

**Decreasing likelihood**:
- Requires governance proposal to pass (social consensus barrier)
- Aptos governance typically has review processes for consensus-critical changes
- Would likely be caught in testnet deployments before mainnet

However, the question explicitly considers "Byzantine validators or malicious config updates", indicating this threat model is in scope. A compromised governance process, insider threat, or sophisticated social engineering attack could exploit this.

## Recommendation

Add validation at multiple defense layers:

**Layer 1 - Rust Validation** (Primary defense):
Add validation in the `OnChainConsensusConfig` implementation:

```rust
// In types/src/on_chain_config/consensus_config.rs
impl OnChainConsensusConfig {
    pub fn window_size(&self) -> Option<u64> {
        let window_size = match self {
            OnChainConsensusConfig::V1(_)
            | OnChainConsensusConfig::V2(_)
            | OnChainConsensusConfig::V3 { .. } => None,
            OnChainConsensusConfig::V4 { window_size, .. }
            | OnChainConsensusConfig::V5 { window_size, .. } => *window_size,
        };
        
        // Validate: if window_size is Some(x), x must be > 0
        if let Some(0) = window_size {
            warn!("Invalid window_size of 0 detected, treating as None");
            None
        } else {
            window_size
        }
    }
}
```

**Layer 2 - BlockStore Validation** (Defense in depth):
Add assertion when initializing BlockStore:

```rust
// In consensus/src/block_storage/block_store.rs
pub fn new(..., window_size: Option<u64>, ...) -> Self {
    if let Some(size) = window_size {
        assert!(size > 0, "window_size must be greater than 0");
    }
    // ... rest of initialization
}
```

**Layer 3 - Move Native Function** (Optional):
Add a native Move function to validate the config before it's committed:

```move
// In aptos-move/framework/aptos-framework/sources/configs/consensus_config.move
native fun validate_consensus_config_internal(config_bytes: vector<u8>): bool;

public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
    system_addresses::assert_aptos_framework(account);
    assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
    assert!(validate_consensus_config_internal(config), error::invalid_argument(EINVALID_CONFIG));
    std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
}
```

## Proof of Concept

```rust
// Rust reproduction demonstrating the panic

#[test]
#[should_panic(expected = "assertion failed: window_size > 0")]
fn test_window_size_zero_causes_panic() {
    use aptos_types::on_chain_config::{
        ConsensusAlgorithmConfig, OnChainConsensusConfig, ValidatorTxnConfig,
    };
    
    // Create a malicious config with window_size = Some(0)
    let malicious_config = OnChainConsensusConfig::V5 {
        alg: ConsensusAlgorithmConfig::default_for_genesis(),
        vtxn: ValidatorTxnConfig::default_for_genesis(),
        window_size: Some(0),  // Malicious value
        rand_check_enabled: true,
    };
    
    // Extract window_size
    let window_size = malicious_config.window_size();
    assert_eq!(window_size, Some(0));
    
    // This will panic when called in block insertion
    let current_round = 100;
    if let Some(size) = window_size {
        let _ = calculate_window_start_round(current_round, size);
        // PANIC occurs here: thread panics with "assertion failed: window_size > 0"
    }
}
```

Move integration test to demonstrate governance attack:

```move
#[test(aptos_framework = @aptos_framework)]
#[expected_failure(abort_code = 0x10001, location = aptos_framework::consensus_config)]
fun test_malicious_consensus_config_with_zero_window(aptos_framework: &signer) {
    use aptos_framework::consensus_config;
    
    // Serialize a config with window_size = Some(0)
    // This would be created off-chain and submitted via governance
    let malicious_config_bytes = create_config_with_zero_window_size();
    
    // Attempt to set the malicious config
    consensus_config::set_for_next_epoch(aptos_framework, malicious_config_bytes);
    
    // If validation is added per recommendation, this should abort
    // Without validation, this would succeed and cause network halt at next epoch
}
```

**Notes**

The vulnerability is exploitable through the governance mechanism, which while requiring social consensus, is explicitly mentioned in the security question's threat model ("Byzantine validators or malicious config updates"). The lack of validation at any layer makes this a defense-in-depth failure. The immediate, network-wide impact and deterministic nature of the failure makes this a critical severity issue requiring urgent remediation.

### Citations

**File:** consensus/src/util/mod.rs (L26-28)
```rust
pub fn calculate_window_start_round(current_round: Round, window_size: u64) -> Round {
    assert!(window_size > 0);
    (current_round + 1).saturating_sub(window_size)
```

**File:** consensus/src/block_storage/block_store.rs (L421-424)
```rust
        let block_window = self
            .inner
            .read()
            .get_ordered_block_window(&block, self.window_size)?;
```

**File:** consensus/src/block_storage/block_tree.rs (L277-282)
```rust
        // window_size is None only if execution pool is turned off
        let Some(window_size) = window_size else {
            return Ok(OrderedBlockWindow::empty());
        };
        let round = block.round();
        let window_start_round = calculate_window_start_round(round, window_size);
```

**File:** consensus/src/block_storage/sync_manager.rs (L349-353)
```rust
            Some(window_size) => {
                let target_round = calculate_window_start_round(
                    highest_commit_cert.ledger_info().ledger_info().round(),
                    window_size,
                )
```

**File:** consensus/src/persistent_liveness_storage.rs (L165-165)
```rust
        let window_start_round = calculate_window_start_round(commit_block.round(), window_size);
```

**File:** types/src/on_chain_config/consensus_config.rs (L12-13)
```rust
pub const DEFAULT_WINDOW_SIZE: Option<u64> = None;
pub const DEFAULT_ENABLED_WINDOW_SIZE: Option<u64> = Some(1);
```

**File:** types/src/on_chain_config/consensus_config.rs (L199-204)
```rust
    V4 {
        alg: ConsensusAlgorithmConfig,
        vtxn: ValidatorTxnConfig,
        // Execution pool block window
        window_size: Option<u64>,
    },
```

**File:** types/src/on_chain_config/consensus_config.rs (L404-412)
```rust
    pub fn window_size(&self) -> Option<u64> {
        match self {
            OnChainConsensusConfig::V1(_)
            | OnChainConsensusConfig::V2(_)
            | OnChainConsensusConfig::V3 { .. } => None,
            OnChainConsensusConfig::V4 { window_size, .. }
            | OnChainConsensusConfig::V5 { window_size, .. } => *window_size,
        }
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L464-468)
```rust
    fn deserialize_into_config(bytes: &[u8]) -> Result<Self> {
        let raw_bytes: Vec<u8> = bcs::from_bytes(bytes)?;
        bcs::from_bytes(&raw_bytes)
            .map_err(|e| format_err!("[on-chain config] Failed to deserialize into config: {}", e))
    }
```

**File:** consensus/src/epoch_manager.rs (L895-896)
```rust
            onchain_consensus_config.order_vote_enabled(),
            onchain_consensus_config.window_size(),
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-55)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
```
