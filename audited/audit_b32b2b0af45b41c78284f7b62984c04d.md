# Audit Report

## Title
Missing Equivocation Detection in Order Vote Processing Enables Consensus Safety Violations

## Summary
The consensus fuzzer only tests proposal processing and completely misses vote processing vulnerabilities. Specifically, the `PendingOrderVotes` structure lacks equivocation detection, allowing malicious validators to send multiple conflicting order votes for the same block without detection, potentially causing consensus divergence in the optimistic execution path.

## Finding Description

The fuzzer in `consensus/src/round_manager_fuzzing.rs` only implements proposal fuzzing through `fuzz_proposal()` and `generate_corpus_proposal()`, completely missing vote processing code paths. [1](#0-0) 

This gap exposes a critical vulnerability: `PendingOrderVotes` does not implement equivocation detection for order votes, unlike regular votes which track each author's vote via the `author_to_vote` HashMap.

**Regular votes have equivocation detection:** [2](#0-1) 

The `author_to_vote` HashMap enables detection of conflicting votes: [3](#0-2) 

**Order votes lack this protection:** [4](#0-3) 

The `insert_order_vote` function only tracks votes by ledger info digest, not by author: [5](#0-4) 

**Attack Path:**
1. Malicious validator creates QC for block B at round R
2. Validator broadcasts OrderVoteMsg₁ voting for state S₁ based on B
3. Same validator broadcasts OrderVoteMsg₂ voting for state S₂ based on B
4. Different nodes receive different subsets of equivocating votes
5. When combined with honest votes, different order certificates may form
6. Optimistic execution commits different states on different nodes

Additionally, `process_order_vote_msg()` lacks round synchronization that regular vote processing enforces via `ensure_round_and_sync_up()`: [6](#0-5) 

Compare with regular vote processing which enforces synchronization: [7](#0-6) 

## Impact Explanation

**Critical Severity** - This breaks the fundamental consensus safety invariant: "AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine validators."

Order votes are used in the optimistic execution path to form order certificates that trigger early state commitment. Without equivocation detection:
- A single Byzantine validator can cause different nodes to form conflicting order certificates
- Nodes executing optimistically may commit to different state roots
- This creates a consensus fork requiring manual intervention or hardfork
- Violates deterministic execution guarantee

The vulnerability affects **all validators** running with order votes enabled (default configuration).

## Likelihood Explanation

**High Likelihood:**
- Order votes are enabled by default via `OnChainConsensusConfig`
- Any validator (even with minimal stake) can send equivocating order votes
- No special privileges required beyond validator status
- Attack is undetectable at protocol level due to missing validation
- Fuzzer cannot catch this as it only tests proposals, not vote processing

The absence of fuzzing for vote messages means this entire attack surface is untested despite being a critical consensus path.

## Recommendation

**Fix 1: Add equivocation detection to PendingOrderVotes**

Add an `author_to_vote` HashMap to track order votes per author:

```rust
pub struct PendingOrderVotes {
    li_digest_to_votes: HashMap<HashValue, (QuorumCert, OrderVoteStatus)>,
    author_to_vote: HashMap<Author, (OrderVote, HashValue)>, // Add this field
}
```

In `insert_order_vote`, check for equivocation before accepting the vote:

```rust
pub fn insert_order_vote(&mut self, order_vote: &OrderVote, ...) -> OrderVoteReceptionResult {
    let li_digest = order_vote.ledger_info().hash();
    
    // Check for equivocation
    if let Some((prev_vote, prev_digest)) = self.author_to_vote.get(&order_vote.author()) {
        if &li_digest != prev_digest {
            error!(SecurityEvent::ConsensusEquivocatingOrderVote, 
                   remote_peer = order_vote.author());
            return OrderVoteReceptionResult::EquivocateVote;
        }
    }
    
    self.author_to_vote.insert(order_vote.author(), (order_vote.clone(), li_digest));
    // ... rest of logic
}
```

**Fix 2: Add vote fuzzing to round_manager_fuzzing.rs**

Implement `fuzz_vote_msg()`, `fuzz_order_vote_msg()`, and `fuzz_round_timeout_msg()` functions to test all vote processing paths.

**Fix 3: Add round synchronization to order vote processing**

Modify `process_order_vote_msg` to validate round state similar to regular votes, though this requires adding SyncInfo to OrderVoteMsg.

## Proof of Concept

```rust
#[test]
fn test_order_vote_equivocation_not_detected() {
    use aptos_consensus_types::{order_vote::OrderVote, quorum_cert::QuorumCert};
    use aptos_types::validator_verifier::random_validator_verifier;
    use crate::pending_order_votes::{PendingOrderVotes, OrderVoteReceptionResult};
    
    let (signers, verifier) = random_validator_verifier(4, Some(2), false);
    let mut pending = PendingOrderVotes::new();
    let qc = QuorumCert::dummy();
    
    // Validator 0 votes for ledger_info_1
    let li1 = LedgerInfo::new(BlockInfo::random(1), HashValue::random());
    let vote1 = OrderVote::new_with_signature(
        signers[0].author(),
        li1.clone(),
        signers[0].sign(&li1).unwrap(),
    );
    
    pending.insert_order_vote(&vote1, &verifier, Some(qc.clone()));
    
    // Same validator 0 equivocates by voting for ledger_info_2
    let li2 = LedgerInfo::new(BlockInfo::random(1), HashValue::random());
    let vote2 = OrderVote::new_with_signature(
        signers[0].author(),
        li2.clone(),
        signers[0].sign(&li2).unwrap(),
    );
    
    // BUG: This should return EquivocateVote but returns VoteAdded instead
    let result = pending.insert_order_vote(&vote2, &verifier, Some(qc.clone()));
    match result {
        OrderVoteReceptionResult::VoteAdded(_) => {
            println!("VULNERABILITY: Equivocation not detected!");
        },
        OrderVoteReceptionResult::EquivocateVote => {
            panic!("Expected equivocation to NOT be detected, but it was");
        },
        _ => panic!("Unexpected result"),
    }
}
```

## Notes

This vulnerability directly answers the security question: **Yes, the fuzzer only tests proposals and completely misses vote processing vulnerabilities.** The missing equivocation detection in order votes is a concrete example of a consensus safety violation that would not be caught by the existing fuzzer, as it only exercises `fuzz_proposal()` and never tests `VoteMsg`, `OrderVoteMsg`, or `RoundTimeoutMsg` processing paths.

The test comment at line 233 in `pending_order_votes.rs` appears misleading but actually tests a different author voting for a different result, not the same author equivocating. [8](#0-7)

### Citations

**File:** consensus/src/round_manager_fuzzing.rs (L230-261)
```rust
// This functions fuzzes a Proposal protobuffer (not a ConsensusMsg)
pub fn fuzz_proposal(data: &[u8]) {
    // create node
    let mut round_manager = create_node_for_fuzzing();

    let proposal: ProposalMsg = match serde_json::from_slice(data) {
        Ok(xx) => xx,
        Err(_) => {
            if cfg!(test) {
                panic!();
            }
            return;
        },
    };

    let proposal = match proposal.verify_well_formed() {
        Ok(_) => proposal,
        Err(e) => {
            println!("{:?}", e);
            if cfg!(test) {
                panic!();
            }
            return;
        },
    };

    block_on(async move {
        // TODO: make sure this obtains a vote when testing
        // TODO: make sure that if this obtains a vote, it's for round 1, etc.
        let _ = round_manager.process_proposal_msg(proposal).await;
    });
}
```

**File:** consensus/src/pending_votes.rs (L164-176)
```rust
/// A PendingVotes structure keep track of votes
pub struct PendingVotes {
    /// Maps LedgerInfo digest to associated signatures.
    /// This might keep multiple LedgerInfos for the current round: either due to different proposals (byzantine behavior)
    /// or due to different NIL proposals (clients can have a different view of what block to extend).
    li_digest_to_votes: HashMap<HashValue /* LedgerInfo digest */, (usize, VoteStatus)>,
    /// Tracks all the signatures of the 2-chain timeout for the given round.
    maybe_2chain_timeout_votes: Option<TwoChainTimeoutVotes>,
    /// Map of Author to (vote, li_digest). This is useful to discard multiple votes.
    author_to_vote: HashMap<Author, (Vote, HashValue)>,
    /// Whether we have echoed timeout for this round.
    echo_timeout: bool,
}
```

**File:** consensus/src/pending_votes.rs (L287-309)
```rust
        if let Some((previously_seen_vote, previous_li_digest)) =
            self.author_to_vote.get(&vote.author())
        {
            // is it the same vote?
            if &li_digest == previous_li_digest {
                // we've already seen an equivalent vote before
                let new_timeout_vote = vote.is_timeout() && !previously_seen_vote.is_timeout();
                if !new_timeout_vote {
                    // it's not a new timeout vote
                    return VoteReceptionResult::DuplicateVote;
                }
            } else {
                // we have seen a different vote for the same round
                error!(
                    SecurityEvent::ConsensusEquivocatingVote,
                    remote_peer = vote.author(),
                    vote = vote,
                    previous_vote = previously_seen_vote
                );

                return VoteReceptionResult::EquivocateVote;
            }
        }
```

**File:** consensus/src/pending_order_votes.rs (L38-53)
```rust
/// A PendingVotes structure keep track of order votes for the last few rounds
pub struct PendingOrderVotes {
    /// Maps LedgerInfo digest to associated signatures.
    /// Order vote status stores caches the information on whether the votes are enough to form a QC.
    /// We also store the QC that the order votes certify.
    li_digest_to_votes:
        HashMap<HashValue /* LedgerInfo digest */, (QuorumCert, OrderVoteStatus)>,
}

impl PendingOrderVotes {
    /// Creates an empty PendingOrderVotes structure
    pub fn new() -> Self {
        Self {
            li_digest_to_votes: HashMap::new(),
        }
    }
```

**File:** consensus/src/pending_order_votes.rs (L61-82)
```rust
    pub fn insert_order_vote(
        &mut self,
        order_vote: &OrderVote,
        validator_verifier: &ValidatorVerifier,
        verified_quorum_cert: Option<QuorumCert>,
    ) -> OrderVoteReceptionResult {
        // derive data from order vote
        let li_digest = order_vote.ledger_info().hash();

        // obtain the ledger info with signatures associated to the order vote's ledger info
        let (quorum_cert, status) = self.li_digest_to_votes.entry(li_digest).or_insert_with(|| {
            // if the ledger info with signatures doesn't exist yet, create it
            (
                verified_quorum_cert.expect(
                    "Quorum Cert is expected when creating a new entry in pending order votes",
                ),
                OrderVoteStatus::NotEnoughVotes(SignatureAggregator::new(
                    order_vote.ledger_info().clone(),
                )),
            )
        });

```

**File:** consensus/src/pending_order_votes.rs (L233-247)
```rust
        // same author voting for a different result -> EquivocateVote
        let li2 = random_ledger_info();
        let order_vote_2_author_1 = OrderVote::new_with_signature(
            signers[1].author(),
            li2.clone(),
            signers[1].sign(&li2).expect("Unable to sign ledger info"),
        );
        assert_eq!(
            pending_order_votes.insert_order_vote(
                &order_vote_2_author_1,
                &verifier,
                Some(qc.clone())
            ),
            OrderVoteReceptionResult::VoteAdded(1)
        );
```

**File:** consensus/src/round_manager.rs (L1546-1573)
```rust
    async fn process_order_vote_msg(&mut self, order_vote_msg: OrderVoteMsg) -> anyhow::Result<()> {
        if self.onchain_config.order_vote_enabled() {
            fail_point!("consensus::process_order_vote_msg", |_| {
                Err(anyhow::anyhow!("Injected error in process_order_vote_msg"))
            });

            let order_vote = order_vote_msg.order_vote();
            trace!(
                self.new_log(LogEvent::ReceiveOrderVote)
                    .remote_peer(order_vote.author()),
                epoch = order_vote.ledger_info().epoch(),
                round = order_vote.ledger_info().round(),
                id = order_vote.ledger_info().consensus_block_id(),
            );

            if self
                .pending_order_votes
                .has_enough_order_votes(order_vote_msg.order_vote().ledger_info())
            {
                return Ok(());
            }

            let highest_ordered_round = self.block_store.sync_info().highest_ordered_round();
            let order_vote_round = order_vote_msg.order_vote().ledger_info().round();
            let li_digest = order_vote_msg.order_vote().ledger_info().hash();
            if order_vote_round > highest_ordered_round
                && order_vote_round < highest_ordered_round + 100
            {
```

**File:** consensus/src/round_manager.rs (L1697-1716)
```rust
    pub async fn process_vote_msg(&mut self, vote_msg: VoteMsg) -> anyhow::Result<()> {
        fail_point!("consensus::process_vote_msg", |_| {
            Err(anyhow::anyhow!("Injected error in process_vote_msg"))
        });
        // Check whether this validator is a valid recipient of the vote.
        if self
            .ensure_round_and_sync_up(
                vote_msg.vote().vote_data().proposed().round(),
                vote_msg.sync_info(),
                vote_msg.vote().author(),
            )
            .await
            .context("[RoundManager] Stop processing vote")?
        {
            self.process_vote(vote_msg.vote())
                .await
                .context("[RoundManager] Add a new vote")?;
        }
        Ok(())
    }
```
