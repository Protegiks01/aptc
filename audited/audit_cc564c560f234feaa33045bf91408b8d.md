# Audit Report

## Title
Authentication Bypass via X-IS-JWT Header Injection in Aptos Faucet

## Summary
The Aptos Faucet service contains a critical authentication bypass vulnerability where attackers can inject the `x-is-jwt` header to skip auth token validation without any actual JWT verification occurring. This allows unauthorized access to faucet funds when the faucet is configured with `AuthTokenChecker` but lacks JWT validation through `RedisRatelimitChecker`.

## Finding Description

The vulnerability exists in the header processing flow of the faucet's funding endpoints. The entire `HeaderMap` is passed through the preprocessing pipeline where checkers and bypassers examine request headers to make authentication decisions.

**The Flawed Design:**

The `AuthTokenChecker` is designed to validate API keys from an allowlist, but it contains logic to skip validation when it detects the `X_IS_JWT_HEADER` ("x-is-jwt") header: [1](#0-0) 

This early return assumes that JWT validation will happen elsewhere. Similarly, the `AuthTokenBypasser` also skips its logic when this header is present: [2](#0-1) 

**The Missing Validation:**

JWT validation is NOT implemented as a standalone checker. It only occurs within `RedisRatelimitChecker` when explicitly configured with the JWT ratelimit key provider: [3](#0-2) 

Critically, the `RatelimitKeyProviderConfig` defaults to IP-based ratelimiting, not JWT: [4](#0-3) 

**The Attack Path:**

1. Faucet is configured with `AuthTokenChecker` to require valid API keys
2. Redis ratelimiting is either:
   - Not configured at all, OR
   - Configured with default IP-based ratelimiting (not JWT)
3. Attacker sends a fund request with header: `x-is-jwt: true`
4. Request flows through `FundApi::fund()` → `fund_inner()` → `preprocess_request()`: [5](#0-4) 

5. The `CheckerData` containing all headers is passed to each checker: [6](#0-5) 

6. `AuthTokenChecker::check()` sees the `X_IS_JWT_HEADER` and returns `Ok(vec![])` - passing validation without checking the actual auth token
7. No JWT validation occurs because there's no checker configured to perform it
8. Request is approved and funded without any authentication

## Impact Explanation

**Severity: HIGH**

This vulnerability allows complete authentication bypass in the Aptos Faucet service. While the faucet is not part of the core blockchain consensus, it represents a critical auxiliary service with the following impacts:

1. **Unauthorized Fund Access**: Attackers can drain testnet faucet funds without proper authentication
2. **Service Availability**: Malicious actors can exhaust faucet resources, denying legitimate developers access
3. **Rate Limit Bypass**: If only auth token checking is configured without rate limiting, unlimited requests are possible
4. **Infrastructure Abuse**: Compromised faucet service can be used to spam the test network

According to the Aptos bug bounty criteria, this qualifies as **High Severity** due to:
- API authentication bypass
- Significant protocol violation (authentication invariant broken)
- Service disruption potential

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to be exploitable in real-world deployments because:

1. **Common Configuration Pattern**: Deployments may use simple auth token checking for basic access control without implementing full JWT infrastructure
2. **Default Behavior**: The `RatelimitKeyProviderConfig` defaults to IP-based ratelimiting, not JWT validation
3. **No Configuration Validation**: There is no validation at startup that enforces: "If AuthTokenChecker skips on X_IS_JWT_HEADER, then JWT validation MUST be configured"
4. **Simple Attack**: Requires only adding a single HTTP header - no complex exploit chain
5. **Documentation Gap**: The interdependency between AuthTokenChecker and JWT validation is not explicitly documented

## Recommendation

**Immediate Fix:**

Add a dedicated `JwtChecker` that performs standalone JWT validation when the `X_IS_JWT_HEADER` is present. This decouples JWT validation from rate limiting:

```rust
// crates/aptos-faucet/core/src/checkers/jwt.rs
pub struct JwtChecker {
    jwt_verifier: FirebaseJwtVerifier,
}

impl JwtChecker {
    pub fn new(config: FirebaseJwtVerifierConfig) -> Result<Self> {
        let jwt_verifier = FirebaseJwtVerifier::new(config).await?;
        Ok(Self { jwt_verifier })
    }
}

#[async_trait]
impl CheckerTrait for JwtChecker {
    async fn check(
        &self,
        data: CheckerData,
        _dry_run: bool,
    ) -> Result<Vec<RejectionReason>, AptosTapError> {
        // Only validate if X_IS_JWT_HEADER is present
        if !data.headers.contains_key(X_IS_JWT_HEADER) {
            return Ok(vec![]);
        }
        
        // Perform JWT validation
        match self.jwt_verifier.validate_jwt(data.headers.clone()).await {
            Ok(_) => Ok(vec![]),
            Err(e) => Ok(vec![RejectionReason::new(
                e.message,
                RejectionReasonCode::AuthTokenInvalid,
            )]),
        }
    }

    fn cost(&self) -> u8 {
        10 // JWT verification is moderately expensive
    }
}
```

**Configuration Validation:**

Add startup validation in `RunConfig::run_impl()` to ensure safe configurations:

```rust
// Validate that if AuthTokenChecker is configured and checks for X_IS_JWT_HEADER,
// then either JwtChecker or RedisRatelimitChecker with JWT must also be configured
let has_auth_token_checker = self.checker_configs.iter().any(|c| matches!(c, CheckerConfig::AuthToken(_)));
let has_jwt_validation = self.checker_configs.iter().any(|c| {
    matches!(c, CheckerConfig::Jwt(_)) ||
    matches!(c, CheckerConfig::RedisRatelimit(cfg) if matches!(cfg.ratelimit_key_provider_config, RatelimitKeyProviderConfig::Jwt(_)))
});

if has_auth_token_checker && !has_jwt_validation {
    anyhow::bail!("Security Error: AuthTokenChecker is configured but no JWT validation is enabled. This allows authentication bypass via x-is-jwt header injection.");
}
```

## Proof of Concept

```rust
// Integration test demonstrating the vulnerability
#[tokio::test]
async fn test_jwt_header_auth_bypass() -> Result<()> {
    // Configure faucet with AuthTokenChecker but NO JWT validation
    let config = r#"
server_config:
  listen_address: "0.0.0.0"
  listen_port: 8081
  api_path_base: ""

checker_configs:
  - type: AuthToken
    list_source:
      type: file
      path: /tmp/test_auth_tokens.txt

# Note: No JWT validation configured!

funder_config:
  type: MintFunder
  # ... funder config ...
"#;

    // Create auth tokens file with valid token
    std::fs::write("/tmp/test_auth_tokens.txt", "valid_token_123")?;
    
    let (port, _handle) = start_server(config).await?;
    
    // Test 1: Request without auth token should fail
    let response = reqwest::Client::new()
        .post(format!("http://127.0.0.1:{}/fund", port))
        .json(&json!({"amount": 100, "address": "0xABCD"}))
        .send()
        .await?;
    assert_eq!(response.status(), 403); // Should be rejected
    
    // Test 2: Request with valid auth token should succeed
    let response = reqwest::Client::new()
        .post(format!("http://127.0.0.1:{}/fund", port))
        .header("Authorization", "Bearer valid_token_123")
        .json(&json!({"amount": 100, "address": "0xABCD"}))
        .send()
        .await?;
    assert_eq!(response.status(), 200); // Should succeed
    
    // Test 3: VULNERABILITY - Request with x-is-jwt header but NO JWT bypasses auth!
    let response = reqwest::Client::new()
        .post(format!("http://127.0.0.1:{}/fund", port))
        .header("x-is-jwt", "true")
        // No Authorization header, no valid token!
        .json(&json!({"amount": 100, "address": "0xDEF0"}))
        .send()
        .await?;
    
    // This should fail but SUCCEEDS due to the vulnerability!
    assert_eq!(response.status(), 200); // Authentication bypassed!
    
    Ok(())
}
```

## Notes

This vulnerability specifically affects the Aptos Faucet auxiliary service rather than the core blockchain consensus or execution layers. However, it represents a critical security flaw that allows complete authentication bypass in faucet deployments that rely on auth token checking without properly configured JWT validation. The issue stems from an implicit design assumption (that JWT validation will happen elsewhere) that is not enforced by configuration validation or code structure.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/auth_token.rs (L37-40)
```rust
        // Don't check if the request has X_IS_JWT_HEADER set.
        if data.headers.contains_key(X_IS_JWT_HEADER) {
            return Ok(vec![]);
        }
```

**File:** crates/aptos-faucet/core/src/bypasser/auth_token.rs (L33-36)
```rust
        // Don't check if the request has X_IS_JWT_HEADER set.
        if data.headers.contains_key(X_IS_JWT_HEADER) {
            return Ok(false);
        }
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L18-24)
```rust
#[derive(Clone, Debug, Default, Deserialize, Serialize)]
#[serde(tag = "type")]
pub enum RatelimitKeyProviderConfig {
    #[default]
    Ip,
    Jwt(FirebaseJwtVerifierConfig),
}
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L44-50)
```rust
    pub async fn ratelimit_key_value(&self, data: &CheckerData) -> Result<String, AptosTapError> {
        match self {
            RatelimitKeyProvider::Ip => Ok(data.source_ip.to_string()),
            RatelimitKeyProvider::Jwt(jwt_verifier) => {
                jwt_verifier.validate_jwt(data.headers.clone()).await
            },
        }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L237-242)
```rust
        let checker_data = CheckerData {
            receiver,
            source_ip,
            headers: Arc::new(header_map.clone()),
            time_request_received_secs: get_current_time_secs(),
        };
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L261-270)
```rust
        // Ensure request passes checkers.
        let mut rejection_reasons = Vec::new();
        for checker in &self.checkers {
            rejection_reasons.extend(checker.check(checker_data.clone(), dry_run).await.map_err(
                |e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError),
            )?);
            if !rejection_reasons.is_empty() && self.return_rejections_early {
                break;
            }
        }
```
