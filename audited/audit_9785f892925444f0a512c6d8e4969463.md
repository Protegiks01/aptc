# Audit Report

## Title
Dual Transaction Filter Configuration Enables Consensus Inconsistency and Self-Rejection of Block Proposals

## Summary
The Aptos consensus system uses two separate `BlockTransactionFilterConfig` instances—`execution_filter` for block preparation and `consensus_filter` for proposal validation—which can be configured differently. This architectural split enables validators to reject their own proposals and creates cross-validator inconsistencies that violate deterministic execution guarantees.

## Finding Description

The Aptos codebase maintains two distinct transaction filter configurations that operate at different stages of consensus: [1](#0-0) 

**Filter Usage Locations:**

1. **Execution Filter** - Applied during block preparation: [2](#0-1) [3](#0-2) [4](#0-3) 

2. **Consensus Filter** - Applied during proposal validation: [5](#0-4) [6](#0-5) [7](#0-6) 

**Attack Scenario 1: Validator Self-Rejection**

When a validator proposes a block, the following sequence occurs:

1. ProposalGenerator creates a block with transactions from mempool
2. BlockPreparer filters transactions using `execution_filter`
3. Block is signed and broadcast to all validators (including self via loopback): [8](#0-7) 

4. RoundManager validates the proposal using `consensus_filter`: [7](#0-6) 

If `execution_filter` is more permissive than `consensus_filter`, the validator will:
- Propose a block containing transaction T (allowed by execution_filter)
- Immediately reject its own proposal (denied by consensus_filter)
- Fail to vote for its own proposal
- Result: **Liveness failure** for that round

**Attack Scenario 2: Cross-Validator Inconsistency**

Different validators may have different `consensus_filter` configurations. When Validator A proposes a block:
- Validator B (consensus_filter allows transaction T) → votes for proposal
- Validator C (consensus_filter denies transaction T) → rejects proposal
- Result: **Split voting, potential consensus stall, violation of safety guarantees**

**DirectMempoolPayloadManager Involvement:**

The `DirectMempoolPayloadManager.check_denied_inline_transactions()` method receives the filter configuration as a parameter (not stored internally): [9](#0-8) 

The question's premise about "notification" is technically incorrect since DirectMempoolPayloadManager doesn't cache configuration. However, the underlying issue of inconsistent filter application remains valid and exploitable.

## Impact Explanation

**Severity: High** (per Aptos Bug Bounty criteria)

This vulnerability causes:

1. **Validator Node Slowdowns**: Self-rejecting validators cannot participate in consensus rounds, degrading network performance
2. **Significant Protocol Violations**: Violates the "Deterministic Execution" invariant (#1) requiring all validators to produce identical outcomes for identical blocks
3. **Consensus Liveness Issues**: If multiple validators have mismatched configs, the network may struggle to achieve 2/3 consensus
4. **Potential Safety Violations**: Different validators making different decisions on the same proposal could lead to consensus splits under certain timing conditions

The impact does not reach Critical severity because:
- No funds are lost or stolen
- The network can recover if configs are corrected
- This requires configuration changes, not a pure code exploit

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability is likely to manifest in production because:

1. **No validation exists** to ensure `execution_filter == consensus_filter`: [10](#0-9) 

2. **Operator Error**: Validators may accidentally configure these filters differently during emergency response scenarios (e.g., filtering malicious transactions)

3. **Lack of Coordination**: There's no on-chain mechanism to coordinate filter configurations across validators, making divergence likely during incidents

4. **Silent Failure**: A validator won't immediately detect it's rejecting its own proposals; the issue manifests as consensus performance degradation

## Recommendation

**Immediate Fix**: Add validation to ensure filter consistency at configuration load time:

```rust
// In config/src/config/transaction_filters_config.rs
impl TransactionFiltersConfig {
    pub fn validate(&self) -> Result<(), String> {
        // Ensure execution and consensus filters are identical
        if self.execution_filter != self.consensus_filter {
            return Err(format!(
                "execution_filter and consensus_filter must be identical. \
                 Found execution_filter={:?}, consensus_filter={:?}",
                self.execution_filter, self.consensus_filter
            ));
        }
        Ok(())
    }
}

// Call validation in NodeConfig::load() or EpochManager::new()
```

**Long-term Solutions**:

1. **Unify Filter Configuration**: Merge execution_filter and consensus_filter into a single `block_transaction_filter` used consistently across both stages

2. **On-Chain Filter Coordination**: Move transaction filter configuration to on-chain governance, ensuring all validators use identical filters

3. **Runtime Validation**: Add assertions in RoundManager to detect when a validator rejects its own proposal:
```rust
// In process_proposal()
if proposal.author() == self.author && denied_transactions_result.is_err() {
    error!("CRITICAL: Validator rejecting its own proposal due to filter mismatch!");
    // Emit telemetry, fail-safe behavior
}
```

## Proof of Concept

Configure two validators with mismatched filters:

**Validator A config** (`validator_a.yaml`):
```yaml
transaction_filters:
  execution_filter:
    filter_enabled: false
  consensus_filter:
    filter_enabled: true
    block_transaction_filter:
      block_matchers:
        - BlockAuthor: "0xBAD_ADDRESS"
```

**Validator B config** (`validator_b.yaml`):
```yaml
transaction_filters:
  execution_filter:
    filter_enabled: true  
    block_transaction_filter:
      block_matchers:
        - BlockAuthor: "0xBAD_ADDRESS"
  consensus_filter:
    filter_enabled: false
```

**Steps to Reproduce**:
1. Start a 4-validator testnet with Validators A, B using above configs
2. Make Validator A the proposer for round N
3. Validator A will propose a block (execution_filter disabled)
4. Validator A will reject its own proposal (consensus_filter enabled, denies block from 0xBAD_ADDRESS)
5. Observe Validator A fails to vote, consensus stalls or requires timeout

**Expected Result**: Validator A successfully proposes and votes  
**Actual Result**: Validator A rejects own proposal, consensus degraded

---

**Notes**: This vulnerability stems from an architectural decision to separate execution and consensus filtering. While the intent may have been flexibility, the implementation lacks safeguards against configuration divergence, creating a critical attack surface for consensus manipulation and liveness failures.

### Citations

**File:** config/src/config/transaction_filters_config.rs (L10-18)
```rust
#[derive(Clone, Debug, Default, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct TransactionFiltersConfig {
    pub api_filter: TransactionFilterConfig, // Filter for the API (e.g., txn simulation)
    pub consensus_filter: BlockTransactionFilterConfig, // Filter for consensus (e.g., proposal voting)
    pub execution_filter: BlockTransactionFilterConfig, // Filter for execution (e.g., block execution)
    pub mempool_filter: TransactionFilterConfig,        // Filter for mempool (e.g., txn submission)
    pub quorum_store_filter: BatchTransactionFilterConfig, // Filter for quorum store (e.g., batch voting)
}
```

**File:** consensus/src/consensus_provider.rs (L69-69)
```rust
        node_config.transaction_filters.execution_filter.clone(),
```

**File:** consensus/src/state_computer.rs (L106-106)
```rust
            self.txn_filter_config.clone(),
```

**File:** consensus/src/block_preparer.rs (L91-98)
```rust
            let filtered_txns = filter_block_transactions(
                txn_filter_config,
                block_id,
                block_author,
                block_epoch,
                block_timestamp_usecs,
                txns,
            );
```

**File:** consensus/src/epoch_manager.rs (L211-211)
```rust
        let consensus_txn_filter_config = node_config.transaction_filters.consensus_filter.clone();
```

**File:** consensus/src/epoch_manager.rs (L982-982)
```rust
            self.consensus_txn_filter_config.clone(),
```

**File:** consensus/src/round_manager.rs (L1204-1214)
```rust
        if let Err(error) = self
            .block_store
            .check_denied_inline_transactions(&proposal, &self.block_txn_filter_config)
        {
            counters::REJECTED_PROPOSAL_DENY_TXN_COUNT.inc();
            bail!(
                "[RoundManager] Proposal for block {} contains denied inline transactions: {}. Dropping proposal!",
                proposal.id(),
                error
            );
        }
```

**File:** consensus/src/network.rs (L366-370)
```rust
        let self_msg = Event::Message(self.author, msg.clone());
        let mut self_sender = self.self_sender.clone();
        if let Err(err) = self_sender.send(self_msg).await {
            error!("Error broadcasting to self: {:?}", err);
        }
```

**File:** consensus/src/payload_manager/direct_mempool_payload_manager.rs (L30-70)
```rust
    fn check_denied_inline_transactions(
        &self,
        block: &Block,
        block_txn_filter_config: &BlockTransactionFilterConfig,
    ) -> anyhow::Result<()> {
        // If the filter is disabled, return early
        if !block_txn_filter_config.is_enabled() {
            return Ok(());
        }

        // Get the inline transactions for the block proposal. Note: all
        // transactions in a direct mempool payload are inline transactions.
        let (inline_transactions, _, _) = get_transactions_from_block(block)?;
        if inline_transactions.is_empty() {
            return Ok(());
        }

        // Fetch the block metadata
        let block_id = block.id();
        let block_author = block.author();
        let block_epoch = block.epoch();
        let block_timestamp = block.timestamp_usecs();

        // Identify any denied inline transactions
        let block_transaction_filter = block_txn_filter_config.block_transaction_filter();
        let denied_inline_transactions = block_transaction_filter.get_denied_block_transactions(
            block_id,
            block_author,
            block_epoch,
            block_timestamp,
            inline_transactions,
        );
        if !denied_inline_transactions.is_empty() {
            return Err(anyhow::anyhow!(
                "Inline transactions for DirectMempoolPayload denied by block transaction filter: {:?}",
                denied_inline_transactions
            ));
        }

        Ok(()) // No transactions were denied
    }
```
