# Audit Report

## Title
Remote Executor gRPC Service Lacks Encryption and Forward Secrecy - Complete Exposure of Transaction and State Data

## Summary
The remote executor gRPC service transmits sensitive transaction data, blockchain state keys/values, and execution results over completely unencrypted HTTP connections. Any network observer can immediately read all messages without needing to compromise keys. Even if TLS were added, there is no evidence of forward secrecy configuration, meaning compromised long-lived keys could decrypt all historical captured traffic.

## Finding Description
The remote executor service implements a distributed execution architecture where a coordinator node sends execution commands to multiple executor shards via gRPC. The gRPC server implementation completely lacks encryption. [1](#0-0) 

The server is created with `Server::builder()` without any TLS configuration. The client connects using plain HTTP: [2](#0-1) 

This breaks the **Cryptographic Correctness** invariant. Sensitive data transmitted over these unencrypted connections includes:

1. **ExecuteBlockCommand** containing `AnalyzedTransaction` objects with transaction payloads, signatures, and sender addresses [3](#0-2) 

2. **RemoteKVRequest/RemoteKVResponse** containing blockchain state keys and values [4](#0-3) 

3. **TransactionOutput** containing execution results, gas consumed, and state changes [5](#0-4) 

The messages are serialized using BCS and transmitted without encryption: [6](#0-5) 

**Attack Path:**
1. Attacker positions themselves to monitor network traffic between coordinator and executor shards (compromised network infrastructure, man-in-the-middle, or access to network logs)
2. Attacker captures gRPC traffic using standard tools (tcpdump, Wireshark)
3. Attacker deserializes BCS-encoded messages to extract transaction data, state keys/values, and execution results
4. Attacker gains complete visibility into transaction patterns, user behavior, and blockchain state

Other gRPC services in the codebase properly implement TLS, showing this is a specific omission: [7](#0-6) 

## Impact Explanation
This qualifies as **Medium Severity** per the Aptos bug bounty program for the following reasons:

1. **Information Disclosure**: Exposes sensitive transaction data including payloads, signatures, sender addresses, and transaction patterns
2. **State Exposure**: Reveals blockchain state keys and values being accessed during execution
3. **Privacy Violation**: Compromises user privacy by exposing all transaction activity in the remote execution path
4. **Attack Enablement**: Revealed information could enable more sophisticated attacks including transaction front-running, user profiling, and strategic exploitation

While this doesn't directly enable fund theft or consensus violations (which would be Critical), it represents a significant confidentiality breach requiring intervention to secure the remote execution infrastructure.

The question specifically categorizes this as Medium severity, which aligns with the "state inconsistencies requiring intervention" and information disclosure impacts.

## Likelihood Explanation
This vulnerability has **HIGH likelihood** of exploitation:

1. **Always Active**: Every remote execution operation transmits data over unencrypted connections
2. **Low Attacker Skill**: Passive network monitoring requires minimal sophistication
3. **Common Attack Position**: Network infrastructure compromises, cloud provider access, or man-in-the-middle positions are common attack vectors
4. **No Detection**: Passive monitoring leaves no traces, making it undetectable
5. **Distributed Architecture**: The remote executor is designed for cross-machine communication, increasing network exposure

The remote executor service is invoked for distributed block execution, making this a frequent target for network surveillance.

## Recommendation

Implement TLS with forward secrecy for all remote executor gRPC connections:

1. **Add TLS Configuration** similar to the indexer services:
   - Add `cert_path` and `key_path` configuration parameters
   - Load certificates using `tokio::fs::read()`
   - Create TLS identity with `tonic::transport::Identity::from_pem()`
   - Configure server with `ServerTlsConfig`

2. **Enforce Forward Secrecy** by configuring Rustls cipher suites to use ephemeral key exchange (ECDHE):
   - Configure TLS to only accept cipher suites with forward secrecy
   - Use TLS 1.3 which provides forward secrecy by default
   - Disable TLS 1.2 cipher suites without ephemeral keys

3. **Update Client Connections** to use HTTPS instead of HTTP and verify server certificates

4. **Implement mTLS** (mutual TLS) for authenticated connections between coordinator and executor shards

Example fix for server in `secure/net/src/grpc_network_service/mod.rs`:
```rust
// Add to function signature:
cert_path: String,
key_path: String,

// In start_async():
let cert = tokio::fs::read(cert_path).await?;
let key = tokio::fs::read(key_path).await?;
let identity = tonic::transport::Identity::from_pem(cert, key);

Server::builder()
    .timeout(std::time::Duration::from_millis(rpc_timeout_ms))
    .tls_config(tonic::transport::ServerTlsConfig::new().identity(identity))?
    .add_service(...)
```

## Proof of Concept

**Prerequisites:**
- Aptos Core with executor-service built
- Network capture tool (tcpdump or Wireshark)

**Steps to Reproduce:**

1. Start coordinator and executor shards:
```bash
# Terminal 1 - Start executor shard 0
./target/release/executor-service \
  --shard-id 0 \
  --num-shards 2 \
  --coordinator-address 127.0.0.1:52200 \
  --remote-executor-addresses 127.0.0.1:52201 127.0.0.1:52202

# Terminal 2 - Start executor shard 1
./target/release/executor-service \
  --shard-id 1 \
  --num-shards 2 \
  --coordinator-address 127.0.0.1:52200 \
  --remote-executor-addresses 127.0.0.1:52201 127.0.0.1:52202
```

2. Capture network traffic:
```bash
# Terminal 3 - Capture traffic
sudo tcpdump -i lo -w remote_executor.pcap 'port 52201 or port 52202'
```

3. Execute a block via the remote executor (from validator or test harness)

4. Analyze captured traffic:
```bash
# Stop tcpdump (Ctrl+C)
# Open in Wireshark
wireshark remote_executor.pcap

# Filter for gRPC traffic
# Protocol will show as HTTP2, not HTTPS
# Inspect packet contents - all data is plaintext
# Extract BCS-serialized messages
# Deserialize to see transaction data, state keys, and results
```

5. Decode a captured message:
```rust
use bcs;
use aptos_executor_service::RemoteExecutionRequest;

// Extract bytes from captured packet
let captured_bytes: Vec<u8> = /* bytes from network capture */;

// Deserialize - this will succeed, proving no encryption
let request: RemoteExecutionRequest = bcs::from_bytes(&captured_bytes).unwrap();

// Access sensitive data
match request {
    RemoteExecutionRequest::ExecuteBlock(cmd) => {
        // cmd.sub_blocks contains all transaction data
        // cmd.onchain_config contains configuration
        println!("Captured transactions: {:?}", cmd.sub_blocks);
    }
}
```

This demonstrates that any network observer can read all transaction data, state keys/values, and execution results without any decryption needed.

## Notes

The vulnerability is more severe than just lacking forward secrecy - there is **no encryption whatsoever**. This means:

1. **Immediate Exposure**: Messages can be read by passive observers without compromising any keys
2. **No Forward Secrecy**: Even if TLS were added without forward secrecy, compromised long-lived keys would allow decryption of all historical captured traffic
3. **Answer to Security Question**: YES, historical messages can be "decrypted" (currently read directly; with TLS but no forward secrecy, they could be decrypted if keys are compromised)

The remote executor architecture is designed for performance-critical distributed execution across multiple machines, making network security essential. The contrast with properly secured gRPC services elsewhere in the codebase (indexer services) confirms this is an oversight rather than an intentional design decision.

### Citations

**File:** secure/net/src/grpc_network_service/mod.rs (L75-86)
```rust
        Server::builder()
            .timeout(std::time::Duration::from_millis(rpc_timeout_ms))
            .add_service(
                NetworkMessageServiceServer::new(self).max_decoding_message_size(MAX_MESSAGE_SIZE),
            )
            .add_service(reflection_service)
            .serve_with_shutdown(server_addr, async {
                server_shutdown_rx.await.ok();
                info!("Received signal to shutdown server at {:?}", server_addr);
            })
            .await
            .unwrap();
```

**File:** secure/net/src/grpc_network_service/mod.rs (L128-137)
```rust
                .block_on(async { Self::get_channel(format!("http://{}", remote_addr)).await }),
        }
    }

    async fn get_channel(remote_addr: String) -> NetworkMessageServiceClient<Channel> {
        info!("Trying to connect to remote server at {:?}", remote_addr);
        let conn = tonic::transport::Endpoint::new(remote_addr)
            .unwrap()
            .connect_lazy();
        NetworkMessageServiceClient::new(conn).max_decoding_message_size(MAX_MESSAGE_SIZE)
```

**File:** execution/executor-service/src/lib.rs (L32-41)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RemoteExecutionResult {
    pub inner: Result<Vec<Vec<TransactionOutput>>, VMStatus>,
}

impl RemoteExecutionResult {
    pub fn new(inner: Result<Vec<Vec<TransactionOutput>>, VMStatus>) -> Self {
        Self { inner }
    }
}
```

**File:** execution/executor-service/src/lib.rs (L48-53)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ExecuteBlockCommand {
    pub(crate) sub_blocks: SubBlocksForShard<AnalyzedTransaction>,
    pub(crate) concurrency_level: usize,
    pub(crate) onchain_config: BlockExecutorConfigFromOnchain,
}
```

**File:** execution/executor-service/src/lib.rs (L67-81)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct RemoteKVRequest {
    pub(crate) shard_id: ShardId,
    pub(crate) keys: Vec<StateKey>,
}

impl RemoteKVRequest {
    pub fn new(shard_id: ShardId, keys: Vec<StateKey>) -> Self {
        Self { shard_id, keys }
    }

    pub fn into(self) -> (ShardId, Vec<StateKey>) {
        (self.shard_id, self.keys)
    }
}
```

**File:** execution/executor-service/src/remote_executor_client.rs (L193-206)
```rust
        for (shard_id, sub_blocks) in sub_blocks.into_iter().enumerate() {
            let senders = self.command_txs.clone();
            let execution_request = RemoteExecutionRequest::ExecuteBlock(ExecuteBlockCommand {
                sub_blocks,
                concurrency_level: concurrency_level_per_shard,
                onchain_config: onchain_config.clone(),
            });

            senders[shard_id]
                .lock()
                .unwrap()
                .send(Message::new(bcs::to_bytes(&execution_request).unwrap()))
                .unwrap();
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/config.rs (L217-228)
```rust
            let cert = tokio::fs::read(config.cert_path.clone()).await?;
            let key = tokio::fs::read(config.key_path.clone()).await?;
            let identity = tonic::transport::Identity::from_pem(cert, key);
            tracing::info!(
                grpc_address = listen_address.to_string().as_str(),
                "[Data Service] Starting gRPC server with TLS."
            );
            tasks.push(tokio::spawn(async move {
                Server::builder()
                    .http2_keepalive_interval(Some(HTTP2_PING_INTERVAL_DURATION))
                    .http2_keepalive_timeout(Some(HTTP2_PING_TIMEOUT_DURATION))
                    .tls_config(tonic::transport::ServerTlsConfig::new().identity(identity))?
```
