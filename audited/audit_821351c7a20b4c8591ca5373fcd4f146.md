# Audit Report

## Title
Path Traversal Vulnerability in Move Package Dependency Resolution Allows Reading from Arbitrary Directories

## Summary
The Move package compilation system lacks path validation for local dependencies specified in `Move.toml` manifests, allowing attackers to use path traversal sequences (`../`) to cause the compiler to read files from unintended directories on the file system.

## Finding Description

The vulnerability exists in the dependency parsing logic used by the Aptos CLI and Move package tooling. When a Move package declares a local dependency in its `Move.toml` file, the path is accepted without any sanitization or validation.

The attack flow is:

1. **Malicious Manifest Creation**: An attacker creates a `Move.toml` with a path-traversed dependency:
   ```toml
   [dependencies]
   MaliciousDep = { local = "../../../sensitive/directory" }
   ```

2. **Unsanitized Path Parsing**: In the manifest parser, the local path string is directly converted to a `PathBuf` without validation: [1](#0-0) 

3. **Path Combination**: The unsanitized path is pushed onto the root path during dependency resolution: [2](#0-1) 

4. **File System Access**: The combined path is used to construct source directories and read files: [3](#0-2) 

5. **Unrestricted File Reading**: The file discovery uses `walkdir` with `follow_links(true)`, enabling symlink traversal: [4](#0-3) 

The Aptos CLI actively uses this vulnerable code path: [5](#0-4) 

**Note**: A newer `move-package-resolver` tool exists with proper path validation, but it is **not used** by the Aptos CLI compilation flow: [6](#0-5) 

## Impact Explanation

**Severity Assessment: Medium to Low**

While this is a genuine security vulnerability, its impact is limited because:

1. **Not a Consensus Violation**: This issue affects the **compilation process**, not runtime execution. Validators execute pre-compiled bytecode, not source code. Different validators would only be affected if they independently compiled the same malicious package, which is not part of normal consensus operation.

2. **Development/Operational Impact**: The primary risk is to:
   - Developers who compile untrusted Move packages
   - CI/CD systems that build Move code from untrusted sources
   - Any system that automatically compiles Move packages

3. **Potential Harms**:
   - **Information Disclosure**: Error messages reveal attempted file paths
   - **File System Probing**: Attacker can determine directory structure
   - **Code Injection**: If attacker controls accessible directories with valid Move packages, they could inject malicious code into compilation

**This does NOT constitute**:
- Critical: No loss of funds, no consensus violation, no network partition
- High: No validator node compromise during consensus operations

**Realistic Impact**: Medium severity for development security, Low severity for blockchain consensus security.

## Likelihood Explanation

**Likelihood: Medium to High for Development, Low for Production Validators**

The vulnerability is easily exploitable:
- No special privileges required
- Simple to craft malicious `Move.toml`
- Affects default Aptos CLI behavior

However, realistic attack scenarios are limited:
- Validators typically don't compile arbitrary packages during consensus
- Published on-chain packages contain bytecode, not source with dependencies
- Attack primarily affects development/build environments

## Recommendation

**Immediate Fix**: Add path validation to the dependency parsing logic in `manifest_parser.rs`:

```rust
fn parse_dependency(dep_name: &str, tval: TV) -> Result<PM::Dependency> {
    // ... existing code ...
    (Some(local), None, None) => {
        let local_str = local
            .as_str()
            .ok_or_else(|| format_err!("Local source path not a string"))?;
        
        // SECURITY FIX: Validate path
        let local_path = PathBuf::from(local_str);
        
        // Reject absolute paths
        if local_path.is_absolute() {
            bail!("Dependency local path cannot be absolute: {}", local_str);
        }
        
        // Normalize and check for parent directory escape
        let normalized = normalize_path(&local_path);
        if let Some(Component::ParentDir) = normalized.components().next() {
            bail!("Dependency path cannot traverse outside package root: {}", local_str);
        }
        
        Ok(PM::Dependency {
            subst,
            version,
            digest,
            local: normalized,
            git_info,
            node_info,
        })
    },
    // ... rest of code ...
}
```

**Long-term Solution**: Migrate Aptos CLI to use the newer `move-package-resolver` which already has these protections implemented.

## Proof of Concept

```bash
# Create a malicious Move package
mkdir malicious_package
cd malicious_package

# Create Move.toml with path traversal
cat > Move.toml << 'EOF'
[package]
name = "MaliciousPackage"
version = "0.0.1"

[dependencies]
# Attempt to read from system directories
EvilDep = { local = "../../../etc" }
EOF

# Create minimal sources directory
mkdir sources
cat > sources/main.move << 'EOF'
module 0x1::Main {
    public fun test() {}
}
EOF

# Attempt compilation - will try to access /etc/Move.toml
aptos move compile

# Expected behavior: Compilation attempts to read ../../../etc/Move.toml
# Error message will reveal attempted path, confirming vulnerability
```

**Note**: This PoC demonstrates the path traversal attempt. The actual impact depends on whether the target directory contains a valid Move package structure.

---

**Notes**

This vulnerability affects the **compilation toolchain**, not the consensus or runtime execution layer. While it represents a security weakness in the Move development ecosystem, it does not directly violate the core blockchain invariants around deterministic execution or consensus safety. The impact is primarily limited to development environments and does not affect on-chain state or validator consensus operations.

### Citations

**File:** third_party/move/tools/move-package/src/source_package/manifest_parser.rs (L342-354)
```rust
                (Some(local), None, None) => {
                    let local_str = local
                        .as_str()
                        .ok_or_else(|| format_err!("Local source path not a string"))?;
                    let local_path = PathBuf::from(local_str);
                    Ok(PM::Dependency {
                        subst,
                        version,
                        digest,
                        local: local_path,
                        git_info,
                        node_info,
                    })
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L499-517)
```rust
    fn parse_package_manifest(
        dep: &Dependency,
        dep_name: &PackageName,
        mut root_path: PathBuf,
    ) -> Result<(SourceManifest, PathBuf)> {
        root_path.push(&dep.local);
        match fs::read_to_string(root_path.join(SourcePackageLayout::Manifest.path())) {
            Ok(contents) => {
                let source_package: SourceManifest =
                    parse_move_manifest_string(contents).and_then(parse_source_manifest)?;
                Ok((source_package, root_path))
            },
            Err(_) => Err(anyhow::format_err!(
                "Unable to find package manifest for '{}' at {:?}",
                dep_name,
                SourcePackageLayout::Manifest.path().join(root_path),
            )),
        }
    }
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L652-673)
```rust
    fn get_source_paths_for_config(
        package_path: &Path,
        config: &BuildConfig,
    ) -> Result<Vec<PathBuf>> {
        let mut places_to_look = Vec::new();
        let mut add_path = |layout_path: SourcePackageLayout| {
            let path = package_path.join(layout_path.path());
            if layout_path.is_optional() && !path.exists() {
                return;
            }
            places_to_look.push(path)
        };

        add_path(SourcePackageLayout::Sources);
        add_path(SourcePackageLayout::Scripts);

        if config.dev_mode {
            add_path(SourcePackageLayout::Examples);
            add_path(SourcePackageLayout::Tests);
        }
        Ok(places_to_look)
    }
```

**File:** third_party/move/move-command-line-common/src/files.rs (L62-94)
```rust
pub fn find_filenames<Predicate: FnMut(&Path) -> bool>(
    paths: &[impl AsRef<Path>],
    mut is_file_desired: Predicate,
) -> anyhow::Result<Vec<String>> {
    let mut result = vec![];

    for s in paths {
        let path = s.as_ref();
        if !path.exists() {
            bail!("No such file or directory '{}'", path.to_string_lossy())
        }
        if path.is_file() && is_file_desired(path) {
            result.push(path_to_string(path)?);
            continue;
        }
        if !path.is_dir() {
            continue;
        }
        for entry in walkdir::WalkDir::new(path)
            .follow_links(true)
            .into_iter()
            .filter_map(|e| e.ok())
        {
            let entry_path = entry.path();
            if !entry.file_type().is_file() || !is_file_desired(entry_path) {
                continue;
            }

            result.push(path_to_string(entry_path)?);
        }
    }
    Ok(result)
}
```

**File:** crates/aptos/src/move_tool/mod.rs (L76-76)
```rust
use move_package::{source_package::layout::SourcePackageLayout, BuildConfig, CompilerConfig};
```

**File:** third_party/move/tools/move-package-resolver/src/resolver.rs (L351-372)
```rust
            SourceLocation::Git {
                repo,
                commit_id,
                subdir,
            } => {
                // Parent is a git dependency while child is local.
                // This makes the child also a git dependency, with path relative to that of the
                // parent's in the same git repo.
                if local_path.is_absolute() {
                    bail!(
                        "local dependency in a git repo cannot be an absolute path: {}",
                        local_path.display()
                    );
                }

                let new_subdir = subdir.join(local_path);
                let normalized_new_subdir = NormalizedPath::new(&new_subdir);
                if let Some(std::path::Component::ParentDir) =
                    normalized_new_subdir.components().next()
                {
                    bail!("subdir outside of repo root: {}", new_subdir.display());
                }
```
