# Audit Report

## Title
BatchRequestMsg DoS Attack via Repeated Non-Existent Batch Requests

## Summary
The batch retrieval mechanism in the Aptos consensus layer is vulnerable to a denial-of-service attack where malicious peers can repeatedly request non-existent batches, consuming resources and delaying legitimate batch retrieval operations that are critical for consensus operation.

## Finding Description

The vulnerability exists in the batch retrieval request handling flow. When a peer sends a `BatchRequestMsg`, the request flows through the consensus network layer without adequate validation of whether the requested batch digest is plausible or exists. [1](#0-0) 

The request is routed through the EpochManager which only validates that the epoch matches the current epoch: [2](#0-1) 

Once epoch validation passes, the request is pushed to the `batch_retrieval_tx` channel without any validation of the digest: [3](#0-2) 

The `batch_retrieval_tx` channel is configured as a LIFO queue with capacity 10 per peer: [4](#0-3) 

A single-threaded `batch_serve` task processes all batch retrieval requests sequentially: [5](#0-4) 

For each non-existent batch request, the task performs a DashMap lookup and fetches ledger info: [6](#0-5) 

**Attack Scenario:**
1. Malicious peer sends `BatchRequestMsg` with correct current epoch but random/non-existent digests
2. Network layer accepts up to 100 concurrent inbound RPCs per peer: [7](#0-6) 

3. Each request is processed by the single-threaded batch_serve task
4. LIFO queue behavior means sustained flooding causes older requests (potentially legitimate) to be dropped: [8](#0-7) 

5. Multiple malicious peers can amplify the attack, consuming batch_serve task capacity
6. Legitimate batch retrieval requests from honest validators experience delays or drops
7. Consensus performance degrades as validators cannot retrieve batches efficiently

## Impact Explanation

This qualifies as **Medium Severity** per Aptos bug bounty criteria as it causes validator node slowdowns and impacts consensus throughput, though it does not directly violate consensus safety. The attack:

- Consumes CPU resources processing invalid requests
- Delays legitimate batch retrieval operations critical for consensus
- Can be sustained indefinitely with correct epoch values
- Impacts multiple validators if the attacker targets several nodes
- Does not cause fund loss or permanent state corruption

The impact is limited by the fact that operations are in-memory and relatively fast, and the LIFO queue prioritizes recent requests. However, sustained flooding from multiple peers can meaningfully degrade consensus performance.

## Likelihood Explanation

**Likelihood: High**

The attack is practical and easy to execute:
- No validator privileges required - any network peer can send BatchRequestMsg
- Epoch value is publicly known (current consensus epoch)
- Random digests are trivial to generate
- Network layer allows 100 concurrent RPCs per peer
- Attack can be automated and sustained
- Multiple attacker peers can amplify the impact

## Recommendation

Implement rate limiting and validation for batch retrieval requests:

1. **Add request validation**: Track failed batch requests per peer and implement exponential backoff or temporary blocking
2. **Digest validation**: Check if the requested digest's batch info exists in cache before attempting full retrieval
3. **Per-peer rate limiting**: Limit the rate of batch requests per peer over time windows (e.g., max 100 requests per second)
4. **Priority queuing**: Separate queues for validators vs non-validators, prioritizing validator requests
5. **Metrics and monitoring**: Track and alert on excessive failed batch requests

Example fix outline:
```rust
// Add to batch_serve task:
// 1. Track failed requests per peer
// 2. Implement rate limiter per peer
// 3. Return early for rate-limited peers
// 4. Add backoff mechanism for repeated failures
```

## Proof of Concept

```rust
// Simulated attack scenario
// An attacker peer repeatedly sends BatchRequestMsg with random digests

use aptos_crypto::HashValue;
use consensus::quorum_store::types::BatchRequest;
use rand::Rng;

async fn dos_attack(network_sender: NetworkSender, target_peer: PeerId, epoch: u64) {
    let my_peer_id = network_sender.author();
    
    loop {
        // Generate 100 random non-existent digests
        for _ in 0..100 {
            let random_digest = HashValue::random();
            let request = BatchRequest::new(my_peer_id, epoch, random_digest);
            
            // Send RPC request - most will return NotFound quickly
            // but consume batch_serve task capacity
            let _ = network_sender.send_rpc(
                target_peer,
                ConsensusMsg::BatchRequestMsg(Box::new(request)),
                Duration::from_secs(5)
            ).await;
        }
        
        // No delay - immediately send more requests
        // This keeps the batch_serve task busy processing invalid requests
    }
}
```

## Notes

The vulnerability is exacerbated by the single-threaded nature of the batch_serve task and the LIFO queue behavior which can drop older legitimate requests during sustained flooding. While individual operations are fast, the cumulative effect across multiple malicious peers can meaningfully impact consensus performance by delaying critical batch retrievals.

### Citations

**File:** consensus/src/network_interface.rs (L71-71)
```rust
    BatchRequestMsg(Box<BatchRequest>),
```

**File:** consensus/src/epoch_manager.rs (L1815-1821)
```rust
        match request.epoch() {
            Some(epoch) if epoch != self.epoch() => {
                monitor!(
                    "process_different_epoch_rpc_request",
                    self.process_different_epoch(epoch, peer_id)
                )?;
                return Ok(());
```

**File:** consensus/src/epoch_manager.rs (L1855-1860)
```rust
            IncomingRpcRequest::BatchRetrieval(request) => {
                if let Some(tx) = &self.batch_retrieval_tx {
                    tx.push(peer_id, request)
                } else {
                    Err(anyhow::anyhow!("Quorum store not started"))
                }
```

**File:** consensus/src/quorum_store/quorum_store_builder.rs (L397-402)
```rust
        let (batch_retrieval_tx, mut batch_retrieval_rx) =
            aptos_channel::new::<AccountAddress, IncomingBatchRetrievalRequest>(
                QueueStyle::LIFO,
                10,
                Some(&counters::BATCH_RETRIEVAL_TASK_MSGS),
            );
```

**File:** consensus/src/quorum_store/quorum_store_builder.rs (L404-438)
```rust
        spawn_named!("batch_serve", async move {
            info!(epoch = epoch, "Batch retrieval task starts");
            while let Some(rpc_request) = batch_retrieval_rx.next().await {
                counters::RECEIVED_BATCH_REQUEST_COUNT.inc();
                let response = if let Ok(value) =
                    batch_store.get_batch_from_local(&rpc_request.req.digest())
                {
                    let batch: Batch<BatchInfoExt> = value.try_into().unwrap();
                    let batch: Batch<BatchInfo> = batch
                        .try_into()
                        .expect("Batch retieval requests must be for V1 batch");
                    BatchResponse::Batch(batch)
                } else {
                    match aptos_db_clone.get_latest_ledger_info() {
                        Ok(ledger_info) => BatchResponse::NotFound(ledger_info),
                        Err(e) => {
                            let e = anyhow::Error::from(e);
                            error!(epoch = epoch, error = ?e, kind = error_kind(&e));
                            continue;
                        },
                    }
                };

                let msg = ConsensusMsg::BatchResponseV2(Box::new(response));
                let bytes = rpc_request.protocol.to_bytes(&msg).unwrap();
                if let Err(e) = rpc_request
                    .response_sender
                    .send(Ok(bytes.into()))
                    .map_err(|_| anyhow::anyhow!("Failed to send block retrieval response"))
                {
                    warn!(epoch = epoch, error = ?e, kind = error_kind(&e));
                }
            }
            info!(epoch = epoch, "Batch retrieval task stops");
        });
```

**File:** consensus/src/quorum_store/batch_store.rs (L571-585)
```rust
    pub(crate) fn get_batch_from_local(
        &self,
        digest: &HashValue,
    ) -> ExecutorResult<PersistedValue<BatchInfoExt>> {
        if let Some(value) = self.db_cache.get(digest) {
            if value.payload_storage_mode() == StorageMode::PersistedOnly {
                self.get_batch_from_db(digest, value.batch_info().is_v2())
            } else {
                // Available in memory.
                Ok(value.clone())
            }
        } else {
            Err(ExecutorError::CouldNotGetData)
        }
    }
```

**File:** network/framework/src/constants.rs (L15-15)
```rust
pub const MAX_CONCURRENT_INBOUND_RPCS: u32 = 100;
```

**File:** crates/channel/src/message_queues.rs (L134-147)
```rust
        if key_message_queue.len() >= self.max_queue_size.get() {
            if let Some(c) = self.counters.as_ref() {
                c.with_label_values(&["dropped"]).inc();
            }
            match self.queue_style {
                // Drop the newest message for FIFO
                QueueStyle::FIFO => Some(message),
                // Drop the oldest message for LIFO
                QueueStyle::LIFO | QueueStyle::KLAST => {
                    let oldest = key_message_queue.pop_front();
                    key_message_queue.push_back(message);
                    oldest
                },
            }
```
