# Audit Report

## Title
Permanent DoS of JWK Consensus Due to Silent Quorum Certificate Drops on Session Key Extraction Failure

## Summary
In the JWK consensus subsystem's `UpdateCertifier::start_produce()` function, if `session_key_from_qc()` fails to extract a session key from a valid `QuorumCertifiedUpdate`, the quorum-certified update is silently dropped rather than being sent to the consensus manager. This causes a permanent denial of service where JWK updates that have achieved validator quorum are never applied on-chain, with no retry mechanism to recover.

## Finding Description
The JWK consensus system is responsible for updating JSON Web Keys used in Aptos's keyless account authentication. The vulnerability exists in the critical path where quorum-certified updates are processed after achieving consensus.

**The Vulnerable Flow:** [1](#0-0) 

When a `QuorumCertifiedUpdate` is successfully produced via reliable broadcast (line 68), the code attempts to extract a session key using `ConsensusMode::session_key_from_qc()` (line 70). If this extraction fails:
1. An error is logged (line 76)
2. The QC is **silently dropped** - it is never sent via `qc_update_tx` (line 73 is not executed)
3. The update never reaches the consensus manager

For PerKeyMode, the session key extraction can fail when `KeyLevelUpdate::try_from_issuer_level_repr()` encounters: [2](#0-1) 

Specifically:
- Invalid JWK count (line 361-363)
- JWK conversion failure (line 365-366)
- Version underflow when version=0 (line 367-370)

**The Deadlock Scenario:**

The consensus manager maintains state for each (issuer, kid) pair: [3](#0-2) 

When a new observation arrives, the code checks if consensus is already in progress. If the state is `InProgress` or `Finished` with the same proposal, it returns early without starting new consensus (line 192-193).

Once a QC is dropped in `update_certifier.rs`, the state in the manager remains `InProgress` forever because:
1. The QC was never received via `qc_update_rx` 
2. The state is never updated to `Finished`
3. Subsequent observations see `InProgress` state and skip consensus initiation
4. No retry mechanism exists [4](#0-3) 

The manager waits indefinitely for a QC that will never arrive.

**Recovery Impossibility:**

The only way to clear the stuck state is via `reset_with_on_chain_state()`: [5](#0-4) 

This retains states only when the on-chain version hasn't changed (lines 244-254). However, the on-chain version can only change if a QC is successfully applied - creating a circular dependency. The system is permanently deadlocked.

## Impact Explanation

**Severity: CRITICAL**

This vulnerability qualifies as Critical severity under the Aptos bug bounty program for multiple reasons:

1. **Consensus Safety Violation**: The fundamental invariant that "quorum-certified updates are applied" is broken. Validators can achieve 2/3+ agreement on a JWK update, but it never gets committed on-chain.

2. **Permanent DoS / Total Loss of Liveness**: Once triggered, JWK updates for the affected (issuer, kid) pair permanently stop working. This is non-recoverable without manual intervention or a hardfork to reset the consensus state.

3. **Critical System Functionality Impaired**: JWKs are essential for keyless account authentication (zkLogin). Without JWK updates:
   - New OIDC provider keys cannot be added
   - Rotated keys cannot be updated
   - Expired keys cannot be removed
   - Users cannot authenticate with new keys
   - Service availability for keyless accounts is compromised [6](#0-5) 

4. **State Inconsistency**: The system achieves quorum (validators agree) but the state is never updated, violating state consistency guarantees.

## Likelihood Explanation

**Likelihood: Medium to High**

While the session key extraction failure "shouldn't happen" in normal operation, several realistic scenarios can trigger it:

1. **JWK Format Edge Cases**: The conversion from `JWK` to `JWKMoveStruct` and back involves complex type handling: [7](#0-6) 

If the `type_name` doesn't match expected values or `MoveAny::unpack()` fails, the conversion fails.

2. **Code Version Mismatches**: If validators are running slightly different code versions during upgrades, the serialization format might differ.

3. **Data Corruption**: While signatures should catch network corruption, any post-verification data handling bugs could corrupt the `JWKMoveStruct`.

4. **Zero Version Edge Case**: If somehow a QC with version=0 is created, `checked_sub(1)` returns None, causing failure.

The critical issue is that even if the probability is low, the code has **zero defensive handling**. A single failure causes **permanent DoS** with no recovery path. This violates defensive programming principles for critical consensus infrastructure.

## Recommendation

Implement robust error handling with retry mechanisms and alerting:

```rust
// In update_certifier.rs, replace lines 70-78 with:
let session_key = ConsensusMode::session_key_from_qc(&qc_update);
match session_key {
    Ok(key) => {
        let _ = qc_update_tx.push(key, qc_update);
    },
    Err(e) => {
        // CRITICAL: QC achieved quorum but session key extraction failed
        // This should NEVER happen - log extensively and attempt recovery
        error!(
            epoch = epoch,
            error = ?e,
            qc_update = ?qc_update,
            "CRITICAL: JWK update QCed but session key extraction failed. This indicates a serious bug."
        );
        
        // Emit metric for alerting
        counters::JWK_SESSION_KEY_EXTRACTION_FAILURES.inc();
        
        // Attempt fallback: extract directly from the update payload
        // This provides a recovery path even if the normal extraction fails
        match extract_session_key_fallback::<ConsensusMode>(&qc_update) {
            Ok(fallback_key) => {
                warn!("Using fallback session key extraction");
                let _ = qc_update_tx.push(fallback_key, qc_update);
            },
            Err(fallback_err) => {
                // If even fallback fails, we must crash to prevent silent data loss
                panic!(
                    "Failed to extract session key from QC with both primary and fallback methods. \
                     Primary error: {e}. Fallback error: {fallback_err}. \
                     QC: {:?}. This is a critical bug requiring immediate investigation.",
                    qc_update
                );
            }
        }
    },
}
```

Additionally, add retry logic in the consensus manager:

```rust
// In jwk_manager_per_key.rs, modify maybe_start_consensus:
fn maybe_start_consensus(&mut self, update: KeyLevelUpdate) -> Result<()> {
    let consensus_already_started = match self
        .states_by_key
        .get(&(update.issuer.clone(), update.kid.clone()))
        .cloned()
    {
        Some(ConsensusState::InProgress { my_proposal, started_at, .. }) => {
            // Check if consensus has been stuck for too long (e.g., > 5 minutes)
            if started_at.elapsed() > Duration::from_secs(300) {
                warn!("Consensus stuck in InProgress for >5min, forcing restart");
                false // Force restart
            } else {
                my_proposal.observed.to_upsert == update.to_upsert
            }
        },
        Some(ConsensusState::Finished { my_proposal, .. }) => {
            my_proposal.observed.to_upsert == update.to_upsert
        },
        _ => false,
    };
    
    // ... rest of function
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test_session_key_extraction_dos {
    use super::*;
    use aptos_types::jwks::{ProviderJWKs, QuorumCertifiedUpdate};
    use aptos_crypto::bls12381::PrivateKey;
    
    #[tokio::test]
    async fn test_qc_dropped_on_session_key_failure() {
        // Setup
        let (qc_update_tx, mut qc_update_rx) = aptos_channel::new(QueueStyle::KLAST, 1, None);
        let epoch_state = create_test_epoch_state();
        
        // Create a ProviderJWKs that will fail session_key_from_qc
        // For example, a ProviderJWKs with version=0 will fail in PerKeyMode
        let bad_qc = QuorumCertifiedUpdate {
            update: ProviderJWKs {
                issuer: b"test_issuer".to_vec(),
                version: 0, // This will cause checked_sub(1) to fail
                jwks: vec![/* valid JWK */],
            },
            multi_sig: AggregateSignature::empty(),
        };
        
        // Simulate what update_certifier does
        let session_key = PerKeyMode::session_key_from_qc(&bad_qc);
        match session_key {
            Ok(key) => {
                let _ = qc_update_tx.push(key, bad_qc.clone());
            },
            Err(e) => {
                // BUG: QC is dropped here!
                eprintln!("Session key extraction failed: {}", e);
            },
        }
        
        // Verify: The QC was never sent
        tokio::time::timeout(
            Duration::from_millis(100),
            qc_update_rx.select_next_some()
        )
        .await
        .expect_err("Should timeout - no QC was sent despite achieving quorum");
        
        // In production, consensus state would now be stuck in InProgress
        // New observations would be ignored
        // JWK updates for this key would be permanently blocked
    }
}
```

## Notes

The vulnerability demonstrates a critical defensive programming failure in consensus-critical infrastructure. Even if the failure mode is theoretically impossible under normal operation, the lack of error recovery for quorum-certified updates violates fundamental safety guarantees. The system should never silently drop data that has achieved validator consensus.

The fix requires both immediate error handling (don't drop QCs) and long-term improvements (timeout-based retry mechanisms, comprehensive monitoring, and graceful degradation paths).

### Citations

**File:** crates/aptos-jwk-consensus/src/update_certifier.rs (L67-78)
```rust
        let task = async move {
            let qc_update = rb.broadcast(req, agg_state).await.expect("cannot fail");
            ConsensusMode::log_certify_done(epoch, &qc_update);
            let session_key = ConsensusMode::session_key_from_qc(&qc_update);
            match session_key {
                Ok(key) => {
                    let _ = qc_update_tx.push(key, qc_update);
                },
                Err(e) => {
                    error!("JWK update QCed but could not identify the session key: {e}");
                },
            }
```

**File:** types/src/jwks/mod.rs (L360-384)
```rust
    pub fn try_from_issuer_level_repr(repr: &ProviderJWKs) -> anyhow::Result<Self> {
        ensure!(
            repr.jwks.len() == 1,
            "wrapped repr of a key-level update should have exactly 1 jwk"
        );
        let jwk =
            JWK::try_from(&repr.jwks[0]).context("try_from_issuer_level_repr failed on JWK")?;
        let base_version = repr
            .version
            .checked_sub(1)
            .context("try_from_issuer_level_repr on version")?;
        Ok(Self {
            issuer: repr.issuer.clone(),
            base_version,
            kid: jwk.id(),
            to_upsert: match jwk {
                JWK::Unsupported(unsupported)
                    if unsupported.payload.as_slice() == DELETE_COMMAND_INDICATOR.as_bytes() =>
                {
                    None
                },
                _ => Some(jwk),
            },
        })
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L179-194)
```rust
    fn maybe_start_consensus(&mut self, update: KeyLevelUpdate) -> Result<()> {
        let consensus_already_started = match self
            .states_by_key
            .get(&(update.issuer.clone(), update.kid.clone()))
            .cloned()
        {
            Some(ConsensusState::InProgress { my_proposal, .. })
            | Some(ConsensusState::Finished { my_proposal, .. }) => {
                my_proposal.observed.to_upsert == update.to_upsert
            },
            _ => false,
        };

        if consensus_already_started {
            return Ok(());
        }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L234-254)
```rust
    pub fn reset_with_on_chain_state(&mut self, on_chain_state: AllProvidersJWKs) -> Result<()> {
        info!(
            epoch = self.epoch_state.epoch,
            "reset_with_on_chain_state starting."
        );

        let new_onchain_jwks = on_chain_state.indexed().context(
            "KeyLevelJWKManager::reset_with_on_chain_state failed at onchain state indexing",
        )?;
        // for an existing state entry (iss, kid) -> state, discard it unless `new_onchain_jwks[iss].version == self.onchain_jwks[iss].version`.
        self.states_by_key.retain(|(issuer, _), _| {
            new_onchain_jwks
                .get(issuer)
                .map(|jwks| jwks.version)
                .unwrap_or_default()
                == self
                    .onchain_jwks
                    .get(issuer)
                    .map(|jwks| jwks.version)
                    .unwrap_or_default()
        });
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L424-425)
```rust
                qc_update = this.qc_update_rx.select_next_some() => {
                    this.process_quorum_certified_update(qc_update)
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L1-10)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

use crate::move_vm_ext::AptosMoveResolver;
use aptos_crypto::ed25519::Ed25519PublicKey;
use aptos_types::{
    invalid_signature,
    jwks::{jwk::JWK, AllProvidersJWKs, FederatedJWKs, PatchedJWKs},
    keyless::{
        get_public_inputs_hash, AnyKeylessPublicKey, Configuration, EphemeralCertificate,
```

**File:** types/src/jwks/jwk/mod.rs (L102-122)
```rust
impl TryFrom<&JWKMoveStruct> for JWK {
    type Error = anyhow::Error;

    fn try_from(value: &JWKMoveStruct) -> Result<Self, Self::Error> {
        match value.variant.type_name.as_str() {
            RSA_JWK::MOVE_TYPE_NAME => {
                let rsa_jwk =
                    MoveAny::unpack(RSA_JWK::MOVE_TYPE_NAME, value.variant.clone()).map_err(|e|anyhow!("converting from jwk move struct to jwk failed with move any to rsa unpacking error: {e}"))?;
                Ok(Self::RSA(rsa_jwk))
            },
            UnsupportedJWK::MOVE_TYPE_NAME => {
                let unsupported_jwk =
                    MoveAny::unpack(UnsupportedJWK::MOVE_TYPE_NAME, value.variant.clone()).map_err(|e|anyhow!("converting from jwk move struct to jwk failed with move any to unsupported unpacking error: {e}"))?;
                Ok(Self::Unsupported(unsupported_jwk))
            },
            _ => Err(anyhow!(
                "converting from jwk move struct to jwk failed with unknown variant"
            )),
        }
    }
}
```
