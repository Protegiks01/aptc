# Audit Report

## Title
Validator Crash via Panic in SecretShareManager When Processing Blocks Without Encrypted Transactions

## Summary
When secret sharing is enabled, any validator processing a block with no encrypted transactions will trigger a panic in `SecretShareManager::process_incoming_block()` that crashes the entire validator process due to Aptos's global panic handler calling `process::exit(12)`.

## Finding Description

The vulnerability occurs in the secret sharing pipeline when blocks without encrypted transactions are processed. The execution flow is:

1. **SecretShareManager spawned as tokio task**: The SecretShareManager is spawned via `tokio::spawn` in the execution client initialization. [1](#0-0) 

2. **Pipeline future setup with oneshot channel**: When building pipeline futures for each block, a oneshot channel is created for `secret_sharing_derive_self_fut`. The receiver is wrapped in a future that returns an error if the sender is dropped without sending. [2](#0-1) 

3. **Early return drops sender without sending**: In `decrypt_encrypted_txns`, when a block has no encrypted transactions, the function returns early without sending anything through the oneshot channel, causing the sender to be dropped. [3](#0-2) 

4. **Panic on .expect()**: The SecretShareManager awaits the future and uses `.expect()` which panics when the channel returns an error (cancelled/dropped). [4](#0-3) 

5. **Global panic handler kills validator**: Aptos sets up a global panic handler at node startup that overrides Tokio's default panic-catching behavior. [5](#0-4) 

6. **Process termination**: The panic handler calls `process::exit(12)` for any panic except those in the Move bytecode verifier or deserializer, terminating the entire validator process. [6](#0-5) 

**Broken Invariant**: This violates the **Consensus Safety** invariant (#2) by causing validators to crash and potentially halt network liveness if enough validators are affected.

## Impact Explanation

**Critical Severity** - This meets the "Total loss of liveness/network availability" criterion for several reasons:

1. **Complete validator crash**: The entire validator process terminates via `process::exit(12)`, not just the task
2. **Deterministic trigger**: ANY block without encrypted transactions will trigger this when secret sharing is enabled
3. **Natural occurrence**: Even without malicious intent, most blocks will have no encrypted transactions during normal operation (encrypted transactions are not the default)
4. **Network-wide impact**: All validators with secret sharing enabled will crash when processing the same block
5. **Consensus halt risk**: If enough validators crash simultaneously, the network cannot reach consensus

The vulnerability effectively creates a network-wide denial of service when the secret sharing feature is enabled.

## Likelihood Explanation

**Extremely High Likelihood**:

1. **No attacker needed**: This occurs naturally during normal operation - any block proposer can trigger it simply by proposing a block with no encrypted transactions
2. **Default behavior**: Encrypted transactions are not the norm; most blocks will contain only regular unencrypted transactions
3. **Feature enabled**: When the secret sharing feature is enabled on the network, all validators running with this configuration are vulnerable
4. **Zero complexity**: No special crafting, timing, or exploitation technique required
5. **Immediate trigger**: Occurs on the first block without encrypted transactions after secret sharing is enabled

This is essentially a guaranteed crash condition during normal network operation when secret sharing is active.

## Recommendation

**Fix**: Send `None` through the oneshot channel before returning early when there are no encrypted transactions:

In `consensus/src/pipeline/decryption_pipeline_builder.rs`, modify the early return to send `None`:

```rust
if encrypted_txns.is_empty() {
    let _ = derived_self_key_share_tx.send(None);  // Add this line
    return Ok((
        unencrypted_txns,
        max_txns_from_block_to_execute,
        block_gas_limit,
    ));
}
```

This ensures the receiver gets a value (`Ok(None)`) instead of a channel cancellation error, preventing the panic.

**Alternative**: Replace `.expect()` with proper error handling in `secret_share_manager.rs` to gracefully handle the `None` case or channel errors without panicking.

## Proof of Concept

**Reproduction Steps**:

1. Enable secret sharing feature in validator configuration (`SecretShareConfig` is `Some`)
2. Start a validator node with this configuration
3. Propose and process any block that contains zero encrypted transactions (standard block)
4. Observe validator crash with exit code 12

**Expected Behavior**: 
- The `decrypt_encrypted_txns` function returns early at line 50-54
- The oneshot sender is dropped without sending
- The `secret_sharing_derive_self_fut.await` returns `Err(channel cancelled)`
- The `.expect()` at line 137 panics with message "Decryption share computation is expected to succeed"
- The global panic handler catches it and logs crash info
- `process::exit(12)` terminates the validator

**Verification**: Check validator logs for panic message and process exit code 12. The backtrace will show the panic originating from `secret_share_manager.rs:137`.

## Notes

This vulnerability demonstrates a critical oversight in the pipeline future error handling. The `Option<SecretShare>` return type suggests that `None` should be a valid result when no encrypted transactions exist, but the implementation never sends this value through the channel. The combination with Aptos's aggressive panic-to-crash policy turns what could be a task-level failure into a validator-terminating event.

### Citations

**File:** consensus/src/pipeline/execution_client.rs (L296-302)
```rust
        tokio::spawn(secret_share_manager.start(
            ordered_block_rx,
            secret_sharing_msg_rx,
            reset_secret_share_manager_rx,
            self.bounded_executor.clone(),
            highest_committed_round,
        ));
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L447-455)
```rust
        let (derived_self_key_share_tx, derived_self_key_share_rx) = oneshot::channel();
        let secret_sharing_derive_self_fut = spawn_shared_fut(
            async move {
                derived_self_key_share_rx
                    .await
                    .map_err(|_| TaskError::from(anyhow!("commit proof tx cancelled")))
            },
            Some(&mut abort_handles),
        );
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L49-54)
```rust
        if encrypted_txns.is_empty() {
            return Ok((
                unencrypted_txns,
                max_txns_from_block_to_execute,
                block_gas_limit,
            ));
```

**File:** consensus/src/rand/secret_sharing/secret_share_manager.rs (L133-138)
```rust
        let futures = block.pipeline_futs().expect("pipeline must exist");
        let self_secret_share = futures
            .secret_sharing_derive_self_fut
            .await
            .expect("Decryption share computation is expected to succeed")
            .expect("Must not be None");
```

**File:** aptos-node/src/lib.rs (L233-234)
```rust
    // Setup panic handler
    aptos_crash_handler::setup_panic_handler();
```

**File:** crates/crash-handler/src/lib.rs (L48-57)
```rust
    // Do not kill the process if the panics happened at move-bytecode-verifier.
    // This is safe because the `state::get_state()` uses a thread_local for storing states. Thus the state can only be mutated to VERIFIER by the thread that's running the bytecode verifier.
    //
    // TODO: once `can_unwind` is stable, we should assert it. See https://github.com/rust-lang/rust/issues/92988.
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
```
