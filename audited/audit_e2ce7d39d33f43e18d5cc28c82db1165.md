# Audit Report

## Title
Division by Zero in RotatingProposer Causes Complete Network Halt via Malicious Governance Configuration

## Summary
The `RotatingProposer` implementation performs division by `contiguous_rounds` without validating that this parameter is non-zero. A malicious governance proposal can set `ProposerElectionType::RotatingProposer(0)` or `FixedProposer(0)`, causing all validator nodes to panic with division by zero on the first proposer election attempt, resulting in total network liveness loss requiring a hardfork to recover.

## Finding Description

The proposer election configuration is controlled by on-chain governance through the `ConsensusConfig` resource. The system supports three proposer election schemes via the `ProposerElectionType` enum: `RotatingProposer`, `LeaderReputation`, and `RoundProposer`. [1](#0-0) 

When governance updates the consensus configuration, only minimal validation occurs: [2](#0-1) 

The configuration update only checks that the config bytes are non-empty, but performs no semantic validation of the deserialized values. During epoch initialization, `EpochManager::create_proposer_election()` instantiates the proposer election handler by directly passing the `contiguous_rounds` parameter to `RotatingProposer::new()`: [3](#0-2) 

The critical vulnerability exists in the `get_valid_proposer()` implementation: [4](#0-3) 

The calculation `round / u64::from(self.contiguous_rounds)` performs integer division without any validation that `contiguous_rounds` is non-zero. When a malicious actor controls governance and submits a proposal with `ProposerElectionType::RotatingProposer(0)` or `FixedProposer(0)`, the following attack sequence occurs:

1. Malicious governance proposal calls `consensus_config::set_for_next_epoch()` with a serialized config containing `contiguous_rounds = 0`
2. Proposal passes and `aptos_governance::reconfigure()` is called
3. At the epoch boundary, `consensus_config::on_new_epoch()` applies the malicious configuration
4. All validators deserialize the new config (deserialization succeeds as BCS accepts any u32 value)
5. `EpochManager::create_proposer_election()` creates a `RotatingProposer` with `contiguous_rounds = 0`
6. On the first consensus round, when any validator calls `proposer_election.get_valid_proposer(round)`, the code panics with division by zero
7. All validator processes crash simultaneously
8. The network experiences complete liveness failure with no blocks being produced
9. Recovery requires a coordinated hardfork to revert the configuration and patch validator software

This breaks the fundamental **Consensus Liveness** invariant. The network cannot produce any blocks, making it non-recoverable through normal consensus mechanisms.

## Impact Explanation

This vulnerability qualifies as **Critical Severity** under the Aptos bug bounty program for the following reasons:

1. **Total loss of liveness/network availability**: The entire validator set crashes simultaneously, causing complete cessation of block production. No transactions can be processed, and the network is entirely non-functional.

2. **Non-recoverable without hardfork**: Since all validators crash immediately upon entering the new epoch, normal consensus recovery mechanisms cannot function. The only recovery path requires coordinated validator software patches and manual state interventionâ€”effectively a hardfork.

3. **Deterministic and instant impact**: Unlike probabilistic attacks, this vulnerability triggers with 100% reliability on the first proposer election call after configuration activation.

4. **Affects core consensus layer**: The vulnerability targets the proposer election mechanism, a fundamental component of the AptosBFT consensus protocol.

According to the Aptos bug bounty criteria, "Total loss of liveness/network availability" and "Non-recoverable network partition (requires hardfork)" are explicitly listed as Critical Severity impacts eligible for up to $1,000,000 in rewards.

## Likelihood Explanation

**Likelihood: Medium-to-High (conditional on governance compromise)**

The attack requires:
- **Governance control**: Attacker must be able to pass a malicious governance proposal through on-chain voting
- **Technical knowledge**: Understanding of the consensus configuration structure and BCS serialization
- **No validator cooperation needed**: Unlike 51% attacks, this requires no validator collusion

While governance control is a significant barrier, it's not insurmountable:
- Governance proposals can pass with sufficient staking power and voting participation
- Social engineering or economic attacks on governance participants
- Potential vulnerabilities in the governance voting system itself
- Insider threats from compromised governance participants

Once governance control is achieved, the attack execution is trivial and guaranteed to succeed. The lack of any validation at the Move level, Rust deserialization level, or consensus initialization level makes this a defense-in-depth failure.

The impact severity is so extreme (complete network halt) that even a medium likelihood warrants critical attention.

## Recommendation

Implement multi-layer validation to ensure `contiguous_rounds` is always positive:

**Layer 1: Rust-level validation in RotatingProposer::new()**
```rust
impl RotatingProposer {
    pub fn new(proposers: Vec<Author>, contiguous_rounds: u32) -> Self {
        assert!(contiguous_rounds > 0, "contiguous_rounds must be positive");
        assert!(!proposers.is_empty(), "proposers list cannot be empty");
        Self {
            proposers,
            contiguous_rounds,
        }
    }
}
```

**Layer 2: Validation in EpochManager::create_proposer_election()**
```rust
ProposerElectionType::RotatingProposer(contiguous_rounds) => {
    if *contiguous_rounds == 0 {
        error!("Invalid contiguous_rounds=0 in consensus config, using default=1");
        Arc::new(RotatingProposer::new(proposers, 1))
    } else {
        Arc::new(RotatingProposer::new(proposers, *contiguous_rounds))
    }
},
ProposerElectionType::FixedProposer(contiguous_rounds) => {
    if *contiguous_rounds == 0 {
        error!("Invalid contiguous_rounds=0 in consensus config, using default=1");
        let proposer = choose_leader(proposers);
        Arc::new(RotatingProposer::new(vec![proposer], 1))
    } else {
        let proposer = choose_leader(proposers);
        Arc::new(RotatingProposer::new(vec![proposer], *contiguous_rounds))
    }
},
```

**Layer 3: Move-level native function validation**

Add a native function in `aptos-move/framework/src/natives/consensus_config.rs` to validate configuration before accepting it:
```rust
pub fn validate_consensus_config_internal(config_bytes: Vec<u8>) -> bool {
    match bcs::from_bytes::<OnChainConsensusConfig>(&config_bytes) {
        Ok(config) => {
            match config.proposer_election_type() {
                ProposerElectionType::RotatingProposer(cr) | 
                ProposerElectionType::FixedProposer(cr) => *cr > 0,
                _ => true,
            }
        },
        Err(_) => false,
    }
}
```

Then call this validation in `consensus_config.move`:
```move
public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
    system_addresses::assert_aptos_framework(account);
    assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
    assert!(validate_consensus_config_internal(config), error::invalid_argument(EINVALID_CONFIG));
    std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
}

native fun validate_consensus_config_internal(config_bytes: vector<u8>): bool;
```

## Proof of Concept

```rust
#[cfg(test)]
mod test_division_by_zero_vulnerability {
    use super::*;
    use aptos_types::account_address::AccountAddress;

    #[test]
    #[should_panic(expected = "attempt to divide by zero")]
    fn test_rotating_proposer_zero_contiguous_rounds_causes_panic() {
        // Simulate malicious governance setting contiguous_rounds to 0
        let proposers = vec![
            AccountAddress::random(),
            AccountAddress::random(),
        ];
        
        // This is what gets created when governance sets RotatingProposer(0)
        let proposer_election = RotatingProposer::new(proposers, 0);
        
        // First call to get_valid_proposer for any round will panic
        // This would crash all validators simultaneously
        let _proposer = proposer_election.get_valid_proposer(1);
        // Execution never reaches here - node has crashed
    }
    
    #[test]
    #[should_panic(expected = "attempt to divide by zero")]
    fn test_fixed_proposer_zero_contiguous_rounds_causes_panic() {
        // FixedProposer is implemented as RotatingProposer with single proposer
        let proposer = AccountAddress::random();
        let proposer_election = RotatingProposer::new(vec![proposer], 0);
        
        // Panic occurs on first proposer election
        let _proposer = proposer_election.get_valid_proposer(1);
    }
    
    #[test]
    fn test_consensus_config_deserialization_accepts_zero() {
        // Demonstrate that BCS deserialization accepts contiguous_rounds=0
        use aptos_types::on_chain_config::{
            OnChainConsensusConfig, ConsensusConfigV1, ProposerElectionType,
            ConsensusAlgorithmConfig, ValidatorTxnConfig,
        };
        
        let malicious_config = OnChainConsensusConfig::V5 {
            alg: ConsensusAlgorithmConfig::JolteonV2 {
                main: ConsensusConfigV1 {
                    decoupled_execution: true,
                    back_pressure_limit: 10,
                    exclude_round: 40,
                    max_failed_authors_to_store: 10,
                    proposer_election_type: ProposerElectionType::RotatingProposer(0), // MALICIOUS!
                },
                quorum_store_enabled: true,
                order_vote_enabled: true,
            },
            vtxn: ValidatorTxnConfig::default_for_genesis(),
            window_size: None,
            rand_check_enabled: true,
        };
        
        // This serialization succeeds
        let config_bytes = bcs::to_bytes(&malicious_config).unwrap();
        
        // Deserialization also succeeds - no validation!
        let deserialized: OnChainConsensusConfig = bcs::from_bytes(&config_bytes).unwrap();
        
        // The malicious config with contiguous_rounds=0 passes through
        match deserialized.proposer_election_type() {
            ProposerElectionType::RotatingProposer(cr) => assert_eq!(*cr, 0),
            _ => panic!("Wrong type"),
        }
    }
}
```

**Notes**

This vulnerability represents a critical gap in defense-in-depth validation across multiple layers of the Aptos stack. The absence of validation at the Move governance level, Rust deserialization level, and consensus initialization level creates a single point of failure that can halt the entire network.

The fix requires coordinated changes across the Move framework (governance validation), native functions (semantic validation), and consensus layer (runtime assertions). Until these validations are implemented, the network remains vulnerable to governance-level attacks that could cause irrecoverable liveness failures.

### Citations

**File:** types/src/on_chain_config/consensus_config.rs (L508-523)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
#[serde(rename_all = "snake_case")] // cannot use tag = "type" as nested enums cannot work, and bcs doesn't support it
pub enum ProposerElectionType {
    // Choose the smallest PeerId as the proposer
    // with specified param contiguous_rounds
    FixedProposer(u32),
    // Round robin rotation of proposers
    // with specified param contiguous_rounds
    RotatingProposer(u32),
    // Committed history based proposer election
    LeaderReputation(LeaderReputationType),
    // Pre-specified proposers for each round,
    // or default proposer if round proposer not
    // specified
    RoundProposer(HashMap<Round, AccountAddress>),
}
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```

**File:** consensus/src/epoch_manager.rs (L296-304)
```rust
        match &onchain_config.proposer_election_type() {
            ProposerElectionType::RotatingProposer(contiguous_rounds) => {
                Arc::new(RotatingProposer::new(proposers, *contiguous_rounds))
            },
            // We don't really have a fixed proposer!
            ProposerElectionType::FixedProposer(contiguous_rounds) => {
                let proposer = choose_leader(proposers);
                Arc::new(RotatingProposer::new(vec![proposer], *contiguous_rounds))
            },
```

**File:** consensus/src/liveness/rotating_proposer_election.rs (L35-40)
```rust
impl ProposerElection for RotatingProposer {
    fn get_valid_proposer(&self, round: Round) -> Author {
        self.proposers
            [((round / u64::from(self.contiguous_rounds)) % self.proposers.len() as u64) as usize]
    }
}
```
