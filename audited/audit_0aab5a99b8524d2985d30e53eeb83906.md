# Audit Report

## Title
Incomplete Build Monitoring Allows Stealthy Framework Backdoors Through Unmonitored Subdirectories

## Summary
The `build.rs` script in `aptos-move/framework/cached-packages/` only monitors top-level `sources/` directories for changes, but does not recursively monitor their subdirectories. Since Cargo's `rerun-if-changed` directive does not watch subdirectories by default, modifications to critical framework files within subdirectories (such as consensus config, gas schedule, account management, and cryptographic verification modules) will not trigger a rebuild, allowing an attacker to inject malicious code that gets embedded in deployed binaries without detection.

## Finding Description

The vulnerability exists in how the build script monitors framework source files for changes. [1](#0-0) 

The build script uses `cargo:rerun-if-changed` directives to specify which paths should trigger a rebuild. However, it only monitors the top-level `sources/` directories for each framework package. According to Cargo's behavior, when `rerun-if-changed` is specified for a directory, it only watches for direct changes to that directory (adding/removing files), **not** for changes to files within subdirectories.

Critical framework modules are located in subdirectories that are **not** being monitored:

**In aptos-framework/sources/:**
- `configs/consensus_config.move` - Controls consensus parameters [2](#0-1) 
- `configs/gas_schedule.move` - Controls gas costs for all operations [3](#0-2) 
- `account/account.move` - Controls account creation and authentication [4](#0-3) 
- `aggregator/`, `aggregator_v2/`, `datastructures/` subdirectories

**In aptos-stdlib/sources/:**
- `cryptography/ed25519.move` - Ed25519 signature verification [5](#0-4) 
- `cryptography/multi_ed25519.move`, `cryptography/secp256k1.move`, `cryptography/bls12381.move`
- `data_structures/` subdirectory

**In move-stdlib/sources/:**
- `configs/features.move` - Feature flag management

The build process creates a `head.mrb` (Move Release Bundle) file containing compiled framework bytecode, which is then embedded directly into the binary using `include_bytes!()`. [6](#0-5) 

**Attack Scenario:**
1. Attacker modifies a critical file in a subdirectory (e.g., `configs/gas_schedule.move` to set all gas costs to 1, or `cryptography/ed25519.move` to always return true for signature verification)
2. The build script does not rerun because subdirectories are not monitored
3. The outdated `head.mrb` file (without the malicious changes) gets embedded in the binary
4. However, when the framework is compiled for actual deployment or testing from source, the malicious changes are included
5. This creates a discrepancy between the cached framework and the live framework, potentially causing:
   - Consensus splits if different nodes use different framework versions
   - Bypassed security checks if signature verification is compromised
   - Gas metering attacks if gas schedules are manipulated

## Impact Explanation

This is **HIGH severity** under the Aptos bug bounty criteria because it enables:

1. **Consensus Safety Violations**: If different validator nodes rebuild with different framework versions (some with cached, some with modified source), they will execute transactions differently, breaking the "Deterministic Execution" invariant and potentially causing chain splits.

2. **Significant Protocol Violations**: Malicious modifications to critical files like `consensus_config.move`, `gas_schedule.move`, or signature verification modules could fundamentally break protocol security guarantees.

3. **Stealthy Backdoor Mechanism**: The incomplete monitoring creates a blind spot where critical security code can be modified without triggering the normal build safeguards, making such attacks harder to detect during code review or CI/CD processes.

The impact is categorized as HIGH (not CRITICAL) because exploitation requires:
- Commit access to the repository or a supply chain attack
- The modified code must still pass other validation layers
- The attack creates inconsistency rather than direct fund theft

However, the potential for consensus violations and widespread protocol compromise makes this a serious vulnerability.

## Likelihood Explanation

**Likelihood: Medium-to-High**

The vulnerability is likely to manifest in several scenarios:

1. **Supply Chain Attacks**: If an attacker gains commit access (through compromised credentials, malicious insider, or dependency confusion), they can stealthily modify subdirectory files knowing they won't trigger rebuild warnings.

2. **Unintentional Bugs**: Developers might modify critical subdirectory files during refactoring, expecting the build system to catch changes, but the cached packages won't be updated, leading to production deployments with stale framework code.

3. **CI/CD Inconsistencies**: Different build environments might have different cached states, leading to non-deterministic builds and potential consensus issues across the network.

The likelihood is elevated because:
- The vulnerability affects multiple critical subdirectories across all framework packages
- Cargo's non-recursive directory watching is a subtle behavior that's easy to overlook
- The build system gives developers a false sense of security that all framework changes are monitored

## Recommendation

The build script must recursively monitor all subdirectories within the framework packages. There are two approaches:

**Option 1: Explicitly list all subdirectories**
```rust
// For each framework package, add monitoring for all subdirectories
println!("cargo:rerun-if-changed={}", prev_dir.join("aptos-framework").join("sources").display());
println!("cargo:rerun-if-changed={}", prev_dir.join("aptos-framework").join("sources").join("account").display());
println!("cargo:rerun-if-changed={}", prev_dir.join("aptos-framework").join("sources").join("aggregator").display());
println!("cargo:rerun-if-changed={}", prev_dir.join("aptos-framework").join("sources").join("aggregator_v2").display());
println!("cargo:rerun-if-changed={}", prev_dir.join("aptos-framework").join("sources").join("configs").display());
println!("cargo:rerun-if-changed={}", prev_dir.join("aptos-framework").join("sources").join("datastructures").display());
// ... repeat for all subdirectories in all packages
```

**Option 2: Programmatically walk all subdirectories (recommended)**
```rust
use std::fs;
use std::path::PathBuf;

fn register_directory_recursive(path: PathBuf) {
    if path.is_dir() {
        println!("cargo:rerun-if-changed={}", path.display());
        if let Ok(entries) = fs::read_dir(&path) {
            for entry in entries.flatten() {
                let entry_path = entry.path();
                if entry_path.is_dir() {
                    register_directory_recursive(entry_path);
                }
            }
        }
    }
}

// In main():
let packages = ["aptos-framework", "aptos-stdlib", "aptos-token", "aptos-token-objects", "aptos-experimental", "move-stdlib"];
for package in packages {
    let sources_dir = prev_dir.join(package).join("sources");
    register_directory_recursive(sources_dir);
    println!("cargo:rerun-if-changed={}", prev_dir.join(package).join("Move.toml").display());
}
```

## Proof of Concept

**Reproduction Steps:**

1. Build the cached-packages crate initially:
```bash
cd aptos-move/framework/cached-packages
cargo build
```

2. Note the timestamp of `target/debug/build/aptos-cached-packages-*/out/head.mrb`

3. Modify a file in a subdirectory (not monitored):
```bash
echo "// Backdoor comment" >> ../aptos-framework/sources/configs/consensus_config.move
```

4. Rebuild:
```bash
cargo build
```

5. Check the timestamp of `head.mrb` - **it will not have changed**, proving the build script did not rerun.

6. For comparison, modify a file in the top-level sources directory:
```bash
echo "// Test comment" >> ../aptos-framework/sources/aptos_coin.move
```

7. Rebuild:
```bash
cargo build
```

8. Check the timestamp of `head.mrb` - **it will have changed**, proving the build script only monitors top-level files.

**Expected Result:** Step 5 shows the vulnerability - subdirectory modifications don't trigger rebuilds, allowing stealthy code changes that won't be reflected in the cached framework bundle.

## Notes

This vulnerability represents a significant gap in the build system's security monitoring. While the immediate impact requires elevated access to modify source files, the stealthy nature of the attack (bypassing expected build triggers) makes it particularly dangerous for:

- Supply chain security
- Code review processes that rely on build system warnings
- CI/CD systems that might cache outdated framework builds
- Multi-developer environments where different team members might have inconsistent cached states

The issue affects all framework packages and their critical security modules, making it a systemic weakness rather than an isolated bug.

### Citations

**File:** aptos-move/framework/cached-packages/build.rs (L16-89)
```rust
        println!(
            "cargo:rerun-if-changed={}",
            prev_dir
                .join("aptos-experimental")
                .join("sources")
                .display()
        );
        println!(
            "cargo:rerun-if-changed={}",
            prev_dir
                .join("aptos-experimental")
                .join("Move.toml")
                .display()
        );
        println!(
            "cargo:rerun-if-changed={}",
            prev_dir
                .join("aptos-token-objects")
                .join("Move.toml")
                .display()
        );
        println!(
            "cargo:rerun-if-changed={}",
            prev_dir
                .join("aptos-token-objects")
                .join("sources")
                .display()
        );
        println!(
            "cargo:rerun-if-changed={}",
            prev_dir.join("aptos-token").join("sources").display()
        );
        println!(
            "cargo:rerun-if-changed={}",
            prev_dir.join("aptos-token").join("Move.toml").display()
        );
        println!(
            "cargo:rerun-if-changed={}",
            prev_dir
                .join("aptos-token-objects")
                .join("sources")
                .display()
        );
        println!(
            "cargo:rerun-if-changed={}",
            prev_dir
                .join("aptos-token-objects")
                .join("Move.toml")
                .display()
        );
        println!(
            "cargo:rerun-if-changed={}",
            prev_dir.join("aptos-framework").join("sources").display()
        );
        println!(
            "cargo:rerun-if-changed={}",
            prev_dir.join("aptos-framework").join("Move.toml").display()
        );
        println!(
            "cargo:rerun-if-changed={}",
            prev_dir.join("aptos-stdlib").join("sources").display()
        );
        println!(
            "cargo:rerun-if-changed={}",
            prev_dir.join("aptos-stdlib").join("Move.toml").display()
        );
        println!(
            "cargo:rerun-if-changed={}",
            prev_dir.join("move-stdlib").join("sources").display()
        );
        println!(
            "cargo:rerun-if-changed={}",
            prev_dir.join("move-stdlib").join("Move.toml").display()
        );
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L1-44)
```text
/// Maintains the consensus config for the blockchain. The config is stored in a
/// Reconfiguration, and may be updated by root.
module aptos_framework::consensus_config {
    use std::error;
    use std::vector;
    use aptos_framework::chain_status;
    use aptos_framework::config_buffer;

    use aptos_framework::reconfiguration;
    use aptos_framework::system_addresses;

    friend aptos_framework::genesis;
    friend aptos_framework::reconfiguration_with_dkg;

    struct ConsensusConfig has drop, key, store {
        config: vector<u8>,
    }

    /// The provided on chain config bytes are empty or invalid
    const EINVALID_CONFIG: u64 = 1;

    /// Publishes the ConsensusConfig config.
    public(friend) fun initialize(aptos_framework: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        move_to(aptos_framework, ConsensusConfig { config });
    }

    /// Deprecated by `set_for_next_epoch()`.
    ///
    /// WARNING: calling this while randomness is enabled will trigger a new epoch without randomness!
    ///
    /// TODO: update all the tests that reference this function, then disable this function.
    public fun set(account: &signer, config: vector<u8>) acquires ConsensusConfig {
        system_addresses::assert_aptos_framework(account);
        chain_status::assert_genesis();
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));

        let config_ref = &mut borrow_global_mut<ConsensusConfig>(@aptos_framework).config;
        *config_ref = config;

        // Need to trigger reconfiguration so validator nodes can sync on the updated configs.
        reconfiguration::reconfigure();
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L1-50)
```text
/// This module defines structs and methods to initialize the gas schedule, which dictates how much
/// it costs to execute Move on the network.
module aptos_framework::gas_schedule {
    use std::bcs;
    use std::error;
    use std::string::String;
    use std::vector;
    use aptos_std::aptos_hash;
    use aptos_framework::chain_status;
    use aptos_framework::config_buffer;

    use aptos_framework::reconfiguration;
    use aptos_framework::system_addresses;
    use aptos_framework::util::from_bytes;
    use aptos_framework::storage_gas::StorageGasConfig;
    use aptos_framework::storage_gas;
    #[test_only]
    use std::bcs::to_bytes;

    friend aptos_framework::genesis;
    friend aptos_framework::reconfiguration_with_dkg;

    /// The provided gas schedule bytes are empty or invalid
    const EINVALID_GAS_SCHEDULE: u64 = 1;
    const EINVALID_GAS_FEATURE_VERSION: u64 = 2;
    const EINVALID_GAS_SCHEDULE_HASH: u64 = 3;

    struct GasEntry has store, copy, drop {
        key: String,
        val: u64,
    }

    struct GasSchedule has key, copy, drop {
        entries: vector<GasEntry>
    }

    struct GasScheduleV2 has key, copy, drop, store {
        feature_version: u64,
        entries: vector<GasEntry>,
    }

    /// Only called during genesis.
    public(friend) fun initialize(aptos_framework: &signer, gas_schedule_blob: vector<u8>) {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));

        // TODO(Gas): check if gas schedule is consistent
        let gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        move_to<GasScheduleV2>(aptos_framework, gas_schedule);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L1-60)
```text
module aptos_framework::account {
    use std::bcs;
    use std::error;
    use std::features;
    use std::hash;
    use std::option::{Self, Option};
    use std::signer;
    use std::vector;
    use aptos_framework::chain_id;
    use aptos_framework::create_signer::create_signer;
    use aptos_framework::event::{Self, EventHandle};
    use aptos_framework::guid;
    use aptos_framework::permissioned_signer;
    use aptos_framework::system_addresses;
    use aptos_std::ed25519;
    use aptos_std::from_bcs;
    use aptos_std::multi_ed25519;
    use aptos_std::single_key;
    use aptos_std::multi_key;
    use aptos_std::table::{Self, Table};
    use aptos_std::type_info::{Self, TypeInfo};

    friend aptos_framework::aptos_account;
    friend aptos_framework::coin;
    friend aptos_framework::genesis;
    friend aptos_framework::multisig_account;
    friend aptos_framework::resource_account;
    friend aptos_framework::transaction_validation;

    #[event]
    struct KeyRotation has drop, store {
        account: address,
        old_authentication_key: vector<u8>,
        new_authentication_key: vector<u8>,
    }

    #[event]
    struct KeyRotationToPublicKey has drop, store {
        // The address of the account that is rotating its key
        account: address,
        // The bitmap of verified public keys.  This indicates which public keys have been verified by the account owner.
        // The bitmap is 4 bytes long, thus representing 32 bits.  Each bit represents whether a public key has been verified.
        // In the 32 bit representation, if a bit at index i (read left to right) is 1, then the public key at index i has
        // been verified in the public key.
        //
        // For example: [0x10100000,0x00000000,0x00000000,0x00000000] marks the first and third public keys in the multi-key as verified.
        //
        // Note: In the case of a single key, only the first bit is used.
        verified_public_key_bit_map: vector<u8>,
        // The scheme of the public key.
        public_key_scheme: u8,
        // The byte representation of the public key.
        public_key: vector<u8>,
        // The old authentication key on the account
        old_auth_key: vector<u8>,
        // The new authentication key which is the hash of [public_key, public_key_scheme]
        new_auth_key: vector<u8>,
    }

    /// Resource representing an account.
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/ed25519.move (L1-80)
```text
/// Contains functions for:
///
///  1. [Ed25519](https://en.wikipedia.org/wiki/EdDSA#Ed25519) digital signatures: i.e., EdDSA signatures over Edwards25519 curves with co-factor 8
///
module aptos_std::ed25519 {
    use std::bcs;
    use aptos_std::type_info::{Self, TypeInfo};
    use std::option::{Self, Option};

    //
    // Error codes
    //

    /// Wrong number of bytes were given as input when deserializing an Ed25519 public key.
    const E_WRONG_PUBKEY_SIZE: u64 = 1;

    /// Wrong number of bytes were given as input when deserializing an Ed25519 signature.
    const E_WRONG_SIGNATURE_SIZE: u64 = 2;

    //
    // Constants
    //

    /// The identifier of the Ed25519 signature scheme, which is used when deriving Aptos authentication keys by hashing
    /// it together with an Ed25519 public key.
    const SIGNATURE_SCHEME_ID: u8 = 0;

    /// The size of a serialized public key, in bytes.
    const PUBLIC_KEY_NUM_BYTES: u64 = 32;

    /// The size of a serialized signature, in bytes.
    const SIGNATURE_NUM_BYTES: u64 = 64;

    //
    // Structs
    //

    #[test_only]
    /// This struct holds an Ed25519 secret key that can be used to generate Ed25519 signatures during testing.
    struct SecretKey has drop {
        bytes: vector<u8>
    }

    /// A BCS-serializable message, which one can verify signatures on via `signature_verify_strict_t`
    struct SignedMessage<MessageType> has drop {
        type_info: TypeInfo,
        inner: MessageType,
    }

    /// An *unvalidated* Ed25519 public key: not necessarily an elliptic curve point, just a sequence of 32 bytes
    struct UnvalidatedPublicKey has copy, drop, store {
        bytes: vector<u8>
    }

    /// A *validated* Ed25519 public key: not necessarily a prime-order point, could be mixed-order, but will never be
    /// a small-order point.
    ///
    /// For now, this struct is not used in any verification functions, but it might be in the future.
    struct ValidatedPublicKey has copy, drop, store {
        bytes: vector<u8>
    }

    /// A purported Ed25519 signature that can be verified via `signature_verify_strict` or `signature_verify_strict_t`.
    struct Signature has copy, drop, store {
        bytes: vector<u8>
    }

    //
    // Functions
    //

    /// Parses the input 32 bytes as an *unvalidated* Ed25519 public key.
    public fun new_unvalidated_public_key_from_bytes(bytes: vector<u8>): UnvalidatedPublicKey {
        assert!(bytes.length() == PUBLIC_KEY_NUM_BYTES, std::error::invalid_argument(E_WRONG_PUBKEY_SIZE));
        UnvalidatedPublicKey { bytes }
    }

    /// Parses the input 32 bytes as a *validated* Ed25519 public key.
    public fun new_validated_public_key_from_bytes(bytes: vector<u8>): Option<ValidatedPublicKey> {
        if (public_key_validate_internal(bytes)) {
```

**File:** aptos-move/framework/cached-packages/src/lib.rs (L12-19)
```rust
#[cfg(unix)]
const HEAD_RELEASE_BUNDLE_BYTES: &[u8] = include_bytes!(concat!(env!("OUT_DIR"), "/head.mrb"));
#[cfg(windows)]
const HEAD_RELEASE_BUNDLE_BYTES: &[u8] = include_bytes!(concat!(env!("OUT_DIR"), "\\head.mrb"));

static HEAD_RELEASE_BUNDLE: Lazy<ReleaseBundle> = Lazy::new(|| {
    bcs::from_bytes::<ReleaseBundle>(HEAD_RELEASE_BUNDLE_BYTES).expect("bcs succeeds")
});
```
