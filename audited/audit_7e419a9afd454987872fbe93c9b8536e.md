# Audit Report

## Title
SpecBlock Bytecode Temporary Variable Remapping Vulnerability in Compiler Optimization Pipeline

## Summary
The `remap_vars_internal()` function fails to handle `SpecBlock` bytecode instructions, causing temporary variable references in specification blocks to become stale after the `eliminate_unused_vars` optimization pass in the livevar analysis pipeline. This results in compiler crashes or incorrect specification metadata generation.

## Finding Description

The Move compiler v2 pipeline includes a variable remapping optimization that renumbers temporary variables. The `remap_all_vars()` function delegates to `remap_vars_internal()` which uses pattern matching to remap temporaries in different bytecode instruction types. [1](#0-0) 

The implementation explicitly handles most bytecode types (Load, Assign, Call, Ret, Branch, Abort, Prop) but uses a catch-all pattern `_ => self` on line 816 that returns unhandled instructions unchanged. This means `SpecBlock` bytecode is NOT remapped.

`SpecBlock` bytecode contains `Spec` objects with `Condition` fields that have expressions (`Exp` type) which can reference temporaries via `ExpData::Temporary(NodeId, TempIndex)`: [2](#0-1) 

When `eliminate_unused_vars()` in the livevar analysis processor renumbers temporaries to eliminate gaps, it calls `remap_all_vars()` on all bytecode: [3](#0-2) 

Since `SpecBlock` is not handled by `remap_vars_internal()`, the spec block still references the OLD temporary indices while all other bytecode has been remapped to NEW indices.

Later, during file format generation, `gen_spec_block()` attempts to rewrite spec block temporaries by looking them up in the `self.temps` mapping: [4](#0-3) 

If a temporary was renumbered but the SpecBlock wasn't updated, line 1902 will panic with "temp has mapping" when the old temporary index is not found in `self.temps`.

## Impact Explanation

**Severity: Low to Medium**

This is primarily a **compiler tooling bug**, not a runtime execution vulnerability:

1. **No Consensus Impact**: SpecBlock bytecode is converted to `Nop` in the final on-chain bytecode and does not execute at runtime. The bug is deterministic (all nodes compiling the same source get the same result), so it cannot cause consensus splits.

2. **Compiler Crashes**: Attempting to compile Move modules with inline specification blocks after livevar optimization will cause compiler panics, preventing module compilation.

3. **Incorrect Verification**: If compilation succeeds in edge cases, the spec block metadata may reference wrong variables, potentially causing the Move Prover to produce incorrect verification results (false positives or false negatives).

4. **Limited Exploitability**: This affects off-chain compilation tooling, not on-chain execution. An attacker cannot directly exploit this to affect running validators or steal funds.

The impact is limited to development/testing workflows and verification correctness, not blockchain runtime security.

## Likelihood Explanation

**Likelihood: Low**

The bug only manifests when:
1. Move code contains inline specification blocks (using `spec { }` syntax within function bodies)
2. The livevar analysis optimization pass is enabled
3. Temporary variable renumbering actually occurs (unused temps exist)

Most production Move modules do not use inline spec blocks extensively, and the variable_coalescing pass protects spec block temporaries via pinning. However, `eliminate_unused_vars` does not respect pinning.

## Recommendation

Add explicit handling for `SpecBlock` in `remap_vars_internal()` to remap temporaries in the spec expressions:

```rust
// In stackless_bytecode.rs, remap_vars_internal function
match self {
    // ... existing cases ...
    SpecBlock(attr, spec) => {
        let new_spec = Self::remap_spec(func_target, &mut |idx| f(true, idx), spec);
        SpecBlock(attr, new_spec)
    },
    _ => self,
}
```

And implement a helper function to remap specs:

```rust
fn remap_spec<F>(func_target: &FunctionTarget<'_>, f: &mut F, spec: &Spec) -> Spec
where
    F: FnMut(TempIndex) -> TempIndex,
{
    let mut replacer = |node_id: NodeId, target: RewriteTarget| {
        if let RewriteTarget::Temporary(idx) = target {
            Some(ExpData::Temporary(node_id, f(idx)).into_exp())
        } else {
            None
        }
    };
    ExpRewriter::new(func_target.global_env(), &mut replacer)
        .rewrite_spec_descent(&SpecBlockTarget::Inline, spec)
        .1
}
```

## Proof of Concept

```move
module 0x1::test_spec_block_bug {
    public fun test_function(x: u64): u64 {
        let temp1 = x + 1;
        let _unused = 42; // Creates a gap in temp numbering
        let temp2 = temp1 * 2;
        
        spec {
            // This spec references temp2
            // After eliminate_unused_vars, temp2 will be renumbered
            // but this spec block won't be updated
            assert temp2 > 0;
        };
        
        temp2
    }
}
```

Compile with:
```bash
aptos move compile --save-metadata
```

Expected result: Compiler panic during file format generation when attempting to look up the old temp index in the spec block.

---

**Note**: While this is a legitimate bug in the compiler implementation, it does **not** meet the criteria for a Critical/High severity blockchain security vulnerability as specified in the original question, because:

1. It does not affect runtime consensus or execution
2. It does not affect the specific instruction types mentioned (branches, function calls, borrows) - those ARE correctly handled
3. SpecBlock is compiler metadata, not runtime bytecode
4. The impact is limited to off-chain tooling

The bug should be fixed for correctness and tooling reliability, but it does not represent an exploitable attack vector against the Aptos blockchain itself.

### Citations

**File:** third_party/move/move-model/bytecode/src/stackless_bytecode.rs (L765-818)
```rust
    fn remap_vars_internal<F>(self, func_target: &FunctionTarget<'_>, f: &mut F) -> Self
    where
        F: FnMut(bool, TempIndex) -> TempIndex,
    {
        use BorrowNode::*;
        use Bytecode::*;
        use Operation::*;
        let map = |is_src: bool, f: &mut F, v: Vec<TempIndex>| -> Vec<TempIndex> {
            v.into_iter().map(|i| f(is_src, i)).collect()
        };
        let map_abort = |f: &mut F, aa: Option<AbortAction>| {
            aa.map(|AbortAction(l, code)| AbortAction(l, f(false, code)))
        };
        let map_node = |f: &mut F, node: BorrowNode| match node {
            LocalRoot(tmp) => LocalRoot(f(true, tmp)),
            Reference(tmp) => Reference(f(true, tmp)),
            _ => node,
        };
        match self {
            Load(attr, dst, cons) => Load(attr, f(false, dst), cons),
            Assign(attr, dest, src, kind) => Assign(attr, f(false, dest), f(true, src), kind),
            Call(attr, _, WriteBack(node, edge), srcs, aa) => Call(
                attr,
                vec![],
                WriteBack(map_node(f, node), edge),
                map(true, f, srcs),
                map_abort(f, aa),
            ),
            Call(attr, dests, IsParent(node, edge), srcs, aa) => Call(
                attr,
                map(false, f, dests),
                IsParent(map_node(f, node), edge),
                map(true, f, srcs),
                map_abort(f, aa),
            ),
            Call(attr, dests, op, srcs, aa) => Call(
                attr,
                map(false, f, dests),
                op,
                map(true, f, srcs),
                map_abort(f, aa),
            ),
            Ret(attr, rets) => Ret(attr, map(true, f, rets)),
            Branch(attr, if_label, else_label, cond) => {
                Branch(attr, if_label, else_label, f(true, cond))
            },
            Abort(attr, cond0, cond1) => Abort(attr, f(true, cond0), cond1.map(|c| f(true, c))),
            Prop(attr, kind, exp) => {
                let new_exp = Bytecode::remap_exp(func_target, &mut |idx| f(true, idx), exp);
                Prop(attr, kind, new_exp)
            },
            _ => self,
        }
    }
```

**File:** third_party/move/move-model/src/ast.rs (L318-324)
```rust
pub struct Condition {
    pub loc: Loc,
    pub kind: ConditionKind,
    pub properties: PropertyBag,
    pub exp: Exp,
    pub additional_exps: Vec<Exp>,
}
```

**File:** third_party/move/move-model/bytecode/src/livevar_analysis.rs (L157-185)
```rust
    fn eliminate_unused_vars(
        func_target: &FunctionTarget,
        code: Vec<Bytecode>,
    ) -> (Vec<Bytecode>, Vec<Type>, BTreeMap<TempIndex, TempIndex>) {
        let mut new_code = vec![];
        let mut new_vars = vec![];
        let mut remap = BTreeMap::new();
        // Do not change user declared vars, so populate remap info with them first.
        for local in 0..func_target.get_user_local_count() {
            let ty = func_target.get_local_type(local);
            new_vars.push(ty.clone());
            remap.insert(local, local);
        }
        let mut transform_local = |local: TempIndex| {
            if let Some(new_idx) = remap.get(&local) {
                *new_idx
            } else {
                let new_idx = new_vars.len();
                let ty = func_target.get_local_type(local);
                new_vars.push(ty.clone());
                remap.insert(local, new_idx);
                new_idx
            }
        };
        for bytecode in code {
            new_code.push(bytecode.remap_all_vars(func_target, &mut transform_local));
        }
        (new_code, new_vars, remap)
    }
```

**File:** third_party/move/move-compiler-v2/src/file_format_generator/function_generator.rs (L1896-1914)
```rust
    fn gen_spec_block(&mut self, ctx: &BytecodeContext, spec: &Spec) {
        let mut replacer = |id: NodeId, target: RewriteTarget| {
            if let RewriteTarget::Temporary(temp) = target {
                Some(
                    ExpData::Temporary(
                        id,
                        self.temps.get(&temp).expect("temp has mapping").local as TempIndex,
                    )
                    .into_exp(),
                )
            } else {
                None
            }
        };
        let (_, spec) = ExpRewriter::new(ctx.fun_ctx.module.env, &mut replacer)
            .rewrite_spec_descent(&SpecBlockTarget::Inline, spec);
        self.spec_blocks.insert(self.code.len() as CodeOffset, spec);
        self.emit(FF::Bytecode::Nop)
    }
```
