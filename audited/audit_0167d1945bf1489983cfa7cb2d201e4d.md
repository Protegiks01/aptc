# Audit Report

## Title
Permanent Fund Loss via Unvalidated Transfers to Reserved System Addresses (0x0, 0x1)

## Summary
The `coin::transfer` function and its SDK wrapper `aptos_coin_transfer()` do not validate that the recipient address is not a reserved system address (0x0, 0x1), allowing users to permanently lock funds by transferring to these addresses. While account creation explicitly blocks reserved addresses, the coin transfer flow bypasses this protection by directly creating primary fungible stores without validation.

## Finding Description
The vulnerability exists in the coin transfer execution path that bypasses normal account creation checks: [1](#0-0) 

This SDK function creates a transaction payload that directly calls the Move `coin::transfer` function: [2](#0-1) 

The `coin::transfer` function withdraws from the sender and deposits to the recipient without any address validation. It delegates to `primary_fungible_store::deposit`: [3](#0-2) 

This function calls `ensure_primary_store_exists`, which creates a primary fungible store for ANY address including reserved system addresses: [4](#0-3) 

The critical issue is that `object::create_user_derived_object` does NOT validate that the owner address is not reserved: [5](#0-4) 

While the framework explicitly blocks account creation for reserved addresses: [6](#0-5) 

This protection is bypassed because primary fungible stores are created directly via the object model without requiring an Account resource. Once funds are transferred to a primary store owned by 0x0 or 0x1, they cannot be recovered because:

1. No Account resource can be created for these addresses (blocked by `ECANNOT_RESERVED_ADDRESS`)
2. Creating a signer for these addresses requires `create_signer`, which is restricted to framework friend modules
3. No recovery mechanism exists in the framework to withdraw from arbitrary primary stores
4. Even the framework would need to deploy new code and upgrade to recover these funds

## Impact Explanation
**Critical Severity** - This vulnerability qualifies as "Permanent freezing of funds (requires hardfork)" per the Aptos bug bounty program:

- **Permanent Fund Loss**: Any user who transfers coins to 0x0 or 0x1 will permanently lose those funds
- **No Recovery Path**: The funds are locked in a primary fungible store with no mechanism to withdraw them
- **Requires Hardfork**: Recovery would require framework changes and potentially a network upgrade
- **Affects All Users**: Any user can accidentally or intentionally trigger this issue
- **Bypass of Security Invariant**: Violates "Access Control: System addresses must be protected"

The impact is potentially in the millions of dollars if multiple users are affected, and the funds remain permanently inaccessible without a coordinated network upgrade.

## Likelihood Explanation
**High Likelihood**:

- **Easy to Execute**: Single function call with no special permissions required
- **No Technical Barrier**: Available through SDK and can be called directly
- **User Confusion**: Users might accidentally use 0x0 thinking it's an "invalid" address that will fail
- **No Warning**: SDK and Move function provide no validation or warning
- **Direct Exposure**: The vulnerable function is part of the primary coin transfer API

Accidental triggering is likely through:
- Testing/development mistakes using 0x0 as a placeholder
- Address typos or parsing errors
- Integration bugs in wallet software
- Deliberate griefing attacks

## Recommendation
Add validation in `coin::transfer` to reject reserved system addresses before attempting the transfer:

```move
public entry fun transfer<CoinType>(
    from: &signer, to: address, amount: u64
) acquires CoinConversionMap, CoinInfo {
    // Add validation for reserved addresses
    assert!(
        to != @vm_reserved && to != @aptos_framework && to != @aptos_token,
        error::invalid_argument(ECANNOT_TRANSFER_TO_RESERVED_ADDRESS)
    );
    
    let fa =
        primary_fungible_store::withdraw(
            from, ensure_paired_metadata<CoinType>(), amount
        );
    primary_fungible_store::deposit(to, fa);
}
```

Additionally, add validation in `primary_fungible_store::deposit` as defense-in-depth:

```move
public fun deposit(owner: address, fa: FungibleAsset) acquires DeriveRefPod {
    // Validate owner is not a reserved address
    assert!(
        owner != @vm_reserved && owner != @aptos_framework,
        error::invalid_argument(ECANNOT_DEPOSIT_TO_RESERVED_ADDRESS)
    );
    
    let metadata = fa.asset_metadata();
    let store = ensure_primary_store_exists(owner, metadata);
    dispatchable_fungible_asset::deposit(store, fa);
}
```

## Proof of Concept

```move
#[test(sender = @0x100, framework = @0x1)]
#[expected_failure(abort_code = 0x10005)] // Should fail but currently succeeds
fun test_transfer_to_vm_reserved_fails(sender: &signer, framework: &signer) {
    use aptos_framework::aptos_coin;
    use aptos_framework::coin;
    use aptos_framework::account;
    
    // Initialize AptosCoin
    let (burn_cap, mint_cap) = aptos_coin::initialize_for_test(framework);
    
    // Create sender account and fund it
    account::create_account_for_test(signer::address_of(sender));
    let coins = coin::mint(1000000, &mint_cap);
    coin::deposit(signer::address_of(sender), coins);
    
    // Attempt to transfer to @vm_reserved (0x0) - should fail but succeeds
    coin::transfer<aptos_coin::AptosCoin>(sender, @vm_reserved, 100000);
    
    // Funds are now permanently locked at 0x0's primary fungible store
    // No way to recover them!
    
    coin::destroy_burn_cap(burn_cap);
    coin::destroy_mint_cap(mint_cap);
}
```

The test demonstrates that transfers to `@vm_reserved` (0x0) succeed when they should fail, resulting in permanent fund loss.

## Notes

This vulnerability affects all coin types, not just AptosCoin, as the validation gap exists in the generic `coin::transfer<CoinType>` function. The issue is particularly concerning because:

1. The SDK function `aptos_coin_transfer()` is commonly used and provides no client-side validation
2. The higher-level `aptos_account::transfer()` function DOES create accounts and would catch this, but direct `coin::transfer` calls bypass it
3. The fungible asset migration makes this worse as primary stores can be created for any address
4. There's no warning or error message to users about the permanent loss

Immediate mitigation: Add address validation at multiple layers (SDK, Move function, primary store creation) to prevent permanent fund loss.

### Citations

**File:** aptos-move/framework/cached-packages/src/aptos_stdlib.rs (L19-21)
```rust
pub fn aptos_coin_transfer(to: AccountAddress, amount: u64) -> TransactionPayload {
    coin_transfer(AptosCoinType::type_tag(), to, amount)
}
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L1138-1146)
```text
    public entry fun transfer<CoinType>(
        from: &signer, to: address, amount: u64
    ) acquires CoinConversionMap, CoinInfo {
        let fa =
            primary_fungible_store::withdraw(
                from, ensure_paired_metadata<CoinType>(), amount
            );
        primary_fungible_store::deposit(to, fa);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/primary_fungible_store.move (L75-88)
```text
    public fun create_primary_store<T: key>(
        owner_addr: address,
        metadata: Object<T>,
    ): Object<FungibleStore> acquires DeriveRefPod {
        let metadata_addr = metadata.object_address();
        object::address_to_object<Metadata>(metadata_addr);
        let derive_ref = &borrow_global<DeriveRefPod>(metadata_addr).metadata_derive_ref;
        let constructor_ref = &object::create_user_derived_object(owner_addr, derive_ref);
        // Disable ungated transfer as deterministic stores shouldn't be transferrable.
        let transfer_ref = &constructor_ref.generate_transfer_ref();
        transfer_ref.disable_ungated_transfer();

        fungible_asset::create_store(constructor_ref, metadata)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/primary_fungible_store.move (L195-199)
```text
    public fun deposit(owner: address, fa: FungibleAsset) acquires DeriveRefPod {
        let metadata = fa.asset_metadata();
        let store = ensure_primary_store_exists(owner, metadata);
        dispatchable_fungible_asset::deposit(store, fa);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/object.move (L259-262)
```text
    public(friend) fun create_user_derived_object(creator_address: address, derive_ref: &DeriveRef): ConstructorRef {
        let obj_addr = create_user_derived_object_address(creator_address, derive_ref.self);
        create_object_internal(creator_address, obj_addr, false)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L276-284)
```text
    public fun create_account_if_does_not_exist(account_address: address) {
        if (!resource_exists_at(account_address)) {
            assert!(
                account_address != @vm_reserved && account_address != @aptos_framework && account_address != @aptos_token,
                error::invalid_argument(ECANNOT_RESERVED_ADDRESS)
            );
            create_account_unchecked(account_address);
        }
    }
```
