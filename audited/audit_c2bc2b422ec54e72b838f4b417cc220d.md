# Audit Report

## Title
Indexer gRPC Data Service Address Spoofing Enables Service Registry Poisoning and Routing Confusion

## Summary
The `self_advertised_address` field in the indexer-grpc-data-service-v2 configuration accepts arbitrary values without validating that they match the actual service endpoint. This allows malicious data services to poison the gRPC manager's service registry with false metadata and non-existent addresses, causing client connection failures and incorrect load balancing decisions.

## Finding Description

The vulnerability exists in how the indexer gRPC infrastructure handles service registration and routing. When a data service sends heartbeat messages to the gRPC manager, it includes a `self_advertised_address` field that identifies where clients should connect to reach the service. [1](#0-0) 

The gRPC manager accepts this address without validating that it matches the actual source of the heartbeat connection: [2](#0-1) 

The address is then used as the key in the service registry and to store service metadata: [3](#0-2) 

**Attack Scenario 1: Metadata Poisoning**
1. Legitimate service at `http://legit:50051` sends heartbeat with 100 active streams
2. Attacker deploys service at `http://attacker:50052` with config `self_advertised_address: "http://legit:50051"`
3. Attacker sends heartbeat claiming 0 active streams
4. Manager updates the registry entry for `http://legit:50051` with attacker's false metadata (line 503)
5. When selecting services, the manager uses the most recent metadata (.back()) which contains the attacker's false information [4](#0-3) 

**Attack Scenario 2: Service Denial via Non-Existent Addresses**
1. Attacker registers multiple services advertising non-existent addresses (`http://fake1:50051`, `http://fake2:50051`, etc.)
2. Manager stores these in its service registry
3. Clients requesting data services receive these non-existent addresses
4. Clients fail to connect, experiencing service unavailability [5](#0-4) 

The returned address is used directly by the gateway to route client requests: [6](#0-5) 

No validation exists anywhere in the codebase to verify that the advertised address matches the connection source (confirmed via grep search showing no usage of `remote_addr()` in the indexer-grpc codebase).

## Impact Explanation

This vulnerability meets **Medium Severity** criteria per the Aptos bug bounty program:
- **State inconsistencies requiring intervention**: False metadata pollutes the service registry, requiring manual cleanup or service restarts to restore correct routing
- Service availability disruption affecting indexer clients (applications, wallets, explorers)

While this does not affect consensus, validator operations, or funds directly, it degrades the reliability of the critical indexer infrastructure that applications depend on for blockchain data access. The issue could also escalate to **High Severity** if it causes significant API crashes or prolonged service outages.

## Likelihood Explanation

**High Likelihood:**
- Exploitability: Trivial - attacker only needs to modify a single configuration field
- No special privileges required - any party can run an indexer data service
- Attack can be executed remotely without physical access
- No rate limiting or validation exists to prevent the attack
- The attack is stealthy - false metadata appears legitimate to the manager

The attack is particularly likely in production environments where multiple data service operators exist, as coordination failures or malicious operators can easily introduce incorrect addresses.

## Recommendation

Implement validation to ensure the advertised address matches the actual connection source:

```rust
// In ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs
async fn heartbeat(
    &self,
    request: Request<HeartbeatRequest>,
) -> Result<Response<HeartbeatResponse>, Status> {
    // Extract the actual remote address
    let remote_addr = request.remote_addr()
        .ok_or_else(|| Status::internal("Cannot determine remote address"))?;
    
    let request = request.into_inner();
    if let Some(service_info) = request.service_info {
        if let Some(address) = service_info.address {
            // Validate advertised address matches connection source
            if let Ok(advertised_url) = url::Url::parse(&address) {
                if let Some(advertised_host) = advertised_url.host_str() {
                    let remote_host = remote_addr.ip().to_string();
                    if advertised_host != remote_host && 
                       !is_localhost(&advertised_host, &remote_host) {
                        return Err(Status::permission_denied(
                            "Advertised address does not match connection source"
                        ));
                    }
                }
            }
            
            if let Some(info) = service_info.info {
                return self
                    .handle_heartbeat(address, info)
                    .await
                    .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
            }
        }
    }
    Err(Status::invalid_argument("Bad request."))
}
```

Additionally, implement health checks that verify bidirectional connectivity before accepting service registrations.

## Proof of Concept

```rust
// Test demonstrating the vulnerability
// Place in ecosystem/indexer-grpc/indexer-grpc-manager/tests/address_spoofing_test.rs

#[tokio::test]
async fn test_address_spoofing_attack() {
    use aptos_protos::indexer::v1::{
        HeartbeatRequest, ServiceInfo, service_info::Info,
        LiveDataServiceInfo, StreamInfo,
    };
    use aptos_indexer_grpc_utils::timestamp_now_proto;
    
    // Setup manager
    let metadata_manager = Arc::new(MetadataManager::new(
        1, // chain_id
        "http://manager:50051".to_string(),
        vec![],
        vec![],
        None,
    ));
    
    // Legitimate service sends heartbeat
    let legit_address = "http://legitimate-service:50051".to_string();
    let legit_info = Info::LiveDataServiceInfo(LiveDataServiceInfo {
        chain_id: 1,
        timestamp: Some(timestamp_now_proto()),
        known_latest_version: Some(1000),
        stream_info: Some(StreamInfo {
            active_streams: vec![/* 100 streams */],
        }),
        min_servable_version: Some(0),
    });
    metadata_manager.handle_heartbeat(legit_address.clone(), legit_info).unwrap();
    
    // Attacker sends spoofed heartbeat claiming same address
    let attacker_info = Info::LiveDataServiceInfo(LiveDataServiceInfo {
        chain_id: 1,
        timestamp: Some(timestamp_now_proto()),
        known_latest_version: Some(1000),
        stream_info: Some(StreamInfo {
            active_streams: vec![], // Claims 0 streams (false)
        }),
        min_servable_version: Some(0),
    });
    metadata_manager.handle_heartbeat(legit_address.clone(), attacker_info).unwrap();
    
    // Verify: The most recent state contains attacker's false metadata
    let services = metadata_manager.get_live_data_services_info();
    let service_state = services.get(&legit_address).unwrap().back().unwrap();
    assert_eq!(service_state.stream_info.as_ref().unwrap().active_streams.len(), 0);
    // BUG: Manager now believes legitimate service has 0 streams due to attacker's spoofed heartbeat
}
```

**Notes**
- This vulnerability is in the indexer infrastructure layer, not the core consensus protocol
- It does not directly affect consensus safety, validator operations, or blockchain state integrity
- The impact is limited to indexer service availability and data access reliability
- Applications relying on indexer services for blockchain data would experience degraded service
- The vulnerability enables routing confusion rather than direct traffic interception, as the manager creates health check clients to the advertised addresses themselves

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/config.rs (L91-91)
```rust
    pub(crate) self_advertised_address: String,
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L71-88)
```rust
    fn pick_live_data_service(&self, starting_version: u64) -> Option<String> {
        let mut candidates = vec![];
        for candidate in self.metadata_manager.get_live_data_services_info() {
            if let Some(info) = candidate.1.back().as_ref() {
                // TODO(grao): Handle the case when the requested starting version is beyond the
                // latest version.
                if info.min_servable_version.is_none()
                    || starting_version < info.min_servable_version.unwrap()
                {
                    continue;
                }
                let num_active_streams = info.stream_info.as_ref().unwrap().active_streams.len();
                candidates.push((candidate.0, num_active_streams));
            }
        }

        Self::pick_data_service_from_candidate(candidates)
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L110-127)
```rust
    async fn heartbeat(
        &self,
        request: Request<HeartbeatRequest>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        let request = request.into_inner();
        if let Some(service_info) = request.service_info {
            if let Some(address) = service_info.address {
                if let Some(info) = service_info.info {
                    return self
                        .handle_heartbeat(address, info)
                        .await
                        .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
                }
            }
        }

        Err(Status::invalid_argument("Bad request."))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L148-196)
```rust
    async fn get_data_service_for_request(
        &self,
        request: Request<GetDataServiceForRequestRequest>,
    ) -> Result<Response<GetDataServiceForRequestResponse>, Status> {
        let request = request.into_inner();

        if request.user_request.is_none()
            || request
                .user_request
                .as_ref()
                .unwrap()
                .starting_version
                .is_none()
        {
            let candidates = self.metadata_manager.get_live_data_services_info();
            if let Some(candidate) = candidates.iter().next() {
                let data_service_address = candidate.0.clone();
                return Ok(Response::new(GetDataServiceForRequestResponse {
                    data_service_address,
                }));
            } else {
                return Err(Status::internal(
                    "Cannot find a data service instance to serve the provided request.",
                ));
            }
        }

        let starting_version = request.user_request.unwrap().starting_version();

        let data_service_address =
            // TODO(grao): Use a simple strategy for now. Consider to make it smarter in the
            // future.
            if let Some(address) = self.pick_live_data_service(starting_version) {
                COUNTER.with_label_values(&["live_data_service_picked"]).inc();
                address
            } else if let Some(address) = self.pick_historical_data_service(starting_version).await {
                COUNTER.with_label_values(&["historical_data_service_picked"]).inc();
                address
            } else {
                COUNTER.with_label_values(&["failed_to_pick_data_service"]).inc();
                return Err(Status::internal(
                    "Cannot find a data service instance to serve the provided request.",
                ));
            };

        Ok(Response::new(GetDataServiceForRequestResponse {
            data_service_address,
        }))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L489-509)
```rust
    fn handle_live_data_service_info(
        &self,
        address: GrpcAddress,
        mut info: LiveDataServiceInfo,
    ) -> Result<()> {
        let mut entry = self
            .live_data_services
            .entry(address.clone())
            .or_insert(LiveDataService::new(address));
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-gateway/src/gateway.rs (L143-152)
```rust
    let response: GetDataServiceForRequestResponse = client
        .get_data_service_for_request(grpc_manager_request)
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?
        .into_inner();

    let url = Url::from_str(&response.data_service_address).unwrap();
    let mut req = Request::from_parts(head, body);
    req.extensions_mut().insert(url);
    Ok(next.run(req).await)
```
