# Audit Report

## Title
DKG Validator Crash via Panic in Multi-Exponentiation Functions Causes Temporary Liveness Disruption

## Summary
The DKG protocol's transcript verification code contains panic conditions in `g1_multi_exp` and `g2_multi_exp` functions that cause immediate validator process termination when triggered. While validators can recover through restart, this creates a window of availability loss and potential denial-of-service vector during DKG execution.

## Finding Description
The DKG (Distributed Key Generation) protocol performs cryptographic verification of transcripts using multi-exponentiation operations. The utility functions `g1_multi_exp` and `g2_multi_exp` contain explicit panic conditions when the number of bases does not match the number of scalars: [1](#0-0) [2](#0-1) 

These functions are called during transcript verification in the low-degree test phase: [3](#0-2) [4](#0-3) 

The critical issue is that the length validation uses `debug_assert_eq!` which is **only active in debug builds**: [5](#0-4) [6](#0-5) 

When a panic occurs, the crash handler terminates the entire validator process: [7](#0-6) 

The panic propagates through the verification call chain: [8](#0-7) [9](#0-8) [10](#0-9) 

## Impact Explanation
This issue qualifies as **High Severity** under the Aptos bug bounty criteria because it causes:

1. **Validator node crashes** requiring restart - explicitly listed as High Severity
2. **Temporary liveness disruption** during DKG execution - if multiple validators crash simultaneously, the network cannot complete DKG until they restart
3. **Availability degradation** - validators are offline during the crash-restart cycle

While not permanent (validators can restart and resume), this creates operational risk during the critical DKG phase when the network is establishing cryptographic parameters for the next epoch. The crash-restart cycle delays DKG completion and could prevent timely epoch transitions.

## Likelihood Explanation
**Likelihood: Medium**

The panic can be triggered if:
1. There exists any implementation bug in the polynomial evaluation, FFT, or domain calculation logic that causes length mismatches
2. The batch evaluation domain configuration is inconsistent with the transcript structure
3. Edge cases in weighted configuration calculations produce unexpected array sizes

While the code appears structurally sound, the reliance on `debug_assert_eq!` instead of runtime checks means production validators lack the safety net present during development. Any latent bug in the complex polynomial arithmetic would only manifest in production as a crash rather than a graceful error.

## Recommendation

**Replace debug assertions with runtime checks and return Result types:**

```rust
// In low_degree_test.rs, replace:
debug_assert_eq!(evals.len(), v_times_f.len());
let zero = g1_multi_exp(evals.as_ref(), v_times_f.as_slice());

// With:
if evals.len() != v_times_f.len() {
    bail!("Length mismatch in low-degree test: expected {}, got {}", 
          evals.len(), v_times_f.len());
}
let zero = g1_multi_exp(evals.as_ref(), v_times_f.as_slice());
```

**Add length validation in multi_exp functions before panic:**

```rust
pub fn g1_multi_exp(bases: &[G1Projective], scalars: &[blstrs::Scalar]) -> G1Projective {
    if bases.len() != scalars.len() {
        // Log the error for debugging
        error!(
            "g1_multi_exp length mismatch: bases={}, scalars={}",
            bases.len(),
            scalars.len()
        );
        // Return identity instead of panicking
        return G1Projective::identity();
    }
    // ... rest of function
}
```

**Add catch_unwind protection in transcript verification:**

```rust
use std::panic::catch_unwind;

// In transcript_aggregation/mod.rs:
let verification_result = catch_unwind(AssertUnwindSafe(|| {
    S::verify_transcript(&self.dkg_pub_params, &transcript)
}));

match verification_result {
    Ok(Ok(())) => { /* success */ },
    Ok(Err(e)) => return Err(anyhow!("Verification failed: {e}")),
    Err(_) => return Err(anyhow!("Verification panicked - malformed transcript")),
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod panic_recovery_test {
    use super::*;
    use crate::pvss::LowDegreeTest;
    use blstrs::{G1Projective, Scalar};
    
    #[test]
    #[should_panic(expected = "blstrs's multiexp has heisenbugs")]
    fn test_mismatched_multiexp_panics() {
        // Create arrays with mismatched lengths
        let bases = vec![G1Projective::identity(); 10];
        let scalars = vec![Scalar::ZERO; 9]; // One less scalar
        
        // This should panic in both debug and release modes
        let _ = g1_multi_exp(&bases, &scalars);
    }
    
    #[test]
    fn test_ldt_with_inconsistent_config() {
        // Simulate a configuration mismatch that could occur
        // if the batch evaluation domain and threshold config are inconsistent
        let mut rng = rand::thread_rng();
        let batch_dom = BatchEvaluationDomain::new(16);
        
        // Create an LDT with parameters that might cause length mismatch
        let ldt = LowDegreeTest::new(
            random_scalars(8, &mut rng),
            8,  // threshold
            17, // n (intentionally off-by-one)
            true,
            &batch_dom,
        );
        
        // This could panic if the length calculations are inconsistent
        let evals = vec![G1Projective::identity(); 16];
        let result = ldt.unwrap().low_degree_test_on_g1(&evals);
        
        // In release mode, this might panic instead of returning an error
        assert!(result.is_err());
    }
}
```

## Notes

The vulnerability is architectural rather than directly exploitable - it represents a failure mode where internal invariant violations cause process termination rather than graceful degradation. While the protocol can recover through restart, the crash-restart cycle creates unnecessary availability loss during the critical DKG phase. The fix should prioritize graceful error handling over defensive panics to maintain validator uptime and protocol liveness.

### Citations

**File:** crates/aptos-dkg/src/utils/mod.rs (L58-72)
```rust
pub fn g1_multi_exp(bases: &[G1Projective], scalars: &[blstrs::Scalar]) -> G1Projective {
    if bases.len() != scalars.len() {
        panic!(
            "blstrs's multiexp has heisenbugs when the # of bases != # of scalars ({} != {})",
            bases.len(),
            scalars.len()
        );
    }

    match bases.len() {
        0 => G1Projective::identity(),
        1 => bases[0].mul(scalars[0]),
        _ => G1Projective::multi_exp(bases, scalars),
    }
}
```

**File:** crates/aptos-dkg/src/utils/mod.rs (L75-88)
```rust
pub fn g2_multi_exp(bases: &[G2Projective], scalars: &[blstrs::Scalar]) -> G2Projective {
    if bases.len() != scalars.len() {
        panic!(
            "blstrs's multiexp has heisenbugs when the # of bases != # of scalars ({} != {})",
            bases.len(),
            scalars.len()
        );
    }
    match bases.len() {
        0 => G2Projective::identity(),
        1 => bases[0].mul(scalars[0]),
        _ => G2Projective::multi_exp(bases, scalars),
    }
}
```

**File:** crates/aptos-dkg/src/pvss/low_degree_test.rs (L141-161)
```rust
    pub fn low_degree_test_on_g1(self, evals: &Vec<G1Projective>) -> anyhow::Result<()> {
        if evals.len() != self.n {
            bail!("Expected {} evaluations; got {}", self.n, evals.len())
        }

        if self.t == self.n {
            return Ok(());
        }

        let v_times_f = self.dual_code_word();

        debug_assert_eq!(evals.len(), v_times_f.len());
        let zero = g1_multi_exp(evals.as_ref(), v_times_f.as_slice());

        (zero == G1Projective::identity())
            .then_some(())
            .context(format!(
                "the LDT G1 multiexp should return zero, but instead returned {}",
                zero
            ))
    }
```

**File:** crates/aptos-dkg/src/pvss/low_degree_test.rs (L164-184)
```rust
    pub fn low_degree_test_on_g2(self, evals: &Vec<G2Projective>) -> anyhow::Result<()> {
        if evals.len() != self.n {
            bail!("Expected {} evaluations; got {}", self.n, evals.len())
        }

        if self.t == self.n {
            return Ok(());
        }

        let v_times_f = self.dual_code_word();

        debug_assert_eq!(evals.len(), v_times_f.len());
        let zero = g2_multi_exp(evals.as_ref(), v_times_f.as_slice());

        (zero == G2Projective::identity())
            .then_some(())
            .context(format!(
                "the LDT G2 multiexp should return zero, but instead returned {}",
                zero
            ))
    }
```

**File:** crates/crash-handler/src/lib.rs (L26-58)
```rust
pub fn setup_panic_handler() {
    panic::set_hook(Box::new(move |pi: &PanicHookInfo<'_>| {
        handle_panic(pi);
    }));
}

// Formats and logs panic information
fn handle_panic(panic_info: &PanicHookInfo<'_>) {
    // The Display formatter for a PanicHookInfo contains the message, payload and location.
    let details = format!("{}", panic_info);
    let backtrace = format!("{:#?}", Backtrace::new());

    let info = CrashInfo { details, backtrace };
    let crash_info = toml::to_string_pretty(&info).unwrap();
    error!("{}", crash_info);
    // TODO / HACK ALARM: Write crash info synchronously via eprintln! to ensure it is written before the process exits which error! doesn't guarantee.
    // This is a workaround until https://github.com/aptos-labs/aptos-core/issues/2038 is resolved.
    eprintln!("{}", crash_info);

    // Wait till the logs have been flushed
    aptos_logger::flush();

    // Do not kill the process if the panics happened at move-bytecode-verifier.
    // This is safe because the `state::get_state()` uses a thread_local for storing states. Thus the state can only be mutated to VERIFIER by the thread that's running the bytecode verifier.
    //
    // TODO: once `can_unwind` is stable, we should assert it. See https://github.com/rust-lang/rust/issues/92988.
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
}
```

**File:** dkg/src/transcript_aggregation/mod.rs (L96-101)
```rust
        S::verify_transcript_extra(&transcript, &self.epoch_state.verifier, false, Some(sender))
            .context("extra verification failed")?;

        S::verify_transcript(&self.dkg_pub_params, &transcript).map_err(|e| {
            anyhow!("[DKG] adding peer transcript failed with trx verification failure: {e}")
        })?;
```

**File:** types/src/dkg/real_dkg/mod.rs (L332-377)
```rust
    fn verify_transcript(
        params: &Self::PublicParams,
        trx: &Self::Transcript,
    ) -> anyhow::Result<()> {
        // Verify dealer indices are valid.
        let dealers = trx
            .main
            .get_dealers()
            .iter()
            .map(|player| player.id)
            .collect::<Vec<usize>>();
        let num_validators = params.session_metadata.dealer_validator_set.len();
        ensure!(
            dealers.iter().all(|id| *id < num_validators),
            "real_dkg::verify_transcript failed with invalid dealer index."
        );

        let all_eks = params.pvss_config.eks.clone();

        let addresses = params.verifier.get_ordered_account_addresses();
        let dealers_addresses = dealers
            .iter()
            .filter_map(|&pos| addresses.get(pos))
            .cloned()
            .collect::<Vec<_>>();

        let spks = dealers_addresses
            .iter()
            .filter_map(|author| params.verifier.get_public_key(author))
            .collect::<Vec<_>>();

        let aux = dealers_addresses
            .iter()
            .map(|address| (params.pvss_config.epoch, address))
            .collect::<Vec<_>>();

        trx.main.verify(
            &params.pvss_config.wconfig,
            &params.pvss_config.pp,
            &spks,
            &all_eks,
            &aux,
        )?;

        // Verify fast path is present if and only if fast_wconfig is present.
        ensure!(
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L104-112)
```rust
        // Deserialize transcript and verify it.
        let pub_params = DefaultDKG::new_public_params(&in_progress_session_state.metadata);
        let transcript = bcs::from_bytes::<<DefaultDKG as DKGTrait>::Transcript>(
            dkg_node.transcript_bytes.as_slice(),
        )
        .map_err(|_| Expected(TranscriptDeserializationFailed))?;

        DefaultDKG::verify_transcript(&pub_params, &transcript)
            .map_err(|_| Expected(TranscriptVerificationFailed))?;
```
