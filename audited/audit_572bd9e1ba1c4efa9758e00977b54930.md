# Audit Report

## Title
Tuple Freeze Operations Bypass for Function Return Values Allowing Type Safety Violation

## Summary
The `freeze_tuple_exp()` function in the Move model builder fails to insert required freeze operations when a function returns a tuple containing mutable references that need conversion to immutable references. This occurs because the function only handles direct tuple constructions (`Operation::Tuple`) but not function call expressions (`Operation::MoveFunction`/`Operation::SpecFunction`), allowing mutable references to leak through tuple destructuring and violating Move's type safety guarantees. [1](#0-0) 

## Finding Description

The vulnerability exists in the Move compiler v2's expression builder, which constructs the Abstract Syntax Tree (AST) used for bytecode generation. When assigning or passing tuples between contexts with different reference mutabilities, the `freeze_tuple_exp()` function is responsible for inserting `Freeze` operations to convert mutable references (`&mut T`) to immutable references (`&T`).

The critical flaw is on line 4916: [2](#0-1) 

This pattern match only succeeds when the operation is `Operation::Tuple` (direct tuple construction like `(x, y)`). However, when a function returns a tuple, the expression is `ExpData::Call(_, Operation::MoveFunction(...), ...)`, causing the pattern match to fail. The function then returns the original expression without applying any freeze operations.

**Attack Path:**

1. Attacker deploys a Move module with a function like:
```move
public fun get_mut_refs(): (&mut u64, &mut u64) {
    (&mut GLOBAL_VALUE1, &mut GLOBAL_VALUE2)
}
```

2. Attacker calls this function and destructures the result into variables typed as immutable references:
```move
let (x, y): (&u64, &u64) = get_mut_refs();
```

3. Move's type system permits this via subtyping (`&mut T` is a subtype of `&T`) and expects the compiler to insert freeze operations.

4. However, `freeze_tuple_exp()` fails to insert freeze operations because the expression is a function call, not a tuple construction.

5. The bytecode generator creates bytecode without freeze instructions: [3](#0-2) 

The `maybe_convert()` function only handles single references, not tuples. The `gen_tuple()` function at line 1400 doesn't add freeze operations either: [4](#0-3) 

6. Variables typed as `&u64` now contain `&mut u64` references, violating type safety.

**Evidence of Known Issue:**

Test files explicitly document this as unhandled: [5](#0-4) [6](#0-5) 

**Invariant Violations:**

This breaks multiple critical invariants:

1. **Move VM Safety**: Variables must have correct runtime types matching their declared types
2. **Deterministic Execution**: If different validators' compilers handle this differently, consensus diverges
3. **Type System Integrity**: Immutability guarantees are violated, allowing mutations through supposedly read-only references

## Impact Explanation

**Severity: Medium to High**

This vulnerability enables type safety violations in Move code, which has several potential impacts:

1. **Type Safety Violation** (Medium): Variables typed as immutable references actually contain mutable references, breaking Move's fundamental safety guarantees. This could allow:
   - Unauthorized mutations of supposedly read-only data
   - Bypassing access control checks that assume immutability
   - Violating protocol invariants that depend on read-only semantics

2. **Consensus Risk** (High): If bytecode verification catches this issue inconsistently across different validator implementations or compiler versions, it could cause:
   - Transaction acceptance divergence between validators
   - State inconsistencies requiring intervention
   - Potential chain splits if some validators accept malformed modules

3. **State Consistency** (Medium): If the malformed bytecode passes verification, executing it could lead to:
   - Unpredictable behavior when mutable references are used in immutable contexts
   - State corruption if the VM's type assumptions are violated
   - Potential for exploiting the type confusion to manipulate blockchain state

This meets the **Medium Severity** criteria ($10,000): "State inconsistencies requiring intervention" and potentially **High Severity** ($50,000): "Significant protocol violations."

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability is exploitable under these conditions:

1. **Attacker Requirements**: 
   - Ability to deploy Move modules (available to any transaction sender)
   - Knowledge of Move's tuple and reference semantics
   - No special privileges required

2. **Exploitation Complexity**: Medium
   - Requires understanding of the compiler's freeze insertion logic
   - Must craft functions returning tuples with references
   - Exploitation depends on whether bytecode verification catches the issue

3. **Current Status**: 
   - Developers are aware (documented as "TODO: this case is not handled")
   - Not yet fixed in the codebase
   - Unknown if this is a compilation failure or runtime vulnerability

The likelihood is tempered by uncertainty about whether the bytecode verifier catches this. However, the fact that it's documented as "not handled" rather than "causes compilation error" suggests it may be a genuine runtime risk.

## Recommendation

**Fix the `freeze_tuple_exp()` function to handle all tuple expressions, not just direct tuple constructions.**

The pattern match should be restructured to apply freeze operations regardless of how the tuple was created:

```rust
fn freeze_tuple_exp(
    &self,
    lhs_tys: &Vec<Type>,
    rhs_tys: &Vec<Type>,
    exp: Exp,
    loc: &Loc,
) -> Exp {
    if lhs_tys.len() != rhs_tys.len() || lhs_tys.eq(rhs_tys) {
        return exp;
    }
    let need_freeze = lhs_tys
        .iter()
        .zip(rhs_tys.iter())
        .any(|(lh_ty, rh_ty)| lh_ty.is_immutable_reference() && rh_ty.is_mutable_reference());
    
    if !need_freeze {
        return exp;
    }
    
    // For ANY tuple expression (not just Operation::Tuple), generate temps and apply freeze
    let temps = rhs_tys.iter().map(|ty| self.new_temp(ty.clone())).collect_vec();
    let freeze_id = self.new_node_id_with_type_loc(&Type::Tuple(lhs_tys.clone()), loc);
    
    // Generate the original expression into temps
    self.generate_into_temps(temps.clone(), &exp);
    
    // Create new tuple with frozen elements
    let frozen_elements = lhs_tys
        .iter()
        .zip(rhs_tys.iter())
        .zip(temps.iter())
        .map(|((lh_ty, rh_ty), &temp)| {
            let temp_exp = ExpData::Temporary(self.new_node_id_with_type_loc(rh_ty, loc), temp).into_exp();
            self.try_freeze(lh_ty, rh_ty, temp_exp)
        })
        .collect_vec();
    
    ExpData::Call(freeze_id, Operation::Tuple, frozen_elements).into_exp()
}
```

Alternatively, handle function call expressions specifically by destructuring the tuple after the call and applying freeze to individual elements.

## Proof of Concept

```move
// malicious_module.move
module 0x42::exploit {
    use std::signer;
    
    struct Container has key {
        value: u64
    }
    
    // Function returning tuple with mutable references
    public fun get_container_refs(account: &signer): (&mut u64, &mut u64) 
        acquires Container 
    {
        let addr = signer::address_of(account);
        let container = borrow_global_mut<Container>(addr);
        (&mut container.value, &mut container.value)
    }
    
    // Exploit: destructure into immutable references
    public fun exploit(account: &signer) acquires Container {
        // Type system says these are immutable...
        let (x, y): (&u64, &u64) = get_container_refs(account);
        
        // But without proper freeze operations, they're actually mutable!
        // This should fail (can't mutate through immutable ref)
        // but might succeed if freeze operations are missing
        
        // Verification: if this compiles and runs without errors,
        // the vulnerability is confirmed
        assert!(*x == *y, 0);
    }
    
    #[test(account = @0x42)]
    public fun test_exploit(account: &signer) acquires Container {
        move_to(account, Container { value: 42 });
        exploit(account);
    }
}
```

This PoC should fail compilation with proper freeze insertion. If it compiles but produces incorrect bytecode, or if it allows mutations through supposedly immutable references, the vulnerability is confirmed.

## Notes

The vulnerability is definitively present in the source code as shown. However, the actual exploitability depends on:

1. Whether the Move bytecode verifier catches missing freeze operations
2. Whether this causes compilation failure or produces malformed but accepted bytecode
3. The VM's runtime behavior when executing bytecode with type mismatches

The documented "TODO" comments indicate developers are aware the functionality is incomplete, but it's unclear if this is a safety issue or just a missing feature. Conservative assessment suggests this is at minimum a Medium severity issue for state consistency concerns, potentially High if it leads to consensus divergence.

### Citations

**File:** third_party/move/move-model/src/builder/exp_builder.rs (L4902-4929)
```rust
    fn freeze_tuple_exp(
        &self,
        lhs_tys: &Vec<Type>,
        rhs_tys: &Vec<Type>,
        exp: Exp,
        loc: &Loc,
    ) -> Exp {
        if lhs_tys.len() != rhs_tys.len() || lhs_tys.eq(rhs_tys) {
            return exp;
        }
        let need_freeze = lhs_tys
            .iter()
            .zip(rhs_tys.iter())
            .any(|(lh_ty, rh_ty)| lh_ty.is_immutable_reference() && rh_ty.is_mutable_reference());
        if let (true, ExpData::Call(_, Operation::Tuple, rhs_vec)) = (need_freeze, exp.as_ref()) {
            let new_rhs = lhs_tys
                .iter()
                .zip(rhs_tys.iter())
                .zip(rhs_vec)
                .map(|((lh_ty, rh_ty), rh)| self.try_freeze(lh_ty, rh_ty, rh.clone()))
                .collect_vec();
            let new_type = Type::Tuple(lhs_tys.clone());
            let new_id_tuple = self.new_node_id_with_type_loc(&new_type, loc);
            ExpData::Call(new_id_tuple, Operation::Tuple, new_rhs).into_exp()
        } else {
            exp
        }
    }
```

**File:** third_party/move/move-compiler-v2/src/bytecode_generator.rs (L1321-1338)
```rust
    fn maybe_convert(&self, exp: &Exp, expected_ty: &Type) -> Exp {
        let id = exp.node_id();
        let exp_ty = self.get_node_type(id);
        if let (
            Type::Reference(ReferenceKind::Mutable, _),
            Type::Reference(ReferenceKind::Immutable, et),
        ) = (exp_ty, expected_ty)
        {
            let freeze_id = self
                .env()
                .new_node(self.env().get_node_loc(id), expected_ty.clone());
            self.env()
                .set_node_instantiation(freeze_id, vec![et.as_ref().clone()]);
            ExpData::Call(freeze_id, Operation::Freeze(false), vec![exp.clone()]).into_exp()
        } else {
            exp.clone()
        }
    }
```

**File:** third_party/move/move-compiler-v2/src/bytecode_generator.rs (L1400-1420)
```rust
    fn gen_tuple(&mut self, exp: &Exp, with_forced_temp: bool) -> Vec<TempIndex> {
        if let ExpData::Call(_, Operation::Tuple, args) = exp.as_ref() {
            args.iter()
                .map(|arg| self.gen_escape_auto_ref_arg(arg, false))
                .collect()
        } else {
            let exp_ty = self.env().get_node_type(exp.node_id());
            if exp_ty.is_tuple() {
                // Need to allocate new temps to store the tuple elements.
                let temps = exp_ty
                    .flatten()
                    .into_iter()
                    .map(|ty| self.new_temp(ty))
                    .collect::<Vec<_>>();
                self.generate(temps.clone(), exp);
                temps
            } else {
                vec![self.gen_escape_auto_ref_arg(exp, with_forced_temp)]
            }
        }
    }
```

**File:** third_party/move/move-compiler-v2/tests/bytecode-generator/freeze_mut_ref.move (L48-53)
```text
    // TODO: this case is not handled
    // fun t3() {
    //     let x: &u64;
    //     let y: &u64;
    //     (x, y) = t2(&mut 3, &mut 4);
    // }
```

**File:** third_party/move/move-compiler-v2/transactional-tests/tests/misc/freeze_mut_ref.move (L63-70)
```text
    // TODO: this case is not handled
    // fun test_4() {
    //     let x: &u64;
    //     let y: &u64;
    //     (x, y) = t2(&mut 3, &mut 4);
    //     assert!(*x == 3, 2);
    //     assert!(*y == 4, 3);
    // }
```
