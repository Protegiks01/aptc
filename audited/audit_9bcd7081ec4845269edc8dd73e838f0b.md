# Audit Report

## Title
JWK Consensus Manager Silent Failure Due to Unmonitored Task Spawning and Panic-Prone Initialization

## Summary
The JWK consensus manager is spawned without capturing its JoinHandle or implementing any panic monitoring. If the spawned task panics during initialization (which can occur when processing malformed on-chain JWK data), the validator will silently stop participating in JWK consensus without detection or recovery, while continuing normal block consensus operations.

## Finding Description

The vulnerability exists in the epoch manager's task spawning mechanism for the JWK consensus manager. The core issue involves multiple failure points:

**1. Unmonitored Task Spawn**

The JWK consensus manager is spawned without any monitoring or error handling: [1](#0-0) 

The `tokio::spawn` call discards the `JoinHandle`, preventing the epoch manager from detecting task failures.

**2. Panic-Prone Initialization**

Both consensus manager implementations contain `.unwrap()` calls that will panic if the initial state setup fails:

For KeyLevelConsensusManager: [2](#0-1) 

For IssuerLevelConsensusManager: [3](#0-2) 

**3. Failure Propagation Path**

The `reset_with_on_chain_state` method calls `indexed()` which can fail when converting malformed JWK data: [4](#0-3) 

This in turn calls conversion on individual JWKs: [5](#0-4) 

The `JWK::try_from()` conversion fails on malformed data: [6](#0-5) 

**4. No Recovery Mechanism**

The epoch manager's shutdown mechanism only handles graceful termination, not crash detection: [7](#0-6) 

**Attack Scenario:**

1. Malformed JWK data gets committed on-chain (via governance proposal with quorum, or through a separate validation bug)
2. Validators restart or enter a new epoch
3. The epoch manager spawns the JWK consensus manager with the malformed on-chain state
4. The consensus manager's `run()` method calls `reset_with_on_chain_state(observed_jwks.unwrap_or_default().into_providers_jwks()).unwrap()`
5. The `indexed()` call within `reset_with_on_chain_state` fails due to invalid JWK conversion
6. The `.unwrap()` panics, killing the spawned task
7. The epoch manager has no awareness of the panic
8. The validator continues normal consensus but doesn't participate in JWK consensus
9. Silent failure - no alerts, no logs indicating the consensus manager crashed

This breaks the **Consensus Safety** invariant by allowing validators to fail silently in a critical subsystem without detection or recovery.

## Impact Explanation

This is a **High Severity** vulnerability per Aptos bug bounty criteria for the following reasons:

1. **Validator Node Slowdown/Partial Functionality Loss**: Affected validators continue participating in block consensus but fail to participate in JWK consensus, causing partial node dysfunction.

2. **Silent Failure**: The lack of panic detection means operators won't know their nodes stopped participating in JWK consensus, making debugging extremely difficult.

3. **Quorum Impact**: If enough validators experience this panic (e.g., all validators restart after malformed data is committed), JWK consensus quorum could be lost, affecting keyless authentication system-wide.

4. **Network-Wide Availability**: Loss of JWK consensus affects the availability of keyless authentication features for all users.

While this doesn't directly affect core block consensus safety, it represents a **significant protocol violation** where critical subsystem failures go undetected, meeting the High severity criterion of "Validator node slowdowns" and "Significant protocol violations."

## Likelihood Explanation

**Likelihood: Medium-Low**

The vulnerability requires malformed JWK data to be committed on-chain, which could occur through:

1. **Governance Proposals**: A malicious or buggy governance proposal could introduce malformed JWK data (requires quorum approval, so not trivial)

2. **Validation Bugs**: A separate bug in JWK update validation logic could allow malformed data through (possible but not yet identified)

3. **State Corruption**: Database corruption or state sync issues could result in malformed JWK data (rare but possible)

4. **Cross-Epoch State Issues**: Complex epoch transitions might create edge cases with invalid JWK data

While not trivially exploitable, the combination of:
- Multiple panic points in initialization
- Complete lack of monitoring
- Silent failure mode
- Impact on all restarting validators

makes this a realistic concern, especially during network upgrades or incident recovery scenarios when validators restart en masse.

## Recommendation

**Primary Fix: Implement Task Monitoring and Recovery**

Capture the `JoinHandle` and monitor for panics, similar to patterns used elsewhere in the codebase:

```rust
// In epoch_manager.rs, add to struct:
jwk_manager_handle: Option<tokio::task::JoinHandle<()>>,

// Replace line 247-253 with:
let handle = tokio::spawn(async move {
    if let Err(e) = std::panic::AssertUnwindSafe(
        jwk_consensus_manager.run(
            oidc_providers,
            onchain_observed_jwks,
            jwk_event_rx,
            jwk_rpc_msg_rx,
            jwk_manager_close_rx,
        )
    ).catch_unwind().await {
        error!(
            epoch = epoch_state.epoch,
            "JWKManager panicked: {:?}", e
        );
        // Increment panic counter metric for monitoring
    }
});
self.jwk_manager_handle = Some(handle);

// Monitor the handle in the main loop:
tokio::select! {
    // ... existing branches ...
    result = async { self.jwk_manager_handle.as_mut()?.await }, if self.jwk_manager_handle.is_some() => {
        match result {
            Some(Err(e)) if e.is_panic() => {
                error!("JWKManager panicked, restarting: {:?}", e);
                // Restart logic here
            },
            _ => {},
        }
    }
}
```

**Secondary Fix: Remove Unwrap Calls**

Replace `.unwrap()` with proper error handling in both consensus managers:

```rust
// In both jwk_manager_per_key.rs and jwk_manager/mod.rs:
if let Err(e) = this.reset_with_on_chain_state(
    observed_jwks.unwrap_or_default().into_providers_jwks()
) {
    error!(
        epoch = this.epoch_state.epoch,
        "Failed to reset with on-chain state: {}", e
    );
    // Continue with empty state or use cached state
    // Don't panic - allow graceful degradation
}
```

**Tertiary Fix: Validate JWK Data Earlier**

Add validation before storing JWK data on-chain to prevent malformed data from ever being committed.

## Proof of Concept

```rust
#[cfg(test)]
mod jwk_consensus_panic_test {
    use super::*;
    use aptos_types::{
        jwks::{JWKMoveStruct, AllProvidersJWKs, ObservedJWKs, ProviderJWKs},
        move_any::Any as MoveAny,
    };
    
    #[tokio::test]
    async fn test_malformed_jwk_causes_panic() {
        // Create malformed JWK data with unknown variant type
        let malformed_jwk = JWKMoveStruct {
            variant: MoveAny {
                type_name: "0x1::jwks::MaliciousJWK".to_string(),
                data: vec![1, 2, 3], // Arbitrary invalid data
            },
        };
        
        let malformed_provider_jwks = ProviderJWKs {
            issuer: b"https://malicious.example.com".to_vec(),
            version: 1,
            jwks: vec![malformed_jwk],
        };
        
        let malformed_state = AllProvidersJWKs {
            entries: vec![malformed_provider_jwks],
        };
        
        // This will fail when indexed() is called
        assert!(malformed_state.indexed().is_err());
        
        // Simulating what happens in the consensus manager:
        // observed_jwks.unwrap_or_default().into_providers_jwks().indexed().unwrap()
        // The .unwrap() at the end would panic with malformed data
        
        let observed = ObservedJWKs {
            jwks: malformed_state,
        };
        
        // This demonstrates the panic path
        let result = std::panic::catch_unwind(|| {
            observed.into_providers_jwks().indexed().unwrap()
        });
        
        assert!(result.is_err(), "Should panic on malformed JWK data");
    }
}
```

**Notes**

This vulnerability represents a critical robustness gap in the JWK consensus subsystem. While it requires specific conditions to trigger (malformed on-chain data), the complete lack of monitoring and silent failure mode makes it a significant operational risk. The issue is particularly concerning during network-wide events like upgrades or incident recovery when many validators restart simultaneously, potentially causing cascading JWK consensus failures that would go undetected.

### Citations

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L247-253)
```rust
            tokio::spawn(jwk_consensus_manager.run(
                oidc_providers,
                onchain_observed_jwks,
                jwk_event_rx,
                jwk_rpc_msg_rx,
                jwk_manager_close_rx,
            ));
```

**File:** crates/aptos-jwk-consensus/src/epoch_manager.rs (L266-274)
```rust
    async fn shutdown_current_processor(&mut self) {
        if let Some(tx) = self.jwk_manager_close_tx.take() {
            let (ack_tx, ack_rx) = oneshot::channel();
            let _ = tx.send(ack_tx);
            let _ = ack_rx.await;
        }

        self.jwk_updated_event_txs = None;
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L379-380)
```rust
        this.reset_with_on_chain_state(observed_jwks.unwrap_or_default().into_providers_jwks())
            .unwrap();
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager/mod.rs (L102-103)
```rust
        this.reset_with_on_chain_state(observed_jwks.unwrap_or_default().into_providers_jwks())
            .unwrap();
```

**File:** types/src/jwks/mod.rs (L142-144)
```rust
            let jwk = JWK::try_from(jwk_in_move)
                .context("ProviderJWKs::indexed failed by JWK conversion")?;
            jwks.insert(jwk.id(), jwk);
```

**File:** types/src/jwks/mod.rs (L239-248)
```rust
    pub fn indexed(&self) -> anyhow::Result<HashMap<Issuer, ProviderJWKsIndexed>> {
        let mut ret = HashMap::new();
        for entry in self.entries.iter() {
            let entry_indexed = entry
                .indexed()
                .context("AllProvidersJWKs::indexed failed at entry indexing")?;
            ret.insert(entry.issuer.clone(), entry_indexed);
        }
        Ok(ret)
    }
```

**File:** types/src/jwks/jwk/mod.rs (L105-120)
```rust
    fn try_from(value: &JWKMoveStruct) -> Result<Self, Self::Error> {
        match value.variant.type_name.as_str() {
            RSA_JWK::MOVE_TYPE_NAME => {
                let rsa_jwk =
                    MoveAny::unpack(RSA_JWK::MOVE_TYPE_NAME, value.variant.clone()).map_err(|e|anyhow!("converting from jwk move struct to jwk failed with move any to rsa unpacking error: {e}"))?;
                Ok(Self::RSA(rsa_jwk))
            },
            UnsupportedJWK::MOVE_TYPE_NAME => {
                let unsupported_jwk =
                    MoveAny::unpack(UnsupportedJWK::MOVE_TYPE_NAME, value.variant.clone()).map_err(|e|anyhow!("converting from jwk move struct to jwk failed with move any to unsupported unpacking error: {e}"))?;
                Ok(Self::Unsupported(unsupported_jwk))
            },
            _ => Err(anyhow!(
                "converting from jwk move struct to jwk failed with unknown variant"
            )),
        }
```
