# Audit Report

## Title
Insufficient Minimum Expiration Validation Allows Near-Immediate Batch Expiration and Resource Waste

## Summary
The Aptos consensus quorum store batch creation system lacks minimum expiration gap validation, allowing malicious validators to create batches with artificially short lifetimes (e.g., `current_time + 1 microsecond`). While batches with `expiration=0` are rejected by existing validations, batches with extremely small non-zero expiration values can be created, persisted, broadcast, and added to the proof queue, only to expire almost immediately, wasting network bandwidth, CPU cycles, storage I/O, and consensus processing resources.

## Finding Description

The batch creation flow in the quorum store consensus subsystem has a critical validation gap. When batches are created via `Batch::new()`, `Batch::new_v1()`, or `Batch::new_v2()`, the `expiration` parameter is accepted without validation: [1](#0-0) 

The underlying `BatchInfo::new()` constructor also performs no expiration validation: [2](#0-1) 

**Validation Points Analysis:**

1. **`SignedBatchInfo::verify()`** - Only validates the UPPER bound (expiration not too far in future), but has NO lower bound check to ensure a minimum expiration gap: [3](#0-2) 

2. **`BatchStore::save()`** - Only checks `expiration > last_certified_time`, allowing expiration values just 1 microsecond in the future: [4](#0-3) 

3. **`BatchProofQueue::insert_proof()`** - Similarly only checks `expiration > latest_block_timestamp`: [5](#0-4) 

4. **`Batch::verify()`** and **`BatchMsg::verify()`** - NO expiration validation at all: [6](#0-5) [7](#0-6) 

**Normal vs Malicious Flow:**

In the normal batch creation flow, batches are created with a healthy expiration gap: [8](#0-7) 

The default expiration gap is 60 seconds: [9](#0-8) 

However, a malicious validator can modify their code to call `Batch::new()` directly with `expiration = current_time + 1`, bypassing the intended expiration gap. The batch will:
- Pass all validation checks (it's technically in the future)
- Be persisted to the batch store
- Be signed and broadcast to other validators  
- Be added to the proof queue
- Expire within 1 microsecond
- Be garbage collected, wasting all the resources spent on it

**Regarding expiration=0 specifically:** Batches with `expiration=0` are rejected because they fail the `expiration > last_certified_time` and `expiration > latest_block_timestamp` checks (both timestamps are >= 0 after the first block). However, `expiration=1` or any tiny non-zero value will pass these checks and cause the described resource waste.

## Impact Explanation

This vulnerability allows a malicious validator to perform a **resource exhaustion attack** that wastes:

1. **Network Bandwidth**: Broadcasting batches that will immediately expire
2. **CPU Cycles**: Signature generation and verification on useless batches  
3. **Storage I/O**: Persisting batches to disk then immediately deleting them
4. **Consensus Processing**: Adding batches to the proof queue then removing them

The attack can be sustained continuously to amplify the impact. While it doesn't directly cause loss of funds or consensus safety violations, it causes **performance degradation** across the validator network.

Per the Aptos Bug Bounty severity categories, this fits **Medium Severity** ($10,000):
- Causes state inconsistencies requiring intervention (batch store and proof queue churn)
- Degrades validator performance without requiring majority stake
- Single malicious validator can execute the attack
- Does not result in direct fund loss or consensus violations

## Likelihood Explanation

**Likelihood: Medium to High**

- **Attack Complexity**: Low - requires only modifying one parameter in batch creation code
- **Attacker Requirements**: Must be a validator (requires stake and validator status)
- **Detection Difficulty**: Medium - requires monitoring batch expiration time distributions
- **Sustainability**: High - attack can be repeated continuously
- **Cost to Attacker**: Low - no financial cost beyond normal validator operations

While the attack requires validator status, it doesn't require collusion or majority stake, making it more likely than attacks requiring coordination.

## Recommendation

Add a **minimum expiration gap validation** at the batch construction or verification stage. The check should enforce that batches have a meaningful lifetime before expiration.

**Recommended Fix:**

Add validation in `BatchInfo::new()`:

```rust
pub fn new(
    author: PeerId,
    batch_id: BatchId,
    epoch: u64,
    expiration: u64,
    digest: HashValue,
    num_txns: u64,
    num_bytes: u64,
    gas_bucket_start: u64,
) -> anyhow::Result<Self> {
    let current_time = aptos_infallible::duration_since_epoch().as_micros() as u64;
    let minimum_expiration_gap = Duration::from_secs(30).as_micros() as u64;
    
    ensure!(
        expiration >= current_time + minimum_expiration_gap,
        "Batch expiration {} must be at least {} microseconds in the future",
        expiration,
        minimum_expiration_gap
    );
    
    Ok(Self {
        author,
        batch_id,
        epoch,
        expiration,
        digest,
        num_txns,
        num_bytes,
        gas_bucket_start,
    })
}
```

Alternatively, add the check in `SignedBatchInfo::verify()` alongside the existing upper bound check, enforcing a minimum gap of at least 50% of the configured `batch_expiry_gap_when_init_usecs`.

## Proof of Concept

```rust
#[test]
fn test_insufficient_expiration_gap() {
    use aptos_types::PeerId;
    use aptos_types::quorum_store::BatchId;
    use aptos_crypto::HashValue;
    
    // Create a batch with minimal expiration (1 microsecond from now)
    let current_time = aptos_infallible::duration_since_epoch().as_micros() as u64;
    let malicious_expiration = current_time + 1; // Only 1 microsecond in future
    
    let batch = Batch::new(
        BatchId::new_for_test(1),
        vec![], // empty payload for simplicity
        0, // epoch
        malicious_expiration,
        PeerId::random(),
        0, // gas_bucket_start
    );
    
    // Batch is successfully created with no validation error
    assert!(batch.expiration() == malicious_expiration);
    
    // Simulate passage of time (even 1 microsecond)
    std::thread::sleep(std::time::Duration::from_micros(1));
    
    // Now the batch is expired
    let new_time = aptos_infallible::duration_since_epoch().as_micros() as u64;
    assert!(batch.expiration() <= new_time);
    
    // This demonstrates that batches can be created with expiration so short
    // that they expire almost immediately, wasting consensus resources
}
```

## Notes

While the specific question asked about `expiration=0`, the actual vulnerability affects batches with **any insufficiently small expiration value** (e.g., `current_time + 1`). Batches with `expiration=0` are rejected by existing validations, but the lack of a minimum expiration gap allows the described attack with tiny non-zero values. The root cause is the absence of lower-bound expiration validation in the batch creation and verification paths.

### Citations

**File:** consensus/src/quorum_store/types.rs (L183-203)
```rust
    pub fn new(
        batch_id: BatchId,
        payload: Vec<SignedTransaction>,
        epoch: u64,
        expiration: u64,
        batch_author: PeerId,
        gas_bucket_start: u64,
    ) -> Self {
        let payload = BatchPayload::new(batch_author, payload);
        let batch_info = BatchInfo::new(
            batch_author,
            batch_id,
            epoch,
            expiration,
            payload.hash(),
            payload.num_txns() as u64,
            payload.num_bytes() as u64,
            gas_bucket_start,
        );
        Self::new_generic(batch_info, payload)
    }
```

**File:** consensus/src/quorum_store/types.rs (L262-290)
```rust
    pub fn verify(&self) -> anyhow::Result<()> {
        ensure!(
            self.payload.author() == self.author(),
            "Payload author doesn't match the info"
        );
        ensure!(
            self.payload.hash() == *self.digest(),
            "Payload hash doesn't match the digest"
        );
        ensure!(
            self.payload.num_txns() as u64 == self.num_txns(),
            "Payload num txns doesn't match batch info"
        );
        ensure!(
            self.payload.num_bytes() as u64 == self.num_bytes(),
            "Payload num bytes doesn't match batch info"
        );
        for txn in self.payload.txns() {
            ensure!(
                txn.gas_unit_price() >= self.gas_bucket_start(),
                "Payload gas unit price doesn't match batch info"
            );
            ensure!(
                !txn.payload().is_encrypted_variant(),
                "Encrypted transaction is not supported yet"
            );
        }
        Ok(())
    }
```

**File:** consensus/src/quorum_store/types.rs (L433-461)
```rust
    pub fn verify(
        &self,
        peer_id: PeerId,
        max_num_batches: usize,
        verifier: &ValidatorVerifier,
    ) -> anyhow::Result<()> {
        ensure!(!self.batches.is_empty(), "Empty message");
        ensure!(
            self.batches.len() <= max_num_batches,
            "Too many batches: {} > {}",
            self.batches.len(),
            max_num_batches
        );
        let epoch_authors = verifier.address_to_validator_index();
        for batch in self.batches.iter() {
            ensure!(
                epoch_authors.contains_key(&batch.author()),
                "Invalid author {} for batch {} in current epoch",
                batch.author(),
                batch.digest()
            );
            ensure!(
                batch.author() == peer_id,
                "Batch author doesn't match sender"
            );
            batch.verify()?
        }
        Ok(())
    }
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L61-81)
```rust
    pub fn new(
        author: PeerId,
        batch_id: BatchId,
        epoch: u64,
        expiration: u64,
        digest: HashValue,
        num_txns: u64,
        num_bytes: u64,
        gas_bucket_start: u64,
    ) -> Self {
        Self {
            author,
            batch_id,
            epoch,
            expiration,
            digest,
            num_txns,
            num_bytes,
            gas_bucket_start,
        }
    }
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L459-482)
```rust
    pub fn verify(
        &self,
        sender: PeerId,
        max_batch_expiry_gap_usecs: u64,
        validator: &ValidatorVerifier,
    ) -> anyhow::Result<()> {
        if sender != self.signer {
            bail!("Sender {} mismatch signer {}", sender, self.signer);
        }

        if self.expiration()
            > aptos_infallible::duration_since_epoch().as_micros() as u64
                + max_batch_expiry_gap_usecs
        {
            bail!(
                "Batch expiration too far in future: {} > {}",
                self.expiration(),
                aptos_infallible::duration_since_epoch().as_micros() as u64
                    + max_batch_expiry_gap_usecs
            );
        }

        Ok(validator.optimistic_verify(self.signer, &self.info, &self.signature)?)
    }
```

**File:** consensus/src/quorum_store/batch_store.rs (L419-439)
```rust
    pub(crate) fn save(&self, value: &PersistedValue<BatchInfoExt>) -> anyhow::Result<bool> {
        let last_certified_time = self.last_certified_time();
        if value.expiration() > last_certified_time {
            fail_point!("quorum_store::save", |_| {
                // Skip caching and storing value to the db
                Ok(false)
            });
            counters::GAP_BETWEEN_BATCH_EXPIRATION_AND_CURRENT_TIME_WHEN_SAVE.observe(
                Duration::from_micros(value.expiration() - last_certified_time).as_secs_f64(),
            );

            return self.insert_to_cache(value);
        }
        counters::NUM_BATCH_EXPIRED_WHEN_SAVE.inc();
        bail!(
            "Incorrect expiration {} in epoch {}, last committed timestamp {}",
            value.expiration(),
            self.epoch(),
            last_certified_time,
        );
    }
```

**File:** consensus/src/quorum_store/batch_proof_queue.rs (L175-179)
```rust
    pub(crate) fn insert_proof(&mut self, proof: ProofOfStore<BatchInfoExt>) {
        if proof.expiration() <= self.latest_block_timestamp {
            counters::inc_rejected_pos_count(counters::POS_EXPIRED_LABEL);
            return;
        }
```

**File:** consensus/src/quorum_store/batch_generator.rs (L383-385)
```rust
        let expiry_time = aptos_infallible::duration_since_epoch().as_micros() as u64
            + self.config.batch_expiry_gap_when_init_usecs;
        let batches = self.bucket_into_batches(&mut pulled_txns, expiry_time);
```

**File:** config/src/config/quorum_store_config.rs (L131-131)
```rust
            batch_expiry_gap_when_init_usecs: Duration::from_secs(60).as_micros() as u64,
```
