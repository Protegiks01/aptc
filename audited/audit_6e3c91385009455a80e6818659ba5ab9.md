# Audit Report

## Title
EventKey Collision and Information Loss in CoinDeposit/CoinWithdraw V2-to-V1 Translation for Fungible Asset Accounts

## Summary
The `CoinDepositTranslator` and `CoinWithdrawTranslator` create EventKey collisions when translating V2 events for accounts without CoinStore resources. All coin types for the same account map to identical EventKeys (creation_number=2 or 3, account_address), causing different coin deposits/withdrawals to share the same event stream and lose coin type information in V1 events.

## Finding Description
When Aptos migrated to fungible assets, accounts can receive coins without having a `CoinStore` resource—they use primary fungible stores instead. This is controlled by the `new_accounts_default_to_fa_apt_store_enabled()` feature flag. [1](#0-0) 

When a `CoinDeposit` V2 event is emitted for such accounts, the translator attempts to look up the CoinStore to get the correct EventKey: [2](#0-1) 

**The vulnerability:** When `get_state_value_bytes_for_resource()` returns `None` (no CoinStore exists), the else branch creates an EventKey using:
- Hardcoded creation number: 2 (for deposits) or 3 (for withdrawals)
- Account address
- Sequence number: 0 (initially)

This EventKey **does not include the coin type**. Therefore:

1. **EventKey Collision**: APT deposits to account 0xABC → EventKey(2, 0xABC)
   USDT deposits to account 0xABC → EventKey(2, 0xABC) [SAME KEY]

2. **Information Loss**: V1 `DepositEvent` only contains `amount: u64`, losing the critical `coin_type` field from the V2 event: [3](#0-2) 

3. **Phantom Event Stream**: Applications querying events by EventKey(2, 0xABC) receive a mixed stream of deposits across different coin types, making it impossible to track per-coin balances.

The sequence numbering caches the key after translation: [4](#0-3) 

This ensures subsequent deposits increment the sequence, but all coin types still share the same EventKey and indistinguishable event stream.

## Impact Explanation
This is **HIGH severity** due to:

1. **State Inconsistency**: Violates the "State Consistency" invariant—event streams do not accurately represent the underlying state changes. Multiple coin types appear under a single EventKey, making state reconstruction impossible from V1 events alone.

2. **Indexer Corruption**: External indexers relying on V1 events will produce incorrect balance tracking. They cannot distinguish between 100 APT deposits and 100 USDT deposits when both appear as `DepositEvent{amount: 100}` under the same EventKey.

3. **API/Application Failures**: Applications using the Events API to track coin movements will receive corrupted data, potentially leading to:
   - Incorrect balance displays
   - Failed reconciliation with on-chain state
   - Security vulnerabilities in dependent systems

4. **Information Loss**: The coin type information is permanently lost in the V1 translation. This is unrecoverable without re-scanning V2 events.

This meets the High Severity category: "Significant protocol violations" and causes "State inconsistencies requiring intervention."

## Likelihood Explanation
This vulnerability is **HIGHLY LIKELY** to occur because:

1. **Default Behavior**: The `new_accounts_default_to_fa_apt_store_enabled()` feature flag is increasingly enabled, making new accounts default to fungible stores without CoinStore resources.

2. **Normal Operations**: Any transaction depositing coins to accounts without CoinStore triggers the vulnerable code path—no malicious intent required.

3. **Multi-Coin Ecosystem**: Aptos supports multiple coin types (APT, USDT, USDC, etc.). Users routinely receive different coins, making EventKey collisions inevitable.

4. **Automatic Triggering**: The vulnerability activates automatically during event translation—no special conditions needed beyond the account lacking a CoinStore.

## Recommendation
The fundamental issue is that EventKey cannot distinguish between coin types. Solutions:

**Option 1: Include Coin Type in EventKey Derivation** (Preferred)
Instead of using a fixed creation number, derive the creation number from the coin type hash:
```rust
let coin_type_hash = hash(coin_deposit.coin_type());
let creation_number = 2 + (coin_type_hash % 1000000);
let key = EventKey::new(creation_number, *coin_deposit.account());
```

**Option 2: Reject Translation for Missing CoinStore**
Return an error when CoinStore is missing, forcing applications to use V2 events:
```rust
} else {
    return Err(AptosDbError::from(anyhow::format_err!(
        "CoinStore resource not found for account {:?}. V2 events should be used.",
        coin_deposit.account()
    )));
}
```

**Option 3: Embed Coin Type in V1 Event**
Extend the V1 `DepositEvent` to include coin type (requires schema migration):
```rust
struct DepositEvent has drop, store {
    amount: u64,
    coin_type: Option<String>, // Added field
}
```

The same fix must be applied to `CoinWithdrawTranslator`: [5](#0-4) 

## Proof of Concept
This vulnerability can be demonstrated with the following scenario:

**Setup:**
1. Enable `new_accounts_default_to_fa_apt_store_enabled()` feature flag
2. Create account 0xABC (gets FA store, no CoinStore)

**Exploit Steps:**
```rust
// Transaction 1: Deposit 100 APT
// Emits: CoinDeposit { coin_type: "0x1::aptos_coin::AptosCoin", account: 0xABC, amount: 100 }
// Translates to: EventKey(2, 0xABC), seq=0, DepositEvent{amount: 100}

// Transaction 2: Deposit 50 USDT  
// Emits: CoinDeposit { coin_type: "0x..::usdt::USDT", account: 0xABC, amount: 50 }
// Translates to: EventKey(2, 0xABC), seq=1, DepositEvent{amount: 50}

// Query V1 events by key EventKey(2, 0xABC):
// Returns: [DepositEvent{100}, DepositEvent{50}]
// Problem: Cannot determine which is APT and which is USDT!
```

**Validation:**
1. Query internal indexer DB for events with key EventKey(2, 0xABC)
2. Observe multiple events with different coin types but indistinguishable V1 representations
3. Verify sequence numbers increment across coin types (proving collision)
4. Attempt balance reconstruction from V1 events—fails due to missing coin type

**Notes**
The vulnerability affects the event indexing layer, which breaks the **State Consistency** invariant by making it impossible to reconstruct accurate per-coin balance history from V1 events. While this doesn't directly affect consensus or on-chain execution (V2 events remain correct), it severely impacts off-chain indexers, APIs, and applications that rely on V1 event streams for historical data analysis.

The issue is particularly critical because the fungible asset migration is irreversible for affected accounts—once a CoinStore is migrated or an account is created without one, the EventKey collision becomes permanent for that account. This creates a growing pool of accounts with corrupted V1 event streams.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/aptos_account.move (L271-277)
```text
    public(friend) fun register_apt(account_signer: &signer) {
        if (features::new_accounts_default_to_fa_apt_store_enabled()) {
            ensure_primary_fungible_store_exists(signer::address_of(account_signer));
        } else {
            coin::register<AptosCoin>(account_signer);
        }
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L238-274)
```rust
struct CoinDepositTranslator;
impl EventV2Translator for CoinDepositTranslator {
    fn translate_event_v2_to_v1(
        &self,
        v2: &ContractEventV2,
        engine: &EventV2TranslationEngine,
    ) -> Result<ContractEventV1> {
        let coin_deposit = CoinDeposit::try_from_bytes(v2.event_data())?;
        let struct_tag_str = format!("0x1::coin::CoinStore<{}>", coin_deposit.coin_type());
        let struct_tag = StructTag::from_str(&struct_tag_str)?;
        let (key, sequence_number) = if let Some(state_value_bytes) =
            engine.get_state_value_bytes_for_resource(coin_deposit.account(), &struct_tag)?
        {
            // We can use `DummyCoinType` as it does not affect the correctness of deserialization.
            let coin_store_resource: CoinStoreResource<DummyCoinType> =
                bcs::from_bytes(&state_value_bytes)?;
            let key = *coin_store_resource.deposit_events().key();
            let sequence_number = engine
                .get_next_sequence_number(&key, coin_store_resource.deposit_events().count())?;
            (key, sequence_number)
        } else {
            // The creation number of DepositEvent is deterministically 2.
            static DEPOSIT_EVENT_CREATION_NUMBER: u64 = 2;
            (
                EventKey::new(DEPOSIT_EVENT_CREATION_NUMBER, *coin_deposit.account()),
                0,
            )
        };
        let deposit_event = DepositEvent::new(coin_deposit.amount());
        Ok(ContractEventV1::new(
            key,
            sequence_number,
            DEPOSIT_EVENT_TYPE.clone(),
            bcs::to_bytes(&deposit_event)?,
        )?)
    }
}
```

**File:** storage/indexer/src/event_v2_translator.rs (L276-312)
```rust
struct CoinWithdrawTranslator;
impl EventV2Translator for CoinWithdrawTranslator {
    fn translate_event_v2_to_v1(
        &self,
        v2: &ContractEventV2,
        engine: &EventV2TranslationEngine,
    ) -> Result<ContractEventV1> {
        let coin_withdraw = CoinWithdraw::try_from_bytes(v2.event_data())?;
        let struct_tag_str = format!("0x1::coin::CoinStore<{}>", coin_withdraw.coin_type());
        let struct_tag = StructTag::from_str(&struct_tag_str)?;
        let (key, sequence_number) = if let Some(state_value_bytes) =
            engine.get_state_value_bytes_for_resource(coin_withdraw.account(), &struct_tag)?
        {
            // We can use `DummyCoinType` as it does not affect the correctness of deserialization.
            let coin_store_resource: CoinStoreResource<DummyCoinType> =
                bcs::from_bytes(&state_value_bytes)?;
            let key = *coin_store_resource.withdraw_events().key();
            let sequence_number = engine
                .get_next_sequence_number(&key, coin_store_resource.withdraw_events().count())?;
            (key, sequence_number)
        } else {
            // The creation number of WithdrawEvent is deterministically 3.
            static WITHDRAW_EVENT_CREATION_NUMBER: u64 = 3;
            (
                EventKey::new(WITHDRAW_EVENT_CREATION_NUMBER, *coin_withdraw.account()),
                0,
            )
        };
        let withdraw_event = WithdrawEvent::new(coin_withdraw.amount());
        Ok(ContractEventV1::new(
            key,
            sequence_number,
            WITHDRAW_EVENT_TYPE.clone(),
            bcs::to_bytes(&withdraw_event)?,
        )?)
    }
}
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L210-212)
```text
    struct DepositEvent has drop, store {
        amount: u64
    }
```

**File:** storage/indexer/src/db_indexer.rs (L459-463)
```rust
                                let key = *translated_v1_event.key();
                                let sequence_number = translated_v1_event.sequence_number();
                                self.event_v2_translation_engine
                                    .cache_sequence_number(&key, sequence_number);
                                event_keys.insert(key);
```
