# Audit Report

## Title
Empty Validator Set Bypasses Genesis Validation Leading to Non-Functional Blockchain

## Summary
The `next_epoch_state.is_some()` check at line 153 in `db_bootstrapper/mod.rs` properly prevents partial genesis when it fails. However, the check does not validate that the validator set is non-empty, allowing a genesis transaction to commit with zero validators and zero quorum voting power, resulting in a permanently broken blockchain that cannot achieve consensus.

## Finding Description

The security question asks whether the check properly prevents partial genesis when it fails. **The answer is YES** - when `next_epoch_state` is `None`, the check prevents partial genesis correctly. [1](#0-0) 

However, the check has a critical weakness: it only validates **existence** of `next_epoch_state`, not its **validity**. The execution flow allows an empty `ValidatorSet` to pass through:

1. Genesis transaction executes and writes an empty `ValidatorSet` to the write set [2](#0-1) 

2. `ensure_next_epoch_state()` fetches this empty `ValidatorSet` and creates an `EpochState` [3](#0-2) 

3. `ValidatorVerifier::new()` accepts an empty validator list and sets quorum to 0 [4](#0-3) 

4. The check at line 153 passes because `next_epoch_state.is_some()` is true

5. `Waypoint::new_epoch_boundary()` only checks `ends_epoch()` which is equivalent to `is_some()` [5](#0-4) 

6. Genesis commits with 0 validators, 0 total voting power, and 0 quorum

This breaks **Consensus Safety** (invariant #2): no validator can sign blocks, no quorum can be reached, and the blockchain cannot progress past genesis.

## Impact Explanation

**Critical Severity** - This meets multiple critical impact criteria:

- **Total loss of liveness/network availability**: With zero validators and zero quorum, no blocks can be signed or committed. The blockchain is permanently halted at genesis.
- **Non-recoverable network partition (requires hardfork)**: Once committed, the empty validator set is part of the ledger history. Recovery requires regenerating genesis from scratch.
- **Consensus/Safety violations**: The fundamental consensus invariant (2f+1 quorum from active validators) is violated with 0 validators.

All validator nodes would be unable to participate in consensus, effectively creating a permanently dead blockchain from inception.

## Likelihood Explanation

**Medium-High Likelihood**:

- **Attack vector**: A buggy or malicious genesis configuration that provides an empty validator list
- **Attacker requirements**: Control over genesis transaction generation (typically during network initialization)
- **Complexity**: Low - simply provide an empty array where validators are expected
- **Detection**: Would not be caught until genesis is committed and consensus fails to start

While genesis is typically a trusted operation, configuration errors or supply chain attacks on genesis generation tools could trigger this vulnerability. The lack of defensive validation makes this exploitable through simple misconfiguration.

## Recommendation

Add validation to ensure the validator set is non-empty before accepting `next_epoch_state`:

```rust
ensure!(
    execution_output.next_epoch_state.is_some(),
    "Genesis txn didn't output reconfig event."
);

// Add validation for non-empty validator set
if let Some(epoch_state) = &execution_output.next_epoch_state {
    ensure!(
        !epoch_state.verifier.validator_infos.is_empty(),
        "Genesis validator set cannot be empty."
    );
    ensure!(
        epoch_state.verifier.quorum_voting_power > 0,
        "Genesis validator set must have non-zero quorum voting power."
    );
}
```

Alternatively, add validation in `ValidatorVerifier::new()` to reject empty validator sets in non-test contexts, or in `EpochState::new()` to prevent creation with empty verifiers.

## Proof of Concept

```rust
// Minimal PoC showing the vulnerability flow
use aptos_types::{
    on_chain_config::ValidatorSet,
    validator_verifier::ValidatorVerifier,
    epoch_state::EpochState,
};

#[test]
fn test_empty_validator_set_vulnerability() {
    // Create an empty ValidatorSet (allowed by the type system)
    let empty_validator_set = ValidatorSet::empty();
    
    // Convert to ValidatorVerifier (no validation)
    let verifier: ValidatorVerifier = (&empty_validator_set).into();
    
    // Verify it has 0 validators and 0 quorum
    assert_eq!(verifier.validator_infos.len(), 0);
    assert_eq!(verifier.quorum_voting_power, 0);
    assert_eq!(verifier.total_voting_power, 0);
    
    // Create EpochState with empty verifier (allowed)
    let epoch_state = EpochState::new(1, verifier);
    
    // This would pass the next_epoch_state.is_some() check
    let next_epoch_state = Some(epoch_state);
    assert!(next_epoch_state.is_some()); // Check passes!
    
    // But consensus cannot function with 0 validators
    // No validator can sign, no quorum can be reached
}
```

## Notes

The vulnerability is specifically in the **insufficiency** of the validation, not in the check failing. When `next_epoch_state` is `None`, the check correctly prevents partial genesis. The issue is that when `next_epoch_state` is `Some` but contains an empty validator set, the check passes but consensus is broken. This represents a gap between the validation performed and the actual requirement for a functional blockchain.

### Citations

**File:** execution/executor/src/db_bootstrapper/mod.rs (L151-154)
```rust
    ensure!(
        execution_output.next_epoch_state.is_some(),
        "Genesis txn didn't output reconfig event."
    );
```

**File:** types/src/on_chain_config/validator_set.rs (L63-65)
```rust
    pub fn empty() -> Self {
        ValidatorSet::new(Vec::new())
    }
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L520-540)
```rust
    fn ensure_next_epoch_state(to_commit: &TransactionsWithOutput) -> Result<EpochState> {
        let last_write_set = to_commit
            .transaction_outputs
            .last()
            .ok_or_else(|| anyhow!("to_commit is empty."))?
            .write_set();

        let write_set_view = WriteSetStateView {
            write_set: last_write_set,
        };

        let validator_set = ValidatorSet::fetch_config(&write_set_view)
            .ok_or_else(|| anyhow!("ValidatorSet not touched on epoch change"))?;
        let configuration = ConfigurationResource::fetch_config(&write_set_view)
            .ok_or_else(|| anyhow!("Configuration resource not touched on epoch change"))?;

        Ok(EpochState::new(
            configuration.epoch(),
            (&validator_set).into(),
        ))
    }
```

**File:** types/src/validator_verifier.rs (L206-214)
```rust
    pub fn new(validator_infos: Vec<ValidatorConsensusInfo>) -> Self {
        let total_voting_power = sum_voting_power(&validator_infos);
        let quorum_voting_power = if validator_infos.is_empty() {
            0
        } else {
            total_voting_power * 2 / 3 + 1
        };
        Self::build_index(validator_infos, quorum_voting_power, total_voting_power)
    }
```

**File:** types/src/waypoint.rs (L48-51)
```rust
    pub fn new_epoch_boundary(ledger_info: &LedgerInfo) -> Result<Self> {
        ensure!(ledger_info.ends_epoch(), "No validator set");
        Ok(Self::new_any(ledger_info))
    }
```
