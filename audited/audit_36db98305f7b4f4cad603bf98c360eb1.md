# Audit Report

## Title
Unbounded Concurrent Handshake Processing Allows Resource Exhaustion via NoCommonProtocols Attack

## Summary
The network layer does not limit the number of concurrent pending connection upgrades before the handshake completes. An attacker can open many connections, complete expensive Noise handshakes, then trigger `NoCommonProtocols` errors to exhaust node CPU and memory resources. The `inbound_connection_limit` is only enforced AFTER successful handshake completion, leaving a window for resource exhaustion attacks.

## Finding Description
The vulnerability exists in the connection upgrade pipeline where multiple expensive operations occur before any connection limit checks:

**Attack Flow:**
1. Attacker opens many TCP connections to the validator node
2. Each connection is accepted and added to `pending_inbound_connections` FuturesUnordered with NO size limit [1](#0-0) 
3. For each connection, the node performs:
   - Noise IK handshake (expensive Diffie-Hellman operations) [2](#0-1) 
   - HandshakeMsg exchange [3](#0-2) 
   - Protocol negotiation via `perform_handshake()` [4](#0-3) 
4. Attacker sends `HandshakeMsg` with empty `supported_protocols` or non-overlapping protocol sets
5. `perform_handshake()` returns `NoCommonProtocols` error [5](#0-4) 
6. Connection is dropped and logged, but CPU/memory already consumed [6](#0-5) 

**Critical Gap:** The `inbound_connection_limit` (default 100) is only checked AFTER successful handshake completion for unknown peers [7](#0-6) . This means an attacker can have thousands of connections in the handshake phase simultaneously, each consuming resources.

**Resource Consumption:**
- Each Noise handshake requires multiple Diffie-Hellman operations (computationally expensive)
- Each pending connection future occupies memory
- No limit on `pending_connection_upgrades` counter increments [8](#0-7) 

## Impact Explanation
This vulnerability qualifies as **High Severity** per Aptos bug bounty criteria:
- **Validator node slowdowns**: Sustained attacks can degrade validator performance by consuming CPU cycles on repeated Noise handshakes
- **Potential consensus impact**: If validators slow down significantly, block proposal and voting may be delayed
- **DoS vector**: While pure network-level DoS is out of scope, this is an application-layer resource exhaustion exploiting handshake protocol logic

The attack doesn't directly cause loss of funds or consensus safety violations, but can significantly degrade network liveness and validator performance, which falls under "Validator node slowdowns" (High Severity, up to $50,000).

## Likelihood Explanation
**High Likelihood:**
- Attack is trivial to execute - no special privileges needed
- Attacker only needs to open TCP connections and send valid (but incompatible) handshake messages
- No rate limiting prevents repeated attacks from same IP ranges
- Default TCP listen backlog is 256 [9](#0-8) , but accepted connections can accumulate unbounded in `FuturesUnordered`
- Byte-rate limiting [10](#0-9)  doesn't prevent connection establishment

**Attacker Requirements:**
- Basic network connectivity to target node
- Ability to complete Noise handshake (requires knowing node's public key, which is publicly available)
- Send minimal HandshakeMsg (can be empty protocol set)

## Recommendation
Implement a limit on concurrent pending connection upgrades BEFORE expensive operations:

```rust
// In peer_manager/transport.rs
pub async fn listen(mut self) {
    const MAX_PENDING_INBOUND_UPGRADES: usize = 200; // 2x inbound_connection_limit
    let mut pending_inbound_connections = FuturesUnordered::new();
    let mut pending_outbound_connections = FuturesUnordered::new();

    loop {
        futures::select! {
            inbound_connection = self.listener.select_next_some() => {
                // Check limit BEFORE accepting
                if pending_inbound_connections.len() >= MAX_PENDING_INBOUND_UPGRADES {
                    warn!("Rejecting inbound connection: pending upgrade limit reached");
                    counters::connections_rejected(&self.network_context, ConnectionOrigin::Inbound).inc();
                    continue;
                }
                if let Some(fut) = self.upgrade_inbound_connection(inbound_connection) {
                    pending_inbound_connections.push(fut);
                }
            },
            // ... rest of select branches
        }
    }
}
```

**Additional Recommendations:**
1. Consider performing protocol negotiation BEFORE Noise handshake in a lightweight pre-handshake message
2. Implement IP-based rate limiting for failed handshakes
3. Add monitoring alerts when pending upgrades exceed thresholds
4. Consider rejecting connections from IPs with high NoCommonProtocols failure rates

## Proof of Concept

```rust
// Test demonstrating unbounded connection accumulation
#[tokio::test]
async fn test_handshake_resource_exhaustion() {
    use aptos_config::network_id::NetworkContext;
    use aptos_crypto::x25519;
    use aptos_types::PeerId;
    use std::sync::Arc;
    use tokio::time::{timeout, Duration};
    
    // Setup validator node
    let validator_key = x25519::PrivateKey::generate(&mut OsRng);
    let validator_pubkey = validator_key.public_key();
    let validator_peer_id = from_identity_public_key(validator_pubkey);
    
    // Attacker opens 1000 connections
    const ATTACK_CONNECTIONS: usize = 1000;
    let mut attack_tasks = vec![];
    
    for i in 0..ATTACK_CONNECTIONS {
        let task = tokio::spawn(async move {
            let attacker_key = x25519::PrivateKey::generate(&mut OsRng);
            let socket = TcpStream::connect(validator_addr).await.unwrap();
            
            // Complete Noise handshake (expensive)
            let noise_config = noise::NoiseConfig::new(attacker_key);
            let mut rng = OsRng;
            noise_config.initiate_connection(
                &mut rng, 
                &prologue, 
                validator_pubkey,
                Some(&timestamp),
                &mut client_msg
            ).unwrap();
            
            // Send empty HandshakeMsg -> triggers NoCommonProtocols
            let empty_handshake = HandshakeMsg {
                supported_protocols: BTreeMap::new(), // EMPTY!
                chain_id: ChainId::test(),
                network_id: NetworkId::Validator,
            };
            
            // This will cause NoCommonProtocols error after expensive Noise handshake
            write_handshake(&empty_handshake, &mut socket).await.unwrap();
        });
        attack_tasks.push(task);
    }
    
    // All 1000 connections will be in pending_inbound_connections simultaneously
    // Each completed Noise handshake before being rejected
    // Validator CPU saturated with DH operations
    
    futures::future::join_all(attack_tasks).await;
    
    // Validator should reject after limit, but currently accepts all
    assert!(pending_upgrades_metric() < MAX_EXPECTED); // FAILS - no limit enforced
}
```

**Notes:**
The vulnerability breaks the **Resource Limits** invariant by allowing unbounded concurrent expensive operations. While individual connections are eventually cleaned up, the lack of a bound on concurrent pending upgrades enables attackers to force validators to waste significant CPU cycles on cryptographic operations for connections that will inevitably fail protocol negotiation.

### Citations

**File:** network/framework/src/peer_manager/transport.rs (L91-109)
```rust
        let mut pending_inbound_connections = FuturesUnordered::new();
        let mut pending_outbound_connections = FuturesUnordered::new();

        debug!(
            NetworkSchema::new(&self.network_context),
            "{} Incoming connections listener Task started", self.network_context
        );

        loop {
            futures::select! {
                dial_request = self.transport_reqs_rx.select_next_some() => {
                    if let Some(fut) = self.dial_peer(dial_request) {
                        pending_outbound_connections.push(fut);
                    }
                },
                inbound_connection = self.listener.select_next_some() => {
                    if let Some(fut) = self.upgrade_inbound_connection(inbound_connection) {
                        pending_inbound_connections.push(fut);
                    }
```

**File:** network/framework/src/peer_manager/transport.rs (L148-152)
```rust
                counters::pending_connection_upgrades(
                    &self.network_context,
                    ConnectionOrigin::Inbound,
                )
                .inc();
```

**File:** network/framework/src/peer_manager/transport.rs (L294-329)
```rust
    async fn handle_completed_inbound_upgrade(
        &mut self,
        upgrade: Result<Connection<TSocket>, TTransport::Error>,
        addr: NetworkAddress,
        start_time: Instant,
    ) {
        counters::pending_connection_upgrades(&self.network_context, ConnectionOrigin::Inbound)
            .dec();

        let elapsed_time = (self.time_service.now() - start_time).as_secs_f64();
        match upgrade {
            Ok(connection) => {
                self.send_connection_to_peer_manager(connection, &addr, elapsed_time)
                    .await;
            },
            Err(err) => {
                warn!(
                    NetworkSchema::new(&self.network_context)
                        .network_address(&addr),
                    error = %err,
                    "{} Inbound connection from {} failed to upgrade after {:.3} secs: {}",
                    self.network_context,
                    addr,
                    elapsed_time,
                    err,
                );

                counters::connection_upgrade_time(
                    &self.network_context,
                    ConnectionOrigin::Inbound,
                    FAILED_LABEL,
                )
                .observe(elapsed_time);
            },
        }
    }
```

**File:** network/framework/src/noise/handshake.rs (L313-486)
```rust
    pub async fn upgrade_inbound<TSocket>(
        &self,
        mut socket: TSocket,
    ) -> Result<(NoiseStream<TSocket>, PeerId, PeerRole), NoiseHandshakeError>
    where
        TSocket: AsyncRead + AsyncWrite + Debug + Unpin,
    {
        // buffer to contain the client first message
        let mut client_message = [0; Self::CLIENT_MESSAGE_SIZE];

        // receive the prologue + first noise handshake message
        trace!("{} noise server: handshake read", self.network_context);
        socket
            .read_exact(&mut client_message)
            .await
            .map_err(NoiseHandshakeError::ServerReadFailed)?;

        // extract prologue (remote_peer_id | self_public_key)
        let (remote_peer_id, self_expected_public_key) =
            client_message[..Self::PROLOGUE_SIZE].split_at(PeerId::LENGTH);

        // parse the client's peer id
        // note: in mutual authenticated network, we could verify that their peer_id is in the trust peer set now.
        // We do this later in this function instead (to batch a number of checks) as there is no known attack here.
        let remote_peer_id = PeerId::try_from(remote_peer_id)
            .map_err(|_| NoiseHandshakeError::InvalidClientPeerId(hex::encode(remote_peer_id)))?;
        let remote_peer_short = remote_peer_id.short_str();

        // reject accidental self-dials
        // this situation could occur either as a result of our own discovery
        // mis-configuration or a potentially malicious discovery peer advertising
        // a (loopback ip or mirror proxy) and our public key.
        if remote_peer_id == self.network_context.peer_id() {
            return Err(NoiseHandshakeError::SelfDialDetected);
        }

        // verify that this is indeed our public key
        let actual_public_key = self.noise_config.public_key();
        if self_expected_public_key != actual_public_key.as_slice() {
            return Err(NoiseHandshakeError::ClientExpectingDifferentPubkey(
                remote_peer_short,
                hex::encode(self_expected_public_key),
                hex::encode(actual_public_key.as_slice()),
            ));
        }

        // parse it
        let (prologue, client_init_message) = client_message.split_at(Self::PROLOGUE_SIZE);
        let (remote_public_key, handshake_state, payload) = self
            .noise_config
            .parse_client_init_message(prologue, client_init_message)
            .map_err(|err| NoiseHandshakeError::ServerParseClient(remote_peer_short, err))?;

        // if mutual auth mode, verify the remote pubkey is in our set of trusted peers
        let network_id = self.network_context.network_id();
        let peer_role = match &self.auth_mode {
            HandshakeAuthMode::Mutual {
                peers_and_metadata, ..
            } => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => Err(NoiseHandshakeError::UnauthenticatedClient(
                        remote_peer_short,
                        remote_peer_id,
                    )),
                }
            },
            HandshakeAuthMode::MaybeMutual(peers_and_metadata) => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => {
                        // The peer is not in the trusted peer set. Verify that the Peer ID is
                        // constructed correctly from the public key.
                        let derived_remote_peer_id =
                            aptos_types::account_address::from_identity_public_key(
                                remote_public_key,
                            );
                        if derived_remote_peer_id != remote_peer_id {
                            // The peer ID is not constructed correctly from the public key
                            Err(NoiseHandshakeError::ClientPeerIdMismatch(
                                remote_peer_short,
                                remote_peer_id,
                                derived_remote_peer_id,
                            ))
                        } else {
                            // Try to infer the role from the network context
                            if self.network_context.role().is_validator() {
                                if network_id.is_vfn_network() {
                                    // Inbound connections to validators on the VFN network must be VFNs
                                    Ok(PeerRole::ValidatorFullNode)
                                } else {
                                    // Otherwise, they're unknown. Validators will connect through
                                    // authenticated channels (on the validator network) so shouldn't hit
                                    // this, and PFNs will connect on public networks (which aren't common).
                                    Ok(PeerRole::Unknown)
                                }
                            } else {
                                // We're a VFN or PFN. VFNs get no inbound connections on the vfn network
                                // (so the peer won't be a validator). Thus, we're on the public network
                                // so mark the peer as unknown.
                                Ok(PeerRole::Unknown)
                            }
                        }
                    },
                }
            },
        }?;

        // if on a mutually authenticated network,
        // the payload should contain a u64 client timestamp
        if let Some(anti_replay_timestamps) = self.auth_mode.anti_replay_timestamps() {
            // check that the payload received as the client timestamp (in seconds)
            if payload.len() != AntiReplayTimestamps::TIMESTAMP_SIZE {
                return Err(NoiseHandshakeError::MissingAntiReplayTimestamp(
                    remote_peer_short,
                ));
            }

            let mut client_timestamp = [0u8; AntiReplayTimestamps::TIMESTAMP_SIZE];
            client_timestamp.copy_from_slice(&payload);
            let client_timestamp = u64::from_le_bytes(client_timestamp);

            // check the timestamp is not a replay
            let mut anti_replay_timestamps = anti_replay_timestamps.write();
            if anti_replay_timestamps.is_replay(remote_public_key, client_timestamp) {
                return Err(NoiseHandshakeError::ServerReplayDetected(
                    remote_peer_short,
                    client_timestamp,
                ));
            }

            // store the timestamp
            anti_replay_timestamps.store_timestamp(remote_public_key, client_timestamp);
        }

        // construct the response
        let mut rng = rand::rngs::OsRng;
        let mut server_response = [0u8; Self::SERVER_MESSAGE_SIZE];
        let session = self
            .noise_config
            .respond_to_client(&mut rng, handshake_state, None, &mut server_response)
            .map_err(|err| {
                NoiseHandshakeError::BuildServerHandshakeMessageFailed(remote_peer_short, err)
            })?;

        // send the response
        trace!(
            "{} noise server: handshake write: remote_peer_id: {}",
            self.network_context,
            remote_peer_short,
        );
        socket
            .write_all(&server_response)
            .await
            .map_err(|err| NoiseHandshakeError::ServerWriteFailed(remote_peer_short, err))?;

        // finalize the connection
        trace!(
            "{} noise server: handshake finalize: remote_peer_id: {}",
            self.network_context,
            remote_peer_short,
        );

        let noise_stream = NoiseStream::new(socket, session);
        Ok((noise_stream, remote_peer_id, peer_role))
    }
```

**File:** network/framework/src/transport/mod.rs (L297-305)
```rust
    // exchange HandshakeMsg
    let handshake_msg = HandshakeMsg {
        supported_protocols: ctxt.supported_protocols.clone(),
        chain_id: ctxt.chain_id,
        network_id: ctxt.network_id,
    };
    let remote_handshake = exchange_handshake(&handshake_msg, &mut socket)
        .await
        .map_err(|err| add_pp_addr(proxy_protocol_enabled, err, &addr))?;
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L431-465)
```rust
    pub fn perform_handshake(
        &self,
        other: &HandshakeMsg,
    ) -> Result<(MessagingProtocolVersion, ProtocolIdSet), HandshakeError> {
        // verify that both peers are on the same chain
        if self.chain_id != other.chain_id {
            return Err(HandshakeError::InvalidChainId(
                other.chain_id,
                self.chain_id,
            ));
        }

        // verify that both peers are on the same network
        if self.network_id != other.network_id {
            return Err(HandshakeError::InvalidNetworkId(
                other.network_id,
                self.network_id,
            ));
        }

        // find the greatest common MessagingProtocolVersion where we both support
        // at least one common ProtocolId.
        for (our_handshake_version, our_protocols) in self.supported_protocols.iter().rev() {
            if let Some(their_protocols) = other.supported_protocols.get(our_handshake_version) {
                let common_protocols = our_protocols.intersect(their_protocols);

                if !common_protocols.is_empty() {
                    return Ok((*our_handshake_version, common_protocols));
                }
            }
        }

        // no intersection found
        Err(HandshakeError::NoCommonProtocols)
    }
```

**File:** network/framework/src/peer_manager/mod.rs (L351-390)
```rust
        // Verify that we have not reached the max connection limit for unknown inbound peers
        if conn.metadata.origin == ConnectionOrigin::Inbound {
            // Everything below here is meant for unknown peers only. The role comes from
            // the Noise handshake and if it's not `Unknown` then it is trusted.
            if conn.metadata.role == PeerRole::Unknown {
                // TODO: Keep track of somewhere else to not take this hit in case of DDoS
                // Count unknown inbound connections
                let unknown_inbound_conns = self
                    .active_peers
                    .iter()
                    .filter(|(peer_id, (metadata, _))| {
                        metadata.origin == ConnectionOrigin::Inbound
                            && trusted_peers
                                .get(peer_id)
                                .is_none_or(|peer| peer.role == PeerRole::Unknown)
                    })
                    .count();

                // Reject excessive inbound connections made by unknown peers
                // We control outbound connections with Connectivity manager before we even send them
                // and we must allow connections that already exist to pass through tie breaking.
                if !self
                    .active_peers
                    .contains_key(&conn.metadata.remote_peer_id)
                    && unknown_inbound_conns + 1 > self.inbound_connection_limit
                {
                    info!(
                        NetworkSchema::new(&self.network_context)
                            .connection_metadata_with_address(&conn.metadata),
                        "{} Connection rejected due to connection limit: {}",
                        self.network_context,
                        conn.metadata
                    );
                    counters::connections_rejected(&self.network_context, conn.metadata.origin)
                        .inc();
                    self.disconnect(conn);
                    return;
                }
            }
        }
```

**File:** network/netcore/src/transport/tcp.rs (L127-127)
```rust
        let listener = socket.listen(256)?;
```

**File:** config/src/config/network_config.rs (L117-119)
```rust
    pub inbound_rate_limit_config: Option<RateLimitConfig>,
    /// Outbound rate limiting configuration, if not specified, no rate limiting
    pub outbound_rate_limit_config: Option<RateLimitConfig>,
```
