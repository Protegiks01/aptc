# Audit Report

## Title
Missing next_epoch_state Validation in BlockInfo Consistency Check Causes Silent Failure During Epoch Transitions

## Summary
The `match_ordered_only()` validation in BlockInfo does not check the `next_epoch_state` field, allowing validators with divergent epoch states to proceed with signing commit votes without raising the `InconsistentExecutionResult` error. While this prevents actual consensus safety violations due to signature aggregation failures, it causes silent liveness failures during epoch transitions when execution determinism is compromised. [1](#0-0) 

## Finding Description

The consensus pipeline validates consistency between ordered and executed BlockInfo using the `match_ordered_only()` method, which only compares epoch, round, id, and timestamp_usecs fields. Critically, it does not validate the `next_epoch_state` field that contains the validator set for the next epoch. [2](#0-1) 

When validators execute a reconfiguration block, the `ensure_next_epoch_state()` function extracts the ValidatorSet from the write set to populate the `next_epoch_state` field: [3](#0-2) 

If execution produces different ValidatorSet values across validators (due to non-deterministic execution bugs, state divergence, or consensus on different write sets), each validator will:

1. Pass the `match_ordered_only()` validation despite having different `next_epoch_state` values
2. Sign their own version of the commit LedgerInfo containing their unique `next_epoch_state`
3. Broadcast commit votes to other validators

During signature aggregation, the `create_signature_aggregator()` function filters votes by exact LedgerInfo equality: [4](#0-3) 

This equality check DOES compare `next_epoch_state`, causing validators with different epoch states to form separate, non-overlapping vote pools. If the voting power splits such that no group reaches the 2/3 threshold, the network halts without clear error indication.

## Impact Explanation

**Severity: Medium** (State inconsistency requiring intervention)

This vulnerability does NOT cause consensus safety violations because:
- Validators with different `next_epoch_state` cannot aggregate signatures (BLS multisignature verification requires signing the same message)
- No invalid block can be committed with 2/3 signatures

However, it causes **liveness failures**:
- Network halts during epoch transitions if validators diverge
- No clear `InconsistentExecutionResult` error is raised to operators
- Manual intervention required to identify and resolve the divergence
- Silent failure mode makes debugging difficult

The `InconsistentBlockInfo` error variant defined in the pipeline errors module is never actually used in the codebase: [5](#0-4) 

## Likelihood Explanation

**Likelihood: Low to Medium**

This issue manifests only when:
1. A reconfiguration block is executed (regular occurrence during epoch changes)
2. AND validators produce different ValidatorSet values due to:
   - Bugs in Move VM execution causing non-determinism
   - State synchronization issues leading to different base states
   - Race conditions in validator set computation
   - Bugs in the staking framework's `on_new_epoch()` function

While Aptos execution should be deterministic, this validation serves as a critical defense-in-depth mechanism. Historical blockchain bugs show that subtle non-determinism issues do occur in practice.

## Recommendation

Add `next_epoch_state` validation to the `match_ordered_only()` function or create a separate validation path for epoch-sensitive fields:

```rust
pub fn match_ordered_only(&self, executed_block_info: &BlockInfo) -> bool {
    self.epoch == executed_block_info.epoch
        && self.round == executed_block_info.round
        && self.id == executed_block_info.id
        && (self.timestamp_usecs == executed_block_info.timestamp_usecs
            || (self.timestamp_usecs > executed_block_info.timestamp_usecs
                && executed_block_info.has_reconfiguration()))
        // Add next_epoch_state validation
        && self.match_epoch_state(executed_block_info)
}

fn match_epoch_state(&self, executed: &BlockInfo) -> bool {
    match (&self.next_epoch_state, &executed.next_epoch_state) {
        // Ordered block should have None, executed may have Some
        (None, _) => true,
        // If ordered has Some, executed must match exactly
        (Some(ordered_state), Some(executed_state)) => {
            ordered_state.epoch == executed_state.epoch
                && ordered_state.verifier.len() == executed_state.verifier.len()
                // Compare validator sets
        }
        (Some(_), None) => false,
    }
}
```

Alternatively, enhance the error reporting in `guarded_sign_commit_vote` to explicitly check and reject mismatched `next_epoch_state` values before signing.

## Proof of Concept

This vulnerability cannot be demonstrated with a standalone PoC because it requires triggering non-deterministic execution, which would itself be a separate vulnerability. However, the validation gap can be verified:

```rust
// Verification test showing the validation gap
#[test]
fn test_match_ordered_only_ignores_next_epoch_state() {
    let ordered_info = BlockInfo::new(
        1, 100, HashValue::random(), 
        *ACCUMULATOR_PLACEHOLDER_HASH,
        0, 1000, None
    );
    
    let validator_set_a = ValidatorSet::new(vec![/* Set A */]);
    let validator_set_b = ValidatorSet::new(vec![/* Set B */]);
    
    let executed_info_a = BlockInfo::new(
        1, 100, ordered_info.id(),
        HashValue::random(),
        10, 1000,
        Some(EpochState::new(2, (&validator_set_a).into()))
    );
    
    let executed_info_b = BlockInfo::new(
        1, 100, ordered_info.id(),
        HashValue::random(),
        10, 1000,
        Some(EpochState::new(2, (&validator_set_b).into()))
    );
    
    // Both pass validation despite different next_epoch_state
    assert!(ordered_info.match_ordered_only(&executed_info_a));
    assert!(ordered_info.match_ordered_only(&executed_info_b));
    
    // But they're not equal
    assert_ne!(executed_info_a, executed_info_b);
}
```

**Notes**

This is a **defense-in-depth validation gap** rather than a directly exploitable vulnerability. The cryptographic signature verification prevents actual safety violations, but the missing validation creates a failure mode that is difficult to diagnose and recover from. The finding is classified as Medium severity because it requires intervention but does not directly compromise funds or consensus safety. The `InconsistentBlockInfo` error variant appears to have been designed for this purpose but was never integrated into the validation logic.

### Citations

**File:** types/src/block_info.rs (L196-204)
```rust
    pub fn match_ordered_only(&self, executed_block_info: &BlockInfo) -> bool {
        self.epoch == executed_block_info.epoch
            && self.round == executed_block_info.round
            && self.id == executed_block_info.id
            && (self.timestamp_usecs == executed_block_info.timestamp_usecs
            // executed block info has changed its timestamp because it's a reconfiguration suffix
                || (self.timestamp_usecs > executed_block_info.timestamp_usecs
                    && executed_block_info.has_reconfiguration()))
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L395-403)
```rust
        if !old_ledger_info
            .commit_info()
            .match_ordered_only(new_ledger_info.commit_info())
        {
            return Err(Error::InconsistentExecutionResult(
                old_ledger_info.commit_info().to_string(),
                new_ledger_info.commit_info().to_string(),
            ));
        }
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L520-540)
```rust
    fn ensure_next_epoch_state(to_commit: &TransactionsWithOutput) -> Result<EpochState> {
        let last_write_set = to_commit
            .transaction_outputs
            .last()
            .ok_or_else(|| anyhow!("to_commit is empty."))?
            .write_set();

        let write_set_view = WriteSetStateView {
            write_set: last_write_set,
        };

        let validator_set = ValidatorSet::fetch_config(&write_set_view)
            .ok_or_else(|| anyhow!("ValidatorSet not touched on epoch change"))?;
        let configuration = ConfigurationResource::fetch_config(&write_set_view)
            .ok_or_else(|| anyhow!("Configuration resource not touched on epoch change"))?;

        Ok(EpochState::new(
            configuration.epoch(),
            (&validator_set).into(),
        ))
    }
```

**File:** consensus/src/pipeline/buffer_item.rs (L40-52)
```rust
fn create_signature_aggregator(
    unverified_votes: HashMap<Author, CommitVote>,
    commit_ledger_info: &LedgerInfo,
) -> SignatureAggregator<LedgerInfo> {
    let mut sig_aggregator = SignatureAggregator::new(commit_ledger_info.clone());
    for vote in unverified_votes.values() {
        let sig = vote.signature_with_status();
        if vote.ledger_info() == commit_ledger_info {
            sig_aggregator.add_signature(vote.author(), sig);
        }
    }
    sig_aggregator
}
```

**File:** consensus/src/pipeline/errors.rs (L11-12)
```rust
    #[error("The block in the message, {0}, does not match expected block, {1}")]
    InconsistentBlockInfo(BlockInfo, BlockInfo),
```
