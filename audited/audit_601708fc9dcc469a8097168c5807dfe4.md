# Audit Report

## Title
Unverified Synced Ledger Info from Byzantine Peers Enables State Sync Manipulation

## Summary
Byzantine peers can advertise malicious `LedgerInfoWithSignatures` in their storage summaries without any signature verification. This allows attackers to manipulate waypoint satisfiability checks, denial-of-service attacks via unreachable sync targets, and performance degradation during state synchronization.

## Finding Description

The state sync data client collects `synced_ledger_info` from all connected peers and selects the highest version as the sync target or for waypoint verification, but critically **never verifies the BLS signatures** on these ledger infos.

**Attack Flow:**

1. **Collection without verification**: In `peer_states.rs`, the code collects all advertised `synced_ledger_info` from peers without any cryptographic validation: [1](#0-0) 

2. **Selection based on version alone**: The code selects the ledger info with the highest version number without signature verification: [2](#0-1) 

3. **Waypoint check without verification**: The bootstrapper uses this unverified highest ledger info to determine waypoint satisfiability: [3](#0-2) 

4. **Sync target selection without verification**: The streaming engine uses this unverified ledger info as the sync target: [4](#0-3) 

**The Vulnerability:**

`LedgerInfoWithSignatures` contains BLS signatures from validators that attest to blockchain state. The signature verification method exists: [5](#0-4) 

However, this verification is **never called** on advertised `synced_ledger_info` from peers. A Byzantine peer can craft a `LedgerInfoWithSignatures` with:
- Arbitrary high version number (e.g., `u64::MAX`)
- Invalid or empty BLS signatures
- Arbitrary state root hash pointing to non-existent or malicious chain state

**Attack Scenarios:**

1. **Waypoint Satisfiability Manipulation**: Advertise fake ledger info with `version > waypoint_version`, causing the bootstrapper to incorrectly believe the waypoint is satisfiable when the actual network hasn't reached it.

2. **Denial of Service**: Advertise extremely high version (e.g., billions ahead), causing nodes to waste resources trying to sync to non-existent data, as no honest peer can service these requests.

3. **Performance Degradation**: Selected as the "best" peer for sync requests due to highest version, but unable to provide valid data, causing repeated request failures and retries.

## Impact Explanation

This vulnerability qualifies as **High Severity** (potentially Critical depending on exploitation):

**High Severity Justification:**
- **Validator node slowdowns**: Nodes waste CPU/network resources attempting to sync to fake targets
- **Significant protocol violations**: Breaks the invariant that BLS signatures must be verified before trusting ledger info
- **Bootstrapping disruption**: New nodes or recovering nodes may fail to bootstrap correctly

**Potential Critical Impact:**
- If exploited widely, could cause **total loss of liveness** for nodes attempting to sync
- Could create **non-recoverable network partition** if nodes are misled to different sync states
- Breaks **Consensus Safety** invariant by allowing unverified ledger infos to guide node behavior

The vulnerability directly violates the "Cryptographic Correctness: BLS signatures, VRF, and hash operations must be secure" invariant, as BLS signatures are completely bypassed.

## Likelihood Explanation

**High Likelihood:**
- **Low complexity**: Byzantine peer simply needs to advertise a crafted `StorageServerSummary` with fake `synced_ledger_info`
- **No special privileges**: Any network peer can advertise storage summaries
- **No detection**: Malicious ledger infos are never flagged as invalid since signature verification is skipped
- **Wide attack surface**: Affects all nodes performing state sync (bootstrapping nodes, lagging full nodes, recovering validators)

The storage service populates `synced_ledger_info` from local storage: [6](#0-5) 

But malicious peers can construct arbitrary responses without ever calling this legitimate code path.

## Recommendation

**Implement mandatory signature verification** on all `synced_ledger_info` received from peers before inclusion in the global summary.

**Fix Location 1** - Add verification when updating peer summaries in `peer_states.rs`:

```rust
pub fn update_summary(&self, peer: PeerNetworkId, storage_summary: StorageServerSummary) {
    // Verify synced_ledger_info signatures if present
    if let Some(synced_ledger_info) = &storage_summary.data_summary.synced_ledger_info {
        // Get the current epoch state to verify signatures
        if let Ok(epoch_state) = get_current_epoch_state() {
            if let Err(e) = synced_ledger_info.verify_signatures(&epoch_state.verifier()) {
                warn!("Peer {} advertised invalid synced_ledger_info: {:?}", peer, e);
                self.update_score_error(peer, ErrorType::Malicious);
                return; // Reject the entire summary
            }
        }
    }
    
    self.peer_to_state
        .entry(peer)
        .or_insert(PeerState::new(self.data_client_config.clone()))
        .update_storage_summary(storage_summary);
}
```

**Fix Location 2** - Add verification in `highest_synced_ledger_info()` before returning:

```rust
pub fn highest_synced_ledger_info(&self) -> Option<LedgerInfoWithSignatures> {
    let highest_synced_position = self
        .synced_ledger_infos
        .iter()
        .enumerate()
        .filter(|(_, li)| {
            // Only consider ledger infos with valid signatures
            // This requires access to epoch state for verification
            verify_ledger_info_signatures(li).is_ok()
        })
        .map(|(idx, li)| (idx, li.ledger_info().version()))
        .max_by_key(|(_, version)| *version)
        .map(|(idx, _)| idx);

    highest_synced_position.and_then(|idx| self.synced_ledger_infos.get(idx).cloned())
}
```

**Additional Safeguards:**
1. Implement maximum version deviation checks (reject ledger infos more than N versions ahead of local state)
2. Cross-validate advertised versions across multiple peers before selection
3. Add metrics for tracking signature verification failures

## Proof of Concept

**Malicious Peer Setup:**

```rust
use aptos_types::ledger_info::{LedgerInfo, LedgerInfoWithSignatures};
use aptos_crypto::bls12381::Signature;
use aptos_storage_service_types::responses::{StorageServerSummary, DataSummary};

fn create_malicious_storage_summary() -> StorageServerSummary {
    // Create a fake ledger info with extremely high version
    let fake_ledger_info = LedgerInfo::new(
        BlockInfo::new(
            999999, // epoch
            0, // round  
            HashValue::zero(), // id
            HashValue::zero(), // executed_state_id
            u64::MAX - 1000, // version (extremely high)
            0, // timestamp
            None, // next_epoch_state
        ),
        HashValue::zero(), // consensus_data_hash
    );
    
    // Create LedgerInfoWithSignatures with EMPTY/INVALID signatures
    let fake_ledger_info_with_sigs = LedgerInfoWithSignatures::new(
        fake_ledger_info,
        AggregateSignature::empty(), // No actual validator signatures!
    );
    
    StorageServerSummary {
        protocol_metadata: ProtocolMetadata::default(),
        data_summary: DataSummary {
            synced_ledger_info: Some(fake_ledger_info_with_sigs),
            epoch_ending_ledger_infos: None,
            states: None,
            transactions: None,
            transaction_outputs: None,
        },
    }
}

#[test]
fn test_malicious_synced_ledger_info_accepted() {
    // Setup peer states
    let peer_states = PeerStates::new(Arc::new(AptosDataClientConfig::default()));
    let byzantine_peer = PeerNetworkId::random();
    
    // Byzantine peer advertises fake high-version ledger info
    let malicious_summary = create_malicious_storage_summary();
    peer_states.update_summary(byzantine_peer, malicious_summary);
    
    // Calculate global summary
    let global_summary = peer_states.calculate_global_data_summary();
    
    // VULNERABILITY: The fake ledger info is selected as highest!
    let highest = global_summary.advertised_data.highest_synced_ledger_info().unwrap();
    assert_eq!(highest.ledger_info().version(), u64::MAX - 1000);
    
    // The empty signatures were NEVER verified - this should have failed!
    // But it didn't, demonstrating the vulnerability.
}
```

**Notes:**
- This PoC demonstrates how easily a Byzantine peer can inject unverified ledger infos
- In a real attack, the malicious peer would respond to storage service summary requests with this crafted response
- The vulnerability allows the attack to succeed because signature verification is completely bypassed
- Honest nodes attempting to sync would select this fake target and waste resources

### Citations

**File:** state-sync/aptos-data-client/src/peer_states.rs (L374-378)
```rust
            if let Some(synced_ledger_info) = summary.data_summary.synced_ledger_info.as_ref() {
                advertised_data
                    .synced_ledger_infos
                    .push(synced_ledger_info.clone());
            }
```

**File:** state-sync/aptos-data-client/src/global_summary.rs (L184-198)
```rust
    pub fn highest_synced_ledger_info(&self) -> Option<LedgerInfoWithSignatures> {
        let highest_synced_position = self
            .synced_ledger_infos
            .iter()
            .map(|ledger_info_with_sigs| ledger_info_with_sigs.ledger_info().version())
            .position_max();

        if let Some(highest_synced_position) = highest_synced_position {
            self.synced_ledger_infos
                .get(highest_synced_position)
                .cloned()
        } else {
            None
        }
    }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L894-914)
```rust
        let highest_advertised_ledger_info = global_data_summary
            .advertised_data
            .highest_synced_ledger_info()
            .ok_or_else(|| {
                Error::UnsatisfiableWaypoint(
                    "Unable to check waypoint satisfiability! No highest advertised ledger info found in the network!".into(),
                )
            })?;
        let highest_advertised_version = highest_advertised_ledger_info.ledger_info().version();

        // Compare the highest advertised version with our waypoint
        if highest_advertised_version < waypoint_version {
            Err(Error::UnsatisfiableWaypoint(
                format!(
                    "The waypoint is not satisfiable! No advertised version higher than our waypoint! Highest version: {:?}, waypoint version: {:?}.",
                    highest_advertised_version, waypoint_version
                )
            ))
        } else {
            Ok(())
        }
```

**File:** state-sync/data-streaming-service/src/stream_engine.rs (L498-535)
```rust
    fn select_target_ledger_info(
        &self,
        advertised_data: &AdvertisedData,
    ) -> Result<Option<LedgerInfoWithSignatures>, Error> {
        // Check if the stream has a final target ledger info
        match &self.request {
            StreamRequest::ContinuouslyStreamTransactions(request) => {
                if let Some(target) = &request.target {
                    return Ok(Some(target.clone()));
                }
            },
            StreamRequest::ContinuouslyStreamTransactionOutputs(request) => {
                if let Some(target) = &request.target {
                    return Ok(Some(target.clone()));
                }
            },
            StreamRequest::ContinuouslyStreamTransactionsOrOutputs(request) => {
                if let Some(target) = &request.target {
                    return Ok(Some(target.clone()));
                }
            },
            request => invalid_stream_request!(request),
        };

        // We don't have a final target, select the highest to make progress
        if let Some(highest_synced_ledger_info) = advertised_data.highest_synced_ledger_info() {
            let (next_request_version, _) = self.next_request_version_and_epoch;
            if next_request_version > highest_synced_ledger_info.ledger_info().version() {
                Ok(None) // We're already at the highest synced ledger info. There's no known target.
            } else {
                Ok(Some(highest_synced_ledger_info))
            }
        } else {
            Err(Error::DataIsUnavailable(
                "Unable to find the highest synced ledger info!".into(),
            ))
        }
    }
```

**File:** types/src/ledger_info.rs (L303-308)
```rust
    pub fn verify_signatures(
        &self,
        validator: &ValidatorVerifier,
    ) -> ::std::result::Result<(), VerifyError> {
        validator.verify_multi_signatures(self.ledger_info(), &self.signatures)
    }
```

**File:** state-sync/storage-service/server/src/storage.rs (L1036-1073)
```rust
    fn get_data_summary(&self) -> aptos_storage_service_types::Result<DataSummary, Error> {
        // Fetch the latest ledger info
        let latest_ledger_info_with_sigs = self.storage.get_latest_ledger_info()?;

        // Fetch the epoch ending ledger info range
        let latest_ledger_info = latest_ledger_info_with_sigs.ledger_info();
        let epoch_ending_ledger_infos = if latest_ledger_info.ends_epoch() {
            let highest_ending_epoch = latest_ledger_info.epoch();
            Some(CompleteDataRange::from_genesis(highest_ending_epoch))
        } else if latest_ledger_info.epoch() > 0 {
            let highest_ending_epoch =
                latest_ledger_info.epoch().checked_sub(1).ok_or_else(|| {
                    Error::UnexpectedErrorEncountered("Highest ending epoch overflowed!".into())
                })?;
            Some(CompleteDataRange::from_genesis(highest_ending_epoch))
        } else {
            None // We haven't seen an epoch change yet
        };

        // Fetch the transaction and transaction output ranges
        let latest_version = latest_ledger_info.version();
        let transactions = self.fetch_transaction_range(latest_version)?;
        let transaction_outputs = self.fetch_transaction_output_range(latest_version)?;

        // Fetch the state values range
        let states = self.fetch_state_values_range(latest_version, &transactions)?;

        // Return the relevant data summary
        let data_summary = DataSummary {
            synced_ledger_info: Some(latest_ledger_info_with_sigs),
            epoch_ending_ledger_infos,
            transactions,
            transaction_outputs,
            states,
        };

        Ok(data_summary)
    }
```
