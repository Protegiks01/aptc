# Audit Report

## Title
Zero-Stake Validators Can Join Genesis Breaking Minimum Stake Requirements and Economic Security

## Summary
The genesis configuration validation does not prevent `minimum_stake` from being set to 0, allowing validators to join the validator set with zero stake during genesis initialization. This breaks the fundamental economic security model where validators must have capital at risk.

## Finding Description

The `validate_required_stake` function in the staking configuration module only validates that the minimum stake is less than or equal to the maximum stake and that the maximum is non-zero, but **does not enforce that minimum_stake itself must be greater than zero**. [1](#0-0) 

This validation function is called during genesis initialization: [2](#0-1) 

When a genesis configuration file (`layout.yaml`) is created with `min_stake: 0`, this value passes validation and gets stored in the on-chain `StakingConfig` resource: [3](#0-2) 

The Rust-side validation in the genesis tooling also relies on this same minimum stake value from the layout: [4](#0-3) 

When validators join the validator set during genesis (or post-genesis), the validation check compares voting power against the minimum stake: [5](#0-4) 

If `minimum_stake` is 0, the assertion `voting_power >= 0` always passes, allowing validators with zero stake (and thus zero voting power) to join the active validator set. The voting power is calculated as the sum of stake amounts: [6](#0-5) 

**Attack Path:**
1. Create a genesis `layout.yaml` file with `min_stake: 0`
2. Create `ValidatorConfiguration` entries with `stake_amount: 0`
3. Run genesis generation - all validations pass
4. Validators with zero stake join the active validator set
5. These validators have zero voting power but participate in consensus messaging

## Impact Explanation

This is a **HIGH severity** vulnerability according to Aptos bug bounty criteria for "Significant protocol violations" and "Validator set manipulation":

**Economic Security Violation**: The core security assumption of Proof-of-Stake is that validators have capital at risk. Zero-stake validators have no economic incentive to behave honestly and no capital to lose if slashed. This fundamentally breaks the game-theoretic security of the consensus protocol.

**Validator Set Manipulation**: An attacker controlling genesis configuration can populate the validator set with zero-stake validators, potentially:
- Occupying validator slots (limited by `MAX_VALIDATOR_SET_SIZE` of 65,536) without economic commitment
- Creating Sybil validators to inflate perceived decentralization metrics
- Consuming network bandwidth and consensus resources with meaningless participation

**Consensus Protocol Impact**: While zero-stake validators' votes don't contribute to quorum (their voting power is 0), they still participate in the consensus protocol: [7](#0-6) 

**Governance Voting Power Distortion**: Zero-stake validators can exist in the validator set but contribute nothing to governance, potentially skewing voting power calculations and quorum thresholds.

**Violates Critical Invariant**: This breaks the "Staking Security" invariant that "validator rewards and penalties must be calculated correctly" - zero-stake validators cannot be properly incentivized through rewards or penalized through slashing.

## Likelihood Explanation

**Medium-to-High Likelihood:**

**For Test/Private Networks**: Any entity setting up a test network, private deployment, or development environment can trivially exploit this by setting `min_stake: 0` in their genesis configuration.

**For Production Networks**: While mainnet genesis would undergo review, the vulnerability represents a critical gap in validation logic that could be exploited during:
- Network hard forks requiring genesis regeneration
- Testnet-to-mainnet migration scenarios  
- Accidental misconfiguration during network upgrades

The exploit requires no special privileges beyond genesis configuration control and is trivial to execute (single parameter change in a YAML file).

## Recommendation

Add explicit validation to enforce that `minimum_stake` must be greater than zero:

```move
// In aptos-move/framework/aptos-framework/sources/configs/staking_config.move

// Add new error constant:
const EZERO_MINIMUM_STAKE: u64 = 12;

// Update validate_required_stake function:
fun validate_required_stake(minimum_stake: u64, maximum_stake: u64) {
    assert!(minimum_stake > 0, error::invalid_argument(EZERO_MINIMUM_STAKE));
    assert!(minimum_stake <= maximum_stake && maximum_stake > 0, error::invalid_argument(EINVALID_STAKE_RANGE));
}
```

Additionally, update the formal specification to document this requirement: [8](#0-7) 

The spec should be updated to:
```
aborts_if minimum_stake == 0 || minimum_stake > maximum_stake || maximum_stake == 0;
```

**Optional Enhancement**: Consider enforcing a hardcoded absolute minimum stake value (e.g., 1,000,000 APT base units) to prevent economically insignificant stakes even if the configured minimum is set very low.

## Proof of Concept

**Step 1: Create malicious genesis layout**

Create `layout.yaml`:
```yaml
root_key: "0xed25519_public_key_hex"
users: ["validator1"]
chain_id: 4
allow_new_validators: true
epoch_duration_secs: 7200
is_test: true
min_stake: 0                    # ← VULNERABILITY: Zero minimum stake
max_stake: 100000000000000000
recurring_lockup_duration_secs: 86400
required_proposer_stake: 0
rewards_apy_percentage: 10
voting_duration_secs: 43200
voting_power_increase_limit: 20
```

**Step 2: Create validator with zero stake**

Create `validator1/owner.yaml`:
```yaml
owner_account_address: "0xValidator1Address"
owner_account_public_key: "0xValidatorPublicKey"
operator_account_address: "0xOperatorAddress"
operator_account_public_key: "0xOperatorPublicKey"  
voter_account_address: "0xVoterAddress"
voter_account_public_key: "0xVoterPublicKey"
stake_amount: "0"               # ← EXPLOIT: Zero stake amount
commission_percentage: "0"
join_during_genesis: "true"
```

**Step 3: Generate genesis**

Run the genesis generation tool:
```bash
aptos genesis generate-genesis --local-repository-dir ./genesis-config
```

**Expected Result**: Genesis generation succeeds, producing a `genesis.blob` with a validator having zero stake in the active validator set.

**Verification**: Query the resulting genesis state to confirm `StakingConfig.minimum_stake == 0` and the validator exists in the active set with `voting_power == 0`.

This PoC demonstrates that the validation logic permits zero-stake validators, violating the fundamental economic security requirements of the staking system.

## Notes

This vulnerability is particularly concerning because it exists at the genesis layer where there is often less scrutiny compared to runtime transaction validation. The formal verification specifications also fail to catch this issue, as evidenced by the spec file only checking for the invalid stake range but not for zero minimum stake.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/staking_config.move (L93-106)
```text
    public(friend) fun initialize(
        aptos_framework: &signer,
        minimum_stake: u64,
        maximum_stake: u64,
        recurring_lockup_duration_secs: u64,
        allow_validator_set_change: bool,
        rewards_rate: u64,
        rewards_rate_denominator: u64,
        voting_power_increase_limit: u64,
    ) {
        system_addresses::assert_aptos_framework(aptos_framework);

        // This can fail genesis but is necessary so that any misconfigurations can be corrected before genesis succeeds
        validate_required_stake(minimum_stake, maximum_stake);
```

**File:** aptos-move/framework/aptos-framework/sources/configs/staking_config.move (L126-134)
```text
        move_to(aptos_framework, StakingConfig {
            minimum_stake,
            maximum_stake,
            recurring_lockup_duration_secs,
            allow_validator_set_change,
            rewards_rate,
            rewards_rate_denominator,
            voting_power_increase_limit,
        });
```

**File:** aptos-move/framework/aptos-framework/sources/configs/staking_config.move (L372-374)
```text
    fun validate_required_stake(minimum_stake: u64, maximum_stake: u64) {
        assert!(minimum_stake <= maximum_stake && maximum_stake > 0, error::invalid_argument(EINVALID_STAKE_RANGE));
    }
```

**File:** crates/aptos/src/genesis/mod.rs (L701-712)
```rust
        if validator.stake_amount < layout.min_stake {
            errors.push(CliError::UnexpectedError(format!(
                "Validator {} has stake {} under the min stake {}",
                name, validator.stake_amount, layout.min_stake
            )));
        }
        if validator.stake_amount > layout.max_stake {
            errors.push(CliError::UnexpectedError(format!(
                "Validator {} has stake {} over the max stake {}",
                name, validator.stake_amount, layout.max_stake
            )));
        }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1072-1076)
```text
        let config = staking_config::get();
        let (minimum_stake, maximum_stake) = staking_config::get_required_stake(&config);
        let voting_power = get_next_epoch_voting_power(stake_pool);
        assert!(voting_power >= minimum_stake, error::invalid_argument(ESTAKE_TOO_LOW));
        assert!(voting_power <= maximum_stake, error::invalid_argument(ESTAKE_TOO_HIGH));
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1087-1094)
```text
        vector::push_back(
            &mut validator_set.pending_active,
            generate_validator_info(pool_address, stake_pool, *validator_config)
        );
        let validator_set_size = vector::length(&validator_set.active_validators) + vector::length(
            &validator_set.pending_active
        );
        assert!(validator_set_size <= MAX_VALIDATOR_SET_SIZE, error::invalid_argument(EVALIDATOR_SET_TOO_LARGE));
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1847-1855)
```text
    fun get_next_epoch_voting_power(stake_pool: &StakePool): u64 {
        let value_pending_active = coin::value(&stake_pool.pending_active);
        let value_active = coin::value(&stake_pool.active);
        let value_pending_inactive = coin::value(&stake_pool.pending_inactive);
        spec {
            assume value_pending_active + value_active + value_pending_inactive <= MAX_U64;
        };
        value_pending_active + value_active + value_pending_inactive
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/staking_config.spec.move (L112-113)
```text
        aborts_if addr != @aptos_framework;
        aborts_if minimum_stake > maximum_stake || maximum_stake == 0;
```
