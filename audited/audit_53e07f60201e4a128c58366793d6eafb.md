# Audit Report

## Title
Unicode Normalization Bypass in OIDC Provider Names Enables Keyless Authentication DoS

## Summary
The JWK consensus configuration system lacks Unicode normalization when validating OIDC provider names, allowing attackers to bypass duplicate detection by using visually-identical but byte-different provider names (e.g., with zero-width spaces). This causes JWK lookups to fail during keyless authentication, resulting in a Denial of Service for affected providers.

## Finding Description

The vulnerability exists in the provider name validation logic across multiple components:

**1. Duplicate Detection Bypass in Configuration**

The `new_v1` function performs duplicate checking using byte-level String comparison without Unicode normalization: [1](#0-0) 

This comparison treats Unicode-equivalent strings with different byte representations (e.g., NFC vs NFD normalization, or strings with zero-width spaces) as distinct, allowing them to pass the duplicate check.

**2. Issuer Mismatch in JWK Observer**

When JWKObserver fetches JWKs, it uses the configured provider name directly as the issuer: [2](#0-1) 

This means if the configured name has different bytes than the actual JWT issuer, JWKs are stored under incorrect issuer bytes.

**3. JWK Lookup Failure During Authentication**

When authenticating, the system looks up JWKs by matching the JWT's `iss` claim byte-for-byte: [3](#0-2) 

The lookup uses `issuer_from_str` which converts the issuer string to bytes without normalization: [4](#0-3) 

**Attack Scenario:**

1. Attacker submits governance proposal with provider name: `"https://accounts.google.com​"` (contains U+200B zero-width space)
2. Proposal passes duplicate check because bytes differ from legitimate provider (if one exists)
3. JWKObserver spawns and fetches Google's JWKs, but stores them under the malformed issuer bytes
4. User attempts keyless authentication with JWT from real Google (iss=`"https://accounts.google.com"` without zero-width space)
5. The JWT's `iss` claim validation passes: [5](#0-4) 

6. JWK lookup searches for correct issuer bytes but fails because JWKs are stored under malformed issuer bytes: [6](#0-5) 

7. Authentication fails with "JWK not found for issuer" error
8. All keyless authentication attempts for affected provider fail → DoS

## Impact Explanation

**Severity: Medium**

This vulnerability falls under the Medium severity category per Aptos bug bounty rules:
- **State inconsistencies requiring intervention**: Creates inconsistent state where provider names don't match actual JWT issuers, requiring governance action to remediate
- **Availability impact**: Causes Denial of Service for keyless authentication affecting potentially thousands of users if a major OIDC provider is targeted
- **Not fund loss or consensus break**: Does not directly steal funds or break consensus safety, preventing Critical classification

The impact is significant because:
- Keyless authentication becomes unavailable for the affected provider
- Requires governance proposal to remove malformed provider and add correct one
- Could target major providers (Google, Facebook, Apple) affecting many users
- Difficult to detect initially as provider name appears visually correct

## Likelihood Explanation

**Likelihood: Medium-Low**

The attack requires:
- **Governance approval**: Attacker must successfully pass a governance proposal, requiring significant voting power or social engineering
- **Technical sophistication**: Knowledge of Unicode normalization vulnerabilities
- **No validator access**: Can be executed without validator privileges

Mitigating factors:
- Governance proposals undergo community review
- Malformed provider names might be detected during review if carefully examined
- Requires attacker to gain sufficient voting power or convince legitimate voters

However, Unicode attacks are notoriously difficult to detect visually, making this more likely than typical governance attacks. Zero-width spaces and alternative normalizations are invisible to most reviewers.

## Recommendation

**1. Add Unicode Normalization to Provider Name Validation:**

Normalize all provider names to NFC (Canonical Composition) form before storing and comparing:

```move
// In jwk_consensus_config.move, new_v1 function
public fun new_v1(oidc_providers: vector<OIDCProvider>): JWKConsensusConfig {
    let name_set = simple_map::new<String, u64>();
    vector::for_each_ref(&oidc_providers, |provider| {
        let provider: &OIDCProvider = provider;
        // Normalize provider name before checking duplicates
        let normalized_name = normalize_unicode_nfc(provider.name);
        let (_, old_value) = simple_map::upsert(&mut name_set, normalized_name, 0);
        if (option::is_some(&old_value)) {
            abort(error::invalid_argument(EDUPLICATE_PROVIDERS))
        }
    });
    JWKConsensusConfig {
        variant: copyable_any::pack( ConfigV1 { oidc_providers } )
    }
}
```

**2. Add Provider Name Format Validation:**

Reject provider names containing:
- Zero-width spaces (U+200B, U+200C, U+200D)
- Other invisible Unicode characters
- Mixed normalization forms

```move
public fun validate_provider_name(name: String): bool {
    // Check for zero-width spaces
    let bytes = string::bytes(&name);
    let i = 0;
    while (i < vector::length(bytes)) {
        let byte = *vector::borrow(bytes, i);
        // Reject zero-width space (U+200B = E2 80 8B in UTF-8)
        if (i + 2 < vector::length(bytes) &&
            byte == 0xE2 && 
            *vector::borrow(bytes, i+1) == 0x80 && 
            *vector::borrow(bytes, i+2) == 0x8B) {
            return false
        };
        i = i + 1;
    };
    true
}
```

**3. Normalize in Rust Layer:**

Add normalization in the Rust conversion functions:

```rust
impl From<crate::on_chain_config::OIDCProvider> for OIDCProvider {
    fn from(value: crate::on_chain_config::OIDCProvider) -> Self {
        use unicode_normalization::UnicodeNormalization;
        let normalized_name = value.name.nfc().collect::<String>();
        OIDCProvider {
            name: normalized_name.as_bytes().to_vec(),
            config_url: value.config_url.as_bytes().to_vec(),
        }
    }
}
```

## Proof of Concept

```move
#[test]
#[expected_failure(abort_code = 0x010001, location = jwk_consensus_config)]
fun test_unicode_normalization_bypass() {
    use std::string::utf8;
    
    // Create two provider names that are visually identical but have different bytes
    // Provider 1: Normal "https://accounts.google.com"
    let normal_name = utf8(b"https://accounts.google.com");
    
    // Provider 2: With zero-width space at end (U+200B = E2 80 8B in UTF-8)
    let malformed_bytes = b"https://accounts.google.com";
    vector::append(&mut malformed_bytes, vector[0xE2, 0x80, 0x8B]);
    let malformed_name = utf8(malformed_bytes);
    
    // Both providers should be rejected due to duplication, but currently pass
    let config = new_v1(vector[
        new_oidc_provider(normal_name, utf8(b"https://accounts.google.com/.well-known/openid-configuration")),
        new_oidc_provider(malformed_name, utf8(b"https://accounts.google.com/.well-known/openid-configuration")),
    ]);
    
    // Test will fail if both providers are accepted (vulnerability exists)
    // Should abort with EDUPLICATE_PROVIDERS but currently doesn't
}

#[test]
fun test_jwk_lookup_fails_with_unicode_mismatch() {
    // Simulate JWK storage under malformed issuer
    let malformed_issuer = b"https://accounts.google.com";
    vector::append(&mut malformed_issuer, vector[0xE2, 0x80, 0x8B]); // zero-width space
    
    let jwks = AllProvidersJWKs {
        entries: vector[
            ProviderJWKs {
                issuer: malformed_issuer,
                version: 1,
                jwks: vector[/* JWKs here */],
            }
        ]
    };
    
    // Try to lookup with correct issuer (no zero-width space)
    let correct_issuer = "https://accounts.google.com";
    let result = jwks.get_provider_jwks(correct_issuer);
    
    // Lookup fails because byte comparison doesn't match
    assert!(option::is_none(&result), 1);
}
```

## Notes

The vulnerability stems from the fundamental assumption that String equality in Move performs Unicode normalization. In reality, Move String comparison is byte-level, identical to Rust's default String comparison. This creates a security gap where visually-identical strings can bypass duplicate detection.

The issue is exacerbated by the JWK system's architecture where the configured provider name becomes the issuer used for JWK storage, rather than fetching the actual issuer from the OIDC provider's metadata. This creates a tight coupling between configuration accuracy and authentication functionality.

No existing Unicode normalization or validation was found in the codebase: [7](#0-6) 

The `new_oidc_provider` constructor accepts arbitrary strings without validation, allowing this attack vector to exist.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/configs/jwk_consensus_config.move (L90-98)
```text
    public fun new_v1(oidc_providers: vector<OIDCProvider>): JWKConsensusConfig {
        let name_set = simple_map::new<String, u64>();
        vector::for_each_ref(&oidc_providers, |provider| {
            let provider: &OIDCProvider = provider;
            let (_, old_value) = simple_map::upsert(&mut name_set, provider.name, 0);
            if (option::is_some(&old_value)) {
                abort(error::invalid_argument(EDUPLICATE_PROVIDERS))
            }
        });
```

**File:** aptos-move/framework/aptos-framework/sources/configs/jwk_consensus_config.move (L105-107)
```text
    public fun new_oidc_provider(name: String, config_url: String): OIDCProvider {
        OIDCProvider { name, config_url }
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_observer.rs (L80-80)
```rust
                        let _ = observation_tx.push((), (issuer.as_bytes().to_vec(), jwks));
```

**File:** types/src/jwks/mod.rs (L48-50)
```rust
pub fn issuer_from_str(s: &str) -> Issuer {
    s.as_bytes().to_vec()
}
```

**File:** types/src/jwks/mod.rs (L225-229)
```rust
    pub fn get_provider_jwks(&self, iss: &str) -> Option<&ProviderJWKs> {
        self.entries
            .iter()
            .find(|&provider_jwk_set| provider_jwk_set.issuer.eq(&issuer_from_str(iss)))
    }
```

**File:** types/src/keyless/openid_sig.rs (L80-84)
```rust
        ensure!(
            claims.oidc_claims.iss.eq(&pk.iss_val),
            "'iss' claim was supposed to match \"{}\"",
            pk.iss_val
        );
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L121-126)
```rust
    let jwk_move_struct = jwks.get_jwk(&pk.iss_val, &jwt_header.kid).map_err(|_| {
        invalid_signature!(format!(
            "JWK for {} with KID {} was not found",
            pk.iss_val, jwt_header.kid
        ))
    })?;
```
