# Audit Report

## Title
Message-Agnostic Signature Verification Status Allows Invalid Commit Votes to Bypass Cryptographic Verification

## Summary
The `SignatureWithStatus` structure uses an `Arc<AtomicBool>` to track verification status without binding it to the specific message that was verified. When `CommitVotes` are added to a `SignatureAggregator` after the Executed stage, only the `BlockInfo` (not the full `LedgerInfo`) is validated. This allows a malicious validator to create a `CommitVote` with a different `consensus_data_hash` but matching `BlockInfo`, have it verified against their chosen message, then inject it into an aggregator expecting a different message. The stale verification status causes `filter_invalid_signatures` to skip cryptographic verification, potentially accepting invalid signatures for quorum formation.

## Finding Description
The vulnerability stems from three interconnected design issues:

**Issue 1: Message-Agnostic Verification Status** [1](#0-0) 

The `verification_status` field is a simple boolean that doesn't track which message was verified. Once set to `true`, it remains trusted regardless of the message context.

**Issue 2: Incomplete Validation in add_signature_if_matched** [2](#0-1) 

For Executed/Signed buffer items, only `commit_info` (BlockInfo) equality is checked, not the full `LedgerInfo`. However, signatures are cryptographically bound to the entire `LedgerInfo` structure: [3](#0-2) 

A `LedgerInfo` contains both `commit_info` and `consensus_data_hash`. Two different `LedgerInfo` instances can have identical `commit_info` but different `consensus_data_hash` values.

**Issue 3: Verification Status Short-Circuit** [4](#0-3) 

When `filter_invalid_signatures` processes signatures, it checks `signature.is_verified()` first. If true, it skips the cryptographic `verify()` call entirely (line 298-301). This short-circuit trusts the verification status regardless of the message being verified.

**Attack Execution:**

1. Honest node A advances a block to Executed stage with `commit_ledger_info = LedgerInfo(commit_info: B, consensus_data_hash: H_honest)`

2. Malicious validator M creates a malicious `CommitVote` with `ledger_info = LedgerInfo(commit_info: B, consensus_data_hash: H_malicious)` where `H_malicious ≠ H_honest`

3. M signs this vote, creating a valid BLS signature for their malicious `LedgerInfo`

4. M sends the vote to node A

5. Verification occurs (in verification task before reaching BufferManager): [5](#0-4) 

The signature is verified against `self.ledger_info` (M's malicious LedgerInfo), and if pessimistic verification is triggered, `verification_status` is set to `true`.

6. The vote reaches `add_signature_if_matched`:
   - Check: `vote.commit_info() == executed.commit_info` → `B == B` → **PASSES**
   - The signature (marked as verified for H_malicious) is added to aggregator (expecting H_honest)

7. When `aggregate_and_verify` runs and the aggregated signature fails verification, `filter_invalid_signatures` is called

8. For M's signature, `is_verified()` returns `true` (from step 5), so `verify(account, H_honest, signature)` is **SKIPPED**

9. The invalid signature passes through and contributes voting power toward quorum formation

This breaks the **Cryptographic Correctness** invariant: signatures invalid for the actual consensus message can be accepted, potentially allowing formation of invalid quorum certificates.

## Impact Explanation
**Critical Severity** - This vulnerability enables consensus safety violations:

- **Quorum Certificate Forgery**: Malicious validators can contribute invalid signatures to QC formation by crafting `CommitVotes` with matching `BlockInfo` but incorrect `consensus_data_hash`
- **Consensus Safety Break**: If enough malicious validators (< 1/3 Byzantine threshold) exploit this, they could form invalid quorum certificates that honest nodes accept
- **Chain Split Risk**: Different nodes might commit different blocks if invalid signatures are accepted in quorum formation
- **Deterministic Execution Violation**: Validators might commit different states despite executing the same blocks if consensus decisions are based on partially-invalid quorums

The attack requires only a single malicious validator and does not require validator collusion or >1/3 Byzantine stake, making it more dangerous than traditional BFT attacks.

## Likelihood Explanation
**High Likelihood**:

- **Easy to Trigger**: Any validator can craft malicious `CommitVotes` with matching `BlockInfo` but different `consensus_data_hash`
- **No Special Privileges Required**: Standard validator participation is sufficient
- **Optimistic Verification Enabled**: The vulnerability is more severe when optimistic signature verification is enabled (which is the default for performance): [6](#0-5) 

When optimistic verification is disabled or the author is in the pessimistic set, verification occurs immediately and sets `verification_status = true`, making the stale status reusable.

- **Race-Free Exploitation**: Unlike typical race conditions, this is a logical vulnerability that manifests deterministically whenever votes arrive after the Executed stage transition

## Recommendation
**Fix 1: Validate Full LedgerInfo in add_signature_if_matched**

Change the validation in `buffer_item.rs` to compare the full `LedgerInfo`:

```rust
Self::Executed(executed) => {
    // Compare full LedgerInfo, not just commit_info
    if executed.partial_commit_proof.data() == vote.ledger_info() {
        executed.partial_commit_proof.add_signature(author, signature);
        return Ok(());
    }
},
Self::Signed(signed) => {
    if signed.partial_commit_proof.data() == vote.ledger_info() {
        signed.partial_commit_proof.add_signature(author, signature);
        return Ok(());
    }
},
```

**Fix 2: Make Verification Status Message-Bound**

Modify `SignatureWithStatus` to track the message hash it was verified against:

```rust
pub struct SignatureWithStatus {
    signature: bls12381::Signature,
    verification_status: Arc<AtomicBool>,
    verified_message_hash: Arc<Mutex<Option<HashValue>>>, // New field
}
```

Update `filter_invalid_signatures` to always re-verify if the message has changed.

**Fix 3: Always Re-Verify in filter_invalid_signatures (Defense in Depth)**

Remove the `is_verified()` short-circuit or make it conditional on message hash matching:

```rust
if !signature.is_verified() || !signature.message_hash_matches(message) {
    if self.verify(account_address, message, signature.signature()).is_ok() {
        signature.set_verified_for(message);
        Some((account_address, signature))
    } else {
        self.add_pessimistic_verify_set(account_address);
        None
    }
} else {
    Some((account_address, signature))
}
```

## Proof of Concept
```rust
// Conceptual PoC demonstrating the vulnerability
#[test]
fn test_signature_verification_status_race() {
    let validator_signer = ValidatorSigner::random([0; 32]);
    let commit_info = BlockInfo::random();
    
    // Create two different LedgerInfos with same BlockInfo but different hashes
    let ledger_info_1 = LedgerInfo::new(commit_info.clone(), HashValue::random());
    let ledger_info_2 = LedgerInfo::new(commit_info.clone(), HashValue::random());
    
    // Malicious vote signed for ledger_info_1
    let malicious_vote = CommitVote::new(
        validator_signer.author(),
        ledger_info_1.clone(),
        &validator_signer,
    ).unwrap();
    
    // Verify the malicious vote (sets verification_status = true)
    malicious_vote.verify(validator_signer.author(), &validator_verifier).unwrap();
    assert!(malicious_vote.signature_with_status().is_verified());
    
    // Create aggregator for ledger_info_2 (different message!)
    let mut aggregator = SignatureAggregator::new(ledger_info_2.clone());
    
    // This should fail because the signature is for ledger_info_1, not ledger_info_2
    // But in the vulnerable code, if add_signature_if_matched only checks BlockInfo,
    // it would accept this signature and trust its verification_status
    
    // In BufferItem, this passes: malicious_vote.commit_info() == aggregator.data().commit_info()
    // The signature is added with verification_status = true (for wrong message)
    aggregator.add_signature(validator_signer.author(), malicious_vote.signature_with_status());
    
    // When filter_invalid_signatures runs, it sees is_verified() = true
    // and skips verification against ledger_info_2
    // The invalid signature passes through!
}
```

**Notes:**
The vulnerability is subtle because it relies on the interaction between three separate components: signature verification caching, partial message validation, and optimistic signature aggregation. The fix requires ensuring that any cached verification status is only trusted when it applies to the exact message being verified. The most robust solution is Fix 1 (full LedgerInfo validation) combined with Fix 2 (message-bound verification status) as defense-in-depth.

### Citations

**File:** types/src/ledger_info.rs (L51-59)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, CryptoHasher, BCSCryptoHash)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub struct LedgerInfo {
    commit_info: BlockInfo,

    /// Hash of consensus specific data that is opaque to all parts of the system other than
    /// consensus.
    consensus_data_hash: HashValue,
}
```

**File:** types/src/ledger_info.rs (L384-412)
```rust
#[derive(Clone, Debug, Derivative)]
#[derivative(PartialEq, Eq)]
pub struct SignatureWithStatus {
    signature: bls12381::Signature,
    #[derivative(PartialEq = "ignore")]
    // false if the signature not verified.
    // true if the signature is verified.
    verification_status: Arc<AtomicBool>,
}

impl SignatureWithStatus {
    pub(crate) fn set_verified(&self) {
        self.verification_status.store(true, Ordering::SeqCst);
    }

    pub fn signature(&self) -> &bls12381::Signature {
        &self.signature
    }

    pub fn from(signature: bls12381::Signature) -> Self {
        Self {
            signature,
            verification_status: Arc::new(AtomicBool::new(false)),
        }
    }

    pub fn is_verified(&self) -> bool {
        self.verification_status.load(Ordering::SeqCst)
    }
```

**File:** consensus/src/pipeline/buffer_item.rs (L393-399)
```rust
            Self::Executed(executed) => {
                if executed.commit_info == *target_commit_info {
                    executed
                        .partial_commit_proof
                        .add_signature(author, signature);
                    return Ok(());
                }
```

**File:** types/src/validator_verifier.rs (L269-285)
```rust
    pub fn optimistic_verify<T: Serialize + CryptoHash>(
        &self,
        author: AccountAddress,
        message: &T,
        signature_with_status: &SignatureWithStatus,
    ) -> std::result::Result<(), VerifyError> {
        if self.get_public_key(&author).is_none() {
            return Err(VerifyError::UnknownAuthor);
        }
        if (!self.optimistic_sig_verification || self.pessimistic_verify_set.contains(&author))
            && !signature_with_status.is_verified()
        {
            self.verify(author, message, signature_with_status.signature())?;
            signature_with_status.set_verified();
        }
        Ok(())
    }
```

**File:** types/src/validator_verifier.rs (L287-311)
```rust
    pub fn filter_invalid_signatures<T: Send + Sync + Serialize + CryptoHash>(
        &self,
        message: &T,
        signatures: BTreeMap<AccountAddress, SignatureWithStatus>,
    ) -> BTreeMap<AccountAddress, SignatureWithStatus> {
        signatures
            .into_iter()
            .collect_vec()
            .into_par_iter()
            .with_min_len(4) // At least 4 signatures are verified in each task
            .filter_map(|(account_address, signature)| {
                if signature.is_verified()
                    || self
                        .verify(account_address, message, signature.signature())
                        .is_ok()
                {
                    signature.set_verified();
                    Some((account_address, signature))
                } else {
                    self.add_pessimistic_verify_set(account_address);
                    None
                }
            })
            .collect()
    }
```

**File:** consensus/consensus-types/src/pipeline/commit_vote.rs (L103-113)
```rust
    pub fn verify(&self, sender: Author, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        ensure!(
            self.author() == sender,
            "Commit vote author {:?} doesn't match with the sender {:?}",
            self.author(),
            sender
        );
        validator
            .optimistic_verify(self.author(), &self.ledger_info, &self.signature)
            .context("Failed to verify Commit Vote")
    }
```
