# Audit Report

## Title
Token Name Uniqueness Constraint Violation in Aptos Token Objects Framework

## Summary
The Aptos Token Objects framework (`aptos-token-objects::token`) allows creation of multiple tokens with identical names within the same collection through the `create_token()` and `create()` functions, violating the documented invariant that token names should be unique within collections. This represents a regression from the older `aptos-token` standard which enforced this constraint.

## Finding Description

The `TokenResource` struct in the Rust types defines a `name()` accessor that returns the token name without validation: [1](#0-0) 

In the Move framework, the `Token` struct explicitly documents that token names should be unique within collections: [2](#0-1) 

However, the token creation logic provides two distinct creation paths with different uniqueness guarantees:

**Path 1: Named Token Creation (enforces uniqueness)**
Functions like `create_named_token()` use deterministic object addresses based on collection and token name: [3](#0-2) 

The seed computation ensures uniqueness: [4](#0-3) 

**Path 2: Random Token Creation (does NOT enforce uniqueness)**
Functions like `create_token()` use random object addresses: [5](#0-4) 

The internal creation logic validates only length constraints, not name uniqueness: [6](#0-5) 

The object creation prevents duplicate addresses but not duplicate names: [7](#0-6) 

**Critical Regression**: The older `aptos-token` standard explicitly enforced name uniqueness: [8](#0-7) 

An attacker can exploit this by repeatedly calling `create_token()` with identical names but different object addresses, creating confusion in marketplaces, indexers, and applications expecting unique token names.

## Impact Explanation

This qualifies as **High Severity** under "Significant protocol violations" because:

1. **State Inconsistency**: Multiple tokens with identical names violate the documented invariant, causing indexers and applications to malfunction
2. **Marketplace Manipulation**: Attackers can create counterfeit tokens with identical names to legitimate tokens, enabling phishing and scam attacks
3. **Protocol Regression**: The older token standard enforced this constraint; its removal without clear documentation creates security expectations mismatches
4. **Deterministic Execution Risk**: Different validators or nodes querying by name may get inconsistent results if ordering differs

While this doesn't directly cause funds loss or consensus violations, it enables significant attack vectors against ecosystem applications and violates documented protocol invariants.

## Likelihood Explanation

**Likelihood: HIGH**

- The vulnerability is trivially exploitable by any user without special permissions
- No gas costs prevent abuse (normal token creation fees apply)
- The attack requires no sophisticated knowledge beyond calling public functions
- Multiple tokens with identical names can be created in a single transaction
- The absence of validation makes exploitation guaranteed to succeed

## Recommendation

Add explicit name uniqueness validation in `create_common_with_collection_internal()`:

```move
inline fun create_common_with_collection_internal(
    constructor_ref: &ConstructorRef,
    collection: Object<Collection>,
    description: String,
    name_prefix: String,
    name_with_index_suffix: Option<String>,
    royalty: Option<Royalty>,
    uri: String,
) {
    // Existing length validations...
    
    // NEW: Validate name uniqueness within collection
    let collection_addr = object::object_address(&collection);
    assert!(
        !token_name_exists_in_collection(collection_addr, name_prefix),
        error::already_exists(ETOKEN_NAME_ALREADY_EXISTS)
    );
    
    // Rest of function...
}
```

Add a helper to track token names per collection (similar to the old token standard's approach) or restrict `create_token()`/`create()` to only allow `create_named_token()` variants for deterministic uniqueness.

## Proof of Concept

```move
#[test(creator = @0x123)]
fun test_duplicate_token_names_via_create_token(creator: &signer) acquires Token, TokenIdentifiers {
    use aptos_token_objects::collection;
    
    let collection_name = string::utf8(b"Test Collection");
    let token_name = string::utf8(b"Duplicate Name Token");
    
    // Create collection allowing 10 tokens
    collection::create_unlimited_collection(
        creator,
        string::utf8(b"description"),
        collection_name,
        option::none(),
        string::utf8(b"uri"),
    );
    
    let creator_addr = signer::address_of(creator);
    let collection_addr = collection::create_collection_address(&creator_addr, &collection_name);
    let collection_obj = object::address_to_object<Collection>(collection_addr);
    
    // Create first token with name "Duplicate Name Token"
    let token1_ref = create_token(
        creator,
        collection_obj,
        string::utf8(b"description1"),
        token_name,
        option::none(),
        string::utf8(b"uri1"),
    );
    let token1_addr = object::address_from_constructor_ref(&token1_ref);
    
    // Create second token with SAME name "Duplicate Name Token" 
    // This should fail but doesn't - VULNERABILITY
    let token2_ref = create_token(
        creator,
        collection_obj,
        string::utf8(b"description2"),
        token_name, // Same name!
        option::none(),
        string::utf8(b"uri2"),
    );
    let token2_addr = object::address_from_constructor_ref(&token2_ref);
    
    // Both tokens exist with different addresses but identical names
    assert!(token1_addr != token2_addr, 1);
    let token1 = object::address_to_object<Token>(token1_addr);
    let token2 = object::address_to_object<Token>(token2_addr);
    
    // BOTH return the same name - uniqueness violated!
    assert!(name(token1) == name(token2), 2);
    assert!(name(token1) == token_name, 3);
}
```

## Notes

This vulnerability demonstrates a critical regression in the Aptos Token Objects V2 framework compared to the original token standard. While `create_named_token()` functions prevent duplicates through deterministic addressing, the `create_token()` and `create()` functions bypass this protection entirely. Applications and marketplaces built assuming token name uniqueness within collections are vulnerable to exploitation.

### Citations

**File:** types/src/account_config/resources/token.rs (L53-55)
```rust
    pub fn name(&self) -> &String {
        &self.name
    }
```

**File:** aptos-move/framework/aptos-token-objects/sources/token.move (L62-64)
```text
        /// The name of the token, which should be unique within the collection; the length of name
        /// should be smaller than 128, characters, eg: "Aptos Animal #1234"
        name: String,
```

**File:** aptos-move/framework/aptos-token-objects/sources/token.move (L210-221)
```text
    ) {
        if (name_with_index_suffix.is_some()) {
            // Be conservative, as we don't know what length the index will be, and assume worst case (20 chars in MAX_U64)
            assert!(
                name_prefix.length() + 20 + name_with_index_suffix.borrow().length() <= MAX_TOKEN_NAME_LENGTH,
                error::out_of_range(ETOKEN_NAME_TOO_LONG)
            );
        } else {
            assert!(name_prefix.length() <= MAX_TOKEN_NAME_LENGTH, error::out_of_range(ETOKEN_NAME_TOO_LONG));
        };
        assert!(description.length() <= MAX_DESCRIPTION_LENGTH, error::out_of_range(EDESCRIPTION_TOO_LONG));
        assert!(uri.length() <= MAX_URI_LENGTH, error::out_of_range(EURI_TOO_LONG));
```

**File:** aptos-move/framework/aptos-token-objects/sources/token.move (L264-285)
```text
    public fun create_token(
        creator: &signer,
        collection: Object<Collection>,
        description: String,
        name: String,
        royalty: Option<Royalty>,
        uri: String,
    ): ConstructorRef {
        let creator_address = signer::address_of(creator);
        let constructor_ref = object::create_object(creator_address);
        create_common_with_collection(
            creator,
            &constructor_ref,
            collection,
            description,
            name,
            option::none(),
            royalty,
            uri
        );
        constructor_ref
    }
```

**File:** aptos-move/framework/aptos-token-objects/sources/token.move (L450-472)
```text
    public fun create_named_token(
        creator: &signer,
        collection_name: String,
        description: String,
        name: String,
        royalty: Option<Royalty>,
        uri: String,
    ): ConstructorRef {
        let seed = create_token_seed(&collection_name, &name);

        let constructor_ref = object::create_named_object(creator, seed);
        create_common(
            creator,
            &constructor_ref,
            collection_name,
            description,
            name,
            option::none(),
            royalty,
            uri
        );
        constructor_ref
    }
```

**File:** aptos-move/framework/aptos-token-objects/sources/token.move (L581-587)
```text
    public fun create_token_seed(collection: &String, name: &String): vector<u8> {
        assert!(name.length() <= MAX_TOKEN_NAME_LENGTH, error::out_of_range(ETOKEN_NAME_TOO_LONG));
        let seed = *collection.bytes();
        seed.append(b"::");
        seed.append(*name.bytes());
        seed
    }
```

**File:** aptos-move/framework/aptos-framework/sources/object.move (L318-339)
```text
    fun create_object_internal(
        creator_address: address,
        object: address,
        can_delete: bool,
    ): ConstructorRef {
        assert!(!exists<ObjectCore>(object), error::already_exists(EOBJECT_EXISTS));

        let object_signer = create_signer(object);
        let guid_creation_num = INIT_GUID_CREATION_NUM;
        let transfer_events_guid = guid::create(object, &mut guid_creation_num);

        move_to(
            &object_signer,
            ObjectCore {
                guid_creation_num,
                owner: creator_address,
                allow_ungated_transfer: true,
                transfer_events: event::new_event_handle(transfer_events_guid),
            },
        );
        ConstructorRef { self: object, can_delete }
    }
```

**File:** aptos-move/framework/aptos-token/sources/token.move (L1282-1285)
```text
        assert!(
            !collections.token_data.contains(token_data_id),
            error::already_exists(ETOKEN_DATA_ALREADY_EXISTS),
        );
```
