# Audit Report

## Title
Native Function Panic Risk Due to Missing Bounds Validation in String Operations

## Summary
The `native_sub_string` function assumes bytecode verifier has validated string slice indices, but lacks defensive bounds checking. If a verifier bug allows out-of-bounds indices to reach this native function, it will panic and crash the validator node rather than returning a proper error.

## Finding Description

The Move VM's native string functions rely on verifier assumptions documented in the specified file. [1](#0-0) 

The `native_sub_string` function implements substring extraction without bounds validation: [2](#0-1) 

The function only checks if `j < i` but **does not validate** that `i` and `j` are within the string's length. The string slicing operation `s_str[i..j]` at line 133 will **panic** if indices are out of bounds - this is standard Rust behavior for slice operations.

The Move wrapper function `sub_string` performs comprehensive validation: [3](#0-2) 

However, the native function visibility is private: [4](#0-3) 

**Attack Path (requires verifier bug):**

1. A verifier bug allows malformed bytecode to bypass type safety or call validation
2. Malformed bytecode calls `internal_sub_string` with out-of-bounds indices `i` or `j`
3. Native function receives unchecked arguments through the interpreter: [5](#0-4) 
4. String slicing panics when `i > len` or `j > len`
5. Panic propagates to global panic handler: [6](#0-5) 
6. Since execution is not in VERIFIER or DESERIALIZER state, process exits with code 12

**Invariant Violations:**
- **Deterministic Execution**: Different validators might exhibit different panic behavior
- **Move VM Safety**: Panics bypass proper error handling and gas metering
- **Consensus Safety**: Node crashes during block execution could cause consensus disruption

## Impact Explanation

**High Severity** per Aptos bug bounty criteria:
- **Validator node crashes**: Panics during native function execution terminate the validator process
- **Significant protocol violations**: Bypasses normal error handling and gas metering mechanisms
- **Potential consensus impact**: If validators have different panic behaviors or timing, could cause divergence

This does not reach Critical severity because:
- No direct fund loss or theft
- No permanent consensus failure (validators can restart)
- Requires precondition of verifier bug to exploit

## Likelihood Explanation

**Medium-Low Likelihood:**

**Prerequisites:**
- Requires an undiscovered verifier bug that allows incorrect arguments to reach native functions
- Bytecode verification includes multiple layers: bounds checking, type safety, and instruction consistency [7](#0-6) 
- Private native functions can only be called from within their declaring module

**Mitigating Factors:**
- The bytecode verifier is extensively tested
- Multiple defense layers (verifier + Move wrapper validation)
- Runtime type checks provide additional safety [8](#0-7) 

**Risk Factors:**
- Native functions explicitly rely on verifier correctness per documentation
- No defensive bounds checking in native implementation
- Panics are unrecoverable during execution (unlike during verification)

## Recommendation

**Add defensive bounds checking in native functions:**

```rust
fn native_sub_string(
    gas_params: &SubStringGasParameters,
    _context: &mut NativeContext,
    _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> PartialVMResult<NativeResult> {
    debug_assert!(args.len() == 3);
    let j = pop_arg!(args, u64) as usize;
    let i = pop_arg!(args, u64) as usize;

    let s_arg = pop_arg!(args, VectorRef);
    let s_ref = s_arg.as_bytes_ref();
    let len = s_ref.as_slice().len();
    
    // DEFENSIVE CHECK: Validate bounds even though verifier should prevent this
    if j < i || i > len || j > len {
        return Ok(NativeResult::err(gas_params.base, EINVALID_INDEX));
    }
    
    let s_str = unsafe {
        std::str::from_utf8_unchecked(s_ref.as_slice())
    };
    
    // Additional safety: check character boundaries
    if !s_str.is_char_boundary(i) || !s_str.is_char_boundary(j) {
        return Ok(NativeResult::err(gas_params.base, EINVALID_INDEX));
    }
    
    let v = Value::vector_u8(s_str[i..j].as_bytes().iter().cloned());
    let cost = gas_params.base + gas_params.per_byte * NumBytes::new((j - i) as u64);
    NativeResult::map_partial_vm_result_one(cost, Ok(v))
}
```

**Alternative: Use safe slicing methods:**
Replace `s_str[i..j]` with `s_str.get(i..j)` which returns `Option` instead of panicking.

## Proof of Concept

A complete PoC requires demonstrating a verifier bug, which is beyond the scope of this analysis. However, the vulnerability can be conceptually demonstrated:

**Hypothetical scenario:**
```
// If verifier bug allows this to execute:
internal_sub_string(&b"hello", 0, 1000)  // j=1000 > len=5

// Expected: Return error/abort
// Actual: Panic and crash validator node
```

**Verification of panic behavior:**
The Rust standard library documentation confirms that `str[i..j]` panics on out-of-bounds access. The Aptos crash handler confirms that execution-time panics terminate the process.

**Notes:**

This finding represents a **defensive programming gap** rather than a directly exploitable vulnerability. The issue is contingent on the existence of a verifier bug, which has not been demonstrated. The bytecode verifier appears to properly validate function calls and argument types.

The security concern is that native functions act as the **last line of defense** but rely entirely on upstream validation. If any component in the verification chain fails, native functions will panic rather than gracefully handle invalid inputs. This violates the principle of defense-in-depth.

The comment in the specification explicitly acknowledges this design: "A common example is a VM invariant violation which should have been forbidden by the verifier" - indicating that native functions are expected to panic on verifier failures rather than handle them defensively.

While the current verifier implementation appears robust, adding defensive bounds checking would provide additional safety margin against potential future verifier bugs or unanticipated edge cases.

### Citations

**File:** third_party/move/move-vm/types/src/natives/function.rs (L28-34)
```rust
/// An execution that causes an invariant violation would not return a `NativeResult` but
/// return a `PartialVMError` error directly.
/// All native functions must return a `PartialVMResult<NativeResult>` where an `Err` is returned
/// when an error condition is met that should not charge for the execution. A common example
/// is a VM invariant violation which should have been forbidden by the verifier.
/// Errors (typically user errors and aborts) that are logically part of the function execution
/// must be expressed in a `NativeResult` with a cost and a VMStatus.
```

**File:** third_party/move/move-stdlib/src/natives/string.rs (L112-137)
```rust
fn native_sub_string(
    gas_params: &SubStringGasParameters,
    _context: &mut NativeContext,
    _ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> PartialVMResult<NativeResult> {
    debug_assert!(args.len() == 3);
    let j = pop_arg!(args, u64) as usize;
    let i = pop_arg!(args, u64) as usize;

    if j < i {
        // TODO: what abort code should we use here?
        return Ok(NativeResult::err(gas_params.base, 1));
    }

    let s_arg = pop_arg!(args, VectorRef);
    let s_ref = s_arg.as_bytes_ref();
    let s_str = unsafe {
        // This is safe because we guarantee the bytes to be utf8.
        std::str::from_utf8_unchecked(s_ref.as_slice())
    };
    let v = Value::vector_u8(s_str[i..j].as_bytes().iter().cloned());

    let cost = gas_params.base + gas_params.per_byte * NumBytes::new((j - i) as u64);
    NativeResult::map_partial_vm_result_one(cost, Ok(v))
}
```

**File:** third_party/move/move-stdlib/sources/string.move (L73-81)
```text
    public fun sub_string(s: &String, i: u64, j: u64): String {
        let bytes = &s.bytes;
        let l = vector::length(bytes);
        assert!(
            j <= l && i <= j && internal_is_char_boundary(bytes, i) && internal_is_char_boundary(bytes, j),
            EINVALID_INDEX
        );
        String{bytes: internal_sub_string(bytes, i, j)}
    }
```

**File:** third_party/move/move-stdlib/sources/string.move (L88-93)
```text
    // Native API
    native fun internal_check_utf8(v: &vector<u8>): bool;
    native fun internal_is_char_boundary(v: &vector<u8>, i: u64): bool;
    native fun internal_sub_string(v: &vector<u8>, i: u64, j: u64): vector<u8>;
    native fun internal_index_of(v: &vector<u8>, r: &vector<u8>): u64;
}
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L1054-1065)
```rust
        let num_param_tys = function.param_tys().len();
        let mut args = VecDeque::new();
        for i in (0..num_param_tys).rev() {
            if mask.is_captured(i) {
                args.push_front(captured.pop().ok_or_else(|| {
                    PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
                        .with_message("inconsistent number of captured arguments".to_string())
                })?)
            } else {
                args.push_front(self.operand_stack.pop()?)
            }
        }
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L1069-1086)
```rust
        if RTTCheck::should_perform_checks(&current_frame.function.function) {
            for i in (0..num_param_tys).rev() {
                let expected_ty = &function.param_tys()[i];
                if !mask.is_captured(i) {
                    let ty = self.operand_stack.pop_ty()?;
                    // For param type to argument, use assignability
                    if !ty_args.is_empty() {
                        let expected_ty = ty_builder.create_ty_with_subst(expected_ty, ty_args)?;
                        ty.paranoid_check_assignable(&expected_ty)?;
                    } else {
                        ty.paranoid_check_assignable(expected_ty)?;
                    }
                    arg_tys.push_front(ty);
                } else {
                    arg_tys.push_front(expected_ty.clone())
                }
            }
        }
```

**File:** crates/crash-handler/src/lib.rs (L48-57)
```rust
    // Do not kill the process if the panics happened at move-bytecode-verifier.
    // This is safe because the `state::get_state()` uses a thread_local for storing states. Thus the state can only be mutated to VERIFIER by the thread that's running the bytecode verifier.
    //
    // TODO: once `can_unwind` is stable, we should assert it. See https://github.com/rust-lang/rust/issues/92988.
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
```

**File:** third_party/move/move-bytecode-verifier/src/type_safety.rs (L284-306)
```rust
fn call(
    verifier: &mut TypeSafetyChecker,
    meter: &mut impl Meter,
    offset: CodeOffset,
    function_handle: &FunctionHandle,
    type_actuals: &Signature,
) -> PartialVMResult<()> {
    let parameters = verifier.resolver.signature_at(function_handle.parameters);
    for parameter in parameters.0.iter().rev() {
        let arg = safe_unwrap!(verifier.stack.pop());
        // For parameter to argument, use assignability
        if (type_actuals.is_empty() && !parameter.is_assignable_from(&arg))
            || (!type_actuals.is_empty()
                && !instantiate(parameter, type_actuals).is_assignable_from(&arg))
        {
            return Err(verifier.error(StatusCode::CALL_TYPE_MISMATCH_ERROR, offset));
        }
    }
    for return_type in &verifier.resolver.signature_at(function_handle.return_).0 {
        verifier.push(meter, instantiate(return_type, type_actuals))?
    }
    Ok(())
}
```
