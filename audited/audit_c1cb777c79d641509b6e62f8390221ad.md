# Audit Report

## Title
Byzantine Validators Can Selectively Censor Transactions Using Unsynchronized Local Filter Configuration

## Summary
Byzantine validators can configure their local `BlockTransactionFilterConfig` to selectively deny transactions from targeted senders without network consensus. When such a validator becomes the block proposer, transactions from censored addresses are filtered during block preparation, enabling targeted censorship while appearing to follow legitimate protocol rules. The lack of network-wide coordination on filter rules allows this censorship to occur with plausible deniability.

## Finding Description

The transaction filtering mechanism in Aptos consensus operates on locally-configured rules without network-wide synchronization. Each validator reads its `BlockTransactionFilterConfig` from its own node configuration file [1](#0-0) , with no mechanism to ensure consistency across validators.

The filter is applied at two critical points:

1. **During Block Preparation**: When a validator is selected as proposer, the `filter_block_transactions()` function removes transactions matching deny rules before the block is even created [2](#0-1) 

2. **During Proposal Validation**: Validators check received proposals for denied transactions using `check_denied_inline_transactions()` [3](#0-2) 

**Attack Scenario:**

A Byzantine validator can configure their `BlockTransactionFilter` with a deny rule targeting specific senders [4](#0-3) . The filter evaluation logic [5](#0-4)  allows matching transactions by sender address.

When this Byzantine validator becomes proposer:
1. They receive transactions from mempool including those from targeted addresses
2. The block preparation phase filters out denied transactions [6](#0-5) 
3. They propose a block excluding the censored transactions
4. Other validators receive the proposal containing no denied transactions (from their perspective)
5. The proposal passes validation since other validators' filters don't match the excluded transactions
6. The block commits, successfully censoring the targeted transactions

The mechanism provides plausible deniabilityâ€”the Byzantine validator can claim they're using legitimate filtering for compliance purposes, while the real configuration [7](#0-6)  is opaque to other network participants.

## Impact Explanation

This vulnerability enables **targeted transaction censorship** at the consensus layer. While it doesn't violate consensus safety (no double-spending or chain splits), it breaks censorship resistance guarantees that are fundamental to blockchain liveness properties.

**Severity: High** based on:
- Enables selective censorship of specific users/addresses
- Byzantine validator can maintain censorship during all rounds where they're selected as proposer
- Provides plausible deniability (appears as legitimate filtering)
- Violates blockchain neutrality and permissionless access principles
- Can be used for targeted denial of service against specific accounts

The impact is classified as "Significant protocol violations" under the High severity category, as it undermines the blockchain's core censorship resistance property while operating within apparent protocol compliance.

## Likelihood Explanation

**Likelihood: Medium-High**

**Requirements:**
- Attacker must be a validator with stake in the network (Byzantine validator assumption)
- Attacker must have access to configure their validator node's configuration file
- Attacker must be selected as block proposer (probability = validator's voting power / total voting power)

**Execution Complexity:** Low
- Simply requires modifying the `transaction_filters.consensus_filter` configuration in the node config
- No complex exploits or timing attacks needed
- Can be deployed persistently across epochs

**Practical Constraints:**
- Censorship only occurs during rounds where the Byzantine validator is proposer
- Censored transactions will eventually be included by honest proposers
- Sustained censorship requires either high voting power or collusion among multiple validators

However, even temporary censorship can be impactful for time-sensitive transactions (e.g., liquidations, governance votes, token swaps during volatile periods).

## Recommendation

Implement network-wide consensus on transaction filtering rules to prevent arbitrary local censorship:

1. **On-Chain Filter Registry**: Move filter rules to on-chain governance, requiring validator consensus for any filtering policies. Rules should be verifiable by all validators.

2. **Filter Rule Attestation**: Require validators to attest to their configured filters in their epoch registration. Discrepancies between attested and actual behavior can be challenged.

3. **Monitoring and Alerting**: Implement network-level monitoring to detect when validators systematically exclude certain transactions that other validators include. Flag validators showing censorship patterns.

4. **Remove Local Filter Configuration**: Deprecate the `consensus_filter` local configuration option, or restrict it to only allow network-agreed rules loaded from on-chain state.

5. **Transparency Requirements**: If local filtering is necessary for compliance, require validators to publicly declare their filtering policies and make them auditable.

**Code Fix Approach:**
Replace the local configuration loading [1](#0-0)  with a call to read filter rules from on-chain governance state, ensuring all validators use consistent filtering criteria.

## Proof of Concept

**Configuration Setup:**
```yaml
# Malicious validator's node config (consensus/src/config/node_config.yaml)
transaction_filters:
  consensus_filter:
    filter_enabled: true
    block_transaction_filter:
      block_transaction_rules:
        - Deny:
            - Transaction:
                Sender: "0xTARGET_ADDRESS"  # Address to censor
```

**Exploitation Steps:**

1. Byzantine validator V configures their node with the above filter targeting address `0xTARGET_ADDRESS`

2. User at `0xTARGET_ADDRESS` submits transactions to mempool

3. When V becomes proposer (via normal leader election):
   - V's `BlockPreparer.prepare_block()` invokes `filter_block_transactions()` 
   - Target's transactions are removed per the deny rule
   - V proposes a block without target's transactions

4. Other validators receive proposal:
   - They validate via `check_denied_inline_transactions()`
   - Their filters don't deny target's address
   - They find no denied transactions in the proposal
   - They vote for the block

5. Block commits successfully, censoring target's transactions for that round

**Observable Outcome:**
- Target's transactions remain in mempool but aren't included in V's blocks
- When other validators propose, target's transactions are included normally
- This creates a pattern of selective exclusion traceable to specific proposers

## Notes

This vulnerability relies on the design decision to allow local, unsynchronized transaction filtering configuration. While the filtering mechanism itself may be legitimate for regulatory compliance, the lack of network consensus on filtering rules creates an attack vector for Byzantine validators to abuse. The censorship is temporary and bounded by the Byzantine validator's share of block proposals, but can still cause meaningful harm for time-sensitive operations. Network operators should monitor for inconsistent filtering behavior across validators as a detection mechanism.

### Citations

**File:** consensus/src/epoch_manager.rs (L211-211)
```rust
        let consensus_txn_filter_config = node_config.transaction_filters.consensus_filter.clone();
```

**File:** consensus/src/block_preparer.rs (L91-98)
```rust
            let filtered_txns = filter_block_transactions(
                txn_filter_config,
                block_id,
                block_author,
                block_epoch,
                block_timestamp_usecs,
                txns,
            );
```

**File:** consensus/src/block_preparer.rs (L123-146)
```rust
fn filter_block_transactions(
    txn_filter_config: Arc<BlockTransactionFilterConfig>,
    block_id: HashValue,
    block_author: Option<AccountAddress>,
    block_epoch: u64,
    block_timestamp_usecs: u64,
    txns: Vec<SignedTransaction>,
) -> Vec<SignedTransaction> {
    // If the transaction filter is disabled, return early
    if !txn_filter_config.is_enabled() {
        return txns;
    }

    // Otherwise, filter the transactions
    txn_filter_config
        .block_transaction_filter()
        .filter_block_transactions(
            block_id,
            block_author,
            block_epoch,
            block_timestamp_usecs,
            txns,
        )
}
```

**File:** consensus/src/round_manager.rs (L1204-1214)
```rust
        if let Err(error) = self
            .block_store
            .check_denied_inline_transactions(&proposal, &self.block_txn_filter_config)
        {
            counters::REJECTED_PROPOSAL_DENY_TXN_COUNT.inc();
            bail!(
                "[RoundManager] Proposal for block {} contains denied inline transactions: {}. Dropping proposal!",
                proposal.id(),
                error
            );
        }
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L174-174)
```rust
    Sender(AccountAddress), // Matches any transaction sent by a specific account address
```

**File:** crates/aptos-transaction-filters/src/block_transaction_filter.rs (L29-59)
```rust
    pub fn allows_transaction(
        &self,
        block_id: HashValue,
        block_author: Option<AccountAddress>,
        block_epoch: u64,
        block_timestamp: u64,
        signed_transaction: &SignedTransaction,
    ) -> bool {
        // If the filter is empty, allow the transaction by default
        if self.is_empty() {
            return true;
        }

        // Check if any rule matches the block transaction
        for block_transaction_rule in &self.block_transaction_rules {
            if block_transaction_rule.matches(
                block_id,
                block_author,
                block_epoch,
                block_timestamp,
                signed_transaction,
            ) {
                return match block_transaction_rule {
                    BlockTransactionRule::Allow(_) => true,
                    BlockTransactionRule::Deny(_) => false,
                };
            }
        }

        true // No rules match (allow the block transaction by default)
    }
```

**File:** config/src/config/transaction_filters_config.rs (L90-123)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct BlockTransactionFilterConfig {
    filter_enabled: bool, // Whether the filter is enabled
    block_transaction_filter: BlockTransactionFilter, // The block transaction filter to apply
}

impl BlockTransactionFilterConfig {
    pub fn new(filter_enabled: bool, block_transaction_filter: BlockTransactionFilter) -> Self {
        Self {
            filter_enabled,
            block_transaction_filter,
        }
    }

    /// Returns true iff the filter is enabled and not empty
    pub fn is_enabled(&self) -> bool {
        self.filter_enabled && !self.block_transaction_filter.is_empty()
    }

    /// Returns a reference to the block transaction filter
    pub fn block_transaction_filter(&self) -> &BlockTransactionFilter {
        &self.block_transaction_filter
    }
}

impl Default for BlockTransactionFilterConfig {
    fn default() -> Self {
        Self {
            filter_enabled: false,                                     // Disable the filter
            block_transaction_filter: BlockTransactionFilter::empty(), // Use an empty filter
        }
    }
}
```
