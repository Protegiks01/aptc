# Audit Report

## Title
Aggregator V1 Delta Operations Bypass IO Gas Metering Leading to Unmetered Storage Operations

## Summary
Aggregator V1 delta operations bypass IO gas charging because deltas are materialized into storage writes after `charge_change_set()` has already executed. This allows attackers to perform storage read/write operations without paying the corresponding IO gas costs, while metrics still show compliant gas usage from other operations.

## Finding Description

The vulnerability exists in the gas charging flow for Aggregator V1 operations. The root cause is a mismatch between when gas is charged and when aggregator deltas are materialized into actual storage operations.

**The Flow:**

1. During transaction execution, aggregator operations (add/sub) create entries in `aggregator_v1_delta_set` within the VMChangeSet [1](#0-0) 

2. When `charge_change_set()` executes, it iterates over `write_set_size_iter()` to charge IO gas for writes [2](#0-1) 

3. However, `write_set_size_iter()` only includes `resource_write_set` and `aggregator_v1_write_set`, explicitly excluding `aggregator_v1_delta_set` [3](#0-2) 

4. Later, `try_materialize_aggregator_v1_delta_set()` converts the deltas into actual write operations by reading base values from storage and applying deltas [4](#0-3) 

5. These materialized writes are added to `aggregator_v1_write_set` but are never charged for IO gas, as evidenced by explicit TODO comments [5](#0-4) 

**The Bypass:**

The materialization process performs uncounted storage operations:
- **Storage reads**: Reading base aggregator values from storage to apply deltas
- **Storage writes**: Writing the materialized aggregator values back to storage

Neither operation charges IO gas because materialization occurs after `charge_change_set()` has completed.

**Metrics vs Reality:**

The `observe_gas()` function correctly reports `io_gas_used()` from the FeeStatement [6](#0-5) , but this only reflects the IO gas that was actually charged (which excludes aggregator materialization). Thus, metrics show "compliant" gas usage while significant storage operations remain unmetered.

## Impact Explanation

**Severity: Critical**

This vulnerability allows attackers to:

1. **Bypass IO Gas Limits**: Perform unlimited aggregator operations that translate into storage reads/writes without paying corresponding IO gas
2. **Resource Exhaustion**: Overwhelm validator nodes with unmetered storage I/O operations
3. **Economic Exploit**: Conduct transactions with artificially low gas costs by using aggregator operations instead of regular storage operations
4. **Consensus Impact**: Different validators may have different resource constraints, potentially causing execution divergence if some validators run out of resources while processing "compliant" transactions

The impact qualifies as **Critical** severity because:
- It breaks the resource limits invariant (Invariant #9: "All operations must respect gas, storage, and computational limits")
- It enables resource exhaustion attacks on validator infrastructure
- It allows attackers to perform operations without proper payment, undermining the gas mechanism's economic security

## Likelihood Explanation

**Likelihood: High**

The vulnerability is highly likely to be exploited because:

1. **No Special Privileges Required**: Any transaction sender can use aggregator operations through native function calls
2. **Explicit Documentation**: The TODO comments acknowledge this as a known incomplete implementation [7](#0-6) 
3. **Active Use**: Aggregator V1 is still functional despite deprecation plans
4. **Easy Detection**: An attacker can easily verify the bypass by comparing gas charged vs operations performed
5. **Repeatable**: The attack can be conducted in every transaction involving aggregator operations

## Recommendation

**Immediate Fix:**

Charge IO gas for aggregator materialization operations. The fix should be implemented in two locations:

1. **Before Materialization**: Calculate the expected IO gas cost for all pending aggregator deltas before calling `try_materialize_aggregator_v1_delta_set()`

2. **Charge for Reads and Writes**: 
   - Charge IO gas for reading base values during delta application
   - Charge IO gas for the resulting write operations

**Implementation approach:**

```rust
// In charge_change_set_and_respawn_session or similar location
// Before returning, charge for pending aggregator deltas

// Count pending aggregator v1 deltas
for (key, _delta) in change_set.aggregator_v1_delta_set() {
    // Estimate read cost for base value
    let read_cost = io_pricing.calculate_read_gas(true, estimate_aggregator_size(key));
    gas_meter.charge_io(read_cost)?;
    
    // Estimate write cost for materialized value  
    let write_op_size = WriteOpSize::Modification { write_len: estimate_aggregator_size(key) };
    let write_cost = io_pricing.io_gas_per_write(key, &write_op_size);
    gas_meter.charge_io(write_cost)?;
}
```

**Long-term Fix:**

Accelerate the deprecation of Aggregator V1 and migration to Aggregator V2, which should have proper gas accounting from the design phase.

## Proof of Concept

```move
// aggregator_gas_bypass.move
module attacker::gas_bypass {
    use aptos_framework::aggregator_v2;
    use std::signer;

    struct AggregatorStore has key {
        counter: aggregator_v2::Aggregator<u64>
    }

    // Initialize multiple aggregators
    public entry fun setup(account: &signer) {
        move_to(account, AggregatorStore {
            counter: aggregator_v2::create_aggregator(1000000)
        });
    }

    // Perform many aggregator operations
    // Each operation creates a delta that bypasses IO gas during materialization
    public entry fun exploit(account: &signer) acquires AggregatorStore {
        let store = borrow_global_mut<AggregatorStore>(signer::address_of(account));
        
        // Perform 1000 aggregator operations
        // Only pays execution gas for the native function calls
        // Does NOT pay IO gas for the 1000 storage reads + writes during materialization
        let i = 0;
        while (i < 1000) {
            aggregator_v2::add(&mut store.counter, 1);
            i = i + 1;
        };
    }
}
```

**Rust Test to Verify:**

```rust
// In aptos-move/aptos-vm/tests/
#[test]
fn test_aggregator_io_gas_bypass() {
    // 1. Execute transaction with aggregator operations
    // 2. Record io_gas_used from FeeStatement
    // 3. Count actual storage operations during materialization
    // 4. Assert: IO gas charged < actual IO operations performed
    // Expected: Test passes, confirming the bypass
}
```

**Notes**

This vulnerability specifically affects Aggregator V1 operations. The issue is explicitly documented in the codebase via TODO comments, indicating it's a known incomplete implementation. While Aggregator V1 is being deprecated in favor of V2, it remains active in the current codebase and exploitable. The vulnerability breaks the fundamental invariant that all storage operations must be properly metered for gas, enabling both resource exhaustion attacks and economic exploits through artificially cheap transactions.

### Citations

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L81-92)
```rust
pub struct VMChangeSet {
    resource_write_set: BTreeMap<StateKey, AbstractResourceWriteOp>,
    events: Vec<(ContractEvent, Option<MoveTypeLayout>)>,

    // Changes separated out from the writes, for better concurrency,
    // materialized back into resources when transaction output is computed.
    delayed_field_change_set: BTreeMap<DelayedFieldID, DelayedChange<DelayedFieldID>>,

    // TODO[agg_v1](cleanup) deprecate aggregator_v1 fields.
    aggregator_v1_write_set: BTreeMap<StateKey, WriteOp>,
    aggregator_v1_delta_set: BTreeMap<StateKey, DeltaOp>,
}
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L365-399)
```rust
    /// Materializes this change set: all aggregator v1 deltas are converted into writes and
    /// are combined with existing aggregator writes. The aggregator v2 changeset is not touched.
    pub fn try_materialize_aggregator_v1_delta_set(
        &mut self,
        resolver: &impl AggregatorV1Resolver,
    ) -> VMResult<()> {
        let into_write =
            |(state_key, delta): (StateKey, DeltaOp)| -> VMResult<(StateKey, WriteOp)> {
                // Materialization is needed when committing a transaction, so
                // we need precise mode to compute the true value of an
                // aggregator.
                let write = resolver
                    .try_convert_aggregator_v1_delta_into_write_op(&state_key, &delta)
                    .map_err(|e| {
                        // We need to set abort location for Aggregator V1 to ensure correct VMStatus can
                        // be constructed.
                        const AGGREGATOR_V1_ADDRESS: AccountAddress = CORE_CODE_ADDRESS;
                        const AGGREGATOR_V1_MODULE_NAME: &IdentStr = ident_str!("aggregator");
                        e.finish(Location::Module(ModuleId::new(
                            AGGREGATOR_V1_ADDRESS,
                            AGGREGATOR_V1_MODULE_NAME.into(),
                        )))
                    })?;
                Ok((state_key, write))
            };

        let aggregator_v1_delta_set = std::mem::take(&mut self.aggregator_v1_delta_set);
        let materialized_aggregator_delta_set = aggregator_v1_delta_set
            .into_iter()
            .map(into_write)
            .collect::<VMResult<BTreeMap<StateKey, WriteOp>>>()?;
        self.aggregator_v1_write_set
            .extend(materialized_aggregator_delta_set);
        Ok(())
    }
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L862-871)
```rust
    fn write_set_size_iter(&self) -> impl Iterator<Item = (&StateKey, WriteOpSize)> {
        self.resource_write_set()
            .iter()
            .map(|(k, v)| (k, v.materialized_size()))
            .chain(
                self.aggregator_v1_write_set()
                    .iter()
                    .map(|(k, v)| (k, v.write_op_size())),
            )
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1120-1126)
```rust
        gas_meter.charge_io_gas_for_transaction(txn_data.transaction_size())?;
        for event in change_set.events_iter() {
            gas_meter.charge_io_gas_for_event(event)?;
        }
        for (key, op_size) in change_set.write_set_size_iter() {
            gas_meter.charge_io_gas_for_write(key, &op_size)?;
        }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1158-1158)
```rust
        // TODO[agg_v1](fix): Charge for aggregator writes
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1350-1350)
```rust
        // TODO(Gas): Charge for aggregator writes
```

**File:** aptos-move/block-executor/src/counters.rs (L270-273)
```rust
    counter.observe_with(
        &[mode_str, GasType::IO_GAS],
        fee_statement.io_gas_used() as f64,
    );
```
