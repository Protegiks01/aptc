# Audit Report

## Title
Empty Username in SetValidatorConfiguration Causes File Path Collision and Validator Configuration Overwrite

## Summary
The `SetValidatorConfiguration` command in the genesis ceremony accepts an empty string as a username parameter without validation, causing validator configuration files to be written to the repository root directory instead of a validator-specific subdirectory. This allows multiple validators using empty usernames to overwrite each other's configurations, resulting in permanent loss of validator setup data during the genesis ceremony.

## Finding Description

The vulnerability exists in the genesis setup process where validators configure their parameters before genesis generation. The `SetValidatorConfiguration` struct accepts a username parameter that is directly used to construct file paths without validation. [1](#0-0) 

The username is used to create a directory path: [2](#0-1) 

When username is an empty string (`""`), `PathBuf::from("")` creates an empty path. Subsequently, joining this with `OPERATOR_FILE` and `OWNER_FILE` results in files being written directly to the repository root: `"operator.yaml"` and `"owner.yaml"` instead of `"username/operator.yaml"` and `"username/owner.yaml"`.

These files are then written via the git client: [3](#0-2) 

The git client's `put` method writes files to the specified paths: [4](#0-3) 

**Attack Scenario:**

1. Validator A executes: `aptos genesis set-validator-configuration --username ""` → writes to `operator.yaml` and `owner.yaml` at repository root
2. Validator B executes: `aptos genesis set-validator-configuration --username ""` → overwrites the same `operator.yaml` and `owner.yaml` files
3. Validator A's configuration is permanently lost
4. During genesis generation, if the layout contains both validators, only one configuration exists

The genesis generation process constructs paths from usernames in the same way: [5](#0-4) 

## Impact Explanation

This is a **High Severity** operational vulnerability affecting genesis ceremony integrity:

- **Data Loss**: Validator configurations (consensus keys, network keys, stake amounts, host information) are permanently overwritten with no warning or error
- **Genesis Ceremony Disruption**: Multiple validators may be excluded from genesis if their configurations are lost
- **Silent Failure**: The overwrite happens without any validation or error message at configuration time
- **Significant Protocol Violation**: The genesis ceremony is a critical one-time setup that establishes the initial validator set and chain state

While this occurs during genesis setup rather than runtime operation, it represents a significant protocol violation in the genesis ceremony process, qualifying as High Severity under the bug bounty criteria.

## Likelihood Explanation

**Likelihood: Medium to High**

This can occur through:
- **Accidental**: Scripts or automation that fail to properly set the username parameter
- **Human Error**: Validators unfamiliar with the process who don't understand the username requirement
- **Copy-Paste Errors**: Using example commands without modifying the username field
- **Malicious**: An attacker who discovers another validator using empty username could intentionally overwrite their configuration

The vulnerability requires no special privileges - any participant in the genesis ceremony can trigger it by simply omitting or emptying the username parameter.

## Recommendation

Add validation to ensure username is non-empty and contains only valid path characters:

```rust
pub struct SetValidatorConfiguration {
    /// Name of the validator
    #[clap(long)]
    pub(crate) username: String,
    // ... other fields
}

impl SetValidatorConfiguration {
    fn validate_username(&self) -> CliTypedResult<()> {
        if self.username.is_empty() {
            return Err(CliError::CommandArgumentError(
                "Username cannot be empty. Please provide a valid validator username.".to_string()
            ));
        }
        
        if self.username.contains('/') || self.username.contains('\\') {
            return Err(CliError::CommandArgumentError(
                "Username cannot contain path separators (/ or \\).".to_string()
            ));
        }
        
        if self.username == "." || self.username == ".." {
            return Err(CliError::CommandArgumentError(
                "Username cannot be '.' or '..'.".to_string()
            ));
        }
        
        Ok(())
    }
}
```

Call this validation at the beginning of the `execute` method: [6](#0-5) 

Add after this line:
```rust
self.validate_username()?;
```

## Proof of Concept

**Setup:**
```bash
# Create a test git repository for genesis
mkdir genesis-test && cd genesis-test
git init

# Generate keys for Validator A
mkdir validator-a
cd validator-a
aptos genesis generate-keys --output-dir .
cd ..

# Set configuration for Validator A with empty username
aptos genesis set-validator-configuration \
  --username "" \
  --owner-public-identity-file validator-a/public-keys.yaml \
  --validator-host "127.0.0.1:6180" \
  --stake-amount 100000000000000 \
  --local-repository-dir .

# Verify files exist at root
ls -la operator.yaml owner.yaml

# Generate keys for Validator B
mkdir validator-b
cd validator-b
aptos genesis generate-keys --output-dir .
cd ..

# Set configuration for Validator B with empty username (overwrites A)
aptos genesis set-validator-configuration \
  --username "" \
  --owner-public-identity-file validator-b/public-keys.yaml \
  --validator-host "127.0.0.1:6181" \
  --stake-amount 100000000000000 \
  --local-repository-dir .

# Check that operator.yaml and owner.yaml now contain Validator B's data
# Validator A's configuration is lost
cat operator.yaml  # Shows Validator B's keys
```

**Expected Result:** Validator B's configuration overwrites Validator A's configuration at the root level, causing permanent data loss.

**Actual Result:** Both validators write to the same files (`operator.yaml`, `owner.yaml`) with no error or warning, resulting in silent data loss for the first validator.

## Notes

The validation in `validate_validators()` would eventually catch duplicate accounts if the layout file contained multiple empty usernames, but by that point the damage is done - validator configurations have already been overwritten and lost. [7](#0-6)

### Citations

**File:** crates/aptos/src/genesis/keys.rs (L112-115)
```rust
pub struct SetValidatorConfiguration {
    /// Name of the validator
    #[clap(long)]
    pub(crate) username: String,
```

**File:** crates/aptos/src/genesis/keys.rs (L163-163)
```rust
    async fn execute(self) -> CliTypedResult<()> {
```

**File:** crates/aptos/src/genesis/keys.rs (L254-256)
```rust
        let directory = PathBuf::from(&self.username);
        let operator_file = directory.join(OPERATOR_FILE);
        let owner_file = directory.join(OWNER_FILE);
```

**File:** crates/aptos/src/genesis/keys.rs (L258-260)
```rust
        let git_client = self.git_options.get_client()?;
        git_client.put(operator_file.as_path(), &operator_config)?;
        git_client.put(owner_file.as_path(), &owner_config)
```

**File:** crates/aptos/src/genesis/git.rs (L187-212)
```rust
    pub fn put<T: Serialize + ?Sized>(&self, name: &Path, input: &T) -> CliTypedResult<()> {
        match self {
            Client::Local(local_repository_path) => {
                let path = local_repository_path.join(name);

                // Create repository path and any sub-directories
                if let Some(dir) = path.parent() {
                    self.create_dir(dir)?;
                } else {
                    return Err(CliError::UnexpectedError(format!(
                        "Path should always have a parent {}",
                        path.display()
                    )));
                }
                write_to_file(
                    path.as_path(),
                    &path.display().to_string(),
                    to_yaml(input)?.as_bytes(),
                )?;
            },
            Client::Github(client) => {
                client.put(&name.display().to_string(), &to_base64_encoded_yaml(input)?)?;
            },
        }

        Ok(())
```

**File:** crates/aptos/src/genesis/mod.rs (L352-361)
```rust
fn get_config(
    client: &Client,
    user: &str,
    is_mainnet: bool,
) -> CliTypedResult<ValidatorConfiguration> {
    // Load a user's configuration files
    let dir = PathBuf::from(user);
    let owner_file = dir.join(OWNER_FILE);
    let owner_file = owner_file.as_path();
    let owner_config = client.get::<StringOwnerConfiguration>(owner_file)?;
```

**File:** crates/aptos/src/genesis/mod.rs (L665-674)
```rust
        if seen_owners.contains_key(&validator.owner_account_address.into()) {
            errors.push(CliError::UnexpectedError(format!(
                "Owner {} in validator {} has been seen before as an owner of validator {}",
                validator.owner_account_address,
                name,
                seen_owners
                    .get(&validator.owner_account_address.into())
                    .unwrap()
            )));
        }
```
