# Audit Report

## Title
Missing Pruning Check in `get_persisted_auxiliary_info_iterator` Causes State Sync Failures

## Summary
The `get_persisted_auxiliary_info_iterator` method lacks a pruning validation check that exists in other similar iterator methods, allowing readers to attempt reading already-pruned data. This causes unexpected iterator failures during state synchronization, potentially degrading node availability and sync performance.

## Finding Description

The vulnerability exists in the inconsistent error handling between different database iterator creation methods. [1](#0-0) 

This method creates an iterator without checking if the requested versions have been pruned, unlike similar methods: [2](#0-1) [3](#0-2) 

Both `get_transaction_iterator` and `get_transaction_info_iterator` include `error_if_ledger_pruned` checks before creating iterators, but `get_persisted_auxiliary_info_iterator` does not.

**How the vulnerability manifests:**

The pruning system updates the minimum readable version before actually deleting data: [4](#0-3) 

When a reader requests auxiliary info after pruning completes:
1. No pruning check occurs in `get_persisted_auxiliary_info_iterator`
2. An iterator is created with a RocksDB snapshot after data deletion
3. The iterator encounters gaps in version sequence
4. The `expect_continuous_versions` validator detects missing versions and fails: [5](#0-4) 

**Real-world impact path:**

State sync uses this iterator to serve data requests: [6](#0-5) 

When the iterator fails, it triggers error handling: [7](#0-6) 

This causes `StorageErrorEncountered` to be returned, failing the state sync request.

## Impact Explanation

This qualifies as **HIGH severity** under Aptos bug bounty criteria for "Validator node slowdowns" and "Significant protocol violations":

1. **State Sync Disruption**: When nodes request historical data that has been pruned, they receive unexpected iterator failures instead of clear "data pruned" errors. This causes sync operations to fail and retry, significantly slowing synchronization.

2. **Operational Degradation**: Nodes falling behind due to sync failures may struggle to catch up, particularly during periods of high pruning activity. This affects network health and validator performance.

3. **Inconsistent Error Semantics**: The missing check violates the expected error handling pattern established by other iterator methods, causing confusing errors that complicate debugging and monitoring.

4. **Cascading Effects**: Failed sync requests may trigger retries, connection drops, or peer reputation penalties, compounding the impact on network operations.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

This issue occurs naturally during normal operations without requiring attacker intervention:

1. **Timing Dependency**: The race condition occurs when:
   - A node requests auxiliary info for versions near the pruning boundary
   - Pruning completes between the request and iterator creation
   - The iterator attempts to read deleted data

2. **Pruning Frequency**: Pruning runs continuously in the background when enabled, creating frequent opportunities for this race condition.

3. **State Sync Patterns**: Nodes regularly request historical data during:
   - Initial synchronization
   - Catching up after downtime  
   - Serving state sync requests to other nodes

4. **No Special Privileges Required**: This affects normal node operation and doesn't require any privileged access or malicious behavior.

## Recommendation

Add the missing pruning check to `get_persisted_auxiliary_info_iterator` to match the pattern used by other iterator methods:

```rust
fn get_persisted_auxiliary_info_iterator(
    &self,
    start_version: Version,
    num_persisted_auxiliary_info: usize,
) -> Result<Box<dyn Iterator<Item = Result<PersistedAuxiliaryInfo>> + '_>> {
    gauged_api("get_persisted_auxiliary_info_iterator", || {
        // Add this check before creating the iterator
        self.error_if_ledger_pruned("PersistedAuxiliaryInfo", start_version)?;
        
        let iter = self
            .ledger_db
            .persisted_auxiliary_info_db()
            .get_persisted_auxiliary_info_iter(start_version, num_persisted_auxiliary_info)?;
        Ok(Box::new(iter)
            as Box<
                dyn Iterator<Item = Result<PersistedAuxiliaryInfo>> + '_,
            >)
    })
}
```

This ensures that:
1. Pruned data requests fail immediately with a clear error message
2. Error handling is consistent across all iterator methods
3. State sync can distinguish between "data pruned" and "data corrupted" errors
4. RocksDB snapshot isolation still protects concurrent reads that pass the check

## Proof of Concept

The vulnerability can be demonstrated through the following sequence:

```rust
// Step 1: Node A has auxiliary info for versions 100-199
// Step 2: Pruning runs and deletes versions < 200
//         min_readable_version updated to 200
//         Data physically deleted from RocksDB

// Step 3: Node B requests auxiliary info via state sync
let start_version = 100;
let num_versions = 100;

// This call succeeds (no pruning check)
let iterator = storage.get_persisted_auxiliary_info_iterator(start_version, num_versions);

// Step 4: Iterator attempts to read deleted data
// expect_continuous_versions finds gaps and returns error
// State sync fails with StorageErrorEncountered

// Expected behavior: Should fail immediately with clear "data pruned" error
// Actual behavior: Fails during iteration with "version mismatch" error
```

This can be triggered in production by:
1. Configuring aggressive pruning windows
2. Requesting historical data near the pruning boundary
3. Observing state sync failures in logs with continuity errors rather than pruning errors

The fix ensures all iterator methods follow the same defensive pattern of checking pruning status before attempting reads.

### Citations

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L446-460)
```rust
    fn get_persisted_auxiliary_info_iterator(
        &self,
        start_version: Version,
        num_persisted_auxiliary_info: usize,
    ) -> Result<Box<dyn Iterator<Item = Result<PersistedAuxiliaryInfo>> + '_>> {
        gauged_api("get_persisted_auxiliary_info_iterator", || {
            let iter = self
                .ledger_db
                .persisted_auxiliary_info_db()
                .get_persisted_auxiliary_info_iter(start_version, num_persisted_auxiliary_info)?;
            Ok(Box::new(iter)
                as Box<
                    dyn Iterator<Item = Result<PersistedAuxiliaryInfo>> + '_,
                >)
        })
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L477-492)
```rust
    fn get_transaction_iterator(
        &self,
        start_version: Version,
        limit: u64,
    ) -> Result<Box<dyn Iterator<Item = Result<Transaction>> + '_>> {
        gauged_api("get_transaction_iterator", || {
            error_if_too_many_requested(limit, MAX_REQUEST_LIMIT)?;
            self.error_if_ledger_pruned("Transaction", start_version)?;

            let iter = self
                .ledger_db
                .transaction_db()
                .get_transaction_iter(start_version, limit as usize)?;
            Ok(Box::new(iter) as Box<dyn Iterator<Item = Result<Transaction>> + '_>)
        })
    }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L494-509)
```rust
    fn get_transaction_info_iterator(
        &self,
        start_version: Version,
        limit: u64,
    ) -> Result<Box<dyn Iterator<Item = Result<TransactionInfo>> + '_>> {
        gauged_api("get_transaction_info_iterator", || {
            error_if_too_many_requested(limit, MAX_REQUEST_LIMIT)?;
            self.error_if_ledger_pruned("Transaction", start_version)?;

            let iter = self
                .ledger_db
                .transaction_info_db()
                .get_transaction_info_iter(start_version, limit as usize)?;
            Ok(Box::new(iter) as Box<dyn Iterator<Item = Result<TransactionInfo>> + '_>)
        })
    }
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs (L162-176)
```rust
    fn set_pruner_target_db_version(&self, latest_version: Version) {
        assert!(self.pruner_worker.is_some());
        let min_readable_version = latest_version.saturating_sub(self.prune_window);
        self.min_readable_version
            .store(min_readable_version, Ordering::SeqCst);

        PRUNER_VERSIONS
            .with_label_values(&["ledger_pruner", "min_readable"])
            .set(min_readable_version as i64);

        self.pruner_worker
            .as_ref()
            .unwrap()
            .set_target_db_version(min_readable_version);
    }
```

**File:** storage/aptosdb/src/utils/iterators.rs (L40-62)
```rust
    fn next_impl(&mut self) -> Result<Option<T>> {
        if self.expected_next_version >= self.end_version {
            return Ok(None);
        }

        let ret = match self.inner.next().transpose()? {
            Some((version, transaction)) => {
                ensure!(
                    version == self.expected_next_version,
                    "{} iterator: first version {}, expecting version {}, got {} from underlying iterator.",
                    std::any::type_name::<T>(),
                    self.first_version,
                    self.expected_next_version,
                    version,
                );
                self.expected_next_version += 1;
                Some(transaction)
            },
            None => None,
        };

        Ok(ret)
    }
```

**File:** state-sync/storage-service/server/src/storage.rs (L390-394)
```rust
        let persisted_auxiliary_info_iterator =
            self.storage.get_persisted_auxiliary_info_iterator(
                start_version,
                num_transactions_to_fetch as usize,
            )?;
```

**File:** state-sync/storage-service/server/src/storage.rs (L451-455)
```rust
                Some((Err(error), _, _, _))
                | Some((_, Err(error), _, _))
                | Some((_, _, Err(error), _))
                | Some((_, _, _, Err(error))) => {
                    return Err(Error::StorageErrorEncountered(error.to_string()));
```
