# Audit Report

## Title
Gas Charged But Not Refunded on Memory Limit Abort in `from_u64_internal()`

## Summary
The `from_u64_internal()` native function charges gas before validating memory limits. When the subsequent `store_element!` macro aborts due to exceeding the 1MB memory limit, the already-charged gas is consumed rather than refunded, enabling attackers to waste gas by intentionally triggering aborts.

## Finding Description

The vulnerability exists in the `from_u64_internal!` macro used by the `from_u64_internal()` function. The execution order is: [1](#0-0) 

The macro charges gas at line 23, then attempts to store the element at line 25. However, the `store_element!` macro performs memory limit validation: [2](#0-1) 

When the memory check fails at line 248, the function aborts with `E_TOO_MUCH_MEMORY_USED`. Critically, the gas charged at line 23 is **not refunded** on abort, as demonstrated by the error handling in the native function wrapper: [3](#0-2) 

Line 135 shows that when `SafeNativeError::Abort` occurs, the wrapper returns `NativeResult::err(context.legacy_gas_used, abort_code)`, meaning all accumulated gas is consumed despite the operation failing.

**Attack Scenario:**
1. Attacker fills the `AlgebraContext` memory to near the 1MB limit by creating algebra elements
2. Attacker calls `from_u64<S>()` (exposed publicly in crypto_algebra.move)
3. Gas is charged (e.g., 1815-3312 internal gas units depending on structure type)
4. The `store_element!` macro aborts due to memory limit
5. Gas is consumed but no element is stored
6. Attacker repeats, wasting gas on each failed operation [4](#0-3) 

The gas costs are non-trivial: [5](#0-4) [6](#0-5) 

## Impact Explanation

This qualifies as **Medium severity** under the Aptos bug bounty program for the following reasons:

1. **Gas Inefficiency**: Users pay for computational work (type checking, argument extraction, element creation) that ultimately fails, violating the principle that gas should reflect completed work.

2. **Predictability Issues**: Transactions operating near the memory limit may unexpectedly consume gas for failed operations, creating a poor user experience and unpredictable gas consumption.

3. **Resource Limit Invariant Violation**: The issue violates the critical invariant "All operations must respect gas, storage, and computational limits" - specifically, the gas charging doesn't properly account for resource limit checks.

4. **Limited Scope**: The attack primarily affects the attacker's own transaction (self-griefing), with the memory limit enforced per-session (transaction). No consensus violations or fund theft is possible.

The impact is limited but non-trivial, fitting the Medium severity category of "State inconsistencies requiring intervention" in terms of gas accounting inefficiencies.

## Likelihood Explanation

This issue will occur with **high likelihood** in the following scenarios:

1. **Regular Usage**: Any user legitimately using algebra operations who approaches the 1MB memory limit will experience gas wastage when subsequent operations fail.

2. **Intentional Exploitation**: An attacker can deliberately trigger this by:
   - Creating algebra elements to consume ~999KB of memory
   - Making repeated `from_u64()` calls
   - Each call wastes ~1815-3312 gas units

The exploit requires no special permissionsâ€”any transaction sender can call the public `crypto_algebra::from_u64<S>()` function. The memory limit is enforced per-transaction via the `AlgebraContext` session listener, which resets on each transaction start. [7](#0-6) 

## Recommendation

Reorder the operations to check memory limits **before** charging gas. This ensures gas is only charged for operations that can successfully complete:

```rust
macro_rules! from_u64_internal {
    ($context:expr, $args:ident, $typ:ty, $gas:expr) => {{
        let value = safely_pop_arg!($args, u64);
        
        // Check memory limit BEFORE charging gas
        let context_ext = $context.extensions().get::<AlgebraContext>();
        let element_size = std::mem::size_of::<$typ>();
        let new_size = context_ext.bytes_used + element_size;
        if new_size > MEMORY_LIMIT_IN_BYTES {
            return Err(SafeNativeError::Abort {
                abort_code: E_TOO_MUCH_MEMORY_USED,
            });
        }
        
        // Now charge gas and proceed
        $context.charge($gas)?;
        let element = <$typ>::from(value as u64);
        let handle = store_element!($context, element)?;
        Ok(smallvec![Value::u64(handle as u64)])
    }};
}
```

This approach eliminates the gas wastage window by failing fast on resource limit violations before consuming gas.

## Proof of Concept

```move
#[test_only]
module test_addr::gas_waste_poc {
    use std::vector;
    use aptos_std::crypto_algebra;
    use aptos_std::bls12381_algebra;

    #[test]
    #[expected_failure(abort_code = 0x090003)] // E_TOO_MUCH_MEMORY_USED
    public fun test_gas_wasted_on_memory_limit_abort() {
        // Fill AlgebraContext memory to near 1MB limit
        // Create many Fr elements to consume ~999KB
        let elements = vector::empty();
        let i = 0;
        
        // Fr element size is ~32 bytes, create ~31000 elements to reach ~992KB
        while (i < 31000) {
            let elem = crypto_algebra::from_u64<bls12381_algebra::Fr>((i as u64));
            vector::push_back(&mut elements, elem);
            i = i + 1;
        };
        
        // Now the next from_u64 call will:
        // 1. Charge 1815 gas units
        // 2. Abort at store_element! due to memory limit
        // 3. Gas is NOT refunded
        // This wastes 1815 gas units per call
        let _waste = crypto_algebra::from_u64<bls12381_algebra::Fr>(42);
    }
}
```

The test demonstrates that when the memory limit is approached, subsequent `from_u64()` calls will abort after charging gas. The charged gas (1815 units for BLS12-381 Fr) is consumed despite the operation failing to complete. An attacker could repeatedly trigger this pattern to waste gas intentionally.

## Notes

- The vulnerability affects all structure types supported by `from_u64_internal()`: BLS12381Fr, BLS12381Fq12, BN254Fr, BN254Fq, and BN254Fq12
- The memory limit (1MB) is defined at [8](#0-7) 
- The same pattern may exist in other algebra native functions that charge gas before calling `store_element!`
- This is a gas accounting inefficiency rather than a critical security vulnerability, as it primarily enables self-griefing

### Citations

**File:** aptos-move/framework/src/natives/cryptography/algebra/new.rs (L20-27)
```rust
macro_rules! from_u64_internal {
    ($context:expr, $args:ident, $typ:ty, $gas:expr) => {{
        let value = safely_pop_arg!($args, u64);
        $context.charge($gas)?;
        let element = <$typ>::from(value as u64);
        let handle = store_element!($context, element)?;
        Ok(smallvec![Value::u64(handle as u64)])
    }};
```

**File:** aptos-move/framework/src/natives/cryptography/algebra/mod.rs (L185-185)
```rust
const MEMORY_LIMIT_IN_BYTES: usize = 1 << 20;
```

**File:** aptos-move/framework/src/natives/cryptography/algebra/mod.rs (L196-209)
```rust
impl SessionListener for AlgebraContext {
    fn start(&mut self, _session_hash: &[u8; 32], _script_hash: &[u8], _session_counter: u8) {
        self.bytes_used = 0;
        self.objs.clear();
    }

    fn finish(&mut self) {
        // No state changes to save.
    }

    fn abort(&mut self) {
        // No state changes to abort. Context will be reset on new session's start.
    }
}
```

**File:** aptos-move/framework/src/natives/cryptography/algebra/mod.rs (L244-260)
```rust
macro_rules! store_element {
    ($context:expr, $obj:expr) => {{
        let context = &mut $context.extensions_mut().get_mut::<AlgebraContext>();
        let new_size = context.bytes_used + std::mem::size_of_val(&$obj);
        if new_size > MEMORY_LIMIT_IN_BYTES {
            Err(SafeNativeError::Abort {
                abort_code: E_TOO_MUCH_MEMORY_USED,
            })
        } else {
            let target_vec = &mut context.objs;
            context.bytes_used = new_size;
            let ret = target_vec.len();
            target_vec.push(Rc::new($obj));
            Ok(ret)
        }
    }};
}
```

**File:** aptos-move/aptos-native-interface/src/builder.rs (L131-136)
```rust
            match res {
                Ok(ret_vals) => Ok(NativeResult::ok(context.legacy_gas_used, ret_vals)),
                Err(err) => match err {
                    Abort { abort_code } => {
                        Ok(NativeResult::err(context.legacy_gas_used, abort_code))
                    },
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/crypto_algebra.move (L61-67)
```text
    /// Convert a u64 to an element of a structure `S`.
    public fun from_u64<S>(value: u64): Element<S> {
        abort_unless_cryptography_algebra_natives_enabled();
        Element<S> {
            handle: from_u64_internal<S>(value)
        }
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/aptos_framework.rs (L67-67)
```rust
        [algebra_ark_bn254_fr_from_u64: InternalGas, { 12.. => "algebra.ark_bn254_fr_from_u64" }, 2478],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/aptos_framework.rs (L128-128)
```rust
        [algebra_ark_bls12_381_fr_from_u64: InternalGas, { 8.. => "algebra.ark_bls12_381_fr_from_u64" }, 1815],
```
