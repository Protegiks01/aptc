# Audit Report

## Title
State Synchronizer Initialization Flag Not Reset on Stream Failure Leading to Recovery Failure

## Summary
The `initialized_state_snapshot_receiver` flag in the `StateValueSyncer` is not reset when a data stream is terminated due to out-of-order chunk errors. This causes subsequent valid retry attempts to skip re-initialization of the state snapshot receiver, leading to failures when trying to send state values to a closed or mismatched receiver channel.

## Finding Description
When the state synchronization bootstrapper detects out-of-order state value chunks, it calls `reset_active_stream` to terminate the faulty stream and retry. [1](#0-0) 

However, this reset only clears `active_data_stream` and `speculative_stream_state`, but does NOT reset the `state_value_syncer` fields, particularly `initialized_state_snapshot_receiver`: [2](#0-1) 

When processing state values after a reset, the code checks this flag: [3](#0-2) 

If the flag remains `true` from the previous stream, the initialization block is skipped. The code then attempts to save state values using the old `state_snapshot_notifier`: [4](#0-3) 

The old receiver task may have completed, encountered errors, or its channel may be closed, causing the save operation to fail. This triggers another reset, but since `initialized_state_snapshot_receiver` is never cleared, the cycle repeats indefinitely.

**Attack Path:**
1. Node begins state synchronization, successfully processes initial chunks
2. `initialized_state_snapshot_receiver` is set to `true`
3. Malicious peer sends chunk N before chunk N-1
4. Ordering verification detects mismatch and calls `reset_active_stream`: [5](#0-4) 

5. New stream is created, requests correct chunks
6. Valid chunks arrive but processing fails because initialization is skipped
7. Errors trigger more resets, but flag remains set
8. Node cannot complete bootstrapping until full restart

## Impact Explanation
This is a **High Severity** issue under Aptos bug bounty criteria as it causes "Validator node slowdowns" and "Significant protocol violations." 

A malicious peer can prevent newly bootstrapping nodes from completing state synchronization by sending a single out-of-order chunk response. The node becomes stuck in a reset loop and cannot recover without restarting the process. This affects network availability and prevents new validators from joining.

## Likelihood Explanation
**Likelihood: High**

The attack requires:
- Malicious peer responding to state sync requests (easily achievable)
- Sending one out-of-order chunk response (trivial)
- No special privileges or validator access needed

The vulnerability is triggered automatically once the initial state is corrupted. Any subsequent valid responses will fail due to the uncleared flag.

## Recommendation
Reset the `initialized_state_snapshot_receiver` flag and related state when `reset_active_stream` is called:

```rust
pub async fn reset_active_stream(
    &mut self,
    notification_and_feedback: Option<NotificationAndFeedback>,
) -> Result<(), Error> {
    if let Some(active_data_stream) = &self.active_data_stream {
        let data_stream_id = active_data_stream.data_stream_id;
        utils::terminate_stream_with_feedback(
            &mut self.streaming_client,
            data_stream_id,
            notification_and_feedback,
        )
        .await?;
    }

    self.active_data_stream = None;
    self.speculative_stream_state = None;
    
    // FIX: Reset state value syncer initialization flag
    self.state_value_syncer.initialized_state_snapshot_receiver = false;
    
    Ok(())
}
```

Alternatively, add a dedicated reset method to `StateValueSyncer`:

```rust
impl StateValueSyncer {
    pub fn reset_initialization(&mut self) {
        self.initialized_state_snapshot_receiver = false;
    }
}
```

## Proof of Concept
```rust
// Integration test demonstrating the vulnerability
#[tokio::test]
async fn test_out_of_order_chunk_recovery_failure() {
    // Setup: Create bootstrapper with state syncing
    let (mut bootstrapper, mock_network) = setup_test_bootstrapper();
    
    // Step 1: Successfully process first chunk [0-99]
    mock_network.send_state_chunk(0, 99);
    bootstrapper.process_active_stream_notifications().await.unwrap();
    assert!(bootstrapper.state_value_syncer.initialized_state_snapshot_receiver);
    
    // Step 2: Send out-of-order chunk [200-299] when expecting [100-199]
    mock_network.send_state_chunk(200, 299);
    
    // Step 3: Verify ordering error triggers reset
    let result = bootstrapper.process_active_stream_notifications().await;
    assert!(result.is_err());
    assert!(bootstrapper.active_data_stream.is_none()); // Stream was reset
    
    // BUG: Flag is still true after reset
    assert!(bootstrapper.state_value_syncer.initialized_state_snapshot_receiver);
    
    // Step 4: Attempt recovery with valid chunk [100-199]
    bootstrapper.initialize_active_data_stream(&global_summary).await.unwrap();
    mock_network.send_state_chunk(100, 199);
    
    // Step 5: Verify recovery fails because initialization is skipped
    let result = bootstrapper.process_active_stream_notifications().await;
    assert!(result.is_err()); // Fails to save_state_values - channel closed
    
    // Step 6: Subsequent retries continue to fail
    for _ in 0..5 {
        bootstrapper.initialize_active_data_stream(&global_summary).await.unwrap();
        mock_network.send_state_chunk(100, 199);
        let result = bootstrapper.process_active_stream_notifications().await;
        assert!(result.is_err()); // Still failing - stuck in loop
        assert!(bootstrapper.state_value_syncer.initialized_state_snapshot_receiver);
    }
}
```

## Notes
The vulnerability specifically affects state value synchronization during bootstrapping. Transaction-based synchronization paths are not affected. A full node restart clears the flag as the bootstrapper is recreated, but this doesn't mitigate the attack as the malicious peer can repeat the attack after restart.

### Citations

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L244-286)
```rust
pub(crate) struct StateValueSyncer {
    // Whether or not a state snapshot receiver has been initialized
    initialized_state_snapshot_receiver: bool,

    // The epoch ending ledger info for the version we're syncing
    ledger_info_to_sync: Option<LedgerInfoWithSignatures>,

    // The next state value index to process (all state values before this have been
    // processed -- i.e., sent to the storage synchronizer).
    next_state_index_to_process: u64,

    // The transaction output (inc. info and proof) for the version we're syncing
    transaction_output_to_sync: Option<TransactionOutputListWithProofV2>,
}

impl StateValueSyncer {
    pub fn new() -> Self {
        Self {
            initialized_state_snapshot_receiver: false,
            ledger_info_to_sync: None,
            next_state_index_to_process: 0,
            transaction_output_to_sync: None,
        }
    }

    /// Sets the ledger info to sync
    pub fn set_ledger_info_to_sync(&mut self, ledger_info_to_sync: LedgerInfoWithSignatures) {
        self.ledger_info_to_sync = Some(ledger_info_to_sync);
    }

    /// Sets the transaction output to sync
    pub fn set_transaction_output_to_sync(
        &mut self,
        transaction_output_to_sync: TransactionOutputListWithProofV2,
    ) {
        self.transaction_output_to_sync = Some(transaction_output_to_sync);
    }

    /// Updates the next state index to process
    pub fn update_next_state_index_to_process(&mut self, next_state_index_to_process: u64) {
        self.next_state_index_to_process = next_state_index_to_process;
    }
}
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L918-935)
```rust
    async fn verify_states_values_indices(
        &mut self,
        notification_id: NotificationId,
        state_value_chunk_with_proof: &StateValueChunkWithProof,
    ) -> Result<(), Error> {
        // Verify the payload start index is valid
        let expected_start_index = self.state_value_syncer.next_state_index_to_process;
        if expected_start_index != state_value_chunk_with_proof.first_index {
            self.reset_active_stream(Some(NotificationAndFeedback::new(
                notification_id,
                NotificationFeedback::InvalidPayloadData,
            )))
            .await?;
            return Err(Error::VerificationError(format!(
                "The start index of the state values was invalid! Expected: {:?}, received: {:?}",
                expected_start_index, state_value_chunk_with_proof.first_index
            )));
        }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L985-1001)
```rust
        if !self.state_value_syncer.initialized_state_snapshot_receiver {
            // Fetch all verified epoch change proofs
            let version_to_sync = ledger_info_to_sync.ledger_info().version();
            let epoch_change_proofs = if version_to_sync == GENESIS_TRANSACTION_VERSION {
                vec![ledger_info_to_sync.clone()] // Sync to genesis
            } else {
                self.verified_epoch_states.all_epoch_ending_ledger_infos() // Sync beyond genesis
            };

            // Initialize the state value synchronizer
            let _join_handle = self.storage_synchronizer.initialize_state_synchronizer(
                epoch_change_proofs,
                ledger_info_to_sync,
                transaction_output_to_sync.clone(),
            )?;
            self.state_value_syncer.initialized_state_snapshot_receiver = true;
        }
```

**File:** state-sync/state-sync-driver/src/bootstrapper.rs (L1539-1556)
```rust
    pub async fn reset_active_stream(
        &mut self,
        notification_and_feedback: Option<NotificationAndFeedback>,
    ) -> Result<(), Error> {
        if let Some(active_data_stream) = &self.active_data_stream {
            let data_stream_id = active_data_stream.data_stream_id;
            utils::terminate_stream_with_feedback(
                &mut self.streaming_client,
                data_stream_id,
                notification_and_feedback,
            )
            .await?;
        }

        self.active_data_stream = None;
        self.speculative_stream_state = None;
        Ok(())
    }
```

**File:** state-sync/state-sync-driver/src/storage_synchronizer.rs (L412-440)
```rust
    async fn save_state_values(
        &mut self,
        notification_id: NotificationId,
        state_value_chunk_with_proof: StateValueChunkWithProof,
    ) -> Result<(), Error> {
        // Get the snapshot notifier and create the storage data chunk
        let state_snapshot_notifier = self.state_snapshot_notifier.as_mut().ok_or_else(|| {
            Error::UnexpectedError("The state snapshot receiver has not been initialized!".into())
        })?;
        let storage_data_chunk =
            StorageDataChunk::States(notification_id, state_value_chunk_with_proof);

        // Notify the snapshot receiver of the storage data chunk
        if let Err(error) = send_and_monitor_backpressure(
            state_snapshot_notifier,
            metrics::STORAGE_SYNCHRONIZER_STATE_SNAPSHOT_RECEIVER,
            storage_data_chunk,
        )
        .await
        {
            Err(Error::UnexpectedError(format!(
                "Failed to send storage data chunk to state snapshot listener: {:?}",
                error
            )))
        } else {
            increment_pending_data_chunks(self.pending_data_chunks.clone());
            Ok(())
        }
    }
```
