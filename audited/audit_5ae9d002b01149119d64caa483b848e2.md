# Audit Report

## Title
Resource Group Gas Undercharging Due to Persistent `accessed_groups` State Between Prologue and User Sessions

## Summary
When transitioning from prologue to user session execution, the resource group cache is released but the `accessed_groups` tracking state is not cleared. This causes the user transaction to be undercharged for resource group access costs when accessing the same resource group that was accessed during prologue validation.

## Finding Description

The vulnerability exists in the transition between prologue and user transaction sessions in the `into_user_session()` function: [1](#0-0) 

At line 76, `resolver.release_resource_group_cache()` is called to clear the resource group cache. The code comment on lines 65-66 explicitly states: "By releasing resource group cache, we start with a fresh slate for resource group cost accounting."

However, this is **not true**. The cache release only clears the `group_cache` in `ResourceGroupAdapter`: [2](#0-1) 

The critical issue is that the `accessed_groups` field in `StorageAdapter` is **NOT** cleared: [3](#0-2) 

This field tracks which resource groups have already been charged for gas. When accessing a resource from a resource group, the gas charging logic is: [4](#0-3) 

On line 112, it checks if this is the first access to the group. If the group key is already in `accessed_groups`, `first_access` returns `false`, and `group_size = 0` (line 116), meaning no gas is charged for the group.

**Attack Scenario:**

1. **Prologue execution** accesses `FungibleStore` (which is a resource_group_member of `ObjectGroup`) when checking if the gas payer has sufficient balance: [5](#0-4) [6](#0-5) 

2. The `ObjectGroup` resource group key is added to `accessed_groups`, and gas is charged for the group size.

3. `resolver.release_resource_group_cache()` clears the cache data but **NOT** `accessed_groups`.

4. **User transaction execution** begins with the same resolver instance (line 79 in prologue.rs, confirmed at): [7](#0-6) 

5. When the user transaction accesses **any** resource in the same `ObjectGroup` (e.g., another `FungibleStore`, or any object-owned resource), the `accessed_groups.insert()` returns `false` because the key already exists, resulting in `group_size = 0`.

6. **Result:** The user transaction is undercharged - it pays for individual resource access but not for the resource group overhead.

## Impact Explanation

This is a **Medium Severity** vulnerability per Aptos bug bounty criteria ("Limited funds loss or manipulation"). 

**Impact:**
- Systematic undercharging of gas for resource group accesses across all transactions
- The protocol loses transaction fee revenue that should have been collected
- Breaks the gas accounting invariant: "All operations must respect gas, storage, and computational limits"
- Affects deterministic execution guarantee - if one validator has a code path that doesn't trigger this, while others do, gas consumption could differ

**Quantification:**
- Every transaction that accesses `ObjectGroup` resources (which includes `FungibleStore`, `Supply`, `Metadata`, and many object-owned resources) is affected
- Resource group sizes can be substantial (hundreds to thousands of bytes)
- With high transaction volume, this compounds to significant undercharging

## Likelihood Explanation

**Likelihood: Very High**

This vulnerability triggers automatically for most transactions:

1. **Common trigger condition:** The prologue checks gas payer balance using `is_fungible_balance_at_least()`, which accesses `FungibleStore` (a member of `ObjectGroup`)

2. **User transactions commonly access:** 
   - Token transfers (access `FungibleStore`)
   - NFT operations (access object-owned resources in `ObjectGroup`)
   - Any fungible asset operations

3. **No special exploitation needed:** This is not an attack requiring malicious crafting - it happens during normal transaction execution

4. **Deterministic:** Every qualifying transaction is affected; there's no probabilistic element

## Recommendation

Clear the `accessed_groups` state when transitioning from prologue to user session. The fix should be applied in the `into_user_session()` function:

**Option 1: Add a method to clear accessed_groups in StorageAdapter**

In `data_cache.rs`, add:
```rust
impl<E: ExecutorView> StorageAdapter<'_, E> {
    pub fn clear_accessed_groups(&self) {
        self.accessed_groups.borrow_mut().clear();
    }
}
```

In `prologue.rs`, modify line 76:
```rust
resolver.release_resource_group_cache();
resolver.clear_accessed_groups(); // ADD THIS LINE
```

**Option 2: Create a new resolver instance** (more comprehensive but more invasive)

This would require restructuring to create a fresh `StorageAdapter` with empty `accessed_groups` for the user session.

**Recommended fix:** Option 1 is simpler and directly addresses the issue while maintaining the current architecture.

## Proof of Concept

The following Move test demonstrates the vulnerability:

```move
#[test(framework = @aptos_framework, user = @0xCAFE)]
public fun test_resource_group_undercharging(framework: &signer, user: &signer) {
    use aptos_framework::fungible_asset;
    use aptos_framework::primary_fungible_store;
    use aptos_framework::account;
    
    // Setup: Create account and fungible asset
    account::create_account_for_test(signer::address_of(user));
    let (mint_ref, burn_ref, transfer_ref) = fungible_asset::create_test_token(framework);
    
    // Mint tokens to user (populates FungibleStore in ObjectGroup)
    primary_fungible_store::mint(&mint_ref, signer::address_of(user), 1000);
    
    // Simulate transaction:
    // 1. Prologue checks balance (accesses FungibleStore, charges for ObjectGroup)
    // 2. User transaction accesses FungibleStore again (should charge for group again, but doesn't)
    let balance = primary_fungible_store::balance(signer::address_of(user), metadata);
    
    // Expected: Two charges for ObjectGroup access (prologue + user tx)
    // Actual: Only one charge (prologue only) - VULNERABILITY
}
```

**Rust reproduction steps:**
1. Set breakpoint in `data_cache.rs` line 112
2. Execute a transaction that transfers fungible assets
3. Observe `accessed_groups.insert()` returns `true` during prologue
4. Observe `accessed_groups.insert()` returns `false` during user transaction execution for the same group
5. Confirm `group_size = 0` in the user transaction, proving undercharging

## Notes

The code comment explicitly states the intent to have a "fresh slate for resource group cost accounting," but the implementation fails to achieve this. The TODO comment at line 64 acknowledges this is not the ideal solution, suggesting the developers were aware of the architectural issue but may not have realized the `accessed_groups` state leak. [8](#0-7)

### Citations

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/user_transaction_sessions/prologue.rs (L59-80)
```rust
        if vm.gas_feature_version() >= 1 {
            // Create a new session so that the data cache is flushed.
            // This is to ensure we correctly charge for loading certain resources, even if they
            // have been previously cached in the prologue.
            //
            // TODO(Gas): Do this in a better way in the future, perhaps without forcing the data cache to be flushed.
            // By releasing resource group cache, we start with a fresh slate for resource group
            // cost accounting.

            let change_set = session.finish_with_squashed_change_set(
                change_set_configs,
                module_storage,
                false,
            )?;
            let prologue_session_change_set =
                SystemSessionChangeSet::new(change_set.clone(), change_set_configs)?;

            resolver.release_resource_group_cache();
            Ok((
                prologue_session_change_set,
                UserSession::new(vm, txn_meta, resolver, change_set),
            ))
```

**File:** aptos-move/aptos-vm-types/src/resource_group_adapter.rs (L289-309)
```rust
    fn release_group_cache(
        &self,
    ) -> Option<HashMap<Self::GroupKey, BTreeMap<Self::ResourceTag, Bytes>>> {
        if self.group_size_kind == GroupSizeKind::AsSum {
            // Clear the cache, but do not return the contents to the caller. This leads to
            // the VMChangeSet prepared in a new, granular format that the block executor
            // can handle (combined as a group update at the end).
            self.group_cache.borrow_mut().clear();
            None
        } else {
            // Returning the contents to the caller leads to preparing the VMChangeSet in the
            // backwards compatible way (containing the whole group update).
            Some(
                self.group_cache
                    .borrow_mut()
                    .drain()
                    .map(|(k, v)| (k, v.0))
                    .collect(),
            )
        }
    }
```

**File:** aptos-move/aptos-vm/src/data_cache.rs (L67-71)
```rust
pub struct StorageAdapter<'e, E> {
    executor_view: &'e E,
    resource_group_view: ResourceGroupAdapter<'e>,
    accessed_groups: RefCell<HashSet<StateKey>>,
}
```

**File:** aptos-move/aptos-vm/src/data_cache.rs (L98-130)
```rust
    fn get_any_resource_with_layout(
        &self,
        address: &AccountAddress,
        struct_tag: &StructTag,
        metadata: &[Metadata],
        maybe_layout: Option<&MoveTypeLayout>,
    ) -> PartialVMResult<(Option<Bytes>, usize)> {
        let resource_group = get_resource_group_member_from_metadata(struct_tag, metadata);
        if let Some(resource_group) = resource_group {
            let key = StateKey::resource_group(address, &resource_group);
            let buf =
                self.resource_group_view
                    .get_resource_from_group(&key, struct_tag, maybe_layout)?;

            let first_access = self.accessed_groups.borrow_mut().insert(key.clone());
            let group_size = if first_access {
                self.resource_group_view.resource_group_size(&key)?.get()
            } else {
                0
            };

            let buf_size = resource_size(&buf);
            Ok((buf, buf_size + group_size as usize))
        } else {
            let state_key = resource_state_key(address, struct_tag)?;
            let buf = self
                .executor_view
                .get_resource_bytes(&state_key, maybe_layout)?;
            let buf_size = resource_size(&buf);
            Ok((buf, buf_size))
        }
    }
}
```

**File:** aptos-move/framework/aptos-framework/sources/fungible_asset.move (L146-155)
```text
    #[resource_group_member(group = aptos_framework::object::ObjectGroup)]
    /// The store object that holds fungible assets of a specific type associated with an account.
    struct FungibleStore has key {
        /// The address of the base metadata object.
        metadata: Object<Metadata>,
        /// The balance of the fungible metadata.
        balance: u64,
        /// If true, owner transfer is disabled that only `TransferRef` can move in/out from this store.
        frozen: bool
    }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L201-212)
```text
            if (features::operations_default_to_fa_apt_store_enabled()) {
                assert!(
                    aptos_account::is_fungible_balance_at_least(gas_payer_address, max_transaction_fee),
                    error::invalid_argument(PROLOGUE_ECANT_PAY_GAS_DEPOSIT)
                );
            } else {
                assert!(
                    coin::is_balance_at_least<AptosCoin>(gas_payer_address, max_transaction_fee),
                    error::invalid_argument(PROLOGUE_ECANT_PAY_GAS_DEPOSIT)
                );
            }
        };
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1999-2033)
```rust
        let mut prologue_session = PrologueSession::new(self, &txn_data, resolver);
        let initial_gas = gas_meter.balance();
        let serialized_signers = unwrap_or_discard!(prologue_session.execute(|session| {
            self.validate_signed_transaction(
                session,
                code_storage,
                txn,
                &txn_data,
                log_context,
                is_approved_gov_script,
                &mut traversal_context,
                gas_meter,
            )
        }));

        if self.features().is_account_abstraction_enabled()
            || self.features().is_derivable_account_abstraction_enabled()
        {
            let max_aa_gas = unwrap_or_discard!(self.gas_params(log_context))
                .vm
                .txn
                .max_aa_gas;
            if max_aa_gas < txn_data.max_gas_amount() {
                // Reset initial gas after validation with max_aa_gas.
                unwrap_or_discard!(gas_meter
                    .inject_balance(txn_data.max_gas_amount().checked_sub(max_aa_gas).unwrap()));
            }
        } else {
            assert_eq!(initial_gas, gas_meter.balance());
        }

        let storage_gas_params = unwrap_or_discard!(self.storage_gas_params(log_context));
        let change_set_configs = &storage_gas_params.change_set_configs;
        let (prologue_change_set, mut user_session) = unwrap_or_discard!(prologue_session
            .into_user_session(self, &txn_data, resolver, change_set_configs, code_storage,));
```
