# Audit Report

## Title
Out-of-Bounds Vector Drain Causing Panic in Transaction Restore When global_first_version Exceeds target_version

## Summary
The `save_before_replay_version()` function in transaction restore contains a critical logic error where two consecutive vector drain operations can cause a panic. When `global_first_version > target_version` and a backup chunk spans both boundaries, the second drain operation attempts to remove more elements than exist in the vectors, causing an out-of-bounds panic that crashes the restore process.

## Finding Description

**Note on Original Question:** The security question asks about integer underflow when `global_first_version < first_version`. However, a guard condition prevents this scenario. [1](#0-0) 

The condition ensures the subtraction only occurs when `global_first_version > first_version`, preventing the integer underflow described in the question.

**Actual Vulnerability:** The real issue occurs when two consecutive drain operations interact incorrectly:

The first drain operation removes transactions exceeding `target_version` from the end of vectors. [2](#0-1) 

The second drain operation removes transactions before `global_first_version` from the beginning. [3](#0-2) 

**The Bug:** The second drain calculates `num_to_remove` using the ORIGINAL `first_version` variable (from the chunk manifest), without accounting for elements already removed by the first drain. When `global_first_version > target_version`, this causes `num_to_remove` to exceed the actual vector size, triggering a panic.

**Exploitation Path:**

1. During Phase 1 restore, `db_next_version` is updated to `tree_snapshot.version`. [4](#0-3) 

2. In Phase 2, if `latest_tree_version > target_version`, the `first_version` parameter becomes `Some(tree_snapshot.version)`. [5](#0-4)  and [6](#0-5) 

3. This creates the scenario where `global_first_version (200) > target_version (150)`.

4. Chunks are filtered to include those where `c.first_version <= target_version && c.last_version >= first_version`. [7](#0-6) 

5. A chunk like `[100-250]` passes this filter and triggers the bug during processing.

**Concrete Example:**
- Backup chunk: `first_version=100`, `last_version=250` (151 transactions)
- `target_version=150` (user specified)
- `global_first_version=200` (from tree snapshot)
- First drain: keeps `(150-100+1)=51` elements, removes 100 from end
- Second drain: attempts to remove `(200-100)=100` elements from 51-element vector â†’ **PANIC**

## Impact Explanation

This vulnerability causes a panic in the restore process, resulting in a **High Severity** impact per Aptos bug bounty criteria:

1. **Validator Node Crashes**: The panic terminates the restore process, preventing validators from recovering from backups during disaster recovery scenarios.

2. **Denial of Service**: Operators cannot complete restore operations when this condition is triggered, effectively causing a DoS of the restore functionality.

3. **Recovery Failures**: In scenarios requiring state recovery (e.g., after data corruption or migration), this bug prevents successful restoration, potentially leaving validators unable to rejoin the network.

The impact qualifies as "Validator node slowdowns" and "API crashes" under the High Severity category (up to $50,000).

## Likelihood Explanation

**Likelihood: Medium to High**

This bug can occur during legitimate restore operations when:
1. An operator specifies a `target_version` lower than the latest available tree snapshot (common when restoring to a specific historical state)
2. Multi-phase restore is performed with existing database state
3. Backup chunks span across both the `target_version` and `global_first_version` boundaries (common with large backup chunks)

The scenario is realistic in:
- Disaster recovery operations
- Validator synchronization from snapshots
- Testing/debugging restore processes
- Network upgrades requiring restoration to specific versions

No malicious actor is required; this occurs due to legitimate operational parameters and backup data characteristics.

## Recommendation

**Fix:** Add validation to ensure `global_first_version <= target_version`, or update `first_version` after the first drain to reflect the new logical starting point.

**Solution 1 - Add validation before processing:**
```rust
// After line 458 in save_before_replay_version
ensure!(
    global_first_version <= target_version,
    "global_first_version ({}) must not exceed target_version ({})",
    global_first_version,
    target_version
);
```

**Solution 2 - Update first_version after first drain (lines 474-495):**
```rust
// remove the txns that exceeds the target_version to be restored
if target_version < last_version {
    let num_to_keep = (target_version - first_version + 1) as usize;
    txns.drain(num_to_keep..);
    persisted_aux_info.drain(num_to_keep..);
    txn_infos.drain(num_to_keep..);
    event_vecs.drain(num_to_keep..);
    write_sets.drain(num_to_keep..);
    last_version = target_version;
}

// remove the txns that are before the global_first_version
if global_first_version > first_version {
    // FIX: Ensure we don't try to remove more than what remains
    let actual_first = std::cmp::max(first_version, global_first_version);
    if actual_first <= last_version {
        let num_to_remove = (actual_first - first_version) as usize;
        txns.drain(..num_to_remove);
        persisted_aux_info.drain(..num_to_remove);
        txn_infos.drain(..num_to_remove);
        event_vecs.drain(..num_to_remove);
        write_sets.drain(..num_to_remove);
        first_version = actual_first;
    }
}
```

## Proof of Concept

```rust
// Reproduction steps for the panic
// File: storage/backup/backup-cli/tests/transaction_restore_panic_test.rs

#[tokio::test]
async fn test_restore_panic_on_boundary_spanning_chunk() {
    // Setup: Create a backup with chunks [100-250]
    // Configure restore with:
    // - target_version = 150
    // - db_next_version = 200 (simulating Phase 1 completion)
    // - first_version parameter = Some(200)
    
    let chunk_first_version = 100;
    let chunk_last_version = 250;
    let target_version = 150;
    let global_first_version = 200;
    
    // Simulate the drain operations
    let mut test_vec: Vec<u32> = (chunk_first_version..=chunk_last_version).collect();
    println!("Initial vector size: {}", test_vec.len()); // 151 elements
    
    // First drain: remove txns exceeding target_version
    if target_version < chunk_last_version {
        let num_to_keep = (target_version - chunk_first_version + 1) as usize;
        test_vec.drain(num_to_keep..);
        println!("After first drain: {} elements", test_vec.len()); // 51 elements
    }
    
    // Second drain: remove txns before global_first_version
    if global_first_version > chunk_first_version {
        let num_to_remove = (global_first_version - chunk_first_version) as usize;
        println!("Attempting to drain {} elements from {} element vector", 
                 num_to_remove, test_vec.len()); // 100 from 51
        
        // This will PANIC with: "range end index 100 out of range for slice of length 51"
        test_vec.drain(..num_to_remove);
    }
}
```

**Expected behavior:** The test panics with `thread 'test_restore_panic_on_boundary_spanning_chunk' panicked at 'range end index 100 out of range for slice of length 51'`

**Notes**

The original security question focused on integer underflow when `global_first_version < first_version`, but the guard condition at line 486 prevents this scenario entirely. However, investigation revealed a different critical bug in the same function: an out-of-bounds vector drain operation when `global_first_version > target_version`.

This vulnerability affects the restore subsystem, which is critical for disaster recovery and validator synchronization. The bug can occur during legitimate operational scenarios without requiring any malicious actions, making it a significant reliability issue for the Aptos network.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L360-362)
```rust
            .try_filter(move |c| {
                future::ready(c.first_version <= target_version && c.last_version >= first_version)
            })
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L474-483)
```rust
                    // remove the txns that exceeds the target_version to be restored
                    if target_version < last_version {
                        let num_to_keep = (target_version - first_version + 1) as usize;
                        txns.drain(num_to_keep..);
                        persisted_aux_info.drain(num_to_keep..);
                        txn_infos.drain(num_to_keep..);
                        event_vecs.drain(num_to_keep..);
                        write_sets.drain(num_to_keep..);
                        last_version = target_version;
                    }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L485-495)
```rust
                    // remove the txns that are before the global_first_version
                    if global_first_version > first_version {
                        let num_to_remove = (global_first_version - first_version) as usize;

                        txns.drain(..num_to_remove);
                        persisted_aux_info.drain(..num_to_remove);
                        txn_infos.drain(..num_to_remove);
                        event_vecs.drain(..num_to_remove);
                        write_sets.drain(..num_to_remove);
                        first_version = global_first_version;
                    }
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L183-196)
```rust
        let tree_snapshot = if let Some((latest_tree_version, _)) = latest_tree_version {
            let snapshot = metadata_view.select_state_snapshot(latest_tree_version)?;

            ensure!(
                snapshot.is_some() && snapshot.as_ref().unwrap().version == latest_tree_version,
                "cannot find tree snapshot {}",
                latest_tree_version
            );
            snapshot.unwrap()
        } else {
            metadata_view
                .select_state_snapshot(target_version)?
                .expect("Cannot find tree snapshot before target version")
        };
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L288-302)
```rust
            transaction_restore_opt.target_version = tree_snapshot.version;
            TransactionRestoreBatchController::new(
                transaction_restore_opt,
                Arc::clone(&self.storage),
                txn_manifests,
                Some(db_next_version),
                Some((kv_replay_version, true /* only replay KV */)),
                epoch_history.clone(),
                VerifyExecutionMode::NoVerify,
                None,
            )
            .run()
            .await?;
            // update the expected version for the first phase restore
            db_next_version = tree_snapshot.version;
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L307-307)
```rust
            let first_version = (db_next_version > 0).then_some(db_next_version);
```
