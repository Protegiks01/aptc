# Audit Report

## Title
Missing Invariant Enforcement: Unchecked `round_id` Bounds Leading to Validator Node Crash

## Summary
The block partitioner V2 implementation fails to enforce the critical invariant that `round_id` must be `< GLOBAL_ROUND_ID` (9) for sharded execution. When misconfigured with `max_partitioning_rounds > MAX_ALLOWED_PARTITIONING_ROUNDS` (8) and `partition_last_round = true`, the system will create sub-blocks with `round_id >= 8`, causing array index out-of-bounds panics during cross-shard message passing, resulting in immediate validator node crashes.

## Finding Description

The system has an implicit invariant that sharded transactions must have `round_id < GLOBAL_ROUND_ID`, where `GLOBAL_ROUND_ID = 9`. [1](#0-0) 

However, this invariant is **not enforced** when creating `SubBlockIdx` instances. The constructor accepts any `round_id` without validation: [2](#0-1) 

The vulnerability manifests when:
1. `PartitionerV2Config` is configured with `max_partitioning_rounds > 8` (no validation exists): [3](#0-2) 

2. `partition_last_round` is set to `true`, preventing the last round from being moved to global execution: [4](#0-3) 

3. The partitioner creates sub-blocks with `round_id >= 8` during the discarding rounds: [5](#0-4) 

4. Cross-shard message channels are pre-allocated **only** for rounds 0-7: [6](#0-5) 

5. During execution, when `execute_sub_block` is called with `round >= 8`, it attempts to send cross-shard messages: [7](#0-6) 

6. This triggers an array index out-of-bounds panic when accessing `message_txs[shard_id][round]` with `round >= 8`: [8](#0-7) 

The same vulnerability exists in `RemoteCrossShardClient`: [9](#0-8) 

## Impact Explanation

**Severity: High** (meets "API crashes" and "Validator node slowdowns" criteria)

When triggered, this causes immediate validator node crash via Rust panic. This breaks the **Consensus Safety** and **Deterministic Execution** invariants, as:
- Affected validators cannot participate in consensus
- Network liveness is degraded if multiple validators are misconfigured
- The crash is deterministic for any block requiring > 8 partitioning rounds

While not as severe as fund loss, this represents a **total loss of liveness** for affected nodes and potential **network availability** issues if widespread.

## Likelihood Explanation

**Likelihood: Low** in production, but **High** impact when it occurs.

The vulnerability requires:
1. Validator operator configuring `max_partitioning_rounds > 8`
2. Setting `partition_last_round = true` (default is `false`)
3. Processing blocks that actually partition into 9+ rounds

The default configuration is safe (`max_partitioning_rounds = 4`, `partition_last_round = false`). However, the **complete absence of validation** means there's no defense against misconfiguration. Additionally, the system contains test code that uses `partition_last_round = true`, suggesting this mode is intended for production use: [10](#0-9) 

## Recommendation

Add validation in multiple defense layers:

**1. Config validation in `PartitionerV2Config::build()`:**
```rust
impl PartitionerConfig for PartitionerV2Config {
    fn build(&self) -> Box<dyn BlockPartitioner> {
        assert!(
            self.max_partitioning_rounds <= MAX_ALLOWED_PARTITIONING_ROUNDS,
            "max_partitioning_rounds ({}) must not exceed MAX_ALLOWED_PARTITIONING_ROUNDS ({})",
            self.max_partitioning_rounds,
            MAX_ALLOWED_PARTITIONING_ROUNDS
        );
        // ... rest of build()
    }
}
```

**2. Runtime validation in `SubBlockIdx::new()`:**
```rust
impl SubBlockIdx {
    pub fn new(round_id: RoundId, shard_id: ShardId) -> Self {
        assert!(
            round_id <= GLOBAL_ROUND_ID,
            "round_id ({}) must be <= GLOBAL_ROUND_ID ({})",
            round_id, GLOBAL_ROUND_ID
        );
        SubBlockIdx { round_id, shard_id }
    }
}
```

**3. Add validation when marking transactions as ordered:**
Check in `ConflictingTxnTracker::mark_txn_ordered()` that `round_id < GLOBAL_ROUND_ID` for sharded transactions.

## Proof of Concept

```rust
// File: execution/block-partitioner/tests/round_bounds_test.rs
use aptos_block_partitioner::{
    test_utils::P2PBlockGenerator,
    v2::config::PartitionerV2Config,
    PartitionerConfig,
};
use aptos_types::block_executor::partitioner::MAX_ALLOWED_PARTITIONING_ROUNDS;
use rand::thread_rng;

#[test]
#[should_panic(expected = "index out of bounds")]
fn test_round_id_exceeds_max_allowed_rounds() {
    let block_gen = P2PBlockGenerator::new(1000);
    let mut rng = thread_rng();
    
    // Create partitioner with invalid configuration
    let partitioner = PartitionerV2Config::default()
        .max_partitioning_rounds(MAX_ALLOWED_PARTITIONING_ROUNDS + 1) // 9 rounds
        .partition_last_round(true) // Keep all rounds as sharded
        .build();
    
    // Generate a block with many conflicts to trigger multiple partitioning rounds
    let transactions = block_gen.rand_block(&mut rng, 10000);
    
    // This should panic when trying to partition into 9 rounds
    let partitioned = partitioner.partition(transactions, 4);
    
    // If we get here, try to execute (will panic on cross-shard messaging)
    // Execution code would trigger: message_txs[shard_id][8] -> out of bounds!
}
```

## Notes

The vulnerability demonstrates a critical gap between the **semantic invariant** (round bounds must be respected) and its **enforcement** in code. While the default configuration is safe, the absence of validation violates defensive programming principles for safety-critical blockchain infrastructure. The fix should add validation at configuration time (fail-fast) and runtime (defense-in-depth) to prevent this class of configuration errors from causing node crashes.

### Citations

**File:** types/src/block_executor/partitioner.rs (L20-22)
```rust
pub static MAX_ALLOWED_PARTITIONING_ROUNDS: usize = 8;
pub static GLOBAL_ROUND_ID: usize = MAX_ALLOWED_PARTITIONING_ROUNDS + 1;
pub static GLOBAL_SHARD_ID: usize = usize::MAX;
```

**File:** execution/block-partitioner/src/v2/types.rs (L31-33)
```rust
    pub fn new(round_id: RoundId, shard_id: ShardId) -> Self {
        SubBlockIdx { round_id, shard_id }
    }
```

**File:** execution/block-partitioner/src/v2/config.rs (L54-65)
```rust
impl Default for PartitionerV2Config {
    fn default() -> Self {
        Self {
            num_threads: 8,
            max_partitioning_rounds: 4,
            cross_shard_dep_avoid_threshold: 0.9,
            dashmap_num_shards: 64,
            partition_last_round: false,
            pre_partitioner_config: Box::<ConnectedComponentPartitionerConfig>::default(),
        }
    }
}
```

**File:** execution/block-partitioner/src/v2/build_edge.rs (L55-70)
```rust
        let global_txns: Vec<TransactionWithDependencies<AnalyzedTransaction>> =
            if !state.partition_last_round {
                state
                    .sub_block_matrix
                    .pop()
                    .unwrap()
                    .last()
                    .unwrap()
                    .lock()
                    .unwrap()
                    .take()
                    .unwrap()
                    .into_transactions_with_deps()
            } else {
                vec![]
            };
```

**File:** execution/block-partitioner/src/v2/partition_to_matrix.rs (L37-70)
```rust
        for round_id in 0..(state.num_rounds_limit - 1) {
            let (accepted, discarded) = Self::discarding_round(state, round_id, remaining_txns);
            state.finalized_txn_matrix.push(accepted);
            remaining_txns = discarded;
            num_remaining_txns = remaining_txns.iter().map(|ts| ts.len()).sum();

            if num_remaining_txns
                < ((1.0 - state.cross_shard_dep_avoid_threshold) * state.num_txns() as f32) as usize
            {
                break;
            }
        }

        let _timer = MISC_TIMERS_SECONDS.timer_with(&["last_round"]);

        if !state.partition_last_round {
            trace!("Merging txns after discarding stopped.");
            let last_round_txns: Vec<PrePartitionedTxnIdx> =
                remaining_txns.into_iter().flatten().collect();
            remaining_txns = vec![vec![]; state.num_executor_shards];
            remaining_txns[state.num_executor_shards - 1] = last_round_txns;
        }

        let last_round_id = state.finalized_txn_matrix.len();
        state.thread_pool.install(|| {
            (0..state.num_executor_shards)
                .into_par_iter()
                .for_each(|shard_id| {
                    remaining_txns[shard_id].par_iter().for_each(|&txn_idx| {
                        state.update_trackers_on_accepting(txn_idx, last_round_id, shard_id);
                    });
                });
        });
        state.finalized_txn_matrix.push(remaining_txns);
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L95-104)
```rust
        let (cross_shard_msg_txs, cross_shard_msg_rxs): (
            Vec<Vec<Sender<CrossShardMsg>>>,
            Vec<Vec<Receiver<CrossShardMsg>>>,
        ) = (0..num_shards)
            .map(|_| {
                (0..MAX_ALLOWED_PARTITIONING_ROUNDS)
                    .map(|_| unbounded())
                    .unzip()
            })
            .unzip();
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L331-333)
```rust
    fn send_cross_shard_msg(&self, shard_id: ShardId, round: RoundId, msg: CrossShardMsg) {
        self.message_txs[shard_id][round].send(msg).unwrap()
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_executor_service.rs (L164-168)
```rust
                    cross_shard_client_clone.send_cross_shard_msg(
                        shard_id,
                        round,
                        CrossShardMsg::StopMsg,
                    );
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L55-58)
```rust
    fn send_cross_shard_msg(&self, shard_id: ShardId, round: RoundId, msg: CrossShardMsg) {
        let input_message = bcs::to_bytes(&msg).unwrap();
        let tx = self.message_txs[shard_id][round].lock().unwrap();
        tx.send(Message::new(input_message)).unwrap();
```

**File:** execution/executor-service/src/test_utils.rs (L132-136)
```rust
    let partitioner = PartitionerV2Config::default()
        .max_partitioning_rounds(2)
        .cross_shard_dep_avoid_threshold(0.9)
        .partition_last_round(true)
        .build();
```
