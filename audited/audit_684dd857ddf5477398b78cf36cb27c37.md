# Audit Report

## Title
Missing Cryptographic Verification During State Snapshot Backup Allows Transaction Info Tampering and Execution Divergence

## Summary
The `get_state_root_proof()` function in `BackupHandler` performs no cryptographic verification when creating backups, and the restore process conditionally skips LedgerInfo signature verification when `epoch_history` is `None`. This allows a compromised or corrupted database to export TransactionInfo with wrong `gas_used`, `state_checkpoint_hash`, or `event_root_hash` values that will be accepted during one-off restore operations, causing execution divergence.

## Finding Description

The backup/restore system has a critical verification gap that breaks the **State Consistency** and **Deterministic Execution** invariants:

**During Backup (No Verification):**
The `BackupHandler::get_state_root_proof()` function retrieves TransactionInfo and LedgerInfo from the database without any cryptographic verification. [1](#0-0) 

The TransactionInfo is read directly from `transaction_info_db` without validation. [2](#0-1) 

**During Restore (Conditional Verification):**
The restore process verifies the accumulator proof but only validates LedgerInfo signatures if `epoch_history` is provided. [3](#0-2) 

The proof verification only checks that the TransactionInfo hash matches the accumulator, not that the individual fields are correct. [4](#0-3) 

**Critical Gap:**
When performing one-off restores via `db-tool`, `epoch_history` is explicitly set to `None`, skipping all signature verification. [5](#0-4) 

**Attack Path:**
1. Attacker compromises a backup source database (via hardware corruption, malicious backup provider, or MITM attack on backup storage)
2. Modifies `TransactionInfo` at version X to have incorrect:
   - `gas_used` (wrong gas accounting)
   - `state_checkpoint_hash` (wrong state root pointer)
   - `event_root_hash` (wrong event root)
3. Updates transaction accumulator to store hash of modified `TransactionInfo`
4. Modifies `LedgerInfo` to have the corrupted `transaction_accumulator_hash` (with invalid signatures)
5. Victim performs one-off state snapshot restore with `epoch_history=None`
6. Proof verification passes (modified TransactionInfo hash matches modified accumulator matches modified LedgerInfo)
7. Signature verification is skipped
8. Corrupted state is restored to victim's database

The restored node now has wrong TransactionInfo, causing:
- Incorrect gas accounting when processing transactions
- Wrong state root causing state sync failures
- Execution divergence from honest nodes
- Inability to participate in consensus

## Impact Explanation

**Severity: Critical**

This vulnerability meets **Critical Severity** criteria per Aptos Bug Bounty:
- **Consensus/Safety violations**: Restored nodes have inconsistent state leading to consensus divergence
- **State inconsistencies requiring intervention**: Affected nodes cannot sync with network and require complete database rebuild
- Breaks fundamental invariants:
  - **Invariant #1 (Deterministic Execution)**: Restored node has different state root than honest nodes
  - **Invariant #4 (State Consistency)**: State transitions not cryptographically verified

The attack enables an adversary to cause any node performing unverified restores to have corrupted state that prevents network participation.

## Likelihood Explanation

**Likelihood: Medium-High**

Required conditions:
1. Compromised backup source (database corruption, malicious backup provider, or MITM on backup storage) - **Realistic**: Hardware failures, cloud storage compromises, and malicious actors providing "helpful" backups are common
2. Victim performs one-off restore without epoch history - **Common**: The `db-tool` explicitly supports this mode for operational convenience

No privileged validator access required - any entity providing backup files or operating backup storage can execute this attack. The attack is particularly concerning for new nodes bootstrapping from community-provided backups.

## Recommendation

**Mandatory Signature Verification:**
Always verify LedgerInfo signatures during restore operations. Remove the conditional check and make `epoch_history` mandatory for state snapshot restores:

```rust
// In StateSnapshotRestoreController::run_impl()
let manifest: StateSnapshotBackup =
    self.storage.load_json_file(&self.manifest_handle).await?;
let (txn_info_with_proof, li): (TransactionInfoWithProof, LedgerInfoWithSignatures) =
    self.storage.load_bcs_file(&manifest.proof).await?;
txn_info_with_proof.verify(li.ledger_info(), manifest.version)?;

// ALWAYS verify signatures - make epoch_history mandatory
let epoch_history = self.epoch_history.as_ref()
    .ok_or_else(|| anyhow!("epoch_history required for secure restore"))?;
epoch_history.verify_ledger_info(&li)?;
```

**Additional Safeguards:**
1. Add cryptographic verification during backup creation to detect corruption at source
2. For one-off restores, require explicit `--allow-unverified` flag with clear security warnings
3. Document that restores without epoch verification should only use trusted backup sources

## Proof of Concept

```rust
// Reproduction steps demonstrating the vulnerability:

// 1. Setup: Create a backup from a node
// 2. Corrupt the backup by modifying TransactionInfo, accumulator, and LedgerInfo
// 3. Attempt restore with epoch_history=None
// 4. Observe that corrupted data is accepted without signature verification

// File: storage/backup/backup-cli/tests/integration_test.rs
#[tokio::test]
async fn test_unverified_restore_accepts_corrupted_data() {
    // Create legitimate backup
    let backup_storage = create_test_backup().await;
    
    // Corrupt TransactionInfo in backup
    let corrupted_txn_info = TransactionInfo::new(
        HashValue::random(),  // wrong transaction_hash
        HashValue::random(),  // wrong state_change_hash
        HashValue::random(),  // wrong event_root_hash
        Some(HashValue::random()),  // wrong state_checkpoint_hash
        0,  // wrong gas_used (should be non-zero)
        ExecutionStatus::Success,
        None,
    );
    
    // Corrupt accumulator and LedgerInfo to match
    let corrupted_accumulator = create_accumulator_with_hash(corrupted_txn_info.hash());
    let corrupted_ledger_info = LedgerInfoWithSignatures::new(
        LedgerInfo::new(
            BlockInfo::new(epoch, version, HashValue::random(), 
                          corrupted_accumulator.root_hash(), ...),
            HashValue::random(),
        ),
        BTreeMap::new(),  // No signatures - would be invalid
    );
    
    // Save corrupted backup
    save_corrupted_backup(&backup_storage, corrupted_txn_info, 
                         corrupted_accumulator, corrupted_ledger_info).await;
    
    // Attempt restore with epoch_history=None
    let result = StateSnapshotRestoreController::new(
        opt,
        global_opt,
        backup_storage,
        None,  // epoch_history = None skips signature verification
    )
    .run()
    .await;
    
    // Vulnerability: Restore succeeds with corrupted data
    assert!(result.is_ok());  // Should FAIL but passes
    
    // Verify corrupted state was restored
    let restored_txn_info = db.get_transaction_info(version).unwrap();
    assert_eq!(restored_txn_info, corrupted_txn_info);  // Wrong data accepted!
}
```

---

**Notes:**

This vulnerability arises from the design decision to make signature verification optional during restore operations. While this provides operational flexibility, it creates a critical security gap where corrupted or malicious backup data can be restored without cryptographic validation. The issue is particularly severe because the `TransactionInfo` struct contains critical consensus data (`state_checkpoint_hash`, `gas_used`, `event_root_hash`) that directly impacts execution determinism. Any node restoring from a compromised backup without epoch history will diverge from the network and be unable to participate in consensus.

### Citations

**File:** storage/aptosdb/src/backup/backup_handler.rs (L188-205)
```rust
    pub fn get_state_root_proof(
        &self,
        version: Version,
    ) -> Result<(TransactionInfoWithProof, LedgerInfoWithSignatures)> {
        let ledger_metadata_db = self.ledger_db.metadata_db();
        let epoch = ledger_metadata_db.get_epoch(version)?;
        let ledger_info = ledger_metadata_db.get_latest_ledger_info_in_epoch(epoch)?;
        let txn_info = self
            .ledger_db
            .transaction_info_db()
            .get_transaction_info_with_proof(
                version,
                ledger_info.ledger_info().version(),
                self.ledger_db.transaction_accumulator_db(),
            )?;

        Ok((txn_info, ledger_info))
    }
```

**File:** storage/aptosdb/src/ledger_db/transaction_info_db.rs (L52-58)
```rust
    pub(crate) fn get_transaction_info(&self, version: Version) -> Result<TransactionInfo> {
        self.db
            .get::<TransactionInfoSchema>(&version)?
            .ok_or_else(|| {
                AptosDbError::NotFound(format!("No TransactionInfo at version {}", version))
            })
    }
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L125-139)
```rust
        let (txn_info_with_proof, li): (TransactionInfoWithProof, LedgerInfoWithSignatures) =
            self.storage.load_bcs_file(&manifest.proof).await?;
        txn_info_with_proof.verify(li.ledger_info(), manifest.version)?;
        let state_root_hash = txn_info_with_proof
            .transaction_info()
            .ensure_state_checkpoint_hash()?;
        ensure!(
            state_root_hash == manifest.root_hash,
            "Root hash mismatch with that in proof. root hash: {}, expected: {}",
            manifest.root_hash,
            state_root_hash,
        );
        if let Some(epoch_history) = self.epoch_history.as_ref() {
            epoch_history.verify_ledger_info(&li)?;
        }
```

**File:** types/src/proof/mod.rs (L40-61)
```rust
fn verify_transaction_info(
    ledger_info: &LedgerInfo,
    transaction_version: Version,
    transaction_info: &TransactionInfo,
    ledger_info_to_transaction_info_proof: &TransactionAccumulatorProof,
) -> Result<()> {
    ensure!(
        transaction_version <= ledger_info.version(),
        "Transaction version {} is newer than LedgerInfo version {}.",
        transaction_version,
        ledger_info.version(),
    );

    let transaction_info_hash = transaction_info.hash();
    ledger_info_to_transaction_info_proof.verify(
        ledger_info.transaction_accumulator_hash(),
        transaction_info_hash,
        transaction_version,
    )?;

    Ok(())
}
```

**File:** storage/db-tool/src/restore.rs (L88-93)
```rust
                        StateSnapshotRestoreController::new(
                            opt,
                            global.try_into()?,
                            storage.init_storage().await?,
                            None, /* epoch_history */
                        )
```
