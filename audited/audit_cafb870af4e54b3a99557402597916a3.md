# Audit Report

## Title
Cross-Round Write-Write Conflict Causes Non-Deterministic State Computation in Sharded Block Executor

## Summary
The sharded block executor allows different shards to concurrently write to the same `StateKey` across different execution rounds without proper conflict resolution. The `RemoteStateValue::set_value()` method unconditionally overwrites previous values, creating a race condition where the final state depends on message arrival order rather than transaction execution order. This violates the fundamental deterministic execution invariant, causing validators to potentially compute different state roots for the same block. [1](#0-0) 

## Finding Description

The vulnerability occurs when transactions in different shards write to the same `StateKey` in different execution rounds. The partitioner's conflict avoidance only applies **within** a single round, not **across** rounds: [2](#0-1) 

When cross-round writes occur:

1. Each shard executes its rounds sequentially, but **different shards execute concurrently** [3](#0-2) 

2. Transactions send cross-shard write messages via `send_cross_shard_msg()`: [4](#0-3) 

3. The receiver processes messages and calls `set_value()` on the `RemoteStateValue`: [5](#0-4) 

4. **Critical bug**: `RemoteStateValue::set_value()` unconditionally **overwrites** the previous value with no conflict detection: [6](#0-5) 

**Attack Scenario:**
- Block contains Shard 0 (Round 0, Transaction T1: write `StateKey K = V1`) and Shard 1 (Round 1, Transaction T2: write `StateKey K = V2`)
- Transaction T3 in Shard 2 has a dependency on `K`
- Both T1 and T2 execute concurrently and send cross-shard messages
- Depending on network timing, T3 may receive V1 then V2 (correct), or V2 then V1 (incorrect - earlier value overwrites later value)
- Validators with different message orderings compute different final states
- **Result**: Consensus failure, state root mismatch, blockchain halt

This breaks **Invariant #1: Deterministic Execution** - validators must produce identical state roots for identical blocks.

## Impact Explanation

This is **CRITICAL severity** under the Aptos bug bounty program because it causes:

1. **Consensus/Safety Violations**: Validators compute different state roots for the same block, causing consensus failure and potential chain splits
2. **Non-recoverable network partition**: Once validators diverge on state, the network cannot recover without manual intervention or a hard fork
3. **Total loss of liveness**: The blockchain halts when validators fail to agree on state roots

The vulnerability affects ALL validators running sharded execution mode. Any attacker can trigger this by submitting transactions that create cross-round write conflicts, requiring only:
- Knowledge of account addresses/resources to target
- Ability to submit transactions (no special privileges needed)
- Understanding of how the partitioner assigns transactions to shards

## Likelihood Explanation

**HIGH likelihood** because:

1. The vulnerability is **inherent to the design** - cross-round dependency tracking is explicitly unimplemented: [7](#0-6) 

2. All conflict-related tests are **ignored** (not run in CI), indicating known issues: [8](#0-7) 

3. The partitioner test only validates **within-round** conflict avoidance, not cross-round: [9](#0-8) 

4. Common DeFi patterns (multiple users trading the same token, updating shared liquidity pools) naturally create cross-shard write conflicts

5. No runtime protection prevents enabling sharded execution in production with this bug present

## Recommendation

**Immediate fixes required:**

1. **Implement cross-round dependency tracking** in the partitioner to ensure transactions writing to the same `StateKey` in different rounds are properly ordered with dependency edges

2. **Add conflict detection to `RemoteStateValue::set_value()`**:
```rust
pub fn set_value(&self, value: Option<StateValue>) {
    let (lock, cvar) = &*self.value_condition;
    let mut status = lock.lock().unwrap();
    
    // Prevent overwriting already-set values
    if matches!(*status, RemoteValueStatus::Ready(_)) {
        panic!("Attempt to overwrite already-set cross-shard value - indicates missing dependency tracking");
    }
    
    *status = RemoteValueStatus::Ready(value);
    cvar.notify_all();
}
```

3. **Disable sharded execution in production** until proper cross-round dependency tracking is implemented

4. **Implement deterministic message ordering** using transaction indices rather than relying on network timing

5. **Add validation** to verify that all shards compute identical state roots before committing blocks

## Proof of Concept

The existing test demonstrates the issue (currently ignored): [10](#0-9) 

To reproduce:

1. Enable the ignored test `test_partitioner_v2_uniform_sharded_block_executor_with_conflict_parallel`
2. Run with transactions that write to overlapping state keys across multiple rounds
3. Observe non-deterministic failures where sharded execution produces different outputs than sequential execution
4. State root mismatches occur when message ordering differs between runs

The vulnerability is confirmed by the fact that ALL conflict tests are marked `#[ignore]` and explicitly documented as non-functional due to missing cross-round dependency tracking.

---

**Notes:**
- This vulnerability exists in the production codebase despite developer awareness (indicated by ignored tests)
- The sharded block executor feature should not be enabled in production until this is resolved
- The issue affects consensus safety, making it the highest severity category in the bug bounty program
- No special permissions or validator access is required to exploit this - any transaction sender can trigger the race condition

### Citations

**File:** aptos-move/aptos-vm/tests/sharded_block_executor.rs (L38-42)
```rust
#[test]
#[ignore]
// Sharded execution with cross shard conflict doesn't work for now because we don't have
// cross round dependency tracking yet.
fn test_partitioner_v2_uniform_sharded_block_executor_with_conflict_parallel() {
```

**File:** aptos-move/aptos-vm/tests/sharded_block_executor.rs (L127-128)
```rust
// Sharded execution with cross shard conflict doesn't work for now because we don't have
// cross round dependency tracking yet.
```

**File:** aptos-move/aptos-vm/tests/sharded_block_executor.rs (L336-385)
```rust
    pub fn sharded_block_executor_with_conflict<E: ExecutorClient<InMemoryStateStore>>(
        partitioner: Box<dyn BlockPartitioner>,
        sharded_block_executor: ShardedBlockExecutor<InMemoryStateStore, E>,
        concurrency: usize,
    ) {
        let num_txns = 800;
        let num_shards = sharded_block_executor.num_shards();
        let num_accounts = 80;
        let state_store = InMemoryStateStore::from_head_genesis();
        let mut transactions = Vec::new();
        let mut accounts = Vec::new();
        let mut txn_hash_to_account = HashMap::new();
        for _ in 0..num_accounts {
            let account = generate_account_at(&state_store, AccountAddress::random());
            accounts.push(Mutex::new(account));
        }
        for i in 1..num_txns / num_accounts {
            for j in 0..num_accounts {
                let sender = &mut accounts[j].lock().unwrap();
                let sender_addr = *sender.address();
                let receiver = &accounts[(j + i) % num_accounts].lock().unwrap();
                let transfer_amount = 1_000;
                let txn = generate_p2p_txn(sender, receiver, transfer_amount);
                txn_hash_to_account.insert(txn.transaction().hash(), sender_addr);
                transactions.push(txn)
            }
        }

        let partitioned_txns = partitioner.partition(transactions.clone(), num_shards);

        let execution_ordered_txns: Vec<SignatureVerifiedTransaction> =
            PartitionedTransactions::flatten(partitioned_txns.clone())
                .into_iter()
                .map(|t| t.into_txn())
                .collect();
        let sharded_txn_output = sharded_block_executor
            .execute_block(
                Arc::new(state_store.clone()),
                partitioned_txns,
                concurrency,
                BlockExecutorConfigFromOnchain::new_no_block_limit(),
            )
            .unwrap();

        let txn_provider = DefaultTxnProvider::new_without_info(execution_ordered_txns);
        let unsharded_txn_output = AptosVMBlockExecutor::new()
            .execute_block_no_limit(&txn_provider, &state_store)
            .unwrap();
        compare_txn_outputs(unsharded_txn_output, sharded_txn_output);
    }
```

**File:** execution/block-partitioner/src/v2/partition_to_matrix.rs (L122-126)
```rust
                            if state.key_owned_by_another_shard(shard_id, key_idx) {
                                in_round_conflict_detected = true;
                                break;
                            }
                        }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_executor_service.rs (L192-193)
```rust
        for (round, sub_block) in transactions.into_sub_blocks().into_iter().enumerate() {
            let _timer = SHARDED_BLOCK_EXECUTION_BY_ROUNDS_SECONDS
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L55-59)
```rust
    fn send_cross_shard_msg(&self, shard_id: ShardId, round: RoundId, msg: CrossShardMsg) {
        let input_message = bcs::to_bytes(&msg).unwrap();
        let tx = self.message_txs[shard_id][round].lock().unwrap();
        tx.send(Message::new(input_message)).unwrap();
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L34-38)
```rust
                RemoteTxnWriteMsg(txn_commit_msg) => {
                    let (state_key, write_op) = txn_commit_msg.take();
                    cross_shard_state_view
                        .set_value(&state_key, write_op.and_then(|w| w.as_state_value()));
                },
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/remote_state_value.rs (L22-27)
```rust
    pub fn set_value(&self, value: Option<StateValue>) {
        let (lock, cvar) = &*self.value_condition;
        let mut status = lock.lock().unwrap();
        *status = RemoteValueStatus::Ready(value);
        cvar.notify_all();
    }
```

**File:** execution/block-partitioner/src/tests.rs (L124-125)
```rust
    let num_partitioning_rounds = sub_blocks[0].num_sub_blocks() - 1;
    for round in 0..num_partitioning_rounds {
```
