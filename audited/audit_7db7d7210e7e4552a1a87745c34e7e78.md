# Audit Report

## Title
Insecure File Permissions in Move Package Compilation Allow Local Privilege Escalation and Supply Chain Attacks

## Summary
The Move package build system creates files and directories without explicitly setting secure permissions, relying on the process's umask. When developers or validators compile Move packages with an insecure umask (e.g., 0000 or 0002), the resulting build artifacts, dependency caches, and git checkouts are created with world-writable or group-writable permissions. This allows local attackers to modify compiled bytecode, poison dependency caches, and inject malicious code into the supply chain before deployment to Aptos mainnet.

## Finding Description

The Move package compilation system creates files and directories in multiple locations without setting explicit permissions:

**1. Compiled Package Artifacts:** [1](#0-0) 

This creates the root build directory using `std::fs::create_dir_all()` which respects the process's umask without enforcing secure permissions. [2](#0-1) 

The `save_under()` method creates parent directories and writes files without setting permissions, allowing them to inherit insecure permissions from the umask.

**2. Package Cache Git Checkouts:** [3](#0-2) 

Git repository checkouts create directories and files without explicit permissions.

**3. On-Chain Package Cache:** [4](#0-3) 

Cached on-chain modules are written without secure permissions.

**Attack Scenarios:**

**Scenario A - Bytecode Injection:** A developer runs `move build` on a shared development server or CI/CD system with umask 0000. The build directory is created with 0777 permissions. A local attacker modifies the compiled `.mv` bytecode files before deployment, injecting malicious code that gets deployed to mainnet.

**Scenario B - Dependency Poisoning:** A validator runs `move build --fetch-deps-only` with umask 0002 in a containerized environment (many Docker containers default to permissive umask). Git checkouts are created with group-writable permissions. An attacker in the same group modifies dependency source files. All subsequent builds compile the poisoned dependencies, affecting multiple packages.

**Scenario C - Supply Chain Attack:** In a CI/CD pipeline running with default umask 0000, an attacker with access to the build agent modifies cached dependencies in MOVE_HOME. All packages built by that CI/CD system include the malicious dependency code.

The Aptos codebase demonstrates awareness of this issue in other contexts: [5](#0-4) 

This shows that confidential files use explicit 0600 permissions, but the Move build system does not apply similar protections.

## Impact Explanation

This vulnerability is classified as **Medium Severity** per Aptos bug bounty criteria for the following reasons:

1. **Limited Funds Loss or Manipulation**: If malicious bytecode is deployed to mainnet due to tampered build artifacts, it could lead to loss of user funds through the malicious smart contract logic.

2. **State Inconsistencies**: Malicious code deployed via this vector could cause state inconsistencies requiring intervention if it corrupts on-chain data structures.

3. **Supply Chain Risk**: Dependency poisoning affects multiple packages and developers, creating a widespread impact beyond a single deployment.

4. **Indirect Impact**: Unlike critical vulnerabilities that directly compromise the blockchain protocol, this requires multiple steps: insecure umask → local access → file modification → deployment of modified code.

The vulnerability breaks the **Deterministic Execution** invariant: if different validators or developers deploy different versions of "the same" package due to local tampering, it could lead to consensus issues.

## Likelihood Explanation

**Likelihood: Medium**

**Factors Increasing Likelihood:**
- Docker containers often default to umask 0000 for convenience
- Shared development servers may use relaxed umask (0002) for collaboration
- CI/CD systems may not explicitly set secure umask
- Cloud build environments sometimes run with permissive defaults
- Validators running multiple services on the same system

**Factors Decreasing Likelihood:**
- Most Unix systems default to umask 0022 (secure)
- Requires local system access (not remote exploit)
- Requires user to actually deploy the modified code
- Security-conscious organizations follow proper deployment hygiene

The vulnerability is realistic in production environments, particularly CI/CD pipelines and containerized builds where umask configuration is often overlooked.

## Recommendation

Set explicit file permissions when creating files and directories in the Move package build system. Use platform-specific permission APIs to ensure secure defaults regardless of umask.

**Fix for `compiled_package.rs`:**

```rust
use std::os::unix::fs::DirBuilderExt;
use std::os::unix::fs::OpenOptionsExt;

pub(crate) fn save_under(&self, file: impl AsRef<Path>, bytes: &[u8]) -> Result<()> {
    let path_to_save = self.root_path.join(file);
    let parent = path_to_save.parent().unwrap();
    
    #[cfg(unix)]
    {
        let mut builder = std::fs::DirBuilder::new();
        builder.mode(0o755); // rwxr-xr-x
        builder.recursive(true);
        builder.create(parent)?;
        
        let mut opts = std::fs::OpenOptions::new();
        opts.write(true);
        opts.create(true);
        opts.mode(0o644); // rw-r--r--
        opts.open(&path_to_save)?.write_all(bytes)?;
    }
    
    #[cfg(not(unix))]
    {
        std::fs::create_dir_all(parent)?;
        std::fs::write(path_to_save, bytes)?;
    }
    
    Ok(())
}
```

**Apply similar fixes to:**
- Line 867 in `compiled_package.rs` when creating the root build directory
- All directory creation in `package_cache.rs` (lines 84, 106, 230, 258, 312, 382)
- All file creation in `package_cache.rs` (lines 259, 383)

**Additional Hardening:**
1. Document secure umask requirements in deployment guides
2. Add runtime umask checks that warn when umask is too permissive
3. Implement build-time verification of file permissions
4. Use temporary directories with secure permissions, then atomic rename

## Proof of Concept

```rust
// Test demonstrating insecure file permissions
// Save as: tests/insecure_permissions_test.rs

#[cfg(unix)]
#[test]
fn test_insecure_build_permissions() {
    use std::os::unix::fs::PermissionsExt;
    use std::path::PathBuf;
    use tempfile::TempDir;
    
    // Simulate building with insecure umask
    unsafe {
        libc::umask(0o000); // World-writable umask
    }
    
    let temp_dir = TempDir::new().unwrap();
    let build_path = temp_dir.path().join("build");
    
    // This is what move-package does
    std::fs::create_dir_all(&build_path).unwrap();
    std::fs::write(build_path.join("test.mv"), b"bytecode").unwrap();
    
    // Check permissions
    let dir_perms = std::fs::metadata(&build_path)
        .unwrap()
        .permissions()
        .mode() & 0o777;
    let file_perms = std::fs::metadata(build_path.join("test.mv"))
        .unwrap()
        .permissions()
        .mode() & 0o777;
    
    println!("Directory permissions: {:o}", dir_perms);
    println!("File permissions: {:o}", file_perms);
    
    // These will be 0777 and 0666 respectively - INSECURE!
    assert_eq!(dir_perms, 0o777, "Directory is world-writable!");
    assert_eq!(file_perms, 0o666, "File is world-writable!");
    
    // Restore safe umask
    unsafe {
        libc::umask(0o022);
    }
}

#[cfg(unix)]
#[test]
fn test_secure_build_permissions() {
    use std::os::unix::fs::{DirBuilderExt, OpenOptionsExt, PermissionsExt};
    use std::io::Write;
    use tempfile::TempDir;
    
    // Even with insecure umask
    unsafe {
        libc::umask(0o000);
    }
    
    let temp_dir = TempDir::new().unwrap();
    let build_path = temp_dir.path().join("build");
    
    // Secure way - explicit permissions
    let mut builder = std::fs::DirBuilder::new();
    builder.mode(0o755);
    builder.recursive(true);
    builder.create(&build_path).unwrap();
    
    let mut opts = std::fs::OpenOptions::new();
    opts.write(true);
    opts.create(true);
    opts.mode(0o644);
    opts.open(build_path.join("test.mv"))
        .unwrap()
        .write_all(b"bytecode")
        .unwrap();
    
    // Check permissions
    let dir_perms = std::fs::metadata(&build_path)
        .unwrap()
        .permissions()
        .mode() & 0o777;
    let file_perms = std::fs::metadata(build_path.join("test.mv"))
        .unwrap()
        .permissions()
        .mode() & 0o777;
    
    println!("Secure directory permissions: {:o}", dir_perms);
    println!("Secure file permissions: {:o}", file_perms);
    
    // These are secure regardless of umask
    assert_eq!(dir_perms, 0o755, "Directory has secure permissions");
    assert_eq!(file_perms, 0o644, "File has secure permissions");
    
    unsafe {
        libc::umask(0o022);
    }
}
```

**To reproduce the vulnerability:**

1. Set insecure umask: `umask 0000`
2. Build a Move package: `aptos move compile`
3. Check permissions: `ls -la build/`
4. Observe world-writable directories and files
5. As another user on the system, modify: `echo "malicious" > build/MyPackage/bytecode_modules/MyModule.mv`
6. Deploy the package (now contains malicious bytecode)

## Notes

While this vulnerability requires local system access and a misconfigured umask, it represents a real supply chain security risk in modern development and deployment practices. Container-based CI/CD systems, shared development servers, and cloud build environments often operate with permissive default umask settings. The fix is straightforward and follows the defense-in-depth principle: security-critical files should have explicit permissions regardless of environment configuration.

### Citations

**File:** third_party/move/tools/move-package/src/compilation/compiled_package.rs (L279-283)
```rust
    pub(crate) fn save_under(&self, file: impl AsRef<Path>, bytes: &[u8]) -> Result<()> {
        let path_to_save = self.root_path.join(file);
        let parent = path_to_save.parent().unwrap();
        std::fs::create_dir_all(parent)?;
        std::fs::write(path_to_save, bytes).map_err(|err| err.into())
```

**File:** third_party/move/tools/move-package/src/compilation/compiled_package.rs (L867-867)
```rust
        std::fs::create_dir_all(&on_disk_package.root_path)?;
```

**File:** third_party/move/tools/move-package-cache/src/package_cache.rs (L258-260)
```rust
                    fs::create_dir_all(full_path.parent().unwrap()).unwrap();
                    let mut file = File::create(&full_path).unwrap();
                    file.write_all(blob.content()).unwrap();
```

**File:** third_party/move/tools/move-package-cache/src/package_cache.rs (L382-384)
```rust
                    fs::create_dir_all(module_file_path.parent().unwrap())?;
                    let mut file = File::create(&module_file_path)?;
                    file.write_all(&module_bytes)?;
```

**File:** crates/aptos/src/common/types.rs (L1083-1089)
```rust
    /// Save to the `output_file` with restricted permissions (mode 0600)
    pub fn save_to_file_confidential(&self, name: &str, bytes: &[u8]) -> CliTypedResult<()> {
        let mut opts = OpenOptions::new();
        #[cfg(unix)]
        opts.mode(0o600);
        write_to_file_with_opts(self.output_file.as_path(), name, bytes, &mut opts)
    }
```
