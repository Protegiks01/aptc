# Audit Report

## Title
Transaction Hash Information Loss After Successful Mempool Acceptance for Encrypted Payloads

## Summary
The `create()` function in `api/src/transactions.rs` can fail to construct a `PendingTransaction` response after successfully submitting a transaction to mempool, specifically when handling encrypted payloads with JSON accept types. This causes users to receive an error despite their transaction being accepted, resulting in loss of the critical transaction hash needed for tracking.

## Finding Description

The vulnerability occurs in the transaction submission flow when encrypted transactions are enabled and users request JSON responses: [1](#0-0) 

After `create_internal()` successfully submits the transaction to mempool (returning `MempoolStatusCode::Accepted`), the code attempts to convert the transaction to a `PendingTransaction` for JSON responses. However, this conversion fails for encrypted payloads: [2](#0-1) 

The root cause is a mismatch between validation and conversion logic. Encrypted transactions are explicitly allowed through validation when the configuration permits: [3](#0-2) 

But the JSON conversion logic unconditionally rejects them as "not supported yet".

The attack path:
1. Node operator enables encrypted transaction submission via `allow_encrypted_txns_submission = true` in configuration
2. User submits an encrypted transaction using BCS content-type (the only way to submit encrypted payloads)
3. User requests JSON response via `Accept: application/json` header, or omits the Accept header (which defaults to JSON per the implementation): [4](#0-3) 

4. Transaction passes validation and is accepted by mempool
5. Conversion to `PendingTransaction` fails with internal error
6. User receives HTTP 500 error but transaction remains in mempool
7. User loses transaction hash information (which should have been in the PendingTransaction response)

The comment in the code acknowledges this is a known concern: [5](#0-4) 

## Impact Explanation

**Severity: Medium** - State inconsistencies requiring intervention.

This vulnerability creates an inconsistency between the API's response state and the actual mempool state. Users who receive an error assume their transaction failed, when in reality it was accepted and may execute. This leads to:

1. **Loss of transaction tracking**: Users cannot track their transaction status without the hash
2. **Potential double submissions**: Users may retry with incremented sequence numbers, causing the original transaction to fail unexpectedly
3. **Unexpected state changes**: Transactions execute without user awareness, potentially transferring funds or modifying state
4. **Degraded user experience**: Users lose confidence in the API reliability

While this doesn't directly cause fund theft or consensus violations, it creates a state inconsistency that requires manual intervention to resolve (users must independently compute the transaction hash or query by sender/sequence number).

## Likelihood Explanation

**Likelihood: Low to Medium**

The vulnerability requires specific conditions:
- Node configuration must enable `allow_encrypted_txns_submission = true`
- User must submit an encrypted transaction (specialized use case)
- User must request or default to JSON response format

While encrypted transactions are currently a niche feature, if they become more widely adopted, this issue would affect all users who don't explicitly request BCS responses. The default behavior of returning JSON makes this more likely to occur in practice.

## Recommendation

**Solution: Validate accept type compatibility before mempool submission**

Check the accept type compatibility with the transaction payload type before submitting to mempool. If the accept type is JSON and the payload cannot be converted to JSON format, reject the transaction early with a clear error message.

Alternatively, for encrypted payloads specifically, either:
1. Force BCS response format regardless of accept type
2. Implement JSON serialization support for encrypted payloads (though this contradicts the "not supported yet" message)
3. Reject encrypted transactions when JSON accept type is requested during validation

The fix should be applied in the `create()` function or during validation to ensure consistency between accepted transactions and returnable responses.

## Proof of Concept

```rust
// Reproduction steps (pseudo-code for API test):
// 1. Configure node with allow_encrypted_txns_submission = true
// 2. Create and submit an encrypted transaction via BCS:

let encrypted_txn = create_encrypted_signed_transaction(sender, payload);
let bcs_encoded = bcs::to_bytes(&encrypted_txn).unwrap();

// 3. Submit with JSON accept header (or no accept header):
let response = client
    .post("/transactions")
    .header("Content-Type", "application/x.aptos.signed_transaction+bcs")
    .header("Accept", "application/json")  // or omit for default JSON
    .body(bcs_encoded)
    .send()
    .await;

// Expected: HTTP 500 Internal Server Error
// Actual mempool state: Transaction accepted and pending
// User impact: Lost transaction hash, unable to track transaction
```

**Notes:**

This vulnerability represents an API consistency issue where validation permits a transaction type that cannot be properly represented in the requested response format. The error occurs post-mempool acceptance, violating the principle that successful mempool acceptance should always return transaction tracking information. While encrypted transactions are currently a specialized feature, this architectural flaw could extend to other payload types if similar mismatches between validation and conversion logic exist elsewhere in the codebase.

### Citations

**File:** api/src/transactions.rs (L1323-1347)
```rust
            TransactionPayload::EncryptedPayload(payload) => {
                if !self.context.node_config.api.allow_encrypted_txns_submission {
                    return Err(SubmitTransactionError::bad_request_with_code(
                        "Encrypted Transaction submission is not allowed yet",
                        AptosErrorCode::InvalidInput,
                        ledger_info,
                    ));
                }

                if !payload.is_encrypted() {
                    return Err(SubmitTransactionError::bad_request_with_code(
                        "Encrypted transaction must be in encrypted state",
                        AptosErrorCode::InvalidInput,
                        ledger_info,
                    ));
                }

                if let Err(e) = payload.verify(signed_transaction.sender()) {
                    return Err(SubmitTransactionError::bad_request_with_code(
                        e.context("Encrypted transaction payload could not be verified"),
                        AptosErrorCode::InvalidInput,
                        ledger_info,
                    ));
                }
            },
```

**File:** api/src/transactions.rs (L1500-1524)
```rust
        match self.create_internal(txn.clone()).await {
            Ok(()) => match accept_type {
                AcceptType::Json => {
                    let state_view = self
                        .context
                        .latest_state_view()
                        .context("Failed to read latest state checkpoint from DB")
                        .map_err(|e| {
                            SubmitTransactionError::internal_with_code(
                                e,
                                AptosErrorCode::InternalError,
                                ledger_info,
                            )
                        })?;

                    // We provide the pending transaction so that users have the hash associated
                    let pending_txn = state_view
                            .as_converter(self.context.db.clone(), self.context.indexer_reader.clone())
                            .try_into_pending_transaction_poem(txn)
                            .context("Failed to build PendingTransaction from mempool response, even though it said the request was accepted")
                            .map_err(|err| SubmitTransactionError::internal_with_code(
                                err,
                                AptosErrorCode::InternalError,
                                ledger_info,
                            ))?;
```

**File:** api/types/src/convert.rs (L405-407)
```rust
            EncryptedPayload(_) => {
                bail!("Encrypted payload isn't supported yet")
            },
```

**File:** api/src/accept_type.rs (L39-40)
```rust
    // Default to returning content as JSON.
    Ok(AcceptType::Json)
```
