# Audit Report

## Title
State Desynchronization in Consensus Observer: Stale `highest_committed_epoch_round` After Clearing Ordered Blocks

## Summary
The `clear_all_ordered_blocks()` function in `OrderedBlockStore` fails to reset the `highest_committed_epoch_round` field when clearing the ordered blocks map. This causes a state desynchronization where valid commit decisions are incorrectly dropped after the consensus observer clears its state, preventing proper blockchain state tracking.

## Finding Description

The vulnerability exists in the consensus observer's block management system. The `clear_all_ordered_blocks()` function only clears the `ordered_blocks` map but does not reset the `highest_committed_epoch_round` field to `None`. [1](#0-0) 

This creates a state inconsistency because `highest_committed_epoch_round` holds a stale value after clearing, while the `ordered_blocks` map is empty.

The desynchronization manifests when:

1. The observer operates normally with `highest_committed_epoch_round = Some((epoch, round))` and populated ordered blocks
2. A subscription failure or fallback mode triggers `clear_pending_block_state()`, which calls `clear_block_data()`
3. The `clear_all_ordered_blocks()` function executes, clearing only the map but leaving the stale epoch/round [2](#0-1) 

4. After clearing, when `get_highest_committed_epoch_round()` is called, it returns the stale value instead of falling back to the root [3](#0-2) 

5. When new commit decisions arrive after resubscription, they are incorrectly compared against the stale value and dropped if their epoch/round is less than or equal to the stale value [4](#0-3) 

This breaks the **State Consistency** invariant (Invariant #4), as the observer's state no longer correctly reflects the actual committed blockchain state.

## Impact Explanation

**Severity: High** (up to $50,000 per Aptos Bug Bounty criteria)

This vulnerability causes **significant protocol violations** and **state inconsistencies requiring intervention**:

1. **Consensus Observer Dysfunction**: After clearing state, the observer cannot properly process valid commit decisions for earlier rounds, causing it to become stuck or permanently desynchronized
2. **Validator Node Impact**: If validators rely on the consensus observer for monitoring or fallback consensus, this could affect their ability to track the canonical chain
3. **State Tracking Failure**: The observer fails to maintain accurate state about committed blocks, violating the state consistency guarantee
4. **Persistent Desync**: The issue persists until the stale `highest_committed_epoch_round` is eventually exceeded by new commits, but during this window the observer is non-functional

The impact qualifies as High severity because it causes state inconsistencies and can slow down or impair validator node operations that depend on the consensus observer.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability will trigger whenever:
- Subscription health checks fail (network issues, peer failures)
- The observer enters fallback mode for state synchronization
- Any condition that calls `clear_pending_block_state()` [5](#0-4) 

These are normal operational scenarios that occur naturally in distributed systems. An attacker could also:
- Manipulate network conditions to trigger subscription failures
- Become an unreliable peer to force the observer into fallback mode
- Cause repeated clear operations to maximize the desynchronization window

The bug is deterministic - it will always cause the desync when the conditions are met. The complexity is low as no special privileges are required.

## Recommendation

Reset `highest_committed_epoch_round` to `None` when clearing all ordered blocks:

```rust
/// Clears all ordered blocks
pub fn clear_all_ordered_blocks(&mut self) {
    self.ordered_blocks.clear();
    self.highest_committed_epoch_round = None;
}
```

This ensures that after clearing, the `get_highest_committed_epoch_round()` function will correctly fall back to the root ledger info instead of using a stale value.

Additionally, the existing test should be enhanced to verify this behavior:

```rust
#[test]
fn test_clear_all_ordered_blocks() {
    let mut ordered_block_store = OrderedBlockStore::new(ConsensusObserverConfig::default());
    
    // Insert blocks and update highest committed
    create_and_add_ordered_blocks(&mut ordered_block_store, 10, 0);
    let commit_decision = CommitDecision::new(create_ledger_info(0, 5));
    ordered_block_store.update_commit_decision(&commit_decision);
    
    // Verify highest committed is set
    assert!(ordered_block_store.get_highest_committed_epoch_round().is_some());
    
    // Clear all ordered blocks
    ordered_block_store.clear_all_ordered_blocks();
    
    // Verify both the map AND highest_committed_epoch_round are cleared
    assert!(ordered_block_store.ordered_blocks.is_empty());
    assert!(ordered_block_store.get_highest_committed_epoch_round().is_none());
}
```

## Proof of Concept

```rust
#[test]
fn test_stale_highest_committed_after_clear() {
    use crate::consensus_observer::observer::ordered_blocks::OrderedBlockStore;
    use aptos_config::config::ConsensusObserverConfig;
    
    // Create ordered block store
    let mut ordered_block_store = OrderedBlockStore::new(ConsensusObserverConfig::default());
    
    // Simulate normal operation: insert blocks at epoch 10, rounds 0-9
    let ordered_blocks = create_and_add_ordered_blocks(&mut ordered_block_store, 10, 10);
    
    // Simulate commit decision for round 9
    let commit_info = ordered_blocks.last().unwrap().last_block().block_info();
    let commit_decision = CommitDecision::new(LedgerInfoWithSignatures::new(
        LedgerInfo::new(commit_info.clone(), HashValue::random()),
        AggregateSignature::empty(),
    ));
    ordered_block_store.update_commit_decision(&commit_decision);
    
    // Verify highest committed is (10, 9)
    assert_eq!(
        ordered_block_store.get_highest_committed_epoch_round(),
        Some((10, 9))
    );
    
    // Simulate subscription failure -> clear_all_ordered_blocks() is called
    ordered_block_store.clear_all_ordered_blocks();
    
    // BUG: ordered_blocks is empty but highest_committed_epoch_round is still (10, 9)
    assert!(ordered_block_store.ordered_blocks.is_empty());
    
    // This should be None but returns Some((10, 9)) - demonstrating the bug
    let stale_value = ordered_block_store.get_highest_committed_epoch_round();
    assert_eq!(stale_value, Some((10, 9))); // STALE!
    
    // Now simulate receiving a valid commit for epoch 10, round 5 after resubscription
    // This would be incorrectly dropped because (10, 5) <= (10, 9)
    // In process_commit_decision_message, this check would fail:
    // if (10, 5) <= (10, 9) { return; } // Drops valid commit!
}
```

## Notes

The vulnerability is particularly insidious because the test at line 235 only verifies that `ordered_blocks` is empty after clearing, but does not check the `highest_committed_epoch_round` field synchronization. [6](#0-5) 

The incomplete test allowed this state consistency bug to slip through, highlighting the importance of comprehensive state verification in distributed consensus systems.

### Citations

**File:** consensus/src/consensus_observer/observer/ordered_blocks.rs (L41-43)
```rust
    pub fn clear_all_ordered_blocks(&mut self) {
        self.ordered_blocks.clear();
    }
```

**File:** consensus/src/consensus_observer/observer/ordered_blocks.rs (L235-249)
```rust
    fn test_clear_all_ordered_blocks() {
        // Create a new ordered block store
        let mut ordered_block_store = OrderedBlockStore::new(ConsensusObserverConfig::default());

        // Insert several ordered blocks for the current epoch
        let current_epoch = 0;
        let num_ordered_blocks = 10;
        create_and_add_ordered_blocks(&mut ordered_block_store, num_ordered_blocks, current_epoch);

        // Clear all ordered blocks
        ordered_block_store.clear_all_ordered_blocks();

        // Check that all the ordered blocks were removed
        assert!(ordered_block_store.ordered_blocks.is_empty());
    }
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L93-105)
```rust
    pub fn clear_block_data(&mut self) -> LedgerInfoWithSignatures {
        // Clear the payload store
        self.block_payload_store.clear_all_payloads();

        // Clear the ordered blocks
        self.ordered_block_store.clear_all_ordered_blocks();

        // Clear the pending blocks
        self.pending_block_store.clear_missing_blocks();

        // Return the root ledger info
        self.root()
    }
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L132-141)
```rust
    pub fn get_highest_committed_epoch_round(&self) -> (u64, Round) {
        if let Some(epoch_round) = self.ordered_block_store.get_highest_committed_epoch_round() {
            // Return the highest committed epoch and round
            epoch_round
        } else {
            // Return the root epoch and round
            let root_block_info = self.root.commit_info().clone();
            (root_block_info.epoch(), root_block_info.round())
        }
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L209-213)
```rust
            // Log the failure and clear the pending block state
            warn!(LogSchema::new(LogEntry::ConsensusObserver)
                .message(&format!("Subscription checks failed! Error: {:?}", error)));
            self.clear_pending_block_state().await;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L453-461)
```rust
        let get_highest_committed_epoch_round = self
            .observer_block_data
            .lock()
            .get_highest_committed_epoch_round();
        if (commit_epoch, commit_round) <= get_highest_committed_epoch_round {
            // Update the metrics for the dropped commit decision
            update_metrics_for_dropped_commit_decision_message(peer_network_id, &commit_decision);
            return;
        }
```
