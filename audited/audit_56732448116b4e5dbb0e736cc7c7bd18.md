# Audit Report

## Title
Panic Propagation in Indexer-GRPC Conversion Functions Causes Service-Wide Crash

## Summary
The indexer-grpc-fullnode service contains multiple `panic!` calls in conversion functions that can crash the entire indexer service. Most critically, the conversion of `WriteTableItem` and `DeleteTableItem` panics when the optional `data` field is `None`—a valid state explicitly documented to occur when the table indexer is disabled. These panics propagate through `spawn_blocking` tasks and crash the main service thread, resulting in total indexer unavailability.

## Finding Description

The vulnerability exists in the conversion pipeline where blockchain transactions are transformed into protobuf messages for streaming to indexer clients.

**Critical Panic Points:** [1](#0-0) [2](#0-1) 

These functions panic when `data` is `None`. However, the API layer explicitly documents this as a **valid state**: [3](#0-2) [4](#0-3) 

The API conversion layer intentionally returns `None` to avoid crashes: [5](#0-4) [6](#0-5) 

**Panic Propagation Path:**

The conversion functions are called within `spawn_blocking` tasks: [7](#0-6) 

When tasks panic, the error propagates to the join point: [8](#0-7) 

This panic occurs in the main streaming task, crashing the entire service: [9](#0-8) 

**Additional Panic Points:** [10](#0-9) [11](#0-10) 

## Impact Explanation

**Severity: HIGH** per Aptos bug bounty criteria.

This qualifies as "API crashes" - the indexer-grpc service is a critical API component that provides transaction streaming to all indexer processors. A crash results in:

1. **Complete Indexer Service Unavailability**: The entire gRPC server thread panics and terminates
2. **Data Pipeline Disruption**: All downstream indexer processors lose connection and cannot process new transactions
3. **Service Restart Required**: Manual intervention needed to restore service
4. **Chain Impact**: While not affecting consensus, indexers are critical infrastructure for explorers, analytics, and ecosystem tools

The vulnerability is particularly severe because:
- Table operations are common in Aptos transactions (account resources, token metadata, etc.)
- The table indexer being disabled is a **valid configuration choice** for performance reasons
- Any single transaction with table operations can trigger the crash

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability will trigger in production under these conditions:

1. **Configuration**: Node operator runs indexer-grpc with table indexer disabled (valid configuration)
2. **Transaction Type**: Any transaction containing table write/delete operations (very common)
3. **Automatic Trigger**: No malicious intent required—normal blockchain operation will trigger it

The API layer's explicit handling (returning `None`) shows this scenario was anticipated and deemed valid. However, the indexer-grpc layer treats it as an impossible state and panics.

**Realistic Scenario:**
- Operator disables table indexer for performance (reduces database load)
- User creates token, updates account resource, or performs any table operation
- Transaction reaches conversion pipeline
- Service crashes immediately

## Recommendation

Replace all `panic!` and `unwrap_or_else` with proper error handling in conversion functions. Return `Result` types and handle errors gracefully.

**Fix for Table Item Conversions:**

```rust
// In convert.rs, replace lines 385-407
pub fn convert_write_set_change(change: &WriteSetChange) -> Result<transaction::WriteSetChange, String> {
    match change {
        WriteSetChange::DeleteTableItem(delete_table_item) => {
            let data = delete_table_item.data.as_ref().ok_or_else(|| {
                format!(
                    "Table data not available (table indexer may be disabled) for handle '{}'",
                    delete_table_item.handle.to_string()
                )
            })?;
            
            Ok(transaction::WriteSetChange {
                r#type: transaction::write_set_change::Type::DeleteTableItem as i32,
                change: Some(transaction::write_set_change::Change::DeleteTableItem(
                    transaction::DeleteTableItem {
                        state_key_hash: convert_hex_string_to_bytes_safe(&delete_table_item.state_key_hash)?,
                        handle: delete_table_item.handle.to_string(),
                        key: delete_table_item.key.to_string(),
                        data: Some(transaction::DeleteTableData {
                            key: data.key.to_string(),
                            key_type: data.key_type.clone(),
                        }),
                    },
                )),
            })
        },
        // ... similar for WriteTableItem
    }
}

// Add safe hex conversion
pub fn convert_hex_string_to_bytes_safe(hex_string: &str) -> Result<Vec<u8>, String> {
    hex::decode(hex_string.strip_prefix("0x").unwrap_or(hex_string))
        .map_err(|e| format!("Failed to decode hex string '{}': {}", hex_string, e))
}
```

**Propagate errors through the call chain:**
- Make `convert_transaction` return `Result`
- Handle errors in `convert_to_pb_txns`
- Log and skip problematic transactions instead of crashing

## Proof of Concept

**Reproduction Steps:**

1. Configure Aptos node with indexer-grpc enabled but table indexer disabled:
```yaml
indexer_grpc:
  enabled: true
  # Table indexer disabled or indexer_reader not configured
```

2. Submit any transaction that performs table operations (token mint, resource update, etc.)

3. The indexer service will crash when attempting to convert the transaction:

```bash
# Expected crash log:
thread 'tokio-runtime-worker' panicked at 'Could not extract data from DeletedTableItem...'
# or
thread 'tokio-runtime-worker' panicked at 'Could not extract data from DecodedTableData...'
```

**Minimal Rust Test:**

```rust
#[test]
#[should_panic(expected = "Could not extract data")]
fn test_table_item_conversion_panic() {
    use crate::convert::convert_write_set_change;
    use aptos_api_types::{DeleteTableItem, HexEncodedBytes, WriteSetChange};
    
    // Create DeleteTableItem with None data (valid state per API types)
    let delete_item = WriteSetChange::DeleteTableItem(DeleteTableItem {
        state_key_hash: "0x1234".to_string(),
        handle: HexEncodedBytes::from(vec![1, 2, 3, 4]),
        key: HexEncodedBytes::from(vec![5, 6, 7, 8]),
        data: None, // Valid when table indexer disabled
    });
    
    // This will panic and crash the service
    convert_write_set_change(&delete_item);
}
```

This test demonstrates that the conversion function cannot handle the documented valid state, violating the service's availability invariant.

---

**Notes:**
- This vulnerability affects all deployments where table indexer is disabled, a valid and documented configuration
- The fix requires careful refactoring of the entire conversion pipeline to propagate errors instead of panicking
- Until fixed, operators must ensure table indexer is always enabled, reducing deployment flexibility

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/convert.rs (L332-335)
```rust
pub fn convert_hex_string_to_bytes(hex_string: &str) -> Vec<u8> {
    hex::decode(hex_string.strip_prefix("0x").unwrap_or(hex_string))
        .unwrap_or_else(|_| panic!("Could not convert '{}' to bytes", hex_string))
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/convert.rs (L385-391)
```rust
            let data = delete_table_item.data.as_ref().unwrap_or_else(|| {
                panic!(
                    "Could not extract data from DeletedTableItem '{:?}' with handle '{:?}'",
                    delete_table_item,
                    delete_table_item.handle.to_string()
                )
            });
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/convert.rs (L428-433)
```rust
                    data: serde_json::to_string(&write_resource.data.data).unwrap_or_else(|_| {
                        panic!(
                            "Could not convert move_resource data to json '{:?}'",
                            write_resource.data
                        )
                    }),
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/convert.rs (L438-443)
```rust
            let data = write_table_item.data.as_ref().unwrap_or_else(|| {
                panic!(
                    "Could not extract data from DecodedTableData '{:?}' with handle '{:?}'",
                    write_table_item,
                    write_table_item.handle.to_string(),
                )
```

**File:** api/types/src/transaction.rs (L1130-1133)
```rust
    // This is optional, and only possible to populate if the table indexer is enabled for this node
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub data: Option<DeletedTableData>,
```

**File:** api/types/src/transaction.rs (L1183-1186)
```rust
    // This is optional, and only possible to populate if the table indexer is enabled for this node
    #[serde(skip_serializing_if = "Option::is_none")]
    #[serde(default)]
    pub data: Option<DecodedTableData>,
```

**File:** api/types/src/convert.rs (L561-566)
```rust
        let table_info = match self.get_table_info(handle)? {
            Some(ti) => ti,
            None => {
                log_missing_table_info(handle);
                return Ok(None); // if table item not found return None anyway to avoid crash
            },
```

**File:** api/types/src/convert.rs (L585-590)
```rust
        let table_info = match self.get_table_info(handle)? {
            Some(ti) => ti,
            None => {
                log_missing_table_info(handle);
                return Ok(None); // if table item not found return None anyway to avoid crash
            },
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L170-173)
```rust
            let task = tokio::task::spawn_blocking(move || {
                let raw_txns = batch;
                let api_txns = Self::convert_to_api_txns(context, raw_txns);
                let pb_txns = Self::convert_to_pb_txns(api_txns);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L202-207)
```rust
        let responses = match futures::future::try_join_all(tasks).await {
            Ok(res) => res.into_iter().flatten().collect::<Vec<_>>(),
            Err(err) => panic!(
                "[Indexer Fullnode] Error processing transaction batches: {:?}",
                err
            ),
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L101-117)
```rust
        tokio::spawn(async move {
            // Initialize the coordinator that tracks starting version and processes transactions
            let mut coordinator = IndexerStreamCoordinator::new(
                context,
                starting_version,
                ending_version,
                processor_task_count,
                processor_batch_size,
                output_batch_size,
                tx.clone(),
                // For now the request for this interface doesn't include a txn filter
                // because it is only used for the txn stream filestore worker, which
                // needs every transaction. Later we may add support for txn filtering
                // to this interface too.
                None,
                Some(abort_handle.clone()),
            );
```
