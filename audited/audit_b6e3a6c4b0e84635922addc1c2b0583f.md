# Audit Report

## Title
Logical OR Operation Incorrectly Marked as Side-Effect-Free Enabling Consensus-Breaking Dead Code Elimination

## Summary
The `Operation::is_ok_to_remove_from_code()` function incorrectly returns `true` for the `Or` operation, while returning `false` for the `And` operation. Since both operators use short-circuit evaluation in Move, this inconsistency allows the optimizer to eliminate unused `Or` expressions that contain side effects (such as abort operations), potentially causing consensus splits between validators with different optimization settings. [1](#0-0) 

## Finding Description
The vulnerability exists in the AST simplification pass of the Move compiler v2. The function `Operation::is_ok_to_remove_from_code()` determines whether an operation can be safely eliminated from code when its result is unused. This function returns `false` for `And` operations but `true` for `Or` operations. [2](#0-1) 

Both `And` and `Or` operations use short-circuit evaluation in the Move compiler v2, as documented in the Move language specification and implemented via the `gen_logical_shortcut` function: [3](#0-2) [4](#0-3) 

Short-circuit evaluation means:
- `p || q` only evaluates `q` if `p` is false
- `p && q` only evaluates `q` if `p` is true

The AST simplifier's `rewrite_sequence` function uses `is_ok_to_remove_from_code()` to eliminate unused expressions in sequences when the `OPTIMIZE_EXTRA` experiment is enabled: [5](#0-4) 

**Attack Scenario:**
A malicious actor deploys a Move module containing code like:
```move
public entry fun vulnerable() {
    let x = false;
    x || abort 42;  // Unused Or expression with abort
    // ... continue execution
}
```

When compiled with `OPTIMIZE_EXTRA` enabled, the optimizer:
1. Identifies `x || abort 42` as an unused expression in a sequence
2. Calls `is_ok_to_remove_from_code()` which returns `true` for `Or`
3. Eliminates the entire line as dead code
4. The function continues execution instead of aborting

When compiled without `OPTIMIZE_EXTRA` (or with different compiler versions):
1. The expression is retained
2. Since `x` is false, `abort 42` is evaluated (short-circuit)
3. The function aborts as expected

This creates non-deterministic execution where the same transaction produces different results depending on optimization settings, violating the **Deterministic Execution** invariant. [6](#0-5) [7](#0-6) 

## Impact Explanation
This is a **Critical Severity** consensus violation issue. According to Aptos invariant #1: "All validators must produce identical state roots for identical blocks."

If different validators use different optimization settings (e.g., some enable `OPTIMIZE_EXTRA` for performance while others don't), they will execute identical transactions differently:
- Validators with `OPTIMIZE_EXTRA=true`: Execute past the `Or` expression
- Validators with `OPTIMIZE_EXTRA=false`: Abort at the `Or` expression

This leads to:
1. **State divergence**: Validators compute different state roots for the same block
2. **Consensus failure**: Validators cannot agree on block validity
3. **Potential chain split**: The network may partition into incompatible factions

The issue also affects:
- **Move module upgrades**: Recompiling modules with different optimization settings changes behavior
- **Cross-version compatibility**: Different compiler versions produce incompatible bytecode
- **Transaction reproducibility**: Historical transactions may not replay correctly

## Likelihood Explanation
**Likelihood: Medium to High**

The vulnerability triggers when:
1. A Move module contains unused `Or` expressions with side effects (abort, function calls)
2. The module is compiled with `OPTIMIZE_EXTRA` enabled
3. Different validators use different compiler settings or versions

While `OPTIMIZE_EXTRA` is currently disabled by default, the likelihood is still significant because:
- Production validators may enable extra optimizations for performance
- Framework modules (Aptos governance, staking) compiled with different settings could exhibit this bug
- Future compiler versions may enable `OPTIMIZE_EXTRA` by default
- The inconsistency between `And` and `Or` suggests this is an overlooked bug that could manifest in multiple ways

The attack complexity is **low**: any developer can write code triggering this condition, either accidentally or maliciously.

## Recommendation
Fix the inconsistency by changing `Or` to return `false` in `is_ok_to_remove_from_code()`:

```rust
// In third_party/move/move-model/src/ast.rs, line 2892-2893:
And => false, // uses short-circuit evaluation
Or => false,  // uses short-circuit evaluation (FIXED)
```

The comment for `And` should also be corrected (it currently says "can overflow" which is incorrect for a boolean operator). The correct reasoning is that both operators use short-circuit evaluation, so removing them could eliminate side effects in the unevaluated branch.

**Additional Recommendations:**
1. Add test cases covering unused `Or` and `And` expressions with side effects in the simplifier-elimination test suite
2. Audit all other operations in `is_ok_to_remove_from_code()` for similar inconsistencies
3. Add compiler warnings when short-circuit operators are used in statement position with unused results
4. Document the optimization behavior and compiler flag implications for module developers

## Proof of Concept
Create a Move test module demonstrating the vulnerability:

```move
module 0x1::consensus_split_poc {
    public entry fun test_or_elimination() {
        let x = false;
        // This unused Or expression should abort when x is false
        // But with OPTIMIZE_EXTRA, it gets eliminated as "dead code"
        x || abort 42;
        
        // If we reach here, consensus is broken
        assert!(true, 99);
    }
    
    public entry fun test_and_not_eliminated() {
        let x = true;
        // This And expression is correctly NOT eliminated
        // because And => false in is_ok_to_remove_from_code()
        x && abort 43;
        
        // We should never reach here
        assert!(false, 100);
    }
}
```

**Test procedure:**
1. Compile with `MVC_EXP=optimize-extra=false`: `test_or_elimination()` aborts with code 42
2. Compile with `MVC_EXP=optimize-extra=true`: `test_or_elimination()` succeeds (bug!)
3. Both settings: `test_and_not_eliminated()` aborts with code 43 (consistent)

The inconsistency proves the vulnerability: identical source code produces different execution results based on compiler flags, violating deterministic execution.

### Citations

**File:** third_party/move/move-model/src/ast.rs (L2860-2965)
```rust
    pub fn is_ok_to_remove_from_code(&self) -> bool {
        use Operation::*;
        match self {
            MoveFunction(..) => false,       // could abort
            SpecFunction(..) => false,       // Spec
            Pack(..) | Closure(..) => false, // Could yield an undroppable value
            Tuple => true,
            Select(..) => false,         // Move-related
            SelectVariants(..) => false, // Move-related
            UpdateField(..) => false,    // Move-related

            // Specification specific
            Result(..) => false,   // Spec
            Index => false,        // Spec
            Slice => false,        // Spec
            Range => false,        // Spec
            Implies => false,      // Spec
            Iff => false,          // Spec
            Identical => false,    // Spec
            Behavior(..) => false, // Spec

            // Binary operators
            Add => false, // can overflow
            Sub => false, // can overflow
            Mul => false, // can overflow
            Mod => false, // can overflow
            Div => false, // can overflow
            BitOr => true,
            BitAnd => true,
            Xor => true,
            Shl => false, // can overflow
            Shr => false, // can overflow
            And => false, // can overflow
            Or => true,
            Eq => true,
            Neq => true,
            Lt => true,
            Gt => true,
            Le => true,
            Ge => true,

            // Copy and Move
            Copy => false, // Could yield an undroppable value
            Move => false, // Move-related

            // Unary operators
            Not => true,
            Cast => false,   // can overflow
            Negate => false, // can overflow

            // Builtin functions (impl and spec)
            Exists(..) => false, // Spec

            // Builtin functions (impl only)
            BorrowGlobal(..) => false, // Move-related
            Borrow(..) => false,       // Move-related
            Deref => false,            // Move-related
            MoveTo => false,           // Move-related
            MoveFrom => false,         // Move-related
            Freeze(_) => false,        // Move-related
            Abort(_) => false,         // Move-related
            Vector => false,           // Move-related

            // Builtin functions (spec only)
            Len => false,            // Spec
            TypeValue => false,      // Spec
            TypeDomain => false,     // Spec
            ResourceDomain => false, // Spec
            Global(..) => false,     // Spec
            CanModify => false,      // Spec
            Old => false,            // Spec
            Trace(..) => false,      // Spec

            EmptyVec => false,     // Spec
            SingleVec => false,    // Spec
            UpdateVec => false,    // Spec
            ConcatVec => false,    // Spec
            IndexOfVec => false,   // Spec
            ContainsVec => false,  // Spec
            InRangeRange => false, // Spec
            InRangeVec => false,   // Spec
            RangeVec => false,     // Spec
            MaxU8 => false,        // Spec
            MaxU16 => false,       // Spec
            MaxU32 => false,       // Spec
            MaxU64 => false,       // Spec
            MaxU128 => false,      // Spec
            MaxU256 => false,      // Spec
            Bv2Int => false,       // Spec
            Int2Bv => false,       // Spec

            // Functions which support the transformation and translation process.
            AbortFlag => false,            // Spec
            AbortCode => false,            // Spec
            WellFormed => false,           // Spec
            BoxValue => false,             // Spec
            UnboxValue => false,           // Spec
            EmptyEventStore => false,      // Spec
            ExtendEventStore => false,     // Spec
            EventStoreIncludes => false,   // Spec
            EventStoreIncludedIn => false, // Spec

            // Operation with no effect
            TestVariants(..) => true, // Cannot abort
            NoOp => true,
        }
```

**File:** third_party/move/move-compiler-v2/src/bytecode_generator.rs (L991-992)
```rust
            Operation::And => self.gen_logical_shortcut(true, targets, id, args),
            Operation::Or => self.gen_logical_shortcut(false, targets, id, args),
```

**File:** third_party/move/move-compiler-v2/src/bytecode_generator.rs (L1227-1260)
```rust
    fn gen_logical_shortcut(
        &mut self,
        is_and: bool,
        targets: Vec<TempIndex>,
        id: NodeId,
        args: &[Exp],
    ) {
        let target = self.require_unary_target(id, targets);
        let arg1 = self.gen_escape_auto_ref_arg(&args[0], false);
        let true_label = self.new_label(id);
        let false_label = self.new_label(id);
        let done_label = self.new_label(id);
        self.emit_with(id, |attr| {
            Bytecode::Branch(attr, true_label, false_label, arg1)
        });
        self.emit_with(id, |attr| Bytecode::Label(attr, true_label));
        if is_and {
            self.generate(vec![target], &args[1]);
        } else {
            self.emit_with(id, |attr| {
                Bytecode::Load(attr, target, Constant::Bool(true))
            })
        }
        self.emit_with(id, |attr| Bytecode::Jump(attr, done_label));
        self.emit_with(id, |attr| Bytecode::Label(attr, false_label));
        if is_and {
            self.emit_with(id, |attr| {
                Bytecode::Load(attr, target, Constant::Bool(false))
            })
        } else {
            self.generate(vec![target], &args[1]);
        }
        self.emit_with(id, |attr| Bytecode::Label(attr, done_label));
    }
```

**File:** third_party/move/move-compiler-v2/src/env_pipeline/ast_simplifier.rs (L1147-1180)
```rust
    fn rewrite_sequence(&mut self, id: NodeId, seq: &[Exp]) -> Option<Exp> {
        if self.eliminate_code && seq.len() > 1 {
            // Check which elements are side-effect-free
            let mut siter = seq.iter();
            let last_expr_opt = siter.next_back(); // first remove last element from siter
            let side_effecting_elts_refs = siter
                .filter(|exp|
                        if exp.as_ref().is_ok_to_remove_from_code() {
                            let loc = self.env().get_node_loc(exp.node_id());
                            if !self.after_inlining_optimization && !loc.is_inlined() {
                                self.env().diag(
                                    Severity::Warning,
                                    &loc,
                                    "Expression value unused and side-effect free, so eliminated as dead code"
                                );
                            }
                            false
                        } else {
                            true
                        })
                .collect_vec();
            if side_effecting_elts_refs.len() + 1 < seq.len() {
                // We can remove some exprs; clone just the others.
                let new_vec = side_effecting_elts_refs
                    .into_iter()
                    .chain(last_expr_opt)
                    .cloned()
                    .collect_vec();
                if new_vec.len() == 1 {
                    // Unwrap a lone sequence item.
                    new_vec.first().cloned()
                } else {
                    Some(ExpData::Sequence(id, new_vec).into_exp())
                }
```

**File:** third_party/move/move-compiler-v2/src/experiments.rs (L225-229)
```rust
        Experiment {
            name: Experiment::AST_SIMPLIFY_FULL.to_string(),
            description: "Whether to run the ast simplifier, including code elimination"
                .to_string(),
            default: Inherited(Experiment::OPTIMIZE_EXTRA.to_string()),
```

**File:** third_party/move/move-compiler-v2/src/lib.rs (L485-489)
```rust
    if options.experiment_on(Experiment::AST_SIMPLIFY_FULL) {
        env_pipeline.add("simplifier with code elimination", {
            move |env: &mut GlobalEnv| {
                ast_simplifier::run_simplifier(env, true, do_inlining_optimization)
            }
```
