# Audit Report

## Title
Governance Bypass: Individual Node Operators Can Unilaterally Disable Critical Security Policies via skip_config_sanitizer

## Summary
The `skip_config_sanitizer` configuration flag allows individual validator operators to bypass all security policy validations by setting it to `true` in their local YAML configuration file. This enables validators to run with insecure settings that are prohibited on mainnet (such as disabled VM paranoid verifications, in-memory consensus key storage, and disabled mutual authentication), potentially causing consensus divergence and violating network-wide security policies that should be governed collectively.

## Finding Description

The configuration sanitization system enforces critical security policies for mainnet validators. However, the `skip_config_sanitizer` flag in `NodeStartupConfig` allows complete bypass of these checks. [1](#0-0) 

When a node operator sets this flag to `true`, the sanitization process returns early without performing any validation: [2](#0-1) 

This bypasses enforcement of multiple critical security requirements:

**1. Execution VM Paranoid Verifications (Consensus Safety)**

Mainnet validators are required to enable paranoid type verification and hot potato verification, which perform runtime checks that ensure Move bytecode executes correctly: [3](#0-2) 

**2. Consensus Key Storage (Validator Security)**

Mainnet validators cannot use in-memory storage for consensus keys and must use persistent secure backends: [4](#0-3) 

**3. Validator Network Mutual Authentication**

Mutual authentication must be enabled on validator networks: [5](#0-4) 

**Attack Path:**

1. A validator operator edits their `validator.yaml` configuration file
2. Adds: `node_startup: { skip_config_sanitizer: true }`
3. Disables security settings: `execution: { paranoid_type_verification: false, paranoid_hot_potato_verification: false }`
4. Restarts their validator node using `NodeConfig::load_from_path()`: [6](#0-5) 

5. The sanitizer check is bypassed and the node starts with insecure configuration

**Invariant Violation:**

This breaks the **Deterministic Execution** invariant. If one validator runs with `paranoid_type_verification: false` while others run with it enabled, they may execute Move bytecode differently when edge cases or bugs are encountered. The paranoid type checks perform runtime validation that can cause transactions to abort. If validators have different checking modes, they will produce different execution results for the same block, leading to different state roots and consensus failure.

## Impact Explanation

This vulnerability qualifies as **HIGH severity** under the Aptos bug bounty program for "Significant protocol violations":

1. **Consensus Safety Risk**: Different VM verification settings across validators can cause consensus divergence when executing blocks containing Move bytecode with edge cases that the paranoid checks would catch. This violates the fundamental requirement that all validators must produce identical state roots for identical blocks.

2. **Governance Bypass**: Security policies intended to be enforced network-wide can be unilaterally bypassed by individual operators without on-chain governance approval. This undermines the governance integrity of the network.

3. **Validator Compromise**: Using in-memory storage for consensus keys violates security best practices and makes validators vulnerable to key loss on restart or memory-based attacks.

4. **Network Security**: Disabling mutual authentication on the validator network opens attack vectors for man-in-the-middle attacks and unauthorized connections.

## Likelihood Explanation

**Likelihood: Medium to High**

- **Ease of Exploitation**: Trivial - only requires editing a YAML file and restarting the node
- **Attacker Requirements**: Requires being a validator operator or compromising a validator's configuration
- **Detection Difficulty**: No network-level mechanism exists to detect when validators run with sanitization disabled
- **Motivation**: Operators might disable sanitization for perceived convenience, performance, or during troubleshooting, unaware of the consensus implications

The test case explicitly demonstrates this capability: [7](#0-6) 

## Recommendation

**Option 1: Remove the skip_config_sanitizer Flag (Recommended)**

Remove the ability to bypass sanitization in production environments. The flag can be conditionally compiled only for test builds.

```rust
impl ConfigSanitizer for NodeConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        // Only allow skipping sanitization in test builds
        #[cfg(not(test))]
        if node_config.node_startup.skip_config_sanitizer {
            return Err(Error::ConfigSanitizerFailed(
                "NodeConfig".to_string(),
                "skip_config_sanitizer cannot be used in production builds".to_string(),
            ));
        }
        
        #[cfg(test)]
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }

        // Continue with normal sanitization...
```

**Option 2: On-Chain Governance Control**

If the flag must exist, make it controllable via on-chain governance by checking an on-chain config resource before allowing sanitization bypass. This would require all validators to agree via governance before security policies can be modified.

**Option 3: Network-Wide Enforcement**

Add consensus-level checks that verify all validators are running with compatible security settings. Validators running with different VM verification modes should be detected and excluded from consensus participation.

## Proof of Concept

**Step 1**: Create a mainnet validator configuration with sanitization bypass

```yaml
# validator.yaml
base:
  role: "validator"
  
node_startup:
  skip_config_sanitizer: true  # BYPASS ALL SECURITY CHECKS
  
execution:
  paranoid_type_verification: false      # DISABLED (should be required on mainnet)
  paranoid_hot_potato_verification: false # DISABLED (should be required on mainnet)
  
consensus:
  safety_rules:
    backend: InMemoryStorage  # INSECURE (should be persistent on mainnet)
```

**Step 2**: Load and verify the configuration is accepted

```rust
use aptos_config::config::{NodeConfig, NodeConfigLoader};
use aptos_types::chain_id::ChainId;

// This would normally fail sanitization for mainnet, but succeeds with skip_config_sanitizer
let config_path = "validator.yaml";
let node_config = NodeConfig::load_from_path(config_path).unwrap();

// Verify insecure settings were accepted
assert!(node_config.node_startup.skip_config_sanitizer);
assert!(!node_config.execution.paranoid_type_verification); // Security check bypassed!
assert!(!node_config.execution.paranoid_hot_potato_verification); // Security check bypassed!

println!("Successfully loaded mainnet validator config with disabled security checks!");
```

**Step 3**: Demonstrate consensus divergence scenario

When a validator with disabled paranoid checks encounters Move bytecode with a type violation, it will execute differently than validators with checks enabled, producing different state roots and breaking consensus.

## Notes

This vulnerability represents a fundamental architectural issue where local configuration can override network-wide security policies. The `skip_config_sanitizer` flag appears to be designed for testing convenience but creates a production security risk when individual operators can unilaterally disable consensus-critical safety checks. The proper solution is to either remove this capability from production builds or place it under collective governance control to maintain network-wide security policy coherence.

### Citations

**File:** config/src/config/node_startup_config.rs (L6-11)
```rust
#[derive(Clone, Copy, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct NodeStartupConfig {
    pub skip_config_optimizer: bool, // Whether or not to skip the config optimizer at startup
    pub skip_config_sanitizer: bool, // Whether or not to skip the config sanitizer at startup
}
```

**File:** config/src/config/config_sanitizer.rs (L45-48)
```rust
        // If config sanitization is disabled, don't do anything!
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }
```

**File:** config/src/config/config_sanitizer.rs (L191-197)
```rust
        // Ensure that mutual authentication is enabled
        if !validator_network_config.mutual_authentication {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Mutual authentication must be enabled for the validator network!".into(),
            ));
        }
```

**File:** config/src/config/config_sanitizer.rs (L212-239)
```rust
    fn test_disable_config_sanitizer() {
        // Create a default node config (with sanitization enabled)
        let mut node_config = NodeConfig::default();

        // Set a bad node config for mainnet
        node_config.execution.paranoid_hot_potato_verification = false;

        // Sanitize the config and verify the sanitizer fails
        let error =
            NodeConfig::sanitize(&node_config, NodeType::Validator, Some(ChainId::mainnet()))
                .unwrap_err();
        assert!(matches!(error, Error::ConfigSanitizerFailed(_, _)));

        // Create a node config with the sanitizer disabled
        let mut node_config = NodeConfig {
            node_startup: NodeStartupConfig {
                skip_config_sanitizer: true,
                ..Default::default()
            },
            ..Default::default()
        };

        // Set a bad node config for mainnet
        node_config.execution.paranoid_hot_potato_verification = false;

        // Sanitize the config and verify the sanitizer passes
        NodeConfig::sanitize(&node_config, NodeType::Validator, Some(ChainId::mainnet())).unwrap();
    }
```

**File:** config/src/config/execution_config.rs (L166-183)
```rust
        // If this is a mainnet node, ensure that additional verifiers are enabled
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() {
                if !execution_config.paranoid_hot_potato_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_hot_potato_verification must be enabled for mainnet nodes!"
                            .into(),
                    ));
                }
                if !execution_config.paranoid_type_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_type_verification must be enabled for mainnet nodes!".into(),
                    ));
                }
            }
        }
```

**File:** config/src/config/safety_rules_config.rs (L85-96)
```rust
        if let Some(chain_id) = chain_id {
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }
```

**File:** config/src/config/node_config.rs (L140-143)
```rust
    pub fn load_from_path<P: AsRef<Path>>(input_path: P) -> Result<Self, Error> {
        let node_config_loader = NodeConfigLoader::new(input_path);
        node_config_loader.load_and_sanitize_config()
    }
```
