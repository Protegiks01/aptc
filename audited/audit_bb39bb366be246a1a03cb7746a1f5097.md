# Audit Report

## Title
Directory Traversal in ValidateProposals Command Allows Unauthorized Access to Production Validator Private Keys

## Summary
The `ValidateProposals` command in `aptos-release-builder` accepts a `test_dir` parameter without path sanitization, allowing directory traversal attacks via relative path sequences (`../../`). This enables reading sensitive validator private keys from arbitrary filesystem locations, breaking the security boundary between test and production environments.

## Finding Description

The vulnerability exists in the `NetworkConfig::new_from_dir` function which directly uses the user-supplied `test_dir` parameter to construct file paths without any validation or canonicalization: [1](#0-0) 

The `test_dir` parameter is defined in the CLI command structure as a `PathBuf` without constraints: [2](#0-1) 

And is passed directly to `new_from_dir` in the command handler: [3](#0-2) 

**Attack Path:**

1. Attacker provides a malicious `test_dir` parameter with directory traversal sequences: `--test-dir ../../../../../../home/validator/.aptos/mainnet`

2. The function uses `PathBuf::join()` which does NOT prevent directory traversal - it simply concatenates paths:
   - `root_key_path` becomes `../../../../../../home/validator/.aptos/mainnet/mint.key`
   - `private_identity_file` becomes `../../../../../../home/validator/.aptos/mainnet/0/private-identity.yaml`

3. `fs::read()` reads these files without validation, exposing the `PrivateIdentity` structure containing: [4](#0-3) 

4. These production keys are then stored in `NetworkConfig` and used throughout the validation process: [5](#0-4) 

5. The keys are used to sign governance proposals, votes, and executions. Critically, while minting operations have mainnet/testnet protection: [6](#0-5) 

**No such protection exists for proposal submission, voting, or execution operations**, allowing production keys to be used on any endpoint.

## Impact Explanation

**CRITICAL Severity** - This vulnerability falls under multiple critical impact categories:

1. **Cryptographic Key Compromise**: Exposes validator consensus private keys (BLS12381), account private keys (Ed25519), and network private keys (x25519) to unauthorized access.

2. **Governance Integrity Violation**: An attacker can use compromised validator keys to:
   - Submit unauthorized governance proposals
   - Vote on proposals with the validator's voting power
   - Execute malicious governance scripts
   - Potentially manipulate on-chain funds through proposal execution

3. **Consensus Safety Risk**: Compromise of consensus private keys could enable:
   - Unauthorized block signing
   - Potential equivocation attacks
   - Validator impersonation

This directly violates the **Access Control** and **Cryptographic Correctness** critical invariants defined in the Aptos security model.

## Likelihood Explanation

**MEDIUM-HIGH** likelihood in the following scenarios:

1. **Automated Systems**: If the tool is integrated into CI/CD pipelines, testing frameworks, or automated deployment scripts that accept external input for `test_dir`

2. **Supply Chain Attacks**: Malicious modification of deployment scripts or documentation examples to include traversal paths

3. **Developer Error**: Developers running commands from untrusted sources or documentation without realizing the security implications

4. **Insider Threat**: Malicious insider with CLI access but not direct filesystem access to production key directories

The tool is designed for development/testing but lacks safeguards to prevent its misuse against production environments.

## Recommendation

Implement strict path validation and canonicalization in the `new_from_dir` function:

```rust
pub fn new_from_dir(endpoint: Url, test_dir: &Path) -> Result<Self> {
    // Canonicalize the path to resolve any symbolic links and relative components
    let canonical_test_dir = test_dir.canonicalize()
        .context("Failed to canonicalize test directory path")?;
    
    // Verify the path doesn't contain suspicious components
    if test_dir.components().any(|c| matches!(c, std::path::Component::ParentDir)) {
        bail!("test_dir parameter cannot contain parent directory references (..)");
    }
    
    // Ensure we're working with an absolute path
    if !canonical_test_dir.is_absolute() {
        bail!("test_dir must be an absolute path");
    }
    
    let root_key_path = canonical_test_dir.join("mint.key");
    let private_identity_file = canonical_test_dir.join("0/private-identity.yaml");
    
    // Verify files exist before reading
    if !root_key_path.exists() || !private_identity_file.exists() {
        bail!("Required key files not found in test directory");
    }
    
    let private_identity =
        serde_yaml::from_slice::<PrivateIdentity>(&fs::read(private_identity_file)?)?;

    Ok(Self {
        endpoint,
        root_key_path,
        validator_account: private_identity.account_address,
        validator_key: private_identity.account_private_key,
        framework_git_rev: None,
    })
}
```

Additionally, add a mainnet/testnet protection check similar to the mint operation to prevent use of this tool against production networks.

## Proof of Concept

```bash
#!/bin/bash
# PoC: Directory Traversal in aptos-release-builder

# Setup: Create a fake production validator directory structure
mkdir -p /tmp/fake-production-validator/0
echo "fake_root_key_data" > /tmp/fake-production-validator/mint.key

# Create a fake private-identity.yaml with sample keys
cat > /tmp/fake-production-validator/0/private-identity.yaml <<EOF
account_address: "0x1234567890abcdef"
account_private_key: "0x0000000000000000000000000000000000000000000000000000000000000001"
consensus_private_key: "0x0000000000000000000000000000000000000000000000000000000000000002"
full_node_network_private_key: "0x0000000000000000000000000000000000000000000000000000000000000003"
validator_network_private_key: "0x0000000000000000000000000000000000000000000000000000000000000004"
EOF

# Create a test directory at a different location
mkdir -p /tmp/test-workspace

# Exploit: Use directory traversal to read production keys
# From /tmp/test-workspace, traverse to /tmp/fake-production-validator
cd /tmp/test-workspace

# The vulnerable command would be:
# aptos-release-builder validate-proposals \
#   --test-dir ../../fake-production-validator \
#   --release-config malicious.yaml \
#   --endpoint http://attacker-endpoint.com \
#   from-directory

# Verification: Show that PathBuf::join allows traversal
cat > verify_traversal.rs <<'EOF'
use std::path::PathBuf;

fn main() {
    let base = PathBuf::from("/tmp/test-workspace");
    let traversal = base.join("../../fake-production-validator/mint.key");
    println!("Traversal path: {:?}", traversal);
    // This will print: "/tmp/test-workspace/../../fake-production-validator/mint.key"
    // Which the OS resolves to: "/tmp/fake-production-validator/mint.key"
}
EOF

echo "Vulnerability demonstrated: PathBuf::join() does not prevent directory traversal"
echo "Production validator keys would be loaded and used to sign governance operations"
```

**Notes**

This vulnerability represents a critical failure in the security boundary between development/testing tools and production environments. While the `aptos-release-builder` is designed for testing governance proposals on local testnets, the lack of input validation allows it to be weaponized against production validator key directories. The exposure of validator consensus private keys could have cascading effects on blockchain consensus safety, governance integrity, and fund security. This issue should be addressed immediately with both input sanitization and runtime environment validation to ensure the tool cannot be used against production networks.

### Citations

**File:** aptos-move/aptos-release-builder/src/validate.rs (L38-51)
```rust
    pub fn new_from_dir(endpoint: Url, test_dir: &Path) -> Result<Self> {
        let root_key_path = test_dir.join("mint.key");
        let private_identity_file = test_dir.join("0/private-identity.yaml");
        let private_identity =
            serde_yaml::from_slice::<PrivateIdentity>(&fs::read(private_identity_file)?)?;

        Ok(Self {
            endpoint,
            root_key_path,
            validator_account: private_identity.account_address,
            validator_key: private_identity.account_private_key,
            framework_git_rev: None,
        })
    }
```

**File:** aptos-move/aptos-release-builder/src/main.rs (L201-205)
```rust
    FromDirectory {
        /// Path to the localnet folder. If you are running localnet via cli, it should be `.aptos/testnet`.
        #[clap(short, long)]
        test_dir: PathBuf,
    },
```

**File:** aptos-move/aptos-release-builder/src/main.rs (L287-293)
```rust
            let mut network_config = match input_option {
                InputOptions::FromDirectory { test_dir } => {
                    aptos_release_builder::validate::NetworkConfig::new_from_dir(
                        endpoint.clone(),
                        test_dir.as_path(),
                    )?
                },
```

**File:** aptos-move/aptos-release-builder/src/main.rs (L332-334)
```rust
                if chain_id == ChainId::mainnet().id() || chain_id == ChainId::testnet().id() {
                    panic!("Mint to mainnet/testnet is not allowed");
                }
```

**File:** crates/aptos-genesis/src/keys.rs (L14-22)
```rust
/// Type for serializing private keys file
#[derive(Deserialize, Serialize)]
pub struct PrivateIdentity {
    pub account_address: AccountAddress,
    pub account_private_key: Ed25519PrivateKey,
    pub consensus_private_key: bls12381::PrivateKey,
    pub full_node_network_private_key: x25519::PrivateKey,
    pub validator_network_private_key: x25519::PrivateKey,
}
```
