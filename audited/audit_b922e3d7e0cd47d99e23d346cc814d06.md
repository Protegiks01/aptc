# Audit Report

## Title
Indexer Fails to Clean Up Event Handle References After CoinStore and FungibleStore Deletions Leading to State Inconsistency

## Summary
The indexer does not process `CoinStoreDeletion` and `FungibleStoreDeletion` events to remove stale event handle entries from `EventByKeySchema` and `EventByVersionSchema`. When CoinStores are deleted during migration to fungible assets, or when FungibleStores are removed, the indexer retains references to destroyed event handles, creating dangling references and potential memory leaks. While test transaction files containing these deletion events exist, no tests verify proper indexer state cleanup. [1](#0-0) 

## Finding Description
When a CoinStore is deleted (typically during migration from legacy Coin to FungibleAsset), the Move framework emits a `CoinStoreDeletion` event containing information about the deleted event handles: [2](#0-1) 

Similarly, when a FungibleStore is deleted, the framework emits a `FungibleStoreDeletion` event: [3](#0-2) 

The on-chain deletion properly destroys the event handles: [4](#0-3) 

However, the indexer in `db_indexer.rs` processes events and adds them to `EventByKeySchema` and `EventByVersionSchema` but never removes entries when deletion events occur: [5](#0-4) 

The indexer has NO code that handles `CoinStoreDeletion` or `FungibleStoreDeletion` events. The only cleanup mechanism is version-based pruning, not event-handle-specific cleanup: [6](#0-5) 

This creates a state inconsistency where the indexer maintains references to event handles that have been destroyed on-chain. When clients query these event keys, the indexer returns stale data from before the deletion.

## Impact Explanation
This issue qualifies as **Medium severity** per the Aptos bug bounty criteria: "State inconsistencies requiring intervention." The indexer is a critical component for querying blockchain state, and maintaining incorrect references to deleted event handles violates the invariant that secondary indices should accurately reflect on-chain state.

**Specific impacts:**
1. **Dangling References**: The indexer contains `EventByKeySchema` entries pointing to event handles that no longer exist on-chain
2. **Memory Leaks**: As CoinStores are migrated to FungibleAssets (a common operation), stale event handle references accumulate without cleanup
3. **Incorrect Query Results**: Clients querying deleted event handles receive events from before deletion, not realizing the handle has been destroyed
4. **Test Coverage Gap**: Test transactions exist but no tests verify the cleanup behavior

## Likelihood Explanation
This issue occurs **frequently** in production:
- CoinStore-to-FungibleAsset migration is a standard operation as the ecosystem transitions to the new asset model
- The test transaction file shows this happened on mainnet at version 2448304257
- Every CoinStore deletion creates 2 dangling event handle references (deposit_events and withdraw_events)
- FungibleStore deletions add additional dangling references

The issue is **currently happening** on mainnet but goes undetected because:
- The indexer silently maintains stale references
- No monitoring alerts for event handle inconsistencies
- No tests validate this cleanup path

## Recommendation
Implement event-handle-specific cleanup in the indexer when processing deletion events:

```rust
// In db_indexer.rs, around line 432-487, add:
if self.indexer_db.event_enabled() {
    events.iter().enumerate().try_for_each(|(idx, event)| {
        // Existing V1 event indexing code...
        
        // NEW: Handle deletion events
        if let ContractEvent::V2(v2) = event {
            if v2.type_tag().to_string() == "0x1::coin::CoinStoreDeletion" {
                // Parse deletion event data to extract:
                // - event_handle_creation_address
                // - deleted_deposit_event_handle_creation_number
                // - deleted_withdraw_event_handle_creation_number
                // Then delete EventByKeySchema entries for these handles
                self.cleanup_deleted_event_handles(v2, &mut batch)?;
            } else if v2.type_tag().to_string() == "0x1::fungible_asset::FungibleStoreDeletion" {
                // Similar cleanup for FungibleAsset deletion
                self.cleanup_fungible_store_event_handles(v2, &mut batch)?;
            }
        }
        Ok::<(), AptosDbError>(())
    })?;
}
```

Additionally, add tests that:
1. Process the existing test transactions containing deletion events
2. Verify that `EventByKeySchema` entries for deleted handles are removed
3. Confirm queries for deleted event handles return appropriate errors or empty results

## Proof of Concept
```rust
#[test]
fn test_coinstore_deletion_cleans_up_indexer_state() {
    // 1. Parse test transaction 2448304257_coinstore_deletion_event.json
    let test_txn = include_bytes!("../indexer-test-transactions/.../2448304257_coinstore_deletion_event.json");
    
    // 2. Process transaction through indexer
    let (aptos_db, indexer_db) = create_test_db();
    let db_indexer = DBIndexer::new(indexer_db.clone(), aptos_db);
    db_indexer.process_transaction(test_txn);
    
    // 3. Extract deleted event handle info from CoinStoreDeletion event
    let deletion_event = find_event_by_type(test_txn, "0x1::coin::CoinStoreDeletion");
    let address = deletion_event.event_handle_creation_address; // 0xf8e25f6c...
    let deposit_num = deletion_event.deleted_deposit_event_handle_creation_number; // 2
    let withdraw_num = deletion_event.deleted_withdraw_event_handle_creation_number; // 3
    
    // 4. Construct EventKeys for deleted handles
    let deposit_key = EventKey::new(deposit_num, address);
    let withdraw_key = EventKey::new(withdraw_num, address);
    
    // 5. Verify indexer has NO entries for these deleted event handles
    let deposit_events = indexer_db.lookup_events_by_key(&deposit_key, 0, 100, u64::MAX);
    let withdraw_events = indexer_db.lookup_events_by_key(&withdraw_key, 0, 100, u64::MAX);
    
    // EXPECTED: Empty results or error
    // ACTUAL: Returns stale events from before deletion (BUG)
    assert!(deposit_events.is_empty(), "Deleted event handle should have no indexed events");
    assert!(withdraw_events.is_empty(), "Deleted event handle should have no indexed events");
}
```

---

**Notes:**
This vulnerability represents a violation of the state consistency invariant for the indexer subsystem. While it doesn't directly compromise consensus or fund safety, it creates a divergence between the indexer's view and actual on-chain state. The test transaction files demonstrate that deletion events are being emitted on mainnet, but the indexer lacks the logic to properly clean up its internal state in response to these events. This is a production issue affecting data integrity in a critical query infrastructure component.

### Citations

**File:** ecosystem/indexer-grpc/indexer-test-transactions/src/json_transactions/generated_transactions.rs (L176-180)
```rust
pub const IMPORTED_MAINNET_TXNS_2448304257_COINSTORE_DELETION_EVENT: &[u8] =
    include_bytes!(concat!(
        env!("CARGO_MANIFEST_DIR"),
        "/src/json_transactions/imported_mainnet_txns/2448304257_coinstore_deletion_event.json"
    ));
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L230-237)
```text
    #[event]
    /// Module event emitted when the event handles related to coin store is deleted.
    struct CoinStoreDeletion has drop, store {
        coin_type: String,
        event_handle_creation_address: address,
        deleted_deposit_event_handle_creation_number: u64,
        deleted_withdraw_event_handle_creation_number: u64
    }
```

**File:** aptos-move/framework/aptos-framework/sources/fungible_asset.move (L253-259)
```text
    #[event]
    /// Module event emitted when a fungible store is deleted.
    struct FungibleStoreDeletion has drop, store {
        store: address,
        owner: address,
        metadata: address
    }
```

**File:** aptos-move/framework/aptos-framework/sources/fungible_asset.move (L921-936)
```text
        // Cleanup deprecated event handles if exist.
        if (exists<FungibleAssetEvents>(addr)) {
            let FungibleAssetEvents { deposit_events, withdraw_events, frozen_events } =
                move_from<FungibleAssetEvents>(addr);
            event::destroy_handle(deposit_events);
            event::destroy_handle(withdraw_events);
            event::destroy_handle(frozen_events);
        };
        event::emit(
            FungibleStoreDeletion {
                store: addr,
                owner: store.owner(),
                metadata: metadata.object_address()
            }
        );
    }
```

**File:** storage/indexer/src/db_indexer.rs (L432-487)
```rust
            if self.indexer_db.event_enabled() {
                events.iter().enumerate().try_for_each(|(idx, event)| {
                    if let ContractEvent::V1(v1) = event {
                        batch
                            .put::<EventByKeySchema>(
                                &(*v1.key(), v1.sequence_number()),
                                &(version, idx as u64),
                            )
                            .expect("Failed to put events by key to a batch");
                        batch
                            .put::<EventByVersionSchema>(
                                &(*v1.key(), version, v1.sequence_number()),
                                &(idx as u64),
                            )
                            .expect("Failed to put events by version to a batch");
                    }
                    if self.indexer_db.event_v2_translation_enabled() {
                        if let ContractEvent::V2(v2) = event {
                            if let Some(translated_v1_event) =
                                self.translate_event_v2_to_v1(v2).map_err(|e| {
                                    anyhow::anyhow!(
                                        "Failed to translate event: {:?}. Error: {}",
                                        v2,
                                        e
                                    )
                                })?
                            {
                                let key = *translated_v1_event.key();
                                let sequence_number = translated_v1_event.sequence_number();
                                self.event_v2_translation_engine
                                    .cache_sequence_number(&key, sequence_number);
                                event_keys.insert(key);
                                batch
                                    .put::<EventByKeySchema>(
                                        &(key, sequence_number),
                                        &(version, idx as u64),
                                    )
                                    .expect("Failed to put events by key to a batch");
                                batch
                                    .put::<EventByVersionSchema>(
                                        &(key, version, sequence_number),
                                        &(idx as u64),
                                    )
                                    .expect("Failed to put events by version to a batch");
                                batch
                                    .put::<TranslatedV1EventSchema>(
                                        &(version, idx as u64),
                                        &translated_v1_event,
                                    )
                                    .expect("Failed to put translated v1 events to a batch");
                            }
                        }
                    }
                    Ok::<(), AptosDbError>(())
                })?;
            }
```

**File:** storage/aptosdb/src/ledger_db/event_db.rs (L192-222)
```rust
    pub(crate) fn prune_event_indices(
        &self,
        start: Version,
        end: Version,
        mut indices_batch: Option<&mut SchemaBatch>,
    ) -> Result<Vec<usize>> {
        let mut ret = Vec::new();

        let mut current_version = start;

        for events in self.get_events_by_version_iter(start, (end - start) as usize)? {
            let events = events?;
            ret.push(events.len());

            if let Some(ref mut batch) = indices_batch {
                for event in events {
                    if let ContractEvent::V1(v1) = event {
                        batch.delete::<EventByKeySchema>(&(*v1.key(), v1.sequence_number()))?;
                        batch.delete::<EventByVersionSchema>(&(
                            *v1.key(),
                            current_version,
                            v1.sequence_number(),
                        ))?;
                    }
                }
            }
            current_version += 1;
        }

        Ok(ret)
    }
```
