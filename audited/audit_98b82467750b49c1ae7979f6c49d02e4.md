# Audit Report

## Title
Consensus Safety Violation: Execution Config Desynchronization Causes Deterministic Execution Failure

## Summary
The `start_new_epoch()` function in the consensus epoch manager silently falls back to `OnChainExecutionConfig::default_if_missing()` when deserialization of the on-chain execution config fails. This creates a critical consensus vulnerability where validators with different execution configurations (specifically different transaction shufflers) will produce different state roots for identical blocks, violating the deterministic execution invariant and causing irrecoverable consensus splits.

## Finding Description

The vulnerability exists in the epoch initialization path where validators read on-chain execution configuration. When `start_new_epoch()` attempts to deserialize the execution config and fails, it only logs a warning without halting: [1](#0-0) 

Then silently falls back to a default configuration: [2](#0-1) 

The `default_if_missing()` method returns `OnChainExecutionConfig::Missing`: [3](#0-2) 

This `Missing` variant has fundamentally different execution parameters. Specifically, it uses `TransactionShufflerType::NoShuffling`: [4](#0-3) 

The execution config is used to create the transaction shuffler during epoch initialization: [5](#0-4) 

This shuffler is then stored in the execution proxy's mutable state: [6](#0-5) 

**The critical flaw**: When blocks are prepared for execution, the shuffler is applied to ALL transactions, not just newly proposed blocks: [7](#0-6) 

This happens in the pipeline for every block that is inserted into the block store: [8](#0-7) 

In Aptos, decoupled execution is always enabled, meaning validators vote on block ordering without execution state: [9](#0-8) 

**Attack Scenario**:

1. During epoch transition, Validator A successfully deserializes `OnChainExecutionConfig::V7` with `TransactionShufflerType::UseCaseAware`
2. Validator B fails to deserialize the config (due to database corruption or version incompatibility) and falls back to `OnChainExecutionConfig::Missing` with `TransactionShufflerType::NoShuffling`
3. Both validators agree on block ordering in consensus
4. When executing the same block:
   - Validator A applies UseCaseAware shuffling, reordering transactions via delayed queues based on sender and use case spread factors
   - Validator B applies NoShuffling, keeping original transaction order
5. Different transaction orders produce different execution results and state roots
6. Validators sign commit votes with different state roots
7. The safety rules detect inconsistent execution results: [10](#0-9) 

8. Commit votes cannot be aggregated because they have different ledger infos
9. **Consensus cannot progress** - permanent network partition occurs

The deserialization happens through `DbBackedOnChainConfig` which reads from local storage: [11](#0-10) 

## Impact Explanation

This is a **CRITICAL severity** vulnerability matching the Aptos bug bounty criteria for "Consensus/Safety Violations" and "Non-recoverable Network Partition":

**Consensus Safety Violation**: The vulnerability directly breaks the deterministic execution invariant that is fundamental to blockchain consensus. When validators execute identical blocks (same transactions, same order in the proposal) but apply different shuffling logic, they produce different execution results and state roots. This violates the core assumption that all honest validators will reach the same state given the same inputs.

**Non-recoverable Network Partition**: Once validators diverge on execution results, they sign different commit votes with incompatible state roots. The commit vote aggregation logic explicitly validates that all votes agree on the same ledger info (including state root). Without 2f+1 validators agreeing on the same execution result, no commit proof can be formed, and consensus cannot progress. This creates a permanent fork requiring manual intervention or a hardfork to resolve.

Unlike Byzantine fault scenarios that require ≥1/3 malicious validators, this bug can trigger with ANY number of validators experiencing deserialization failures, making it exceptionally dangerous. Even a single validator with a corrupted database or outdated code version will prevent consensus from progressing if it cannot form a supermajority with either the "correct" or "fallback" configuration groups.

## Likelihood Explanation

**MEDIUM-HIGH likelihood** due to multiple realistic trigger conditions:

1. **Database corruption**: Storage-level corruption from disk errors, power failures during writes, or filesystem issues can corrupt the serialized execution config bytes in one validator's database while others remain intact. This is a realistic scenario in distributed systems operating across diverse infrastructure.

2. **Version incompatibility**: If governance upgrades the on-chain execution config to a newer version (e.g., hypothetical V8) but some validators haven't upgraded their node software, those validators will fail to deserialize the new format. The BCS deserialization will fail when encountering an unknown enum variant, triggering the fallback behavior. This is a realistic deployment scenario during rolling upgrades.

3. **Double BCS deserialization complexity**: The execution config requires double deserialization (outer Vec<u8>, then inner config), increasing the surface area for deserialization failures due to malformed data at either layer.

The vulnerability requires no attacker action and can occur naturally during normal network operations. The silent fallback behavior (logging only a warning) means operators may not immediately detect the misconfiguration before consensus fails.

## Recommendation

The proper fix is to **fail-fast** when execution config deserialization fails during epoch initialization, rather than silently falling back to a different configuration:

```rust
let execution_config = onchain_execution_config
    .expect("Failed to deserialize on-chain execution config - validator cannot proceed with epoch initialization");
```

Alternatively, implement a validation mechanism that ensures all validators have successfully loaded the same execution config before allowing consensus to proceed. This could involve:

1. Including a hash of the execution config in the epoch change proof
2. Validators verifying they can deserialize and agree on the config hash before participating in the new epoch
3. Halting consensus participation if deserialization fails, rather than continuing with a fallback configuration

The `default_if_missing()` fallback should only be used for backward compatibility when replaying old blocks before execution config was introduced, not as a runtime error recovery mechanism.

## Proof of Concept

While a complete end-to-end PoC would require simulating database corruption or deploying multiple validator versions, the vulnerability mechanism can be demonstrated through the code flow:

1. Trigger condition: Simulate deserialization failure by corrupting on-chain config bytes or using incompatible version
2. Observe: Validator falls back to `OnChainExecutionConfig::Missing` with `NoShuffling`
3. Execute: Same block processed by validator with `UseCaseAware` vs `NoShuffling` shuffler
4. Result: Different transaction orders → different execution results → different state roots
5. Consensus failure: Commit votes with different state roots cannot be aggregated per safety rules validation

The core issue is architectural: the silent fallback behavior combined with decoupled execution creates a path where validators can diverge on execution configuration without immediate detection, leading to irrecoverable consensus splits when they attempt to commit blocks.

### Citations

**File:** consensus/src/epoch_manager.rs (L1191-1193)
```rust
        if let Err(error) = &onchain_execution_config {
            warn!("Failed to read on-chain execution config {}", error);
        }
```

**File:** consensus/src/epoch_manager.rs (L1202-1203)
```rust
        let execution_config = onchain_execution_config
            .unwrap_or_else(|_| OnChainExecutionConfig::default_if_missing());
```

**File:** types/src/on_chain_config/execution_config.rs (L29-31)
```rust
    pub fn transaction_shuffler_type(&self) -> TransactionShufflerType {
        match &self {
            OnChainExecutionConfig::Missing => TransactionShufflerType::NoShuffling,
```

**File:** types/src/on_chain_config/execution_config.rs (L137-139)
```rust
    pub fn default_if_missing() -> Self {
        OnChainExecutionConfig::Missing
    }
```

**File:** consensus/src/pipeline/execution_client.rs (L560-561)
```rust
        let transaction_shuffler =
            create_transaction_shuffler(onchain_execution_config.transaction_shuffler_type());
```

**File:** consensus/src/state_computer.rs (L247-254)
```rust
        *self.state.write() = Some(MutableState {
            validators: epoch_state
                .verifier
                .get_ordered_account_addresses_iter()
                .collect::<Vec<_>>()
                .into(),
            payload_manager,
            transaction_shuffler,
```

**File:** consensus/src/block_preparer.rs (L100-103)
```rust
            let mut shuffled_txns = {
                let _timer = TXN_SHUFFLE_SECONDS.start_timer();

                txn_shuffler.shuffle(deduped_txns)
```

**File:** consensus/src/block_storage/block_store.rs (L490-496)
```rust
            pipeline_builder.build_for_consensus(
                &pipelined_block,
                parent_block.pipeline_futs().ok_or_else(|| {
                    anyhow::anyhow!("Parent future doesn't exist, potentially epoch ended")
                })?,
                callback,
            );
```

**File:** types/src/on_chain_config/consensus_config.rs (L238-241)
```rust
    /// Decouple execution from consensus or not.
    pub fn decoupled_execution(&self) -> bool {
        true
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L395-402)
```rust
        if !old_ledger_info
            .commit_info()
            .match_ordered_only(new_ledger_info.commit_info())
        {
            return Err(Error::InconsistentExecutionResult(
                old_ledger_info.commit_info().to_string(),
                new_ledger_info.commit_info().to_string(),
            ));
```

**File:** state-sync/inter-component/event-notifications/src/lib.rs (L397-412)
```rust
impl OnChainConfigProvider for DbBackedOnChainConfig {
    fn get<T: OnChainConfig>(&self) -> Result<T> {
        let bytes = self
            .reader
            .get_state_value_by_version(&StateKey::on_chain_config::<T>()?, self.version)?
            .ok_or_else(|| {
                anyhow!(
                    "no config {} found in aptos root account state",
                    T::CONFIG_ID
                )
            })?
            .bytes()
            .clone();

        T::deserialize_into_config(&bytes)
    }
```
