# Audit Report

## Title
Missing WriteSet Cryptographic Validation During Backup Restore Enables State Corruption

## Summary
During backup restore operations, WriteSets are deserialized from backup data without cryptographic validation against `TransactionInfo.state_change_hash`. While Transactions and Events are verified using cryptographic hashes, WriteSets bypass this validation, allowing corrupted backup data to cause state divergence and consensus violations.

## Finding Description

The vulnerability exists in the backup restore flow where WriteSets are not validated cryptographically:

**1. WriteSets are deserialized from backup without validation:**

During backup restore, `LoadedChunk::load()` deserializes WriteSets from backup storage: [1](#0-0) 

**2. Verification only validates Transactions and Events, NOT WriteSets:**

The `TransactionListWithProofV2::verify()` call validates the backup data: [2](#0-1) 

However, `TransactionListWithAuxiliaryInfos::verify()` only validates transactions, transaction infos, events, and auxiliary infos - it does NOT validate WriteSets: [3](#0-2) 

**3. Contrast with proper WriteSet validation:**

The codebase has `TransactionOutputListWithProof::verify()` which DOES validate WriteSets by computing their hash and comparing against `state_change_hash`: [4](#0-3) 

This validation path is NOT used during backup restore.

**4. Unvalidated WriteSets are applied to state:**

In KV-only replay mode, unvalidated WriteSets are applied directly to the state tree: [5](#0-4) [6](#0-5) 

The `kv_replay=true` parameter causes WriteSets to be applied to state without re-execution: [7](#0-6) 

**5. NoVerify mode used in production:**

The restore coordinator explicitly uses `VerifyExecutionMode::NoVerify` for KV-only replay: [8](#0-7) 

This means no VM-based validation occurs for WriteSets.

**6. Acknowledgement of missing validation:**

A TODO comment explicitly acknowledges that structural validation was planned but never implemented: [9](#0-8) 

**Attack Scenario:**
1. Attacker gains access to backup storage or performs MITM during backup retrieval
2. Attacker modifies WriteSets in backup chunks while keeping TransactionInfos unchanged
3. During restore with KV-only replay, `TransactionListWithProofV2::verify()` passes because it only validates transactions and events
4. Malicious WriteSets are applied to state via `index_write_sets()` without validation
5. Node's state diverges from honest validators

## Impact Explanation

This vulnerability has **Critical Severity** impact:

**Consensus/Safety Violations:** Nodes restored from corrupted backups will have different state than honest validators. When processing the same blocks, they will produce different state roots, breaking consensus invariants and causing permanent network divergence.

**State Divergence:** The restored node's Jellyfish Merkle tree will have incorrect state values. All subsequent transaction execution will produce different results, as the VM reads corrupted state.

**Potential for Double-Spending:** Maliciously crafted WriteSets could modify account balances, coin supplies, or validator stakes, enabling various attacks including double-spending.

This meets the Critical severity criteria: "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**Medium to High Likelihood:**

- Backup infrastructure is a common attack surface, often with weaker security than primary systems
- Cloud storage misconfigurations (S3, GCS) are common
- The attack requires no validator collusion or majority stake
- KV-only replay with `NoVerify` mode is used in production restore paths
- Detection would be delayed until consensus divergence manifests
- No special timing or coordination required

The vulnerability is exploitable whenever a node performs backup restore using KV-only replay mode, which is a standard disaster recovery procedure.

## Recommendation

Add cryptographic validation of WriteSets during backup restore by computing their hash and comparing against `TransactionInfo.state_change_hash`, similar to how `TransactionOutputListWithProof::verify()` validates WriteSets:

```rust
// In TransactionListWithAuxiliaryInfos::verify()
// Add WriteSet validation
for (write_set, txn_info) in write_sets.iter().zip(transaction_infos.iter()) {
    let write_set_hash = CryptoHash::hash(write_set);
    ensure!(
        write_set_hash == txn_info.state_change_hash(),
        "WriteSet hash mismatch: computed {:?}, expected {:?}",
        write_set_hash,
        txn_info.state_change_hash()
    );
}
```

Alternatively, modify the backup restore flow to use `TransactionOutputListWithProof` instead of `TransactionListWithProof` to leverage existing WriteSet validation.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Creating a backup with legitimate data
2. Modifying a WriteSet in the backup to change a state value (e.g., account balance)
3. Restoring using KV-only replay mode with `--kv-only-replay=true`
4. Observing that the corrupted WriteSet is applied without validation
5. Verifying state divergence by comparing state roots with an honest node

The code paths shown above confirm that no validation occurs for WriteSets in this scenario, making the attack feasible.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L110-137)
```rust
        let mut write_sets = Vec::new();

        while let Some(record_bytes) = file.read_record_bytes().await? {
            let (txn, aux_info, txn_info, events, write_set): (
                _,
                PersistedAuxiliaryInfo,
                _,
                _,
                WriteSet,
            ) = match manifest.format {
                TransactionChunkFormat::V0 => {
                    let (txn, txn_info, events, write_set) = bcs::from_bytes(&record_bytes)?;
                    (
                        txn,
                        PersistedAuxiliaryInfo::None,
                        txn_info,
                        events,
                        write_set,
                    )
                },
                TransactionChunkFormat::V1 => bcs::from_bytes(&record_bytes)?,
            };
            txns.push(txn);
            persisted_aux_info.push(aux_info);
            txn_infos.push(txn_info);
            event_vecs.push(events);
            write_sets.push(write_set);
        }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L157-167)
```rust
        let txn_list_with_proof =
            TransactionListWithProofV2::new(TransactionListWithAuxiliaryInfos::new(
                TransactionListWithProof::new(
                    txns,
                    Some(event_vecs),
                    Some(manifest.first_version),
                    TransactionInfoListWithProof::new(range_proof, txn_infos),
                ),
                persisted_aux_info,
            ));
        txn_list_with_proof.verify(ledger_info.ledger_info(), Some(manifest.first_version))?;
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L593-600)
```rust
                        handler.save_transactions_and_replay_kv(
                            base_version,
                            &txns,
                            &persisted_aux_info,
                            &txn_infos,
                            &events,
                            write_sets,
                        )?;
```

**File:** types/src/transaction/mod.rs (L2487-2504)
```rust
    /// Verifies the transaction list with auxiliary infos using the given ledger
    /// info. This method verifies the inner transaction list first, before ensuring
    /// that the auxiliary infos are valid using the transaction infos in the proof.
    pub fn verify(
        &self,
        ledger_info: &LedgerInfo,
        first_transaction_version: Option<Version>,
    ) -> Result<()> {
        // Verify the inner transaction list with proof
        self.transaction_list_with_proof
            .verify(ledger_info, first_transaction_version)?;

        // Verify the auxiliary infos against the transaction infos
        verify_auxiliary_infos_against_transaction_infos(
            &self.persisted_auxiliary_infos,
            &self.transaction_list_with_proof.proof.transaction_infos,
        )
    }
```

**File:** types/src/transaction/mod.rs (L2573-2586)
```rust
        self.transactions_and_outputs.par_iter().zip_eq(self.proof.transaction_infos.par_iter())
        .map(|((txn, txn_output), txn_info)| {
            // Check the events against the expected events root hash
            verify_events_against_root_hash(&txn_output.events, txn_info)?;

            // Verify the write set matches for both the transaction info and output
            let write_set_hash = CryptoHash::hash(&txn_output.write_set);
            ensure!(
                txn_info.state_change_hash() == write_set_hash,
                "The write set in transaction output does not match the transaction info \
                     in proof. Hash of write set in transaction output: {}. Write set hash in txn_info: {}.",
                write_set_hash,
                txn_info.state_change_hash(),
            );
```

**File:** storage/aptosdb/src/backup/restore_handler.rs (L105-126)
```rust
    pub fn save_transactions_and_replay_kv(
        &self,
        first_version: Version,
        txns: &[Transaction],
        persisted_aux_info: &[PersistedAuxiliaryInfo],
        txn_infos: &[TransactionInfo],
        events: &[Vec<ContractEvent>],
        write_sets: Vec<WriteSet>,
    ) -> Result<()> {
        restore_utils::save_transactions(
            self.state_store.clone(),
            self.ledger_db.clone(),
            first_version,
            txns,
            persisted_aux_info,
            txn_infos,
            events,
            write_sets,
            None,
            true,
        )
    }
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L269-277)
```rust
    if kv_replay && first_version > 0 && state_store.get_usage(Some(first_version - 1)).is_ok() {
        let (ledger_state, _hot_state_updates) = state_store.calculate_state_and_put_updates(
            &StateUpdateRefs::index_write_sets(first_version, write_sets, write_sets.len(), vec![]),
            &mut ledger_db_batch.ledger_metadata_db_batches, // used for storing the storage usage
            state_kv_batches,
        )?;
        // n.b. ideally this is set after the batches are committed
        state_store.set_state_ignoring_summary(ledger_state);
    }
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L290-298)
```rust
                transaction_restore_opt,
                Arc::clone(&self.storage),
                txn_manifests,
                Some(db_next_version),
                Some((kv_replay_version, true /* only replay KV */)),
                epoch_history.clone(),
                VerifyExecutionMode::NoVerify,
                None,
            )
```

**File:** types/src/write_set.rs (L783-789)
```rust
    pub fn freeze(self) -> Result<WriteSet> {
        // TODO: add structural validation
        Ok(WriteSet {
            value: ValueWriteSet::V0(WriteSetV0(self)),
            hotness: BTreeMap::new(),
        })
    }
```
