# Audit Report

## Title
MintFunder Allows Unbounded Per-Request Amount When maximum_amount Is Not Configured

## Summary
The MintFunder implementation in the Aptos faucet service contains a code path that accepts arbitrary user-supplied amounts (up to u64::MAX) when the `maximum_amount` configuration parameter is not set. This allows attackers to bypass intended per-request limits and mint massive amounts of APT tokens in a single request, even when rate-limiting controls request frequency.

## Finding Description
The vulnerability exists in the `get_amount` method of MintFunder: [1](#0-0) 

When a user provides a custom amount in their funding request and the faucet is configured with `maximum_amount: None`, the code path at line 546 returns the user-provided amount without any cap. The official CLI implementation demonstrates this misconfiguration: [2](#0-1) 

**Attack Flow:**
1. Attacker sends a POST request to the faucet `/fund` or `/mint` endpoint with `amount=18446744073709551615` (u64::MAX, approximately 184 billion APT)
2. The request passes through the faucet's endpoint handler: [3](#0-2) 

3. The FundApiComponents calls the funder with the user-provided amount, which is not validated against any maximum
4. The MintFunder's `get_amount` returns the full user-provided amount when `maximum_amount` is None
5. The minting transaction is submitted to the blockchain: [4](#0-3) 

The only limit is the coin supply cap of MAX_U128, which is checked during minting: [5](#0-4) 

**Rate Limiting Bypass:**
The faucet's rate limiting mechanisms (IP-based or account-based) only control request frequency, not per-request amounts. An attacker can make a single request for u64::MAX and receive the full amount even with strict rate limits of 1 request per day.

## Impact Explanation
This qualifies as **Medium Severity** per the Aptos bug bounty criteria for the following reasons:

1. **Economic Disruption on Test Networks**: While the faucet is designed for devnet/testnet environments, massive supply inflation (minting 184 billion APT in a single request) can:
   - Disrupt the test network's economic model
   - Invalidate testing scenarios for developers
   - Cause state bloat and database performance issues
   - Accelerate approach to the MAX_U128 supply limit

2. **Bypasses Intended Controls**: Rate limiting is explicitly mentioned in the security question ("even if rate-limited"), confirming that per-request amount limits are expected to exist alongside frequency limits

3. **Configuration Vulnerability**: The default configuration in the official CLI implementation enables this vulnerability, making it likely to be deployed in production faucets

**Note**: This vulnerability does NOT affect mainnet as the faucet service and MintCapability are only available on devnet/testnet networks per the Move framework design: [6](#0-5) 

## Likelihood Explanation
**HIGH** - This vulnerability is highly likely to occur because:

1. **Default Configuration**: The official CLI implementation sets `maximum_amount: None`, making this the reference implementation that operators may copy
2. **Easy Exploitation**: Any user can exploit this with a simple HTTP POST request
3. **No Warning**: There is no validation warning or error when deploying a faucet without `maximum_amount` configured
4. **Single Request Impact**: Unlike traditional rate limiting attacks that require many requests, this can be exploited with a single request

## Recommendation
Implement mandatory per-request amount limits in the MintFunder. The fix should:

1. **Make maximum_amount required** instead of optional in TransactionSubmissionConfig
2. **Add runtime validation** to reject configurations without a cap
3. **Set sensible defaults** (e.g., 100 APT = 100_000_000_000 OCTA)

Alternatively, modify the `get_amount` logic to always enforce a cap:

```rust
fn get_amount(&self, amount: Option<u64>, did_bypass_checkers: bool) -> u64 {
    let max_allowed = self.txn_config.get_maximum_amount(did_bypass_checkers)
        .unwrap_or(self.amount_to_fund); // Use amount_to_fund as fallback cap
    
    match amount {
        Some(amount) => std::cmp::min(amount, max_allowed),
        None => std::cmp::min(self.amount_to_fund, max_allowed),
    }
}
```

This ensures the user-provided amount is ALWAYS capped, even when `maximum_amount` is misconfigured.

## Proof of Concept

```rust
// Rust PoC demonstrating the vulnerability
use aptos_sdk::types::account_address::AccountAddress;
use reqwest;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let faucet_url = "https://faucet.devnet.aptoslabs.com";
    let attacker_address = AccountAddress::from_hex_literal("0x1234...").unwrap();
    
    // Exploit: Request maximum u64 amount
    let malicious_amount = u64::MAX; // 18,446,744,073,709,551,615 OCTA
    
    let response = reqwest::Client::new()
        .post(format!("{}/mint", faucet_url))
        .query(&[
            ("address", attacker_address.to_string()),
            ("amount", malicious_amount.to_string()),
        ])
        .send()
        .await?;
    
    println!("Response: {:?}", response.status());
    println!("If successful, minted {} OCTA (~184 billion APT) in single request", malicious_amount);
    
    Ok(())
}
```

**Expected Result**: If the faucet is configured without `maximum_amount`, this request will succeed and mint the full u64::MAX amount (subject only to the MAX_U128 supply limit).

**Actual Safe Behavior**: The request should be capped to the configured `maximum_amount` or a sensible default like DEFAULT_FUNDED_COINS (100_000_000 OCTA = 1 APT).

## Notes
- This vulnerability ONLY affects MintFunder; TransferFunder is not vulnerable as it always caps amounts: [7](#0-6) 

- The vulnerability is specific to devnet/testnet environments where MintCapability exists
- While not a consensus or mainnet security issue, it represents a significant operational security concern for test network infrastructure

### Citations

**File:** crates/aptos-faucet/core/src/funder/mint.rs (L540-550)
```rust
    fn get_amount(&self, amount: Option<u64>, did_bypass_checkers: bool) -> u64 {
        match (
            amount,
            self.txn_config.get_maximum_amount(did_bypass_checkers),
        ) {
            (Some(amount), Some(maximum_amount)) => std::cmp::min(amount, maximum_amount),
            (Some(amount), None) => amount,
            (None, Some(maximum_amount)) => std::cmp::min(self.amount_to_fund, maximum_amount),
            (None, None) => self.amount_to_fund,
        }
    }
```

**File:** crates/aptos-faucet/cli/src/main.rs (L83-92)
```rust
        let transaction_submission_config = TransactionSubmissionConfig::new(
            None, // maximum_amount
            None, // maximum_amount_with_bypass
            30,   // gas_unit_price_ttl_secs
            None, // gas_unit_price_override
            self.max_gas_amount,
            25,   // transaction_expiration_secs
            30,   // wait_for_outstanding_txns_secs
            true, // wait_for_transactions
        );
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L283-309)
```rust
    async fn fund_inner(
        &self,
        fund_request: FundRequest,
        // This automagically uses FromRequest to get this data from the request.
        // It takes into things like X-Forwarded-IP and X-Real-IP.
        source_ip: RealIp,
        // Same thing, this uses FromRequest.
        header_map: &HeaderMap,
        dry_run: bool,
        asset: Option<String>,
    ) -> poem::Result<Vec<SignedTransaction>, AptosTapError> {
        let (checker_data, bypass, _semaphore_permit) = self
            .preprocess_request(&fund_request, source_ip, header_map, dry_run)
            .await?;

        // Fund the account - pass asset directly, funder will use its configured default if None
        let asset_for_logging = asset.clone();
        let fund_result = self
            .funder
            .fund(
                fund_request.amount,
                checker_data.receiver,
                asset,
                false,
                bypass,
            )
            .await;
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_coin.move (L70-89)
```text
    /// Can only be called during genesis for tests to grant mint capability to aptos framework and core resources
    /// accounts.
    /// Expects account and APT store to be registered before calling.
    public(friend) fun configure_accounts_for_test(
        aptos_framework: &signer,
        core_resources: &signer,
        mint_cap: MintCapability<AptosCoin>,
    ) {
        system_addresses::assert_aptos_framework(aptos_framework);

        // Mint the core resource account AptosCoin for gas so it can execute system transactions.
        let coins = coin::mint<AptosCoin>(
            18446744073709551615,
            &mint_cap,
        );
        coin::deposit<AptosCoin>(signer::address_of(core_resources), coins);

        move_to(core_resources, MintCapStore { mint_cap });
        move_to(core_resources, Delegations { inner: vector::empty() });
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_coin.move (L93-108)
```text
    public entry fun mint(
        account: &signer,
        dst_addr: address,
        amount: u64,
    ) acquires MintCapStore {
        let account_addr = signer::address_of(account);

        assert!(
            exists<MintCapStore>(account_addr),
            error::not_found(ENO_CAPABILITIES),
        );

        let mint_cap = &borrow_global<MintCapStore>(account_addr).mint_cap;
        let coins_minted = coin::mint<AptosCoin>(amount, mint_cap);
        coin::deposit<AptosCoin>(dst_addr, coins_minted);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L1193-1226)
```text
    fun mint_internal<CoinType>(amount: u64): Coin<CoinType> acquires CoinInfo {
        if (amount == 0) {
            return Coin<CoinType> { value: 0 }
        };

        let maybe_supply =
            &mut borrow_global_mut<CoinInfo<CoinType>>(coin_address<CoinType>()).supply;
        if (option::is_some(maybe_supply)) {
            let supply = option::borrow_mut(maybe_supply);
            spec {
                use aptos_framework::optional_aggregator;
                use aptos_framework::aggregator;
                assume optional_aggregator::is_parallelizable(supply) ==>
                    (
                        aggregator::spec_aggregator_get_val(
                            option::borrow(supply.aggregator)
                        ) + amount
                            <= aggregator::spec_get_limit(
                                option::borrow(supply.aggregator)
                            )
                    );
                assume !optional_aggregator::is_parallelizable(supply) ==>
                    (
                        option::borrow(supply.integer).value + amount
                            <= option::borrow(supply.integer).limit
                    );
            };
            optional_aggregator::add(supply, (amount as u128));
        };
        spec {
            update supply<CoinType> = supply<CoinType> + amount;
        };
        Coin<CoinType> { value: amount }
    }
```

**File:** crates/aptos-faucet/core/src/funder/transfer.rs (L333-344)
```rust
    fn get_amount(
        &self,
        amount: Option<u64>,
        // Ignored for now with TransferFunder, since generally we don't use Bypassers
        // when using the TransferFunder.
        _did_bypass_checkers: bool,
    ) -> u64 {
        match amount {
            Some(amount) => std::cmp::min(amount, self.amount_to_fund.0),
            None => self.amount_to_fund.0,
        }
    }
```
