# Audit Report

## Title
Validator Consensus Private Keys Stored in Plaintext When Using OnDiskStorage Backend

## Summary
Validator nodes configured with the `OnDiskStorage` backend for consensus safety rules store BLS12381 consensus private keys in plaintext JSON files on disk without encryption. The default validator configuration templates distributed with Aptos Core use this insecure backend, creating a critical key management vulnerability where file system compromise leads to validator key theft.

## Finding Description

The `OnDiskStorage` implementation in the secure storage subsystem writes all key-value pairs, including consensus private keys, to disk in unencrypted JSON format. [1](#0-0) 

When a validator node is configured with `consensus.safety_rules.backend.type: "on_disk_storage"`, the `PersistentSafetyStorage` component stores the validator's BLS12381 consensus private key using this backend: [2](#0-1) 

The private key is serialized as 32 bytes and stored under the key constant `CONSENSUS_KEY` ("consensus"): [3](#0-2) 

**Critical Issue**: The default validator configuration templates shipped with Aptos Core explicitly configure OnDiskStorage as the backend: [4](#0-3) [5](#0-4) 

While the README documentation warns that OnDiskStorage "should not be used in production," there is no runtime enforcement preventing its use, and the default configuration templates encourage insecure deployments: [6](#0-5) 

**Attack Scenario**:
1. Validator operator deploys a node using the provided Docker Compose or Helm configuration templates
2. Consensus private key is written to `/opt/aptos/data/secure-data.json` in plaintext JSON
3. Attacker gains file system access through container escape, backup compromise, or OS vulnerability
4. Attacker reads the plaintext consensus key from the JSON file
5. Attacker can now impersonate the validator in consensus protocol
6. Multiple validator compromises could enable consensus disruption or safety violations

## Impact Explanation

This vulnerability has **Critical** severity per Aptos bug bounty criteria:

- **Consensus/Safety Violations**: Compromised validator keys allow attackers to participate in consensus as legitimate validators, potentially enabling equivocation, double-signing, or safety rule violations if multiple validators are compromised (approaching 1/3 Byzantine threshold)

- **Validator Key Compromise**: Each compromised key represents a validator identity that can be impersonated indefinitely until key rotation occurs

- **Attack Surface**: File system compromise can occur through:
  - Container escape vulnerabilities (CVEs in Docker/Kubernetes)
  - Backup system breaches (cloud storage, snapshot volumes)
  - OS-level exploits on validator hosts
  - Insider threats with host access
  - Log file or crash dump leaks containing file contents

The cryptographic correctness invariant is violated: "BLS signatures, VRF, and hash operations must be secure" - this requires that private keys remain confidential.

## Likelihood Explanation

**High Likelihood** because:

1. **Default Configuration Risk**: Operators commonly copy-paste provided configuration templates without modification. Both Docker Compose and Kubernetes Helm templates use OnDiskStorage by default.

2. **No Runtime Protection**: The codebase includes no compile-time or runtime checks preventing OnDiskStorage in production environments: [7](#0-6) 

3. **Documentation Insufficient**: While the README warns against production use, this warning is buried in developer documentation and not surfaced as a runtime error or configuration validation failure.

4. **File System Access Vectors**: Modern cloud deployments present multiple vectors for file access:
   - Persistent volume snapshots in Kubernetes
   - Container image layer inspection
   - Backup system access
   - Host OS vulnerabilities

## Recommendation

Implement multiple layers of defense:

**1. Runtime Enforcement** - Add a production environment check that prevents OnDiskStorage:

```rust
// In secure/storage/src/on_disk.rs
impl OnDiskStorage {
    pub fn new(file_path: PathBuf) -> Self {
        #[cfg(not(any(test, feature = "testing")))]
        {
            panic!(
                "OnDiskStorage is not secure and must not be used in production. \
                Configure VaultStorage backend instead. \
                See: https://aptos.dev/guides/validator-setup#secure-storage"
            );
        }
        
        Self::new_with_time_service(file_path, TimeService::real())
    }
}
```

**2. Configuration Validation** - Add validation to SafetyRulesConfig:

```rust
// In config/src/config/safety_rules_config.rs
impl SafetyRulesConfig {
    pub fn validate_for_production(&self) -> Result<(), Error> {
        if matches!(self.backend, SecureBackend::OnDiskStorage(_)) {
            return Err(Error::ConfigError(
                "OnDiskStorage backend is insecure for production. Use Vault.".into()
            ));
        }
        Ok(())
    }
}
```

**3. Update Default Configurations** - Change all validator configuration templates to use VaultStorage or include prominent warnings:

```yaml
consensus:
  safety_rules:
    service:
      type: "local"
    backend:
      # SECURITY WARNING: OnDiskStorage stores keys in PLAINTEXT!
      # Use Vault for production: https://aptos.dev/validator-setup
      type: "vault"
      server: "https://vault.example.com:8200"
      token:
        from_disk: "/etc/aptos/vault-token"
```

**4. Add File Permissions** - If OnDiskStorage must be supported for development, enforce user-only permissions:

```rust
// In secure/storage/src/on_disk.rs write method
use std::os::unix::fs::PermissionsExt;

fn write(&self, data: &HashMap<String, Value>) -> Result<(), Error> {
    let contents = serde_json::to_vec(data)?;
    let mut file = File::create(self.temp_path.path())?;
    
    // Set user-only permissions (0600)
    #[cfg(unix)]
    {
        let mut perms = file.metadata()?.permissions();
        perms.set_mode(0o600);
        std::fs::set_permissions(self.temp_path.path(), perms)?;
    }
    
    file.write_all(&contents)?;
    fs::rename(&self.temp_path, &self.file_path)?;
    Ok(())
}
```

## Proof of Concept

**Setup**: Deploy a validator using the default Docker Compose configuration

```bash
# Deploy validator with default config
cd docker/compose/aptos-node
docker-compose up -d validator

# Wait for initialization
sleep 10

# Read plaintext consensus key from storage file
docker exec aptos-validator cat /opt/aptos/data/secure-data.json
```

**Expected Output** (example structure):
```json
{
  "consensus": {
    "data": {
      "last_update": 1234567890,
      "value": [1, 2, 3, ..., 32]  // 32-byte BLS private key in plaintext
    }
  },
  "owner_account": {
    "data": {
      "last_update": 1234567890,
      "value": "0x..."
    }
  }
}
```

**Rust Test to Demonstrate Vulnerability**:

```rust
#[test]
fn test_ondisk_storage_stores_keys_plaintext() {
    use aptos_crypto::bls12381::PrivateKey;
    use aptos_crypto::Uniform;
    use aptos_secure_storage::{Storage, OnDiskStorage, CryptoStorage};
    use aptos_temppath::TempPath;
    use std::fs;
    
    let temp_path = TempPath::new();
    temp_path.create_as_file().unwrap();
    let mut storage = Storage::from(OnDiskStorage::new(temp_path.path().to_path_buf()));
    
    // Create a consensus key
    let key_name = "consensus";
    let public_key = storage.create_key(key_name).unwrap();
    
    // Read the file directly
    let file_contents = fs::read_to_string(temp_path.path()).unwrap();
    println!("File contents: {}", file_contents);
    
    // Verify the private key is stored in plaintext JSON
    assert!(file_contents.contains("consensus"));
    assert!(file_contents.contains("value"));
    
    // An attacker can deserialize and extract the key
    let json: serde_json::Value = serde_json::from_str(&file_contents).unwrap();
    let key_bytes = json["consensus"]["data"]["value"]
        .as_array()
        .unwrap()
        .iter()
        .map(|v| v.as_u64().unwrap() as u8)
        .collect::<Vec<u8>>();
    
    // Reconstruct the private key from plaintext
    let stolen_key = PrivateKey::try_from(&key_bytes[..]).unwrap();
    assert_eq!(stolen_key.public_key(), public_key);
    
    println!("âœ“ Successfully extracted private key from plaintext storage!");
}
```

This vulnerability enables attackers with file system access to steal validator consensus keys, violating the fundamental security requirement that private keys must be protected at rest.

### Citations

**File:** secure/storage/src/on_disk.rs (L64-69)
```rust
    fn write(&self, data: &HashMap<String, Value>) -> Result<(), Error> {
        let contents = serde_json::to_vec(data)?;
        let mut file = File::create(self.temp_path.path())?;
        file.write_all(&contents)?;
        fs::rename(&self.temp_path, &self.file_path)?;
        Ok(())
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L63-68)
```rust
    fn initialize_keys_and_accounts(
        internal_store: &mut Storage,
        author: Author,
        consensus_private_key: bls12381::PrivateKey,
    ) -> Result<(), Error> {
        let result = internal_store.set(CONSENSUS_KEY, consensus_private_key);
```

**File:** crates/aptos-crypto/src/bls12381/bls12381_keys.rs (L89-97)
```rust
impl PrivateKey {
    /// The length of a serialized PrivateKey struct.
    // NOTE: We have to hardcode this here because there is no library-defined constant
    pub const LENGTH: usize = 32;

    /// Serialize a PrivateKey.
    pub fn to_bytes(&self) -> [u8; Self::LENGTH] {
        self.privkey.to_bytes()
    }
```

**File:** docker/compose/aptos-node/validator.yaml (L7-13)
```yaml
consensus:
  safety_rules:
    service:
      type: "local"
    backend:
      type: "on_disk_storage"
      path: secure-data.json
```

**File:** terraform/helm/aptos-node/files/configs/validator-base.yaml (L10-17)
```yaml
consensus:
  safety_rules:
    service:
      type: "local"
    backend:
      type: "on_disk_storage"
      path: secure-data.json
      namespace: ~
```

**File:** secure/storage/README.md (L37-42)
```markdown
- `OnDisk`: Similar to InMemory, the OnDisk secure storage implementation provides another
useful testing implementation: an on-disk storage engine, where the storage backend is
implemented using a single file written to local disk. In a similar fashion to the in-memory
storage, on-disk should not be used in production environments as it provides no security
guarantees (e.g., encryption before writing to disk). Moreover, OnDisk storage does not
currently support concurrent data accesses.
```

**File:** config/src/config/secure_backend_config.rs (L162-173)
```rust
impl From<&SecureBackend> for Storage {
    fn from(backend: &SecureBackend) -> Self {
        match backend {
            SecureBackend::InMemoryStorage => Storage::from(InMemoryStorage::new()),
            SecureBackend::OnDiskStorage(config) => {
                let storage = Storage::from(OnDiskStorage::new(config.path()));
                if let Some(namespace) = &config.namespace {
                    Storage::from(Namespaced::new(namespace, Box::new(storage)))
                } else {
                    storage
                }
            },
```
