# Audit Report

## Title
Premature Pruning of Genesis and Early Blockchain State Due to Incorrect Initial State Handling in State KV Pruner

## Summary
The `StateKvPrunerManager::maybe_set_pruner_target_db_version()` function incorrectly handles the initial state where `min_readable_version` is 0 in a newly initialized database. The pruning trigger condition adds `batch_size` to the threshold, causing the first `batch_size` versions (including genesis at version 0) to be prematurely marked as pruned, even though the configured `prune_window` should retain all historical data until sufficient excess accumulates.

## Finding Description

In a newly initialized Aptos blockchain database, the state KV pruner's `min_readable_version` starts at 0, retrieved from the database metadata. [1](#0-0) 

The pruning trigger condition in `maybe_set_pruner_target_db_version()` checks: [2](#0-1) 

When `min_readable_version = 0` (initial state), this condition becomes:
```
latest_version >= 0 + pruning_batch_size + prune_window
```

With default configuration values: [3](#0-2) 

The first pruning triggers at version 90,005,000 (= 5,000 + 90,000,000).

When triggered, `set_pruner_target_db_version()` calculates: [4](#0-3) 

This sets `min_readable_version = 90,005,000 - 90,000,000 = 5,000`, making versions 0-4,999 immediately unreadable.

The error checking in read paths enforces this: [5](#0-4) 

**Root Cause:** The condition treats initial `min_readable_version = 0` as if 0 versions have been pruned, when it actually means "no pruning has occurred yet." The addition of `batch_size` to the trigger threshold causes premature pruning before sufficient excess history accumulates beyond the `prune_window`.

**Expected Behavior:** With `prune_window = 90,000,000`, no pruning should occur until the database has significantly more than 90 million versions. The first pruning should ideally happen at version â‰¥ 90,000,000 + margin, keeping all early history including genesis.

**Actual Behavior:** Pruning triggers at 90,005,000 and immediately prunes the first 5,000 versions including genesis.

This affects the Ledger Pruner identically: [6](#0-5) 

## Impact Explanation

This is a **Medium Severity** vulnerability per the Aptos bug bounty criteria:

1. **Permanent Data Loss**: Genesis transaction (version 0) and the first 4,999 transactions become permanently unreadable once pruning occurs. This violates the intended data retention guarantee of the `prune_window` configuration.

2. **State Inconsistencies Requiring Intervention**: 
   - Historical state queries for versions 0-4,999 will fail
   - Archive nodes cannot serve complete blockchain history
   - State synchronization from genesis becomes impossible
   - Audit trails are broken for early blockchain activity

3. **No Direct Consensus or Funds Impact**: This does not cause consensus splits, validator crashes, or direct loss of funds, preventing it from being Critical or High severity. However, it does cause operational issues requiring manual intervention to restore data availability.

4. **Violation of Invariant #4 (State Consistency)**: While state transitions remain atomic, the ability to verify historical state via Merkle proofs is lost for pruned versions, breaking the verifiability guarantee.

## Likelihood Explanation

**Likelihood: High**

- **Automatic Trigger**: This vulnerability triggers automatically without any attacker action once the blockchain reaches version (`prune_window + batch_size`). With mainnet transaction volumes, this will occur naturally.

- **No Attacker Required**: The bug is inherent to the pruning logic and does not require malicious input or privileged access.

- **Production Impact**: Using default configuration, every Aptos node with pruning enabled will experience this issue after 90,005,000 transactions.

- **Irreversible**: Once pruning occurs, the data loss is permanent. Nodes cannot re-obtain pruned versions without restoring from a backup or syncing from an archive node that hasn't pruned.

## Recommendation

Modify the pruning trigger condition to exclude `batch_size` from the threshold calculation when `min_readable_version` is still at its initial value (0), or adjust the logic to account for the initial state properly.

**Option 1: Remove batch_size from initial trigger**
```rust
fn maybe_set_pruner_target_db_version(&self, latest_version: Version) {
    let min_readable_version = self.get_min_readable_version();
    
    // For initial state (min_readable = 0), only use prune_window
    // For subsequent pruning, add batch_size to avoid frequent small operations
    let threshold = if min_readable_version == 0 {
        self.prune_window
    } else {
        min_readable_version + self.pruning_batch_size as u64 + self.prune_window
    };
    
    if self.is_pruner_enabled() && latest_version >= threshold {
        self.set_pruner_target_db_version(latest_version);
    }
}
```

**Option 2: Adjust target calculation to preserve early history**
```rust
fn set_pruner_target_db_version(&self, latest_version: Version) {
    assert!(self.pruner_worker.is_some());
    let min_readable_version = latest_version.saturating_sub(self.prune_window);
    
    // Never prune below batch_size to preserve genesis and early state
    let min_readable_version = std::cmp::max(min_readable_version, self.pruning_batch_size as u64);
    
    self.min_readable_version
        .store(min_readable_version, Ordering::SeqCst);
    // ... rest of function
}
```

**Apply similar fixes to:**
- `LedgerPrunerManager::maybe_set_pruner_target_db_version()`
- Consider reviewing `StateMerklePrunerManager` which has different logic but may have related issues

## Proof of Concept

```rust
#[cfg(test)]
mod test_premature_pruning {
    use super::*;
    use crate::pruner::state_kv_pruner::state_kv_pruner_manager::StateKvPrunerManager;
    use aptos_config::config::LedgerPrunerConfig;
    use aptos_temppath::TempPath;
    use std::sync::Arc;

    #[test]
    fn test_premature_pruning_on_first_trigger() {
        let tmp_dir = TempPath::new();
        let db = crate::AptosDB::new_for_test(&tmp_dir);
        
        // Create pruner with small values for testing
        let prune_window = 100;
        let batch_size = 10;
        let pruner = StateKvPrunerManager::new(
            Arc::clone(&db.state_kv_db),
            LedgerPrunerConfig {
                enable: true,
                prune_window,
                batch_size,
                user_pruning_window_offset: 0,
            },
        );
        
        // Initially, min_readable_version should be 0
        assert_eq!(pruner.get_min_readable_version(), 0);
        
        // Simulate reaching version 110 (batch_size + prune_window)
        let trigger_version = batch_size as u64 + prune_window;
        pruner.maybe_set_pruner_target_db_version(trigger_version);
        
        // BUG: min_readable_version jumps to batch_size (10)
        // This means versions 0-9 (including genesis) are now pruned
        let min_readable = pruner.get_min_readable_version();
        assert_eq!(min_readable, batch_size as u64);
        
        // EXPECTED: min_readable_version should still be 0
        // We have only 110 versions total with prune_window=100
        // We should keep all of them, not prune the first 10
        assert_eq!(min_readable, 0, 
            "First {} versions including genesis were prematurely pruned!", 
            batch_size);
    }
}
```

**Notes:**
- The identical issue exists in `LedgerPrunerManager` and should be fixed there as well
- The `StateMerklePrunerManager` uses a different condition without `batch_size` but may have its own initialization issues
- Archive nodes and historical state queries are immediately affected once pruning occurs
- The issue is deterministic and reproducible on any node with pruning enabled using default configuration

### Citations

**File:** storage/aptosdb/src/pruner/pruner_utils.rs (L23-29)
```rust
pub(crate) fn get_state_kv_pruner_progress(state_kv_db: &StateKvDb) -> Result<Version> {
    Ok(get_progress(
        state_kv_db.metadata_db(),
        &DbMetadataKey::StateKvPrunerProgress,
    )?
    .unwrap_or(0))
}
```

**File:** storage/aptosdb/src/pruner/state_kv_pruner/state_kv_pruner_manager.rs (L46-55)
```rust
    fn maybe_set_pruner_target_db_version(&self, latest_version: Version) {
        let min_readable_version = self.get_min_readable_version();
        // Only wake up the state kv pruner if there are `ledger_pruner_pruning_batch_size` pending
        if self.is_pruner_enabled()
            && latest_version
                >= min_readable_version + self.pruning_batch_size as u64 + self.prune_window
        {
            self.set_pruner_target_db_version(latest_version);
        }
    }
```

**File:** storage/aptosdb/src/pruner/state_kv_pruner/state_kv_pruner_manager.rs (L128-142)
```rust
    fn set_pruner_target_db_version(&self, latest_version: Version) {
        assert!(self.pruner_worker.is_some());
        let min_readable_version = latest_version.saturating_sub(self.prune_window);
        self.min_readable_version
            .store(min_readable_version, Ordering::SeqCst);

        PRUNER_VERSIONS
            .with_label_values(&["state_kv_pruner", "min_readable"])
            .set(min_readable_version as i64);

        self.pruner_worker
            .as_ref()
            .unwrap()
            .set_target_db_version(min_readable_version);
    }
```

**File:** config/src/config/storage_config.rs (L84-89)
```rust
            match num_or_range.len() {
                1 => {
                    let num = u8::from_str(num_or_range[0])?;
                    ensure!(num < 16);
                    shard_ids.push(num);
                },
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L305-315)
```rust
    pub(super) fn error_if_state_kv_pruned(&self, data_type: &str, version: Version) -> Result<()> {
        let min_readable_version = self.state_store.state_kv_pruner.get_min_readable_version();
        ensure!(
            version >= min_readable_version,
            "{} at version {} is pruned, min available version is {}.",
            data_type,
            version,
            min_readable_version
        );
        Ok(())
    }
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs (L66-78)
```rust
    fn maybe_set_pruner_target_db_version(&self, latest_version: Version) {
        *self.latest_version.lock() = latest_version;

        let min_readable_version = self.get_min_readable_version();
        // Only wake up the ledger pruner if there are `ledger_pruner_pruning_batch_size` pending
        // versions.
        if self.is_pruner_enabled()
            && latest_version
                >= min_readable_version + self.pruning_batch_size as u64 + self.prune_window
        {
            self.set_pruner_target_db_version(latest_version);
        }
    }
```
