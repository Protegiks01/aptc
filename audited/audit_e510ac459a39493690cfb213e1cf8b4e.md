# Audit Report

## Title
TOCTOU Race Condition in Faucet Sequence Number Management Allows Exceeding Transaction Limits

## Summary
The `update_sequence_numbers()` function in the Aptos faucet contains a Time-of-Check-Time-of-Use (TOCTOU) race condition that allows concurrent requests to bypass the `MAX_NUM_OUTSTANDING_TRANSACTIONS` limit, potentially causing transaction expiration and faucet service disruption.

## Finding Description

The vulnerability exists in the sequence number validation logic where `our_funder_seq` is captured once at the beginning of the function but never updated within the validation loop. [1](#0-0) 

This captured value is then used in the validation check inside the loop: [2](#0-1) 

**The Race Condition:**

When multiple concurrent requests arrive simultaneously:

1. All threads enter `update_sequence_numbers()` and capture the **same** `our_funder_seq` value (e.g., 100) before any of them proceed to increment it
2. All threads query the blockchain and receive the same `funder_seq` value (e.g., 100)  
3. All threads evaluate `100 < 100 + 15` and pass the check
4. All threads add themselves to the outstanding requests queue
5. The queue enforces FIFO ordering, but all threads have **already passed the limit check**
6. Each thread proceeds to call `execute_transaction()`, which increments the local sequence number via `sign_with_transaction_builder()` [3](#0-2) 

The LocalAccount uses atomic operations for sequence number management [4](#0-3) , but this doesn't prevent the TOCTOU issue because the validation check at line 233 uses the stale captured value, not the current atomic value.

**Exploitation Scenario:**

With `MAX_NUM_OUTSTANDING_TRANSACTIONS = 15` defined at [5](#0-4) , an attacker can send 20+ concurrent requests. All requests capture `our_funder_seq = 100`, all pass the `< 115` check, and all proceed to create transactions, resulting in 20 outstanding transactions when only 15 should be allowed.

This vulnerability affects both TransferFunder [6](#0-5)  and MintFunder [7](#0-6) , as both use the same `update_sequence_numbers()` function.

## Impact Explanation

Exceeding `MAX_NUM_OUTSTANDING_TRANSACTIONS` can cause multiple issues:

1. **Transaction Expiration**: With a 25-second expiration time [8](#0-7) , transactions may expire before being processed when too many are submitted concurrently

2. **Sequence Number Desynchronization**: The local sequence number advances beyond what the blockchain has processed, causing a desync that triggers error conditions [9](#0-8) 

3. **Service Disruption**: The faucet enters an unhealthy state requiring sequence number reset, causing temporary unavailability for legitimate users

4. **Resource Exhaustion**: Exceeding the limit can overwhelm the mempool and cause additional resource consumption

This represents a **state inconsistency requiring intervention** per the Medium severity criteria, as the recovery mechanism at lines 288-296 is a fallback that indicates the system has entered an error state.

## Likelihood Explanation

**Likelihood: HIGH**

- **Attack Complexity**: Trivial - attacker simply sends 20+ concurrent HTTP requests to the faucet endpoint
- **Prerequisites**: None - public faucet access is all that's required
- **Detection**: Difficult - appears as normal concurrent traffic
- **Exploitation Window**: Always present during high-concurrency periods

The race condition window exists between capturing `our_funder_seq` (line 223) and the validation check (line 233), which spans multiple await points where other threads can interleave. In high-traffic scenarios (testnet onboarding events, promotional campaigns), this occurs naturally without intentional exploitation.

## Recommendation

**Fix the TOCTOU vulnerability by reading the current sequence number inside the loop instead of using a stale captured value:**

```rust
// Remove the captured our_funder_seq variable at lines 215-224
// Instead, read it fresh inside the loop:

for _ in 0..(wait_for_outstanding_txns_secs * 2) {
    // Read current sequence number INSIDE the critical section
    let our_funder_seq = funder_account.read().await.sequence_number();
    
    if our_funder_seq < funder_seq + MAX_NUM_OUTSTANDING_TRANSACTIONS {
        // Rest of the logic remains the same...
        if !set_outstanding {
            let mut requests_map = outstanding_requests.write().await;
            let queue = requests_map
                .entry(asset_name.to_string())
                .or_insert_with(Vec::new);
            queue.push(request_key);
            set_outstanding = true;
        }
        // ... queue checking logic ...
    }
    // ... sleep and retry logic ...
}
```

This ensures each validation check uses the **current** sequence number, preventing multiple threads from bypassing the limit by all checking against the same stale value.

**Alternative approach**: Acquire and hold a write lock on `funder_account` for the entire duration of the check-and-increment operation, but this would significantly reduce concurrency.

## Proof of Concept

```rust
#[tokio::test]
async fn test_toctou_exceeds_transaction_limit() {
    use tokio::task::JoinSet;
    use std::sync::Arc;
    
    // Setup: Create faucet with LocalAccount at sequence 100
    let faucet_account = Arc::new(RwLock::new(LocalAccount::new(
        test_address,
        test_key,
        100  // Starting sequence number
    )));
    let outstanding_requests = Arc::new(RwLock::new(HashMap::new()));
    
    // Mock client that returns sequence 100 from blockchain
    let mock_client = create_mock_client_returning_seq(100);
    
    // Attack: Send 20 concurrent requests
    let mut join_set = JoinSet::new();
    for i in 0..20 {
        let account = faucet_account.clone();
        let requests = outstanding_requests.clone();
        let client = mock_client.clone();
        
        join_set.spawn(async move {
            update_sequence_numbers(
                &client,
                &account,
                &requests,
                AccountAddress::random(),
                1000,
                30,
                "apt",
            ).await
        });
    }
    
    // Wait for all to pass the check
    while join_set.join_next().await.is_some() {}
    
    // Verification: Check that local sequence number exceeds limit
    let final_seq = faucet_account.read().await.sequence_number();
    
    // Expected: Should be 100 + 15 = 115 (respecting MAX_NUM_OUTSTANDING_TRANSACTIONS)
    // Actual: Will be 100 + 20 = 120 (all 20 requests passed the check)
    assert!(final_seq > 100 + 15, 
        "TOCTOU vulnerability: {} transactions created, exceeding limit of 15", 
        final_seq - 100);
}
```

**Expected behavior**: Maximum 15 concurrent requests should pass the check  
**Actual behavior**: All 20 requests pass the check using the same stale `our_funder_seq = 100` value, creating 20 transactions and advancing the sequence number to 120

## Notes

The vulnerability is exacerbated by the queue mechanism that enforces FIFO ordering **after** the limit check has passed. The queue prevents simultaneous execution but does not prevent too many requests from being admitted into the queue in the first place. The atomic operations in LocalAccount's `sequence_number()` and `increment_sequence_number()` methods protect against data races in reading/writing the value, but do not prevent the logical TOCTOU race where multiple threads all read the same value and make decisions based on it before any of them increment it.

### Citations

**File:** crates/aptos-faucet/core/src/funder/common.rs (L39-39)
```rust
const MAX_NUM_OUTSTANDING_TRANSACTIONS: u64 = 15;
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L161-162)
```rust
    fn default_transaction_expiration_secs() -> u64 {
        25
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L215-224)
```rust
    let our_funder_seq = {
        let funder_account = funder_account.write().await;

        // If the onchain sequence_number is greater than what we have, update our
        // sequence_numbers
        if funder_seq > funder_account.sequence_number() {
            funder_account.set_sequence_number(funder_seq);
        }
        funder_account.sequence_number()
    };
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L232-233)
```rust
    for _ in 0..(wait_for_outstanding_txns_secs * 2) {
        if our_funder_seq < funder_seq + MAX_NUM_OUTSTANDING_TRANSACTIONS {
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L288-296)
```rust
    if our_funder_seq >= funder_seq + MAX_NUM_OUTSTANDING_TRANSACTIONS {
        error!("We are unhealthy, transactions have likely expired.");
        let funder_account = funder_account.write().await;
        if funder_account.sequence_number() >= funder_seq + MAX_NUM_OUTSTANDING_TRANSACTIONS {
            info!("Resetting the sequence number counter.");
            funder_account.set_sequence_number(funder_seq);
        } else {
            info!("Someone else reset the sequence number counter ahead of us.");
        }
```

**File:** crates/aptos-faucet/core/src/funder/transfer.rs (L218-222)
```rust
        let signed_transaction = self
            .faucet_account
            .write()
            .await
            .sign_with_transaction_builder(transaction_builder);
```

**File:** crates/aptos-faucet/core/src/funder/transfer.rs (L284-293)
```rust
        let (_funder_seq_num, receiver_seq_num) = update_sequence_numbers(
            &client,
            &self.faucet_account,
            &self.outstanding_requests,
            receiver_address,
            amount,
            self.wait_for_outstanding_txns_secs,
            DEFAULT_ASSET_NAME,
        )
        .await?;
```

**File:** sdk/src/types.rs (L546-548)
```rust
    pub fn increment_sequence_number(&self) -> u64 {
        self.sequence_number.fetch_add(1, Ordering::SeqCst)
    }
```

**File:** crates/aptos-faucet/core/src/funder/mint.rs (L405-414)
```rust
        let (_faucet_seq, receiver_seq) = update_sequence_numbers(
            client,
            self.get_asset_account(asset_name)?,
            &self.outstanding_requests,
            receiver_address,
            amount,
            self.txn_config.wait_for_outstanding_txns_secs,
            asset_name,
        )
        .await?;
```
