# Audit Report

## Title
Missing GAS_PAYER_ENABLED Feature Flag Enforcement Allows Fee Payer Transaction Bypass

## Summary
The `GAS_PAYER_ENABLED` feature flag is not enforced in transaction validation, allowing fee payer transactions to be processed even when the feature is disabled. This breaks governance controls and creates a non-functional "kill switch" for fee payer functionality.

## Finding Description

The Aptos blockchain uses feature flags to control the rollout and emergency shutdown of features. The `GAS_PAYER_ENABLED` flag is intended to gate all fee payer transaction functionality. However, the implementation fails to check this flag at critical validation points. [1](#0-0) 

An error code `PROLOGUE_EFEE_PAYER_NOT_ENABLED` exists but is never used in the codebase. The formal specification explicitly requires this check: [2](#0-1) [3](#0-2) 

However, the actual implementation in multiple critical functions lacks this validation:

**1. VM-Level Validation Missing Check:**
The `validate_signed_transaction` function processes fee payer authenticators without checking the feature flag: [4](#0-3) 

**2. Prologue Dispatch Missing Check:**
The `run_script_prologue` function routes to fee payer prologues without validation: [5](#0-4) 

**3. Move Prologue Functions Missing Check:**
Both `unified_prologue_fee_payer_v2` and `fee_payer_script_prologue_extended` lack the required assertion: [6](#0-5) [7](#0-6) 

**Contrast with Proper Feature Gating:**
Other features like `ORDERLESS_TRANSACTIONS` are correctly enforced: [8](#0-7) 

**Exploitation Path:**
1. Governance disables `GAS_PAYER_ENABLED` (e.g., emergency response to discovered vulnerability)
2. Attacker submits `TransactionAuthenticator::FeePayer` transaction
3. Transaction passes through all validation without flag check
4. With `SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION` enabled, automatic account creation occurs: [9](#0-8) 
5. Fee payer functionality remains active despite governance decision

## Impact Explanation

This is a **High Severity** issue per Aptos bug bounty criteria as it constitutes a "Significant protocol violation":

**Governance Bypass:** The governance mechanism for controlling feature flags is fundamentally broken for fee payer functionality. When governance votes to disable `GAS_PAYER_ENABLED`, the flag has no effect.

**Emergency Response Failure:** If a critical vulnerability is discovered in fee payer logic, operators cannot emergency-disable the feature. The "kill switch" doesn't work.

**Conflicting Feature State Vulnerabilities:** With `SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION` enabled but `GAS_PAYER_ENABLED` disabled, unexpected behavior occurs:
- Sponsored account creation continues working
- Fee payer transactions process despite being "disabled"  
- Potential for fee manipulation when combined with `FEE_PAYER_ACCOUNT_OPTIONAL`

**Consensus Impact:** If different validators interpret the feature flag differently (e.g., due to upgrade timing), this could cause non-deterministic transaction execution and state divergence.

## Likelihood Explanation

**Likelihood: Medium-High**

The vulnerability becomes exploitable in several realistic scenarios:

1. **Emergency Shutdown:** Governance discovers a fee payer vulnerability and attempts emergency disable via `GAS_PAYER_ENABLED` - shutdown fails, network remains vulnerable

2. **Feature Rollout:** During coordinated rollout, if `SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION` or `FEE_PAYER_ACCOUNT_OPTIONAL` are enabled before `GAS_PAYER_ENABLED` is fully deployed, inconsistent behavior occurs

3. **Governance Testing:** Protocol upgrades that manipulate feature flags could unintentionally expose this vulnerability

Currently, all three flags are enabled by default: [10](#0-9) [11](#0-10) 

However, any future governance action to disable `GAS_PAYER_ENABLED` would be ineffective, making the flag's existence misleading and dangerous.

## Recommendation

Add the missing `GAS_PAYER_ENABLED` check at the earliest validation point. The fix should be implemented in `validate_signed_transaction` before processing fee payer authenticators:

**In `aptos-move/aptos-vm/src/aptos_vm.rs`:**
```rust
// After line 1829, add:
if transaction_data.fee_payer.is_some() && !self.features().is_enabled(FeatureFlag::GAS_PAYER_ENABLED) {
    return Err(VMStatus::error(
        StatusCode::FEATURE_UNDER_GATING,
        Some("Fee payer transactions are not enabled".to_string()),
    ));
}
```

**Alternative: Add check in Move prologue functions:**
```move
// In unified_prologue_fee_payer_v2 and fee_payer_script_prologue_extended
// Add at the beginning:
assert!(
    features::fee_payer_enabled(),
    error::invalid_state(PROLOGUE_EFEE_PAYER_NOT_ENABLED)
);
```

The Rust-level check is preferred as it catches the issue earlier in the validation pipeline and is consistent with how other feature flags (like `ORDERLESS_TRANSACTIONS`) are enforced.

## Proof of Concept

```rust
#[test]
fn test_fee_payer_bypasses_disabled_flag() {
    // Create harness with GAS_PAYER_ENABLED explicitly disabled
    let mut h = MoveHarness::new_with_features(
        vec![
            FeatureFlag::SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION,
            FeatureFlag::ACCOUNT_ABSTRACTION,
        ],
        vec![
            FeatureFlag::GAS_PAYER_ENABLED, // DISABLED
            FeatureFlag::DEFAULT_ACCOUNT_RESOURCE,
        ],
    );

    let sender = h.new_account_with_balance_and_sequence_number(0, 0);
    let fee_payer = h.new_account_at(AccountAddress::from_hex_literal("0xfee").unwrap());

    // Submit fee payer transaction - should be rejected but isn't
    let payload = aptos_stdlib::aptos_coin_transfer(*sender.address(), 0);
    let transaction = TransactionBuilder::new(sender.clone())
        .fee_payer(fee_payer.clone())
        .payload(payload)
        .sequence_number(0)
        .max_gas_amount(1_000_000)
        .gas_unit_price(1)
        .sign_fee_payer();

    let output = h.run_raw(transaction);
    
    // Expected: Should fail with FEATURE_UNDER_GATING or PROLOGUE_EFEE_PAYER_NOT_ENABLED
    // Actual: Transaction succeeds, bypassing the disabled flag
    // This demonstrates the vulnerability
    assert!(output.status().is_success(), "Fee payer transaction processed despite flag being disabled!");
}
```

This test demonstrates that fee payer transactions are processed successfully even when `GAS_PAYER_ENABLED` is explicitly disabled, confirming the governance control is non-functional.

## Notes

The vulnerability stems from a discrepancy between the formal specification and implementation. While the specification mandates the check, three separate code paths (Rust VM validation, Rust prologue dispatch, and Move prologue functions) all omit it. This suggests the check was either never implemented or was removed during refactoring. The existence of the unused `PROLOGUE_EFEE_PAYER_NOT_ENABLED` error code indicates the check was originally planned but never enforced.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L71-71)
```text
    const PROLOGUE_EFEE_PAYER_NOT_ENABLED: u64 = 1010;
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L480-516)
```text
    fun fee_payer_script_prologue_extended(
        sender: signer,
        txn_sequence_number: u64,
        txn_sender_public_key: vector<u8>,
        secondary_signer_addresses: vector<address>,
        secondary_signer_public_key_hashes: vector<vector<u8>>,
        fee_payer_address: address,
        fee_payer_public_key_hash: vector<u8>,
        txn_gas_price: u64,
        txn_max_gas_units: u64,
        txn_expiration_time: u64,
        chain_id: u8,
        is_simulation: bool,
    ) {
        prologue_common(
            &sender,
            &create_signer::create_signer(fee_payer_address),
            ReplayProtector::SequenceNumber(txn_sequence_number),
            option::some(txn_sender_public_key),
            txn_gas_price,
            txn_max_gas_units,
            txn_expiration_time,
            chain_id,
            is_simulation,
        );
        multi_agent_common_prologue(
            secondary_signer_addresses,
            vector::map(secondary_signer_public_key_hashes, |x| option::some(x)),
            is_simulation
        );
        if (!skip_auth_key_check(is_simulation, &option::some(fee_payer_public_key_hash))) {
                assert!(
                    fee_payer_public_key_hash == account::get_authentication_key(fee_payer_address),
                    error::invalid_argument(PROLOGUE_EINVALID_ACCOUNT_AUTH_KEY),
                )
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L760-800)
```text
    fun unified_prologue_fee_payer_v2(
        sender: signer,
        fee_payer: signer,
        txn_sender_public_key: Option<vector<u8>>,
        fee_payer_public_key_hash: Option<vector<u8>>,
        replay_protector: ReplayProtector,
        secondary_signer_addresses: vector<address>,
        secondary_signer_public_key_hashes: vector<Option<vector<u8>>>,
        txn_gas_price: u64,
        txn_max_gas_units: u64,
        txn_expiration_time: u64,
        chain_id: u8,
        is_simulation: bool,
    ) {
        prologue_common(
            &sender,
            &fee_payer,
            replay_protector,
            txn_sender_public_key,
            txn_gas_price,
            txn_max_gas_units,
            txn_expiration_time,
            chain_id,
            is_simulation,
        );
        multi_agent_common_prologue(secondary_signer_addresses, secondary_signer_public_key_hashes, is_simulation);
        if (!skip_auth_key_check(is_simulation, &fee_payer_public_key_hash)) {
            let fee_payer_address = signer::address_of(&fee_payer);
            if (option::is_some(&fee_payer_public_key_hash)) {
                assert!(
                    fee_payer_public_key_hash == option::some(account::get_authentication_key(fee_payer_address)),
                    error::invalid_argument(PROLOGUE_EINVALID_ACCOUNT_AUTH_KEY)
                );
            } else {
                assert!(
                    allow_missing_txn_authentication_key(fee_payer_address),
                    error::invalid_argument(PROLOGUE_EINVALID_ACCOUNT_AUTH_KEY)
                )
            };
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.spec.move (L259-259)
```text
        aborts_if !features::spec_is_enabled(features::FEE_PAYER_ENABLED);
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.spec.move (L274-274)
```text
        aborts_if !features::spec_fee_payer_enabled();
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1830-1869)
```rust
        let fee_payer_signer = if let Some(fee_payer) = transaction_data.fee_payer {
            Some(match &transaction_data.fee_payer_authentication_proof {
                Some(AuthenticationProof::Abstract {
                    function_info,
                    auth_data,
                }) => {
                    let enabled = match auth_data {
                        AbstractAuthenticationData::V1 { .. } => {
                            self.features().is_account_abstraction_enabled()
                        },
                        AbstractAuthenticationData::DerivableV1 { .. } => {
                            self.features().is_derivable_account_abstraction_enabled()
                        },
                    };
                    if enabled {
                        dispatchable_authenticate(
                            session,
                            gas_meter,
                            fee_payer,
                            function_info.clone(),
                            auth_data,
                            traversal_context,
                            module_storage,
                        )
                        .map_err(|mut vm_error| {
                            if vm_error.major_status() == OUT_OF_GAS {
                                vm_error
                                    .set_major_status(ACCOUNT_AUTHENTICATION_GAS_LIMIT_EXCEEDED);
                            }
                            vm_error.into_vm_status()
                        })
                    } else {
                        return Err(VMStatus::error(StatusCode::FEATURE_UNDER_GATING, None));
                    }
                },
                _ => Ok(serialized_signer(&fee_payer)),
            }?)
        } else {
            None
        };
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1923-1930)
```rust
        if !self.features().is_orderless_txns_enabled() {
            if let ReplayProtector::Nonce(_) = transaction.replay_protector() {
                return Err(VMStatus::error(
                    StatusCode::FEATURE_UNDER_GATING,
                    Some("Orderless transactions are not yet supported".to_string()),
                ));
            }
        }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3457-3460)
```rust
    if (features.is_enabled(FeatureFlag::DEFAULT_ACCOUNT_RESOURCE)
        || (features.is_enabled(FeatureFlag::SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION)
            && txn_data.fee_payer.is_some()))
        && txn_data.replay_protector == ReplayProtector::SequenceNumber(0)
```

**File:** aptos-move/aptos-vm/src/transaction_validation.rs (L151-197)
```rust
            if let (Some(_fee_payer), Some(fee_payer_auth_key)) = (
                txn_data.fee_payer(),
                txn_data
                    .fee_payer_authentication_proof
                    .as_ref()
                    .map(|proof| proof.optional_auth_key()),
            ) {
                let serialized_args = vec![
                    serialized_signers.sender(),
                    serialized_signers
                        .fee_payer()
                        .ok_or_else(|| VMStatus::error(StatusCode::UNREACHABLE, None))?,
                    txn_authentication_key
                        .as_move_value()
                        .simple_serialize()
                        .unwrap(),
                    fee_payer_auth_key
                        .as_move_value()
                        .simple_serialize()
                        .unwrap(),
                    replay_protector_move_value,
                    MoveValue::vector_address(txn_data.secondary_signers())
                        .simple_serialize()
                        .unwrap(),
                    MoveValue::Vector(secondary_auth_keys)
                        .simple_serialize()
                        .unwrap(),
                    MoveValue::U64(txn_gas_price.into())
                        .simple_serialize()
                        .unwrap(),
                    MoveValue::U64(txn_max_gas_units.into())
                        .simple_serialize()
                        .unwrap(),
                    MoveValue::U64(txn_expiration_timestamp_secs)
                        .simple_serialize()
                        .unwrap(),
                    MoveValue::U8(chain_id.id()).simple_serialize().unwrap(),
                    MoveValue::Bool(is_simulation).simple_serialize().unwrap(),
                ];
                (
                    if features.is_transaction_payload_v2_enabled() {
                        &APTOS_TRANSACTION_VALIDATION.unified_prologue_fee_payer_v2_name
                    } else {
                        &APTOS_TRANSACTION_VALIDATION.unified_prologue_fee_payer_name
                    },
                    serialized_args,
                )
```

**File:** types/src/on_chain_config/aptos_features.rs (L197-197)
```rust
            FeatureFlag::GAS_PAYER_ENABLED,
```

**File:** types/src/on_chain_config/aptos_features.rs (L208-209)
```rust
            FeatureFlag::SPONSORED_AUTOMATIC_ACCOUNT_V1_CREATION,
            FeatureFlag::FEE_PAYER_ACCOUNT_OPTIONAL,
```
