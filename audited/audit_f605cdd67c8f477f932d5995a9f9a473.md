# Audit Report

## Title
IPv6-Based SSRF Vulnerability in JWK Fetching Allows Validator Access to Internal Services

## Summary
The `fetch_jwks_from_jwks_uri()` function in the JWK utilities module lacks URL validation, allowing IPv6 addresses, IPv6-mapped IPv4 addresses, and private IP ranges to be used in JWK fetch requests. This enables Server-Side Request Forgery (SSRF) attacks against validator nodes, potentially exposing internal cloud metadata services and causing validator disruption.

## Finding Description

The JWK consensus system in Aptos allows validators to fetch JSON Web Keys from OIDC providers to support keyless accounts. The flow operates as follows:

1. On-chain governance adds OIDC providers to `SupportedOIDCProviders` via the `upsert_oidc_provider_for_next_epoch()` function [1](#0-0) 

2. Each validator spawns a `JWKObserver` thread for each provider [2](#0-1) 

3. The observer periodically fetches the OpenID configuration from the provider's `config_url` [3](#0-2) 

4. The configuration response contains a `jwks_uri` field [4](#0-3) 

5. Validators then fetch JWKs from this `jwks_uri` [5](#0-4) 

**The vulnerability exists because neither URL undergoes any validation:**

The `fetch_jwks_from_jwks_uri()` function creates a default `reqwest::Client` and directly makes a GET request to the provided URL string without any IP address validation, scheme checking, or SSRF protection [6](#0-5) 

Similarly, `fetch_jwks_uri_from_openid_config()` has no validation [7](#0-6) 

**Attack Scenarios:**

**Scenario 1: Compromised OIDC Provider**
1. A legitimate OIDC provider (e.g., Google, Facebook) is added through governance
2. An attacker compromises the provider's OpenID configuration endpoint (via DNS hijacking, CDN compromise, or direct breach)
3. The compromised endpoint returns a malicious `jwks_uri` containing:
   - IPv6 localhost: `http://[::1]/sensitive-endpoint`
   - IPv6-mapped IPv4: `http://[::ffff:127.0.0.1]/metadata`
   - IPv6 ULA addresses: `http://[fd00::1]/internal-api`
   - Link-local IPv6: `http://[fe80::1]/kubernetes-api`
   - Cloud metadata: `http://[::ffff:169.254.169.254]/latest/meta-data/`
4. All validators make requests to these internal endpoints
5. Internal service responses are captured in error logs or metrics

**Scenario 2: Governance Attack (requires privileged access)**
1. A malicious governance proposal directly sets `config_url` to an internal service URL
2. Validators fetch from the internal service

The Move code provides no URL validation when storing the `config_url` [8](#0-7) 

Validators run in cloud environments (GCP/AWS) where they have access to:
- Cloud metadata services at `169.254.169.254`
- Kubernetes internal services
- Other internal infrastructure endpoints

The pepper service also uses the same vulnerable pattern for federated JWK fetching [9](#0-8) 

The federated issuer constructs URLs by concatenating the JWT issuer with a suffix, again without validation [10](#0-9) 

## Impact Explanation

This vulnerability meets **High Severity** criteria per the Aptos Bug Bounty program:

1. **Validator Node Disruption**: If internal services return large responses or timeout, validators experience slowdowns while fetching JWKs, impacting their ability to participate in consensus.

2. **Information Disclosure**: Validators can be tricked into accessing:
   - Cloud metadata services (IAM credentials, instance metadata)
   - Internal Kubernetes service endpoints
   - Internal monitoring/metrics endpoints
   - Internal configuration services

3. **Protocol Violation**: The JWK consensus system could be manipulated if attackers control the JWK data being fetched, potentially affecting keyless account validation.

4. **Lack of Defense-in-Depth**: Even with governance trust assumptions, validators should implement SSRF protections to prevent supply chain attacks against OIDC providers.

While this does not directly cause consensus safety violations or fund loss (Critical severity), it represents a significant security weakness in the validator infrastructure that could be exploited through OIDC provider compromise—a realistic supply chain attack vector.

## Likelihood Explanation

**Likelihood: Medium to High**

The vulnerability is exploitable under two conditions:

1. **OIDC Provider Compromise** (More likely): Supply chain attacks against identity providers are increasingly common. Recent incidents include:
   - DNS hijacking of major service providers
   - CDN compromises affecting configuration endpoints
   - Third-party integration vulnerabilities

   Once any supported OIDC provider is compromised, all Aptos validators become vulnerable to SSRF attacks.

2. **Malicious Governance Proposal** (Less likely): Requires successfully passing a malicious governance proposal, which requires significant stake and community support.

The exploitation itself is trivial once conditions are met—simply return a malicious `jwks_uri` containing IPv6 addresses or IPv6-mapped IPv4 addresses pointing to internal services.

## Recommendation

Implement comprehensive URL validation before making any HTTP requests to fetch JWKs. The validation should include:

1. **Scheme Validation**: Only allow HTTPS (not HTTP)
2. **URL Parsing**: Parse the URL and extract the host
3. **DNS Resolution**: Resolve hostnames to IP addresses
4. **IP Address Validation**: Block requests to:
   - Private IPv4 ranges: 10.0.0.0/8, 172.16.0.0/12, 192.168.0.0/16, 127.0.0.0/8
   - Link-local: 169.254.0.0/16
   - Private IPv6 ranges: fc00::/7 (Unique Local Addresses)
   - IPv6 localhost: ::1
   - IPv6 link-local: fe80::/10
   - IPv6 multicast: ff00::/8
   - IPv4-mapped IPv6: ::ffff:0:0/96 when the mapped IPv4 is private
5. **Domain Validation**: For known providers (Google, Apple), validate that the domain matches expected patterns

**Recommended Fix Location:**

Add validation functions to `crates/jwk-utils/src/lib.rs`:

```rust
use std::net::{IpAddr, Ipv4Addr, Ipv6Addr};
use url::Url;

/// Validates that a URL is safe for fetching external resources
fn validate_url_for_fetch(url_str: &str) -> Result<()> {
    // Parse URL
    let url = Url::parse(url_str)
        .context("Invalid URL")?;
    
    // Require HTTPS
    if url.scheme() != "https" {
        return Err(anyhow!("Only HTTPS URLs are allowed"));
    }
    
    // Get host
    let host = url.host_str()
        .ok_or_else(|| anyhow!("URL must have a host"))?;
    
    // Resolve to IP addresses
    let addrs = tokio::net::lookup_host((host, 443))
        .await
        .context("Failed to resolve hostname")?;
    
    // Check each resolved IP
    for addr in addrs {
        let ip = addr.ip();
        if is_private_or_internal_ip(&ip) {
            return Err(anyhow!("URL resolves to private/internal IP: {}", ip));
        }
    }
    
    Ok(())
}

fn is_private_or_internal_ip(ip: &IpAddr) -> bool {
    match ip {
        IpAddr::V4(ipv4) => is_private_ipv4(ipv4),
        IpAddr::V6(ipv6) => is_private_ipv6(ipv6),
    }
}

fn is_private_ipv4(ip: &Ipv4Addr) -> bool {
    ip.is_private() || 
    ip.is_loopback() || 
    ip.is_link_local() ||
    ip.is_broadcast() ||
    ip.is_unspecified()
}

fn is_private_ipv6(ip: &Ipv6Addr) -> bool {
    // Check for IPv4-mapped IPv6
    if let Some(ipv4) = ip.to_ipv4_mapped() {
        return is_private_ipv4(&ipv4);
    }
    
    ip.is_loopback() ||
    ip.is_unspecified() ||
    // Unique Local Addresses (fc00::/7)
    (ip.segments()[0] & 0xfe00) == 0xfc00 ||
    // Link-local (fe80::/10)
    (ip.segments()[0] & 0xffc0) == 0xfe80 ||
    // Multicast (ff00::/8)
    ip.is_multicast()
}
```

Then call `validate_url_for_fetch()` before making requests in both `fetch_jwks_from_jwks_uri()` and `fetch_jwks_uri_from_openid_config()`.

Apply similar validation in the pepper service [9](#0-8) 

## Proof of Concept

**PoC: Rust Test Demonstrating IPv6 SSRF**

```rust
#[tokio::test]
async fn test_ipv6_ssrf_vulnerability() {
    // These URLs should be blocked but currently are not
    let malicious_urls = vec![
        "http://[::1]/internal-api",                    // IPv6 localhost
        "http://[::ffff:127.0.0.1]/metadata",          // IPv4-mapped localhost
        "http://[::ffff:169.254.169.254]/cloud-meta",  // IPv4-mapped cloud metadata
        "http://[fc00::1]/internal-service",            // IPv6 ULA
        "http://[fe80::1]/kubernetes-api",              // IPv6 link-local
    ];
    
    for url in malicious_urls {
        // Current implementation makes the request without validation
        let result = fetch_jwks_from_jwks_uri(None, url).await;
        
        // In a vulnerable system, this would either:
        // 1. Successfully reach internal service (if it exists)
        // 2. Return a connection error (but attempt was made)
        
        // With proper validation, this should fail immediately
        // with a validation error before any network request
        println!("Attempted fetch from {}: {:?}", url, result);
    }
}

#[tokio::test] 
async fn test_oidc_provider_compromise_scenario() {
    // Simulate a compromised OIDC provider returning malicious jwks_uri
    
    // Step 1: Legitimate config_url is called
    let config_url = "https://malicious-oidc.example.com/.well-known/openid-configuration";
    
    // Step 2: Response contains malicious jwks_uri with IPv6 internal address
    // Attacker controls the OpenID config response to return:
    // {
    //   "issuer": "https://malicious-oidc.example.com",
    //   "jwks_uri": "http://[::ffff:169.254.169.254]/latest/meta-data/iam/security-credentials/"
    // }
    
    // Step 3: Validator calls fetch_jwks_from_jwks_uri with malicious URL
    let malicious_jwks_uri = "http://[::ffff:169.254.169.254]/latest/meta-data/iam/security-credentials/";
    
    // This should be blocked but currently isn't
    let result = fetch_jwks_from_jwks_uri(None, malicious_jwks_uri).await;
    
    // If running on AWS, this could successfully fetch IAM credentials
    // demonstrating SSRF vulnerability
    assert!(result.is_err(), "SSRF protection should block this request");
}
```

**PoC: Move Governance Proposal (Scenario 2)**

```move
script {
    use aptos_framework::jwks;
    use aptos_framework::aptos_governance;
    
    fun add_malicious_oidc_provider(framework: &signer) {
        // Malicious governance proposal to add OIDC provider
        // with IPv6 internal address
        jwks::upsert_oidc_provider_for_next_epoch(
            framework,
            b"malicious-provider",
            b"http://[::ffff:127.0.0.1]/fake-openid-config"
        );
        
        // Apply changes
        aptos_governance::reconfigure(framework);
        
        // All validators will now attempt to fetch from localhost
        // via IPv6-mapped IPv4 address
    }
}
```

## Notes

This vulnerability demonstrates a failure in defense-in-depth principles. While governance participants are trusted, validators should still implement SSRF protections because:

1. **Supply Chain Risk**: OIDC providers are external dependencies that could be compromised
2. **Configuration Errors**: Accidental misconfigurations could point to internal services
3. **Defense in Depth**: Security should not rely solely on governance trust
4. **Cloud Security Best Practices**: SSRF protection is standard for services making outbound HTTP requests

The vulnerability affects both the JWK consensus system used by validators and the pepper service used for keyless account operations, indicating a systemic issue with URL validation across the codebase.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L54-61)
```text
    struct OIDCProvider has copy, drop, store {
        /// The utf-8 encoded issuer string. E.g., b"https://www.facebook.com".
        name: vector<u8>,

        /// The ut8-8 encoded OpenID configuration URL of the provider.
        /// E.g., b"https://www.facebook.com/.well-known/openid-configuration/".
        config_url: vector<u8>,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L317-330)
```text
    public fun upsert_oidc_provider_for_next_epoch(fx: &signer, name: vector<u8>, config_url: vector<u8>): Option<vector<u8>> acquires SupportedOIDCProviders {
        system_addresses::assert_aptos_framework(fx);

        let provider_set = if (config_buffer::does_exist<SupportedOIDCProviders>()) {
            config_buffer::extract_v2<SupportedOIDCProviders>()
        } else {
            *borrow_global<SupportedOIDCProviders>(@aptos_framework)
        };

        let old_config_url = remove_oidc_provider_internal(&mut provider_set, name);
        vector::push_back(&mut provider_set.providers, OIDCProvider { name, config_url });
        config_buffer::upsert(provider_set);
        old_config_url
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_observer.rs (L22-49)
```rust
    pub fn spawn(
        epoch: u64,
        my_addr: AccountAddress,
        issuer: String,
        config_url: String,
        fetch_interval: Duration,
        observation_tx: aptos_channel::Sender<(), (Issuer, Vec<JWK>)>,
    ) -> Self {
        let (close_tx, close_rx) = oneshot::channel();
        let join_handle = tokio::spawn(Self::start(
            fetch_interval,
            my_addr,
            issuer.clone(),
            config_url.clone(),
            observation_tx,
            close_rx,
        ));
        info!(
            epoch = epoch,
            issuer = issuer,
            config_url = config_url,
            "JWKObserver spawned."
        );
        Self {
            close_tx,
            join_handle,
        }
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_observer.rs (L102-110)
```rust
async fn fetch_jwks(open_id_config_url: &str, my_addr: Option<AccountAddress>) -> Result<Vec<JWK>> {
    let jwks_uri = fetch_jwks_uri_from_openid_config(open_id_config_url)
        .await
        .map_err(|e| anyhow!("fetch_jwks failed with open-id config request: {e}"))?;
    let jwks = fetch_jwks_from_jwks_uri(my_addr, jwks_uri.as_str())
        .await
        .map_err(|e| anyhow!("fetch_jwks failed with jwks uri request: {e}"))?;
    Ok(jwks)
}
```

**File:** crates/jwk-utils/src/lib.rs (L25-37)
```rust
pub async fn fetch_jwks_from_jwks_uri(
    my_addr: Option<AccountAddress>,
    jwks_uri: &str,
) -> Result<Vec<JWK>> {
    let client = reqwest::Client::new();
    let mut request_builder = client.get(jwks_uri);
    if let Some(addr) = my_addr {
        request_builder = request_builder.header(COOKIE, addr.to_hex());
    }
    let JWKsResponse { keys } = request_builder.send().await?.json().await?;
    let jwks = keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
}
```

**File:** crates/jwk-utils/src/lib.rs (L40-44)
```rust
pub async fn fetch_jwks_uri_from_openid_config(config_url: &str) -> Result<String> {
    let client = reqwest::Client::new();
    let OpenIDConfiguration { jwks_uri, .. } = client.get(config_url).send().await?.json().await?;
    Ok(jwks_uri)
}
```

**File:** keyless/pepper/service/src/external_resources/jwk_fetcher.rs (L72-94)
```rust
pub async fn fetch_jwks(jwk_url: &str) -> Result<HashMap<KeyID, Arc<RSA_JWK>>> {
    // Create the request client
    let client = utils::create_request_client();

    // Fetch the JWKs from the URL
    let response = client
        .get(jwk_url)
        .send()
        .await
        .map_err(|error| anyhow!("Failed to fetch JWKs from {}! Error: {}", jwk_url, error))?;

    // Extract the response text
    let response_text = response.text().await.map_err(|error| {
        anyhow!(
            "Failed to extract response text from {}! Error: {}",
            jwk_url,
            error
        )
    })?;

    // Parse the JWKs from the response text
    parse_jwks(&response_text)
}
```

**File:** keyless/pepper/service/src/external_resources/jwk_types.rs (L90-93)
```rust
    async fn fetch_jwks(&self, jwt_issuer: String) -> Result<HashMap<KeyID, Arc<RSA_JWK>>> {
        let jwk_url = format!("{}{}", jwt_issuer, self.issuer_jwk_url_suffix);
        jwk_fetcher::fetch_jwks(&jwk_url).await
    }
```
