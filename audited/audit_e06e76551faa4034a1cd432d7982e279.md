# Audit Report

## Title
Genesis Validator Configuration Overwrite via Duplicate Username

## Summary
The `SetValidatorConfiguration::execute()` function does not validate username uniqueness when writing validator configurations to the genesis repository. Multiple validators using the same username will result in the last writer's configuration overwriting all previous configurations at that path, potentially excluding legitimate validators from the genesis validator set.

## Finding Description

During genesis setup, validators use the `aptos genesis set-validator-configuration` command to submit their configuration files. The configuration directory path is derived solely from the username parameter without any uniqueness checks or collision warnings. [1](#0-0) 

When multiple validators specify the same username, each invocation overwrites the files in that directory. The underlying storage clients (both local filesystem and GitHub) unconditionally overwrite existing files: [2](#0-1) [3](#0-2) 

The Layout structure allows duplicate usernames in its users vector without validation: [4](#0-3) 

While `GenerateGenesis` validates against duplicate addresses during generation, it cannot detect when one validator's configuration was overwritten by another using the same username but different addresses: [5](#0-4) 

**Attack Scenario:**
1. Legitimate validator "alice" runs: `aptos genesis set-validator-configuration --username "validator-alice" --validator-host 1.2.3.4:6180 [alice's keys]`
2. Malicious validator runs: `aptos genesis set-validator-configuration --username "validator-alice" --validator-host 5.6.7.8:6180 [attacker's keys]`
3. Alice's configuration files are completely overwritten
4. If layout.yaml includes "validator-alice", only the attacker's configuration is used in genesis
5. Legitimate validator "alice" is excluded; attacker's node joins instead

## Impact Explanation

This is a **High Severity** vulnerability representing a **Significant Protocol Violation** per Aptos bug bounty criteria.

Genesis establishes the foundational security model of the blockchain by determining the initial validator set. The ability to manipulate this process allows an attacker to:
- Exclude legitimate validators from genesis
- Insert unauthorized validators into the initial validator set
- Potentially gain disproportionate control over network consensus from launch

While this doesn't affect a running network's runtime security, it compromises the integrity of the most critical initialization phase. An incorrect genesis validator set cannot be corrected without network restart or hard fork, making this a high-impact configuration integrity violation.

## Likelihood Explanation

**Likelihood: Medium-to-High** depending on genesis ceremony procedures.

The attack requires:
- Write access to the genesis repository (granted to all participating validators)
- Knowledge of another validator's username (often predictable: company names, public identities)
- Timing: execution before genesis generation

This is realistic in scenarios where:
- Multiple validators submit configurations over an extended period
- Usernames follow predictable patterns (validator-1, validator-2, company names)
- No cryptographic binding between username and validator identity
- Limited out-of-band verification by coordinators

The vulnerability is more exploitable in permissionless or semi-permissionless genesis ceremonies where validator identities are not strictly pre-vetted.

## Recommendation

Implement username uniqueness validation with cryptographic binding:

**Option 1: Pre-flight Check with Warning**
```rust
// In SetValidatorConfiguration::execute(), before line 258:
let git_client = self.git_options.get_client()?;

// Check if configuration already exists
let directory = PathBuf::from(&self.username);
let operator_file = directory.join(OPERATOR_FILE);

match git_client.get::<OperatorConfiguration>(operator_file.as_path()) {
    Ok(existing_config) => {
        // File exists - verify it's the same operator
        if existing_config.operator_account_address != operator_config.operator_account_address {
            return Err(CliError::CommandArgumentError(format!(
                "Username '{}' already exists with different operator address {}. Use a unique username or verify you're updating your own configuration.",
                self.username,
                existing_config.operator_account_address
            )));
        }
        eprintln!("Warning: Updating existing configuration for username '{}'", self.username);
    },
    Err(_) => {
        // File doesn't exist, proceed with creation
    }
}

git_client.put(operator_file.as_path(), &operator_config)?;
git_client.put(owner_file.as_path(), &owner_config)
```

**Option 2: Layout Validation**
Add duplicate username check in Layout deserialization:
```rust
impl Layout {
    pub fn from_disk(path: &Path) -> anyhow::Result<Self> {
        // ... existing code ...
        let layout: Layout = serde_yaml::from_str(&contents)?;
        
        // Validate unique usernames
        let mut seen = HashSet::new();
        for user in &layout.users {
            if !seen.insert(user) {
                return Err(anyhow::Error::msg(format!(
                    "Duplicate username '{}' in layout.yaml. Each validator must have a unique username.",
                    user
                )));
            }
        }
        
        Ok(layout)
    }
}
```

## Proof of Concept

```rust
// Test demonstrating configuration overwrite
// File: crates/aptos/src/genesis/keys_test.rs

#[tokio::test]
async fn test_duplicate_username_overwrites_config() {
    use tempfile::TempDir;
    use std::path::PathBuf;
    
    // Setup: Create temporary repository
    let temp_dir = TempDir::new().unwrap();
    let repo_path = temp_dir.path().to_path_buf();
    
    // Validator 1 submits configuration
    let validator1_config = SetValidatorConfiguration {
        username: "test-validator".to_string(),
        validator_host: HostAndPort::from_str("192.168.1.1:6180").unwrap(),
        full_node_host: None,
        stake_amount: 100_000_000,
        commission_percentage: 10,
        join_during_genesis: true,
        owner_public_identity_file: Some(PathBuf::from("validator1/public-keys.yaml")),
        operator_public_identity_file: None,
        voter_public_identity_file: None,
        git_options: GitOptions {
            local_repository_dir: Some(repo_path.clone()),
            ..Default::default()
        },
    };
    
    // Execute - writes validator1's config
    validator1_config.execute().await.unwrap();
    
    // Verify validator1's config exists
    let config_path = repo_path.join("test-validator").join("operator.yaml");
    let config1 = std::fs::read_to_string(&config_path).unwrap();
    assert!(config1.contains("192.168.1.1"));
    
    // Validator 2 submits configuration with SAME username
    let validator2_config = SetValidatorConfiguration {
        username: "test-validator".to_string(), // SAME USERNAME!
        validator_host: HostAndPort::from_str("10.0.0.1:6180").unwrap(),
        full_node_host: None,
        stake_amount: 200_000_000,
        commission_percentage: 15,
        join_during_genesis: true,
        owner_public_identity_file: Some(PathBuf::from("validator2/public-keys.yaml")),
        operator_public_identity_file: None,
        voter_public_identity_file: None,
        git_options: GitOptions {
            local_repository_dir: Some(repo_path.clone()),
            ..Default::default()
        },
    };
    
    // Execute - OVERWRITES validator1's config
    validator2_config.execute().await.unwrap();
    
    // Verify validator1's config is GONE, replaced by validator2
    let config2 = std::fs::read_to_string(&config_path).unwrap();
    assert!(!config2.contains("192.168.1.1")); // Validator1 IP gone
    assert!(config2.contains("10.0.0.1"));     // Validator2 IP present
    
    // Validator 1's configuration has been silently overwritten!
}
```

## Notes

This vulnerability specifically affects the genesis setup phase, which is a critical one-time operation. While genesis ceremonies typically involve coordination and review, the code-level lack of validation creates a exploitable window during the configuration submission period. The issue is particularly concerning for permissionless or semi-permissionless genesis ceremonies where validators may not be fully trusted or closely coordinated.

The validation during `GenerateGenesis` only catches duplicate addresses, not configuration overwrites where the attacker uses different addresses. A coordinator would need to manually verify each configuration file's integrity to detect this attack, which is error-prone for large validator sets.

### Citations

**File:** crates/aptos/src/genesis/keys.rs (L254-260)
```rust
        let directory = PathBuf::from(&self.username);
        let operator_file = directory.join(OPERATOR_FILE);
        let owner_file = directory.join(OWNER_FILE);

        let git_client = self.git_options.get_client()?;
        git_client.put(operator_file.as_path(), &operator_config)?;
        git_client.put(owner_file.as_path(), &owner_config)
```

**File:** crates/aptos/src/genesis/git.rs (L187-213)
```rust
    pub fn put<T: Serialize + ?Sized>(&self, name: &Path, input: &T) -> CliTypedResult<()> {
        match self {
            Client::Local(local_repository_path) => {
                let path = local_repository_path.join(name);

                // Create repository path and any sub-directories
                if let Some(dir) = path.parent() {
                    self.create_dir(dir)?;
                } else {
                    return Err(CliError::UnexpectedError(format!(
                        "Path should always have a parent {}",
                        path.display()
                    )));
                }
                write_to_file(
                    path.as_path(),
                    &path.display().to_string(),
                    to_yaml(input)?.as_bytes(),
                )?;
            },
            Client::Github(client) => {
                client.put(&name.display().to_string(), &to_base64_encoded_yaml(input)?)?;
            },
        }

        Ok(())
    }
```

**File:** crates/aptos-github-client/src/lib.rs (L168-188)
```rust
    pub fn put(&self, path: &str, content: &str) -> Result<(), Error> {
        let json = match self.get_sha(path) {
            Ok(hash) => {
                json!({ "branch": self.branch.to_string(), "content": content, "message": format!("[aptos-management] {}", path), "sha": hash })
            },
            Err(Error::NotFound(_)) => {
                json!({ "branch": self.branch.to_string(), "content": content, "message": format!("[aptos-management] {}", path) })
            },
            Err(e) => return Err(e),
        };

        let resp = self
            .upgrade_request(ureq::put(&self.post_url(path)))
            .send_json(json);

        match resp.status() {
            200 => Ok(()),
            201 => Ok(()),
            _ => Err(resp.into()),
        }
    }
```

**File:** crates/aptos-genesis/src/config.rs (L30-35)
```rust
pub struct Layout {
    /// Root key for the blockchain only for test chains
    #[serde(default)]
    pub root_key: Option<Ed25519PublicKey>,
    /// List of usernames or identifiers
    pub users: Vec<String>,
```

**File:** crates/aptos/src/genesis/mod.rs (L322-349)
```rust
fn get_validator_configs(
    client: &Client,
    layout: &Layout,
    is_mainnet: bool,
) -> Result<Vec<ValidatorConfiguration>, Vec<String>> {
    let mut validators = Vec::new();
    let mut errors = Vec::new();
    for user in &layout.users {
        match get_config(client, user, is_mainnet) {
            Ok(validator) => {
                validators.push(validator);
            },
            Err(failure) => {
                if let CliError::UnexpectedError(failure) = failure {
                    errors.push(format!("{}: {}", user, failure));
                } else {
                    errors.push(format!("{}: {:?}", user, failure));
                }
            },
        }
    }

    if errors.is_empty() {
        Ok(validators)
    } else {
        Err(errors)
    }
}
```
