# Audit Report

## Title
Missing Epoch State Verification in Branch 1 of `maybe_select_chunk_ending_ledger_info` Allows Validator Set Confusion

## Summary
The `StateSyncChunkVerifier::maybe_select_chunk_ending_ledger_info` function contains a critical defense-in-depth vulnerability where Branch 1 (lines 80-88) fails to verify that the `next_epoch_state` in `verified_target_li` matches the locally computed `next_epoch_state` from transaction execution. This creates an inconsistency with Branch 2 (lines 89-117) which explicitly performs this validation at lines 112-116. If a maliciously signed epoch-ending ledger info reaches the execution layer, Branch 1 would accept it without validating the validator set, enabling potential validator set confusion and chain splits.

## Finding Description

The vulnerability exists in the conditional logic of `maybe_select_chunk_ending_ledger_info`: [1](#0-0) 

**Branch 1** (when `li.version() + 1 == txn_accumulator.num_leaves()`): [2](#0-1) 

This branch only validates the transaction accumulator hash but **does not verify `next_epoch_state`**, even when `verified_target_li` is an epoch-ending ledger info.

**Branch 2** (when `epoch_change_li` is provided): [3](#0-2) 

This branch explicitly validates `next_epoch_state` at lines 112-116: [4](#0-3) 

**The Attack Path:**

1. During consensus or through a consensus bug, 2f+1 Byzantine validators sign a `LedgerInfoWithSignatures` containing:
   - Correct `transaction_accumulator_hash` 
   - Correct `version`
   - `ends_epoch() == true`
   - **Malicious/incorrect `next_epoch_state`** (wrong validator set)

2. This malicious ledger info passes BLS signature verification and becomes `verified_target_li` during state sync: [5](#0-4) 

3. An honest node executes transactions locally, computing the **correct** `next_epoch_state`: [6](#0-5) 

4. The node calls `maybe_select_chunk_ending_ledger_info`: [7](#0-6) 

5. If `verified_target_li.version() + 1 == txn_accumulator.num_leaves()`, Branch 1 is taken, which **skips the `next_epoch_state` validation**

6. The malicious `verified_target_li` is accepted and committed to storage: [8](#0-7) 

7. Storage layer also lacks `next_epoch_state` content validation: [9](#0-8) 

The storage layer only validates version, root hash, epoch continuity, and state snapshot existence, but **not the content of `next_epoch_state`**.

**Why This Breaks Invariants:**

- **Consensus Safety (Invariant #2)**: Different nodes could accept different validator sets for the next epoch, causing chain splits
- **Deterministic Execution (Invariant #1)**: The locally computed `next_epoch_state` (correct) is overridden by the ledger info's `next_epoch_state` (malicious)
- **Defense-in-Depth**: The execution layer fails to independently verify what consensus claims

## Impact Explanation

**Critical Severity** - This vulnerability enables **Consensus/Safety violations** and **Non-recoverable network partition**:

1. **Validator Set Confusion**: Nodes commit different validator sets for epoch N+1
2. **Chain Split**: When transitioning to epoch N+1, nodes using different validator sets cannot reach consensus on blocks
3. **Network Partition**: The network splits into multiple incompatible chains, each following different validator sets
4. **Requires Hardfork**: Recovery requires manual intervention and potentially a hardfork to re-establish canonical validator set

This directly violates Aptos's core BFT safety guarantee that nodes should never commit different chains under < 1/3 Byzantine validators. Even if the attack requires Byzantine validator collusion, the missing check represents a critical defense-in-depth failure that could amplify consensus bugs or enable attacks during edge cases.

## Likelihood Explanation

**Likelihood: Medium-to-High** given that:

1. **Defense-in-Depth Failure**: Even if consensus normally prevents malicious ledger infos, the execution layer should independently verify. The inconsistency between Branch 1 and Branch 2 shows developers knew this check was critical.

2. **Amplifies Consensus Bugs**: Any future consensus bug that allows incorrect ledger infos to be signed would bypass execution-layer protection in Branch 1.

3. **State Sync Attack Surface**: During bootstrap or recovery, nodes rely heavily on state sync. A sophisticated attacker could exploit this during these vulnerable periods.

4. **Epoch Boundaries Are Critical**: Epoch transitions are high-risk periods where validator set changes occur. Any vulnerability here has amplified impact.

5. **The Question Explicitly Considers Malicious Validators**: The security review scope includes validator-level attacks at epoch boundaries.

## Recommendation

Add `next_epoch_state` validation to Branch 1, mirroring the check in Branch 2:

```rust
fn maybe_select_chunk_ending_ledger_info(
    &self,
    ledger_update_output: &LedgerUpdateOutput,
    next_epoch_state: Option<&EpochState>,
) -> Result<Option<LedgerInfoWithSignatures>> {
    let li = self.verified_target_li.ledger_info();
    let txn_accumulator = &ledger_update_output.transaction_accumulator;

    if li.version() + 1 == txn_accumulator.num_leaves() {
        // If the chunk corresponds to the target LI, the target LI can be added to storage.
        ensure!(
            li.transaction_accumulator_hash() == txn_accumulator.root_hash(),
            "Root hash in target ledger info does not match local computation. {:?} != {:?}",
            li,
            txn_accumulator,
        );
        
        // ADD THIS CHECK: Verify next_epoch_state matches if this is an epoch-ending LI
        if li.ends_epoch() {
            ensure!(
                li.next_epoch_state() == next_epoch_state,
                "Next epoch state in verified target LI does not match local computation. {:?} vs {:?}",
                li.next_epoch_state(),
                next_epoch_state,
            );
        }
        
        Ok(Some(self.verified_target_li.clone()))
    } else if let Some(epoch_change_li) = &self.epoch_change_li {
        // ... rest of Branch 2 unchanged ...
```

This ensures consistent validation regardless of which branch is taken, providing proper defense-in-depth.

## Proof of Concept

```rust
// Conceptual PoC - demonstrates the logic flaw
// Location: execution/executor/src/chunk_executor/chunk_result_verifier.rs

#[test]
fn test_branch1_missing_epoch_state_check() {
    // Setup: Create a chunk that ends at verified_target_li version
    let verified_target_li = create_epoch_ending_li_with_wrong_validator_set();
    let epoch_change_li = None; // Not provided, so Branch 1 will be taken
    
    // Execute transactions locally - produces correct next_epoch_state
    let local_next_epoch_state = execute_epoch_ending_transactions();
    
    let verifier = StateSyncChunkVerifier {
        txn_infos_with_proof: create_valid_proof(),
        verified_target_li: verified_target_li.clone(),
        epoch_change_li,
    };
    
    // Call maybe_select_chunk_ending_ledger_info
    let result = verifier.maybe_select_chunk_ending_ledger_info(
        &ledger_update_output,
        Some(&local_next_epoch_state),
    );
    
    // BUG: This should fail but succeeds!
    // Branch 1 is taken (version matches), and it doesn't check next_epoch_state
    assert!(result.is_ok()); // Vulnerability: malicious LI accepted
    
    // The returned LI has wrong validator set
    let returned_li = result.unwrap().unwrap();
    assert_ne!(
        returned_li.ledger_info().next_epoch_state(),
        Some(&local_next_epoch_state)
    ); // Different validator sets!
}
```

**Exploitation Steps:**
1. Attacker needs 2f+1 Byzantine validators to sign malicious epoch-ending ledger info
2. Ensure the ledger info has correct `transaction_accumulator_hash` and `version`
3. Include malicious `next_epoch_state` with attacker-controlled validator set
4. Propagate this as `verified_target_li` during state sync
5. Honest nodes take Branch 1 and accept without validation
6. Network splits when entering next epoch with different validator sets

**Notes**

This vulnerability represents a critical defense-in-depth failure in the Aptos execution layer. While BFT consensus should prevent malicious ledger infos under normal operation with < f+1 Byzantine validators, the execution layer must independently verify all committed data. The inconsistency between Branch 1 (missing check) and Branch 2 (has check) indicates this was an oversight rather than intentional design. The check exists in Branch 2 precisely because validator set correctness is critical for consensus safety - it must also exist in Branch 1.

### Citations

**File:** execution/executor/src/chunk_executor/chunk_result_verifier.rs (L72-127)
```rust
    fn maybe_select_chunk_ending_ledger_info(
        &self,
        ledger_update_output: &LedgerUpdateOutput,
        next_epoch_state: Option<&EpochState>,
    ) -> Result<Option<LedgerInfoWithSignatures>> {
        let li = self.verified_target_li.ledger_info();
        let txn_accumulator = &ledger_update_output.transaction_accumulator;

        if li.version() + 1 == txn_accumulator.num_leaves() {
            // If the chunk corresponds to the target LI, the target LI can be added to storage.
            ensure!(
                li.transaction_accumulator_hash() == txn_accumulator.root_hash(),
                "Root hash in target ledger info does not match local computation. {:?} != {:?}",
                li,
                txn_accumulator,
            );
            Ok(Some(self.verified_target_li.clone()))
        } else if let Some(epoch_change_li) = &self.epoch_change_li {
            // If the epoch change LI is present, it must match the version of the chunk:
            let li = epoch_change_li.ledger_info();

            // Verify that the given ledger info corresponds to the new accumulator.
            ensure!(
                li.transaction_accumulator_hash() == txn_accumulator.root_hash(),
                "Root hash of a given epoch LI does not match local computation. {:?} vs {:?}",
                li,
                txn_accumulator,
            );
            ensure!(
                li.version() + 1 == txn_accumulator.num_leaves(),
                "Version of a given epoch LI does not match local computation. {:?} vs {:?}",
                li,
                txn_accumulator,
            );
            ensure!(
                li.ends_epoch(),
                "Epoch change LI does not carry validator set. version:{}",
                li.version(),
            );
            ensure!(
                li.next_epoch_state() == next_epoch_state,
                "New validator set of a given epoch LI does not match local computation. {:?} vs {:?}",
                li.next_epoch_state(),
                next_epoch_state,
            );
            Ok(Some(epoch_change_li.clone()))
        } else {
            ensure!(
                next_epoch_state.is_none(),
                "End of epoch chunk based on local computation but no EoE LedgerInfo provided. version: {:?}",
                txn_accumulator.num_leaves().checked_sub(1),
            );
            Ok(None)
        }
    }
}
```

**File:** execution/executor/src/chunk_executor/mod.rs (L114-156)
```rust
    fn enqueue_chunk_by_execution(
        &self,
        txn_list_with_proof: TransactionListWithProofV2,
        verified_target_li: &LedgerInfoWithSignatures,
        epoch_change_li: Option<&LedgerInfoWithSignatures>,
    ) -> Result<()> {
        let _guard = CONCURRENCY_GAUGE.concurrency_with(&["chunk", "enqueue_by_execution"]);
        let _timer = EXECUTE_CHUNK.start_timer();

        self.maybe_initialize()?;

        // Verify input data.
        // In consensus-only mode, txn_list_with_proof is fake.
        if !cfg!(feature = "consensus-only-perf-test") {
            txn_list_with_proof.verify(
                verified_target_li.ledger_info(),
                txn_list_with_proof.get_first_transaction_version(),
            )?;
        }

        let (txn_list_with_proof, persisted_aux_info) = txn_list_with_proof.into_parts();
        // Compose enqueue_chunk parameters.
        let TransactionListWithProof {
            transactions,
            events: _,
            first_transaction_version: v,
            proof: txn_infos_with_proof,
        } = txn_list_with_proof;

        let chunk = ChunkToExecute {
            transactions,
            persisted_aux_info,
            first_version: v.ok_or_else(|| anyhow!("first version is None"))?,
        };
        let chunk_verifier = Arc::new(StateSyncChunkVerifier {
            txn_infos_with_proof,
            verified_target_li: verified_target_li.clone(),
            epoch_change_li: epoch_change_li.cloned(),
        });

        // Call the shared implementation.
        self.with_inner(|inner| inner.enqueue_chunk(chunk, chunk_verifier, "execute"))
    }
```

**File:** execution/executor/src/chunk_executor/mod.rs (L261-287)
```rust
    fn commit_chunk_impl(&self) -> Result<ExecutedChunk> {
        let _timer = CHUNK_OTHER_TIMERS.timer_with(&["commit_chunk_impl__total"]);
        let chunk = {
            let _timer =
                CHUNK_OTHER_TIMERS.timer_with(&["commit_chunk_impl__next_chunk_to_commit"]);
            self.commit_queue.lock().next_chunk_to_commit()?
        };

        let output = chunk.output.expect_complete_result();
        let num_txns = output.num_transactions_to_commit();
        if chunk.ledger_info_opt.is_some() || num_txns != 0 {
            let _timer = CHUNK_OTHER_TIMERS.timer_with(&["commit_chunk_impl__save_txns"]);
            // TODO(aldenhu): remove since there's no practical strategy to recover from this error.
            fail_point!("executor::commit_chunk", |_| {
                Err(anyhow::anyhow!("Injected error in commit_chunk"))
            });
            self.db.writer.save_transactions(
                output.as_chunk_to_commit(),
                chunk.ledger_info_opt.as_ref(),
                false, // sync_commit
            )?;
        }

        let _timer = CHUNK_OTHER_TIMERS.timer_with(&["commit_chunk_impl__dequeue_and_return"]);
        self.commit_queue.lock().dequeue_committed()?;

        Ok(chunk)
```

**File:** execution/executor/src/chunk_executor/mod.rs (L367-370)
```rust
        let ledger_info_opt = chunk_verifier.maybe_select_chunk_ending_ledger_info(
            &ledger_update_output,
            output.execution_output.next_epoch_state.as_ref(),
        )?;
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L520-540)
```rust
    fn ensure_next_epoch_state(to_commit: &TransactionsWithOutput) -> Result<EpochState> {
        let last_write_set = to_commit
            .transaction_outputs
            .last()
            .ok_or_else(|| anyhow!("to_commit is empty."))?
            .write_set();

        let write_set_view = WriteSetStateView {
            write_set: last_write_set,
        };

        let validator_set = ValidatorSet::fetch_config(&write_set_view)
            .ok_or_else(|| anyhow!("ValidatorSet not touched on epoch change"))?;
        let configuration = ConfigurationResource::fetch_config(&write_set_view)
            .ok_or_else(|| anyhow!("Configuration resource not touched on epoch change"))?;

        Ok(EpochState::new(
            configuration.epoch(),
            (&validator_set).into(),
        ))
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L540-600)
```rust
    fn check_and_put_ledger_info(
        &self,
        version: Version,
        ledger_info_with_sig: &LedgerInfoWithSignatures,
        ledger_batch: &mut SchemaBatch,
    ) -> Result<(), AptosDbError> {
        let ledger_info = ledger_info_with_sig.ledger_info();

        // Verify the version.
        ensure!(
            ledger_info.version() == version,
            "Version in LedgerInfo doesn't match last version. {:?} vs {:?}",
            ledger_info.version(),
            version,
        );

        // Verify the root hash.
        let db_root_hash = self
            .ledger_db
            .transaction_accumulator_db()
            .get_root_hash(version)?;
        let li_root_hash = ledger_info_with_sig
            .ledger_info()
            .transaction_accumulator_hash();
        ensure!(
            db_root_hash == li_root_hash,
            "Root hash pre-committed doesn't match LedgerInfo. pre-commited: {:?} vs in LedgerInfo: {:?}",
            db_root_hash,
            li_root_hash,
        );

        // Verify epoch continuity.
        let current_epoch = self
            .ledger_db
            .metadata_db()
            .get_latest_ledger_info_option()
            .map_or(0, |li| li.ledger_info().next_block_epoch());
        ensure!(
            ledger_info_with_sig.ledger_info().epoch() == current_epoch,
            "Gap in epoch history. Trying to put in LedgerInfo in epoch: {}, current epoch: {}",
            ledger_info_with_sig.ledger_info().epoch(),
            current_epoch,
        );

        // Ensure that state tree at the end of the epoch is persisted.
        if ledger_info_with_sig.ledger_info().ends_epoch() {
            let state_snapshot = self.state_store.get_state_snapshot_before(version + 1)?;
            ensure!(
                state_snapshot.is_some() && state_snapshot.as_ref().unwrap().0 == version,
                "State checkpoint not persisted at the end of the epoch, version {}, next_epoch {}, snapshot in db: {:?}",
                version,
                ledger_info_with_sig.ledger_info().next_block_epoch(),
                state_snapshot,
            );
        }

        // Put write to batch.
        self.ledger_db
            .metadata_db()
            .put_ledger_info(ledger_info_with_sig, ledger_batch)?;
        Ok(())
```
