# Audit Report

## Title
Path Traversal Vulnerability in State Snapshot Restore via Unvalidated FileHandles

## Summary
The `StateSnapshotChunk` structure's `blobs` and `proof` FileHandles can contain arbitrary path strings (including path traversal sequences like `../` or absolute paths) that are deserialized without validation and directly used in filesystem operations, enabling attackers to read arbitrary files outside the backup directory during restore operations.

## Finding Description

The vulnerability exists in the backup/restore system's handling of `FileHandle` references in state snapshot manifests. [1](#0-0) 

The `FileHandle` type is merely a String alias with no validation or sanitization. The `StateSnapshotChunk` structure contains two critical FileHandles: [2](#0-1) 

During the restore process, manifests are deserialized from JSON without any path validation: [3](#0-2) 

The FileHandles from chunk data are then used to read files: [4](#0-3) 

Which internally calls: [5](#0-4) 

For the LocalFs storage implementation, the `open_for_read` method performs an unsafe path join operation: [6](#0-5) 

The vulnerability chain is:
1. Attacker crafts malicious state snapshot manifest with FileHandles containing path traversal sequences (e.g., `../../../../etc/passwd`) or absolute paths (e.g., `/etc/passwd`)
2. Metadata files reference this malicious manifest: [7](#0-6) 
3. Metadata is deserialized without validation: [8](#0-7) 
4. During restore, Rust's `Path::join()` behavior allows the traversal to escape the backup directory
5. Arbitrary files are read and potentially processed as blockchain state data

**Attack Scenarios:**
- **Information Disclosure**: Read sensitive files like private keys, configuration files, or system files from the validator node
- **State Corruption**: If arbitrary file contents are processed as state data, could corrupt the restored database
- **Restore Failure**: Cause restore operations to fail by pointing to non-existent or incompatible files

## Impact Explanation

This vulnerability qualifies as **HIGH severity** under the Aptos bug bounty program for the following reasons:

1. **Significant Protocol Violation**: Violates the security boundary assumption that backup storage operations are confined to designated directories
2. **Validator Node Impact**: Can affect validator nodes during restore operations, potentially exposing sensitive configuration data or cryptographic material
3. **State Integrity Risk**: If malicious file contents are processed as state data, could lead to database corruption requiring manual intervention

While not CRITICAL (doesn't directly steal funds or break consensus during normal operations), this vulnerability:
- Enables arbitrary file system access from validator nodes
- Could expose validator private keys if stored on the same filesystem
- May cause validator node operational failures
- Breaks the fundamental security assumption that backup/restore operations are sandboxed

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

**Attack Prerequisites:**
- Attacker must control or compromise the backup storage source
- OR perform man-in-the-middle attack during backup metadata sync
- OR social engineer node operators to use a malicious backup source

**Feasibility:**
- **Easy to exploit** once prerequisites are met - simply requires crafting JSON manifests with malicious paths
- **No special privileges** required beyond controlling the backup source
- **No cryptographic bypasses** needed
- **No race conditions** or timing requirements

**Real-world scenarios:**
- Compromised cloud storage buckets (misconfigured S3/GCS permissions)
- Malicious backup providers
- Supply chain attacks on backup infrastructure
- Insider threats from operators with backup storage access

The likelihood increases significantly if:
- Backup storage credentials are leaked
- Operators use untrusted or unverified backup sources
- Network-level MITM is possible during metadata synchronization

## Recommendation

**Immediate Fix: Implement Path Validation**

Add validation to sanitize and verify FileHandles before filesystem operations:

```rust
// In storage/backup/backup-cli/src/storage/local_fs/mod.rs

async fn open_for_read(
    &self,
    file_handle: &FileHandleRef,
) -> Result<Box<dyn AsyncRead + Send + Unpin>> {
    // Validate file_handle doesn't escape backup directory
    let requested_path = PathBuf::from(file_handle);
    
    // Reject absolute paths
    if requested_path.is_absolute() {
        bail!("Absolute paths not allowed in FileHandle: {}", file_handle);
    }
    
    // Reject paths with parent directory traversal
    for component in requested_path.components() {
        if matches!(component, std::path::Component::ParentDir) {
            bail!("Path traversal not allowed in FileHandle: {}", file_handle);
        }
    }
    
    let path = self.dir.join(file_handle);
    
    // Canonicalize and verify final path is within backup directory
    let canonical_path = path.canonicalize()
        .or_else(|_| bail!("Invalid file path: {}", file_handle))?;
    let canonical_dir = self.dir.canonicalize()?;
    
    if !canonical_path.starts_with(&canonical_dir) {
        bail!("FileHandle escapes backup directory: {}", file_handle);
    }
    
    let file = OpenOptions::new()
        .read(true)
        .open(&canonical_path)
        .await
        .err_notes(&canonical_path)?;
    Ok(Box::new(file))
}
```

**Additional Hardening:**
1. Apply same validation in `create_for_write` and `backup_metadata_file` methods
2. Consider using a whitelist approach for allowed path patterns
3. Add similar validation for CommandAdapter storage backend
4. Implement cryptographic signing of manifest files to prevent tampering
5. Add audit logging for all file access during restore operations

## Proof of Concept

**Step 1: Create malicious state snapshot manifest**

```json
{
  "version": 1000,
  "epoch": 10,
  "root_hash": "0x0000000000000000000000000000000000000000000000000000000000000000",
  "chunks": [
    {
      "first_idx": 0,
      "last_idx": 99,
      "first_key": "0x0000000000000000000000000000000000000000000000000000000000000000",
      "last_key": "0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff",
      "blobs": "../../../../etc/passwd",
      "proof": "../../../../etc/hostname"
    }
  ],
  "proof": "legitimate_proof_file"
}
```

**Step 2: Create metadata file referencing malicious manifest**

```json
{"StateSnapshotBackup":{"epoch":10,"version":1000,"manifest":"malicious_snapshot.json"}}
```

**Step 3: Trigger restore operation**

```bash
# Assuming LocalFs backup storage at /backup_dir
# Place malicious manifest at /backup_dir/malicious_snapshot.json
# Place metadata in /backup_dir/metadata/

aptos-db-tool restore \
  --local-fs-dir /backup_dir \
  --target-db-dir /tmp/restored_db \
  --target-version 1000
```

**Expected vulnerable behavior:**
- System attempts to read `/etc/passwd` and `/etc/hostname` instead of backup files
- File contents are processed as state data
- Potential information disclosure or restore failure

**Expected secure behavior (after fix):**
- System detects path traversal attempt
- Restore operation fails with clear error message
- No files outside backup directory are accessed

## Notes

This vulnerability demonstrates a critical gap in input validation for externally-provided file paths. While the backup/restore system is typically operated by trusted administrators, the security model should assume backups themselves may be compromised or tampered with. Defense-in-depth principles require validating all external inputs, including file paths from deserialized manifests.

### Citations

**File:** storage/backup/backup-cli/src/storage/mod.rs (L36-41)
```rust
/// URI pointing to a file in a backup storage, like "s3:///bucket/path/file".
/// These are created by the storage when `create_for_write()`, stored in manifests by the backup
/// controller, and passed back to the storage when `open_for_read()` by the restore controller
/// to retrieve a file referred to in the manifest.
pub type FileHandle = String;
pub type FileHandleRef = str;
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/manifest.rs (L12-27)
```rust
pub struct StateSnapshotChunk {
    /// index of the first account in this chunk over all accounts.
    pub first_idx: usize,
    /// index of the last account in this chunk over all accounts.
    pub last_idx: usize,
    /// key of the first account in this chunk.
    pub first_key: HashValue,
    /// key of the last account in this chunk.
    pub last_key: HashValue,
    /// Repeated `len(record) + record` where `record` is BCS serialized tuple
    /// `(key, state_value)`
    pub blobs: FileHandle,
    /// BCS serialized `SparseMerkleRangeProof` that proves this chunk adds up to the root hash
    /// indicated in the backup (`StateSnapshotBackup::root_hash`).
    pub proof: FileHandle,
}
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L123-124)
```rust
        let manifest: StateSnapshotBackup =
            self.storage.load_json_file(&self.manifest_handle).await?;
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L191-192)
```rust
                    let blobs = Self::read_state_value(&storage, chunk.blobs.clone()).await?;
                    let proof = storage.load_bcs_file(&chunk.proof).await?;
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L253-257)
```rust
    async fn read_state_value(
        storage: &Arc<dyn BackupStorage>,
        file_handle: FileHandle,
    ) -> Result<Vec<(StateKey, StateValue)>> {
        let mut file = storage.open_for_read(&file_handle).await?;
```

**File:** storage/backup/backup-cli/src/storage/local_fs/mod.rs (L98-109)
```rust
    async fn open_for_read(
        &self,
        file_handle: &FileHandleRef,
    ) -> Result<Box<dyn AsyncRead + Send + Unpin>> {
        let path = self.dir.join(file_handle);
        let file = OpenOptions::new()
            .read(true)
            .open(&path)
            .await
            .err_notes(&path)?;
        Ok(Box::new(file))
    }
```

**File:** storage/backup/backup-cli/src/metadata/mod.rs (L184-189)
```rust
#[derive(Clone, Debug, Deserialize, Serialize, Eq, PartialEq, Ord, PartialOrd)]
pub struct StateSnapshotBackupMeta {
    pub epoch: u64,
    pub version: Version,
    pub manifest: FileHandle,
}
```

**File:** storage/backup/backup-cli/src/metadata/cache.rs (L237-246)
```rust
    async fn load_metadata_lines(&mut self) -> Result<Vec<Metadata>> {
        let mut buf = String::new();
        self.read_to_string(&mut buf)
            .await
            .err_notes((file!(), line!(), &buf))?;
        Ok(buf
            .lines()
            .map(serde_json::from_str::<Metadata>)
            .collect::<Result<_, serde_json::error::Error>>()?)
    }
```
