# Audit Report

## Title
Validator Transactions Become Invalid During Same-Block Epoch Transitions

## Summary
During epoch transitions, the `pull()` method in the validator transaction pool can return validator transactions that become invalid by the time they are executed, causing deterministic execution failures. This occurs because block proposal pulls validator transactions before knowing if the block will trigger an epoch transition, and the execution order places `BlockMetadata` (which increments the epoch) before validator transactions.

## Finding Description

The vulnerability exists in the interaction between three components:

1. **Transaction Pulling** - The proposal generator pulls validator transactions from the pool without checking if the current block will trigger an epoch transition. [1](#0-0) 

2. **Execution Order** - Transactions are executed in a strict order: BlockMetadata first, then validator transactions, then user transactions. [2](#0-1) 

3. **Epoch Validation** - Validator transactions (specifically DKGResult) validate that their embedded epoch matches the current on-chain epoch. [3](#0-2) 

**Attack Path:**

1. During epoch N, a DKG manager creates a `ValidatorTransaction::DKGResult` with `epoch: N` and places it in the pool. [4](#0-3) 

2. Consensus pulls this transaction via `pull()` to include in a block at a timestamp satisfying: `timestamp - last_reconfiguration_time >= epoch_interval`.

3. During block execution, `BlockMetadata` is processed first, which calls `block_prologue()` or `block_prologue_ext()`. [5](#0-4) 

4. If using immediate reconfiguration (non-DKG path), this triggers `reconfiguration::reconfigure()`, incrementing the epoch to N+1.

5. Subsequently, the `ValidatorTransaction::DKGResult` is executed with `epoch: N`, but the on-chain epoch is now N+1.

6. Epoch validation fails with `EpochNotCurrent` error, and the transaction is discarded with `TransactionStatus::Discard(StatusCode::ABORTED)`. [6](#0-5) 

**Invariant Violations:**

- **Deterministic Execution**: While all validators deterministically discard the transaction, the expectation that pulled validator transactions should be valid is violated.
- **Transaction Validation**: Validator transactions returned by `pull()` should be executable, but they become invalid mid-block.

## Impact Explanation

**Severity: High** (Significant Protocol Violation)

This vulnerability causes validator transaction execution failures during epoch transitions:

1. **DKG Process Disruption**: If a DKGResult transaction is discarded, the distributed key generation process may fail or be delayed, affecting randomness availability for the new epoch.

2. **Epoch Transition Reliability**: The system relies on validator transactions for critical epoch transition operations. Discarding them creates operational issues.

3. **Resource Waste**: Consensus bandwidth and execution resources are wasted on transactions that are deterministically discarded.

4. **Timing-Dependent Behavior**: The bug only manifests when block timestamps cross epoch boundaries, making it timing-dependent and potentially surprising.

While this doesn't cause consensus splits (all nodes deterministically discard the transaction), it represents a significant protocol violation affecting the reliability of epoch transitions.

## Likelihood Explanation

**Likelihood: Medium-High**

This issue occurs when:
- A validator transaction is in the pool for epoch N
- A block is proposed with a timestamp that triggers epoch transition
- The system uses immediate reconfiguration (non-DKG path)

The likelihood increases when:
- Epoch intervals are short
- Multiple validator transactions exist in the pool near epoch boundaries
- The `reconfigure()` path is used instead of DKG-based reconfiguration

The reconfiguration suffix rule prevents FUTURE blocks from including validator transactions after reconfiguration is detected, but it doesn't prevent the reconfiguration-triggering block itself from containing them. [7](#0-6) 

## Recommendation

**Fix: Check for potential epoch transition before pulling validator transactions**

Modify the proposal generator to check if the current timestamp would trigger an epoch transition BEFORE pulling validator transactions. If an epoch transition will occur, skip pulling validator transactions entirely.

```rust
// In proposal_generator.rs, around line 600-650
let timestamp = self.time_service.get_current_timestamp();

// NEW: Check if this block will trigger reconfiguration
let will_trigger_reconfig = self.will_trigger_reconfiguration(timestamp).await;

let validator_txn_filter = if will_trigger_reconfig {
    // Don't pull validator transactions if we're about to reconfigure
    vtxn_pool::TransactionFilter::PendingTxnHashSet(HashSet::new())
} else {
    // Normal case: filter only pending transactions
    let pending_validator_txn_hashes: HashSet<HashValue> = pending_blocks
        .iter()
        .filter_map(|block| block.validator_txns())
        .flatten()
        .map(ValidatorTransaction::hash)
        .collect();
    vtxn_pool::TransactionFilter::PendingTxnHashSet(pending_validator_txn_hashes)
};
```

Add a helper method to check for pending reconfiguration:

```rust
async fn will_trigger_reconfiguration(&self, timestamp: Duration) -> bool {
    // Query the state to get last_reconfiguration_time and epoch_interval
    // This requires access to the state view, which may need to be passed in
    // Return true if: timestamp - last_reconfiguration_time >= epoch_interval
    // Implementation details depend on available state access
    false // Placeholder
}
```

**Alternative Fix: Coordinate epoch transitions with validator transaction pool cleanup**

Ensure that when an epoch transition is imminent, the validator transaction pool is cleared of transactions from the previous epoch BEFORE blocks are proposed.

## Proof of Concept

```rust
// Rust integration test demonstrating the issue
#[tokio::test]
async fn test_validator_txn_invalid_during_epoch_transition() {
    // Setup: Create a test environment with:
    // 1. Epoch N with epoch_interval set to a small value
    // 2. A DKGResult transaction in the validator pool for epoch N
    // 3. Advance time so next block timestamp will trigger reconfiguration
    
    let mut executor = TestExecutor::new();
    executor.set_epoch_interval(1000000); // 1 second
    
    // Create and add DKG transaction for current epoch
    let current_epoch = executor.get_current_epoch();
    let dkg_txn = ValidatorTransaction::DKGResult(DKGTranscript {
        metadata: DKGTranscriptMetadata {
            epoch: current_epoch,
            author: AccountAddress::ZERO,
        },
        transcript_bytes: vec![1, 2, 3],
    });
    
    executor.vtxn_pool.put(Topic::DKG, Arc::new(dkg_txn), None);
    
    // Advance time past epoch interval
    executor.advance_time(1000001);
    
    // Propose a block that will include the validator transaction
    let block = executor.propose_block_with_validator_txns().await;
    
    // Execute the block
    let result = executor.execute_block(block).await;
    
    // Verify: The validator transaction was pulled but discarded during execution
    assert!(result.validator_txn_statuses[0].is_discard());
    assert_eq!(result.validator_txn_statuses[0].status_code(), StatusCode::ABORTED);
    
    // Verify: Epoch was incremented
    assert_eq!(executor.get_current_epoch(), current_epoch + 1);
}
```

**Notes:**

This vulnerability demonstrates a coordination failure between consensus (which pulls transactions) and execution (which validates them). The root cause is that epoch transitions are determined during execution (in `block_prologue`), but transaction pulling happens during proposal generation without awareness of whether the block will trigger a transition. The reconfiguration suffix mechanism prevents this for subsequent blocks but not for the transition-triggering block itself.

### Citations

**File:** consensus/src/liveness/proposal_generator.rs (L505-515)
```rust
        let (validator_txns, payload, timestamp) = if hqc.certified_block().has_reconfiguration() {
            // Reconfiguration rule - we propose empty blocks with parents' timestamp
            // after reconfiguration until it's committed
            (
                vec![],
                Payload::empty(
                    self.quorum_store_enabled,
                    self.allow_batches_without_pos_in_proposal,
                ),
                hqc.certified_block().timestamp_usecs(),
            )
```

**File:** consensus/src/liveness/proposal_generator.rs (L643-672)
```rust
        let pending_validator_txn_hashes: HashSet<HashValue> = pending_blocks
            .iter()
            .filter_map(|block| block.validator_txns())
            .flatten()
            .map(ValidatorTransaction::hash)
            .collect();
        let validator_txn_filter =
            vtxn_pool::TransactionFilter::PendingTxnHashSet(pending_validator_txn_hashes);

        let (validator_txns, mut payload) = self
            .payload_client
            .pull_payload(
                PayloadPullParameters {
                    max_poll_time: self.quorum_store_poll_time.saturating_sub(proposal_delay),
                    max_txns: max_block_txns,
                    max_txns_after_filtering: max_block_txns_after_filtering,
                    soft_max_txns_after_filtering: max_txns_from_block_to_execute
                        .unwrap_or(max_block_txns_after_filtering),
                    max_inline_txns: self.max_inline_txns,
                    maybe_optqs_payload_pull_params,
                    user_txn_filter: payload_filter,
                    pending_ordering,
                    pending_uncommitted_blocks: pending_blocks.len(),
                    recent_max_fill_fraction: max_fill_fraction,
                    block_timestamp: timestamp,
                },
                validator_txn_filter,
            )
            .await
            .context("Fail to retrieve payload")?;
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L812-826)
```rust
        let txns = [
            vec![SignatureVerifiedTransaction::from(Transaction::from(
                metadata_txn,
            ))],
            block
                .validator_txns()
                .cloned()
                .unwrap_or_default()
                .into_iter()
                .map(Transaction::ValidatorTransaction)
                .map(SignatureVerifiedTransaction::from)
                .collect(),
            user_txns.as_ref().clone(),
        ]
        .concat();
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L68-77)
```rust
            Err(Expected(failure)) => {
                // Pretend we are inside Move, and expected failures are like Move aborts.
                Ok((
                    VMStatus::MoveAbort {
                        location: AbortLocation::Script,
                        code: failure as u64,
                        message: None,
                    },
                    VMOutput::empty_with_status(TransactionStatus::Discard(StatusCode::ABORTED)),
                ))
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L100-102)
```rust
        if dkg_node.metadata.epoch != config_resource.epoch() {
            return Err(Expected(EpochNotCurrent));
        }
```

**File:** dkg/src/dkg_manager/mod.rs (L397-409)
```rust
                let txn = ValidatorTransaction::DKGResult(DKGTranscript {
                    metadata: DKGTranscriptMetadata {
                        epoch: self.epoch_state.epoch,
                        author: self.my_addr,
                    },
                    transcript_bytes: bcs::to_bytes(&agg_trx)
                        .map_err(|e| anyhow!("transcript serialization error: {e}"))?,
                });
                let vtxn_guard = self.vtxn_pool.put(
                    Topic::DKG,
                    Arc::new(txn),
                    Some(self.pull_notification_tx.clone()),
                );
```

**File:** aptos-move/framework/aptos-framework/sources/block.move (L215-217)
```text
        if (timestamp - reconfiguration::last_reconfiguration_time() >= epoch_interval) {
            reconfiguration::reconfigure();
        };
```
