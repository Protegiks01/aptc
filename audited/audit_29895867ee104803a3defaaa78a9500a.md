# Audit Report

## Title
Incomplete Constant-Time Test Coverage Allows Timing Side-Channel Vulnerabilities to Remain Undetected in Production VUF Operations

## Summary
The constant-time scalar multiplication tests used by the Aptos pepper service fail to test critical code paths (zero scalars and multi-exponentiation) despite explicit warnings about timing differences. This creates a false sense of security where the production service may pass constant-time verification while still containing exploitable timing side-channels that could leak VUF secret keys.

## Finding Description
The Aptos pepper service performs a critical security check at startup by running constant-time verification tests on scalar multiplication operations. [1](#0-0)  These tests are designed to detect timing variations that could leak secret key information through side-channel attacks.

However, the tests have two critical gaps:

**Gap 1: Zero Scalar Never Tested**

The code explicitly warns that blstrs is faster when the scalar is exactly zero. [2](#0-1) 

Yet the test function `random_scalar_with_k_bits_set` enforces that k must be less than BIT_SIZE (255), [3](#0-2)  and the minimum value tested is k=1, [4](#0-3)  meaning zero scalars are **never** included in the statistical test.

**Gap 2: Multi-Exponentiation Code Path Not Tested**

The tests only exercise single scalar multiplication via `base.mul(&sk)`. [5](#0-4) 

However, production DKG code uses `g1_multi_exp` which has three distinct code paths: [6](#0-5) 

The multi-exponentiation path (2+ elements) uses `G1Projective::multi_exp()` which may employ different algorithms (e.g., Pippenger's algorithm) with potentially different constant-time properties. This code path is used in production for DKG secret key reconstruction. [7](#0-6) 

**Security Impact**

The VUF secret key is generated without excluding zero, [8](#0-7)  and is used in constant-time-critical operations. [9](#0-8) 

If blstrs has measurable timing differences for zero scalars or if the multi_exp code path has timing variations, an attacker with precise timing measurement capabilities could potentially extract secret key bits through statistical analysis of many VUF evaluations.

## Impact Explanation
This qualifies as **High Severity** under the Aptos bug bounty program for the following reasons:

1. **Cryptographic Correctness Violation**: The issue violates the critical invariant that "BLS signatures, VRF, and hash operations must be secure" by potentially allowing timing side-channel attacks on VUF secret keys.

2. **False Security Gate**: The pepper service uses these tests as a security invariant check before handling secret keys. [10](#0-9)  If the tests pass with incomplete coverage, the service operates under a false assumption of security.

3. **Secret Key Leakage Potential**: While direct fund theft is not the primary vector, leaking VUF secret keys compromises the keyless account system's security foundations, which could enable subsequent attacks on user accounts.

4. **Significant Protocol Violation**: Timing side-channels in cryptographic operations represent a fundamental protocol security weakness that undermines the security model of the entire keyless authentication system.

## Likelihood Explanation
**Medium-High Likelihood** due to:

1. **Explicit Warning Ignored**: The code itself warns about zero being faster, yet this case is deliberately excluded from tests, suggesting the developers are aware of the potential issue but haven't properly validated it.

2. **Probability vs. Testing**: While a random secret key being exactly zero has negligible probability (1/2^255), the tests are **designed** to catch ANY timing variations. Excluding zero means the tests cannot verify the constant-time property for this edge case.

3. **Attack Feasibility**: Remote timing attacks on web services are well-established (e.g., Lucky Thirteen, Bleichenbacher), and sophisticated attackers with infrastructure to make many requests and statistical analysis capabilities could exploit micro-second level timing differences.

4. **Production Code Path Gap**: The multi_exp code path is actively used in production DKG operations but receives zero constant-time validation, creating an unverified attack surface.

## Recommendation
Modify the constant-time tests to include comprehensive coverage:

**Fix 1: Test Zero Scalars**

```rust
// In build_and_run_bench(), add a third class that tests zero and near-zero scalars
pub fn build_and_run_bench(
    runner: &mut CtRunner,
    rng: &mut BenchRng,
    random_bases: bool,
    num_iters: usize,
) {
    let mut inputs: Vec<(Class, usize, Scalar, G1Projective)> = Vec::with_capacity(N);
    
    // Add zero/near-zero scalar testing
    let test_zero = true; // Enable zero scalar testing
    
    for _ in 0..num_iters {
        let base = if random_bases {
            G1Projective::random(&mut *rng)
        } else {
            G1Projective::generator()
        };
        let choice = rng.gen::<u8>() % 3; // Three-way split
        
        match choice {
            0 => {
                // Existing "left" class: 1-4 bits
                let num_bits_left = rng.gen_range(1..4);
                inputs.push((Class::Left, num_bits_left, 
                    random_scalar_with_k_bits_set(rng, num_bits_left), base));
            },
            1 => {
                // Existing "right" class: 200 bits
                inputs.push((Class::Right, 200, 
                    random_scalar_with_k_bits_set(rng, 200), base));
            },
            2 => {
                // NEW: Zero scalar class
                if test_zero {
                    inputs.push((Class::Left, 0, Scalar::ZERO, base));
                }
            },
            _ => unreachable!(),
        }
    }
    
    for (class, _k, sk, base) in inputs {
        runner.run_one(class, || {
            let _ = black_box(base.mul(&sk));
        })
    }
}
```

**Fix 2: Test Multi-Exponentiation Code Path**

```rust
/// Tests constant-time properties of multi_exp with 2+ elements
pub fn run_bench_multi_exp(runner: &mut CtRunner, rng: &mut BenchRng) {
    const N: usize = 5_000;
    let mut inputs: Vec<(Class, Vec<G1Projective>, Vec<Scalar>)> = Vec::with_capacity(N);
    
    for _ in 0..N {
        let num_elements = rng.gen_range(2..5); // 2-4 elements
        let bases: Vec<G1Projective> = (0..num_elements)
            .map(|_| G1Projective::random(&mut *rng))
            .collect();
        
        let choice = rng.gen::<bool>();
        let scalars: Vec<Scalar> = if choice {
            // Left: small scalars
            (0..num_elements).map(|_| random_scalar_with_k_bits_set(rng, 2)).collect()
        } else {
            // Right: large scalars
            (0..num_elements).map(|_| random_scalar_with_k_bits_set(rng, 200)).collect()
        };
        
        inputs.push((if choice { Class::Left } else { Class::Right }, bases, scalars));
    }
    
    for (class, bases, scalars) in inputs {
        runner.run_one(class, || {
            let _ = black_box(G1Projective::multi_exp(&bases, &scalars));
        })
    }
}
```

**Fix 3: Update Production Verification**

Update the pepper service to run all three test variants: [1](#0-0) 

## Proof of Concept

```rust
// Test demonstrating the gap: zero scalars are never tested
#[test]
fn test_zero_scalar_timing_not_covered() {
    use crate::constant_time::blstrs_scalar_mul::random_scalar_with_k_bits_set;
    use rand::thread_rng;
    
    let mut rng = thread_rng();
    
    // This will panic, proving zero scalars cannot be generated by the test
    // k=0 would create a zero scalar, but the assertion prevents it
    let result = std::panic::catch_unwind(|| {
        random_scalar_with_k_bits_set(&mut rng, 0)
    });
    
    assert!(result.is_err(), "Zero scalar test should fail due to assertion");
}

// Test demonstrating multi_exp is not tested for constant-time
#[test]
fn test_multi_exp_not_tested_for_constant_time() {
    use blstrs::{G1Projective, Scalar};
    use group::Group;
    use std::time::Instant;
    
    // Create test inputs for multi_exp
    let bases = vec![G1Projective::generator(), G1Projective::generator()];
    let scalar_small = vec![Scalar::from(1u64), Scalar::from(1u64)];
    let scalar_large = vec![Scalar::from(u64::MAX), Scalar::from(u64::MAX)];
    
    // Measure timing for small scalars
    let start = Instant::now();
    for _ in 0..1000 {
        let _ = G1Projective::multi_exp(&bases, &scalar_small);
    }
    let time_small = start.elapsed();
    
    // Measure timing for large scalars  
    let start = Instant::now();
    for _ in 0..1000 {
        let _ = G1Projective::multi_exp(&bases, &scalar_large);
    }
    let time_large = start.elapsed();
    
    // If there's a measurable difference, multi_exp may not be constant-time
    // But the current tests would never detect this!
    eprintln!("Time for small scalars: {:?}", time_small);
    eprintln!("Time for large scalars: {:?}", time_large);
}
```

## Notes

The vulnerability lies in the **gap between what the tests claim to verify (constant-time scalar multiplication) and what they actually test (only single .mul() with non-zero scalars)**. This is particularly critical because:

1. The production pepper service relies on these tests as a security gate that must pass before handling secret keys
2. The code explicitly warns about zero being faster, yet deliberately excludes this case from testing
3. Multi-exponentiation uses potentially different algorithms that could have different timing characteristics
4. Both gaps create unverified attack surfaces where timing side-channels could exist undetected

While the practical exploitation requires sophisticated timing measurement capabilities, the fundamental issue is that the security verification is incomplete, creating a false sense of security in a cryptographically critical component of the Aptos keyless account system.

### Citations

**File:** keyless/pepper/service/src/main.rs (L363-392)
```rust
/// Verifies that scalar multiplication is constant time
fn verify_constant_time_scalar_multiplication() {
    // Run the constant time benchmarks for random bases
    let abs_max_t = ctbench::run_bench(
        &BenchName("blstrs_scalar_mul/random_bases"),
        constant_time::blstrs_scalar_mul::run_bench_with_random_bases,
        None,
    )
    .1
    .max_t
    .abs()
    .ceil()
    .to_i64()
    .expect("Floating point arithmetic went awry.");
    assert_le!(abs_max_t, ABS_MAX_T);

    // Run the constant time benchmarks for fixed bases
    let abs_max_t = ctbench::run_bench(
        &BenchName("blstrs_scalar_mul/fixed_bases"),
        constant_time::blstrs_scalar_mul::run_bench_with_fixed_bases,
        None,
    )
    .1
    .max_t
    .abs()
    .ceil()
    .to_i64()
    .expect("Floating point arithmetic went awry.");
    assert_le!(abs_max_t, ABS_MAX_T);
}
```

**File:** keyless/pepper/service/src/main.rs (L402-410)
```rust
    // Verify constant-time scalar multiplication if in production.
    if args.local_development_mode {
        info!(
            "Constant-time scalar multiplication verification skipped in local development mode."
        );
    } else {
        info!("Verifying constant-time scalar multiplication...");
        verify_constant_time_scalar_multiplication();
    }
```

**File:** crates/aptos-crypto/src/constant_time/blstrs_scalar_mul.rs (L32-36)
```rust
    assert!(
        k < BIT_SIZE,
        "k must be < the field's bit size {}",
        BIT_SIZE
    );
```

**File:** crates/aptos-crypto/src/constant_time/blstrs_scalar_mul.rs (L79-80)
```rust
    let min_num_bits_left = 1;
    let max_num_bits_left = 4;
```

**File:** crates/aptos-crypto/src/constant_time/blstrs_scalar_mul.rs (L101-101)
```rust
            // WARNING: `blstrs` is faster when the scalar is exactly 0!
```

**File:** crates/aptos-crypto/src/constant_time/blstrs_scalar_mul.rs (L119-123)
```rust
    for (class, _k, sk, base) in inputs {
        runner.run_one(class, || {
            let _ = black_box(base.mul(&sk));
        })
    }
```

**File:** crates/aptos-dkg/src/utils/mod.rs (L67-71)
```rust
    match bases.len() {
        0 => G1Projective::identity(),
        1 => bases[0].mul(scalars[0]),
        _ => G1Projective::multi_exp(bases, scalars),
    }
```

**File:** crates/aptos-dkg/src/pvss/dealt_secret_key.rs (L119-121)
```rust
                Ok(DealtSecretKey {
                    h_hat: $gt_multi_exp(bases.as_slice(), lagr.as_slice()),
                })
```

**File:** keyless/pepper/common/src/vuf/bls12381_g1_bls.rs (L71-74)
```rust
    fn setup<R: CryptoRng + RngCore>(rng: &mut R) -> (Self::PrivateKey, Self::PublicKey) {
        let sk = random_scalar(rng);
        let pk = G2Affine::generator() * sk;
        (sk, pk)
```

**File:** keyless/pepper/common/src/vuf/bls12381_g1_bls.rs (L81-87)
```rust
    /// WARNING: This function must remain constant-time w.r.t. to `sk` and `input`.
    fn eval(sk: &Scalar, input: &[u8]) -> anyhow::Result<(Vec<u8>, Vec<u8>)> {
        let input_g1 = Self::hash_to_g1(input);
        let output_g1 = input_g1.mul(sk);
        let output_bytes = output_g1.to_compressed().to_vec();
        Ok((output_bytes, vec![]))
    }
```
