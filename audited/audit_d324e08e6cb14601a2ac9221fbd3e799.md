# Audit Report

## Title
TOCTOU Race Condition in CLI Authentication Key Retrieval Leading to Transaction Authentication Failures

## Summary
The `get_auth_key()` function in the Aptos CLI does not check if an authentication key has been recently rotated, creating a Time-of-Check to Time-of-Use (TOCTOU) vulnerability. This allows transactions to fail during prologue validation if the authentication key changes between retrieval and submission, causing denial of service and poor user experience.

## Finding Description

The vulnerability exists in the transaction submission flow where the CLI retrieves the authentication key at one point in time, but the on-chain validation happens later: [1](#0-0) 

This function simply retrieves the authentication key without any validation against recent rotations or warnings. The key is used in critical operations like key rotation: [2](#0-1) 

When a transaction is submitted, the prologue validates the authentication key: [3](#0-2) 

**Attack Scenario:**

1. User's CLI calls `get_auth_key(address)` at time T1, retrieving `auth_key_1`
2. Between T1 and transaction submission, the authentication key is rotated to `auth_key_2` (by another process, concurrent operation, or frontrunning attacker)
3. User submits transaction at time T3 with a public key that derives to `auth_key_1`
4. Prologue checks: `txn_auth_key (auth_key_1) == on_chain_auth_key (auth_key_2)` â†’ **FAILS**
5. Transaction rejected with `PROLOGUE_EINVALID_ACCOUNT_AUTH_KEY` error

The code even contains a TODO acknowledging this issue: [4](#0-3) 

## Impact Explanation

This vulnerability falls under **High Severity** per the bug bounty criteria as it can cause:

- **API crashes/failures**: Systematic transaction authentication failures affect API reliability
- **Denial of Service**: An attacker monitoring transaction patterns could deliberately trigger key rotations to cause victim transaction failures
- **Protocol violations**: While not breaking consensus, it violates the expected reliability of transaction submission

The impact is particularly severe for:
- Key rotation operations that must read the current auth key
- Multi-step transaction flows
- Automated systems relying on deterministic transaction success
- Users in time-sensitive scenarios (DeFi operations, auctions, etc.)

## Likelihood Explanation

**Likelihood: Medium to High**

This issue can occur in several realistic scenarios:

1. **Concurrent Operations**: Multiple CLI processes or applications operating on the same account
2. **Frontrunning Attack**: Malicious actors monitoring mempool and frontrunning with key rotations
3. **Automated Systems**: Scripts that rotate keys on schedules conflicting with transaction submissions
4. **Recovery Operations**: Users recovering accounts while other processes attempt transactions

The issue is particularly likely because:
- No locking mechanism exists to prevent concurrent key operations
- No timestamp or version checks validate auth key freshness
- The window between retrieval and submission can be significant (network latency, user confirmation prompts)

## Recommendation

Implement authentication key validation and freshness checks:

```rust
pub async fn get_auth_key(
    client: &aptos_rest_client::Client,
    address: AccountAddress,
) -> CliTypedResult<AuthenticationKey> {
    let (account, state) = get_account_with_state(client, address).await?;
    
    // Return both auth key and blockchain state for freshness validation
    Ok(account.authentication_key)
}

// In transaction submission:
pub async fn submit_transaction(&self, payload: TransactionPayload) -> CliTypedResult<Transaction> {
    let client = self.rest_client()?;
    let (sender_public_key, sender_address) = self.get_public_key_and_address()?;
    
    // Validate auth key matches current public key BEFORE building transaction
    let expected_auth_key = AuthenticationKey::ed25519(&sender_public_key);
    let (account, state) = get_account_with_state(&client, sender_address).await?;
    
    if account.authentication_key != expected_auth_key.to_vec() {
        return Err(CliError::CommandArgumentError(format!(
            "Authentication key mismatch: on-chain auth key has been rotated. \
             Expected: {:?}, On-chain: {:?}. \
             Please use --sender-account flag with the correct address or update your profile configuration.",
            expected_auth_key, account.authentication_key
        )));
    }
    
    // Continue with transaction building...
}
```

Additionally:
- Add warnings when auth keys were recently modified (within last N blocks)
- Implement retry logic with auth key re-validation
- Add `--force` flag to bypass checks if user confirms the risk

## Proof of Concept

```rust
// Reproduction steps:
// 1. Create account with key_1
// 2. In parallel threads:
//    Thread A: Call get_auth_key() then submit transaction after delay
//    Thread B: Rotate authentication key to key_2
// 3. Observe Thread A's transaction fails with PROLOGUE_EINVALID_ACCOUNT_AUTH_KEY

#[tokio::test]
async fn test_toctou_auth_key_rotation() {
    let (mut swarm, cli, _faucet) = launch_swarm_with_cli(1, 0).await;
    let client = swarm.validators().next().unwrap().rest_client();
    
    // Create account
    let account_key = AccountKey::generate(&mut rand::rngs::OsRng);
    let account_address = account_key.authentication_key().account_address();
    
    // Fund account
    fund_account(&client, &faucet_url, None, account_address, 100_000_000).await.unwrap();
    
    // Thread A: Retrieve auth key and prepare transaction
    let auth_key_t1 = get_auth_key(&client, account_address).await.unwrap();
    
    // Thread B: Rotate authentication key
    let new_key = AccountKey::generate(&mut rand::rngs::OsRng);
    let rotation_txn = create_rotation_transaction(
        &account_key,
        &new_key,
        account_address
    );
    client.submit(&rotation_txn).await.unwrap();
    client.wait_for_transaction(&rotation_txn).await.unwrap();
    
    // Thread A: Submit transaction (should fail due to TOCTOU)
    let transfer_txn = create_transfer_transaction(
        &account_key,  // Using old key
        receiver_address,
        1000
    );
    
    let result = client.submit(&transfer_txn).await;
    
    // Assert transaction fails with auth key mismatch
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("PROLOGUE_EINVALID_ACCOUNT_AUTH_KEY"));
}
```

## Notes

This vulnerability is acknowledged in the codebase via the TODO comment but remains unaddressed. The `--sender-account` flag provides a workaround for users aware of key rotations, but does not prevent the TOCTOU condition for unaware users or automated systems. The fix should include both validation logic and clear user messaging to prevent transaction failures and improve the overall security posture of the CLI tool.

### Citations

**File:** crates/aptos/src/common/utils.rs (L296-301)
```rust
pub async fn get_auth_key(
    client: &aptos_rest_client::Client,
    address: AccountAddress,
) -> CliTypedResult<AuthenticationKey> {
    Ok(get_account(client, address).await?.authentication_key)
}
```

**File:** crates/aptos/src/account/key_rotation.rs (L191-202)
```rust
        let sequence_number = self.txn_options.sequence_number(current_address).await?;
        let auth_key = self.txn_options.auth_key(current_address).await?;
        let rotation_proof = RotationProofChallenge {
            account_address: CORE_CODE_ADDRESS,
            module_name: "account".to_string(),
            struct_name: "RotationProofChallenge".to_string(),
            sequence_number,
            originator: current_address,
            current_auth_key: AccountAddress::from_bytes(auth_key)
                .map_err(|err| CliError::UnableToParse("auth_key", err.to_string()))?,
            new_public_key: new_public_key.to_bytes().to_vec(),
        };
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L148-167)
```text
        // Check if the authentication key is valid
        if (!skip_auth_key_check(is_simulation, &txn_authentication_key)) {
            if (option::is_some(&txn_authentication_key)) {
                if (
                    sender_address == gas_payer_address ||
                    account::exists_at(sender_address) ||
                    !features::sponsored_automatic_account_creation_enabled()
                ) {
                    assert!(
                        txn_authentication_key == option::some(account::get_authentication_key(sender_address)),
                        error::invalid_argument(PROLOGUE_EINVALID_ACCOUNT_AUTH_KEY),
                    );
                };
            } else {
                assert!(
                    allow_missing_txn_authentication_key(sender_address),
                    error::invalid_argument(PROLOGUE_EINVALID_ACCOUNT_AUTH_KEY)
                );
            };
        };
```

**File:** crates/aptos/src/common/types.rs (L1977-1977)
```rust
        // TODO: Check auth key against current private key and provide a better message
```
