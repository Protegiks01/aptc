# Audit Report

## Title
Missing Per-Byte Deserialization Gas Charge in Bulletproofs Batch Verification Enables Validator DoS

## Summary
The batch bulletproofs range proof verification native function fails to charge gas proportional to the proof size during deserialization, unlike its single-proof counterpart. This allows attackers to submit oversized malformed proofs that consume validator CPU resources without paying appropriate gas, enabling denial-of-service attacks against validator nodes.

## Finding Description

The bulletproofs module provides two verification paths: single-proof and batch-proof verification. A critical inconsistency exists in their gas metering:

**Single Proof Verification** charges gas in two stages: [1](#0-0) 

This charges `BULLETPROOFS_BASE` (11,794,651 gas) plus 121 gas per byte of the proof before attempting deserialization.

**Batch Proof Verification** only charges a fixed amount: [2](#0-1) 

The `charge_gas` function is a lookup table that charges based solely on batch_size and bit_length combinations: [3](#0-2) 

After charging this fixed amount, deserialization proceeds: [4](#0-3) 

**The Attack Vector:**

1. Attacker submits a transaction calling `verify_batch_range_proof_internal` with:
   - `batch_size = 1`, `num_bits = 8` (minimal parameters)
   - `proof_bytes` of size 64 KB (transaction size limit) [5](#0-4) 

2. Gas charged: only 17,099,501 (BULLETPROOFS_VERIFY_BASE_BATCH_1_BITS_8) [6](#0-5) 

3. Valid proof size for these parameters: 32 × (9 + 2 × log₂(1 × 8)) = 480 bytes

4. Attacker provides: 65,536 bytes (136× larger than valid size)

5. **Missing gas charge**: 121 × 65,536 = 7,929,856 gas for deserialization work

6. The `bulletproofs::RangeProof::from_bytes()` parser must process all 64 KB, consuming CPU cycles proportional to input size, even though it will ultimately fail

7. Multiplying this across many transactions causes validator nodes to waste CPU cycles on undercharged deserialization operations

This breaks **Invariant #9 (Resource Limits)**: "All operations must respect gas, storage, and computational limits" - the computation performed does not match the gas charged.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos Bug Bounty Program category of "Validator node slowdowns."

**Impact Quantification:**
- Each malicious transaction undercharges by ~7.9M gas units per 64 KB proof
- An attacker can submit multiple transactions per block to amplify the effect
- Validator nodes process expensive deserialization operations while paying insufficient gas
- Cumulative effect across transactions can significantly degrade validator performance
- No funds are at risk, but network liveness and performance are compromised

The vulnerability affects all validator nodes processing transactions with batch bulletproofs verification, which is a production feature enabled in the Aptos framework.

## Likelihood Explanation

**Likelihood: HIGH**

The attack requires:
- ✅ No privileged access - any transaction sender can exploit this
- ✅ Simple exploitation - call public Move function with oversized proof bytes
- ✅ No complex setup - single transaction submission
- ✅ Feature is enabled - bulletproofs batch verification is production-ready [7](#0-6) 

The vulnerability is easily discoverable through code inspection and straightforward to exploit. An attacker simply needs to:
1. Craft a transaction calling `ristretto255_bulletproofs::verify_batch_range_proof()`
2. Provide minimal valid parameters (batch_size=1, num_bits=8)
3. Include maximum-sized proof_bytes (64 KB)
4. Submit multiple such transactions to amplify the DoS effect

## Recommendation

Add per-byte deserialization gas charging to batch verification, matching the single-proof path:

```rust
fn verify_batch_range_proof(
    context: &mut SafeNativeContext,
    comm_points: &[CompressedRistretto],
    pc_gens: &PedersenGens,
    proof_bytes: &[u8],
    bit_length: usize,
    dst: Vec<u8>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    // ADD THIS: Charge for deserialization based on proof size
    context.charge(
        BULLETPROOFS_BASE
            + BULLETPROOFS_PER_BYTE_RANGEPROOF_DESERIALIZE
                * NumBytes::new(proof_bytes.len() as u64),
    )?;
    
    // Then charge fixed verification cost
    charge_gas(context, comm_points.len(), bit_length)?;

    let range_proof = match bulletproofs::RangeProof::from_bytes(proof_bytes) {
        Ok(proof) => proof,
        Err(_) => {
            return Err(SafeNativeError::Abort {
                abort_code: abort_codes::NFE_DESERIALIZE_RANGE_PROOF,
            })
        },
    };

    let mut ver_trans = Transcript::new(dst.as_slice());

    let success = range_proof
        .verify_multiple(
            &BULLETPROOF_GENERATORS,
            pc_gens,
            &mut ver_trans,
            comm_points,
            bit_length,
        )
        .is_ok();

    Ok(smallvec![Value::bool(success)])
}
```

This ensures gas charges scale with actual computational work performed during deserialization.

## Proof of Concept

```move
#[test(fx = @std)]
fun test_dos_via_oversized_batch_proof(fx: signer) {
    use aptos_std::features;
    use aptos_std::ristretto255_bulletproofs;
    use aptos_std::ristretto255;
    use std::vector;
    
    // Enable bulletproofs batch feature
    features::change_feature_flags_for_testing(&fx, 
        vector[ features::get_bulletproofs_batch_feature() ], 
        vector[]
    );
    
    // Create minimal valid parameters
    let comm = ristretto255::new_compressed_point_from_bytes(
        x"0000000000000000000000000000000000000000000000000000000000000000"
    ).extract();
    let comms = vector[comm];
    
    // Create oversized proof (64 KB of garbage data)
    let oversized_proof = vector::empty<u8>();
    let i = 0;
    while (i < 65536) {
        vector::push_back(&mut oversized_proof, 0xFF);
        i = i + 1;
    };
    
    let proof = bulletproofs_bulletproofs::range_proof_from_bytes(oversized_proof);
    
    // This call will:
    // 1. Charge only 17,099,501 gas (BULLETPROOFS_VERIFY_BASE_BATCH_1_BITS_8)
    // 2. Attempt to deserialize 64 KB proof (expensive operation)
    // 3. Missing ~7.9M gas charge for deserialization work
    // 4. Eventually fail with E_DESERIALIZE_RANGE_PROOF, but CPU already consumed
    
    let result = bulletproofs_bulletproofs::verify_batch_range_proof(
        &comms,
        &ristretto255::basepoint(),
        &ristretto255::hash_to_point_base(),
        &proof,
        8, // num_bits (minimal)
        b"test_dst"
    );
    
    // Proof will fail verification, but deserialization work was undercharged
    assert!(result == false, 1);
}
```

To demonstrate the DoS: Submit multiple transactions with this pattern. Each transaction undercharges by ~7.9M gas units while consuming validator CPU proportional to the 64 KB proof size. The cumulative effect degrades validator performance.

## Notes

This vulnerability specifically affects the batch verification code path. The single-proof verification path (`verify_range_proof`) correctly charges per-byte deserialization gas and is not vulnerable. The fix should ensure both paths use consistent gas metering strategies.

### Citations

**File:** aptos-move/framework/src/natives/cryptography/bulletproofs.rs (L328-332)
```rust
    context.charge(
        BULLETPROOFS_BASE
            + BULLETPROOFS_PER_BYTE_RANGEPROOF_DESERIALIZE
                * NumBytes::new(proof_bytes.len() as u64),
    )?;
```

**File:** aptos-move/framework/src/natives/cryptography/bulletproofs.rs (L371-371)
```rust
    charge_gas(context, comm_points.len(), bit_length)?;
```

**File:** aptos-move/framework/src/natives/cryptography/bulletproofs.rs (L373-380)
```rust
    let range_proof = match bulletproofs::RangeProof::from_bytes(proof_bytes) {
        Ok(proof) => proof,
        Err(_) => {
            return Err(SafeNativeError::Abort {
                abort_code: abort_codes::NFE_DESERIALIZE_RANGE_PROOF,
            })
        },
    };
```

**File:** aptos-move/framework/src/natives/cryptography/bulletproofs.rs (L398-426)
```rust
fn charge_gas(
    context: &mut SafeNativeContext,
    batch_size: usize,
    bit_length: usize,
) -> SafeNativeResult<()> {
    match (batch_size, bit_length) {
        (1, 8) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_1_BITS_8),
        (1, 16) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_1_BITS_16),
        (1, 32) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_1_BITS_32),
        (1, 64) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_1_BITS_64),
        (2, 8) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_2_BITS_8),
        (2, 16) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_2_BITS_16),
        (2, 32) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_2_BITS_32),
        (2, 64) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_2_BITS_64),
        (4, 8) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_4_BITS_8),
        (4, 16) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_4_BITS_16),
        (4, 32) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_4_BITS_32),
        (4, 64) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_4_BITS_64),
        (8, 8) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_8_BITS_8),
        (8, 16) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_8_BITS_16),
        (8, 32) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_8_BITS_32),
        (8, 64) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_8_BITS_64),
        (16, 8) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_16_BITS_8),
        (16, 16) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_16_BITS_16),
        (16, 32) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_16_BITS_32),
        (16, 64) => context.charge(BULLETPROOFS_VERIFY_BASE_BATCH_16_BITS_64),
        _ => unreachable!(),
    }
}
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L73-76)
```rust
            max_transaction_size_in_bytes: NumBytes,
            "max_transaction_size_in_bytes",
            64 * 1024
        ],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/aptos_framework.rs (L250-250)
```rust
        [bulletproofs_verify_base_batch_1_bits_8: InternalGas, { RELEASE_V1_28.. => "bulletproofs.verify.base_batch_1_bits_8" }, 17_099_501],
```

**File:** aptos-move/framework/aptos-stdlib/sources/cryptography/ristretto255_bulletproofs.move (L150-151)
```text
        assert!(features::bulletproofs_batch_enabled(), error::invalid_state(E_NATIVE_FUN_NOT_AVAILABLE));
        assert!(dst.length() <= 256, error::invalid_argument(E_DST_TOO_LONG));
```
