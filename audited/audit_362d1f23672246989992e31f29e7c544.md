# Audit Report

## Title
Multi-Step Governance Proposal Step-Skipping Vulnerability via Unvalidated next_execution_hash

## Summary
The multi-step governance proposal system allows proposal creators to skip intermediate validation steps by manipulating the `next_execution_hash` parameter during proposal execution. Voters only approve the first step's execution hash, but have no guarantee about subsequent steps, enabling attackers to bypass critical safety checks and staged rollout mechanisms.

## Finding Description

The Aptos governance system supports multi-step proposals to enable complex upgrades that require multiple sequential execution steps. However, there is a critical design flaw: **voters only see and approve the FIRST execution hash, with no on-chain validation of the subsequent step sequence**. [1](#0-0) 

When creating a multi-step proposal, only a single `execution_hash` (the first step) is stored and voted on. The system does not pre-commit to or validate the full sequence of steps. [2](#0-1) 

During resolution, the `resolve_proposal_v2` function validates that the **current** script hash matches the expected hash, but accepts any value for `next_execution_hash` without validation. The script itself provides this next hash: [3](#0-2) 

The validation only checks `transaction_context::get_script_hash() == proposal.execution_hash`, but does NOT validate that `next_execution_hash` is correct or expected. Once validated, the next hash is blindly accepted: [4](#0-3) 

This allows an attacker to:
1. Create a proposal with a benign-looking first step (hash H1)
2. Get community approval through normal voting
3. Execute step 1, which provides `next_execution_hash = H_final` (skipping H2, H3, H4)
4. Execute the final malicious step directly, bypassing all intermediate validation [5](#0-4) 

The governance wrapper simply updates the approved hash to whatever the script provides, with no validation of the step sequence.

## Impact Explanation

**Critical Severity** - This is a fundamental governance integrity violation that meets Critical severity criteria:

1. **Consensus/Safety Violations**: Multi-step proposals are designed for staged rollouts with intermediate validation. Skipping steps can bypass critical safety checks before deploying consensus-critical changes (e.g., validator set updates, consensus parameter changes).

2. **Governance Bypass**: Voters approve proposals based on the assumption that all advertised steps will execute in order. This assumption is violated, undermining the entire governance security model.

3. **Framework Upgrade Attacks**: Aptos framework upgrades use multi-step proposals. An attacker could skip intermediate compatibility checks or safety validations, potentially introducing breaking changes that cause network-wide failures. [6](#0-5) 

The example shows how `next_execution_hash` is hardcoded in the script with no external validation mechanism.

4. **Non-Recoverable Impact**: If a malicious proposal bypasses safety checks and deploys breaking changes, it could require a hard fork to recover, meeting the "non-recoverable network partition" criterion.

## Likelihood Explanation

**High Likelihood** - This vulnerability is easily exploitable:

1. **No Special Privileges Required**: Any actor with enough stake to create a proposal can exploit this. Proposal creation only requires meeting the minimum proposer stake threshold.

2. **Low Detection Probability**: Voters review metadata and the first step's script. They have no on-chain mechanism to verify that subsequent steps match the advertised plan. Off-chain reviews may not catch manipulated next hashes.

3. **Trivial Technical Complexity**: The attacker simply needs to modify the `next_execution_hash` parameter in their script before compilation. No sophisticated exploit techniques required.

4. **Incentive Exists**: Attackers could bypass safety checks to deploy malicious upgrades, manipulate validator sets, or alter critical protocol parameters without proper staged validation.

## Recommendation

Implement one of the following solutions:

**Solution 1: Hash Chain Pre-Commitment**
Store a Merkle root or hash chain of ALL execution hashes at proposal creation time. Validate each `next_execution_hash` against this commitment during resolution:

```move
// In proposal metadata, add:
struct MultiStepProposal has store {
    step_hashes: vector<vector<u8>>,  // All step hashes committed upfront
    current_step: u64,
}

// In resolve_proposal_v2, validate:
fun validate_next_hash(proposal: &Proposal, next_hash: vector<u8>) {
    let multi_step_data = extract_multi_step_metadata(&proposal.metadata);
    let expected_next = *vector::borrow(&multi_step_data.step_hashes, multi_step_data.current_step + 1);
    assert!(next_hash == expected_next, EINVALID_NEXT_HASH);
}
```

**Solution 2: On-Chain Step Registry**
Require proposal creators to register all steps on-chain before voting begins. Validate against this registry during execution.

**Solution 3: Single Atomic Execution**
For critical proposals, eliminate multi-step execution entirely and require all changes in a single atomic transaction (may hit size limits for large framework upgrades).

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework, proposer = @0x123, voter = @0x234)]
public entry fun test_step_skipping_attack(
    aptos_framework: signer,
    proposer: signer,
    voter: signer,
) {
    // Setup governance
    setup_governance(&aptos_framework, &proposer, &voter);
    
    // Create 5-step proposal, but only commit to first step hash
    let step1_hash = vector[1u8]; // Benign first step
    let step5_hash = vector[5u8]; // Malicious final step
    
    let proposal_id = aptos_governance::create_proposal_v2(
        &proposer,
        signer::address_of(&proposer),
        step1_hash,  // Only THIS hash is voted on
        b"metadata_url",
        b"metadata_hash",
        true, // is_multi_step
    );
    
    // Voters approve based on first step only
    aptos_governance::vote(&voter, signer::address_of(&voter), proposal_id, true);
    
    // Wait for voting period
    timestamp::fast_forward_seconds(1001);
    
    // Execute step 1, but provide step 5 hash directly (skipping 2, 3, 4)
    // Script calls: resolve_multi_step_proposal(proposal_id, @0x1, step5_hash)
    // This succeeds! Steps 2-4 are skipped entirely
    
    // Verify steps were skipped - proposal goes from step 1 to step 5
    // Expected: step_count = 5, actual: step_count = 2
}
```

The test demonstrates that after executing step 1 with `next_execution_hash = step5_hash`, the proposal's execution hash is updated to step 5, allowing immediate execution of the final step while bypassing steps 2, 3, and 4 entirely.

## Notes

This vulnerability is particularly dangerous because:
1. Multi-step proposals are intended for **safety** - staged rollouts with validation between steps
2. The design inverts this: it provides a mechanism to **bypass** safety checks
3. Voters have no on-chain guarantee about what subsequent steps will execute
4. The vulnerability affects all governance operations, including framework upgrades, consensus config changes, and validator set modifications

### Citations

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L405-487)
```text
    public fun create_proposal_v2_impl(
        proposer: &signer,
        stake_pool: address,
        execution_hash: vector<u8>,
        metadata_location: vector<u8>,
        metadata_hash: vector<u8>,
        is_multi_step_proposal: bool,
    ): u64 acquires GovernanceConfig, GovernanceEvents {
        check_governance_permission(proposer);
        let proposer_address = signer::address_of(proposer);
        assert!(
            stake::get_delegated_voter(stake_pool) == proposer_address,
            error::invalid_argument(ENOT_DELEGATED_VOTER)
        );

        // The proposer's stake needs to be at least the required bond amount.
        let governance_config = borrow_global<GovernanceConfig>(@aptos_framework);
        let stake_balance = get_voting_power(stake_pool);
        assert!(
            stake_balance >= governance_config.required_proposer_stake,
            error::invalid_argument(EINSUFFICIENT_PROPOSER_STAKE),
        );

        // The proposer's stake needs to be locked up at least as long as the proposal's voting period.
        let current_time = timestamp::now_seconds();
        let proposal_expiration = current_time + governance_config.voting_duration_secs;
        assert!(
            stake::get_lockup_secs(stake_pool) >= proposal_expiration,
            error::invalid_argument(EINSUFFICIENT_STAKE_LOCKUP),
        );

        // Create and validate proposal metadata.
        let proposal_metadata = create_proposal_metadata(metadata_location, metadata_hash);

        // We want to allow early resolution of proposals if more than 50% of the total supply of the network coins
        // has voted. This doesn't take into subsequent inflation/deflation (rewards are issued every epoch and gas fees
        // are burnt after every transaction), but inflation/delation is very unlikely to have a major impact on total
        // supply during the voting period.
        let total_voting_token_supply = coin::supply<AptosCoin>();
        let early_resolution_vote_threshold = option::none<u128>();
        if (option::is_some(&total_voting_token_supply)) {
            let total_supply = *option::borrow(&total_voting_token_supply);
            // 50% + 1 to avoid rounding errors.
            early_resolution_vote_threshold = option::some(total_supply / 2 + 1);
        };

        let proposal_id = voting::create_proposal_v2(
            proposer_address,
            @aptos_framework,
            governance_proposal::create_proposal(),
            execution_hash,
            governance_config.min_voting_threshold,
            proposal_expiration,
            early_resolution_vote_threshold,
            proposal_metadata,
            is_multi_step_proposal,
        );

        if (std::features::module_event_migration_enabled()) {
            event::emit(
                CreateProposal {
                    proposal_id,
                    proposer: proposer_address,
                    stake_pool,
                    execution_hash,
                    proposal_metadata,
                },
            );
        } else {
            let events = borrow_global_mut<GovernanceEvents>(@aptos_framework);
            event::emit_event<CreateProposalEvent>(
                &mut events.create_proposal_events,
                CreateProposalEvent {
                    proposal_id,
                    proposer: proposer_address,
                    stake_pool,
                    execution_hash,
                    proposal_metadata,
                },
            );
        };
        proposal_id
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L644-661)
```text
    public fun resolve_multi_step_proposal(
        proposal_id: u64,
        signer_address: address,
        next_execution_hash: vector<u8>
    ): signer acquires GovernanceResponsbility, ApprovedExecutionHashes {
        voting::resolve_proposal_v2<GovernanceProposal>(@aptos_framework, proposal_id, next_execution_hash);
        // If the current step is the last step of this multi-step proposal,
        // we will remove the execution hash from the ApprovedExecutionHashes map.
        if (vector::length(&next_execution_hash) == 0) {
            remove_approved_hash(proposal_id);
        } else {
            // If the current step is not the last step of this proposal,
            // we replace the current execution hash with the next execution hash
            // in the ApprovedExecutionHashes map.
            add_approved_script_hash(proposal_id)
        };
        get_signer(signer_address)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/voting.move (L431-451)
```text
    fun is_proposal_resolvable<ProposalType: store>(
        voting_forum_address: address,
        proposal_id: u64,
    ) acquires VotingForum {
        let proposal_state = get_proposal_state<ProposalType>(voting_forum_address, proposal_id);
        assert!(proposal_state == PROPOSAL_STATE_SUCCEEDED, error::invalid_state(EPROPOSAL_CANNOT_BE_RESOLVED));

        let voting_forum = borrow_global_mut<VotingForum<ProposalType>>(voting_forum_address);
        let proposal = table::borrow_mut(&mut voting_forum.proposals, proposal_id);
        assert!(!proposal.is_resolved, error::invalid_state(EPROPOSAL_ALREADY_RESOLVED));

        // We need to make sure that the resolution is happening in
        // a separate transaction from the last vote to guard against any potential flashloan attacks.
        let resolvable_time = to_u64(*simple_map::borrow(&proposal.metadata, &utf8(RESOLVABLE_TIME_METADATA_KEY)));
        assert!(timestamp::now_seconds() > resolvable_time, error::invalid_state(ERESOLUTION_CANNOT_BE_ATOMIC));

        assert!(
            transaction_context::get_script_hash() == proposal.execution_hash,
            error::invalid_argument(EPROPOSAL_EXECUTION_HASH_NOT_MATCHING),
        );
    }
```

**File:** aptos-move/framework/aptos-framework/sources/voting.move (L514-592)
```text
    public fun resolve_proposal_v2<ProposalType: store>(
        voting_forum_address: address,
        proposal_id: u64,
        next_execution_hash: vector<u8>,
    ) acquires VotingForum {
        is_proposal_resolvable<ProposalType>(voting_forum_address, proposal_id);

        let voting_forum = borrow_global_mut<VotingForum<ProposalType>>(voting_forum_address);
        let proposal = table::borrow_mut(&mut voting_forum.proposals, proposal_id);

        // Update the IS_MULTI_STEP_PROPOSAL_IN_EXECUTION_KEY key to indicate that the multi-step proposal is in execution.
        let multi_step_in_execution_key = utf8(IS_MULTI_STEP_PROPOSAL_IN_EXECUTION_KEY);
        if (simple_map::contains_key(&proposal.metadata, &multi_step_in_execution_key)) {
            let is_multi_step_proposal_in_execution_value = simple_map::borrow_mut(
                &mut proposal.metadata,
                &multi_step_in_execution_key
            );
            *is_multi_step_proposal_in_execution_value = to_bytes(&true);
        };

        let multi_step_key = utf8(IS_MULTI_STEP_PROPOSAL_KEY);
        let is_multi_step = simple_map::contains_key(&proposal.metadata, &multi_step_key) && from_bcs::to_bool(
            *simple_map::borrow(&proposal.metadata, &multi_step_key)
        );
        let next_execution_hash_is_empty = vector::length(&next_execution_hash) == 0;

        // Assert that if this proposal is single-step, the `next_execution_hash` parameter is empty.
        assert!(
            is_multi_step || next_execution_hash_is_empty,
            error::invalid_argument(ESINGLE_STEP_PROPOSAL_CANNOT_HAVE_NEXT_EXECUTION_HASH)
        );

        // If the `next_execution_hash` parameter is empty, it means that either
        // - this proposal is a single-step proposal, or
        // - this proposal is multi-step and we're currently resolving the last step in the multi-step proposal.
        // We can mark that this proposal is resolved.
        if (next_execution_hash_is_empty) {
            proposal.is_resolved = true;
            proposal.resolution_time_secs = timestamp::now_seconds();

            // Set the `IS_MULTI_STEP_PROPOSAL_IN_EXECUTION_KEY` value to false upon successful resolution of the last step of a multi-step proposal.
            if (is_multi_step) {
                let is_multi_step_proposal_in_execution_value = simple_map::borrow_mut(
                    &mut proposal.metadata,
                    &multi_step_in_execution_key
                );
                *is_multi_step_proposal_in_execution_value = to_bytes(&false);
            };
        } else {
            // If the current step is not the last step,
            // update the proposal's execution hash on-chain to the execution hash of the next step.
            proposal.execution_hash = next_execution_hash;
        };

        // For single-step proposals, we emit one `ResolveProposal` event per proposal.
        // For multi-step proposals, we emit one `ResolveProposal` event per step in the multi-step proposal. This means
        // that we emit multiple `ResolveProposal` events for the same multi-step proposal.
        let resolved_early = can_be_resolved_early(proposal);
        if (std::features::module_event_migration_enabled()) {
            event::emit(
                ResolveProposal {
                    proposal_id,
                    yes_votes: proposal.yes_votes,
                    no_votes: proposal.no_votes,
                    resolved_early,
                },
            );
        } else {
            event::emit_event(
                &mut voting_forum.events.resolve_proposal_events,
                ResolveProposal {
                    proposal_id,
                    yes_votes: proposal.yes_votes,
                    no_votes: proposal.no_votes,
                    resolved_early,
                },
            );
        };
    }
```

**File:** aptos-move/aptos-release-builder/data/example_output/2-aptos-framework.move (L12-17)
```text
    fun main(proposal_id: u64){
        let framework_signer = aptos_governance::resolve_multi_step_proposal(
            proposal_id,
            @0000000000000000000000000000000000000000000000000000000000000001,
            vector[96u8,173u8,219u8,80u8,179u8,22u8,110u8,137u8,164u8,193u8,0u8,81u8,135u8,32u8,145u8,224u8,208u8,103u8,73u8,224u8,74u8,29u8,17u8,93u8,237u8,3u8,152u8,156u8,113u8,255u8,58u8,225u8,],
        );
```
