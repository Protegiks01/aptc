# Audit Report

## Title
Missing Extension Validation in Commit Vote Signing Allows Conflicting Commit Signatures

## Summary
The `sign_commit_vote()` implementation in SafetyRules fails to validate that execution results (state root hash and version) are consistent across multiple signing requests for the same block. This allows a validator to sign multiple conflicting commit votes for identical blocks with different execution results, breaking consensus safety.

## Finding Description

The SafetyRules implementation is designed to prevent validators from signing conflicting consensus messages. For commit votes, the `guarded_sign_commit_vote` function is supposed to ensure that a validator cannot sign two different execution results for the same block.

However, the current validation is incomplete. The function performs three main checks: [1](#0-0) [2](#0-1) [3](#0-2) 

The critical issue is that the `match_ordered_only` function only validates block metadata (epoch, round, id, timestamp) but **does not** validate execution results: [4](#0-3) 

Notably absent from this check are:
- `executed_state_id` (the transaction accumulator root hash)
- `version` (the transaction version number)
- `next_epoch_state`

This means a validator could sign two different commit votes:
- `CommitVote1`: BlockInfo{epoch=1, round=10, id=0xAAA, **executed_state_id=0xXXX, version=100**}
- `CommitVote2`: BlockInfo{epoch=1, round=10, id=0xAAA, **executed_state_id=0xYYY, version=200**}

Both would pass all validation checks because they have the same epoch/round/id/timestamp.

The developers were aware of this gap: [5](#0-4) 

Furthermore, SafetyData does not track commit votes, only order votes: [6](#0-5) 

The absence of commit vote tracking means there is no persistent state to prevent signing multiple conflicting commits for the same block.

**Attack Scenario:**

1. A block B is ordered with 2f+1 order votes
2. The execution engine produces result R1: {state_root: 0xXXX, version: 100}
3. Validator signs commit vote for R1
4. A compromised execution component or race condition produces different result R2: {state_root: 0xYYY, version: 200} for the same block
5. `sign_commit_vote()` is called again with the same `ordered_ledger_info` but different `new_ledger_info` containing R2
6. All validation passes (same epoch/round/id/timestamp)
7. Validator signs conflicting commit vote for R2

If f+1 validators sign conflicting commits due to this vulnerability, different nodes could commit different states, causing a permanent chain split.

## Impact Explanation

**Critical Severity** - This vulnerability breaks the fundamental consensus safety property:

1. **Consensus Safety Violation**: The core invariant that "all honest validators commit identical states" is violated. This falls under the Critical category: "Consensus/Safety violations" worth up to $1,000,000.

2. **Chain Split Risk**: If f+1 validators sign conflicting commits, the network could permanently fork into incompatible chains, requiring a hard fork to recover ("Non-recoverable network partition").

3. **Loss of Funds**: Different validators committing different states could lead to double-spending attacks and loss of user funds.

4. **Defense-in-Depth Failure**: SafetyRules is the last line of defense. Even if execution should be deterministic, SafetyRules must protect against Byzantine components.

The TODO comment explicitly acknowledges this missing validation, suggesting the implementation is incomplete rather than intentionally designed this way.

## Likelihood Explanation

**Medium-High Likelihood:**

1. **Decoupled Execution**: Aptos uses decoupled execution where ordering and execution are separate phases. This increases the attack surface: [7](#0-6) 

2. **Multiple Attack Vectors**:
   - Compromised execution engine
   - Race conditions in execution pipeline
   - Network manipulation to deliver fake execution results
   - Software bugs in execution logic

3. **No Rate Limiting**: There's no mechanism preventing multiple `sign_commit_vote()` calls for the same block.

4. **Acknowledged Gap**: The TODO comment shows developers knew this validation was incomplete.

While execution should be deterministic in a properly functioning system, consensus safety rules should not trust execution components to be non-Byzantine.

## Recommendation

Add an "extension check" that validates execution results are consistent and monotonically increasing. The fix should:

1. **Track Commit History**: Extend SafetyData to include:
   ```rust
   pub struct SafetyData {
       // ... existing fields ...
       pub last_signed_commit_info: Option<BlockInfo>,
   }
   ```

2. **Validate Extension**: In `guarded_sign_commit_vote`, add:
   ```rust
   // After line 410, before line 413:
   
   // Verify execution result consistency
   if let Some(last_commit) = &safety_data.last_signed_commit_info {
       // If we've signed a commit for this epoch/round before
       if last_commit.epoch() == new_ledger_info.epoch() 
          && last_commit.round() == new_ledger_info.round() {
           // Must be identical execution results
           if last_commit.executed_state_id() != new_ledger_info.commit_info().executed_state_id()
              || last_commit.version() != new_ledger_info.commit_info().version() {
               return Err(Error::InconsistentExecutionResult(
                   last_commit.to_string(),
                   new_ledger_info.commit_info().to_string(),
               ));
           }
       }
   }
   
   // Update tracking after successful signature
   safety_data.last_signed_commit_info = Some(new_ledger_info.commit_info().clone());
   self.persistent_storage.set_safety_data(safety_data)?;
   ```

3. **Persist State**: Ensure the updated SafetyData is persisted before returning the signature.

## Proof of Concept

```rust
// Add to consensus/safety-rules/src/tests/suite.rs

fn test_conflicting_commit_votes(safety_rules: &Callback) {
    let (mut safety_rules, signer) = safety_rules();
    let (proof, genesis_qc) = test_utils::make_genesis(&signer);
    
    let round = genesis_qc.certified_block().round();
    safety_rules.initialize(&proof).unwrap();
    
    // Create a chain: genesis -> a1 -> a2 -> a3
    let a1 = test_utils::make_proposal_with_qc(round + 1, genesis_qc, &signer);
    let a2 = make_proposal_with_parent(round + 2, &a1, None, &signer);
    let a3 = make_proposal_with_parent(round + 3, &a2, Some(&a1), &signer);
    
    // Get the ordered ledger info for a1 (from a3's QC)
    let ordered_ledger_info = a3.block().quorum_cert().ledger_info().clone();
    
    // Create first commit ledger info with execution result 1
    let commit_info_1 = a1.block().gen_block_info(
        HashValue::random(), // executed_state_id 1
        100,                  // version 1
        None,
    );
    let commit_ledger_info_1 = LedgerInfo::new(
        commit_info_1,
        ordered_ledger_info.ledger_info().consensus_data_hash(),
    );
    
    // Sign first commit vote - should succeed
    let sig1 = safety_rules
        .sign_commit_vote(ordered_ledger_info.clone(), commit_ledger_info_1.clone())
        .expect("First commit vote should succeed");
    
    // Create CONFLICTING commit ledger info with different execution result
    let commit_info_2 = BlockInfo::new(
        commit_info_1.epoch(),
        commit_info_1.round(),
        commit_info_1.id(),
        HashValue::random(), // DIFFERENT executed_state_id
        200,                  // DIFFERENT version
        commit_info_1.timestamp_usecs(),
        None,
    );
    let commit_ledger_info_2 = LedgerInfo::new(
        commit_info_2,
        ordered_ledger_info.ledger_info().consensus_data_hash(),
    );
    
    // Attempt to sign conflicting commit vote
    // VULNERABILITY: This should fail but currently succeeds!
    let result = safety_rules
        .sign_commit_vote(ordered_ledger_info, commit_ledger_info_2);
    
    // Expected: Err(Error::InconsistentExecutionResult(..))
    // Actual: Ok(signature) - VULNERABILITY!
    assert!(result.is_err(), 
        "Should reject conflicting commit vote, but got: {:?}", result);
}
```

This test demonstrates that SafetyRules will sign two different execution results for the same block, which should never be allowed. The test will **fail** (revealing the vulnerability) because the current implementation incorrectly allows both signatures.

## Notes

The DagCommitSigner implementation has even weaker validation: [8](#0-7) 

It completely ignores the `old_ledger_info` parameter and performs no validation whatsoever, making it even more vulnerable to this attack.

### Citations

**File:** consensus/safety-rules/src/safety_rules.rs (L381-393)
```rust
        if !old_ledger_info.commit_info().is_ordered_only()
            // When doing fast forward sync, we pull the latest blocks and quorum certs from peers
            // and store them in storage. We then compute the root ordered cert and root commit cert
            // from storage and start the consensus from there. But given that we are not storing the
            // ordered cert obtained from order votes in storage, instead of obtaining the root ordered cert
            // from storage, we set root ordered cert to commit certificate.
            // This means, the root ordered cert will not have a dummy executed_state_id in this case.
            // To handle this, we do not raise error if the old_ledger_info.commit_info() matches with
            // new_ledger_info.commit_info().
            && old_ledger_info.commit_info() != new_ledger_info.commit_info()
        {
            return Err(Error::InvalidOrderedLedgerInfo(old_ledger_info.to_string()));
        }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L395-403)
```rust
        if !old_ledger_info
            .commit_info()
            .match_ordered_only(new_ledger_info.commit_info())
        {
            return Err(Error::InconsistentExecutionResult(
                old_ledger_info.commit_info().to_string(),
                new_ledger_info.commit_info().to_string(),
            ));
        }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L406-410)
```rust
        if !self.skip_sig_verify {
            ledger_info
                .verify_signatures(&self.epoch_state()?.verifier)
                .map_err(|error| Error::InvalidQuorumCertificate(error.to_string()))?;
        }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L413-413)
```rust
        // TODO: add extension check
```

**File:** types/src/block_info.rs (L196-204)
```rust
    pub fn match_ordered_only(&self, executed_block_info: &BlockInfo) -> bool {
        self.epoch == executed_block_info.epoch
            && self.round == executed_block_info.round
            && self.id == executed_block_info.id
            && (self.timestamp_usecs == executed_block_info.timestamp_usecs
            // executed block info has changed its timestamp because it's a reconfiguration suffix
                || (self.timestamp_usecs > executed_block_info.timestamp_usecs
                    && executed_block_info.has_reconfiguration()))
    }
```

**File:** consensus/consensus-types/src/safety_data.rs (L10-21)
```rust
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```

**File:** consensus/src/pipeline/buffer_item.rs (L159-163)
```rust
                    let commit_ledger_info = generate_commit_ledger_info(
                        &commit_info,
                        &ordered_proof,
                        order_vote_enabled,
                    );
```

**File:** consensus/src/dag/commit_signer.rs (L19-31)
```rust
impl CommitSignerProvider for DagCommitSigner {
    fn sign_commit_vote(
        &self,
        _ledger_info: aptos_types::ledger_info::LedgerInfoWithSignatures,
        new_ledger_info: aptos_types::ledger_info::LedgerInfo,
    ) -> Result<bls12381::Signature, aptos_safety_rules::Error> {
        let signature = self
            .signer
            .sign(&new_ledger_info)
            .map_err(|err| aptos_safety_rules::Error::SerializationError(err.to_string()))?;

        Ok(signature)
    }
```
