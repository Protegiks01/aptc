# Audit Report

## Title
Division-by-Zero Panic in Proposer Election Due to Unvalidated Consensus Config Weights

## Summary
On-chain consensus configuration parameters can be set to zero values through governance proposals. When these zero-weight configurations are deserialized and used during proposer election, they cause a division-by-zero panic in `choose_index()`, crashing all validator nodes and causing complete network unavailability. [1](#0-0) 

## Finding Description
BCS deserialization validates format correctness (proper encoding, lengths, type tags) but does not validate semantic constraints on numeric values. The consensus configuration contains reputation weights (`active_weight`, `inactive_weight`, `failed_weight`) that are stored on-chain as raw bytes without value validation. [2](#0-1) 

The Move smart contract only validates that the config vector is non-empty, but performs no validation of the actual deserialized values. [3](#0-2) 

When validators load the consensus config and create the proposer election mechanism, these weights are passed directly to `ProposerAndVoterHeuristic`: [4](#0-3) 

The reputation heuristic returns these weights (potentially all zeros) which are then multiplied by voting powers and passed to `choose_index()`: [5](#0-4) 

The `choose_index()` function accumulates weights and then performs modulo operation with the total: [6](#0-5) 

If all weights are zero, `total_weight` becomes zero at line 50, and line 59 calls `next_in_range(state, 0)`, which attempts `% 0` at line 45, **causing a panic**.

## Impact Explanation
This vulnerability qualifies as **Critical Severity** under the Aptos Bug Bounty program category "Total loss of liveness/network availability":

- All validators in the network will crash simultaneously when attempting to elect a proposer
- The network cannot produce new blocks, resulting in complete unavailability
- Requires a hard fork to recover, as the malformed config is stored on-chain
- Affects consensus safety and liveness invariants

## Likelihood Explanation
Likelihood is **Medium to High**:

**Requires**: A governance proposal setting consensus config weights to zero must be approved and executed. This requires:
- Compromised governance (malicious proposal passing)
- Accidental misconfiguration during legitimate governance upgrade
- Attack on governance participants to approve malicious config

**Detection**: Current validation does not catch this issue. BCS deserialization succeeds, and no runtime validation occurs until the panic.

**Triggering**: Automatically triggered on next epoch when proposer election occurs.

## Recommendation
Add validation in the Move smart contract to ensure weights are non-zero and within reasonable bounds:

```move
public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
    system_addresses::assert_aptos_framework(account);
    assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
    
    // Validate config structure before storing
    assert!(validate_consensus_config(&config), error::invalid_argument(EINVALID_CONFIG));
    
    std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
}

native fun validate_consensus_config(config_bytes: &vector<u8>): bool;
```

Additionally, add defensive checks in Rust when consuming config values:

```rust
// In ProposerAndVoterHeuristic::new()
pub fn new(
    author: Author,
    active_weight: u64,
    inactive_weight: u64,
    failed_weight: u64,
    // ...
) -> Self {
    assert!(active_weight > 0, "active_weight must be positive");
    assert!(inactive_weight > 0, "inactive_weight must be positive");
    assert!(failed_weight > 0, "failed_weight must be positive");
    // ...
}
```

And in `choose_index()`:

```rust
pub(crate) fn choose_index(mut weights: Vec<u128>, state: Vec<u8>) -> usize {
    let mut total_weight = 0;
    for w in &mut weights {
        total_weight = total_weight
            .checked_add(w)
            .expect("Total stake shouldn't exceed u128::MAX");
        *w = total_weight;
    }
    assert!(total_weight > 0, "Total weight must be positive for proposer selection");
    // ...
}
```

## Proof of Concept

```rust
#[test]
#[should_panic(expected = "attempt to calculate the remainder with a divisor of zero")]
fn test_zero_weights_panic() {
    use consensus::liveness::proposer_election::choose_index;
    
    // Simulate zero weights from malformed consensus config
    let weights = vec![0u128, 0u128, 0u128];
    let state = vec![1, 2, 3, 4];
    
    // This will panic with division by zero
    choose_index(weights, state);
}
```

To demonstrate the full attack:

```move
#[test(framework = @aptos_framework)]
fun test_malformed_consensus_config(framework: &signer) {
    // Create malformed config with zero weights
    let config = create_zero_weight_consensus_config();
    
    consensus_config::set_for_next_epoch(framework, config);
    aptos_governance::reconfigure(framework);
    
    // On next epoch, all validators will crash when trying to elect proposer
}
```

### Citations

**File:** types/src/on_chain_config/mod.rs (L155-173)
```rust
    // Single-round BCS deserialization from bytes to `Self`
    // This is the expected deserialization pattern if the Rust representation lives natively in Move.
    // but sometimes `deserialize_into_config` may need an extra customized round of deserialization
    // when the data is represented as opaque vec<u8> in Move.
    // In the override, we can reuse this default logic via this function
    // Note: we cannot directly call the default `deserialize_into_config` implementation
    // in its override - this will just refer to the override implementation itself
    fn deserialize_default_impl(bytes: &[u8]) -> Result<Self> {
        bcs::from_bytes::<Self>(bytes)
            .map_err(|e| format_err!("[on-chain config] Failed to deserialize into config: {}", e))
    }

    // Function for deserializing bytes to `Self`
    // It will by default try one round of BCS deserialization directly to `Self`
    // The implementation for the concrete type should override this function if this
    // logic needs to be customized
    fn deserialize_into_config(bytes: &[u8]) -> Result<Self> {
        Self::deserialize_default_impl(bytes)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L552-575)
```rust
#[derive(Clone, Copy, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct ProposerAndVoterConfig {
    // Selection weight for active validators with proposer failures below threshold
    pub active_weight: u64,
    // Selection weight for inactive validators with proposer failures below threshold
    pub inactive_weight: u64,
    // Selection weight for validators with proposer failures above threshold
    pub failed_weight: u64,
    // Thresholed of failures in the rounds validator was selected to be proposer
    // integer values representing percentages, i.e. 12 is 12%.
    pub failure_threshold_percent: u32,
    // Window into history considered for proposer statistics, multiplier
    // on top of number of validators
    pub proposer_window_num_validators_multiplier: usize,
    // Window into history considered for votre statistics, multiplier
    // on top of number of validators
    pub voter_window_num_validators_multiplier: usize,
    // Flag whether to use voting power as multiplier to the weights
    pub weight_by_voting_power: bool,
    // Flag whether to use history from previous epoch (0 if not),
    // representing a number of historical epochs (beyond the current one)
    // to consider.
    pub use_history_from_previous_epoch_max_count: u32,
}
```

**File:** consensus/src/epoch_manager.rs (L319-328)
```rust
                            Box::new(ProposerAndVoterHeuristic::new(
                                self.author,
                                proposer_and_voter_config.active_weight,
                                proposer_and_voter_config.inactive_weight,
                                proposer_and_voter_config.failed_weight,
                                proposer_and_voter_config.failure_threshold_percent,
                                voter_window_size,
                                proposer_window_size,
                                leader_reputation_type.use_reputation_window_from_stale_end(),
                            ));
```

**File:** consensus/src/liveness/leader_reputation.rs (L521-552)
```rust
impl ReputationHeuristic for ProposerAndVoterHeuristic {
    fn get_weights(
        &self,
        epoch: u64,
        epoch_to_candidates: &HashMap<u64, Vec<Author>>,
        history: &[NewBlockEvent],
    ) -> Vec<u64> {
        assert!(epoch_to_candidates.contains_key(&epoch));

        let (votes, proposals, failed_proposals) =
            self.aggregation
                .get_aggregated_metrics(epoch_to_candidates, history, &self.author);

        epoch_to_candidates[&epoch]
            .iter()
            .map(|author| {
                let cur_votes = *votes.get(author).unwrap_or(&0);
                let cur_proposals = *proposals.get(author).unwrap_or(&0);
                let cur_failed_proposals = *failed_proposals.get(author).unwrap_or(&0);

                if cur_failed_proposals * 100
                    > (cur_proposals + cur_failed_proposals) * self.failure_threshold_percent
                {
                    self.failed_weight
                } else if cur_proposals > 0 || cur_votes > 0 {
                    self.active_weight
                } else {
                    self.inactive_weight
                }
            })
            .collect()
    }
```

**File:** consensus/src/liveness/proposer_election.rs (L38-69)
```rust
// next consumes seed and returns random deterministic u64 value in [0, max) range
fn next_in_range(state: Vec<u8>, max: u128) -> u128 {
    // hash = SHA-3-256(state)
    let hash = aptos_crypto::HashValue::sha3_256_of(&state).to_vec();
    let mut temp = [0u8; 16];
    copy_slice_to_vec(&hash[..16], &mut temp).expect("next failed");
    // return hash[0..16]
    u128::from_le_bytes(temp) % max
}

// chose index randomly, with given weight distribution
pub(crate) fn choose_index(mut weights: Vec<u128>, state: Vec<u8>) -> usize {
    let mut total_weight = 0;
    // Create cumulative weights vector
    // Since we own the vector, we can safely modify it in place
    for w in &mut weights {
        total_weight = total_weight
            .checked_add(w)
            .expect("Total stake shouldn't exceed u128::MAX");
        *w = total_weight;
    }
    let chosen_weight = next_in_range(state, total_weight);
    weights
        .binary_search_by(|w| {
            if *w <= chosen_weight {
                Ordering::Less
            } else {
                Ordering::Greater
            }
        })
        .expect_err("Comparison never returns equals, so it's always guaranteed to be error")
}
```
