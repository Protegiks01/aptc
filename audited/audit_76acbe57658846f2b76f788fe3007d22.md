# Audit Report

## Title
Information Disclosure via Unsanitized Error Messages in State Values Query

## Summary
The storage service exposes internal implementation details and storage configuration through error messages when clients request state values at non-existent versions, violating the principle of minimal information disclosure.

## Finding Description

When a client sends a `StateValuesWithProofRequest` with a version that doesn't exist (either too high or pruned), the storage service returns unsanitized error messages containing internal implementation details. [1](#0-0) 

The request flows through the handler which calls into storage layers without version validation: [2](#0-1) 

**Attack Path 1: Future/Non-existent Version**

When requesting a version that doesn't exist (e.g., version 999999999), the JellyfishMerkleIterator attempts to fetch the root node: [3](#0-2) 

The tree reader returns a detailed error exposing internal structure: [4](#0-3) 

This error contains the `NodeKey` structure which includes the version and nibble path: [5](#0-4) 

**Attack Path 2: Pruned Version**

For pruned versions, the error explicitly reveals storage configuration: [6](#0-5) 

These errors are converted to `InternalError` and sent to clients: [7](#0-6) [8](#0-7) 

## Impact Explanation

This is a **Low Severity** information disclosure vulnerability per Aptos bug bounty criteria. It exposes:
- Internal NodeKey structure and Jellyfish Merkle tree implementation details
- Precise pruning boundaries (min_readable_version, min_readable_epoch_snapshot_version)
- Storage configuration information

However, it does NOT:
- Enable theft or manipulation of funds
- Cause consensus violations or safety breaks
- Allow state corruption or manipulation
- Enable validator crashes or performance degradation
- Break any of the 10 critical invariants

## Likelihood Explanation

**Likelihood: High** - Any network peer can trivially exploit this by sending storage service requests with invalid versions. No special privileges or complex attack setup required.

## Recommendation

Implement error sanitization to prevent information leakage:

1. Add version range validation before processing requests
2. Return generic error messages that don't expose internal details
3. Log detailed errors server-side only, not in client responses

Example fix in handler:

```rust
fn get_state_value_chunk_with_proof(
    &self,
    request: &StateValuesWithProofRequest,
) -> aptos_storage_service_types::Result<DataResponse, Error> {
    // Validate version is within serviceable range
    let latest_version = self.storage.get_latest_version()?;
    if request.version > latest_version {
        return Err(Error::InvalidRequest(
            "Requested version exceeds latest available version".into()
        ));
    }
    
    // Check pruning without exposing exact boundaries
    if self.is_version_pruned(request.version)? {
        return Err(Error::InvalidRequest(
            "Requested version has been pruned".into()
        ));
    }
    
    // Wrap storage calls to sanitize errors
    match self.storage.get_state_value_chunk_with_proof(...) {
        Ok(result) => Ok(DataResponse::StateValueChunkWithProof(result)),
        Err(_) => Err(Error::InvalidRequest(
            "Failed to retrieve state values at requested version".into()
        ))
    }
}
```

## Proof of Concept

```rust
// Send request with non-existent version
let request = StorageServiceRequest::new(
    DataRequest::GetStateValuesWithProof(StateValuesWithProofRequest {
        version: 999999999,  // Far future version
        start_index: 0,
        end_index: 100,
    }),
    false
);

// Response will contain InternalError with message like:
// "Storage error encountered: Missing node at NodeKey { version: 999999999, nibble_path: NibblePath { ... } }"

// Send request with pruned version
let request = StorageServiceRequest::new(
    DataRequest::GetStateValuesWithProof(StateValuesWithProofRequest {
        version: 1,  // Very old, likely pruned
        start_index: 0,
        end_index: 100,
    }),
    false
);

// Response will contain InternalError with message like:
// "State merkle at version 1 is pruned. snapshots are available at >= 12345, epoch snapshots are available at >= 10000"
```

## Notes

While this is a valid information disclosure vulnerability, it is correctly categorized as **Low Severity** and represents a minor security concern rather than a critical flaw. The exposed information does not enable direct exploitation of funds, consensus, or state integrity.

### Citations

**File:** state-sync/storage-service/types/src/requests.rs (L343-348)
```rust
#[derive(Clone, Debug, Deserialize, Eq, Hash, PartialEq, Serialize)]
pub struct StateValuesWithProofRequest {
    pub version: u64,     // The version to fetch the state values at
    pub start_index: u64, // The index to start fetching state values (inclusive)
    pub end_index: u64,   // The index to stop fetching state values (inclusive)
}
```

**File:** state-sync/storage-service/server/src/handler.rs (L196-202)
```rust
        process_result.map_err(|error| match error {
            Error::InvalidRequest(error) => StorageServiceError::InvalidRequest(error),
            Error::TooManyInvalidRequests(error) => {
                StorageServiceError::TooManyInvalidRequests(error)
            },
            error => StorageServiceError::InternalError(error.to_string()),
        })
```

**File:** state-sync/storage-service/server/src/handler.rs (L463-476)
```rust
    fn get_state_value_chunk_with_proof(
        &self,
        request: &StateValuesWithProofRequest,
    ) -> aptos_storage_service_types::Result<DataResponse, Error> {
        let state_value_chunk_with_proof = self.storage.get_state_value_chunk_with_proof(
            request.version,
            request.start_index,
            request.end_index,
        )?;

        Ok(DataResponse::StateValueChunkWithProof(
            state_value_chunk_with_proof,
        ))
    }
```

**File:** storage/jellyfish-merkle/src/iterator/mod.rs (L207-220)
```rust
    pub fn new_by_index(reader: Arc<R>, version: Version, start_idx: usize) -> Result<Self> {
        let mut parent_stack = vec![];

        let mut current_node_key = NodeKey::new_empty_path(version);
        let mut current_node = reader.get_node(&current_node_key)?;
        if start_idx >= current_node.leaf_count() {
            return Ok(Self {
                reader,
                version,
                parent_stack,
                done: true,
                phantom_value: PhantomData,
            });
        }
```

**File:** storage/jellyfish-merkle/src/lib.rs (L126-129)
```rust
    fn get_node_with_tag(&self, node_key: &NodeKey, tag: &str) -> Result<Node<K>> {
        self.get_node_option(node_key, tag)?
            .ok_or_else(|| AptosDbError::NotFound(format!("Missing node at {:?}.", node_key)))
    }
```

**File:** storage/jellyfish-merkle/src/node_type/mod.rs (L49-54)
```rust
pub struct NodeKey {
    // The version at which the node is created.
    version: Version,
    // The nibble path this node represents in the tree.
    nibble_path: NibblePath,
}
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L295-302)
```rust
            bail!(
                "{} at version {} is pruned. snapshots are available at >= {}, epoch snapshots are available at >= {}",
                data_type,
                version,
                min_readable_version,
                min_readable_epoch_snapshot_version,
            )
        }
```

**File:** state-sync/storage-service/server/src/error.rs (L43-46)
```rust
impl From<aptos_storage_interface::AptosDbError> for Error {
    fn from(error: aptos_storage_interface::AptosDbError) -> Self {
        Error::StorageErrorEncountered(error.to_string())
    }
```
