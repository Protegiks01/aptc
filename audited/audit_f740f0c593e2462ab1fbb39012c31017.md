# Audit Report

## Title
Panic-Induced Health Check Failure in Indexer Fullnode Service Due to Unsafe Duration Subtraction

## Summary
The `ping()` function in the indexer-grpc fullnode service performs unsafe Duration subtraction when calculating block latency, which causes a panic when block timestamps are in the future due to clock skew between validator and indexer nodes.

## Finding Description
The vulnerability exists in the latency calculation logic within the `ping()` health check endpoint. [1](#0-0) 

The code retrieves a block timestamp from the database and computes latency using:
```rust
let latency = SystemTime::now().duration_since(UNIX_EPOCH).unwrap()
    - Duration::from_micros(timestamp_us);
```

In Rust, the `-` operator for `Duration` types uses `checked_sub()` internally and **panics on underflow** when the right operand is greater than the left operand. This panic occurs when:

1. A validator proposes a block with a timestamp in the future (either due to clock skew or misconfigured system time)
2. The block is accepted by consensus because the only validation is monotonic increase
3. The indexer stores this future timestamp in its database
4. The `ping()` function attempts to calculate latency and triggers underflow

**Why Future Timestamps Are Possible:**

The Aptos framework only validates that block timestamps are strictly monotonically increasing, with no upper bound check against wall clock time: [2](#0-1) 

This validation ensures `timestamp > previous_timestamp` but does NOT prevent `timestamp > current_system_time`.

**Correct Pattern in Codebase:**

Other parts of the codebase handle this scenario correctly by using `saturating_sub()`: [3](#0-2) 

## Impact Explanation
This issue qualifies as **Low Severity** per Aptos bug bounty criteria because:

- **No consensus impact**: The indexer-grpc service is not part of core consensus
- **No funds at risk**: This is a monitoring/health check endpoint
- **Limited availability impact**: Only the `ping()` endpoint is affected; the main transaction streaming functionality (`get_transactions_from_node()`) continues operating normally
- **Service continues running**: The panic is caught by tokio's runtime and only fails individual gRPC requests, not the entire service
- **Non-critical implementation bug**: This falls under the "Low Severity" category of non-critical bugs

The impact is limited to:
- Health check failures causing monitoring systems to mark the indexer as unhealthy
- Prometheus metric `LATENCY_MS` not being updated
- Potential false alerts in monitoring infrastructure [4](#0-3) 

## Likelihood Explanation
**High likelihood** - This can occur naturally without malicious intent:

1. **Clock skew between nodes**: Validator nodes and indexer nodes may have slightly different system clocks
2. **Network time synchronization issues**: NTP synchronization failures can cause clock drift
3. **Timezone/DST misconfiguration**: System time configuration errors
4. **Validator clock ahead**: A validator with a clock several seconds ahead can propose blocks with future timestamps

The scenario does not require:
- Malicious validator behavior
- Coordinated attacks
- Privileged access
- Complex exploitation

## Recommendation
Replace the unsafe `-` operator with `saturating_sub()` to prevent panic on underflow:

```rust
if let Ok(timestamp_us) = self.service_context.context.db.get_block_timestamp(version) {
    let latency = SystemTime::now()
        .duration_since(UNIX_EPOCH)
        .unwrap()
        .saturating_sub(Duration::from_micros(timestamp_us));
    LATENCY_MS.set(latency.as_millis() as i64);
}
```

With `saturating_sub()`, if the block timestamp is in the future, the latency will be clamped to zero instead of panicking, allowing the health check to complete successfully.

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::time::{Duration, SystemTime, UNIX_EPOCH};

    #[test]
    #[should_panic(expected = "overflow when subtracting durations")]
    fn test_panic_on_future_timestamp() {
        // Simulate current time
        let current_time = SystemTime::now().duration_since(UNIX_EPOCH).unwrap();
        
        // Simulate block timestamp 60 seconds in the future
        let future_timestamp_us = (current_time + Duration::from_secs(60)).as_micros() as u64;
        
        // This will panic - demonstrating the vulnerability
        let _latency = current_time - Duration::from_micros(future_timestamp_us);
    }

    #[test]
    fn test_safe_calculation_with_saturating_sub() {
        // Simulate current time
        let current_time = SystemTime::now().duration_since(UNIX_EPOCH).unwrap();
        
        // Simulate block timestamp 60 seconds in the future
        let future_timestamp_us = (current_time + Duration::from_secs(60)).as_micros() as u64;
        
        // This is safe - returns zero instead of panicking
        let latency = current_time.saturating_sub(Duration::from_micros(future_timestamp_us));
        
        assert_eq!(latency.as_millis(), 0);
    }
}
```

## Notes
While this is a valid bug with a concrete panic condition, it is classified as **Low severity** because:
- It affects only the health check endpoint of an indexer service (not core consensus)
- The service continues operating for its primary function (transaction streaming)
- No funds, consensus safety, or state integrity is at risk
- The fix is straightforward and follows existing patterns in the codebase

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L228-231)
```rust
            if let Ok(timestamp_us) = self.service_context.context.db.get_block_timestamp(version) {
                let latency = SystemTime::now().duration_since(UNIX_EPOCH).unwrap()
                    - Duration::from_micros(timestamp_us);
                LATENCY_MS.set(latency.as_millis() as i64);
```

**File:** aptos-move/framework/aptos-framework/sources/timestamp.move (L46-49)
```text
            // Normal block. Time must advance
            assert!(now < timestamp, error::invalid_argument(EINVALID_TIMESTAMP));
            global_timer.microseconds = timestamp;
        };
```

**File:** crates/aptos-rest-client/src/lib.rs (L858-860)
```rust
                                aptos_infallible::duration_since_epoch()
                                    .saturating_sub(Duration::from_micros(timestamp_usecs))
                                    .as_secs()
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/counters.rs (L29-35)
```rust
pub static LATENCY_MS: Lazy<IntGauge> = Lazy::new(|| {
    register_int_gauge!(
        "indexer_grpc_fullnode_latency_ms",
        "Latency of indexer fullnode (comparing with block timestamp).",
    )
    .unwrap()
});
```
