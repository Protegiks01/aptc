# Audit Report

## Title
Frozen Flag Bypass During CoinStore to FungibleStore Migration for Zero-Balance Stores

## Summary
The `maybe_convert_to_fungible_store` function in the Coin module fails to synchronize the frozen flag when migrating a frozen CoinStore with zero balance to a FungibleStore. This allows users to bypass account freezes by exploiting the migration path, withdrawing funds from an unfrozen FungibleStore even when the corresponding CoinStore was frozen by the coin issuer.

## Finding Description
The vulnerability exists in the CoinStore-to-FungibleStore migration logic. The frozen flag synchronization only occurs when the CoinStore being migrated has a non-zero balance, creating a bypass opportunity. [1](#0-0) 

The critical flaw is at lines 656 and 692-693. The frozen flag synchronization (`set_frozen_flag_internal`) only executes when `coin.value > 0`. When a frozen CoinStore with zero balance is migrated while a FungibleStore already exists (with funds), the frozen status is never transferred to the FungibleStore.

**Attack Scenario:**
1. User has a legacy CoinStore containing coins (unfrozen)
2. User withdraws all coins from CoinStore, leaving balance at 0
3. User receives new coins via transfer, which automatically creates a FungibleStore (unfrozen)
4. Coin issuer detects malicious activity and freezes the account by calling `freeze_coin_store`
5. The CoinStore is now frozen with 0 balance; the FungibleStore is unfrozen with funds
6. User calls `migrate_to_fungible_store` 
7. Migration logic sees `coin.value == 0`, skips the frozen flag synchronization block (line 656)
8. User successfully withdraws from the unfrozen FungibleStore, bypassing the freeze

The code comment at lines 687-691 explicitly states the intention to synchronize frozen status "to make the frozen semantic as consistent as possible," but the implementation fails to do this for zero-balance CoinStores. [2](#0-1) 

## Impact Explanation
**Severity: Medium to High**

This vulnerability allows users to bypass account freezes, which undermines a critical security mechanism used to:
- Prevent withdrawal of illicit/stolen funds
- Enforce regulatory compliance (e.g., sanctions, court orders)
- Respond to security incidents

According to Aptos bug bounty criteria, this qualifies as **Medium Severity** (Limited funds loss or manipulation) trending toward **High Severity** due to:
- Bypassing access control mechanisms (frozen flag)
- Potential for loss of funds that should be frozen
- Undermining the coin issuer's ability to enforce freezes

The impact is limited by requiring specific conditions (empty frozen CoinStore + funded unfrozen FungibleStore), but these conditions are achievable in normal operation as accounts transition from the legacy Coin system to the new FungibleAsset system.

## Likelihood Explanation
**Likelihood: Medium**

The vulnerability requires specific but realistic conditions:

1. **Account has both CoinStore and FungibleStore**: This naturally occurs during the transition period as the framework migrates from Coin to FungibleAsset standards
2. **CoinStore has zero balance**: Users commonly drain legacy stores before migration
3. **FungibleStore has funds**: Receiving transfers creates unfrozen FungibleStores automatically
4. **CoinStore is frozen**: Coin issuer must have frozen the account

While not every account will meet these conditions, the scenario is realistic during the migration period. Users who understand the code could intentionally create these conditions to evade freezes.

The attack requires no special privileges - any user with a frozen account can exploit this if they structure their balances appropriately before the freeze occurs, or if they receive funds after being frozen.

## Recommendation
The frozen flag synchronization should occur regardless of the CoinStore balance. Move the frozen flag check outside the `coin.value > 0` conditional:

```move
fun maybe_convert_to_fungible_store<CoinType>(
    account: address
) acquires CoinStore, CoinConversionMap, CoinInfo {
    if (exists<CoinStore<CoinType>>(account)) {
        let CoinStore<CoinType> { coin, frozen, deposit_events, withdraw_events } =
            move_from<CoinStore<CoinType>>(account);
        
        if (is_coin_initialized<CoinType>()) {
            let metadata = ensure_paired_metadata<CoinType>();
            let store = primary_fungible_store::ensure_primary_store_exists(account, metadata);
            
            // Handle coin migration if non-zero
            if (coin.value > 0) {
                event::emit(CoinStoreDeletion { /* ... */ });
                fungible_asset::unchecked_deposit_with_no_events(
                    object_address(&store),
                    coin_to_fungible_asset(coin)
                );
            } else {
                destroy_zero(coin);
            };
            
            // ALWAYS synchronize frozen flag regardless of balance
            if (frozen != fungible_asset::is_frozen(store)) {
                fungible_asset::set_frozen_flag_internal(store, frozen);
            }
        } else {
            destroy_zero(coin);
        };
        
        event::destroy_handle(deposit_events);
        event::destroy_handle(withdraw_events);
    };
}
```

This ensures the frozen status is consistently enforced across both storage systems regardless of balance.

## Proof of Concept

```move
#[test_only]
module test_addr::frozen_bypass_test {
    use aptos_framework::coin::{Self, FreezeCapability};
    use aptos_framework::fungible_asset;
    use aptos_framework::primary_fungible_store;
    use std::signer;

    struct TestCoin {}

    #[test(framework = @aptos_framework, attacker = @0xBAD, helper = @0x123)]
    fun test_frozen_bypass(framework: &signer, attacker: &signer, helper: &signer) {
        // Initialize test coin
        let (burn_cap, freeze_cap, mint_cap) = 
            coin::initialize_and_register_fake_money(attacker, 8, true);
        
        let attacker_addr = signer::address_of(attacker);
        
        // Step 1: Attacker has CoinStore with 100 coins
        let coins = coin::mint<TestCoin>(100, &mint_cap);
        coin::deposit(attacker_addr, coins);
        
        // Step 2: Attacker withdraws all coins (CoinStore now empty)
        let withdrawn = coin::withdraw<TestCoin>(attacker, 100);
        
        // Step 3: Helper sends coins to attacker, creating FungibleStore
        coin::deposit(attacker_addr, withdrawn); // This creates FungibleStore
        
        // Step 4: Coin issuer freezes the account (freezes CoinStore)
        coin::freeze_coin_store<TestCoin>(attacker_addr, &freeze_cap);
        
        // Verify CoinStore is frozen
        assert!(coin::is_coin_store_frozen<TestCoin>(attacker_addr), 1);
        
        // Step 5: Attacker migrates to FungibleStore
        coin::migrate_to_fungible_store<TestCoin>(attacker);
        
        // Step 6: FungibleStore is NOT frozen - bypass successful!
        let metadata = option::destroy_some(coin::paired_metadata<TestCoin>());
        assert!(!primary_fungible_store::is_frozen(attacker_addr, metadata), 2);
        
        // Step 7: Attacker withdraws funds from unfrozen FungibleStore
        let bypassed_coins = coin::withdraw<TestCoin>(attacker, 100);
        
        // Cleanup
        coin::deposit(attacker_addr, bypassed_coins);
        coin::destroy_freeze_cap(freeze_cap);
        coin::destroy_burn_cap(burn_cap);
        coin::destroy_mint_cap(mint_cap);
    }
}
```

This test demonstrates that after migration of a frozen zero-balance CoinStore, the FungibleStore remains unfrozen, allowing the user to withdraw funds that should have been frozen.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/coin.move (L650-701)
```text
    fun maybe_convert_to_fungible_store<CoinType>(
        account: address
    ) acquires CoinStore, CoinConversionMap, CoinInfo {
        if (exists<CoinStore<CoinType>>(account)) {
            let CoinStore<CoinType> { coin, frozen, deposit_events, withdraw_events } =
                move_from<CoinStore<CoinType>>(account);
            if (is_coin_initialized<CoinType>() && coin.value > 0) {
                let metadata = ensure_paired_metadata<CoinType>();
                let store =
                    primary_fungible_store::ensure_primary_store_exists(
                        account, metadata
                    );

                event::emit(
                    CoinStoreDeletion {
                        coin_type: type_info::type_name<CoinType>(),
                        event_handle_creation_address: guid::creator_address(
                            event::guid(&deposit_events)
                        ),
                        deleted_deposit_event_handle_creation_number: guid::creation_num(
                            event::guid(&deposit_events)
                        ),
                        deleted_withdraw_event_handle_creation_number: guid::creation_num(
                            event::guid(&withdraw_events)
                        )
                    }
                );

                if (coin.value == 0) {
                    destroy_zero(coin);
                } else {
                    fungible_asset::unchecked_deposit_with_no_events(
                        object_address(&store),
                        coin_to_fungible_asset(coin)
                    );
                };

                // Note:
                // It is possible the primary fungible store may already exist before this function call.
                // In this case, if the account owns a frozen CoinStore and an unfrozen primary fungible store, this
                // function would convert and deposit the rest coin into the primary store and freeze it to make the
                // `frozen` semantic as consistent as possible.
                if (frozen != fungible_asset::is_frozen(store)) {
                    fungible_asset::set_frozen_flag_internal(store, frozen);
                }
            } else {
                destroy_zero(coin);
            };
            event::destroy_handle(deposit_events);
            event::destroy_handle(withdraw_events);
        };
    }
```
