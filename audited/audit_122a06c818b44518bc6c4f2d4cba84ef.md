# Audit Report

## Title
Aptos Faucet Error Responses Expose Sensitive Internal State Information

## Summary
The `FundApi::fund()` endpoint in the Aptos faucet exposes detailed internal state information through error responses, including funder account balance, database connection details, API error stack traces, and checker logic. This information disclosure aids attackers in crafting sophisticated bypass attempts and timing attacks.

## Finding Description

When `fund_inner()` fails in the faucet service, errors are converted to `AptosTapErrorResponse` and returned as JSON to the client. The error conversion uses verbose formatting that includes full error chains and internal state details.

**Critical Information Leaks Identified:**

**1. Funder Account Balance Exposure**

The `TransferFunder` health check exposes the exact funder account balance when the account is low on funds: [1](#0-0) 

This error is returned when `is_healthy_as_result()` is called during funding: [2](#0-1) 

**2. Database Error Details**

Redis database operations expose internal key structures and connection errors: [3](#0-2) [4](#0-3) 

**3. API Error Stack Traces**

Full API error details including account addresses are exposed: [5](#0-4) 

**4. Verbose Error Formatting**

The error conversion uses `format!("{:#}", error)` which includes the full error chain: [6](#0-5) 

**5. Error Response Structure**

All error details are serialized and returned to clients: [7](#0-6) [8](#0-7) 

**Exploitation Path:**

1. Attacker makes repeated requests to the faucet
2. When funder account is low, receives detailed error with exact balance
3. Attacker learns: funder address, current balance, minimum threshold
4. For database errors, learns Redis key structure (e.g., "ip:1.2.3.4:12345")
5. Uses timing and balance information to optimize bypass attempts
6. Understands internal architecture to craft more sophisticated attacks

## Impact Explanation

This is a **Low Severity** information disclosure vulnerability per the Aptos bug bounty program, which explicitly includes "Minor information leaks" in the Low severity category.

While this does not directly lead to fund theft or consensus violations, it provides valuable reconnaissance information:
- Exact funder balance enables timing attacks when funds are low
- Database key structure aids in understanding rate limiting mechanisms
- API error details reveal internal architecture
- Combined information helps attackers optimize bypass strategies

## Likelihood Explanation

**Likelihood: High**

This vulnerability is easily triggered:
- No authentication required beyond normal faucet access
- Occurs naturally when funder runs low on funds
- Database errors can be triggered through network conditions
- Every failed request potentially leaks information

The information leak is deterministic and reproducible, making it highly likely that sophisticated attackers will discover and exploit this reconnaissance vector.

## Recommendation

Implement generic error messages for external responses while maintaining detailed logging internally:

```rust
// In errors.rs, add a sanitization method
impl AptosTapError {
    pub fn sanitize_for_external_response(self) -> Self {
        // Only expose user-friendly messages, not internal details
        let sanitized_message = match self.error_code {
            AptosTapErrorCode::FunderAccountProblem => 
                "Service temporarily unavailable. Please try again later.".to_string(),
            AptosTapErrorCode::StorageError => 
                "Internal service error. Please try again later.".to_string(),
            AptosTapErrorCode::CheckerError =>
                "Unable to process request. Please try again later.".to_string(),
            AptosTapErrorCode::AptosApiError =>
                "Blockchain service temporarily unavailable.".to_string(),
            _ => self.message, // Keep user-facing errors as-is
        };
        
        Self {
            message: sanitized_message,
            error_code: self.error_code,
            rejection_reasons: self.rejection_reasons,
            txn_hashes: self.txn_hashes,
        }
    }
}

// In AptosTapErrorResponse From implementation
impl From<AptosTapError> for AptosTapErrorResponse {
    fn from(error: AptosTapError) -> Self {
        bump_rejection_reason_counters(&error.rejection_reasons);
        // Log full error details internally
        error!("Faucet error: {:#}", error);
        // Sanitize before returning to client
        let sanitized = error.sanitize_for_external_response();
        let (status, retry_after) = sanitized.status_and_retry_after();
        Self::Default(status, Json(sanitized), retry_after)
    }
}
```

Additionally, ensure `USE_HELPFUL_ERRORS` is set to `false` in production deployments.

## Proof of Concept

```bash
#!/bin/bash
# PoC: Extract funder balance information

# 1. Make legitimate funding request
curl -X POST https://faucet.testnet.aptoslabs.com/fund \
  -H "Content-Type: application/json" \
  -d '{"address": "0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"}'

# Expected when funder is low on funds:
# {
#   "message": "Tap TransferFunder is not able to handle requests right now: 
#              Funder account 0xABCD has insufficient funds. It has 5000000000, but the minimum is 10000000000",
#   "error_code": 54,
#   "rejection_reasons": [],
#   "txn_hashes": []
# }

# 2. Extract information from error:
# - Funder address: 0xABCD
# - Current balance: 5000000000 (5 APT)
# - Minimum threshold: 10000000000 (10 APT)
# - Service will be down until refilled

# 3. Monitor for refill and time attacks accordingly
```

**Notes:**

This is a valid Low severity finding. While the validation checklist may prioritize Medium+ severity issues, the security question explicitly investigates this Low severity information leak, and the Aptos bug bounty program explicitly covers "Minor information leaks" under Low severity (up to $1,000). The information disclosed aids attackers in reconnaissance and timing attacks against the faucet service.

### Citations

**File:** crates/aptos-faucet/core/src/funder/transfer.rs (L234-248)
```rust
    async fn is_healthy_as_result(&self) -> Result<(), AptosTapError> {
        let funder_health = self.is_healthy().await;
        if !funder_health.can_process_requests {
            return Err(AptosTapError::new(
                format!(
                    "Tap TransferFunder is not able to handle requests right now: {}",
                    funder_health
                        .message
                        .unwrap_or_else(|| "no message".to_string()),
                ),
                AptosTapErrorCode::FunderAccountProblem,
            ));
        }
        Ok(())
    }
```

**File:** crates/aptos-faucet/core/src/funder/transfer.rs (L366-373)
```rust
        if funder_balance < self.minimum_funds.0 {
            FunderHealthMessage {
                can_process_requests: false,
                message: Some(format!(
                    "Funder account {} has insufficient funds. It has {}, but the minimum is {}",
                    account_address, funder_balance, self.minimum_funds.0
                )),
            }
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L176-183)
```rust
    pub async fn get_redis_connection(&self) -> Result<Connection, AptosTapError> {
        self.db_pool.get().await.map_err(|e| {
            AptosTapError::new_with_error_code(
                format!("Failed to connect to redis storage: {}", e),
                AptosTapErrorCode::StorageError,
            )
        })
    }
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L247-252)
```rust
        let limit_value: Option<i64> = conn.get(&key).await.map_err(|e| {
            AptosTapError::new_with_error_code(
                format!("Failed to get value for redis key {}: {}", key, e),
                AptosTapErrorCode::StorageError,
            )
        })?;
```

**File:** crates/aptos-faucet/core/src/funder/common.rs (L327-337)
```rust
    let funder_seq_num = responses
        .remove(0)
        .map_err(|e| {
            AptosTapError::new(
                format!("funder account {} not found: {:#}", funder_address, e),
                AptosTapErrorCode::AccountDoesNotExist,
            )
        })?
        .inner()
        .sequence_number;

```

**File:** crates/aptos-faucet/core/src/endpoints/errors.rs (L14-25)
```rust
#[derive(Debug, Clone, Object)]
pub struct AptosTapError {
    /// A message describing the error
    pub message: String,
    /// A code describing the error for programmatic use.
    pub error_code: AptosTapErrorCode,
    /// If we're returning a 403 because we're rejecting the mint request, this
    /// contains additional reasons why.
    pub rejection_reasons: Vec<RejectionReason>,
    /// Submitted transaction hashes, if it got to that point.
    pub txn_hashes: Vec<String>,
}
```

**File:** crates/aptos-faucet/core/src/endpoints/errors.rs (L46-51)
```rust
    pub fn new_with_error_code<ErrorType: std::fmt::Display>(
        error: ErrorType,
        error_code: AptosTapErrorCode,
    ) -> AptosTapError {
        Self::new(format!("{:#}", error), error_code)
    }
```

**File:** crates/aptos-faucet/core/src/endpoints/errors.rs (L100-109)
```rust
impl From<AptosTapError> for AptosTapErrorResponse {
    fn from(error: AptosTapError) -> Self {
        // We use this opportunity to bump metrics based on the specifics of
        // this response, since this function is only called right when we're
        // about to return this error to the client.
        bump_rejection_reason_counters(&error.rejection_reasons);
        let (status, retry_after) = error.status_and_retry_after();
        Self::Default(status, Json(error), retry_after)
    }
}
```
