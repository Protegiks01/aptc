# Audit Report

## Title
Message Type Confusion in NetworkController Enabling Authentication Bypass via Unsafe Deserialization

## Summary
The `NetworkController` in `secure/net` accepts arbitrary `message_type` strings from untrusted network sources and uses them to route messages to registered handlers without authentication or validation. When combined with the executor-service's deserialization of `SignatureVerifiedTransaction` types, this allows an attacker with network access to bypass transaction signature verification and execute arbitrary transactions.

## Finding Description

The vulnerability chain consists of three interconnected issues:

**Issue 1: Unvalidated Message Type Routing**

The `NetworkMessage` protobuf structure contains a `message_type` field that is an arbitrary string. [1](#0-0) 

When messages are received via GRPC, the `message_type` is extracted directly from the protobuf and used as a HashMap key to route messages to handlers, with no validation: [2](#0-1) 

**Issue 2: No Network Layer Authentication**

The GRPC server is configured without TLS or any authentication mechanism: [3](#0-2) 

**Issue 3: Unsafe Deserialization of Trust Markers**

The executor service registers handlers for message types like `execute_command_{shard_id}`. [4](#0-3) 

When execution commands are received, they are deserialized as `RemoteExecutionRequest` containing `AnalyzedTransaction` instances, which wrap `SignatureVerifiedTransaction` types: [5](#0-4) 

These `SignatureVerifiedTransaction` instances are then extracted and passed directly to the VM executor WITHOUT re-verifying signatures: [6](#0-5) 

**The Attack Path:**

1. Attacker crafts a malicious transaction (e.g., transferring funds from victim to attacker)
2. Attacker wraps it in `SignatureVerifiedTransaction::Valid(malicious_txn)` via BCS serialization
3. Attacker creates `AnalyzedTransaction` and `ExecuteBlockCommand` containing these transactions
4. Attacker serializes as `RemoteExecutionRequest::ExecuteBlock` using BCS
5. Attacker sends GRPC request to executor shard with `message_type = "execute_command_0"` and the malicious payload
6. Shard receives, deserializes, and executes the transactions without verifying signatures

**Invariants Broken:**

1. **Transaction Validation**: Signature verification is bypassed completely
2. **Cryptographic Correctness**: Authentication mechanisms are not enforced
3. **Deterministic Execution**: Different code paths (normal vs. remote) have different security properties

## Impact Explanation

**Severity: CRITICAL (if network accessible) / HIGH (if misconfigured)**

Per Aptos bug bounty criteria, this vulnerability enables:

1. **Loss of Funds (Critical)**: Arbitrary transactions can transfer funds without valid signatures
2. **State Corruption (Critical)**: Malicious transactions can corrupt blockchain state
3. **Consensus Safety Violation (Critical)**: Different shards could execute different transactions if selectively attacked

The normal transaction verification flow properly checks signatures: [7](#0-6) 

However, the remote executor path trusts the serialized `SignatureVerifiedTransaction` enum variant without re-verification, allowing complete authentication bypass.

## Likelihood Explanation

**Likelihood: Medium to High (depending on deployment)**

The executor-service is a production workspace member with a standalone binary: [8](#0-7) 

While this service appears designed for internal cluster use, the likelihood depends on:

1. **Network Exposure**: If deployed with external access (misconfiguration, cloud networking, compromised adjacent services)
2. **Insider Threats**: Malicious operators with network access to the cluster
3. **Supply Chain**: Compromised dependencies or tools with network access

The lack of defense-in-depth mechanisms (no authentication, no signature re-verification) means a single network exposure leads to complete compromise.

## Recommendation

**Immediate Fixes:**

1. **Add Authentication**: Implement mutual TLS (mTLS) or message signing for all NetworkController communications
2. **Re-verify Signatures**: Never trust deserialized `SignatureVerifiedTransaction` types from network sources. Always re-verify signatures on the receiving end
3. **Validate Message Types**: Use an enum instead of arbitrary strings, or validate against a whitelist
4. **Network Isolation**: Ensure executor-service is only accessible within trusted network boundaries with strict firewall rules

**Code Fix Example:**

In `remote_cordinator_client.rs`, add signature re-verification:

```rust
pub fn receive_execute_command(&self) -> ExecutorShardCommand<RemoteStateViewClient> {
    match self.command_rx.recv() {
        Ok(message) => {
            let request: RemoteExecutionRequest = bcs::from_bytes(&message.data).unwrap();
            match request {
                RemoteExecutionRequest::ExecuteBlock(command) => {
                    // RE-VERIFY signatures before trusting
                    let verified_transactions: Vec<SignatureVerifiedTransaction> = 
                        command.sub_blocks.into_iter()
                            .map(|txn| Transaction::from(txn).into()) // Forces re-verification
                            .collect();
                    
                    // Continue with verified transactions...
                }
            }
        }
    }
}
```

## Proof of Concept

```rust
// Proof of Concept - demonstrates the vulnerability

#[test]
fn test_message_type_confusion_bypass() {
    use aptos_types::transaction::{Transaction, SignedTransaction, RawTransaction};
    use aptos_secure_net::network_controller::{NetworkController, Message};
    use execution_executor_service::{RemoteExecutionRequest, ExecuteBlockCommand};
    
    // 1. Setup executor service on localhost
    let executor_addr = SocketAddr::new(IpAddr::V4(Ipv4Addr::LOCALHOST), 8080);
    let mut executor_service = ExecutorService::new(
        0, // shard_id
        1, // num_shards
        4, // num_threads
        executor_addr,
        coordinator_addr,
        vec![]
    );
    executor_service.start();
    
    // 2. Craft malicious transaction WITHOUT valid signature
    let malicious_txn = Transaction::UserTransaction(
        SignedTransaction::new(
            RawTransaction::new(
                victim_address,
                sequence_number,
                TransactionPayload::transfer_to_attacker(),
                // ... other fields
            ),
            invalid_signature, // NO VALID SIGNATURE!
            public_key,
        )
    );
    
    // 3. Wrap in SignatureVerifiedTransaction::Valid (lying about verification)
    let fake_verified = SignatureVerifiedTransaction::Valid(malicious_txn);
    let analyzed = AnalyzedTransaction::new(fake_verified);
    
    // 4. Create execution command
    let cmd = RemoteExecutionRequest::ExecuteBlock(ExecuteBlockCommand {
        sub_blocks: SubBlocksForShard::new(vec![analyzed]),
        concurrency_level: 1,
        onchain_config: BlockExecutorConfigFromOnchain::default(),
    });
    
    // 5. Send via GRPC with manipulated message_type
    let network_msg = NetworkMessage {
        message: bcs::to_bytes(&cmd).unwrap(),
        message_type: "execute_command_0".to_string(), // Route to shard 0
    };
    
    // 6. Send to executor service
    grpc_client.simple_msg_exchange(network_msg).await.unwrap();
    
    // 7. Transaction executes WITHOUT signature verification!
    // Victim's funds are transferred to attacker
}
```

**Notes:**

This vulnerability exists at the architectural level where trust boundaries are crossed without re-validation. The executor-service assumes it's running in a trusted environment, but lacks the defensive mechanisms to enforce that assumption. Even if intended for internal use only, the principle of defense-in-depth requires authentication and re-verification at trust boundaries.

### Citations

**File:** protos/rust/src/pb/aptos.remote_executor.v1.rs (L8-13)
```rust
pub struct NetworkMessage {
    #[prost(bytes="vec", tag="1")]
    pub message: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag="2")]
    pub message_type: ::prost::alloc::string::String,
}
```

**File:** secure/net/src/grpc_network_service/mod.rs (L75-86)
```rust
        Server::builder()
            .timeout(std::time::Duration::from_millis(rpc_timeout_ms))
            .add_service(
                NetworkMessageServiceServer::new(self).max_decoding_message_size(MAX_MESSAGE_SIZE),
            )
            .add_service(reflection_service)
            .serve_with_shutdown(server_addr, async {
                server_shutdown_rx.await.ok();
                info!("Received signal to shutdown server at {:?}", server_addr);
            })
            .await
            .unwrap();
```

**File:** secure/net/src/grpc_network_service/mod.rs (L93-114)
```rust
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L32-36)
```rust
        let execute_command_type = format!("execute_command_{}", shard_id);
        let execute_result_type = format!("execute_result_{}", shard_id);
        let command_rx = controller.create_inbound_channel(execute_command_type);
        let result_tx =
            controller.create_outbound_channel(coordinator_address, execute_result_type);
```

**File:** execution/executor-service/src/remote_cordinator_client.rs (L81-99)
```rust
        match self.command_rx.recv() {
            Ok(message) => {
                let _rx_timer = REMOTE_EXECUTOR_TIMER
                    .with_label_values(&[&self.shard_id.to_string(), "cmd_rx"])
                    .start_timer();
                let bcs_deser_timer = REMOTE_EXECUTOR_TIMER
                    .with_label_values(&[&self.shard_id.to_string(), "cmd_rx_bcs_deser"])
                    .start_timer();
                let request: RemoteExecutionRequest = bcs::from_bytes(&message.data).unwrap();
                drop(bcs_deser_timer);

                match request {
                    RemoteExecutionRequest::ExecuteBlock(command) => {
                        let init_prefetch_timer = REMOTE_EXECUTOR_TIMER
                            .with_label_values(&[&self.shard_id.to_string(), "init_prefetch"])
                            .start_timer();
                        let state_keys = Self::extract_state_keys(&command);
                        self.state_view_client.init_for_block(state_keys);
                        drop(init_prefetch_timer);
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_executor_service.rs (L128-131)
```rust
        let signature_verified_transactions: Vec<SignatureVerifiedTransaction> = transactions
            .into_iter()
            .map(|txn| txn.into_txn().into_txn())
            .collect();
```

**File:** types/src/transaction/signature_verified_transaction.rs (L129-138)
```rust
impl From<Transaction> for SignatureVerifiedTransaction {
    fn from(txn: Transaction) -> Self {
        match txn {
            Transaction::UserTransaction(txn) => match txn.verify_signature() {
                Ok(_) => SignatureVerifiedTransaction::Valid(Transaction::UserTransaction(txn)),
                Err(_) => SignatureVerifiedTransaction::Invalid(Transaction::UserTransaction(txn)),
            },
            _ => SignatureVerifiedTransaction::Valid(txn),
        }
    }
```

**File:** execution/executor-service/src/main.rs (L27-48)
```rust
fn main() {
    let args = Args::parse();
    aptos_logger::Logger::new().init();

    let (tx, rx) = crossbeam_channel::unbounded();
    ctrlc::set_handler(move || {
        tx.send(()).unwrap();
    })
    .expect("Error setting Ctrl-C handler");

    let _exe_service = ProcessExecutorService::new(
        args.shard_id,
        args.num_shards,
        args.num_executor_threads,
        args.coordinator_address,
        args.remote_executor_addresses,
    );

    rx.recv()
        .expect("Could not receive Ctrl-C msg from channel.");
    info!("Process executor service shutdown successfully.");
}
```
