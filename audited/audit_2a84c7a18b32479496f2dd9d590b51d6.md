# Audit Report

## Title
LedgerInfo Consistency Issue in Backup Handler - State Root Proof May Reference Uncommitted Versions

## Summary
The `get_state_root_proof()` function in `backup_handler.rs` can return a LedgerInfo from an earlier commit that does not include the requested version, causing proof generation to fail when transactions are committed without accompanying LedgerInfo signatures during chunked execution.

## Finding Description
The vulnerability exists in how `get_state_root_proof()` retrieves the LedgerInfo for a given version: [1](#0-0) 

The function performs these steps:
1. Gets the epoch of the requested version
2. Retrieves the latest LedgerInfo stored for that epoch
3. Attempts to generate a proof using the LedgerInfo's version as the accumulator root

The critical flaw is that `LedgerInfoSchema` stores only one LedgerInfo per epoch (the most recently committed one), which overwrites previous LedgerInfos: [2](#0-1) 

However, transactions can be committed WITHOUT accompanying LedgerInfos during chunked execution: [3](#0-2) 

When `ledger_info_with_sigs` is `None`, the commit proceeds but no LedgerInfo is written to the database. This creates a consistency gap where:
- Transaction data exists for versions 2501-2600
- Latest LedgerInfo in the epoch is at version 2500
- Calling `get_state_root_proof(2600)` retrieves LedgerInfo(2500) and attempts to prove version 2600

The MerkleAccumulator validates bounds and rejects this: [4](#0-3) 

The proof generation fails with error "invalid leaf_index 2600, num_leaves 2501" because the accumulator at version 2500 cannot prove existence of version 2600.

## Impact Explanation
This constitutes a **High severity** issue under "Significant protocol violations" and "API crashes" categories:

1. **Backup System Failures**: Backup operations fail unexpectedly when attempting to backup recently committed versions, compromising disaster recovery capabilities
2. **State Consistency Violation**: Breaks the invariant that committed versions should be provable via the backup API
3. **Operational Impact**: Automated backup systems may repeatedly fail during normal chunked execution patterns, requiring manual intervention

While this doesn't cause consensus violations or fund loss, it represents a significant protocol-level inconsistency that affects critical infrastructure operations (backups) and violates reasonable API contract expectations.

## Likelihood Explanation
**High likelihood** - This occurs regularly during normal operations:

ChunkExecutor commonly commits transactions without LedgerInfos between checkpoints: [5](#0-4) 

Test evidence confirms chunks are committed without updating LedgerInfo: [6](#0-5) 

This happens during:
- State synchronization when replaying chunks
- Fast-sync operations
- Any time ChunkExecutor commits transactions between ledger checkpoints

## Recommendation
Add validation in `get_state_root_proof()` to ensure the LedgerInfo covers the requested version:

```rust
pub fn get_state_root_proof(
    &self,
    version: Version,
) -> Result<(TransactionInfoWithProof, LedgerInfoWithSignatures)> {
    let ledger_metadata_db = self.ledger_db.metadata_db();
    let epoch = ledger_metadata_db.get_epoch(version)?;
    let ledger_info = ledger_metadata_db.get_latest_ledger_info_in_epoch(epoch)?;
    
    // Validate that the LedgerInfo includes the requested version
    ensure!(
        ledger_info.ledger_info().version() >= version,
        "LedgerInfo at version {} does not include requested version {}",
        ledger_info.ledger_info().version(),
        version
    );
    
    let txn_info = self
        .ledger_db
        .transaction_info_db()
        .get_transaction_info_with_proof(
            version,
            ledger_info.ledger_info().version(),
            self.ledger_db.transaction_accumulator_db(),
        )?;

    Ok((txn_info, ledger_info))
}
```

Alternatively, document this behavior clearly and require callers to verify the LedgerInfo version, or wait for a suitable LedgerInfo to be committed before requesting proofs.

## Proof of Concept

```rust
// This test demonstrates the vulnerability
#[test]
fn test_backup_handler_ledger_info_consistency() {
    use aptos_types::transaction::Version;
    
    // Setup: Initialize AptosDB and BackupHandler
    let db = create_test_db();
    let backup_handler = db.get_backup_handler();
    
    // Step 1: Commit genesis (version 0) with LedgerInfo
    commit_genesis(&db);
    
    // Step 2: Commit chunk at versions 1-100 WITH LedgerInfo at version 100 for epoch 1
    let chunk1 = create_test_chunk(1, 100);
    let ledger_info_100 = create_test_ledger_info(100, 1);
    db.save_transactions(chunk1, Some(&ledger_info_100), false).unwrap();
    
    // Step 3: Commit chunk at versions 101-200 WITHOUT LedgerInfo (common during state sync)
    let chunk2 = create_test_chunk(101, 200);
    db.save_transactions(chunk2, None, false).unwrap();
    
    // Step 4: Attempt to get state root proof for version 150
    // This should fail because latest LedgerInfo in epoch 1 is at version 100
    let result = backup_handler.get_state_root_proof(150);
    
    // Verify the failure
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("invalid leaf_index"));
    
    // The error occurs because:
    // - get_epoch(150) returns epoch 1
    // - get_latest_ledger_info_in_epoch(1) returns LedgerInfo(100)
    // - get_transaction_proof(150, 100) fails: 150 >= 101 (num_leaves)
}
```

## Notes
This vulnerability demonstrates a fundamental inconsistency between the transaction commit model (allowing commits without LedgerInfo) and the backup API assumptions (assuming LedgerInfo always covers requested versions). The issue is exacerbated by the epoch-keyed LedgerInfo storage which only retains the latest LedgerInfo per epoch, creating gaps in provability for intermediate versions during chunked execution.

### Citations

**File:** storage/aptosdb/src/backup/backup_handler.rs (L188-204)
```rust
    pub fn get_state_root_proof(
        &self,
        version: Version,
    ) -> Result<(TransactionInfoWithProof, LedgerInfoWithSignatures)> {
        let ledger_metadata_db = self.ledger_db.metadata_db();
        let epoch = ledger_metadata_db.get_epoch(version)?;
        let ledger_info = ledger_metadata_db.get_latest_ledger_info_in_epoch(epoch)?;
        let txn_info = self
            .ledger_db
            .transaction_info_db()
            .get_transaction_info_with_proof(
                version,
                ledger_info.ledger_info().version(),
                self.ledger_db.transaction_accumulator_db(),
            )?;

        Ok((txn_info, ledger_info))
```

**File:** storage/aptosdb/src/ledger_db/ledger_metadata_db.rs (L186-198)
```rust
    pub(crate) fn put_ledger_info(
        &self,
        ledger_info_with_sigs: &LedgerInfoWithSignatures,
        batch: &mut SchemaBatch,
    ) -> Result<()> {
        let ledger_info = ledger_info_with_sigs.ledger_info();

        if ledger_info.ends_epoch() {
            // This is the last version of the current epoch, update the epoch by version index.
            batch.put::<EpochByVersionSchema>(&ledger_info.version(), &ledger_info.epoch())?;
        }
        batch.put::<LedgerInfoSchema>(&ledger_info.epoch(), ledger_info_with_sigs)
    }
```

**File:** storage/storage-interface/src/lib.rs (L608-627)
```rust
    fn save_transactions(
        &self,
        chunk: ChunkToCommit,
        ledger_info_with_sigs: Option<&LedgerInfoWithSignatures>,
        sync_commit: bool,
    ) -> Result<()> {
        // For reconfig suffix.
        if ledger_info_with_sigs.is_none() && chunk.is_empty() {
            return Ok(());
        }

        if !chunk.is_empty() {
            self.pre_commit_ledger(chunk.clone(), sync_commit)?;
        }
        let version_to_commit = if let Some(ledger_info_with_sigs) = ledger_info_with_sigs {
            ledger_info_with_sigs.ledger_info().version()
        } else {
            chunk.expect_last_version()
        };
        self.commit_ledger(version_to_commit, ledger_info_with_sigs, Some(chunk))
```

**File:** storage/accumulator/src/lib.rs (L358-367)
```rust
    fn get_proof(&self, leaf_index: u64) -> Result<AccumulatorProof<H>> {
        ensure!(
            leaf_index < self.num_leaves,
            "invalid leaf_index {}, num_leaves {}",
            leaf_index,
            self.num_leaves
        );
        let siblings = self.get_siblings(leaf_index, |_p| true)?;
        Ok(AccumulatorProof::new(siblings))
    }
```

**File:** execution/executor/src/chunk_executor/mod.rs (L261-288)
```rust
    fn commit_chunk_impl(&self) -> Result<ExecutedChunk> {
        let _timer = CHUNK_OTHER_TIMERS.timer_with(&["commit_chunk_impl__total"]);
        let chunk = {
            let _timer =
                CHUNK_OTHER_TIMERS.timer_with(&["commit_chunk_impl__next_chunk_to_commit"]);
            self.commit_queue.lock().next_chunk_to_commit()?
        };

        let output = chunk.output.expect_complete_result();
        let num_txns = output.num_transactions_to_commit();
        if chunk.ledger_info_opt.is_some() || num_txns != 0 {
            let _timer = CHUNK_OTHER_TIMERS.timer_with(&["commit_chunk_impl__save_txns"]);
            // TODO(aldenhu): remove since there's no practical strategy to recover from this error.
            fail_point!("executor::commit_chunk", |_| {
                Err(anyhow::anyhow!("Injected error in commit_chunk"))
            });
            self.db.writer.save_transactions(
                output.as_chunk_to_commit(),
                chunk.ledger_info_opt.as_ref(),
                false, // sync_commit
            )?;
        }

        let _timer = CHUNK_OTHER_TIMERS.timer_with(&["commit_chunk_impl__dequeue_and_return"]);
        self.commit_queue.lock().dequeue_committed()?;

        Ok(chunk)
    }
```

**File:** execution/executor/src/tests/chunk_executor_tests.rs (L56-81)
```rust
    // Execute the first chunk. After that we should still get the genesis ledger info from DB.
    executor
        .execute_chunk(chunks[0].clone(), &ledger_info, None)
        .unwrap();
    executor.commit_chunk().unwrap();
    let li = db.reader.get_latest_ledger_info().unwrap();
    assert_eq!(li.ledger_info().version(), 0);
    assert_eq!(li.ledger_info().consensus_block_id(), HashValue::zero());

    // Execute the second chunk. After that we should still get the genesis ledger info from DB.
    executor
        .execute_chunk(chunks[1].clone(), &ledger_info, None)
        .unwrap();
    executor.commit_chunk().unwrap();
    let li = db.reader.get_latest_ledger_info().unwrap();
    assert_eq!(li.ledger_info().version(), 0);
    assert_eq!(li.ledger_info().consensus_block_id(), HashValue::zero());

    // Execute the third chunk. After that we should get the new ledger info.
    executor
        .execute_chunk(chunks[2].clone(), &ledger_info, None)
        .unwrap();
    executor.commit_chunk().unwrap();
    let li = db.reader.get_latest_ledger_info().unwrap();
    assert_eq!(li, ledger_info);
}
```
