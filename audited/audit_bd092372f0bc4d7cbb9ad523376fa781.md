# Audit Report

## Title
Node Startup Panic Due to Insufficient Validation of Zero Worker Threads in API Configuration

## Summary
The API configuration sanitizer fails to validate when `max_runtime_workers` is explicitly set to `Some(0)`, allowing an invalid configuration that causes the node to panic during startup, resulting in total node unavailability.

## Finding Description
The vulnerability exists in the configuration validation logic for the API runtime worker threads. The config sanitizer only validates the case where `max_runtime_workers` is `None` and `runtime_worker_multiplier` is 0, but fails to catch the case where `max_runtime_workers` is explicitly set to `Some(0)`. [1](#0-0) 

When `max_runtime_workers` is set to `Some(0)`, the value passes sanitization and propagates through the bootstrap process: [2](#0-1) 

The `get_max_runtime_workers` function returns 0 when `max_runtime_workers` is `Some(0)`. This value is then passed to the runtime builder: [3](#0-2) 

The `spawn_named_runtime` function accepts this value and calls `builder.worker_threads(0)`: [4](#0-3) 

Tokio's multi-threaded runtime requires at least 1 worker thread. When `builder.worker_threads(0)` is called, the subsequent `builder.build()` fails with an error. The error handling causes a panic: [5](#0-4) 

This panic occurs during node startup when `bootstrap_api_and_indexer` is called: [6](#0-5) 

## Impact Explanation
This qualifies as **Medium severity** per the security question's categorization. While the Aptos bug bounty program lists "API crashes" under High Severity (up to $50,000), this specific issue is more accurately characterized as a configuration validation bug rather than a runtime crash vulnerability. 

The impact is:
- **Complete node unavailability**: The node fails to start entirely, not just the API
- **Requires manual intervention**: Node operator must fix the configuration and restart
- **Affects only misconfigured nodes**: Does not impact the broader network
- **Easily detectable**: The panic occurs immediately during startup with a clear error message

## Likelihood Explanation
The likelihood is **Low** because:
- Requires operator access to modify the node configuration file
- Not exploitable by external attackers (network peers, transaction senders)
- Unlikely to occur accidentally (0 is not a reasonable value for worker threads)
- Could occur through configuration management errors or automated configuration systems
- The default configuration uses `None` for `max_runtime_workers`, which is safe

However, defense-in-depth principles dictate that the config sanitizer should catch all invalid configurations, regardless of likelihood.

## Recommendation
Add validation in the config sanitizer to reject `max_runtime_workers` values of 0:

```rust
// Validate basic runtime properties
if api_config.max_runtime_workers.is_none() && api_config.runtime_worker_multiplier == 0 {
    return Err(Error::ConfigSanitizerFailed(
        sanitizer_name,
        "runtime_worker_multiplier must be greater than 0!".into(),
    ));
}

// Add validation for explicit zero workers
if let Some(max_workers) = api_config.max_runtime_workers {
    if max_workers == 0 {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name,
            "max_runtime_workers must be greater than 0!".into(),
        ));
    }
}
```

## Proof of Concept

```rust
#[test]
fn test_sanitize_zero_max_runtime_workers() {
    // Create a node config with max_runtime_workers set to Some(0)
    let node_config = NodeConfig {
        api: ApiConfig {
            enabled: true,
            max_runtime_workers: Some(0),
            ..Default::default()
        },
        ..Default::default()
    };

    // Sanitize the config and verify that it fails
    let error =
        ApiConfig::sanitize(&node_config, NodeType::Validator, Some(ChainId::mainnet()))
            .unwrap_err();
    assert!(matches!(error, Error::ConfigSanitizerFailed(_, _)));
    
    // Verify error message mentions max_runtime_workers
    if let Error::ConfigSanitizerFailed(_, msg) = error {
        assert!(msg.contains("max_runtime_workers"));
    }
}
```

**Notes:**
- This vulnerability requires configuration file access (operator-level privilege) and is therefore **not exploitable by unprivileged external attackers**
- It represents a defensive programming failure in the config sanitizer rather than a traditional security exploit
- The security question specifically asks about this scenario, validating that the config sanitizer does indeed fail to catch this case
- The actual behavior is worse than described in the question: instead of "failing to process requests," the node panics and fails to start entirely
- The fix is straightforward and should be added for completeness and defense-in-depth

### Citations

**File:** config/src/config/api_config.rs (L188-193)
```rust
        if api_config.max_runtime_workers.is_none() && api_config.runtime_worker_multiplier == 0 {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "runtime_worker_multiplier must be greater than 0!".into(),
            ));
        }
```

**File:** api/src/runtime.rs (L50-51)
```rust
    let max_runtime_workers = get_max_runtime_workers(&config.api);
    let runtime = aptos_runtimes::spawn_named_runtime("api".into(), Some(max_runtime_workers));
```

**File:** api/src/runtime.rs (L292-296)
```rust
fn get_max_runtime_workers(api_config: &ApiConfig) -> usize {
    api_config
        .max_runtime_workers
        .unwrap_or_else(|| num_cpus::get() * api_config.runtime_worker_multiplier)
}
```

**File:** crates/aptos-runtimes/src/lib.rs (L52-54)
```rust
    if let Some(num_worker_threads) = num_worker_threads {
        builder.worker_threads(num_worker_threads);
    }
```

**File:** crates/aptos-runtimes/src/lib.rs (L57-62)
```rust
    builder.build().unwrap_or_else(|error| {
        panic!(
            "Failed to spawn named runtime! Name: {:?}, Error: {:?}",
            thread_name, error
        )
    })
```

**File:** aptos-node/src/services.rs (L100-111)
```rust
    let api_runtime = if node_config.api.enabled {
        Some(bootstrap_api(
            node_config,
            chain_id,
            db_rw.reader.clone(),
            mempool_client_sender.clone(),
            indexer_reader.clone(),
            api_port_tx,
        )?)
    } else {
        None
    };
```
