# Audit Report

## Title
Stale One-Chain Round Values in Order Vote Processing Enable Consensus Safety Violations

## Summary
The `construct_and_sign_order_vote()` function updates `one_chain_round` in memory via `observe_qc()` before performing safety checks. If the safety check `safe_for_order_vote()` fails, the function returns an error without persisting the updated `one_chain_round` value. This creates a stale state vulnerability where validators may later sign timeouts with outdated QC information, violating 2-chain BFT safety guarantees.

## Finding Description

In the 2-chain BFT consensus protocol implemented by Aptos, validators must track the highest 1-chain round they've observed via the `one_chain_round` field in `SafetyData`. This value is critical for timeout safety: validators should only sign timeouts if their included QC is at least as recent as the highest QC they've observed.

The vulnerability exists in the order of operations in `guarded_construct_and_sign_order_vote()`: [1](#0-0) 

The function calls `observe_qc()` at line 108, which updates `one_chain_round` in the in-memory `safety_data`: [2](#0-1) 

However, the safety check `safe_for_order_vote()` occurs AFTER this update at line 110: [3](#0-2) 

If this safety check fails (when `block.round() <= highest_timeout_round`), the function returns an error before reaching line 117 where `set_safety_data()` would persist the updated state. The in-memory update to `one_chain_round` is lost.

This differs from the regular voting path where safety checks occur BEFORE `observe_qc()`: [4](#0-3) 

**Attack Scenario:**

1. **Initial State:** Validator has `one_chain_round = 1`, `highest_timeout_round = 4`

2. **Trigger:** Network delivers OrderVoteProposal for block at round 3 with QC certifying round 3
   - `observe_qc()` updates `one_chain_round` to 3 in memory
   - `safe_for_order_vote(round=3)` checks: `3 > 4`? NO → Returns `Error::NotSafeForOrderVote`
   - Function exits; `one_chain_round` remains 1 in persistent storage

3. **Exploitation:** Validator later receives timeout request for round 5 with QC at round 2
   - Loads `safety_data` with stale `one_chain_round = 1`
   - `safe_to_timeout()` checks: `qc_round(2) >= one_chain_round(1)`? YES [5](#0-4) 

   - Validator signs timeout with QC at round 2

4. **Safety Violation:** Validator signed a timeout with QC at round 2, despite having observed and verified a certified QC at round 3. This violates the monotonicity requirement of 2-chain BFT safety rules.

## Impact Explanation

This is a **HIGH severity** consensus safety violation per Aptos bug bounty criteria. The vulnerability allows validators to sign timeouts with stale QCs that are older than QCs they've already observed. This breaks the fundamental safety guarantee of the 2-chain BFT protocol.

**Potential Consequences:**
- Byzantine validators can exploit this to construct conflicting timeout certificates
- Violates the "Consensus Safety: AptosBFT must prevent double-spending and chain splits under < 1/3 Byzantine" invariant
- Could enable chain forks or consensus disagreements between honest validators
- Affects network liveness and safety guarantees

The impact qualifies as "Significant protocol violations" under the High Severity category.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

**Triggering Conditions:**
1. Validator has previously signed a timeout (setting `highest_timeout_round`)
2. Network delivers order vote proposal for block at round R where R ≤ `highest_timeout_round`
3. The QC in this proposal has a higher round than current `one_chain_round`
4. Validator later receives timeout request with QC round between old and new `one_chain_round`

These conditions can occur naturally in normal network operation when:
- Validators experience network partitions or message delays
- Timeout certificates are generated during view changes
- Order vote proposals arrive out-of-order due to network asynchrony

The vulnerability doesn't require Byzantine behavior to trigger, though Byzantine actors could deliberately exploit it to violate consensus safety.

## Recommendation

**Fix: Move `observe_qc()` call to occur AFTER safety checks pass**

The order vote path should match the regular voting path pattern. Move the `observe_qc()` call to after `safe_for_order_vote()`:

```rust
pub(crate) fn guarded_construct_and_sign_order_vote(
    &mut self,
    order_vote_proposal: &OrderVoteProposal,
) -> Result<OrderVote, Error> {
    // Exit early if we cannot sign
    self.signer()?;
    self.verify_order_vote_proposal(order_vote_proposal)?;
    let proposed_block = order_vote_proposal.block();
    let mut safety_data = self.persistent_storage.safety_data()?;

    // Safety check FIRST
    self.safe_for_order_vote(proposed_block, &safety_data)?;
    
    // Record 1-chain data AFTER safety check passes
    self.observe_qc(order_vote_proposal.quorum_cert(), &mut safety_data);
    
    // Construct and sign order vote
    let author = self.signer()?.author();
    let ledger_info =
        LedgerInfo::new(order_vote_proposal.block_info().clone(), HashValue::zero());
    let signature = self.sign(&ledger_info)?;
    let order_vote = OrderVote::new_with_signature(author, ledger_info.clone(), signature);
    self.persistent_storage.set_safety_data(safety_data)?;
    Ok(order_vote)
}
```

This ensures `one_chain_round` is only updated when the order vote is actually signed, maintaining consistency between observed QCs and signed votes.

## Proof of Concept

Add this test to `consensus/safety-rules/src/tests/suite.rs`:

```rust
fn test_stale_one_chain_round_vulnerability(safety_rules: &Callback) {
    let (mut safety_rules, signer) = safety_rules();
    let (proof, genesis_qc) = test_utils::make_genesis(&signer);
    let round = genesis_qc.certified_block().round();
    let epoch = genesis_qc.certified_block().epoch();

    // Build chain: genesis -> p0 -> p1 -> p2 -> p3
    let p0 = test_utils::make_proposal_with_qc(round + 1, genesis_qc.clone(), &signer);
    let p1 = test_utils::make_proposal_with_parent(Payload::empty(false, true), round + 2, &p0, None, &signer);
    let p2 = test_utils::make_proposal_with_parent(Payload::empty(false, true), round + 3, &p1, None, &signer);
    let p3 = test_utils::make_proposal_with_parent(Payload::empty(false, true), round + 4, &p2, None, &signer);

    safety_rules.initialize(&proof).unwrap();
    
    // Vote on p0 to establish one_chain_round = 0 (genesis)
    safety_rules.construct_and_sign_vote_two_chain(&p0, None).unwrap();
    
    // Sign timeout for round 4, setting highest_timeout_round = 4
    safety_rules.sign_timeout_with_qc(
        &TwoChainTimeout::new(epoch, round + 4, p3.block().quorum_cert().clone()),
        None
    ).unwrap();
    
    // Create order vote proposal for p2 (round 3) with QC from p3 certifying p2 (round 3)
    let ov_p2 = OrderVoteProposal::new(
        p2.block().clone(),
        p3.block().quorum_cert().certified_block().clone(),
        Arc::new(p3.block().quorum_cert().clone()),
    );
    
    // This should fail due to safe_for_order_vote (round 3 > highest_timeout_round 4? NO)
    // BUG: observe_qc() was called before the check, updating one_chain_round to 3 in memory
    // but this update is NOT persisted when the function returns error
    assert_err!(safety_rules.construct_and_sign_order_vote(&ov_p2));
    
    // Now attempt to sign timeout for round 5 with QC at round 2
    // This should FAIL because one_chain_round should be 3 (from observing p2's QC)
    // But due to the bug, one_chain_round is still 0, so this incorrectly succeeds
    let result = safety_rules.sign_timeout_with_qc(
        &TwoChainTimeout::new(epoch, round + 5, p2.block().quorum_cert().clone()),
        Some(&test_utils::make_timeout_cert(round + 4, p3.block().quorum_cert(), &signer))
    );
    
    // VULNERABILITY: This should fail with NotSafeToTimeout(5, 2, 4, 3)
    // but actually succeeds because one_chain_round is stale (0 instead of 3)
    // Validator signed timeout with stale QC violating 2-chain safety!
    assert!(result.is_ok(), "BUG: Validator signed timeout with stale QC!");
}
```

Expected behavior: The final timeout signature should fail because the validator observed a QC at round 3.

Actual behavior: The timeout signature succeeds because `one_chain_round` was not persisted when the order vote failed, allowing the validator to sign a timeout with a stale QC at round 2.

### Citations

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L81-84)
```rust
        self.safe_to_vote(proposed_block, timeout_cert)?;

        // Record 1-chain data
        self.observe_qc(proposed_block.quorum_cert(), &mut safety_data);
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L97-119)
```rust
    pub(crate) fn guarded_construct_and_sign_order_vote(
        &mut self,
        order_vote_proposal: &OrderVoteProposal,
    ) -> Result<OrderVote, Error> {
        // Exit early if we cannot sign
        self.signer()?;
        self.verify_order_vote_proposal(order_vote_proposal)?;
        let proposed_block = order_vote_proposal.block();
        let mut safety_data = self.persistent_storage.safety_data()?;

        // Record 1-chain data
        self.observe_qc(order_vote_proposal.quorum_cert(), &mut safety_data);

        self.safe_for_order_vote(proposed_block, &safety_data)?;
        // Construct and sign order vote
        let author = self.signer()?.author();
        let ledger_info =
            LedgerInfo::new(order_vote_proposal.block_info().clone(), HashValue::zero());
        let signature = self.sign(&ledger_info)?;
        let order_vote = OrderVote::new_with_signature(author, ledger_info.clone(), signature);
        self.persistent_storage.set_safety_data(safety_data)?;
        Ok(order_vote)
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L124-145)
```rust
    fn safe_to_timeout(
        &self,
        timeout: &TwoChainTimeout,
        maybe_tc: Option<&TwoChainTimeoutCertificate>,
        safety_data: &SafetyData,
    ) -> Result<(), Error> {
        let round = timeout.round();
        let qc_round = timeout.hqc_round();
        let tc_round = maybe_tc.map_or(0, |tc| tc.round());
        if (round == next_round(qc_round)? || round == next_round(tc_round)?)
            && qc_round >= safety_data.one_chain_round
        {
            Ok(())
        } else {
            Err(Error::NotSafeToTimeout(
                round,
                qc_round,
                tc_round,
                safety_data.one_chain_round,
            ))
        }
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L168-178)
```rust
    fn safe_for_order_vote(&self, block: &Block, safety_data: &SafetyData) -> Result<(), Error> {
        let round = block.round();
        if round > safety_data.highest_timeout_round {
            Ok(())
        } else {
            Err(Error::NotSafeForOrderVote(
                round,
                safety_data.highest_timeout_round,
            ))
        }
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L135-156)
```rust
    pub(crate) fn observe_qc(&self, qc: &QuorumCert, safety_data: &mut SafetyData) -> bool {
        let mut updated = false;
        let one_chain = qc.certified_block().round();
        let two_chain = qc.parent_block().round();
        if one_chain > safety_data.one_chain_round {
            safety_data.one_chain_round = one_chain;
            trace!(
                SafetyLogSchema::new(LogEntry::OneChainRound, LogEvent::Update)
                    .preferred_round(safety_data.one_chain_round)
            );
            updated = true;
        }
        if two_chain > safety_data.preferred_round {
            safety_data.preferred_round = two_chain;
            trace!(
                SafetyLogSchema::new(LogEntry::PreferredRound, LogEvent::Update)
                    .preferred_round(safety_data.preferred_round)
            );
            updated = true;
        }
        updated
    }
```
