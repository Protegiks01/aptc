# Audit Report

## Title
Path Traversal in Move Package Dependency Resolution Allows Arbitrary Filesystem Access

## Summary
The Move package dependency resolver accepts absolute paths for local dependencies without validation, allowing malicious Move.toml manifests to access arbitrary filesystem locations during package compilation. This bypasses intended sandboxing boundaries and can be exploited when compiling untrusted packages.

## Finding Description

The vulnerability exists in the dependency resolution logic where local package dependencies are processed. [1](#0-0) 

When a `PackageLocation::Local` dependency is deserialized from Move.toml, the path is stored without validation. During resolution, the code explicitly allows absolute paths when the parent package is local: [2](#0-1) 

The critical issue is at lines 329-330 where absolute paths are accepted directly without any security checks to ensure they remain within safe boundaries. The path is then canonicalized, but `CanonicalPath::new()` only resolves symbolic links and converts to absolute formâ€”it does NOT restrict access: [3](#0-2) 

**Contrast with Git Dependencies:** The developers implemented protection for git repositories, explicitly rejecting absolute paths: [4](#0-3) 

This inconsistency indicates awareness of path traversal risks, but incomplete mitigation.

**Attack Scenario:**
1. Attacker creates malicious Move.toml with: `MaliciousDep = { local = "/etc/" }` or `EvilDep = { local = "/root/.ssh/" }`
2. Victim runs `aptos move compile` or similar build command
3. Resolver attempts to access arbitrary system paths
4. Even if Move.toml doesn't exist at target location, directory probing is possible via error message analysis
5. If attacker can place malicious Move package at predictable path (e.g., `/tmp/exploit/`), arbitrary code compilation occurs

## Impact Explanation

**Severity: HIGH** (for hosted services) / **MEDIUM** (for local development)

While this does NOT directly affect blockchain consensus, execution, or on-chain security, it represents a significant security boundary violation:

1. **Hosted Compilation Services**: If Aptos operates or plans to operate package registries, online IDEs, or CI/CD services that compile untrusted Move packages, this allows complete filesystem access within the service's permission context - potentially **CRITICAL**.

2. **Supply Chain Attacks**: Malicious packages in dependency chains can probe filesystem structure, leak sensitive information, or include backdoored code from attacker-controlled paths.

3. **Developer Machine Compromise**: When developers compile packages from untrusted sources, their local filesystem becomes accessible to the malicious package.

4. **Breaks Sandboxing Assumptions**: Any security model assuming Move compilation is sandboxed is violated.

This meets the **High Severity** criteria under "Significant protocol violations" if interpreted broadly, or **Medium Severity** under "State inconsistencies requiring intervention" as it affects the integrity of the build system.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

Exploitation requires:
- Victim compiling a package with malicious Move.toml (EASY - common in open source development)
- Attacker controlling Move.toml content (EASY - pull requests, dependencies of dependencies)
- For maximum impact: hosted compilation service context (MEDIUM - depends on Aptos infrastructure)

The attack is **straightforward to execute** and requires no special privileges. Developers routinely compile third-party packages, making this a realistic threat vector. The vulnerability is particularly dangerous in automated CI/CD pipelines that build community packages.

## Recommendation

Implement strict validation for local dependency paths to ensure they cannot escape the project directory structure:

```rust
// In resolver.rs, replace lines 326-350 with:
SourceLocation::Local { path: parent_path } => {
    let dep_manifest_path = if local_path.is_absolute() {
        // REJECT absolute paths for security
        bail!(
            "local dependency cannot use absolute path: {}. Use relative paths only.",
            local_path.display()
        );
    } else {
        parent_path.join(local_path)
    };
    
    // Validate the resolved path doesn't escape via ../ 
    let canonical_path = CanonicalPath::new(&dep_manifest_path).map_err(|err| {
        anyhow!(
            "failed to find package at {}: {}",
            dep_manifest_path.display(),
            err
        )
    })?;
    
    // Ensure canonical path is within allowed boundaries
    if !canonical_path.starts_with(&**parent_path) {
        bail!(
            "local dependency path escapes package directory: {}",
            dep_manifest_path.display()
        );
    }

    let identity = PackageIdentity {
        name: dep_name.to_string(),
        location: SourceLocation::Local {
            path: canonical_path,
        },
    };

    (identity, None)
},
```

Additionally, consider adding a configuration option to restrict local dependencies to specific allowed directories for high-security contexts.

## Proof of Concept

**Step 1: Create malicious package**

Create `malicious_package/Move.toml`:
```toml
[package]
name = "MaliciousPackage"
version = "1.0.0"

[dependencies]
# Attempts to access /etc/ directory
SystemProbe = { local = "/etc/" }

# Attempts to access /root/.ssh/ directory  
SecretAccess = { local = "/root/.ssh/" }
```

Create `malicious_package/sources/dummy.move`:
```move
module MaliciousPackage::Dummy {
    public fun test() {}
}
```

**Step 2: Attempt compilation**

```bash
cd malicious_package
aptos move compile
```

**Expected Result:** 
The resolver will attempt to access `/etc/Move.toml` and `/root/.ssh/Move.toml`, demonstrating arbitrary filesystem access. Error messages will reveal whether these directories exist and are accessible, enabling filesystem reconnaissance.

**Step 3: More dangerous variant**

If attacker can place a malicious package at `/tmp/backdoor/`:

```toml
[dependencies]
Backdoor = { local = "/tmp/backdoor/" }
```

The victim will unknowingly compile and potentially execute attacker-controlled Move code during the build process.

## Notes

This vulnerability specifically affects the **build-time tooling** rather than runtime blockchain execution. However, it represents a critical break in security assumptions for:
- Package registries that compile uploaded packages
- Developer environments processing untrusted code
- CI/CD systems building community contributions
- Any sandboxed compilation environment

The fix should align with the existing protection for git dependencies, where absolute paths are explicitly forbidden.

### Citations

**File:** third_party/move/tools/move-package-manifest/src/manifest.rs (L282-283)
```rust
        let location = match (raw.local, raw.git, raw.aptos) {
            (Some(path), None, None) => PackageLocation::Local { path },
```

**File:** third_party/move/tools/move-package-resolver/src/resolver.rs (L325-350)
```rust
        PackageLocation::Local { path: local_path } => match &parent_identity.location {
            SourceLocation::Local { path: parent_path } => {
                // Both parent and child are local, so if the child's path is relative,
                // it is relative to the parent's path.
                let dep_manitest_path = if local_path.is_absolute() {
                    local_path
                } else {
                    parent_path.join(local_path)
                };
                let canonical_path = CanonicalPath::new(&dep_manitest_path).map_err(|err| {
                    anyhow!(
                        "failed to find package at {}: {}",
                        dep_manitest_path.display(),
                        err
                    )
                })?;

                let identity = PackageIdentity {
                    name: dep_name.to_string(),
                    location: SourceLocation::Local {
                        path: canonical_path,
                    },
                };

                (identity, None)
            },
```

**File:** third_party/move/tools/move-package-resolver/src/resolver.rs (L359-364)
```rust
                if local_path.is_absolute() {
                    bail!(
                        "local dependency in a git repo cannot be an absolute path: {}",
                        local_path.display()
                    );
                }
```

**File:** third_party/move/tools/move-package-resolver/src/path.rs (L29-34)
```rust
impl CanonicalPath {
    pub fn new(path: impl AsRef<Path>) -> Result<Self> {
        let path = path.as_ref().canonicalize()?;
        Ok(Self(path))
    }
}
```
