# Audit Report

## Title
JWK Hash Cache Exhaustion DoS via Federated Keyless Accounts with Unique JWKs

## Summary
The `JWK_HASH_CACHE` in `types/src/keyless/bn254_circom.rs` has a fixed size of 100 entries, which can be exhausted by an attacker creating multiple federated keyless accounts with unique JWKs and submitting ZK keyless transactions. This forces cache misses and expensive Poseidon-BN254 hash recomputation on every transaction, degrading validator transaction processing performance. [1](#0-0) 

## Finding Description

The vulnerability exists in the keyless authentication system's JWK (JSON Web Key) hash caching mechanism. When validating ZK keyless signatures, validators must compute a Poseidon-BN254 hash of the RSA JWK used to verify the OpenID signature. This hash computation is expensive, involving:

1. Base64 decoding the 256-byte RSA modulus
2. Chunking into ~11 24-byte pieces and converting to field elements  
3. Computing a Poseidon-BN254 hash over ~12 scalars [2](#0-1) 

To optimize this, a cache is implemented with only 100 entries: [3](#0-2) 

The cached hash is used when computing public inputs for ZK proof verification: [4](#0-3) 

**Attack Path:**

1. Attacker creates 100+ federated keyless accounts, each with unique JWKs (up to 2KB per account allows 1-2 unique RSA JWKs): [5](#0-4) 

2. Attacker submits ZK keyless transactions from these accounts in rapid succession or parallel

3. During transaction validation in the prologue, each transaction triggers `validate_authenticators`: [6](#0-5) 

4. For each ZK keyless signature, `get_public_inputs_hash` is called: [7](#0-6) 

5. With >100 unique JWKs, the LRU cache is thrashed, forcing expensive Poseidon hash recomputation on nearly every transaction

6. The expensive computation occurs in the prologue **before** the main transaction execution, blocking validator throughput

Note that this only affects ZK keyless transactions (EphemeralCertificate::ZeroKnowledgeSig), not zkless keyless (EphemeralCertificate::OpenIdSig). [8](#0-7) 

## Impact Explanation

This vulnerability causes **validator node slowdowns**, qualifying as **Medium Severity** per the Aptos bug bounty program (up to $10,000). While technically "validator node slowdowns" is listed as High severity, the economic constraints (gas costs for account creation and transaction submission) limit the practical impact to moderate performance degradation rather than severe operational disruption.

The attack breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits." The unbounded JWK diversity relative to cache size allows an attacker to force validators to perform expensive cryptographic computations that should be cached.

Impact quantification:
- All validators processing blocks with the malicious transactions are affected
- Transaction processing latency increases for the duration of the attack
- Legitimate user transactions may experience delays
- No fund loss, consensus violation, or permanent damage occurs

## Likelihood Explanation

**Likelihood: Medium**

The attack is technically feasible but economically constrained:

**Requirements:**
- Create 100+ federated keyless accounts (one-time gas cost)
- Install unique JWKs on each account (one-time gas cost, limited to 2KB per account)
- Submit ZK keyless transactions continuously (ongoing gas cost)

**Constraints:**
- Gas costs for account creation and transaction submission
- Mempool limits on transaction throughput
- Block proposal frequency limits attack rate
- Attacker must craft valid ephemeral signatures (easy, as they control ephemeral keys)

**Likelihood factors:**
- No special privileges required
- Attack can be sustained as long as attacker pays gas
- Detection is difficult without specific monitoring
- Existing legitimate federated accounts could exceed 100 unique JWKs in production

## Recommendation

**Immediate mitigations:**

1. **Increase cache size**: Raise `JWK_HASH_CACHE` from 100 to 1,000 or 10,000 entries to match `PAD_AND_HASH_STRING_CACHE`:

```rust
static JWK_HASH_CACHE: Lazy<Cache<RSA_JWK, Fr>> = Lazy::new(|| Cache::new(10_000));
``` [9](#0-8) 

2. **Add rate limiting**: Implement per-account rate limits for ZK keyless transactions in the mempool to prevent rapid submission from many accounts

3. **Monitor cache metrics**: Add telemetry to track JWK cache hit rates and alert on unusual cache thrashing patterns

**Long-term solutions:**

1. **Limit federated JWK diversity**: Add on-chain limits for the total number of unique JWKs across all federated accounts
2. **Optimize hash computation**: Pre-compute and cache JWK hashes for common providers during JWK consensus updates
3. **Tiered caching**: Implement separate cache tiers for governance-managed JWKs (higher priority) vs. federated JWKs (lower priority)

## Proof of Concept

```rust
// Reproduction steps (conceptual - requires Aptos test infrastructure):

#[test]
fn test_jwk_cache_exhaustion() {
    // 1. Create 150 federated keyless accounts with unique JWKs
    let mut accounts = vec![];
    for i in 0..150 {
        let account = create_federated_keyless_account(i);
        let unique_jwk = generate_unique_rsa_jwk(i);
        install_federated_jwk(&account, unique_jwk);
        accounts.push(account);
    }
    
    // 2. Submit ZK keyless transactions from each account
    let start = std::time::Instant::now();
    for account in &accounts {
        let txn = create_zk_keyless_transaction(account);
        submit_transaction(txn);
    }
    
    // 3. Measure validator processing time
    let elapsed = start.elapsed();
    
    // Expected: Processing time increases significantly after first 100 transactions
    // due to cache misses forcing Poseidon hash recomputation
    
    // 4. Compare with cached scenario (resubmit same JWKs)
    let start_cached = std::time::Instant::now();
    for account in accounts.iter().take(50) {
        let txn = create_zk_keyless_transaction(account);
        submit_transaction(txn);
    }
    let elapsed_cached = start_cached.elapsed();
    
    // Expected: Cached scenario is significantly faster
    assert!(elapsed > elapsed_cached * 2);
}

// Move test to verify federated JWK installation:
#[test(jwk_owner = @0x123)]
fun test_install_multiple_unique_jwks(jwk_owner: &signer) {
    use aptos_framework::jwks;
    
    // Install unique JWK
    let patches = create_jwk_patch_vector(
        b"https://federated.example.com",
        b"unique_kid_1",
        b"unique_modulus_1"
    );
    jwks::patch_federated_jwks(jwk_owner, patches);
    
    // Verify installation succeeded and size is within 2KB limit
    let fed_jwks = borrow_global<FederatedJWKs>(signer::address_of(jwk_owner));
    assert!(vector::length(&bcs::to_bytes(fed_jwks)) < 2048, 0);
}
```

**Notes**

The vulnerability is exacerbated by the discrepancy between `JWK_HASH_CACHE` (100 entries) and `PAD_AND_HASH_STRING_CACHE` (1,000 entries), suggesting the JWK cache size may have been set arbitrarily low. The Poseidon-BN254 hash computation using the `neptune` library is cryptographically expensive by design, making caching essential for performance. The attack is economically bounded but could still cause noticeable performance degradation during sustained exploitation.

### Citations

**File:** types/src/keyless/bn254_circom.rs (L251-252)
```rust
static PAD_AND_HASH_STRING_CACHE: Lazy<Cache<(String, usize), Fr>> =
    Lazy::new(|| Cache::new(1_000));
```

**File:** types/src/keyless/bn254_circom.rs (L254-254)
```rust
static JWK_HASH_CACHE: Lazy<Cache<RSA_JWK, Fr>> = Lazy::new(|| Cache::new(100));
```

**File:** types/src/keyless/bn254_circom.rs (L268-277)
```rust
pub fn cached_jwk_hash(jwk: &RSA_JWK) -> anyhow::Result<Fr> {
    match JWK_HASH_CACHE.get(jwk) {
        None => {
            let hash = jwk.to_poseidon_scalar()?;
            JWK_HASH_CACHE.insert(jwk.clone(), hash);
            Ok(hash)
        },
        Some(hash) => Ok(hash),
    }
}
```

**File:** types/src/keyless/bn254_circom.rs (L317-317)
```rust
    let jwk_hash = cached_jwk_hash(jwk)?;
```

**File:** types/src/jwks/rsa/mod.rs (L102-125)
```rust
    pub fn to_poseidon_scalar(&self) -> Result<ark_bn254::Fr> {
        let mut modulus = base64::decode_config(&self.n, URL_SAFE_NO_PAD)?;
        // The circuit only supports RSA256
        if modulus.len() != Self::RSA_MODULUS_BYTES {
            bail!(
                "Wrong modulus size, must be {} bytes",
                Self::RSA_MODULUS_BYTES
            );
        }

        // This is done to match the circuit, which requires the modulus in a verify specific format
        // due to how RSA verification is implemented
        modulus.reverse();

        let mut scalars = modulus
            .chunks(24) // Pack 3 64 bit limbs per scalar, so chunk into 24 bytes per scalar
            .map(|chunk| {
                poseidon_bn254::keyless::pack_bytes_to_one_scalar(chunk)
                    .expect("chunk converts to scalar")
            })
            .collect::<Vec<ark_bn254::Fr>>();
        scalars.push(ark_bn254::Fr::from(Self::RSA_MODULUS_BYTES as i32));
        poseidon_bn254::hash_scalars(scalars)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L33-33)
```text
    const MAX_FEDERATED_JWKS_SIZE_BYTES: u64 = 2 * 1024; // 2 KiB
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L153-273)
```rust
pub(crate) fn validate_authenticators(
    pvk: Option<&PreparedVerifyingKey<Bn254>>,
    configuration: Option<&Configuration>,
    authenticators: &Vec<(AnyKeylessPublicKey, KeylessSignature)>,
    features: &Features,
    resolver: &impl AptosMoveResolver,
    module_storage: &impl ModuleStorage,
) -> Result<(), VMStatus> {
    let mut with_zk = false;
    for (pk, sig) in authenticators {
        // Feature-gating for keyless TXNs (whether ZK or ZKless, whether passkey-based or not)
        if matches!(sig.cert, EphemeralCertificate::ZeroKnowledgeSig { .. }) {
            if !features.is_zk_keyless_enabled() {
                return Err(VMStatus::error(StatusCode::FEATURE_UNDER_GATING, None));
            }

            with_zk = true;
        }
        if matches!(sig.cert, EphemeralCertificate::OpenIdSig { .. })
            && !features.is_zkless_keyless_enabled()
        {
            return Err(VMStatus::error(StatusCode::FEATURE_UNDER_GATING, None));
        }
        if matches!(sig.ephemeral_signature, EphemeralSignature::WebAuthn { .. })
            && !features.is_keyless_with_passkeys_enabled()
        {
            return Err(VMStatus::error(StatusCode::FEATURE_UNDER_GATING, None));
        }
        if matches!(pk, AnyKeylessPublicKey::Federated { .. })
            && !features.is_federated_keyless_enabled()
        {
            return Err(VMStatus::error(StatusCode::FEATURE_UNDER_GATING, None));
        }
    }

    // If there are ZK authenticators, the Groth16 VK must have been set on-chain.
    if with_zk && pvk.is_none() {
        return Err(invalid_signature!("Groth16 VK has not been set on-chain"));
    }

    let config = configuration.ok_or_else(|| {
        // Preserve error code for compatibility.
        value_deserialization_error!(format!(
            "get_resource failed on {}::{}::{}",
            CORE_CODE_ADDRESS.to_hex_literal(),
            Configuration::struct_tag().module,
            Configuration::struct_tag().name
        ))
    })?;
    if authenticators.len() > config.max_signatures_per_txn as usize {
        // println!("[aptos-vm][groth16] Too many keyless authenticators");
        return Err(invalid_signature!("Too many keyless authenticators"));
    }

    let onchain_timestamp_obj = get_current_time_onchain(resolver)?;
    // Check the expiry timestamp on all authenticators first to fail fast
    // This is a redundant check to quickly dismiss expired signatures early and save compute on more computationally costly checks.
    // The actual check is performed in `verify_keyless_signature_without_ephemeral_signature_check`.
    for (_, sig) in authenticators {
        sig.verify_expiry(onchain_timestamp_obj.microseconds)
            .map_err(|_| {
                // println!("[aptos-vm][groth16] ZKP expired");

                invalid_signature!("The ephemeral keypair has expired")
            })?;
    }

    let patched_jwks = get_jwks_onchain(resolver)?;

    let training_wheels_pk = match &config.training_wheels_pubkey {
        None => None,
        // This takes ~4.4 microseconds, so we are not too concerned about speed here.
        // (Run `cargo bench -- ed25519/pk_deserialize` in `crates/aptos-crypto`.)
        Some(bytes) => Some(EphemeralPublicKey::ed25519(
            Ed25519PublicKey::try_from(bytes.as_slice()).map_err(|_| {
                // println!("[aptos-vm][groth16] On chain TW PK is invalid");

                invalid_signature!("The training wheels PK set on chain is not a valid PK")
            })?,
        )),
    };

    for (pk, sig) in authenticators {
        // Try looking up the jwk in 0x1.
        let jwk = match get_jwk_for_authenticator(&patched_jwks.jwks, pk.inner_keyless_pk(), sig) {
            // 1: If found in 0x1, then we consider that the ground truth & we are done.
            Ok(jwk) => jwk,
            // 2: If not found in 0x1, we check the Keyless PK type.
            Err(e) => {
                match pk {
                    // 2.a: If this is a federated keyless account; look in `jwk_addr` for JWKs
                    AnyKeylessPublicKey::Federated(fed_pk) => {
                        let federated_jwks =
                            get_federated_jwks_onchain(resolver, &fed_pk.jwk_addr, module_storage)
                                .map_err(|_| {
                                    invalid_signature!(format!(
                                        "Could not fetch federated PatchedJWKs at {}",
                                        fed_pk.jwk_addr
                                    ))
                                })?;
                        // 2.a.i If not found in jwk_addr either, then we fail the validation.
                        get_jwk_for_authenticator(&federated_jwks.jwks, pk.inner_keyless_pk(), sig)?
                    },
                    // 2.b: If this is not a federated keyless account, then we fail the validation.
                    AnyKeylessPublicKey::Normal(_) => return Err(e),
                }
            },
        };
        verify_keyless_signature_without_ephemeral_signature_check(
            pk,
            sig,
            &jwk,
            onchain_timestamp_obj.microseconds,
            &training_wheels_pk,
            config,
            pvk,
        )?;
    }

    Ok(())
}
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L291-292)
```rust
    match &signature.cert {
        EphemeralCertificate::ZeroKnowledgeSig(zksig) => match jwk {
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L307-316)
```rust
                        let public_inputs_hash = get_public_inputs_hash(
                            signature,
                            public_key.inner_keyless_pk(),
                            rsa_jwk,
                            config,
                        )
                        .map_err(|_| {
                            // println!("[aptos-vm][groth16] PIH computation failed");
                            invalid_signature!("Could not compute public inputs hash")
                        })?;
```
