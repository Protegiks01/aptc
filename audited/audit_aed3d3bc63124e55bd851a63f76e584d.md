# Audit Report

## Title
Byzantine Validators Can Crash Consensus Nodes via Empty Weights HashMap in Secret Sharing

## Summary
The `SecretShareConfig` struct initializes its `weights` HashMap as empty, but this HashMap is used in critical code paths with `.expect()` calls that assume weights exist for all validators. Byzantine validators can trigger consensus node crashes by sending secret shares, causing honest validators to panic when processing their own shares.

## Finding Description

The secret sharing module contains a critical design flaw where two different weight lookup mechanisms are inconsistently implemented: [1](#0-0) 

The `weights` HashMap is initialized as empty in the constructor, while `get_peer_weight()` returns a hardcoded value of 1: [2](#0-1) 

When shares from other validators arrive, they are processed via `add_share()` which uses `get_peer_weight()` (returning 1): [3](#0-2) 

However, when the local validator processes its own share via `add_self_share()`, it retrieves the empty HashMap: [4](#0-3) 

This empty HashMap is then passed to `add_share_with_metadata()`, which contains multiple `.expect()` calls that panic when the HashMap is empty: [5](#0-4) 

The panic occurs at line 164 when trying to lookup the share author in the empty HashMap. Even if that were somehow bypassed, the `retain()` call at line 168 would also panic: [6](#0-5) 

**Attack Path:**
1. Byzantine validator sends secret share for round N to target honest validator
2. Honest validator receives and stores share via `add_share()` (uses `get_peer_weight()` â†’ weight=1)
3. Share is added to `SecretShareAggregator` in `PendingMetadata` state
4. Honest validator processes block for round N locally
5. Calls `add_self_share()` with self-generated share
6. `add_self_share()` retrieves empty weights HashMap via `get_peer_weights()`
7. Calls `add_share_with_metadata()` with empty HashMap
8. **PANIC** at line 164: `.expect("Author must exist in weights")` fails
9. Validator node crashes, leaving consensus

This breaks the **Consensus Safety** invariant - a Byzantine validator can selectively crash honest validators by sending shares early, potentially reducing the network below the 2/3 quorum threshold needed for liveness.

## Impact Explanation

**Severity: Critical**

This vulnerability meets Critical severity criteria from the Aptos bug bounty program:

- **Total loss of liveness/network availability**: If a Byzantine attacker crashes enough validators (e.g., targeting >1/3 of the validator set), the network cannot maintain consensus and halts.

- **Non-recoverable network partition**: Crashed validators require code patches and restarts. During an active attack, validators would repeatedly crash upon restart when processing pending shares.

The impact is amplified because:
1. Attack requires no special privileges - any validator can send shares
2. Attack is deterministic - will always crash target node
3. Attack is stealthy - shares are cryptographically valid and pass verification
4. Recovery requires coordinated upgrade across validator set

## Likelihood Explanation

**Likelihood: High (when secret sharing feature is enabled)**

Currently, the secret sharing feature appears disabled in production (execution_client.rs passes `None` for `secret_sharing_config`). However, once enabled:

- **Trivial to execute**: Byzantine validator simply sends shares before target processes blocks
- **No special conditions needed**: Normal protocol operation triggers the bug
- **Affects all validators**: Any validator can be targeted
- **Timing is easy**: Network latency naturally causes shares to arrive before local block processing

The bug would manifest immediately upon feature activation, making it a blocking issue for deployment.

## Recommendation

Fix the inconsistent weight lookup mechanism by properly initializing the weights HashMap. The `SecretShareConfig` should populate weights from the `ValidatorVerifier`:

```rust
impl SecretShareConfig {
    pub fn new(
        author: Author,
        epoch: u64,
        validator: Arc<ValidatorVerifier>,
        digest_key: DigestKey,
        msk_share: MasterSecretKeyShare,
        verification_keys: Vec<VerificationKey>,
        config: <FPTXWeighted as BatchThresholdEncryption>::ThresholdConfig,
        encryption_key: EncryptionKey,
    ) -> Self {
        // Initialize weights from validator verifier
        let weights: HashMap<Author, u64> = validator
            .get_ordered_account_addresses_iter()
            .map(|addr| (*addr, validator.get_voting_power(addr).unwrap_or(0)))
            .collect();
            
        Self {
            _author: author,
            _epoch: epoch,
            validator,
            digest_key,
            msk_share,
            verification_keys,
            config,
            encryption_key,
            weights,
        }
    }
    
    pub fn get_peer_weight(&self, peer: &Author) -> u64 {
        // Use actual weights from HashMap instead of hardcoded 1
        *self.weights.get(peer).unwrap_or(&0)
    }
}
```

Additionally, replace `.expect()` calls with proper error handling to prevent panics:

```rust
fn add_share_with_metadata(
    &mut self,
    share: SecretShare,
    share_weights: &HashMap<Author, u64>,
) -> anyhow::Result<()> {
    let item = std::mem::replace(self, Self::new(Author::ONE));
    let share_weight = *share_weights
        .get(share.author())
        .ok_or_else(|| anyhow!("Author {} not found in weights", share.author()))?;
    // ... rest of function
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_types::validator_verifier::ValidatorVerifier;
    use std::sync::Arc;

    #[test]
    #[should_panic(expected = "Author must exist in weights")]
    fn test_empty_weights_panic() {
        // Create a minimal SecretShareConfig with empty weights
        let author = AccountAddress::random();
        let epoch = 1;
        let validator = Arc::new(ValidatorVerifier::new(vec![]));
        
        // Create config using constructor (weights will be empty HashMap)
        let config = SecretShareConfig::new(
            author,
            epoch,
            validator,
            DigestKey::default(),
            MasterSecretKeyShare::default(),
            vec![],
            Default::default(),
            EncryptionKey::default(),
        );
        
        // Create store and add a share from another validator first
        let (decision_tx, _decision_rx) = unbounded();
        let mut store = SecretShareStore::new(epoch, author, config.clone(), decision_tx);
        
        // Simulate Byzantine validator sending share
        let byzantine_author = AccountAddress::random();
        let byzantine_share = SecretShare::new(
            byzantine_author,
            SecretShareMetadata::new(epoch, 1, 0, HashValue::zero(), vec![]),
            SecretKeyShare::default(),
        );
        
        // Add Byzantine share via add_share (works - uses get_peer_weight returning 1)
        let _ = store.add_share(byzantine_share);
        
        // Now try to add self share - this will PANIC
        let self_share = SecretShare::new(
            author,
            SecretShareMetadata::new(epoch, 1, 0, HashValue::zero(), vec![]),
            SecretKeyShare::default(),
        );
        
        // This call will panic at line 164 in add_share_with_metadata
        store.add_self_share(self_share).unwrap();
    }
}
```

## Notes

This vulnerability is currently not exploitable in production as the secret sharing feature appears to be disabled (based on analysis of execution_client.rs). However, it represents a critical blocking issue that must be resolved before the feature can be safely enabled. The bug would cause immediate network-wide crashes upon activation, making it a priority security issue for the development roadmap.

### Citations

**File:** types/src/secret_sharing.rs (L168-168)
```rust
            weights: HashMap::new(),
```

**File:** types/src/secret_sharing.rs (L196-202)
```rust
    pub fn get_peer_weight(&self, _peer: &Author) -> u64 {
        1
    }

    pub fn get_peer_weights(&self) -> &HashMap<Author, u64> {
        &self.weights
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L74-81)
```rust
    fn retain(&mut self, metadata: &SecretShareMetadata, weights: &HashMap<Author, u64>) {
        self.shares.retain(|_, share| share.metadata == *metadata);
        self.total_weight = self
            .shares
            .keys()
            .map(|author| weights.get(author).expect("Author must exist for weight"))
            .sum();
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L156-182)
```rust
    fn add_share_with_metadata(
        &mut self,
        share: SecretShare,
        share_weights: &HashMap<Author, u64>,
    ) -> anyhow::Result<()> {
        let item = std::mem::replace(self, Self::new(Author::ONE));
        let share_weight = *share_weights
            .get(share.author())
            .expect("Author must exist in weights");
        let new_item = match item {
            SecretShareItem::PendingMetadata(mut share_aggregator) => {
                let metadata = share.metadata.clone();
                share_aggregator.retain(share.metadata(), share_weights);
                share_aggregator.add_share(share, share_weight);
                SecretShareItem::PendingDecision {
                    metadata,
                    share_aggregator,
                }
            },
            SecretShareItem::PendingDecision { .. } => {
                bail!("Cannot add self share in PendingDecision state");
            },
            SecretShareItem::Decided { .. } => return Ok(()),
        };
        let _ = std::mem::replace(self, new_item);
        Ok(())
    }
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L237-256)
```rust
    pub fn add_self_share(&mut self, share: SecretShare) -> anyhow::Result<()> {
        assert!(
            self.self_author == share.author,
            "Only self shares can be added with metadata"
        );
        let peer_weights = self.secret_share_config.get_peer_weights();
        let metadata = share.metadata();
        ensure!(metadata.epoch == self.epoch, "Share from different epoch");
        ensure!(
            metadata.round <= self.highest_known_round + FUTURE_ROUNDS_TO_ACCEPT,
            "Share from future round"
        );

        let item = self
            .secret_share_map
            .entry(metadata.round)
            .or_insert_with(|| SecretShareItem::new(self.self_author));
        item.add_share_with_metadata(share, peer_weights)?;
        item.try_aggregate(&self.secret_share_config, self.decision_tx.clone());
        Ok(())
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L259-275)
```rust
    pub fn add_share(&mut self, share: SecretShare) -> anyhow::Result<bool> {
        let weight = self.secret_share_config.get_peer_weight(share.author());
        let metadata = share.metadata();
        ensure!(metadata.epoch == self.epoch, "Share from different epoch");
        ensure!(
            metadata.round <= self.highest_known_round + FUTURE_ROUNDS_TO_ACCEPT,
            "Share from future round"
        );

        let item = self
            .secret_share_map
            .entry(metadata.round)
            .or_insert_with(|| SecretShareItem::new(self.self_author));
        item.add_share(share, weight)?;
        item.try_aggregate(&self.secret_share_config, self.decision_tx.clone());
        Ok(item.has_decision())
    }
```
