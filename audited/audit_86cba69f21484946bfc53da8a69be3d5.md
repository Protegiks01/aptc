# Audit Report

## Title
Lazy Module Loading Bypasses Dependency Linking Verification Leading to Type Safety Violations

## Summary
When lazy loading is enabled, the `build_verified_module_skip_linking_checks()` function constructs Move modules without verifying their dependencies, violating the invariant that all on-chain modules must have their transitive dependencies verified. This allows modules with unverified dependency contracts to be cached and executed, potentially causing type confusion and consensus divergence.

## Finding Description

The Move VM runtime has two code paths for building verified modules:

1. **Correct path** - `build_verified_module_with_linking_checks()`: Performs linking verification BEFORE constructing internal data structures [1](#0-0) 

2. **Vulnerable path** - `build_verified_module_skip_linking_checks()`: Constructs internal data structures WITHOUT any linking verification [2](#0-1) 

The vulnerable path is invoked when lazy loading is enabled, specifically in the `unmetered_get_lazily_verified_module()` function: [3](#0-2) 

**Critical invariant violation**: Linking verification (via `dependencies::verify_module()`) checks that:
- All imported modules exist in dependencies
- Imported struct handles match their definitions (abilities, type parameters)
- Imported function handles match their definitions (signatures, parameters, return types, attributes)  
- Script visibility rules are enforced [4](#0-3) 

When these checks are skipped, modules can be constructed and cached with assumptions about dependencies that may not hold. During module publishing with lazy loading enabled, dependencies are loaded without verification: [5](#0-4) 

**Attack scenario:**
1. Module A (version 1) depends on Module B with function signature `foo(u64) -> bool`
2. Module B is upgraded to version 2 with signature `foo(u128) -> bool` (compatibility checks may have bugs or administrative overrides)
3. When Module C is published with lazy loading enabled and depends on Module A:
   - Module A is loaded via `unmetered_get_existing_lazily_verified_module()`
   - Module A's internal structures are built WITHOUT verifying against current Module B (v2)
   - Module A's `function_refs` and type information assume Module B v1's interface
   - Module A is cached in this unverified state
4. During execution, when Module A calls `B::foo()`, it passes `u64` but Module B v2 expects `u128`
5. Type confusion occurs at the bytecode instruction level, potentially causing stack corruption or incorrect type interpretation

This breaks the **Deterministic Execution** invariant: different validators with different module cache states could execute the same transaction differently, leading to consensus divergence.

## Impact Explanation

**Severity: High** (per Aptos bug bounty criteria for "Significant protocol violations")

This vulnerability can cause:
- **Type safety violations**: Modules execute with incorrect assumptions about dependency signatures
- **Consensus divergence**: Validators with different cached module states may produce different execution results for the same transaction
- **State inconsistency**: Different nodes could commit different state roots, requiring manual intervention

The impact is limited by:
- Requires lazy loading feature flag to be enabled
- Requires specific module upgrade patterns (incompatible changes that bypass compatibility checks)
- Move VM's runtime type checking may catch some mismatches (but not guaranteed for all edge cases)

This qualifies as "Significant protocol violations" which falls under High severity ($50,000).

## Likelihood Explanation

**Likelihood: Medium**

Required conditions:
1. `ENABLE_LAZY_LOADING` feature flag must be enabled (production setting) [6](#0-5) 

2. Module upgrade that bypasses or exploits gaps in compatibility checking [7](#0-6) 

3. Subsequent module publishing or execution that triggers lazy loading of the incompatibly-upgraded module

The vulnerability is not trivially exploitable but becomes realistic if:
- Compatibility checking has bugs in complex upgrade scenarios
- Administrative functions allow bypassing checks in emergencies
- Race conditions during upgrades create temporary inconsistencies

## Recommendation

Enforce linking verification for ALL module loading paths, including lazy loading. The `build_verified_module_skip_linking_checks()` function should only be used in controlled test environments, never in production.

**Proposed fix:**

```rust
pub(crate) fn build_verified_module_skip_linking_checks(
    &self,
    locally_verified_module: LocallyVerifiedModule,
) -> VMResult<Module> {
    // SECURITY: Always perform linking checks, even in lazy loading mode
    // to ensure type safety and consensus consistency
    
    // For lazy loading, we still need to verify the module's immediate dependencies
    // However, we don't need to recursively verify transitive dependencies
    // This maintains type safety while preserving lazy loading performance benefits
    
    // TODO: Implement lightweight linking verification that checks module's
    // immediate dependencies without full transitive verification
    
    Module::new(
        &self.natives,
        locally_verified_module.1,
        locally_verified_module.0,
        self.struct_name_index_map(),
        self.ty_pool(),
        self.module_id_pool(),
    )
    .map_err(|err| err.finish(Location::Undefined))
}
```

Alternative: Remove the `skip_linking_checks` function entirely and always use `build_verified_module_with_linking_checks()`, accepting the performance cost for correctness.

## Proof of Concept

```rust
// Pseudo-code demonstrating the vulnerability

// Step 1: Deploy Module B v1
module 0xB::ModuleB {
    public fun foo(x: u64): bool { x > 0 }
}

// Step 2: Deploy Module A depending on B v1
module 0xA::ModuleA {
    use 0xB::ModuleB;
    
    public fun bar(): bool {
        // Module A's bytecode expects foo(u64) -> bool
        ModuleB::foo(42)
    }
}

// Step 3: Upgrade Module B to v2 with incompatible signature
// (Assuming compatibility check bypass via bug or admin override)
module 0xB::ModuleB {
    public fun foo(x: u128): bool { x > 0 }  // Changed u64 -> u128
}

// Step 4: Publish Module C with lazy loading enabled
module 0xC::ModuleC {
    use 0xA::ModuleA;
    
    public entry fun trigger() {
        // Publishing Module C triggers lazy loading of Module A
        // Module A is loaded WITHOUT verifying against current Module B (v2)
        // Module A is cached with assumptions about old B v1 interface
        ModuleA::bar();  // This will cause type confusion
    }
}

// When trigger() executes:
// 1. Module A tries to call B::foo(u64=42)
// 2. But B::foo expects u128
// 3. Type mismatch causes undefined behavior
// 4. Different validators may handle this differently -> consensus split
```

## Notes

The core issue is the architectural decision to skip linking verification in lazy loading mode. While this improves performance, it violates the fundamental security principle that all code execution must operate on verified assumptions. The Move VM's type system provides defense-in-depth, but relying solely on runtime checks without static linking verification creates an attack surface for type confusion vulnerabilities.

### Citations

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L210-216)
```rust
        dependencies::verify_module(
            &self.vm_config.verifier_config,
            locally_verified_module.0.as_ref(),
            immediate_dependencies
                .iter()
                .map(|module| module.as_ref().as_ref()),
        )?;
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L236-243)
```rust
        Module::new(
            &self.natives,
            locally_verified_module.1,
            locally_verified_module.0,
            self.struct_name_index_map(),
            self.ty_pool(),
            self.module_id_pool(),
        )
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L320-321)
```rust
        let verified_code =
            runtime_environment.build_verified_module_skip_linking_checks(locally_verified_code)?;
```

**File:** third_party/move/move-bytecode-verifier/src/dependencies.rs (L173-195)
```rust
pub fn verify_module<'a>(
    config: &VerifierConfig,
    module: &CompiledModule,
    dependencies: impl IntoIterator<Item = &'a CompiledModule>,
) -> VMResult<()> {
    if config.verify_nothing() {
        return Ok(());
    }
    verify_module_impl(module, dependencies)
        .map_err(|e| e.finish(Location::Module(module.self_id())))
}

fn verify_module_impl<'a>(
    module: &CompiledModule,
    dependencies: impl IntoIterator<Item = &'a CompiledModule>,
) -> PartialVMResult<()> {
    let context = &Context::module(module, dependencies);

    verify_imported_modules(context)?;
    verify_imported_structs(context)?;
    verify_imported_functions(context)?;
    verify_all_script_visibility_usage(context)
}
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L175-194)
```rust
            if compatibility.need_check_compat() {
                // INVARIANT:
                //   Old module must be metered at the caller side.
                if let Some(old_module_ref) =
                    existing_module_storage.unmetered_get_deserialized_module(addr, name)?
                {
                    if !is_framework_for_option_enabled
                        && is_enum_option_enabled
                        && old_module_ref.self_id().is_option()
                        && old_module_ref.self_id() == compiled_module.self_id()
                    {
                        // skip check for option module during publishing
                    } else {
                        let old_module = old_module_ref.as_ref();
                        compatibility
                            .check(old_module, &compiled_module)
                            .map_err(|e| e.finish(Location::Undefined))?;
                    }
                }
            }
```

**File:** third_party/move/move-vm/runtime/src/storage/publishing.rs (L266-270)
```rust
                    let dependency =
                        staged_module_storage.unmetered_get_existing_lazily_verified_module(
                            &ModuleId::new(*dep_addr, dep_name.to_owned()),
                        )?;
                    verified_dependencies.push(dependency);
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L255-255)
```rust
        enable_lazy_loading: features.is_lazy_loading_enabled(),
```
