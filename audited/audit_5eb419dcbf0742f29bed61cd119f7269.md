# Audit Report

## Title
Insufficient Validation of Peer-Reported Distance Metadata Enables Mempool Priority Manipulation

## Summary
The `handle_update_peers()` function in the mempool coordinator trusts peer-reported `distance_from_validators` metadata without validating its accuracy for values greater than 1. Malicious fullnodes can falsely claim lower distances from validators to gain unfair priority in transaction broadcasting, potentially enabling transaction censorship and network disruption.

## Finding Description

The mempool's `handle_update_peers()` function receives peer metadata from `PeersAndMetadata` and uses it to prioritize peers for transaction broadcasting. [1](#0-0) 

This metadata includes `distance_from_validators`, which is extracted from peer-reported `NetworkInformationResponse` messages and stored in `PeerMonitoringMetadata`. [2](#0-1) 

The validation logic in `NetworkInfoState::handle_monitoring_service_response()` performs sanity checks based on peer roles, but critically **only validates that distance ≤ 100 for values greater than 1**, without verifying the claimed distance is accurate: [3](#0-2) 

The mempool's peer prioritization system uses this unvalidated distance to determine transaction broadcast priority. Lower distances receive higher priority: [4](#0-3) [5](#0-4) 

The intelligent peer comparison explicitly prioritizes peers with lower validator distances: [6](#0-5) 

**Attack Scenario:**
1. A malicious Public Fullnode (PFN) at true distance 10 from validators connects to the network
2. It reports `distance_from_validators = 2` in its `NetworkInformationResponse`
3. The validation passes because `2 ≤ MAX_DISTANCE_FROM_VALIDATORS (100)`
4. Mempool incorrectly prioritizes this peer for transaction broadcasts
5. The malicious peer receives transactions before honest peers at true distance 2-9
6. The attacker can selectively drop or delay transactions, enabling censorship

The distance calculation itself relies on peer-reported values in a cascading manner: [7](#0-6) 

Each node computes its distance as `min(peer_distances) + 1`, trusting the distances reported by connected peers. This creates a trust chain where a single dishonest peer can poison the network topology view of all downstream nodes.

## Impact Explanation

**Severity: High**

This vulnerability meets the **High Severity** criteria per Aptos Bug Bounty:
- **Significant protocol violations**: Breaks the fairness guarantee of transaction propagation
- **Validator node slowdowns**: Honest nodes may experience degraded transaction throughput if malicious nodes monopolize broadcast channels
- **Network disruption**: Transaction censorship capability

The impact includes:
1. **Transaction Censorship**: Malicious prioritized peers can selectively drop transactions from specific senders or addresses
2. **Unfair Transaction Ordering**: Attackers gain early access to transactions, potentially exploiting MEV opportunities
3. **Network Topology Poisoning**: Downstream nodes compute incorrect distances based on false reports, cascading the attack
4. **Resource Exhaustion**: Honest nodes waste bandwidth broadcasting to malicious peers who drop transactions

While this doesn't directly lead to consensus safety violations or fund theft, it significantly degrades network reliability and enables selective censorship attacks.

## Likelihood Explanation

**Likelihood: Medium-High**

The attack is straightforward to execute:
- **No cryptographic breaks required**: Peer role validation only checks authenticated roles (validator/VFN), not distance accuracy
- **Low attacker requirements**: Any node can connect as a PFN and make false claims
- **Simple exploitation**: Just modify the `NetworkInformationResponse` to claim a lower distance
- **No validator collusion needed**: Attack works with a single malicious fullnode

The only barrier is that the attacker must maintain network connectivity to honest peers. Detection would require cross-validation of distance claims across multiple peers, which is not currently implemented.

## Recommendation

Implement **cross-validation of distance claims** by:

1. **Add distance verification logic** in `NetworkInfoState::handle_monitoring_service_response()`:
   - For peers claiming distance N, verify they have at least one connected peer at distance N-1
   - Check consistency of reported `connected_peers` against known network topology
   - Implement reputation scoring to downgrade peers with inconsistent distance reports

2. **Add server-side validation** in `get_distance_from_validators()`:
   - Verify that reported distances from connected peers are consistent with their roles
   - Implement Byzantine-resistant distance computation using multiple peer reports
   - Cap trust in any single peer's distance claim

3. **Example fix** for validation (pseudo-code):
```rust
// In handle_monitoring_service_response(), after line 141:
if network_info_response.distance_from_validators > 1 {
    // Verify the peer has connected peers at distance-1
    let has_closer_peer = network_info_response.connected_peers
        .values()
        .any(|peer| {
            // Check if this peer could plausibly be at distance-1
            peer.peer_role.is_validator() || peer.peer_role.is_vfn()
        });
    
    if !has_closer_peer && network_info_response.distance_from_validators == 2 {
        warn!("Peer claims distance 2 but has no validators/VFNs in connected_peers");
        self.handle_request_failure();
        return;
    }
}
```

4. **Implement distance consensus**: Compute local distance estimates based on multiple peer reports and flag significant discrepancies for investigation.

## Proof of Concept

```rust
// This PoC demonstrates how a malicious peer can falsely claim distance 2
// File: peer-monitoring-service/client/src/peer_states/network_info.rs (test section)

#[test]
fn test_malicious_distance_claim() {
    use crate::peer_states::{key_value::StateValueInterface, network_info::NetworkInfoState};
    use aptos_config::{
        config::{BaseConfig, NodeConfig, PeerRole, RoleType},
        network_id::{NetworkId, PeerNetworkId},
    };
    use aptos_netcore::transport::ConnectionOrigin;
    use aptos_network::{
        application::metadata::PeerMetadata,
        protocols::wire::handshake::v1::{MessagingProtocolVersion, ProtocolIdSet},
        transport::{ConnectionId, ConnectionMetadata},
    };
    use aptos_peer_monitoring_service_types::{
        request::PeerMonitoringServiceRequest,
        response::{NetworkInformationResponse, PeerMonitoringServiceResponse},
    };
    use aptos_time_service::TimeService;
    use aptos_types::{network_address::NetworkAddress, PeerId};
    use std::{collections::BTreeMap, str::FromStr};

    // Create a PFN node that will receive the malicious claim
    let node_config = NodeConfig {
        base: BaseConfig {
            role: RoleType::FullNode,
            ..Default::default()
        },
        ..Default::default()
    };
    let mut network_info_state = NetworkInfoState::new(node_config, TimeService::mock());

    // Create a malicious peer claiming to be a PFN at distance 2
    let peer_network_id = PeerNetworkId::new(NetworkId::Public, PeerId::random());
    let connection_metadata = ConnectionMetadata::new(
        peer_network_id.peer_id(),
        ConnectionId::default(),
        NetworkAddress::from_str("/ip4/127.0.0.1/tcp/8081").unwrap(),
        ConnectionOrigin::Outbound,
        MessagingProtocolVersion::V1,
        ProtocolIdSet::empty(),
        PeerRole::Unknown, // PFN role
    );
    let peer_metadata = PeerMetadata::new(connection_metadata);

    // Malicious response claiming distance 2 (but could be distance 10+)
    let malicious_response = PeerMonitoringServiceResponse::NetworkInformation(
        NetworkInformationResponse {
            connected_peers: BTreeMap::new(), // Empty - no validators!
            distance_from_validators: 2, // FALSE CLAIM
        }
    );

    // Handle the malicious response - it will be ACCEPTED
    network_info_state.handle_monitoring_service_response(
        &peer_network_id,
        peer_metadata,
        PeerMonitoringServiceRequest::GetNetworkInformation,
        malicious_response,
        0.0,
    );

    // Verify the false distance was stored
    let stored_response = network_info_state.get_latest_network_info_response().unwrap();
    assert_eq!(stored_response.distance_from_validators, 2);
    
    // VULNERABILITY: The malicious claim passes validation even though:
    // 1. The peer has NO connected validators or VFNs
    // 2. True distance is likely much higher (8-10+)
    // 3. This peer will now get HIGH PRIORITY in mempool broadcasting
    
    println!("VULNERABILITY CONFIRMED: Malicious peer successfully claimed distance 2");
    println!("This peer will receive priority in mempool transaction broadcasts");
    println!("Attack enables transaction censorship and network disruption");
}
```

**Notes**
- The vulnerability exists because distance validation for values >1 only checks the upper bound (`≤ 100`), not accuracy
- The mempool's prioritization logic directly uses this unvalidated distance, giving malicious peers unfair advantage
- Cross-validation against peer topology or Byzantine-resistant distance computation would mitigate this attack
- The cascading nature of distance calculation (each node computes `min(peer_distances) + 1`) amplifies the impact, as false claims propagate through the network

### Citations

**File:** mempool/src/shared_mempool/coordinator.rs (L418-442)
```rust
async fn handle_update_peers<NetworkClient, TransactionValidator>(
    peers_and_metadata: Arc<PeersAndMetadata>,
    smp: &mut SharedMempool<NetworkClient, TransactionValidator>,
    scheduled_broadcasts: &mut FuturesUnordered<ScheduledBroadcast>,
    executor: Handle,
) where
    NetworkClient: NetworkClientInterface<MempoolSyncMsg> + 'static,
    TransactionValidator: TransactionValidation + 'static,
{
    if let Ok(connected_peers) = peers_and_metadata.get_connected_peers_and_metadata() {
        let (newly_added_upstream, disabled) = smp.network_interface.update_peers(&connected_peers);
        if !newly_added_upstream.is_empty() || !disabled.is_empty() {
            counters::shared_mempool_event_inc("peer_update");
            notify_subscribers(SharedMempoolNotification::PeerStateChange, &smp.subscribers);
        }
        for peer in &newly_added_upstream {
            debug!(LogSchema::new(LogEntry::NewPeer).peer(peer));
            tasks::execute_broadcast(*peer, false, smp, scheduled_broadcasts, executor.clone())
                .await;
        }
        for peer in &disabled {
            debug!(LogSchema::new(LogEntry::LostPeer).peer(peer));
        }
    }
}
```

**File:** peer-monitoring-service/types/src/response.rs (L50-55)
```rust
/// A response for the network information request
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct NetworkInformationResponse {
    pub connected_peers: BTreeMap<PeerNetworkId, ConnectionMetadata>, // Connected peers
    pub distance_from_validators: u64, // The distance of the peer from the validator set
}
```

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L118-154)
```rust
        let is_valid_depth = match network_info_response.distance_from_validators {
            0 => {
                // Verify the peer is a validator and has the correct network id
                let peer_is_validator = peer_metadata.get_connection_metadata().role.is_validator();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_validator_network(), // We're a validator
                    RoleType::FullNode => network_id.is_vfn_network(),        // We're a VFN
                };
                peer_is_validator && peer_has_correct_network
            },
            1 => {
                // Verify the peer is a VFN and has the correct network id
                let peer_is_vfn = peer_metadata.get_connection_metadata().role.is_vfn();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_vfn_network(), // We're a validator
                    RoleType::FullNode => network_id.is_public_network(), // We're a VFN or PFN
                };
                peer_is_vfn && peer_has_correct_network
            },
            distance_from_validators => {
                // The distance must be less than or equal to the max
                distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS
            },
        };

        // If the depth did not pass our sanity checks, handle a failure
        if !is_valid_depth {
            warn!(LogSchema::new(LogEntry::NetworkInfoRequest)
                .event(LogEvent::InvalidResponse)
                .peer(peer_network_id)
                .message(&format!(
                    "Peer returned invalid depth from validators: {}",
                    network_info_response.distance_from_validators
                )));
            self.handle_request_failure();
            return;
        }
```

**File:** mempool/src/shared_mempool/priority.rs (L103-109)
```rust
        // Otherwise, compare by peer distance from the validators.
        // This avoids badly configured/connected peers (e.g., broken VN-VFN connections).
        let distance_ordering =
            compare_validator_distance(monitoring_metadata_a, monitoring_metadata_b);
        if !distance_ordering.is_eq() {
            return distance_ordering; // Only return if it's not equal
        }
```

**File:** mempool/src/shared_mempool/priority.rs (L507-516)
```rust
fn get_distance_from_validators(
    monitoring_metadata: &Option<&PeerMonitoringMetadata>,
) -> Option<u64> {
    monitoring_metadata.and_then(|metadata| {
        metadata
            .latest_network_info_response
            .as_ref()
            .map(|network_info_response| network_info_response.distance_from_validators)
    })
}
```

**File:** mempool/src/shared_mempool/priority.rs (L615-639)
```rust
fn compare_validator_distance(
    monitoring_metadata_a: &Option<&PeerMonitoringMetadata>,
    monitoring_metadata_b: &Option<&PeerMonitoringMetadata>,
) -> Ordering {
    // Get the validator distance from the monitoring metadata
    let validator_distance_a = get_distance_from_validators(monitoring_metadata_a);
    let validator_distance_b = get_distance_from_validators(monitoring_metadata_b);

    // Compare the distances
    match (validator_distance_a, validator_distance_b) {
        (Some(validator_distance_a), Some(validator_distance_b)) => {
            // Prioritize the peer with the lowest validator distance
            validator_distance_a.cmp(&validator_distance_b).reverse()
        },
        (Some(_), None) => {
            Ordering::Greater // Prioritize the peer with a validator distance
        },
        (None, Some(_)) => {
            Ordering::Less // Prioritize the peer with a validator distance
        },
        (None, None) => {
            Ordering::Equal // Neither peer has a validator distance
        },
    }
}
```

**File:** peer-monitoring-service/server/src/lib.rs (L298-340)
```rust
fn get_distance_from_validators(
    base_config: &BaseConfig,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> u64 {
    // Get the connected peers and metadata
    let connected_peers_and_metadata = match peers_and_metadata.get_connected_peers_and_metadata() {
        Ok(connected_peers_and_metadata) => connected_peers_and_metadata,
        Err(error) => {
            warn!(LogSchema::new(LogEntry::PeerMonitoringServiceError).error(&error.into()));
            return MAX_DISTANCE_FROM_VALIDATORS;
        },
    };

    // If we're a validator and we have active validator peers, we're in the validator set.
    // TODO: figure out if we need to deal with validator set forks here.
    if base_config.role.is_validator() {
        for peer_metadata in connected_peers_and_metadata.values() {
            if peer_metadata.get_connection_metadata().role.is_validator() {
                return 0;
            }
        }
    }

    // Otherwise, go through our peers, find the min, and return a distance relative to the min
    let mut min_peer_distance_from_validators = MAX_DISTANCE_FROM_VALIDATORS;
    for peer_metadata in connected_peers_and_metadata.values() {
        if let Some(ref latest_network_info_response) = peer_metadata
            .get_peer_monitoring_metadata()
            .latest_network_info_response
        {
            min_peer_distance_from_validators = min(
                min_peer_distance_from_validators,
                latest_network_info_response.distance_from_validators,
            );
        }
    }

    // We're one hop away from the peer
    min(
        MAX_DISTANCE_FROM_VALIDATORS,
        min_peer_distance_from_validators + 1,
    )
}
```
