# Audit Report

## Title
Lack of Cryptographic Protection for Consensus-Critical Transaction Filter Configuration Enables Validator Vote Manipulation

## Summary
The `TransactionFiltersConfig`, which directly controls consensus voting behavior, lacks cryptographic protection mechanisms such as digital signatures or integrity checks. Any process with filesystem write access can inject malicious filter rules that cause validators to refuse voting on legitimate proposals, potentially breaking consensus liveness if multiple validators are compromised.

## Finding Description

The Aptos validator node loads its `TransactionFiltersConfig` from a YAML file using only filesystem-based access control, with no additional cryptographic verification. [1](#0-0) 

The configuration is deserialized directly from the file contents without signature verification or integrity checks. [2](#0-1) 

The `TransactionFiltersConfig` structure contains the `consensus_filter` field, which is used during proposal processing to determine whether a validator should vote on a block. [3](#0-2) 

During proposal processing, the `RoundManager` invokes `check_denied_inline_transactions()` to verify that inline transactions in the proposal are not denied by the configured filter. If any transactions match deny rules, the validator **drops the entire proposal and refuses to vote**. [4](#0-3) 

The filter checking is implemented in the payload manager, which evaluates each inline transaction against the configured block transaction filter rules. [5](#0-4) 

The `BlockTransactionFilter` supports powerful matching capabilities including sender addresses, block authors, epoch ranges, timestamps, entry functions, module addresses, public keys, and catch-all matchers. [6](#0-5) 

**Attack Scenario:**

1. An attacker gains write access to the validator's config file through privilege escalation, container escape, or supply chain compromise
2. The attacker modifies `transaction_filters.consensus_filter` to inject deny rules targeting:
   - Specific validator addresses (to prevent their transactions from being voted on)
   - Specific epoch/timestamp ranges (to cause time-based voting failures)
   - Catch-all rules (to prevent all voting)
3. The validator loads the malicious configuration at startup
4. When proposals containing targeted transactions arrive, the validator refuses to vote
5. If multiple validators are compromised with coordinated filter rules, consensus liveness degrades or breaks entirely

This breaks the **Consensus Safety** invariant by allowing local configuration manipulation to affect consensus participation without cryptographic authorization.

## Impact Explanation

This vulnerability qualifies as **HIGH severity** under the Aptos bug bounty program for the following reasons:

1. **Validator Node Slowdowns**: A single compromised validator will stop participating in consensus for proposals matching the injected filter rules, causing that validator to fall behind and fail to contribute to quorum formation.

2. **Consensus Liveness Attacks**: If an attacker compromises â‰¥1/3 of validators' configuration files with coordinated filter rules, they can prevent quorum formation (2f+1 votes) for targeted proposals, breaking consensus liveness. While AptosBFT tolerates f Byzantine validators, this attack affects honest validators' ability to vote.

3. **No Cryptographic Protection**: The consensus-critical configuration lacks the same cryptographic security properties (signatures, integrity checks) that protect consensus messages themselves. This creates a weaker security boundary.

4. **Silent Failures**: The attack is difficult to detect since validators appear to be running normally but selectively refuse to vote on certain proposals.

## Likelihood Explanation

The likelihood is **MEDIUM-TO-HIGH** because:

**Attack Prerequisites:**
- Write access to validator config file (typically requires host compromise)
- Knowledge of target transaction patterns to construct effective filter rules
- Ability to restart validator or wait for config reload (if implemented)

**Feasible Attack Vectors:**
1. **Container Escape**: In Kubernetes deployments, a compromised container could modify mounted config files
2. **Privilege Escalation**: Local privilege escalation exploits could grant config write access
3. **Supply Chain**: Compromised configuration management tools (Ansible, Terraform, etc.) could inject malicious configs during deployment
4. **Insider Threat**: Low-privilege operators with filesystem access but not authorized for consensus-critical changes

**Amplification Factor:**
- Single exploit technique can affect multiple validators if they share infrastructure
- Configuration management systems often deploy to multiple nodes simultaneously
- Attack persists across validator restarts until config is manually corrected

## Recommendation

Implement cryptographic protection for consensus-critical configuration:

1. **Digital Signatures**: Require `TransactionFiltersConfig` to be signed by authorized keys (validator operator keys or governance multisig)

```rust
// In transaction_filters_config.rs
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
pub struct SignedTransactionFiltersConfig {
    pub config: TransactionFiltersConfig,
    pub signature: Ed25519Signature,
    pub signer: Ed25519PublicKey,
}

impl SignedTransactionFiltersConfig {
    pub fn verify(&self, authorized_keys: &[Ed25519PublicKey]) -> Result<(), Error> {
        // Verify signature against config hash
        let config_bytes = bcs::to_bytes(&self.config)?;
        let config_hash = HashValue::sha3_256_of(&config_bytes);
        
        // Check signer is authorized
        if !authorized_keys.contains(&self.signer) {
            return Err(Error::Unauthorized("Signer not in authorized key list".into()));
        }
        
        // Verify signature
        self.signature.verify(&config_hash, &self.signer)
            .map_err(|_| Error::InvalidSignature)?;
        
        Ok(())
    }
}
```

2. **On-Chain Governance**: Move transaction filter configuration to on-chain governance for validators to vote on changes

3. **Config Integrity Monitoring**: Implement runtime integrity checks that alert operators if config files are modified unexpectedly

4. **Principle of Least Privilege**: Restrict filesystem permissions so only the validator process owner can read configs, and only authorized deployment systems can write

5. **Audit Logging**: Log all config loads with cryptographic attestation of the loaded configuration state

## Proof of Concept

The existing smoke test demonstrates that transaction filters directly affect consensus voting behavior: [7](#0-6) 

The test shows that when a `consensus_filter` is configured to deny transactions from a specific sender, those transactions are dropped and never committed (the transaction expires in mempool).

To demonstrate the vulnerability:

1. Deploy a validator with normal configuration
2. Modify the validator's `node.yaml` to inject a malicious consensus filter:
```yaml
transaction_filters:
  consensus_filter:
    filter_enabled: true
    block_transaction_filter:
      block_transaction_rules:
        - Deny:
          - Transaction:
              Sender: "0x..." # Target a legitimate validator's address
        - Allow:
          - Block:
              All
```
3. Restart the validator
4. Observe that the validator refuses to vote on proposals containing transactions from the targeted address
5. If multiple validators are configured similarly, observe consensus slowdown or liveness failures

The test infrastructure for this already exists in the smoke test framework. [8](#0-7) 

## Notes

This vulnerability represents a **defense-in-depth failure** where consensus-critical configuration relies solely on operating system-level access control rather than cryptographic protection. While filesystem permissions are the first line of defense, the lack of additional verification mechanisms creates a weakness that could be exploited through various attack vectors including privilege escalation, container escapes, or supply chain compromises.

The impact is particularly severe because transaction filters affect consensus voting behavior in a way that:
1. Is difficult to detect (validators appear healthy but selectively don't vote)
2. Can be coordinated across multiple validators
3. Persists until manual intervention corrects the configuration
4. Bypasses the cryptographic security that protects all other consensus messages

Similar consensus-critical parameters in other blockchain systems are typically protected through on-chain governance, cryptographic signatures, or secure enclaves. Aptos should implement comparable protections for `TransactionFiltersConfig`.

### Citations

**File:** config/src/config/persistable_config.rs (L14-20)
```rust
    fn load_config<P: AsRef<Path>>(path: P) -> Result<Self, Error> {
        // Read the file into a string
        let file_contents = Self::read_config_file(&path)?;

        // Parse the file string
        Self::parse_serialized_config(&file_contents)
    }
```

**File:** config/src/config/persistable_config.rs (L32-40)
```rust
    fn read_config_file<P: AsRef<Path>>(path: P) -> Result<String, Error> {
        let config_path_string = path.as_ref().to_str().unwrap().to_string();
        read_to_string(config_path_string.clone()).map_err(|error| {
            Error::Unexpected(format!(
                "Failed to read the config file into a string: {:?}. Error: {:?}",
                config_path_string, error
            ))
        })
    }
```

**File:** config/src/config/transaction_filters_config.rs (L10-18)
```rust
#[derive(Clone, Debug, Default, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct TransactionFiltersConfig {
    pub api_filter: TransactionFilterConfig, // Filter for the API (e.g., txn simulation)
    pub consensus_filter: BlockTransactionFilterConfig, // Filter for consensus (e.g., proposal voting)
    pub execution_filter: BlockTransactionFilterConfig, // Filter for execution (e.g., block execution)
    pub mempool_filter: TransactionFilterConfig,        // Filter for mempool (e.g., txn submission)
    pub quorum_store_filter: BatchTransactionFilterConfig, // Filter for quorum store (e.g., batch voting)
}
```

**File:** consensus/src/round_manager.rs (L1202-1214)
```rust
        // If the proposal contains any inline transactions that need to be denied
        // (e.g., due to filtering) drop the message and do not vote for the block.
        if let Err(error) = self
            .block_store
            .check_denied_inline_transactions(&proposal, &self.block_txn_filter_config)
        {
            counters::REJECTED_PROPOSAL_DENY_TXN_COUNT.inc();
            bail!(
                "[RoundManager] Proposal for block {} contains denied inline transactions: {}. Dropping proposal!",
                proposal.id(),
                error
            );
        }
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L308-347)
```rust
    fn check_denied_inline_transactions(
        &self,
        block: &Block,
        block_txn_filter_config: &BlockTransactionFilterConfig,
    ) -> anyhow::Result<()> {
        // If the filter is disabled, return early
        if !block_txn_filter_config.is_enabled() {
            return Ok(());
        }

        // Get the inline transactions for the block proposal
        let inline_transactions = get_inline_transactions(block);
        if inline_transactions.is_empty() {
            return Ok(());
        }

        // Fetch the block metadata
        let block_id = block.id();
        let block_author = block.author();
        let block_epoch = block.epoch();
        let block_timestamp = block.timestamp_usecs();

        // Identify any denied inline transactions
        let block_transaction_filter = block_txn_filter_config.block_transaction_filter();
        let denied_inline_transactions = block_transaction_filter.get_denied_block_transactions(
            block_id,
            block_author,
            block_epoch,
            block_timestamp,
            inline_transactions,
        );
        if !denied_inline_transactions.is_empty() {
            return Err(anyhow::anyhow!(
                "Inline transactions for QuorumStorePayload denied by block transaction filter: {:?}",
                denied_inline_transactions
            ));
        }

        Ok(()) // No transactions were denied
    }
```

**File:** crates/aptos-transaction-filters/src/block_transaction_filter.rs (L250-260)
```rust
/// A matcher that defines the criteria for matching blocks
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub enum BlockMatcher {
    All,                            // Matches any block
    Author(AccountAddress),         // Matches blocks proposed by the specified author
    BlockId(HashValue),             // Matches blocks with the specified ID
    BlockEpochGreaterThan(u64),     // Matches blocks with epochs greater than the specified value
    BlockEpochLessThan(u64),        // Matches blocks with epochs less than the specified value
    BlockTimeStampGreaterThan(u64), // Matches blocks with timestamps greater than the specified value
    BlockTimeStampLessThan(u64),    // Matches blocks with timestamps less than the specified value
}
```

**File:** testsuite/smoke-test/src/transaction_filter.rs (L33-76)
```rust
#[tokio::test]
async fn test_consensus_block_filter() {
    // Generate a new key pair and sender address
    let (private_key, sender_address) = create_sender_account();

    // Create a new swarm with an inline consensus filter that denies transactions
    // from the sender, and disable quorum store (to ensure the filter is applied).
    let mut swarm = SwarmBuilder::new_local(3)
        .with_aptos()
        .with_init_config(Arc::new(move |_, config, _| {
            filter_inline_transactions(config, sender_address);
        }))
        .with_init_genesis_config(Arc::new(|genesis_config| {
            genesis_config.consensus_config = OnChainConsensusConfig::V4 {
                alg: ConsensusAlgorithmConfig::default_with_quorum_store_disabled(),
                vtxn: ValidatorTxnConfig::default_for_genesis(),
                window_size: DEFAULT_WINDOW_SIZE,
            };
        }))
        .build()
        .await;

    // Execute a few regular transactions and verify that they are processed correctly
    execute_test_transactions(&mut swarm).await;

    // Prepare a transaction from the sender address
    let transaction = create_transaction_from_sender(private_key, sender_address, &mut swarm).await;

    // Submit the transaction and wait for it to be processed
    let aptos_public_info = swarm.aptos_public_info();
    let response = aptos_public_info
        .client()
        .submit_and_wait(&transaction)
        .await;

    // Verify the transaction was dropped by the consensus filter
    let error = response.unwrap_err();
    assert!(error
        .to_string()
        .contains("Used to be pending and now not found. Transaction expired."));

    // Execute a few more transactions and verify that they are processed correctly
    execute_test_transactions(&mut swarm).await;
}
```

**File:** testsuite/smoke-test/src/transaction_filter.rs (L246-258)
```rust
/// Adds a filter to the consensus config to ignore transactions from the given sender
fn filter_inline_transactions(node_config: &mut NodeConfig, sender_address: AccountAddress) {
    // Create the block transaction filter
    let block_transaction_filter = BlockTransactionFilter::empty()
        .add_multiple_matchers_filter(false, vec![BlockTransactionMatcher::Transaction(
            TransactionMatcher::Sender(sender_address),
        )])
        .add_all_filter(true);

    // Update the node config with the new filter
    node_config.transaction_filters.consensus_filter =
        BlockTransactionFilterConfig::new(true, block_transaction_filter);
}
```
