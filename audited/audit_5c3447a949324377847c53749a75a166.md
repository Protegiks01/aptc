# Audit Report

## Title
Recursive Distance Poisoning in Peer Monitoring Service Allows Network-Wide Peer Selection Manipulation

## Summary
The peer monitoring service's validation logic contains a critical gap that allows malicious nodes to report false `distance_from_validators` values. For distances ≥ 2, validation only checks an upper bound (≤100) without verifying role consistency or topology accuracy. Since distance calculations are recursive (`min(peer_distances) + 1`), a single malicious node reporting a false low distance can poison the entire network's distance metrics, causing widespread misrouting of consensus data, transactions, and state sync traffic.

## Finding Description

The Aptos peer monitoring service tracks each node's `distance_from_validators` metric to prioritize well-connected peers. This distance is calculated recursively in the server implementation [1](#0-0) , where each node computes its distance as the minimum distance of all connected peers plus one.

The client-side validation in [2](#0-1)  performs role-based checks for specific distances:
- Distance 0: Must be a Validator with correct network
- Distance 1: Must be a VFN with correct network  
- Distance ≥ 2: **Only checks if distance ≤ MAX_DISTANCE_FROM_VALIDATORS (100)**

This validation gap allows a malicious Public Full Node (PFN) with role `Unknown` to claim any distance from 2-100, bypassing all role and topology verification.

**Attack Propagation:**

1. Malicious PFN at actual distance 50 reports `distance_from_validators = 2`
2. Validation at line 137-140 only checks `2 <= 100`, which passes
3. Honest nodes store this false distance [3](#0-2) 
4. When calculating their own distance, nodes use `min(2, other_peers) + 1 = 3`
5. Their peers calculate distance 4, cascading through the network

This poisoned distance metric directly affects critical peer selection in:
- **Mempool**: Prioritizes peers by validator distance [4](#0-3) 
- **State Sync**: Selects peers weighted by distance and latency [5](#0-4) 
- **Consensus Observer**: Sorts peers by subscription optimality using distance

Nodes far from validators (distance 50+) will believe they're at distance 3-10, causing the system to route critical data through poorly-connected or malicious peers instead of legitimate well-connected nodes.

## Impact Explanation

**Severity: HIGH (up to $50,000) - Significant Protocol Violation**

This vulnerability constitutes a significant protocol violation affecting multiple critical subsystems:

1. **Consensus Data Propagation**: Consensus observer uses distance for peer subscription, potentially routing consensus blocks through malicious paths
2. **Transaction Routing**: Mempool prioritizes "closer" peers for transaction broadcast, enabling eclipse attacks on transaction visibility
3. **State Synchronization**: State sync client selects data sources by distance, potentially causing nodes to sync from stale or malicious sources
4. **Network Partitioning Risk**: Coordinated attacks with multiple malicious nodes could create false topology views, fragmenting the network

While not directly causing fund loss or consensus safety breaks, this enables sophisticated attacks that degrade network reliability and could facilitate other exploits (eclipse attacks, transaction censoring, state inconsistencies).

## Likelihood Explanation

**Likelihood: HIGH**

The attack is highly feasible:

1. **Low Barrier**: Any node operator can run modified peer-monitoring-service code
2. **No Authentication Required**: Public Full Nodes are untrusted by design; no special permissions needed
3. **Passive Acceptance**: Honest nodes automatically accept and propagate false distances due to insufficient validation
4. **Network Effect**: The recursive calculation amplifies the attack—one malicious node affects all downstream nodes
5. **Detection Difficulty**: No cross-validation or consistency checks exist to detect false distance claims

The only constraint is that the malicious node must be connected to victim nodes, which is trivial for publicly accessible PFNs.

## Recommendation

Add comprehensive validation for distance values ≥ 2 based on peer role and topology consistency:

```rust
// In peer-monitoring-service/client/src/peer_states/network_info.rs
// Lines 137-140 should be replaced with:

distance_from_validators => {
    // Basic upper bound check
    if distance_from_validators > MAX_DISTANCE_FROM_VALIDATORS {
        false
    } else {
        // Role-based distance validation
        let peer_role = peer_metadata.get_connection_metadata().role;
        match peer_role {
            PeerRole::Validator => {
                // Validators should report distance 0 or be disconnected (high distance)
                distance_from_validators == 0 || distance_from_validators >= 10
            },
            PeerRole::ValidatorFullNode => {
                // VFNs should report distance 1 or be disconnected
                distance_from_validators == 1 || distance_from_validators >= 10
            },
            PeerRole::Unknown | PeerRole::PreferredUpstream => {
                // PFNs must have distance >= 2
                distance_from_validators >= 2
            },
            _ => {
                // Reject unexpected roles
                false
            }
        }
    }
}
```

Additionally, implement cross-validation:
1. Track minimum observed distance per peer over time
2. Reject sudden decreases in reported distance
3. Compare peer's claimed distance with their connected peers' distances
4. Add rate limiting for distance updates

## Proof of Concept

```rust
// Integration test demonstrating the vulnerability
// File: peer-monitoring-service/client/src/tests/distance_poisoning_test.rs

#[cfg(test)]
mod distance_poisoning_test {
    use super::*;
    use aptos_config::config::{NodeConfig, PeerRole, RoleType};
    use aptos_config::network_id::{NetworkId, PeerNetworkId};
    use aptos_peer_monitoring_service_types::response::{
        NetworkInformationResponse, PeerMonitoringServiceResponse,
    };
    use aptos_network::application::metadata::PeerMetadata;
    use aptos_types::PeerId;

    #[test]
    fn test_malicious_distance_accepted_and_propagated() {
        // Setup: Create a VFN node that will be the victim
        let victim_config = NodeConfig {
            base: BaseConfig {
                role: RoleType::FullNode,
                ..Default::default()
            },
            ..Default::default()
        };
        let mut victim_network_info_state = 
            NetworkInfoState::new(victim_config, TimeService::mock());

        // Attack Step 1: Malicious PFN (Unknown role) reports distance 2
        // In reality, this node is at distance 50 or completely disconnected
        let malicious_peer = PeerNetworkId::new(NetworkId::Public, PeerId::random());
        let malicious_peer_metadata = create_peer_metadata(PeerRole::Unknown);
        
        let malicious_response = PeerMonitoringServiceResponse::NetworkInformation(
            NetworkInformationResponse {
                connected_peers: Default::default(),
                distance_from_validators: 2, // FALSE! Actual distance >> 2
            }
        );

        // Attack Step 2: Victim accepts the malicious distance
        victim_network_info_state.handle_monitoring_service_response(
            &malicious_peer,
            malicious_peer_metadata,
            PeerMonitoringServiceRequest::GetNetworkInformation,
            malicious_response,
            0.0,
        );

        // Verify: The false distance was accepted despite Unknown role
        let stored_response = victim_network_info_state
            .get_latest_network_info_response()
            .expect("Response should be stored");
        assert_eq!(stored_response.distance_from_validators, 2);
        
        // Attack Step 3: Victim calculates own distance as min(2) + 1 = 3
        // When the victim serves this to its peers, they calculate 4, etc.
        // This demonstrates recursive propagation of the poisoned distance
        
        println!("✗ VULNERABILITY CONFIRMED: Unknown role peer claiming distance 2 was accepted!");
        println!("✗ This will cause victim to calculate distance 3 and propagate to network");
        println!("✗ Expected: Validation should reject distance 2 from non-VFN peer");
    }

    fn create_peer_metadata(role: PeerRole) -> PeerMetadata {
        use aptos_netcore::transport::ConnectionOrigin;
        use aptos_network::protocols::wire::handshake::v1::{
            MessagingProtocolVersion, ProtocolIdSet,
        };
        use aptos_network::transport::{ConnectionId, ConnectionMetadata};
        use aptos_types::network_address::NetworkAddress;
        use std::str::FromStr;

        let connection_metadata = ConnectionMetadata::new(
            PeerId::random(),
            ConnectionId::default(),
            NetworkAddress::from_str("/ip4/127.0.0.1/tcp/8081").unwrap(),
            ConnectionOrigin::Outbound,
            MessagingProtocolVersion::V1,
            ProtocolIdSet::empty(),
            role,
        );
        PeerMetadata::new(connection_metadata)
    }
}
```

**Expected Output**: Test passes, demonstrating that a malicious peer with `Unknown` role can successfully claim `distance_from_validators = 2` and have it accepted by honest nodes, which then propagate this false metric throughout the network.

## Notes

This vulnerability is particularly severe because:

1. **No Local Detection**: Individual nodes cannot independently verify peer-reported distances without global topology knowledge
2. **Amplification Effect**: The recursive calculation means one malicious node affects all transitively connected nodes
3. **Silent Failure**: No warnings or errors occur; the system silently accepts and uses poisoned metrics
4. **Cross-Component Impact**: Affects mempool, state sync, and consensus observer simultaneously

The fix requires both immediate validation hardening and longer-term architectural improvements for distance verification and cross-validation mechanisms.

### Citations

**File:** peer-monitoring-service/server/src/lib.rs (L298-340)
```rust
fn get_distance_from_validators(
    base_config: &BaseConfig,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> u64 {
    // Get the connected peers and metadata
    let connected_peers_and_metadata = match peers_and_metadata.get_connected_peers_and_metadata() {
        Ok(connected_peers_and_metadata) => connected_peers_and_metadata,
        Err(error) => {
            warn!(LogSchema::new(LogEntry::PeerMonitoringServiceError).error(&error.into()));
            return MAX_DISTANCE_FROM_VALIDATORS;
        },
    };

    // If we're a validator and we have active validator peers, we're in the validator set.
    // TODO: figure out if we need to deal with validator set forks here.
    if base_config.role.is_validator() {
        for peer_metadata in connected_peers_and_metadata.values() {
            if peer_metadata.get_connection_metadata().role.is_validator() {
                return 0;
            }
        }
    }

    // Otherwise, go through our peers, find the min, and return a distance relative to the min
    let mut min_peer_distance_from_validators = MAX_DISTANCE_FROM_VALIDATORS;
    for peer_metadata in connected_peers_and_metadata.values() {
        if let Some(ref latest_network_info_response) = peer_metadata
            .get_peer_monitoring_metadata()
            .latest_network_info_response
        {
            min_peer_distance_from_validators = min(
                min_peer_distance_from_validators,
                latest_network_info_response.distance_from_validators,
            );
        }
    }

    // We're one hop away from the peer
    min(
        MAX_DISTANCE_FROM_VALIDATORS,
        min_peer_distance_from_validators + 1,
    )
}
```

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L116-154)
```rust
        // Sanity check the response depth from the peer metadata
        let network_id = peer_network_id.network_id();
        let is_valid_depth = match network_info_response.distance_from_validators {
            0 => {
                // Verify the peer is a validator and has the correct network id
                let peer_is_validator = peer_metadata.get_connection_metadata().role.is_validator();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_validator_network(), // We're a validator
                    RoleType::FullNode => network_id.is_vfn_network(),        // We're a VFN
                };
                peer_is_validator && peer_has_correct_network
            },
            1 => {
                // Verify the peer is a VFN and has the correct network id
                let peer_is_vfn = peer_metadata.get_connection_metadata().role.is_vfn();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_vfn_network(), // We're a validator
                    RoleType::FullNode => network_id.is_public_network(), // We're a VFN or PFN
                };
                peer_is_vfn && peer_has_correct_network
            },
            distance_from_validators => {
                // The distance must be less than or equal to the max
                distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS
            },
        };

        // If the depth did not pass our sanity checks, handle a failure
        if !is_valid_depth {
            warn!(LogSchema::new(LogEntry::NetworkInfoRequest)
                .event(LogEvent::InvalidResponse)
                .peer(peer_network_id)
                .message(&format!(
                    "Peer returned invalid depth from validators: {}",
                    network_info_response.distance_from_validators
                )));
            self.handle_request_failure();
            return;
        }
```

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L156-158)
```rust
        // Store the new latency ping result
        self.record_network_info_response(network_info_response);
    }
```

**File:** mempool/src/shared_mempool/priority.rs (L103-109)
```rust
        // Otherwise, compare by peer distance from the validators.
        // This avoids badly configured/connected peers (e.g., broken VN-VFN connections).
        let distance_ordering =
            compare_validator_distance(monitoring_metadata_a, monitoring_metadata_b);
        if !distance_ordering.is_eq() {
            return distance_ordering; // Only return if it's not equal
        }
```

**File:** state-sync/aptos-data-client/src/utils.rs (L26-64)
```rust
pub fn choose_random_peers_by_distance_and_latency(
    peers: HashSet<PeerNetworkId>,
    peers_and_metadata: Arc<PeersAndMetadata>,
    num_peers_to_choose: usize,
) -> HashSet<PeerNetworkId> {
    // Group peers and latency weights by validator distance, i.e., distance -> [(peer, latency weight)]
    let mut peers_and_latencies_by_distance = BTreeMap::new();
    for peer in peers {
        if let Some((distance, latency)) =
            get_distance_and_latency_for_peer(&peers_and_metadata, peer)
        {
            let latency_weight = convert_latency_to_weight(latency);
            peers_and_latencies_by_distance
                .entry(distance)
                .or_insert_with(Vec::new)
                .push((peer, latency_weight));
        }
    }

    // Select the peers by distance and latency weights. Note: BTreeMaps are
    // sorted by key, so the entries will be sorted by distance in ascending order.
    let mut selected_peers = HashSet::new();
    for (_, peers_and_latencies) in peers_and_latencies_by_distance {
        // Select the peers by latency weights
        let num_peers_remaining = num_peers_to_choose.saturating_sub(selected_peers.len()) as u64;
        let peers = choose_random_peers_by_weight(num_peers_remaining, peers_and_latencies);

        // Add the peers to the entire set
        selected_peers.extend(peers);

        // If we have selected enough peers, return early
        if selected_peers.len() >= num_peers_to_choose {
            return selected_peers;
        }
    }

    // Return the selected peers
    selected_peers
}
```
