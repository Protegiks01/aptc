# Audit Report

## Title
AsyncConcurrentDropper Panic-Induced Resource Exhaustion Leading to Node Deadlock

## Summary
The `AsyncConcurrentDropper` used throughout Aptos Core's critical execution and storage paths does not handle panics in Drop implementations. When a resource panics during asynchronous dropping, the task slot is permanently leaked, and after `max_tasks` panics (32 for `DEFAULT_DROPPER`), all future async drop operations block indefinitely, causing validator node deadlock and loss of liveness.

## Finding Description

The `AsyncConcurrentDropper` is used extensively in production code through the global `DEFAULT_DROPPER` instance and other static instances for dropping heavy resources like block execution state, cached Merkle tree nodes, and database structures. [1](#0-0) [2](#0-1) 

The critical flaw exists in the `schedule_drop_impl` method where drops are executed: [3](#0-2) 

If `Self::do_drop(v, notif_sender_opt)` panics on line 80 (which calls `drop(v)` on line 87), the closure unwinds and `num_tasks_tracker.dec()` on line 82 is never executed. This permanently leaks a task slot. [4](#0-3) 

The task tracker enforces a maximum concurrent drops limit through a condition variable: [5](#0-4) 

When `max_tasks` slots are leaked due to panics, line 114's condition becomes permanently true, causing all future `schedule_drop` calls to block forever on line 115.

While Aptos has a security policy stating Drop implementations must not panic: [6](#0-5) 

There exist Drop implementations that can panic. For example: [7](#0-6) 

This Drop implementation contains double `.unwrap()` calls that panic if the channel is closed or returns an error, violating the secure coding policy.

**Attack Scenario:**

1. Attacker identifies or triggers conditions causing Drop implementations to panic (e.g., corrupted state, race conditions in shutdown, malformed cached structures)
2. Through malicious transactions or exploiting existing bugs, attacker triggers 32 panicking drops
3. All 32 task slots in `DEFAULT_DROPPER` are leaked
4. All subsequent block execution completions attempt to schedule drops and block forever
5. Node becomes unresponsive, losing liveness
6. Consensus participation stops, network degradation occurs

## Impact Explanation

This vulnerability qualifies as **High Severity** per Aptos bug bounty criteria:

- **Validator node slowdowns**: After partial slot leakage, drop operations become progressively slower
- **Total loss of liveness**: After 32 panics, the node completely deadlocks and cannot process blocks
- **Network availability impact**: Multiple affected validators cause consensus disruption

The impact escalates from High to potentially Critical if an attacker can systematically trigger this across multiple validators simultaneously, causing network-wide liveness failure.

## Likelihood Explanation

**Likelihood: Medium to High**

- Drop implementations exist that violate the no-panic policy (as shown in `JellyfishMerkleRestore`)
- The codebase uses `DEFAULT_DROPPER` extensively in critical paths (block executor, storage)
- An attacker needs to either:
  - Find and exploit existing panicking Drop implementations through malicious inputs
  - Trigger edge cases during node shutdown or state corruption
  - Exploit race conditions that cause Drop implementations to panic
- Once triggered, the effect is cumulative and permanent until node restart
- No runtime monitoring or recovery mechanism exists

## Recommendation

Implement panic-safe resource tracking using either a guard pattern or `std::panic::catch_unwind`:

**Option 1: RAII Guard Pattern (Recommended)**
```rust
struct TaskGuard<'a> {
    tracker: Arc<NumTasksTracker>,
    decremented: bool,
}

impl Drop for TaskGuard<'_> {
    fn drop(&mut self) {
        if !self.decremented {
            self.tracker.dec();
        }
    }
}

impl TaskGuard<'_> {
    fn mark_complete(&mut self) {
        if !self.decremented {
            self.tracker.dec();
            self.decremented = true;
        }
    }
}

fn schedule_drop_impl<V: Send + 'static>(&self, v: V, notif_sender_opt: Option<Sender<()>>) {
    if IN_ANY_DROP_POOL.get() {
        Self::do_drop(v, notif_sender_opt);
        return;
    }

    let _timer = TIMER.timer_with(&[self.name, "enqueue_drop"]);
    self.num_tasks_tracker.inc();

    let name = self.name;
    let num_tasks_tracker = self.num_tasks_tracker.clone();

    self.thread_pool.execute(move || {
        let _timer = TIMER.timer_with(&[name, "real_drop"]);
        let mut guard = TaskGuard {
            tracker: num_tasks_tracker,
            decremented: false,
        };

        IN_ANY_DROP_POOL.with(|flag| {
            flag.set(true);
        });

        Self::do_drop(v, notif_sender_opt);
        
        guard.mark_complete(); // Explicit successful completion
    })
}
```

**Option 2: Catch Panic**
```rust
fn schedule_drop_impl<V: Send + 'static>(&self, v: V, notif_sender_opt: Option<Sender<()>>) {
    // ... existing code ...
    
    self.thread_pool.execute(move || {
        let _timer = TIMER.timer_with(&[name, "real_drop"]);

        IN_ANY_DROP_POOL.with(|flag| {
            flag.set(true);
        });

        // Catch panics to ensure dec() is always called
        let result = std::panic::catch_unwind(std::panic::AssertUnwindSafe(|| {
            Self::do_drop(v, notif_sender_opt);
        }));

        num_tasks_tracker.dec();

        if let Err(e) = result {
            error!("Async drop panicked for {}: {:?}", name, e);
            // Optionally: record metrics, trigger alerts
        }
    })
}
```

Apply the same fix to `AsyncDropQueue`: [8](#0-7) 

## Proof of Concept

```rust
use aptos_drop_helper::DEFAULT_DROPPER;
use std::sync::atomic::{AtomicUsize, Ordering};
use std::sync::Arc;

struct PanickingDrop {
    counter: Arc<AtomicUsize>,
}

impl Drop for PanickingDrop {
    fn drop(&mut self) {
        let count = self.counter.fetch_add(1, Ordering::SeqCst);
        // Panic on every drop
        panic!("Intentional panic in drop #{}", count);
    }
}

#[test]
fn test_panic_induced_deadlock() {
    let counter = Arc::new(AtomicUsize::new(0));
    let max_tasks = DEFAULT_DROPPER.max_tasks();
    
    println!("Triggering {} panicking drops (max_tasks = {})", max_tasks, max_tasks);
    
    // Trigger max_tasks panicking drops to leak all slots
    for i in 0..max_tasks {
        let c = counter.clone();
        std::thread::spawn(move || {
            DEFAULT_DROPPER.schedule_drop(PanickingDrop { counter: c });
        });
    }
    
    // Wait for panics to propagate
    std::thread::sleep(std::time::Duration::from_secs(2));
    
    assert_eq!(counter.load(Ordering::SeqCst), max_tasks);
    
    println!("All slots leaked. Attempting one more drop - this will deadlock!");
    
    // This will block forever because all slots are leaked
    let start = std::time::Instant::now();
    std::thread::spawn(|| {
        DEFAULT_DROPPER.schedule_drop(String::from("This will never complete"));
    });
    
    std::thread::sleep(std::time::Duration::from_secs(5));
    
    // If we reach here without deadlock, the vulnerability is NOT present
    panic!("Expected deadlock did not occur - vulnerability may be fixed");
}
```

**Notes:**
- This vulnerability exists in production code through `DEFAULT_DROPPER` and other static `AsyncConcurrentDropper` instances
- While Drop implementations should not panic per policy, defense-in-depth requires handling such cases
- The vulnerability directly answers the security question: panicking drops leave resources inconsistent AND cause permanent deadlock through resource exhaustion
- The fix is straightforward and has minimal performance impact
- This issue affects graceful shutdown as the leaked slots prevent proper cleanup during node termination

### Citations

**File:** crates/aptos-drop-helper/src/lib.rs (L19-20)
```rust
pub static DEFAULT_DROPPER: Lazy<AsyncConcurrentDropper> =
    Lazy::new(|| AsyncConcurrentDropper::new("default", 32, 8));
```

**File:** aptos-move/block-executor/src/executor.rs (L1837-1837)
```rust
        DEFAULT_DROPPER.schedule_drop((last_input_output, scheduler, versioned_cache));
```

**File:** crates/aptos-drop-helper/src/async_concurrent_dropper.rs (L73-83)
```rust
        self.thread_pool.execute(move || {
            let _timer = TIMER.timer_with(&[name, "real_drop"]);

            IN_ANY_DROP_POOL.with(|flag| {
                flag.set(true);
            });

            Self::do_drop(v, notif_sender_opt);

            num_tasks_tracker.dec();
        })
```

**File:** crates/aptos-drop-helper/src/async_concurrent_dropper.rs (L86-92)
```rust
    fn do_drop<V: Send + 'static>(v: V, notif_sender_opt: Option<Sender<()>>) {
        drop(v);

        if let Some(sender) = notif_sender_opt {
            sender.send(()).ok();
        }
    }
```

**File:** crates/aptos-drop-helper/src/async_concurrent_dropper.rs (L112-119)
```rust
    fn inc(&self) {
        let mut num_tasks = self.lock.lock();
        while *num_tasks >= self.max_tasks {
            num_tasks = self.cvar.wait(num_tasks).expect("lock poisoned.");
        }
        *num_tasks += 1;
        GAUGE.set_with(&[self.name, "num_tasks"], *num_tasks as i64);
    }
```

**File:** RUST_SECURE_CODING.md (L93-94)
```markdown
In a Rust secure development, the implementation of the `std::ops::Drop` trait
must not panic.
```

**File:** storage/jellyfish-merkle/src/restore/mod.rs (L792-797)
```rust
impl<K> Drop for JellyfishMerkleRestore<K> {
    fn drop(&mut self) {
        if let Some(rx) = self.async_commit_result.take() {
            rx.recv().unwrap().unwrap();
        }
    }
```

**File:** crates/aptos-drop-helper/src/async_drop_queue.rs (L43-49)
```rust
        self.thread.execute(move || {
            let _timer = TIMER.timer_with(&[name, "real_drop"]);

            drop(v);

            token_tx.send(()).ok();
        })
```
