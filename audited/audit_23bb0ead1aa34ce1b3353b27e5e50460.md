# Audit Report

## Title
Stream Protocol Request ID Reuse Vulnerability Allows Message Corruption via Late Fragment Injection

## Summary
The `InboundStreamBuffer` in the network stream protocol does not track previously used `request_id` values after stream completion. A malicious peer can reuse the same `request_id` for a new stream and inject fragments from the old stream into the new stream, causing message corruption that could affect consensus, state synchronization, or RPC handling.

## Finding Description

The network stream protocol splits large messages into fragments for transmission. Each stream is identified by a `request_id` and consists of a header followed by numbered fragments. The vulnerability exists in how completed streams are handled.

When a stream completes, the `InboundStream` is removed via `self.stream.take()`, setting the field to `None`. [1](#0-0) 

The critical issue is that there is **no tracking mechanism** to prevent a peer from reusing the same `request_id` for a subsequent stream. The `InboundStreamBuffer` maintains only a single `Option<InboundStream>` field. [2](#0-1) 

When a new stream header arrives with a reused `request_id`, if no active stream exists (`self.stream` is `None`), the new stream is created without any validation against previously used IDs. [3](#0-2) 

**Attack Sequence:**

1. Malicious peer sends: `Header(request_id=100, num_fragments=3)` with legitimate data
2. Peer completes the stream by sending fragments 1, 2, 3
3. Stream completes, message is processed, `self.stream` becomes `None`
4. Peer immediately sends: `Header(request_id=100, num_fragments=2)` - **reusing the same request_id**
5. Peer sends: `Fragment(request_id=100, fragment_id=1, data=NEW_DATA)`
6. Peer sends: `Fragment(request_id=100, fragment_id=2, data=OLD_DATA)` - fragment from the original stream

At step 6, the fragment validation in `append_fragment` checks only: [4](#0-3) 

- Request ID matches current stream (✓ both are 100)
- Fragment ID is within bounds (✓ 2 ≤ 2)
- Fragment ID matches expected sequence (✓ expecting fragment 2, received fragment 2)

All checks pass, and `OLD_DATA` from the completed stream is appended to the new stream, resulting in a corrupted message: `NEW_DATA + OLD_DATA`.

The corrupted `NetworkMessage` is then passed to `handle_inbound_network_message` for processing. [5](#0-4) 

This breaks the **Deterministic Execution** and **State Consistency** invariants because different nodes may receive different fragment orderings or corrupted data, leading to divergent state.

## Impact Explanation

**Medium Severity** - State inconsistencies requiring intervention:

1. **Message Corruption**: The reassembled `NetworkMessage` contains mixed data from two different logical streams, violating message integrity.

2. **Consensus Impact**: If consensus messages (`DirectSendMsg` with consensus protocol_id) are corrupted, validators may process malformed proposals or votes, potentially causing:
   - Deserialization failures leading to missed consensus rounds
   - Safety violations if corrupted data happens to deserialize to a valid but incorrect consensus message
   - Liveness issues if multiple validators experience corruption simultaneously

3. **State Synchronization Impact**: Corrupted state sync messages could cause nodes to request or apply incorrect state chunks, requiring manual intervention to resynchronize.

4. **RPC Impact**: Corrupted RPC requests/responses could cause incorrect application behavior or service disruptions.

While the corrupted data would likely fail deserialization in many cases (providing some defense-in-depth), an attacker with detailed protocol knowledge could craft fragments that:
- Deserialize successfully to valid but semantically incorrect messages
- Target specific message types where corruption has security impact
- Exploit parsing ambiguities or protocol weaknesses

The impact qualifies as **Medium severity** per Aptos bug bounty criteria: "State inconsistencies requiring intervention" and potential for limited consensus disruption.

## Likelihood Explanation

**Medium Likelihood:**

**Attack Requirements:**
- Attacker must be a network peer (can establish connections to validator nodes)
- Must control message timing to inject fragments at precise moments
- Requires protocol knowledge to craft effective fragment sequences
- No special privileges or validator access required

**Feasibility:**
- The attacker has full control over outbound messages and their timing
- Request IDs are not cryptographically protected or validated
- The attack is deterministic once the timing is controlled
- Can be executed repeatedly against multiple nodes

**Constraints:**
- Corrupted data must pass deserialization checks to have full impact
- Requires coordination of multiple message sends in quick succession
- Detection via monitoring could identify unusual request_id patterns

The likelihood is **medium** because while the attack is technically straightforward for a malicious peer, exploiting it for meaningful security impact requires additional sophistication in fragment crafting.

## Recommendation

Implement request ID tracking to prevent reuse within a reasonable time window:

```rust
use std::collections::HashSet;

pub struct InboundStreamBuffer {
    stream: Option<InboundStream>,
    max_fragments: usize,
    // Track recently used request IDs to prevent reuse
    recent_request_ids: HashSet<u32>,
    max_tracked_ids: usize,
}

impl InboundStreamBuffer {
    pub fn new(max_fragments: usize) -> Self {
        Self {
            stream: None,
            max_fragments,
            recent_request_ids: HashSet::new(),
            max_tracked_ids: 1000, // Prevent unbounded growth
        }
    }

    pub fn new_stream(&mut self, header: StreamHeader) -> anyhow::Result<()> {
        // Check if request_id was recently used
        if self.recent_request_ids.contains(&header.request_id) {
            bail!(
                "Request ID {} was recently used and cannot be reused",
                header.request_id
            );
        }

        let inbound_stream = InboundStream::new(header, self.max_fragments)?;
        if let Some(old) = self.stream.replace(inbound_stream) {
            bail!(
                "Discarding existing stream for request ID: {}",
                old.request_id
            )
        } else {
            // Track this request_id
            self.recent_request_ids.insert(header.request_id);
            
            // Limit tracking set size to prevent memory exhaustion
            if self.recent_request_ids.len() > self.max_tracked_ids {
                // Remove oldest entries (or use LRU cache)
                // Simple approach: clear half when full
                if self.recent_request_ids.len() > self.max_tracked_ids * 2 {
                    self.recent_request_ids.clear();
                }
            }
            
            Ok(())
        }
    }
}
```

**Alternative Solution:** Use a combination of peer ID and request ID to create unique stream identifiers, preventing cross-stream confusion even with ID reuse.

**Additional Hardening:** Consider implementing a monotonicity check where each peer's request IDs must be strictly increasing (with wraparound handling), similar to sequence numbers in TCP.

## Proof of Concept

```rust
#[cfg(test)]
mod exploit_tests {
    use super::*;
    use crate::protocols::wire::messaging::v1::{DirectSendMsg, NetworkMessage};
    use crate::protocols::wire::handshake::v1::ProtocolId::ConsensusRpcBcs;

    #[test]
    fn test_request_id_reuse_vulnerability() {
        let max_fragments = 10;
        let mut buffer = InboundStreamBuffer::new(max_fragments);

        // Step 1: Start first stream with request_id=100
        let header1 = StreamHeader {
            request_id: 100,
            num_fragments: 3,
            message: NetworkMessage::DirectSendMsg(DirectSendMsg {
                protocol_id: ConsensusRpcBcs,
                priority: 0,
                raw_msg: vec![],
            }),
        };
        assert!(buffer.new_stream(header1).is_ok());

        // Step 2: Complete first stream
        for fragment_id in 1..=3 {
            let fragment = StreamFragment {
                request_id: 100,
                fragment_id,
                raw_data: vec![0xFF; 10], // OLD_DATA
            };
            let result = buffer.append_fragment(fragment);
            assert!(result.is_ok());
        }
        
        // Stream is now complete and taken
        assert!(buffer.stream.is_none());

        // Step 3: Start NEW stream with SAME request_id=100 (VULNERABILITY!)
        let header2 = StreamHeader {
            request_id: 100, // REUSED ID!
            num_fragments: 2,
            message: NetworkMessage::DirectSendMsg(DirectSendMsg {
                protocol_id: ConsensusRpcBcs,
                priority: 0,
                raw_msg: vec![],
            }),
        };
        // This should fail but currently succeeds!
        assert!(buffer.new_stream(header2).is_ok());

        // Step 4: Send first fragment of new stream
        let fragment_new = StreamFragment {
            request_id: 100,
            fragment_id: 1,
            raw_data: vec![0xAA; 10], // NEW_DATA
        };
        assert!(buffer.append_fragment(fragment_new).is_ok());

        // Step 5: Inject OLD fragment from completed stream
        let fragment_old = StreamFragment {
            request_id: 100,
            fragment_id: 2,
            raw_data: vec![0xFF; 10], // OLD_DATA from first stream!
        };
        
        // This should fail but SUCCEEDS - fragment is accepted!
        let result = buffer.append_fragment(fragment_old);
        assert!(result.is_ok());
        
        // The resulting message contains corrupted data: NEW_DATA + OLD_DATA
        if let Some(corrupted_message) = result.unwrap() {
            match corrupted_message {
                NetworkMessage::DirectSendMsg(msg) => {
                    // Message contains mixed data from two different streams!
                    println!("VULNERABILITY CONFIRMED: Message corrupted with mixed fragment data");
                    println!("Expected size: 10 bytes (NEW_DATA only)");
                    println!("Actual size: {} bytes (NEW_DATA + OLD_DATA)", msg.raw_msg.len());
                    assert_eq!(msg.raw_msg.len(), 20); // 10 NEW + 10 OLD = corruption!
                },
                _ => panic!("Unexpected message type"),
            }
        }
    }
}
```

**Notes:**

- This vulnerability requires a malicious or compromised peer to exploit
- The impact severity depends on the message types being corrupted and the attacker's ability to craft exploitable payloads
- Defense-in-depth from deserialization checks provides partial mitigation but does not eliminate the vulnerability
- The fix should balance security (preventing reuse) with memory efficiency (bounded tracking)

### Citations

**File:** network/framework/src/protocols/stream/mod.rs (L68-71)
```rust
pub struct InboundStreamBuffer {
    stream: Option<InboundStream>,
    max_fragments: usize,
}
```

**File:** network/framework/src/protocols/stream/mod.rs (L82-92)
```rust
    pub fn new_stream(&mut self, header: StreamHeader) -> anyhow::Result<()> {
        let inbound_stream = InboundStream::new(header, self.max_fragments)?;
        if let Some(old) = self.stream.replace(inbound_stream) {
            bail!(
                "Discarding existing stream for request ID: {}",
                old.request_id
            )
        } else {
            Ok(())
        }
    }
```

**File:** network/framework/src/protocols/stream/mod.rs (L107-108)
```rust
        if stream_end {
            Ok(Some(self.stream.take().unwrap().message))
```

**File:** network/framework/src/protocols/stream/mod.rs (L164-195)
```rust
    fn append_fragment(&mut self, mut fragment: StreamFragment) -> anyhow::Result<bool> {
        // Verify the stream request ID and fragment request ID
        ensure!(
            self.request_id == fragment.request_id,
            "Stream fragment from a different request! Expected {}, got {}.",
            self.request_id,
            fragment.request_id
        );

        // Verify the fragment ID
        let fragment_id = fragment.fragment_id;
        ensure!(fragment_id > 0, "Fragment ID must be greater than zero!");
        ensure!(
            fragment_id <= self.num_fragments,
            "Fragment ID {} exceeds number of fragments {}!",
            fragment_id,
            self.num_fragments
        );

        // Verify the fragment ID is the expected next fragment
        let expected_fragment_id = self.received_fragment_id.checked_add(1).ok_or_else(|| {
            anyhow::anyhow!(
                "Current fragment ID overflowed when adding 1: {}",
                self.received_fragment_id
            )
        })?;
        ensure!(
            expected_fragment_id == fragment_id,
            "Unexpected fragment ID, expected {}, got {}!",
            expected_fragment_id,
            fragment_id
        );
```

**File:** network/framework/src/peer/mod.rs (L543-557)
```rust
    fn handle_inbound_stream_message(
        &mut self,
        message: StreamMessage,
    ) -> Result<(), PeerManagerError> {
        match message {
            StreamMessage::Header(header) => {
                self.inbound_stream.new_stream(header)?;
            },
            StreamMessage::Fragment(fragment) => {
                if let Some(message) = self.inbound_stream.append_fragment(fragment)? {
                    self.handle_inbound_network_message(message)?;
                }
            },
        }
        Ok(())
```
