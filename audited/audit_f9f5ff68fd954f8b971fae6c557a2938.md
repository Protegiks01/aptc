# Audit Report

## Title
Seed PeerRole Immutability Enables Persistent Role Confusion Attacks in Network Layer

## Summary
The ConnectivityManager never updates a peer's role after initial discovery, allowing seed configurations to permanently assign incorrect PeerRoles that override subsequent onchain discovery. This enables role confusion attacks where malicious or misconfigured nodes can elevate privileges, disrupt validator connectivity, or manipulate peer selection priority.

## Finding Description

The vulnerability exists in the interaction between seed configuration processing and the connectivity manager's peer discovery logic.

**Root Cause 1: Role Immutability**

In the ConnectivityManager's `handle_update_discovered_peers()` function, peer roles are set only when first discovered and never updated: [1](#0-0) 

The `or_insert_with` pattern ensures that once a peer's role is set during initial discovery (typically from seeds), it persists permanently even when subsequent discovery sources (like OnChainValidatorSet) provide the correct role.

**Root Cause 2: Hardcoded ValidatorFullNode Role for Legacy Seeds**

The `merge_seeds()` function hardcodes ALL peers from the legacy `seed_addrs` configuration as `PeerRole::ValidatorFullNode`: [2](#0-1) 

**Root Cause 3: Seeds Processed Before Onchain Discovery**

Seeds are processed first during ConnectivityManager initialization: [3](#0-2) 

This ensures seed-provided roles take precedence over onchain discovery.

**Attack Vectors:**

1. **Validator Network Role Confusion**: A misconfigured validator marks non-validator peers as `PeerRole::Validator` in seeds. Since the validator network only allows connections to `PeerRole::Validator` peers, the validator wastes resources attempting to dial non-validators: [4](#0-3) 

2. **Privilege Escalation on Public Networks**: Malicious nodes mark themselves as `PeerRole::ValidatorFullNode` in seeds distributed to public fullnodes. Public fullnodes prioritize ValidatorFullNodes for upstream connections, giving malicious nodes undeserved priority and trust.

3. **Role Downgrade Attack**: Seeds mark legitimate ValidatorFullNodes as `PeerRole::Downstream` or `PeerRole::Known`, preventing proper upstream peer selection and disrupting network connectivity.

**Additional Bug: Inverted Logic in Peer::extend()**

The role validation logic is inverted - it rejects matching roles instead of mismatching roles: [5](#0-4) 

The condition checks `self.role == other.role` but the error message says "Roles don't match", indicating the intended check was `self.role != other.role`.

## Impact Explanation

This vulnerability qualifies as **HIGH severity** under Aptos bug bounty criteria:

1. **Validator Node Slowdowns**: Validators attempting to connect to incorrectly-roled peers waste computational resources on failed connection attempts, connection backoffs, and dial queue management.

2. **Significant Protocol Violations**: The network layer's trust model is violated when nodes can permanently assign arbitrary roles to peers, bypassing the intended role hierarchy (Validator > ValidatorFullNode > Upstream > Downstream > Known > Unknown).

3. **Network Connectivity Disruption**: Incorrect roles prevent proper peer selection, particularly affecting:
   - Validators unable to maintain full mesh connectivity
   - Fullnodes unable to discover legitimate ValidatorFullNodes
   - Public network nodes connecting to malicious "elevated" peers

The role determines critical network behaviors including dial eligibility (`roles_to_dial.contains(&peer.role)`), peer prioritization (`peer.role.partial_cmp(&other.role)`), and trusted peer set composition. [6](#0-5) 

## Likelihood Explanation

**Likelihood: HIGH**

1. **Easy to Exploit**: Requires only configuration file modification, no special access or complex attack setup.

2. **Multiple Attack Vectors**: Affects both malicious actors (intentional privilege escalation) and accidental misconfigurations (operators incorrectly configuring seeds).

3. **Persistent Impact**: Once set via seeds, incorrect roles persist indefinitely, even through epoch changes and validator set updates.

4. **No Validation**: The `verify_seeds()` function only validates addresses and key presence, not role correctness: [7](#0-6) 

5. **Backwards Compatibility Risk**: The legacy `seed_addrs` format automatically elevates all seeds to ValidatorFullNode, potentially affecting existing deployments.

## Recommendation

**Solution 1: Update Roles from Higher-Priority Discovery Sources**

Modify `handle_update_discovered_peers()` to update roles when higher-priority discovery sources (OnChain > File > Rest > Config) provide different roles:

```rust
// In handle_update_discovered_peers, replace line 940:
let peer = discovered_peers
    .peer_set
    .entry(peer_id)
    .or_insert_with(|| DiscoveredPeer::new(discovered_peer.role));

// With role update logic:
let peer = discovered_peers
    .peer_set
    .entry(peer_id)
    .or_insert_with(|| DiscoveredPeer::new(discovered_peer.role));

// Update role if source has higher priority
if src < DiscoverySource::Config || peer.role != discovered_peer.role {
    info!(
        NetworkSchema::new(&self.network_context).remote_peer(&peer_id),
        old_role = ?peer.role,
        new_role = ?discovered_peer.role,
        "{} Updating peer role: {} from {:?} to {:?}",
        self.network_context,
        peer_id.short_str(),
        peer.role,
        discovered_peer.role
    );
    peer.role = discovered_peer.role;
}
```

**Solution 2: Fix Inverted Logic in Peer::extend()**

Correct the role validation check:

```rust
pub fn extend(&mut self, other: Peer) -> Result<(), Error> {
    if self.role != other.role {  // Changed from ==
        return Err(Error::InvariantViolation(format!(
            "Roles don't match self {:?} vs other {:?}",
            self.role, other.role
        )));
    }
    // ... rest of function
}
```

**Solution 3: Add Role Validation in verify_seeds()**

Validate that seed roles are appropriate for the network context:

```rust
pub fn verify_seeds(&self) -> Result<(), Error> {
    // ... existing validation ...
    
    // Validate roles are appropriate for network
    let allowed_roles = self.network_id.upstream_roles(&self.role);
    for (peer_id, seed) in self.seeds.iter() {
        if self.network_id.is_validator_network() && seed.role != PeerRole::Validator {
            return Err(Error::InvariantViolation(format!(
                "Seed peer {} has invalid role {:?} for validator network",
                peer_id.short_str(),
                seed.role
            )));
        }
    }
    Ok(())
}
```

## Proof of Concept

**Setup**: Create two nodes - a validator and a malicious fullnode

**Step 1**: Configure validator's seeds to include malicious fullnode with elevated role:

```yaml
# validator_config.yaml
seeds:
  malicious_peer_id:
    addresses: ["/ip4/10.0.0.50/tcp/6180"]
    keys: [malicious_pubkey]
    role: "validator"  # Incorrect - should be "unknown" or not in seeds
```

**Step 2**: Start validator node with this config

**Step 3**: Observe behavior:
- Validator's ConnectivityManager processes seeds first (Config discovery source)
- Malicious peer assigned `PeerRole::Validator` 
- When OnChainValidatorSet discovery occurs, role is NOT updated (line 940 uses `or_insert_with`)
- Validator attempts to dial malicious peer on validator network
- Connection fails but validator keeps retrying with exponential backoff
- Dial queue and connection resources consumed

**Verification Steps**:
1. Check logs for dial attempts to malicious peer
2. Check `discovered_peers` - malicious peer shows `role: Validator`
3. Monitor metrics: `aptos_network_dial_queue_size` increases
4. Check `trusted_peers` set includes malicious peer with Validator role
5. Verify OnChain discovery updates don't change the role

**Expected vs Actual**:
- **Expected**: OnChain discovery should correct the role to Unknown/not present
- **Actual**: Role remains Validator permanently, causing ongoing dial attempts

This can be reproduced in integration tests by mocking the discovery sources and observing peer role persistence across discovery updates.

---

**Notes**

This vulnerability affects network connectivity and trust model integrity but does not directly compromise consensus safety due to additional handshake validation. However, the resource exhaustion and role confusion can degrade validator performance and enable secondary attacks. The combination of role immutability, hardcoded legacy seed roles, and lack of validation creates a significant attack surface for network-layer exploits.

### Citations

**File:** network/framework/src/connectivity_manager/mod.rs (L400-402)
```rust
        // Set the initial seed config addresses and public keys
        connmgr.handle_update_discovered_peers(DiscoverySource::Config, seeds);
        connmgr
```

**File:** network/framework/src/connectivity_manager/mod.rs (L572-586)
```rust
    async fn choose_peers_to_dial(&mut self) -> Vec<(PeerId, DiscoveredPeer)> {
        // Get the eligible peers to dial
        let network_id = self.network_context.network_id();
        let role = self.network_context.role();
        let roles_to_dial = network_id.upstream_roles(&role);
        let discovered_peers = self.discovered_peers.read().peer_set.clone();
        let eligible_peers: Vec<_> = discovered_peers
            .into_iter()
            .filter(|(peer_id, peer)| {
                peer.is_eligible_to_be_dialed() // The node is eligible to dial
                    && !self.connected.contains_key(peer_id) // The node is not already connected
                    && !self.dial_queue.contains_key(peer_id) // There is no pending dial to this node
                    && roles_to_dial.contains(&peer.role) // We can dial this role
            })
            .collect();
```

**File:** network/framework/src/connectivity_manager/mod.rs (L935-940)
```rust
            // Create the new `DiscoveredPeer`, role is set when a `Peer` is first discovered
            let mut discovered_peers = self.discovered_peers.write();
            let peer = discovered_peers
                .peer_set
                .entry(peer_id)
                .or_insert_with(|| DiscoveredPeer::new(discovered_peer.role));
```

**File:** network/builder/src/builder.rs (L478-494)
```rust
    // TODO(gnazario): Once fully migrated, remove `seed_addrs`
    config
        .seed_addrs
        .iter()
        .map(|(peer_id, addrs)| {
            (
                peer_id,
                Peer::from_addrs(PeerRole::ValidatorFullNode, addrs.clone()),
            )
        })
        .for_each(|(peer_id, peer)| {
            seeds
                .entry(*peer_id)
                // Sad clone due to Rust not realizing these are two distinct paths
                .and_modify(|seed| seed.extend(peer.clone()).unwrap())
                .or_insert(peer);
        });
```

**File:** config/src/network_id.rs (L173-186)
```rust
    pub fn upstream_roles(&self, role: &RoleType) -> &'static [PeerRole] {
        match self {
            NetworkId::Validator => &[PeerRole::Validator],
            NetworkId::Public => &[
                PeerRole::PreferredUpstream,
                PeerRole::Upstream,
                PeerRole::ValidatorFullNode,
            ],
            NetworkId::Vfn => match role {
                RoleType::Validator => &[],
                RoleType::FullNode => &[PeerRole::Validator],
            },
        }
    }
```

**File:** config/src/config/network_config.rs (L319-340)
```rust
    pub fn verify_seeds(&self) -> Result<(), Error> {
        for (peer_id, addrs) in self.seed_addrs.iter() {
            for addr in addrs {
                Self::verify_address(peer_id, addr)?;
            }
        }

        for (peer_id, seed) in self.seeds.iter() {
            for addr in seed.addresses.iter() {
                Self::verify_address(peer_id, addr)?;
            }

            // Require there to be a pubkey somewhere, either in the address (assumed by `is_aptosnet_addr`)
            if seed.keys.is_empty() && seed.addresses.is_empty() {
                return Err(Error::InvariantViolation(format!(
                    "Seed peer {} has no pubkeys",
                    peer_id.short_str(),
                )));
            }
        }
        Ok(())
    }
```

**File:** config/src/config/network_config.rs (L486-492)
```rust
    pub fn extend(&mut self, other: Peer) -> Result<(), Error> {
        if self.role == other.role {
            return Err(Error::InvariantViolation(format!(
                "Roles don't match self {:?} vs other {:?}",
                self.role, other.role
            )));
        }
```
