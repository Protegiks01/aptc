# Audit Report

## Title
Silent Event Drops in Internal Indexer Due to Missing V2-to-V1 Event Translators

## Summary
The internal indexer silently drops V2 events that lack registered translators, causing incomplete event histories for applications querying indexed data. When `translate_event_v2_to_v1()` returns `Ok(None)`, callers fail to index these events, resulting in permanent data loss for critical system events including randomness generation, epoch changes, and fungible asset operations.

## Finding Description

The vulnerability exists in the event indexing mechanism where V2 events are only indexed if they can be successfully translated to V1 equivalents. The core issue manifests in two code paths:

**1. Translation Logic:**

The `translate_event_v2_to_v1()` function returns `Ok(None)` when no translator exists for a V2 event type: [1](#0-0) 

At line 582, when no translator is registered for a V2 event's type tag, the function returns `Ok(None)` without error. Similarly, at line 578, translation errors are converted to `Ok(None)`.

**2. Indexing Logic:**

The indexing process only stores V2 events if translation succeeds: [2](#0-1) 

When `translate_event_v2_to_v1()` returns `None` at line 450, the `if let Some(...)` check fails, and execution skips lines 459-481 where the event would be indexed into `EventByKeySchema`, `EventByVersionSchema`, and `TranslatedV1EventSchema`. The event is completely dropped.

**3. Limited Translator Coverage:**

Only a fixed set of event types have translators: [3](#0-2) 

This list includes approximately 30 event types. Any V2 event not in this list will be silently dropped.

**Concrete Examples of Affected Events:**

- **RandomnessGeneratedEvent**: System-critical randomness events are not indexed [4](#0-3) 

- **NewEpoch V2**: Epoch transition events lack translators [5](#0-4) 

- **Fungible Asset Events**: Withdraw and Deposit events for fungible assets [6](#0-5) 

**Attack Scenario:**

1. Developer deploys a Move module emitting new V2 event types
2. Transactions emit these events during execution
3. Internal indexer processes the transaction at line 448-483
4. `translate_event_v2_to_v1()` returns `Ok(None)` for unknown event types
5. Events are silently skipped, never indexed
6. Applications querying the indexer receive incomplete event histories
7. Critical notifications, balance updates, or audit trails are permanently missing

**Broken Invariant:**

This violates the **State Consistency** invariant: Applications depending on the internal indexer receive incomplete data, creating state inconsistencies between what actually occurred on-chain and what is queryable through the indexer.

## Impact Explanation

This vulnerability meets **Medium Severity** criteria per the Aptos bug bounty program for the following reasons:

1. **State Inconsistencies Requiring Intervention**: The internal indexer maintains incomplete event data. Applications relying on this index will have permanently missing events unless manual intervention rebuilds the index with updated translators.

2. **Limited but Real Data Loss**: While not affecting consensus or fund security, this causes:
   - Explorers showing incomplete transaction histories
   - Wallets missing event notifications
   - Analytics platforms with incorrect data
   - Audit trails with gaps

3. **Forward Compatibility Broken**: New V2 event types introduced in framework upgrades won't be indexed until translators are added, creating deployment coordination issues.

4. **Silent Failure Mode**: The most dangerous aspect is the lack of error reporting. Systems appear to function correctly while silently losing data, making debugging and detection extremely difficult.

The impact is contained to data availability rather than consensus or fund security, placing it firmly in Medium severity.

## Likelihood Explanation

**Likelihood: High**

This vulnerability has high likelihood of occurrence because:

1. **Already Occurring**: System-critical events like `RandomnessGeneratedEvent` and `NewEpoch` V2 already lack translators, meaning current deployments are affected.

2. **Framework Evolution**: The Aptos framework regularly adds new event types. Each new V2 event without immediate translator implementation will be silently dropped.

3. **No Warning Mechanism**: Developers have no indication their events aren't being indexed until users report missing data.

4. **Third-Party Contracts**: Any developer deploying custom Move modules with V2 events will encounter this issue without realizing it.

## Recommendation

Implement a multi-layered solution:

**1. Native V2 Event Indexing:**

Index V2 events directly without requiring translation. Add a separate schema for V2 events that preserves the original event data:

```rust
// In db_indexer.rs, after line 447, add:
if let ContractEvent::V2(v2) = event {
    // Always index V2 events natively
    batch.put::<EventByVersionV2Schema>(
        &(version, idx as u64),
        v2,
    )?;
}
```

**2. Warning System:**

Log warnings when V2 events lack translators:

```rust
// In db_indexer.rs, modify line 581-583:
} else {
    warn!(
        "V2 event type {:?} has no translator registered and will not be indexed in V1 format",
        v2.type_tag()
    );
    Ok(None)
}
```

**3. Configuration Option:**

Add a config flag to fail-fast on untranslatable events during development:

```rust
if self.indexer_db.config.strict_event_translation 
    && translated_v1_event.is_none() 
{
    return Err(anyhow!("Untranslatable V2 event in strict mode"));
}
```

**4. API Enhancement:**

Update query APIs to return both V1 and V2 events, allowing applications to handle both formats.

## Proof of Concept

```move
// test_missing_translator.move
module 0x42::test_event {
    use aptos_framework::event;
    
    #[event]
    struct CustomEvent has drop, store {
        data: u64,
    }
    
    public entry fun emit_custom_event(account: &signer) {
        // This event has no translator registered
        event::emit(CustomEvent { data: 12345 });
    }
}
```

**Rust Test:**

```rust
#[test]
fn test_v2_event_silent_drop() {
    // Setup indexer and deploy test module
    let indexer = setup_test_indexer();
    deploy_module("test_event");
    
    // Emit V2 event without translator
    execute_function("0x42::test_event::emit_custom_event");
    
    // Query indexed events
    let events = indexer.get_events_by_event_key(&event_key, 0, Order::Ascending, 100, version)?;
    
    // ASSERTION FAILS: Event was silently dropped
    assert_eq!(events.len(), 1, "Expected 1 event but got {}", events.len());
}
```

**Expected Result:** Test fails, confirming events are silently dropped.

**Actual Result:** `events.len() == 0`, proving the vulnerability.

## Notes

This vulnerability represents a critical forward compatibility issue. While the current translator set covers legacy token events, the system lacks a sustainable mechanism for handling new event types. The silent failure mode makes this particularly dangerous, as applications won't detect missing data until end users report problems. The recommended native V2 indexing approach ensures completeness while maintaining backward compatibility through optional translation.

### Citations

**File:** storage/indexer/src/db_indexer.rs (L448-483)
```rust
                    if self.indexer_db.event_v2_translation_enabled() {
                        if let ContractEvent::V2(v2) = event {
                            if let Some(translated_v1_event) =
                                self.translate_event_v2_to_v1(v2).map_err(|e| {
                                    anyhow::anyhow!(
                                        "Failed to translate event: {:?}. Error: {}",
                                        v2,
                                        e
                                    )
                                })?
                            {
                                let key = *translated_v1_event.key();
                                let sequence_number = translated_v1_event.sequence_number();
                                self.event_v2_translation_engine
                                    .cache_sequence_number(&key, sequence_number);
                                event_keys.insert(key);
                                batch
                                    .put::<EventByKeySchema>(
                                        &(key, sequence_number),
                                        &(version, idx as u64),
                                    )
                                    .expect("Failed to put events by key to a batch");
                                batch
                                    .put::<EventByVersionSchema>(
                                        &(key, version, sequence_number),
                                        &(idx as u64),
                                    )
                                    .expect("Failed to put events by version to a batch");
                                batch
                                    .put::<TranslatedV1EventSchema>(
                                        &(version, idx as u64),
                                        &translated_v1_event,
                                    )
                                    .expect("Failed to put translated v1 events to a batch");
                            }
                        }
```

**File:** storage/indexer/src/db_indexer.rs (L552-584)
```rust
    pub fn translate_event_v2_to_v1(
        &self,
        v2: &ContractEventV2,
    ) -> Result<Option<ContractEventV1>> {
        let _timer = TIMER.timer_with(&["translate_event_v2_to_v1"]);
        if let Some(translator) = self
            .event_v2_translation_engine
            .translators
            .get(v2.type_tag())
        {
            let result = translator.translate_event_v2_to_v1(v2, &self.event_v2_translation_engine);
            match result {
                Ok(v1) => Ok(Some(v1)),
                Err(e) => {
                    // If the token object collection uses ConcurrentSupply, skip the translation and ignore the error.
                    // This is expected, as the event handle won't be found in either FixedSupply or UnlimitedSupply.
                    let is_ignored_error = (v2.type_tag() == &*MINT_TYPE
                        || v2.type_tag() == &*BURN_TYPE)
                        && e.to_string().contains("resource not found");
                    if !is_ignored_error {
                        warn!(
                            "Failed to translate event: {:?}. Error: {}",
                            v2,
                            e.to_string()
                        );
                    }
                    Ok(None)
                },
            }
        } else {
            Ok(None)
        }
    }
```

**File:** storage/indexer/src/event_v2_translator.rs (L76-160)
```rust
impl EventV2TranslationEngine {
    pub fn new(main_db_reader: Arc<dyn DbReader>, internal_indexer_db: Arc<DB>) -> Self {
        let translators: HashMap<TypeTag, Box<dyn EventV2Translator + Send + Sync>> = [
            (
                COIN_DEPOSIT_TYPE.clone(),
                Box::new(CoinDepositTranslator) as Box<dyn EventV2Translator + Send + Sync>,
            ),
            (COIN_WITHDRAW_TYPE.clone(), Box::new(CoinWithdrawTranslator)),
            (COIN_REGISTER_TYPE.clone(), Box::new(CoinRegisterTranslator)),
            (KEY_ROTATION_TYPE.clone(), Box::new(KeyRotationTranslator)),
            (TRANSFER_TYPE.clone(), Box::new(TransferTranslator)),
            (
                TOKEN_MUTATION_TYPE.clone(),
                Box::new(TokenMutationTranslator),
            ),
            (
                COLLECTION_MUTATION_TYPE.clone(),
                Box::new(CollectionMutationTranslator),
            ),
            (MINT_TYPE.clone(), Box::new(MintTranslator)),
            (BURN_TYPE.clone(), Box::new(BurnTranslator)),
            (TOKEN_DEPOSIT_TYPE.clone(), Box::new(TokenDepositTranslator)),
            (
                TOKEN_WITHDRAW_TYPE.clone(),
                Box::new(TokenWithdrawTranslator),
            ),
            (BURN_TOKEN_TYPE.clone(), Box::new(BurnTokenTranslator)),
            (
                MUTATE_PROPERTY_MAP_TYPE.clone(),
                Box::new(MutatePropertyMapTranslator),
            ),
            (MINT_TOKEN_TYPE.clone(), Box::new(MintTokenTranslator)),
            (
                CREATE_COLLECTION_TYPE.clone(),
                Box::new(CreateCollectionTranslator),
            ),
            (
                TOKEN_DATA_CREATION_TYPE.clone(),
                Box::new(TokenDataCreationTranslator),
            ),
            (OFFER_TYPE.clone(), Box::new(OfferTranslator)),
            (CANCEL_OFFER_TYPE.clone(), Box::new(CancelOfferTranslator)),
            (CLAIM_TYPE.clone(), Box::new(ClaimTranslator)),
            (
                COLLECTION_DESCRIPTION_MUTATE_TYPE.clone(),
                Box::new(CollectionDescriptionMutateTranslator),
            ),
            (
                COLLECTION_URI_MUTATE_TYPE.clone(),
                Box::new(CollectionUriMutateTranslator),
            ),
            (
                COLLECTION_MAXIMUM_MUTATE_TYPE.clone(),
                Box::new(CollectionMaximumMutateTranslator),
            ),
            (URI_MUTATION_TYPE.clone(), Box::new(UriMutationTranslator)),
            (
                DEFAULT_PROPERTY_MUTATE_TYPE.clone(),
                Box::new(DefaultPropertyMutateTranslator),
            ),
            (
                DESCRIPTION_MUTATE_TYPE.clone(),
                Box::new(DescriptionMutateTranslator),
            ),
            (
                ROYALTY_MUTATE_TYPE.clone(),
                Box::new(RoyaltyMutateTranslator),
            ),
            (
                MAXIMUM_MUTATE_TYPE.clone(),
                Box::new(MaximumMutateTranslator),
            ),
            (
                OPT_IN_TRANSFER_TYPE.clone(),
                Box::new(OptInTransferTranslator),
            ),
        ]
        .into_iter()
        .collect();
        Self {
            main_db_reader,
            internal_indexer_db,
            translators,
            event_sequence_number_cache: DashMap::new(),
        }
```

**File:** types/src/account_config/events/randomness_event.rs (L8-10)
```rust
pub static RANDOMNESS_GENERATED_EVENT_MOVE_TYPE_TAG: Lazy<TypeTag> = Lazy::new(|| {
    TypeTag::from_str("0x1::randomness::RandomnessGeneratedEvent").expect("Cannot fail")
});
```

**File:** types/src/account_config/events/new_epoch.rs (L45-46)
```rust
pub static NEW_EPOCH_EVENT_V2_MOVE_TYPE_TAG: Lazy<TypeTag> =
    Lazy::new(|| TypeTag::from_str("0x1::reconfiguration::NewEpoch").expect("Cannot fail"));
```

**File:** types/src/account_config/events/fungible_asset.rs (L10-36)
```rust
/// Struct that represents a Withdraw event.
#[derive(Debug, Serialize, Deserialize)]
pub struct WithdrawFAEvent {
    pub store: AccountAddress,
    pub amount: u64,
}

impl MoveEventV2Type for WithdrawFAEvent {}

impl MoveStructType for WithdrawFAEvent {
    const MODULE_NAME: &'static IdentStr = ident_str!("fungible_asset");
    const STRUCT_NAME: &'static IdentStr = ident_str!("Withdraw");
}

/// Struct that represents a Deposit event.
#[derive(Debug, Serialize, Deserialize)]
pub struct DepositFAEvent {
    pub store: AccountAddress,
    pub amount: u64,
}

impl MoveEventV2Type for DepositFAEvent {}

impl MoveStructType for DepositFAEvent {
    const MODULE_NAME: &'static IdentStr = ident_str!("fungible_asset");
    const STRUCT_NAME: &'static IdentStr = ident_str!("Deposit");
}
```
