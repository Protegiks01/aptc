# Audit Report

## Title
Missing Duplicate Key Validation in Gas Schedule Governance Updates Enables Gas Parameter Override Attack

## Summary
The gas schedule governance update mechanism lacks validation for duplicate keys in the `GasScheduleV2.entries` vector, allowing an attacker to submit a governance proposal containing duplicate gas parameter keys. When processed via `into_btree_map()`, the last duplicate value overwrites earlier ones, enabling critical gas parameters to be maliciously overridden to values like 0 (enabling free transactions) or MAX (making the network unusable).

## Finding Description

While investigating whether `to_on_chain_gas_schedule()` implementations can generate malicious keys, I discovered that the implementations themselves are secure (using compile-time string literals via macros), but the system lacks validation when accepting gas schedules from governance proposals.

**Attack Flow:**

1. **Normal Gas Schedule Generation**: The `to_on_chain_gas_schedule()` method generates gas schedule entries with keys like `"txn.min_transaction_gas_units"`. [1](#0-0) 

2. **Governance Proposal Submission**: An attacker crafts a malicious `GasScheduleV2` with legitimate entries followed by duplicate entries with malicious values:
   ```
   entries = [
     ("txn.min_transaction_gas_units", 2_760_000),  // legitimate
     ("instr.nop", 36),                              // legitimate
     ... all other legitimate entries ...
     ("txn.min_transaction_gas_units", 0),          // malicious duplicate
   ]
   ```

3. **No Validation in Move**: The gas schedule is accepted without duplicate key validation. [2](#0-1) 

4. **Deterministic Override on Deserialization**: When validators load the gas schedule, `into_btree_map()` converts the vector to a BTreeMap, where the last duplicate value overwrites earlier ones. [3](#0-2) 

5. **Exploitation**: Critical gas parameters are now set to malicious values:
   - Setting `min_transaction_gas_units` to 0 enables free transactions (DoS via resource exhaustion)
   - Setting gas parameters to MAX values makes all transactions unaffordable (network liveness failure)

**Invariant Violations:**
- **Deterministic Execution**: All validators process duplicates identically (last wins), but the gas schedule integrity is compromised
- **Resource Limits**: Gas metering can be bypassed entirely if parameters are set to 0
- **Governance Integrity**: The governance system allows malicious configurations that break fundamental blockchain properties

The code explicitly acknowledges this issue via TODO comments but provides no validation. [4](#0-3) 

## Impact Explanation

**Critical Severity** - This vulnerability enables:

1. **Network Liveness Failure** (Critical): By setting critical gas parameters to extremely high values, all transactions become prohibitively expensive, completely halting the network until a new gas schedule is adopted via emergency governance.

2. **Resource Exhaustion via Free Transactions** (Critical): By setting gas parameters to 0 through duplicate key override, attackers can execute unlimited transactions without cost, exhausting validator resources and potentially corrupting state through storage bombing attacks.

3. **Gas Metering Bypass** (Critical): The fundamental security mechanism that limits computational and storage resources can be completely disabled, breaking the Move VM safety guarantee of respecting gas limits (Invariant #3).

## Likelihood Explanation

**Medium-High Likelihood:**

**Attacker Requirements:**
- Governance proposal submission (requires stake and proposal fee)
- Sufficient voting power or social engineering to pass the malicious proposal
- Understanding of gas schedule internals

**Realistic Scenario:**
1. Attacker with moderate stake submits a "gas optimization" proposal
2. The proposal contains hundreds of legitimate-looking entries with a few malicious duplicates buried deep in the vector
3. Governance participants may not notice duplicates in a 200+ entry gas schedule
4. Proposal passes and applies at next epoch
5. Network immediately experiences free transactions or becomes unusable

**Difficulty:** The technical implementation is straightforward (just add duplicate entries), but requires navigating the governance process. The lack of validation makes exploitation deterministic once a malicious schedule is accepted.

## Recommendation

**Immediate Fix**: Add duplicate key validation in the Move code before accepting gas schedules:

```move
public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    // NEW: Validate no duplicate keys
    validate_no_duplicate_keys(&new_gas_schedule.entries);
    
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    config_buffer::upsert(new_gas_schedule);
}

fun validate_no_duplicate_keys(entries: &vector<GasEntry>) {
    let seen = simple_map::new();
    let i = 0;
    while (i < vector::length(entries)) {
        let entry = vector::borrow(entries, i);
        assert!(
            !simple_map::contains_key(&seen, &entry.key),
            error::invalid_argument(EDUPLICATE_GAS_SCHEDULE_KEY)
        );
        simple_map::add(&mut seen, entry.key, true);
        i = i + 1;
    };
}
```

Apply the same validation to `set_for_next_epoch_check_hash()` and `set_gas_schedule()`.

## Proof of Concept

```move
#[test(framework = @0x1)]
#[expected_failure(abort_code=EDUPLICATE_KEY)]
fun test_duplicate_gas_schedule_keys_should_fail(framework: signer) {
    use std::vector;
    use aptos_framework::gas_schedule::{GasEntry, GasScheduleV2};
    
    // Create gas schedule with duplicate keys
    let entries = vector::empty();
    vector::push_back(&mut entries, GasEntry { 
        key: string::utf8(b"txn.min_transaction_gas_units"), 
        val: 2_760_000 
    });
    vector::push_back(&mut entries, GasEntry { 
        key: string::utf8(b"instr.nop"), 
        val: 36 
    });
    // Malicious duplicate that overrides min_transaction_gas_units to 0
    vector::push_back(&mut entries, GasEntry { 
        key: string::utf8(b"txn.min_transaction_gas_units"), 
        val: 0  // FREE TRANSACTIONS!
    });
    
    let malicious_schedule = GasScheduleV2 {
        feature_version: 100,
        entries,
    };
    
    let blob = bcs::to_bytes(&malicious_schedule);
    gas_schedule::set_for_next_epoch(&framework, blob); // Should abort but currently succeeds
}
```

**Rust Reproduction:**
```rust
#[test]
fn test_duplicate_keys_override() {
    let entries = vec![
        ("txn.min_transaction_gas_units".to_string(), 2_760_000),
        ("instr.nop".to_string(), 36),
        ("txn.min_transaction_gas_units".to_string(), 0), // duplicate
    ];
    let map: BTreeMap<String, u64> = entries.into_iter().collect();
    assert_eq!(map.get("txn.min_transaction_gas_units"), Some(&0)); // Last value wins!
}
```

## Notes

The vulnerability is not in the `to_on_chain_gas_schedule()` implementations themselves (which use safe compile-time string literals), but in the lack of validation when gas schedules are submitted via governance. The TODO comment acknowledges awareness but the issue remains unmitigated in production code. [5](#0-4)

### Citations

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/macros.rs (L48-61)
```rust
        impl $crate::traits::ToOnChainGasSchedule for $params_name {
            #[allow(unused)]
            fn to_on_chain_gas_schedule(&self, feature_version: u64) -> Vec<(String, u64)> {
                let mut output = vec![];

                $(
                    if let Some(key) = $crate::gas_schedule::macros::define_gas_parameters_extract_key_at_version!($key_bindings, feature_version) {
                        output.push((format!("{}.{}", $prefix, key), self.$name.into()))
                    }
                )*

                output
            }
        }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L47-47)
```text
        // TODO(Gas): check if gas schedule is consistent
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** types/src/on_chain_config/gas_schedule.rs (L50-53)
```rust
    pub fn into_btree_map(self) -> BTreeMap<String, u64> {
        // TODO: what if the gas schedule contains duplicated entries?
        self.entries.into_iter().collect()
    }
```
