# Audit Report

## Title
Module Verification Failure After Function Values Feature Activation Due to Reduced max_type_nodes Limit

## Summary
When the `ENABLE_FUNCTION_VALUES` feature flag is enabled via on-chain governance, the Move bytecode verifier's `max_type_nodes` limit decreases from 256 to 128. This causes previously verified and deployed modules with type complexity between 129-256 nodes to fail re-verification when loaded from storage, breaking deterministic execution and potentially causing consensus splits or denial of service.

## Finding Description

The Aptos blockchain uses the Move bytecode verifier to ensure module safety before and during execution. The verification configuration is controlled by feature flags that can be changed through on-chain governance. [1](#0-0) 

When `enable_function_values` is enabled, `max_type_nodes` is reduced from 256 to 128. This limit is enforced during bytecode verification through a weighted type size calculation where struct instantiations and type parameters each contribute a weight of 4, while primitive types contribute 1. [2](#0-1) 

The critical issue is that modules are re-verified every time they are loaded from storage (not just at publish time): [3](#0-2) [4](#0-3) 

While there is a global verification cache to avoid repeated verification, this cache behavior creates two problematic scenarios:

**Scenario A (gas_feature_version >= 38)**: The verification cache is flushed when verifier config changes: [5](#0-4) 

When the cache is flushed, all previously verified modules must pass verification again under the new stricter limits. Modules with weighted type size between 129-256 will fail with `TOO_MANY_TYPE_NODES` error, making them unloadable.

**Scenario B (gas_feature_version < 38)**: The cache is NOT flushed when config changes. Old modules remain cached and bypass the new verification limits, leading to non-deterministic behavior where some nodes may have cached versions while others attempt fresh verification.

**Attack/Failure Path:**

1. Module publisher deploys a module when `enable_function_values=false` with a struct like `struct Complex<T1, T2, ..., T40>` (weighted size: 40×4 = 160 nodes)
2. Module is verified successfully (160 < 256) and published to blockchain
3. On-chain governance proposal enables `ENABLE_FUNCTION_VALUES` feature flag
4. Verifier config changes: `max_type_nodes` → 128
5. Transaction attempts to use the published module
6. Module loading triggers re-verification with new config
7. Verification fails: weighted type size 160 > 128
8. Transaction fails with `TOO_MANY_TYPE_NODES` error
9. Any dependent modules or system functions become unusable

**Broken Invariants:**
- **Deterministic Execution**: Nodes with different cache states may execute differently
- **Module Availability**: Published modules can become permanently unusable after governance changes
- **State Consistency**: Transactions may succeed or fail based on cache state rather than blockchain state

## Impact Explanation

This is a **HIGH severity** vulnerability per Aptos bug bounty criteria:

1. **Validator Node Degradation**: If critical framework modules (e.g., governance, staking) have type complexity between 129-256 and become unloadable after the feature flag change, validator nodes cannot process transactions that depend on these modules, causing operational disruption.

2. **Non-Deterministic Consensus Risk**: Different validators may have different cache states during the transition period. Some may successfully execute transactions using cached modules while others fail verification, potentially causing consensus disagreements on transaction outcomes.

3. **Denial of Service**: Applications and protocols built on top of Aptos that deployed modules before the feature flag change could suddenly become unusable, affecting all users of those applications without any action on their part.

4. **Protocol-Level Disruption**: Unlike a typical smart contract bug, this affects the core Move VM verification layer, impacting all modules across the entire blockchain based on on-chain configuration changes.

While this doesn't directly cause loss of funds or consensus safety breaks (validators would likely fail-stop rather than diverge), it represents a **significant protocol violation** that can cause widespread availability issues and requires careful coordination to resolve.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

The vulnerability is likely to manifest because:

1. **Feature Flag Will Be Enabled**: The `ENABLE_FUNCTION_VALUES` feature (flag 89) is a planned feature for enabling function values (closures) in Move, and will be activated via governance proposal on mainnet as part of normal protocol upgrades. [6](#0-5) 

2. **Existing Modules May Exceed Limit**: The Aptos ecosystem already has numerous deployed modules. Any module with complex generic structs (30+ type parameters, nested struct instantiations) would have weighted type size exceeding 128.

3. **No Pre-Flight Validation**: There is no mechanism to scan existing on-chain modules before enabling the feature flag to identify which modules would become invalid under the new limits.

4. **Cache Behavior Exacerbates Issue**: For gas_feature_version >= 38, the intentional cache flushing ensures all modules are re-verified, guaranteeing the issue manifests. For earlier versions, the non-deterministic cache behavior creates consensus risk.

The only reason this isn't CRITICAL is that it requires a governance action to trigger, and the Aptos team could potentially audit modules before enabling the flag. However, given the size of the mainnet module set, such an audit is practically difficult.

## Recommendation

**Immediate Fix:**

1. **Add Compatibility Check**: Before enabling `ENABLE_FUNCTION_VALUES` via governance, scan all deployed modules to ensure none exceed the new `max_type_nodes=128` limit. Reject the governance proposal if incompatible modules exist.

2. **Grandfather Existing Modules**: Modify the verification logic to exempt modules published before a certain version/timestamp from the stricter type node limits:

```rust
pub fn aptos_prod_verifier_config(
    gas_feature_version: u64, 
    features: &Features,
    module_publish_version: Option<u64>, // Add module version context
) -> VerifierConfig {
    let enable_function_values = features.is_enabled(FeatureFlag::ENABLE_FUNCTION_VALUES);
    
    // Apply stricter limits only to newly published modules
    let use_strict_limits = enable_function_values && 
        module_publish_version.map_or(false, |v| v >= VERSION_WITH_FUNCTION_VALUES);
    
    VerifierConfig {
        max_type_nodes: if use_strict_limits {
            Some(128)
        } else {
            Some(256)
        },
        // ... rest of config
    }
}
```

3. **Cache Invalidation with Verification**: Instead of simply flushing the cache when config changes, implement a graceful transition that re-verifies cached modules against BOTH old and new configs, allowing modules that pass either config to continue working.

4. **Module Migration Period**: Provide a migration window where module publishers can update their modules to comply with new limits before enforcement begins.

**Long-term Fix:**

Implement a versioned verification system where each module is verified and cached with its specific verification config version, eliminating the need to re-verify modules when global config changes.

## Proof of Concept

```move
// Module that will fail after ENABLE_FUNCTION_VALUES is activated
module 0x42::vulnerable_module {
    // Struct with 40 type parameters (weighted size = 40 * 4 = 160 nodes)
    // Valid when max_type_nodes=256, invalid when max_type_nodes=128
    struct ComplexType<
        T1, T2, T3, T4, T5, T6, T7, T8, T9, T10,
        T11, T12, T13, T14, T15, T16, T17, T18, T19, T20,
        T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
        T31, T32, T33, T34, T35, T36, T37, T38, T39, T40
    > {
        value: u64
    }
    
    // This function signature will fail verification after flag change
    public fun create_complex<
        T1, T2, T3, T4, T5, T6, T7, T8, T9, T10,
        T11, T12, T13, T14, T15, T16, T17, T18, T19, T20,
        T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
        T31, T32, T33, T34, T35, T36, T37, T38, T39, T40
    >(): ComplexType<
        T1, T2, T3, T4, T5, T6, T7, T8, T9, T10,
        T11, T12, T13, T14, T15, T16, T17, T18, T19, T20,
        T21, T22, T23, T24, T25, T26, T27, T28, T29, T30,
        T31, T32, T33, T34, T35, T36, T37, T38, T39, T40
    > {
        ComplexType { value: 42 }
    }
}
```

**Reproduction Steps:**

1. Deploy the above module on testnet with `enable_function_values=false`
2. Verify module loads successfully and function executes
3. Submit governance proposal to enable `ENABLE_FUNCTION_VALUES` feature flag
4. Wait for epoch change and feature activation
5. Attempt to call `create_complex()` function
6. Observe `TOO_MANY_TYPE_NODES` verification failure when module is loaded

**Expected Result**: Module that was previously valid becomes unloadable, causing all transactions depending on it to fail.

## Notes

This vulnerability represents a **breaking change** in the protocol's backward compatibility guarantees. While the Aptos team likely intends the stricter limits for security reasons (to prevent deeply nested types that could cause runtime issues), the lack of a migration path creates an unacceptable risk of breaking existing applications and system modules. The issue is particularly critical because it affects the core verification layer rather than just application logic, making it a protocol-level concern that requires careful coordination across the entire network.

### Citations

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L162-166)
```rust
        max_type_nodes: if enable_function_values {
            Some(128)
        } else {
            Some(256)
        },
```

**File:** third_party/move/move-bytecode-verifier/src/limits.rs (L127-195)
```rust
    fn verify_type_node(
        &self,
        config: &VerifierConfig,
        ty: &SignatureToken,
    ) -> PartialVMResult<()> {
        if config.max_type_nodes.is_none()
            && config.max_function_parameters.is_none()
            && config.max_function_return_values.is_none()
            && config.max_type_depth.is_none()
        {
            // If no type-related limits are set, we do not need to verify the type nodes.
            return Ok(());
        }
        // Structs and Parameters can expand to an unknown number of nodes, therefore
        // we give them a higher size weight here.
        const STRUCT_SIZE_WEIGHT: usize = 4;
        const PARAM_SIZE_WEIGHT: usize = 4;
        let mut type_size = 0;
        for (token, depth) in ty.preorder_traversal_with_depth() {
            if let Some(limit) = config.max_type_depth {
                if depth > limit {
                    return Err(PartialVMError::new(StatusCode::TOO_MANY_TYPE_NODES));
                }
            }
            match token {
                SignatureToken::Struct(..) | SignatureToken::StructInstantiation(..) => {
                    type_size += STRUCT_SIZE_WEIGHT
                },
                SignatureToken::TypeParameter(..) => type_size += PARAM_SIZE_WEIGHT,
                SignatureToken::Function(params, ret, _) => {
                    if let Some(limit) = config.max_function_parameters {
                        if params.len() > limit {
                            return Err(PartialVMError::new(StatusCode::TOO_MANY_PARAMETERS));
                        }
                    }
                    if let Some(limit) = config.max_function_return_values {
                        if ret.len() > limit {
                            return Err(PartialVMError::new(StatusCode::TOO_MANY_PARAMETERS));
                        }
                    }
                    type_size += 1;
                },
                SignatureToken::Bool
                | SignatureToken::U8
                | SignatureToken::U16
                | SignatureToken::U32
                | SignatureToken::U64
                | SignatureToken::U128
                | SignatureToken::U256
                | SignatureToken::I8
                | SignatureToken::I16
                | SignatureToken::I32
                | SignatureToken::I64
                | SignatureToken::I128
                | SignatureToken::I256
                | SignatureToken::Address
                | SignatureToken::Signer
                | SignatureToken::Vector(_)
                | SignatureToken::Reference(_)
                | SignatureToken::MutableReference(_) => type_size += 1,
            }
        }
        if let Some(limit) = config.max_type_nodes {
            if type_size > limit {
                return Err(PartialVMError::new(StatusCode::TOO_MANY_TYPE_NODES));
            }
        }
        Ok(())
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L178-201)
```rust
    pub fn build_locally_verified_module(
        &self,
        compiled_module: Arc<CompiledModule>,
        module_size: usize,
        module_hash: &[u8; 32],
    ) -> VMResult<LocallyVerifiedModule> {
        if !VERIFIED_MODULES_CACHE.contains(module_hash) {
            let _timer =
                VM_TIMER.timer_with_label("move_bytecode_verifier::verify_module_with_config");

            // For regular execution, we cache already verified modules. Note that this even caches
            // verification for the published modules. This should be ok because as long as the
            // hash is the same, the deployed bytecode and any dependencies are the same, and so
            // the cached verification result can be used.
            move_bytecode_verifier::verify_module_with_config(
                &self.vm_config().verifier_config,
                compiled_module.as_ref(),
            )?;
            check_natives(compiled_module.as_ref())?;
            VERIFIED_MODULES_CACHE.put(*module_hash);
        }

        Ok(LocallyVerifiedModule(compiled_module, module_size))
    }
```

**File:** third_party/move/move-vm/runtime/src/storage/module_storage.rs (L315-321)
```rust
        let locally_verified_code = runtime_environment.build_locally_verified_module(
            module.code().deserialized().clone(),
            module.extension().size_in_bytes(),
            module.extension().hash(),
        )?;
        let verified_code =
            runtime_environment.build_verified_module_skip_linking_checks(locally_verified_code)?;
```

**File:** aptos-move/block-executor/src/code_cache_global_manager.rs (L117-126)
```rust
            if storage_environment.gas_feature_version() >= RELEASE_V1_34 {
                let flush_verifier_cache = self.environment.as_ref().is_none_or(|e| {
                    e.verifier_config_bytes() != storage_environment.verifier_config_bytes()
                });
                if flush_verifier_cache {
                    // Additionally, if the verifier config changes, we flush static verifier cache
                    // as well.
                    RuntimeEnvironment::flush_verified_module_cache();
                }
            }
```

**File:** types/src/on_chain_config/aptos_features.rs (L138-139)
```rust
    /// Whether function values are enabled.
    ENABLE_FUNCTION_VALUES = 89,
```
