# Audit Report

## Title
Delegation Pool Owner Can Steal Voting Power from Delegators via Legacy Governance Path

## Summary
A malicious delegation pool owner can create governance proposals using all delegators' voting power without their consent by exploiting delegation pools that have not yet enabled partial governance voting. The owner bypasses the intended per-delegator voting controls by directly calling the legacy `aptos_governance::create_proposal_v2()` function instead of the protected `delegation_pool::create_proposal()` function.

## Finding Description

The Aptos governance system contains two distinct paths for delegation pools to create proposals:

1. **Modern Path (Protected)**: `delegation_pool::create_proposal()` requires partial governance voting to be enabled and only uses voting power explicitly delegated to the caller [1](#0-0) 

2. **Legacy Path (Vulnerable)**: `aptos_governance::create_proposal_v2()` uses the entire stake pool's voting power if the caller is the designated delegated voter [2](#0-1) 

The vulnerability exists because:

**Step 1**: When delegation pools are initialized, the owner is initially set as both operator and voter [3](#0-2) 

**Step 2**: Partial governance voting is enabled during initialization for new pools [4](#0-3) , which changes the delegated voter to the pool address itself [5](#0-4) 

**Step 3**: However, for pools created before this feature was added, or if `enable_partial_governance_voting()` was never called, the pool owner remains the delegated voter.

**Step 4**: The condition for partial governance voting being enabled checks both that `GovernanceRecords` exists AND that the delegated voter equals the pool address [6](#0-5) 

**Step 5**: For vulnerable pools, a malicious owner can call `aptos_governance::create_proposal_v2()` directly. This function verifies that the proposer is the delegated voter [7](#0-6) , which passes for the owner on unprotected pools.

**Step 6**: The voting power calculation uses `get_voting_power(stake_pool)` which returns the entire pool's stake (active + pending_active + pending_inactive) [8](#0-7) 

**Step 7**: This allows the proposal to be created using ALL delegators' stake as voting power, without their explicit consent via the delegation mechanism.

By default, each delegator's voting power is delegated to themselves [9](#0-8) , and they must explicitly call `delegate_voting_power()` to delegate to another address. The legacy governance path bypasses this entire system.

## Impact Explanation

This vulnerability has **High Severity** impact according to Aptos bug bounty criteria, constituting a significant protocol violation affecting governance integrity.

**Governance Integrity Violation**: This breaks the critical invariant that "Voting power must be correctly calculated from stake." While the stake amount is correct, the *authorization* to use that voting power is violated - delegators never consented to the pool owner using their stake for governance proposals.

**Unauthorized Control**: A malicious pool owner can:
- Create proposals that delegators oppose without their knowledge
- Meet minimum proposer stake requirements using others' stake
- Influence protocol governance decisions without delegator consent
- Bypass the intended per-delegator voting control mechanism

**Affected Users**: All delegators in delegation pools without partial governance voting enabled lose control over their governance voting power.

## Likelihood Explanation

**Likelihood: Medium**

The attack is straightforward to execute but requires specific preconditions:

**Requirements**:
1. A delegation pool exists where `partial_governance_voting_enabled()` returns false
2. The pool has sufficient total stake to meet proposer requirements
3. The pool owner has not yet migrated to the new system
4. No other party has called the permissionless `enable_partial_governance_voting()` function

**Mitigating Factors**:
- New pools automatically enable partial governance voting
- The CLI tool auto-enables the feature before governance operations [10](#0-9) 
- `enable_partial_governance_voting()` is permissionless, so any delegator can protect themselves

**Exploitability**: The attack requires only calling a public entry function with no complex state manipulation, making it trivial to execute once the conditions are met.

## Recommendation

**Immediate Fix**: Enforce that ALL delegation pools must use partial governance voting for proposal creation. Modify `aptos_governance::create_proposal_v2_impl()` to reject delegation pool addresses that haven't enabled partial governance voting:

```move
public fun create_proposal_v2_impl(
    proposer: &signer,
    stake_pool: address,
    execution_hash: vector<u8>,
    metadata_location: vector<u8>,
    metadata_hash: vector<u8>,
    is_multi_step_proposal: bool,
): u64 acquires GovernanceConfig, GovernanceEvents {
    check_governance_permission(proposer);
    let proposer_address = signer::address_of(proposer);
    
    // NEW CHECK: If this is a delegation pool, require partial governance voting
    if (delegation_pool::delegation_pool_exists(stake_pool)) {
        assert!(
            delegation_pool::partial_governance_voting_enabled(stake_pool),
            error::invalid_state(EDELEGATION_POOL_MUST_USE_PARTIAL_VOTING)
        );
    };
    
    assert!(
        stake::get_delegated_voter(stake_pool) == proposer_address,
        error::invalid_argument(ENOT_DELEGATED_VOTER)
    );
    // ... rest of function
}
```

**Long-term Fix**: Implement automatic migration that enables partial governance voting for all existing delegation pools via a governance proposal or mandatory upgrade.

## Proof of Concept

```move
#[test_only]
module aptos_framework::delegation_pool_voting_theft_test {
    use aptos_framework::delegation_pool;
    use aptos_framework::aptos_governance;
    use aptos_framework::stake;
    use std::signer;
    
    #[test(aptos_framework = @aptos_framework, pool_owner = @0x123, delegator1 = @0x456)]
    public entry fun test_voting_power_theft(
        aptos_framework: &signer,
        pool_owner: &signer, 
        delegator1: &signer
    ) {
        // Setup: Create an old-style delegation pool without partial governance voting
        // This simulates a pool created before the feature was auto-enabled
        
        // 1. Create delegation pool (simulate old version without auto-enable)
        let pool_address = create_old_delegation_pool(pool_owner);
        
        // 2. Delegator adds stake (has no control over voting)
        let delegator_stake = 1000000; // 1M APT
        delegation_pool::add_stake(delegator1, pool_address, delegator_stake);
        
        // 3. Verify pool owner is still the delegated voter (vulnerable state)
        assert!(
            stake::get_delegated_voter(pool_address) == signer::address_of(pool_owner),
            0
        );
        
        // 4. Verify partial governance voting is NOT enabled
        assert!(
            !delegation_pool::partial_governance_voting_enabled(pool_address),
            1
        );
        
        // 5. ATTACK: Pool owner creates proposal using ALL stake (including delegator's)
        let execution_hash = x"1234";
        let metadata_url = b"https://malicious.proposal";
        let metadata_hash = x"5678";
        
        // This succeeds because owner is delegated voter and has sufficient voting power
        // from the delegator's stake
        aptos_governance::create_proposal_v2(
            pool_owner,
            pool_address,
            execution_hash,
            metadata_url,
            metadata_hash,
            false
        );
        
        // Proposal created successfully using delegator's voting power without consent!
        // Delegator has no record of having delegated to the owner in GovernanceRecords
    }
}
```

**Notes**
This vulnerability represents a governance integrity violation where the architectural assumption that delegators control their voting power is violated for unmigrated delegation pools. While mitigation mechanisms exist (CLI auto-enablement, permissionless migration), the vulnerability window remains open until all pools are migrated. The fix should enforce that delegation pools cannot use the legacy governance path, ensuring all governance operations go through the consent-based partial voting system.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/delegation_pool.move (L538-540)
```text
    public fun partial_governance_voting_enabled(pool_address: address): bool {
        exists<GovernanceRecords>(pool_address) && stake::get_delegated_voter(pool_address) == pool_address
    }
```

**File:** aptos-move/framework/aptos-framework/sources/delegation_pool.move (L892-892)
```text
        stake::initialize_stake_owner(&stake_pool_signer, 0, owner_address, owner_address);
```

**File:** aptos-move/framework/aptos-framework/sources/delegation_pool.move (L919-920)
```text
        // All delegation pool enable partial governance voting by default once the feature flag is enabled.
        enable_partial_governance_voting(pool_address);
```

**File:** aptos-move/framework/aptos-framework/sources/delegation_pool.move (L943-946)
```text
        let stake_pool_signer = retrieve_stake_pool_owner(delegation_pool);
        // delegated_voter is managed by the stake pool itself, which signer capability is managed by DelegationPool.
        // So voting power of this stake pool can only be used through this module.
        stake::set_delegated_voter(&stake_pool_signer, signer::address_of(&stake_pool_signer));
```

**File:** aptos-move/framework/aptos-framework/sources/delegation_pool.move (L1024-1045)
```text
    public entry fun create_proposal(
        voter: &signer,
        pool_address: address,
        execution_hash: vector<u8>,
        metadata_location: vector<u8>,
        metadata_hash: vector<u8>,
        is_multi_step_proposal: bool,
    ) acquires DelegationPool, GovernanceRecords, BeneficiaryForOperator, NextCommissionPercentage {
        check_stake_management_permission(voter);
        assert_partial_governance_voting_enabled(pool_address);

        // synchronize delegation and stake pools before any user operation
        synchronize_delegation_pool(pool_address);

        let voter_addr = signer::address_of(voter);
        let pool = borrow_global<DelegationPool>(pool_address);
        let governance_records = borrow_global_mut<GovernanceRecords>(pool_address);
        let total_voting_power = calculate_and_update_delegated_votes(pool, governance_records, voter_addr);
        assert!(
            total_voting_power >= aptos_governance::get_required_proposer_stake(),
            error::invalid_argument(EINSUFFICIENT_PROPOSER_STAKE));
        let pool_signer = retrieve_stake_pool_owner(borrow_global<DelegationPool>(pool_address));
```

**File:** aptos-move/framework/aptos-framework/sources/delegation_pool.move (L1226-1233)
```text
        // By default, a delegator's delegated voter is itself.
        // TODO: recycle storage when VoteDelegation equals to default value.
        if (!smart_table::contains(vote_delegation_table, delegator)) {
            return smart_table::borrow_mut_with_default(vote_delegation_table, delegator, VoteDelegation {
                voter: delegator,
                last_locked_until_secs: locked_until_secs,
                pending_voter: delegator,
            })
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L405-426)
```text
    public fun create_proposal_v2_impl(
        proposer: &signer,
        stake_pool: address,
        execution_hash: vector<u8>,
        metadata_location: vector<u8>,
        metadata_hash: vector<u8>,
        is_multi_step_proposal: bool,
    ): u64 acquires GovernanceConfig, GovernanceEvents {
        check_governance_permission(proposer);
        let proposer_address = signer::address_of(proposer);
        assert!(
            stake::get_delegated_voter(stake_pool) == proposer_address,
            error::invalid_argument(ENOT_DELEGATED_VOTER)
        );

        // The proposer's stake needs to be at least the required bond amount.
        let governance_config = borrow_global<GovernanceConfig>(@aptos_framework);
        let stake_balance = get_voting_power(stake_pool);
        assert!(
            stake_balance >= governance_config.required_proposer_stake,
            error::invalid_argument(EINSUFFICIENT_PROPOSER_STAKE),
        );
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L731-742)
```text
    public fun get_voting_power(pool_address: address): u64 {
        let allow_validator_set_change = staking_config::get_allow_validator_set_change(&staking_config::get());
        if (allow_validator_set_change) {
            let (active, _, pending_active, pending_inactive) = stake::get_stake(pool_address);
            // We calculate the voting power as total non-inactive stakes of the pool. Even if the validator is not in the
            // active validator set, as long as they have a lockup (separately checked in create_proposal and voting), their
            // stake would still count in their voting power for governance proposals.
            active + pending_active + pending_inactive
        } else {
            stake::get_current_epoch_voting_power(pool_address)
        }
    }
```

**File:** crates/aptos/src/governance/delegation_pool.rs (L192-204)
```rust
    if is_partial_governance_voting_enabled_for_delegation_pool(client, pool_address).await? {
        Ok(None)
    } else {
        println!("Partial governance voting for delegation pool {} hasn't been enabled yet. Enabling it now...",
                 pool_address);
        let txn_summary = txn_options
            .submit_transaction(
                aptos_stdlib::delegation_pool_enable_partial_governance_voting(pool_address),
            )
            .await
            .map(TransactionSummary::from)?;
        Ok(Some(txn_summary))
    }
```
