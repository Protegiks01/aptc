# Audit Report

## Title
Unverified Epoch Ending Restoration Allows Attacker-Controlled Validator Set Injection and Critical Epoch Exclusion

## Summary
The epoch ending restoration process in `restore.rs` fails to verify the first epoch ending ledger info when no trusted waypoints are provided. This allows an attacker controlling backup storage to inject fake epoch endings with manipulated versions set to exactly `target_version`, causing legitimate subsequent epochs to be excluded from restoration and injecting attacker-controlled validator sets.

## Finding Description

The vulnerability exists in the epoch ending restore logic where version comparison occurs before cryptographic verification. [1](#0-0) 

The verification logic has a critical gap: [2](#0-1) 

When the first epoch (genesis) is being restored, `previous_li` is `None`: [3](#0-2) 

If no trusted waypoints are provided (which is optional per the CLI design [4](#0-3) ), the first epoch ending ledger info undergoes NO signature verification - neither trusted waypoint validation nor cryptographic signature checks.

The only verification performed is that the waypoint computed from the ledger info matches the waypoint in the manifest [5](#0-4)  - but both are attacker-controlled when the backup storage is compromised.

**Attack Scenario:**
1. Attacker controls backup storage (compromised S3 bucket, malicious backup service, or MITM)
2. User runs restore without `--trust-waypoint` arguments (a supported use case as evidenced by test code [6](#0-5) )
3. Attacker crafts malicious backup where epoch 0 has `version = target_version` (instead of real version ~100)
4. During restoration, this fake epoch 0 passes all checks without signature verification
5. Loop terminates after processing epoch 0 since any subsequent epochs would have `version > target_version`
6. Real epochs 1, 2, 3, etc. are completely excluded from restoration
7. The fake epoch 0 contains attacker's `next_epoch_state` (validator set for epoch 1)

The restored epoch history is then used to verify subsequent transaction and state backups: [7](#0-6) 

## Impact Explanation

**High Severity** per Aptos bug bounty criteria:

1. **Significant Protocol Violation**: The node operates with a completely fabricated epoch history, violating the fundamental assumption that epoch transitions are cryptographically verified through BLS signature aggregation.

2. **Validator Set Manipulation**: Attacker injects fake validator sets that will be used to "verify" subsequent blockchain data, breaking the **Consensus Safety** invariant that requires proper validator authentication.

3. **State Inconsistency**: The restored node has state fundamentally inconsistent with the actual blockchain, requiring manual intervention to detect and remediate.

4. **Critical Data Exclusion**: Legitimate epochs are permanently excluded from the restoration, potentially causing the node to accept or reject blocks based on fake validator sets rather than real consensus.

While this doesn't directly compromise the network (as other nodes have correct state), it can cause:
- Restored validator nodes to malfunction or fail to participate correctly in consensus
- Full nodes to serve incorrect data to clients
- Archive nodes to have corrupted historical records

## Likelihood Explanation

**Likelihood: Medium to High**

**Attacker Requirements:**
- Control over backup storage (compromised cloud storage, malicious backup provider, MITM on backup retrieval)
- No validator keys or on-chain privileges required

**User Requirements for Exploitation:**
- User must run restore without providing `--trust-waypoint` arguments
- This is explicitly supported by the codebase and demonstrated in tests
- Documentation does not warn that this is unsafe with untrusted backup sources

The epoch history restoration is invoked whenever users restore from backup: [8](#0-7) 

Given that:
1. Trusted waypoints are optional (not enforced)
2. No warnings exist about the security implications
3. Test code demonstrates usage without trusted waypoints
4. Users may not understand the cryptographic trust model

The likelihood is **MEDIUM** for users operating without security awareness, and **HIGH** in scenarios where backup infrastructure is partially compromised.

## Recommendation

**Immediate Fix**: Enforce trusted waypoint requirement for genesis (epoch 0):

```rust
// In preheat_impl, after line 111:
if li.ledger_info().epoch() == manifest.first_epoch && manifest.first_epoch == 0 {
    // Genesis epoch MUST have a trusted waypoint
    ensure!(
        self.trusted_waypoints.get(&li.ledger_info().version()).is_some(),
        "Genesis epoch (epoch 0) restoration requires a trusted waypoint. \
         Provide --trust-waypoint with the genesis waypoint to verify the backup source."
    );
}
```

**Long-term Improvements:**

1. **Enhanced CLI Documentation**: Update help text to explicitly warn about security implications:
```rust
#[clap(
    long,
    help = "REQUIRED for secure restoration. When provided, an epoch ending LedgerInfo at \
    the waypoint version will be checked against the hash in the waypoint. \
    WARNING: Restoring without trusted waypoints allows backup storage to inject fake validator sets. \
    At minimum, provide the genesis waypoint to verify backup authenticity. \
    ..."
)]
```

2. **Additional Verification**: When `previous_epoch_ending_ledger_info` is provided in `run_impl`, always verify the first epoch against it, even if a trusted waypoint exists [9](#0-8) 

3. **Audit Logging**: Log warnings when restoration proceeds without trusted waypoints for epochs that lack signature verification.

## Proof of Concept

```rust
// Integration test demonstrating the vulnerability
#[tokio::test]
async fn test_malicious_epoch_restore_without_waypoints() {
    use aptos_backup_cli::backup_types::epoch_ending::restore::*;
    use aptos_types::{ledger_info::*, block_info::*, epoch_state::EpochState};
    use std::sync::Arc;
    
    // Setup: Create malicious backup with fake epoch 0
    let malicious_backup_storage = /* create temp storage */;
    let target_version = 1000u64;
    
    // Craft fake epoch 0 ledger info with version = target_version
    let fake_epoch_0_li = LedgerInfo::new(
        BlockInfo::new(
            0,  // epoch
            0,  // round
            HashValue::zero(),
            HashValue::zero(),
            target_version,  // manipulated version
            0,  // timestamp
            Some(EpochState::empty()),  // attacker's validator set
        ),
        HashValue::zero(),
    );
    
    let fake_li_with_sigs = LedgerInfoWithSignatures::new(
        fake_epoch_0_li,
        AggregateSignature::empty(),  // No valid signatures
    );
    
    // Create manifest with matching waypoint
    let manifest = EpochEndingBackup {
        first_epoch: 0,
        last_epoch: 0,
        waypoints: vec![Waypoint::new_epoch_boundary(&fake_li_with_sigs.ledger_info()).unwrap()],
        chunks: /* create chunk with fake_li_with_sigs */,
    };
    
    // Save malicious backup
    // ...
    
    // Attempt restore WITHOUT trusted waypoints
    let global_opt = GlobalRestoreOptions {
        target_version,
        trusted_waypoints: Arc::new(HashMap::new()),  // EMPTY - no verification!
        run_mode: Arc::new(RestoreRunMode::Verify),
        concurrent_downloads: 2,
        replay_concurrency_level: 1,
    };
    
    let controller = EpochEndingRestoreController::new(
        EpochEndingRestoreOpt { manifest_handle: /* ... */ },
        global_opt.clone(),
        malicious_backup_storage,
    );
    
    // This should FAIL but will SUCCEED, accepting fake epoch 0
    let result = controller.run(None).await;
    
    assert!(result.is_ok());  // Vulnerability: fake epoch accepted!
    let restored_epochs = result.unwrap();
    assert_eq!(restored_epochs.len(), 1);  // Only fake epoch 0, real epochs excluded
    assert_eq!(restored_epochs[0].version(), target_version);  // Version manipulated
}
```

## Notes

This vulnerability is particularly insidious because:

1. **Silent Failure**: No errors or warnings are generated when restoration proceeds without proper verification
2. **Test-Driven Acceptance**: The codebase includes tests that demonstrate restoration without trusted waypoints, potentially normalizing this unsafe practice
3. **Documentation Gap**: The CLI help text describes trusted waypoints as optional enhancement rather than critical security control
4. **Delayed Impact**: The vulnerability may not be immediately apparent - the node might start successfully but operate with corrupted epoch history

The root cause is a **defense-in-depth failure**: the code relies on a single optional verification mechanism (trusted waypoints) without fallback verification or enforcement, violating the principle that security-critical operations should fail closed rather than open.

### Citations

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L88-89)
```rust
        let mut previous_li: Option<&LedgerInfoWithSignatures> = None;
        let mut ledger_infos = Vec::new();
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L107-111)
```rust
            for li in lis {
                if li.ledger_info().version() > self.target_version {
                    past_target = true;
                    break;
                }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L119-128)
```rust
                let wp_manifest = waypoint_iter.next().ok_or_else(|| {
                    anyhow!("More LedgerInfo's found than waypoints in manifest.")
                })?;
                let wp_li = Waypoint::new_epoch_boundary(li.ledger_info())?;
                ensure!(
                    *wp_manifest == wp_li,
                    "Waypoints don't match. In manifest: {}, In chunk: {}",
                    wp_manifest,
                    wp_li,
                );
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L129-147)
```rust
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
                }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L218-240)
```rust
        if let Some(li) = previous_epoch_ending_ledger_info {
            ensure!(
                li.next_block_epoch() == preheat_data.manifest.first_epoch,
                "Previous epoch ending LedgerInfo is not the one expected. \
                My first epoch: {}, previous LedgerInfo next_block_epoch: {}",
                preheat_data.manifest.first_epoch,
                li.next_block_epoch(),
            );
            // Waypoint has been verified in preheat if it's trusted, otherwise try to check
            // the signatures.
            if self
                .controller
                .trusted_waypoints
                .get(&first_li.ledger_info().version())
                .is_none()
            {
                li.next_epoch_state()
                    .ok_or_else(|| {
                        anyhow!("Previous epoch ending LedgerInfo doesn't end an epoch")
                    })?
                    .verify(first_li)?;
            }
        }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L276-312)
```rust
    pub fn verify_ledger_info(&self, li_with_sigs: &LedgerInfoWithSignatures) -> Result<()> {
        let epoch = li_with_sigs.ledger_info().epoch();
        ensure!(!self.epoch_endings.is_empty(), "Empty epoch history.",);
        if epoch > self.epoch_endings.len() as u64 {
            // TODO(aldenhu): fix this from upper level
            warn!(
                epoch = epoch,
                epoch_history_until = self.epoch_endings.len(),
                "Epoch is too new and can't be verified. Previous chunks are verified and node \
                won't be able to start if this data is malicious."
            );
            return Ok(());
        }
        if epoch == 0 {
            ensure!(
                li_with_sigs.ledger_info() == &self.epoch_endings[0],
                "Genesis epoch LedgerInfo info doesn't match.",
            );
        } else if let Some(wp_trusted) = self
            .trusted_waypoints
            .get(&li_with_sigs.ledger_info().version())
        {
            let wp_li = Waypoint::new_any(li_with_sigs.ledger_info());
            ensure!(
                *wp_trusted == wp_li,
                "Waypoints don't match. In backup: {}, trusted: {}",
                wp_li,
                wp_trusted,
            );
        } else {
            self.epoch_endings[epoch as usize - 1]
                .next_epoch_state()
                .ok_or_else(|| anyhow!("Shouldn't contain non- epoch bumping LIs."))?
                .verify(li_with_sigs)?;
        };
        Ok(())
    }
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L331-346)
```rust
#[derive(Clone, Default, Parser)]
pub struct TrustedWaypointOpt {
    #[clap(
        long,
        help = "(multiple) When provided, an epoch ending LedgerInfo at the waypoint version will be \
        checked against the hash in the waypoint, but signatures on it are NOT checked. \
        Use this for two purposes: \
        1. set the genesis or the latest waypoint to confirm the backup is compatible. \
        2. set waypoints at versions where writeset transactions were used to overwrite the \
        validator set, so that the signature check is skipped. \
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
    )]
    pub trust_waypoint: Vec<Waypoint>,
}
```

**File:** testsuite/smoke-test/src/storage.rs (L136-136)
```rust
    db_restore(backup_path.path(), db_dir.as_path(), &[], None);
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L219-228)
```rust
        let epoch_history = if !self.skip_epoch_endings {
            Some(Arc::new(
                EpochHistoryRestoreController::new(
                    epoch_handles,
                    self.global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
```
