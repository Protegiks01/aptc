# Audit Report

## Title
Unencrypted Network Transmission of Execution Commands in Remote Executor Service

## Summary
The Remote Executor Service transmits transaction execution commands and payloads over unencrypted HTTP/gRPC connections, allowing passive network observers to intercept and read sensitive transaction data including account addresses, transaction payloads, signatures, and execution parameters.

## Finding Description

The Remote Executor Service uses `NetworkController` from `secure/net` to communicate between the coordinator and executor shards for distributed transaction execution. However, this communication occurs over plaintext HTTP without any encryption layer.

The gRPC client explicitly uses the `http://` protocol [1](#0-0) , and the gRPC server has no TLS configuration [2](#0-1) .

When the coordinator sends execution commands to shards, it serializes `RemoteExecutionRequest` containing `ExecuteBlockCommand` with BCS and transmits it directly through these unencrypted channels [3](#0-2) .

The `ExecuteBlockCommand` contains `SubBlocksForShard<AnalyzedTransaction>` [4](#0-3) , where each `AnalyzedTransaction` wraps a `SignatureVerifiedTransaction` [5](#0-4) , which in turn contains the actual `Transaction` with full user transaction data including payloads, senders, and authenticators.

The `NetworkMessage` protobuf structure carries this sensitive data as raw bytes without any encryption [6](#0-5) .

**Attack Path:**
1. Attacker positions themselves on the network path between coordinator and executor shards (e.g., compromised router, network tap, or ISP-level access)
2. Attacker captures gRPC traffic using standard packet sniffing tools (Wireshark, tcpdump)
3. Attacker extracts `NetworkMessage` payloads from captured packets
4. Attacker deserializes BCS-encoded data to read full transaction details including:
   - Account addresses (senders/receivers)
   - Transaction payloads (entry function calls, scripts, arguments)
   - Gas prices and limits
   - Sequence numbers
   - Public keys and signatures

This violates the confidentiality requirement for sensitive execution data and could enable front-running attacks if execution commands are observed before consensus finalization.

## Impact Explanation

This qualifies as **HIGH severity** under the "Significant protocol violations" category. While the main Aptos validator network uses Noise protocol encryption, this separate remote executor subsystem transmits sensitive transaction data in plaintext, violating fundamental security expectations for distributed systems handling financial transactions.

The information disclosure enables:
- **Transaction front-running**: Observing execution commands before they're committed to chain
- **Privacy violations**: Exposing user transaction details to network observers  
- **Strategic intelligence**: Competitors could monitor high-value transactions or protocol operations
- **Attack surface reconnaissance**: Understanding execution patterns to plan further attacks

Though this affects the remote executor service rather than core consensus, the `ProcessExecutorService` is production code designed to "run in a standalone process" [7](#0-6) , indicating real deployment scenarios across network boundaries.

## Likelihood Explanation

**Likelihood: Medium to High** depending on deployment configuration.

If remote executor shards are deployed:
- **Across data centers**: High likelihood of interception at network boundaries
- **On cloud infrastructure**: Medium likelihood via compromised networking equipment or malicious cloud provider employees
- **Within single trusted network**: Lower likelihood but still possible via insider threats or network compromise

The code allows arbitrary socket addresses with no restrictions to localhost or private networks [8](#0-7) , suggesting this could be deployed across various network topologies.

The attack requires only passive network access (no active MITM), making it lower complexity than active attacks.

## Recommendation

Implement TLS encryption for all remote executor service communications:

**For gRPC Server** - Configure TLS with mutual authentication:
```rust
// In grpc_network_service/mod.rs
use tonic::transport::ServerTlsConfig;

async fn start_async(
    self,
    server_addr: SocketAddr,
    rpc_timeout_ms: u64,
    server_shutdown_rx: oneshot::Receiver<()>,
    tls_config: ServerTlsConfig, // Add TLS config parameter
) {
    // ... existing code ...
    Server::builder()
        .tls_config(tls_config).unwrap() // Add TLS configuration
        .timeout(std::time::Duration::from_millis(rpc_timeout_ms))
        .add_service(NetworkMessageServiceServer::new(self))
        .serve_with_shutdown(server_addr, server_shutdown_rx)
        .await
        .unwrap();
}
```

**For gRPC Client** - Configure TLS connection:
```rust
// In grpc_network_service/mod.rs  
use tonic::transport::ClientTlsConfig;

async fn get_channel(
    remote_addr: String,
    tls_config: ClientTlsConfig, // Add TLS config parameter
) -> NetworkMessageServiceClient<Channel> {
    let conn = tonic::transport::Endpoint::new(format!("https://{}", remote_addr)) // Use HTTPS
        .unwrap()
        .tls_config(tls_config).unwrap() // Add TLS configuration
        .connect_lazy();
    NetworkMessageServiceClient::new(conn)
}
```

**Alternative:** Consider using the existing Noise protocol infrastructure from `network/framework/` for consistency with the main Aptos network layer.

## Proof of Concept

**Setup:**
1. Deploy remote executor service with coordinator on `127.0.0.1:52200` and shard on `127.0.0.1:52201`
2. Start packet capture: `tcpdump -i lo -w capture.pcap port 52201`
3. Execute transactions through the remote executor client
4. Analyze captured packets:

```bash
# Extract HTTP/gRPC payloads from capture
tshark -r capture.pcap -Y "http" -T fields -e http.file_data | xxd -r -p > extracted_payload.bin

# Deserialize BCS-encoded RemoteExecutionRequest (pseudocode)
# The payload will contain readable transaction data including:
# - Account addresses
# - Transaction payloads  
# - Gas parameters
# - Execution configurations
```

**Rust verification code:**
```rust
use aptos_secure_net::network_controller::NetworkController;

// Demonstrates unencrypted transmission
let mut controller = NetworkController::new(
    "test".to_string(),
    "127.0.0.1:52200".parse().unwrap(),
    5000,
);

// Creates channel - inspect source shows http:// protocol used
let tx = controller.create_outbound_channel(
    "127.0.0.1:52201".parse().unwrap(),
    "test_type".to_string(),
);

// Any message sent here is transmitted in plaintext
// Network observers can intercept and read the data
```

The vulnerability can be verified by running the remote executor service and capturing traffic showing plaintext BCS-serialized transaction data flowing over HTTP on the wire.

### Citations

**File:** secure/net/src/grpc_network_service/mod.rs (L75-87)
```rust
        Server::builder()
            .timeout(std::time::Duration::from_millis(rpc_timeout_ms))
            .add_service(
                NetworkMessageServiceServer::new(self).max_decoding_message_size(MAX_MESSAGE_SIZE),
            )
            .add_service(reflection_service)
            .serve_with_shutdown(server_addr, async {
                server_shutdown_rx.await.ok();
                info!("Received signal to shutdown server at {:?}", server_addr);
            })
            .await
            .unwrap();
        info!("Server shutdown at {:?}", server_addr);
```

**File:** secure/net/src/grpc_network_service/mod.rs (L128-128)
```rust
                .block_on(async { Self::get_channel(format!("http://{}", remote_addr)).await }),
```

**File:** execution/executor-service/src/remote_executor_client.rs (L35-44)
```rust
pub fn set_remote_addresses(addresses: Vec<SocketAddr>) {
    REMOTE_ADDRESSES.set(addresses).ok();
}

pub fn get_remote_addresses() -> Vec<SocketAddr> {
    match REMOTE_ADDRESSES.get() {
        Some(value) => value.clone(),
        None => vec![],
    }
}
```

**File:** execution/executor-service/src/remote_executor_client.rs (L193-206)
```rust
        for (shard_id, sub_blocks) in sub_blocks.into_iter().enumerate() {
            let senders = self.command_txs.clone();
            let execution_request = RemoteExecutionRequest::ExecuteBlock(ExecuteBlockCommand {
                sub_blocks,
                concurrency_level: concurrency_level_per_shard,
                onchain_config: onchain_config.clone(),
            });

            senders[shard_id]
                .lock()
                .unwrap()
                .send(Message::new(bcs::to_bytes(&execution_request).unwrap()))
                .unwrap();
        }
```

**File:** execution/executor-service/src/lib.rs (L48-53)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct ExecuteBlockCommand {
    pub(crate) sub_blocks: SubBlocksForShard<AnalyzedTransaction>,
    pub(crate) concurrency_level: usize,
    pub(crate) onchain_config: BlockExecutorConfigFromOnchain,
}
```

**File:** types/src/transaction/analyzed_transaction.rs (L23-37)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct AnalyzedTransaction {
    transaction: SignatureVerifiedTransaction,
    /// Set of storage locations that are read by the transaction - this doesn't include location
    /// that are written by the transactions to avoid duplication of locations across read and write sets
    /// This can be accurate or strictly overestimated.
    pub read_hints: Vec<StorageLocation>,
    /// Set of storage locations that are written by the transaction. This can be accurate or strictly
    /// overestimated.
    pub write_hints: Vec<StorageLocation>,
    /// A transaction is predictable if neither the read_hint or the write_hint have wildcards.
    predictable_transaction: bool,
    /// The hash of the transaction - this is cached for performance reasons.
    hash: HashValue,
}
```

**File:** protos/rust/src/pb/aptos.remote_executor.v1.rs (L7-13)
```rust
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NetworkMessage {
    #[prost(bytes="vec", tag="1")]
    pub message: ::prost::alloc::vec::Vec<u8>,
    #[prost(string, tag="2")]
    pub message_type: ::prost::alloc::string::String,
}
```

**File:** execution/executor-service/src/process_executor_service.rs (L11-14)
```rust
/// An implementation of the remote executor service that runs in a standalone process.
pub struct ProcessExecutorService {
    executor_service: ExecutorService,
}
```
