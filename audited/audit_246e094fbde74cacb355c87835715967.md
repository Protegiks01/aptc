# Audit Report

## Title
Indexer Denial of Service via Missing Table Metadata Causing Panic on WriteTableItem Processing

## Summary
The Aptos indexer crashes when processing table write operations that lack table metadata, causing a complete indexer shutdown and hiding all table content from queries. The vulnerability stems from unchecked `.unwrap()` calls on optional decoded table data.

## Finding Description

When the Aptos node API converts a `WriteTableItem` from storage, it attempts to decode the raw bytes using table metadata (key/value types). If table metadata is not available, the API sets the `data` field to `None` and continues processing: [1](#0-0) 

This defensive programming prevents API crashes. However, the indexer service that consumes these transactions assumes the `data` field is always present and calls `.unwrap()` without checking: [2](#0-1) [3](#0-2) 

When table info is missing (e.g., table created before indexer started, race conditions, or corrupted metadata), the `data` field is `None`, causing the `.unwrap()` to panic. This panic propagates through the transaction processing pipeline and crashes the entire indexer: [4](#0-3) 

**Attack Scenario:**
1. Attacker creates a table via Move transaction
2. Due to timing or indexer configuration, table metadata is not captured
3. Attacker writes to the table
4. Indexer fetches transaction from node API
5. API returns `WriteTableItem` with `data = None`
6. Indexer attempts to process via `from_write_table_item()`
7. Panic occurs on `.unwrap()` 
8. Entire indexer process crashes
9. All table content becomes inaccessible, no further transactions are indexed

## Impact Explanation

**Medium Severity** - This vulnerability causes:

1. **Denial of Service**: Complete indexer shutdown requiring manual intervention
2. **Data Availability Loss**: All table content becomes hidden from queries as indexer stops functioning
3. **Cascading Failure**: No subsequent blockchain data is indexed after the crash point

This meets the Medium severity criteria of "State inconsistencies requiring intervention" per the Aptos bug bounty program. While it doesn't directly affect consensus or validator operation, it breaks the indexer's availability guarantees and hides critical blockchain state from applications and users.

## Likelihood Explanation

**High Likelihood** - This vulnerability can occur naturally under several conditions:

1. **Indexer Cold Start**: Tables created before indexer initialization will lack metadata
2. **Race Conditions**: Table creation and write operations in same block may not capture metadata properly
3. **Metadata Corruption**: Database issues or crashes during table metadata persistence
4. **Selective Indexing**: Indexer configurations that skip certain transactions may miss table creation events

The vulnerability requires no attacker privileges - simply writing to a table without available metadata triggers the crash. This makes it highly exploitable and likely to occur in production environments.

## Recommendation

Replace all `.unwrap()` calls with proper error handling. The indexer should gracefully handle missing table metadata by either:

1. **Logging and skipping**: Log the missing metadata and insert the table item with `decoded_value = NULL`, matching the database schema's nullable design
2. **Deferred processing**: Queue items with missing metadata for later retry when metadata becomes available

Recommended fix for `from_write_table_item()`:

```rust
pub fn from_write_table_item(
    write_table_item: &WriteTableItem,
    write_set_change_index: i64,
    transaction_version: i64,
    transaction_block_height: i64,
) -> (Self, CurrentTableItem) {
    let (decoded_key, decoded_value) = match &write_table_item.data {
        Some(data) => (data.key.clone(), Some(data.value.clone())),
        None => {
            // Log warning about missing table metadata
            aptos_logger::warn!(
                "Missing table metadata for handle: {}, version: {}",
                write_table_item.handle,
                transaction_version
            );
            // Use raw key as JSON string, set value to null
            (serde_json::Value::String(write_table_item.key.to_string()), None)
        }
    };
    
    (
        Self {
            transaction_version,
            write_set_change_index,
            transaction_block_height,
            key: write_table_item.key.to_string(),
            table_handle: standardize_address(&write_table_item.handle.to_string()),
            decoded_key: decoded_key.clone(),
            decoded_value,
            is_deleted: false,
        },
        CurrentTableItem {
            table_handle: standardize_address(&write_table_item.handle.to_string()),
            key_hash: hash_str(&write_table_item.key.to_string()),
            key: write_table_item.key.to_string(),
            decoded_key,
            decoded_value,
            last_transaction_version: transaction_version,
            is_deleted: false,
        },
    )
}
```

## Proof of Concept

**Reproduction Steps:**

1. Start an Aptos node with indexer enabled
2. Deploy a Move module that creates a table:

```move
module test_addr::table_test {
    use std::table;
    
    struct TableHolder has key {
        data: table::Table<u64, u64>
    }
    
    public entry fun create_and_write(account: &signer) {
        let t = table::new<u64, u64>();
        table::add(&mut t, 1, 100);
        move_to(account, TableHolder { data: t });
    }
}
```

3. Configure indexer to start from a version AFTER the table creation
4. Execute `create_and_write` transaction
5. Observe indexer fetch the transaction
6. Indexer will panic with: `thread 'indexer' panicked at 'called Option::unwrap() on a None value'`
7. Verify indexer process has terminated and no further transactions are processed

**Alternative PoC** - Corrupt table metadata:
1. Start indexer normally
2. Manually delete entries from `table_metadatas` database table
3. Execute transaction writing to those tables
4. Observe indexer crash

The vulnerability is deterministic and reproducible whenever `WriteTableItem.data` is `None`.

### Citations

**File:** api/types/src/convert.rs (L561-567)
```rust
        let table_info = match self.get_table_info(handle)? {
            Some(ti) => ti,
            None => {
                log_missing_table_info(handle);
                return Ok(None); // if table item not found return None anyway to avoid crash
            },
        };
```

**File:** crates/indexer/src/models/move_tables.rs (L66-67)
```rust
                decoded_key: write_table_item.data.as_ref().unwrap().key.clone(),
                decoded_value: Some(write_table_item.data.as_ref().unwrap().value.clone()),
```

**File:** crates/indexer/src/models/move_tables.rs (L74-75)
```rust
                decoded_key: write_table_item.data.as_ref().unwrap().key.clone(),
                decoded_value: Some(write_table_item.data.as_ref().unwrap().value.clone()),
```

**File:** crates/indexer/src/runtime.rs (L230-243)
```rust
                Some(Err(tpe)) => {
                    let (err, start_version, end_version, _) = tpe.inner();
                    error!(
                        processor_name = processor_name,
                        start_version = start_version,
                        end_version = end_version,
                        error =? err,
                        "Error processing batch!"
                    );
                    panic!(
                        "Error in '{}' while processing batch: {:?}",
                        processor_name, err
                    );
                },
```
