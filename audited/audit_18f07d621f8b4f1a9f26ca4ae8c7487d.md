# Audit Report

## Title
Missing BCS Deserialization Size Check for WebAuthn Signature Fields Enables Mempool Pollution

## Summary
The `PartialAuthenticatorAssertionResponse` structure lacks size validation during BCS deserialization, allowing transactions with WebAuthn signatures up to 64KB (64x larger than the documented 1024-byte limit) to enter the mempool before being rejected by the VM.

## Finding Description
The codebase defines a `MAX_WEBAUTHN_SIGNATURE_BYTES` constant of 1024 bytes for WebAuthn signatures, but this limit is only enforced for JSON/Hex API submissions, not for BCS-encoded transaction submissions. [1](#0-0) 

The `PartialAuthenticatorAssertionResponse` struct contains two `Vec<u8>` fields (`authenticator_data` and `client_data_json`) that are deserialized without size bounds: [2](#0-1) 

When transactions are submitted via BCS, the API only enforces a depth limit of 16 during deserialization, not a size limit: [3](#0-2) 

The size check for WebAuthn signatures in the API validation layer only applies to JSON/Hex submissions: [4](#0-3) 

**Attack Path:**
1. Attacker crafts a `SignedTransaction` with BCS-encoded `PartialAuthenticatorAssertionResponse`
2. Sets `authenticator_data` and/or `client_data_json` to values totaling ~60KB (staying under the 64KB transaction size limit)
3. Submits via BCS endpoint (under 8MB HTTP body limit)
4. Transaction passes BCS deserialization (no size check, only depth limit)
5. Transaction enters mempool consuming ~60KB per transaction
6. Transaction is eventually rejected by VM when transaction size check occurs [5](#0-4) 

## Impact Explanation
This issue enables a **mempool pollution attack** where an attacker can flood the network with transactions containing oversized WebAuthn signatures that:
- Consume 60x more memory than intended (60KB vs 1KB per signature)
- Bypass the intended `MAX_WEBAUTHN_SIGNATURE_BYTES` limit
- Are accepted by the API and mempool before being rejected by the VM

However, the actual impact is **LIMITED** because:
- Each transaction is capped at 64KB total size by the VM check
- Transactions are rejected before execution
- No funds are at risk, no consensus violation occurs
- Network-level DoS is explicitly out of scope per bug bounty rules

This represents a **protocol implementation inconsistency** rather than a critical security vulnerability, as the system eventually enforces limits through the 64KB transaction size check.

## Likelihood Explanation
**Likelihood: High** - The attack is trivial to execute by any transaction sender. However, the impact is limited to temporary resource consumption.

## Recommendation
Add explicit size validation for WebAuthn signature fields during BCS deserialization to enforce the `MAX_WEBAUTHN_SIGNATURE_BYTES` limit consistently across all submission paths:

```rust
// In types/src/transaction/webauthn.rs
impl TryFrom<&[u8]> for PartialAuthenticatorAssertionResponse {
    type Error = CryptoMaterialError;
    
    fn try_from(bytes: &[u8]) -> Result<PartialAuthenticatorAssertionResponse, CryptoMaterialError> {
        let response: PartialAuthenticatorAssertionResponse = bcs::from_bytes(bytes)
            .map_err(|_e| CryptoMaterialError::DeserializationError)?;
        
        // Enforce MAX_WEBAUTHN_SIGNATURE_BYTES limit
        let total_size = response.authenticator_data.len() 
            + response.client_data_json.len() 
            + response.signature_bytes().len();
            
        if total_size > MAX_WEBAUTHN_SIGNATURE_BYTES {
            return Err(CryptoMaterialError::ValidationError);
        }
        
        Ok(response)
    }
}
```

## Proof of Concept
```rust
// This demonstrates creating an oversized WebAuthn signature that would be accepted via BCS
use aptos_types::transaction::webauthn::{PartialAuthenticatorAssertionResponse, AssertionSignature, MAX_WEBAUTHN_SIGNATURE_BYTES};
use aptos_crypto::secp256r1_ecdsa;

fn test_oversized_webauthn_signature() {
    let signature = secp256r1_ecdsa::Signature::dummy_signature();
    let assertion_sig = AssertionSignature::Secp256r1Ecdsa { signature };
    
    // Create oversized fields (60KB total, 60x larger than MAX_WEBAUTHN_SIGNATURE_BYTES)
    let oversized_authenticator_data = vec![0u8; 30_000];
    let oversized_client_data_json = vec![0u8; 30_000];
    
    let paar = PartialAuthenticatorAssertionResponse::new(
        assertion_sig,
        oversized_authenticator_data,
        oversized_client_data_json,
    );
    
    // BCS serialization succeeds despite exceeding MAX_WEBAUTHN_SIGNATURE_BYTES
    let bcs_bytes = paar.to_bytes();
    assert!(bcs_bytes.len() > MAX_WEBAUTHN_SIGNATURE_BYTES as usize);
    
    // Deserialization also succeeds without size validation
    let decoded = PartialAuthenticatorAssertionResponse::try_from(bcs_bytes.as_slice());
    assert!(decoded.is_ok());
}
```

## Notes
While this issue represents an implementation inconsistency between JSON/Hex and BCS submission paths, **the overall impact is limited** to temporary resource consumption during mempool processing. The system's 64KB transaction size limit provides an ultimate bound that prevents truly "enormous" sizes from being processed. This qualifies as a protocol implementation issue requiring correction for consistency, but does not meet the threshold for critical or high severity impact per the bug bounty criteria.

### Citations

**File:** types/src/transaction/webauthn.rs (L12-12)
```rust
pub const MAX_WEBAUTHN_SIGNATURE_BYTES: usize = 1024;
```

**File:** types/src/transaction/webauthn.rs (L78-96)
```rust
#[derive(Clone, Debug, Eq, Hash, PartialEq, Serialize, Deserialize)]
#[cfg_attr(feature = "fuzzing", derive(arbitrary::Arbitrary))]
pub struct PartialAuthenticatorAssertionResponse {
    /// This attribute contains the raw signature returned from the authenticator.
    /// NOTE: Many signatures returned from WebAuthn assertions are not raw signatures.
    /// As an example, Secp256r1 ECDSA signatures are encoded as an [ASN.1 DER Ecdsa-Sig_value](https://www.w3.org/TR/webauthn-3/#sctn-signature-attestation-types)
    /// If the signature is encoded, the client is expected to convert the encoded signature
    /// into a raw signature before including it in the transaction
    signature: AssertionSignature,
    /// This attribute contains the authenticator data returned by the authenticator.
    /// See [`AuthenticatorData`](passkey_types::ctap2::AuthenticatorData).
    #[serde(with = "serde_bytes")]
    authenticator_data: Vec<u8>,
    /// This attribute contains the JSON byte serialization of [`CollectedClientData`](CollectedClientData) passed to the
    /// authenticator by the client in order to generate this credential. The exact JSON serialization
    /// MUST be preserved, as the hash of the serialized client data has been computed over it.
    #[serde(with = "serde_bytes")]
    client_data_json: Vec<u8>,
}
```

**File:** api/src/transactions.rs (L1223-1225)
```rust
                let signed_transaction: SignedTransaction =
                    bcs::from_bytes_with_limit(&data.0, Self::MAX_SIGNED_TRANSACTION_DEPTH)
                        .context("Failed to deserialize input into SignedTransaction")
```

**File:** api/types/src/transaction.rs (L1498-1502)
```rust
        } else if signature_len > MAX_WEBAUTHN_SIGNATURE_BYTES {
            bail!(
                "The WebAuthn signature length is greater than the maximum number of {} bytes: found {} bytes.",
                MAX_WEBAUTHN_SIGNATURE_BYTES, signature_len
            )
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L73-76)
```rust
            max_transaction_size_in_bytes: NumBytes,
            "max_transaction_size_in_bytes",
            64 * 1024
        ],
```
