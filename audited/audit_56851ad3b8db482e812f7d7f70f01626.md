# Audit Report

## Title
Unbounded Memory Growth in Faucet Captcha Manager Leading to Denial of Service

## Summary
The Aptos faucet's captcha implementation stores challenges in an unbounded in-memory HashMap with no expiration mechanism. Attackers can exhaust server memory by repeatedly requesting captcha challenges without validation, causing the faucet service to crash via Out-of-Memory (OOM) conditions.

## Finding Description

The `CaptchaManager` in the faucet service stores captcha challenges in an unbounded `HashMap<u32, String>` without any expiration or cleanup mechanism. [1](#0-0) 

When the `/request_captcha` endpoint is called, it invokes `CaptchaManager::create_challenge()` which generates a random key and stores the captcha text in the HashMap. [2](#0-1) 

The captcha data structure stores challenges indefinitely: [3](#0-2) 

Challenges are only removed from memory when correctly validated: [4](#0-3) 

If a challenge is never validated, or if validation fails with an incorrect answer, the challenge remains in the HashMap permanently. No periodic cleanup task exists - the `spawn_periodic_tasks` method is not overridden by `TapCaptchaChecker`. [5](#0-4) 

**Attack Path:**
1. Attacker sends repeated GET requests to `/request_captcha` endpoint
2. Each request generates a new captcha and stores it in the HashMap
3. Attacker never validates these challenges (or intentionally submits wrong answers)
4. Memory usage grows unbounded as HashMap accumulates entries
5. Eventually the faucet process exhausts available memory and crashes (OOM)

This breaks the Resource Limits invariant - the system fails to respect computational and memory limits for this operation.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program criteria for "API crashes". The faucet service is critical infrastructure for developers and testnets, and a successful attack would:

- Cause complete denial of service for the faucet API
- Prevent legitimate users from obtaining testnet/devnet tokens
- Require manual service restart and potential investigation
- Could affect multiple services if the faucet shares infrastructure with other components

While the faucet is not part of the core consensus layer, it is production infrastructure within the Aptos Core codebase that supports the developer ecosystem.

## Likelihood Explanation

**Likelihood: HIGH**

The attack is trivially simple to execute:
- No authentication required for `/request_captcha` endpoint
- No rate limiting specifically on captcha generation (only on fund requests)
- Single HTTP GET request per challenge generation
- Can be automated with basic scripting
- No special knowledge of the system required

An attacker could exhaust memory within hours or days depending on available system memory and request rate. With automated scripts making requests every few seconds, a server with 8GB RAM could be overwhelmed in a relatively short timeframe.

## Recommendation

Implement a time-based expiration mechanism for captcha challenges. Add a timestamp to each challenge and implement periodic cleanup:

**Solution 1: Add expiration tracking**
```rust
// In CaptchaManager struct
pub struct CaptchaManager {
    challenges: HashMap<u32, (String, Instant)>, // Add timestamp
}

// In create_challenge()
self.challenges.insert(key, (name, Instant::now()));

// Implement periodic cleanup in spawn_periodic_tasks
impl CheckerTrait for TapCaptchaChecker {
    fn spawn_periodic_tasks(&self, join_set: &mut JoinSet<anyhow::Result<()>>) {
        let captcha_manager = self.captcha_manager.clone();
        join_set.spawn(async move {
            loop {
                tokio::time::sleep(Duration::from_secs(60)).await;
                let mut manager = captcha_manager.lock().await;
                let now = Instant::now();
                manager.challenges.retain(|_, (_, timestamp)| {
                    now.duration_since(*timestamp) < Duration::from_secs(300) // 5 min expiry
                });
            }
        });
    }
}
```

**Solution 2: Implement size-based LRU cache**
Use a bounded LRU cache (e.g., `lru` crate) with a maximum size limit to automatically evict oldest challenges when capacity is reached.

## Proof of Concept

```bash
#!/bin/bash
# Simple PoC to demonstrate unbounded memory growth
# This script continuously requests captchas without validation

FAUCET_URL="http://localhost:8081/request_captcha"
COUNTER=0

while true; do
    curl -s "$FAUCET_URL" > /dev/null
    COUNTER=$((COUNTER + 1))
    echo "Requested captcha #$COUNTER"
    sleep 0.1  # 10 requests per second
done

# Monitor memory usage with: ps aux | grep faucet
# Memory will grow continuously until OOM
```

**Rust Integration Test:**
```rust
#[tokio::test]
async fn test_captcha_memory_leak() {
    let captcha_manager = Arc::new(Mutex::new(CaptchaManager::new()));
    
    // Request 10,000 captchas without validation
    for i in 0..10000 {
        let mut manager = captcha_manager.lock().await;
        let _ = manager.create_challenge().unwrap();
        
        if i % 1000 == 0 {
            println!("Challenges stored: {}", manager.challenges.len());
        }
    }
    
    // All 10,000 challenges remain in memory
    let manager = captcha_manager.lock().await;
    assert_eq!(manager.challenges.len(), 10000);
    // Memory never freed without validation
}
```

## Notes

The development team is aware of this issue as evidenced by the warning comment in the source code, but it remains unresolved in the current implementation. This represents a known but unfixed vulnerability that poses a real security risk to production faucet deployments.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L4-6)
```rust
//! Warning: This could be attacked and cause the server to OOM because we
//! don't throw out captchas info if it has been sitting there for too long /
//! the map grows too large.
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L125-131)
```rust
#[derive(Debug, Default)]
pub struct CaptchaManager {
    /// When a challenge is created, we return to the client the captcha itself
    /// and a random key they must make the second request with. This is a map
    /// from that random key to the value of the captcha.
    challenges: HashMap<u32, String>,
}
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L164-177)
```rust
    /// Check a captcha challenge. Returns true if the captcha is correct.
    pub fn check_challenge(&mut self, key: u32, value: &str) -> Result<bool> {
        match self.challenges.get(&key) {
            Some(captcha) => {
                if captcha == value {
                    self.challenges.remove(&key);
                    Ok(true)
                } else {
                    Ok(false)
                }
            },
            None => bail!("Captcha key unknown: {}", key),
        }
    }
```

**File:** crates/aptos-faucet/core/src/endpoints/captcha.rs (L48-57)
```rust
        let mut captcha_manager = self.captcha_manager.lock().await;
        let (key, image) = match captcha_manager.create_challenge() {
            Ok((key, image)) => (key, image),
            Err(e) => {
                return Err(
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError).into(),
                );
            },
        };
        Ok(Response::new(Binary(image)).header(CAPTCHA_KEY, key))
```

**File:** crates/aptos-faucet/core/src/checkers/mod.rs (L69-76)
```rust
    /// This function will be called once at startup. In it, the trait implementation
    /// should spawn any periodic tasks that it wants and return handles to them.
    /// If tasks want to signal that there is an issue, all they have to do is return.
    /// If the task wants to tolerate some errors, e.g. only cause the process to die
    /// if the task has failed n times, it must handle that itself and only return
    /// when it wants this to happen.
    // Sadly we can't use ! here yet: https://github.com/rust-lang/rust/issues/35121.
    fn spawn_periodic_tasks(&self, _join_set: &mut JoinSet<anyhow::Result<()>>) {}
```
