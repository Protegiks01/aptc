# Audit Report

## Title
Premature Pruning of Committed Blocks Due to Stale Commit Root and Unsafe Window Calculation

## Summary
A critical logic vulnerability in the consensus layer's block pruning mechanism can cause committed blocks to be permanently deleted from persistent storage before the commit root is updated. This occurs when multiple blocks are batched for commit, but only the last block's callback is invoked, leading to pruning decisions based on stale commit root state.

## Finding Description

The vulnerability arises from an unsafe operation ordering in the `commit_callback` function within the block tree management system. When blocks are committed in batches, the following dangerous sequence occurs:

**Batch Commit Behavior:**

When multiple blocks (e.g., 101-120) are persisted together via `PersistingRequest`, they all receive the same `LedgerInfoWithSignatures` commit proof. [1](#0-0) 

However, only the block whose ID matches the commit proof ID will have its `block_store_callback` invoked, as verified by the check in `commit_ledger`: [2](#0-1) 

The callback is only invoked when `commit_ledger` returns `Some`: [3](#0-2) 

**Unsafe Pruning Sequence:**

In `commit_callback`, the operations execute in this order: [4](#0-3) 

The critical issue is:
1. Line 588: New window root calculated based on the **newly committed block's round** (e.g., round 120)
2. Line 589: Blocks to prune identified from old window_root to new window_root
3. Line 591: Blocks **permanently deleted from persistent storage** via `storage.prune_tree()`
4. Line 598: Window root updated
5. Line 599: **Only then** is commit root updated via `update_highest_commit_cert`

The window calculation uses the newly committed block's round: [5](#0-4) 

**Invariant Violation:**

The codebase documents that `window_root.round() <= commit_root.round()` must hold: [6](#0-5) 

However, between lines 598-599 of `commit_callback`, this invariant is violated when window_root advances beyond the still-stale commit_root.

**Permanent Data Loss:**

The `prune_tree` call permanently deletes blocks from ConsensusDB: [7](#0-6) 

**Recovery Failure:**

Upon node restart, the recovery process attempts to find the commit root block: [8](#0-7) 

If the commit root was pruned, recovery fails with "unable to find root".

**Concrete Attack Scenario:**

1. Initial state: commit_root at round 100, window_root at round ~81 (assuming window_size=20)
2. Network commits blocks 101-120 in a batch with commit proof for block 120
3. Only block 120's `commit_callback` is invoked
4. `find_window_root(block_120, window_size=20)` calculates new window root at round ~101
5. `find_blocks_to_prune` traverses from old window_root (round ~81) to new (round ~101), including all blocks 81-100
6. Block 100 (the current commit_root) is permanently deleted from disk
7. Commit root is updated to 120, but block 100 is already gone
8. Node crash triggers recovery failure when trying to load block 100

## Impact Explanation

**Critical Severity** - This vulnerability constitutes a consensus safety violation with catastrophic impact:

1. **Loss of Finalized State**: Committed blocks that have reached finality are permanently deleted from persistent storage, violating the fundamental blockchain immutability guarantee.

2. **Consensus Safety Violation**: Breaks the core consensus invariant that committed blocks are never lost, directly violating AptosBFT safety properties.

3. **Non-Recoverable Failure**: Nodes that crash after pruning but before updating the commit root cannot restart. The recovery process will fail when attempting to load the deleted commit root from storage, causing permanent node failure.

4. **Potential Network Partition**: If different validators experience crashes at different points in the commit sequence, they may prune different sets of committed blocks, leading to irreconcilable state divergence requiring a hardfork.

This meets the Aptos bug bounty **Critical Severity** criteria for "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**High Likelihood** - This vulnerability occurs naturally during normal consensus operation:

1. **Batch Commits Are Standard**: The `advance_head` function regularly batches multiple blocks together for persistence when commit proofs arrive: [9](#0-8) 

2. **No Attacker Required**: The vulnerability triggers automatically when:
   - Multiple blocks accumulate in the buffer (common under load)
   - A commit proof arrives for the last block
   - All accumulated blocks are persisted as a batch

3. **Realistic Parameters**: With typical window_size values (e.g., 20) and batch sizes of 10-20 blocks during periods of high throughput, the gap between the old commit_root and new window_root will span committed blocks.

4. **Normal Operation**: No malicious behavior, specific timing attacks, or Byzantine validators are required. This occurs during regular AptosBFT consensus operation, especially when validators are catching up after brief network delays.

## Recommendation

Reorder operations in `commit_callback` to update the commit root **before** calculating the new window root and pruning:

```rust
pub fn commit_callback(
    &mut self,
    storage: Arc<dyn PersistentLivenessStorage>,
    block_id: HashValue,
    block_round: Round,
    finality_proof: WrappedLedgerInfo,
    commit_decision: LedgerInfoWithSignatures,
    window_size: Option<u64>,
) {
    let current_round = self.commit_root().round();
    let committed_round = block_round;
    let commit_proof = finality_proof
        .create_merged_with_executed_state(commit_decision)
        .expect("Inconsistent commit proof and evaluation decision, cannot commit block");

    debug!(
        LogSchema::new(LogEvent::CommitViaBlock).round(current_round),
        committed_round = committed_round,
        block_id = block_id,
    );

    // FIX: Update commit root FIRST
    self.update_highest_commit_cert(commit_proof);
    
    // THEN calculate window root and prune using the UPDATED commit root
    let window_root_id = self.find_window_root(block_id, window_size);
    let ids_to_remove = self.find_blocks_to_prune(window_root_id);

    if let Err(e) = storage.prune_tree(ids_to_remove.clone().into_iter().collect()) {
        warn!(error = ?e, "fail to delete block");
    }
    self.process_pruned_blocks(ids_to_remove);
    self.update_window_root(window_root_id);
}
```

Additionally, add an assertion to verify the invariant is maintained:

```rust
assert!(
    self.window_root().round() <= self.commit_root().round(),
    "Invariant violated: window_root round {} > commit_root round {}",
    self.window_root().round(),
    self.commit_root().round()
);
```

## Proof of Concept

The vulnerability can be demonstrated by:

1. Setting up a test BlockStore with `window_size = 20`
2. Committing blocks 1-100 individually (establishing commit_root at 100)
3. Creating a batch of blocks 101-120 with a single commit proof for block 120
4. Invoking only block 120's `commit_callback`
5. Verifying that block 100 is included in `ids_to_remove` from `find_blocks_to_prune`
6. Confirming that `storage.prune_tree` is called before `update_highest_commit_cert`
7. Simulating a crash and observing recovery failure when attempting to load the deleted commit root

A Rust integration test can be constructed using the existing test infrastructure in `consensus/src/block_storage/execution_pool/block_window_test.rs` to reproduce this exact scenario.

## Notes

This is a genuine logic vulnerability in the consensus layer that violates fundamental safety guarantees. The issue stems from the assumption that `commit_callback` would be invoked for each committed block individually, but the batch commit optimization breaks this assumption. The fix requires careful reordering to ensure commit root updates happen before pruning decisions are made based on that root.

### Citations

**File:** consensus/src/pipeline/persisting_phase.rs (L65-72)
```rust
        for b in &blocks {
            if let Some(tx) = b.pipeline_tx().lock().as_mut() {
                tx.commit_proof_tx
                    .take()
                    .map(|tx| tx.send(commit_ledger_info.clone()));
            }
            b.wait_for_commit_ledger().await;
        }
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L1091-1094)
```rust
        // it's committed as prefix
        if ledger_info_with_sigs.commit_info().id() != block.id() {
            return Ok(None);
        }
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L1137-1140)
```rust
        if let Some(ledger_info_with_sigs) = maybe_ledger_info_with_sigs {
            let order_proof = order_proof_fut.await?;
            block_store_callback(order_proof, ledger_info_with_sigs);
        }
```

**File:** consensus/src/block_storage/block_tree.rs (L114-117)
```rust
        assert!(window_root.round() <= root_ordered_cert.commit_info().round());
        let window_root_id = window_root.id();

        // Build the tree from the window root block which is <= the commit root block.
```

**File:** consensus/src/block_storage/block_tree.rs (L588-599)
```rust
        let window_root_id = self.find_window_root(block_id, window_size);
        let ids_to_remove = self.find_blocks_to_prune(window_root_id);

        if let Err(e) = storage.prune_tree(ids_to_remove.clone().into_iter().collect()) {
            // it's fine to fail here, as long as the commit succeeds, the next restart will clean
            // up dangling blocks, and we need to prune the tree to keep the root consistent with
            // executor.
            warn!(error = ?e, "fail to delete block");
        }
        self.process_pruned_blocks(ids_to_remove);
        self.update_window_root(window_root_id);
        self.update_highest_commit_cert(commit_proof);
```

**File:** consensus/src/util/mod.rs (L26-29)
```rust
pub fn calculate_window_start_round(current_round: Round, window_size: u64) -> Round {
    assert!(window_size > 0);
    (current_round + 1).saturating_sub(window_size)
}
```

**File:** consensus/src/persistent_liveness_storage.rs (L134-138)
```rust
        let latest_commit_idx = blocks
            .iter()
            .position(|block| block.id() == latest_commit_id)
            .ok_or_else(|| format_err!("unable to find root: {}", latest_commit_id))?;
        let commit_block = blocks[latest_commit_idx].clone();
```

**File:** consensus/src/persistent_liveness_storage.rs (L499-505)
```rust
    fn prune_tree(&self, block_ids: Vec<HashValue>) -> Result<()> {
        if !block_ids.is_empty() {
            // quorum certs that certified the block_ids will get removed
            self.db.delete_blocks_and_quorum_certificates(block_ids)?;
        }
        Ok(())
    }
```

**File:** consensus/src/pipeline/buffer_manager.rs (L493-496)
```rust
        let mut blocks_to_persist: Vec<Arc<PipelinedBlock>> = vec![];

        while let Some(item) = self.buffer.pop_front() {
            blocks_to_persist.extend(item.get_blocks().clone());
```
