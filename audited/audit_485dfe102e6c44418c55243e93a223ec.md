# Audit Report

## Title
Version-Event Mismatch in State Sync Notification Handlers Without Monotonicity Enforcement

## Summary
The state sync driver's notification handlers fetch versions from storage asynchronously after transaction commits, creating a critical mismatch between committed transaction versions and the versions reported to event subscribers. Additionally, there is no enforcement of version monotonicity in the event notification layer, despite tests explicitly expecting this invariant.

## Finding Description

The vulnerability exists in how version numbers are propagated through the notification system. When transactions are committed, the notification handlers do not track the actual version range of the committed transactions. Instead, they fetch the current version from storage after the fact. [1](#0-0) 

This function fetches `latest_synced_version` from storage at the time of processing, which may not correspond to the transactions being notified. The committed transactions come from the `ChunkCommitNotification`: [2](#0-1) 

Notice that `ChunkCommitNotification` does NOT include version information - only transactions and events. When this notification is processed: [3](#0-2) 

The handler creates `CommittedTransactions` with the events and transactions from the notification, but then fetches an unrelated version from storage to tag these events.

Furthermore, the `EventSubscriptionService` has no monotonicity check: [4](#0-3) 

The `notify_events` method accepts any version without validating it's greater than previously notified versions. However, tests explicitly expect this invariant: [5](#0-4) 

The test enforces strict version ordering with `assert_lt!`, but production code has no such check.

## Impact Explanation

**Severity: Medium (up to $10,000)**

This issue causes **state inconsistencies** where:

1. **Version-Event Mismatch**: Events from transactions at version V are tagged with version W (where W â‰  V), breaking the semantic relationship between events and blockchain state
2. **Potential Version Duplicates**: Multiple notifications may report the same version with different events
3. **Violated Test Expectations**: Production code violates invariants that tests explicitly verify

While this doesn't directly cause consensus violations or fund loss, it creates state inconsistencies that could:
- Confuse event subscribers (like consensus reconfiguration listeners)
- Break external systems relying on version-event correspondence
- Lead to incorrect application-level state machines

This falls under "State inconsistencies requiring intervention" per the Medium severity criteria.

## Likelihood Explanation

**Likelihood: High**

This occurs in normal operation whenever:
1. Multiple transaction chunks are committed in quick succession
2. The notification processing lags behind commits
3. Any async delay exists between commit and notification processing

The sequential processing in the driver (`futures::select!`) prevents true version regression under normal circumstances, but the version mismatch occurs regularly. The lack of monotonicity enforcement means any future refactoring that introduces concurrency or reordering could immediately cause version regression without detection.

## Recommendation

1. **Include version information in ChunkCommitNotification**:

```rust
pub struct ChunkCommitNotification {
    pub subscribable_events: Vec<ContractEvent>,
    pub committed_transactions: Vec<Transaction>,
    pub reconfiguration_occurred: bool,
    pub first_version: Version,  // ADD THIS
    pub last_version: Version,   // ADD THIS
}
```

2. **Use the committed version range instead of fetching from storage**:

Modify `handle_committed_transactions` to accept version as a parameter instead of fetching it.

3. **Add monotonicity enforcement in EventSubscriptionService**:

```rust
pub struct EventSubscriptionService {
    // existing fields...
    last_notified_version: Arc<Mutex<Option<Version>>>,  // ADD THIS
}

impl EventNotificationSender for EventSubscriptionService {
    fn notify_events(&mut self, version: Version, events: Vec<ContractEvent>) -> Result<(), Error> {
        // ADD THIS CHECK:
        let mut last_version = self.last_notified_version.lock();
        if let Some(prev_version) = *last_version {
            if version <= prev_version {
                return Err(Error::UnexpectedErrorEncountered(format!(
                    "Version regression detected: {} <= {}", version, prev_version
                )));
            }
        }
        *last_version = Some(version);
        
        // existing notification logic...
    }
}
```

4. **Pass version through the commit pipeline**:

Ensure `commit_chunk` includes version information in its notification, and propagate this through `handle_committed_transactions` to `notify_events`.

## Proof of Concept

While a full PoC would require modifying the executor to include version tracking, the vulnerability can be demonstrated by tracing the notification flow:

```rust
// Simulated scenario showing version mismatch:
// 
// 1. Chunk 1 (versions 100-110) commits to storage
// 2. Chunk 2 (versions 111-120) commits to storage
// 3. Both notifications are queued
// 
// Processing notification 1:
// - committed_transactions = [txs from versions 100-110]
// - events = [events from versions 100-110]
// - fetch_pre_committed_version(storage) -> returns 120 (latest)
// - notify_events(120, events_from_100_110)  // MISMATCH!
//
// Processing notification 2:
// - committed_transactions = [txs from versions 111-120]
// - events = [events from versions 111-120]
// - fetch_pre_committed_version(storage) -> returns 120
// - notify_events(120, events_from_111_120)  // DUPLICATE VERSION!
//
// Event subscribers receive:
// - Version 120 with events from transactions 100-110
// - Version 120 with events from transactions 111-120
// 
// This violates the test's expectation that versions are strictly increasing
// and breaks the semantic link between version and events.
```

To trigger this in a test environment:
1. Commit multiple chunks rapidly
2. Add delays in notification processing
3. Observe that all notifications report the same (latest) version
4. Verify that test assertions about version ordering would fail if applied to production notification flow

## Notes

The current architecture prevents actual version **regression** (V2 followed by V1) in normal operation due to sequential processing. However, the lack of enforcement means this guarantee is fragile and could break with any architectural changes. The version-event **mismatch** is a definite correctness issue that occurs in production.

### Citations

**File:** state-sync/state-sync-driver/src/utils.rs (L335-353)
```rust
    // Fetch the latest synced version and ledger info from storage
    let (latest_synced_version, latest_synced_ledger_info) =
        match fetch_pre_committed_version(storage.clone()) {
            Ok(latest_synced_version) => match fetch_latest_synced_ledger_info(storage.clone()) {
                Ok(latest_synced_ledger_info) => (latest_synced_version, latest_synced_ledger_info),
                Err(error) => {
                    error!(LogSchema::new(LogEntry::SynchronizerNotification)
                        .error(&error)
                        .message("Failed to fetch latest synced ledger info!"));
                    return;
                },
            },
            Err(error) => {
                error!(LogSchema::new(LogEntry::SynchronizerNotification)
                    .error(&error)
                    .message("Failed to fetch latest synced version!"));
                return;
            },
        };
```

**File:** execution/executor-types/src/lib.rs (L266-272)
```rust
/// A structure that holds relevant information about a chunk that was committed.
#[derive(Clone)]
pub struct ChunkCommitNotification {
    pub subscribable_events: Vec<ContractEvent>,
    pub committed_transactions: Vec<Transaction>,
    pub reconfiguration_occurred: bool,
}
```

**File:** state-sync/state-sync-driver/src/storage_synchronizer.rs (L806-817)
```rust
            let committed_transactions = CommittedTransactions {
                events: notification.subscribable_events,
                transactions: notification.committed_transactions,
            };
            utils::handle_committed_transactions(
                committed_transactions,
                storage.clone(),
                mempool_notification_handler.clone(),
                event_subscription_service.clone(),
                storage_service_notification_handler.clone(),
            )
            .await;
```

**File:** state-sync/inter-component/event-notifications/src/lib.rs (L311-326)
```rust
    fn notify_events(&mut self, version: Version, events: Vec<ContractEvent>) -> Result<(), Error> {
        if events.is_empty() {
            return Ok(()); // No events!
        }

        // Notify event subscribers and check if a reconfiguration event was processed
        let reconfig_event_processed = self.notify_event_subscribers(version, events)?;

        // If a reconfiguration event was found, also notify the reconfig subscribers
        // of the new configuration values.
        if reconfig_event_processed {
            self.notify_reconfiguration_subscribers(version)
        } else {
            Ok(())
        }
    }
```

**File:** state-sync/inter-component/event-notifications/src/tests.rs (L419-438)
```rust
fn count_event_notifications_and_ensure_ordering(listener: &mut EventNotificationListener) -> u64 {
    let mut notification_received = true;
    let mut notification_count = 0;
    let mut last_version_received: i64 = -1;

    while notification_received {
        if let Some(event_notification) = listener.select_next_some().now_or_never() {
            notification_count += 1;
            assert_lt!(
                last_version_received,
                std::convert::TryInto::<i64>::try_into(event_notification.version).unwrap()
            );
            last_version_received = event_notification.version.try_into().unwrap();
        } else {
            notification_received = false;
        }
    }

    notification_count
}
```
