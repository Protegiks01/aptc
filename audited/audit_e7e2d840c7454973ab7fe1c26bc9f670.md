# Audit Report

## Title
DKG Consensus Failure Due to blstrs Library Version Incompatibility in DealtPubKey Serialization

## Summary
The `DealtPubKey::to_bytes()` function directly depends on the `blstrs` library's compressed format for G2 points. If validators run different versions of the `blstrs` library with incompatible compression formats, they will compute different byte representations for the same dealt public key, causing signature verification failures during DKG (Distributed Key Generation) and preventing successful epoch transitions.

## Finding Description
The vulnerability exists in the serialization and signature verification flow for DKG transcripts: [1](#0-0) 

The `to_bytes()` method calls `self.g_a.to_compressed()`, which uses the blstrs library's compression format. During DKG, validators sign a `SessionContribution` struct containing the `DealtPubKey`: [2](#0-1) 

The signature verification process re-serializes the `SessionContribution` to verify the signature: [3](#0-2) 

The signature verification calls `signing_message()` which BCS-serializes the `SessionContribution`: [4](#0-3) 

The serialization uses the `SerializeKey` derive macro, which calls `ValidCryptoMaterial::to_bytes()`: [5](#0-4) 

**Attack Scenario:**
1. Validator A (running blstrs v0.7.1) creates a transcript during DKG
2. The `DealtPubKey` is serialized using blstrs v0.7.1's `to_compressed()` format
3. Validator A signs the `SessionContribution` containing this serialized key
4. Validator B (running blstrs v0.8.0 with a changed compression format) receives the transcript
5. Validator B deserializes the `DealtPubKey` using `from_compressed()` (which may succeed if backward compatible)
6. During signature verification, Validator B re-serializes the `SessionContribution`
7. The `DealtPubKey` is now serialized using blstrs v0.8.0's `to_compressed()` format, producing **different bytes**
8. Signature verification fails because the signed bytes differ from the verified bytes
9. Validator B rejects the transcript as invalid

This breaks the **Deterministic Execution** invariant (invariant #1) and causes **Consensus Safety** violations (invariant #2) as validators disagree on transcript validity. [6](#0-5) 

If insufficient validators accept each other's transcripts due to version mismatches, the DKG cannot reach quorum: [7](#0-6) 

## Impact Explanation
This vulnerability qualifies as **High Severity** under the Aptos bug bounty program because it causes:

1. **Significant Protocol Violations**: DKG is critical for on-chain randomness and validator set transitions. Failure prevents epoch transitions.

2. **Validator Node Impact**: All validators running mismatched blstrs versions will be unable to complete DKG, affecting network-wide operations.

3. **Potential Network Partition**: The validator set could split into groups based on blstrs version, each rejecting the other's transcripts, requiring coordinated intervention.

4. **Liveness Degradation**: While Aptos can proceed without completed DKG, this severely impacts functionality that depends on randomness and delays epoch transitions.

The impact does not reach Critical severity because:
- No direct fund loss occurs
- The network may continue operating with incomplete DKG
- Recovery is possible through coordinated validator upgrades

## Likelihood Explanation
The likelihood of this vulnerability manifesting is **HIGH** during normal operations:

1. **Rolling Upgrades**: Validators typically upgrade in a rolling fashion to maintain network availability. During any upgrade window where the blstrs library version changes, validators will run mixed versions.

2. **Dependency Updates**: The workspace-level Cargo.toml pins blstrs to version 0.7.1: [8](#0-7) 

Any update to blstrs that changes the compressed format would trigger this issue.

3. **No Version Checks**: The codebase contains no validation that all validators use compatible blstrs versions or compression formats.

4. **Automatic Triggering**: Unlike vulnerabilities requiring attacker action, this occurs automatically during version transitions without malicious intent.

## Recommendation

**Immediate Fix**: Implement format versioning or use a stable, version-agnostic serialization format:

```rust
// Option 1: Add format version prefix
pub fn to_bytes(&self) -> [u8; DEALT_PK_NUM_BYTES + 1] {
    let mut bytes = [0u8; DEALT_PK_NUM_BYTES + 1];
    bytes[0] = COMPRESSION_FORMAT_VERSION; // e.g., 0x01
    bytes[1..].copy_from_slice(&self.g_a.to_compressed());
    bytes
}

// Option 2: Use canonical serialization
pub fn to_bytes(&self) -> [u8; DEALT_PK_NUM_BYTES] {
    // Convert to uncompressed, then apply deterministic compression
    let uncompressed = self.g_a.to_uncompressed();
    canonical_compress(&uncompressed)
}
```

**Long-term Solution**:
1. Pin the exact blstrs version with `=` instead of `^` in Cargo.toml
2. Add integration tests that verify serialization format stability across updates
3. Implement transcript format versioning to support graceful transitions
4. Add runtime checks to detect and warn about format incompatibilities during DKG

**Migration Strategy**:
When updating blstrs:
1. Verify compression format compatibility through tests
2. If incompatible, introduce format versioning
3. Require coordinated validator upgrades (no rolling upgrades)
4. Provide backward-compatible deserialization during transition period

## Proof of Concept

```rust
#[cfg(test)]
mod version_compatibility_test {
    use super::*;
    use blstrs::G2Projective;
    use group::Group;
    
    #[test]
    fn test_dealt_pub_key_serialization_stability() {
        // Simulate a DealtPubKey
        let g_a = G2Projective::generator();
        let dealt_key = DealtPubKey::new(g_a);
        
        // Serialize with current version
        let bytes_v1 = dealt_key.to_bytes();
        
        // Simulate deserialization and re-serialization
        // (in real scenario, this would be with different blstrs version)
        let deserialized = DealtPubKey::try_from(bytes_v1.as_slice())
            .expect("Deserialization should succeed");
        let bytes_v2 = deserialized.to_bytes();
        
        // CRITICAL: These must be identical for signature verification
        assert_eq!(
            bytes_v1, bytes_v2,
            "Re-serialization must produce identical bytes for signature compatibility"
        );
        
        // Simulate signature verification scenario
        use aptos_crypto::{bls12381, SigningKey};
        use serde::{Serialize, Deserialize};
        
        #[derive(Serialize, Deserialize)]
        struct TestSessionContribution {
            contrib: DealtPubKey,
            sid: u64,
        }
        
        let sk = bls12381::PrivateKey::generate(&mut rand::thread_rng());
        let contribution = TestSessionContribution {
            contrib: dealt_key.clone(),
            sid: 12345,
        };
        
        // Sign with original serialization
        let sig = sk.sign(&contribution).unwrap();
        
        // Verify with re-serialized key (simulating different validator)
        let contribution_v2 = TestSessionContribution {
            contrib: deserialized,
            sid: 12345,
        };
        
        // This will fail if serialization format changed between versions
        sig.verify(&contribution_v2, &sk.public_key())
            .expect("Signature verification must succeed with re-serialized key");
    }
}
```

To test with actual version incompatibility:
1. Create two branches with different blstrs versions
2. Serialize a `DealtPubKey` in branch 1, save bytes to file
3. Load bytes in branch 2, deserialize, and re-serialize
4. Compare byte arrays - differences indicate the vulnerability would trigger

**Notes**

This vulnerability is particularly insidious because:
- It only manifests during version transitions, not during normal single-version operation
- The blstrs library is an external dependency outside Aptos's direct control
- The compression format is an implementation detail not covered by semantic versioning guarantees
- Backward-compatible deserialization might succeed while re-serialization produces different bytes, making the issue non-obvious

The current implementation assumes blstrs compression format stability across versions, which is not guaranteed by the library's API contract.

### Citations

**File:** crates/aptos-dkg/src/pvss/dealt_pub_key.rs (L32-34)
```rust
            pub fn to_bytes(&self) -> [u8; DEALT_PK_NUM_BYTES] {
                self.g_a.to_compressed()
            }
```

**File:** crates/aptos-dkg/src/pvss/signed/generic_signing.rs (L92-97)
```rust
        let sig = ssk
            .sign(&SessionContribution {
                contrib: trs.get_dealt_public_key(),
                sid,
            })
            .expect("signing of `chunky` PVSS transcript failed");
```

**File:** crates/aptos-dkg/src/pvss/signed/generic_signing.rs (L169-175)
```rust
        self.sig.verify(
            &SessionContribution {
                contrib: self.trs.get_dealt_public_key(),
                sid,
            },
            &spks[self.get_dealers()[0].id],
        )?;
```

**File:** crates/aptos-crypto/src/traits/mod.rs (L170-177)
```rust
pub fn signing_message<T: CryptoHash + Serialize>(
    message: &T,
) -> Result<Vec<u8>, CryptoMaterialError> {
    let mut bytes = <T::Hasher as CryptoHasher>::seed().to_vec();
    bcs::serialize_into(&mut bytes, &message)
        .map_err(|_| CryptoMaterialError::SerializationError)?;
    Ok(bytes)
}
```

**File:** crates/aptos-crypto-derive/src/lib.rs (L200-206)
```rust
                } else {
                    // See comment in deserialize_key.
                    serializer.serialize_newtype_struct(
                        #name_string,
                        serde_bytes::Bytes::new(&ValidCryptoMaterial::to_bytes(self).as_slice()),
                    )
                }
```

**File:** dkg/src/transcript_aggregation/mod.rs (L96-101)
```rust
        S::verify_transcript_extra(&transcript, &self.epoch_state.verifier, false, Some(sender))
            .context("extra verification failed")?;

        S::verify_transcript(&self.dkg_pub_params, &transcript).map_err(|e| {
            anyhow!("[DKG] adding peer transcript failed with trx verification failure: {e}")
        })?;
```

**File:** dkg/src/transcript_aggregation/mod.rs (L122-134)
```rust
        let threshold = self.epoch_state.verifier.quorum_voting_power();
        let power_check_result = self
            .epoch_state
            .verifier
            .check_voting_power(trx_aggregator.contributors.iter(), true);
        let new_total_power = match &power_check_result {
            Ok(x) => Some(*x),
            Err(VerifyError::TooLittleVotingPower { voting_power, .. }) => Some(*voting_power),
            _ => None,
        };
        let maybe_aggregated = power_check_result
            .ok()
            .map(|_| trx_aggregator.trx.clone().unwrap());
```

**File:** Cargo.toml (L541-541)
```text
blstrs = { version = "0.7.1", features = ["serde", "__private_bench"] }
```
