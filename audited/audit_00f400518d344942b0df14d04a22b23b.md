# Audit Report

## Title
Windows Drive Letter Injection via Path Normalization in Move Package Resolver

## Summary
The `normalize_path()` function in the Move package resolver fails to properly validate Windows absolute paths that are disguised using the current directory component (`.`). This allows attackers to craft malicious Move package dependencies that can read arbitrary files on Windows systems by bypassing path validation checks through the combination of path normalization and insufficient post-normalization validation.

## Finding Description

The vulnerability exists in the interaction between `normalize_path()` [1](#0-0)  and the validation logic in the dependency resolver [2](#0-1) .

The attack works as follows:

1. **Path Parsing on Windows**: When a path like `./C:/sensitive/directory` is provided as a git dependency's `subdir`, Windows path parsing creates components: `[CurDir, Prefix('C'), RootDir, Normal("sensitive"), Normal("directory")]`

2. **Pre-normalization Validation Bypass**: The `is_absolute()` check [3](#0-2)  returns `false` for `./C:/sensitive/directory` because the path starts with `.`, not a drive letter, so it appears to be relative.

3. **Normalization Strips Leading Dot**: The `normalize_path()` function removes `CurDir` components [4](#0-3) , transforming `[CurDir, Prefix('C'), RootDir, Normal("sensitive"), Normal("directory")]` into `[Prefix('C'), RootDir, Normal("sensitive"), Normal("directory")]`, which reconstructs to the absolute path `C:\sensitive\directory`.

4. **Post-normalization Validation Bypass**: The validation only checks if the first component is `ParentDir` [5](#0-4) , but does not check for `Prefix` (Windows drive letters) or `RootDir` components. Since the first component is now `Prefix('C')`, the check passes.

5. **Path Join Exploitation**: When the normalized subdir is joined with the checkout path [6](#0-5) , Rust's `PathBuf::join()` behavior causes absolute paths to **replace** the base path rather than being appended. Thus `checkout_path.join("C:\\sensitive\\directory")` returns `C:\sensitive\directory`.

6. **Arbitrary File Access**: The resolver then attempts to read `Move.toml` from this arbitrary location [7](#0-6) , allowing an attacker to probe the filesystem or potentially read sensitive files if they can control the contents.

The same vulnerability exists in the code path for local dependencies within git repositories [8](#0-7) .

## Impact Explanation

**Severity: High**

This vulnerability allows arbitrary file system access on Windows development and build systems, which could lead to:

1. **Information Disclosure**: Reading sensitive configuration files, credentials, or source code from arbitrary locations on Windows systems
2. **Validator Compromise**: If validator nodes build packages on Windows with access to private keys in the file system, those keys could be exfiltrated through error messages or by placing malicious Move.toml files at predictable locations
3. **Build System Compromise**: Development and CI/CD systems running on Windows could leak secrets during the package resolution process
4. **Supply Chain Attack**: Malicious dependencies could be injected into the Aptos ecosystem by compromising developer machines

While this is a build-time vulnerability rather than a runtime consensus issue, it falls under "Significant protocol violations" (High severity) as it breaks the fundamental security boundary that dependencies should be isolated to their repository scope.

## Likelihood Explanation

**Likelihood: Medium**

The attack requires:
- Target system running Windows (common for Move developers)
- Social engineering to add a malicious dependency, or compromise of an existing dependency
- Knowledge of the target file system layout to craft effective exploit paths

However, the attack is straightforward once understood, requires no special privileges, and the vulnerable code has explicitly untested Windows path handling as indicated by the TODO comment [9](#0-8) .

## Recommendation

Add comprehensive validation after normalization to detect absolute paths regardless of how they're constructed:

```rust
let normalized_subdir = NormalizedPath::new(&subdir);

// Check if the normalized path is absolute
if normalized_subdir.is_absolute() {
    bail!("subdir cannot resolve to an absolute path: {}", subdir.display());
}

// Check if the first component indicates escaping the repository
match normalized_subdir.components().next() {
    Some(std::path::Component::ParentDir) => {
        bail!("subdir outside of repo root: {}", subdir.display());
    }
    Some(std::path::Component::Prefix(_)) => {
        bail!("subdir cannot contain drive letter: {}", subdir.display());
    }
    Some(std::path::Component::RootDir) => {
        bail!("subdir cannot be a root path: {}", subdir.display());
    }
    _ => {}
}
```

This fix should be applied at both validation sites:
- Lines 367-372 for local dependencies within git repositories
- Lines 393-399 for direct git dependencies

Additionally, add comprehensive Windows path tests as indicated by the TODO to prevent regression.

## Proof of Concept

```rust
#[cfg(target_os = "windows")]
#[test]
fn test_windows_drive_letter_bypass() {
    use std::path::{Path, PathBuf, Component};
    
    // Simulate the attack: a path that appears relative but becomes absolute
    let malicious_path = Path::new("./C:/Windows/System32");
    
    // Pre-normalization: appears relative
    assert!(!malicious_path.is_absolute(), "Path should appear relative before normalization");
    
    // Normalize the path (simulating normalize_path behavior)
    let normalized = normalize_path(malicious_path);
    
    // Post-normalization: becomes absolute
    assert!(normalized.is_absolute(), "Path should be absolute after normalization");
    
    // The validation only checks for ParentDir, not Prefix
    let first_component = normalized.components().next();
    assert!(matches!(first_component, Some(Component::Prefix(_))), 
            "First component should be Prefix, bypassing ParentDir check");
    
    // When joined with a base path, it replaces instead of joining
    let checkout_path = PathBuf::from("C:\\Users\\user\\.aptos\\cache\\git\\repo");
    let joined = checkout_path.join(&normalized);
    
    assert_eq!(joined, normalized, "Absolute path should replace base path on join");
    assert!(joined.to_string_lossy().contains("C:\\Windows\\System32"), 
            "Attacker can access arbitrary paths");
}
```

**Notes**

This vulnerability is specific to Windows systems and exploits the combination of:
1. Windows path components (Prefix for drive letters) 
2. Rust's path normalization removing CurDir
3. Insufficient validation that only checks for `ParentDir` escapes

The issue does not affect Unix-like systems where drive letters don't exist. The explicit TODO comment about Windows testing confirms this code path has not been thoroughly validated on Windows platforms.

### Citations

**File:** third_party/move/tools/move-package-resolver/src/path.rs (L44-71)
```rust
fn normalize_path(path: impl AsRef<Path>) -> PathBuf {
    let path = path.as_ref();
    let mut stack = vec![];

    for component in path.components() {
        match &component {
            Component::CurDir => (),
            Component::ParentDir => match stack.last() {
                Some(Component::Prefix(_) | Component::RootDir) => (),
                Some(Component::Normal(_)) => {
                    stack.pop();
                },
                Some(Component::ParentDir) | None => {
                    stack.push(component);
                },
                Some(Component::CurDir) => unreachable!(),
            },
            Component::Prefix(_) | Component::RootDir | Component::Normal(_) => {
                stack.push(component);
            },
        }
    }

    stack
        .into_iter()
        .map(|c| c.as_os_str())
        .collect::<PathBuf>()
}
```

**File:** third_party/move/tools/move-package-resolver/src/path.rs (L130-130)
```rust
        // TODO: Add tests for Windows
```

**File:** third_party/move/tools/move-package-resolver/src/resolver.rs (L212-213)
```rust
            let checkout_path = package_cache.checkout_git_repo(git_url, *commit_id).await?;
            checkout_path.join(subdir)
```

**File:** third_party/move/tools/move-package-resolver/src/resolver.rs (L249-256)
```rust
            let manifest_path = local_path.join("Move.toml");
            let contents = fs::read_to_string(&manifest_path).map_err(|err| {
                anyhow!(
                    "failed to read package manifest at {}: {}",
                    manifest_path.display(),
                    err
                )
            })?;
```

**File:** third_party/move/tools/move-package-resolver/src/resolver.rs (L359-372)
```rust
                if local_path.is_absolute() {
                    bail!(
                        "local dependency in a git repo cannot be an absolute path: {}",
                        local_path.display()
                    );
                }

                let new_subdir = subdir.join(local_path);
                let normalized_new_subdir = NormalizedPath::new(&new_subdir);
                if let Some(std::path::Component::ParentDir) =
                    normalized_new_subdir.components().next()
                {
                    bail!("subdir outside of repo root: {}", new_subdir.display());
                }
```

**File:** third_party/move/tools/move-package-resolver/src/resolver.rs (L393-399)
```rust
            if subdir.is_absolute() {
                bail!("subdir cannot be an absolute path: {}", subdir.display());
            }
            let normalized_subdir = NormalizedPath::new(&subdir);
            if let Some(std::path::Component::ParentDir) = normalized_subdir.components().next() {
                bail!("subdir outside of repo root: {}", subdir.display());
            }
```
