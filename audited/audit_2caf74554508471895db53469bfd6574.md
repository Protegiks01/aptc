# Audit Report

## Title
Testnet OIDC Provider Configuration Can Be Applied to Mainnet Without Validation

## Summary
The `generate_jwk_consensus_config_update_proposal()` function does not validate that OIDC provider configurations are appropriate for the target network. A developer could accidentally create a mainnet governance proposal containing testnet-specific OIDC provider URLs, leading to keyless accounts on mainnet relying on insecure test identity providers.

## Finding Description

The JWK consensus configuration system allows on-chain governance to specify OIDC (OpenID Connect) providers that validators should monitor for JSON Web Keys, which are used for keyless account authentication. The release builder tool generates governance proposals to update these configurations.

The vulnerability exists in the proposal generation flow: [1](#0-0) 

This function accepts an `OnChainJWKConsensusConfig` parameter and an `is_testnet` boolean flag. However, it performs **no validation** to ensure that the OIDC providers in `config` are appropriate for the target network. The function blindly embeds the provider names and config_urls from the configuration into the generated Move script. [2](#0-1) 

The `is_testnet` flag is determined solely by the `execution_mode` in the YAML configuration file, but this doesn't validate the actual OIDC provider URLs in the configuration. [3](#0-2) 

The configuration object is passed directly from the deserialized YAML without any validation of the provider URLs.

The Move smart contract level also lacks validation: [4](#0-3) 

The `new_v1()` function only validates that provider names are unique (no duplicates), but does not validate that the URLs are appropriate for production use. [5](#0-4) 

The `new_oidc_provider()` function accepts any strings for `name` and `config_url` without validation.

**Attack Scenario:**
1. A developer creates a release YAML file with `execution_mode: MultiStep` (mainnet)
2. The `update_sequence` includes a `JwkConsensus` entry with testnet OIDC providers (e.g., `https://test-auth.example.com`, `http://localhost:8080`, or test servers like those shown in tests)
3. The release builder generates a valid mainnet governance proposal
4. The proposal gets approved through governance (assuming reviewers don't catch the error)
5. Upon execution, validators update their JWK consensus configuration to monitor the testnet OIDC providers
6. Keyless accounts on mainnet now rely on authentication from insecure test providers

Test examples demonstrate use of test OIDC providers: [6](#0-5) 

## Impact Explanation

**Severity: High**

This vulnerability meets the High severity criteria under "Significant protocol violations" because:

1. **Authentication Bypass Risk**: Testnet OIDC providers are not designed for production security. They may:
   - Use weak or test cryptographic keys
   - Lack proper SSL/TLS configuration
   - Have inadequate access controls
   - Be easily compromised by attackers

2. **Account Compromise**: If testnet providers are compromised, attackers could forge authentication tokens and take over keyless accounts on mainnet, potentially leading to theft of funds.

3. **Availability Issues**: Test servers may not have production-grade uptime guarantees, causing authentication failures for legitimate users.

4. **Trust Model Violation**: Mainnet users trust that identity providers meet production security standards. Using testnet providers violates this fundamental security assumption.

While this doesn't directly cause consensus violations or immediate fund loss, it creates a critical security vulnerability in the keyless account authentication system that could be exploited for account takeover and fund theft.

## Likelihood Explanation

**Likelihood: Medium**

This vulnerability is likely to occur because:

1. **Human Error**: Release configurations are complex YAML files that could easily contain copy-pasted testnet configurations
2. **No Automated Checks**: The codebase has no validation to catch this error
3. **Similar Test/Production Configs**: OIDC provider configurations for testnet and mainnet have the same structure, making mistakes easy
4. **Review Process Gaps**: Manual review might not catch subtle URL differences between test and production providers

The likelihood is not High because:
- Governance proposals require approval
- Multiple reviewers should examine proposals before approval
- The impact would be visible after deployment

However, relying solely on manual review without automated safeguards is insufficient for defense in depth.

## Recommendation

Add validation to `generate_jwk_consensus_config_update_proposal()` to verify OIDC provider configurations are appropriate for the target network:

```rust
pub fn generate_jwk_consensus_config_update_proposal(
    config: &OnChainJWKConsensusConfig,
    is_testnet: bool,
    next_execution_hash: Option<HashValue>,
    is_multi_step: bool,
) -> anyhow::Result<Vec<(String, String)>> {
    // Validate OIDC providers for mainnet
    if !is_testnet {
        validate_mainnet_oidc_providers(config)?;
    }
    
    // ... rest of function
}

fn validate_mainnet_oidc_providers(config: &OnChainJWKConsensusConfig) -> anyhow::Result<()> {
    if let OnChainJWKConsensusConfig::V1(v1) = config {
        // Whitelist of approved production OIDC providers
        const APPROVED_MAINNET_PROVIDERS: &[&str] = &[
            "https://accounts.google.com",
            "https://appleid.apple.com",
            // Add other approved providers
        ];
        
        for provider in v1.oidc_providers.iter() {
            // Check if provider name starts with an approved domain
            if !APPROVED_MAINNET_PROVIDERS.iter().any(|approved| provider.name.starts_with(approved)) {
                anyhow::bail!(
                    "Mainnet proposal contains non-approved OIDC provider: {}. Only production providers are allowed.",
                    provider.name
                );
            }
            
            // Validate config_url is HTTPS and matches expected pattern
            if !provider.config_url.starts_with("https://") {
                anyhow::bail!(
                    "Mainnet OIDC provider config_url must use HTTPS: {}",
                    provider.config_url
                );
            }
            
            // Additional checks for localhost, test domains, etc.
            if provider.config_url.contains("localhost") 
                || provider.config_url.contains("127.0.0.1")
                || provider.config_url.contains(".test")
                || provider.config_url.contains(".dev") {
                anyhow::bail!(
                    "Mainnet proposal contains test/local OIDC provider URL: {}",
                    provider.config_url
                );
            }
        }
    }
    Ok(())
}
```

Additionally, add a similar check in the Move smart contract as a second line of defense, using a feature flag or on-chain registry of approved providers.

## Proof of Concept

**Reproduction Steps:**

1. Create a malicious release YAML file `testnet_leak.yaml`:
```yaml
name: malicious_release
remote_endpoint: ~
proposals:
  - name: jwk_config_leak
    metadata:
      title: "JWK Configuration Update"
      description: "Update JWK consensus configuration"
    execution_mode: MultiStep  # This targets MAINNET
    update_sequence:
      - JwkConsensus:
          V1:
            oidc_providers:
              - name: "https://test-auth.example.com"  # TESTNET PROVIDER!
                config_url: "https://test-auth.example.com/.well-known/openid-configuration"
              - name: "http://localhost:8080"  # LOCALHOST!
                config_url: "http://localhost:8080/.well-known/openid-configuration"
```

2. Run the release builder:
```bash
cargo run --bin aptos-release-builder -- \
    --config testnet_leak.yaml \
    --output-dir ./malicious_output
```

3. The tool will successfully generate a mainnet governance proposal script containing testnet OIDC providers without any warnings or errors.

4. Examine the generated Move script in `./malicious_output/sources/malicious_release/jwk_config_leak/0-jwk-consensus-config.move`:
```move
script {
    use aptos_framework::aptos_governance;
    use aptos_framework::jwk_consensus_config;
    use std::string::utf8;
    
    fun main(proposal_id: u64) {
        let framework_signer = aptos_governance::resolve_multi_step_proposal(/*...*/);
        let config = jwk_consensus_config::new_v1(vector[
            jwk_consensus_config::new_oidc_provider(utf8(b"https://test-auth.example.com"), utf8(b"https://test-auth.example.com/.well-known/openid-configuration")),
            jwk_consensus_config::new_oidc_provider(utf8(b"http://localhost:8080"), utf8(b"http://localhost:8080/.well-known/openid-configuration")),
        ]);
        jwk_consensus_config::set_for_next_epoch(&framework_signer, config);
        aptos_governance::reconfigure(&framework_signer);
    }
}
```

The generated proposal contains testnet/localhost OIDC providers but targets mainnet execution, demonstrating the lack of validation.

## Notes

This vulnerability represents a **defense-in-depth failure** where the system lacks safeguards against configuration errors. While governance approval provides some protection, automated validation is essential to prevent accidents that could compromise the security of keyless accounts on mainnet. The fix should implement both Rust-level validation during proposal generation and Move-level validation during on-chain execution.

### Citations

**File:** aptos-move/aptos-release-builder/src/components/jwk_consensus_config.rs (L9-50)
```rust
pub fn generate_jwk_consensus_config_update_proposal(
    config: &OnChainJWKConsensusConfig,
    is_testnet: bool,
    next_execution_hash: Option<HashValue>,
    is_multi_step: bool,
) -> anyhow::Result<Vec<(String, String)>> {
    let signer_arg = get_signer_arg(is_testnet, &next_execution_hash);
    let mut result = vec![];

    let writer = CodeWriter::new(Loc::default());

    let proposal = generate_governance_proposal(
        &writer,
        is_testnet,
        next_execution_hash,
        is_multi_step,
        &["aptos_framework::jwk_consensus_config", "std::string::utf8"],
        |writer| {
            match config {
                OnChainJWKConsensusConfig::Off => {
                    emitln!(writer, "jwk_consensus_config::set_for_next_epoch({}, jwk_consensus_config::new_off());", signer_arg);
                },
                OnChainJWKConsensusConfig::V1(v1) => {
                    emitln!(writer, "let config = jwk_consensus_config::new_v1(vector[");
                    for p in v1.oidc_providers.iter() {
                        emitln!(writer, "jwk_consensus_config::new_oidc_provider(utf8(b\"{}\"), utf8(b\"{}\")),", p.name, p.config_url);
                    }
                    emitln!(writer, "]);");
                    emitln!(
                        writer,
                        "jwk_consensus_config::set_for_next_epoch({}, config);",
                        signer_arg
                    );
                },
            }
            emitln!(writer, "aptos_governance::reconfigure({});", signer_arg);
        },
    );

    result.push(("jwk-consensus-config".to_string(), proposal));
    Ok(result)
}
```

**File:** aptos-move/aptos-release-builder/src/components/mod.rs (L224-227)
```rust
        let (is_testnet, is_multi_step) = match execution_mode {
            ExecutionMode::MultiStep => (false, true),
            ExecutionMode::RootSigner => (true, false),
        };
```

**File:** aptos-move/aptos-release-builder/src/components/mod.rs (L420-432)
```rust
            ReleaseEntry::JwkConsensus(config) => {
                result.append(
                    &mut jwk_consensus_config::generate_jwk_consensus_config_update_proposal(
                        config,
                        is_testnet,
                        if is_multi_step {
                            get_execution_hash(result)
                        } else {
                            None
                        },
                        is_multi_step,
                    )?,
                );
```

**File:** aptos-move/framework/aptos-framework/sources/configs/jwk_consensus_config.move (L90-102)
```text
    public fun new_v1(oidc_providers: vector<OIDCProvider>): JWKConsensusConfig {
        let name_set = simple_map::new<String, u64>();
        vector::for_each_ref(&oidc_providers, |provider| {
            let provider: &OIDCProvider = provider;
            let (_, old_value) = simple_map::upsert(&mut name_set, provider.name, 0);
            if (option::is_some(&old_value)) {
                abort(error::invalid_argument(EDUPLICATE_PROVIDERS))
            }
        });
        JWKConsensusConfig {
            variant: copyable_any::pack( ConfigV1 { oidc_providers } )
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/jwk_consensus_config.move (L105-107)
```text
    public fun new_oidc_provider(name: String, config_url: String): OIDCProvider {
        OIDCProvider { name, config_url }
    }
```

**File:** testsuite/smoke-test/src/jwks/jwk_consensus_per_key.rs (L69-86)
```rust
    let alice_issuer_id = "https://alice.io";
    let bob_issuer_id = "https://bob.dev";
    alice_config_server.update_request_handler(Some(Arc::new(StaticContentServer::new_str(
        format!(
            r#"{{"issuer": "{}", "jwks_uri": "{}"}}"#,
            alice_issuer_id,
            alice_jwks_server.url()
        )
        .as_str(),
    ))));
    bob_config_server.update_request_handler(Some(Arc::new(StaticContentServer::new_str(
        format!(
            r#"{{"issuer": "{}", "jwks_uri": "{}"}}"#,
            bob_issuer_id,
            bob_jwks_server.url()
        )
        .as_str(),
    ))));
```
