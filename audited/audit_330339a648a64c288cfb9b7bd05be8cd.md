# Audit Report

## Title
Private Key Memory Residue Vulnerability in ValidCryptoMaterialStringExt::to_encoded_string()

## Summary
The `ValidCryptoMaterialStringExt::to_encoded_string()` method creates unzeroized heap allocations containing private key material in both raw bytes and hex-encoded forms. This violates the project's documented secure coding guidelines and exposes private keys to memory-based extraction attacks through core dumps, memory dumps, or process memory inspection.

## Finding Description

The `ValidCryptoMaterialStringExt` trait provides a blanket implementation for encoding cryptographic material to strings. [1](#0-0) 

When this method is invoked on private keys (as done in the aptos-keygen tool [2](#0-1) ), it creates two sensitive heap allocations:

1. A `Vec<u8>` containing raw private key bytes via `self.to_bytes()` [3](#0-2) 

2. A `String` containing the hex-encoded private key via `hex::encode()`

Neither allocation is zeroized before being dropped, leaving private key material in heap memory indefinitely until that memory is reused and overwritten.

This directly violates the project's **RUST_SECURE_CODING.md** security guidelines, which explicitly state: [4](#0-3) 

Furthermore, the guidelines require: [5](#0-4) 

However, the `aptos-crypto` crate does not include `zeroize` as a dependency [6](#0-5)  and no private key type implements `Drop` with zeroization (confirmed via grep search showing zero implementations).

The vulnerability affects all private key types: Ed25519, secp256k1, secp256r1, BLS12-381, SLH-DSA, and X25519, as they all use the same trait implementation.

## Impact Explanation

This is a **High Severity** vulnerability as indicated in the security question. The impact includes:

1. **Private Key Exposure via Memory Dumps**: If a validator node or key generation process crashes and produces a core dump, the private keys will be present in the dump file in both raw and hex-encoded forms.

2. **Process Memory Reading**: An attacker with sufficient privileges (or exploiting another vulnerability) can read process memory via `/proc/[pid]/mem` on Linux or similar mechanisms on other platforms to extract active or recently-used private keys.

3. **Memory Forensics**: On compromised systems or seized hardware, memory forensics tools can recover private keys from RAM or swap space even after the process has terminated.

4. **Cloud Environment Risks**: In cloud/containerized environments, memory snapshots or memory introspection features could inadvertently expose private keys.

While this doesn't directly cause "Loss of Funds" or "Consensus/Safety violations" (Critical severity), it creates a significant attack surface for private key theft, qualifying as a **High Severity** protocol violation and validator node security issue.

## Likelihood Explanation

The likelihood varies by context:

- **High** for systems with debugging enabled, core dumps enabled, or running in untrusted environments
- **Medium** for hardened production systems where an attacker would first need to compromise the system
- **Low** for airgapped systems with physical security

The vulnerability is **always present** when `to_encoded_string()` is called on private keys, but exploitation requires additional conditions (memory access capability). However, the fact that it violates explicit security guidelines makes it unacceptable regardless of exploitation difficulty.

## Recommendation

1. **Add zeroize dependency** to `aptos-crypto/Cargo.toml`:
```toml
zeroize = { version = "1.7", features = ["derive"] }
```

2. **Implement Drop with zeroization** for all private key types. Example for Ed25519PrivateKey:
```rust
impl Drop for Ed25519PrivateKey {
    fn drop(&mut self) {
        use zeroize::Zeroize;
        // Zeroize the underlying ed25519_dalek::SecretKey bytes
        let mut bytes = self.0.to_bytes();
        bytes.zeroize();
    }
}
```

3. **Create a zeroizing wrapper** for the `to_encoded_string()` implementation:
```rust
fn to_encoded_string(&self) -> Result<String> {
    use zeroize::Zeroize;
    let mut bytes = self.to_bytes();
    let encoded = format!("0x{}", ::hex::encode(&bytes));
    bytes.zeroize(); // Explicitly zero the Vec<u8>
    Ok(encoded)
}
```

Note: The returned `String` still contains the key (by design for serialization), so callers must handle it appropriately.

4. **Apply similar treatment** to all other private key types (secp256k1, secp256r1, BLS12-381, SLH-DSA, X25519).

## Proof of Concept

```rust
// File: test_memory_residue.rs
use aptos_crypto::{ed25519::Ed25519PrivateKey, Uniform, ValidCryptoMaterialStringExt};
use std::ptr;

#[test]
fn test_private_key_memory_residue() {
    let privkey = Ed25519PrivateKey::generate_for_testing();
    let original_bytes = privkey.to_bytes();
    
    // Call to_encoded_string() which should zeroize intermediate values
    let encoded = privkey.to_encoded_string().unwrap();
    
    // Drop the encoded string
    drop(encoded);
    
    // In a real exploit, an attacker would scan process heap memory
    // and find the unzeroized private key bytes
    // This PoC demonstrates the issue conceptually:
    // After to_encoded_string() returns, the Vec<u8> containing
    // original_bytes is deallocated but NOT zeroized.
    
    println!("Private key was exposed in memory without zeroization");
    println!("Original bytes would be recoverable from heap inspection");
}
```

To demonstrate the actual memory residue, one could:
1. Use a memory profiling tool like Valgrind or a heap inspector
2. Examine core dumps after intentional crashes
3. Use debugger commands to inspect heap memory after the function returns

## Notes

While the `aptos-keygen` tool intentionally outputs private keys (making memory exposure somewhat less critical in that specific context), the vulnerability exists in the **trait implementation** itself, which is used throughout the codebase including in serialization contexts [7](#0-6)  where unintentional exposure is a legitimate security concern.

The broader issue is that all private key types in the `aptos-crypto` crate lack proper memory zeroization, contradicting the project's own security standards.

### Citations

**File:** crates/aptos-crypto/src/traits/mod.rs (L102-104)
```rust
    fn to_encoded_string(&self) -> Result<String> {
        Ok(format!("0x{}", ::hex::encode(self.to_bytes())))
    }
```

**File:** crates/aptos-keygen/src/main.rs (L13-13)
```rust
    println!("{}", privkey.to_encoded_string().unwrap());
```

**File:** crates/aptos-crypto/src/ed25519/ed25519_keys.rs (L229-231)
```rust
    fn to_bytes(&self) -> Vec<u8> {
        self.to_bytes().to_vec()
    }
```

**File:** RUST_SECURE_CODING.md (L96-96)
```markdown
Do not rely on `Drop` trait in security material treatment after the use, use [zeroize](https://docs.rs/zeroize/latest/zeroize/#) to explicit destroy security material, e.g. private keys.
```

**File:** RUST_SECURE_CODING.md (L145-145)
```markdown
Use [zeroize](https://docs.rs/zeroize/latest/zeroize/#) for zeroing memory containing sensitive data.
```

**File:** crates/aptos-crypto/Cargo.toml (L15-76)
```text
[dependencies]
aes-gcm = { workspace = true }
anyhow = { workspace = true }
aptos-crypto-derive = { workspace = true }
arbitrary = { workspace = true, features = ["derive"], optional = true }
ark-bls12-381 = { workspace = true }
ark-bn254 = { workspace = true }
ark-ec = { workspace = true }
ark-ff = { workspace = true }
ark-groth16 = { workspace = true }
ark-poly = { workspace = true }
ark-relations = { workspace = true }
ark-serialize = { workspace = true }
ark-snark = { workspace = true }
ark-std = { workspace = true }
base64 = { workspace = true }
bcs = { workspace = true }
bls12_381 = { workspace = true }
blst = { workspace = true }
blstrs = { workspace = true }
bulletproofs = { workspace = true }
bytes = { workspace = true }
curve25519-dalek = { workspace = true }
curve25519-dalek-ng = { workspace = true }
digest = { workspace = true }
dudect-bencher = { workspace = true }
ed25519-dalek = { workspace = true }
ff = { workspace = true }
group = { workspace = true }
hex = { workspace = true }
hkdf = { workspace = true }
itertools = { workspace = true }
libsecp256k1 = { workspace = true }
merlin = { workspace = true }
more-asserts = { workspace = true }
neptune = { workspace = true }
num-bigint = { workspace = true }
num-integer = { workspace = true }
num-traits = { workspace = true }
once_cell = { workspace = true }
p256 = { workspace = true }
pairing = { workspace = true }
proptest = { workspace = true, optional = true }
proptest-derive = { workspace = true, optional = true }
rand = { workspace = true }
rand_core = { workspace = true }
rayon = { workspace = true }
ring = { workspace = true }
serde = { workspace = true }
serde-name = { workspace = true }
serde_bytes = { workspace = true }
sha2 = { workspace = true }
sha2_0_10_6 = { workspace = true }
sha3 = { workspace = true }
signature = { workspace = true }
slh-dsa = { workspace = true }
static_assertions = { workspace = true }
thiserror = { workspace = true }
tiny-keccak = { workspace = true }
typenum = { workspace = true }
x25519-dalek = { workspace = true }

```

**File:** crates/aptos-crypto-derive/src/lib.rs (L196-199)
```rust
                if serializer.is_human_readable() {
                    self.to_encoded_string()
                        .map_err(<S::Error as ::serde::ser::Error>::custom)
                        .and_then(|str| serializer.serialize_str(&str[..]))
```
