# Audit Report

## Title
SignedBatchInfoMsg Total Size Limit Bypass Enables Resource Exhaustion Attack

## Summary
The `SignedBatchInfoMsg::verify()` function only validates the number of batches in a message but fails to enforce total transaction and byte limits across all batches. This allows malicious validators to bypass intended resource limits by sending messages with multiple batches whose combined size exceeds the configured `receiver_max_total_txns` and `receiver_max_total_bytes` limits, potentially causing memory exhaustion and network resource depletion on victim nodes.

## Finding Description
The Aptos Quorum Store implements two separate limits for incoming batch messages:
1. **Per-message batch count limit** (`receiver_max_num_batches`: 20 by default)
2. **Per-message total size limits** (`receiver_max_total_txns`: 2000, `receiver_max_total_bytes`: ~4MB by default)

These limits are intended to prevent any single network message from consuming excessive node resources.

For `BatchMsg` messages containing actual batch data, both limits are properly enforced: [1](#0-0) 

However, for `SignedBatchInfoMsg` messages (used for signature collection), only the batch count is verified: [2](#0-1) 

The verification checks that `signed_infos.len() <= max_num_batches` but never validates the total claimed transactions or bytes across all batches in the message. Each `SignedBatchInfo` contains a `BatchInfo` with `num_txns` and `num_bytes` fields that represent the claimed batch size, but these are never summed and checked against total limits.

**Attack Scenario:**
1. Malicious validator creates 20 batches, each claiming maximum individual size (e.g., 100 txns, 1MB each based on receiver limits)
2. Validator signs these batch infos and sends them in a single `SignedBatchInfoMsg`
3. The message passes verification despite containing 2000 txns and 20MB total (5x the `receiver_max_total_bytes` limit of 4MB)
4. Victim nodes process and store signature aggregation state for all 20 batches
5. The `ProofCoordinator` maintains this state in memory without enforcing total size limits [3](#0-2) 

The configuration clearly defines these total limits: [4](#0-3) 

## Impact Explanation
This vulnerability enables **High Severity** resource exhaustion attacks:

1. **Memory Exhaustion**: Each `SignedBatchInfo` creates proof aggregation state in `ProofCoordinator`. An attacker can flood nodes with messages containing maximum batches per message, exhausting memory.

2. **Network Amplification**: When proofs are formed and broadcast, the total payload size is larger than intended limits, consuming excessive bandwidth.

3. **CPU Overhead**: Signature verification and proof aggregation for oversized batches wastes computational resources.

4. **Validator Node Slowdowns**: Repeated malicious messages can degrade node performance, potentially affecting consensus participation.

This aligns with **High Severity** criteria per the Aptos bug bounty program: "Validator node slowdowns" and "Significant protocol violations" (violation of documented resource limit invariants).

## Likelihood Explanation
**Likelihood: HIGH**

- **Attacker Requirements**: Any validator with valid credentials can craft and send malicious `SignedBatchInfoMsg` messages. No special privileges or collusion required beyond being a validator.

- **Attack Complexity**: Low - attacker simply needs to construct `BatchInfo` structures with inflated `num_txns`/`num_bytes` values and sign them.

- **Detection Difficulty**: The attack blends with normal signature collection traffic, making it hard to distinguish from legitimate behavior until resource exhaustion occurs.

- **Repeatability**: Attacker can send multiple such messages continuously to amplify the attack.

## Recommendation
Add total size validation to `SignedBatchInfoMsg::verify()` similar to how `BatchCoordinator` enforces these limits:

```rust
pub fn verify(
    &self,
    sender: PeerId,
    max_num_batches: usize,
    max_batch_expiry_gap_usecs: u64,
    max_total_txns: u64,  // ADD THIS PARAMETER
    max_total_bytes: u64, // ADD THIS PARAMETER
    validator: &ValidatorVerifier,
) -> anyhow::Result<()> {
    ensure!(!self.signed_infos.is_empty(), "Empty message");
    ensure!(
        self.signed_infos.len() <= max_num_batches,
        "Too many batches: {} > {}",
        self.signed_infos.len(),
        max_num_batches
    );
    
    // ADD TOTAL SIZE CHECKING
    let mut total_txns = 0u64;
    let mut total_bytes = 0u64;
    
    for signed_info in &self.signed_infos {
        signed_info.verify(sender, max_batch_expiry_gap_usecs, validator)?;
        total_txns += signed_info.num_txns();
        total_bytes += signed_info.num_bytes();
    }
    
    ensure!(
        total_txns <= max_total_txns,
        "Exceeds total txn limit {} > {}",
        total_txns,
        max_total_txns
    );
    ensure!(
        total_bytes <= max_total_bytes,
        "Exceeds total bytes limit {} > {}",
        total_bytes,
        max_total_bytes
    );
    
    Ok(())
}
```

Update all call sites in `round_manager.rs` to pass the additional parameters from the quorum store configuration.

## Proof of Concept
```rust
// Proof of Concept: Construct malicious SignedBatchInfoMsg

use aptos_consensus_types::proof_of_store::{BatchInfo, SignedBatchInfo, SignedBatchInfoMsg};
use aptos_types::validator_signer::ValidatorSigner;
use aptos_crypto::HashValue;

fn create_attack_message(
    signer: &ValidatorSigner,
    epoch: u64,
) -> SignedBatchInfoMsg<BatchInfo> {
    let mut signed_infos = Vec::new();
    
    // Create 20 batches, each claiming maximum individual size
    for i in 0..20 {
        let batch_info = BatchInfo::new(
            signer.author(),
            i.into(),  // batch_id
            epoch,
            aptos_infallible::duration_since_epoch().as_micros() as u64 + 60_000_000, // +60s
            HashValue::random(),
            100,  // num_txns: maximum individual batch limit
            1024 * 1024,  // num_bytes: 1MB per batch
            0,  // gas_bucket_start
        );
        
        let signed_info = SignedBatchInfo::new(batch_info, signer)
            .expect("Failed to sign");
        signed_infos.push(signed_info);
    }
    
    SignedBatchInfoMsg::new(signed_infos)
    // Total: 2000 txns, 20MB - bypasses 4MB receiver_max_total_bytes limit
}

#[test]
fn test_batch_limit_bypass() {
    let signer = ValidatorSigner::random(None);
    let validator_verifier = /* create verifier */;
    
    let malicious_msg = create_attack_message(&signer, 1);
    
    // This should FAIL but currently PASSES
    let result = malicious_msg.verify(
        signer.author(),
        20,  // max_num_batches
        60_000_000,  // max_batch_expiry_gap_usecs
        &validator_verifier,
    );
    
    assert!(result.is_ok()); // Vulnerability: passes despite exceeding total limits
    
    // Total size is 20MB but receiver_max_total_bytes is only 4MB
    let total_bytes: u64 = malicious_msg.take().iter()
        .map(|info| info.num_bytes())
        .sum();
    assert_eq!(total_bytes, 20 * 1024 * 1024); // 20MB > 4MB limit
}
```

**Notes**
- This vulnerability specifically affects the signature collection phase of the Quorum Store protocol, separate from the batch data transmission phase
- The attack exploits the asymmetry between `BatchMsg` validation (which has comprehensive size checks) and `SignedBatchInfoMsg` validation (which only checks batch count)
- The fix requires passing `receiver_max_total_txns` and `receiver_max_total_bytes` configuration parameters through the verification call chain from `round_manager.rs` where they are available from the quorum store config

### Citations

**File:** consensus/src/quorum_store/batch_coordinator.rs (L137-171)
```rust
    fn ensure_max_limits(&self, batches: &[Batch<BatchInfoExt>]) -> anyhow::Result<()> {
        let mut total_txns = 0;
        let mut total_bytes = 0;
        for batch in batches.iter() {
            ensure!(
                batch.num_txns() <= self.max_batch_txns,
                "Exceeds batch txn limit {} > {}",
                batch.num_txns(),
                self.max_batch_txns,
            );
            ensure!(
                batch.num_bytes() <= self.max_batch_bytes,
                "Exceeds batch bytes limit {} > {}",
                batch.num_bytes(),
                self.max_batch_bytes,
            );

            total_txns += batch.num_txns();
            total_bytes += batch.num_bytes();
        }
        ensure!(
            total_txns <= self.max_total_txns,
            "Exceeds total txn limit {} > {}",
            total_txns,
            self.max_total_txns,
        );
        ensure!(
            total_bytes <= self.max_total_bytes,
            "Exceeds total bytes limit: {} > {}",
            total_bytes,
            self.max_total_bytes,
        );

        Ok(())
    }
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L363-381)
```rust
    pub fn verify(
        &self,
        sender: PeerId,
        max_num_batches: usize,
        max_batch_expiry_gap_usecs: u64,
        validator: &ValidatorVerifier,
    ) -> anyhow::Result<()> {
        ensure!(!self.signed_infos.is_empty(), "Empty message");
        ensure!(
            self.signed_infos.len() <= max_num_batches,
            "Too many batches: {} > {}",
            self.signed_infos.len(),
            max_num_batches
        );
        for signed_info in &self.signed_infos {
            signed_info.verify(sender, max_batch_expiry_gap_usecs, validator)?
        }
        Ok(())
    }
```

**File:** consensus/src/quorum_store/network_listener.rs (L57-66)
```rust
                    VerifiedEvent::SignedBatchInfo(signed_batch_infos) => {
                        counters::QUORUM_STORE_MSG_COUNT
                            .with_label_values(&["NetworkListener::signedbatchinfo"])
                            .inc();
                        let cmd =
                            ProofCoordinatorCommand::AppendSignature(sender, *signed_batch_infos);
                        self.proof_coordinator_tx
                            .send(cmd)
                            .await
                            .expect("Could not send signed_batch_info to proof_coordinator");
```

**File:** config/src/config/quorum_store_config.rs (L76-83)
```rust
    /// The maximum number of batches a BatchMsg received from peers can contain.
    pub receiver_max_num_batches: usize,
    /// The maximum number of transactions a BatchMsg received from peers can contain. Each BatchMsg can contain
    /// multiple batches.
    pub receiver_max_total_txns: usize,
    /// The maximum number of bytes a BatchMsg received from peers can contain. Each BatchMsg can contain
    /// multiple batches.
    pub receiver_max_total_bytes: usize,
```
