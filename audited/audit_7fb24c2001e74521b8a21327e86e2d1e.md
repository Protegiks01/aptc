# Audit Report

## Title
Missing Quorum Certificate Validation in Block Retrieval Allows Consensus Safety Violation

## Summary
During block synchronization, when blocks are retrieved from the network to fill missing ancestors, the system fails to validate that embedded Quorum Certificates (QCs) represent valid quorums with >2/3 voting power. This allows malicious peers to provide blocks with insufficient signatures, violating AptosBFT consensus safety guarantees.

## Finding Description

When a node needs to synchronize missing blocks, it retrieves them from peers via the block retrieval mechanism. The vulnerability exists in the block retrieval code path where `BlockRetrievalResponse::verify()` exists but is never called. [1](#0-0) 

The `verify()` method correctly validates each block's signature (including its embedded QC) by calling `block.validate_signature(sig_verifier)`, which chains through to `quorum_cert().verify()` to check voting power. [2](#0-1) 

However, in the actual retrieval path, responses are used without validation: [3](#0-2) 

The `retrieve_block_chunk` method returns responses at line 728 without calling `verify()`. These unvalidated blocks flow through `retrieve_blocks` to `fetch_quorum_cert`: [4](#0-3) 

At lines 265-266, the QC from retrieved blocks is inserted via `insert_single_quorum_cert` without validation. This method only checks structural consistency but not cryptographic validity: [5](#0-4) 

The invalid QC is then sent through the pipeline via `set_qc` and eventually used in `materialize_block`: [6](#0-5) 

At line 57, when `block_qc_fut` resolves, the QC's voter information is used directly without any validation that it represents a valid quorum (>2/3 voting power).

The proper validation exists in the codebase and correctly checks voting power: [7](#0-6) [8](#0-7) 

The quorum voting power threshold is correctly set at `total_voting_power * 2 / 3 + 1`: [9](#0-8) 

But this validation chain is bypassed entirely in the block retrieval path.

## Impact Explanation

**Critical Severity** - This vulnerability breaks the fundamental consensus safety invariant of AptosBFT:

1. **Consensus Safety Violation**: Blocks can be certified with QCs containing insufficient signatures (<2/3 voting power), violating the Byzantine fault tolerance guarantee that assumes <1/3 Byzantine validators.

2. **Chain Split Risk**: Different honest nodes could accept different blocks as valid if they receive conflicting blocks with invalid QCs from malicious peers during synchronization.

3. **Quorum Certificate Forgery**: A single malicious peer (or small coalition <1/3) can provide blocks with forged QCs during block retrieval, and these will be accepted and integrated into the consensus state.

This meets the Critical Severity criteria: "Consensus/Safety violations" that could lead to "Non-recoverable network partition (requires hardfork)".

## Likelihood Explanation

**High Likelihood**:

1. **Common Trigger**: Block retrieval occurs regularly during normal operation when nodes fall behind or restart
2. **Easy Exploitation**: Any peer can respond to block retrieval requests with malicious blocks
3. **No Special Privileges Required**: Attacker only needs to be selected as a peer for block retrieval (random selection from QC voters)
4. **Silent Failure**: Invalid QCs are accepted without error, making the attack undetectable until consensus divergence occurs

## Recommendation

Add proper validation by calling `BlockRetrievalResponse::verify()` before using retrieved blocks:

```rust
// In retrieve_block_chunk, around line 728:
match response {
    Ok(result) => {
        // CRITICAL FIX: Validate the response before accepting it
        result.verify(request.clone(), &self.verifier)?;
        return Ok(result)
    },
    e => {
        // ... existing error handling
    }
}
```

Additionally, add validation in `fetch_quorum_cert` before inserting QCs:

```rust
// In fetch_quorum_cert, before line 266:
block_qc.verify(&self.epoch_state.verifier)?;
self.insert_single_quorum_cert(block_qc)?;
```

## Proof of Concept

**Rust Test Scenario:**

```rust
// Create a malicious peer that responds to block retrieval with invalid QCs
// 1. Set up honest validator set with 100 voting power distributed across 4 validators
// 2. Create a block with a QC that only has 1 signature (25 voting power < 67 required)
// 3. Honest node requests missing blocks via fetch_quorum_cert
// 4. Malicious peer responds with block containing invalid QC
// 5. Verify that insert_single_quorum_cert succeeds (vulnerability)
// 6. Verify that the QC is set on the block without validation
// 7. Verify that materialize_block uses the invalid QC

// Expected: The invalid QC should be rejected
// Actual: The invalid QC is accepted and used in consensus
```

**Attack Steps:**

1. Attacker runs a malicious peer node
2. Honest validator V falls behind and needs to sync
3. V receives SyncInfo with a valid high QC from another validator
4. V calls `fetch_quorum_cert` to retrieve missing ancestor blocks
5. Attacker's peer is selected (from QC voters list) for block retrieval
6. Attacker responds with blocks containing QCs with <2/3 signatures
7. V accepts these blocks and inserts invalid QCs into its block store
8. V uses these invalid QCs in its consensus pipeline
9. Consensus safety is violated - V has accepted blocks as certified without proper quorum

## Notes

This vulnerability exists because the defensive validation mechanism (`BlockRetrievalResponse::verify()`) was implemented but never integrated into the actual code path. The validation logic is complete and correct, but the critical call site is missing. This is a classic example of defense-in-depth that was partially implemented but not completed.

### Citations

**File:** consensus/consensus-types/src/block_retrieval.rs (L260-281)
```rust
    pub fn verify(
        &self,
        retrieval_request: BlockRetrievalRequest,
        sig_verifier: &ValidatorVerifier,
    ) -> anyhow::Result<()> {
        self.verify_inner(&retrieval_request)?;

        self.blocks
            .iter()
            .try_fold(retrieval_request.block_id(), |expected_id, block| {
                block.validate_signature(sig_verifier)?;
                block.verify_well_formed()?;
                ensure!(
                    block.id() == expected_id,
                    "blocks doesn't form a chain: expect {}, get {}",
                    expected_id,
                    block.id()
                );
                Ok(block.parent_id())
            })
            .map(|_| ())
    }
```

**File:** consensus/consensus-types/src/block.rs (L425-464)
```rust
    pub fn validate_signature(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        match self.block_data.block_type() {
            BlockType::Genesis => bail!("We should not accept genesis from others"),
            BlockType::NilBlock { .. } => self.quorum_cert().verify(validator),
            BlockType::Proposal { author, .. } => {
                let signature = self
                    .signature
                    .as_ref()
                    .ok_or_else(|| format_err!("Missing signature in Proposal"))?;
                let (res1, res2) = rayon::join(
                    || validator.verify(*author, &self.block_data, signature),
                    || self.quorum_cert().verify(validator),
                );
                res1?;
                res2
            },
            BlockType::ProposalExt(proposal_ext) => {
                let signature = self
                    .signature
                    .as_ref()
                    .ok_or_else(|| format_err!("Missing signature in Proposal"))?;
                let (res1, res2) = rayon::join(
                    || validator.verify(*proposal_ext.author(), &self.block_data, signature),
                    || self.quorum_cert().verify(validator),
                );
                res1?;
                res2
            },
            BlockType::OptimisticProposal(p) => {
                // Note: Optimistic proposal is not signed by proposer unlike normal proposal
                let (res1, res2) = rayon::join(
                    || p.grandparent_qc().verify(validator),
                    || self.quorum_cert().verify(validator),
                );
                res1?;
                res2
            },
            BlockType::DAGBlock { .. } => bail!("We should not accept DAG block from others"),
        }
    }
```

**File:** consensus/src/block_storage/sync_manager.rs (L233-270)
```rust
    async fn fetch_quorum_cert(
        &self,
        qc: QuorumCert,
        retriever: &mut BlockRetriever,
    ) -> anyhow::Result<()> {
        let mut pending = vec![];
        let mut retrieve_qc = qc.clone();
        loop {
            if self.block_exists(retrieve_qc.certified_block().id()) {
                break;
            }
            BLOCKS_FETCHED_FROM_NETWORK_WHILE_INSERTING_QUORUM_CERT.inc_by(1);
            let target_block_retrieval_payload = match &self.window_size {
                None => TargetBlockRetrieval::TargetBlockId(retrieve_qc.certified_block().id()),
                Some(_) => TargetBlockRetrieval::TargetRound(retrieve_qc.certified_block().round()),
            };
            let mut blocks = retriever
                .retrieve_blocks_in_range(
                    retrieve_qc.certified_block().id(),
                    1,
                    target_block_retrieval_payload,
                    qc.ledger_info()
                        .get_voters(&retriever.validator_addresses()),
                )
                .await?;
            // retrieve_blocks_in_range guarantees that blocks has exactly 1 element
            let block = blocks.remove(0);
            retrieve_qc = block.quorum_cert().clone();
            pending.push(block);
        }
        // insert the qc <- block pair
        while let Some(block) = pending.pop() {
            let block_qc = block.quorum_cert().clone();
            self.insert_single_quorum_cert(block_qc)?;
            self.insert_block(block).await?;
        }
        self.insert_single_quorum_cert(qc)
    }
```

**File:** consensus/src/block_storage/sync_manager.rs (L667-779)
```rust
    async fn retrieve_block_chunk(
        &mut self,
        block_id: HashValue,
        target_block_retrieval_payload: TargetBlockRetrieval,
        retrieve_batch_size: u64,
        mut peers: Vec<AccountAddress>,
    ) -> anyhow::Result<BlockRetrievalResponse> {
        let mut failed_attempt = 0_u32;
        let mut cur_retry = 0;

        let num_retries = NUM_RETRIES;
        let request_num_peers = NUM_PEERS_PER_RETRY;
        let retry_interval = Duration::from_millis(RETRY_INTERVAL_MSEC);
        let rpc_timeout = Duration::from_millis(RPC_TIMEOUT_MSEC);

        monitor!("retrieve_block_for_id_chunk", {
            let mut interval = time::interval(retry_interval);
            let mut futures = FuturesUnordered::new();
            if retrieve_batch_size == 1 {
                let (tx, rx) = oneshot::channel();
                self.pending_blocks
                    .lock()
                    .insert_request(target_block_retrieval_payload, tx);
                let author = self.network.author();
                futures.push(
                    async move {
                        let response = match timeout(rpc_timeout, rx).await {
                            Ok(Ok(block)) => Ok(BlockRetrievalResponse::new(
                                BlockRetrievalStatus::SucceededWithTarget,
                                vec![block],
                            )),
                            Ok(Err(_)) => Err(anyhow!("self retrieval cancelled")),
                            Err(_) => Err(anyhow!("self retrieval timeout")),
                        };
                        (author, response)
                    }
                    .boxed(),
                )
            }
            let request = match target_block_retrieval_payload {
                TargetBlockRetrieval::TargetBlockId(target_block_id) => {
                    BlockRetrievalRequest::V1(BlockRetrievalRequestV1::new_with_target_block_id(
                        block_id,
                        retrieve_batch_size,
                        target_block_id,
                    ))
                },
                TargetBlockRetrieval::TargetRound(target_round) => {
                    BlockRetrievalRequest::V2(BlockRetrievalRequestV2::new_with_target_round(
                        block_id,
                        retrieve_batch_size,
                        target_round,
                    ))
                },
            };

            loop {
                tokio::select! {
                    biased;
                    Some((peer, response)) = futures.next() => {
                        match response {
                            Ok(result) => return Ok(result),
                            e => {
                                warn!(
                                    remote_peer = peer,
                                    block_id = block_id,
                                    "{:?}, Failed to fetch block",
                                    e,
                                );
                                failed_attempt += 1;
                            },
                        }
                    },
                    _ = interval.tick() => {
                        // send batch request to a set of peers of size request_num_peers (or 1 for the first time)
                        let next_peers = if cur_retry < num_retries {
                            let first_attempt = cur_retry == 0;
                            cur_retry += 1;
                            self.pick_peers(
                                first_attempt,
                                &mut peers,
                                if first_attempt { 1 } else {request_num_peers}
                            )
                        } else {
                            Vec::new()
                        };

                        if next_peers.is_empty() && futures.is_empty() {
                            bail!("Couldn't fetch block")
                        }

                        for peer in next_peers {
                            debug!(
                                LogSchema::new(LogEvent::RetrieveBlock).remote_peer(peer),
                                block_id = block_id,
                                "Fetching {} blocks, retry {}, failed attempts {}",
                                retrieve_batch_size,
                                cur_retry,
                                failed_attempt
                            );
                            let remote_peer = peer;
                            let future = self.network.request_block(
                                request.clone(),
                                peer,
                                rpc_timeout,
                            );
                            futures.push(async move { (remote_peer, future.await) }.boxed());
                        }
                    }
                }
            }
        })
    }
```

**File:** consensus/src/block_storage/block_store.rs (L519-556)
```rust
    pub fn insert_single_quorum_cert(&self, qc: QuorumCert) -> anyhow::Result<()> {
        // If the parent block is not the root block (i.e not None), ensure the executed state
        // of a block is consistent with its QuorumCert, otherwise persist the QuorumCert's
        // state and on restart, a new execution will agree with it.  A new execution will match
        // the QuorumCert's state on the next restart will work if there is a memory
        // corruption, for example.
        match self.get_block(qc.certified_block().id()) {
            Some(pipelined_block) => {
                ensure!(
                    // decoupled execution allows dummy block infos
                    pipelined_block
                        .block_info()
                        .match_ordered_only(qc.certified_block()),
                    "QC for block {} has different {:?} than local {:?}",
                    qc.certified_block().id(),
                    qc.certified_block(),
                    pipelined_block.block_info()
                );
                observe_block(
                    pipelined_block.block().timestamp_usecs(),
                    BlockStage::QC_ADDED,
                );
                if pipelined_block.block().is_opt_block() {
                    observe_block(
                        pipelined_block.block().timestamp_usecs(),
                        BlockStage::QC_ADDED_OPT_BLOCK,
                    );
                }
                pipelined_block.set_qc(Arc::new(qc.clone()));
            },
            None => bail!("Insert {} without having the block in store first", qc),
        };

        self.storage
            .save_tree(vec![], vec![qc.clone()])
            .context("Insert block failed when saving quorum")?;
        self.inner.write().insert_quorum_cert(qc)
    }
```

**File:** consensus/src/block_preparer.rs (L54-63)
```rust
        let (txns, max_txns_from_block_to_execute, block_gas_limit) = tokio::select! {
                // Poll the block qc future until a QC is received. Ignore None outcomes.
                Some(qc) = block_qc_fut => {
                    let block_voters = Some(qc.ledger_info().get_voters_bitvec().clone());
                    self.payload_manager.get_transactions(block, block_voters).await
                },
                result = self.payload_manager.get_transactions(block, None) => {
                   result
                }
        }?;
```

**File:** types/src/validator_verifier.rs (L206-214)
```rust
    pub fn new(validator_infos: Vec<ValidatorConsensusInfo>) -> Self {
        let total_voting_power = sum_voting_power(&validator_infos);
        let quorum_voting_power = if validator_infos.is_empty() {
            0
        } else {
            total_voting_power * 2 / 3 + 1
        };
        Self::build_index(validator_infos, quorum_voting_power, total_voting_power)
    }
```

**File:** types/src/validator_verifier.rs (L345-386)
```rust
    pub fn verify_multi_signatures<T: CryptoHash + Serialize>(
        &self,
        message: &T,
        multi_signature: &AggregateSignature,
    ) -> std::result::Result<(), VerifyError> {
        // Verify the number of signature is not greater than expected.
        Self::check_num_of_voters(self.len() as u16, multi_signature.get_signers_bitvec())?;
        let mut pub_keys = vec![];
        let mut authors = vec![];
        for index in multi_signature.get_signers_bitvec().iter_ones() {
            let validator = self
                .validator_infos
                .get(index)
                .ok_or(VerifyError::UnknownAuthor)?;
            authors.push(validator.address);
            pub_keys.push(validator.public_key());
        }
        // Verify the quorum voting power of the authors
        self.check_voting_power(authors.iter(), true)?;
        #[cfg(any(test, feature = "fuzzing"))]
        {
            if self.quorum_voting_power == 0 {
                // This should happen only in case of tests.
                // TODO(skedia): Clean up the test behaviors to not rely on empty signature
                // verification
                return Ok(());
            }
        }
        // Verify empty multi signature
        let multi_sig = multi_signature
            .sig()
            .as_ref()
            .ok_or(VerifyError::EmptySignature)?;
        // Verify the optimistically aggregated signature.
        let aggregated_key =
            PublicKey::aggregate(pub_keys).map_err(|_| VerifyError::FailedToAggregatePubKey)?;

        multi_sig
            .verify(message, &aggregated_key)
            .map_err(|_| VerifyError::InvalidMultiSignature)?;
        Ok(())
    }
```

**File:** types/src/validator_verifier.rs (L453-480)
```rust
    pub fn check_voting_power<'a>(
        &self,
        authors: impl Iterator<Item = &'a AccountAddress>,
        check_super_majority: bool,
    ) -> std::result::Result<u128, VerifyError> {
        let aggregated_voting_power = self.sum_voting_power(authors)?;
        self.check_aggregated_voting_power(aggregated_voting_power, check_super_majority)
    }

    pub fn check_aggregated_voting_power(
        &self,
        aggregated_voting_power: u128,
        check_super_majority: bool,
    ) -> std::result::Result<u128, VerifyError> {
        let target = if check_super_majority {
            self.quorum_voting_power
        } else {
            self.total_voting_power - self.quorum_voting_power + 1
        };

        if aggregated_voting_power < target {
            return Err(VerifyError::TooLittleVotingPower {
                voting_power: aggregated_voting_power,
                expected_voting_power: target,
            });
        }
        Ok(aggregated_voting_power)
    }
```
