# Audit Report

## Title
Gas Schedule Manipulation via Unvalidated `gas_unit_scaling_factor` Enables Network-Wide DOS Through Governance

## Summary
The gas schedule update mechanism through on-chain governance lacks validation of gas parameter values, specifically the `gas_unit_scaling_factor`. This parameter directly controls the denominator in the ratio conversion functions `apply_ratio_round_down()` and `apply_ratio_round_up()`, allowing attackers with sufficient governance voting power to set extreme values that either underprice gas (enabling network spam) or overprice gas (causing network-wide DOS).

## Finding Description

The vulnerability exists in the interaction between three components:

1. **Gas Algebra Conversion Functions**: The `apply_ratio_round_down()` and `apply_ratio_round_up()` functions accept nominator and denominator parameters that control gas unit conversions. [1](#0-0) 

2. **Gas Unit Scaling Factor**: The `gas_unit_scaling_factor` parameter (default: 1,000,000) determines the conversion ratio from internal gas units to external gas units through the trait implementation. [2](#0-1) [3](#0-2) [4](#0-3) 

3. **Conversion Trait Implementation**: The ratio is automatically derived as `(1, gas_unit_scaling_factor)` for all gas conversions. [5](#0-4) 

4. **Critical Usage Points**: These conversions are used in security-critical paths including balance calculation, gas usage reporting, and intrinsic gas validation. [6](#0-5) [7](#0-6) 

5. **Governance Update Mechanism**: The `set_for_next_epoch()` function accepts arbitrary gas schedule parameters with NO value validation—only feature version is checked. The code explicitly acknowledges this gap with a TODO comment. [8](#0-7) [9](#0-8) 

**Attack Path:**

A malicious actor with sufficient stake creates a governance proposal that:
1. Calls `gas_schedule::set_for_next_epoch()` with a modified gas schedule blob
2. Sets `gas_unit_scaling_factor` to either:
   - **Underpricing Attack**: u64::MAX or ~10^18 → makes `internal_gas / u64::MAX ≈ 0`, resulting in essentially free gas
   - **Overpricing Attack**: 1 → makes `internal_gas / 1 = internal_gas`, resulting in 1,000,000x more expensive gas

3. The proposal passes through normal governance voting [10](#0-9) 

4. Upon epoch transition, the malicious gas schedule is activated network-wide [11](#0-10) 

## Impact Explanation

**Severity: CRITICAL** (up to $1,000,000 per Aptos Bug Bounty)

This vulnerability meets the **"Total loss of liveness/network availability"** criteria:

- **Underpricing Scenario**: Gas becomes essentially free (division by very large denominator approaches zero). Attackers can spam the network with millions of transactions at minimal cost, overwhelming validator resources and causing network-wide denial of service through resource exhaustion.

- **Overpricing Scenario**: Gas becomes 1,000,000x more expensive (denominator = 1 vs default 1,000,000). All legitimate transactions become economically infeasible, effectively freezing the network. Users cannot transact, validators cannot process blocks economically.

Both scenarios break the critical invariant: **"Resource Limits: All operations must respect gas, storage, and computational limits."** The network would require emergency governance action or potentially a hard fork to recover, qualifying as **"Non-recoverable network partition"**.

## Likelihood Explanation

**Likelihood: MEDIUM**

**Requirements:**
- Attacker needs sufficient voting power to create and pass a governance proposal (requires staked APT meeting `required_proposer_stake` threshold)
- Requires coordination to gain majority voting support OR compromise of existing large stakeholders
- No validator insider access required—purely governance-based attack

**Complexity:** LOW to MEDIUM
- The attack is straightforward: craft a gas schedule with extreme scaling factor
- Governance proposal submission is well-documented
- No need to exploit complex race conditions or timing vulnerabilities

**Feasibility:** 
While requiring significant stake or social engineering to pass a malicious proposal, the technical execution is trivial once voting power is obtained. The complete absence of validation makes exploitation certain if governance control is achieved.

## Recommendation

Implement strict validation of gas parameter values in the gas schedule update functions:

**Primary Fix:** Add validation bounds in `gas_schedule.move`:

```move
// In set_for_next_epoch() and set_for_next_epoch_check_hash()
const MIN_GAS_UNIT_SCALING_FACTOR: u64 = 100_000;  // 10x lower than default
const MAX_GAS_UNIT_SCALING_FACTOR: u64 = 10_000_000;  // 10x higher than default

public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
    system_addresses::assert_aptos_framework(aptos_framework);
    assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
    let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
    
    // NEW: Validate gas parameter bounds
    validate_gas_schedule_consistency(&new_gas_schedule);
    
    if (exists<GasScheduleV2>(@aptos_framework)) {
        let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
        assert!(
            new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
            error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
        );
    };
    config_buffer::upsert(new_gas_schedule);
}

fun validate_gas_schedule_consistency(schedule: &GasScheduleV2) {
    // Validate gas_unit_scaling_factor is within acceptable bounds
    let scaling_factor_val = extract_gas_param_value(schedule, b"txn.gas_unit_scaling_factor");
    assert!(
        scaling_factor_val >= MIN_GAS_UNIT_SCALING_FACTOR && 
        scaling_factor_val <= MAX_GAS_UNIT_SCALING_FACTOR,
        error::invalid_argument(EINVALID_GAS_SCHEDULE)
    );
    // Add similar validations for other critical gas parameters
}
```

**Secondary Defense:** Add runtime safeguards in `scaling_factor()`:

```rust
pub fn scaling_factor(&self) -> GasScalingFactor {
    const MIN_SCALING: u64 = 100_000;
    const MAX_SCALING: u64 = 10_000_000;
    
    let value = u64::from(self.gas_unit_scaling_factor);
    if value == 0 {
        return 1.into();
    }
    // Clamp to safe bounds
    value.clamp(MIN_SCALING, MAX_SCALING).into()
}
```

## Proof of Concept

**Move Governance Proposal Script:**

```move
script {
    use aptos_framework::aptos_governance;
    use aptos_framework::gas_schedule;
    use std::vector;
    
    fun malicious_gas_schedule_update(proposal_creator: &signer) {
        // Create malicious gas schedule with scaling_factor = 1 (overpricing attack)
        // or scaling_factor = u64::MAX (underpricing attack)
        
        let malicious_gas_schedule_blob = construct_gas_schedule_with_extreme_scaling();
        
        // Submit governance proposal
        let execution_hash = x"<hash_of_resolution_script>";
        let metadata_location = b"https://attacker.com/malicious_proposal";
        let metadata_hash = b"hash";
        
        let proposal_id = aptos_governance::create_proposal_v2(
            proposal_creator,
            @stake_pool_address,
            execution_hash,
            metadata_location,
            metadata_hash,
            false
        );
        
        // Resolution script (executed after voting passes):
        gas_schedule::set_for_next_epoch(
            &aptos_governance::get_signer_testnet_only(proposal_creator),
            malicious_gas_schedule_blob
        );
        aptos_governance::reconfigure(&framework_signer);
    }
    
    fun construct_gas_schedule_with_extreme_scaling(): vector<u8> {
        // Construct GasScheduleV2 with gas_unit_scaling_factor = 1 or u64::MAX
        // Serialized BCS bytes with modified scaling factor
        // ... implementation omitted for brevity ...
        vector::empty<u8>()
    }
}
```

**Impact Demonstration:**
1. Before attack: Transaction with 1,000,000 internal gas costs 1 external gas unit
2. After attack (scaling_factor=1): Same transaction costs 1,000,000 external gas units
3. After attack (scaling_factor=u64::MAX): Same transaction costs ~0 external gas units

## Notes

The vulnerability is explicitly acknowledged in the codebase with the TODO comment: `"TODO(Gas): check if gas schedule is consistent"` at line 47 and 67 of `gas_schedule.move`, indicating developers are aware of this validation gap but have not yet implemented the fix. This represents a **critical security debt** that must be addressed before any adversarial governance scenario.

The attack requires governance voting power but does not require validator collusion or insider access, making it exploitable by any sufficiently-staked malicious actor or coordinated group. Given the severity of impact (complete network DOS), this vulnerability should be prioritized for immediate remediation.

### Citations

**File:** third_party/move/move-core/types/src/gas_algebra.rs (L253-279)
```rust
fn apply_ratio_round_down(val: u64, nominator: u64, denominator: u64) -> u64 {
    assert_ne!(nominator, 0);
    assert_ne!(denominator, 0);

    let res = val as u128 * nominator as u128 / denominator as u128;
    if res > u64::MAX as u128 {
        u64::MAX
    } else {
        res as u64
    }
}

#[allow(clippy::bool_to_int_with_if)]
fn apply_ratio_round_up(val: u64, nominator: u64, denominator: u64) -> u64 {
    assert_ne!(nominator, 0);
    assert_ne!(denominator, 0);

    let n = val as u128 * nominator as u128;
    let d = denominator as u128;

    let res = n / d + if n.is_multiple_of(d) { 0 } else { 1 };
    if res > u64::MAX as u128 {
        u64::MAX
    } else {
        res as u64
    }
}
```

**File:** third_party/move/move-core/types/src/gas_algebra.rs (L377-384)
```rust
impl<P, U, T> ToUnitFractionalWithParams<P, U> for T
where
    U: ToUnitWithParams<P, T>,
{
    fn ratio(params: &P) -> (u64, u64) {
        (1, <U as ToUnitWithParams<P, T>>::multiplier(params))
    }
}
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L83-86)
```rust
            gas_unit_scaling_factor: GasScalingFactor,
            "gas_unit_scaling_factor",
            GAS_SCALING_FACTOR
        ],
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L293-298)
```rust
    pub fn scaling_factor(&self) -> GasScalingFactor {
        match u64::from(self.gas_unit_scaling_factor) {
            0 => 1.into(),
            x => x.into(),
        }
    }
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/transaction.rs (L313-317)
```rust
impl ToUnitWithParams<TransactionGasParameters, InternalGasUnit> for GasUnit {
    fn multiplier(params: &TransactionGasParameters) -> u64 {
        params.scaling_factor().into()
    }
}
```

**File:** aptos-move/aptos-gas-meter/src/traits.rs (L240-263)
```rust
    fn balance(&self) -> Gas {
        self.algebra()
            .balance_internal()
            .to_unit_round_down_with_params(&self.vm_gas_params().txn)
    }

    /// Returns the scaling factor between internal and external gas units.
    fn gas_unit_scaling_factor(&self) -> GasScalingFactor {
        self.algebra().vm_gas_params().txn.scaling_factor()
    }

    /// Return the total gas used for execution.
    fn execution_gas_used(&self) -> Gas {
        self.algebra()
            .execution_gas_used()
            .to_unit_round_up_with_params(&self.vm_gas_params().txn)
    }

    /// Return the total gas used for io.
    fn io_gas_used(&self) -> Gas {
        self.algebra()
            .io_gas_used()
            .to_unit_round_up_with_params(&self.vm_gas_params().txn)
    }
```

**File:** aptos-move/aptos-vm/src/gas.rs (L154-172)
```rust
    let intrinsic_gas = txn_gas_params
        .calculate_intrinsic_gas(raw_bytes_len)
        .evaluate(gas_feature_version, &gas_params.vm);
    let total_rounded: Gas =
        (intrinsic_gas + keyless + slh_dsa_sha2_128s).to_unit_round_up_with_params(txn_gas_params);
    if txn_metadata.max_gas_amount() < total_rounded {
        speculative_warn!(
            log_context,
            format!(
                "[VM] Gas unit error; min {}, submitted {}",
                total_rounded,
                txn_metadata.max_gas_amount()
            ),
        );
        return Err(VMStatus::error(
            StatusCode::MAX_GAS_UNITS_BELOW_MIN_TRANSACTION_GAS_UNITS,
            None,
        ));
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L43-50)
```text
    public(friend) fun initialize(aptos_framework: &signer, gas_schedule_blob: vector<u8>) {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));

        // TODO(Gas): check if gas schedule is consistent
        let gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        move_to<GasScheduleV2>(aptos_framework, gas_schedule);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L91-103)
```text
    public fun set_for_next_epoch(aptos_framework: &signer, gas_schedule_blob: vector<u8>) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));
        let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let cur_gas_schedule = borrow_global<GasScheduleV2>(@aptos_framework);
            assert!(
                new_gas_schedule.feature_version >= cur_gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION)
            );
        };
        config_buffer::upsert(new_gas_schedule);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L135-145)
```text
    public(friend) fun on_new_epoch(framework: &signer) acquires GasScheduleV2 {
        system_addresses::assert_aptos_framework(framework);
        if (config_buffer::does_exist<GasScheduleV2>()) {
            let new_gas_schedule = config_buffer::extract_v2<GasScheduleV2>();
            if (exists<GasScheduleV2>(@aptos_framework)) {
                *borrow_global_mut<GasScheduleV2>(@aptos_framework) = new_gas_schedule;
            } else {
                move_to(framework, new_gas_schedule);
            }
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L405-434)
```text
    public fun create_proposal_v2_impl(
        proposer: &signer,
        stake_pool: address,
        execution_hash: vector<u8>,
        metadata_location: vector<u8>,
        metadata_hash: vector<u8>,
        is_multi_step_proposal: bool,
    ): u64 acquires GovernanceConfig, GovernanceEvents {
        check_governance_permission(proposer);
        let proposer_address = signer::address_of(proposer);
        assert!(
            stake::get_delegated_voter(stake_pool) == proposer_address,
            error::invalid_argument(ENOT_DELEGATED_VOTER)
        );

        // The proposer's stake needs to be at least the required bond amount.
        let governance_config = borrow_global<GovernanceConfig>(@aptos_framework);
        let stake_balance = get_voting_power(stake_pool);
        assert!(
            stake_balance >= governance_config.required_proposer_stake,
            error::invalid_argument(EINSUFFICIENT_PROPOSER_STAKE),
        );

        // The proposer's stake needs to be locked up at least as long as the proposal's voting period.
        let current_time = timestamp::now_seconds();
        let proposal_expiration = current_time + governance_config.voting_duration_secs;
        assert!(
            stake::get_lockup_secs(stake_pool) >= proposal_expiration,
            error::invalid_argument(EINSUFFICIENT_STAKE_LOCKUP),
        );
```
