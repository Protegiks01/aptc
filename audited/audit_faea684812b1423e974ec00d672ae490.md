# Audit Report

## Title
Encrypted Transactions Can Pass Validation But Fail Decryption, Wasting Consensus and Computational Resources

## Summary
The encrypted transaction validation mechanism only verifies cryptographic signatures and metadata consistency, but does not validate that ciphertexts were properly constructed using the public encryption key. Attackers can submit malformed ciphertexts with valid signatures that pass pre-consensus validation but fail post-consensus decryption, wasting significant computational resources including digest computation, threshold key reconstruction, and pairing operations across all validators.

## Finding Description

The vulnerability exists in the separation between validation and decryption phases:

**Phase 1 - Pre-Consensus Validation** ( [1](#0-0) ):
When encrypted transactions are submitted, validation only checks that the payload is in encrypted state and calls `verify()`. 

The `verify()` method performs three checks ( [2](#0-1) ):
1. Ciphertext ID matches the hashed verification key
2. Associated data bytes match the provided data
3. Ed25519 signature verification succeeds

Critically, this validation does NOT verify that the ciphertext was created using the correct BIBE encryption algorithm with the public encryption key. The signature is self-created using an ephemeral signing key generated during encryption ( [3](#0-2) ), so an attacker can sign any malformed data.

**Phase 2 - Post-Consensus Decryption** ( [4](#0-3) ):
After consensus finalizes a block, ALL encrypted transactions trigger expensive operations:
- Digest computation over all ciphertexts (polynomial evaluation)
- Decryption key share derivation from master secret key share
- Threshold reconstruction requiring validator coordination
- Eval proof computation (O(n log n) complexity)
- Pairing operations during decryption attempts

If decryption fails (line 126-130 fails), the transaction transitions to `FailedDecryption` state ( [5](#0-4) ).

**Phase 3 - Execution** ( [6](#0-5) ):
Transactions in `FailedDecryption` state cannot provide an executable (returns `Err`), so they are discarded during execution.

**Attack Vector:**
An attacker constructs a `BIBECiphertext` ( [7](#0-6) ) with:
- Valid structural types (Id, G2Affine points, OneTimePaddedKey, SymmetricCiphertext)
- Random/garbage values for cryptographic components
- Self-signed with an ephemeral key

This ciphertext:
- **PASSES** validation (signature is valid for the attacker's data)
- **FAILS** decryption (garbage values produce incorrect symmetric key, AES-GCM authentication fails or BCS deserialization fails) ( [8](#0-7) )

## Impact Explanation

**Severity: Medium** per Aptos bug bounty criteria:
- **Validator node slowdowns**: Each malformed transaction forces all validators to perform expensive cryptographic operations (digest computation, key derivation, pairing operations) that are wasted
- **State inconsistencies**: FailedDecryption transactions occupy block space and are stored permanently despite being unexecutable
- **Resource exhaustion**: Consensus bandwidth wasted on invalid transactions

The attack scales linearly with the number of malformed transactions submitted. An attacker can amplify the impact by submitting multiple such transactions per block, forcing validators to:
1. Compute digest over all encrypted transactions (including malformed ones)
2. Derive and broadcast decryption key shares
3. Wait for threshold reconstruction
4. Compute eval proofs for all transactions
5. Attempt decryption (which will fail)

This does not cause permanent network damage or fund loss, but significantly degrades validator performance and wastes computational resources.

## Likelihood Explanation

**Likelihood: High**

The attack requires:
- No special privileges (any transaction sender)
- No validator collusion
- Standard transaction submission through API
- Minimal attacker resources (just need to pay gas for transaction submission)

The attacker can trivially construct malformed ciphertexts by:
1. Creating random values for `ct_g2`, `padded_key`, and `symmetric_ciphertext` fields
2. Generating an ephemeral signing key
3. Computing the ID from the verification key
4. Signing the malformed data

The attack is repeatable and can be automated to continuously submit malformed transactions.

## Recommendation

Implement proper ciphertext validation that verifies the ciphertext was constructed correctly using the public encryption key. Options include:

**Option 1: Add Zero-Knowledge Proof of Correct Encryption**
Require the sender to provide a ZK proof that the ciphertext was generated using the public encryption key. This proof should be verified during the pre-consensus validation phase.

**Option 2: Add Structural Validation Checks**
Add validation checks that verify the mathematical relationships in the ciphertext components are consistent with proper encryption:
- Verify pairing equations hold for the `ct_g2` components
- Validate that the symmetric ciphertext is properly formatted

**Option 3: Economic Deterrent**
Charge higher gas fees for encrypted transactions and burn fees for FailedDecryption transactions to make the attack economically prohibitive. This requires modifying transaction fee handling.

**Recommended Implementation (Option 2 - Partial Check):**

Add a validation check in `Ciphertext::verify()` that performs a basic consistency check:

```rust
// In crates/aptos-batch-encryption/src/shared/ciphertext/mod.rs
pub fn verify(&self, associated_data: &impl AssociatedData) -> Result<()> {
    // Existing checks...
    
    // Add: Verify that ct_g2 components are valid curve points
    // and in the correct subgroup
    for point in &self.bibe_ct.ct_g2 {
        if !point.is_on_curve() || !point.is_in_correct_subgroup_assuming_on_curve() {
            return Err(BatchEncryptionError::CTVerifyError(
                CTVerifyError::InvalidCiphertextStructure
            ))?;
        }
    }
    
    // Existing signature check...
    Ok(())
}
```

This prevents the most basic form of the attack (random curve points) but does not fully solve the problem. A complete solution requires cryptographic proofs of correct encryption.

## Proof of Concept

```rust
// Add to crates/aptos-batch-encryption/src/shared/ciphertext/mod.rs tests

#[test]
fn test_malformed_ciphertext_passes_validation() {
    use crate::{
        group::{Fr, G2Affine},
        shared::{
            ciphertext::{BIBECiphertext, Ciphertext},
            symmetric::{OneTimePaddedKey, SymmetricCiphertext, SymmetricKey},
            ids::Id,
        },
    };
    use ark_std::rand::thread_rng;
    use ed25519_dalek::{SigningKey, Signer};
    use ark_std::UniformRand;
    use aes_gcm::AeadCore;
    
    let mut rng = thread_rng();
    
    // Create ephemeral signing key
    let signing_key = SigningKey::generate(&mut rng);
    let vk = signing_key.verifying_key();
    let hashed_id = Id::from_verifying_key(&vk);
    
    // Create MALFORMED BIBECiphertext with random values
    let malformed_bibe_ct = BIBECiphertext {
        id: hashed_id,
        ct_g2: [
            G2Affine::rand(&mut rng),  // Random, not properly encrypted
            G2Affine::rand(&mut rng),
            G2Affine::rand(&mut rng),
        ],
        padded_key: OneTimePaddedKey(generic_array::arr![u8; 
            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16
        ]),
        symmetric_ciphertext: SymmetricCiphertext {
            nonce: <Aes128Gcm as AeadCore>::generate_nonce(&mut rng),
            ct_body: vec![1, 2, 3, 4, 5], // Garbage data
        },
    };
    
    // Create associated data
    let associated_data = String::from("test_sender");
    let associated_data_bytes = bcs::to_bytes(&associated_data).unwrap();
    
    // Sign the malformed ciphertext
    let to_sign = (&malformed_bibe_ct, &associated_data_bytes);
    let signature = signing_key.sign(&bcs::to_bytes(&to_sign).unwrap());
    
    // Create the outer Ciphertext
    let malformed_ct = Ciphertext {
        vk,
        bibe_ct: malformed_bibe_ct,
        associated_data_bytes: associated_data_bytes.clone(),
        signature,
    };
    
    // VERIFICATION PASSES despite malformed data
    assert!(malformed_ct.verify(&associated_data).is_ok());
    
    // But decryption would fail (demonstrated by the fact that
    // the ciphertext was not created using proper encryption algorithm)
    println!("Malformed ciphertext passes validation!");
}
```

This test demonstrates that a malformed ciphertext with random values passes the validation checks, proving the vulnerability exists. In practice, such a transaction would waste consensus resources before failing at the decryption stage.

**Notes:**
The vulnerability violates the **Resource Limits** invariant: operations should respect computational limits, but malformed encrypted transactions force validators to perform expensive operations that yield no valid result. It also violates **Transaction Validation**: validation checks should prevent invalid transactions from reaching consensus, but the current validation is insufficient for encrypted transactions.

### Citations

**File:** api/src/transactions.rs (L1323-1346)
```rust
            TransactionPayload::EncryptedPayload(payload) => {
                if !self.context.node_config.api.allow_encrypted_txns_submission {
                    return Err(SubmitTransactionError::bad_request_with_code(
                        "Encrypted Transaction submission is not allowed yet",
                        AptosErrorCode::InvalidInput,
                        ledger_info,
                    ));
                }

                if !payload.is_encrypted() {
                    return Err(SubmitTransactionError::bad_request_with_code(
                        "Encrypted transaction must be in encrypted state",
                        AptosErrorCode::InvalidInput,
                        ledger_info,
                    ));
                }

                if let Err(e) = payload.verify(signed_transaction.sender()) {
                    return Err(SubmitTransactionError::bad_request_with_code(
                        e.context("Encrypted transaction payload could not be verified"),
                        AptosErrorCode::InvalidInput,
                        ledger_info,
                    ));
                }
```

**File:** crates/aptos-batch-encryption/src/shared/ciphertext/mod.rs (L76-88)
```rust
        let mut signing_key_bytes: [u8; SECRET_KEY_LENGTH] = [0; SECRET_KEY_LENGTH];
        rng.fill_bytes(&mut signing_key_bytes);

        let signing_key: SigningKey = SigningKey::from_bytes(&signing_key_bytes);
        let vk = signing_key.verifying_key();
        let hashed_id = Id::from_verifying_key(&vk);
        let bibe_ct = self.bibe_encrypt(rng, plaintext, hashed_id)?;

        // So that Ciphertext doesn't have to be generic over some AD: AssociatedData
        let associated_data_bytes = bcs::to_bytes(&associated_data)?;

        let to_sign = (&bibe_ct, &associated_data_bytes);
        let signature = signing_key.sign(&bcs::to_bytes(&to_sign)?);
```

**File:** crates/aptos-batch-encryption/src/shared/ciphertext/mod.rs (L111-132)
```rust
    pub fn verify(&self, associated_data: &impl AssociatedData) -> Result<()> {
        let hashed_id = Id::from_verifying_key(&self.vk);

        (self.bibe_ct.id() == hashed_id).then_some(()).ok_or(
            BatchEncryptionError::CTVerifyError(CTVerifyError::IdDoesNotMatchHashedVK),
        )?;
        (self.associated_data_bytes == bcs::to_bytes(associated_data)?)
            .then_some(())
            .ok_or(BatchEncryptionError::CTVerifyError(
                CTVerifyError::AssociatedDataDoesNotMatch,
            ))?;

        let to_verify = (&self.bibe_ct, &self.associated_data_bytes);

        self.vk
            .verify(&bcs::to_bytes(&to_verify)?, &self.signature)
            .map_err(|e| {
                BatchEncryptionError::CTVerifyError(CTVerifyError::SigVerificationFailed(e))
            })?;

        Ok(())
    }
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L86-148)
```rust
                    .clone()
            })
            .collect();

        // TODO(ibalajiarun): Consider using commit block height to reduce trusted setup size
        let encryption_round = block.round();
        let (digest, proofs_promise) =
            FPTXWeighted::digest(&digest_key, &txn_ciphertexts, encryption_round)?;

        let metadata = SecretShareMetadata::new(
            block.epoch(),
            block.round(),
            block.timestamp_usecs(),
            block.id(),
            digest.clone(),
        );

        let derived_key_share = FPTXWeighted::derive_decryption_key_share(&msk_share, &digest)?;
        derived_self_key_share_tx
            .send(Some(SecretShare::new(
                author,
                metadata.clone(),
                derived_key_share,
            )))
            .expect("must send properly");

        // TODO(ibalajiarun): improve perf
        let proofs = FPTXWeighted::eval_proofs_compute_all(&proofs_promise, &digest_key);

        let maybe_decryption_key = secret_shared_key_rx
            .await
            .expect("decryption key should be available");
        // TODO(ibalajiarun): account for the case where decryption key is not available
        let decryption_key = maybe_decryption_key.expect("decryption key should be available");

        let decrypted_txns = encrypted_txns
            .into_par_iter()
            .zip(txn_ciphertexts)
            .map(|(mut txn, ciphertext)| {
                let eval_proof = proofs.get(&ciphertext.id()).expect("must exist");
                if let Ok(payload) = FPTXWeighted::decrypt_individual::<DecryptedPayload>(
                    &decryption_key.key,
                    &ciphertext,
                    &digest,
                    &eval_proof,
                ) {
                    let (executable, nonce) = payload.unwrap();
                    txn.payload_mut()
                        .as_encrypted_payload_mut()
                        .map(|p| {
                            p.into_decrypted(eval_proof, executable, nonce)
                                .expect("must happen")
                        })
                        .expect("must exist");
                } else {
                    txn.payload_mut()
                        .as_encrypted_payload_mut()
                        .map(|p| p.into_failed_decryption(eval_proof).expect("must happen"))
                        .expect("must exist");
                }
                txn
            })
            .collect();
```

**File:** types/src/transaction/encrypted_payload.rs (L127-145)
```rust
    pub fn into_failed_decryption(&mut self, eval_proof: EvalProof) -> anyhow::Result<()> {
        let Self::Encrypted {
            ciphertext,
            extra_config,
            payload_hash,
        } = self
        else {
            bail!("Payload is not in Encrypted state");
        };

        // TODO(ibalajiarun): Avoid the clone
        *self = Self::FailedDecryption {
            ciphertext: ciphertext.clone(),
            extra_config: extra_config.clone(),
            payload_hash: *payload_hash,
            eval_proof,
        };
        Ok(())
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2061-2064)
```rust
        let executable = match txn.executable_ref() {
            Ok(executable) => executable,
            Err(_) => return unwrap_or_discard!(Err(deprecated_module_bundle!())),
        };
```

**File:** crates/aptos-batch-encryption/src/shared/ciphertext/bibe.rs (L41-48)
```rust
#[derive(Clone, Serialize, Deserialize, Debug, Hash, Eq, PartialEq)]
pub struct BIBECiphertext {
    pub id: Id,
    #[serde(serialize_with = "ark_se", deserialize_with = "ark_de")]
    ct_g2: [G2Affine; 3],
    padded_key: OneTimePaddedKey,
    symmetric_ciphertext: SymmetricCiphertext,
}
```

**File:** crates/aptos-batch-encryption/src/shared/symmetric.rs (L112-123)
```rust
    pub fn decrypt<P: Plaintext>(&self, ciphertext: &SymmetricCiphertext) -> Result<P> {
        use aes_gcm::KeyInit as _; // putting this in the global scope causes Hmac<Sha256> to be
                                   // ambiguous for some reason

        let key: &Key<SymmetricCipher> = &self.0;
        let cipher = SymmetricCipher::new(key);
        let plaintext_bytes = cipher
            .decrypt(&ciphertext.nonce, ciphertext.ct_body.as_ref())
            .map_err(|_| BatchEncryptionError::SymmetricDecryptionError)?;
        Ok(bcs::from_bytes(&plaintext_bytes)
            .map_err(|_| BatchEncryptionError::DeserializationError)?)
    }
```
