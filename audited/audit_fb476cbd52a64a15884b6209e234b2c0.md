# Audit Report

## Title
Empty Epoch Ending Backups Cause Restoration Failure Due to Incorrect Empty History Handling

## Summary
When `epoch_ending_backups` is empty, the compaction process correctly avoids creating metadata files, but the restoration process fails with "Empty epoch history" error because `EpochHistoryRestoreController` returns a `Some(EpochHistory)` with empty `epoch_endings` instead of signaling that epoch history verification should be skipped. This breaks disaster recovery for legitimate backup scenarios.

## Finding Description

The vulnerability exists in the interaction between the backup compaction and restoration systems:

**During Compaction (Correct Behavior):**
When `compact_epoch_ending_backups()` is called with an empty `epoch_ending_backups` vector, the `compact_backups()` function correctly returns an empty vector. [1](#0-0) 

The `compact_backups()` function uses Rust's `chunks()` iterator which produces zero chunks when the input slice is empty, resulting in no compacted metadata files being created. [2](#0-1) 

In the backup compactor, when the returned vector is empty, the loop doesn't execute and no files are written. [3](#0-2) 

**During Restoration (Vulnerability):**
The restore coordinator retrieves epoch ending backups and constructs epoch handles. When `epoch_ending_backups` is empty, `epoch_handles` becomes an empty vector. [4](#0-3) 

If `skip_epoch_endings` is false, an `EpochHistoryRestoreController` is created with the empty handles and executed. [5](#0-4) 

The critical flaw: `EpochHistoryRestoreController::run_impl()` returns `Ok(EpochHistory { epoch_endings: Vec::new(), ... })` when given empty manifest handles, rather than signaling an error or returning None. [6](#0-5) 

This empty `EpochHistory` is wrapped in `Some(Arc::new(...))` and passed to transaction and state snapshot restore controllers, which attempt to verify ledger info.

**Failure Point:**
When transaction restore or state snapshot restore attempts to verify ledger info with the empty epoch history, the `verify_ledger_info()` method immediately fails with an ensure check. [7](#0-6) 

This occurs in both transaction restore [8](#0-7)  and state snapshot restore [9](#0-8) .

## Impact Explanation

**Severity: Medium** - State inconsistencies requiring intervention

This vulnerability breaks the backup/restore disaster recovery mechanism:

1. **Restoration Failure**: Any attempt to restore a backup with empty epoch ending metadata fails completely with "Empty epoch history" error, even if the backup contains valid state snapshots and transaction data.

2. **Legitimate Scenarios Affected**:
   - Backups taken during epoch 0 before the first epoch change
   - Backups after metadata corruption or loss
   - Backups that underwent compaction when no epoch endings existed

3. **Data Availability Impact**: Operators cannot recover from disaster using affected backups, violating the fundamental purpose of the backup system. If this is the only available backup, data may be permanently unrecoverable without manual intervention.

4. **Operational Impact**: Requires manual intervention to fix the backup metadata or bypass epoch verification, causing extended downtime during critical disaster recovery scenarios.

This meets Medium severity criteria as it causes "state inconsistencies requiring intervention" and affects the availability guarantees of the backup/restore system.

## Likelihood Explanation

**Likelihood: Medium to High**

This issue occurs in realistic operational scenarios:

1. **Early Chain State**: Any backup taken during epoch 0 (before the first epoch change) will have no epoch endings. When compaction is run on such backups, restoration becomes impossible.

2. **Normal Operations**: The compaction process runs automatically in production environments. If triggered on a backup without epoch endings (legitimately or due to metadata issues), it creates unrestorable backups without any warning.

3. **No Attacker Required**: This is a logic bug that manifests during normal backup/restore operations without requiring any malicious action.

4. **Silent Failure Creation**: The compaction completes successfully without errors, creating backups that appear valid but cannot be restored.

The likelihood is not higher only because most production chains quickly progress beyond epoch 0, but for test networks, new deployments, or early-stage chains, this is highly probable.

## Recommendation

Fix the `EpochHistoryRestoreController::run_impl()` to distinguish between "no epoch history needed" vs "invalid state":

**Option 1**: Return `None` from restore coordinator when epoch handles are empty:
```rust
let epoch_history = if !self.skip_epoch_endings && !epoch_handles.is_empty() {
    Some(Arc::new(
        EpochHistoryRestoreController::new(
            epoch_handles,
            self.global_opt.clone(),
            self.storage.clone(),
        )
        .run()
        .await?,
    ))
} else {
    None
};
```

**Option 2**: Make `verify_ledger_info()` gracefully handle empty epoch history for epoch 0:
```rust
pub fn verify_ledger_info(&self, li_with_sigs: &LedgerInfoWithSignatures) -> Result<()> {
    let epoch = li_with_sigs.ledger_info().epoch();
    
    // Allow empty epoch history if we're still in epoch 0
    if self.epoch_endings.is_empty() {
        if epoch == 0 {
            return Ok(());
        }
        bail!("Empty epoch history for epoch {}", epoch);
    }
    // ... rest of verification
}
```

**Option 3**: Fail early with clear error in `EpochHistoryRestoreController::run_impl()`:
```rust
if self.manifest_handles.is_empty() {
    bail!("No epoch ending backups found. Cannot verify epoch history. Use --skip-epoch-endings if intentional.");
}
```

**Recommended Approach**: Option 1 is cleanest as it maintains the existing contract where `Option<EpochHistory>` means "verification should be skipped when None."

## Proof of Concept

```rust
// Reproduction steps:
// 1. Create a MetadataView with empty epoch_ending_backups
// 2. Call compact_epoch_ending_backups
// 3. Simulate restoration process

use storage_backup_backup_cli::metadata::view::MetadataView;
use storage_backup_backup_cli::backup_types::epoch_ending::restore::EpochHistory;

#[test]
fn test_empty_epoch_ending_restoration_failure() {
    // Create MetadataView with empty epoch_ending_backups
    let metadata_view = MetadataView::new(vec![], vec![]);
    
    // Compaction succeeds with empty result
    let mut view = metadata_view;
    let compacted = view.compact_epoch_ending_backups(10).unwrap();
    assert!(compacted.is_empty()); // No files created - this is correct
    
    // Simulate restoration: select epoch ending backups
    let epoch_backups = view.select_epoch_ending_backups(1000).unwrap();
    assert!(epoch_backups.is_empty());
    
    // Create empty epoch handles (as restore coordinator would)
    let epoch_handles: Vec<FileHandle> = vec![];
    
    // Create EpochHistoryRestoreController with empty handles
    let controller = EpochHistoryRestoreController::new(
        epoch_handles,
        global_opt,
        storage,
    );
    
    // This returns Ok(EpochHistory { epoch_endings: vec![], ... })
    let epoch_history = controller.run().await.unwrap();
    assert!(epoch_history.epoch_endings.is_empty());
    
    // Now attempt to verify any ledger info - this will fail
    let test_ledger_info = create_test_ledger_info_epoch_0();
    
    // THIS FAILS with "Empty epoch history."
    let result = epoch_history.verify_ledger_info(&test_ledger_info);
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("Empty epoch history"));
    
    // Restoration cannot proceed, even though backup data may be valid
}
```

**Notes:**
- This vulnerability does NOT create "empty compacted metadata files" as the question hypothesized - the compaction correctly avoids creating files.
- The actual issue is more subtle: empty epoch metadata causes restoration to fail in the verification phase, not the file reading phase.
- The root cause is that `EpochHistoryRestoreController` returns `Some(empty_history)` rather than `None` or an error, preventing downstream code from distinguishing "no verification needed" from "verification required but no data available."

### Citations

**File:** storage/backup/backup-cli/src/metadata/view.rs (L200-213)
```rust
    pub fn compact_backups<T>(backups: &[T], compaction_cnt: usize) -> Result<Vec<&[T]>> {
        // Initialize an empty vector to store the output
        let mut output_vec = Vec::new();

        // Iterate over the input vector in chunks of compaction_cnt
        for chunk in backups.chunks(compaction_cnt) {
            // Create a new vector containing the current chunk
            let new_slice = chunk;
            // Add the new vector to the output vector
            output_vec.push(new_slice);
        }
        // Return the output vector
        Ok(output_vec)
    }
```

**File:** storage/backup/backup-cli/src/metadata/view.rs (L215-220)
```rust
    pub fn compact_epoch_ending_backups(
        &mut self,
        compaction_cnt: usize,
    ) -> Result<Vec<&[EpochEndingBackupMeta]>> {
        Self::compact_backups(&self.epoch_ending_backups, compaction_cnt)
    }
```

**File:** storage/backup/backup-cli/src/coordinators/backup.rs (L423-431)
```rust
        for range in metaview.compact_epoch_ending_backups(self.epoch_ending_file_compact_factor)? {
            let (epoch_range, file_name) =
                Metadata::compact_epoch_ending_backup_range(range.to_vec())?;
            let file_handle = self
                .storage
                .save_metadata_lines(&file_name, epoch_range.as_slice())
                .await?;
            new_files.insert(file_handle);
        }
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L213-218)
```rust
        let epoch_ending_backups = metadata_view.select_epoch_ending_backups(target_version)?;
        let epoch_handles = epoch_ending_backups
            .iter()
            .filter(|e| e.first_version <= target_version)
            .map(|backup| backup.manifest.clone())
            .collect();
```

**File:** storage/backup/backup-cli/src/coordinators/restore.rs (L219-231)
```rust
        let epoch_history = if !self.skip_epoch_endings {
            Some(Arc::new(
                EpochHistoryRestoreController::new(
                    epoch_handles,
                    self.global_opt.clone(),
                    self.storage.clone(),
                )
                .run()
                .await?,
            ))
        } else {
            None
        };
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L276-278)
```rust
    pub fn verify_ledger_info(&self, li_with_sigs: &LedgerInfoWithSignatures) -> Result<()> {
        let epoch = li_with_sigs.ledger_info().epoch();
        ensure!(!self.epoch_endings.is_empty(), "Empty epoch history.",);
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L351-358)
```rust
    async fn run_impl(self) -> Result<EpochHistory> {
        let timer = Instant::now();
        if self.manifest_handles.is_empty() {
            return Ok(EpochHistory {
                epoch_endings: Vec::new(),
                trusted_waypoints: Arc::new(HashMap::new()),
            });
        }
```

**File:** storage/backup/backup-cli/src/backup_types/transaction/restore.rs (L152-154)
```rust
        if let Some(epoch_history) = epoch_history {
            epoch_history.verify_ledger_info(&ledger_info)?;
        }
```

**File:** storage/backup/backup-cli/src/backup_types/state_snapshot/restore.rs (L137-139)
```rust
        if let Some(epoch_history) = self.epoch_history.as_ref() {
            epoch_history.verify_ledger_info(&li)?;
        }
```
