# Audit Report

## Title
QuorumCert Signature Validation Bypassed During Consensus Recovery from Persistent Storage

## Summary
The consensus recovery mechanism loads QuorumCerts from ConsensusDB without verifying their cryptographic signatures, allowing an attacker with filesystem access to inject forged QuorumCerts that would be accepted by the validator on restart. This violates the fundamental consensus safety guarantee that all certified blocks must have valid signatures from 2f+1 validators.

## Finding Description

When a validator restarts, the consensus layer recovers its state from ConsensusDB through `PersistentLivenessStorage::start()`. The recovery process loads blocks and QuorumCerts from persistent storage and rebuilds the block tree. However, unlike QuorumCerts received from network peers (which undergo signature verification), QCs loaded from ConsensusDB are accepted without any cryptographic validation.

**Critical Code Path - Recovery without Validation:**

1. `StorageWriteProxy::start()` loads QCs from ConsensusDB: [1](#0-0) 

2. These QCs are passed to `RecoveryData::new()`: [2](#0-1) 

3. `RecoveryData::new()` calls `find_root()` which searches for matching QCs but never validates signatures: [3](#0-2) 

4. The recovery data is passed to `BlockStore::new()`: [4](#0-3) 

5. `BlockStore::build()` inserts QCs via `insert_single_quorum_cert()`: [5](#0-4) 

6. `insert_single_quorum_cert()` only validates structural consistency, NOT signatures: [6](#0-5) 

**Contrast with Network Path - Proper Validation:**

When QCs arrive via network messages, they are cryptographically verified:

- `SyncInfo::verify()` validates QC signatures: [7](#0-6) 

- `Block::validate_signature()` verifies QC signatures in proposals: [8](#0-7) 

- `QuorumCert::verify()` performs actual signature verification: [9](#0-8) 

**Attack Scenario:**

1. Attacker gains filesystem access to validator's ConsensusDB (via backup manipulation, container escape, filesystem vulnerability, or supply chain attack)
2. Attacker crafts a forged QuorumCert with invalid/missing signatures for a malicious block
3. Attacker injects the forged QC into ConsensusDB
4. Validator restarts and loads the forged QC without signature verification
5. Validator accepts the forged QC and incorporates it into consensus state
6. Validator may commit to a chain that lacks proper 2f+1 validator signatures

**Broken Invariants:**
- **Consensus Safety**: AptosBFT's guarantee that all certified blocks have 2f+1 valid signatures is violated
- **Cryptographic Correctness**: BLS signature verification is bypassed for recovery path

## Impact Explanation

This is a **Critical Severity** vulnerability per Aptos bug bounty criteria:

**Consensus/Safety Violation**: The core invariant of AptosBFT is that a block can only be certified if 2f+1 validators sign it. By accepting forged QCs during recovery, a validator could:
- Commit to blocks without proper validator consensus
- Diverge from the honest chain, causing a fork
- Violate Byzantine fault tolerance guarantees

**Network Partition Risk**: If multiple validators load corrupted ConsensusDB state, they could form a divergent partition that cannot reconcile with honest validators without manual intervention or hard fork.

**Defense-in-Depth Failure**: Even trusted persistent storage should not bypass cryptographic verification. This violates security engineering principles and creates unnecessary attack surface.

While the validator verifier is available during recovery (as shown by `epoch_state.verifier` being accessible), it is never used to validate recovered QCs. [10](#0-9) 

## Likelihood Explanation

**Attack Prerequisites:**
- Filesystem access to validator's ConsensusDB directory
- Ability to modify RocksDB database files
- Knowledge of QC serialization format

**Realistic Attack Vectors:**
1. **Backup/Restore Manipulation**: Interception and modification of validator backup archives
2. **Container/VM Escape**: In cloud deployments, escape to host filesystem
3. **Filesystem Vulnerabilities**: Path traversal or arbitrary file write bugs in validator software
4. **Supply Chain Attacks**: Compromise of storage providers or backup systems
5. **Physical Access**: In co-location scenarios

The likelihood is **Medium to High** for sophisticated attackers, as filesystem access vectors are well-understood in security research and validator infrastructure often involves multiple trust boundaries (cloud providers, backup systems, monitoring tools).

## Recommendation

**Immediate Fix**: Add QC signature verification during recovery before inserting into BlockStore.

Modify `StorageWriteProxy::start()` to validate all recovered QCs:

```rust
// In consensus/src/persistent_liveness_storage.rs
fn start(&self, order_vote_enabled: bool, window_size: Option<u64>) -> LivenessStorageData {
    info!("Start consensus recovery.");
    let raw_data = self.db.get_data().expect("unable to recover consensus data");
    
    // ... existing code ...
    
    let blocks = raw_data.2;
    let quorum_certs: Vec<_> = raw_data.3;
    
    // NEW: Validate QC signatures during recovery
    let latest_ledger_info = self.aptos_db.get_latest_ledger_info()
        .expect("Failed to get latest ledger info.");
    let ledger_recovery_data = LedgerRecoveryData::new(latest_ledger_info.clone());
    
    // Get validator verifier from latest epoch state
    if let Some(epoch_state) = latest_ledger_info.ledger_info().next_epoch_state() {
        let validator = &epoch_state.verifier;
        
        // Verify all recovered QCs
        for qc in &quorum_certs {
            if let Err(e) = qc.verify(validator) {
                error!("Invalid QC signature during recovery: {:?}, QC: {}", e, qc);
                // Fall back to partial recovery if any QC is invalid
                return LivenessStorageData::PartialRecoveryData(ledger_recovery_data);
            }
        }
        info!("All recovered QCs validated successfully");
    }
    
    // ... continue with existing recovery logic ...
}
```

**Alternative**: Validate in `BlockStore::insert_single_quorum_cert()` by accepting a `ValidatorVerifier` parameter and calling `qc.verify(validator)` before insertion.

**Defense-in-Depth**: Consider adding HMAC/signature over the entire ConsensusDB contents to detect tampering at the database level.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[cfg(test)]
mod test_recovery_qc_validation {
    use super::*;
    use aptos_consensus_types::{
        block::Block, quorum_cert::QuorumCert, vote_data::VoteData,
    };
    use aptos_crypto::HashValue;
    use aptos_types::{
        aggregate_signature::AggregateSignature,
        block_info::BlockInfo,
        ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
    };
    use aptos_bitvec::BitVec;
    
    #[test]
    fn test_forged_qc_accepted_during_recovery() {
        // Create a forged QC with invalid signatures
        let block_info = BlockInfo::new(
            1, // epoch
            0, // round  
            HashValue::random(),
            HashValue::random(),
            0, // version
            0, // timestamp
            None,
        );
        
        let vote_data = VoteData::new(block_info.clone(), block_info.clone());
        let ledger_info = LedgerInfo::new(block_info, vote_data.hash());
        
        // Create QC with EMPTY signature (invalid!)
        let forged_qc = QuorumCert::new(
            vote_data,
            LedgerInfoWithSignatures::new(
                ledger_info,
                AggregateSignature::empty(), // No valid signatures!
            ),
        );
        
        // During recovery, this forged QC would be accepted without verification
        // In normal operation, it would be rejected by verify()
        
        // This test demonstrates that insert_single_quorum_cert() does not
        // call verify() and would accept the forged QC
        
        // Expected: QC signature should be verified during recovery
        // Actual: QC is accepted without signature verification
    }
}
```

## Notes

The validator verifier is available in the epoch state during recovery, so adding validation is straightforward and does not require architectural changes. The fix should have minimal performance impact as signature verification is already parallelized in the codebase using rayon.

This vulnerability requires filesystem-level access to ConsensusDB, which may involve compromising validator infrastructure. However, defense-in-depth principles dictate that cryptographic verification should never be bypassed, even for trusted storage, as storage can be compromised through various attack vectors (backup manipulation, container escape, filesystem bugs, supply chain).

The absence of validation creates unnecessary risk and violates the security principle that all inputs—even from persistent storage—should be validated against their cryptographic guarantees.

### Citations

**File:** consensus/src/persistent_liveness_storage.rs (L358-364)
```rust
        let root = ledger_recovery_data
            .find_root(
                &mut blocks,
                &mut quorum_certs,
                order_vote_enabled,
                window_size,
            )
```

**File:** consensus/src/persistent_liveness_storage.rs (L533-534)
```rust
        let blocks = raw_data.2;
        let quorum_certs: Vec<_> = raw_data.3;
```

**File:** consensus/src/persistent_liveness_storage.rs (L559-568)
```rust
        match RecoveryData::new(
            last_vote,
            ledger_recovery_data.clone(),
            blocks,
            accumulator_summary.into(),
            quorum_certs,
            highest_2chain_timeout_cert,
            order_vote_enabled,
            window_size,
        ) {
```

**File:** consensus/src/epoch_manager.rs (L818-824)
```rust
        let epoch = epoch_state.epoch;
        info!(
            epoch = epoch_state.epoch,
            validators = epoch_state.verifier.to_string(),
            root_block = %recovery_data.commit_root_block(),
            "Starting new epoch",
        );
```

**File:** consensus/src/epoch_manager.rs (L887-899)
```rust
        let block_store = Arc::new(BlockStore::new(
            Arc::clone(&self.storage),
            recovery_data,
            self.execution_client.clone(),
            self.config.max_pruned_blocks_in_mem,
            Arc::clone(&self.time_service),
            self.config.vote_back_pressure_limit,
            payload_manager,
            onchain_consensus_config.order_vote_enabled(),
            onchain_consensus_config.window_size(),
            self.pending_blocks.clone(),
            Some(pipeline_builder),
        ));
```

**File:** consensus/src/block_storage/block_store.rs (L299-305)
```rust
        for qc in quorum_certs {
            block_store
                .insert_single_quorum_cert(qc)
                .unwrap_or_else(|e| {
                    panic!("[BlockStore] failed to insert quorum during build{:?}", e)
                });
        }
```

**File:** consensus/src/block_storage/block_store.rs (L519-556)
```rust
    pub fn insert_single_quorum_cert(&self, qc: QuorumCert) -> anyhow::Result<()> {
        // If the parent block is not the root block (i.e not None), ensure the executed state
        // of a block is consistent with its QuorumCert, otherwise persist the QuorumCert's
        // state and on restart, a new execution will agree with it.  A new execution will match
        // the QuorumCert's state on the next restart will work if there is a memory
        // corruption, for example.
        match self.get_block(qc.certified_block().id()) {
            Some(pipelined_block) => {
                ensure!(
                    // decoupled execution allows dummy block infos
                    pipelined_block
                        .block_info()
                        .match_ordered_only(qc.certified_block()),
                    "QC for block {} has different {:?} than local {:?}",
                    qc.certified_block().id(),
                    qc.certified_block(),
                    pipelined_block.block_info()
                );
                observe_block(
                    pipelined_block.block().timestamp_usecs(),
                    BlockStage::QC_ADDED,
                );
                if pipelined_block.block().is_opt_block() {
                    observe_block(
                        pipelined_block.block().timestamp_usecs(),
                        BlockStage::QC_ADDED_OPT_BLOCK,
                    );
                }
                pipelined_block.set_qc(Arc::new(qc.clone()));
            },
            None => bail!("Insert {} without having the block in store first", qc),
        };

        self.storage
            .save_tree(vec![], vec![qc.clone()])
            .context("Insert block failed when saving quorum")?;
        self.inner.write().insert_quorum_cert(qc)
    }
```

**File:** consensus/consensus-types/src/sync_info.rs (L187-211)
```rust
        self.highest_quorum_cert
            .verify(validator)
            .and_then(|_| {
                self.highest_ordered_cert
                    .as_ref()
                    .map_or(Ok(()), |cert| cert.verify(validator))
                    .context("Fail to verify ordered certificate")
            })
            .and_then(|_| {
                // we do not verify genesis ledger info
                if self.highest_commit_cert.commit_info().round() > 0 {
                    self.highest_commit_cert
                        .verify(validator)
                        .context("Fail to verify commit certificate")?
                }
                Ok(())
            })
            .and_then(|_| {
                if let Some(tc) = &self.highest_2chain_timeout_cert {
                    tc.verify(validator)?;
                }
                Ok(())
            })
            .context("Fail to verify SyncInfo")?;
        Ok(())
```

**File:** consensus/consensus-types/src/block.rs (L425-464)
```rust
    pub fn validate_signature(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        match self.block_data.block_type() {
            BlockType::Genesis => bail!("We should not accept genesis from others"),
            BlockType::NilBlock { .. } => self.quorum_cert().verify(validator),
            BlockType::Proposal { author, .. } => {
                let signature = self
                    .signature
                    .as_ref()
                    .ok_or_else(|| format_err!("Missing signature in Proposal"))?;
                let (res1, res2) = rayon::join(
                    || validator.verify(*author, &self.block_data, signature),
                    || self.quorum_cert().verify(validator),
                );
                res1?;
                res2
            },
            BlockType::ProposalExt(proposal_ext) => {
                let signature = self
                    .signature
                    .as_ref()
                    .ok_or_else(|| format_err!("Missing signature in Proposal"))?;
                let (res1, res2) = rayon::join(
                    || validator.verify(*proposal_ext.author(), &self.block_data, signature),
                    || self.quorum_cert().verify(validator),
                );
                res1?;
                res2
            },
            BlockType::OptimisticProposal(p) => {
                // Note: Optimistic proposal is not signed by proposer unlike normal proposal
                let (res1, res2) = rayon::join(
                    || p.grandparent_qc().verify(validator),
                    || self.quorum_cert().verify(validator),
                );
                res1?;
                res2
            },
            BlockType::DAGBlock { .. } => bail!("We should not accept DAG block from others"),
        }
    }
```

**File:** consensus/consensus-types/src/quorum_cert.rs (L119-148)
```rust
    pub fn verify(&self, validator: &ValidatorVerifier) -> anyhow::Result<()> {
        let vote_hash = self.vote_data.hash();
        ensure!(
            self.ledger_info().ledger_info().consensus_data_hash() == vote_hash,
            "Quorum Cert's hash mismatch LedgerInfo"
        );
        // Genesis's QC is implicitly agreed upon, it doesn't have real signatures.
        // If someone sends us a QC on a fake genesis, it'll fail to insert into BlockStore
        // because of the round constraint.
        if self.certified_block().round() == 0 {
            ensure!(
                self.parent_block() == self.certified_block(),
                "Genesis QC has inconsistent parent block with certified block"
            );
            ensure!(
                self.certified_block() == self.ledger_info().ledger_info().commit_info(),
                "Genesis QC has inconsistent commit block with certified block"
            );
            ensure!(
                self.ledger_info().get_num_voters() == 0,
                "Genesis QC should not carry signatures"
            );
            return Ok(());
        }
        self.ledger_info()
            .verify_signatures(validator)
            .context("Fail to verify QuorumCert")?;
        self.vote_data.verify()?;
        Ok(())
    }
```
