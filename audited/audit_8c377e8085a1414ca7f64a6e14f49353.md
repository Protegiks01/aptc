# Audit Report

## Title
Abstract Authenticator Bypass of PublicKey Transaction Filters

## Summary
The transaction filtering system's PublicKey matcher explicitly returns `false` for `AccountAuthenticator::Abstract` variants, allowing attackers to completely bypass PublicKey-based Deny/Allow rules by using Abstract authenticators instead of traditional signature schemes (Ed25519, MultiEd25519, SingleKey, MultiKey). [1](#0-0) 

## Finding Description
The `matches_account_authenticator_public_key` function handles all `AccountAuthenticator` variants to determine if a transaction's authenticator contains a specific public key for filtering purposes. While it properly checks Ed25519, MultiEd25519, SingleKey, and MultiKey authenticators, it explicitly returns `false` for Abstract authenticators: [2](#0-1) 

This design means that if a node operator configures transaction filters to deny transactions from a specific public key (e.g., to block a malicious actor), an attacker can bypass this filter by submitting transactions using an Abstract authenticator instead. Abstract authenticators are fully supported in Aptos and delegate signature verification to custom Move functions: [3](#0-2) [4](#0-3) 

**Attack Path:**
1. Node operator sets up a Deny rule: `TransactionMatcher::PublicKey(attacker_key)` to block a malicious actor
2. The filter is deployed across mempool, consensus, and execution layers via `TransactionFiltersConfig`: [5](#0-4) 

3. Attacker creates an Abstract authenticator transaction pointing to a custom Move authentication function
4. The PublicKey matcher calls `matches_transaction_authenticator_public_key`: [6](#0-5) 

5. This eventually calls `matches_account_authenticator_public_key` which returns `false` for Abstract authenticators
6. Since the Deny rule doesn't match, the transaction is allowed by default
7. The transaction passes through all filter layers (mempool, consensus, execution) and gets executed

## Impact Explanation
This vulnerability falls under **High Severity** based on the Aptos bug bounty criteria as it enables "Significant protocol violations" by allowing attackers to bypass security policies:

- **Transaction Admission Control Bypass**: Filters are applied at critical layers including mempool submission, consensus proposal voting, and block execution: [7](#0-6) 

- **Policy Enforcement Failure**: Node operators lose the ability to enforce PublicKey-based access control, which may be critical for network security
- **No Compensating Controls**: There is no alternative filter type specifically for Abstract authenticators, leaving operators unable to block these transactions
- **Network-Wide Impact**: All nodes running with PublicKey filters can be bypassed simultaneously

While this doesn't directly cause consensus violations or fund loss, it breaks the intended security boundary of the filtering system, which operators may rely on to exclude malicious actors from the network.

## Likelihood Explanation
**Likelihood: High**

The attack is highly feasible because:
1. Abstract authenticators are a fully supported, production feature in Aptos with documented usage
2. Any user can create transactions with Abstract authenticators without special privileges
3. The bypass is complete - Abstract authenticators will never match any PublicKey filter
4. The behavior is deterministic and reliable for attackers
5. Node operators may configure PublicKey filters without awareness of this bypass

The only barrier is that the attacker must have an account configured to use Abstract authentication, but this can be set up during account creation or via authentication key rotation.

## Recommendation
Implement explicit handling for Abstract authenticators in the filtering system. Options include:

**Option 1: Add Abstract Authenticator Matcher**
Create a new `TransactionMatcher::AbstractAuthenticator(AccountAddress, String, String)` variant that matches based on the function_info (module address, module name, function name) used in the Abstract authenticator: [8](#0-7) 

**Option 2: Match by Derived Authentication Key**
For Abstract authenticators, extract and match against the authentication key or the FunctionInfo that defines the authentication logic, allowing operators to filter these transactions.

**Option 3: Fail-Secure for Unknown Types**
Modify `matches_account_authenticator_public_key` to have an explicit allowlist mode where Abstract authenticators can optionally be treated as "no match" (current behavior) or "always match deny rules" based on configuration.

**Recommended Implementation:**
The safest approach is Option 1, adding a dedicated matcher while documenting that PublicKey filters only apply to key-based authenticators. Update the filter configuration to support:

```rust
pub enum TransactionMatcher {
    // ... existing variants ...
    AbstractFunction(AccountAddress, String, String), // module_address, module_name, function_name
}
```

This allows operators to explicitly filter Abstract authenticators while maintaining backward compatibility.

## Proof of Concept

```rust
#[cfg(test)]
mod abstract_authenticator_bypass_poc {
    use super::*;
    use aptos_crypto::ed25519::Ed25519PrivateKey;
    use aptos_types::{
        chain_id::ChainId,
        function_info::FunctionInfo,
        transaction::{RawTransaction, Script, TransactionPayload},
    };

    #[test]
    fn test_abstract_authenticator_bypasses_public_key_filter() {
        // Step 1: Create a private key that we want to block
        let blocked_private_key = Ed25519PrivateKey::generate_for_testing();
        let blocked_public_key = AnyPublicKey::ed25519(blocked_private_key.public_key());

        // Step 2: Create a filter that denies transactions from this public key
        let filter = TransactionFilter::empty()
            .add_public_key_filter(false, blocked_public_key.clone()); // false = Deny

        // Step 3: Create a normal Ed25519 transaction with the blocked key
        let raw_txn = RawTransaction::new(
            AccountAddress::random(),
            0,
            TransactionPayload::Script(Script::new(vec![], vec![], vec![])),
            0,
            0,
            0,
            ChainId::new(1),
        );
        let signature = blocked_private_key.sign(&raw_txn).unwrap();
        let signed_txn_ed25519 = SignedTransaction::new(
            raw_txn.clone(),
            blocked_private_key.public_key(),
            signature,
        );

        // Step 4: Verify that the Ed25519 transaction is correctly DENIED
        assert_eq!(
            filter.allows_transaction(&signed_txn_ed25519),
            false,
            "Ed25519 transaction should be denied by the filter"
        );

        // Step 5: Create an Abstract authenticator transaction
        // The attacker uses the SAME account but with an Abstract authenticator
        let function_info = FunctionInfo::new(
            AccountAddress::random(),
            "custom_auth".to_string(),
            "verify".to_string(),
        );
        let abstract_authenticator =
            AccountAuthenticator::abstraction(function_info, vec![0; 32], vec![0; 64]);
        let signed_txn_abstract = SignedTransaction::new_single_sender(
            raw_txn.clone(),
            abstract_authenticator,
        );

        // Step 6: VULNERABILITY: The Abstract authenticator transaction is ALLOWED
        // even though it's from the same attacker, bypassing the PublicKey filter
        assert_eq!(
            filter.allows_transaction(&signed_txn_abstract),
            true,
            "VULNERABILITY: Abstract authenticator bypasses PublicKey filter!"
        );

        println!("âœ— VULNERABILITY CONFIRMED: Abstract authenticators bypass PublicKey filters");
        println!("  - Ed25519 transaction: DENIED (as expected)");
        println!("  - Abstract transaction: ALLOWED (bypass!)");
    }
}
```

**Notes**

The vulnerability exists as a design limitation where the filtering system cannot match Abstract authenticators against public keys because these authenticators fundamentally delegate authentication to custom Move code rather than containing explicit public keys. However, this creates a security gap where attackers aware of this limitation can bypass PublicKey-based access controls. The existing test suite confirms this behavior is intentional: [9](#0-8) 

Node operators should be aware that PublicKey filters only apply to traditional key-based authenticators (Ed25519, MultiEd25519, SingleKey, MultiKey) and provide no protection against Abstract authenticators. To comprehensively control transaction admission, operators must use AccountAddress filters or implement a new AbstractAuthenticator matcher.

### Citations

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L204-206)
```rust
            TransactionMatcher::PublicKey(public_key) => {
                matches_transaction_authenticator_public_key(signed_transaction, public_key)
            },
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L282-309)
```rust
/// Returns true iff the account authenticator contains the given public key
fn matches_account_authenticator_public_key(
    account_authenticator: &AccountAuthenticator,
    any_public_key: &AnyPublicKey,
) -> bool {
    // Match all variants explicitly to ensure future enum changes are caught during compilation
    match account_authenticator {
        AccountAuthenticator::NoAccountAuthenticator | AccountAuthenticator::Abstract { .. } => {
            false
        },
        AccountAuthenticator::Ed25519 { public_key, .. } => {
            compare_ed25519_public_key(public_key, any_public_key)
        },
        AccountAuthenticator::MultiEd25519 { public_key, .. } => {
            public_key.public_keys().iter().any(|ed25519_public_key| {
                compare_ed25519_public_key(ed25519_public_key, any_public_key)
            })
        },
        AccountAuthenticator::SingleKey { authenticator } => {
            authenticator.public_key() == any_public_key
        },
        AccountAuthenticator::MultiKey { authenticator } => authenticator
            .public_keys()
            .public_keys()
            .iter()
            .any(|key| key == any_public_key),
    }
}
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L757-771)
```rust
        // Create an abstraction account authenticator
        let function_info = FunctionInfo::new(
            AccountAddress::random(),
            "test_module".to_string(),
            "test_function".to_string(),
        );
        let account_authenticator =
            AccountAuthenticator::abstraction(function_info, vec![], vec![]);

        // Verify that the authenticator doesn't match the public key
        verify_matches_account_auth_public_key(
            &account_authenticator,
            &AnyPublicKey::ed25519(private_key_1.public_key()),
            false,
        );
```

**File:** types/src/transaction/authenticator.rs (L543-545)
```rust
    Abstract {
        authenticator: AbstractAuthenticator,
    }, // ... add more schemes here
```

**File:** types/src/transaction/authenticator.rs (L548-563)
```rust
#[derive(Clone, Debug, Eq, PartialEq, Serialize, Deserialize, Hash)]
pub struct AbstractAuthenticator {
    /// An abstract `authenticator` should be verifiable by the function in `function_info` over the signing_message_digest = sha3_256(signing_message(AASigningData(original_signing_message, function_info))))
    /// For example, consider the following authentication function:
    ///
    ///   fun verify(owner: signer, authenticator: vector<u8>, signing_message_digest: vector<u8>) -> signer
    ///
    /// It might operate by, for example:
    ///  1. Looking up the public key of `owner` in some table
    ///  2. Parsing the `authenticator` as an RSA signature
    ///  2. Verifying this RSA signature over the `signing_message_digest` under this public key
    ///
    /// Note: Abstract authenticators don't exactly follow the `AccountAuthenticator` paradigm, where an "authenticator" typically consists of a public key and a signature.
    function_info: FunctionInfo,
    auth_data: AbstractAuthenticationData,
}
```

**File:** config/src/config/transaction_filters_config.rs (L12-18)
```rust
pub struct TransactionFiltersConfig {
    pub api_filter: TransactionFilterConfig, // Filter for the API (e.g., txn simulation)
    pub consensus_filter: BlockTransactionFilterConfig, // Filter for consensus (e.g., proposal voting)
    pub execution_filter: BlockTransactionFilterConfig, // Filter for execution (e.g., block execution)
    pub mempool_filter: TransactionFilterConfig,        // Filter for mempool (e.g., txn submission)
    pub quorum_store_filter: BatchTransactionFilterConfig, // Filter for quorum store (e.g., batch voting)
}
```

**File:** consensus/src/payload_manager/direct_mempool_payload_manager.rs (L30-70)
```rust
    fn check_denied_inline_transactions(
        &self,
        block: &Block,
        block_txn_filter_config: &BlockTransactionFilterConfig,
    ) -> anyhow::Result<()> {
        // If the filter is disabled, return early
        if !block_txn_filter_config.is_enabled() {
            return Ok(());
        }

        // Get the inline transactions for the block proposal. Note: all
        // transactions in a direct mempool payload are inline transactions.
        let (inline_transactions, _, _) = get_transactions_from_block(block)?;
        if inline_transactions.is_empty() {
            return Ok(());
        }

        // Fetch the block metadata
        let block_id = block.id();
        let block_author = block.author();
        let block_epoch = block.epoch();
        let block_timestamp = block.timestamp_usecs();

        // Identify any denied inline transactions
        let block_transaction_filter = block_txn_filter_config.block_transaction_filter();
        let denied_inline_transactions = block_transaction_filter.get_denied_block_transactions(
            block_id,
            block_author,
            block_epoch,
            block_timestamp,
            inline_transactions,
        );
        if !denied_inline_transactions.is_empty() {
            return Err(anyhow::anyhow!(
                "Inline transactions for DirectMempoolPayload denied by block transaction filter: {:?}",
                denied_inline_transactions
            ));
        }

        Ok(()) // No transactions were denied
    }
```
