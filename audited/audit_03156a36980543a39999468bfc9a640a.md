# Audit Report

## Title
Consensus Observer Root State Regression via Unchecked update_root() Calls

## Summary
The `update_root()` function in `ObserverBlockData` lacks validation to ensure the new root is monotonically increasing. This allows potential state regression when multiple asynchronous code paths update the root in non-deterministic order, violating state consistency for observer nodes.

## Finding Description
The vulnerability exists in the interaction between three code paths that update the consensus observer's root ledger info:

1. **Validated path**: `handle_committed_blocks()` [1](#0-0)  contains proper round validation before updating the root [2](#0-1) 

2. **Unvalidated path 1**: `process_fallback_sync_notification()` directly calls `update_root()` without validation [3](#0-2) 

3. **Unvalidated path 2**: `update_blocks_for_state_sync_commit()` calls `update_root()` without validation [4](#0-3) 

The core issue is that `update_root()` performs no validation [5](#0-4) 

The developers were aware of this risk, as evidenced by their comment in `handle_committed_blocks()` [6](#0-5)  stating: "Note: we only want to do this if the new ledger info round is greater than the current root round. Otherwise, this can race with the state sync process."

However, this protection was only implemented in one of the three update paths.

**Race Condition Scenario:**
1. Observer node at root epoch 10, round 100
2. Node enters fallback mode, initiates state sync at T₀
3. At T₁: New commit decision arrives for round 110, calls `update_blocks_for_state_sync_commit()` → `update_root(ledger_110)`
4. Root advances to round 110
5. At T₂: Delayed fallback sync completes with round 105, calls `update_root(ledger_105)` without validation
6. Root regresses from 110 to 105

While `Arc<Mutex<>>` prevents true concurrent writes [7](#0-6) , it only serializes access—it cannot prevent logical race conditions based on execution order.

## Impact Explanation
**Severity Assessment: Medium**

This vulnerability affects consensus observer nodes (non-validator full nodes) only. The impact includes:

- **State Inconsistency**: Observer nodes could report incorrect blockchain state to clients
- **Non-deterministic Behavior**: Different observer nodes may have different root values depending on message timing
- **Data Integrity**: Clients querying observer nodes could receive inconsistent or outdated state

This qualifies as **Medium Severity** per Aptos bug bounty criteria: "State inconsistencies requiring intervention."

It does NOT qualify as Critical because:
- It does not affect validator consensus (only observers)
- No funds can be stolen or minted
- The network continues operating normally
- Validators maintain correct state

## Likelihood Explanation
**Likelihood: Medium**

The race condition can occur during:
- Network partitions causing fallback sync
- Concurrent state sync operations and commit processing
- Delayed consensus messages arriving out of order
- Observer nodes catching up after being offline

While not trivially exploitable by external attackers, the condition can naturally arise during:
- Network instability
- Node startup/recovery
- High latency environments

The lack of validation in `update_root()` means any timing variance in asynchronous operations can trigger the bug.

## Recommendation
Add monotonicity validation to `update_root()` to ensure the root never regresses:

```rust
/// Updates the root ledger info
pub fn update_root(&mut self, new_root: LedgerInfoWithSignatures) {
    let current_root = self.root.commit_info();
    let new_root_info = new_root.commit_info();
    
    // Only update if the new root is for a higher epoch or higher round in the same epoch
    if new_root_info.epoch() > current_root.epoch() || 
       (new_root_info.epoch() == current_root.epoch() && 
        new_root_info.round() > current_root.round()) {
        self.root = new_root;
    } else {
        warn!(
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Attempted to update root with older ledger info. Current: (epoch: {}, round: {}), New: (epoch: {}, round: {})",
                current_root.epoch(), current_root.round(),
                new_root_info.epoch(), new_root_info.round()
            ))
        );
    }
}
```

This applies the same validation logic already present in `handle_committed_blocks()` [2](#0-1)  to all update paths.

## Proof of Concept

```rust
#[cfg(test)]
mod race_condition_test {
    use super::*;
    use std::sync::{Arc, Barrier};
    use std::thread;
    
    #[test]
    fn test_update_root_race_condition() {
        // Create observer block data at epoch 10, round 100
        let root_100 = create_ledger_info(10, 100);
        let observer_data = Arc::new(Mutex::new(
            ObserverBlockData::new_with_root(
                ConsensusObserverConfig::default(), 
                root_100.clone()
            )
        ));
        
        // Create ledger infos for different rounds
        let ledger_110 = create_ledger_info(10, 110);
        let ledger_105 = create_ledger_info(10, 105);
        
        let barrier = Arc::new(Barrier::new(2));
        let data1 = observer_data.clone();
        let data2 = observer_data.clone();
        let b1 = barrier.clone();
        let b2 = barrier.clone();
        
        // Thread 1: Update to round 110
        let handle1 = thread::spawn(move || {
            b1.wait(); // Synchronize start
            data1.lock().update_root(ledger_110);
        });
        
        // Thread 2: Update to round 105 (older)
        let handle2 = thread::spawn(move || {
            b2.wait(); // Synchronize start
            thread::sleep(std::time::Duration::from_millis(10)); // Slight delay
            data2.lock().update_root(ledger_105);
        });
        
        handle1.join().unwrap();
        handle2.join().unwrap();
        
        // Check final root - due to the race, it could be either 110 or 105
        let final_root = observer_data.lock().root();
        let final_round = final_root.commit_info().round();
        
        // This demonstrates the non-deterministic behavior
        // The root should be 110 (highest), but could regress to 105
        println!("Final root round: {}", final_round);
        
        // Without the fix, this assertion may fail:
        assert_eq!(final_round, 110, "Root regressed to older round!");
    }
}
```

## Notes
- The vulnerability is in production code paths used by consensus observer nodes
- The existing validation in `handle_committed_blocks()` demonstrates the developers' awareness of the race condition risk
- The fix is straightforward: apply the same validation to all root update paths
- Observer nodes should also implement additional defensive checks when processing state sync notifications to verify the ledger info is actually newer than the current state

### Citations

**File:** consensus/src/consensus_observer/observer/block_data.rs (L182-219)
```rust
    fn handle_committed_blocks(&mut self, ledger_info: LedgerInfoWithSignatures) {
        // Remove the committed blocks from the payload and ordered block stores
        self.block_payload_store.remove_blocks_for_epoch_round(
            ledger_info.commit_info().epoch(),
            ledger_info.commit_info().round(),
        );
        self.ordered_block_store
            .remove_blocks_for_commit(&ledger_info);

        // Verify the ledger info is for the same epoch
        let root_commit_info = self.root.commit_info();
        if ledger_info.commit_info().epoch() != root_commit_info.epoch() {
            warn!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Received commit callback for a different epoch! Ledger info: {:?}, Root: {:?}",
                    ledger_info.commit_info(),
                    root_commit_info
                ))
            );
            return;
        }

        // Update the root ledger info. Note: we only want to do this if
        // the new ledger info round is greater than the current root
        // round. Otherwise, this can race with the state sync process.
        if ledger_info.commit_info().round() > root_commit_info.round() {
            info!(
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Updating the root ledger info! Old root: (epoch: {:?}, round: {:?}). New root: (epoch: {:?}, round: {:?})",
                root_commit_info.epoch(),
                root_commit_info.round(),
                ledger_info.commit_info().epoch(),
                ledger_info.commit_info().round(),
            ))
        );
            self.root = ledger_info;
        }
    }
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L281-282)
```rust
        // Update the root
        self.update_root(commit_proof.clone());
```

**File:** consensus/src/consensus_observer/observer/block_data.rs (L299-302)
```rust
    /// Updates the root ledger info
    pub fn update_root(&mut self, new_root: LedgerInfoWithSignatures) {
        self.root = new_root;
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L75-75)
```rust
    observer_block_data: Arc<Mutex<ObserverBlockData>>,
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L947-950)
```rust
        // Update the root with the latest synced ledger info
        self.observer_block_data
            .lock()
            .update_root(latest_synced_ledger_info);
```
