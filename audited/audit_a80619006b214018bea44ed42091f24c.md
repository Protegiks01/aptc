# Audit Report

## Title
Consensus-Only Performance Test Mode Can Be Enabled on Mainnet via Sanitizer Bypass

## Summary
The `consensus-only-perf-test` feature flag check can be bypassed on mainnet nodes, allowing deployment of validators that skip transaction execution, use in-memory storage, and bypass mempool validation. This causes deterministic execution failures and consensus safety violations.

## Finding Description

The `is_consensus_only_perf_test_enabled()` function is a compile-time check that returns `true` when the binary is built with the `consensus-only-perf-test` feature flag. [1](#0-0) 

The only runtime safeguard preventing this performance test mode from running on mainnet is in the `ConsensusConfig::sanitize()` method: [2](#0-1) 

**Critical Flaw**: This check only executes `if let Some(chain_id) = chain_id`, meaning it is completely skipped when `chain_id` is `None`.

The `chain_id` parameter comes from `extract_node_type_and_chain_id()`, which catches all errors from `get_chain_id()` and returns `None`: [3](#0-2) 

Additionally, the entire sanitizer can be bypassed via configuration: [4](#0-3) 

**Attack Path:**
1. Compile `aptos-node` with `--features consensus-only-perf-test`
2. Deploy on mainnet using either:
   - **Bypass A**: Omit or corrupt the genesis transaction file, causing `get_chain_id()` to fail and return `None`
   - **Bypass B**: Set `node_startup.skip_config_sanitizer: true` in the node config
3. The node passes sanitization and starts

**What Happens When This Feature is Enabled:**

The performance test mode fundamentally breaks consensus by replacing actual execution with fake results. In the executor, all non-genesis blocks skip VM execution entirely: [5](#0-4) 

Storage uses an in-memory fake implementation instead of persistent RocksDB: [6](#0-5) 

Mempool validation is completely bypassed: [7](#0-6) 

**Invariant Violation:**
This breaks the **Deterministic Execution** invariant: "All validators must produce identical state roots for identical blocks." Nodes running with this feature will produce different state roots than normal validators because they return empty WriteSets instead of executing transactions.

## Impact Explanation

**Severity: Critical** (Consensus/Safety Violation)

This vulnerability enables consensus safety violations on mainnet, qualifying for the highest severity tier in the Aptos bug bounty program. Specifically:

1. **Consensus Safety Break**: Validators running in performance test mode will compute different state roots for the same block than normal validators, causing consensus to fail on state root verification.

2. **Network Partition**: If multiple validators deploy this misconfiguration, the network will split into incompatible forks - those executing transactions normally vs. those returning fake outputs. This requires manual intervention or a hard fork to resolve.

3. **State Divergence**: Any block proposed by a performance-test validator will be rejected by honest validators during execution verification, but the malicious validator will believe it's valid, causing permanent desynchronization.

The impact affects the entire network's consensus mechanism, which qualifies as "Non-recoverable network partition (requires hardfork)" in the Critical severity category.

## Likelihood Explanation

**Likelihood: Medium-to-High**

While this requires compiling a custom binary, the barriers are low:

1. **No Special Privileges Required**: Any entity can compile the Aptos node software with custom feature flags. Validator operators routinely build from source.

2. **Trivial Bypass**: The bypasses are straightforward:
   - Simply omit the genesis file (accidental misconfiguration)
   - Or set a single config flag (`skip_config_sanitizer: true`)

3. **Realistic Scenarios**:
   - A validator operator testing performance locally, accidentally deploys the wrong binary to production
   - An attacker intentionally deploys this to disrupt mainnet consensus
   - Automated deployment scripts that skip config validation

4. **Silent Failure**: The error handling in `extract_node_type_and_chain_id()` only prints to stdout, which may not be monitored, allowing the node to start without alerting the operator.

The combination of easy exploitation and catastrophic impact makes this a serious vulnerability despite requiring binary compilation.

## Recommendation

Implement multiple defense layers:

**1. Remove the chain_id bypass** - Make the check mandatory:

```rust
fn sanitize(
    node_config: &NodeConfig,
    node_type: NodeType,
    chain_id: Option<ChainId>,
) -> Result<(), Error> {
    let sanitizer_name = Self::get_sanitizer_name();
    
    // Verify feature is not enabled in production builds
    if is_consensus_only_perf_test_enabled() {
        let chain_id = chain_id.ok_or_else(|| {
            Error::ConfigSanitizerFailed(
                sanitizer_name.clone(),
                "consensus-only-perf-test is enabled but chain_id is unknown. This feature must not be used in production!".to_string(),
            )
        })?;
        
        if chain_id.is_mainnet() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "consensus-only-perf-test must not be enabled on mainnet!".to_string(),
            ));
        }
    }
    
    // ... rest of sanitization
}
```

**2. Add compile-time enforcement** - Use mutually exclusive features:

In `Cargo.toml`, add:
```toml
[features]
consensus-only-perf-test = []
production = []

[package.metadata.aptos]
required-features = ["production"]
```

**3. Fail loudly on missing genesis** - Don't silently continue with None:

```rust
fn extract_node_type_and_chain_id(node_config: &NodeConfig) -> Result<(NodeType, ChainId), Error> {
    let node_type = NodeType::extract_from_config(node_config);
    let chain_id = get_chain_id(node_config)?; // Don't catch error
    Ok((node_type, chain_id))
}
```

**4. Restrict skip_config_sanitizer** - Only allow in test builds:

```rust
#[cfg(not(test))]
pub fn sanitize(...) -> Result<(), Error> {
    if node_config.node_startup.skip_config_sanitizer {
        return Err(Error::ConfigSanitizerFailed(
            "Config sanitizer cannot be skipped in non-test builds!".to_string()
        ));
    }
    // ... rest of sanitization
}
```

## Proof of Concept

**Step 1: Compile with performance test feature**
```bash
cd aptos-core
cargo build --release --features consensus-only-perf-test --bin aptos-node
```

**Step 2: Create a mainnet config with bypass**
```yaml
# node.yaml
base:
  role: "validator"
  waypoint:
    from_config: "0:0000000000000000000000000000000000000000000000000000000000000000"

node_startup:
  skip_config_sanitizer: true  # Bypass sanitizer

consensus:
  # ... standard consensus config
```

**Step 3: Run the node**
```bash
# Note: No genesis file provided, but skip_config_sanitizer bypasses validation
./target/release/aptos-node -f node.yaml
```

**Expected Result**: The node starts successfully despite having `consensus-only-perf-test` enabled, which should be forbidden on mainnet.

**Verification**: Check the logs - the node will execute the genesis transaction normally (because of the special case in `execute_block`), but all subsequent blocks will return fake execution results with empty WriteSets, causing it to compute different state roots than honest validators.

**Alternative PoC (Bypass A)**: Omit the genesis file entirely or provide a malformed one - the `get_chain_id()` call will fail, returning `None`, and the mainnet check will be skipped even without `skip_config_sanitizer: true`.

### Citations

**File:** config/src/config/consensus_config.rs (L515-523)
```rust
        // Verify that the consensus-only feature is not enabled in mainnet
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() && is_consensus_only_perf_test_enabled() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "consensus-only-perf-test should not be enabled in mainnet!".to_string(),
                ));
            }
        }
```

**File:** config/src/config/consensus_config.rs (L559-567)
```rust
fn is_consensus_only_perf_test_enabled() -> bool {
    cfg_if! {
        if #[cfg(feature = "consensus-only-perf-test")] {
            true
        } else {
            false
        }
    }
}
```

**File:** config/src/config/node_config_loader.rs (L112-123)
```rust
fn extract_node_type_and_chain_id(node_config: &NodeConfig) -> (NodeType, Option<ChainId>) {
    // Get the node type from the node config
    let node_type = NodeType::extract_from_config(node_config);

    // Get the chain ID from the genesis transaction
    match get_chain_id(node_config) {
        Ok(chain_id) => (node_type, Some(chain_id)),
        Err(error) => {
            println!("Failed to extract the chain ID from the genesis transaction: {:?}! Continuing with None.", error);
            (node_type, None)
        },
    }
```

**File:** config/src/config/config_sanitizer.rs (L45-48)
```rust
        // If config sanitization is disabled, don't do anything!
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L301-339)
```rust
    #[cfg(feature = "consensus-only-perf-test")]
    fn execute_block<V: VMBlockExecutor>(
        executor: &V,
        txn_provider: &DefaultTxnProvider<SignatureVerifiedTransaction>,
        state_view: &CachedStateView,
        onchain_config: BlockExecutorConfigFromOnchain,
        transaction_slice_metadata: TransactionSliceMetadata,
    ) -> Result<BlockOutput<TransactionOutput>> {
        use aptos_types::{
            state_store::{StateViewId, TStateView},
            transaction::TransactionAuxiliaryData,
            write_set::WriteSet,
        };

        let transaction_outputs = match state_view.id() {
            // this state view ID implies a genesis block in non-test cases.
            StateViewId::Miscellaneous => executor.execute_block(
                txn_provider,
                state_view,
                onchain_config,
                transaction_slice_metadata,
            )?,
            _ => BlockOutput::new(
                (0..txn_provider.num_txns())
                    .map(|_| {
                        TransactionOutput::new(
                            WriteSet::default(),
                            Vec::new(),
                            0, // Keep gas zero to match with StateCheckpoint txn output
                            TransactionStatus::Keep(ExecutionStatus::Success),
                            TransactionAuxiliaryData::None,
                        )
                    })
                    .collect::<Vec<_>>(),
                None,
            ),
        };
        Ok(transaction_outputs)
    }
```

**File:** storage/aptosdb/src/db/fake_aptosdb.rs (L151-173)
```rust
/// Alternate implementation of [AptosDB] for use with consensus-only-perf-test feature.
/// It stores and serves data from in-memory data structures as opposed to [AptosDB],
/// which uses RocksDB. Note that FakeAptosDB re-implements only a subset of the
/// features of [AptosDB] while passing through remaining features to the wrapped inner
/// [AptosDB].
pub struct FakeAptosDB {
    inner: AptosDB,
    // A map of transaction hash to transaction version
    txn_version_by_hash: Arc<DashMap<HashValue, Version>>,
    // A map of transaction version to Transaction
    txn_by_version: Arc<DashMap<Version, Transaction>>,
    // A map of transaction to TransactionInfo
    txn_info_by_version: Arc<DashMap<Version, TransactionInfo>>,
    // A map of Position to transaction HashValue
    txn_hash_by_position: Arc<DashMap<Position, HashValue>>,
    // A map of account address to the highest executed sequence number
    account_seq_num: Arc<DashMap<AccountAddress, u64>>,
    // A map of transaction version to block timestamp
    latest_block_timestamp: AtomicU64,
    latest_version: Mutex<Option<Version>>,
    ledger_commit_lock: std::sync::Mutex<()>,
    buffered_state: Mutex<FakeBufferedState>,
}
```

**File:** mempool/src/shared_mempool/tasks.rs (L555-570)
```rust
#[cfg(feature = "consensus-only-perf-test")]
fn validate_and_add_transactions<NetworkClient, TransactionValidator>(
    transactions: Vec<(SignedTransaction, Option<u64>, Option<u64>)>,
    smp: &SharedMempool<NetworkClient, TransactionValidator>,
    timeline_state: TimelineState,
    statuses: &mut Vec<(
        SignedTransaction,
        (
            MempoolStatus,
            Option<StatusCode>,
            Option<BroadcastPeerPriority>,
        ),
    )>,
    client_submitted: bool,
) where
    NetworkClient: NetworkClientInterface<MempoolSyncMsg>,
```
