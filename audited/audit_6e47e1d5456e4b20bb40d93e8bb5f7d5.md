# Audit Report

## Title
Module Verification Cost Not Accounted for in Gas Metering or Complexity Checking

## Summary
The bytecode verification process during module publishing consumes validator CPU time that is not proportionally accounted for in gas charging. While gas is charged based on module size and structural complexity is checked, the actual CPU cost of bytecode verification (which can reach 80M verifier units) operates independently without gas metering, creating a resource exhaustion vector.

## Finding Description

During module publishing, three distinct cost accounting mechanisms operate independently:

**1. Gas Charging (based on module SIZE):**
Gas is charged per byte of module dependencies using `DEPENDENCY_PER_BYTE = 42` for old module versions and new modules in the bundle. [1](#0-0) 

**2. Complexity Checking (based on STRUCTURAL complexity):**
The complexity budget is `2048 + blob.code().len() * 20` and meters primarily structural elements like signatures, function instantiations, and struct instantiations. [2](#0-1) 

The complexity check iterates through bytecode but only meters generic instantiations and vector operations, not regular instructions. [3](#0-2) 

**3. Bytecode Verification (based on VERIFICATION complexity):**
Module publishing creates `StagingModuleStorage` which performs verification WITHOUT receiving the gas meter. [4](#0-3) 

The verification is called through `build_locally_verified_module` which invokes `verify_module_with_config` without any gas metering context. [5](#0-4) 

The verification uses `BoundMeter` with production limits of 80,000,000 verifier units per function and module. [6](#0-5) 

**Critical Cost Disparity:**
Reference safety verification charges per instruction based on: `STEP_BASE_COST (10) + STEP_PER_LOCAL_COST (20) × locals + STEP_PER_GRAPH_ITEM_COST (50) × graph_size` [7](#0-6) 

An attacker can craft modules with:
- Small size (low gas via `DEPENDENCY_PER_BYTE`)
- Few generic instantiations (passes complexity check)
- Many regular instructions with high locals and complex borrow graphs (high verification cost)

While verification failures do charge gas as `MiscellaneousError`, the gas charged is based on module size, not the CPU time spent on verification attempts. [8](#0-7) 

## Impact Explanation

This is a **Medium-to-High Severity** vulnerability that enables validator resource exhaustion:

**Validator Node Slowdowns (High Severity per bounty):** Validators must perform expensive verification during transaction execution. While individual transactions fail if exceeding 80M verifier units, the CPU time spent attempting verification is not adequately compensated through gas charging. A 10KB module pays ~420,000 gas units (10,000 × 42) but can consume up to 80,000,000 verifier units - a ~190x disparity.

**Economic Attack Vector:** The asymmetric cost/damage ratio allows attackers to submit multiple such transactions per block, forcing validators to waste significant CPU cycles on verification attempts. Each failed verification still charges the attacker gas, but only based on module size, not the verification work performed.

**Mitigation Factors (limiting to Medium):**
- Transactions fail properly without state corruption
- `BoundMeter` prevents unbounded resource consumption at 80M units
- No consensus violations or fund loss
- Network slowdown is temporary, not persistent

## Likelihood Explanation

**High Likelihood** of exploitation:

1. **Easy to Execute:** Any user can publish modules through standard transaction submission
2. **No Special Privileges:** Module publishing is a permissionless operation
3. **Difficult to Detect:** Attack appears as legitimate module publishing attempts that fail verification
4. **Economically Viable:** Cost to attacker (transaction gas based on size) is significantly less than cost to validators (CPU time for verification)

An attacker can repeatedly submit such transactions, paying only the gas for module size while consuming disproportionate validator resources.

## Recommendation

Implement verification cost accounting in the gas metering system:

1. **Add Verification Gas Parameter:** Introduce a gas parameter that accounts for verification complexity (e.g., per verifier unit consumed)

2. **Pass Gas Meter to Verification:** Modify `StagingModuleStorage::create_with_compat_config` to accept and use a gas meter during verification

3. **Charge for Verification Work:** Before calling `verify_module_with_config`, charge gas proportional to expected verification cost based on module characteristics (instruction count, locals, control flow complexity)

4. **Adjust Complexity Budget:** Align the complexity check budget more closely with actual verification costs by metering all instructions, not just generic instantiations

## Proof of Concept

A PoC would construct a Move module with:
- Minimal size (~10KB)
- Few generic instantiations (to pass complexity check with budget ~202,048)
- Multiple functions with high local variable counts (e.g., 50+ locals per function)
- Complex control flow and borrow patterns (deep borrow graphs)
- Many bytecode instructions (e.g., 40,000+ instructions)

Each instruction would cost approximately `10 + 20*50 + 50*10 = 1,510` verifier units, allowing ~53,000 such instructions within the 80M limit. This module would pass gas charging and complexity checks but consume maximum verification resources, demonstrating the asymmetric cost/damage ratio.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1512-1536)
```rust
                    gas_meter
                        .charge_dependency(
                            DependencyKind::Existing,
                            addr,
                            name,
                            NumBytes::new(old_size),
                        )
                        .map_err(|err| {
                            err.finish(Location::Module(ModuleId::new(*addr, name.to_owned())))
                        })?;
                }
            }

            // Charge all modules in the bundle that is about to be published.
            for (module, blob) in modules.iter().zip(bundle.iter()) {
                let addr = module.self_addr();
                let name = module.self_name();
                gas_meter
                    .charge_dependency(
                        DependencyKind::New,
                        addr,
                        name,
                        NumBytes::new(blob.code().len() as u64),
                    )
                    .map_err(|err| err.finish(Location::Undefined))?;
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1554-1559)
```rust
        for (module, blob) in modules.iter().zip(bundle.iter()) {
            // TODO(Gas): Make budget configurable.
            let budget = 2048 + blob.code().len() as u64 * 20;
            move_binary_format::check_complexity::check_module_complexity(module, budget)
                .map_err(|err| err.finish(Location::Undefined))?;
        }
```

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L259-350)
```rust
    fn meter_code(&self, code: &CodeUnit) -> PartialVMResult<()> {
        use Bytecode::*;

        self.meter_signature(code.locals)?;

        for instr in &code.code {
            match instr {
                CallGeneric(idx) | PackClosureGeneric(idx, ..) => {
                    self.meter_function_instantiation(*idx)?;
                },
                PackGeneric(idx) | UnpackGeneric(idx) => {
                    self.meter_struct_instantiation(*idx)?;
                },
                PackVariantGeneric(idx) | UnpackVariantGeneric(idx) | TestVariantGeneric(idx) => {
                    self.meter_struct_variant_instantiation(*idx)?;
                },
                ExistsGeneric(idx)
                | MoveFromGeneric(idx)
                | MoveToGeneric(idx)
                | ImmBorrowGlobalGeneric(idx)
                | MutBorrowGlobalGeneric(idx) => {
                    self.meter_struct_instantiation(*idx)?;
                },
                ImmBorrowFieldGeneric(idx) | MutBorrowFieldGeneric(idx) => {
                    self.meter_field_instantiation(*idx)?;
                },
                ImmBorrowVariantFieldGeneric(idx) | MutBorrowVariantFieldGeneric(idx) => {
                    self.meter_variant_field_instantiation(*idx)?;
                },
                CallClosure(idx)
                | VecPack(idx, _)
                | VecLen(idx)
                | VecImmBorrow(idx)
                | VecMutBorrow(idx)
                | VecPushBack(idx)
                | VecPopBack(idx)
                | VecUnpack(idx, _)
                | VecSwap(idx) => {
                    self.meter_signature(*idx)?;
                },

                // List out the other options explicitly so there's a compile error if a new
                // bytecode gets added.
                Pop
                | Ret
                | Branch(_)
                | BrTrue(_)
                | BrFalse(_)
                | LdU8(_)
                | LdU16(_)
                | LdU32(_)
                | LdU64(_)
                | LdU128(_)
                | LdU256(_)
                | LdI8(_)
                | LdI16(_)
                | LdI32(_)
                | LdI64(_)
                | LdI128(_)
                | LdI256(_)
                | LdConst(_)
                | CastU8
                | CastU16
                | CastU32
                | CastU64
                | CastU128
                | CastU256
                | CastI8
                | CastI16
                | CastI32
                | CastI64
                | CastI128
                | CastI256
                | LdTrue
                | LdFalse
                | Call(_)
                | Pack(_)
                | Unpack(_)
                | PackVariant(_)
                | UnpackVariant(_)
                | TestVariant(_)
                | PackClosure(..)
                | ReadRef
                | WriteRef
                | FreezeRef
                | Add
                | Sub
                | Mul
                | Mod
                | Div
                | Negate
                | BitOr
```

**File:** aptos-move/aptos-vm/src/move_vm_ext/session/user_transaction_sessions/user.rs (L97-102)
```rust
        let staging_module_storage = StagingModuleStorage::create_with_compat_config(
            &destination,
            compatability_checks,
            module_storage,
            bundle.into_bytes(),
        )?;
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L178-200)
```rust
    pub fn build_locally_verified_module(
        &self,
        compiled_module: Arc<CompiledModule>,
        module_size: usize,
        module_hash: &[u8; 32],
    ) -> VMResult<LocallyVerifiedModule> {
        if !VERIFIED_MODULES_CACHE.contains(module_hash) {
            let _timer =
                VM_TIMER.timer_with_label("move_bytecode_verifier::verify_module_with_config");

            // For regular execution, we cache already verified modules. Note that this even caches
            // verification for the published modules. This should be ok because as long as the
            // hash is the same, the deployed bytecode and any dependencies are the same, and so
            // the cached verification result can be used.
            move_bytecode_verifier::verify_module_with_config(
                &self.vm_config().verifier_config,
                compiled_module.as_ref(),
            )?;
            check_natives(compiled_module.as_ref())?;
            VERIFIED_MODULES_CACHE.put(*module_hash);
        }

        Ok(LocallyVerifiedModule(compiled_module, module_size))
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L175-176)
```rust
        max_per_fun_meter_units: Some(1000 * 80000),
        max_per_mod_meter_units: Some(1000 * 80000),
```

**File:** third_party/move/move-bytecode-verifier/src/reference_safety/abstract_state.rs (L75-77)
```rust
pub(crate) const STEP_BASE_COST: u128 = 10;
pub(crate) const STEP_PER_LOCAL_COST: u128 = 20;
pub(crate) const STEP_PER_GRAPH_ITEM_COST: u128 = 50;
```

**File:** third_party/move/move-core/types/src/vm_status.rs (L300-301)
```rust
                    // A transaction that publishes code that cannot be verified will be charged.
                    StatusType::Verification => Ok(KeptVMStatus::MiscellaneousError),
```
