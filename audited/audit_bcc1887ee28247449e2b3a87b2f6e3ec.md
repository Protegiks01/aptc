# Audit Report

## Title
Logging Context Bypass in Sharded Block Execution via Missing StateViewId Override

## Summary
When sharded block execution is enabled in Aptos, the `CrossShardStateView` and `AggregatorOverriddenStateView` wrappers fail to override the `id()` method, causing them to return `StateViewId::Miscellaneous` instead of proper execution context. This triggers the testing code path in production, stripping all transaction execution logs of critical audit information (block ID, version numbers) during sharded execution.

## Finding Description

The vulnerability exists in the interaction between multiple components:

1. **Default StateViewId behavior**: The `TStateView` trait provides a default `id()` implementation that returns `StateViewId::Miscellaneous`, intended only for testing scenarios. [1](#0-0) 

2. **Missing overrides in production StateViews**: Both `CrossShardStateView` and `AggregatorOverriddenStateView`, used in sharded block execution, fail to override this method. [2](#0-1) [3](#0-2) 

3. **Logging initialization uses StateViewId**: When the `AptosExecutorTask` is initialized, it captures the `StateViewId` from the state view. [4](#0-3) 

4. **LogSchema creation uses the captured ID**: During transaction execution, `AdapterLogSchema::new()` is called with this StateViewId, creating a log context with no execution metadata when `Miscellaneous` is used. [5](#0-4) 

5. **Sharded execution wraps StateViews**: In production sharded execution, the base StateView is wrapped first in `CrossShardStateView`, then in `AggregatorOverriddenStateView`. [6](#0-5) 

**Exploitation Path:**
1. Node operator enables sharded execution by configuring `num_shards > 1` [7](#0-6) 
2. Sharded execution creates `AggregatorOverriddenStateView` wrapping `CrossShardStateView`
3. When `state_view.id()` is called, it returns `StateViewId::Miscellaneous` 
4. All transaction logs during sharded execution lose block_id, first_version, and base_version fields
5. Attackers executing exploits during sharded execution benefit from reduced forensic evidence

## Impact Explanation

This qualifies as **High Severity** under Aptos bug bounty criteria for the following reasons:

1. **Significant Protocol Violation**: Logging and auditing are critical security mechanisms. The Aptos logging infrastructure is designed to track execution context (block IDs, versions) for forensic analysis, incident response, and consensus debugging. Bypassing this violates the observability guarantees of the protocol.

2. **Aids Attack Evasion**: While not directly exploitable, this issue provides tangible benefit to attackers executing other exploits. Reduced logging makes it harder to:
   - Detect ongoing attacks in real-time
   - Perform post-incident forensic analysis
   - Trace malicious transaction execution
   - Debug consensus issues during attacks
   - Correlate events across validator nodes

3. **Production Impact**: Sharded execution is a legitimate production feature enabled on high-throughput networks. When enabled, ALL transaction execution loses audit context, affecting potentially millions of transactions.

4. **Silent Degradation**: Unlike crashes or obvious failures, this silently degrades security monitoring without alerting operators, making it particularly dangerous.

## Likelihood Explanation

**Likelihood: Medium-High**

1. **Precondition**: Requires sharded execution to be enabled (`num_shards > 1`), which is configurable and used in production for performance scaling.

2. **Automatic Trigger**: Once sharded execution is enabled, the issue triggers automatically for all transactions processed through sharded execution - no attacker action needed.

3. **Detection Difficulty**: The issue is subtle - logs still generate, but lack critical context fields. Operators may not notice the degradation unless specifically monitoring log completeness.

4. **Widespread Effect**: Affects the entire transaction execution pipeline when sharded execution is active, not isolated to specific transaction types.

## Recommendation

Both `CrossShardStateView` and `AggregatorOverriddenStateView` must override the `id()` method to delegate to their underlying base views:

**For CrossShardStateView:**
```rust
impl<S: StateView + Sync + Send> TStateView for CrossShardStateView<'_, S> {
    type Key = StateKey;

    fn id(&self) -> StateViewId {
        self.base_view.id()
    }

    // ... existing methods
}
```

**For AggregatorOverriddenStateView:**
```rust
impl<S: StateView + Sync + Send> TStateView for AggregatorOverriddenStateView<'_, S> {
    type Key = StateKey;

    fn id(&self) -> StateViewId {
        self.base_view.id()
    }

    // ... existing methods
}
```

This ensures that the original execution context (BlockExecution, ChunkExecution, or TransactionValidation) is preserved through the wrapper layers.

## Proof of Concept

To demonstrate this vulnerability:

1. **Enable sharded execution:**
```rust
// In node initialization
AptosVM::set_num_shards_once(4); // Enable 4 shards
```

2. **Execute transactions through sharded path:**
```rust
// When ExecutableTransactions::Sharded is used, observe logs
// Expected: Logs should contain block_id for BlockExecution
// Actual: Logs show LogEntry::Miscellaneous with all context fields as None
```

3. **Verify in logs:**
```rust
// Check AdapterLogSchema instances created during sharded execution
// They will have:
// - name: LogEntry::Miscellaneous (instead of LogEntry::Execution)
// - block_id: None (should have block hash)
// - first_version: None (should have version for ChunkExecution)
// - base_version: None (should have version for TransactionValidation)
```

4. **Compare with non-sharded execution:**
When `num_shards = 1`, the same transactions will have proper logging context with block_id populated, demonstrating the regression in sharded mode.

## Notes

- The vulnerability is in production code paths, not test-only code
- It affects the entire sharded execution pipeline when enabled
- The issue compounds with other potential vulnerabilities by reducing detection capability
- Both local and remote sharded execution are affected [8](#0-7)

### Citations

**File:** types/src/state_store/mod.rs (L37-39)
```rust
    fn id(&self) -> StateViewId {
        StateViewId::Miscellaneous
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_state_view.rs (L74-87)
```rust
impl<S: StateView + Sync + Send> TStateView for CrossShardStateView<'_, S> {
    type Key = StateKey;

    fn get_state_value(&self, state_key: &StateKey) -> Result<Option<StateValue>, StateViewError> {
        if let Some(value) = self.cross_shard_data.get(state_key) {
            return Ok(value.get_value());
        }
        self.base_view.get_state_value(state_key)
    }

    fn get_usage(&self) -> Result<StateStorageUsage, StateViewError> {
        Ok(StateStorageUsage::new_untracked())
    }
}
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/aggr_overridden_state_view.rs (L38-55)
```rust
impl<S: StateView + Sync + Send> TStateView for AggregatorOverriddenStateView<'_, S> {
    type Key = StateKey;

    fn get_state_value(&self, state_key: &StateKey) -> Result<Option<StateValue>> {
        if *state_key == *TOTAL_SUPPLY_STATE_KEY {
            // TODO: Remove this when we have aggregated total supply implementation for remote
            //       sharding. For now we need this because after all the txns are executed, the
            //       proof checker expects the total_supply to read/written to the tree.
            self.base_view.get_state_value(state_key)?;
            return self.total_supply_base_view_override();
        }
        self.base_view.get_state_value(state_key)
    }

    fn get_usage(&self) -> Result<StateStorageUsage> {
        self.base_view.get_usage()
    }
}
```

**File:** aptos-move/aptos-vm/src/block_executor/vm_wrapper.rs (L35-43)
```rust
    fn init(
        environment: &AptosEnvironment,
        state_view: &impl StateView,
        async_runtime_checks_enabled: bool,
    ) -> Self {
        let vm = AptosVM::new_for_block_executor(environment, async_runtime_checks_enabled);
        let id = state_view.id();
        Self { vm, id }
    }
```

**File:** aptos-move/aptos-vm-logging/src/log_schema.rs (L31-69)
```rust
    pub fn new(view_id: StateViewId, txn_idx: usize) -> Self {
        match view_id {
            StateViewId::BlockExecution { block_id } => Self {
                name: LogEntry::Execution,
                block_id: Some(block_id),
                first_version: None,
                base_version: None,
                txn_idx,
            },
            StateViewId::ChunkExecution { first_version } => Self {
                name: LogEntry::Execution,
                block_id: None,
                first_version: Some(first_version),
                base_version: None,
                txn_idx,
            },
            StateViewId::TransactionValidation { base_version } => Self {
                name: LogEntry::Validation,
                block_id: None,
                first_version: None,
                base_version: Some(base_version),
                txn_idx,
            },
            StateViewId::Replay => Self {
                name: LogEntry::Execution,
                block_id: None,
                first_version: None,
                base_version: None,
                txn_idx,
            },
            StateViewId::Miscellaneous => Self {
                name: LogEntry::Miscellaneous,
                block_id: None,
                first_version: None,
                base_version: None,
                txn_idx,
            },
        }
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_executor_service.rs (L115-126)
```rust
        let cross_shard_state_view = Arc::new(CrossShardStateView::create_cross_shard_state_view(
            state_view,
            &transactions,
        ));

        let cross_shard_state_view_clone = cross_shard_state_view.clone();
        let cross_shard_client_clone = cross_shard_client.clone();

        let aggr_overridden_state_view = Arc::new(AggregatorOverriddenStateView::new(
            cross_shard_state_view.as_ref(),
            TOTAL_SUPPLY_AGGR_BASE_VAL,
        ));
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L457-468)
```rust
    pub fn set_num_shards_once(mut num_shards: usize) {
        num_shards = max(num_shards, 1);
        // Only the first call succeeds, due to OnceCell semantics.
        NUM_EXECUTION_SHARD.set(num_shards).ok();
    }

    pub fn get_num_shards() -> usize {
        match NUM_EXECUTION_SHARD.get() {
            Some(num_shards) => *num_shards,
            None => 1,
        }
    }
```

**File:** execution/executor/src/workflow/do_get_execution_output.rs (L256-276)
```rust
    fn execute_block_sharded<V: VMBlockExecutor>(
        partitioned_txns: PartitionedTransactions,
        state_view: Arc<CachedStateView>,
        onchain_config: BlockExecutorConfigFromOnchain,
    ) -> Result<Vec<TransactionOutput>> {
        if !get_remote_addresses().is_empty() {
            Ok(V::execute_block_sharded(
                &REMOTE_SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        } else {
            Ok(V::execute_block_sharded(
                &SHARDED_BLOCK_EXECUTOR.lock(),
                partitioned_txns,
                state_view,
                onchain_config,
            )?)
        }
    }
```
