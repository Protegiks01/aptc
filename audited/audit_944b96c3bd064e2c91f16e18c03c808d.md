# Audit Report

## Title
Unimplemented `on_execution_aborted` Hook in Sharded Execution Causes Node Crash on Transaction Failures

## Summary
The production `CrossShardCommitSender` commit hook implementation contains an unimplemented `on_execution_aborted` method that uses `todo!()` macro, which will panic the executor thread when called. Since tests exclusively use `NoOpTransactionCommitHook` (which silently ignores abort events), this critical bug is never detected in testing but can crash validator nodes in production when BlockMetadata or Genesis transactions fail during sharded block execution.

## Finding Description

The `TransactionCommitHook` trait defines two methods that implementations must handle: [1](#0-0) 

The `NoOpTransactionCommitHook` used in tests provides no-op implementations: [2](#0-1) 

However, the **production** `CrossShardCommitSender` implementation used in sharded execution has an unimplemented abort handler: [3](#0-2) 

This `todo!()` macro will **panic** when invoked. The hook is called during transaction execution when abort status is detected: [4](#0-3) 

Transaction aborts occur when critical system transactions (BlockMetadata, Genesis) fail: [5](#0-4) 

BlockMetadata transactions contain fail points that can trigger errors: [6](#0-5) 

The `CrossShardCommitSender` is instantiated in production sharded execution: [7](#0-6) 

Meanwhile, regular (non-sharded) execution and all tests use `NoOpTransactionCommitHook`: [8](#0-7) 

**Attack Path:**
1. Validator enables sharded execution mode
2. A BlockMetadata or Genesis transaction encounters an execution error (e.g., via fail point injection, Move runtime error, or corrupted state)
3. VM returns `ExecutionStatus::Abort(err)`
4. Block executor calls `on_execution_aborted` on the `CrossShardCommitSender` hook
5. The `todo!()` macro panics, crashing the executor shard thread
6. Block execution fails, potentially causing consensus liveness issues

## Impact Explanation

This vulnerability qualifies as **High Severity** under Aptos bug bounty criteria:

- **Validator node slowdowns/crashes**: Panic in executor shard thread can halt block processing
- **Significant protocol violations**: Unhandled panics in critical execution path violate deterministic execution invariant
- **Potential consensus liveness impact**: If multiple validators hit this condition simultaneously, the network could experience consensus delays

The issue breaks the **Deterministic Execution** invariant - all validators must handle errors consistently. A panic in production code creates non-deterministic behavior where some validators crash while others may not encounter the error condition.

While not reaching Critical severity (no direct fund loss or permanent network partition), it represents a serious operational risk that could trigger emergency validator restarts or network degradation.

## Likelihood Explanation

**Likelihood: Medium to High**

The vulnerability triggers when:
1. Sharded execution is enabled (production feature for high-throughput scenarios)
2. A BlockMetadata or Genesis transaction fails execution

While these "should never fail" transactions are designed to be reliable, several realistic scenarios can trigger failures:
- Fail point activation (used in testing/debugging, but can be accidentally left enabled)
- State corruption causing Move execution errors
- Resource exhaustion during system transaction execution
- Consensus edge cases during epoch transitions

The fact that tests use `NoOpTransactionCommitHook` instead of the production hook means this code path has **zero test coverage**, significantly increasing the probability that it surfaces only in production under stress conditions.

## Recommendation

Implement the `on_execution_aborted` method for `CrossShardCommitSender`:

```rust
impl TransactionCommitHook for CrossShardCommitSender {
    fn on_transaction_committed(
        &self,
        txn_idx: TxnIndex,
        txn_output: &OnceCell<TransactionOutput>,
    ) {
        let global_txn_idx = txn_idx + self.index_offset;
        if self.dependent_edges.contains_key(&global_txn_idx) {
            self.send_remote_update_for_success(global_txn_idx, txn_output);
        }
    }

    fn on_execution_aborted(&self, txn_idx: TxnIndex) {
        // For cross-shard execution, abort handling requires sending
        // abort notifications to dependent shards. For now, log the
        // abort and allow graceful error propagation.
        let global_txn_idx = txn_idx + self.index_offset;
        trace!(
            "Transaction {} aborted in shard {}, dependent edges will be invalidated",
            global_txn_idx,
            self.shard_id
        );
        
        // Optionally: send abort messages to dependent shards
        if let Some(edges) = self.dependent_edges.get(&global_txn_idx) {
            for (dependent_shard_id, round_id) in edges.values().flatten() {
                // Send abort notification to dependent shards
                // Implementation depends on desired abort propagation semantics
            }
        }
    }
}
```

Additionally, update tests to use the actual production hook implementations rather than `NoOpTransactionCommitHook` to ensure full code coverage of error paths.

## Proof of Concept

The following Rust test would demonstrate the panic (requires enabling sharded execution with a hook that can abort):

```rust
#[test]
#[should_panic(expected = "not yet implemented")]
fn test_cross_shard_commit_sender_abort_panics() {
    use aptos_vm::sharded_block_executor::cross_shard_client::CrossShardCommitSender;
    use aptos_block_executor::txn_commit_hook::TransactionCommitHook;
    
    // Create a minimal CrossShardCommitSender
    let cross_shard_client = Arc::new(MockCrossShardClient::new());
    let sub_block = create_test_sub_block(); // Helper to create test sub-block
    
    let hook = CrossShardCommitSender::new(0, cross_shard_client, &sub_block);
    
    // This should panic with "not yet implemented"
    hook.on_execution_aborted(0);
}
```

To trigger in production scenario:
1. Enable sharded execution mode
2. Activate fail point `move_adapter::process_block_prologue` 
3. Execute block with BlockMetadata transaction
4. Observe executor shard thread panic when abort handler is invoked

**Notes:**
The vulnerability is exacerbated by the test coverage gap - using `NoOpTransactionCommitHook` in tests masks this production bug. This represents a systemic testing issue where test doubles do not faithfully represent production behavior, violating the principle that tests should exercise the same code paths as production systems.

### Citations

**File:** aptos-move/block-executor/src/txn_commit_hook.rs (L11-15)
```rust
pub trait TransactionCommitHook: Send + Sync {
    fn on_transaction_committed(&self, txn_idx: TxnIndex, output: &OnceCell<TransactionOutput>);

    fn on_execution_aborted(&self, txn_idx: TxnIndex);
}
```

**File:** aptos-move/block-executor/src/txn_commit_hook.rs (L35-43)
```rust
impl<E: Sync + Send> TransactionCommitHook for NoOpTransactionCommitHook<E> {
    fn on_transaction_committed(&self, _txn_idx: TxnIndex, _output: &OnceCell<TransactionOutput>) {
        // no-op
    }

    fn on_execution_aborted(&self, _txn_idx: TxnIndex) {
        // no-op
    }
}
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L149-151)
```rust
    fn on_execution_aborted(&self, _txn_idx: TxnIndex) {
        todo!("on_transaction_aborted not supported for sharded execution yet")
    }
```

**File:** aptos-move/block-executor/src/txn_last_input_output.rs (L426-428)
```rust
            OutputStatusKind::Abort(_) => {
                txn_listener.on_execution_aborted(txn_idx);
            },
```

**File:** aptos-move/aptos-vm/src/block_executor/vm_wrapper.rs (L99-114)
```rust
            // execute_single_transaction only returns an error when transactions that should never fail
            // (BlockMetadataTransaction and GenesisTransaction) return an error themselves.
            Err(err) => {
                if err.status_code() == StatusCode::SPECULATIVE_EXECUTION_ABORT_ERROR {
                    ExecutionStatus::SpeculativeExecutionAbortError(
                        err.message().cloned().unwrap_or_default(),
                    )
                } else if err.status_code()
                    == StatusCode::DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR
                {
                    ExecutionStatus::DelayedFieldsCodeInvariantError(
                        err.message().cloned().unwrap_or_default(),
                    )
                } else {
                    ExecutionStatus::Abort(err)
                }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2428-2433)
```rust
        fail_point!("move_adapter::process_block_prologue", |_| {
            Err(VMStatus::error(
                StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
                None,
            ))
        });
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3076-3087)
```rust
        let result = AptosVMBlockExecutorWrapper::execute_block::<
            _,
            NoOpTransactionCommitHook<VMStatus>,
            DefaultTxnProvider<SignatureVerifiedTransaction, AuxiliaryInfo>,
        >(
            txn_provider,
            state_view,
            &self.module_cache_manager,
            config,
            transaction_slice_metadata,
            None,
        );
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/sharded_executor_service.rs (L89-96)
```rust
        let cross_shard_commit_sender =
            CrossShardCommitSender::new(self.shard_id, self.cross_shard_client.clone(), &sub_block);
        Self::execute_transactions_with_dependencies(
            Some(self.shard_id),
            self.executor_thread_pool.clone(),
            sub_block.into_transactions_with_deps(),
            self.cross_shard_client.clone(),
            Some(cross_shard_commit_sender),
```
