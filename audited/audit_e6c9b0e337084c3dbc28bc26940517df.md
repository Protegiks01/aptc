# Audit Report

## Title
False Positive Initialization Check Allows Denial of Service via Dummy File Injection in GCS File Store

## Summary
The `is_initialized()` function in the GCS file store (v2) implementation uses a weak initialization check that returns `true` if ANY file or prefix exists in the bucket, rather than specifically verifying the presence of the required `metadata.json` file. An attacker with write access to the GCS bucket can exploit this to cause a Denial of Service by creating a dummy file before initialization, causing the indexer to skip creating `metadata.json` and subsequently crash when attempting to read it.

## Finding Description

The vulnerability exists in the `is_initialized()` implementation which checks for initialization by listing objects in the bucket and returning `true` if any items or prefixes exist: [1](#0-0) 

This implementation does NOT specifically verify that `metadata.json` exists—it only checks whether the bucket/subdirectory is non-empty.

The attack flow exploits the initialization logic in `FileStoreUploader::new()`: [2](#0-1) 

When `is_initialized()` returns `true` (due to the dummy file), the system skips creating `metadata.json`. Subsequently, when `FileStoreReader::new()` is instantiated, it attempts to read the metadata: [3](#0-2) 

The `get_file_store_metadata()` function expects `metadata.json` to exist: [4](#0-3) 

When `metadata.json` doesn't exist, `get_raw_file()` returns `Ok(None)`: [5](#0-4) 

This causes the `.expect("Failed to fetch num_transactions_per_folder.")` to panic, crashing the indexer.

**Attack Steps:**
1. Attacker gains write access to GCS bucket (misconfigured IAM, compromised credentials, or shared bucket)
2. Attacker creates dummy file (e.g., `exploit.txt`) in the bucket before indexer initialization
3. `is_initialized()` returns `true` because dummy file exists
4. System skips creating `metadata.json`
5. `FileStoreReader::new()` panics when trying to read non-existent `metadata.json`
6. Indexer crashes and cannot start

The same vulnerability exists in the LocalFileStore implementation: [6](#0-5) 

## Impact Explanation

This vulnerability qualifies as **Medium Severity** per the Aptos Bug Bounty program criteria:
- **"State inconsistencies requiring intervention"**: The file store is in an inconsistent state where `is_initialized()` returns `true` but the required `metadata.json` does not exist
- **Limited Denial of Service**: The indexer-grpc service cannot initialize and crashes, preventing users from querying indexed blockchain data

The impact is limited because:
- Does NOT affect core consensus or validator operations
- Does NOT affect fund security or transaction execution
- Requires manual operator intervention to remove dummy file and restart
- Only affects the indexer service, not the blockchain itself

However, the indexer-grpc is critical infrastructure for dApps and users who rely on historical blockchain data queries, making this a meaningful availability issue.

## Likelihood Explanation

**Likelihood: Medium**

The attack requires the attacker to have write access to the GCS bucket, which can occur through:

1. **Misconfigured GCS Permissions** (Common): Buckets accidentally set to public write access, `allUsers`, or overly permissive IAM roles
2. **Compromised Service Account Credentials**: If the service account JSON key is leaked or compromised
3. **Shared Bucket Scenarios**: Multiple services sharing the same bucket with different subdirectories—if one service is compromised, the attacker can access other subdirectories
4. **Development/Test Environments**: Often have weaker security controls, making this attack more feasible

While production environments with proper security practices (principle of least privilege, private buckets, credential rotation) reduce the likelihood, misconfigurations are common enough to make this a realistic threat, especially in:
- Early deployment phases
- Multi-tenant or shared infrastructure
- Organizations with less mature cloud security practices

## Recommendation

**Fix: Change `is_initialized()` to specifically verify `metadata.json` existence**

Replace the current implementation with a check that specifically looks for the metadata file:

```rust
async fn is_initialized(&self) -> bool {
    self.get_raw_file(PathBuf::from(METADATA_FILE_NAME))
        .await
        .unwrap_or(Ok(None))
        .is_some()
}
```

This ensures initialization status is based on the actual presence of the required metadata file, not just any arbitrary file in the storage location.

Apply the same fix to LocalFileStore implementation:

```rust
async fn is_initialized(&self) -> bool {
    let metadata_path = self.path.join(METADATA_FILE_NAME);
    tokio::fs::metadata(&metadata_path).await.is_ok()
}
```

Where `METADATA_FILE_NAME` is imported from: [7](#0-6) 

## Proof of Concept

```rust
#[tokio::test]
async fn test_false_positive_initialization_dos() {
    use tempfile::TempDir;
    use std::path::PathBuf;
    use aptos_indexer_grpc_utils::file_store_operator_v2::local::LocalFileStore;
    use aptos_indexer_grpc_utils::file_store_operator_v2::common::{
        IFileStoreReader, IFileStoreWriter, METADATA_FILE_NAME
    };
    
    // Setup: Create temporary directory
    let temp_dir = TempDir::new().unwrap();
    let store_path = temp_dir.path().to_path_buf();
    
    // Attack Step 1: Attacker creates dummy file before initialization
    let dummy_file = store_path.join("malicious_dummy.txt");
    tokio::fs::write(&dummy_file, b"attacker payload").await.unwrap();
    
    // Create file store
    let file_store = LocalFileStore::new(store_path.clone());
    
    // Attack Step 2: Verify is_initialized() returns true due to dummy file
    assert!(file_store.is_initialized().await, "is_initialized should return true");
    
    // Attack Step 3: System would skip creating metadata.json here in FileStoreUploader
    // (simulated by not creating it)
    
    // Attack Step 4: Attempt to read metadata.json
    let metadata_result = file_store
        .get_raw_file(PathBuf::from(METADATA_FILE_NAME))
        .await
        .expect("get_raw_file should not error");
    
    // Verify metadata.json doesn't exist
    assert!(metadata_result.is_none(), "metadata.json should not exist");
    
    // Attack Step 5: In real code, FileStoreReader::new() would panic here
    // with "Failed to fetch num_transactions_per_folder."
    // This demonstrates the DoS condition
    
    println!("DoS condition achieved: is_initialized=true but metadata.json absent");
}
```

**To run the PoC:**
1. Add this test to `ecosystem/indexer-grpc/indexer-grpc-utils/src/file_store_operator_v2/local.rs`
2. Run: `cargo test test_false_positive_initialization_dos`
3. Observe that the dummy file causes `is_initialized()` to return `true` while `metadata.json` is absent

The test demonstrates that an attacker-created dummy file triggers the false positive initialization check, which would cause the subsequent `FileStoreReader::new()` panic in production code.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/file_store_operator_v2/gcs.rs (L68-93)
```rust
    async fn is_initialized(&self) -> bool {
        let request = ListRequest {
            max_results: Some(1),
            prefix: self
                .bucket_sub_dir
                .clone()
                .map(|p| p.to_string_lossy().into_owned()),
            ..Default::default()
        };

        let response = Object::list(&self.bucket_name, request)
            .await
            .unwrap_or_else(|e| {
                panic!(
                    "Failed to list bucket. Bucket name: {}, sub_dir: {:?}, error: {e:?}.",
                    self.bucket_name, self.bucket_sub_dir
                )
            })
            .boxed()
            .next()
            .await
            .expect("Expect response.")
            .unwrap_or_else(|e| panic!("Got error in response: {e:?}."));

        !response.prefixes.is_empty() || !response.items.is_empty()
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/file_store_operator_v2/gcs.rs (L95-115)
```rust
    async fn get_raw_file(&self, file_path: PathBuf) -> Result<Option<Vec<u8>>> {
        let path = self.get_path(file_path);
        trace!(
            "Downloading object at {}/{}.",
            self.bucket_name,
            path.as_str()
        );
        match Object::download(&self.bucket_name, path.as_str()).await {
            Ok(file) => Ok(Some(file)),
            Err(cloud_storage::Error::Other(err)) => {
                if err.contains("No such object: ") {
                    Ok(None)
                } else {
                    bail!("[Indexer File] Error happens when downloading file at {path:?}. {err}",);
                }
            },
            Err(err) => {
                bail!("[Indexer File] Error happens when downloading file at {path:?}. {err}");
            },
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/file_store_uploader.rs (L47-63)
```rust
        if !file_store.is_initialized().await {
            info!(
                chain_id = chain_id,
                "FileStore is not initialized, initializing..."
            );
            info!("Transactions per folder: {NUM_TXNS_PER_FOLDER}.");
            let metadata = FileStoreMetadata {
                chain_id,
                num_transactions_per_folder: NUM_TXNS_PER_FOLDER,
                version: 0,
            };
            let raw_data = serde_json::to_vec(&metadata).unwrap();
            file_store
                .save_raw_file(PathBuf::from(METADATA_FILE_NAME), raw_data)
                .await
                .unwrap_or_else(|e| panic!("Failed to initialize FileStore: {e:?}."));
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/file_store_operator_v2/file_store_reader.rs (L33-51)
```rust
    pub async fn new(chain_id: u64, reader: Arc<dyn IFileStore>) -> Self {
        assert!(reader.is_initialized().await);

        let mut myself = Self {
            chain_id,
            reader,
            num_transactions_per_folder: 0,
            cached_file_store_version: AtomicU64::new(0),
        };

        let metadata = Self::get_file_store_metadata(&myself)
            .await
            .expect("Failed to fetch num_transactions_per_folder.");

        assert!(chain_id == metadata.chain_id);

        myself.num_transactions_per_folder = metadata.num_transactions_per_folder;

        myself
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/file_store_operator_v2/file_store_reader.rs (L160-166)
```rust
    pub async fn get_file_store_metadata(&self) -> Option<FileStoreMetadata> {
        self.reader
            .get_raw_file(PathBuf::from(METADATA_FILE_NAME))
            .await
            .expect("Failed to get file store metadata.")
            .map(|data| serde_json::from_slice(&data).expect("Metadata JSON is invalid."))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/file_store_operator_v2/local.rs (L34-42)
```rust
    async fn is_initialized(&self) -> bool {
        tokio::fs::read_dir(&self.path)
            .await
            .unwrap()
            .next_entry()
            .await
            .unwrap()
            .is_some()
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-utils/src/file_store_operator_v2/common.rs (L9-9)
```rust
pub const METADATA_FILE_NAME: &str = "metadata.json";
```
