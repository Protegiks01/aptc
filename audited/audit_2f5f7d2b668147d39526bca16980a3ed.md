# Audit Report

## Title
Module Cache Lacks Deletion Support - Protocol Mismatch Creates Panic Risk

## Summary
The global module cache implementation explicitly rejects module deletion operations with a panic error, despite the blockchain protocol supporting module deletion at the write set level. This creates a protocol-implementation mismatch that could cause validator node crashes if module deletions are attempted.

## Finding Description

The `global_module_cache` has proper invalidation mechanisms for module updates (`mark_overridden()`, `flush()`, `insert_verified()`), but explicitly rejects module deletions: [1](#0-0) 

When a module write operation is processed, if the underlying `WriteOp` is a deletion (returns `None` from `as_state_value()`), the function panics with "Modules cannot be deleted". However, the protocol supports deletion operations: [2](#0-1) 

The Move framework attempts to prevent module deletion during package upgrades: [3](#0-2) 

However, this creates a defense-in-depth gap. If module deletion write ops reach the cache code (through VM bugs, system transactions, or framework bypasses), block execution will panic, crashing the validator.

**Cache Invalidation for Non-Deletion Operations:**

The cache properly handles module updates through:
- Marking entries as overridden when republished: [4](#0-3) 
- Replacing overridden entries at block end: [5](#0-4) 
- Auto-flushing on size limits: [6](#0-5) 

Therefore, **malicious modules do NOT remain cached indefinitely** - they are properly invalidated and replaced through normal cache operations.

## Impact Explanation

**High Severity** - Validator node crash risk if module deletion is triggered:
- If a module deletion reaches `add_module_write_to_module_cache`, the validator panics
- This breaks **Deterministic Execution** invariant if only some nodes panic while others handle it differently
- Could cause consensus disruption requiring manual intervention
- Does not qualify as Critical because module deletion is prevented by multiple layers

**Note:** The original concern about "malicious modules remaining cached indefinitely" is **NOT valid** - cache invalidation works correctly for all supported operations.

## Likelihood Explanation

**Low-Medium Likelihood:**
- Module framework explicitly prevents deletion (EMODULE_MISSING check)
- Would require VM bug, framework bypass, or undocumented system operation
- No known attack vector currently exists
- Defensive programming gap rather than active exploit

## Recommendation

Handle module deletion gracefully instead of panicking:

```rust
pub(crate) fn add_module_write_to_module_cache<T: BlockExecutableTransaction>(
    write: &ModuleWrite<T::Value>,
    txn_idx: TxnIndex,
    runtime_environment: &RuntimeEnvironment,
    global_module_cache: &GlobalModuleCache<...>,
    per_block_module_cache: &impl ModuleCache<...>,
) -> Result<(), PanicError> {
    // Handle module deletion by marking as overridden
    if write.write_op().as_state_value().is_none() {
        global_module_cache.mark_overridden(write.module_id());
        return Ok(());
    }
    
    let state_value = write.write_op().as_state_value().unwrap();
    // ... rest of existing code
}
```

This aligns cache behavior with protocol capabilities and prevents crashes.

## Proof of Concept

The panic can be demonstrated if module deletion write ops could be created (currently prevented by framework):

```rust
// Hypothetical test if deletion bypass existed
#[test]
fn test_module_deletion_causes_panic() {
    let mut cache = GlobalModuleCache::empty();
    let module_id = ModuleId::new(AccountAddress::ZERO, Identifier::new("test").unwrap());
    
    // Create a deletion write op
    let deletion_write = ModuleWrite::new(
        module_id.clone(),
        WriteOp::legacy_deletion() // This is the deletion operation
    );
    
    // This would panic with "Modules cannot be deleted"
    let result = add_module_write_to_module_cache(
        &deletion_write,
        0,
        &runtime_env,
        &cache,
        &per_block_cache
    );
    
    assert!(result.is_err()); // Currently panics instead
}
```

**Validation Result:** While a protocol mismatch exists, the framework prevents module deletion effectively. The vulnerability requires a separate bug to exploit. The original claim about "malicious modules remaining cached indefinitely" is **invalid** - cache invalidation mechanisms work correctly.

### Citations

**File:** aptos-move/block-executor/src/code_cache_global.rs (L209-212)
```rust
                } else {
                    self.size -= entry.get().module_code().extension().size_in_bytes();
                    entry.remove();
                }
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L285-288)
```rust
    let state_value = write
        .write_op()
        .as_state_value()
        .ok_or_else(|| PanicError::CodeInvariantError("Modules cannot be deleted".to_string()))?;
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L317-317)
```rust
    global_module_cache.mark_overridden(write.module_id());
```

**File:** types/src/write_set.rs (L39-44)
```rust
#[derive(Eq, Clone, Debug, PartialEq)]
pub enum WriteOpKind {
    Creation,
    Modification,
    Deletion,
}
```

**File:** aptos-move/framework/aptos-framework/sources/code.move (L273-278)
```text
        vector::for_each_ref(&old_modules, |old_module| {
            assert!(
                vector::contains(new_modules, old_module),
                EMODULE_MISSING
            );
        });
```

**File:** aptos-move/block-executor/src/code_cache_global_manager.rs (L173-175)
```rust
        if module_cache_size_in_bytes > config.max_module_cache_size_in_bytes {
            self.module_cache.flush();
        }
```
