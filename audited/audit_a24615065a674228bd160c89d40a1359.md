# Audit Report

## Title
Path Traversal and Symlink Following in Move Package Dependency Resolution Enables Malicious Bytecode Injection

## Summary
The Move package compilation system fails to validate local dependency paths and follows symlinks when discovering bytecode files, allowing attackers to inject malicious compiled modules from arbitrary filesystem locations. This bypasses all compilation safety checks and can lead to consensus violations across validator nodes.

## Finding Description

The vulnerability exists in the dependency resolution and compilation pipeline, specifically in how local dependency paths are parsed and how bytecode files are discovered:

**Step 1: Unvalidated Path Parsing**

When parsing a dependency's `local` field from Move.toml, the path string is directly converted to a PathBuf without any validation: [1](#0-0) 

The `local_path` is created from user-controlled input with no checks for path traversal sequences (`..`), absolute paths, or whether the path stays within expected boundaries.

**Step 2: Path Propagation Through Resolution**

This unvalidated path becomes the `package_path` in the resolution graph: [2](#0-1) 

The `root_path.push(&dep.local)` operation at line 504 directly uses the unvalidated path, which is then stored in the package table.

**Step 3: Bytecode Discovery with Symlink Following**

When retrieving bytecode files for a dependency, the system uses `find_filenames()` which explicitly follows symlinks: [3](#0-2) 

Combined with the unvalidated package_path, this allows discovery of bytecode files outside the package directory through symlinks.

**Step 4: Transitive Dependency Construction**

The compilation process retrieves these paths without additional validation: [4](#0-3) 

The `.unwrap()` calls assume package_table entries are valid, and `get_bytecodes()` returns paths that could point anywhere due to symlinks.

**Step 5: Malicious Bytecode Injection**

Finally, these bytecode files are deserialized and included in the compilation: [5](#0-4) 

The `get_module_in_package()` function reads and deserializes these bytecode files without verifying their origin or integrity.

**Attack Scenario:**

An attacker can exploit this through two methods:

1. **Path Traversal**: Create a dependency with `local = "../../attacker-dir"` in Move.toml to reference arbitrary directories
2. **Symlink Injection**: Create a legitimate-looking package but place symlinks in its `build/` directory pointing to malicious bytecode files

When validators compile packages with such dependencies, they will include different bytecode depending on their filesystem state, violating the **Deterministic Execution** invariant.

## Impact Explanation

**Severity: CRITICAL** (up to $1,000,000)

This vulnerability meets multiple Critical Severity criteria:

1. **Consensus/Safety Violations**: Different validator nodes could compile and execute different bytecode for the same source package, breaking consensus. Validators with different filesystem layouts or symlink resolutions will produce different state roots, causing chain splits.

2. **Remote Code Execution**: Malicious bytecode can be injected that exploits Move VM vulnerabilities or contains backdoors. Since the bytecode bypasses normal compilation validation, it could contain constructs that violate VM safety invariants.

3. **Supply Chain Attack**: Any package in the dependency tree can inject malicious code, affecting all downstream consumers. This is particularly dangerous for widely-used framework packages.

4. **Deterministic Execution Violation**: The fundamental invariant that "all validators must produce identical state roots for identical blocks" is broken, as compilation results depend on filesystem state rather than source code.

## Likelihood Explanation

**Likelihood: HIGH**

This vulnerability is highly likely to be exploited because:

1. **No Special Access Required**: Any package author can create a malicious dependency. No validator privileges or stake are needed.

2. **Simple Exploitation**: The attack requires only crafting a Move.toml with a malformed path or creating symlinks in a package directory.

3. **Wide Attack Surface**: Any Move package compilation is vulnerable, including:
   - Framework upgrades through governance
   - Third-party package deployments
   - Local development environments
   - CI/CD pipelines

4. **Difficult Detection**: The malicious bytecode is included during compilation, making it hard to detect without inspecting the filesystem state of every validator.

5. **Existing Infrastructure**: Attackers can leverage existing package distribution channels (git repositories, package registries) to distribute malicious packages.

## Recommendation

Implement comprehensive path validation and canonicalization throughout the dependency resolution pipeline:

1. **Validate Dependency Paths**: In `manifest_parser.rs`, canonicalize and validate local paths:

```rust
(Some(local), None, None) => {
    let local_str = local
        .as_str()
        .ok_or_else(|| format_err!("Local source path not a string"))?;
    
    // Canonicalize the path to resolve symlinks and ..
    let local_path = PathBuf::from(local_str);
    let canonical_path = std::fs::canonicalize(&local_path)
        .context("Failed to canonicalize dependency path")?;
    
    // Ensure path is relative and doesn't escape parent directory
    if local_path.is_absolute() {
        bail!("Absolute paths not allowed for dependencies: {}", local_str);
    }
    if local_path.components().any(|c| matches!(c, std::path::Component::ParentDir)) {
        bail!("Path traversal not allowed in dependencies: {}", local_str);
    }
    
    Ok(PM::Dependency {
        subst,
        version,
        digest,
        local: canonical_path,
        git_info,
        node_info,
    })
}
```

2. **Disable Symlink Following**: Modify `find_filenames()` to not follow symlinks, or add validation:

```rust
for entry in walkdir::WalkDir::new(path)
    .follow_links(false)  // Change to false
    .into_iter()
    .filter_map(|e| e.ok())
```

3. **Validate Package Paths**: In `resolution_graph.rs`, ensure resolved paths stay within expected boundaries:

```rust
// After line 504
let canonical_dep_path = std::fs::canonicalize(&root_path)
    .context("Failed to canonicalize dependency package path")?;

// Ensure it's within the expected dependency directory
if !canonical_dep_path.starts_with(&expected_deps_root) {
    bail!("Dependency path escapes expected directory: {:?}", canonical_dep_path);
}
```

4. **Add Content-Based Validation**: Implement digest verification for all bytecode files before deserialization.

## Proof of Concept

**Setup: Create Malicious Dependency**

1. Create `MaliciousPackage/Move.toml`:
```toml
[package]
name = "MaliciousPackage"
version = "1.0.0"

[addresses]
MaliciousPkg = "0x42"
```

2. Create `MaliciousPackage/build/` directory with a symlink:
```bash
mkdir -p MaliciousPackage/build
# Create or obtain malicious bytecode
echo "MALICIOUS_BYTECODE" > /tmp/evil.mv
ln -s /tmp/evil.mv MaliciousPackage/build/module.mv
```

**Exploit: Use in Victim Package**

3. Create `VictimPackage/Move.toml`:
```toml
[package]
name = "VictimPackage"
version = "1.0.0"

[dependencies]
MaliciousPackage = { local = "../MaliciousPackage" }

[addresses]
VictimPkg = "0x1"
```

4. Compile VictimPackage:
```bash
cd VictimPackage
aptos move compile
```

**Result**: The compilation process will:
- Follow the symlink in `MaliciousPackage/build/module.mv`
- Read `/tmp/evil.mv` from outside the package directory
- Include its contents as a compiled module dependency
- Different validators with different `/tmp/evil.mv` contents will produce different compilation results

This breaks deterministic execution and enables consensus violations.

### Citations

**File:** third_party/move/tools/move-package/src/source_package/manifest_parser.rs (L342-354)
```rust
                (Some(local), None, None) => {
                    let local_str = local
                        .as_str()
                        .ok_or_else(|| format_err!("Local source path not a string"))?;
                    let local_path = PathBuf::from(local_str);
                    Ok(PM::Dependency {
                        subst,
                        version,
                        digest,
                        local: local_path,
                        git_info,
                        node_info,
                    })
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L499-517)
```rust
    fn parse_package_manifest(
        dep: &Dependency,
        dep_name: &PackageName,
        mut root_path: PathBuf,
    ) -> Result<(SourceManifest, PathBuf)> {
        root_path.push(&dep.local);
        match fs::read_to_string(root_path.join(SourcePackageLayout::Manifest.path())) {
            Ok(contents) => {
                let source_package: SourceManifest =
                    parse_move_manifest_string(contents).and_then(parse_source_manifest)?;
                Ok((source_package, root_path))
            },
            Err(_) => Err(anyhow::format_err!(
                "Unable to find package manifest for '{}' at {:?}",
                dep_name,
                SourcePackageLayout::Manifest.path().join(root_path),
            )),
        }
    }
```

**File:** third_party/move/move-command-line-common/src/files.rs (L80-82)
```rust
        for entry in walkdir::WalkDir::new(path)
            .follow_links(true)
            .into_iter()
```

**File:** third_party/move/tools/move-package/src/compilation/build_plan.rs (L103-116)
```rust
                let dep_package = self
                    .resolution_graph
                    .package_table
                    .get(&package_name)
                    .unwrap();
                let mut dep_source_paths = dep_package
                    .get_sources(&self.resolution_graph.build_options)
                    .unwrap();
                let mut source_available = true;
                // If source is empty, search bytecode(mv) files
                if dep_source_paths.is_empty() {
                    dep_source_paths = dep_package.get_bytecodes().unwrap();
                    source_available = false;
                }
```

**File:** third_party/move/tools/move-package/src/compilation/compiled_package.rs (L750-758)
```rust
            bytecode_deps: bytecode_deps
                .iter()
                .flat_map(|package| {
                    let name = package.name.unwrap();
                    package.paths.iter().map(move |pkg_path| {
                        get_module_in_package(name, pkg_path.as_str()).map(|module| (name, module))
                    })
                })
                .try_collect()?,
```
