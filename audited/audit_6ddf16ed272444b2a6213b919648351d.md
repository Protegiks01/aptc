# Audit Report

## Title
Time-of-Check to Time-of-Use (TOCTOU) Vulnerability in Consensus Config Reconfiguration Enables Randomness Feature Without DKG

## Summary
A Time-of-Check to Time-of-Use (TOCTOU) vulnerability exists in `aptos_governance::reconfigure()` where the decision to run Distributed Key Generation (DKG) is made based on the current on-chain consensus configuration, but the buffered (staged) configuration is what actually takes effect in the new epoch. This allows enabling validator transactions and randomness features without running the required DKG protocol, breaking the randomness security model.

## Finding Description
The vulnerability lies in the config application flow during reconfiguration: [1](#0-0) 

This check reads the **current on-chain state** via `validator_txn_enabled()` and `randomness_config::enabled()`: [2](#0-1) 

However, when `set_for_next_epoch()` is called prior to reconfiguration, it only **stages** the new config in a buffer without updating the on-chain storage: [3](#0-2) 

The actual application of the staged config happens later in `on_new_epoch()`: [4](#0-3) 

This is called from `reconfiguration_with_dkg::finish()`: [5](#0-4) 

**Attack Path:**
1. Initial state: `validator_txn_enabled = false`, `randomness_enabled = false`
2. Governance proposal stages new configs: `set_for_next_epoch(vtxn=true)` and `set_for_next_epoch(randomness=true)`
3. Governance calls `reconfigure()`
4. Line 687 check reads OLD values (false & false) = false
5. Takes else branch, calls `finish()` directly **without DKG**
6. Inside `finish()`, line 49 applies NEW config with `vtxn=true`
7. Inside `finish()`, line 58 applies NEW config with `randomness=true`
8. New epoch starts with randomness enabled but **no shared secret established via DKG**

The randomness feature critically depends on DKG to establish shared secrets among validators. Without DKG, validators cannot generate valid randomness, violating the deterministic execution invariant.

## Impact Explanation
**High Severity** - This breaks the randomness security model and causes protocol violations:

- **Consensus Safety Risk**: Different validators may behave inconsistently when attempting to generate randomness without DKG-established secrets
- **Liveness Risk**: Validators expecting randomness functionality will fail to produce valid randomness values, potentially causing crashes or undefined behavior
- **Protocol Violation**: The randomness specification explicitly requires DKG (as noted in line 74 of randomness_config.move: "The feature works if and only if `consensus_config::validator_txn_enabled() && randomness_config::enabled()`")

While this doesn't directly lead to fund theft, it breaks critical consensus invariants and could cause non-recoverable network states requiring governance intervention.

## Likelihood Explanation
**Medium Likelihood**:
- Requires governance proposal, but any participant meeting proposal requirements can submit
- Could occur accidentally during legitimate config updates if both features are enabled simultaneously
- The TOCTOU window is guaranteed to exist whenever staged configs differ from current configs
- No insider access required, only governance participation rights

## Recommendation
The check in `reconfigure()` must read the **staged** configuration values that will actually be applied, not the current on-chain values. Modify the logic to:

```move
public entry fun reconfigure(aptos_framework: &signer) {
    system_addresses::assert_aptos_framework(aptos_framework);
    
    // Read staged configs if they exist, otherwise use current
    let effective_vtxn_enabled = if (config_buffer::does_exist<ConsensusConfig>()) {
        let staged_config = config_buffer::read<ConsensusConfig>();
        consensus_config::validator_txn_enabled_from_bytes(staged_config.config)
    } else {
        consensus_config::validator_txn_enabled()
    };
    
    let effective_randomness_enabled = if (config_buffer::does_exist<RandomnessConfig>()) {
        randomness_config::is_enabled_from_staged()
    } else {
        randomness_config::enabled()
    };
    
    if (effective_vtxn_enabled && effective_randomness_enabled) {
        reconfiguration_with_dkg::try_start();
    } else {
        reconfiguration_with_dkg::finish(aptos_framework);
    }
}
```

Alternatively, apply the configs before making the decision, or add validation to prevent enabling randomness without running DKG.

## Proof of Concept
```move
#[test(aptos_framework = @aptos_framework)]
fun test_toctou_randomness_without_dkg(aptos_framework: &signer) {
    // Setup: Initialize with vtxn=false, randomness=false
    consensus_config::initialize(aptos_framework, encode_config_v0());
    randomness_config::initialize(aptos_framework, randomness_config::new_off());
    
    // Stage new configs with both enabled
    consensus_config::set_for_next_epoch(aptos_framework, encode_config_v1_vtxn_enabled());
    randomness_config::set_for_next_epoch(aptos_framework, randomness_config::new_v1(...));
    
    // Trigger reconfiguration
    aptos_governance::reconfigure(aptos_framework);
    
    // Verify: New epoch has randomness enabled but no DKG session was started
    assert!(consensus_config::validator_txn_enabled(), 0);
    assert!(randomness_config::enabled(), 1);
    assert!(option::is_none(&dkg::incomplete_session()), 2); // No DKG was run!
}
```

This vulnerability breaks the critical invariant that randomness functionality requires DKG-established shared secrets, enabling a protocol state that should be impossible.

---

**Notes**

Regarding the original question about caching: The RoundManager does cache `vtxn_config` values [6](#0-5) , populated at epoch start [7](#0-6) . However, this cache is properly invalidated at epoch boundaries when new RoundManager instances are created. The actual vulnerability is the TOCTOU bug in Move code, not a Rust-level cache invalidation issue.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/aptos_governance.move (L687-692)
```text
        if (consensus_config::validator_txn_enabled() && randomness_config::enabled()) {
            reconfiguration_with_dkg::try_start();
        } else {
            reconfiguration_with_dkg::finish(aptos_framework);
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L52-56)
```text
    public fun set_for_next_epoch(account: &signer, config: vector<u8>) {
        system_addresses::assert_aptos_framework(account);
        assert!(vector::length(&config) > 0, error::invalid_argument(EINVALID_CONFIG));
        std::config_buffer::upsert<ConsensusConfig>(ConsensusConfig {config});
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L59-68)
```text
    public(friend) fun on_new_epoch(framework: &signer) acquires ConsensusConfig {
        system_addresses::assert_aptos_framework(framework);
        if (config_buffer::does_exist<ConsensusConfig>()) {
            let new_config = config_buffer::extract_v2<ConsensusConfig>();
            if (exists<ConsensusConfig>(@aptos_framework)) {
                *borrow_global_mut<ConsensusConfig>(@aptos_framework) = new_config;
            } else {
                move_to(framework, new_config);
            };
        }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/consensus_config.move (L71-74)
```text
    public fun validator_txn_enabled(): bool acquires ConsensusConfig {
        let config_bytes = borrow_global<ConsensusConfig>(@aptos_framework).config;
        validator_txn_enabled_internal(config_bytes)
    }
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration_with_dkg.move (L46-61)
```text
    public(friend) fun finish(framework: &signer) {
        system_addresses::assert_aptos_framework(framework);
        dkg::try_clear_incomplete_session(framework);
        consensus_config::on_new_epoch(framework);
        execution_config::on_new_epoch(framework);
        gas_schedule::on_new_epoch(framework);
        std::version::on_new_epoch(framework);
        features::on_new_epoch(framework);
        jwk_consensus_config::on_new_epoch(framework);
        jwks::on_new_epoch(framework);
        keyless_account::on_new_epoch(framework);
        randomness_config_seqnum::on_new_epoch(framework);
        randomness_config::on_new_epoch(framework);
        randomness_api_v0_config::on_new_epoch(framework);
        reconfiguration::reconfigure();
    }
```

**File:** consensus/src/round_manager.rs (L313-313)
```rust
    vtxn_config: ValidatorTxnConfig,
```

**File:** consensus/src/round_manager.rs (L363-363)
```rust
        let vtxn_config = onchain_config.effective_validator_txn_config();
```
