# Audit Report

## Title
Consensus Observer Denial-of-Service via Future-Epoch Block Payload Flooding

## Summary
An attacker can perform a denial-of-service attack on consensus observer nodes by flooding the payload store with block payloads containing artificially high epoch values. These malicious payloads fill the store to its maximum capacity, causing legitimate blocks to be dropped, while the cleanup mechanism fails to remove them.

## Finding Description

The vulnerability exists in the consensus observer's block payload storage mechanism, which uses a BTreeMap indexed by `(epoch, round)` tuples. The attack exploits three critical flaws:

**1. No Epoch Bounds Validation**

When processing incoming block payloads, the system only checks if blocks are behind the last ordered block, but does not validate if blocks are unreasonably far in the future: [1](#0-0) 

An attacker can send blocks with epoch values like 999999, which will pass this check since `(999999, 0) > (current_epoch, current_round)`.

**2. Unverified Future Blocks Accepted**

Blocks for future epochs are accepted without signature verification: [2](#0-1) 

Future-epoch blocks only require valid payload digests (line 385-397), not cryptographic signatures. An attacker can construct these with minimal or empty transactions.

**3. Cleanup Mechanism Fails for Future Epochs**

The critical flaw is in the cleanup logic using `BTreeMap::split_off()`: [3](#0-2) 

This function KEEPS all entries with keys >= `(epoch, split_off_round)` and DISCARDS entries < that key. When blocks at epoch 10 are committed and `remove_blocks_for_epoch_round(10, 50)` is called, it removes old blocks but RETAINS malicious blocks at epoch 999999.

**4. Storage Limit Enforcement**

The store has a fixed capacity check: [4](#0-3) 

Once the attacker fills all 150 slots (or 300 on testnets) with future-epoch blocks, legitimate blocks are dropped.

**Attack Execution:**

1. Attacker crafts 150+ BlockPayload messages with epoch=999999, rounds 0-149
2. Constructs valid BlockInfo structures (no signatures required at this stage)
3. Includes minimal transaction data with valid digests
4. Sends these to consensus observer nodes via P2P network
5. Messages pass validation: not out-of-date, valid digests, accepted as unverified
6. Payload store fills to capacity with unremovable junk blocks
7. Legitimate blocks at current epoch are dropped when attempting insertion
8. Normal cleanup operations (`remove_blocks_for_epoch_round`) fail to remove the malicious blocks
9. Consensus observer functionality is disrupted until manual intervention or the far-future epoch arrives

## Impact Explanation

This is **High Severity** per Aptos bug bounty criteria because it causes:

- **Validator node slowdowns**: Consensus observer nodes cannot process legitimate blocks, impacting their ability to follow the chain efficiently
- **Significant protocol violations**: The consensus observer protocol is designed to efficiently propagate blocks, but this attack breaks that guarantee
- **Network availability impact**: Affected nodes fall back to slower state synchronization mechanisms

While not a complete network halt (nodes can use fallback sync), this represents a significant degradation of the consensus observer system's intended functionality. The attack is low-cost for the attacker (no staking required, just network access) but high-impact for victims.

## Likelihood Explanation

**Likelihood: HIGH**

The attack is highly likely to occur because:

1. **Low barrier to entry**: Any network peer can send block payload messages - no validator credentials, stake, or special access required
2. **Easy to execute**: Attacker only needs to construct basic data structures with valid digests, not cryptographic signatures
3. **No automatic mitigation**: The system has no peer reputation/banning for this behavior, and invalid message counters don't trigger any defensive actions [5](#0-4) 

4. **Persistent impact**: Once the store is filled, legitimate traffic is blocked until manual intervention
5. **Default configuration vulnerability**: Default `max_num_pending_blocks` of 150 is easily filled [6](#0-5) 

## Recommendation

Implement strict epoch validation for incoming block payloads:

```rust
// In process_block_payload_message, after line 364, add:
const MAX_FUTURE_EPOCH_TOLERANCE: u64 = 2; // Allow at most 2 epochs ahead

let epoch_state = self.get_epoch_state();
if block_epoch > epoch_state.epoch + MAX_FUTURE_EPOCH_TOLERANCE {
    warn!(
        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
            "Rejecting block payload with epoch too far in future: {:?} (current: {:?}), from peer: {:?}",
            block_epoch, epoch_state.epoch, peer_network_id
        ))
    );
    increment_invalid_message_counter(&peer_network_id, metrics::BLOCK_PAYLOAD_LABEL);
    return;
}
```

Additionally, consider:
1. **Implement periodic cleanup of unverified blocks**: Remove unverified payloads older than a timeout
2. **Add peer reputation tracking**: Ban peers sending consistently invalid or excessive future-epoch blocks
3. **Increase `max_num_pending_blocks`**: While not a complete fix, raising the limit increases attack cost

The epoch validation is the most critical fix as it prevents the attack at the source.

## Proof of Concept

```rust
#[cfg(test)]
mod exploit_test {
    use super::*;
    use aptos_types::block_info::BlockInfo;
    use aptos_crypto::HashValue;
    
    #[test]
    fn test_future_epoch_dos_attack() {
        // Setup: Create consensus observer with default config
        let max_num_pending_blocks = 150;
        let consensus_observer_config = ConsensusObserverConfig {
            max_num_pending_blocks,
            ..ConsensusObserverConfig::default()
        };
        let mut block_payload_store = BlockPayloadStore::new(consensus_observer_config);
        
        // Attack: Fill store with future-epoch blocks
        let malicious_epoch = 999999u64;
        for round in 0..max_num_pending_blocks {
            let block_info = BlockInfo::new(
                malicious_epoch,
                round,
                HashValue::random(),
                HashValue::random(),
                0,
                0,
                None,
            );
            let block_payload = BlockPayload::new(
                block_info,
                BlockTransactionPayload::empty()
            );
            
            // Insert as unverified (as would happen for future epochs)
            block_payload_store.insert_block_payload(block_payload, false);
        }
        
        // Verify store is full
        assert_eq!(block_payload_store.block_payloads.lock().len(), max_num_pending_blocks as usize);
        
        // Attempt to insert legitimate block at current epoch
        let current_epoch = 10u64;
        let legitimate_block_info = BlockInfo::new(
            current_epoch,
            100,
            HashValue::random(),
            HashValue::random(),
            0,
            0,
            None,
        );
        let legitimate_payload = BlockPayload::new(
            legitimate_block_info,
            BlockTransactionPayload::empty()
        );
        
        // This insertion will be DROPPED due to max_num_pending_blocks check
        block_payload_store.insert_block_payload(legitimate_payload.clone(), true);
        
        // Verify legitimate block was NOT added
        assert!(!block_payload_store.existing_payload_entry(&legitimate_payload));
        
        // Simulate cleanup after committing blocks at current epoch
        block_payload_store.remove_blocks_for_epoch_round(current_epoch, 100);
        
        // Critical vulnerability: Future-epoch malicious blocks are STILL present
        let remaining_payloads = block_payload_store.block_payloads.lock();
        assert_eq!(remaining_payloads.len(), max_num_pending_blocks as usize);
        
        // All remaining blocks are malicious future-epoch blocks
        for ((epoch, _), _) in remaining_payloads.iter() {
            assert_eq!(*epoch, malicious_epoch);
        }
        
        // DOS achieved: Legitimate blocks cannot be processed
    }
}
```

This test demonstrates that an attacker can fill the payload store with future-epoch blocks that persist through normal cleanup operations, effectively denying service to legitimate consensus observer operations.

### Citations

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L367-379)
```rust
        let last_ordered_block = self.observer_block_data.lock().get_last_ordered_block();
        let payload_out_of_date =
            (block_epoch, block_round) <= (last_ordered_block.epoch(), last_ordered_block.round());
        let payload_exists = self
            .observer_block_data
            .lock()
            .existing_payload_entry(&block_payload);

        // If the payload is out of date or already exists, ignore it
        if payload_out_of_date || payload_exists {
            // Update the metrics for the dropped block payload
            update_metrics_for_dropped_block_payload_message(peer_network_id, &block_payload);
            return;
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L399-418)
```rust
        // If the payload is for the current epoch, verify the proof signatures
        let epoch_state = self.get_epoch_state();
        let verified_payload = if block_epoch == epoch_state.epoch {
            // Verify the block proof signatures
            if let Err(error) = block_payload.verify_payload_signatures(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify block payload signatures! Ignoring block: {:?}, from peer: {:?}. Error: {:?}",
                        block_payload.block(), peer_network_id, error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::BLOCK_PAYLOAD_LABEL);
                return;
            }

            true // We have successfully verified the signatures
        } else {
            false // We can't verify the signatures yet
        };
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L1360-1366)
```rust
        peer_network_id,
    );
}

/// Increments the received message counter for the given peer and message
fn increment_received_message_counter(
    peer_network_id: &PeerNetworkId,
```

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L84-95)
```rust
        // Verify that the number of payloads doesn't exceed the maximum
        let max_num_pending_blocks = self.consensus_observer_config.max_num_pending_blocks as usize;
        if self.block_payloads.lock().len() >= max_num_pending_blocks {
            warn!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Exceeded the maximum number of payloads: {:?}. Dropping block: {:?}!",
                    max_num_pending_blocks,
                    block_payload.block(),
                ))
            );
            return; // Drop the block if we've exceeded the maximum
        }
```

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L111-119)
```rust
    /// Removes all blocks up to the specified epoch and round (inclusive)
    pub fn remove_blocks_for_epoch_round(&self, epoch: u64, round: Round) {
        // Determine the round to split off
        let split_off_round = round.saturating_add(1);

        // Remove the blocks from the payload store
        let mut block_payloads = self.block_payloads.lock();
        *block_payloads = block_payloads.split_off(&(epoch, split_off_round));
    }
```

**File:** config/src/config/consensus_observer_config.rs (L72-72)
```rust
            max_num_pending_blocks: 150, // 150 blocks (sufficient for existing production networks)
```
