# Audit Report

## Title
HTTP Health Check Indefinite Hang Vulnerability Leading to Localnet DoS

## Summary
The HTTP health checker in `aptos-localnet` lacks timeout configuration on HTTP GET requests, allowing a malicious server to cause indefinite resource consumption and denial of service by accepting connections but never responding.

## Finding Description
The `check()` function in the `HealthChecker::Http` variant uses `reqwest::get()` without any timeout configuration. [1](#0-0) 

The `reqwest::get()` convenience function creates a default HTTP client with **no timeout configured**. This breaks the **Resource Limits** invariant which requires "all operations must respect gas, storage, and computational limits."

When a malicious HTTP server accepts a TCP connection but never sends a response, the health check will hang indefinitely. The `wait_for_startup()` function has a 60-second outer timeout, but this timeout is never reached because it waits on `check_fn().await` which never completes: [2](#0-1) 

The timeout loop at line 194 checks `start.elapsed() < max_wait`, but this check only happens between iterations. If the first call to `check_fn().await` (line 195) hangs indefinitely, the loop never progresses and the timeout is never evaluated.

**Attack Path:**
1. Attacker configures localnet with a malicious HTTP endpoint
2. Localnet attempts health check during startup
3. Malicious server accepts TCP connection but never sends HTTP response
4. `reqwest::get()` hangs indefinitely waiting for response
5. Health check task consumes resources (TCP connection, async task) permanently
6. Localnet startup fails or becomes unresponsive

This pattern is inconsistent with other components in the codebase that properly configure timeouts: [3](#0-2) [4](#0-3) [5](#0-4) 

## Impact Explanation
This is a **High Severity** vulnerability per Aptos bug bounty criteria because it causes:
- **API/Service crashes**: Localnet fails to start or becomes unresponsive
- **Validator node slowdowns**: Health check tasks consume resources indefinitely
- **Significant protocol violations**: Violates resource limit invariants

The impact includes:
- Resource exhaustion through unbounded TCP connections and async tasks
- Denial of service preventing localnet initialization
- Potential cascade failures if other services wait on health checks

## Likelihood Explanation
**Likelihood: High**

The attack is trivial to execute:
- Requires no special privileges or insider access
- Simple to implement (HTTP server that accepts but never responds)
- Affects any localnet configuration using HTTP health checks
- No cryptographic or consensus knowledge required

The vulnerability is deterministic and always exploitable when a malicious HTTP endpoint is configured.

## Recommendation
Configure a timeout on the HTTP client using `reqwest::Client::builder()`:

```rust
HealthChecker::Http(url, _) => {
    let client = reqwest::Client::builder()
        .timeout(Duration::from_secs(10))
        .build()
        .context("Failed to build HTTP client")?;
    client.get(Url::clone(url))
        .send()
        .await
        .with_context(|| format!("Failed to GET {}", url))?;
    Ok(())
}
```

Alternatively, add a constant at the module level (similar to other health checkers like `DataServiceGrpc` which uses 5 seconds):

```rust
const HTTP_HEALTH_CHECK_TIMEOUT_SECS: u64 = 10;
```

## Proof of Concept

**Malicious Server (Python):**
```python
import socket
import time

# Create server that accepts connections but never responds
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.bind(('127.0.0.1', 8080))
server.listen(1)
print("Malicious server listening on port 8080...")

while True:
    conn, addr = server.accept()
    print(f"Accepted connection from {addr}, hanging indefinitely...")
    # Never send response - connection hangs forever
    time.sleep(999999)
```

**Rust PoC:**
```rust
#[tokio::test]
async fn test_http_health_check_timeout() {
    use std::time::Duration;
    use tokio::time::timeout;
    
    // Start malicious server that never responds
    tokio::spawn(async {
        let listener = tokio::net::TcpListener::bind("127.0.0.1:9999")
            .await
            .unwrap();
        loop {
            let (mut socket, _) = listener.accept().await.unwrap();
            // Accept connection but never respond
            tokio::time::sleep(Duration::from_secs(999999)).await;
        }
    });
    
    tokio::time::sleep(Duration::from_millis(100)).await;
    
    let url = reqwest::Url::parse("http://127.0.0.1:9999").unwrap();
    let checker = HealthChecker::Http(url, "malicious".to_string());
    
    // This should timeout but will hang indefinitely
    let result = timeout(Duration::from_secs(2), checker.check()).await;
    
    // Expected: timeout error
    // Actual: hangs forever
    assert!(result.is_err(), "Health check should timeout");
}
```

The PoC demonstrates that without timeout configuration, the health check hangs indefinitely when the server never responds.

## Notes
- The vulnerability is specific to the `HealthChecker::Http` variant
- Other health checkers (`DataServiceGrpc`, `NodeApi`) may have proper timeout handling
- The fix should align with timeout patterns used elsewhere in the codebase (5-15 seconds)
- Consider adding timeout configuration as a parameter for different use cases

### Citations

**File:** crates/aptos-localnet/src/health_checker.rs (L46-51)
```rust
            HealthChecker::Http(url, _) => {
                reqwest::get(Url::clone(url))
                    .await
                    .with_context(|| format!("Failed to GET {}", url))?;
                Ok(())
            },
```

**File:** crates/aptos-localnet/src/health_checker.rs (L182-216)
```rust
async fn wait_for_startup<F, Fut>(check_fn: F, error_message: String) -> Result<()>
where
    F: Fn() -> Fut,
    Fut: futures::Future<Output = Result<()>>,
{
    let max_wait = Duration::from_secs(MAX_WAIT_S);
    let wait_interval = Duration::from_millis(WAIT_INTERVAL_MS);

    let start = Instant::now();
    let mut started_successfully = false;

    let mut last_error_message = None;
    while start.elapsed() < max_wait {
        match check_fn().await {
            Ok(_) => {
                started_successfully = true;
                break;
            },
            Err(err) => {
                last_error_message = Some(format!("{:#}", err));
            },
        }
        tokio::time::sleep(wait_interval).await
    }

    if !started_successfully {
        let error_message = match last_error_message {
            Some(last_error_message) => format!("{}: {}", error_message, last_error_message),
            None => error_message,
        };
        return Err(anyhow!(error_message));
    }

    Ok(())
}
```

**File:** keyless/pepper/service/src/utils.rs (L16-22)
```rust
/// Creates and returns a reqwest HTTP client with a timeout
pub fn create_request_client() -> Client {
    Client::builder()
        .timeout(Duration::from_secs(CLIENT_REQUEST_TIMEOUT_SECS))
        .build()
        .expect("Failed to build the request client!")
}
```

**File:** crates/aptos-rest-client/src/faucet.rs (L25-28)
```rust
            inner: ReqwestClient::builder()
                .timeout(Duration::from_secs(10))
                .build()
                .unwrap(),
```

**File:** ecosystem/node-checker/fn-check-client/src/check.rs (L62-65)
```rust
        let nhc_client = ReqwestClient::builder()
            .timeout(Duration::from_secs(self.nhc_timeout_secs))
            .build()
            .expect("Somehow failed to build reqwest client");
```
