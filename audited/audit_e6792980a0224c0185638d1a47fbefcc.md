# Audit Report

## Title
Information Disclosure via Unsanitized Error Messages in API Error Responses

## Summary
The Aptos API error handling chain does not sanitize internal error details when converting storage layer errors to API responses. This allows sensitive information such as database file paths, internal directory structures, and system configuration details to leak to external clients through API error messages, violating information security best practices and potentially aiding attackers in reconnaissance.

## Finding Description

The vulnerability exists in the error conversion chain from RocksDB storage errors to API responses. When database operations fail, the raw error messages—which can contain sensitive internal details—are propagated without sanitization through multiple layers and ultimately exposed to external API clients.

**Error Flow Chain:**

1. **RocksDB Error Generation**: When RocksDB encounters errors (IO errors, file access issues, corruption), it generates error messages containing full file system paths and internal details.

2. **Storage Layer Conversion**: In `storage/schemadb/src/lib.rs`, the `to_db_err()` function converts RocksDB errors to `AptosDbError` by calling `rocksdb_err.to_string()`, preserving all error details without sanitization: [1](#0-0) 

3. **API Error Conversion**: In `api/types/src/error.rs`, when creating `AptosError` from internal errors, the message is formatted using `format!("{:#}", error)` with no sanitization: [2](#0-1) 

4. **Warp Webserver Error Handling**: The `aptos-warp-webserver` also exposes this issue in its `from_anyhow_error()` function, which directly calls `err.to_string()`: [3](#0-2) 

5. **API Response Generation**: The generated error response macro in `api/src/response.rs` creates API errors that serialize the unsanitized message to JSON: [4](#0-3) 

**Attack Scenario:**

An attacker makes API requests (e.g., GET `/v1/transactions`, POST `/v1/transactions`) while the node is experiencing database issues or when specific error conditions can be triggered. The API returns error responses like:

```json
{
  "message": "Failed to read latest state checkpoint from DB: AptosDB RocksDB Error: IO error: /var/aptos/production/db/state_merkle_db/000123.sst: No such file or directory",
  "error_code": "internal_error",
  "vm_error_code": null
}
```

This reveals:
- Internal database directory structure (`/var/aptos/production/db/state_merkle_db/`)
- File naming conventions (`000123.sst`)
- Deployment paths and configuration
- Database architecture details

**Concrete Example in Code:**

In `api/src/transactions.rs`, when submitting transactions, database errors are wrapped with context and converted to API errors without sanitization: [5](#0-4) 

The `.context()` call adds descriptive text, but the underlying error (which may contain paths) is preserved and ultimately exposed to the client.

## Impact Explanation

**Severity: Medium** (per Aptos Bug Bounty criteria for information disclosure)

This vulnerability qualifies as **Medium severity** because:

1. **Information Disclosure**: It leaks sensitive internal system information to unauthorized external parties, meeting the "Minor information leaks" to "State inconsistencies requiring intervention" criteria.

2. **Reconnaissance Aid**: The exposed information significantly aids attackers in:
   - Understanding the node's deployment environment
   - Mapping internal file system structure
   - Identifying potential attack surfaces
   - Crafting targeted exploits against specific paths or configurations

3. **Operational Security Impact**: Reveals details that should remain internal:
   - Database sharding configuration
   - Storage paths and organization
   - System architecture decisions
   - Deployment patterns

4. **No Direct Fund Loss**: This is not a direct fund theft or consensus violation, preventing Critical/High classification, but it materially weakens the security posture of the deployment.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to be exploited because:

1. **No Special Access Required**: Any external client with API access can trigger this by making normal API requests during error conditions.

2. **Common Error Conditions**: Database errors occur naturally during:
   - System restarts or maintenance
   - Storage capacity issues
   - File system permission problems
   - Hardware failures
   - State sync operations

3. **Easy to Trigger**: An attacker can attempt to trigger errors through:
   - High volume of concurrent requests
   - Requests during known maintenance windows
   - Requests for recently pruned data
   - Edge case queries that stress the storage layer

4. **No Rate Limiting on Errors**: Error responses are not typically rate-limited, allowing attackers to probe extensively.

5. **Production Exposure**: All public API endpoints are affected, including those exposed to untrusted internet clients.

## Recommendation

Implement error message sanitization at the API boundary. Sensitive internal details should be logged server-side but never exposed to clients.

**Recommended Fix:**

1. **Create Error Sanitization Layer**:

```rust
// In api/types/src/error.rs
impl AptosError {
    pub fn new_with_error_code<ErrorType: std::fmt::Display>(
        error: ErrorType,
        error_code: AptosErrorCode,
    ) -> AptosError {
        Self {
            message: sanitize_error_message(format!("{:#}", error)),
            error_code,
            vm_error_code: None,
        }
    }
}

// Add sanitization function
fn sanitize_error_message(msg: String) -> String {
    // Remove file paths
    let msg = regex::Regex::new(r"/[^\s:]+")
        .unwrap()
        .replace_all(&msg, "[REDACTED_PATH]");
    
    // Remove potential memory addresses
    let msg = regex::Regex::new(r"0x[0-9a-fA-F]{8,}")
        .unwrap()
        .replace_all(&msg, "[REDACTED_ADDR]");
    
    // Provide generic error message
    match extract_error_category(&msg) {
        Some(category) => format!("Internal error: {}", category),
        None => "Internal server error occurred".to_string()
    }
}
```

2. **Update Warp Webserver Error Handling**:

```rust
// In crates/aptos-warp-webserver/src/error.rs
pub fn from_anyhow_error(code: StatusCode, err: anyhow::Error) -> Self {
    Self::new(code, sanitize_error_for_client(err.to_string()))
}
```

3. **Maintain Detailed Logging**: Ensure full error details (including paths) are still logged server-side for debugging:

```rust
// Log full details before sanitization
error!(
    error_code = ?error_code,
    full_error = %error,
    "Internal error occurred"
);

// Then sanitize for client
Self {
    message: sanitize_error_message(format!("{:#}", error)),
    error_code,
    vm_error_code: None,
}
```

## Proof of Concept

**Setup**: Deploy an Aptos node with API enabled.

**Step 1**: Create a scenario where database errors occur (e.g., restrict file permissions on a DB file):

```bash
# On the node
chmod 000 /var/aptos/data/db/state_merkle_db/CURRENT
```

**Step 2**: Make an API request that requires database access:

```bash
curl -X GET "http://localhost:8080/v1/transactions?start=100&limit=10" \
  -H "Accept: application/json"
```

**Expected Vulnerable Response**:
```json
{
  "message": "Failed to read transactions from storage: AptosDB RocksDB Error: IO error: /var/aptos/data/db/state_merkle_db/CURRENT: Permission denied (os error 13)",
  "error_code": "internal_error",
  "vm_error_code": null
}
```

**Expected Secure Response** (after fix):
```json
{
  "message": "Internal error: database access failed",
  "error_code": "internal_error", 
  "vm_error_code": null
}
```

**Verification**: Inspect the JSON response for the presence of file system paths. The vulnerable version will contain paths like `/var/aptos/data/db/state_merkle_db/CURRENT`, while the fixed version will contain only a sanitized generic message.

**Notes**

This vulnerability represents a defense-in-depth failure rather than a direct exploit. While it doesn't immediately lead to fund theft or consensus violation, it materially weakens operational security by exposing internal implementation details that should remain confidential. The fix is straightforward but requires careful implementation to balance security (hiding internal details) with debuggability (maintaining server-side logs).

The issue affects all API endpoints that interact with the storage layer, including transaction submission, account queries, state reads, and event retrieval. Production deployments should prioritize this fix to prevent reconnaissance by potential attackers.

### Citations

**File:** storage/schemadb/src/lib.rs (L389-407)
```rust
fn to_db_err(rocksdb_err: rocksdb::Error) -> AptosDbError {
    match rocksdb_err.kind() {
        ErrorKind::Incomplete => AptosDbError::RocksDbIncompleteResult(rocksdb_err.to_string()),
        ErrorKind::NotFound
        | ErrorKind::Corruption
        | ErrorKind::NotSupported
        | ErrorKind::InvalidArgument
        | ErrorKind::IOError
        | ErrorKind::MergeInProgress
        | ErrorKind::ShutdownInProgress
        | ErrorKind::TimedOut
        | ErrorKind::Aborted
        | ErrorKind::Busy
        | ErrorKind::Expired
        | ErrorKind::TryAgain
        | ErrorKind::CompactionTooLarge
        | ErrorKind::ColumnFamilyDropped
        | ErrorKind::Unknown => AptosDbError::OtherRocksDbError(rocksdb_err.to_string()),
    }
```

**File:** api/types/src/error.rs (L29-38)
```rust
    pub fn new_with_error_code<ErrorType: std::fmt::Display>(
        error: ErrorType,
        error_code: AptosErrorCode,
    ) -> AptosError {
        Self {
            message: format!("{:#}", error),
            error_code,
            vm_error_code: None,
        }
    }
```

**File:** crates/aptos-warp-webserver/src/error.rs (L30-32)
```rust
    pub fn from_anyhow_error(code: StatusCode, err: anyhow::Error) -> Self {
        Self::new(code, err.to_string())
    }
```

**File:** api/src/response.rs (L170-189)
```rust
            fn [<$name:snake _with_code>]<Err: std::fmt::Display>(
                err: Err,
                error_code: aptos_api_types::AptosErrorCode,
                ledger_info: &aptos_api_types::LedgerInfo
            )-> Self where Self: Sized {
                let error = aptos_api_types::AptosError::new_with_error_code(err, error_code);
                let payload = poem_openapi::payload::Json(Box::new(error));

                Self::from($enum_name::$name(
                    payload,
                    Some(ledger_info.chain_id),
                    Some(ledger_info.ledger_version.into()),
                    Some(ledger_info.oldest_ledger_version.into()),
                    Some(ledger_info.ledger_timestamp.into()),
                    Some(ledger_info.epoch.into()),
                    Some(ledger_info.block_height.into()),
                    Some(ledger_info.oldest_block_height.into()),
                    None,
                ))
            }
```

**File:** api/src/transactions.rs (L1503-1513)
```rust
                    let state_view = self
                        .context
                        .latest_state_view()
                        .context("Failed to read latest state checkpoint from DB")
                        .map_err(|e| {
                            SubmitTransactionError::internal_with_code(
                                e,
                                AptosErrorCode::InternalError,
                                ledger_info,
                            )
                        })?;
```
