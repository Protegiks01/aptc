# Audit Report

## Title
Race Condition in BlockSTMv2 Module Validation Leading to Consensus Divergence

## Summary
A race condition exists in BlockSTMv2's cold validation mechanism between transaction scheduling and module validation requirement recording. This allows transactions to execute with stale module versions and commit without validation, breaking the deterministic execution invariant and causing consensus divergence.

## Finding Description

BlockSTMv2 uses a cold validation mechanism for module reads to avoid overhead on the common path. When a transaction publishes modules during commit, it records validation requirements for all potentially affected transactions by reading `min_never_scheduled_idx` from the `ExecutionQueueManager`. [1](#0-0) 

The race condition occurs because `pop_next()` performs two non-atomic operations:
1. Pops a transaction index from the execution queue (acquiring and releasing the lock)
2. Updates `min_never_scheduled_idx` to `idx + 1` [2](#0-1) 

Concurrently, `record_validation_requirements` reads `min_never_scheduled_idx` to determine which transactions need module validation: [3](#0-2) 

**Attack Sequence:**
1. Transaction T3 commits and publishes module M
2. Thread 1 begins `record_validation_requirements(txn_idx=3)`
3. Thread 2 calls `pop_next()`, pops transaction index 10, releases queue lock
4. Thread 1 reads `min_never_scheduled_idx()` â†’ returns 10 (not yet updated)
5. Thread 2 updates `min_never_scheduled_idx` to 11
6. Thread 1 records requirements for transactions 4-9 only (missing T10)
7. Transaction 10 starts executing, reads module M from global cache (old version)
8. Module M is marked as overridden in global cache [4](#0-3) 

9. Transaction 10 completes execution with old module M
10. Transaction 10 is NOT in cold validation requirements range
11. Transaction 10 commits without module read validation [5](#0-4) 

The commit is allowed because `is_commit_blocked` returns false - T10 is not in the recorded requirements range.

## Impact Explanation

This vulnerability breaks the **Deterministic Execution** invariant: "All validators must produce identical state roots for identical blocks."

When this race occurs:
- Some validators may execute transaction 10 with the old module version (if race occurs)
- Other validators may execute transaction 10 with the new module version (if properly validated and re-executed)
- Different execution results lead to different state roots
- **Consensus Safety Violation** - validators diverge on block state

This qualifies as **Critical Severity** per Aptos bug bounty:
- Consensus/Safety violations (up to $1,000,000)
- Non-recoverable network partition requiring hardfork

The vulnerability affects all validators running BlockSTMv2 (when `blockstm_v2: true`). Even a single occurrence causes permanent chain split requiring coordinated intervention.

## Likelihood Explanation

The race condition window is microseconds wide - between releasing the execution queue lock and updating `min_never_scheduled_idx`. However:

**Likelihood factors:**
- Occurs probabilistically during normal operation with module publishing
- Probability increases with:
  - Higher parallelism (more concurrent workers)
  - More module publishing transactions
  - Higher transaction throughput
- With only 5-10 test executions per configuration in `module_tests.rs`, probability of detection is extremely low
- In production with sustained load, the race will eventually occur [6](#0-5) 

The test parameters show insufficient stress testing for this timing-dependent race condition.

## Recommendation

Make the read of `min_never_scheduled_idx` and transaction scheduling atomic with respect to module validation requirement recording. 

**Option 1: Acquire lock during validation requirement recording**
```rust
pub(crate) fn record_validation_requirements(
    &self,
    worker_id: u32,
    calling_txn_idx: TxnIndex,
    requirements: BTreeSet<R>,
) -> Result<(), PanicError> {
    // Acquire execution queue lock to ensure atomicity
    let execution_queue = self.txn_statuses.get_execution_queue_manager().execution_queue.lock();
    let min_never_scheduled_idx = self.min_never_scheduled_idx()?;
    drop(execution_queue); // Release after reading
    
    // Continue with existing logic...
}
```

**Option 2: Update min_never_scheduled_idx BEFORE releasing queue lock**
```rust
fn pop_next(&self) -> Option<TxnIndex> {
    let mut queue = self.execution_queue.lock();
    let ret = queue.pop_first();
    if let Some(idx) = ret {
        self.min_never_scheduled_idx.fetch_max(idx + 1, Ordering::Relaxed);
    }
    drop(queue); // Update happens before lock release
    ret
}
```

**Option 3: Use a single atomic operation combining pop and update** (most robust).

Additionally, increase test executions in `module_tests.rs` from 5-10 to at least 1000 iterations for critical module publishing scenarios to detect such race conditions.

## Proof of Concept

```rust
// Stress test to reproduce the race condition
#[test]
fn test_module_validation_race_condition() {
    use std::sync::{Arc, atomic::{AtomicBool, Ordering}};
    use std::thread;
    
    let race_detected = Arc::new(AtomicBool::new(false));
    let iterations = 10000;
    
    for _ in 0..iterations {
        let executor_pool = create_executor_thread_pool();
        let scheduler = SchedulerV2::new(100, 8);
        let race_flag = race_detected.clone();
        
        // Thread 1: Module publishing + requirement recording
        let handle1 = thread::spawn(move || {
            // Simulate module publish at index 50
            let min_idx = scheduler.min_never_scheduled_idx().unwrap();
            // Record requirements for transactions after 50
            scheduler.record_validation_requirements(0, 50, min_idx, requirements);
        });
        
        // Thread 2: Transaction scheduling
        let handle2 = thread::spawn(move || {
            // Simulate scheduling transaction at min_idx
            let popped = scheduler.txn_statuses
                .get_execution_queue_manager()
                .pop_next();
            // Check if this transaction should have been in requirements
            if let Some(idx) = popped {
                // Verify validation requirements were recorded
                if !scheduler.cold_validation_requirements
                    .requires_validation(idx) {
                    race_flag.store(true, Ordering::SeqCst);
                }
            }
        });
        
        handle1.join().unwrap();
        handle2.join().unwrap();
        
        if race_detected.load(Ordering::SeqCst) {
            panic!("Race condition detected: transaction bypassed validation");
        }
    }
}
```

The test should be run with thread scheduling randomization to increase probability of detecting the race within reasonable iterations.

### Citations

**File:** aptos-move/block-executor/src/scheduler_v2.rs (L391-398)
```rust
    fn pop_next(&self) -> Option<TxnIndex> {
        let ret = self.execution_queue.lock().pop_first();
        if let Some(idx) = ret {
            self.min_never_scheduled_idx
                .fetch_max(idx + 1, Ordering::Relaxed);
        }
        ret
    }
```

**File:** aptos-move/block-executor/src/scheduler_v2.rs (L400-402)
```rust
    fn min_never_scheduled_idx(&self) -> TxnIndex {
        self.min_never_scheduled_idx.load(Ordering::Relaxed)
    }
```

**File:** aptos-move/block-executor/src/scheduler_v2.rs (L1037-1049)
```rust
        let min_never_scheduled_idx = self.min_never_scheduled_idx()?;
        if txn_idx >= min_never_scheduled_idx {
            return Err(code_invariant_error(format!(
                "Calling txn idx {} must be less than min_never_scheduled_idx {}",
                txn_idx, min_never_scheduled_idx
            )));
        }
        self.cold_validation_requirements.record_requirements(
            worker_id,
            txn_idx,
            min_never_scheduled_idx,
            module_ids,
        )
```

**File:** aptos-move/block-executor/src/code_cache_global.rs (L124-128)
```rust
    pub fn mark_overridden(&self, key: &K) {
        if let Some(entry) = self.module_cache.get(key) {
            entry.mark_overridden();
        }
    }
```

**File:** aptos-move/block-executor/src/cold_validation.rs (L421-431)
```rust
    pub(crate) fn is_commit_blocked(&self, txn_idx: TxnIndex, incarnation: Incarnation) -> bool {
        // The order of checks is important to avoid a concurrency bugs (since recording
        // happens in the opposite order). We first check that there are no unscheduled
        // requirements below (incl.) the given index, and then that there are no scheduled
        // but yet unfulfilled (validated) requirements for the index.
        self.min_idx_with_unprocessed_validation_requirement
            .load(Ordering::Relaxed)
            <= txn_idx
            || self.deferred_requirements_status[txn_idx as usize].load(Ordering::Relaxed)
                == blocked_incarnation_status(incarnation)
    }
```

**File:** aptos-move/block-executor/src/combinatorial_tests/module_tests.rs (L152-157)
```rust
#[test_matrix(
    50, 100, [false, true], [false, true], [ModuleTestType::AllTransactionsAndAccesses, ModuleTestType::MixedTransactionsMixedAccesses,  ModuleTestType::AllTransactionsMixedAccesses], 10, 3; "module tests"
)]
#[test_matrix(
    10, 1000, [false, true], [false, true], [ModuleTestType::AllTransactionsAndAccesses, ModuleTestType::MixedTransactionsMixedAccesses,  ModuleTestType::AllTransactionsMixedAccesses], 5, 2; "contended module tests"
)]
```
