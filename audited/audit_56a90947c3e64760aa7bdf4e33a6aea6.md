# Audit Report

## Title
Unhandled Allocation Failures in Multi-Pairing Native Function Lead to Validator Node Crashes

## Summary
The `multi_pairing_internal!` macro in the pairing cryptography native function allocates temporary vectors without proper error handling. If `Vec::with_capacity` fails due to allocation errors, the resulting panic will crash the validator node instead of being gracefully converted to a `SafeNativeError`. [1](#0-0) [2](#0-1) 

## Finding Description

The vulnerability exists in the error handling (or lack thereof) of vector allocations within the `multi_pairing_internal!` macro. The macro receives vectors of cryptographic element handles from Move code, extracts their length as `num_entries`, and uses this to allocate temporary vectors for affine point representations. [3](#0-2) 

In Rust, `Vec::with_capacity(n)` can panic in the following scenarios:
1. The capacity calculation overflows or exceeds `isize::MAX`
2. The system allocator fails to allocate the requested memory

When a panic occurs in a native function, it propagates through the call stack without being caught. The Aptos panic handler only allows unwinding for specific VM states (VERIFIER or DESERIALIZER), as shown in the crash handler: [4](#0-3) 

For native function execution, the VM state is NOT in VERIFIER or DESERIALIZER mode, so the panic will trigger `process::exit(12)`, crashing the entire validator node.

The native function builder does not wrap native function calls in any panic-catching mechanism: [5](#0-4) 

**Attack Vector:**

1. An attacker creates a Move transaction that builds large vectors of cryptographic element handles within the Move VM's memory quota (10 million abstract units)
2. The transaction calls `multi_pairing` with these large vectors
3. The native function attempts to allocate temporary vectors for affine point representations
4. Under memory pressure (e.g., concurrent transactions, memory fragmentation, or other system load), the allocation fails
5. `Vec::with_capacity` panics, causing the validator node to crash

**Memory Amplification:**
For a vector of N u64 handles (8N bytes), the native function allocates:
- BLS12-381: ~96N bytes (G1 affine) + ~192N bytes (G2 affine) = 288N bytes total
- BN254: ~64N bytes (G1 affine) + ~128N bytes (G2 affine) = 192N bytes total

This represents a 36x (BLS12-381) or 24x (BN254) memory amplification from the input vector size.

**Contrast with Proper Error Handling:**

The `store_element!` macro in the same module demonstrates proper error handling for memory limits: [6](#0-5) 

This macro checks memory limits and returns `SafeNativeError::Abort` if exceeded. The temporary vector allocations in the pairing function lack similar protections.

## Impact Explanation

This issue qualifies as **High Severity** according to the Aptos bug bounty criteria:
- "Validator node slowdowns" - A node crash causes complete unavailability until manual restart
- "API crashes" - The native function execution failure crashes the API endpoint

The impact includes:
- **Validator Availability**: Affected validators become unavailable, reducing network liveness
- **Consensus Participation**: Crashed validators cannot participate in consensus rounds
- **Service Disruption**: Users experience transaction failures and service degradation
- **Network Health**: Multiple crashed validators could impact network performance

While this does not directly cause loss of funds or consensus violations, it affects network availability, which is a High severity impact category.

## Likelihood Explanation

The likelihood is **Medium** because:

**Factors Increasing Likelihood:**
- Move VM memory quota allows vectors with hundreds of thousands to millions of elements
- Concurrent transaction execution can exhaust available memory
- Memory fragmentation over time increases allocation failure probability
- No validation or limits on temporary allocation sizes in native functions
- Validators run continuously under varying load conditions

**Factors Decreasing Likelihood:**
- Validator nodes typically have adequate RAM (32-64+ GB)
- Modern allocators are robust and rarely fail for sub-GB allocations
- Transaction argument size limit (1 MB) restricts direct argument vectors
- Gas costs discourage creation of extremely large vectors in Move code

The vulnerability requires specific conditions (memory pressure, concurrent large transactions) but is feasible under realistic validator operation, especially during high-load periods.

## Recommendation

Implement proper error handling for vector allocations using fallible allocation methods. Replace `Vec::with_capacity` with a checked allocation pattern:

```rust
// Replace lines 106 and 113 with:
let mut g1_elements_affine = Vec::new();
match g1_elements_affine.try_reserve(num_entries) {
    Ok(_) => {},
    Err(_) => {
        return Err(SafeNativeError::Abort {
            abort_code: E_TOO_MUCH_MEMORY_USED,
        });
    }
}

// Similar for g2_elements_affine:
let mut g2_elements_affine = Vec::new();
match g2_elements_affine.try_reserve(num_entries) {
    Ok(_) => {},
    Err(_) => {
        return Err(SafeNativeError::Abort {
            abort_code: E_TOO_MUCH_MEMORY_USED,
        });
    }
}
```

Alternatively, enforce a maximum limit on vector sizes before allocation:

```rust
const MAX_PAIRING_ELEMENTS: usize = 10_000;
if num_entries > MAX_PAIRING_ELEMENTS {
    return Err(SafeNativeError::Abort {
        abort_code: MOVE_ABORT_CODE_INPUT_VECTOR_SIZES_NOT_MATCHING,
    });
}
```

This ensures all allocation failures are gracefully handled and converted to appropriate Move-level errors.

## Proof of Concept

```move
// Move test demonstrating the vulnerability path
// File: test_pairing_memory_exhaustion.move

#[test_only]
module test_addr::pairing_memory_test {
    use std::vector;
    use aptos_std::crypto_algebra::{multi_pairing, Element};
    use aptos_std::bls12381_algebra::{G1, G2, Gt, Fr};

    #[test(fx = @std)]
    fun test_large_multi_pairing(fx: &signer) {
        // Enable cryptography algebra natives
        aptos_framework::enable_cryptography_algebra_natives(fx);
        
        // Create large vectors approaching memory quota limits
        // This attempts to trigger allocation failure in native function
        let g1_elements = vector::empty<Element<G1>>();
        let g2_elements = vector::empty<Element<G2>>();
        
        // Build vectors with many elements
        // Actual size limited by Move VM memory quota
        let i = 0;
        while (i < 500000) {  // Half million elements
            vector::push_back(&mut g1_elements, create_random_g1());
            vector::push_back(&mut g2_elements, create_random_g2());
            i = i + 1;
        };
        
        // This call will attempt to allocate:
        // 500k * 96 bytes = 48 MB for G1 affine
        // 500k * 192 bytes = 96 MB for G2 affine
        // Total: 144 MB temporary allocation
        // Under memory pressure, this allocation could fail and panic
        let result = multi_pairing<G1, G2, Gt>(&g1_elements, &g2_elements);
    }
}
```

**Note:** The actual PoC would need to be run under memory-constrained conditions or with concurrent transactions to trigger the allocation failure. The vulnerability is in the error handling path, not in normal successful execution.

## Notes

This vulnerability represents a violation of native function safety principlesâ€”native functions must never panic under any input conditions, including resource exhaustion. While the AlgebraContext properly tracks and limits memory for stored elements, temporary allocations bypass these protections. The fix should align temporary allocation handling with the defensive programming standards demonstrated in the `store_element!` macro.

### Citations

**File:** aptos-move/framework/src/natives/cryptography/algebra/pairing.rs (L96-103)
```rust
        let g2_element_handles = safely_pop_arg!($args, Vec<u64>);
        let g1_element_handles = safely_pop_arg!($args, Vec<u64>);
        let num_entries = g1_element_handles.len();
        if num_entries != g2_element_handles.len() {
            return Err(SafeNativeError::Abort {
                abort_code: MOVE_ABORT_CODE_INPUT_VECTOR_SIZES_NOT_MATCHING,
            });
        }
```

**File:** aptos-move/framework/src/natives/cryptography/algebra/pairing.rs (L106-106)
```rust
        let mut g1_elements_affine = Vec::with_capacity(num_entries);
```

**File:** aptos-move/framework/src/natives/cryptography/algebra/pairing.rs (L113-113)
```rust
        let mut g2_elements_affine = Vec::with_capacity(num_entries);
```

**File:** crates/crash-handler/src/lib.rs (L48-57)
```rust
    // Do not kill the process if the panics happened at move-bytecode-verifier.
    // This is safe because the `state::get_state()` uses a thread_local for storing states. Thus the state can only be mutated to VERIFIER by the thread that's running the bytecode verifier.
    //
    // TODO: once `can_unwind` is stable, we should assert it. See https://github.com/rust-lang/rust/issues/92988.
    if state::get_state() == VMState::VERIFIER || state::get_state() == VMState::DESERIALIZER {
        return;
    }

    // Kill the process
    process::exit(12);
```

**File:** aptos-move/aptos-native-interface/src/builder.rs (L117-118)
```rust
            let res: Result<SmallVec<[Value; 1]>, SafeNativeError> =
                native(&mut context, ty_args, args);
```

**File:** aptos-move/framework/src/natives/cryptography/algebra/mod.rs (L244-260)
```rust
macro_rules! store_element {
    ($context:expr, $obj:expr) => {{
        let context = &mut $context.extensions_mut().get_mut::<AlgebraContext>();
        let new_size = context.bytes_used + std::mem::size_of_val(&$obj);
        if new_size > MEMORY_LIMIT_IN_BYTES {
            Err(SafeNativeError::Abort {
                abort_code: E_TOO_MUCH_MEMORY_USED,
            })
        } else {
            let target_vec = &mut context.objs;
            context.bytes_used = new_size;
            let ret = target_vec.len();
            target_vec.push(Rc::new($obj));
            Ok(ret)
        }
    }};
}
```
