# Audit Report

## Title
Health Check Failure Counter Reset via Unsolicited Ping Requests

## Summary
Malicious peers can avoid disconnection due to health check failures by periodically sending unsolicited Ping RPC requests. When a node receives an inbound Ping request, it unconditionally resets the sender's failure counter, even if that sender is currently failing to respond to the node's outbound health checks.

## Finding Description

The HealthChecker protocol is designed to monitor peer liveness by periodically sending Ping requests and expecting Pong responses. If a peer fails to respond to consecutive health checks exceeding `ping_failures_tolerated`, the node disconnects from that peer. [1](#0-0) 

However, the implementation has a critical flaw in how it handles inbound Ping requests. When a node receives a Ping request from a peer, it calls `reset_peer_failures()` to reset that peer's failure counter: [2](#0-1) 

The `reset_peer_failures()` method unconditionally sets the failure counter to zero: [3](#0-2) 

This creates an exploitable condition where:

1. **Node A** actively monitors **Node B** by sending periodic Ping requests
2. **Node B** stops responding to A's Ping requests (malicious or faulty behavior)
3. **Node A** increments B's failure counter with each timeout
4. Before reaching `ping_failures_tolerated`, **Node B** sends a Ping request to **Node A**
5. **Node A** receives the Ping, responds with Pong, and **resets B's failure counter to 0**
6. **Node B** can continue ignoring A's health checks while periodically sending Pings to reset the counter

This breaks the health check invariant that unresponsive peers should be disconnected after a configured number of failures. A malicious peer can strategically send Ping requests to maintain connectivity indefinitely, even when completely unresponsive to health checks.

## Impact Explanation

This vulnerability allows malicious or faulty peers to:
- **Avoid disconnection** despite failing health checks
- **Remain connected to the network** without providing proper liveness guarantees
- **Consume connection slots** that could be used by healthy peers
- **Degrade network quality** by maintaining connections to unresponsive nodes

The impact is classified as **Low Severity** per Aptos bug bounty criteria:
- Does not directly compromise consensus, funds, or state integrity
- Does not cause network partition or liveness failure
- Affects peer reputation and connection management (non-critical network health)
- Can be mitigated by other network-level mechanisms (e.g., connection limits, reputation systems)

This directly addresses the security question about manipulating HealthCheckerRpc to falsely report health status and affect connection management.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is easy to exploit because:
- **No special privileges required**: Any connected peer can send HealthCheckerRpc requests
- **Simple attack vector**: Requires only periodic Ping requests (already part of the protocol)
- **No detection mechanism**: No validation distinguishes legitimate vs. manipulative Ping requests
- **Bidirectional health checking**: The protocol naturally allows both nodes to ping each other
- **Timing is flexible**: Attacker can send Pings at any time before reaching failure threshold

The code comment "Record Ingress HC here and reset failures" suggests this may have been intentional design, but it creates an exploitable loophole.

## Recommendation

Modify the health checker to distinguish between:
1. **Outbound health checks** (this node monitoring peers)
2. **Inbound health checks** (peers monitoring this node)

The failure counter should only be reset by successful **outbound** Ping/Pong exchanges, not by receiving inbound Ping requests. 

**Recommended fix** in `handle_ping_request()`:

```rust
fn handle_ping_request(
    &mut self,
    peer_id: PeerId,
    ping: Ping,
    protocol: ProtocolId,
    res_tx: oneshot::Sender<Result<Bytes, RpcError>>,
) {
    // Serialize and send Pong response
    let message = match protocol.to_bytes(&HealthCheckerMsg::Pong(Pong(ping.0))) {
        Ok(msg) => msg,
        Err(e) => {
            warn!(...);
            return;
        },
    };
    
    trace!(...);
    
    // REMOVE THIS LINE - inbound pings should not reset outbound failure tracking:
    // self.network_interface.reset_peer_failures(peer_id);
    
    let _ = res_tx.send(Ok(message.into()));
}
```

Alternatively, maintain separate counters for inbound and outbound health checks if bidirectional monitoring is desired.

## Proof of Concept

The following Rust test demonstrates the vulnerability by showing that a peer can reset its failure counter by sending unsolicited Pings:

```rust
#[tokio::test]
async fn inbound_ping_resets_outbound_failure_counter() {
    let ping_failures_tolerated = 5;
    let (mut harness, health_checker) = TestHarness::new_permissive(ping_failures_tolerated);

    let test = async move {
        let peer_id = PeerId::new([0x42; PeerId::LENGTH]);
        harness.send_new_peer_notification(peer_id).await;

        // Trigger failures: peer doesn't respond to our pings
        for i in 0..ping_failures_tolerated {
            harness.trigger_ping().await;
            harness.expect_ping_send_not_ok().await;
            // After each failure, check if peer is about to be disconnected
            if i == ping_failures_tolerated - 1 {
                // Peer sends unsolicited ping to reset counter
                let res_rx = harness.send_inbound_ping(peer_id, 999).await;
                expect_pong(res_rx).await;
                // Failure counter is now reset to 0!
            }
        }

        // Continue failing for another ping_failures_tolerated rounds
        // Peer should have been disconnected by now, but isn't due to counter reset
        for _ in 0..ping_failures_tolerated {
            harness.trigger_ping().await;
            harness.expect_ping_send_not_ok().await;
        }

        // Peer will only be disconnected after another full cycle
        harness.expect_disconnect(peer_id).await;
    };
    
    future::join(health_checker.start(), test).await;
}
```

This test demonstrates that receiving an inbound Ping resets the failure counter, allowing a peer to survive an additional `ping_failures_tolerated` failures before disconnection.

## Notes

The vulnerability exists in the health checker's design assumption that receiving a Ping from a peer indicates health. While this may indicate the peer can send requests, it doesn't verify they can **respond** to requests, which is what outbound health checks measure. The two should be tracked independently to prevent manipulation.

### Citations

**File:** network/framework/src/protocols/health_checker/mod.rs (L5-18)
```rust
//!
//! The HealthChecker is responsible for ensuring liveness of all peers of a node.
//! It does so by periodically selecting a random connected peer and sending a Ping probe. A
//! healthy peer is expected to respond with a corresponding Pong message.
//!
//! If a certain number of successive liveness probes for a peer fail, the HealthChecker initiates a
//! disconnect from the peer. It relies on ConnectivityManager or the remote peer to re-establish
//! the connection.
//!
//! Future Work
//! -----------
//! We can make a few other improvements to the health checker. These are:
//! - Make the policy for interpreting ping failures pluggable
//! - Use successful inbound pings as a sign of remote note being healthy
```

**File:** network/framework/src/protocols/health_checker/mod.rs (L277-306)
```rust
    fn handle_ping_request(
        &mut self,
        peer_id: PeerId,
        ping: Ping,
        protocol: ProtocolId,
        res_tx: oneshot::Sender<Result<Bytes, RpcError>>,
    ) {
        let message = match protocol.to_bytes(&HealthCheckerMsg::Pong(Pong(ping.0))) {
            Ok(msg) => msg,
            Err(e) => {
                warn!(
                    NetworkSchema::new(&self.network_context),
                    error = ?e,
                    "{} Unable to serialize pong response: {}", self.network_context, e
                );
                return;
            },
        };
        trace!(
            NetworkSchema::new(&self.network_context).remote_peer(&peer_id),
            "{} Sending Pong response to peer: {} with nonce: {}",
            self.network_context,
            peer_id.short_str(),
            ping.0,
        );
        // Record Ingress HC here and reset failures.
        self.network_interface.reset_peer_failures(peer_id);

        let _ = res_tx.send(Ok(message.into()));
    }
```

**File:** network/framework/src/protocols/health_checker/interface.rs (L118-124)
```rust
    /// Resets the number of peer failures for the given peer.
    /// If the peer is not found, nothing is done.
    pub fn reset_peer_failures(&mut self, peer_id: PeerId) {
        if let Some(health_check_data) = self.health_check_data.write().get_mut(&peer_id) {
            health_check_data.failures = 0;
        }
    }
```
