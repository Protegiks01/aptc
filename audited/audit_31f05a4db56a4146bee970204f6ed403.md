# Audit Report

## Title
Resource Exhaustion via Unknown Peer Connection Flooding on Public Network

## Summary
Public-facing Aptos nodes (VFNs/PFNs) accept inbound connections from unauthenticated peers (`PeerRole::Unknown`) and allow them to send transaction broadcasts and state sync requests. While connection limits and rate limiting exist, the implementation has performance weaknesses that enable resource exhaustion attacks.

## Finding Description

The Aptos network architecture allows `NetworkId::Public` to accept `PeerRole::Unknown` in its downstream roles [1](#0-0) . During the Noise handshake, peers not in the trusted peer set on the public network are assigned `PeerRole::Unknown` after basic validation [2](#0-1) .

Once connected, unknown peers can send mempool transaction broadcasts without role-based filtering [3](#0-2)  and state sync requests [4](#0-3) .

The peer manager enforces a connection limit (default 100) for unknown inbound peers [5](#0-4) . However, the counting operation iterates through all active peers on every new connection attempt, creating an O(n) performance bottleneck explicitly acknowledged in a TODO comment: "TODO: Keep track of somewhere else to not take this hit in case of DDoS" [6](#0-5) .

For state sync, invalid requests trigger peer ignoring after 500 invalid requests (default) for 5 minutes [7](#0-6) . However, connections are not terminated, with another TODO noting: "TODO: at some point we'll want to terminate the connection entirely" [8](#0-7) .

## Impact Explanation

**Network-level DoS attacks are explicitly out of scope per Aptos bug bounty rules.** While this finding demonstrates a resource exhaustion vector, it falls under the excluded category of network-level attacks and does not meet the severity criteria for:

- **Critical**: No consensus violations, funds loss, or network partition
- **High**: Limited to public-facing nodes (VFNs/PFNs), not core validators
- **Medium**: No direct funds loss or state inconsistencies

The mitigating controls include:
- Default inbound connection limit of 100 [9](#0-8) 
- IP-based rate limiting at 100 KiB/s [10](#0-9) 
- State sync request moderation with exponential backoff [11](#0-10) 

## Likelihood Explanation

The attack is easily executable: any attacker can connect up to 100 unknown peers to public-facing nodes using multiple IP addresses. However, the real-world impact is limited by existing protections and the exclusion of public-facing nodes from consensus participation.

## Recommendation

While out of scope for the bug bounty, the TODO comments indicate this is a known limitation. Recommended improvements:

1. Maintain a separate counter for unknown inbound connections instead of O(n) iteration
2. Implement stricter per-peer message rate limiting beyond IP-based throttling
3. Terminate connections from peers exceeding invalid request thresholds
4. Consider mutual authentication requirements for the public network

## Proof of Concept

This is a network-level resource exhaustion attack. Reproduction would involve:
1. Establishing 100+ connections from different IPs to a public-facing VFN/PFN
2. Sending transaction broadcasts or state sync requests at maximum allowed rate
3. Observing O(n) performance degradation during new connection attempts

However, **this finding does not qualify for the bug bounty program as network-level DoS attacks are explicitly excluded from scope.**

---

**Notes**

This investigation reveals a design trade-off rather than a critical security vulnerability. The Aptos team is aware of these limitations (evidenced by TODO comments) and has implemented multiple layers of defense-in-depth. The public network is intentionally permissive to allow decentralized access while protecting core consensus validators through network segregation.

The architecture correctly isolates validators on the `NetworkId::Validator` network with mutual authentication [12](#0-11) , ensuring consensus safety is not compromised by unknown peers on the public network.

### Citations

**File:** config/src/network_id.rs (L173-186)
```rust
    pub fn upstream_roles(&self, role: &RoleType) -> &'static [PeerRole] {
        match self {
            NetworkId::Validator => &[PeerRole::Validator],
            NetworkId::Public => &[
                PeerRole::PreferredUpstream,
                PeerRole::Upstream,
                PeerRole::ValidatorFullNode,
            ],
            NetworkId::Vfn => match role {
                RoleType::Validator => &[],
                RoleType::FullNode => &[PeerRole::Validator],
            },
        }
    }
```

**File:** config/src/network_id.rs (L189-204)
```rust
    pub fn downstream_roles(&self, role: &RoleType) -> &'static [PeerRole] {
        match self {
            NetworkId::Validator => &[PeerRole::Validator],
            // In order to allow fallbacks, we must allow for nodes to accept ValidatorFullNodes
            NetworkId::Public => &[
                PeerRole::ValidatorFullNode,
                PeerRole::Downstream,
                PeerRole::Known,
                PeerRole::Unknown,
            ],
            NetworkId::Vfn => match role {
                RoleType::Validator => &[PeerRole::ValidatorFullNode],
                RoleType::FullNode => &[],
            },
        }
    }
```

**File:** network/framework/src/noise/handshake.rs (L384-426)
```rust
            HandshakeAuthMode::MaybeMutual(peers_and_metadata) => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => {
                        // The peer is not in the trusted peer set. Verify that the Peer ID is
                        // constructed correctly from the public key.
                        let derived_remote_peer_id =
                            aptos_types::account_address::from_identity_public_key(
                                remote_public_key,
                            );
                        if derived_remote_peer_id != remote_peer_id {
                            // The peer ID is not constructed correctly from the public key
                            Err(NoiseHandshakeError::ClientPeerIdMismatch(
                                remote_peer_short,
                                remote_peer_id,
                                derived_remote_peer_id,
                            ))
                        } else {
                            // Try to infer the role from the network context
                            if self.network_context.role().is_validator() {
                                if network_id.is_vfn_network() {
                                    // Inbound connections to validators on the VFN network must be VFNs
                                    Ok(PeerRole::ValidatorFullNode)
                                } else {
                                    // Otherwise, they're unknown. Validators will connect through
                                    // authenticated channels (on the validator network) so shouldn't hit
                                    // this, and PFNs will connect on public networks (which aren't common).
                                    Ok(PeerRole::Unknown)
                                }
                            } else {
                                // We're a VFN or PFN. VFNs get no inbound connections on the vfn network
                                // (so the peer won't be a validator). Thus, we're on the public network
                                // so mark the peer as unknown.
                                Ok(PeerRole::Unknown)
                            }
                        }
                    },
                }
            },
```

**File:** mempool/src/shared_mempool/coordinator.rs (L356-390)
```rust
    match event {
        Event::Message(peer_id, msg) => {
            counters::shared_mempool_event_inc("message");
            match msg {
                MempoolSyncMsg::BroadcastTransactionsRequest {
                    message_id,
                    transactions,
                } => {
                    process_received_txns(
                        bounded_executor,
                        smp,
                        network_id,
                        message_id,
                        transactions.into_iter().map(|t| (t, None, None)).collect(),
                        peer_id,
                    )
                    .await;
                },
                MempoolSyncMsg::BroadcastTransactionsRequestWithReadyTime {
                    message_id,
                    transactions,
                } => {
                    process_received_txns(
                        bounded_executor,
                        smp,
                        network_id,
                        message_id,
                        transactions
                            .into_iter()
                            .map(|t| (t.0, Some(t.1), Some(t.2)))
                            .collect(),
                        peer_id,
                    )
                    .await;
                },
```

**File:** state-sync/storage-service/server/src/moderator.rs (L48-69)
```rust
    /// the peer to be ignored if it has sent too many invalid requests.
    /// Note: we only ignore peers on the public network.
    pub fn increment_invalid_request_count(&mut self, peer_network_id: &PeerNetworkId) {
        // Increment the invalid request count
        self.invalid_request_count += 1;

        // If the peer is a PFN and has sent too many invalid requests, start ignoring it
        if self.ignore_start_time.is_none()
            && peer_network_id.network_id().is_public_network()
            && self.invalid_request_count >= self.max_invalid_requests
        {
            // TODO: at some point we'll want to terminate the connection entirely

            // Start ignoring the peer
            self.ignore_start_time = Some(self.time_service.now());

            // Log the fact that we're now ignoring the peer
            warn!(LogSchema::new(LogEntry::RequestModeratorIgnoredPeer)
                .peer_network_id(peer_network_id)
                .message("Ignoring peer due to too many invalid requests!"));
        }
    }
```

**File:** state-sync/storage-service/server/src/moderator.rs (L76-98)
```rust
    /// Refreshes the peer's state (if it has been ignored for long enough).
    /// Note: each time we unblock a peer, we double the min time to ignore the peer.
    /// This provides an exponential backoff for peers that are sending too many invalid requests.
    pub fn refresh_peer_state(&mut self, peer_network_id: &PeerNetworkId) {
        if let Some(ignore_start_time) = self.ignore_start_time {
            let ignored_duration = self.time_service.now().duration_since(ignore_start_time);
            if ignored_duration >= Duration::from_secs(self.min_time_to_ignore_secs) {
                // Reset the invalid request count
                self.invalid_request_count = 0;

                // Reset the ignore start time
                self.ignore_start_time = None;

                // Double the min time to ignore the peer
                self.min_time_to_ignore_secs *= 2;

                // Log the fact that we're no longer ignoring the peer
                warn!(LogSchema::new(LogEntry::RequestModeratorIgnoredPeer)
                    .peer_network_id(peer_network_id)
                    .message("No longer ignoring peer! Enough time has elapsed."));
            }
        }
    }
```

**File:** network/framework/src/peer_manager/mod.rs (L352-390)
```rust
        if conn.metadata.origin == ConnectionOrigin::Inbound {
            // Everything below here is meant for unknown peers only. The role comes from
            // the Noise handshake and if it's not `Unknown` then it is trusted.
            if conn.metadata.role == PeerRole::Unknown {
                // TODO: Keep track of somewhere else to not take this hit in case of DDoS
                // Count unknown inbound connections
                let unknown_inbound_conns = self
                    .active_peers
                    .iter()
                    .filter(|(peer_id, (metadata, _))| {
                        metadata.origin == ConnectionOrigin::Inbound
                            && trusted_peers
                                .get(peer_id)
                                .is_none_or(|peer| peer.role == PeerRole::Unknown)
                    })
                    .count();

                // Reject excessive inbound connections made by unknown peers
                // We control outbound connections with Connectivity manager before we even send them
                // and we must allow connections that already exist to pass through tie breaking.
                if !self
                    .active_peers
                    .contains_key(&conn.metadata.remote_peer_id)
                    && unknown_inbound_conns + 1 > self.inbound_connection_limit
                {
                    info!(
                        NetworkSchema::new(&self.network_context)
                            .connection_metadata_with_address(&conn.metadata),
                        "{} Connection rejected due to connection limit: {}",
                        self.network_context,
                        conn.metadata
                    );
                    counters::connections_rejected(&self.network_context, conn.metadata.origin)
                        .inc();
                    self.disconnect(conn);
                    return;
                }
            }
        }
```

**File:** config/src/config/state_sync_config.rs (L201-213)
```rust
            max_invalid_requests_per_peer: 500,
            max_lru_cache_size: 500, // At ~0.6MiB per chunk, this should take no more than 0.5GiB
            max_network_channel_size: 4000,
            max_network_chunk_bytes: SERVER_MAX_MESSAGE_SIZE as u64,
            max_network_chunk_bytes_v2: SERVER_MAX_MESSAGE_SIZE_V2 as u64,
            max_num_active_subscriptions: 30,
            max_optimistic_fetch_period_ms: 5000, // 5 seconds
            max_state_chunk_size: MAX_STATE_CHUNK_SIZE,
            max_storage_read_wait_time_ms: 10_000, // 10 seconds
            max_subscription_period_ms: 30_000,    // 30 seconds
            max_transaction_chunk_size: MAX_TRANSACTION_CHUNK_SIZE,
            max_transaction_output_chunk_size: MAX_TRANSACTION_OUTPUT_CHUNK_SIZE,
            min_time_to_ignore_peers_secs: 300, // 5 minutes
```

**File:** config/src/config/network_config.rs (L44-44)
```rust
pub const MAX_INBOUND_CONNECTIONS: usize = 100;
```

**File:** config/src/config/network_config.rs (L52-53)
```rust
pub const IP_BYTE_BUCKET_RATE: usize = 102400 /* 100 KiB */;
pub const IP_BYTE_BUCKET_SIZE: usize = IP_BYTE_BUCKET_RATE;
```
