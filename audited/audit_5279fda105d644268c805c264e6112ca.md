# Audit Report

## Title
Missing SafetyData Invariant Validation Could Allow Consensus Safety Violations Through State Inconsistencies

## Summary
The `SafetyData` structure in the consensus safety-rules lacks invariant validation when loaded from persistent storage. Specifically, there is no enforcement that `one_chain_round >= preferred_round`, which should always hold in valid consensus states. This missing validation, combined with the absence of preferred_round checking during voting (only checked during proposal signing), could theoretically allow validators with corrupted state to vote on conflicting chains, violating AptosBFT safety properties.

## Finding Description

The `ConsensusState` struct wraps `SafetyData`, which tracks critical consensus safety state including:
- `epoch`: Current epoch
- `last_voted_round`: Last round voted on  
- `preferred_round`: Highest 2-chain round (parent of certified blocks)
- `one_chain_round`: Highest 1-chain round (certified blocks) [1](#0-0) 

The fundamental invariant that should hold is: **`one_chain_round >= preferred_round`**

This invariant exists because in any valid QuorumCert, the parent block's round must be strictly less than the certified block's round, as enforced by `VoteData::verify()`: [2](#0-1) 

However, **there is NO validation** when `SafetyData` is loaded from storage: [3](#0-2) 

The `SafetyData` constructor also has no invariant checks: [4](#0-3) 

This is confirmed by test code that creates inconsistent states without error: [5](#0-4) 

The test creates `SafetyData` with `one_chain_round=0` and `preferred_round=1`, violating the invariant.

**Critical Missing Safety Check:**

The `verify_and_update_preferred_round` function checks that incoming proposals respect the preferred_round: [6](#0-5) 

However, this check is **only called in `guarded_sign_proposal`** (when a validator proposes a block), **NOT in `guarded_construct_and_sign_vote_two_chain`** (when voting): [7](#0-6) 

When voting, only `safe_to_vote` and `verify_and_update_last_vote_round` are checked. The `observe_qc` function updates both `one_chain_round` and `preferred_round` independently without validation: [8](#0-7) 

## Impact Explanation

**Severity: High to Critical (Borderline)**

While this represents a significant consensus safety concern, the actual exploitability is limited:

**Potential Impact:**
- **Consensus Safety Violation**: A validator with corrupted state (e.g., `preferred_round > one_chain_round`) could vote on proposals that conflict with chains it should recognize as committed, potentially enabling double-commits under specific network conditions
- **State Inconsistency**: No runtime detection or recovery mechanism exists for inconsistent safety state
- **Liveness Degradation**: Validators with corrupted state may reject valid proposals or accept invalid ones inconsistently

**Why Not Clearly Critical:**
The attack requires either:
1. Filesystem/storage access to validator node (insider threat or node compromise)
2. A serialization/deserialization bug that produces inconsistent state
3. A state migration error during upgrades

An **unprivileged external attacker cannot directly cause** this state corruption without first compromising the validator node, which puts it at the boundary of the threat model.

## Likelihood Explanation

**Likelihood: Medium-Low**

**Factors Increasing Likelihood:**
- State persists across restarts, so corruption could remain undetected
- No automated invariant checks or alerts
- Serde deserialization accepts any structurally-valid data
- Complex state migrations during protocol upgrades could introduce bugs

**Factors Decreasing Likelihood:**
- Requires storage corruption or implementation bug, not direct network exploit
- Validator operators would need compromised or buggy storage backends
- Modern filesystems and databases provide integrity guarantees

**Most Realistic Scenario:**
A bug in state migration logic during a protocol upgrade causes some validators to load inconsistent `SafetyData`, which then persists and affects consensus voting behavior without detection.

## Recommendation

**Implement Invariant Validation:**

1. **Add invariant validation to SafetyData constructor and setters:**

```rust
impl SafetyData {
    pub fn new(
        epoch: u64,
        last_voted_round: u64,
        preferred_round: u64,
        one_chain_round: u64,
        last_vote: Option<Vote>,
        highest_timeout_round: u64,
    ) -> Result<Self, Error> {
        // Validate invariants
        if one_chain_round < preferred_round {
            return Err(Error::InvalidSafetyData(format!(
                "Invariant violation: one_chain_round ({}) < preferred_round ({})",
                one_chain_round, preferred_round
            )));
        }
        
        Ok(Self {
            epoch,
            last_voted_round,
            preferred_round,
            one_chain_round,
            last_vote,
            highest_timeout_round,
        })
    }
}
```

2. **Validate when loading from storage:**

```rust
pub fn safety_data(&mut self) -> Result<SafetyData, Error> {
    let safety_data = if !self.enable_cached_safety_data {
        let _timer = counters::start_timer("get", SAFETY_DATA);
        self.internal_store.get(SAFETY_DATA).map(|v| v.value)?
    } else {
        // ... existing cache logic
    };
    
    // Validate invariants
    safety_data.validate_invariants()?;
    Ok(safety_data)
}
```

3. **Add runtime assertion in observe_qc:**

```rust
pub(crate) fn observe_qc(&self, qc: &QuorumCert, safety_data: &mut SafetyData) -> bool {
    let mut updated = false;
    let one_chain = qc.certified_block().round();
    let two_chain = qc.parent_block().round();
    
    // This should always hold for valid QCs
    assert!(one_chain >= two_chain, "QC invariant violated");
    
    // ... existing update logic
    
    // Validate state invariants after update
    assert!(safety_data.one_chain_round >= safety_data.preferred_round,
            "SafetyData invariant violated after observe_qc");
    updated
}
```

## Proof of Concept

```rust
#[test]
fn test_safety_data_invariant_violation() {
    use aptos_consensus_types::safety_data::SafetyData;
    use aptos_secure_storage::InMemoryStorage;
    use aptos_types::validator_signer::ValidatorSigner;
    
    // Create inconsistent SafetyData (currently allowed!)
    let inconsistent_data = SafetyData::new(
        10,   // epoch
        100,  // last_voted_round
        200,  // preferred_round (HIGH)
        50,   // one_chain_round (LOW) - VIOLATES INVARIANT!
        None,
        0
    );
    
    // This should fail but currently succeeds
    assert!(inconsistent_data.one_chain_round < inconsistent_data.preferred_round);
    
    // Create storage and persist the inconsistent state
    let storage = Storage::from(InMemoryStorage::new());
    let consensus_private_key = ValidatorSigner::from_int(0).private_key().clone();
    let mut safety_storage = PersistentSafetyStorage::initialize(
        storage,
        Author::random(),
        consensus_private_key,
        Waypoint::default(),
        true,
    );
    
    // This should fail validation but currently succeeds
    safety_storage.set_safety_data(inconsistent_data).unwrap();
    
    // Load it back - no validation occurs
    let loaded_data = safety_storage.safety_data().unwrap();
    assert!(loaded_data.one_chain_round < loaded_data.preferred_round);
    
    // Validator would now operate with inconsistent state
    println!("Successfully persisted and loaded inconsistent SafetyData!");
}
```

**Notes:**

After extensive analysis, this issue represents a **defensive programming gap** rather than a clearly exploitable vulnerability by unprivileged attackers. The missing invariant validation is concerning for system robustness, especially during state migrations or in the presence of storage bugs, but constructing a realistic attack where an external attacker exploits this to violate consensus safety requires additional vulnerabilities (storage access or serialization bugs). The severity lies between High and Critical depending on risk tolerance for state corruption scenarios.

### Citations

**File:** consensus/consensus-types/src/safety_data.rs (L10-21)
```rust
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```

**File:** consensus/consensus-types/src/safety_data.rs (L24-40)
```rust
    pub fn new(
        epoch: u64,
        last_voted_round: u64,
        preferred_round: u64,
        one_chain_round: u64,
        last_vote: Option<Vote>,
        highest_timeout_round: u64,
    ) -> Self {
        Self {
            epoch,
            last_voted_round,
            preferred_round,
            one_chain_round,
            last_vote,
            highest_timeout_round,
        }
    }
```

**File:** consensus/consensus-types/src/vote_data.rs (L64-67)
```rust
        anyhow::ensure!(
            self.parent.round() < self.proposed.round(),
            "Proposed round is less than parent round",
        );
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L134-148)
```rust
    pub fn safety_data(&mut self) -> Result<SafetyData, Error> {
        if !self.enable_cached_safety_data {
            let _timer = counters::start_timer("get", SAFETY_DATA);
            return self.internal_store.get(SAFETY_DATA).map(|v| v.value)?;
        }

        if let Some(cached_safety_data) = self.cached_safety_data.clone() {
            Ok(cached_safety_data)
        } else {
            let _timer = counters::start_timer("get", SAFETY_DATA);
            let safety_data: SafetyData = self.internal_store.get(SAFETY_DATA).map(|v| v.value)?;
            self.cached_safety_data = Some(safety_data.clone());
            Ok(safety_data)
        }
    }
```

**File:** consensus/safety-rules/src/persistent_safety_storage.rs (L233-235)
```rust
        safety_storage
            .set_safety_data(SafetyData::new(9, 8, 1, 0, None, 0))
            .unwrap();
```

**File:** consensus/safety-rules/src/safety_rules.rs (L135-156)
```rust
    pub(crate) fn observe_qc(&self, qc: &QuorumCert, safety_data: &mut SafetyData) -> bool {
        let mut updated = false;
        let one_chain = qc.certified_block().round();
        let two_chain = qc.parent_block().round();
        if one_chain > safety_data.one_chain_round {
            safety_data.one_chain_round = one_chain;
            trace!(
                SafetyLogSchema::new(LogEntry::OneChainRound, LogEvent::Update)
                    .preferred_round(safety_data.one_chain_round)
            );
            updated = true;
        }
        if two_chain > safety_data.preferred_round {
            safety_data.preferred_round = two_chain;
            trace!(
                SafetyLogSchema::new(LogEntry::PreferredRound, LogEvent::Update)
                    .preferred_round(safety_data.preferred_round)
            );
            updated = true;
        }
        updated
    }
```

**File:** consensus/safety-rules/src/safety_rules.rs (L173-188)
```rust
    fn verify_and_update_preferred_round(
        &mut self,
        quorum_cert: &QuorumCert,
        safety_data: &mut SafetyData,
    ) -> Result<bool, Error> {
        let preferred_round = safety_data.preferred_round;
        let one_chain_round = quorum_cert.certified_block().round();

        if one_chain_round < preferred_round {
            return Err(Error::IncorrectPreferredRound(
                one_chain_round,
                preferred_round,
            ));
        }
        Ok(self.observe_qc(quorum_cert, safety_data))
    }
```

**File:** consensus/safety-rules/src/safety_rules_2chain.rs (L53-95)
```rust
    pub(crate) fn guarded_construct_and_sign_vote_two_chain(
        &mut self,
        vote_proposal: &VoteProposal,
        timeout_cert: Option<&TwoChainTimeoutCertificate>,
    ) -> Result<Vote, Error> {
        // Exit early if we cannot sign
        self.signer()?;

        let vote_data = self.verify_proposal(vote_proposal)?;
        if let Some(tc) = timeout_cert {
            self.verify_tc(tc)?;
        }
        let proposed_block = vote_proposal.block();
        let mut safety_data = self.persistent_storage.safety_data()?;

        // if already voted on this round, send back the previous vote
        // note: this needs to happen after verifying the epoch as we just check the round here
        if let Some(vote) = safety_data.last_vote.clone() {
            if vote.vote_data().proposed().round() == proposed_block.round() {
                return Ok(vote);
            }
        }

        // Two voting rules
        self.verify_and_update_last_vote_round(
            proposed_block.block_data().round(),
            &mut safety_data,
        )?;
        self.safe_to_vote(proposed_block, timeout_cert)?;

        // Record 1-chain data
        self.observe_qc(proposed_block.quorum_cert(), &mut safety_data);
        // Construct and sign vote
        let author = self.signer()?.author();
        let ledger_info = self.construct_ledger_info_2chain(proposed_block, vote_data.hash())?;
        let signature = self.sign(&ledger_info)?;
        let vote = Vote::new_with_signature(vote_data, author, ledger_info, signature);

        safety_data.last_vote = Some(vote.clone());
        self.persistent_storage.set_safety_data(safety_data)?;

        Ok(vote)
    }
```
