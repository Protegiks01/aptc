# Audit Report

## Title
Feature Flag Mismatch During Transaction Replay Causes code_invariant_error() and Replay Failures

## Summary
When replaying historical transactions using the replay-benchmark tool with feature flag overrides, transactions that were originally executed with `AGGREGATOR_V2_DELAYED_FIELDS` disabled can trigger `code_invariant_error()` if replayed with the feature enabled (or vice versa). This causes the replay tool to panic instead of gracefully handling the incompatibility, breaking testing and benchmarking infrastructure.

## Finding Description

The vulnerability stems from a fundamental mismatch between how the VM reads feature flags and how aggregator v2 operations store values:

**Root Cause 1: VM reads current feature flags, not historical ones**

The `Environment::new()` function fetches feature flags from the current state view, not from the historical state at the time of transaction execution: [1](#0-0) 

**Root Cause 2: Replay-benchmark allows feature flag overrides**

The replay-benchmark tool explicitly allows developers to override feature flags when replaying historical transactions: [2](#0-1) 

**Root Cause 3: Aggregator operations produce incompatible value types**

When `AGGREGATOR_V2_DELAYED_FIELDS` is enabled vs disabled, the native `create_aggregator` function produces completely different value types: [3](#0-2) 

With the feature enabled, it creates a `Value::delayed_value(id)` (DelayedFieldID). With the feature disabled, it creates a regular u128/u64 value.

**Attack Path:**

1. A transaction at version V=1000 executes with `AGGREGATOR_V2_DELAYED_FIELDS` disabled, storing regular u128 values in aggregator structs
2. Developer runs replay-benchmark with `--enable-features AGGREGATOR_V2_DELAYED_FIELDS` to test the feature's impact
3. During replay, the VM enables delayed field optimization based on the overridden flag: [4](#0-3) 

4. When aggregator operations execute, they expect DelayedFieldID values but encounter u128 values from the historical transaction
5. The `validate_delayed_field_id()` function detects an invalid ID and returns `code_invariant_error()`: [5](#0-4) 

6. This error propagates up to `execute_workload()` which panics instead of handling the error gracefully: [6](#0-5) 

This breaks the replay tool with a panic, preventing developers from testing how feature flag changes would affect historical workloads.

## Impact Explanation

**Severity: Medium** - State inconsistencies requiring intervention ($10,000 tier per Aptos bug bounty)

While this doesn't affect production consensus or cause fund loss, it represents a significant infrastructure reliability issue:

1. **Testing Infrastructure Failure**: The replay-benchmark tool is critical for validating that feature flag changes don't break historical transaction execution. This vulnerability makes that testing unreliable.

2. **Operational Impact**: When developers need to test new optimizations (like delayed fields) against historical workloads, they cannot do so if those transactions used aggregators, significantly limiting the tool's utility.

3. **Breaks Deterministic Execution Invariant**: The same transaction produces different execution results (success vs code_invariant_error) based solely on feature flag configuration, violating the expectation that historical transactions should be replayable.

4. **Ungraceful Failure**: Rather than reporting the incompatibility clearly, the tool panics, making debugging difficult.

## Likelihood Explanation

**Likelihood: Medium-High**

This issue is likely to occur in practice because:

1. **Documented Feature**: The README explicitly encourages using feature flag overrides to test performance: [7](#0-6) 

2. **Common Testing Pattern**: Testing aggregator v2 performance with delayed fields is a natural use case for the replay-benchmark tool

3. **No Warning or Validation**: The tool provides no warning that certain feature flag overrides may be incompatible with historical transactions

4. **Aggregator V2 Usage**: As aggregator v2 adoption increases on mainnet, more historical transactions will be affected

## Recommendation

Implement version-aware replay with feature flag validation:

**Option 1: Store Feature Flag State with Transactions**
Persist the feature flags that were active during original execution and enforce they match during replay (or at minimum, warn users).

**Option 2: Add Graceful Error Handling**
Modify `execute_workload()` to catch `code_invariant_error()` and provide clear error messages:

```rust
.unwrap_or_else(|err| {
    if let Some(status) = err.status_code() {
        if status == StatusCode::DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR {
            eprintln!("Error: Transaction replay failed due to feature flag mismatch.");
            eprintln!("This transaction may have been executed with different AGGREGATOR_V2_DELAYED_FIELDS settings.");
            eprintln!("Consider replaying without feature flag overrides or using --txns-to-skip.");
        }
    }
    panic!("Block execution failed: {:?}", err)
})
```

**Option 3: Add Pre-Flight Validation**
Before replay, check if overridden feature flags are compatible with the transaction version range being replayed.

## Proof of Concept

```bash
# Step 1: Download transactions that used aggregator v2 before delayed fields were enabled
aptos-replay-benchmark download \
  --begin-version <VERSION_BEFORE_DELAYED_FIELDS> \
  --end-version <VERSION_BEFORE_DELAYED_FIELDS + 100> \
  --rest-endpoint https://api.mainnet.aptoslabs.com/v1 \
  --transactions-file historical-agg-txns.file

# Step 2: Initialize baseline state (without override)
aptos-replay-benchmark initialize \
  --rest-endpoint https://api.mainnet.aptoslabs.com/v1 \
  --transactions-file historical-agg-txns.file \
  --inputs-file baseline-state.file

# Step 3: Try to replay with AGGREGATOR_V2_DELAYED_FIELDS enabled
# This will trigger code_invariant_error and panic
aptos-replay-benchmark benchmark \
  --transactions-file historical-agg-txns.file \
  --inputs-file baseline-state.file \
  --enable-features AGGREGATOR_V2_DELAYED_FIELDS RESOURCE_GROUPS_SPLIT_IN_VM_CHANGE_SET \
  --concurrency-levels 1

# Expected result: Panic with DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR
# instead of graceful error reporting
```

The panic will occur because:
1. Historical aggregator values are stored as u128
2. Replay with delayed fields enabled expects DelayedFieldID
3. Invalid ID validation triggers code_invariant_error()
4. execute_workload() panics on any execution error

## Notes

The issue is specifically triggered by the combination of:
- Feature flag override capability ( [8](#0-7) )
- Environment reading current flags ( [1](#0-0) )
- Type-incompatible value storage ( [3](#0-2) )
- Panic on error ( [6](#0-5) )

The error code used is specifically designed for delayed field invariant violations: [9](#0-8)

### Citations

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L219-220)
```rust
        let features =
            fetch_config_and_update_hash::<Features>(&mut sha3_256, state_view).unwrap_or_default();
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L320-323)
```rust
    fn try_enable_delayed_field_optimization(mut self) -> Self {
        if self.features.is_aggregator_v2_delayed_fields_enabled() {
            self.runtime_environment.enable_delayed_field_optimization();
        }
```

**File:** aptos-move/replay-benchmark/src/overrides.rs (L98-110)
```rust
            let (features_state_key, features_state_value) =
                config_override::<Features, _>(state_view, |features| {
                    for feature in &self.additional_enabled_features {
                        if features.is_enabled(*feature) {
                            error!("Feature {:?} is already enabled", feature);
                        }
                        features.enable(*feature);
                    }
                    for feature in &self.additional_disabled_features {
                        if !features.is_enabled(*feature) {
                            error!("Feature {:?} is already disabled", feature);
                        }
                        features.disable(*feature);
```

**File:** aptos-move/framework/src/natives/aggregator_natives/aggregator_v2.rs (L118-125)
```rust
    let value = if let Some((resolver, mut delayed_field_data)) = get_context_data(context) {
        let width = get_width_by_type(aggregator_value_ty, EUNSUPPORTED_AGGREGATOR_TYPE)?;
        let id = resolver.generate_delayed_field_id(width);
        delayed_field_data.create_new_aggregator(id);
        Value::delayed_value(id)
    } else {
        create_value_by_type(aggregator_value_ty, 0, EUNSUPPORTED_AGGREGATOR_TYPE)?
    };
```

**File:** aptos-move/block-executor/src/view.rs (L1923-1927)
```rust
        if unique_index < start_counter || unique_index >= current_counter {
            return Err(code_invariant_error(format!(
                "Invalid delayed field id: {:?} with index: {} (started from {} and reached {})",
                id, unique_index, start_counter, current_counter
            )));
```

**File:** aptos-move/replay-benchmark/src/execution.rs (L42-46)
```rust
        .unwrap_or_else(|err| {
            panic!(
                "Block execution should not fail, but returned an error: {:?}",
                err
            )
```

**File:** aptos-move/replay-benchmark/README.md (L107-110)
```markdown
Overriding the state can be very useful if you want to experiment with a new feature or Move code,
and check its performance as well as the gas usage. For example, if there is a new feature that
makes MoveVM faster, overriding it for past transactions it is possible to see the execution performance
on historical workloads.
```

**File:** third_party/move/move-core/types/src/vm_status.rs (L866-866)
```rust
    DELAYED_FIELD_OR_BLOCKSTM_CODE_INVARIANT_ERROR = 2023,
```
