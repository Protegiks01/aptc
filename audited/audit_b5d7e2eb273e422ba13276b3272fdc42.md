# Audit Report

## Title
Insufficient Validation of TimedFeatures Determinism Could Enable Consensus Fork via Dependency Version Mismatch

## Summary
The `TimedFeaturesBuilder::is_enabled()` function relies on `chrono_tz` timezone conversions to compute feature activation times, but the computed `TimedFeatures` state is not included in the environment hash used to detect configuration mismatches between validators. If validators run with different `chrono_tz` versions or builds, they could compute different activation times, leading to divergent execution and consensus failure.

## Finding Description

The `is_enabled()` function compares block timestamps against activation times computed using timezone conversions: [1](#0-0) 

The activation times are computed using Los Angeles timezone from `chrono_tz`: [2](#0-1) 

The `chrono_tz` crate embeds the IANA timezone database at compile time. If validators build with different versions or at different times with updated timezone data, they could theoretically compute different UTC timestamps for the same Los Angeles local time.

**Critical Issue**: The `Environment` hash does NOT include the computed `TimedFeatures`: [3](#0-2) 

The environment hash includes inputs (ChainId, timestamp_micros, override profile) but not the resulting `TimedFeatures` array. Two validators with identical inputs but different `chrono_tz` builds would have identical hashes but different timed feature states.

**Consensus Impact**: `TimedFeatures` affects gas charging and native function behavior: [4](#0-3) [5](#0-4) 

If validators disagree on whether `FixMemoryUsageTracking` or `FixTableNativesMemoryDoubleCounting` is enabled, they will charge different gas amounts for the same operations, causing identical transactions to succeed on some validators but fail (out of gas) on others, resulting in different state roots.

## Impact Explanation

**Severity: Critical** - This breaks the "Deterministic Execution" invariant. If triggered, it causes:
- Validators compute different state roots for identical blocks
- Consensus cannot reach 2/3+ quorum on any state root
- **Network liveness failure** requiring emergency intervention or hard fork
- Affects ALL validators network-wide

This meets the Critical severity criteria: "Consensus/Safety violations" and "Non-recoverable network partition (requires hardfork)."

## Likelihood Explanation

**Likelihood: Very Low** in properly managed deployments because:
- `Cargo.lock` pins `chrono-tz` to version 0.10.1
- Validators should build from identical source with identical lock file
- Tests validate expected timestamp values
- IANA timezone data for 2024-2025 is stable

**However**, likelihood increases if:
- Validators don't strictly enforce using the same `Cargo.lock`
- A validator rebuilds from source without lock file
- Supply chain compromise injects different `chrono_tz` version
- Platform-specific build differences (highly unlikely but possible)

The lack of runtime validation means any such mismatch would go undetected until consensus failure occurs.

## Recommendation

**Add `TimedFeatures` to the environment hash** to enable early detection of mismatches:

```rust
// In Environment::new(), after building timed_features:
let timed_features = timed_features_builder.build();

// Add timed features to hash
let timed_features_bytes = bcs::to_bytes(&timed_features)
    .expect("TimedFeatures should always be serializable");
sha3_256.update(&timed_features_bytes);
```

This requires making `TimedFeatures` derive `Serialize`: [6](#0-5) 

**Additional hardening:**
1. Add genesis validation that hardcodes expected activation timestamp values
2. Log warnings if computed activation times differ from expected hardcoded values
3. Consider moving to on-chain activation times instead of compile-time timezone conversions

## Proof of Concept

This vulnerability cannot be demonstrated with a simple PoC because it requires validators running different software builds. However, the validation gap can be shown:

```rust
#[test]
fn test_timed_features_not_in_environment_hash() {
    use aptos_types::state_store::MockStateView;
    
    // Two environments with same on-chain state
    let state_view = MockStateView::empty();
    let env1 = AptosEnvironment::new(&state_view);
    let env2 = AptosEnvironment::new(&state_view);
    
    // They are considered equal (same hash)
    assert_eq!(env1, env2);
    
    // But if timed_features were different (due to build differences),
    // the hash comparison wouldn't detect it because TimedFeatures
    // is not included in the hash computation
}
```

The actual exploitation requires:
1. Deploy validator A with chrono_tz build X
2. Deploy validator B with chrono_tz build Y (where X ≠ Y affects activation times)
3. Wait for block timestamp to cross a feature activation boundary
4. Observe validators compute different feature states
5. Identical transactions execute with different gas, producing different state roots
6. Network halts (cannot reach consensus)

## Notes

While this represents a **defense-in-depth weakness** rather than an immediately exploitable vulnerability, it violates secure coding principles for distributed consensus systems. The Aptos codebase explicitly documents the importance of deterministic data structures for consensus: [7](#0-6) 

The same principle should apply to all consensus-critical computations. The lack of validation means the system relies entirely on operational discipline and dependency pinning, with no runtime safeguards against version mismatches.

### Citations

**File:** types/src/on_chain_config/timed_features.rs (L72-141)
```rust
    pub fn activation_time_on(&self, chain_id: &NamedChain) -> DateTime<Utc> {
        use NamedChain::*;
        use TimedFeatureFlag::*;

        match (self, chain_id) {
            // Note: These have been enabled since the start due to a bug.
            (_LimitTypeTagSize, TESTNET) => BEGINNING_OF_TIME,
            (_LimitTypeTagSize, MAINNET) => BEGINNING_OF_TIME,

            (_ModuleComplexityCheck, TESTNET) => Los_Angeles
                .with_ymd_and_hms(2024, 6, 25, 16, 0, 0)
                .unwrap()
                .with_timezone(&Utc),
            (_ModuleComplexityCheck, MAINNET) => Los_Angeles
                .with_ymd_and_hms(2024, 7, 3, 12, 0, 0)
                .unwrap()
                .with_timezone(&Utc),

            (EntryCompatibility, TESTNET) => Los_Angeles
                .with_ymd_and_hms(2024, 11, 6, 12, 0, 0)
                .unwrap()
                .with_timezone(&Utc),
            (EntryCompatibility, MAINNET) => Los_Angeles
                .with_ymd_and_hms(2024, 11, 12, 12, 0, 0)
                .unwrap()
                .with_timezone(&Utc),

            // Note: Activation time set to 1 hour after the beginning of time
            //       so we can test the old and new behaviors in tests.
            (FixMemoryUsageTracking, TESTING) => Utc.with_ymd_and_hms(1970, 1, 1, 1, 0, 0).unwrap(),
            (FixMemoryUsageTracking, TESTNET) => Los_Angeles
                .with_ymd_and_hms(2025, 3, 7, 12, 0, 0)
                .unwrap()
                .with_timezone(&Utc),
            (FixMemoryUsageTracking, MAINNET) => Los_Angeles
                .with_ymd_and_hms(2025, 3, 11, 17, 0, 0)
                .unwrap()
                .with_timezone(&Utc),

            (ChargeBytesForPrints, TESTNET) => Los_Angeles
                .with_ymd_and_hms(2025, 3, 7, 12, 0, 0)
                .unwrap()
                .with_timezone(&Utc),
            (ChargeBytesForPrints, MAINNET) => Los_Angeles
                .with_ymd_and_hms(2025, 3, 11, 17, 0, 0)
                .unwrap()
                .with_timezone(&Utc),
            (DisabledCaptureOption, TESTNET) => Los_Angeles
                .with_ymd_and_hms(2025, 9, 15, 12, 0, 0)
                .unwrap()
                .with_timezone(&Utc),
            // For testing, time set to 1 hour after the beginning of time to test the old and new behaviors in tests.
            (DisabledCaptureOption, TESTING) => Utc.with_ymd_and_hms(1970, 1, 1, 1, 0, 0).unwrap(),
            // For mainnet, always enable this feature.
            (DisabledCaptureOption, MAINNET) => BEGINNING_OF_TIME,

            (FixTableNativesMemoryDoubleCounting, TESTNET) => Los_Angeles
                .with_ymd_and_hms(2025, 10, 16, 17, 0, 0)
                .unwrap()
                .with_timezone(&Utc),
            (FixTableNativesMemoryDoubleCounting, MAINNET) => Los_Angeles
                .with_ymd_and_hms(2025, 10, 21, 10, 0, 0)
                .unwrap()
                .with_timezone(&Utc),

            // For chains other than testnet and mainnet, a timed feature is considered enabled from
            // the very beginning, if left unspecified.
            (_, TESTING | DEVNET | PREMAINNET) => BEGINNING_OF_TIME,
        }
    }
```

**File:** types/src/on_chain_config/timed_features.rs (L181-199)
```rust
    fn is_enabled(&self, flag: TimedFeatureFlag) -> bool {
        use TimedFeaturesImpl::*;

        if let Some(override_) = &self.override_ {
            if let Some(enabled) = override_.get_override(flag) {
                return enabled;
            }
        }

        match &self.inner {
            OnNamedChain {
                named_chain,
                timestamp_micros,
            } => {
                *timestamp_micros >= flag.activation_time_on(named_chain).timestamp_micros() as u64
            },
            EnableAll => true,
        }
    }
```

**File:** types/src/on_chain_config/timed_features.rs (L211-218)
```rust
#[derive(Clone, Debug, Serialize, Eq, PartialEq)]
pub struct TimedFeatures([bool; TimedFeatureFlag::COUNT]);

impl TimedFeatures {
    pub fn is_enabled(&self, flag: TimedFeatureFlag) -> bool {
        self.0[flag as usize]
    }
}
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L216-240)
```rust
    ) -> Self {
        // We compute and store a hash of configs in order to distinguish different environments.
        let mut sha3_256 = Sha3_256::new();
        let features =
            fetch_config_and_update_hash::<Features>(&mut sha3_256, state_view).unwrap_or_default();

        // If no chain ID is in storage, we assume we are in a testing environment.
        let chain_id = fetch_config_and_update_hash::<ChainId>(&mut sha3_256, state_view)
            .unwrap_or_else(ChainId::test);
        let timestamp_micros =
            fetch_config_and_update_hash::<ConfigurationResource>(&mut sha3_256, state_view)
                .map(|config| config.last_reconfiguration_time_micros())
                .unwrap_or(0);

        let mut timed_features_builder = TimedFeaturesBuilder::new(chain_id, timestamp_micros);
        if let Some(profile) = get_timed_feature_override() {
            // We need to ensure the override is taken into account for the hash.
            let profile_bytes = bcs::to_bytes(&profile)
                .expect("Timed features override should always be serializable");
            sha3_256.update(&profile_bytes);

            timed_features_builder = timed_features_builder.with_override_profile(profile)
        }
        let timed_features = timed_features_builder.build();

```

**File:** aptos-move/aptos-native-interface/src/context.rs (L205-217)
```rust
    pub fn use_heap_memory(&mut self, amount: u64) -> SafeNativeResult<()> {
        if self.timed_feature_enabled(TimedFeatureFlag::FixMemoryUsageTracking) {
            if self.has_direct_gas_meter_access_in_native_context() {
                self.gas_meter()
                    .use_heap_memory_in_native_context(amount)
                    .map_err(LimitExceededError::from_err)?;
            } else {
                self.legacy_heap_memory_usage =
                    self.legacy_heap_memory_usage.saturating_add(amount);
            }
        }
        Ok(())
    }
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L395-426)
```rust
    let fix_memory_double_counting =
        context.timed_feature_enabled(TimedFeatureFlag::FixTableNativesMemoryDoubleCounting);

    let (extensions, mut loader_context, abs_val_gas_params, gas_feature_version) =
        context.extensions_with_loader_context_and_gas_params();
    let table_context = extensions.get::<NativeTableContext>();
    let mut table_data = table_context.table_data.borrow_mut();

    let val = args.pop_back().unwrap();
    let key = args.pop_back().unwrap();
    let handle = get_table_handle(&safely_pop_arg!(args, StructRef))?;

    let table =
        table_data.get_or_create_table(&mut loader_context, handle, &ty_args[0], &ty_args[2])?;

    let function_value_extension = loader_context.function_value_extension();
    let key_bytes = serialize_key(&function_value_extension, &table.key_layout, &key)?;
    let key_cost = ADD_BOX_PER_BYTE_SERIALIZED * NumBytes::new(key_bytes.len() as u64);

    let (gv, loaded) =
        table.get_or_create_global_value(&function_value_extension, table_context, key_bytes)?;
    let mem_usage = if !fix_memory_double_counting || loaded.is_some() {
        gv.view()
            .map(|val| {
                abs_val_gas_params
                    .abstract_heap_size(&val, gas_feature_version)
                    .map(u64::from)
            })
            .transpose()?
    } else {
        None
    };
```

**File:** RUST_SECURE_CODING.md (L121-133)
```markdown
### Data Structures with Deterministic Internal Order

Certain data structures, like HashMap and HashSet, do not guarantee a deterministic order for the elements stored within them. This lack of order can lead to problems in operations that require processing elements in a consistent sequence across multiple executions. In the Aptos blockchain, deterministic data structures help in achieving consensus, maintaining the integrity of the ledger, and ensuring that computations can be reliably reproduced across different nodes.

Below is a list of deterministic data structures available in Rust. Please note, this list may not be exhaustive:

- **BTreeMap:** maintains its elements in sorted order by their keys.
- **BinaryHeap:** It maintains its elements in a heap order, which is a complete binary tree where each parent node is less than or equal to its child nodes.
- **Vec**: It maintains its elements in the order in which they were inserted. ⚠️
- **LinkedList:** It maintains its elements in the order in which they were inserted. ⚠️
- **VecDeque:** It maintains its elements in the order in which they were inserted. ⚠️

## Cryptography
```
