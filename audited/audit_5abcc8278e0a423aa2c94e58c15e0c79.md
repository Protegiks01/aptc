# Audit Report

## Title
Database Truncation Tool Proceeds on Corrupted Data Without Validation, Potentially Making Recovery Impossible

## Summary
The database truncation tool in `storage/aptosdb/src/db_debugger/truncate/mod.rs` does not validate database consistency before performing destructive truncation operations. The `open_dbs()` function opens databases without detecting corruption or inconsistent state, allowing the truncation tool to proceed on corrupted data and potentially overwrite recovery metadata, making database recovery impossible.

## Finding Description

The `run()` function in the database truncation tool performs the following operations: [1](#0-0) 

The `open_dbs()` function opens all database components (LedgerDb, StateMerkleDb, StateKvDb) without performing any validation of database consistency: [2](#0-1) 

Critically, the `LedgerDb::new()` function contains an explicit TODO comment acknowledging that data inconsistency handling is not implemented: [3](#0-2) 

After opening the databases, the truncation tool reads version metadata using `.expect()` calls that will panic with unhelpful messages if reads fail: [4](#0-3) 

The tool then performs basic assertion checks on version relationships: [5](#0-4) 

If these assertions pass (or panic), the tool writes new metadata and calls `sync_commit_progress`: [6](#0-5) 

**The vulnerability:** If the database is already corrupted with:
1. Metadata that deserializes to structurally valid but semantically invalid version numbers
2. Cross-database inconsistencies not detected by the assertions
3. Corrupted Jellyfish Merkle tree data

The truncation tool will:
1. **Overwrite the original metadata** (line 134) with new `OverallCommitProgress`, destroying potential recovery information
2. **Attempt to truncate all databases** (line 137-142) based on potentially invalid version numbers
3. **Delete data** that may be needed for recovery

If the operator opts out of backup creation (line 63), there is no recovery path once truncation proceeds.

## Impact Explanation

This issue falls under **Medium Severity** ($10,000) per Aptos bug bounty criteria: "State inconsistencies requiring intervention."

While not directly exploitable during normal validator operations, this vulnerability:
- **Transforms recoverable corruption into permanent data loss**: A validator with partial database corruption could use this tool expecting recovery, but instead makes the situation unrecoverable
- **Violates the safety principle of recovery tools**: Database recovery tools must fail-safe, never making situations worse
- **Could affect network availability**: If multiple validators encounter corruption and use this tool, they may all end up with unrecoverable databases, affecting network liveness
- **Breaks the State Consistency invariant**: The tool can create additional cross-database inconsistencies during truncation of corrupted data

The impact is limited because:
- It requires pre-existing database corruption
- It requires operator intervention to run the db_debugger tool
- It only affects nodes that choose to use this specific recovery tool

## Likelihood Explanation

**Likelihood: Low to Medium**

The vulnerability will occur when:
1. **Database corruption exists** (from crashes, disk failures, bugs in write paths) - This can happen in production
2. **An operator attempts recovery** using the truncate tool - Standard procedure when corruption is detected
3. **The operator opts out of backup** OR corruption occurs during truncation - The opt-out option exists specifically for situations where creating backups is not feasible

The TODO comment at line 281 indicates this is a known missing feature, suggesting developers are aware that validation should exist but have not yet implemented it.

Database corruption is not theoretical - it can occur from:
- Process crashes during multi-database commits
- Disk failures or filesystem corruption  
- Bugs in the write path that leave databases inconsistent
- Memory corruption affecting RocksDB data structures

## Recommendation

Implement comprehensive validation in `open_dbs()` and before truncation:

```rust
pub fn open_dbs(
    db_paths: &StorageDirPaths,
    rocksdb_configs: RocksdbConfigs,
    env: Option<&Env>,
    block_cache: Option<&Cache>,
    readonly: bool,
    max_num_nodes_per_lru_cache_shard: usize,
    reset_hot_state: bool,
) -> Result<(LedgerDb, Option<StateMerkleDb>, StateMerkleDb, StateKvDb)> {
    // Open all databases
    let ledger_db = LedgerDb::new(...)?;
    let state_kv_db = StateKvDb::new(...)?;
    let hot_state_merkle_db = ...;
    let state_merkle_db = StateMerkleDb::new(...)?;
    
    // ADDED: Validate cross-database consistency
    validate_database_consistency(&ledger_db, &state_kv_db, &state_merkle_db)?;
    
    Ok((ledger_db, hot_state_merkle_db, state_merkle_db, state_kv_db))
}

fn validate_database_consistency(
    ledger_db: &LedgerDb,
    state_kv_db: &StateKvDb, 
    state_merkle_db: &StateMerkleDb,
) -> Result<()> {
    // Read version metadata
    let overall_version = ledger_db.metadata_db().get_synced_version()?
        .ok_or_else(|| AptosDbError::Other("Missing OverallCommitProgress".to_string()))?;
    let ledger_version = ledger_db.metadata_db().get_ledger_commit_progress()?;
    let state_kv_version = get_state_kv_commit_progress(state_kv_db)?
        .ok_or_else(|| AptosDbError::Other("Missing StateKvCommitProgress".to_string()))?;
    let state_merkle_version = get_current_version_in_state_merkle_db(state_merkle_db)?
        .ok_or_else(|| AptosDbError::Other("Missing StateMerkleVersion".to_string()))?;
    
    // Validate version relationships with helpful error messages
    ensure!(
        overall_version <= ledger_version,
        "Database inconsistency: overall_version ({}) > ledger_version ({})",
        overall_version, ledger_version
    );
    ensure!(
        overall_version <= state_kv_version,
        "Database inconsistency: overall_version ({}) > state_kv_version ({})", 
        overall_version, state_kv_version
    );
    ensure!(
        state_merkle_version <= overall_version,
        "Database inconsistency: state_merkle_version ({}) > overall_version ({})",
        state_merkle_version, overall_version
    );
    
    // Validate Merkle tree root exists at overall_version
    ensure!(
        root_exists_at_version(state_merkle_db, overall_version)?,
        "Database corruption: No valid Merkle tree root at version {}",
        overall_version
    );
    
    // Validate reasonable version bounds
    ensure!(
        overall_version < u64::MAX / 2,
        "Suspicious version number ({}), possible corruption",
        overall_version
    );
    
    Ok(())
}
```

Additionally, in the `run()` function of truncate/mod.rs, replace panicking assertions with proper error handling:

```rust
// Replace assert_le! with ensure! for better error messages
ensure!(
    overall_version <= ledger_db_version,
    "Cannot truncate: overall_version ({}) exceeds ledger_db_version ({})",
    overall_version, ledger_db_version
);
ensure!(
    overall_version <= state_kv_db_version,
    "Cannot truncate: overall_version ({}) exceeds state_kv_db_version ({})",
    overall_version, state_kv_db_version  
);
// ... similar for other assertions
```

Make backup creation mandatory by removing the `opt_out_backup_checkpoint` option, or at minimum require explicit confirmation from the operator.

## Proof of Concept

```rust
#[cfg(test)]
mod corruption_test {
    use super::*;
    use aptos_temppath::TempPath;
    use aptos_storage_interface::DbReader;
    
    #[test]
    #[should_panic(expected = "assertion failed")]
    fn test_truncate_on_corrupted_database() {
        // Setup: Create a database with some valid data
        let tmp_dir = TempPath::new();
        let db = AptosDB::new_for_test(&tmp_dir);
        
        // Commit some transactions to create valid state
        let txns_to_commit = vec![/* ... valid transactions ... */];
        db.save_transactions_for_test(&txns_to_commit, 0, None, true).unwrap();
        let valid_version = db.expect_synced_version();
        drop(db);
        
        // Simulate corruption: Manually corrupt the OverallCommitProgress metadata
        // by writing an invalid version number
        let rocksdb_config = RocksdbConfigs::default();
        let (ledger_db, _, _, _) = AptosDB::open_dbs(
            &StorageDirPaths::from_path(&tmp_dir),
            rocksdb_config,
            None,
            None,
            false,
            0,
            true,
        ).unwrap();
        
        let mut batch = SchemaBatch::new();
        // Write a corrupted version that's way too high
        batch.put::<DbMetadataSchema>(
            &DbMetadataKey::OverallCommitProgress,
            &DbMetadataValue::Version(u64::MAX - 1000),
        ).unwrap();
        ledger_db.metadata_db().write_schemas(batch).unwrap();
        drop(ledger_db);
        
        // Now attempt truncation - this should detect corruption and fail safely
        // but instead it will panic on assertion failure
        let cmd = Cmd {
            db_dir: tmp_dir.path().to_path_buf(),
            target_version: valid_version - 10,
            ledger_db_batch_size: 100,
            opt_out_backup_checkpoint: true,  // No backup!
            backup_checkpoint_dir: None,
            sharding_config: ShardingConfig {
                enable_storage_sharding: false,
            },
        };
        
        // This will panic with "assertion failed: overall_version <= ledger_db_version"
        // instead of failing safely with a helpful error message
        cmd.run().unwrap();
    }
}
```

**Notes:**

This vulnerability specifically affects the `db_debugger/truncate` tool used for database maintenance and recovery. The lack of validation means that attempting to recover from corruption using this tool can make the situation permanently unrecoverable. The explicit TODO comment in the codebase confirms that this validation is a known missing feature.

### Citations

**File:** storage/aptosdb/src/db_debugger/truncate/mod.rs (L74-82)
```rust
        let (ledger_db, hot_state_merkle_db, state_merkle_db, state_kv_db) = AptosDB::open_dbs(
            &StorageDirPaths::from_path(&self.db_dir),
            rocksdb_config,
            env,
            block_cache,
            /*readonly=*/ false,
            /*max_num_nodes_per_lru_cache_shard=*/ 0,
            /*reset_hot_state=*/ true,
        )?;
```

**File:** storage/aptosdb/src/db_debugger/truncate/mod.rs (L88-100)
```rust
        let overall_version = ledger_db
            .metadata_db()
            .get_synced_version()
            .expect("DB read failed.")
            .expect("Overall commit progress must exist.");
        let ledger_db_version = ledger_db
            .metadata_db()
            .get_ledger_commit_progress()
            .expect("Current version of ledger db must exist.");
        let state_kv_db_version = get_state_kv_commit_progress(&state_kv_db)?
            .expect("Current version of state kv db must exist.");
        let state_merkle_db_version = get_current_version_in_state_merkle_db(&state_merkle_db)?
            .expect("Current version of state merkle db must exist.");
```

**File:** storage/aptosdb/src/db_debugger/truncate/mod.rs (L104-107)
```rust
        assert_le!(overall_version, ledger_db_version);
        assert_le!(overall_version, state_kv_db_version);
        assert_le!(state_merkle_db_version, overall_version);
        assert_le!(target_version, overall_version);
```

**File:** storage/aptosdb/src/db_debugger/truncate/mod.rs (L130-142)
```rust
        let mut batch = SchemaBatch::new();
        batch.put::<DbMetadataSchema>(
            &DbMetadataKey::OverallCommitProgress,
            &DbMetadataValue::Version(target_version),
        )?;
        ledger_db.metadata_db().write_schemas(batch)?;

        StateStore::sync_commit_progress(
            Arc::clone(&ledger_db),
            Arc::clone(&state_kv_db),
            Arc::clone(&state_merkle_db),
            /*crash_if_difference_is_too_large=*/ false,
        );
```

**File:** storage/aptosdb/src/db/mod.rs (L106-156)
```rust
    pub fn open_dbs(
        db_paths: &StorageDirPaths,
        rocksdb_configs: RocksdbConfigs,
        env: Option<&Env>,
        block_cache: Option<&Cache>,
        readonly: bool,
        max_num_nodes_per_lru_cache_shard: usize,
        reset_hot_state: bool,
    ) -> Result<(LedgerDb, Option<StateMerkleDb>, StateMerkleDb, StateKvDb)> {
        let ledger_db = LedgerDb::new(
            db_paths.ledger_db_root_path(),
            rocksdb_configs,
            env,
            block_cache,
            readonly,
        )?;
        let state_kv_db = StateKvDb::new(
            db_paths,
            rocksdb_configs,
            env,
            block_cache,
            readonly,
            ledger_db.metadata_db_arc(),
        )?;
        let hot_state_merkle_db = if !readonly && rocksdb_configs.enable_storage_sharding {
            Some(StateMerkleDb::new(
                db_paths,
                rocksdb_configs,
                env,
                block_cache,
                readonly,
                max_num_nodes_per_lru_cache_shard,
                /* is_hot = */ true,
                reset_hot_state,
            )?)
        } else {
            None
        };
        let state_merkle_db = StateMerkleDb::new(
            db_paths,
            rocksdb_configs,
            env,
            block_cache,
            readonly,
            max_num_nodes_per_lru_cache_shard,
            /* is_hot = */ false,
            /* delete_on_restart = */ false,
        )?;

        Ok((ledger_db, hot_state_merkle_db, state_merkle_db, state_kv_db))
    }
```

**File:** storage/aptosdb/src/ledger_db/mod.rs (L281-281)
```rust
        // TODO(grao): Handle data inconsistency.
```
