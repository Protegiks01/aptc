# Audit Report

## Title
No Validation Preventing commission_paid from Exceeding amount in UnlockStakeEvent - Enabling Commission Extraction Obfuscation

## Summary
The `UnlockStakeEvent` emitted by `staking_contract::unlock_stake` can display `commission_paid` values that exceed the `amount` being unlocked, creating misleading event data that obscures the true extent of commission extraction from stakers.

## Finding Description

The `UnlockStakeEvent` struct in the staking contract contains two fields that represent distinct sequential operations, but their proximity in the event structure suggests a relationship that doesn't exist: [1](#0-0) 

The vulnerability lies in the `unlock_stake` function's execution flow: [2](#0-1) 

The critical issue is that commission is calculated and unlocked FIRST from the total active stake, then the unlock amount is adjusted based on what remains. The event emission occurs after both operations: [3](#0-2) 

**Exploitation Scenario:**
1. Stake pool has 1000 APT active (100 principal + 900 accumulated rewards)
2. Operator sets commission rate to 90%
3. Commission calculation: 90% × 900 = 810 APT
4. After commission unlock: 1000 - 810 = 190 APT remaining active
5. Staker attempts to unlock 50 APT
6. Event emitted: `amount=50, commission_paid=810`

This creates an event where `commission_paid` is **16× larger** than the `amount`, making it appear that a massive commission was extracted from a small unlock operation. Off-chain monitoring systems focused on tracking unlock amounts would miss the 810 APT commission extraction hidden in this transaction.

## Impact Explanation

This qualifies as **High Severity** under "Significant protocol violations" because:

1. **Event Integrity Violation**: Events are a critical part of the blockchain's transparency mechanism. This violates the expectation that events provide clear, unambiguous data about operations.

2. **Accounting Obfuscation**: The event structure enables operators to hide excessive commission extraction by making small unlock requests trigger large commission payments that appear unrelated to the unlock amount.

3. **Monitoring Bypass**: Security systems monitoring for suspicious staking activity could fail to detect excessive commission extraction if they focus on the `amount` field without properly correlating `commission_paid`.

4. **Trust Model Violation**: Stakers rely on event data to verify their stake operations. Misleading events undermine this trust and could facilitate undetected fund extraction.

While this doesn't directly steal funds, it represents a **significant protocol-level issue** in how critical staking operations are reported and monitored, fitting the High severity category.

## Likelihood Explanation

**High Likelihood** - This is not a rare edge case but occurs naturally when:
- Significant rewards accumulate (common in active validator pools)
- Operators use moderate-to-high commission rates (standard practice)
- Any unlock operation is performed after reward accumulation

The combination of these common conditions makes this scenario highly likely to occur in production environments, affecting real stakers' ability to properly track their stake operations.

## Recommendation

Add validation and semantic clarity to the event structure. Two approaches:

**Option 1: Add validation to prevent misleading events**
```move
// After line 766, before event emission
assert!(
    commission_paid <= amount || commission_paid == 0,
    error::invalid_state(ECOMMISSION_EXCEEDS_UNLOCK_AMOUNT)
);
```

**Option 2: Restructure event to show true relationship (RECOMMENDED)**
```move
// Replace UnlockStakeEvent with more descriptive structure
struct UnlockStakeEvent has drop, store {
    operator: address,
    pool_address: address,
    staker_unlock_amount: u64,
    operator_commission_amount: u64,
    total_unlocked: u64,  // staker_unlock_amount + operator_commission_amount
}

// Emit with clear semantics
emit_event(
    &mut store.unlock_stake_events,
    UnlockStakeEvent { 
        pool_address, 
        operator, 
        staker_unlock_amount: amount,
        operator_commission_amount: commission_paid,
        total_unlocked: amount + commission_paid
    }
);
```

This makes it explicit that both amounts are part of a total unlock operation, preventing misinterpretation.

## Proof of Concept

```move
#[test(aptos_framework = @0x1, staker = @0x123, operator = @0x234)]
public entry fun test_commission_exceeds_unlock_amount_in_event(
    aptos_framework: &signer, staker: &signer, operator: &signer
) acquires Store, BeneficiaryForOperator {
    // Setup with initial stake
    let initial_balance = 100_000_000; // 1 APT
    setup_staking_contract(aptos_framework, staker, operator, initial_balance, 90); // 90% commission
    
    let staker_address = signer::address_of(staker);
    let operator_address = signer::address_of(operator);
    let pool_address = stake_pool_address(staker_address, operator_address);
    
    // Join validator set and generate rewards
    let (_sk, pk, pop) = stake::generate_identity();
    stake::join_validator_set_for_test(&pk, &pop, operator, pool_address, true);
    
    // Generate massive rewards (9× original stake)
    stake::end_epoch();
    let rewards_balance = with_rewards(initial_balance); // ~900M additional
    let expected_commission = (rewards_balance - initial_balance) * 90 / 100; // ~810M
    
    // Staker unlocks tiny amount (5M = 0.05 APT)
    let tiny_unlock = 5_000_000;
    
    // This will emit UnlockStakeEvent with:
    // amount = 5_000_000 (5M)
    // commission_paid = ~810_000_000 (810M)
    // commission_paid / amount = 162× ratio!
    unlock_stake(staker, operator_address, tiny_unlock);
    
    // Verify event was emitted (event inspection would show the misleading data)
    // In production, monitoring systems would see a 5M unlock but miss the 810M commission
}
```

**Notes**

This finding specifically addresses the Rosetta API event structure defined at: [4](#0-3) 

The issue affects both the Move-level events and their Rosetta API representation, impacting off-chain systems that rely on event data for tracking staking operations, accounting, and security monitoring.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/staking_contract.move (L241-246)
```text
    struct UnlockStakeEvent has drop, store {
        operator: address,
        pool_address: address,
        amount: u64,
        commission_paid: u64
    }
```

**File:** aptos-move/framework/aptos-framework/sources/staking_contract.move (L753-766)
```text
        let commission_paid =
            request_commission_internal(
                operator,
                staking_contract,
                &mut store.add_distribution_events,
                &mut store.request_commission_events
            );

        // If there's less active stake remaining than the amount requested (potentially due to commission),
        // only withdraw up to the active amount.
        let (active, _, _, _) = stake::get_stake(staking_contract.pool_address);
        if (active < amount) {
            amount = active;
        };
```

**File:** aptos-move/framework/aptos-framework/sources/staking_contract.move (L785-791)
```text
                UnlockStake { pool_address, operator, amount, commission_paid }
            );
        } else {
            emit_event(
                &mut store.unlock_stake_events,
                UnlockStakeEvent { pool_address, operator, amount, commission_paid }
            );
```

**File:** crates/aptos-rosetta/src/types/move_types.rs (L153-159)
```rust
#[derive(Debug, Serialize, Deserialize)]
pub struct UnlockStakeEvent {
    pub operator: AccountAddress,
    pub pool_address: AccountAddress,
    pub amount: u64,
    pub commission_paid: u64,
}
```
