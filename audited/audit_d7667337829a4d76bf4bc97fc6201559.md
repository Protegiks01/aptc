# Audit Report

## Title
Storage Layer Denial of Service via Unbounded Version in Pruner Progress During Fast Sync

## Summary
The `write_pruner_progress()` function in `ledger_db/mod.rs` lacks validation that the version parameter is within valid blockchain height range. During fast sync finalization, an out-of-bounds version can be written to pruner metadata, corrupting the pruning state and making all blockchain data inaccessible. [1](#0-0) 

## Finding Description
The vulnerability exists in the fast sync finalization path where pruner progress is initialized without bounds checking:

**Attack Flow:**

1. During fast sync, `finalize_state_snapshot()` receives a `version` parameter from the state synchronizer [2](#0-1) 

2. This version originates from `target_ledger_info.ledger_info().version()` [3](#0-2) 

3. The version is passed to `ledger_pruner.save_min_readable_version(version)` which calls `write_pruner_progress()` [4](#0-3) 

4. Each sub-database writes this version as pruner progress without validation [5](#0-4) 

**Impact Mechanism:**

When reads attempt to access data, they check `error_if_ledger_pruned()` [6](#0-5) 

This validates: `version >= min_readable_version`

If `min_readable_version` is set to an extremely high value (e.g., `u64::MAX - 1000`), ALL legitimate version requests will fail this check, as no normal blockchain version will be >= the corrupted min_readable_version. Critical operations like `get_transactions()` will fail [7](#0-6) 

This breaks the **State Consistency** invariant - the storage layer becomes unable to serve any historical data, effectively corrupting the node's state accessibility.

## Impact Explanation
**Medium Severity** - State inconsistencies requiring intervention

While this doesn't directly cause consensus violations or fund loss, it results in:
- Complete inability to read any blockchain data
- State sync failures (nodes cannot bootstrap)
- API service unavailability
- Requires manual database intervention or full node reset

The impact is limited to **availability** rather than safety or liveness of the overall network, but affected nodes become completely non-functional for serving historical data.

## Likelihood Explanation
**Low to Medium Likelihood**

This requires specific conditions:
- Fast sync must be in progress
- The `target_ledger_info` must contain an invalid version number
- However, LedgerInfo structures are cryptographically signed by validators

While LedgerInfo verification checks signature validity and version consistency [8](#0-7) , there's no explicit upper bound validation on the version field itself. A malicious or compromised peer during fast sync, or a bug in version calculation elsewhere, could potentially provide a LedgerInfo with an unreasonably high version.

## Recommendation
Add defensive bounds checking in `write_pruner_progress()`:

```rust
pub(crate) fn write_pruner_progress(&self, version: Version) -> Result<()> {
    // Get current synced version as upper bound
    let synced_version = self.metadata_db().get_synced_version()?.unwrap_or(0);
    
    // Allow some margin but prevent absurdly high values
    const MAX_VERSION_MARGIN: u64 = 1_000_000; // Configurable safety margin
    ensure!(
        version <= synced_version + MAX_VERSION_MARGIN || version <= MAX_VERSION_MARGIN,
        "Pruner progress version {} exceeds reasonable bounds (synced: {})",
        version,
        synced_version
    );
    
    info!("Fast sync is done, writing pruner progress {version} for all ledger sub pruners.");
    // ... existing code
}
```

Additionally, validate in `finalize_state_snapshot()` before calling pruner methods.

## Proof of Concept
```rust
#[test]
fn test_pruner_progress_out_of_bounds_corruption() {
    let tmpdir = TempPath::new();
    let db = AptosDB::new_for_test(&tmpdir);
    
    // Simulate fast sync completing with corrupted high version
    let corrupted_version = u64::MAX - 1000;
    
    // This should fail but currently succeeds
    db.ledger_db.write_pruner_progress(corrupted_version).unwrap();
    
    // Now try to read a normal transaction
    let normal_version = 100u64;
    
    // This will fail because min_readable_version is now u64::MAX - 1000
    let result = db.error_if_ledger_pruned("Transaction", normal_version);
    
    // Demonstrates that all data is now inaccessible
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("pruned"));
}
```

## Notes
While the attack requires specific conditions during fast sync, the complete absence of bounds validation represents a defensive programming failure. The storage layer should not blindly trust version values even from consensus-verified sources, as bugs elsewhere in the codebase could propagate invalid values. Adding validation here provides defense-in-depth against potential future vulnerabilities in version handling.

### Citations

**File:** storage/aptosdb/src/ledger_db/mod.rs (L373-388)
```rust
    pub(crate) fn write_pruner_progress(&self, version: Version) -> Result<()> {
        info!("Fast sync is done, writing pruner progress {version} for all ledger sub pruners.");
        self.event_db.write_pruner_progress(version)?;
        self.persisted_auxiliary_info_db
            .write_pruner_progress(version)?;
        self.transaction_accumulator_db
            .write_pruner_progress(version)?;
        self.transaction_auxiliary_data_db
            .write_pruner_progress(version)?;
        self.transaction_db.write_pruner_progress(version)?;
        self.transaction_info_db.write_pruner_progress(version)?;
        self.write_set_db.write_pruner_progress(version)?;
        self.ledger_metadata_db.write_pruner_progress(version)?;

        Ok(())
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L225-225)
```rust
            self.ledger_pruner.save_min_readable_version(version)?;
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L548-554)
```rust
        // Verify the version.
        ensure!(
            ledger_info.version() == version,
            "Version in LedgerInfo doesn't match last version. {:?} vs {:?}",
            ledger_info.version(),
            version,
        );
```

**File:** state-sync/state-sync-driver/src/storage_synchronizer.rs (L846-846)
```rust
        let version = target_ledger_info.ledger_info().version();
```

**File:** storage/aptosdb/src/pruner/ledger_pruner/ledger_pruner_manager.rs (L80-89)
```rust
    fn save_min_readable_version(&self, min_readable_version: Version) -> Result<()> {
        self.min_readable_version
            .store(min_readable_version, Ordering::SeqCst);

        PRUNER_VERSIONS
            .with_label_values(&["ledger_pruner", "min_readable"])
            .set(min_readable_version as i64);

        self.ledger_db.write_pruner_progress(min_readable_version)
    }
```

**File:** storage/aptosdb/src/ledger_db/transaction_db.rs (L40-45)
```rust
    pub(super) fn write_pruner_progress(&self, version: Version) -> Result<()> {
        self.db.put::<DbMetadataSchema>(
            &DbMetadataKey::TransactionPrunerProgress,
            &DbMetadataValue::Version(version),
        )
    }
```

**File:** storage/aptosdb/src/db/aptosdb_internal.rs (L261-271)
```rust
    pub(super) fn error_if_ledger_pruned(&self, data_type: &str, version: Version) -> Result<()> {
        let min_readable_version = self.ledger_pruner.get_min_readable_version();
        ensure!(
            version >= min_readable_version,
            "{} at version {} is pruned, min available version is {}.",
            data_type,
            version,
            min_readable_version
        );
        Ok(())
    }
```

**File:** storage/aptosdb/src/db/aptosdb_reader.rs (L280-280)
```rust
            self.error_if_ledger_pruned("Transaction", start_version)?;
```
