# Audit Report

## Title
Concurrent Fallback and Commit Sync Notifications Cause State Corruption in Consensus Observer

## Summary
The consensus observer can simultaneously trigger both fallback sync and commit sync operations, allowing both `FallbackSyncCompleted` and `CommitSyncCompleted` notifications to be processed sequentially. This results in conflicting state updates including double epoch transitions, cleared pending blocks being processed, and corrupted execution pipeline state.

## Finding Description

The consensus observer maintains two independent state sync mechanisms:
1. **Fallback sync** - triggered when the observer falls behind or loses subscription health
2. **Commit sync** - triggered when a commit decision for a future epoch/round arrives

The vulnerability exists because `process_commit_decision_message()` fails to check if the system is already in fallback mode before initiating commit sync. The guard at line 507 only verifies `is_syncing_through_epoch()` (whether a commit sync with epoch transition is active) but does NOT check `in_fallback_mode()` (whether fallback sync is active). [1](#0-0) 

The `is_syncing_through_epoch()` method only checks if there's an active epoch-transitioning commit sync: [2](#0-1) 

This allows the following attack sequence:

**Attack Flow:**
1. Node enters fallback mode via `enter_fallback_mode()`, which calls `sync_for_fallback()`: [3](#0-2) 

2. The fallback sync spawns an async task setting `fallback_sync_handle` that runs for the configured duration: [4](#0-3) 

3. Before fallback completes, a commit decision message arrives and proceeds to call `sync_to_commit()`: [5](#0-4) 

4. The commit sync spawns its own async task setting `sync_to_commit_handle`: [6](#0-5) 

5. Now both `fallback_sync_handle` and `sync_to_commit_handle` are set with both async tasks running concurrently

6. Both tasks complete and send notifications through the same unbounded channel

7. The notifications are processed sequentially in the main event loop: [7](#0-6) 

**Conflicting State Updates:**

When `FallbackSyncCompleted` is processed, it updates the root, potentially calls `end_epoch()` and `wait_for_epoch_start()`, and clears ALL pending block state: [8](#0-7) 

When `CommitSyncCompleted` is processed, it performs its own validation, potentially calls `end_epoch()` and `wait_for_epoch_start()` AGAIN, and attempts to process ordered blocks: [9](#0-8) 

This violates the State Consistency invariant - state transitions must be atomic and cannot have conflicting concurrent updates.

## Impact Explanation

**Severity: HIGH** (up to $50,000)

This vulnerability causes:

1. **Consensus Observer Corruption**: The observer enters an inconsistent state where:
   - The root may point to different ledger infos depending on notification order
   - The execution pipeline can be reset multiple times or in conflicting ways
   - Ordered blocks are cleared but then attempted to be finalized

2. **Double Epoch Transitions**: Both handlers can call `execution_client.end_epoch()` and `wait_for_epoch_start()`, potentially causing:
   - Race conditions in the execution client
   - Corrupted epoch state
   - Incorrect epoch initialization

3. **Observer Liveness Failure**: The corrupted state can cause the consensus observer to:
   - Fail to process subsequent blocks
   - Require node restart to recover
   - Lose sync with the network

This qualifies as **High Severity** under "Validator node slowdowns" and "API Crashes" categories - the consensus observer component can become non-functional, requiring manual intervention.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

This vulnerability can be triggered through:

1. **Natural Network Conditions**: 
   - Observer falls behind due to network latency → enters fallback mode
   - During fallback (default 10 minutes), validators continue producing blocks
   - New commit decision arrives → both syncs active [10](#0-9) 

2. **Automatic Trigger**: Fallback mode is automatically triggered when:
   - No progress for 10 seconds (observer_fallback_progress_threshold_ms)
   - Sync lag exceeds 15 seconds (observer_fallback_sync_lag_threshold_ms)

The attack requires no special privileges - any validator can send commit decisions, and fallback mode is triggered automatically by the observer's own health checks. The 10-minute fallback window provides ample opportunity for commit decisions to arrive during the concurrent sync period.

## Recommendation

Add a check for fallback mode before initiating commit sync:

```rust
// In process_commit_decision_message(), line 504-516:
if epoch_changed || commit_round > last_block.round() {
    // Check if we're in fallback mode
    if self.state_sync_manager.in_fallback_mode() {
        info!(
            LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                "Already in fallback mode. Dropping commit decision: {:?}!",
                commit_decision.proof_block_info()
            ))
        );
        return;
    }
    
    // If we're waiting for state sync to transition into a new epoch,
    // we should just wait and not issue a new state sync request.
    if self.state_sync_manager.is_syncing_through_epoch() {
        // ... existing code
    }
    
    // ... rest of the function
}
```

## Proof of Concept

While a complete PoC would require setting up a consensus observer environment, the vulnerability can be demonstrated by:

1. Deploy a consensus observer node
2. Induce network latency to trigger fallback mode (wait 10 seconds without progress)
3. Send a commit decision message from a validator during the 10-minute fallback window
4. Both `FallbackSyncCompleted` and `CommitSyncCompleted` notifications will be sent
5. Observer state becomes corrupted with double epoch transitions and cleared blocks being processed

The code evidence clearly shows both sync handles can be set concurrently and both notification handlers will execute conflicting state updates.

## Notes

- This affects consensus observer nodes (primarily validator fullnodes), not validators directly
- The consensus observer is enabled by default on validator fullnodes per the configuration optimizer
- The 10-minute default fallback duration creates a large vulnerability window
- No cryptographic or consensus protocol violations are required - only normal network conditions

### Citations

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L237-246)
```rust
    async fn enter_fallback_mode(&mut self) {
        // Terminate all active subscriptions (to ensure we don't process any more messages)
        self.subscription_manager.terminate_all_subscriptions();

        // Clear all the pending block state
        self.clear_pending_block_state().await;

        // Start syncing for the fallback
        self.state_sync_manager.sync_for_fallback();
    }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L507-516)
```rust
            if self.state_sync_manager.is_syncing_through_epoch() {
                info!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Already waiting for state sync to reach new epoch: {:?}. Dropping commit decision: {:?}!",
                        self.observer_block_data.lock().root().commit_info(),
                        commit_decision.proof_block_info()
                    ))
                );
                return;
            }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L518-527)
```rust
            // Otherwise, we should start the state sync process for the commit.
            // Update the block data (to the commit decision).
            self.observer_block_data
                .lock()
                .update_blocks_for_state_sync_commit(&commit_decision);

            // Start state syncing to the commit decision
            self.state_sync_manager
                .sync_to_commit(commit_decision, epoch_changed);
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L947-961)
```rust
        // Update the root with the latest synced ledger info
        self.observer_block_data
            .lock()
            .update_root(latest_synced_ledger_info);

        // If the epoch has changed, end the current epoch and start the latest one
        let current_epoch_state = self.get_epoch_state();
        if epoch > current_epoch_state.epoch {
            // Wait for the latest epoch to start
            self.execution_client.end_epoch().await;
            self.wait_for_epoch_start().await;
        };

        // Reset the pending block state
        self.clear_pending_block_state().await;
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L1027-1061)
```rust
        let current_epoch_state = self.get_epoch_state();
        if synced_epoch > current_epoch_state.epoch {
            // Wait for the latest epoch to start
            self.execution_client.end_epoch().await;
            self.wait_for_epoch_start().await;

            // Verify the block payloads for the new epoch
            let new_epoch_state = self.get_epoch_state();
            let verified_payload_rounds = self
                .observer_block_data
                .lock()
                .verify_payload_signatures(&new_epoch_state);

            // Order all the pending blocks that are now ready (these were buffered during state sync)
            for payload_round in verified_payload_rounds {
                self.order_ready_pending_block(new_epoch_state.epoch, payload_round)
                    .await;
            }
        };

        // Reset the state sync manager for the synced commit decision
        self.state_sync_manager.clear_active_commit_sync();

        // Process all the newly ordered blocks
        let all_ordered_blocks = self.observer_block_data.lock().get_all_ordered_blocks();
        for (_, (observed_ordered_block, commit_decision)) in all_ordered_blocks {
            // Finalize the ordered block
            let ordered_block = observed_ordered_block.consume_ordered_block();
            self.finalize_ordered_block(ordered_block).await;

            // If a commit decision is available, forward it to the execution pipeline
            if let Some(commit_decision) = commit_decision {
                self.forward_commit_decision(commit_decision.clone());
            }
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L1127-1141)
```rust
        loop {
            tokio::select! {
                Some(network_message) = consensus_observer_message_receiver.next() => {
                    self.process_network_message(network_message).await;
                }
                Some(state_sync_notification) = state_sync_notification_listener.recv() => {
                    self.process_state_sync_notification(state_sync_notification).await;
                },
                _ = progress_check_interval.select_next_some() => {
                    self.check_progress().await;
                }
                else => {
                    break; // Exit the consensus observer loop
                }
            }
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L107-109)
```rust
    pub fn is_syncing_through_epoch(&self) -> bool {
        matches!(self.sync_to_commit_handle, Some((_, true)))
    }
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L134-186)
```rust
        // Spawn a task to sync for the fallback
        let (abort_handle, abort_registration) = AbortHandle::new_pair();
        tokio::spawn(Abortable::new(
            async move {
                // Update the state sync metrics now that we're syncing for the fallback
                metrics::set_gauge_with_label(
                    &metrics::OBSERVER_STATE_SYNC_EXECUTING,
                    metrics::STATE_SYNCING_FOR_FALLBACK,
                    1, // We're syncing for the fallback
                );

                // Get the fallback duration
                let fallback_duration =
                    Duration::from_millis(consensus_observer_config.observer_fallback_duration_ms);

                // Sync for the fallback duration
                let latest_synced_ledger_info = match execution_client
                    .clone()
                    .sync_for_duration(fallback_duration)
                    .await
                {
                    Ok(latest_synced_ledger_info) => latest_synced_ledger_info,
                    Err(error) => {
                        error!(LogSchema::new(LogEntry::ConsensusObserver)
                            .message(&format!("Failed to sync for fallback! Error: {:?}", error)));
                        return;
                    },
                };

                // Notify consensus observer that we've synced for the fallback
                let state_sync_notification =
                    StateSyncNotification::fallback_sync_completed(latest_synced_ledger_info);
                if let Err(error) = sync_notification_sender.send(state_sync_notification) {
                    error!(
                        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                            "Failed to send state sync notification for fallback! Error: {:?}",
                            error
                        ))
                    );
                }

                // Clear the state sync metrics now that we're done syncing
                metrics::set_gauge_with_label(
                    &metrics::OBSERVER_STATE_SYNC_EXECUTING,
                    metrics::STATE_SYNCING_FOR_FALLBACK,
                    0, // We're no longer syncing for the fallback
                );
            },
            abort_registration,
        ));

        // Save the sync task handle
        self.fallback_sync_handle = Some(DropGuard::new(abort_handle));
```

**File:** consensus/src/consensus_observer/observer/state_sync_manager.rs (L207-257)
```rust
        // Spawn a task to sync to the commit decision
        let (abort_handle, abort_registration) = AbortHandle::new_pair();
        tokio::spawn(Abortable::new(
            async move {
                // Update the state sync metrics now that we're syncing to a commit
                metrics::set_gauge_with_label(
                    &metrics::OBSERVER_STATE_SYNC_EXECUTING,
                    metrics::STATE_SYNCING_TO_COMMIT,
                    1, // We're syncing to a commit decision
                );

                // Sync to the commit decision
                if let Err(error) = execution_client
                    .clone()
                    .sync_to_target(commit_decision.commit_proof().clone())
                    .await
                {
                    error!(
                        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                            "Failed to sync to commit decision: {:?}! Error: {:?}",
                            commit_decision, error
                        ))
                    );
                    return;
                }

                // Notify consensus observer that we've synced to the commit decision
                let state_sync_notification = StateSyncNotification::commit_sync_completed(
                    commit_decision.commit_proof().clone(),
                );
                if let Err(error) = sync_notification_sender.send(state_sync_notification) {
                    error!(
                        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                            "Failed to send state sync notification for commit decision epoch: {:?}, round: {:?}! Error: {:?}",
                            commit_epoch, commit_round, error
                        ))
                    );
                }

                // Clear the state sync metrics now that we're done syncing
                metrics::set_gauge_with_label(
                    &metrics::OBSERVER_STATE_SYNC_EXECUTING,
                    metrics::STATE_SYNCING_TO_COMMIT,
                    0, // We're no longer syncing to a commit decision
                );
            },
            abort_registration,
        ));

        // Save the sync task handle
        self.sync_to_commit_handle = Some((DropGuard::new(abort_handle), epoch_changed));
```

**File:** config/src/config/consensus_observer_config.rs (L79-82)
```rust
            observer_fallback_duration_ms: 600_000, // 10 minutes
            observer_fallback_startup_period_ms: 60_000, // 60 seconds
            observer_fallback_progress_threshold_ms: 10_000, // 10 seconds
            observer_fallback_sync_lag_threshold_ms: 15_000, // 15 seconds
```
