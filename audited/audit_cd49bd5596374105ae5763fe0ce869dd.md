# Audit Report

## Title
Zero-Weight Validators Can Participate in Randomness Share Aggregation Despite Having No Voting Power

## Summary
Validators with zero voting weight (resulting from DKG rounding of very low stake) can send randomness shares that are accepted and included in cryptographic aggregation, despite having no contribution to quorum calculations. This creates resource consumption and violates the semantic invariant that only validators with voting power should participate in consensus operations.

## Finding Description

The DKG rounding algorithm can assign zero weight to validators with very low stake relative to the `stake_per_weight` parameter: [1](#0-0) 

When randomness shares are received via `ShareAggregateState::add()`, the function only validates:
- Author matches peer
- Metadata matches
- Cryptographic signature is valid

**There is no check of the validator's voting weight:** [2](#0-1) 

Contrast this with `AugDataCertBuilder::add()` which DOES check voting power: [3](#0-2) 

Zero-weight validators' shares are stored in the aggregator, with weight 0 added to `total_weight`: [4](#0-3) 

During aggregation, ALL shares including zero-weight ones are collected and passed to WVUF: [5](#0-4) 

The PinkasWUF implementation includes all shares without weight-based filtering: [6](#0-5) 

In the evaluation derivation, zero-weight validators contribute the identity element via empty Lagrange coefficient slices: [7](#0-6) [8](#0-7) 

## Impact Explanation

**Resource Consumption (Low-Medium Severity):**
Zero-weight validators can send shares that consume:
- Network bandwidth for share transmission
- CPU cycles for cryptographic verification  
- Memory in ShareAggregator HashMap
- CPU for multi-exponentiation operations (even though result is identity)

**Semantic Invariant Violation:**
Validators with zero voting power should not participate in any consensus operations including randomness generation. This violates the principle that voting power determines participation rights.

**However, this does NOT affect:**
- **Quorum calculation** - Zero weights don't contribute to total_weight threshold checks
- **Randomness correctness** - Identity elements don't alter the final randomness output
- **Consensus safety** - No impact on block production or finalization

This qualifies as **Low to Medium severity** - resource consumption without consensus impact.

## Likelihood Explanation

**Medium likelihood** in certain network conditions:
- Requires validator set with highly imbalanced stakes (some validators with minimal stake)
- DKG rounding algorithm can produce zero weights when `stake_per_weight` is high relative to a validator's stake
- Active validators below a certain stake threshold could have zero weight after rounding
- Zero-weight validators can trivially send shares (no special exploit needed)

## Recommendation

Add voting weight validation in `ShareAggregateState::add()`:

```rust
fn add(&self, peer: Author, share: Self::Response) -> anyhow::Result<Option<()>> {
    ensure!(share.author() == &peer, "Author does not match");
    ensure!(
        share.metadata() == &self.rand_metadata,
        "Metadata does not match: local {:?}, received {:?}",
        self.rand_metadata,
        share.metadata()
    );
    
    // Add weight check similar to AugDataCertBuilder
    let weight = self.rand_config.get_peer_weight(&peer);
    ensure!(weight > 0, "Validator {} has zero voting weight", peer);
    
    share.verify(&self.rand_config)?;
    // ... rest of function
}
```

Alternatively, filter zero-weight validators when constructing the target list in `spawn_aggregate_shares_task()`: [9](#0-8) 

## Proof of Concept

**Setup conditions:**
1. Create validator set where one validator has very low stake (e.g., 1 unit) compared to others (e.g., 1,000,000 units each)
2. Run DKG rounding - the low-stake validator receives zero weight
3. During randomness generation, the zero-weight validator sends a valid share
4. The share is accepted and stored despite zero weight
5. Share is included in aggregation, consuming resources

**Expected behavior:** Shares from zero-weight validators should be rejected early.

**Actual behavior:** Shares are accepted and processed through the full aggregation pipeline.

## Notes

While mathematically the system handles zero-weight validators gracefully (they contribute identity elements that don't alter results), accepting and processing their shares violates the security principle of least privilege and creates unnecessary resource consumption. The inconsistency between the DKG rounding comment claiming "each validator has at least 1 weight" and the actual code that can produce zero weights suggests this edge case was not fully considered in the design.

### Citations

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L310-321)
```rust
    for stake in validator_stakes {
        let ideal_weight_fixed = U64F64::from_num(*stake) / stake_per_weight;
        // rounded to the nearest integer
        let rounded_weight_fixed = (ideal_weight_fixed + (one / 2)).floor();
        let rounded_weight = rounded_weight_fixed.to_num::<u64>();
        validator_weights.push(rounded_weight);
        if ideal_weight_fixed > rounded_weight_fixed {
            delta_down_fixed += ideal_weight_fixed - rounded_weight_fixed;
        } else {
            delta_up_fixed += rounded_weight_fixed - ideal_weight_fixed;
        }
    }
```

**File:** consensus/src/rand/rand_gen/reliable_broadcast_state.rs (L48-66)
```rust
    fn add(&self, peer: Author, ack: Self::Response) -> anyhow::Result<Option<Self::Aggregated>> {
        ack.verify(peer, &self.epoch_state.verifier, &self.aug_data)?;
        let mut parital_signatures_guard = self.partial_signatures.lock();
        parital_signatures_guard.add_signature(peer, ack.into_signature());
        let qc_aug_data = self
            .epoch_state
            .verifier
            .check_voting_power(parital_signatures_guard.signatures().keys(), true)
            .ok()
            .map(|_| {
                let aggregated_signature = self
                    .epoch_state
                    .verifier
                    .aggregate_signatures(parital_signatures_guard.signatures_iter())
                    .expect("Signature aggregation should succeed");
                CertifiedAugData::new(self.aug_data.clone(), aggregated_signature)
            });
        Ok(qc_aug_data)
    }
```

**File:** consensus/src/rand/rand_gen/reliable_broadcast_state.rs (L131-151)
```rust
    fn add(&self, peer: Author, share: Self::Response) -> anyhow::Result<Option<()>> {
        ensure!(share.author() == &peer, "Author does not match");
        ensure!(
            share.metadata() == &self.rand_metadata,
            "Metadata does not match: local {:?}, received {:?}",
            self.rand_metadata,
            share.metadata()
        );
        share.verify(&self.rand_config)?;
        info!(LogSchema::new(LogEvent::ReceiveReactiveRandShare)
            .epoch(share.epoch())
            .round(share.metadata().round)
            .remote_peer(*share.author()));
        let mut store = self.rand_store.lock();
        let aggregated = if store.add_share(share, PathType::Slow)? {
            Some(())
        } else {
            None
        };
        Ok(aggregated)
    }
```

**File:** consensus/src/rand/rand_gen/rand_store.rs (L35-39)
```rust
    pub fn add_share(&mut self, weight: u64, share: RandShare<S>) {
        if self.shares.insert(*share.author(), share).is_none() {
            self.total_weight += weight;
        }
    }
```

**File:** consensus/src/rand/rand_gen/types.rs (L107-128)
```rust
        for share in shares {
            let id = rand_config
                .validator
                .address_to_validator_index()
                .get(share.author())
                .copied()
                .ok_or_else(|| {
                    anyhow!(
                        "Share::aggregate failed with invalid share author: {}",
                        share.author
                    )
                })?;
            let apk = rand_config
                .get_certified_apk(share.author())
                .ok_or_else(|| {
                    anyhow!(
                        "Share::aggregate failed with missing apk for share from {}",
                        share.author
                    )
                })?;
            apks_and_proofs.push((Player { id }, apk.clone(), share.share().share));
        }
```

**File:** crates/aptos-dkg/src/weighted_vuf/pinkas/mod.rs (L172-183)
```rust
    fn aggregate_shares(
        _wc: &WeightedConfigBlstrs,
        apks_and_proofs: &[(Player, Self::AugmentedPubKeyShare, Self::ProofShare)],
    ) -> Self::Proof {
        let mut players_and_shares = Vec::with_capacity(apks_and_proofs.len());

        for (p, _, share) in apks_and_proofs {
            players_and_shares.push((p.clone(), share.clone()));
        }

        players_and_shares
    }
```

**File:** crates/aptos-dkg/src/weighted_vuf/pinkas/mod.rs (L316-335)
```rust
    pub fn rk_multiexps(
        proof: &Vec<(Player, G2Projective)>,
        rks: Vec<&Vec<G1Projective>>,
        lagr: &Vec<Scalar>,
        ranges: &Vec<Range<usize>>,
        thread_pool: &ThreadPool,
    ) -> Vec<G1Projective> {
        thread_pool.install(|| {
            proof
                .par_iter()
                .with_min_len(MIN_MULTIEXP_NUM_JOBS)
                .enumerate()
                .map(|(idx, _)| {
                    let rks = rks[idx];
                    let lagr = &lagr[ranges[idx].clone()];
                    g1_multi_exp(rks, lagr)
                })
                .collect::<Vec<G1Projective>>()
        })
    }
```

**File:** crates/aptos-dkg/src/utils/mod.rs (L58-72)
```rust
pub fn g1_multi_exp(bases: &[G1Projective], scalars: &[blstrs::Scalar]) -> G1Projective {
    if bases.len() != scalars.len() {
        panic!(
            "blstrs's multiexp has heisenbugs when the # of bases != # of scalars ({} != {})",
            bases.len(),
            scalars.len()
        );
    }

    match bases.len() {
        0 => G1Projective::identity(),
        1 => bases[0].mul(scalars[0]),
        _ => G1Projective::multi_exp(bases, scalars),
    }
}
```

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L279-283)
```rust
                let targets = epoch_state
                    .verifier
                    .get_ordered_account_addresses_iter()
                    .filter(|author| !existing_shares.contains(author))
                    .collect::<Vec<_>>();
```
