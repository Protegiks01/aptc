# Audit Report

## Title
Idempotency Violation in set_state_checkpoint_output() Prevents Valid Retry Attempts

## Summary
The `set_state_checkpoint_output()` function uses a non-idempotent `OnceCell::set()` operation that panics on subsequent calls. While the code includes an early-return guard to prevent retries when the complete result exists, this guard is insufficient for partial failure scenarios where only `state_checkpoint_output` is set but not `ledger_update_output`. This design prevents valid retry attempts and can cause validator node crashes.

## Finding Description
The `PartialStateComputeResult` struct stores checkpoint outputs in `OnceCell` fields that can only be set once: [1](#0-0) 

The `OnceCell::set()` method returns an error if the cell is already filled, and calling `.expect()` converts this to a panic with message "StateCheckpointOutput already set".

The `ledger_update()` method in BlockExecutor has an incomplete retry guard: [2](#0-1) 

This guard only protects against retries when BOTH outputs are set (checked via `get_complete_result()`): [3](#0-2) 

The guard fails in partial failure scenarios. The actual setting operations occur in adjacent lines: [4](#0-3) 

Blocks are stored in a BlockTree with their `PartialStateComputeResult`: [5](#0-4) 

When `ledger_update()` retrieves a block via `get_blocks_opt()`, it gets the SAME `PartialStateComputeResult` object, not a new instance.

## Impact Explanation
This issue causes **High Severity** impact under the Aptos bug bounty criteria:

1. **Validator Node Crashes**: If a partial failure occurs and the system attempts retry, the panic crashes the validator node
2. **Loss of Liveness**: Affected validators cannot participate in consensus until manually restarted
3. **Potential Network Impact**: If multiple validators hit this condition during critical operations (e.g., epoch transitions), it could affect network liveness

However, the actual exploitability is **LIMITED** because:
- The code comments indicate retries are "not expected" 
- No explicit retry loops were found in the consensus pipeline
- An unprivileged attacker cannot directly force this condition

## Likelihood Explanation
**Likelihood: Low to Medium**

The vulnerability requires:
1. A failure occurring after `set_state_checkpoint_output()` succeeds but before `set_ledger_update_output()` completes
2. The system attempting to retry `ledger_update()` on the same block

While the code has fail points for testing: [6](#0-5) 

This fail point is positioned BEFORE both set calls, so it doesn't trigger the vulnerability. Real-world triggers would require:
- Resource exhaustion (OOM) occurring at the exact moment between the two calls
- A panic in `DoLedgerUpdate::run()` after state checkpoint succeeds
- Future code changes introducing retry logic without awareness of this limitation

## Recommendation
Make the setter methods idempotent by using `OnceCell::get_or_init()` or checking if already set:

```rust
pub fn set_state_checkpoint_output(&self, state_checkpoint_output: StateCheckpointOutput) {
    // Idempotent: only set if not already set
    let _ = self.state_checkpoint_output.set(state_checkpoint_output);
}
```

Or implement proper retry detection:

```rust
pub fn set_state_checkpoint_output(&self, state_checkpoint_output: StateCheckpointOutput) {
    if let Err(existing) = self.state_checkpoint_output.set(state_checkpoint_output) {
        // Already set - verify it matches (optional)
        warn!("StateCheckpointOutput already set, ignoring duplicate call");
    }
}
```

Alternatively, improve the retry guard to detect partial state: [2](#0-1) 

Add a check for partial state and handle it appropriately.

## Proof of Concept

```rust
#[test]
fn test_idempotency_violation() {
    use crate::types::partial_state_compute_result::PartialStateComputeResult;
    use aptos_executor_types::execution_output::ExecutionOutput;
    use aptos_storage_interface::LedgerSummary;
    
    // Create a PartialStateComputeResult
    let ledger_summary = LedgerSummary::default(); // Mock summary
    let execution_output = ExecutionOutput::new_empty(ledger_summary.state);
    let result = PartialStateComputeResult::new(execution_output);
    
    // Create mock state checkpoint output
    let checkpoint_output = StateCheckpointOutput::new_empty(ledger_summary.state_summary);
    
    // First call succeeds
    result.set_state_checkpoint_output(checkpoint_output.clone());
    
    // Second call with same data panics - demonstrates non-idempotency
    // This would panic: result.set_state_checkpoint_output(checkpoint_output);
    // Expected: "StateCheckpointOutput already set"
}
```

**Notes:**
While this represents a genuine design limitation that violates idempotency principles, the practical exploitability is limited by the absence of retry logic in the current codebase. The TODO comments suggest developers are aware of this limitation. This is more of a robustness/defensive programming issue than an actively exploitable vulnerability by external attackers, though it could cause operational issues under rare failure conditions or if future changes introduce retry logic.

### Citations

**File:** execution/executor/src/types/partial_state_compute_result.rs (L76-80)
```rust
    pub fn set_state_checkpoint_output(&self, state_checkpoint_output: StateCheckpointOutput) {
        self.state_checkpoint_output
            .set(state_checkpoint_output)
            .expect("StateCheckpointOutput already set");
    }
```

**File:** execution/executor/src/types/partial_state_compute_result.rs (L94-105)
```rust
    pub fn get_complete_result(&self) -> Option<StateComputeResult> {
        self.ledger_update_output.get().map(|ledger_update_output| {
            StateComputeResult::new(
                self.execution_output.clone(),
                // ledger_update_output is set in a later stage, so it's safe to `expect` here.
                self.ensure_state_checkpoint_output()
                    .expect("StateCheckpointOutput missing.")
                    .clone(),
                ledger_update_output.clone(),
            )
        })
    }
```

**File:** execution/executor/src/block_executor/mod.rs (L290-294)
```rust
        // TODO(aldenhu): remove, assuming no retries.
        if let Some(complete_result) = block.output.get_complete_result() {
            info!(block_id = block_id, "ledger_update already done.");
            return Ok(complete_result);
        }
```

**File:** execution/executor/src/block_executor/mod.rs (L311-314)
```rust
                // TODO(aldenhu): remove? no known strategy to recover from this failure
                fail_point!("executor::block_state_checkpoint", |_| {
                    Err(anyhow::anyhow!("Injected error in block state checkpoint."))
                });
```

**File:** execution/executor/src/block_executor/mod.rs (L315-328)
```rust
                output.set_state_checkpoint_output(DoStateCheckpoint::run(
                    &output.execution_output,
                    parent_block.output.ensure_result_state_summary()?,
                    &ProvableStateSummary::new_persisted(self.db.reader.as_ref())?,
                    None,
                )?);
                output.set_ledger_update_output(DoLedgerUpdate::run(
                    &output.execution_output,
                    output.ensure_state_checkpoint_output()?,
                    parent_out
                        .ensure_ledger_update_output()?
                        .transaction_accumulator
                        .clone(),
                )?);
```

**File:** execution/executor/src/block_executor/block_tree/mod.rs (L27-32)
```rust
pub struct Block {
    pub id: HashValue,
    pub output: PartialStateComputeResult,
    children: Mutex<Vec<Arc<Block>>>,
    block_lookup: Arc<BlockLookup>,
}
```
