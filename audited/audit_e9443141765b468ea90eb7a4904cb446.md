# Audit Report

## Title
Profile Account Confusion in Resource Account Creation Leads to Package Deployment at Unexpected Address

## Summary
The `CreateResourceAccountAndPublishPackage::execute()` function derives the resource account address from the profile's account field, but the transaction is signed and submitted using a potentially different account obtained from `TransactionOptions`. This mismatch causes the package to be deployed to a different resource account address than the user expects, breaking deterministic execution and potentially resulting in loss of deployed code.

## Finding Description

The vulnerability exists in the resource account creation flow where two different account sources are used without validation: [1](#0-0) 

The CLI extracts the account from the profile configuration and uses it to calculate the expected resource account address. However, when the transaction is submitted: [2](#0-1) 

This calls `submit_transaction()` which obtains the transaction signer from a different source: [3](#0-2) 

The `get_public_key_and_address()` method can return a different account if the user provides `--private-key`, `--private-key-file`, or `--sender-account` flags: [4](#0-3) [5](#0-4) 

The on-chain Move function derives the resource account address from the transaction signer: [6](#0-5) [7](#0-6) 

**Attack Scenario:**
1. User has profile with `account = 0xAAAA`
2. User runs: `aptos move create-resource-account-and-publish-package --seed myseed --private-key <key_for_0xBBBB> --assume-yes`
3. CLI calculates resource address as `create_resource_address(0xAAAA, "myseed")` → shows address `0xRRRR` to user
4. Transaction is signed by `0xBBBB` (from `--private-key`)
5. On-chain execution creates resource account at `create_resource_address(0xBBBB, "myseed")` → actual address `0xSSS`
6. Package is deployed to `0xSSS`, not `0xRRRR` as user expected

## Impact Explanation

**Medium Severity** - This vulnerability causes:

1. **Package deployed to unexpected address**: The user believes their package is at one address but it's actually at another, potentially losing track of their deployed code
2. **State inconsistency**: The CLI's calculated address doesn't match the actual on-chain deployment address
3. **Access control violation**: If different accounts are used, the package ownership and signer capabilities are stored under the wrong origin account
4. **Potential fund loss**: Resources or capabilities tied to the expected address become inaccessible

This meets the Medium severity criteria of "State inconsistencies requiring intervention" and "Limited funds loss or manipulation" as the deployed package may become lost or inaccessible to the user.

## Likelihood Explanation

**High Likelihood** - This vulnerability is easily triggered when:
- User has a configured profile with an account field
- User provides `--private-key` or `--private-key-file` flag with a key for a different account than the profile (common in multi-account setups)
- User uses `--assume-yes` to skip confirmation prompts (common in automation/scripts)
- No validation exists to ensure profile account matches transaction signer

The vulnerability is particularly dangerous because:
- The error handling at lines 1890-1901 only checks if the profile account EXISTS, not if it MATCHES the transaction signer
- Users commonly use `--private-key` to override profile settings for testing or multi-account operations
- The confirmation prompt shows the wrong address, giving false confidence

## Recommendation

Add validation to ensure the profile account matches the transaction signing account before deriving the resource address:

```rust
async fn execute(self) -> CliTypedResult<TransactionSummary> {
    let CreateResourceAccountAndPublishPackage {
        address_name,
        mut move_options,
        txn_options,
        override_size_check_option,
        included_artifacts_args,
        seed_args,
    } = self;

    let account = if let Some(Some(account)) = CliConfig::load_profile(
        txn_options.profile_options.profile_name(),
        ConfigSearchMode::CurrentDirAndParents,
    )?
    .map(|p| p.account)
    {
        account
    } else {
        return Err(CliError::CommandArgumentError(
            "Please provide an account using --profile or run aptos init".to_string(),
        ));
    };
    
    // ADD VALIDATION: Ensure transaction signer matches profile account
    let (_, signer_address) = txn_options.get_public_key_and_address()?;
    if account != signer_address {
        return Err(CliError::CommandArgumentError(
            format!(
                "Profile account ({}) does not match transaction signing account ({}). \
                The resource account address is derived from the profile account, but the \
                transaction will be signed by a different account. Please ensure --private-key, \
                --private-key-file, or --sender-account matches the profile account.",
                account, signer_address
            )
        ));
    }
    
    let seed = seed_args.seed()?;
    let resource_address = create_resource_address(account, &seed);
    // ... rest of function
}
```

## Proof of Concept

**Setup:**
1. Create two accounts with different addresses
2. Configure profile with account A: `aptos init --profile test --private-key <key_A>`
3. Note the account address from profile

**Exploitation:**
```bash
# Create a Move package
mkdir test_package && cd test_package
aptos move init --name TestPackage

# Attempt to create resource account using profile account A but signing with key B
aptos move create-resource-account-and-publish-package \
  --profile test \
  --private-key <key_B_for_different_account> \
  --seed "test_seed" \
  --address-name test_resource \
  --assume-yes

# Observe:
# 1. CLI shows resource address derived from account A
# 2. Transaction succeeds but package is deployed to resource address derived from account B
# 3. User cannot find package at expected address
# 4. Signer capability stored in account B's Container, not account A's
```

**Verification:**
```bash
# Check the actual deployment address (will be different from displayed)
# Query account B's Container resource to find the actual resource account address
aptos account list --account <account_B_address>
```

The package will be deployed to a resource address derived from account B (the transaction signer), not account A (the profile account), demonstrating the address confusion vulnerability.

**Notes**

The vulnerability stems from a fundamental design flaw where the CLI separates resource address derivation (using profile account) from transaction signing (using `TransactionOptions` which can source accounts from multiple places). The error handling at lines 1890-1901 validates profile account existence but not consistency with the transaction signer. This allows silent mismatches between expected and actual deployment addresses, particularly dangerous when combined with `--assume-yes` flag that bypasses confirmation prompts.

### Citations

**File:** crates/aptos/src/move_tool/mod.rs (L1890-1904)
```rust
        let account = if let Some(Some(account)) = CliConfig::load_profile(
            txn_options.profile_options.profile_name(),
            ConfigSearchMode::CurrentDirAndParents,
        )?
        .map(|p| p.account)
        {
            account
        } else {
            return Err(CliError::CommandArgumentError(
                "Please provide an account using --profile or run aptos init".to_string(),
            ));
        };
        let seed = seed_args.seed()?;

        let resource_address = create_resource_address(account, &seed);
```

**File:** crates/aptos/src/move_tool/mod.rs (L1938-1941)
```rust
        txn_options
            .submit_transaction(payload)
            .await
            .map(TransactionSummary::from)
```

**File:** crates/aptos/src/common/types.rs (L837-874)
```rust
    pub fn extract_ed25519_public_key_and_address(
        &self,
        encoding: EncodingType,
        profile: &ProfileOptions,
        maybe_address: Option<AccountAddress>,
    ) -> CliTypedResult<(Ed25519PublicKey, AccountAddress)> {
        // Order of operations
        // 1. CLI inputs
        // 2. Profile
        // 3. Derived
        if let Some(private_key) = self.extract_private_key_cli(encoding)? {
            // If we use the CLI inputs, then we should derive or use the address from the input
            if let Some(address) = maybe_address {
                Ok((private_key.public_key(), address))
            } else {
                let address = account_address_from_public_key(&private_key.public_key());
                Ok((private_key.public_key(), address))
            }
        } else if let Some((Some(public_key), maybe_config_address)) = CliConfig::load_profile(
            profile.profile_name(),
            ConfigSearchMode::CurrentDirAndParents,
        )?
        .map(|p| (p.public_key, p.account))
        {
            match (maybe_address, maybe_config_address) {
                (Some(address), _) => Ok((public_key, address)),
                (_, Some(address)) => Ok((public_key, address)),
                (None, None) => {
                    let address = account_address_from_public_key(&public_key);
                    Ok((public_key, address))
                },
            }
        } else {
            Err(CliError::CommandArgumentError(
                "One of ['--private-key', '--private-key-file'], or ['public_key'] must present in profile".to_string(),
            ))
        }
    }
```

**File:** crates/aptos/src/common/types.rs (L1867-1874)
```rust
    pub fn get_public_key_and_address(&self) -> CliTypedResult<(Ed25519PublicKey, AccountAddress)> {
        self.private_key_options
            .extract_ed25519_public_key_and_address(
                self.encoding_options.encoding,
                &self.profile_options,
                self.sender_account,
            )
    }
```

**File:** crates/aptos/src/common/types.rs (L1943-1943)
```rust
        let (sender_public_key, sender_address) = self.get_public_key_and_address()?;
```

**File:** aptos-move/framework/aptos-framework/sources/resource_account.move (L124-139)
```text
    public entry fun create_resource_account_and_publish_package(
        origin: &signer,
        seed: vector<u8>,
        metadata_serialized: vector<u8>,
        code: vector<vector<u8>>
    ) acquires Container {
        let (resource, resource_signer_cap) =
            account::create_resource_account(origin, seed);
        aptos_framework::code::publish_package_txn(&resource, metadata_serialized, code);
        rotate_account_authentication_key_and_store_capability(
            origin,
            resource,
            resource_signer_cap,
            ZERO_AUTH_KEY
        );
    }
```

**File:** aptos-move/framework/aptos-framework/sources/account/account.move (L1125-1126)
```text
    public fun create_resource_account(source: &signer, seed: vector<u8>): (signer, SignerCapability) acquires Account {
        let resource_addr = create_resource_address(&signer::address_of(source), seed);
```
