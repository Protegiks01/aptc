# Audit Report

## Title
Race Condition in Sharded Block Executor: Cross-Shard Messages to GLOBAL_ROUND_ID Can Cause Non-Deterministic Execution

## Summary
The sharded block executor's handling of cross-shard messages sent to `GLOBAL_ROUND_ID` contains a race condition that can cause non-deterministic execution and consensus failures. Messages from different rounds and shards targeting the same state key in the global round all flow through a single unbounded channel and overwrite the same `RemoteStateValue` entry, causing transactions to potentially read incorrect values depending on message arrival order.

## Finding Description

The sharded block executor uses a partitioning scheme where transactions are distributed across multiple shards and rounds, with a final "global round" for transactions that couldn't be partitioned. When transactions in regular rounds have dependencies pointing to the global round, they send cross-shard messages using `send_global_msg()`.

**The Race Condition:**

1. All messages to `GLOBAL_ROUND_ID` share a single channel (`global_message_tx`), regardless of which round or shard they originate from. [1](#0-0) 

2. The `CrossShardStateView` maintains one `RemoteStateValue` entry per state key, shared by all global round transactions that depend on that key. [2](#0-1) 

3. When `RemoteStateValue.set_value()` is called, it unconditionally overwrites the previous value without any versioning or validation. [3](#0-2) 

4. Different shards execute their rounds concurrently, so message ordering depends on execution timing rather than logical dependencies.

**Exploitation Scenario:**

Consider this dependency graph:
- Shard 0, Round 0: Transaction T0 writes state key `"X"` with value `"A"`
- Shard 1, Round 1: Transaction T1 writes state key `"X"` with value `"B"`
- Global Round: Transaction G0 depends on T0 (expects `"X" = "A"`)
- Global Round: Transaction G1 depends on T1 (expects `"X" = "B"`)

**Execution Flow:**

1. Global executor starts and creates `CrossShardStateView` with a single `RemoteStateValue` for state key `"X"`
2. Shards execute concurrently:
   - Shard 1 finishes Round 0 quickly and starts Round 1
   - Shard 1, Round 1 executes T1, sends message with `("X", "B")` to global channel
   - Message arrives first, sets `RemoteStateValue["X"] = "B"`
   - Shard 0 is still executing Round 0
   - Shard 0, Round 0 executes T0, sends message with `("X", "A")` to global channel
   - Message arrives second, **overwrites** `RemoteStateValue["X"] = "A"`

3. Global round execution:
   - G1 tries to read `"X"`, gets `"A"` instead of expected `"B"` ❌
   - G0 reads `"X"`, gets `"A"` ✓ (correct by accident)

The messages are sent based on the check at: [4](#0-3) 

The receiver processes messages without transaction-specific context: [5](#0-4) 

**Which Invariant is Broken:**

This violates the **Deterministic Execution** invariant: validators with identical blocks must produce identical state roots. The race condition introduces non-determinism because message arrival order depends on timing, not logical ordering.

## Impact Explanation

**IF this feature were enabled in production**, this would be **Critical Severity** under Aptos bug bounty criteria:

- **Consensus/Safety violations**: Different validators would execute the same block with different message orderings, producing different state roots
- **Non-recoverable network partition**: Validators would disagree on state and fail to reach consensus, potentially requiring a hard fork

However, there is **critical evidence that this feature is NOT currently used in production**: [6](#0-5) 

The comment explicitly states the sharded executor is "only for benchmark purpose right now."

## Likelihood Explanation

**Current Production Risk: ZERO** - The sharded executor appears to be experimental/benchmark-only code.

**If Enabled:** The race condition would occur naturally during concurrent execution whenever:
- Multiple rounds write to the same state key
- Both have dependencies to the global round  
- Different shards execute at different speeds

No active exploitation is required - this is an inherent design flaw that manifests during normal operation.

## Recommendation

**If this feature is to be enabled in production**, the following fixes are required:

1. **Add transaction-specific versioning to RemoteStateValue**: Include source transaction metadata (shard_id, round_id, txn_index) with each message and validate on receive.

2. **Use per-transaction channels**: Instead of one `RemoteStateValue` per state key, use one per `(state_key, source_txn_index)` pair.

3. **Enforce strict ordering**: Implement happens-before relationships to ensure messages from earlier rounds are processed before later rounds.

4. **Alternative: Redesign dependency model**: Restructure the global round to eliminate shared state keys between dependencies from different source transactions.

**Immediate Action:** Ensure this feature remains disabled in production consensus until the race condition is resolved.

## Proof of Concept

Due to the complexity of setting up a multi-shard concurrent execution environment, a full PoC would require:
1. Configuring `num_executor_shards > 1` 
2. Creating transactions that write to the same state keys across different rounds
3. Running with instrumentation to observe message arrival order
4. Demonstrating divergent state roots

A simplified Rust test demonstrating the core issue:

```rust
// Demonstrates that RemoteStateValue.set_value() unconditionally overwrites
#[test]
fn test_remote_state_value_overwrite_race() {
    use std::sync::Arc;
    use aptos_types::state_store::state_value::StateValue;
    
    let remote_value = Arc::new(RemoteStateValue::waiting());
    
    // Simulate message from Round 1 arriving first
    let rv_clone1 = remote_value.clone();
    std::thread::spawn(move || {
        std::thread::sleep(std::time::Duration::from_millis(10));
        rv_clone1.set_value(Some(StateValue::from("B".as_bytes().to_vec())));
    });
    
    // Simulate message from Round 0 arriving second
    let rv_clone2 = remote_value.clone();
    std::thread::spawn(move || {
        std::thread::sleep(std::time::Duration::from_millis(20));
        rv_clone2.set_value(Some(StateValue::from("A".as_bytes().to_vec())));
    });
    
    std::thread::sleep(std::time::Duration::from_millis(50));
    
    // Both transactions will see "A" (last write wins), even if one depended on "B"
    let final_value = remote_value.get_value();
    // This demonstrates the race - value depends on timing, not dependencies
}
```

---

**Note:** While this is a genuine bug in the codebase, it does **NOT** meet the criteria for a production bug bounty because the affected feature is explicitly marked as experimental/benchmark-only and does not appear to be enabled in production consensus.

### Citations

**File:** aptos-move/aptos-vm/src/sharded_block_executor/local_executor_shard.rs (L66-66)
```rust
        let (cross_shard_tx, cross_shard_rx) = unbounded();
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_state_view.rs (L62-67)
```rust
        let mut cross_shard_state_key = HashSet::new();
        for txn in transactions {
            for (_, storage_locations) in txn.cross_shard_dependencies.required_edges_iter() {
                for storage_location in storage_locations {
                    cross_shard_state_key.insert(storage_location.clone().into_state_key());
                }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/remote_state_value.rs (L22-27)
```rust
    pub fn set_value(&self, value: Option<StateValue>) {
        let (lock, cvar) = &*self.value_condition;
        let mut status = lock.lock().unwrap();
        *status = RemoteValueStatus::Ready(value);
        cvar.notify_all();
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L32-37)
```rust
            let msg = cross_shard_client.receive_cross_shard_msg(round);
            match msg {
                RemoteTxnWriteMsg(txn_commit_msg) => {
                    let (state_key, write_op) = txn_commit_msg.take();
                    cross_shard_state_view
                        .set_value(&state_key, write_op.and_then(|w| w.as_state_value()));
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L122-130)
```rust
                    if *round_id == GLOBAL_ROUND_ID {
                        self.cross_shard_client.send_global_msg(message);
                    } else {
                        self.cross_shard_client.send_cross_shard_msg(
                            *dependent_shard_id,
                            *round_id,
                            message,
                        );
                    }
```

**File:** types/src/block_executor/partitioner.rs (L449-454)
```rust
            ExecutableTransactions::Sharded(_) => {
                // Not supporting auxiliary info here because the sharded executor is only for
                // benchmark purpose right now.
                // TODO: Revisit when we need it.
                assert!(auxiliary_info.is_empty());
            },
```
