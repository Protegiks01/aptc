# Audit Report

## Title
Consensus Private Key Disclosure Through Verbose Serde_json Deserialization Error Messages

## Summary
The secure storage layer's error handling preserves and propagates verbose serde_json error messages that can contain hex-encoded cryptographic private keys. When storage data is corrupted or malformed, deserialization failures expose the full key material in error messages that are logged server-side and transmitted over the network to remote SafetyRules clients.

## Finding Description

The vulnerability exists in the secure storage deserialization error handling chain: [1](#0-0) 

When `serde_json::from_slice()` fails, the error is converted to the storage Error type: [2](#0-1) 

This conversion uses `format!("{}", error)` which preserves the complete serde_json error message, including any data that was being deserialized.

BLS12-381 private keys used for consensus are serialized as hex-encoded strings: [3](#0-2) 

The GetResponse structure wraps values with timestamps: [4](#0-3) 

When consensus keys are stored, the JSON representation includes the full hex-encoded private key (32 bytes = 64 hex characters):

```json
{
  "last_update": 1234567890,
  "value": "0x<64_hex_chars_of_private_key>"
}
```

If this data is corrupted, serde_json produces error messages like: `"invalid type: string \"0x<key_material>\", expected ..."` which exposes the private key.

The vulnerability propagates through the SafetyRules system: [5](#0-4) 

Storage errors become `SecureStorageUnexpectedError` containing the full serialization error message.

These errors are then logged and transmitted: [6](#0-5) 

Error responses are serialized and sent over the network: [7](#0-6) 

The Error enum is Serializable, meaning error messages containing private keys are transmitted to remote clients.

## Impact Explanation

This qualifies as **Medium Severity** per the Aptos bug bounty criteria: "Minor information leaks" that could escalate to consensus compromise.

**Impact:**
- **Direct disclosure:** Consensus private keys are exposed in error messages
- **Consensus risk:** If a validator's consensus key is leaked, an attacker can forge votes and signatures, potentially violating consensus safety
- **Cryptographic Correctness violation:** The invariant that "BLS signatures, VRF, and hash operations must be secure" is undermined when private keys leak

**Affected systems:**
- All storage implementations (InMemoryStorage, OnDiskStorage, VaultStorage) share this error handling
- SafetyRules remote services that transmit errors over the network
- Log aggregation systems that collect error logs

## Likelihood Explanation

**Likelihood: Medium-Low**

The vulnerability requires specific preconditions:
1. Storage data must be corrupted or malformed (filesystem access, software bugs, hardware failures)
2. Attacker must observe error messages via log access or network interception

**Realistic scenarios:**
- **Log aggregation attacks:** Error logs collected in centralized logging systems with weaker access controls
- **Passive network monitoring:** If SafetyRules runs remotely, network traffic can be passively captured
- **Post-compromise forensics:** After partial system compromise, old error logs reveal historical keys
- **Software bugs:** Other vulnerabilities that corrupt storage can trigger this leak

**Why it matters despite access requirements:**
- **Defense in depth:** Error messages should never leak secrets, regardless of attacker capabilities
- **Privilege escalation:** Log or network access is easier than storage access in many deployments
- **Passive attacks:** No active corruption needed if logs already contain past errors

## Recommendation

Implement sanitized error messages that never include sensitive data values:

```rust
impl From<serde_json::Error> for Error {
    fn from(error: serde_json::Error) -> Self {
        // Sanitize error message to remove potential data leakage
        let sanitized = match error.classify() {
            serde_json::error::Category::Io => "IO error during deserialization".to_string(),
            serde_json::error::Category::Syntax => format!("Syntax error at line {} column {}", 
                error.line(), error.column()),
            serde_json::error::Category::Data => "Invalid data structure".to_string(),
            serde_json::error::Category::Eof => "Unexpected end of input".to_string(),
        };
        Self::SerializationError(sanitized)
    }
}
```

Additional hardening:
1. Add `[serde(skip_serializing)]` to error fields containing sensitive data
2. Implement custom Debug/Display traits that redact sensitive information
3. Use structured logging with field-level controls to prevent key material in logs
4. Consider encrypting error messages when transmitted over the network

## Proof of Concept

```rust
#[cfg(test)]
mod test {
    use super::*;
    use aptos_crypto::bls12381::PrivateKey;
    use aptos_crypto::Uniform;
    
    #[test]
    fn test_key_leakage_in_error_messages() {
        let mut storage = InMemoryStorage::new();
        
        // Generate a test private key
        let private_key = PrivateKey::generate_for_testing();
        let key_hex = format!("0x{}", hex::encode(private_key.to_bytes()));
        
        // Store the key
        storage.set("consensus_key", private_key.clone()).unwrap();
        
        // Corrupt the stored data by modifying the JSON
        let corrupted_json = format!(
            r#"{{"last_update":123,"value":{}}}"#, 
            key_hex
        ).replace("0x", ""); // Remove 0x prefix to trigger type error
        
        storage.data.insert(
            "consensus_key".to_string(), 
            corrupted_json.as_bytes().to_vec()
        );
        
        // Attempt to retrieve the key - this triggers deserialization error
        let result = storage.get::<PrivateKey>("consensus_key");
        
        // The error message contains the key material!
        assert!(result.is_err());
        let error_msg = format!("{}", result.unwrap_err());
        
        // Verify that key bytes are present in error message
        // This demonstrates the vulnerability
        println!("Error leaked: {}", error_msg);
        assert!(error_msg.contains(&key_hex[2..10]), 
            "Error message should contain key material (this is the vulnerability!)");
    }
}
```

**Notes**

This vulnerability represents a defense-in-depth failure where error handling undermines cryptographic security. While exploitation requires specific access conditions, the principle that **error messages must never expose cryptographic key material** is absolute in security-critical systems. The SafetyRules component handles consensus-critical operations, and any information disclosure of consensus keys poses a direct threat to blockchain safety guarantees.

### Citations

**File:** secure/storage/src/in_memory.rs (L41-48)
```rust
    fn get<V: DeserializeOwned>(&self, key: &str) -> Result<GetResponse<V>, Error> {
        let response = self
            .data
            .get(key)
            .ok_or_else(|| Error::KeyNotSet(key.to_string()))?;

        serde_json::from_slice(response).map_err(|e| e.into())
    }
```

**File:** secure/storage/src/error.rs (L50-54)
```rust
impl From<serde_json::Error> for Error {
    fn from(error: serde_json::Error) -> Self {
        Self::SerializationError(format!("{}", error))
    }
}
```

**File:** crates/aptos-crypto/src/traits/mod.rs (L102-104)
```rust
    fn to_encoded_string(&self) -> Result<String> {
        Ok(format!("0x{}", ::hex::encode(self.to_bytes())))
    }
```

**File:** secure/storage/src/kv_storage.rs (L56-63)
```rust
#[derive(Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(tag = "data")]
pub struct GetResponse<T> {
    /// Time since Unix Epoch in seconds.
    pub last_update: u64,
    /// Value stored at the provided key
    pub value: T,
}
```

**File:** consensus/safety-rules/src/error.rs (L8-8)
```rust
#[derive(Clone, Debug, Deserialize, Error, PartialEq, Eq, Serialize)]
```

**File:** consensus/safety-rules/src/error.rs (L78-98)
```rust
impl From<aptos_secure_storage::Error> for Error {
    fn from(error: aptos_secure_storage::Error) -> Self {
        match error {
            aptos_secure_storage::Error::PermissionDenied => {
                // If a storage error is thrown that indicates a permission failure, we
                // want to panic immediately to alert an operator that something has gone
                // wrong. For example, this error is thrown when a storage (e.g., vault)
                // token has expired, so it makes sense to fail fast and require a token
                // renewal!
                panic!(
                    "A permission error was thrown: {:?}. Maybe the storage token needs to be renewed?",
                    error
                );
            },
            aptos_secure_storage::Error::KeyVersionNotFound(_, _)
            | aptos_secure_storage::Error::KeyNotSet(_) => {
                Self::SecureStorageMissingDataError(error.to_string())
            },
            _ => Self::SecureStorageUnexpectedError(error.to_string()),
        }
    }
```

**File:** consensus/safety-rules/src/remote_service.rs (L40-44)
```rust
    loop {
        if let Err(e) = process_one_message(&mut network_server, &mut serializer_service) {
            warn!("Failed to process message: {}", e);
        }
    }
```
