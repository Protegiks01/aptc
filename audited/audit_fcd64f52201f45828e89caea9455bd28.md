# Audit Report

## Title
Missing Inline Transaction Limit Validation in Consensus Config Sanitizer Allows Consensus Liveness Failures

## Summary
The `sanitize_send_recv_block_limits()` function only validates that `max_sending_block_txns` ≤ `max_receiving_block_txns` and `max_sending_block_bytes` ≤ `max_receiving_block_bytes`, but fails to validate the same constraint for `max_sending_inline_txns` and `max_sending_inline_bytes` against receiving limits. This allows validators to configure inline sending limits that exceed network receiving limits, causing their proposals to be rejected and breaking consensus liveness.

## Finding Description

The `ConsensusConfig` struct defines separate limits for inline transactions: [1](#0-0) 

However, the configuration sanitizer only validates two send/recv pairs: [2](#0-1) 

This validation **does not include** checks for `max_sending_inline_txns` vs `max_receiving_block_txns` or `max_sending_inline_bytes` vs `max_receiving_block_bytes`.

When a validator becomes the leader, inline transaction limits are used to pull payload: [3](#0-2) 

These inline limits are populated directly from the validator's config: [4](#0-3) 

When receiving validators process proposals, they count inline transactions as part of the total payload: [5](#0-4) 

The receiving validator then validates the total against `max_receiving_block_txns`: [6](#0-5) 

**Attack Scenario:**
A validator misconfigures (accidentally or through compromise):
- `max_sending_inline_txns = 15000`  
- `max_receiving_block_txns = 10000` (default)

When this validator becomes leader:
1. Proposal generator pulls up to 15,000 inline transactions
2. Other validators receive the proposal with 15,000 inline txns
3. Validation fails: `0 + 15000 > 10000`
4. All validators reject the proposal
5. Round times out, consensus stalls until new leader elected

## Impact Explanation

**High Severity** - This breaks the **Consensus Liveness** invariant. When a misconfigured validator becomes the proposer:

- Their proposals are systematically rejected by all other validators
- Consensus rounds fail and must timeout
- If multiple validators are misconfigured, network throughput degrades significantly
- In worst case with many misconfigured validators, consensus may stall completely

This qualifies as **High Severity** under Aptos bug bounty criteria: "Validator node slowdowns" and "Significant protocol violations."

## Likelihood Explanation

**Medium-to-Low Likelihood:**

While the vulnerability exists in the code, exploitation requires:
- Validator operator access to modify local config files
- Either accidental misconfiguration or compromised validator node
- Validator being elected as leader

Under the stated trust model where validator operators are trusted, this is primarily a defensive programming issue. However, it represents a critical gap in config validation that could manifest through:
- Human error during validator setup
- Automated config generation bugs  
- Compromised validator infrastructure

## Recommendation

Add validation for inline transaction limits in `sanitize_send_recv_block_limits()`:

```rust
fn sanitize_send_recv_block_limits(
    sanitizer_name: &str,
    config: &ConsensusConfig,
) -> Result<(), Error> {
    let send_recv_pairs = [
        (
            config.max_sending_block_txns,
            config.max_receiving_block_txns,
            "send < recv for txns",
        ),
        (
            config.max_sending_block_bytes,
            config.max_receiving_block_bytes,
            "send < recv for bytes",
        ),
        // ADD THESE TWO CHECKS:
        (
            config.max_sending_inline_txns,
            config.max_receiving_block_txns,
            "send < recv for inline_txns",
        ),
        (
            config.max_sending_inline_bytes,
            config.max_receiving_block_bytes,
            "send < recv for inline_bytes",
        ),
    ];
    for (send, recv, label) in &send_recv_pairs {
        if *send > *recv {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name.to_owned(),
                format!("Failed {}: {} > {}", label, *send, *recv),
            ));
        }
    }
    Ok(())
}
```

## Proof of Concept

```rust
#[test]
fn test_invalid_inline_txn_limits() {
    // Create a node config where max_sending_inline_txns exceeds max_receiving_block_txns
    let node_config = NodeConfig {
        consensus: ConsensusConfig {
            max_sending_inline_txns: 15000,
            max_receiving_block_txns: 10000,
            ..Default::default()
        },
        ..Default::default()
    };

    // Sanitize the config - this SHOULD fail but currently passes
    let result = ConsensusConfig::sanitize(
        &node_config,
        NodeType::Validator,
        Some(ChainId::testnet()),
    );
    
    // Currently this test would PASS (no error), demonstrating the vulnerability
    // After fix, this should return ConfigSanitizerFailed error
    assert!(result.is_err(), "Sanitizer should reject inline_txns > receiving limit");
}

#[test]
fn test_invalid_inline_bytes_limits() {
    // Create a node config where max_sending_inline_bytes exceeds max_receiving_block_bytes  
    let node_config = NodeConfig {
        consensus: ConsensusConfig {
            max_sending_inline_bytes: 10 * 1024 * 1024, // 10MB
            max_receiving_block_bytes: 6 * 1024 * 1024,  // 6MB
            ..Default::default()
        },
        ..Default::default()
    };

    let result = ConsensusConfig::sanitize(
        &node_config,
        NodeType::Validator,
        Some(ChainId::testnet()),
    );
    
    assert!(result.is_err(), "Sanitizer should reject inline_bytes > receiving limit");
}
```

## Notes

This vulnerability represents incomplete input validation rather than a logic error in consensus itself. The receiving validators correctly reject oversized blocks, but the sanitizer fails to prevent misconfiguration that leads to systematic proposal rejection. Adding the recommended checks ensures validators cannot accidentally or maliciously configure sending limits that exceed network receiving limits, protecting consensus liveness.

### Citations

**File:** config/src/config/consensus_config.rs (L39-40)
```rust
    pub max_sending_inline_txns: u64,
    pub max_sending_inline_bytes: u64,
```

**File:** config/src/config/consensus_config.rs (L419-430)
```rust
        let send_recv_pairs = [
            (
                config.max_sending_block_txns,
                config.max_receiving_block_txns,
                "send < recv for txns",
            ),
            (
                config.max_sending_block_bytes,
                config.max_receiving_block_bytes,
                "send < recv for bytes",
            ),
        ];
```

**File:** consensus/src/liveness/proposal_generator.rs (L661-661)
```rust
                    max_inline_txns: self.max_inline_txns,
```

**File:** consensus/src/epoch_manager.rs (L930-933)
```rust
            PayloadTxnsSize::new(
                self.config.max_sending_inline_txns,
                self.config.max_sending_inline_bytes,
            ),
```

**File:** consensus/consensus-types/src/common.rs (L292-299)
```rust
            Payload::QuorumStoreInlineHybrid(inline_batches, proof_with_data, _)
            | Payload::QuorumStoreInlineHybridV2(inline_batches, proof_with_data, _) => {
                proof_with_data.num_txns()
                    + inline_batches
                        .iter()
                        .map(|(_, txns)| txns.len())
                        .sum::<usize>()
            },
```

**File:** consensus/src/round_manager.rs (L1180-1185)
```rust
        ensure!(
            num_validator_txns + payload_len as u64 <= self.local_config.max_receiving_block_txns,
            "Payload len {} exceeds the limit {}",
            payload_len,
            self.local_config.max_receiving_block_txns,
        );
```
