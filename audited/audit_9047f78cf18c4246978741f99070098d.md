# Audit Report

## Title
Consensus Observer Complete Loss of Liveness When Execution Pool Is Enabled Due to Unimplemented Message Processing

## Summary
The consensus observer's `process_ordered_block_with_window_message()` function accepts and validates `OrderedBlockWithWindow` messages but then silently drops them without processing, causing complete loss of liveness when the execution pool feature is enabled. This breaks the consensus observer's ability to track blockchain state during epoch transitions when the execution pool window size changes.

## Finding Description

The consensus observer implements two message processing paths based on whether the execution pool feature is enabled:

1. **OrderedBlock messages** - Processed when `execution_pool_window_size` is `None`
2. **OrderedBlockWithWindow messages** - Should be processed when `execution_pool_window_size` is `Some(x)`

The execution pool window size is updated during epoch transitions based on on-chain consensus configuration. [1](#0-0) 

When execution pool is enabled, validators send `OrderedBlockWithWindow` messages. However, the observer's processing function contains only validation logic followed by a TODO comment with no actual block processing. [2](#0-1) 

Additionally, the window content verification is a no-op that always returns `Ok(())`. [3](#0-2) 

During epoch transitions, message type mismatches cause blocks to be rejected:
- When execution pool becomes enabled, `OrderedBlock` messages are rejected. [4](#0-3) 
- When execution pool is enabled, `OrderedBlockWithWindow` messages are accepted but dropped without processing.

**Exploitation Scenario:**

1. Epoch N operates with `execution_pool_window_size = None`
2. Consensus observers successfully process `OrderedBlock` messages
3. Epoch N+1 starts with `execution_pool_window_size = Some(10)` (via on-chain config change)
4. Observer's epoch state updates via `wait_for_epoch_start()` 
5. Validators begin sending `OrderedBlockWithWindow` messages
6. Observer accepts messages, performs validation (which is a no-op), then drops them
7. Observer cannot make any progress and accumulates no blocks
8. Observer eventually triggers state sync fallback after timeout
9. During this period, the observer has no view of current consensus state

## Impact Explanation

This qualifies as **High Severity** per Aptos bug bounty criteria:
- **Validator node slowdowns**: Consensus observers are forced into repeated state sync cycles instead of following real-time consensus
- **Significant protocol violations**: The consensus observer protocol breaks entirely when execution pool is enabled

While this doesn't directly cause fund loss or consensus safety violations, it completely disables the consensus observer functionality, which is critical for:
- Non-validator full nodes tracking consensus
- Backup/monitoring infrastructure
- Applications requiring real-time block data

The impact is systematic rather than exploitable - when the feature is enabled network-wide, ALL consensus observers fail simultaneously, creating a network-wide outage for observer nodes.

## Likelihood Explanation

**Likelihood: HIGH** - This will occur 100% of the time when execution pool feature is enabled via on-chain governance configuration changes. The issue is deterministic and not dependent on specific timing or race conditions.

The vulnerability manifests during:
1. Any epoch transition where execution pool window size changes from None to Some(x)
2. Continuous operation when execution pool is enabled (all blocks dropped)

There are no mitigating factors - the code path is always taken when the configuration condition is met.

## Recommendation

Implement the `process_ordered_block_with_window_message()` function to actually process blocks. The implementation should:

1. Complete the window content verification logic
2. Extract the ordered block and execution pool window from the message
3. Create an `ObservedOrderedBlock::OrderedWithWindow` variant
4. Follow the same processing flow as regular ordered blocks (check payloads, insert into stores, finalize)
5. Handle execution pool dependencies properly

Specifically:

- Implement `verify_window_contents()` to validate the block ID chain [3](#0-2) 
- Complete the message processing by calling similar logic to `process_ordered_block()` [2](#0-1) 
- Ensure the `ObservedOrderedBlock::OrderedWithWindow` variant is properly handled throughout the processing pipeline

## Proof of Concept

This can be demonstrated by:

1. Configuring a consensus observer node in a test network
2. Enabling execution pool via on-chain configuration (setting `window_size` > 0)
3. Observing that the consensus observer:
   - Receives `OrderedBlockWithWindow` messages (metrics show received messages)
   - Never processes them (TODO at line 895 is reached)
   - Falls behind and enters state sync after progress check timeout
   - Logs show dropped messages with updated metrics but no block progression

The TODO comments themselves serve as evidence that this code path is incomplete:
- Processing TODO [2](#0-1) 
- Verification TODO [5](#0-4) 
- Struct design TODO [6](#0-5) 

A Rust integration test would show that when `execution_pool_window_size.is_some()`, the observer's `get_last_ordered_block()` never advances beyond the epoch boundary, proving complete loss of liveness.

## Notes

This vulnerability represents an incomplete feature implementation rather than a traditional security exploit. However, it meets High severity criteria because enabling the execution pool feature through legitimate governance mechanisms causes complete failure of consensus observer functionality across the network. The issue is in production code (not test code) and would manifest immediately upon feature activation, making it a critical reliability and availability concern.

### Citations

**File:** consensus/src/consensus_observer/observer/epoch_state.rs (L101-101)
```rust
        self.execution_pool_window_size = consensus_config.window_size();
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L646-656)
```rust
        if self.get_execution_pool_window_size().is_some() {
            // Log the failure and update the invalid message counter
            warn!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Received ordered block message from peer: {:?}, but execution pool is enabled! Ignoring: {:?}",
                    peer_network_id, ordered_block.proof_block_info()
                ))
            );
            increment_invalid_message_counter(&peer_network_id, metrics::ORDERED_BLOCK_LABEL);
            return;
        }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L895-895)
```rust
        // TODO: process the ordered block with window message (instead of just dropping it!)
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L315-315)
```rust
    // TODO: identify exactly what information is required here
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L330-332)
```rust
    pub fn verify_window_contents(&self, _expected_window_size: u64) -> Result<(), Error> {
        Ok(()) // TODO: Implement this method!
    }
```
