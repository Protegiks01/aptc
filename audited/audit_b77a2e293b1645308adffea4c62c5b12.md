# Audit Report

## Title
Path Injection Vulnerability in Node Configuration Loader Enables Denial of Service via Device File Reads

## Summary
The node configuration loading mechanism accepts arbitrary absolute paths in the `genesis_file_location` field without validation, allowing device files (e.g., `/dev/zero`, `/dev/random`) to be specified. When the node starts, it attempts to read the entire device into memory using `read_to_end()`, causing memory exhaustion and node crash. This can be exploited through supply chain attacks where operators use malicious configuration templates.

## Finding Description
The vulnerability exists across multiple components of the configuration loading system:

1. **No Path Validation in RootPath.full_path()**: The `RootPath::full_path()` method accepts absolute paths and returns them without any validation. [1](#0-0) 

2. **Unrestricted File Reading**: The `ExecutionConfig::load_from_path()` method opens files at the path specified in `genesis_file_location` and reads them completely into memory using `read_to_end()`. [2](#0-1) 

3. **No Sanitization of Paths**: The `ExecutionConfig::sanitize()` method only validates execution flags but does not check the `genesis_file_location` path for dangerous values. [3](#0-2) 

**Attack Scenario:**

An attacker creates a malicious node configuration YAML file:
```yaml
execution:
  genesis_file_location: /dev/zero
```

When a node operator uses this configuration (obtained from a compromised template repository, documentation, or third-party source):

1. The operator starts the node with `aptos-node --config malicious-config.yaml`
2. `NodeConfig::load_from_path()` is called [4](#0-3) 

3. The config loader reads the YAML and deserializes the `genesis_file_location: /dev/zero` field
4. `ExecutionConfig::load_from_path()` is invoked with the malicious path [5](#0-4) 

5. `RootPath::full_path()` returns `/dev/zero` as-is since it's absolute
6. `File::open()` successfully opens `/dev/zero`
7. `read_to_end()` attempts to read the infinite device stream into a `Vec<u8>`, causing:
   - Unbounded memory allocation
   - Memory exhaustion (OOM)
   - Node crash or system instability

Similar attacks work with `/dev/random`, `/dev/urandom`, or reading sensitive files like `/etc/shadow` (leading to information disclosure through error messages).

## Impact Explanation
This vulnerability meets **HIGH severity** criteria per the Aptos bug bounty program:

- **Validator node crashes**: Reading device files causes memory exhaustion and immediate node failure, meeting the "Validator node slowdowns" and "API crashes" criteria for HIGH severity
- **Network availability impact**: If multiple validators use compromised config templates, this could affect network liveness
- **No recovery without manual intervention**: Crashed nodes require operator intervention to fix the config and restart

The impact is NOT Critical because:
- It doesn't directly cause loss of funds or consensus violations
- It requires the operator to use a malicious config (supply chain attack)
- Recovery is possible through config correction and restart

## Likelihood Explanation
The likelihood is **MEDIUM to HIGH** because:

**Realistic Attack Vectors:**
1. **Supply chain attacks**: Operators frequently download config templates from GitHub repositories, documentation sites, or third-party sources that could be compromised
2. **Automated config generation**: Tools that generate configs from user input could be exploited if not properly validated
3. **Copy-paste from untrusted sources**: Operators may copy config snippets from forums or chat channels

**Attacker Requirements:**
- Ability to influence config templates used by operators (through compromised documentation, malicious packages, or social engineering)
- No direct system access required
- No validator privileges needed

**Historical Precedent:**
- Supply chain attacks targeting configuration files have succeeded in other blockchain ecosystems
- Operators often trust "official-looking" config templates without thorough review

## Recommendation
Implement strict path validation at multiple layers:

1. **Add Path Validation in RootPath.full_path()**:
```rust
pub fn full_path(&self, file_path: &Path) -> Result<PathBuf, Error> {
    // Reject absolute paths outside the root
    if file_path.is_absolute() {
        return Err(Error::InvalidConfig(
            "Absolute paths are not allowed in configuration files. Use relative paths instead.".to_string()
        ));
    }
    
    // Resolve the full path
    let full_path = self.root_path.join(file_path);
    
    // Canonicalize to resolve symlinks and check it's within root
    let canonical_path = full_path.canonicalize()
        .map_err(|e| Error::InvalidConfig(format!("Invalid path: {:?}", e)))?;
    let canonical_root = self.root_path.canonicalize()
        .map_err(|e| Error::InvalidConfig(format!("Invalid root: {:?}", e)))?;
    
    if !canonical_path.starts_with(&canonical_root) {
        return Err(Error::InvalidConfig(
            "Path traversal detected: path escapes root directory".to_string()
        ));
    }
    
    Ok(full_path)
}
```

2. **Add Validation in ExecutionConfig::sanitize()**:
```rust
impl ConfigSanitizer for ExecutionConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let execution_config = &node_config.execution;
        
        // Validate genesis_file_location is not a device file or absolute path
        let genesis_path = &execution_config.genesis_file_location;
        if genesis_path.is_absolute() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name.clone(),
                format!("genesis_file_location must not be an absolute path: {:?}", genesis_path)
            ));
        }
        
        // Check for device files
        if genesis_path.to_str().map(|s| s.starts_with("/dev/")).unwrap_or(false) {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name.clone(),
                "genesis_file_location must not point to device files".to_string()
            ));
        }
        
        // Existing mainnet validation...
        // ...
        
        Ok(())
    }
}
```

3. **Limit File Size During Read**:
```rust
const MAX_GENESIS_FILE_SIZE: usize = 100 * 1024 * 1024; // 100 MB

// In load_from_path()
let mut buffer = Vec::with_capacity(MAX_GENESIS_FILE_SIZE);
let bytes_read = file.take(MAX_GENESIS_FILE_SIZE as u64).read_to_end(&mut buffer)
    .map_err(|error| Error::Unexpected(format!("Failed to read genesis file: {:?}", error)))?;

if bytes_read == MAX_GENESIS_FILE_SIZE {
    return Err(Error::Unexpected("Genesis file exceeds maximum allowed size".to_string()));
}
```

## Proof of Concept

**Step 1**: Create a malicious config file `malicious-config.yaml`:
```yaml
base:
  role: validator
  
execution:
  genesis_file_location: /dev/zero
  
# ... other required config fields ...
```

**Step 2**: Start a node with this config:
```bash
aptos-node --config malicious-config.yaml
```

**Expected Result**: The node will hang or crash with OOM error as it attempts to read `/dev/zero` infinitely into memory.

**Rust Reproduction Test** (to be added to `config/src/config/execution_config.rs`):
```rust
#[test]
#[should_panic(expected = "Absolute paths are not allowed")]
fn test_reject_absolute_path_in_genesis_location() {
    let mut config = ExecutionConfig::default();
    config.genesis_file_location = PathBuf::from("/dev/zero");
    
    let root = RootPath::new_path(PathBuf::from("/tmp"));
    // This should panic or return error
    let result = config.load_from_path(&root);
    assert!(result.is_err());
}

#[test]
fn test_reject_device_files() {
    let device_paths = vec!["/dev/zero", "/dev/random", "/dev/null"];
    for path in device_paths {
        let mut config = ExecutionConfig::default();
        config.genesis_file_location = PathBuf::from(path);
        // Validation should catch this
        assert!(ConfigSanitizer::sanitize(&config, NodeType::Validator, None).is_err());
    }
}
```

**Notes**:
- This vulnerability affects all node types (validators, VFNs, PFNs) equally
- The same pattern may exist in other config loading paths (identity files, waypoint files) and should be audited
- While the immediate attack requires supplying a malicious config, supply chain attacks on config templates are a realistic threat in decentralized networks where operators source configs from various repositories and documentation sites

### Citations

**File:** config/src/config/utils.rs (L30-36)
```rust
    pub fn full_path(&self, file_path: &Path) -> PathBuf {
        if file_path.is_relative() {
            self.root_path.join(file_path)
        } else {
            file_path.to_path_buf()
        }
    }
```

**File:** config/src/config/execution_config.rs (L112-126)
```rust
            let mut file = File::open(&genesis_path).map_err(|error| {
                Error::Unexpected(format!(
                    "Failed to open the genesis file: {:?}. Error: {:?}",
                    genesis_path.display(),
                    error
                ))
            })?;
            let mut buffer = vec![];
            file.read_to_end(&mut buffer).map_err(|error| {
                Error::Unexpected(format!(
                    "Failed to read the genesis file into a buffer: {:?}. Error: {:?}",
                    genesis_path.display(),
                    error
                ))
            })?;
```

**File:** config/src/config/execution_config.rs (L157-186)
```rust
impl ConfigSanitizer for ExecutionConfig {
    fn sanitize(
        node_config: &NodeConfig,
        _node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let execution_config = &node_config.execution;

        // If this is a mainnet node, ensure that additional verifiers are enabled
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() {
                if !execution_config.paranoid_hot_potato_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_hot_potato_verification must be enabled for mainnet nodes!"
                            .into(),
                    ));
                }
                if !execution_config.paranoid_type_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_type_verification must be enabled for mainnet nodes!".into(),
                    ));
                }
            }
        }

        Ok(())
    }
```

**File:** config/src/config/node_config.rs (L140-143)
```rust
    pub fn load_from_path<P: AsRef<Path>>(input_path: P) -> Result<Self, Error> {
        let node_config_loader = NodeConfigLoader::new(input_path);
        node_config_loader.load_and_sanitize_config()
    }
```

**File:** config/src/config/node_config_loader.rs (L77-78)
```rust
        let input_dir = RootPath::new(&self.node_config_path);
        node_config.execution.load_from_path(&input_dir)?;
```
