# Audit Report

## Title
Unauthenticated Information Disclosure of Sensitive Validator Consensus State and Network Topology Through Metrics Endpoints

## Summary
The Aptos Inspection Service exposes `/metrics`, `/json_metrics`, and `/forge_metrics` endpoints without any authentication or access control checks, allowing any unauthenticated attacker to extract complete validator network topology (all validator peer IDs and voting power), real-time consensus state, validator performance metrics, and stress indicators that can be used to identify optimal attack timing against specific validators.

## Finding Description

The inspection service provides metrics endpoints that expose comprehensive consensus and validator information without authentication. While other sensitive endpoints (`/configuration`, `/identity_information`, `/peer_information`, `/system_information`) have configurable access control flags (`expose_configuration`, `expose_identity_information`, etc.), the metrics endpoints have no such protection.

The vulnerability manifests through three attack vectors:

**Attack Vector 1: Network Topology Extraction**

The `ALL_VALIDATORS_VOTING_POWER` metric exposes every validator's peer ID and voting power: [1](#0-0) 

This metric is populated for all validators in the current epoch: [2](#0-1) 

**Attack Vector 2: Validator Performance and Participation Tracking**

The `CONSENSUS_PARTICIPATION_STATUS` metric reveals which validators are actively participating versus offline/underperforming: [3](#0-2) 

This is updated with each validator's participation status by peer ID: [4](#0-3) 

Additional per-validator metrics expose:
- Last vote epoch and round for each peer: [5](#0-4) 
- Current round voting status by peer: [6](#0-5) 
- Failed proposals indicating performance issues: [7](#0-6) 

**Attack Vector 3: Timing Attack Enablement**

Metrics revealing validator stress and optimal attack windows:
- Consensus state (current round, committed version): [8](#0-7) 
- Backpressure and backoff triggers: [9](#0-8) 
- Proposal delays: [10](#0-9) 

**Root Cause: Missing Access Control**

The metrics endpoints are exposed without authentication checks. The `get_all_metrics()` function directly gathers all registered Prometheus metrics: [11](#0-10) 

These metrics are exposed through three endpoints that lack access control: [12](#0-11) 

The routing logic shows no authentication is required: [13](#0-12) 

Unlike the admin service which requires authentication on mainnet: [14](#0-13) 

The inspection service configuration lacks authentication capability and only has endpoint-specific flags that do NOT cover metrics: [15](#0-14) 

The inspection service always starts unconditionally on all nodes: [16](#0-15) 

## Impact Explanation

This vulnerability meets **HIGH severity** criteria per the Aptos Bug Bounty program for the following reasons:

1. **Enables Targeted Validator Attacks**: Attackers can identify which validators have high voting power, are experiencing performance issues (failed proposals, errors, nil votes), or are under stress (backpressure, delays), allowing them to target the most vulnerable nodes for eclipse attacks, DDoS, or exploitation attempts.

2. **Complete Network Topology Disclosure**: The full validator set with peer IDs and voting power is exposed, violating the security assumption that validator network topology should not be trivially enumerable by adversaries.

3. **Real-time Consensus State Tracking**: Attackers can monitor consensus progression (current round, committed version) to identify synchronization windows or consensus instability periods optimal for attack execution.

4. **Validator Performance Profiling**: Metrics like `FAILED_PROPOSALS_IN_WINDOW`, `ERROR_COUNT`, and `VOTE_NIL_COUNT` reveal which validators are underperforming, making them prime targets for reputation attacks or attempts to drive them offline.

5. **No Mitigation Available**: Unlike other sensitive endpoints that can be disabled via configuration flags, operators cannot disable metrics exposure without code modification, as the inspection service always starts and metrics endpoints have no access control.

While this is primarily an information disclosure vulnerability, it significantly increases the attack surface for **validator node slowdowns** and **significant protocol violations** by enabling reconnaissance that would otherwise require extensive network probing or insider knowledge.

## Likelihood Explanation

**Likelihood: HIGH**

The vulnerability is trivially exploitable:
- No authentication required
- Simple HTTP GET requests to `http://<validator-ip>:9101/metrics`
- Inspection service runs on port 9101 by default on all nodes
- No special tools or privileges needed
- Can be automated for continuous monitoring
- All mainnet validators are potentially affected

An attacker can:
1. Enumerate validator IP addresses from network discovery or blockchain data
2. Query `/metrics` endpoint on each validator
3. Parse Prometheus-format output to extract sensitive metrics
4. Build real-time dashboard tracking all validators' consensus state and performance
5. Identify optimal targets and timing for attacks

This can be executed in minutes with a simple script.

## Recommendation

**Immediate Fix**: Add access control flags for metrics endpoints similar to other sensitive endpoints.

1. **Add metrics exposure flag to InspectionServiceConfig**:
```rust
pub struct InspectionServiceConfig {
    pub address: String,
    pub port: u16,
    pub expose_configuration: bool,
    pub expose_identity_information: bool,
    pub expose_peer_information: bool,
    pub expose_system_information: bool,
    pub expose_metrics: bool,  // ADD THIS
}
```

2. **Update default to disable metrics on production**:
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
            expose_metrics: false,  // DISABLE BY DEFAULT
        }
    }
}
```

3. **Add access control checks to metrics handlers**:
```rust
pub fn handle_metrics_request(node_config: &NodeConfig) -> (StatusCode, Body, String) {
    if !node_config.inspection_service.expose_metrics {
        return (
            StatusCode::FORBIDDEN,
            Body::from("Metrics endpoint is disabled. Enable with inspection_service.expose_metrics: true"),
            CONTENT_TYPE_TEXT.into(),
        );
    }
    let buffer = utils::get_encoded_metrics(TextEncoder::new());
    (StatusCode::OK, Body::from(buffer), CONTENT_TYPE_TEXT.into())
}
```

4. **Add sanitizer to prevent mainnet validators from exposing metrics**:
```rust
// In InspectionServiceConfig::sanitize
if let Some(chain_id) = chain_id {
    if node_type.is_validator() && chain_id.is_mainnet() && inspection_service_config.expose_metrics {
        return Err(Error::ConfigSanitizerFailed(
            sanitizer_name,
            "Mainnet validators should not expose metrics publicly!".to_string(),
        ));
    }
}
```

**Long-term Fix**: Consider implementing authentication similar to AdminService, or moving sensitive consensus metrics to the authenticated admin service instead of the inspection service.

## Proof of Concept

```bash
#!/bin/bash
# PoC: Extract sensitive validator information from unauthenticated metrics endpoint

VALIDATOR_IP="<validator-node-ip>"
PORT="9101"

echo "=== Extracting Validator Network Topology ==="
curl -s "http://${VALIDATOR_IP}:${PORT}/metrics" | grep "aptos_all_validators_voting_power"

echo -e "\n=== Extracting Validator Participation Status ==="
curl -s "http://${VALIDATOR_IP}:${PORT}/metrics" | grep "aptos_consensus_participation_status"

echo -e "\n=== Extracting Consensus State ==="
curl -s "http://${VALIDATOR_IP}:${PORT}/metrics" | grep -E "(aptos_consensus_last_committed_round|aptos_consensus_current_round|aptos_consensus_last_committed_version)"

echo -e "\n=== Extracting Validator Performance Issues ==="
curl -s "http://${VALIDATOR_IP}:${PORT}/metrics" | grep -E "(aptos_failed_proposals_in_window|aptos_consensus_error_count|aptos_consensus_vote_nil_count)"

echo -e "\n=== Extracting Stress Indicators ==="
curl -s "http://${VALIDATOR_IP}:${PORT}/metrics" | grep -E "(aptos_chain_health_backoff_triggered|aptos_proposer_delay_proposal|consensus_withold_vote_backpressure_triggered)"

echo -e "\n=== Getting JSON Format for Easy Parsing ==="
curl -s "http://${VALIDATOR_IP}:${PORT}/json_metrics" | jq '
  {
    "total_validators": .aptos_chain_health_total_num_validators,
    "total_voting_power": .aptos_chain_health_total_voting_power,
    "current_round": .aptos_consensus_current_round,
    "committed_round": .aptos_consensus_last_committed_round,
    "validator_voting_powers": [.[] | select(. | tostring | startswith("aptos_all_validators_voting_power"))],
    "failed_proposals": .aptos_failed_proposals_in_window,
    "error_count": .aptos_consensus_error_count
  }
'
```

**Expected Result**: The script successfully retrieves all sensitive validator information without authentication, including:
- Complete list of validator peer IDs with voting power
- Which validators are actively participating
- Current consensus round and state
- Validator performance issues
- Network stress indicators

This information can be used to build a real-time monitoring dashboard of the entire validator network, identify vulnerable targets, and determine optimal attack timing.

### Citations

**File:** consensus/src/counters.rs (L78-103)
```rust
/// This counter is set to the round of the highest committed block.
pub static LAST_COMMITTED_ROUND: Lazy<IntGauge> = Lazy::new(|| {
    register_int_gauge!(
        "aptos_consensus_last_committed_round",
        "This counter is set to the round of the highest committed block."
    )
    .unwrap()
});

/// The counter corresponds to the round of the highest committed opt block.
pub static LAST_COMMITTED_OPT_BLOCK_ROUND: Lazy<IntGauge> = Lazy::new(|| {
    register_int_gauge!(
        "aptos_consensus_last_committed_opt_block_round",
        "The counter corresponds to the round of the highest committed opt block."
    )
    .unwrap()
});

/// The counter corresponds to the version of the last committed ledger info.
pub static LAST_COMMITTED_VERSION: Lazy<IntGauge> = Lazy::new(|| {
    register_int_gauge!(
        "aptos_consensus_last_committed_version",
        "The counter corresponds to the version of the last committed ledger info."
    )
    .unwrap()
});
```

**File:** consensus/src/counters.rs (L295-301)
```rust
pub static FAILED_PROPOSALS_IN_WINDOW: Lazy<IntGauge> = Lazy::new(|| {
    register_int_gauge!(
        "aptos_failed_proposals_in_window",
        "Total number of failed proposals in the current reputation window",
    )
    .unwrap()
});
```

**File:** consensus/src/counters.rs (L322-351)
```rust
pub static CONSENSUS_WITHOLD_VOTE_BACKPRESSURE_TRIGGERED: Lazy<Histogram> = Lazy::new(|| {
    register_avg_counter(
        "aptos_consensus_withold_vote_backpressure_triggered",
        "Counts when consensus vote_backpressure is triggered",
    )
});

/// Counts when chain_health backoff is triggered
pub static CHAIN_HEALTH_BACKOFF_TRIGGERED: Lazy<Histogram> = Lazy::new(|| {
    register_avg_counter(
        "aptos_chain_health_backoff_triggered",
        "Counts when chain_health backoff is triggered",
    )
});

/// Counts when waiting for full blocks is triggered
pub static WAIT_FOR_FULL_BLOCKS_TRIGGERED: Lazy<Histogram> = Lazy::new(|| {
    register_avg_counter(
        "aptos_wait_for_full_blocks_triggered",
        "Counts when waiting for full blocks is triggered",
    )
});

/// Counts when pipeline backpressure is triggered
pub static PIPELINE_BACKPRESSURE_ON_PROPOSAL_TRIGGERED: Lazy<Histogram> = Lazy::new(|| {
    register_avg_counter(
        "aptos_pipeline_backpressure_on_proposal_triggered",
        "Counts when pipeline backpressure is triggered",
    )
});
```

**File:** consensus/src/counters.rs (L381-386)
```rust
pub static PROPOSER_DELAY_PROPOSAL: Lazy<Histogram> = Lazy::new(|| {
    register_avg_counter(
        "aptos_proposer_delay_proposal",
        "Amount of time (in seconds) proposal is delayed due to backpressure/backoff",
    )
});
```

**File:** consensus/src/counters.rs (L519-526)
```rust
pub static CONSENSUS_PARTICIPATION_STATUS: Lazy<IntGaugeVec> = Lazy::new(|| {
    register_int_gauge_vec!(
        "aptos_consensus_participation_status",
        "Counter for consensus participation status, 0 means no participation and 1 otherwise",
        &["peer_id"]
    )
    .unwrap()
});
```

**File:** consensus/src/counters.rs (L538-545)
```rust
pub static ALL_VALIDATORS_VOTING_POWER: Lazy<IntGaugeVec> = Lazy::new(|| {
    register_int_gauge_vec!(
        "aptos_all_validators_voting_power",
        "Voting power for all validators in current epoch",
        &["peer_id"]
    )
    .unwrap()
});
```

**File:** consensus/src/counters.rs (L557-574)
```rust
pub static CONSENSUS_CURRENT_ROUND_VOTED_POWER: Lazy<GaugeVec> = Lazy::new(|| {
    register_gauge_vec!(
        "aptos_consensus_current_round_voted_power",
        "Counter for consensus participation status, 0 means no participation and 1 otherwise",
        &["peer_id", "hash_index"]
    )
    .unwrap()
});

/// For the current ordering round, for each peer, whether they have voted for a timeout
pub static CONSENSUS_CURRENT_ROUND_TIMEOUT_VOTED_POWER: Lazy<GaugeVec> = Lazy::new(|| {
    register_gauge_vec!(
        "aptos_consensus_current_round_timeout_voted_power",
        "Counter for consensus participation status, 0 means no participation and 1 otherwise",
        &["peer_id"]
    )
    .unwrap()
});
```

**File:** consensus/src/counters.rs (L577-594)
```rust
pub static CONSENSUS_LAST_VOTE_EPOCH: Lazy<IntGaugeVec> = Lazy::new(|| {
    register_int_gauge_vec!(
        "aptos_consensus_last_voted_epoch",
        "for each peer_id, last epoch we've seen consensus vote",
        &["peer_id"]
    )
    .unwrap()
});

/// Last vote seen for each of the peers
pub static CONSENSUS_LAST_VOTE_ROUND: Lazy<IntGaugeVec> = Lazy::new(|| {
    register_int_gauge_vec!(
        "aptos_consensus_last_voted_round",
        "for each peer_id, last round we've seen consensus vote",
        &["peer_id"]
    )
    .unwrap()
});
```

**File:** consensus/src/epoch_manager.rs (L790-797)
```rust
        epoch_state
            .verifier
            .get_ordered_account_addresses_iter()
            .for_each(|peer_id| {
                counters::ALL_VALIDATORS_VOTING_POWER
                    .with_label_values(&[&peer_id.to_string()])
                    .set(epoch_state.verifier.get_voting_power(&peer_id).unwrap_or(0) as i64)
            });
```

**File:** consensus/src/liveness/leader_reputation.rs (L647-657)
```rust
                    candidates.iter().for_each(|author| {
                        if participants.contains(author) {
                            CONSENSUS_PARTICIPATION_STATUS
                                .with_label_values(&[&author.to_hex()])
                                .set(1_i64)
                        } else {
                            CONSENSUS_PARTICIPATION_STATUS
                                .with_label_values(&[&author.to_hex()])
                                .set(0_i64)
                        }
                    });
```

**File:** crates/aptos-inspection-service/src/server/utils.rs (L25-29)
```rust
/// A simple utility function that returns all metrics as a HashMap
pub fn get_all_metrics() -> HashMap<String, String> {
    let metric_families = get_metric_families();
    get_metrics_map(metric_families)
}
```

**File:** crates/aptos-inspection-service/src/server/metrics.rs (L50-76)
```rust
/// Handles a new forge metrics request
pub fn handle_forge_metrics() -> (StatusCode, Body, String) {
    // Get and encode the metrics
    let metrics = utils::get_all_metrics();
    let encoded_metrics = match serde_json::to_string(&metrics) {
        Ok(encoded_metrics) => encoded_metrics,
        Err(error) => format!("Failed to get forge metrics! Error: {}", error),
    };

    (
        StatusCode::OK,
        Body::from(encoded_metrics),
        CONTENT_TYPE_JSON.into(),
    )
}

/// Handles a new metrics request (with JSON encoding)
pub fn handle_json_metrics_request() -> (StatusCode, Body, String) {
    let buffer = utils::get_encoded_metrics(JsonEncoder);
    (StatusCode::OK, Body::from(buffer), CONTENT_TYPE_JSON.into())
}

/// Handles a new metrics request (with text encoding)
pub fn handle_metrics_request() -> (StatusCode, Body, String) {
    let buffer = utils::get_encoded_metrics(TextEncoder::new());
    (StatusCode::OK, Body::from(buffer), CONTENT_TYPE_TEXT.into())
}
```

**File:** crates/aptos-inspection-service/src/server/mod.rs (L111-146)
```rust
    let (status_code, body, content_type) = match req.uri().path() {
        CONFIGURATION_PATH => {
            // /configuration
            // Exposes the node configuration
            configuration::handle_configuration_request(&node_config)
        },
        CONSENSUS_HEALTH_CHECK_PATH => {
            // /consensus_health_check
            // Exposes the consensus health check
            metrics::handle_consensus_health_check(&node_config).await
        },
        FORGE_METRICS_PATH => {
            // /forge_metrics
            // Exposes forge encoded metrics
            metrics::handle_forge_metrics()
        },
        IDENTITY_INFORMATION_PATH => {
            // /identity_information
            // Exposes the identity information of the node
            identity_information::handle_identity_information_request(&node_config)
        },
        INDEX_PATH => {
            // /
            // Exposes the index and list of available endpoints
            index::handle_index_request()
        },
        JSON_METRICS_PATH => {
            // /json_metrics
            // Exposes JSON encoded metrics
            metrics::handle_json_metrics_request()
        },
        METRICS_PATH => {
            // /metrics
            // Exposes text encoded metrics
            metrics::handle_metrics_request()
        },
```

**File:** config/src/config/admin_service_config.rs (L21-39)
```rust
    // If empty, will allow all requests without authentication. (Not allowed on mainnet.)
    pub authentication_configs: Vec<AuthenticationConfig>,
    pub malloc_stats_max_len: usize,
}

#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(rename_all = "snake_case")]
pub enum AuthenticationConfig {
    // This will allow authentication through query parameter.
    // e.g. `/profilez?passcode=abc`.
    //
    // To calculate sha256, use sha256sum tool, or other online tools.
    //
    // e.g.
    //
    // printf abc |sha256sum
    PasscodeSha256(String),
    // TODO(grao): Add SSL support if necessary.
}
```

**File:** config/src/config/inspection_service_config.rs (L15-37)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, Serialize)]
#[serde(default, deny_unknown_fields)]
pub struct InspectionServiceConfig {
    pub address: String,
    pub port: u16,
    pub expose_configuration: bool,
    pub expose_identity_information: bool,
    pub expose_peer_information: bool,
    pub expose_system_information: bool,
}

impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
}
```

**File:** aptos-node/src/lib.rs (L771-776)
```rust
    // Start the node inspection service
    services::start_node_inspection_service(
        &node_config,
        aptos_data_client,
        peers_and_metadata.clone(),
    );
```
