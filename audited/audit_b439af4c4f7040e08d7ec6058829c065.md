# Audit Report

## Title
Missing Cryptographic Verification in Epoch Ending Restore Allows Blockchain History Fabrication

## Summary
The epoch ending restore process in `preheat_impl()` fails to perform cryptographic verification (signature validation or trusted waypoint verification) for the first epoch in a restore batch when no trusted waypoints are configured. This allows an attacker controlling backup storage to inject arbitrary epoch endings with fabricated validator sets, completely compromising consensus security.

## Finding Description

The vulnerability exists in the verification logic for epoch ending ledger infos during backup restoration. The code has two paths for verification: [1](#0-0) 

The verification logic checks:
1. First, if a trusted waypoint exists at the ledger info's version (line 129)
2. Otherwise, if a previous ledger info exists to verify signatures (line 136)

However, the `trusted_waypoints` parameter is **optional** and can be empty: [2](#0-1) 

When a user performs a restore without providing trusted waypoints (using the default empty list), and for the first epoch in a restore batch where `previous_li` is initialized to `None`: [3](#0-2) 

**Neither verification path executes**, resulting in no cryptographic validation. The only checks that occur are:

1. Version check (line 108-111) - attacker sets version â‰¤ target_version
2. Epoch number match (line 113-118) - attacker sets expected epoch
3. Waypoint consistency between manifest and ledger info (line 119-128) - **both are attacker-controlled**

The waypoint is computed from the ledger info fields including version, epoch, and validator set: [4](#0-3) 

Since the attacker controls both the manifest (containing waypoints) and the ledger info chunks (containing the actual data), they can ensure these match while containing completely fabricated data. The malicious first epoch's `next_epoch_state` then becomes the trust anchor for verifying subsequent epochs, allowing the attacker to construct an entire fake blockchain history.

## Impact Explanation

**Critical Severity** - This vulnerability enables complete consensus compromise:

1. **Fabricated Validator Sets**: Attacker can create epoch endings with arbitrary validator sets under their control
2. **Consensus Safety Violation**: Nodes restored from malicious backups will accept blocks signed by fabricated validator sets, breaking the core BFT safety guarantee
3. **Complete History Fabrication**: Once the first epoch is accepted, all subsequent epochs can be "verified" against the attacker's fabricated validator set
4. **Persistent Compromise**: The malicious data is permanently saved to the database with no detection: [5](#0-4) 

This breaks the **Consensus Safety** invariant (AptosBFT must prevent chain splits) and the **Cryptographic Correctness** invariant (BLS signatures must be secure). The impact is equivalent to a complete consensus failure requiring a hard fork to recover.

## Likelihood Explanation

**High Likelihood**:

1. **Common Scenario**: Operators frequently perform backup restores during node recovery, disaster recovery, or new node setup
2. **Optional Security Feature**: Trusted waypoints are optional CLI parameters, and operators may not understand their critical security role
3. **Easy to Exploit**: Attacker only needs to control or compromise the backup storage (S3 bucket, cloud storage, etc.) - no validator access required
4. **No Warning**: The code provides no warning when restoring without trusted waypoints, giving operators false confidence

## Recommendation

**Mandatory Trusted Waypoint Validation**: The restore process must enforce that at least a genesis waypoint is provided, or fail if the first epoch cannot be cryptographically verified.

**Recommended Fix**:

```rust
// In preheat_impl(), after line 128:
if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
    ensure!(
        *wp_trusted == wp_li,
        "Waypoints don't match. In backup: {}, trusted: {}",
        wp_li,
        wp_trusted,
    );
} else if let Some(pre_li) = previous_li {
    pre_li
        .ledger_info()
        .next_epoch_state()
        .ok_or_else(|| {
            anyhow!(
                "Next epoch state not found from LI at epoch {}.",
                pre_li.ledger_info().epoch()
            )
        })?
        .verify(&li)?;
} else {
    // NEW: Fail if no verification method available
    return Err(anyhow!(
        "Cannot verify epoch {} at version {} - no trusted waypoint or previous epoch state available. \
        Please provide a trusted waypoint via --trust-waypoint for this epoch to proceed.",
        li.ledger_info().epoch(),
        li.ledger_info().version()
    ));
}
```

Additionally, document prominently that trusted waypoints are **required** for security, not optional.

## Proof of Concept

```rust
#[tokio::test]
async fn test_restore_without_trusted_waypoint_accepts_malicious_epoch() {
    use tempfile::TempDir;
    use std::sync::Arc;
    
    // Setup: Create a malicious backup with fabricated epoch 0
    let storage_dir = TempDir::new().unwrap();
    let backup_storage = Arc::new(LocalFs::new(storage_dir.path().to_path_buf()));
    
    // Create a completely fabricated LedgerInfoWithSignatures for epoch 0
    let malicious_validator_set = ValidatorSet::new(vec![/* attacker-controlled validators */]);
    let fake_epoch_state = EpochState::new(1, (&malicious_validator_set).into());
    
    let malicious_ledger_info = LedgerInfo::new(
        BlockInfo::new(
            0, // epoch
            0, // round
            HashValue::random(),
            HashValue::random(), 
            500, // version < some target version like 1000
            1000000, // timestamp
            Some(fake_epoch_state), // malicious validator set
        ),
        HashValue::zero(),
    );
    
    // Create fake signatures (won't be verified!)
    let malicious_li_with_sigs = LedgerInfoWithSignatures::new(
        malicious_ledger_info.clone(),
        AggregateSignature::empty(), // Invalid signatures!
    );
    
    // Compute waypoint from the malicious LI
    let malicious_waypoint = Waypoint::new_epoch_boundary(&malicious_ledger_info).unwrap();
    
    // Create manifest with the malicious waypoint
    let manifest = EpochEndingBackup {
        first_epoch: 0,
        last_epoch: 0,
        waypoints: vec![malicious_waypoint], // Attacker controls this
        chunks: vec![/* chunk containing malicious_li_with_sigs */],
    };
    
    // Write malicious backup to storage
    // ... (write manifest and chunks)
    
    // Restore WITHOUT trusted waypoints (empty HashMap)
    let global_opt = GlobalRestoreOptions {
        target_version: 1000,
        trusted_waypoints: Arc::new(HashMap::new()), // EMPTY - no verification!
        run_mode: Arc::new(RestoreRunMode::Verify),
        concurrent_downloads: 4,
        replay_concurrency_level: 4,
    };
    
    let controller = EpochEndingRestoreController::new(
        EpochEndingRestoreOpt { manifest_handle: manifest_handle },
        global_opt,
        backup_storage,
    );
    
    // This should FAIL but will SUCCEED - accepting completely fabricated epoch!
    let result = controller.run(None).await;
    
    // Assertion: The malicious epoch is accepted without any signature verification
    assert!(result.is_ok()); // This proves the vulnerability - should have failed!
    let restored_epochs = result.unwrap();
    assert_eq!(restored_epochs[0].epoch(), 0);
    // The epoch has invalid signatures but was accepted anyway!
}
```

**Notes**:
- This vulnerability only affects the backup restore process, not live consensus operation
- The attack requires control over backup storage but no validator privileges
- Impact is critical because it allows complete fabrication of blockchain state that persists in the database
- The fix is straightforward: require trusted waypoints or fail restoration when no verification method is available
- Operators should always provide at least a genesis waypoint when performing restores for security

### Citations

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L88-88)
```rust
        let mut previous_li: Option<&LedgerInfoWithSignatures> = None;
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L129-147)
```rust
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
                }
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L331-346)
```rust
#[derive(Clone, Default, Parser)]
pub struct TrustedWaypointOpt {
    #[clap(
        long,
        help = "(multiple) When provided, an epoch ending LedgerInfo at the waypoint version will be \
        checked against the hash in the waypoint, but signatures on it are NOT checked. \
        Use this for two purposes: \
        1. set the genesis or the latest waypoint to confirm the backup is compatible. \
        2. set waypoints at versions where writeset transactions were used to overwrite the \
        validator set, so that the signature check is skipped. \
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
    )]
    pub trust_waypoint: Vec<Waypoint>,
}
```

**File:** types/src/waypoint.rs (L129-147)
```rust
#[derive(Deserialize, Serialize, CryptoHasher, BCSCryptoHash)]
struct Ledger2WaypointConverter {
    epoch: u64,
    root_hash: HashValue,
    version: Version,
    timestamp_usecs: u64,
    next_epoch_state: Option<EpochState>,
}

impl Ledger2WaypointConverter {
    pub fn new(ledger_info: &LedgerInfo) -> Self {
        Self {
            epoch: ledger_info.epoch(),
            root_hash: ledger_info.transaction_accumulator_hash(),
            version: ledger_info.version(),
            timestamp_usecs: ledger_info.timestamp_usecs(),
            next_epoch_state: ledger_info.next_epoch_state().cloned(),
        }
    }
```

**File:** storage/aptosdb/src/backup/restore_utils.rs (L179-190)
```rust
fn save_ledger_infos_impl(
    ledger_metadata_db: &LedgerMetadataDb,
    ledger_infos: &[LedgerInfoWithSignatures],
    batch: &mut SchemaBatch,
) -> Result<()> {
    ledger_infos
        .iter()
        .map(|li| ledger_metadata_db.put_ledger_info(li, batch))
        .collect::<Result<Vec<_>>>()?;

    Ok(())
}
```
