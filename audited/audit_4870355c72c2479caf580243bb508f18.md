# Audit Report

## Title
Panic-Induced Validator Disruption via Mixed V1/V2 Batch Version Attack in Batch Coordinator

## Summary
A malicious validator can crash batch processing on victim validators by sending a `BatchMsg` containing mixed V1 and V2 batches. The `persist_and_send_digests()` function checks only the first batch's version to determine the processing path, causing a panic when attempting to convert V2 batches through the V1 conversion path.

## Finding Description

The vulnerability exists in the batch version handling logic within the `BatchCoordinator::persist_and_send_digests()` function. The code assumes all batches in a single message are version-homogeneous, but this assumption is never validated. [1](#0-0) 

The function checks only the first batch's version using `persist_requests[0].batch_info().is_v2()` at line 102. Based on this single check, it routes **all** batches through either the V2 path or V1 path. In the V1 path (lines 112-130), line 124 attempts to convert all signed batch infos using:

```rust
.map(|sbi| sbi.try_into().expect("Batch must be V1 batch"))
```

The `TryFrom` implementation for `SignedBatchInfo<BatchInfoExt>` to `SignedBatchInfo<BatchInfo>` enforces version validation: [2](#0-1) 

Lines 524-527 show the conversion will fail with error "Batch must be V1 type" if the batch is V2, causing the `expect()` to panic.

**Attack Path:**

1. A malicious validator crafts a `BatchMsg<BatchInfoExt>` containing:
   - First batch: V1 (`BatchInfoExt::V1`)
   - Subsequent batches: V2 (`BatchInfoExt::V2`)

2. The message passes verification because `BatchMsg::verify()` does not check version homogeneity: [3](#0-2) 

The verification only checks batch count limits, author validity, and individual batch integrity—not version consistency.

3. The message is routed to `BatchCoordinator::handle_batches_msg()` and converted to `persist_requests`: [4](#0-3) 

4. In `persist_and_send_digests()`, the spawned task (line 90) panics at line 124 when encountering the V2 batch, disrupting batch processing for the victim validator.

## Impact Explanation

This vulnerability qualifies as **HIGH severity** per Aptos bug bounty criteria:

- **Validator node slowdowns**: Repeated attacks force validators to continuously spawn and panic tasks, degrading performance and increasing latency
- **Significant protocol violations**: Batches from the malicious validator cannot be processed correctly, disrupting quorum store operations
- **Consensus disruption**: If enough validators are affected simultaneously, consensus liveness may be impacted

A single malicious validator (within the < 1/3 Byzantine threshold) can disrupt batch processing on all honest validators, affecting network-wide consensus operations without requiring collusion.

## Likelihood Explanation

**Likelihood: HIGH**

- **Attacker requirements**: Must be a validator in the current epoch
- **Complexity**: Trivial—requires only crafting a network message with mixed batch versions
- **Detection difficulty**: Hard to detect and attribute to specific malicious validator
- **Repeatability**: Attack can be repeated indefinitely to maintain disruption
- **No cryptographic breaks required**: Simple message format manipulation

Within the Byzantine fault tolerance model (< 1/3 malicious validators), this attack is highly feasible and requires minimal sophistication.

## Recommendation

Add version homogeneity validation in `BatchMsg::verify()` to reject messages with mixed batch versions:

```rust
pub fn verify(
    &self,
    peer_id: PeerId,
    max_num_batches: usize,
    verifier: &ValidatorVerifier,
) -> anyhow::Result<()> {
    ensure!(!self.batches.is_empty(), "Empty message");
    ensure!(
        self.batches.len() <= max_num_batches,
        "Too many batches: {} > {}",
        self.batches.len(),
        max_num_batches
    );
    
    // Add version homogeneity check
    if self.batches.len() > 1 {
        let first_is_v2 = self.batches[0].batch_info().is_v2();
        for batch in self.batches.iter().skip(1) {
            ensure!(
                batch.batch_info().is_v2() == first_is_v2,
                "Mixed batch versions in single message: expected all {}, got mixed",
                if first_is_v2 { "V2" } else { "V1" }
            );
        }
    }
    
    let epoch_authors = verifier.address_to_validator_index();
    for batch in self.batches.iter() {
        // ... rest of validation
    }
    Ok(())
}
```

Alternatively, handle mixed batches gracefully in `persist_and_send_digests()` by separating V1 and V2 batches before processing, though validation at the network boundary is preferable.

## Proof of Concept

```rust
#[cfg(test)]
mod test_mixed_batch_vulnerability {
    use super::*;
    use aptos_consensus_types::proof_of_store::{BatchInfoExt, BatchKind};
    use aptos_types::transaction::SignedTransaction;
    
    #[tokio::test]
    async fn test_mixed_v1_v2_batches_panic() {
        // Setup: Create batch coordinator with necessary dependencies
        let (tx, _rx) = tokio::sync::mpsc::channel(100);
        // ... initialize batch_coordinator with mocks ...
        
        // Craft malicious mixed batch message
        let v1_batch = Batch::new_v1(
            BatchId::new(1),
            vec![/* dummy transactions */],
            1, // epoch
            1000000, // expiration
            PeerId::random(),
            0, // gas_bucket_start
        );
        
        let v2_batch = Batch::new_v2(
            BatchId::new(2),
            vec![/* dummy transactions */],
            1, // epoch
            1000000, // expiration
            PeerId::random(),
            0, // gas_bucket_start
            BatchKind::Normal,
        );
        
        // Create message with V1 first, then V2 (triggers V1 path with V2 batch)
        let mixed_batches = vec![v1_batch, v2_batch];
        
        // This should cause a panic in the spawned task at line 124
        // when try_into().expect() fails on the V2 batch
        batch_coordinator.handle_batches_msg(author, mixed_batches).await;
        
        // The spawned task will panic with: "Batch must be V1 batch"
        // Note: In a real test, you'd need to capture the panic or observe
        // the task failure through metrics/logs
    }
}
```

## Notes

This vulnerability demonstrates a critical gap in input validation for consensus network messages. While normal operation ensures batch version homogeneity through configuration flags, the system must defend against Byzantine validators that can craft arbitrary messages. The lack of version consistency validation at the network boundary allows a single malicious validator to disrupt batch processing across the network, violating the Byzantine fault tolerance guarantees of the AptosBFT consensus protocol.

### Citations

**File:** consensus/src/quorum_store/batch_coordinator.rs (L102-130)
```rust
            if persist_requests[0].batch_info().is_v2() {
                let signed_batch_infos = batch_store.persist(persist_requests);
                if !signed_batch_infos.is_empty() {
                    if approx_created_ts_usecs > 0 {
                        observe_batch(approx_created_ts_usecs, peer_id, BatchStage::SIGNED);
                    }
                    network_sender
                        .send_signed_batch_info_msg_v2(signed_batch_infos, vec![peer_id])
                        .await;
                }
            } else {
                let signed_batch_infos = batch_store.persist(persist_requests);
                if !signed_batch_infos.is_empty() {
                    assert!(!signed_batch_infos
                        .first()
                        .expect("must not be empty")
                        .is_v2());
                    if approx_created_ts_usecs > 0 {
                        observe_batch(approx_created_ts_usecs, peer_id, BatchStage::SIGNED);
                    }
                    let signed_batch_infos = signed_batch_infos
                        .into_iter()
                        .map(|sbi| sbi.try_into().expect("Batch must be V1 batch"))
                        .collect();
                    network_sender
                        .send_signed_batch_info_msg(signed_batch_infos, vec![peer_id])
                        .await;
                }
            }
```

**File:** consensus/src/quorum_store/batch_coordinator.rs (L228-244)
```rust
        let mut persist_requests = vec![];
        for batch in batches.into_iter() {
            // TODO: maybe don't message batch generator if the persist is unsuccessful?
            if let Err(e) = self
                .sender_to_batch_generator
                .send(BatchGeneratorCommand::RemoteBatch(batch.clone()))
                .await
            {
                warn!("Failed to send batch to batch generator: {}", e);
            }
            persist_requests.push(batch.into());
        }
        counters::RECEIVED_BATCH_COUNT.inc_by(persist_requests.len() as u64);
        if author != self.my_peer_id {
            counters::RECEIVED_REMOTE_BATCH_COUNT.inc_by(persist_requests.len() as u64);
        }
        self.persist_and_send_digests(persist_requests, approx_created_ts_usecs);
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L520-539)
```rust
impl TryFrom<SignedBatchInfo<BatchInfoExt>> for SignedBatchInfo<BatchInfo> {
    type Error = anyhow::Error;

    fn try_from(signed_batch_info: SignedBatchInfo<BatchInfoExt>) -> Result<Self, Self::Error> {
        ensure!(
            matches!(signed_batch_info.batch_info(), &BatchInfoExt::V1 { .. }),
            "Batch must be V1 type"
        );
        let SignedBatchInfo {
            info,
            signer,
            signature,
        } = signed_batch_info;
        Ok(Self {
            info: info.unpack_info(),
            signer,
            signature,
        })
    }
}
```

**File:** consensus/src/quorum_store/types.rs (L433-461)
```rust
    pub fn verify(
        &self,
        peer_id: PeerId,
        max_num_batches: usize,
        verifier: &ValidatorVerifier,
    ) -> anyhow::Result<()> {
        ensure!(!self.batches.is_empty(), "Empty message");
        ensure!(
            self.batches.len() <= max_num_batches,
            "Too many batches: {} > {}",
            self.batches.len(),
            max_num_batches
        );
        let epoch_authors = verifier.address_to_validator_index();
        for batch in self.batches.iter() {
            ensure!(
                epoch_authors.contains_key(&batch.author()),
                "Invalid author {} for batch {} in current epoch",
                batch.author(),
                batch.digest()
            );
            ensure!(
                batch.author() == peer_id,
                "Batch author doesn't match sender"
            );
            batch.verify()?
        }
        Ok(())
    }
```
