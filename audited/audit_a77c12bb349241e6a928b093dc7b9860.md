# Audit Report

## Title
Transaction Filter Bypass via Encrypted Payload Inspection Failure

## Summary
The transaction filter system fails open when inspecting encrypted payloads, allowing attackers to bypass module address, entry function, and account address deny rules by submitting transactions with `EncryptedPayload` in the `Encrypted` or `FailedDecryption` state. This occurs because `executable_ref()` returns an error for non-decrypted payloads, causing matching functions to return `false`, which prevents deny rules from matching and allows transactions through by default.

## Finding Description

The transaction filter is designed to allow validators to block specific types of transactions based on various criteria (module addresses, entry functions, etc.). When processing encrypted transactions, the filter attempts to inspect the payload to determine if it matches configured rules. [1](#0-0) 

The vulnerability exists in `matches_entry_function_module_address()` (and similar functions like `matches_entry_function()` and `matches_script_argument_address()`). When handling `EncryptedPayload` variants, these functions call `payload.executable_ref()` which only succeeds when the payload is in the `Decrypted` state: [2](#0-1) 

The `EncryptedPayload` enum has three states: `Encrypted`, `FailedDecryption`, and `Decrypted`. For the first two states, `executable_ref()` returns an error with message "Transaction is encrypted". [3](#0-2) 

When `executable_ref()` fails, the matching functions return `false`, indicating the transaction doesn't match the filter criteria. In the filter logic, if no rules match, transactions are allowed by default: [4](#0-3) 

**Attack Path:**

1. Validator configures a deny rule for transactions calling module address `0x1` (e.g., governance or staking modules)
2. Attacker crafts a transaction with `EncryptedPayload` in `Encrypted` state that (when decrypted) will call module `0x1`
3. Transaction enters mempool where filters are applied: [5](#0-4) 

4. The filter evaluates the transaction but cannot inspect the encrypted payload
5. `matches_entry_function_module_address()` returns `false` (doesn't match module `0x1`)
6. Deny rule doesn't match; transaction is allowed by default
7. Transaction proceeds to consensus where it's decrypted: [6](#0-5) 

8. Decrypted transaction executes, calling the denied module `0x1`

## Impact Explanation

This is a **Critical Severity** vulnerability under the Aptos Bug Bounty program for the following reasons:

1. **Security Control Bypass**: Transaction filters are a critical security mechanism for validators to protect themselves from malicious or unwanted transactions. This vulnerability completely bypasses filters for encrypted transactions.

2. **Access Control Violation**: Validators may use filters to block access to sensitive system modules (governance, staking, system configuration). This bypass could allow unauthorized access to protected modules.

3. **Governance and Consensus Impact**: If filters are used to enforce governance policies or consensus-level restrictions, this bypass could lead to unauthorized state changes or protocol violations.

4. **Fail-Open Security Flaw**: The system fails open (allows by default) when unable to inspect a transaction, which is a fundamental security design flaw. Proper security systems should fail closed (deny by default) when unable to verify safety properties.

5. **Wide Attack Surface**: Affects multiple matcher types:
   - `ModuleAddress` matcher
   - `EntryFunction` matcher  
   - `AccountAddress` matcher (which uses both above)
   - Script argument matchers

## Likelihood Explanation

**Likelihood: HIGH**

1. **Easy to Execute**: Any transaction sender can create encrypted transactions in the `Encrypted` state. No special privileges required.

2. **No User Interaction**: Attack requires only submitting a transaction; no validator cooperation or complex setup needed.

3. **Deterministic**: The vulnerability is deterministic - encrypted payloads will always bypass filters that attempt to inspect their contents.

4. **Real-World Usage**: Transaction filters are likely used in production by validators for:
   - Blocking spam or resource-intensive modules
   - Enforcing local policies
   - Protection during upgrades or maintenance
   - Governance participation restrictions

5. **Detection Difficulty**: The bypass is silent - validators won't know their filters are being circumvented until after transactions execute.

## Recommendation

**Primary Fix: Fail-Closed for Uninspectable Payloads**

Modify the matching functions to explicitly handle encrypted payloads that cannot be inspected. The safest approach is to make uninspectable encrypted payloads match all deny rules (fail-closed):

```rust
TransactionPayload::EncryptedPayload(payload) => {
    if let Ok(executable) = payload.executable_ref() {
        match executable {
            TransactionExecutableRef::Script(_) | TransactionExecutableRef::Empty => false,
            TransactionExecutableRef::EntryFunction(entry_function) => {
                compare_entry_function_module_address(entry_function, module_address)
            },
        }
    } else {
        // SECURITY FIX: Cannot inspect encrypted payload
        // For deny rules, conservatively assume it matches (fail-closed)
        // For allow rules, this ensures encrypted payloads are blocked unless explicitly allowed
        true  // Changed from false to true
    }
},
```

**Alternative Solutions:**

1. **Decrypt Before Filtering**: Move filter application to after decryption in the consensus pipeline. However, this may have performance implications.

2. **Explicit Encrypted Transaction Handling**: Add configuration option requiring validators to explicitly allow/deny all encrypted transactions when filters are enabled:
   - If filters contain any deny rules, automatically add a deny rule for all encrypted transactions unless explicitly allowed
   - Document that encrypted transactions cannot be inspected and must be handled with blanket allow/deny rules

3. **Validation at Submission**: Reject encrypted transactions at submission time if filters are configured that would require inspecting payload contents.

**Recommended Approach:** Implement the fail-closed fix (#1) as it maintains backward compatibility while fixing the security flaw. Additionally, document this behavior and recommend validators explicitly configure encrypted transaction handling.

## Proof of Concept

```rust
#[test]
fn test_encrypted_payload_filter_bypass() {
    use aptos_types::{
        transaction::{
            SignedTransaction, TransactionPayload, RawTransaction,
            encrypted_payload::EncryptedPayload, TransactionExecutable, 
            EntryFunction, TransactionExtraConfig,
        },
        chain_id::ChainId,
        secret_sharing::Ciphertext,
    };
    use aptos_crypto::HashValue;
    use move_core_types::{
        account_address::AccountAddress,
        identifier::Identifier,
        language_storage::ModuleId,
    };
    
    // Create a deny rule for module address 0x1
    let restricted_module = AccountAddress::ONE;
    let filter = TransactionFilter::empty()
        .add_module_address_filter(false, restricted_module); // Deny transactions to 0x1
    
    // Create an encrypted transaction that (when decrypted) would call module 0x1
    // But at filter time, it's in Encrypted state
    let encrypted_payload = EncryptedPayload::Encrypted {
        ciphertext: Ciphertext::random(),
        extra_config: TransactionExtraConfig::V1 {
            multisig_address: None,
            replay_protection_nonce: None,
        },
        payload_hash: HashValue::random(),
    };
    
    let raw_txn = RawTransaction::new(
        AccountAddress::random(),
        0,
        TransactionPayload::EncryptedPayload(encrypted_payload),
        1000000,
        1,
        1000,
        ChainId::test(),
    );
    
    let signed_txn = SignedTransaction::new(
        raw_txn,
        Ed25519PublicKey::dummy(),
        Ed25519Signature::dummy_signature(),
    );
    
    // BUG: This should be denied because the transaction will call module 0x1
    // But the filter allows it because it cannot inspect the encrypted payload
    assert!(filter.allows_transaction(&signed_txn)); // PASSES - demonstrates bypass
    
    // For comparison: if we create the same transaction in Decrypted state
    let decrypted_payload = EncryptedPayload::Decrypted {
        ciphertext: Ciphertext::random(),
        extra_config: TransactionExtraConfig::V1 {
            multisig_address: None,
            replay_protection_nonce: None,
        },
        payload_hash: HashValue::random(),
        eval_proof: EvalProof::random(),
        executable: TransactionExecutable::EntryFunction(
            EntryFunction::new(
                ModuleId::new(restricted_module, Identifier::new("test").unwrap()),
                Identifier::new("func").unwrap(),
                vec![],
                vec![],
            )
        ),
        decryption_nonce: 0,
    };
    
    let raw_txn_decrypted = RawTransaction::new(
        AccountAddress::random(),
        0,
        TransactionPayload::EncryptedPayload(decrypted_payload),
        1000000,
        1,
        1000,
        ChainId::test(),
    );
    
    let signed_txn_decrypted = SignedTransaction::new(
        raw_txn_decrypted,
        Ed25519PublicKey::dummy(),
        Ed25519Signature::dummy_signature(),
    );
    
    // Correctly denied when decrypted
    assert!(!filter.allows_transaction(&signed_txn_decrypted)); // FAILS - correctly blocked
    
    // This demonstrates the vulnerability: the same logical transaction is treated
    // differently based on whether it's inspectable or not
}
```

## Notes

This vulnerability affects all transaction matching functions that attempt to inspect payload contents:
- `matches_entry_function_module_address()` 
- `matches_entry_function()`
- `matches_script_argument_address()`

The `AccountAddress` matcher is also affected as it uses `matches_entry_function_module_address()` internally. The fail-open behavior creates a fundamental security flaw where encrypted transactions can bypass critical access controls that validators rely on for protection.

### Citations

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L29-47)
```rust
    /// Returns true iff the filter allows the transaction
    pub fn allows_transaction(&self, signed_transaction: &SignedTransaction) -> bool {
        // If the filter is empty, allow the transaction by default
        if self.is_empty() {
            return true;
        }

        // Check if any rule matches the transaction
        for transaction_rule in &self.transaction_rules {
            if transaction_rule.matches(signed_transaction) {
                return match transaction_rule {
                    TransactionRule::Allow(_) => true,
                    TransactionRule::Deny(_) => false,
                };
            }
        }

        true // No rules match (allow the transaction by default)
    }
```

**File:** crates/aptos-transaction-filters/src/transaction_filter.rs (L378-417)
```rust
fn matches_entry_function_module_address(
    signed_transaction: &SignedTransaction,
    module_address: &AccountAddress,
) -> bool {
    // Match all variants explicitly to ensure future enum changes are caught during compilation
    match signed_transaction.payload() {
        TransactionPayload::Script(_) | TransactionPayload::ModuleBundle(_) => false,
        TransactionPayload::Multisig(multisig) => multisig
            .transaction_payload
            .as_ref()
            .map(|payload| match payload {
                MultisigTransactionPayload::EntryFunction(entry_function) => {
                    compare_entry_function_module_address(entry_function, module_address)
                },
            })
            .unwrap_or(false),
        TransactionPayload::EntryFunction(entry_function) => {
            compare_entry_function_module_address(entry_function, module_address)
        },
        TransactionPayload::Payload(TransactionPayloadInner::V1 { executable, .. }) => {
            match executable.as_ref() {
                TransactionExecutableRef::Script(_) | TransactionExecutableRef::Empty => false,
                TransactionExecutableRef::EntryFunction(entry_function) => {
                    compare_entry_function_module_address(entry_function, module_address)
                },
            }
        },
        TransactionPayload::EncryptedPayload(payload) => {
            if let Ok(executable) = payload.executable_ref() {
                match executable {
                    TransactionExecutableRef::Script(_) | TransactionExecutableRef::Empty => false,
                    TransactionExecutableRef::EntryFunction(entry_function) => {
                        compare_entry_function_module_address(entry_function, module_address)
                    },
                }
            } else {
                false
            }
        },
    }
```

**File:** types/src/transaction/encrypted_payload.rs (L41-64)
```rust
#[derive(Clone, Debug, Hash, Eq, PartialEq, Serialize, Deserialize)]
pub enum EncryptedPayload {
    Encrypted {
        ciphertext: Ciphertext,
        extra_config: TransactionExtraConfig,
        payload_hash: HashValue,
    },
    FailedDecryption {
        ciphertext: Ciphertext,
        extra_config: TransactionExtraConfig,
        payload_hash: HashValue,
        eval_proof: EvalProof,
    },
    Decrypted {
        ciphertext: Ciphertext,
        extra_config: TransactionExtraConfig,
        payload_hash: HashValue,
        eval_proof: EvalProof,

        // decrypted things
        executable: TransactionExecutable,
        decryption_nonce: u64,
    },
}
```

**File:** types/src/transaction/encrypted_payload.rs (L82-87)
```rust
    pub fn executable_ref(&self) -> Result<TransactionExecutableRef<'_>> {
        let Self::Decrypted { executable, .. } = self else {
            bail!("Transaction is encrypted");
        };
        Ok(executable.as_ref())
    }
```

**File:** mempool/src/shared_mempool/tasks.rs (L318-326)
```rust
    // Filter out any disallowed transactions
    let mut statuses = vec![];
    let transactions =
        filter_transactions(&smp.transaction_filter_config, transactions, &mut statuses);

    // If there are no transactions left after filtering, return early
    if transactions.is_empty() {
        return statuses;
    }
```

**File:** consensus/src/pipeline/decryption_pipeline_builder.rs (L121-148)
```rust
        let decrypted_txns = encrypted_txns
            .into_par_iter()
            .zip(txn_ciphertexts)
            .map(|(mut txn, ciphertext)| {
                let eval_proof = proofs.get(&ciphertext.id()).expect("must exist");
                if let Ok(payload) = FPTXWeighted::decrypt_individual::<DecryptedPayload>(
                    &decryption_key.key,
                    &ciphertext,
                    &digest,
                    &eval_proof,
                ) {
                    let (executable, nonce) = payload.unwrap();
                    txn.payload_mut()
                        .as_encrypted_payload_mut()
                        .map(|p| {
                            p.into_decrypted(eval_proof, executable, nonce)
                                .expect("must happen")
                        })
                        .expect("must exist");
                } else {
                    txn.payload_mut()
                        .as_encrypted_payload_mut()
                        .map(|p| p.into_failed_decryption(eval_proof).expect("must happen"))
                        .expect("must exist");
                }
                txn
            })
            .collect();
```
