# Audit Report

## Title
Consensus Split via OnChainConsensusConfig Deserialization Fallback Leading to Proposer Election Mismatch

## Summary
Validators running different code versions during epoch changes can elect different proposers due to inconsistent handling of OnChainConsensusConfig deserialization failures. When some validators fail to deserialize the on-chain config (e.g., due to unknown enum variants), they fall back to a hardcoded default with potentially different ProposerElectionType, causing a consensus split and complete network liveness failure.

## Finding Description

The vulnerability exists in the epoch change handling logic where OnChainConsensusConfig is fetched and applied. The critical flaw is in the error handling: [1](#0-0) 

When `payload.get::<OnChainConsensusConfig>()` fails (line 1178), the code uses `.unwrap_or_default()` (line 1201), which falls back to the Default implementation: [2](#0-1) 

This default returns a V4 config with `default_if_missing()` algorithm config: [3](#0-2) 

Which uses the hardcoded default proposer election type from ConsensusConfigV1::default(): [4](#0-3) 

**Attack Scenario:**

1. Network is running with a mix of validators on different code versions (old version knows V1-V4, new version knows V1-V5)
2. Governance updates the on-chain consensus config to V5 with a different proposer election type (e.g., RotatingProposer or LeaderReputation with different parameters)
3. During epoch change:
   - **Validators with new code**: Successfully deserialize V5 → Use the on-chain proposer election type
   - **Validators with old code**: BCS deserialization fails on unknown V5 variant → Fall back to default (LeaderReputation with hardcoded parameters)
4. For each round N:
   - New code validators elect proposer using V5 config's algorithm
   - Old code validators elect proposer using default LeaderReputation algorithm
   - **They elect DIFFERENT proposers**
5. Each group votes for their elected proposer's block
6. Neither block achieves 2f+1 votes → **Consensus halts**

The proposer election logic retrieves the election type here: [5](#0-4) 

And uses it to determine the proposer: [6](#0-5) 

The OnChainConsensusConfig::proposer_election_type() method delegates to the inner config: [7](#0-6) 

Different validators will have different inner configs (V5 vs Default V4), leading to different ProposerElectionType values being returned.

## Impact Explanation

**Severity: CRITICAL** (up to $1,000,000 per Aptos Bug Bounty)

This vulnerability causes **total loss of liveness/network availability**:

- Validators cannot reach consensus on any block when they elect different proposers
- No 2f+1 quorum can form for either proposer's block
- Network completely halts until manual intervention
- Requires hardfork or coordinated validator upgrades to recover
- All transaction processing stops, funds become temporarily inaccessible

This also constitutes a **Consensus Safety violation** as different validators follow divergent execution paths based on their interpretation of the same on-chain state.

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

This can occur during:
1. **Normal validator upgrades**: Validators upgrade gradually, creating a mixed-version network
2. **Config version updates**: When governance proposes new config versions (V5, future V6, etc.)
3. **Backward incompatibility**: BCS deserialization inherently fails on unknown enum variants

The compatibility test suite confirms validators can run different versions: [8](#0-7) 

No version enforcement prevents this scenario. The AptosVersion on-chain config is only a feature flag system, not a strict compatibility enforcement mechanism: [9](#0-8) 

## Recommendation

**Immediate Fix:** Fail-fast on config deserialization errors instead of silently falling back to default:

```rust
async fn start_new_epoch(&mut self, payload: OnChainConfigPayload<P>) {
    // ... existing code ...
    
    let onchain_consensus_config: anyhow::Result<OnChainConsensusConfig> = payload.get();
    
    // CRITICAL: Do NOT fall back to default on deserialization failure
    let consensus_config = match onchain_consensus_config {
        Ok(config) => config,
        Err(error) => {
            error!("FATAL: Failed to deserialize on-chain consensus config: {}", error);
            panic!("Cannot start epoch without valid consensus config. This indicates validator software is incompatible with current on-chain config version. Please upgrade validator software.");
        }
    };
    
    // ... rest of function ...
}
```

**Long-term Solutions:**

1. **Version-aware deserialization**: Add forward-compatibility handling that can gracefully handle unknown fields while preserving critical consensus parameters
2. **Consensus config validation**: Add on-chain checks that enforce minimum validator version before config updates
3. **Strict version enforcement**: Prevent validators from participating in consensus if they don't support the current config version
4. **Config migration path**: Provide explicit migration logic for config version upgrades with backward compatibility guarantees

## Proof of Concept

```rust
// Reproduction steps (Rust test):

#[test]
fn test_proposer_election_mismatch_on_config_version_mismatch() {
    use aptos_types::on_chain_config::{OnChainConsensusConfig, ProposerElectionType};
    
    // Scenario 1: Old validator code deserializes V4 config
    let v4_config = OnChainConsensusConfig::V4 {
        alg: ConsensusAlgorithmConfig::default_if_missing(),
        vtxn: ValidatorTxnConfig::default_if_missing(),
        window_size: None,
    };
    
    // Scenario 2: New validator deserializes V5 with RotatingProposer
    let v5_config = OnChainConsensusConfig::V5 {
        alg: ConsensusAlgorithmConfig::JolteonV2 {
            main: ConsensusConfigV1 {
                proposer_election_type: ProposerElectionType::RotatingProposer(1),
                ..Default::default()
            },
            quorum_store_enabled: true,
            order_vote_enabled: true,
        },
        vtxn: ValidatorTxnConfig::default_for_genesis(),
        window_size: None,
        rand_check_enabled: true,
    };
    
    // Get proposer election types
    let v4_election = v4_config.proposer_election_type();
    let v5_election = v5_config.proposer_election_type();
    
    // They are DIFFERENT!
    assert_ne!(
        std::mem::discriminant(v4_election),
        std::mem::discriminant(v5_election),
        "V4 default uses LeaderReputation, V5 uses RotatingProposer - validators will elect different proposers!"
    );
}

// Scenario demonstrating the deserialization failure:
#[test]
fn test_v5_deserialization_fails_on_old_code() {
    // Simulate old code that only knows V1-V4
    #[derive(Deserialize)]
    enum OldOnChainConsensusConfig {
        V1(ConsensusConfigV1),
        V2(ConsensusConfigV1),
        V3 { alg: ConsensusAlgorithmConfig, vtxn: ValidatorTxnConfig },
        V4 { alg: ConsensusAlgorithmConfig, vtxn: ValidatorTxnConfig, window_size: Option<u64> },
        // V5 not known!
    }
    
    // Create V5 config bytes
    let v5_config = OnChainConsensusConfig::V5 { /* ... */ };
    let v5_bytes = bcs::to_bytes(&v5_config).unwrap();
    
    // Old code tries to deserialize
    let result = bcs::from_bytes::<OldOnChainConsensusConfig>(&v5_bytes);
    
    // FAILS! Unknown variant
    assert!(result.is_err(), "Old code cannot deserialize V5 config");
}
```

**Notes:**

This vulnerability demonstrates a critical failure in consensus determinism. The issue arises from the fundamental tension between forward compatibility (allowing gradual validator upgrades) and consensus safety (requiring all validators to agree on proposer election). The current implementation silently degrades to a default config when deserialization fails, violating the invariant that all validators must execute identical consensus logic.

The fix must be fail-fast: if a validator cannot deserialize the on-chain config, it MUST NOT participate in consensus with potentially incorrect parameters. This prevents silent consensus splits while maintaining network safety.

### Citations

**File:** consensus/src/epoch_manager.rs (L286-407)
```rust
    /// Create a proposer election handler based on proposers
    fn create_proposer_election(
        &self,
        epoch_state: &EpochState,
        onchain_config: &OnChainConsensusConfig,
    ) -> Arc<dyn ProposerElection + Send + Sync> {
        let proposers = epoch_state
            .verifier
            .get_ordered_account_addresses_iter()
            .collect::<Vec<_>>();
        match &onchain_config.proposer_election_type() {
            ProposerElectionType::RotatingProposer(contiguous_rounds) => {
                Arc::new(RotatingProposer::new(proposers, *contiguous_rounds))
            },
            // We don't really have a fixed proposer!
            ProposerElectionType::FixedProposer(contiguous_rounds) => {
                let proposer = choose_leader(proposers);
                Arc::new(RotatingProposer::new(vec![proposer], *contiguous_rounds))
            },
            ProposerElectionType::LeaderReputation(leader_reputation_type) => {
                let (
                    heuristic,
                    window_size,
                    weight_by_voting_power,
                    use_history_from_previous_epoch_max_count,
                ) = match &leader_reputation_type {
                    LeaderReputationType::ProposerAndVoter(proposer_and_voter_config)
                    | LeaderReputationType::ProposerAndVoterV2(proposer_and_voter_config) => {
                        let proposer_window_size = proposers.len()
                            * proposer_and_voter_config.proposer_window_num_validators_multiplier;
                        let voter_window_size = proposers.len()
                            * proposer_and_voter_config.voter_window_num_validators_multiplier;
                        let heuristic: Box<dyn ReputationHeuristic> =
                            Box::new(ProposerAndVoterHeuristic::new(
                                self.author,
                                proposer_and_voter_config.active_weight,
                                proposer_and_voter_config.inactive_weight,
                                proposer_and_voter_config.failed_weight,
                                proposer_and_voter_config.failure_threshold_percent,
                                voter_window_size,
                                proposer_window_size,
                                leader_reputation_type.use_reputation_window_from_stale_end(),
                            ));
                        (
                            heuristic,
                            std::cmp::max(proposer_window_size, voter_window_size),
                            proposer_and_voter_config.weight_by_voting_power,
                            proposer_and_voter_config.use_history_from_previous_epoch_max_count,
                        )
                    },
                };

                let seek_len = onchain_config.leader_reputation_exclude_round() as usize
                    + onchain_config.max_failed_authors_to_store()
                    + PROPOSER_ROUND_BEHIND_STORAGE_BUFFER;

                let backend = Arc::new(AptosDBBackend::new(
                    window_size,
                    seek_len,
                    self.storage.aptos_db(),
                ));
                let voting_powers: Vec<_> = if weight_by_voting_power {
                    proposers
                        .iter()
                        .map(|p| {
                            epoch_state
                                .verifier
                                .get_voting_power(p)
                                .expect("INVARIANT VIOLATION: proposer not in verifier set")
                        })
                        .collect()
                } else {
                    vec![1; proposers.len()]
                };

                let epoch_to_proposers = self.extract_epoch_proposers(
                    epoch_state,
                    use_history_from_previous_epoch_max_count,
                    proposers,
                    (window_size + seek_len) as u64,
                );

                info!(
                    "Starting epoch {}: proposers across epochs for leader election: {:?}",
                    epoch_state.epoch,
                    epoch_to_proposers
                        .iter()
                        .map(|(epoch, proposers)| (epoch, proposers.len()))
                        .sorted()
                        .collect::<Vec<_>>()
                );

                let proposer_election = Box::new(LeaderReputation::new(
                    epoch_state.epoch,
                    epoch_to_proposers,
                    voting_powers,
                    backend,
                    heuristic,
                    onchain_config.leader_reputation_exclude_round(),
                    leader_reputation_type.use_root_hash_for_seed(),
                    self.config.window_for_chain_health,
                ));
                // LeaderReputation is not cheap, so we can cache the amount of rounds round_manager needs.
                Arc::new(CachedProposerElection::new(
                    epoch_state.epoch,
                    proposer_election,
                    onchain_config.max_failed_authors_to_store()
                        + PROPOSER_ELECTION_CACHING_WINDOW_ADDITION,
                ))
            },
            ProposerElectionType::RoundProposer(round_proposers) => {
                // Hardcoded to the first proposer
                let default_proposer = proposers
                    .first()
                    .expect("INVARIANT VIOLATION: proposers is empty");
                Arc::new(RoundProposer::new(
                    round_proposers.clone(),
                    *default_proposer,
                ))
            },
        }
    }
```

**File:** consensus/src/epoch_manager.rs (L852-854)
```rust
        info!(epoch = epoch, "Create ProposerElection");
        let proposer_election =
            self.create_proposer_election(&epoch_state, &onchain_consensus_config);
```

**File:** consensus/src/epoch_manager.rs (L1178-1201)
```rust
        let onchain_consensus_config: anyhow::Result<OnChainConsensusConfig> = payload.get();
        let onchain_execution_config: anyhow::Result<OnChainExecutionConfig> = payload.get();
        let onchain_randomness_config_seq_num: anyhow::Result<RandomnessConfigSeqNum> =
            payload.get();
        let randomness_config_move_struct: anyhow::Result<RandomnessConfigMoveStruct> =
            payload.get();
        let onchain_jwk_consensus_config: anyhow::Result<OnChainJWKConsensusConfig> = payload.get();
        let dkg_state = payload.get::<DKGState>();

        if let Err(error) = &onchain_consensus_config {
            warn!("Failed to read on-chain consensus config {}", error);
        }

        if let Err(error) = &onchain_execution_config {
            warn!("Failed to read on-chain execution config {}", error);
        }

        if let Err(error) = &randomness_config_move_struct {
            warn!("Failed to read on-chain randomness config {}", error);
        }

        self.epoch_state = Some(epoch_state.clone());

        let consensus_config = onchain_consensus_config.unwrap_or_default();
```

**File:** types/src/on_chain_config/consensus_config.rs (L46-52)
```rust
    pub fn default_if_missing() -> Self {
        Self::JolteonV2 {
            main: ConsensusConfigV1::default(),
            quorum_store_enabled: true,
            order_vote_enabled: false,
        }
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L257-266)
```rust
    pub fn proposer_election_type(&self) -> &ProposerElectionType {
        match &self {
            OnChainConsensusConfig::V1(config) | OnChainConsensusConfig::V2(config) => {
                &config.proposer_election_type
            },
            OnChainConsensusConfig::V3 { alg, .. }
            | OnChainConsensusConfig::V4 { alg, .. }
            | OnChainConsensusConfig::V5 { alg, .. } => alg.proposer_election_type(),
        }
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L443-450)
```rust
impl Default for OnChainConsensusConfig {
    fn default() -> Self {
        OnChainConsensusConfig::V4 {
            alg: ConsensusAlgorithmConfig::default_if_missing(),
            vtxn: ValidatorTxnConfig::default_if_missing(),
            window_size: DEFAULT_WINDOW_SIZE,
        }
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L481-505)
```rust
impl Default for ConsensusConfigV1 {
    fn default() -> Self {
        Self {
            decoupled_execution: true,
            back_pressure_limit: 10,
            exclude_round: 40,
            max_failed_authors_to_store: 10,
            proposer_election_type: ProposerElectionType::LeaderReputation(
                LeaderReputationType::ProposerAndVoterV2(ProposerAndVoterConfig {
                    active_weight: 1000,
                    inactive_weight: 10,
                    failed_weight: 1,
                    failure_threshold_percent: 10, // = 10%
                    // In each round we get stastics for the single proposer
                    // and large number of validators. So the window for
                    // the proposers needs to be significantly larger
                    // to have enough useful statistics.
                    proposer_window_num_validators_multiplier: 10,
                    voter_window_num_validators_multiplier: 1,
                    weight_by_voting_power: true,
                    use_history_from_previous_epoch_max_count: 5,
                }),
            ),
        }
    }
```

**File:** testsuite/testcases/src/compatibility_test.rs (L33-50)
```rust
        // Get the different versions we're testing with
        let (old_version, new_version) = {
            let mut versions = ctxa
                .ctx
                .lock()
                .await
                .swarm
                .read()
                .await
                .versions()
                .collect::<Vec<_>>();
            versions.sort();
            if versions.len() != 2 {
                bail!("exactly two different versions needed to run compat test");
            }

            (versions[0].clone(), versions[1].clone())
        };
```

**File:** types/src/on_chain_config/aptos_version.rs (L7-16)
```rust
/// Defines the version of Aptos Validator software.
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, PartialOrd, Ord, Serialize)]
pub struct AptosVersion {
    pub major: u64,
}

impl OnChainConfig for AptosVersion {
    const MODULE_IDENTIFIER: &'static str = "version";
    const TYPE_IDENTIFIER: &'static str = "Version";
}
```
