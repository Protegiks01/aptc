# Audit Report

## Title
Randomness Liveness Failure in Small Validator Sets Due to Insufficient Threshold Validation

## Summary
The default DKG randomness thresholds (50% secrecy, 67% reconstruction) combined with the absence of minimum validator set size validation can cause permanent randomness liveness failures in small validator sets with unequal stake distributions when a large stakeholder fails to participate in reconstruction.

## Finding Description

The Aptos randomness system uses Distributed Key Generation (DKG) with hardcoded default thresholds: [1](#0-0) 

These thresholds require 67% of validator stake to reconstruct randomness. However, the staking system only enforces that at least one validator remains active: [2](#0-1) 

This creates a vulnerability in small validator sets with unequal stake distributions. Consider a 3-validator network with stakes [50%, 40%, 10%]:

1. **DKG Phase**: All validators participate in dealing (100% > 67% quorum), so DKG completes successfully and each validator receives their secret share.

2. **Reconstruction Phase**: When randomness needs to be generated, the system requires validators with ≥67% combined stake to contribute their shares: [3](#0-2) 

3. **Attack Execution**: If the validator with 50% stake becomes unavailable or malicious and withholds their share, the remaining validators (40% + 10% = 50%) cannot meet the 67% threshold. The reconstruction fails permanently for that epoch.

The DKG rounding algorithm correctly implements the configured thresholds: [4](#0-3) 

But there is no validation ensuring the validator set configuration is compatible with Byzantine fault tolerance requirements (n ≥ 3f+1 where f is the number of Byzantine validators).

## Impact Explanation

**Severity: Medium** - This vulnerability causes a liveness failure of the randomness protocol, not a safety violation. No funds are lost or stolen, but on-chain functionality depending on randomness (random leader election, lottery systems, etc.) becomes unavailable. This meets the Medium severity criteria: "State inconsistencies requiring intervention."

The impact is limited by:
- Only affects small validator sets (<4 validators with specific stake distributions)
- Mainnet deployments typically have 100+ validators with more balanced distributions
- Private/test networks are most vulnerable

## Likelihood Explanation

**Likelihood: Low-Medium**

This vulnerability requires:
1. A validator set with fewer than 4 validators (or small sets with highly concentrated stake)
2. Unequal stake distribution where one validator controls >33% but <67% stake
3. That large stakeholder becoming unavailable or malicious during reconstruction

While unlikely on mainnet, this is realistic for:
- Development/test networks with minimal validators
- Private Aptos deployments with few participants
- Early-stage networks before reaching full decentralization
- Validators experiencing extended downtime

## Recommendation

Add validation to ensure validator set configurations are compatible with the configured thresholds:

**Option 1**: Enforce minimum validator set size based on reconstruction threshold:
```rust
// In stake.move, add validation in join_validator_set_internal()
const MINIMUM_VALIDATORS_FOR_RANDOMNESS: u64 = 4;

public(friend) fun join_validator_set_internal(
    validator_address: address,
    pool_address: address,
) acquires ValidatorSet, ValidatorConfig {
    let validator_set = borrow_global_mut<ValidatorSet>(@aptos_framework);
    
    // Existing check
    let validator_set_size = vector::length(&validator_set.active_validators);
    assert!(validator_set_size < MAX_VALIDATOR_SET_SIZE, 
            error::invalid_argument(EVALIDATOR_SET_TOO_LARGE));
    
    // NEW: Minimum validator set size for randomness
    if (features::randomness_enabled()) {
        assert!(validator_set_size >= MINIMUM_VALIDATORS_FOR_RANDOMNESS,
                error::invalid_state(EINSUFFICIENT_VALIDATORS_FOR_RANDOMNESS));
    }
    // ... rest of function
}
```

**Option 2**: Add runtime validation in DKG initialization:
```rust
// In types/src/dkg/real_dkg/mod.rs::build_dkg_pvss_config()
pub fn build_dkg_pvss_config(
    cur_epoch: u64,
    secrecy_threshold: U64F64,
    reconstruct_threshold: U64F64,
    maybe_fast_path_secrecy_threshold: Option<U64F64>,
    next_validators: &[ValidatorConsensusInfo],
) -> anyhow::Result<DKGPvssConfig> {
    // NEW: Validate minimum viable set
    ensure!(
        next_validators.len() >= 4,
        "Validator set too small for configured thresholds"
    );
    
    // NEW: Ensure largest single validator cannot cause deadlock
    let total_power: u64 = next_validators.iter().map(|v| v.voting_power).sum();
    let max_single_power = next_validators.iter().map(|v| v.voting_power).max().unwrap_or(0);
    let remaining_power = total_power - max_single_power;
    let remaining_ratio = U64F64::from_num(remaining_power) / U64F64::from_num(total_power);
    
    ensure!(
        remaining_ratio >= reconstruct_threshold,
        "Validator stake distribution incompatible with reconstruction threshold"
    );
    
    // ... rest of function
}
```

**Option 3**: Make thresholds configurable per validator set size via governance.

## Proof of Concept

```rust
// Rust test demonstrating the vulnerability
#[test]
fn test_small_validator_set_reconstruction_failure() {
    use aptos_types::dkg::real_dkg::{build_dkg_pvss_config, RealDKG};
    use fixed::types::U64F64;
    
    // Setup: 3 validators with unequal stakes
    let validator_stakes = vec![
        ValidatorConsensusInfo { voting_power: 50, /* ... */ },  // 50%
        ValidatorConsensusInfo { voting_power: 40, /* ... */ },  // 40%
        ValidatorConsensusInfo { voting_power: 10, /* ... */ },  // 10%
    ];
    
    let secrecy = U64F64::from_num(1) / U64F64::from_num(2);      // 50%
    let reconstruct = U64F64::from_num(2) / U64F64::from_num(3);  // 67%
    
    // DKG completes successfully (all 3 participate = 100% > 67%)
    let config = build_dkg_pvss_config(0, secrecy, reconstruct, None, &validator_stakes);
    
    // Attempt reconstruction with only validators 1 and 2 (50% total stake)
    let available_validators = vec![
        validator_stakes[1].clone(),  // 40%
        validator_stakes[2].clone(),  // 10%
    ];
    
    let available_power: u64 = available_validators.iter()
        .map(|v| v.voting_power).sum();  // = 50
    let total_power: u64 = validator_stakes.iter()
        .map(|v| v.voting_power).sum();  // = 100
    let available_ratio = U64F64::from_num(available_power) / U64F64::from_num(total_power);
    
    // Assert: Cannot reconstruct with 50% < 67% threshold
    assert!(available_ratio < reconstruct);  // 0.50 < 0.67 → FAILS
    println!("Reconstruction blocked: {}% < {}%", 
             available_ratio.to_num::<f64>() * 100.0,
             reconstruct.to_num::<f64>() * 100.0);
}
```

## Notes

This vulnerability specifically affects the **reconstruction phase** of randomness generation, not the initial DKG dealing phase. The Byzantine fault tolerance assumption (n ≥ 3f+1) is designed for consensus safety, but the randomness thresholds must also account for liveness under Byzantine failures. The hardcoded 2/3 reconstruction threshold is safe for standard BFT networks with many validators, but becomes problematic when:

1. Validator counts are below the minimum viable set size for the threshold
2. Stake concentration allows a single entity to control more than (1 - reconstruction_threshold) of total stake

The fix requires either enforcing minimum validator set sizes, validating stake distributions, or making thresholds dynamically adjustable based on network composition.

### Citations

**File:** types/src/on_chain_config/randomness_config.rs (L28-38)
```rust
impl Default for ConfigV1 {
    fn default() -> Self {
        Self {
            secrecy_threshold: FixedPoint64MoveStruct::from_u64f64(
                U64F64::from_num(1) / U64F64::from_num(2),
            ),
            reconstruction_threshold: FixedPoint64MoveStruct::from_u64f64(
                U64F64::from_num(2) / U64F64::from_num(3),
            ),
        }
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1255-1255)
```text
            assert!(vector::length(&validator_set.active_validators) > 0, error::invalid_state(ELAST_VALIDATOR));
```

**File:** consensus/src/rand/secret_sharing/secret_share_store.rs (L38-46)
```rust
    pub fn try_aggregate(
        self,
        secret_share_config: &SecretShareConfig,
        metadata: SecretShareMetadata,
        decision_tx: Sender<SecretSharedKey>,
    ) -> Either<Self, SecretShare> {
        if self.total_weight < secret_share_config.threshold() {
            return Either::Left(self);
        }
```

**File:** types/src/dkg/real_dkg/rounding/mod.rs (L323-333)
```rust
    let delta_total_fixed = delta_down_fixed + delta_up_fixed;
    let reconstruct_threshold_in_weights_fixed =
        (secrecy_threshold_in_stake_ratio * stake_sum_fixed / stake_per_weight + delta_up_fixed)
            .ceil()
            + one;
    let reconstruct_threshold_in_weights: u64 = min(
        weight_total,
        reconstruct_threshold_in_weights_fixed.to_num::<u64>(),
    );
    let stake_gap_fixed = stake_per_weight * delta_total_fixed / stake_sum_fixed;
    let reconstruct_threshold_in_stake_ratio = secrecy_threshold_in_stake_ratio + stake_gap_fixed;
```
