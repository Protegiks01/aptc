# Audit Report

## Title
Network Shutdown via Validator Set Depletion During Epoch Transition

## Summary
The `on_new_epoch()` function can result in an empty validator set if all remaining validators are filtered out due to insufficient stake, causing complete network shutdown. While `leave_validator_set()` prevents the last validator from explicitly leaving, it does not prevent the validator set from becoming empty during epoch transitions when validators fall below the minimum stake requirement.

## Finding Description

The vulnerability exists in the interaction between two critical functions in the staking module.

The `leave_validator_set()` function contains a protection that prevents removing the last validator from the active set. After a validator is removed from `active_validators`, the function checks that at least one validator remains: [1](#0-0) 

However, this check only applies during **explicit** leave operations initiated by validators. The critical vulnerability occurs in the `on_new_epoch()` function, which handles automatic validator set updates during epoch transitions.

During epoch transitions, `on_new_epoch()` iterates through all active validators and filters them based on whether their voting power meets the minimum stake requirement: [2](#0-1) 

Validators whose `voting_power` is less than `minimum_stake` are NOT added to `next_epoch_validators`. Crucially, **there is no validation after the filtering loop to ensure that `next_epoch_validators` is not empty** before assigning it to `validator_set.active_validators` at line 1401.

The framework's documentation explicitly confirms this automatic removal behavior: [3](#0-2) [4](#0-3) 

**Attack Scenario:**

1. Network starts with N validators (N ≥ 2)
2. N-1 validators call `leave_validator_set()` successfully - each time the check at line 1255 passes since ≥1 validator remains after each removal
3. One validator remains in `active_validators`
4. This validator's stake drops below `minimum_stake` through either:
   - **Path A**: The validator calls `unlock()` to move active stake to pending_inactive. The unlock function allows moving any amount up to the full active stake with no check for maintaining minimum stake requirements: [5](#0-4) 
   - **Path B**: Governance executes a proposal to increase `minimum_stake` via the staking config, which can be updated by the @aptos_framework account: [6](#0-5) 
5. At the next epoch boundary, `reconfigure()` calls `stake::on_new_epoch()`: [7](#0-6) 
6. The filtering loop evaluates the last validator and finds `voting_power < minimum_stake`
7. The validator is NOT added to `next_epoch_validators`
8. `next_epoch_validators` remains empty
9. Line 1401 assigns the empty vector: `validator_set.active_validators = []`
10. Network cannot produce blocks → Complete shutdown

## Impact Explanation

This is a **CRITICAL severity** vulnerability under the Aptos Bug Bounty Program, meeting multiple critical impact criteria:

**1. Total Loss of Liveness/Network Availability (Critical - up to $1,000,000):**
With zero validators, the AptosBFT consensus protocol cannot function. The validator verifier in the Rust implementation handles empty validator sets by setting quorum voting power to 0, but this doesn't enable consensus - it merely prevents a panic: [8](#0-7) 

Without any validators to propose blocks or vote on proposals, block production completely halts and the network enters a permanent deadlock state.

**2. Non-recoverable Network Partition (Critical):**
Once `active_validators` becomes empty, the network cannot recover through normal operations. There are no validators to execute transactions, process governance proposals, or trigger any state changes. Recovery would require either:
- Manual intervention by the Aptos foundation to inject validators through a special maintenance mode
- A hardfork to restore the validator set
- Complete network restart with modified genesis state

The validator set is fundamental to AptosBFT consensus. An empty validator set violates the core protocol invariant that the network must always have at least one validator capable of producing blocks.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability can occur through several realistic scenarios that do NOT require Byzantine behavior or malicious intent:

**Scenario 1 - Natural Validator Attrition:**
As validators leave the network over time for legitimate operational or economic reasons, the validator set naturally shrinks. If the last remaining validator subsequently unlocks stake for treasury management, reward claiming, or rebalancing purposes and falls below the minimum threshold, the network halts at the next epoch. This is particularly likely during:
- Bear markets when validator economics become unfavorable
- Network upgrades that cause validator departures
- Consolidation of validator operations

**Scenario 2 - Governance-Driven Minimum Stake Increase:**
A well-intentioned governance proposal to improve network security by raising `minimum_stake` could inadvertently trigger this vulnerability if:
- The proposal passes when validator count is already low
- Remaining validators haven't proactively increased their stake
- The increase is substantial relative to current validator stakes

**Scenario 3 - Coordinated Departures During Network Stress:**
Multiple validators deciding to leave during periods of network instability, protocol uncertainty, or regulatory concerns, combined with insufficient stake management by remaining validator(s).

**Key factors making this MEDIUM-HIGH likelihood:**

✅ Does NOT require Byzantine validator behavior or compromised keys
✅ Can occur through normal network operations and legitimate validator decisions
✅ No complex exploit chain or precise timing required (epoch transitions are predictable)
✅ No significant attacker resources needed
✅ Both triggering mechanisms (unlock and governance) are standard operations
❌ Requires specific conditions (low validator count + stake management issue)
❌ Assumes network governance/operators don't proactively monitor validator health

The validation framework acknowledges this risk with the `ELAST_VALIDATOR` error constant, but the protection is incomplete - it only guards explicit leaving, not automatic removal during epoch transitions.

## Recommendation

Add a validation check in the `on_new_epoch()` function after the validator filtering loop to ensure the validator set cannot become empty:

```move
// After line 1399, before line 1401:
assert!(
    vector::length(&next_epoch_validators) > 0,
    error::invalid_state(ELAST_VALIDATOR)
);
validator_set.active_validators = next_epoch_validators;
```

This would cause the epoch transition to abort if all validators would be filtered out, preventing the network from entering an unrecoverable state. Additionally, consider:

1. Implementing early warnings when the validator set size drops below a critical threshold
2. Adding governance restrictions on minimum_stake increases when validator count is low
3. Preventing validators from unlocking stake that would drop them below minimum_stake while active
4. Adding a formal verification invariant that `len(active_validators) > 0` must always hold

## Proof of Concept

While a complete Move test is not provided in the original report, the vulnerability can be demonstrated by:

1. Initializing a network with 2 validators
2. Having validator 1 call `leave_validator_set()`
3. Having validator 2 call `unlock()` to move active stake below `minimum_stake`
4. Triggering epoch transition via `reconfigure()`
5. Observing that `validator_set.active_validators` becomes empty
6. Confirming that subsequent consensus operations fail due to no validators

The vulnerability logic is verifiable through code inspection of the cited functions, and the attack path requires only standard transaction calls available to validator operators and governance.

## Notes

This vulnerability represents a critical gap in the validator set management logic. While the codebase includes the `ELAST_VALIDATOR` error constant and uses it to prevent explicit removal of the last validator, it fails to apply the same protection to automatic removal during epoch transitions. The framework's own documentation confirms that validators are automatically removed when their stake falls below the minimum, but no safeguard exists to prevent this from resulting in an empty set.

The trust model consideration is important here: validator operators and governance participants are trusted roles, but this vulnerability demonstrates that even trusted actors making legitimate decisions within the protocol's rules can inadvertently cause catastrophic network failure. This is a protocol design flaw rather than an access control issue.

### Citations

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L15-16)
```text
/// 7. After exiting, the validator can either explicitly leave the validator set by calling stake::leave_validator_set
/// or if their stake drops below the min required, they would get removed at the end of the epoch.
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1117-1132)
```text
    public fun unlock_with_cap(amount: u64, owner_cap: &OwnerCapability) acquires StakePool {
        assert_reconfig_not_in_progress();
        // Short-circuit if amount to unlock is 0 so we don't emit events.
        if (amount == 0) {
            return
        };

        // Unlocked coins are moved to pending_inactive. When the current lockup cycle expires, they will be moved into
        // inactive in the earliest possible epoch transition.
        let pool_address = owner_cap.pool_address;
        assert_stake_pool_exists(pool_address);
        let stake_pool = borrow_global_mut<StakePool>(pool_address);
        // Cap amount to unlock by maximum active stake.
        let amount = min(amount, coin::value(&stake_pool.active));
        let unlocked_stake = coin::extract(&mut stake_pool.active, amount);
        coin::merge<AptosCoin>(&mut stake_pool.pending_inactive, unlocked_stake);
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1253-1255)
```text
            let validator_info = vector::swap_remove(
                &mut validator_set.active_validators, option::extract(&mut maybe_active_index));
            assert!(vector::length(&validator_set.active_validators) > 0, error::invalid_state(ELAST_VALIDATOR));
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1390-1401)
```text
            // A validator needs at least the min stake required to join the validator set.
            if (new_validator_info.voting_power >= minimum_stake) {
                spec {
                    assume total_voting_power + new_validator_info.voting_power <= MAX_U128;
                };
                total_voting_power = total_voting_power + (new_validator_info.voting_power as u128);
                vector::push_back(&mut next_epoch_validators, new_validator_info);
            };
            i = i + 1;
        };

        validator_set.active_validators = next_epoch_validators;
```

**File:** aptos-move/framework/aptos-framework/sources/configs/staking_config.move (L48-57)
```text
    /// Validator set configurations that will be stored with the @aptos_framework account.
    struct StakingConfig has copy, drop, key {
        // A validator needs to stake at least this amount to be able to join the validator set.
        // If after joining the validator set and at the start of any epoch, a validator's stake drops below this amount
        // they will be removed from the set.
        minimum_stake: u64,
        // A validator can only stake at most this amount. Any larger stake will be rejected.
        // If after joining the validator set and at the start of any epoch, a validator's stake exceeds this amount,
        // their voting power and rewards would only be issued for the max stake amount.
        maximum_stake: u64,
```

**File:** aptos-move/framework/aptos-framework/sources/reconfiguration.move (L133-134)
```text
        // Call stake to compute the new validator set and distribute rewards and transaction fees.
        stake::on_new_epoch();
```

**File:** types/src/validator_verifier.rs (L206-212)
```rust
    pub fn new(validator_infos: Vec<ValidatorConsensusInfo>) -> Self {
        let total_voting_power = sum_voting_power(&validator_infos);
        let quorum_voting_power = if validator_infos.is_empty() {
            0
        } else {
            total_voting_power * 2 / 3 + 1
        };
```
