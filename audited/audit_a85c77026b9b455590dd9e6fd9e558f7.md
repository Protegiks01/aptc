# Audit Report

## Title
Storage Service Information Leakage via InternalError Variant Exposes Database Implementation Details to Network Peers

## Summary
The `StorageServiceError::InternalError` variant exposes sensitive internal implementation details including RocksDB error messages, file paths, database structure information, and internal state details to any remote network peer. This information leakage occurs when storage layer errors are converted to client-facing errors and transmitted over the network.

## Finding Description

The storage service error handling chain contains an information leakage vulnerability where internal database errors are exposed to remote peers: [1](#0-0) 

The `InternalError` variant contains a `String` that gets populated with internal error details. The vulnerability manifests in the error conversion chain:

1. **Storage Layer Errors** - Internal database errors (RocksDB, IO errors, BCS errors) contain implementation details: [2](#0-1) 

2. **RocksDB Error Conversion** - All RocksDB errors including IO errors are converted using `.to_string()`: [3](#0-2) 

3. **Server Error Transformation** - Storage errors are converted to server errors preserving full details: [4](#0-3) 

4. **Network Transmission** - Internal errors are converted to `StorageServiceError::InternalError` and sent to remote peers: [5](#0-4) 

5. **BCS Serialization** - The error is serialized and transmitted over the network: [6](#0-5) 

Examples of exposed information include:
- Database file paths from IO errors
- RocksDB internal error messages revealing database structure
- BCS deserialization errors with internal data structures
- Debug-formatted internal state values
- Version numbers and internal indices [7](#0-6) [8](#0-7) 

## Impact Explanation

This qualifies as **Low Severity** per Aptos bug bounty criteria for "Minor information leaks". While the exposed information does not directly lead to funds loss, consensus violations, or availability issues, it provides reconnaissance value to attackers:

1. **Implementation Fingerprinting** - Reveals exact RocksDB version and configuration details
2. **Path Disclosure** - Exposes filesystem structure and database locations
3. **Internal State Exposure** - Reveals database schema, table structures, and internal data representations
4. **Attack Surface Mapping** - Helps attackers identify specific components to target
5. **Vulnerability Identification** - Error messages may reveal specific bugs or misconfigurations

The information does not break any critical invariants (consensus safety, deterministic execution, state consistency) but violates security best practices for production systems by exposing internal implementation details to untrusted parties.

## Likelihood Explanation

**Likelihood: High** - Any remote peer on the Aptos network can trigger this information leakage by:
1. Sending storage service requests to validator nodes or fullnodes
2. Crafting requests that target non-existent data or trigger internal errors
3. Analyzing the returned error messages for implementation details

The attack requires no special privileges - any network participant can send storage service requests and receive detailed error responses. Test code demonstrates this is the intended behavior: [9](#0-8) [10](#0-9) 

## Recommendation

Implement sanitized error messages for network responses that remove internal implementation details:

```rust
// In state-sync/storage-service/server/src/handler.rs
process_result.map_err(|error| match error {
    Error::InvalidRequest(error) => StorageServiceError::InvalidRequest(error),
    Error::TooManyInvalidRequests(error) => {
        StorageServiceError::TooManyInvalidRequests(error)
    },
    // Sanitize internal errors - do not expose implementation details
    Error::StorageErrorEncountered(_) => StorageServiceError::InternalError(
        "Internal storage error occurred".to_string()
    ),
    Error::UnexpectedErrorEncountered(_) => StorageServiceError::InternalError(
        "Internal server error occurred".to_string()
    ),
})
```

Additionally:
1. Log full error details server-side for debugging while returning generic messages to clients
2. Implement error code system instead of descriptive strings
3. Add rate limiting for clients that trigger excessive errors
4. Monitor for error-based reconnaissance attempts

## Proof of Concept

```rust
// PoC demonstrating information leakage via storage service requests
// This would be added as a test in state-sync/storage-service/server/src/tests/

#[tokio::test]
async fn test_internal_error_information_leakage() {
    use crate::tests::{mock, utils};
    use aptos_storage_interface::AptosDbError;
    use aptos_storage_service_types::StorageServiceError;
    
    // Create a mock DB that returns an error with internal details
    let mut db_reader = mock::create_mock_db_reader();
    db_reader
        .expect_get_state_item_count()
        .returning(|_| {
            // Simulate an IO error that would expose file paths
            Err(AptosDbError::IoError(
                "Failed to read from /var/lib/aptos/db/state_kv_db: Permission denied".to_string()
            ))
        });
    
    // Create storage service
    let (mut mock_client, service, _, _, _) = mock::MockClient::new(Some(db_reader), None);
    tokio::spawn(service.start());
    
    // Send request from remote peer
    let response = utils::get_number_of_states(&mut mock_client, 100, false)
        .await
        .unwrap_err();
    
    // Verify that internal details are exposed in the error
    match response {
        StorageServiceError::InternalError(msg) => {
            // The error message contains internal file path and system details
            assert!(msg.contains("/var/lib/aptos/db") || msg.contains("Permission denied"),
                "Expected internal details to be exposed, got: {}", msg);
            println!("LEAKED INFORMATION: {}", msg);
        },
        _ => panic!("Expected InternalError variant"),
    }
}
```

**Notes:**

This finding represents a genuine information leakage issue where the storage service exposes internal implementation details to any network peer through the `InternalError` variant. While categorized as Low severity, it violates security best practices and provides valuable reconnaissance information to potential attackers. The issue is easily exploitable by any network participant and should be addressed by implementing sanitized error messages for external clients while preserving detailed error information in server-side logs.

### Citations

**File:** state-sync/storage-service/types/src/lib.rs (L31-32)
```rust
    #[error("Internal service error: {0}")]
    InternalError(String),
```

**File:** storage/storage-interface/src/errors.rs (L11-37)
```rust
pub enum AptosDbError {
    /// A requested item is not found.
    #[error("{0} not found.")]
    NotFound(String),
    /// Requested too many items.
    #[error("Too many items requested: at least {0} requested, max is {1}")]
    TooManyRequested(u64, u64),
    #[error("Missing state root node at version {0}, probably pruned.")]
    MissingRootError(u64),
    /// Other non-classified error.
    #[error("AptosDB Other Error: {0}")]
    Other(String),
    #[error("AptosDB RocksDb Error: {0}")]
    RocksDbIncompleteResult(String),
    #[error("AptosDB RocksDB Error: {0}")]
    OtherRocksDbError(String),
    #[error("AptosDB bcs Error: {0}")]
    BcsError(String),
    #[error("AptosDB IO Error: {0}")]
    IoError(String),
    #[error("AptosDB Recv Error: {0}")]
    RecvError(String),
    #[error("AptosDB ParseInt Error: {0}")]
    ParseIntError(String),
    #[error("Hot state not configured properly")]
    HotStateError,
}
```

**File:** storage/schemadb/src/lib.rs (L389-407)
```rust
fn to_db_err(rocksdb_err: rocksdb::Error) -> AptosDbError {
    match rocksdb_err.kind() {
        ErrorKind::Incomplete => AptosDbError::RocksDbIncompleteResult(rocksdb_err.to_string()),
        ErrorKind::NotFound
        | ErrorKind::Corruption
        | ErrorKind::NotSupported
        | ErrorKind::InvalidArgument
        | ErrorKind::IOError
        | ErrorKind::MergeInProgress
        | ErrorKind::ShutdownInProgress
        | ErrorKind::TimedOut
        | ErrorKind::Aborted
        | ErrorKind::Busy
        | ErrorKind::Expired
        | ErrorKind::TryAgain
        | ErrorKind::CompactionTooLarge
        | ErrorKind::ColumnFamilyDropped
        | ErrorKind::Unknown => AptosDbError::OtherRocksDbError(rocksdb_err.to_string()),
    }
```

**File:** state-sync/storage-service/server/src/error.rs (L43-46)
```rust
impl From<aptos_storage_interface::AptosDbError> for Error {
    fn from(error: aptos_storage_interface::AptosDbError) -> Self {
        Error::StorageErrorEncountered(error.to_string())
    }
```

**File:** state-sync/storage-service/server/src/handler.rs (L196-202)
```rust
        process_result.map_err(|error| match error {
            Error::InvalidRequest(error) => StorageServiceError::InvalidRequest(error),
            Error::TooManyInvalidRequests(error) => {
                StorageServiceError::TooManyInvalidRequests(error)
            },
            error => StorageServiceError::InternalError(error.to_string()),
        })
```

**File:** state-sync/storage-service/server/src/network.rs (L106-112)
```rust
    pub fn send(self, response: Result<StorageServiceResponse>) {
        let msg = StorageServiceMessage::Response(response);
        let result = bcs::to_bytes(&msg)
            .map(Bytes::from)
            .map_err(RpcError::BcsError);
        let _ = self.response_tx.send(result);
    }
```

**File:** storage/indexer/src/lib.rs (L137-137)
```rust
                db_other_bail!("Failed to parse table info: {:?}", err);
```

**File:** storage/indexer/src/lib.rs (L246-246)
```rust
                        _ => db_other_bail!("Table struct malformed. {:?}", struct_value),
```

**File:** state-sync/aptos-data-client/src/tests/peers.rs (L714-721)
```rust
/// Sends an error response to the specified network request
fn send_error_response(network_request: NetworkRequest) {
    network_request
        .response_sender
        .send(Err(StorageServiceError::InternalError(
            "Oops! Something went wrong!".to_string(),
        )));
}
```

**File:** state-sync/storage-service/server/src/tests/number_of_states.rs (L66-94)
```rust
async fn test_get_number_of_states_at_version_invalid() {
    // Create test data
    let version = 1;

    // Create the mock db reader
    let mut db_reader = mock::create_mock_db_reader();
    db_reader
        .expect_get_state_item_count()
        .times(1)
        .with(eq(version))
        .returning(move |_| {
            Err(AptosDbError::NotFound(
                format_err!("Version does not exist!").to_string(),
            ))
        });

    // Create the storage client and server
    let (mut mock_client, mut service, _, _, _) = MockClient::new(Some(db_reader), None);
    utils::update_storage_server_summary(&mut service, version, 10);
    tokio::spawn(service.start());

    // Process a request to fetch the number of states at a version
    let response = utils::get_number_of_states(&mut mock_client, version, false)
        .await
        .unwrap_err();

    // Verify the response is correct
    assert_matches!(response, StorageServiceError::InternalError(_));
}
```
