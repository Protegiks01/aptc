# Audit Report

## Title
Insecure Default Configuration Bypasses Sanitization When Chain ID Extraction Fails

## Summary
The NodeConfig sanitizer allows validators to run with insecure default configurations (consensus keys stored in process memory rather than HSM) when chain ID extraction fails. This occurs because security-critical checks in `SafetyRulesConfig::sanitize` are only enforced when `chain_id` is `Some(...)`, allowing `NodeConfig::default()` with in-memory key storage to pass validation when genesis transaction is missing or malformed.

## Finding Description

The vulnerability exists in the interaction between configuration loading, chain ID extraction, and sanitization logic:

**1. Insecure Default Configuration:** [1](#0-0) 

The default `SafetyRulesConfig` uses `SecureBackend::InMemoryStorage`, storing consensus signing keys in process memory rather than secure hardware (HSM/Vault). For validators, this violates the critical security requirement that consensus keys must be stored in tamper-resistant hardware.

**2. Genesis Transaction Default:** [2](#0-1) 

`ExecutionConfig::default()` sets `genesis = None`, meaning no genesis transaction is loaded by default.

**3. Chain ID Extraction Failure:** [3](#0-2) 

When genesis transaction is missing or malformed, `get_chain_id()` fails and the node continues with `chain_id = None`, merely printing a warning without failing startup.

**4. Conditional Security Checks:** [4](#0-3) 

The sanitizer only validates secure backend configuration when `chain_id` is `Some(...)`. When `chain_id = None`, ALL security checks are bypassed, including:
- Verification that mainnet validators don't use in-memory storage
- Verification that safety rules service is local (not remote)
- Verification that test config is not enabled

**5. Node Continues Without Genesis:** [5](#0-4) 

The storage initialization explicitly allows nodes to continue without genesis transaction, logging only an info message rather than failing.

**Attack Scenario:**
1. Validator operator deploys node with `NodeConfig::default()` or missing genesis file
2. Node startup: `get_genesis_txn()` returns `None`
3. Chain ID extraction fails → `chain_id = None` 
4. Sanitizer runs: `SafetyRulesConfig::sanitize()` skips all checks (line 85)
5. Node runs with `SecureBackend::InMemoryStorage` (default)
6. Consensus signing keys stored in process memory (not HSM)
7. Process compromise → attacker extracts signing keys from memory
8. Attacker can sign malicious blocks, cause equivocation, double-signing

This breaks **Cryptographic Correctness Invariant #10**: Consensus signing keys are the most critical cryptographic material and must be stored in secure hardware, never in process memory vulnerable to memory dumps, debugging, or process compromise.

## Impact Explanation

**Severity: Medium** (up to $10,000 per Aptos Bug Bounty)

This qualifies as "State inconsistencies requiring intervention" because:

1. **Consensus Safety Risk**: If a validator's process is compromised and keys extracted from memory, the attacker can sign arbitrary blocks, potentially causing:
   - Double-signing (signing conflicting blocks at same height)
   - Equivocation (Byzantine behavior)
   - Consensus safety violations if combined with other compromised validators

2. **Defense-in-Depth Failure**: While operators are trusted, the sanitizer should provide defense-in-depth by catching obviously insecure configurations. The current implementation allows critical security violations to pass validation silently.

3. **Production Impact**: A misconfigured validator joining mainnet with in-memory keys could compromise network security if that validator is later compromised through unrelated vulnerabilities (RCE, memory exploits, etc.).

This does NOT reach Critical/High severity because:
- Requires operator misconfiguration (trusted actor error)
- Node would likely fail to operate properly without genesis
- Cannot be directly exploited by external attacker without first compromising the validator

## Likelihood Explanation

**Likelihood: Medium-Low**

**Factors increasing likelihood:**
- Default configuration is insecure by design
- Sanitizer allows it to pass when chain_id = None
- Operators testing on devnet might deploy with defaults
- Configuration could accidentally propagate to mainnet
- The error message is only info-level, easily missed

**Factors decreasing likelihood:**
- Requires operator error (deploying without genesis)
- Operators following documentation would include genesis
- Node likely fails to function without genesis for other reasons
- Most validators use proper deployment tooling that includes genesis
- Mainnet validators are typically security-conscious

## Recommendation

**1. Strengthen Chain ID Validation:**

```rust
// In config/src/config/node_config_loader.rs
fn extract_node_type_and_chain_id(node_config: &NodeConfig) -> Result<(NodeType, ChainId), Error> {
    let node_type = NodeType::extract_from_config(node_config);
    
    // REQUIRE chain ID for validators
    let chain_id = get_chain_id(node_config)?;
    
    Ok((node_type, chain_id))
}
```

**2. Enforce Secure Backend for Validators:**

```rust
// In config/src/config/safety_rules_config.rs
impl ConfigSanitizer for SafetyRulesConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        let sanitizer_name = Self::get_sanitizer_name();
        let safety_rules_config = &node_config.consensus.safety_rules;

        if !node_type.is_validator() {
            return Ok(());
        }

        // ALWAYS validate secure backend for validators, regardless of chain_id
        if safety_rules_config.backend.is_in_memory() {
            return Err(Error::ConfigSanitizerFailed(
                sanitizer_name,
                "Validators must use secure backend (HSM/Vault), not in-memory storage!".to_string(),
            ));
        }

        // Existing mainnet-specific checks
        if let Some(chain_id) = chain_id {
            // ... existing checks ...
        }

        Ok(())
    }
}
```

**3. Require Genesis for Validators:**

```rust
// In aptos-node/src/storage.rs
pub(crate) fn maybe_apply_genesis(
    db_rw: &DbReaderWriter,
    node_config: &NodeConfig,
) -> Result<Option<LedgerInfoWithSignatures>> {
    let genesis_waypoint = node_config
        .execution
        .genesis_waypoint
        .as_ref()
        .unwrap_or(&node_config.base.waypoint)
        .genesis_waypoint();
        
    if let Some(genesis) = get_genesis_txn(node_config) {
        let ledger_info_opt =
            maybe_bootstrap::<AptosVMBlockExecutor>(db_rw, genesis, genesis_waypoint)
                .map_err(|err| anyhow!("DB failed to bootstrap {}", err))?;
        Ok(ledger_info_opt)
    } else {
        // For validators, genesis is REQUIRED
        if node_config.base.role.is_validator() {
            return Err(anyhow!("Genesis transaction is required for validators!"));
        }
        info!("Genesis txn not provided for fullnode - this is acceptable");
        Ok(None)
    }
}
```

## Proof of Concept

```rust
use aptos_config::config::{NodeConfig, NodeType, SafetyRulesConfig};
use aptos_config::config::config_sanitizer::ConfigSanitizer;
use aptos_types::chain_id::ChainId;

#[test]
fn test_insecure_default_passes_sanitization() {
    // Create a validator config with defaults (no genesis)
    let mut node_config = NodeConfig::default();
    node_config.base.role = aptos_config::config::RoleType::Validator;
    
    // Verify the default has insecure settings
    assert!(node_config.consensus.safety_rules.backend.is_in_memory());
    assert!(node_config.execution.genesis.is_none());
    
    // Simulate chain_id = None (no genesis to extract from)
    let chain_id = None;
    let node_type = NodeType::Validator;
    
    // BUG: This should fail but passes!
    let result = SafetyRulesConfig::sanitize(&node_config, node_type, chain_id);
    assert!(result.is_ok(), "Insecure config passed sanitization!");
    
    // With mainnet chain_id, it correctly fails
    let result_mainnet = SafetyRulesConfig::sanitize(
        &node_config,
        node_type,
        Some(ChainId::mainnet())
    );
    assert!(result_mainnet.is_err(), "Should fail for mainnet");
}

#[test]
fn test_chain_id_none_bypass() {
    let mut node_config = NodeConfig::default();
    node_config.base.role = aptos_config::config::RoleType::Validator;
    
    // With chain_id = None, security checks are bypassed
    let result = NodeConfig::sanitize(&node_config, NodeType::Validator, None);
    
    // This passes even though:
    // 1. Consensus keys are in memory (insecure)
    // 2. No genesis transaction (no chain context)
    // 3. Test config could be enabled
    assert!(result.is_ok(), "Demonstrated sanitization bypass");
}
```

## Notes

This vulnerability represents a **defense-in-depth failure** rather than a directly exploitable attack vector. While the sanitizer should catch insecure configurations regardless of chain ID, the actual exploitation requires:

1. Validator operator error (deploying without proper genesis configuration)
2. Subsequent process compromise (separate vulnerability needed)
3. Memory extraction of signing keys

The primary security concern is that the sanitizer—designed as a safety net—allows obviously insecure configurations to pass when chain ID cannot be determined. This violates the principle that security checks should fail closed (reject uncertain configurations) rather than fail open (allow potentially dangerous configurations).

The recommended fixes enforce that validators always have:
- Valid genesis transaction with extractable chain ID
- Secure backend for consensus key storage (HSM/Vault)
- Appropriate configuration for their network role

These changes would prevent misconfigured validators from joining the network with dangerously insecure settings.

### Citations

**File:** config/src/config/safety_rules_config.rs (L36-48)
```rust
impl Default for SafetyRulesConfig {
    fn default() -> Self {
        Self {
            backend: SecureBackend::InMemoryStorage,
            logger: LoggerConfig::default(),
            service: SafetyRulesService::Local,
            test: None,
            // Default value of 30 seconds for a timeout
            network_timeout_ms: 30_000,
            enable_cached_safety_data: true,
            initial_safety_rules_config: InitialSafetyRulesConfig::None,
        }
    }
```

**File:** config/src/config/safety_rules_config.rs (L85-113)
```rust
        if let Some(chain_id) = chain_id {
            // Verify that the secure backend is appropriate for mainnet validators
            if chain_id.is_mainnet()
                && node_type.is_validator()
                && safety_rules_config.backend.is_in_memory()
            {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The secure backend should not be set to in memory storage in mainnet!"
                        .to_string(),
                ));
            }

            // Verify that the safety rules service is set to local for optimal performance
            if chain_id.is_mainnet() && !safety_rules_config.service.is_local() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("The safety rules service should be set to local in mainnet for optimal performance! Given config: {:?}", &safety_rules_config.service)
                ));
            }

            // Verify that the safety rules test config is not enabled in mainnet
            if chain_id.is_mainnet() && safety_rules_config.test.is_some() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    "The safety rules test config should not be used in mainnet!".to_string(),
                ));
            }
        }
```

**File:** config/src/config/execution_config.rs (L78-96)
```rust
impl Default for ExecutionConfig {
    fn default() -> ExecutionConfig {
        ExecutionConfig {
            genesis: None,
            genesis_file_location: PathBuf::new(),
            // use min of (num of cores/2, DEFAULT_CONCURRENCY_LEVEL) as default concurrency level
            concurrency_level: 0,
            num_proof_reading_threads: 32,
            paranoid_type_verification: true,
            paranoid_hot_potato_verification: true,
            discard_failed_blocks: false,
            processed_transactions_detailed_counters: false,
            genesis_waypoint: None,
            blockstm_v2_enabled: false,
            layout_caches_enabled: true,
            // TODO: consider setting to be true by default.
            async_runtime_checks: false,
        }
    }
```

**File:** config/src/config/node_config_loader.rs (L112-124)
```rust
fn extract_node_type_and_chain_id(node_config: &NodeConfig) -> (NodeType, Option<ChainId>) {
    // Get the node type from the node config
    let node_type = NodeType::extract_from_config(node_config);

    // Get the chain ID from the genesis transaction
    match get_chain_id(node_config) {
        Ok(chain_id) => (node_type, Some(chain_id)),
        Err(error) => {
            println!("Failed to extract the chain ID from the genesis transaction: {:?}! Continuing with None.", error);
            (node_type, None)
        },
    }
}
```

**File:** aptos-node/src/storage.rs (L34-42)
```rust
    if let Some(genesis) = get_genesis_txn(node_config) {
        let ledger_info_opt =
            maybe_bootstrap::<AptosVMBlockExecutor>(db_rw, genesis, genesis_waypoint)
                .map_err(|err| anyhow!("DB failed to bootstrap {}", err))?;
        Ok(ledger_info_opt)
    } else {
        info ! ("Genesis txn not provided! This is fine only if you don't expect to apply it. Otherwise, the config is incorrect!");
        Ok(None)
    }
```
