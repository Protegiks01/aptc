# Audit Report

## Title
Consensus Observer Payload Store Poisoning via Unvalidated Future Epoch Blocks

## Summary
The consensus observer's block payload store can be permanently filled with unverified future epoch blocks, causing a critical denial-of-service that prevents legitimate consensus blocks from being stored and processed. An attacker can send 150 BlockPayload messages with arbitrarily high epoch numbers that bypass signature verification and are never cleaned up, rendering the consensus observer node non-functional.

## Finding Description

The `ConsensusObserverPayloadManager` holds a reference to a shared `BTreeMap<(u64, Round), BlockPayloadStatus>` that stores block payloads indexed by epoch and round. [1](#0-0) 

While this BTreeMap does have a size limit enforced during insertion (default 150 blocks), there is a critical validation gap that allows attackers to permanently pollute the store with malicious entries. [2](#0-1) 

**The Attack Path:**

1. **Bypassing Authentication:** When a BlockPayload message arrives, it undergoes validation checks. If the block's epoch matches the current epoch, signature verification is enforced. However, if the block is for a **future epoch**, signature verification is completely bypassed and the block is stored as "unverified". [3](#0-2) 

2. **Passing Staleness Check:** The only check preventing future blocks is whether they are "out of date" compared to the last ordered block. This check only filters blocks with `(epoch, round) <= (last_ordered_epoch, last_ordered_round)`, meaning arbitrarily high future epoch blocks pass through. [4](#0-3) 

3. **Digest Verification Weakness:** The `verify_payload_digests()` check only validates internal data consistency (that batch digests match transactions), which an attacker can easily craft correctly. It does not authenticate the sender or validate epoch bounds.

4. **Permanent Pollution:** Once 150 future epoch blocks are stored, the size limit prevents any new blocks (including legitimate ones) from being inserted. The insertion method simply drops new blocks with a warning when the limit is reached. [5](#0-4) 

5. **No Cleanup Mechanism:** Future epoch blocks are never removed because:
   - The `verify_payload_signatures` method breaks early when it encounters epochs greater than the current epoch, leaving them permanently unverified. [6](#0-5) 
   - The `remove_blocks_for_epoch_round` cleanup method only removes blocks **up to** a given epoch/round (i.e., old blocks), not future blocks. [7](#0-6) 

**Exploitation Steps:**

1. Attacker sends 150 BlockPayload messages to a consensus observer node
2. Each message contains a BlockInfo with `epoch = 999999999` (or any large number)
3. Messages include properly formatted BlockTransactionPayload with valid digests
4. All messages pass validation and are stored as "AvailableAndUnverified"
5. Payload store is now full - legitimate blocks for current epoch are rejected
6. Node cannot process consensus updates, breaking liveness
7. Pollution persists indefinitely until manual intervention (node restart/fallback)

## Impact Explanation

**Severity: Critical** (meets Aptos Bug Bounty Critical criteria)

This vulnerability causes **total loss of liveness** for consensus observer nodes:

- **Availability Impact:** Affected nodes cannot process any consensus blocks, completely breaking their consensus observer functionality
- **Network-Wide Risk:** If multiple observer nodes (VFNs, PFNs) are attacked, the network's observation and validation infrastructure degrades significantly
- **Persistent Damage:** The attack effect is permanent until manual intervention - blocks cannot be committed, state cannot advance
- **No Privilege Required:** Attack requires only network-level access to send messages to observer nodes, no validator credentials needed
- **Low Complexity:** Attacker only needs to craft 150 messages with high epoch numbers and valid digests (no cryptographic attacks required)

This breaks the **Resource Limits** invariant (operations must respect computational limits) and the **Consensus Safety** invariant (by preventing nodes from participating in consensus observation).

## Likelihood Explanation

**Likelihood: High**

- **Attack Complexity:** Low - requires only basic network message crafting capability
- **Attacker Requirements:** Minimal - ability to send P2P messages to consensus observer nodes (typically accessible to any peer)
- **Detection Difficulty:** Medium - the attack appears as legitimate unverified payloads in logs
- **Exploitation Barriers:** None - no authentication or rate limiting prevents this attack
- **Target Surface:** All consensus observer nodes (VFNs, potentially PFNs if enabled)

The vulnerability is straightforward to exploit and affects a critical component of the Aptos network infrastructure.

## Recommendation

**Immediate Fix:** Add epoch bounds validation when processing BlockPayload messages to reject blocks that are unreasonably far in the future.

**Recommended Code Changes:**

In `consensus/src/consensus_observer/observer/consensus_observer.rs`, add epoch bounds checking in the `process_block_payload_message` method after line 364:

```rust
// Get the current epoch state
let current_epoch = self.get_epoch_state().epoch;

// Reject blocks that are too far in the future
const MAX_EPOCH_DRIFT: u64 = 2; // Allow up to 2 epochs ahead
if block_epoch > current_epoch + MAX_EPOCH_DRIFT {
    warn!(
        LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
            "Rejecting block payload with future epoch too far ahead! Block epoch: {}, Current epoch: {}, from peer: {:?}",
            block_epoch, current_epoch, peer_network_id
        ))
    );
    increment_invalid_message_counter(&peer_network_id, metrics::BLOCK_PAYLOAD_LABEL);
    return;
}
```

**Additional Hardening:**

1. Add periodic cleanup of unverified payloads that remain unverified beyond a time threshold
2. Implement per-peer rate limiting for unverified payload messages
3. Add metrics tracking for rejected future-epoch blocks to enable monitoring
4. Consider adding peer reputation scoring to penalize peers sending invalid future blocks

## Proof of Concept

```rust
// PoC: Consensus Observer Payload Store Poisoning
// This demonstrates how an attacker can fill the payload store with future epoch blocks

use aptos_consensus_types::block_info::{BlockInfo, Round};
use aptos_crypto::HashValue;
use aptos_types::aggregate_signature::AggregateSignature;

// Step 1: Craft 150 BlockPayload messages with future epochs
fn craft_attack_payloads() -> Vec<BlockPayload> {
    let mut attack_payloads = vec![];
    let future_epoch = 999_999_999_u64; // Arbitrarily high epoch
    
    for round in 0..150 {
        // Create BlockInfo with future epoch
        let block_info = BlockInfo::new(
            future_epoch,
            round,
            HashValue::random(),
            HashValue::random(),
            0,
            0,
            None,
        );
        
        // Create empty transaction payload (passes digest verification)
        let transaction_payload = BlockTransactionPayload::empty();
        
        // Create the malicious payload
        let attack_payload = BlockPayload::new(block_info, transaction_payload);
        attack_payloads.push(attack_payload);
    }
    
    attack_payloads
}

// Step 2: Send attack payloads to target consensus observer node
// Each payload will:
// - Pass the "out of date" check (future_epoch > last_ordered_epoch)
// - Pass digest verification (empty payload is valid)
// - Bypass signature verification (future epoch != current epoch)
// - Get stored as "AvailableAndUnverified"
// - Occupy one of the 150 payload store slots

// Step 3: Once 150 payloads are stored, legitimate blocks are rejected
// The insert_block_payload method will hit the size limit check at line 86
// and drop all new blocks with a warning, including legitimate current epoch blocks

// Result: Consensus observer node is non-functional, cannot process consensus updates
```

**Test Scenario:**

1. Deploy a consensus observer node (VFN configuration)
2. Send 150 BlockPayload messages with `epoch = 999999999`, rounds 0-149
3. Observe payload store fills up completely with unverified future blocks
4. Attempt to send legitimate BlockPayload for current epoch
5. Verify legitimate block is rejected with "Exceeded the maximum number of payloads" warning
6. Confirm node cannot process any new consensus blocks
7. Verify future blocks remain in store indefinitely (check after multiple epoch transitions)

**Notes**

The vulnerability exists because the consensus observer architecture assumes all peers send reasonable messages and relies primarily on signature verification for authentication. However, the signature verification exemption for future epoch blocks creates a critical gap that allows unauthenticated pollution of the payload store.

The default configuration limit of 150 blocks makes this attack highly practical - an attacker only needs to send 150 messages to completely disable a consensus observer node. On test networks, the limit increases to 300 blocks, but this only marginally increases attack cost while the vulnerability remains fully exploitable.

The issue is particularly severe because consensus observer nodes (especially VFNs) play a critical role in the Aptos network architecture for validating and propagating consensus decisions. Disabling these nodes impacts network health and decentralization.

### Citations

**File:** consensus/src/payload_manager/co_payload_manager.rs (L78-81)
```rust
pub struct ConsensusObserverPayloadManager {
    txns_pool: Arc<Mutex<BTreeMap<(u64, Round), BlockPayloadStatus>>>,
    consensus_publisher: Option<Arc<ConsensusPublisher>>,
}
```

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L84-95)
```rust
        // Verify that the number of payloads doesn't exceed the maximum
        let max_num_pending_blocks = self.consensus_observer_config.max_num_pending_blocks as usize;
        if self.block_payloads.lock().len() >= max_num_pending_blocks {
            warn!(
                LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                    "Exceeded the maximum number of payloads: {:?}. Dropping block: {:?}!",
                    max_num_pending_blocks,
                    block_payload.block(),
                ))
            );
            return; // Drop the block if we've exceeded the maximum
        }
```

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L112-119)
```rust
    pub fn remove_blocks_for_epoch_round(&self, epoch: u64, round: Round) {
        // Determine the round to split off
        let split_off_round = round.saturating_add(1);

        // Remove the blocks from the payload store
        let mut block_payloads = self.block_payloads.lock();
        *block_payloads = block_payloads.split_off(&(epoch, split_off_round));
    }
```

**File:** consensus/src/consensus_observer/observer/payload_store.rs (L228-231)
```rust
            // Check if we can break early (BtreeMaps are sorted by key)
            if epoch > current_epoch {
                break;
            }
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L367-379)
```rust
        let last_ordered_block = self.observer_block_data.lock().get_last_ordered_block();
        let payload_out_of_date =
            (block_epoch, block_round) <= (last_ordered_block.epoch(), last_ordered_block.round());
        let payload_exists = self
            .observer_block_data
            .lock()
            .existing_payload_entry(&block_payload);

        // If the payload is out of date or already exists, ignore it
        if payload_out_of_date || payload_exists {
            // Update the metrics for the dropped block payload
            update_metrics_for_dropped_block_payload_message(peer_network_id, &block_payload);
            return;
```

**File:** consensus/src/consensus_observer/observer/consensus_observer.rs (L399-418)
```rust
        // If the payload is for the current epoch, verify the proof signatures
        let epoch_state = self.get_epoch_state();
        let verified_payload = if block_epoch == epoch_state.epoch {
            // Verify the block proof signatures
            if let Err(error) = block_payload.verify_payload_signatures(&epoch_state) {
                // Log the error and update the invalid message counter
                error!(
                    LogSchema::new(LogEntry::ConsensusObserver).message(&format!(
                        "Failed to verify block payload signatures! Ignoring block: {:?}, from peer: {:?}. Error: {:?}",
                        block_payload.block(), peer_network_id, error
                    ))
                );
                increment_invalid_message_counter(&peer_network_id, metrics::BLOCK_PAYLOAD_LABEL);
                return;
            }

            true // We have successfully verified the signatures
        } else {
            false // We can't verify the signatures yet
        };
```
