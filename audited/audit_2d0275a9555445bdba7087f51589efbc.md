# Audit Report

## Title
Network Isolation Breach: Peer Monitoring Service Leaks Validator Network Topology to Public Network Attackers

## Summary
The global `PeersAndMetadata` structure created by `create_peers_and_metadata()` aggregates peer information from all networks (validator and public) without maintaining isolation boundaries. The peer monitoring service's `GetNetworkInformation` RPC handler exposes this information to any connected peer, allowing attackers on the public network to enumerate validator network peers, their addresses, roles, and connection states.

## Finding Description

The vulnerability stems from an architectural design where a single global `PeersAndMetadata` structure is shared across all network types without network-level access controls.

**Step 1: Global Peers Structure Creation** [1](#0-0) 

The `create_peers_and_metadata()` function creates a single `PeersAndMetadata` instance initialized with ALL network IDs (validator + public networks combined), extracted via: [2](#0-1) 

**Step 2: Shared Across All Networks**

This same `PeersAndMetadata` instance is then passed to every network builder and application: [3](#0-2) 

**Step 3: Cross-Network Data Aggregation**

The `PeersAndMetadata` structure stores peers from all networks in a single data structure: [4](#0-3) 

Methods like `get_connected_peers_and_metadata()` iterate over ALL networks without filtering: [5](#0-4) 

**Step 4: Peer Monitoring Service Exposure**

The peer monitoring service, registered on ALL networks including public, exposes this aggregated data: [6](#0-5) 

When handling `GetNetworkInformation` requests, the server returns ALL connected peers: [7](#0-6) 

Note that the `network_id` parameter from the request handler is NOT used to filter results: [8](#0-7) 

**Step 5: Information Disclosure**

The response contains sensitive information about ALL connected peers: [9](#0-8) 

**Attack Scenario:**
1. Attacker operates a node on the public network
2. Attacker connects to a validator full node (VFN) that has both validator and public network connections
3. Attacker sends `PeerMonitoringServiceRequest::GetNetworkInformation` via the public network
4. VFN's peer monitoring service calls `get_connected_peers_and_metadata()` which returns peers from ALL networks
5. Response includes validator network peers with their `PeerNetworkId` (containing `NetworkId::Validator`), network addresses, peer IDs, and roles
6. Attacker learns the private validator network topology

**Evidence from Tests:**

The existing test demonstrates this cross-network behavior: [10](#0-9) 

The test shows that when peers are connected on both `NetworkId::Public` and `NetworkId::Validator`, the `GetNetworkInformation` response includes both peer types without filtering.

## Impact Explanation

**Severity: Medium** (up to $10,000 per Aptos bug bounty)

This vulnerability qualifies as a **medium severity information leak** with security implications:

1. **Information Disclosure**: Validator network topology, peer identities, and network addresses are exposed to unauthorized parties
2. **Reduced Network Anonymity**: Validators lose privacy protections intended by network segregation
3. **Increased Attack Surface**: Attackers can identify and target specific validators with DDoS or other network-layer attacks
4. **Security Architecture Violation**: Breaks the intended isolation between validator and public networks

While this does not directly lead to consensus violations or fund theft, it significantly weakens the security posture by exposing infrastructure that should remain private.

## Likelihood Explanation

**Likelihood: High**

The attack is trivial to execute:
- **No special privileges required**: Any peer can connect to the public network
- **No authentication bypass needed**: The peer monitoring service is legitimately accessible
- **Minimal complexity**: Single RPC call with standard protocol
- **Always exploitable**: The vulnerability exists in the core architecture, not an edge case
- **Currently deployed**: All nodes running both validator and public networks are affected

The attack can be executed with a simple script sending `GetNetworkInformation` requests.

## Recommendation

**Immediate Fix**: Implement network-scoped access controls in `PeersAndMetadata` methods.

**Option 1: Filter by Request Network (Minimal Change)**

Modify the peer monitoring service handler to filter results based on the requesting network:

```rust
fn get_network_information(&self, request_network_id: NetworkId) -> Result<PeerMonitoringServiceResponse, Error> {
    // Get the connected peers
    let connected_peers_and_metadata =
        self.peers_and_metadata.get_connected_peers_and_metadata()?;
    
    // Filter to only include peers from the same network as the requester
    let connected_peers = connected_peers_and_metadata
        .into_iter()
        .filter(|(peer_network_id, _)| peer_network_id.network_id() == request_network_id)
        .map(|(peer, metadata)| {
            let connection_metadata = metadata.get_connection_metadata();
            (
                peer,
                ConnectionMetadata::new(
                    connection_metadata.addr,
                    connection_metadata.remote_peer_id,
                    connection_metadata.role,
                ),
            )
        })
        .collect();
    // ... rest of function
}
```

Update the handler signature: [8](#0-7) 

Pass `network_id` to `get_network_information()`.

**Option 2: Network-Scoped PeersAndMetadata (Architectural Fix)**

Create separate `PeersAndMetadata` instances per network instead of a global shared instance. This ensures isolation at the data structure level.

**Option 3: Implement Network-Aware Access Control**

Add a method to `PeersAndMetadata` that takes a `NetworkId` parameter:

```rust
pub fn get_connected_peers_and_metadata_for_network(
    &self,
    network_id: &NetworkId,
) -> Result<HashMap<PeerNetworkId, PeerMetadata>, Error> {
    let cached_peers_and_metadata = self.cached_peers_and_metadata.load();
    
    let mut connected_peers_and_metadata = HashMap::new();
    if let Some(peers_and_metadata) = cached_peers_and_metadata.get(network_id) {
        for (peer_id, peer_metadata) in peers_and_metadata.iter() {
            if peer_metadata.is_connected() {
                let peer_network_id = PeerNetworkId::new(*network_id, *peer_id);
                connected_peers_and_metadata.insert(peer_network_id, peer_metadata.clone());
            }
        }
    }
    Ok(connected_peers_and_metadata)
}
```

## Proof of Concept

The vulnerability can be demonstrated by extending the existing test to explicitly show the cross-network leak:

```rust
#[tokio::test]
async fn test_network_isolation_breach() {
    use aptos_config::{config::{BaseConfig, RoleType}, network_id::{NetworkId, PeerNetworkId}};
    use aptos_types::PeerId;
    
    // Create a fullnode with both validator and public networks
    let base_config = BaseConfig {
        role: RoleType::FullNode,
        ..Default::default()
    };
    let (mut mock_client, service, _, peers_and_metadata) =
        MockClient::new(Some(base_config), None, None);
    tokio::spawn(service.start());
    
    // Simulate a validator network peer connection
    let validator_peer_id = PeerId::random();
    let validator_peer = PeerNetworkId::new(NetworkId::Validator, validator_peer_id);
    let validator_metadata = create_connection_metadata(validator_peer_id, PeerRole::Validator);
    peers_and_metadata
        .insert_connection_metadata(validator_peer, validator_metadata.clone())
        .unwrap();
    
    // Simulate a public network peer connection
    let public_peer_id = PeerId::random();
    let public_peer = PeerNetworkId::new(NetworkId::Public, public_peer_id);
    let public_metadata = create_connection_metadata(public_peer_id, PeerRole::Unknown);
    peers_and_metadata
        .insert_connection_metadata(public_peer, public_metadata.clone())
        .unwrap();
    
    // Attacker on public network requests network information
    let request = PeerMonitoringServiceRequest::GetNetworkInformation;
    let response = mock_client.send_request(request).await.unwrap();
    
    // Verify the response leaks validator network information
    match response {
        PeerMonitoringServiceResponse::NetworkInformation(info) => {
            // VULNERABILITY: Response includes peers from both networks
            assert!(info.connected_peers.contains_key(&validator_peer),
                "Validator peer should NOT be visible to public network attacker!");
            assert!(info.connected_peers.contains_key(&public_peer),
                "Public peer should be visible");
            
            // Attacker now knows:
            // 1. Validator peer ID
            // 2. Validator network address
            // 3. Validator role
            let leaked_validator = &info.connected_peers[&validator_peer];
            println!("LEAKED: Validator {} at {} with role {:?}",
                leaked_validator.peer_id,
                leaked_validator.network_address,
                leaked_validator.peer_role);
        }
        _ => panic!("Unexpected response type"),
    }
}
```

This PoC demonstrates that a simple `GetNetworkInformation` request from any network returns information about peers on ALL networks, violating network isolation.

## Notes

- The vulnerability exists in the architectural design, not a coding error
- All nodes running multiple networks (VFNs with both validator and public networks) are affected
- The existing test suite demonstrates this behavior but treats it as expected functionality
- Similar cross-network access may exist in other services that use the global `PeersAndMetadata` structure
- The inspection service endpoint `/peer_information` has a similar issue but is protected by a configuration flag (`expose_peer_information`)

### Citations

**File:** aptos-node/src/network.rs (L217-228)
```rust
/// Extracts all network configs from the given node config
fn extract_network_configs(node_config: &NodeConfig) -> Vec<NetworkConfig> {
    let mut network_configs: Vec<NetworkConfig> = node_config.full_node_networks.to_vec();
    if let Some(network_config) = node_config.validator_network.as_ref() {
        // Ensure that mutual authentication is enabled by default!
        if !network_config.mutual_authentication {
            panic!("Validator networks must always have mutual_authentication enabled!");
        }
        network_configs.push(network_config.clone());
    }
    network_configs
}
```

**File:** aptos-node/src/network.rs (L238-242)
```rust
/// Creates the global peers and metadata struct
pub fn create_peers_and_metadata(node_config: &NodeConfig) -> Arc<PeersAndMetadata> {
    let network_ids = extract_network_ids(node_config);
    PeersAndMetadata::new(&network_ids)
}
```

**File:** aptos-node/src/network.rs (L282-290)
```rust
        // Create a new network builder
        let mut network_builder = NetworkBuilder::create(
            chain_id,
            node_config.base.role,
            &network_config,
            TimeService::real(),
            Some(event_subscription_service),
            peers_and_metadata.clone(),
        );
```

**File:** aptos-node/src/network.rs (L370-378)
```rust
        // Register the peer monitoring service (both client and server) with the network
        let peer_monitoring_service_network_handle = register_client_and_service_with_network(
            &mut network_builder,
            network_id,
            &network_config,
            peer_monitoring_network_configuration(node_config),
            true,
        );
        peer_monitoring_service_network_handles.push(peer_monitoring_service_network_handle);
```

**File:** network/framework/src/application/storage.rs (L42-54)
```rust
pub struct PeersAndMetadata {
    peers_and_metadata: RwLock<HashMap<NetworkId, HashMap<PeerId, PeerMetadata>>>,
    trusted_peers: HashMap<NetworkId, Arc<ArcSwap<PeerSet>>>,

    // We maintain a cached copy of the peers and metadata. This is useful to
    // reduce lock contention, as we expect very heavy and frequent reads,
    // but infrequent writes. The cache is updated on all underlying updates.
    //
    // TODO: should we remove this when generational versioning is supported?
    cached_peers_and_metadata: Arc<ArcSwap<HashMap<NetworkId, HashMap<PeerId, PeerMetadata>>>>,

    subscribers: Mutex<Vec<tokio::sync::mpsc::Sender<ConnectionNotification>>>,
}
```

**File:** network/framework/src/application/storage.rs (L107-125)
```rust
    /// Returns metadata for all peers currently connected to the node
    pub fn get_connected_peers_and_metadata(
        &self,
    ) -> Result<HashMap<PeerNetworkId, PeerMetadata>, Error> {
        // Get the cached peers and metadata
        let cached_peers_and_metadata = self.cached_peers_and_metadata.load();

        // Collect all connected peers
        let mut connected_peers_and_metadata = HashMap::new();
        for (network_id, peers_and_metadata) in cached_peers_and_metadata.iter() {
            for (peer_id, peer_metadata) in peers_and_metadata.iter() {
                if peer_metadata.is_connected() {
                    let peer_network_id = PeerNetworkId::new(*network_id, *peer_id);
                    connected_peers_and_metadata.insert(peer_network_id, peer_metadata.clone());
                }
            }
        }
        Ok(connected_peers_and_metadata)
    }
```

**File:** peer-monitoring-service/server/src/lib.rs (L155-182)
```rust
    pub fn call(
        &self,
        network_id: NetworkId,
        request: PeerMonitoringServiceRequest,
    ) -> Result<PeerMonitoringServiceResponse> {
        // Update the request count
        increment_counter(
            &metrics::PEER_MONITORING_REQUESTS_RECEIVED,
            network_id,
            request.get_label(),
        );

        // Time the request processing (the timer will stop when it's dropped)
        let _timer = start_timer(
            &metrics::PEER_MONITORING_REQUEST_PROCESSING_LATENCY,
            network_id,
            request.get_label(),
        );

        // Process the request
        let response = match &request {
            PeerMonitoringServiceRequest::GetNetworkInformation => self.get_network_information(),
            PeerMonitoringServiceRequest::GetServerProtocolVersion => {
                self.get_server_protocol_version()
            },
            PeerMonitoringServiceRequest::GetNodeInformation => self.get_node_information(),
            PeerMonitoringServiceRequest::LatencyPing(request) => self.handle_latency_ping(request),
        };
```

**File:** peer-monitoring-service/server/src/lib.rs (L217-248)
```rust
    fn get_network_information(&self) -> Result<PeerMonitoringServiceResponse, Error> {
        // Get the connected peers
        let connected_peers_and_metadata =
            self.peers_and_metadata.get_connected_peers_and_metadata()?;
        let connected_peers = connected_peers_and_metadata
            .into_iter()
            .map(|(peer, metadata)| {
                let connection_metadata = metadata.get_connection_metadata();
                (
                    peer,
                    ConnectionMetadata::new(
                        connection_metadata.addr,
                        connection_metadata.remote_peer_id,
                        connection_metadata.role,
                    ),
                )
            })
            .collect();

        // Get the distance from the validators
        let distance_from_validators =
            get_distance_from_validators(&self.base_config, self.peers_and_metadata.clone());

        // Create and return the response
        let network_information_response = NetworkInformationResponse {
            connected_peers,
            distance_from_validators,
        };
        Ok(PeerMonitoringServiceResponse::NetworkInformation(
            network_information_response,
        ))
    }
```

**File:** peer-monitoring-service/types/src/response.rs (L50-75)
```rust
/// A response for the network information request
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct NetworkInformationResponse {
    pub connected_peers: BTreeMap<PeerNetworkId, ConnectionMetadata>, // Connected peers
    pub distance_from_validators: u64, // The distance of the peer from the validator set
}

// Display formatting provides a high-level summary of the response
impl Display for NetworkInformationResponse {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        write!(
            f,
            "{{ num_connected_peers: {:?}, distance_from_validators: {:?} }}",
            self.connected_peers.len(),
            self.distance_from_validators,
        )
    }
}

/// Simple connection metadata associated with each peer
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct ConnectionMetadata {
    pub network_address: NetworkAddress,
    pub peer_id: PeerId,
    pub peer_role: PeerRole,
}
```

**File:** peer-monitoring-service/server/src/tests.rs (L175-200)
```rust
    // Connect another peer to the fullnode
    let peer_id_2 = PeerId::random();
    let peer_network_id_2 = PeerNetworkId::new(NetworkId::Validator, peer_id_2);
    let peer_distance_2 = 0; // The peer is a validator
    let connection_metadata_2 = create_connection_metadata(peer_id_2, PeerRole::Validator);
    let expected_peers = btreemap! {peer_network_id_1 => connection_metadata_1.clone(), peer_network_id_2 => connection_metadata_2.clone()};
    let latest_network_info_response = NetworkInformationResponse {
        connected_peers: transform_connection_metadata(expected_peers),
        distance_from_validators: peer_distance_2,
    };
    let peer_monitoring_metadata_2 =
        PeerMonitoringMetadata::new(None, None, Some(latest_network_info_response), None, None);
    peers_and_metadata
        .insert_connection_metadata(peer_network_id_2, connection_metadata_2.clone())
        .unwrap();
    peers_and_metadata
        .update_peer_monitoring_metadata(peer_network_id_2, peer_monitoring_metadata_2.clone())
        .unwrap();

    // Process a client request to fetch the network information and verify the response
    verify_network_information(
        &mut mock_client,
        btreemap! {peer_network_id_1 => connection_metadata_1.clone(), peer_network_id_2 => connection_metadata_2},
        peer_distance_2 + 1,
    )
    .await;
```
