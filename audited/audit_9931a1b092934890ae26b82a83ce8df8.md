# Audit Report

## Title
StateKey Ord/Eq Semantic Inconsistency Violates Rust Standard Library Invariants

## Summary
`StateKey` implements pointer-based equality via `Arc::ptr_eq()` but content-based ordering via `deserialized.cmp()`, violating Rust's fundamental requirement that `Ord` and `Eq` must be consistent. This inconsistency affects all `BTreeMap<StateKey, _>` and `BTreeSet<StateKey>` usage throughout the codebase, potentially causing incorrect data structure behavior.

## Finding Description
The `StateKey` type is used as a key in both `HashMap` (block partitioner, executor) and `BTreeMap`/`BTreeSet` (VM change sets, write sets) throughout the Aptos codebase. However, it has fundamentally inconsistent comparison semantics: [1](#0-0) [2](#0-1) 

This creates a semantic violation where two `StateKey` instances with identical content but different `Arc` pointers will:
- Return `Ordering::Equal` via `cmp()` (content comparison)
- Return `false` via `==` (pointer comparison)

This violates the Rust standard library's documented requirement that "if `a.cmp(&b) == Ordering::Equal`, then `a == b` must be true."

The inconsistency propagates to `StorageLocation`: [3](#0-2) 

Since `StorageLocation` derives `Eq` and `PartialEq`, it inherits the pointer-based equality from its contained `StateKey`.

**Critical usage in BTreeMap/BTreeSet:** [4](#0-3) 

The `VMChangeSet` uses `BTreeMap<StateKey, _>` for resource writes and aggregator operations. BTreeMap relies on the Ord/Eq consistency guarantee for correct operation.

**Exploitation path:**

While the `REGISTRY` interning mechanism usually prevents `StateKey` instances with the same content from having different Arc pointers within a single process: [5](#0-4) 

The weak reference pattern can fail if:

1. StateKeys are created, used, and dropped before new ones for the same content are requested
2. The weak reference upgrade fails (Arc refcount = 0)
3. A new Arc instance is created for the same content [6](#0-5) 

This would cause BTreeMap operations to produce incorrect results, as keys that should be equal (same content) are treated as distinct (different pointers).

## Impact Explanation
**Severity: Medium**

While this is a fundamental semantic violation that affects core data structures, its impact is mitigated by the REGISTRY deduplication mechanism that works correctly in most scenarios. However, the bug violates critical invariants:

- **Deterministic Execution Risk**: If different validators somehow have StateKeys with different Arc pointers for the same content, their BTreeMap-based structures would have different internal states, potentially leading to different execution results and state root mismatches.

- **Data Structure Correctness**: BTreeMap operations (insertion, lookup, iteration order) may behave incorrectly when the Ord/Eq invariant is violated, though this would be subtle and hard to trigger.

This doesn't meet Critical severity because:
- No immediate consensus violation path identified
- REGISTRY deduplication works in normal operation
- No evidence of cross-validator StateKey serialization that would break Arc pointer identity

## Likelihood Explanation
**Likelihood: Low**

The vulnerability requires the REGISTRY's weak reference deduplication to fail, which is unlikely in normal operation because:

1. StateKeys used in active data structures keep their Arc refcounts > 0
2. The REGISTRY's double-checked locking correctly handles concurrent access
3. Factory methods consistently use the REGISTRY

However, the bug remains a latent design flaw that could be triggered by:
- Future refactoring that changes StateKey lifecycle
- Race conditions in StateKey creation/destruction
- Edge cases not covered by current testing

## Recommendation
**Fix the semantic inconsistency by using content-based equality:**

The `StateKey` equality and hashing should be consistent with ordering. Modify the `PartialEq` implementation:

```rust
impl PartialEq for StateKey {
    fn eq(&self, other: &Self) -> bool {
        // Use content comparison instead of pointer comparison
        self.0.deserialized == other.0.deserialized
    }
}
```

Alternatively, keep pointer-based equality but change ordering to be pointer-based:

```rust
impl Ord for StateKey {
    fn cmp(&self, other: &Self) -> Ordering {
        // Use pointer comparison for consistency with Eq
        Arc::as_ptr(&self.0).cmp(&Arc::as_ptr(&other.0))
    }
}
```

The first approach (content-based equality) is semantically correct for storage locations and aligns with the REGISTRY's deduplication intent. The second approach maintains current performance characteristics but requires careful handling of StateKey lifecycle.

## Proof of Concept

```rust
// Demonstration of Ord/Eq inconsistency
use aptos_types::state_store::state_key::StateKey;
use std::cmp::Ordering;

#[test]
fn test_statekey_ord_eq_inconsistency() {
    // Create two StateKeys with the same content
    let key1 = StateKey::raw(b"test_key");
    let key2 = StateKey::raw(b"test_key");
    
    // These should be deduplicated by REGISTRY, but if weak ref is dropped:
    // Ordering comparison (content-based) would return Equal
    assert_eq!(key1.cmp(&key2), Ordering::Equal);
    
    // But equality comparison (pointer-based) would return false
    // This assertion would fail if Arc pointers differ:
    // assert_eq!(key1, key2);  // May fail!
    
    // This violates: if a.cmp(&b) == Equal, then a == b must be true
    if key1.cmp(&key2) == Ordering::Equal {
        assert!(key1 == key2, "Ord/Eq inconsistency detected!");
    }
}

#[test]
fn test_btreemap_invariant_violation() {
    use std::collections::BTreeMap;
    
    let mut map = BTreeMap::new();
    let key1 = StateKey::raw(b"test");
    
    map.insert(key1.clone(), "value1");
    
    // If a second StateKey with same content but different Arc is created:
    let key2 = StateKey::raw(b"test");
    
    // BTreeMap may treat them as different keys despite cmp() returning Equal
    // This could lead to duplicate entries or incorrect lookups
    map.insert(key2, "value2");
    
    // The map might have 1 or 2 entries depending on Arc pointer identity
    println!("Map size: {}", map.len());
}
```

### Citations

**File:** types/src/state_store/state_key/mod.rs (L261-267)
```rust
impl PartialEq for StateKey {
    fn eq(&self, other: &Self) -> bool {
        Arc::ptr_eq(&self.0, &other.0)
    }
}

impl Eq for StateKey {}
```

**File:** types/src/state_store/state_key/mod.rs (L275-286)
```rust
impl PartialOrd for StateKey {
    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {
        // TODO: consider more efficient PartialOrd && Ord, maybe on another wrapper type, so keys
        //       can be hosted more cheaply in a BTreeSet
        self.0.deserialized.partial_cmp(&other.0.deserialized)
    }
}

impl Ord for StateKey {
    fn cmp(&self, other: &Self) -> Ordering {
        self.0.deserialized.cmp(&other.0.deserialized)
    }
```

**File:** types/src/transaction/analyzed_transaction.rs (L39-49)
```rust
#[derive(Debug, Clone, Hash, Eq, PartialEq, Serialize, Deserialize)]
// TODO(skedia): Evaluate if we need to cache the HashValue for efficiency reasons.
pub enum StorageLocation {
    // A specific storage location denoted by an address and a struct tag.
    Specific(StateKey),
    // Storage location denoted by a struct tag and any arbitrary address.
    // Example read<T>(*), write<T>(*) in Move
    WildCardStruct(StructTag),
    // Storage location denoted by a table handle and any arbitrary item in the table.
    WildCardTable(TableHandle),
}
```

**File:** aptos-move/aptos-vm-types/src/change_set.rs (L76-92)
```rust
/// A change set produced by the VM.
///
/// **WARNING**: Just like VMOutput, this type should only be used inside the
/// VM. For storage backends, use `ChangeSet`.
#[derive(Debug, Clone, Eq, PartialEq)]
pub struct VMChangeSet {
    resource_write_set: BTreeMap<StateKey, AbstractResourceWriteOp>,
    events: Vec<(ContractEvent, Option<MoveTypeLayout>)>,

    // Changes separated out from the writes, for better concurrency,
    // materialized back into resources when transaction output is computed.
    delayed_field_change_set: BTreeMap<DelayedFieldID, DelayedChange<DelayedFieldID>>,

    // TODO[agg_v1](cleanup) deprecate aggregator_v1 fields.
    aggregator_v1_write_set: BTreeMap<StateKey, WriteOp>,
    aggregator_v1_delta_set: BTreeMap<StateKey, DeltaOp>,
}
```

**File:** types/src/state_store/state_key/registry.rs (L136-146)
```rust
                Some(weak) => match weak.upgrade() {
                    Some(entry) => {
                        // some other thread has added it
                        entry
                    },
                    None => {
                        // previous version of this key is being dropped.
                        let entry = Entry::new(deserialized, encoded, hash_value);
                        Self::insert_key2(map2, key2.to_owned(), entry)
                    },
                },
```

**File:** types/src/state_store/state_key/registry.rs (L194-194)
```rust
pub static REGISTRY: Lazy<StateKeyRegistry> = Lazy::new(StateKeyRegistry::default);
```
