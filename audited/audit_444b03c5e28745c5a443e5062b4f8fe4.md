# Audit Report

## Title
JWK Patch Rollback Vulnerability: Missing Version Tracking Allows Restoration of Compromised Keys

## Summary
The `Patches` resource in the JWK management system lacks version tracking, allowing governance proposals to rollback previously applied security patches. This enables restoration of compromised JWKs that were intentionally removed, breaking keyless account authentication security.

## Finding Description

The JWK (JSON Web Key) management system in Aptos maintains three critical resources:

1. **ObservedJWKs** - Base state from validator consensus (has version tracking per issuer)
2. **Patches** - Governance-controlled modifications (NO version tracking)
3. **PatchedJWKs** - Final state used by applications = ObservedJWKs + Patches

The `Patches` resource has no version tracking or monotonicity enforcement: [1](#0-0) 

The `set_patches()` function allows governance to set patches to ANY arbitrary vector without validation: [2](#0-1) 

When patches are regenerated, they're applied sequentially to ObservedJWKs with no historical tracking: [3](#0-2) 

**Attack Scenario:**

1. **T1**: OIDC provider's JWK endpoint hosts a key that becomes compromised. ObservedJWKs contains: `{issuer: "provider.com", jwks: [good_key_1, compromised_key_2, good_key_3]}`

2. **T2**: Governance responds to security incident by setting patches to remove the compromised key:
   ```
   set_patches([PatchRemoveJWK("provider.com", "compromised_key_2")])
   ```
   PatchedJWKs now safely excludes compromised_key_2.

3. **T3**: Attacker (or compromised governance participant) creates a NEW governance proposal that calls:
   ```
   set_patches([])  // Empty patches
   ```

4. **T4**: If this malicious proposal passes voting, `regenerate_patched_jwks()` executes:
   - Starts with ObservedJWKs (still contains compromised_key_2 if provider hasn't rotated)
   - Applies ZERO patches
   - Result: PatchedJWKs now contains compromised_key_2 again

5. **T5**: Attacker uses the compromised private key to forge JWTs and authenticate as any user

This violates the **Governance Integrity** and **Access Control** invariants. The `PatchedJWKs` struct in Rust reflects this lack of versioning: [4](#0-3) 

While `ProviderJWKs` has version tracking for consensus deduplication: [5](#0-4) 

The `Patches` resource has no equivalent protection, allowing arbitrary rollback through new governance proposals.

## Impact Explanation

**Critical Severity** - This vulnerability meets multiple critical impact criteria:

1. **Authentication Bypass**: Keyless accounts rely on JWK verification. Restored compromised keys enable JWT forgery, allowing attackers to authenticate as any user.

2. **Loss of Funds**: Compromised authentication leads to unauthorized transaction execution, enabling direct theft from keyless accounts.

3. **Consensus/Safety Violation**: Different nodes may see different PatchedJWKs states during rollback transitions, potentially causing transaction execution disagreements if JWK verification results differ.

4. **Bypasses Emergency Response**: The patches mechanism is designed for emergency security responses (e.g., removing compromised keys before OIDC providers rotate). Rollback capability renders this emergency mechanism ineffective.

Per Aptos Bug Bounty severity categories, this qualifies as **Critical** due to authentication bypass leading to potential loss of funds and consensus safety implications.

## Likelihood Explanation

**Medium-High Likelihood** - This vulnerability has realistic exploitation paths:

**Requirements:**
- Governance proposal must pass voting (requires stake accumulation or social engineering)
- OR governance participants must be compromised
- Original compromised key must still exist in ObservedJWKs (provider hasn't rotated)

**Realistic Scenarios:**
1. **Delayed Provider Response**: OIDC providers may be slow to rotate compromised keys, leaving them in ObservedJWKs for extended periods
2. **Governance Manipulation**: Attacker accumulates voting power or socially engineers proposal approval
3. **Insider Compromise**: Governance participant accounts get compromised
4. **Policy Dispute**: Legitimate governance participants may disagree about patch necessity and vote to remove "overly cautious" patches

The vulnerability is particularly concerning because:
- No technical barriers prevent execution once governance access obtained
- No alerts or warnings when patches are rolled back
- Applications blindly consume PatchedJWKs without version verification

## Recommendation

Add version tracking and monotonicity enforcement to the `Patches` resource:

**Solution 1: Add Version Field**
```move
struct Patches has key {
    patches: vector<Patch>,
    version: u64,  // New field
}

public fun set_patches(fx: &signer, patches: vector<Patch>) acquires Patches, PatchedJWKs, ObservedJWKs {
    system_addresses::assert_aptos_framework(fx);
    let patches_resource = borrow_global_mut<Patches>(@aptos_framework);
    
    // Enforce monotonic version increase
    patches_resource.version = patches_resource.version + 1;
    patches_resource.patches = patches;
    
    regenerate_patched_jwks();
}
```

**Solution 2: Append-Only Patches**
```move
public fun append_patch(fx: &signer, patch: Patch) acquires Patches, PatchedJWKs, ObservedJWKs {
    system_addresses::assert_aptos_framework(fx);
    let patches_resource = borrow_global_mut<Patches>(@aptos_framework);
    
    // Only allow appending, never removing
    vector::push_back(&mut patches_resource.patches, patch);
    
    regenerate_patched_jwks();
}
```

**Solution 3: Hash-Chain Verification**
```move
struct Patches has key {
    patches: vector<Patch>,
    version: u64,
    previous_hash: vector<u8>,  // Hash of previous patches state
}
```

**Recommended Approach**: Implement Solution 1 (version tracking) with the following enhancements:
- Emit events when patches are modified, including version number
- Add `require_minimum_patch_version()` function that applications can call
- Consider adding a governance timelock for patch modifications

## Proof of Concept

```move
#[test(aptos_framework = @aptos_framework)]
fun test_patch_rollback_vulnerability(aptos_framework: signer) acquires ObservedJWKs, PatchedJWKs, Patches {
    // Initialize JWK system
    initialize_for_test(&aptos_framework);
    features::change_feature_flags_for_testing(
        &aptos_framework,
        vector[],
        vector[features::get_jwk_consensus_per_key_mode_feature()]
    );

    // Step 1: Validators observe JWKs including a compromised key
    let good_jwk = new_unsupported_jwk(b"good_key_id", b"good_key_payload");
    let compromised_jwk = new_unsupported_jwk(b"compromised_key_id", b"COMPROMISED_PAYLOAD");
    
    upsert_into_observed_jwks(&aptos_framework, vector[
        ProviderJWKs {
            issuer: b"https://provider.com",
            version: 1,
            jwks: vector[good_jwk, compromised_jwk],
        }
    ]);
    
    // Verify compromised key is accessible
    assert!(option::is_some(&try_get_patched_jwk(b"https://provider.com", b"compromised_key_id")), 1);

    // Step 2: Emergency response - governance removes compromised key via patch
    set_patches(&aptos_framework, vector[
        new_patch_remove_jwk(b"https://provider.com", b"compromised_key_id"),
    ]);
    
    // Verify compromised key is now blocked
    assert!(option::is_none(&try_get_patched_jwk(b"https://provider.com", b"compromised_key_id")), 2);
    
    // Step 3: ATTACK - Malicious governance proposal rolls back patches
    set_patches(&aptos_framework, vector[]);  // Empty patches = rollback
    
    // Step 4: VULNERABILITY - Compromised key is restored!
    let restored_jwk = try_get_patched_jwk(b"https://provider.com", b"compromised_key_id");
    assert!(option::is_some(&restored_jwk), 3);
    
    // The compromised key can now be used to forge JWTs and bypass authentication
    let restored_key = option::extract(&mut restored_jwk);
    assert!(restored_key == compromised_jwk, 4);
}
```

**Notes:**
- This vulnerability exists at the governance mechanism layer, not requiring validator insider access
- The lack of version tracking violates security-in-depth principles for emergency response systems
- While exploitation requires governance access, the vulnerability itself is in the patch management design
- The issue is particularly severe because patches are explicitly designed for emergency security responses
- ObservedJWKs has proper version tracking (line 102), but Patches does not, creating an asymmetric security model

### Citations

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L94-106)
```text
    struct ProviderJWKs has copy, drop, store {
        /// The utf-8 encoding of the issuer string (e.g., "https://www.facebook.com").
        issuer: vector<u8>,

        /// A version number is needed by JWK consensus to dedup the updates.
        /// e.g, when on chain version = 5, multiple nodes can propose an update with version = 6.
        /// Bumped every time the JWKs for the current issuer is updated.
        /// The Rust authenticator only uses the latest version.
        version: u64,

        /// Vector of `JWK`'s sorted by their unique ID (from `get_jwk_id`) in dictionary order.
        jwks: vector<JWK>,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L157-162)
```text
    /// A sequence of `Patch` objects that are applied *one by one* to the `ObservedJWKs`.
    ///
    /// Maintained by governance proposals.
    struct Patches has key {
        patches: vector<Patch>,
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L379-383)
```text
    public fun set_patches(fx: &signer, patches: vector<Patch>) acquires Patches, PatchedJWKs, ObservedJWKs {
        system_addresses::assert_aptos_framework(fx);
        borrow_global_mut<Patches>(@aptos_framework).patches = patches;
        regenerate_patched_jwks();
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L523-531)
```text
    fun regenerate_patched_jwks() acquires PatchedJWKs, Patches, ObservedJWKs {
        let jwks = borrow_global<ObservedJWKs>(@aptos_framework).jwks;
        let patches = borrow_global<Patches>(@aptos_framework);
        vector::for_each_ref(&patches.patches, |obj|{
            let patch: &Patch = obj;
            apply_patch(&mut jwks, *patch);
        });
        *borrow_global_mut<PatchedJWKs>(@aptos_framework) = PatchedJWKs { jwks };
    }
```

**File:** types/src/jwks/mod.rs (L281-284)
```rust
#[derive(Debug, Serialize, Deserialize, PartialEq)]
pub struct PatchedJWKs {
    pub jwks: AllProvidersJWKs,
}
```
