# Audit Report

## Title
Non-Canonical JSON Serialization in UnsupportedJWK Causes Consensus State Inconsistencies and Duplicate JWKs

## Summary
The `UnsupportedJWK::from(serde_json::Value)` implementation uses non-canonical JSON serialization to generate payload bytes, which are then hashed to create the JWK ID. Different JSON formatting of the same logical JWK (different key ordering, whitespace, etc.) produces different IDs, allowing duplicate JWKs in consensus state and causing validator disagreements.

## Finding Description

The vulnerability exists in the conversion of `serde_json::Value` to `UnsupportedJWK`. [1](#0-0) 

The implementation calls `json_value.to_string()` which preserves the internal key ordering from JSON deserialization. When validators fetch JWKs from OIDC providers, they may receive the same logical JWK with different JSON formatting due to:
- Different server instances or load balancers
- Different JSON library versions
- Network caching layers
- Different API response ordering (JSON spec doesn't guarantee key order)

**Attack Path:**

1. OIDC provider publishes an EC (Elliptic Curve) JWK that Aptos doesn't yet support, which becomes an `UnsupportedJWK`
2. Validators fetch from the provider's JWKs endpoint [2](#0-1) 
3. Due to normal web service behavior, different validators receive different JSON formatting:
   - Validator A: `{"kid":"abc","kty":"EC","crv":"P-256",...}`
   - Validator B: `{"kty":"EC","kid":"abc","crv":"P-256",...}`
4. Both parse to `serde_json::Value` but preserve different internal key orders
5. Both convert via `JWK::from()` [3](#0-2) 
6. Since `kty` is not "RSA", both become `UnsupportedJWK` instances
7. The `to_string()` output differs based on preserved key order, producing different payload bytes
8. Different payloads → different SHA3-256 hashes → different IDs
9. In the consensus state, these are treated as distinct JWKs [4](#0-3) 

The `upsert_jwk()` function compares JWKs by ID for deduplication. JWKs with different IDs are inserted as separate entries, even if they represent the same logical key. This violates the **Deterministic Execution** invariant - validators observing the same logical data produce different state.

## Impact Explanation

**High Severity** - This constitutes a "Significant protocol violation" under the Aptos bug bounty criteria:

1. **Consensus State Corruption**: The same logical JWK is stored multiple times with different IDs in `ObservedJWKs`, violating state consistency guarantees

2. **Keyless Account Validation Failures**: When the keyless validation system looks up a JWK by its expected ID, it may fail to find the correct key because it was stored under a different ID hash, blocking legitimate user transactions

3. **Version Number Conflicts**: The per-issuer versioning mechanism [5](#0-4)  assumes validators agree on JWK identities. Different IDs for the same logical key can cause version mismatch rejections

4. **Validator Disagreement**: Validators reach different conclusions about which JWKs exist, potentially causing consensus delays or requiring manual intervention to resolve state inconsistencies

This does not meet Critical severity as it doesn't cause permanent network failure or direct fund loss, but constitutes a significant operational and security issue.

## Likelihood Explanation

**High Likelihood** - This will occur in production:

1. **External Dependency**: OIDC providers (Google, Apple, Auth0, AWS Cognito) are external services that routinely return JSON with varying formats
2. **No Attacker Required**: Normal web service behavior (load balancing, caching, server diversity) naturally produces different JSON formatting
3. **JSON Specification**: The JSON specification explicitly does NOT guarantee object key ordering, making format variations expected and compliant
4. **Observed Pattern**: The TODO comment acknowledges the issue [6](#0-5) , suggesting developers are aware of the canonicalization requirement
5. **Active Feature**: JWK consensus is actively used for keyless accounts, processing updates from real OIDC providers

## Recommendation

Implement canonical JSON serialization before computing the payload and ID:

```rust
impl From<serde_json::Value> for UnsupportedJWK {
    fn from(json_value: serde_json::Value) -> Self {
        // Use canonical JSON serialization (sorted keys, no whitespace)
        let payload = canonical_json::to_string(&json_value)
            .unwrap_or_else(|_| json_value.to_string())
            .into_bytes();
        Self {
            id: HashValue::sha3_256_of(payload.as_slice()).to_vec(),
            payload,
        }
    }
}
```

Use a canonical JSON library like `canonical_json` or implement a custom serializer that:
- Sorts object keys lexicographically
- Uses consistent whitespace (none)
- Has deterministic number formatting
- Produces identical output for logically identical JSON

Alternatively, parse the JSON into a normalized internal representation before hashing, ensuring validators always produce the same ID for the same logical JWK regardless of input formatting.

## Proof of Concept

```rust
#[test]
fn test_unsupported_jwk_non_canonical_formatting() {
    use serde_json::json;
    use aptos_crypto::HashValue;
    
    // Same logical JWK, different key ordering
    let jwk1 = json!({
        "kid": "test-key",
        "kty": "EC",
        "crv": "P-256"
    });
    
    let jwk2 = json!({
        "kty": "EC",
        "kid": "test-key",
        "crv": "P-256"
    });
    
    // Convert to UnsupportedJWK
    let unsupported1 = UnsupportedJWK::from(jwk1);
    let unsupported2 = UnsupportedJWK::from(jwk2);
    
    // VULNERABILITY: Same logical JWK produces different IDs
    assert_ne!(unsupported1.id, unsupported2.id, 
        "Different JSON formatting produced different IDs for same logical JWK");
    
    // This means the same JWK can be stored twice in consensus state
    println!("JWK1 ID: {}", hex::encode(&unsupported1.id));
    println!("JWK2 ID: {}", hex::encode(&unsupported2.id));
    println!("JWK1 payload: {}", String::from_utf8_lossy(&unsupported1.payload));
    println!("JWK2 payload: {}", String::from_utf8_lossy(&unsupported2.payload));
}
```

This test demonstrates that the same logical JWK data with different JSON key ordering produces different `UnsupportedJWK` IDs, confirming the vulnerability.

## Notes

The existing TODO comment in the code indicates developer awareness of the canonicalization requirement, but no fix has been implemented. This vulnerability affects all UnsupportedJWK instances created from externally-fetched JSON, which includes all non-RSA JWKs observed from OIDC providers in the JWK consensus system. The issue does NOT affect `RSA_JWK` because it extracts specific fields rather than serializing the entire JSON. [7](#0-6)

### Citations

**File:** types/src/jwks/unsupported/mod.rs (L51-59)
```rust
impl From<serde_json::Value> for UnsupportedJWK {
    fn from(json_value: serde_json::Value) -> Self {
        let payload = json_value.to_string().into_bytes(); //TODO: canonical to_string.
        Self {
            id: HashValue::sha3_256_of(payload.as_slice()).to_vec(),
            payload,
        }
    }
}
```

**File:** crates/jwk-utils/src/lib.rs (L25-37)
```rust
pub async fn fetch_jwks_from_jwks_uri(
    my_addr: Option<AccountAddress>,
    jwks_uri: &str,
) -> Result<Vec<JWK>> {
    let client = reqwest::Client::new();
    let mut request_builder = client.get(jwks_uri);
    if let Some(addr) = my_addr {
        request_builder = request_builder.header(COOKIE, addr.to_hex());
    }
    let JWKsResponse { keys } = request_builder.send().await?.json().await?;
    let jwks = keys.into_iter().map(JWK::from).collect();
    Ok(jwks)
}
```

**File:** types/src/jwks/jwk/mod.rs (L80-90)
```rust
impl From<serde_json::Value> for JWK {
    fn from(value: serde_json::Value) -> Self {
        match RSA_JWK::try_from(&value) {
            Ok(rsa) => Self::RSA(rsa),
            Err(_) => {
                let unsupported = UnsupportedJWK::from(value);
                Self::Unsupported(unsupported)
            },
        }
    }
}
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L478-493)
```text
                assert!(cur_issuer_jwks.version + 1 == proposed_provider_jwks.version, error::invalid_argument(EUNEXPECTED_VERSION));
                vector::for_each(proposed_provider_jwks.jwks, |jwk|{
                    let variant_type_name = *string::bytes(copyable_any::type_name(&jwk.variant));
                    let is_delete = if (variant_type_name == b"0x1::jwks::UnsupportedJWK") {
                        let repr = copyable_any::unpack<UnsupportedJWK>(jwk.variant);
                        &repr.payload == &DELETE_COMMAND_INDICATOR
                    } else {
                        false
                    };
                    if (is_delete) {
                        remove_jwk(&mut cur_issuer_jwks, get_jwk_id(&jwk));
                    } else {
                        upsert_jwk(&mut cur_issuer_jwks, jwk);
                    }
                });
                cur_issuer_jwks.version = cur_issuer_jwks.version + 1;
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L625-654)
```text
    /// Upsert a `JWK` into a `ProviderJWKs`. If this upsert replaced an existing entry, return it.
    fun upsert_jwk(set: &mut ProviderJWKs, jwk: JWK): Option<JWK> {
        let found = false;
        let index = 0;
        let num_entries = vector::length(&set.jwks);
        while (index < num_entries) {
            let cur_entry = vector::borrow(&set.jwks, index);
            let comparison = compare_u8_vector(get_jwk_id(&jwk), get_jwk_id(cur_entry));
            if (is_greater_than(&comparison)) {
                index = index + 1;
            } else {
                found = is_equal(&comparison);
                break
            }
        };

        // Now if `found == true`, `index` points to the JWK we want to update/remove; otherwise, `index` points to
        // where we want to insert.
        let ret = if (found) {
            let entry = vector::borrow_mut(&mut set.jwks, index);
            let old_entry = option::some(*entry);
            *entry = jwk;
            old_entry
        } else {
            vector::insert(&mut set.jwks, index, jwk);
            option::none()
        };

        ret
    }
```

**File:** types/src/jwks/rsa/mod.rs (L132-178)
```rust
impl TryFrom<&serde_json::Value> for RSA_JWK {
    type Error = anyhow::Error;

    fn try_from(json_value: &serde_json::Value) -> Result<Self, Self::Error> {
        let kty = json_value
            .get("kty")
            .ok_or_else(|| anyhow!("Field `kty` not found"))?
            .as_str()
            .ok_or_else(|| anyhow!("Field `kty` is not a string"))?
            .to_string();

        ensure!(
            kty.as_str() == "RSA",
            "json to rsa jwk conversion failed with incorrect kty"
        );

        let ret = Self {
            kty,
            kid: json_value
                .get("kid")
                .ok_or_else(|| anyhow!("Field `kid` not found"))?
                .as_str()
                .ok_or_else(|| anyhow!("Field `kid` is not a string"))?
                .to_string(),
            alg: json_value
                .get("alg")
                .ok_or_else(|| anyhow!("Field `alg` not found"))?
                .as_str()
                .ok_or_else(|| anyhow!("Field `alg` is not a string"))?
                .to_string(),
            e: json_value
                .get("e")
                .ok_or_else(|| anyhow!("Field `e` not found"))?
                .as_str()
                .ok_or_else(|| anyhow!("Field `e` is not a string"))?
                .to_string(),
            n: json_value
                .get("n")
                .ok_or_else(|| anyhow!("Field `n` not found"))?
                .as_str()
                .ok_or_else(|| anyhow!("Field `n` is not a string"))?
                .to_string(),
        };

        Ok(ret)
    }
}
```
