# Audit Report

## Title
Unauthenticated Exposure of Internal State Sync Operations via Inspection Service Enables Validator Fingerprinting and Targeted Attacks

## Summary
The node inspection service exposes sensitive internal state sync operations, peer prioritization data, and validator identification information through an unauthenticated HTTP endpoint that is enabled by default and bound to all network interfaces. This allows attackers to fingerprint validators, understand peer selection algorithms, and gather intelligence for targeted attacks.

## Finding Description

The `start_node_inspection_service()` function passes the `aptos_data_client` directly to the inspection service without sanitization or access control: [1](#0-0) 

The inspection service exposes this data through the `/peer_information` endpoint, which is controlled only by a boolean configuration flag with no authentication: [2](#0-1) 

The endpoint exposes comprehensive state sync metadata including peer priorities, scores, storage summaries, and request/response patterns: [3](#0-2) 

**Critical Security Issues:**

1. **Default Configuration is Insecure**: The service binds to `0.0.0.0:9101` and enables peer information exposure by default: [4](#0-3) 

2. **No Authentication**: The inspection service implements only boolean on/off flags, with no passcode, API key, or network-based access control.

3. **Validator Identification**: The exposed data reveals which peers are high-priority (validators) versus regular peers through priority categorization: [5](#0-4) 

4. **Detailed State Sync Intelligence**: For each peer, the endpoint exposes:
   - Peer reputation scores used for selection
   - Storage version ranges (synced ledger info, epochs, transactions, states)
   - Request/response counters revealing activity patterns
   - Bucket IDs and internal scoring metrics
   - Global data availability summary

**Exploitation Path:**

1. Attacker scans for Aptos nodes (port 9101 is default)
2. Sends: `GET http://[validator-ip]:9101/peer_information`
3. If `expose_peer_information` is enabled (default for testnet/devnet), receives complete peer state dump
4. Analyzes response to identify:
   - Which peers are validators (priority_peers vs regular_peers)
   - Current validator state sync status and version ranges
   - Peer selection scoring and bucketing logic
   - Network topology and data availability
5. Uses intelligence for targeted attacks:
   - **Eclipse attacks**: Manipulate peer selection by understanding scoring algorithm
   - **Targeted DoS**: Focus attacks on identified high-priority validators
   - **State sync manipulation**: Target validators lagging in specific data ranges
   - **Network profiling**: Map validator network topology and relationships

## Impact Explanation

This vulnerability meets **Medium Severity** criteria under "State inconsistencies requiring intervention" because:

1. **Enables Targeted State Sync Attacks**: Attackers can identify validators with specific storage gaps and target them with malicious state sync data, potentially causing inconsistencies that require manual intervention to resolve.

2. **Facilitates Eclipse Attacks**: Understanding the peer selection algorithm (priorities, scores, latency weighting) allows attackers to position malicious nodes to become preferred data sources for validators.

3. **Validator Operational Security**: Exposes which nodes are validators (priority peers) on validator networks, enabling targeted reconnaissance and attacks against critical infrastructure.

4. **Default Configuration Vulnerability**: The insecure default (enabled + 0.0.0.0 binding) affects all non-mainnet deployments and any mainnet validator that enables this endpoint.

While this does not directly cause fund loss or consensus failure (which would be Critical/High), it significantly lowers the bar for attacks that could cause state inconsistencies, making it more than a minor information leak (Low severity).

## Likelihood Explanation

**High Likelihood of Exploitation:**

1. **Trivial to Exploit**: Simple HTTP GET request with no authentication required
2. **Default Enabled**: Automatically enabled for all testnet/devnet nodes
3. **Public Exposure**: Default `0.0.0.0` binding makes it accessible from any network interface
4. **Clear Value to Attackers**: Provides actionable intelligence for sophisticated attacks
5. **Widespread Deployment**: Affects all nodes using default configuration

**Attack Prerequisites:**
- Network connectivity to target validator's port 9101
- No special privileges or insider access required
- No cryptographic operations needed

The vulnerability is essentially guaranteed to be exploitable on any node running with default non-mainnet configuration.

## Recommendation

**Immediate Mitigations:**

1. **Disable by Default**: Change default for `expose_peer_information` to `false`

2. **Require Authentication**: Implement API key or passcode-based authentication (similar to admin service):

```rust
// In InspectionServiceConfig
pub struct InspectionServiceConfig {
    pub address: String,
    pub port: u16,
    pub expose_configuration: bool,
    pub expose_identity_information: bool,
    pub expose_peer_information: bool,
    pub expose_system_information: bool,
    // NEW: Add authentication
    pub authentication_key: Option<String>,
}

// In peer_information.rs
pub fn handle_peer_information_request(
    node_config: &NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
    auth_header: Option<String>,
) -> (StatusCode, Body, String) {
    // Verify authentication
    if let Some(required_key) = &node_config.inspection_service.authentication_key {
        match auth_header {
            Some(provided_key) if provided_key == *required_key => {},
            _ => return (StatusCode::UNAUTHORIZED, Body::from("Authentication required"), CONTENT_TYPE_TEXT.into()),
        }
    }
    
    // Only return peer information if enabled
    if node_config.inspection_service.expose_peer_information {
        // ... existing code
    } else {
        (StatusCode::FORBIDDEN, Body::from(PEER_INFO_DISABLED_MESSAGE), CONTENT_TYPE_TEXT.into())
    }
}
```

3. **Bind to Localhost by Default**: Change default address to `127.0.0.1` instead of `0.0.0.0`

4. **Sanitize Exposed Data**: Remove or aggregate sensitive information:
   - Don't expose individual peer scores
   - Don't reveal priority classifications (validator vs non-validator)
   - Aggregate storage summaries instead of per-peer details

5. **Add Rate Limiting**: Prevent reconnaissance by rate-limiting inspection service requests

## Proof of Concept

**Exploitation Steps:**

```bash
# 1. Start an Aptos validator/fullnode with default config
cargo run -p aptos-node -- --config-path config.yaml

# 2. Query the inspection service (from attacker machine)
curl http://[validator-ip]:9101/peer_information

# Expected output includes:
# - "Priority peers: [PeerNetworkId(...)]" - Identifies validators
# - "Peer: ..., score: 87.5, bucket ID: 2" - Reveals scoring
# - "Advertised storage summary: DataSummary { ... }" - Shows version ranges
# - "Sent requests by type: {...}" - Reveals activity patterns
# - "Received responses by type: {...}" - Shows behavior metrics

# 3. Parse output to identify validators
# Validators appear in "priority_peers" list or have high priority bucket IDs

# 4. Use gathered intelligence for targeted attacks
# - Identify validators with storage gaps
# - Understand peer selection preferences
# - Map network topology
# - Target high-value validators for DoS/eclipse
```

**Verification Test (Rust):**

```rust
#[test]
fn test_inspection_service_exposes_validator_info() {
    // Start node with inspection service
    let config = NodeConfig::default();
    assert_eq!(config.inspection_service.address, "0.0.0.0");
    assert_eq!(config.inspection_service.expose_peer_information, true);
    
    // Simulate attacker request
    let response = reqwest::blocking::get(
        format!("http://localhost:{}/peer_information", config.inspection_service.port)
    ).unwrap();
    
    assert_eq!(response.status(), 200);
    let body = response.text().unwrap();
    
    // Verify sensitive information is exposed
    assert!(body.contains("Priority peers:"));
    assert!(body.contains("score:"));
    assert!(body.contains("Advertised storage summary:"));
    assert!(body.contains("Sent requests by type:"));
}
```

## Notes

- **Mainnet Protection Limited**: While mainnet validators have sanitization for `expose_configuration`, there's no such protection for `expose_peer_information`, leaving mainnet validators vulnerable if they enable this endpoint.
  
- **Auto-Enable on Non-Mainnet**: The optimizer automatically enables all inspection endpoints for testnet/devnet nodes, maximizing the attack surface on these networks.

- **Related Service**: The admin service (`AdminService`) implements proper authentication, showing that the project has the capability to secure such endpoints but didn't apply it to the inspection service.

- **Defense in Depth Violation**: Even with the configuration flag, the lack of authentication violates security best practices. Configuration mistakes or misunderstandings can expose validators to attacks.

### Citations

**File:** aptos-node/src/services.rs (L212-222)
```rust
pub fn start_node_inspection_service(
    node_config: &NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) {
    aptos_inspection_service::start_inspection_service(
        node_config.clone(),
        aptos_data_client,
        peers_and_metadata,
    )
}
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L21-38)
```rust
pub fn handle_peer_information_request(
    node_config: &NodeConfig,
    aptos_data_client: AptosDataClient,
    peers_and_metadata: Arc<PeersAndMetadata>,
) -> (StatusCode, Body, String) {
    // Only return peer information if the endpoint is enabled
    let (status_code, body) = if node_config.inspection_service.expose_peer_information {
        let peer_information = get_peer_information(aptos_data_client, peers_and_metadata);
        (StatusCode::OK, Body::from(peer_information))
    } else {
        (
            StatusCode::FORBIDDEN,
            Body::from(PEER_INFO_DISABLED_MESSAGE),
        )
    };

    (status_code, body, CONTENT_TYPE_TEXT.into())
}
```

**File:** crates/aptos-inspection-service/src/server/peer_information.rs (L206-271)
```rust
fn display_state_sync_metadata(
    peer_information_output: &mut Vec<String>,
    all_peers: &Vec<PeerNetworkId>,
    aptos_data_client: AptosDataClient,
) {
    peer_information_output.push("State sync metadata for each peer:".into());

    // Fetch and display the priority and regular peers
    if let Ok((priority_peers, regular_peers)) = aptos_data_client.get_priority_and_regular_peers()
    {
        // Sort the peer lists before displaying them
        let mut priority_peers: Vec<_> = priority_peers.into_iter().collect();
        priority_peers.sort();
        let mut regular_peers: Vec<_> = regular_peers.into_iter().collect();
        regular_peers.sort();

        // Display the priority and regular peers
        peer_information_output.push(format!(
            "\t- Priority peers: {:?}, regular peers: {:?}",
            priority_peers, regular_peers
        ));
    }

    // Fetch and display the global advertised data summary
    let global_data_summary = aptos_data_client.get_global_data_summary();
    peer_information_output.push(format!(
        "\t- Global advertised data summary: {:?}",
        global_data_summary
    ));

    // Fetch and display the state sync metadata for each peer
    let peer_to_state = aptos_data_client.get_peer_states().get_peer_to_states();
    for peer in all_peers {
        if let Some(peer_state_entry) = peer_to_state.get(peer) {
            // Get the peer states
            let peer = *peer_state_entry.key();
            let peer_bucket_id = peer_states::get_bucket_id_for_peer(peer);
            let peer_score = peer_state_entry.get_score();
            let peer_storage_summary = peer_state_entry.get_storage_summary();

            // Display the peer states
            peer_information_output.push(format!(
                "\t- Peer: {}, score: {}, bucket ID: {}",
                peer, peer_score, peer_bucket_id
            ));
            peer_information_output.push(format!(
                "\t\t- Advertised storage summary: {:?}",
                peer_storage_summary
            ));

            // Get the peer's request/response counts
            let sent_requests_by_type = peer_state_entry.get_sent_requests_by_type();
            let received_responses_by_type = peer_state_entry.get_received_responses_by_type();

            // Display the peer's request/response counts
            peer_information_output.push(format!(
                "\t\t- Sent requests by type: {:?}",
                sent_requests_by_type
            ));
            peer_information_output.push(format!(
                "\t\t- Received responses by type: {:?}",
                received_responses_by_type
            ));
        }
    }
}
```

**File:** config/src/config/inspection_service_config.rs (L26-37)
```rust
impl Default for InspectionServiceConfig {
    fn default() -> InspectionServiceConfig {
        InspectionServiceConfig {
            address: "0.0.0.0".to_string(),
            port: 9101,
            expose_configuration: false,
            expose_identity_information: true,
            expose_peer_information: true,
            expose_system_information: true,
        }
    }
}
```

**File:** state-sync/aptos-data-client/src/priority.rs (L53-73)
```rust
pub fn get_peer_priority(
    base_config: Arc<BaseConfig>,
    peers_and_metadata: Arc<PeersAndMetadata>,
    peer: &PeerNetworkId,
) -> PeerPriority {
    // Handle the case that this node is a validator
    let peer_network_id = peer.network_id();
    if base_config.role.is_validator() {
        // Validators should highly prioritize other validators
        if peer_network_id.is_validator_network() {
            return PeerPriority::HighPriority;
        }

        // VFNs should be prioritized over PFNs. Note: having PFNs
        // connected to a validator is a rare (but possible) scenario.
        return if peer_network_id.is_vfn_network() {
            PeerPriority::MediumPriority
        } else {
            PeerPriority::LowPriority
        };
    }
```
