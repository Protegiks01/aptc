# Audit Report

## Title
Unverified Genesis Epoch Allows Validator Set Corruption During Backup Restore

## Summary
The backup restore mechanism fails to enforce verification of epoch 0 (genesis) LedgerInfo when no trusted waypoint is provided, allowing an attacker who controls the backup source to inject a malicious genesis with a corrupted validator set. This enables silent compromise of restored nodes.

## Finding Description

The `new_epoch_ending_backup()` function creates `EpochEndingBackupMeta` without any validation of the epoch/version relationship: [1](#0-0) 

During restore, the `preheat_impl()` function processes epoch ending backups with the following verification logic: [2](#0-1) 

For epoch 0 (genesis), when `previous_li` is `None` (line 88) and no trusted waypoint is provided, BOTH verification branches are skipped:
- Line 129-135: No trusted waypoint check passes through
- Line 136-147: No previous LedgerInfo exists for epoch 0 [3](#0-2) 

The trusted waypoint parameter is documented as optional: [4](#0-3) 

**Attack Path:**
1. Attacker compromises backup storage or social engineers user to restore from malicious location
2. Attacker creates `EpochEndingBackupMeta` with `first_epoch=0, last_epoch=0`, arbitrary `first_version/last_version`
3. Attacker provides matching backup chunks containing fake genesis `LedgerInfoWithSignatures` with malicious validator set
4. Victim initiates restore without `--trust-waypoint` for genesis version
5. During restore, the fake genesis passes through verification logic unchecked
6. Restored node starts with corrupted genesis validator set

The restored node will accept blocks signed by the fake validator set and reject legitimate blocks from the real network, effectively placing it on a different blockchain.

## Impact Explanation

This vulnerability meets **HIGH severity** criteria under the Aptos Bug Bounty Program:

**"Significant protocol violations"**: The restored node has fundamentally incorrect consensus state - its genesis validator set doesn't match the real Aptos network. This breaks the **Consensus Safety** invariant (#2) as the node will accept/reject blocks based on incorrect validator signatures.

**Potential harms:**
- Node corruption requiring complete re-synchronization with verified backup
- If attacker also controls peer connections, the node could accept fraudulent transactions
- Silent failure mode - user may not immediately realize their node is on a fake chain
- Violation of **Deterministic Execution** invariant (#1) - different validator set produces different state

While this doesn't directly compromise the main Aptos network (corrupted nodes can't force real validators to accept invalid blocks), it represents a significant security flaw in the backup/restore mechanism that puts individual node operators at risk.

## Likelihood Explanation

**Likelihood: MEDIUM**

**Required conditions:**
1. User performs full restore from epoch 0 (common for new nodes or disaster recovery)
2. Backup storage is compromised OR user is tricked into using malicious backup location
3. User doesn't provide `--trust-waypoint` for genesis (likely, given optional documentation)

**Feasibility factors:**
- Backup storage compromise is a real threat (cloud storage misconfigurations, credential leaks)
- Users may not know genesis waypoint verification is critical
- No warning or enforcement mechanism exists
- Attack is fully reproducible once conditions are met

**Mitigating factors:**
- Requires backup source compromise
- Corrupted node won't sync with real network (peers will detect mismatch)
- Sophisticated operators likely use trusted waypoints

## Recommendation

**Immediate fixes:**

1. **Enforce mandatory genesis verification**:
```rust
pub fn new_epoch_ending_backup(
    first_epoch: u64,
    last_epoch: u64,
    first_version: Version,
    last_version: Version,
    manifest: FileHandle,
) -> Result<Self> {
    // Validate epoch/version relationship
    ensure!(
        first_epoch <= last_epoch,
        "Invalid epoch range: first_epoch {} > last_epoch {}",
        first_epoch,
        last_epoch
    );
    
    ensure!(
        first_version <= last_version,
        "Invalid version range: first_version {} > last_version {}",
        first_version,
        last_version
    );
    
    Ok(Self::EpochEndingBackup(EpochEndingBackupMeta {
        first_epoch,
        last_epoch,
        first_version,
        last_version,
        manifest,
    }))
}
```

2. **Require trusted waypoint for epoch 0**:
```rust
async fn preheat_impl(&self) -> Result<EpochEndingRestorePreheatData> {
    let manifest: EpochEndingBackup = self.storage.load_json_file(&self.manifest_handle).await?;
    manifest.verify()?;

    // CRITICAL: Enforce genesis verification
    if manifest.first_epoch == 0 {
        let first_waypoint_version = manifest.waypoints.first()
            .ok_or_else(|| anyhow!("Genesis backup must have at least one waypoint"))?
            .version();
        
        ensure!(
            self.trusted_waypoints.contains_key(&first_waypoint_version),
            "Genesis epoch (epoch 0) restore REQUIRES a trusted waypoint at version {}. \
            Use --trust-waypoint to specify the genesis waypoint.",
            first_waypoint_version
        );
    }
    
    // ... rest of function
}
```

3. **Update documentation** to clearly state that genesis restoration requires trusted waypoint verification.

## Proof of Concept

```rust
// Reproduction steps for vulnerability demonstration:

// 1. Create malicious backup structure
use aptos_backup_cli::metadata::{Metadata, EpochEndingBackupMeta};
use aptos_types::{
    ledger_info::{LedgerInfo, LedgerInfoWithSignatures},
    waypoint::Waypoint,
};

// 2. Craft fake genesis LedgerInfo with malicious validator set
let fake_genesis_li = LedgerInfo::new(
    // Malicious block info with attacker-controlled validator set
    BlockInfo::new(
        0,          // epoch
        0,          // round
        HashValue::zero(),
        HashValue::zero(),
        0,          // version
        0,          // timestamp
        Some(attacker_controlled_epoch_state), // MALICIOUS validator set
    ),
    HashValue::zero(),
);

// 3. Create EpochEndingBackupMeta (no validation!)
let malicious_metadata = Metadata::new_epoch_ending_backup(
    0,                    // first_epoch (genesis)
    0,                    // last_epoch
    0,                    // first_version (or any incorrect value)
    0,                    // last_version
    manifest_handle,
);

// 4. Save to backup storage
// ... save malicious backup files ...

// 5. Victim restores WITHOUT --trust-waypoint:
// $ aptos-db-tool restore --db-dir /tmp/db --target-version 1000000 
//   [MISSING: --trust-waypoint <genesis_waypoint>]

// 6. Verification in preheat_impl():
// - previous_li is None for epoch 0
// - trusted_waypoints is empty
// - BOTH verification branches skipped!
// - Fake genesis ACCEPTED without any validation

// 7. Result: Node starts with corrupted validator set
```

**Notes:**

This vulnerability exemplifies a critical gap in defense-in-depth. While the system assumes users will provide trusted waypoints, it fails to enforce this assumption for the most critical case (genesis). The optional nature of `--trust-waypoint` combined with lack of warnings creates a dangerous security pitfall.

The fix requires making genesis waypoint verification mandatory, converting the current "best practice" into a hard requirement. This aligns with blockchain security principles where genesis state must always be cryptographically verified.

### Citations

**File:** storage/backup/backup-cli/src/metadata/mod.rs (L25-39)
```rust
    pub fn new_epoch_ending_backup(
        first_epoch: u64,
        last_epoch: u64,
        first_version: Version,
        last_version: Version,
        manifest: FileHandle,
    ) -> Self {
        Self::EpochEndingBackup(EpochEndingBackupMeta {
            first_epoch,
            last_epoch,
            first_version,
            last_version,
            manifest,
        })
    }
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L88-89)
```rust
        let mut previous_li: Option<&LedgerInfoWithSignatures> = None;
        let mut ledger_infos = Vec::new();
```

**File:** storage/backup/backup-cli/src/backup_types/epoch_ending/restore.rs (L129-147)
```rust
                if let Some(wp_trusted) = self.trusted_waypoints.get(&wp_li.version()) {
                    ensure!(
                        *wp_trusted == wp_li,
                        "Waypoints don't match. In backup: {}, trusted: {}",
                        wp_li,
                        wp_trusted,
                    );
                } else if let Some(pre_li) = previous_li {
                    pre_li
                        .ledger_info()
                        .next_epoch_state()
                        .ok_or_else(|| {
                            anyhow!(
                                "Next epoch state not found from LI at epoch {}.",
                                pre_li.ledger_info().epoch()
                            )
                        })?
                        .verify(&li)?;
                }
```

**File:** storage/backup/backup-cli/src/utils/mod.rs (L333-345)
```rust
    #[clap(
        long,
        help = "(multiple) When provided, an epoch ending LedgerInfo at the waypoint version will be \
        checked against the hash in the waypoint, but signatures on it are NOT checked. \
        Use this for two purposes: \
        1. set the genesis or the latest waypoint to confirm the backup is compatible. \
        2. set waypoints at versions where writeset transactions were used to overwrite the \
        validator set, so that the signature check is skipped. \
        N.B. LedgerInfos are verified only when restoring / verifying the epoch ending backups, \
        i.e. they are NOT checked at all when doing one-shot restoring of the transaction \
        and state backups."
    )]
    pub trust_waypoint: Vec<Waypoint>,
```
