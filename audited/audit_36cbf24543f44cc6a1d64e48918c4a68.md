# Audit Report

## Title
Race Condition in JWK Consensus Allows Acceptance of Stale Quorum Certificates Leading to On-Chain State Inconsistency

## Summary
A race condition exists in `KeyLevelConsensusManager` between concurrent certifier task completion and sequential state updates, allowing stale quorum-certified updates to be accepted and committed on-chain when the consensus state has been superseded by a newer observation.

## Finding Description

The vulnerability occurs due to insufficient synchronization between the concurrent `UpdateCertifier` tasks and the `KeyLevelConsensusManager` event loop in the JWK consensus system.

**The Race Condition Flow:** [1](#0-0) 

When `maybe_start_consensus()` is called with a new update at line 216, it inserts an `InProgress` state, potentially overwriting a previous `InProgress` state if the JWK value has changed. The old state's `QuorumCertProcessGuard` is dropped, which calls `abort()` on the certifier task: [2](#0-1) 

However, the certifier task runs concurrently and may have already completed and pushed its quorum certificate to the channel before the abort occurs: [3](#0-2) 

The event loop then processes this stale QC without validating whether it matches the current proposal: [4](#0-3) 

**Critical Missing Validation:** The function `process_quorum_certified_update()` only checks if the state is `InProgress` (line 335) but does NOT validate that the received quorum-certified update matches the `my_proposal.observed` in the current state. This allows a quorum certificate for update_A to be accepted even when the current state contains `InProgress` for update_B.

**Concrete Attack Scenario:**
1. Observation arrives with JWK value A for (issuer, kid) → starts certifier_A → inserts InProgress_A
2. Certifier_A completes quickly and pushes QC_A to channel
3. Before event loop processes QC_A, another observation arrives with JWK value B → starts certifier_B → **overwrites** InProgress_A with InProgress_B
4. Event loop receives QC_A, finds InProgress_B, **accepts QC_A anyway**
5. System puts QC_A (stale value) into validator transaction pool
6. QC_A gets committed on-chain despite current observed value being B
7. Certifier_B's QC_B is later rejected because state is already Finished

**Result:** The on-chain JWK state contains value A while the actual current value is B, creating a persistent state inconsistency.

## Impact Explanation

This vulnerability qualifies as **Medium Severity** per Aptos bug bounty criteria:
- **State inconsistencies requiring intervention**: The mismatch between `my_proposal` and `quorum_certified` creates an inconsistent internal state, and the wrong JWK value gets committed on-chain
- **Authentication/Authorization Impact**: JWKs are used to validate JWTs from OIDC providers for keyless accounts. A stale or incorrect JWK on-chain could cause legitimate authentication attempts to fail or potentially allow invalid JWTs to be accepted
- **Consensus State Integrity**: Violates the "State Consistency" invariant - the system accepts a quorum certificate that doesn't match what the validator actually proposed

The channel configuration uses KLAST with capacity 1 per key: [5](#0-4) 

This provides some protection but doesn't prevent the race if the event loop processes the stale QC before the new one arrives.

## Likelihood Explanation

**Likelihood: Medium**

The race window is narrow (microseconds to milliseconds between certifier completion and state update), but can occur naturally without malicious action when:
1. OIDC provider rotates JWK keys in rapid succession
2. Provider endpoints return temporarily inconsistent values during propagation
3. Network conditions cause observation timing to align with certifier completion
4. Multiple validators independently observe JWK changes at slightly different times

The JWKObserver polls every 10 seconds: [6](#0-5) 

While an attacker cannot directly control OIDC provider responses, the race can occur in production during legitimate key rotations, especially if providers have eventual consistency issues.

## Recommendation

Add validation in `process_quorum_certified_update()` to verify that the received quorum certificate matches the current proposal before accepting it:

```rust
pub fn process_quorum_certified_update(
    &mut self,
    issuer_level_repr: QuorumCertifiedUpdate,
) -> Result<()> {
    let key_level_update =
        KeyLevelUpdate::try_from_issuer_level_repr(&issuer_level_repr.update)
            .context("process_quorum_certified_update failed with repr err")?;
    let issuer = &key_level_update.issuer;
    let kid = &key_level_update.kid;
    
    let state = self
        .states_by_key
        .entry((issuer.clone(), kid.clone()))
        .or_default();
    
    match state {
        ConsensusState::InProgress { my_proposal, .. } => {
            // ADDED: Validate that QC matches our current proposal
            let my_update = &my_proposal.observed;
            if my_update.to_upsert != key_level_update.to_upsert 
                || my_update.base_version != key_level_update.base_version {
                return Err(anyhow!(
                    "QC for stale update: expected {:?} but got {:?}",
                    my_update.to_upsert,
                    key_level_update.to_upsert
                ));
            }
            
            // Proceed with acceptance...
            let topic = Topic::JWK_CONSENSUS_PER_KEY_MODE {
                issuer: issuer.clone(),
                kid: kid.clone(),
            };
            let txn = ValidatorTransaction::ObservedJWKUpdate(issuer_level_repr.clone());
            let vtxn_guard = self.vtxn_pool.put(topic, Arc::new(txn), None);
            *state = ConsensusState::Finished {
                vtxn_guard,
                my_proposal: my_proposal.clone(),
                quorum_certified: issuer_level_repr,
            };
            Ok(())
        },
        _ => Err(anyhow!(
            "qc update not expected for issuer {:?} in state {}",
            String::from_utf8(issuer.clone()),
            state.name()
        )),
    }
}
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_stale_qc_race_condition() {
    // Setup: Create KeyLevelConsensusManager
    let (consensus_key, my_addr, epoch_state, rb, vtxn_pool) = setup_test_manager();
    let mut manager = KeyLevelConsensusManager::new(
        Arc::new(consensus_key),
        my_addr,
        epoch_state.clone(),
        rb,
        vtxn_pool,
    );
    
    let issuer = b"test-issuer".to_vec();
    let kid = b"key-1".to_vec();
    
    // Step 1: Observe JWK value A
    let jwk_a = create_test_jwk(kid.clone(), "value_a");
    manager.process_new_observation(issuer.clone(), vec![jwk_a.clone()]).unwrap();
    
    // Step 2: Simulate certifier_A completing quickly and pushing QC_A
    // (In real scenario, this happens concurrently)
    let qc_a = create_test_qc(issuer.clone(), kid.clone(), Some(jwk_a));
    manager.qc_update_tx.push((issuer.clone(), kid.clone()), qc_a.clone()).unwrap();
    
    // Step 3: Before processing QC_A, observe JWK value B (different)
    let jwk_b = create_test_jwk(kid.clone(), "value_b");
    manager.process_new_observation(issuer.clone(), vec![jwk_b.clone()]).unwrap();
    
    // At this point:
    // - states_by_key has InProgress for value_b
    // - qc_update_rx has QC for value_a
    
    // Step 4: Process QC_A (stale value)
    let result = manager.process_quorum_certified_update(qc_a);
    
    // BUG: This should fail but currently succeeds!
    assert!(result.is_ok(), "Stale QC was accepted - race condition!");
    
    // Step 5: Verify state inconsistency
    let state = manager.states_by_key.get(&(issuer, kid)).unwrap();
    match state {
        ConsensusState::Finished { my_proposal, quorum_certified, .. } => {
            // INCONSISTENCY: my_proposal is for value_b but quorum_certified is for value_a
            assert_ne!(
                my_proposal.observed.to_upsert,
                KeyLevelUpdate::try_from_issuer_level_repr(&quorum_certified.update)
                    .unwrap()
                    .to_upsert,
                "State contains mismatched proposal and QC!"
            );
        },
        _ => panic!("Expected Finished state"),
    }
}
```

## Notes

The vulnerability exists because the event loop's sequential processing cannot prevent races with concurrently executing certifier tasks. The abort mechanism via `QuorumCertProcessGuard` is insufficient because it only works if the task hasn't completed yet. Once a certifier pushes its QC to the channel, aborting the task has no effect. The fix must include explicit validation that the received QC matches the current proposal state.

### Citations

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L79-79)
```rust
        let (qc_update_tx, qc_update_rx) = aptos_channel::new(QueueStyle::KLAST, 1, None);
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L179-231)
```rust
    fn maybe_start_consensus(&mut self, update: KeyLevelUpdate) -> Result<()> {
        let consensus_already_started = match self
            .states_by_key
            .get(&(update.issuer.clone(), update.kid.clone()))
            .cloned()
        {
            Some(ConsensusState::InProgress { my_proposal, .. })
            | Some(ConsensusState::Finished { my_proposal, .. }) => {
                my_proposal.observed.to_upsert == update.to_upsert
            },
            _ => false,
        };

        if consensus_already_started {
            return Ok(());
        }

        let issuer_level_repr = update
            .try_as_issuer_level_repr()
            .context("initiate_key_level_consensus failed at repr conversion")?;
        let signature = self
            .consensus_key
            .sign(&issuer_level_repr)
            .context("crypto material error occurred during signing")?;

        let update_translated = update
            .try_as_issuer_level_repr()
            .context("maybe_start_consensus failed at update translation")?;
        let abort_handle = self
            .update_certifier
            .start_produce(
                self.epoch_state.clone(),
                update_translated,
                self.qc_update_tx.clone(),
            )
            .context("maybe_start_consensus failed at update_certifier.start_produce")?;

        self.states_by_key.insert(
            (update.issuer.clone(), update.kid.clone()),
            ConsensusState::InProgress {
                my_proposal: ObservedKeyLevelUpdate {
                    author: self.my_addr,
                    observed: update,
                    signature,
                },
                abort_handle_wrapper: QuorumCertProcessGuard {
                    handle: abort_handle,
                },
            },
        );

        Ok(())
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L312-362)
```rust
    pub fn process_quorum_certified_update(
        &mut self,
        issuer_level_repr: QuorumCertifiedUpdate,
    ) -> Result<()> {
        let key_level_update =
            KeyLevelUpdate::try_from_issuer_level_repr(&issuer_level_repr.update)
                .context("process_quorum_certified_update failed with repr err")?;
        let issuer = &key_level_update.issuer;
        let issuer_str = String::from_utf8(issuer.clone()).ok();
        let kid = &key_level_update.kid;
        let kid_str = String::from_utf8(kid.clone()).ok();
        info!(
            epoch = self.epoch_state.epoch,
            issuer = issuer_str,
            kid = kid_str,
            base_version = key_level_update.base_version,
            "KeyLevelJWKManager processing certified key-level update."
        );
        let state = self
            .states_by_key
            .entry((issuer.clone(), kid.clone()))
            .or_default();
        match state {
            ConsensusState::InProgress { my_proposal, .. } => {
                let topic = Topic::JWK_CONSENSUS_PER_KEY_MODE {
                    issuer: issuer.clone(),
                    kid: kid.clone(),
                };
                let txn = ValidatorTransaction::ObservedJWKUpdate(issuer_level_repr.clone());
                let vtxn_guard = self.vtxn_pool.put(topic, Arc::new(txn), None);
                *state = ConsensusState::Finished {
                    vtxn_guard,
                    my_proposal: my_proposal.clone(),
                    quorum_certified: issuer_level_repr,
                };
                info!(
                    epoch = self.epoch_state.epoch,
                    issuer = issuer_str,
                    kid = kid_str,
                    base_version = key_level_update.base_version,
                    "certified key-level update accepted."
                );
                Ok(())
            },
            _ => Err(anyhow!(
                "qc update not expected for issuer {:?} in state {}",
                String::from_utf8(issuer.clone()),
                state.name()
            )),
        }
    }
```

**File:** crates/aptos-jwk-consensus/src/jwk_manager_per_key.rs (L399-399)
```rust
                        Duration::from_secs(10),
```

**File:** crates/aptos-jwk-consensus/src/types.rs (L96-101)
```rust
impl Drop for QuorumCertProcessGuard {
    fn drop(&mut self) {
        let QuorumCertProcessGuard { handle } = self;
        handle.abort();
    }
}
```

**File:** crates/aptos-jwk-consensus/src/update_certifier.rs (L67-82)
```rust
        let task = async move {
            let qc_update = rb.broadcast(req, agg_state).await.expect("cannot fail");
            ConsensusMode::log_certify_done(epoch, &qc_update);
            let session_key = ConsensusMode::session_key_from_qc(&qc_update);
            match session_key {
                Ok(key) => {
                    let _ = qc_update_tx.push(key, qc_update);
                },
                Err(e) => {
                    error!("JWK update QCed but could not identify the session key: {e}");
                },
            }
        };
        let (abort_handle, abort_registration) = AbortHandle::new_pair();
        tokio::spawn(Abortable::new(task, abort_registration));
        Ok(abort_handle)
```
