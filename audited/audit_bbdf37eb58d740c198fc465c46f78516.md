# Audit Report

## Title
Race Condition in Transaction Notification Handler Causes Incorrect Version Association with Events

## Summary
A race condition exists in `handle_committed_transactions` where concurrent notification processing can cause events and transactions to be associated with incorrect version numbers. The function fetches the latest synced version from storage at notification time rather than using the version of the actual committed transactions, leading to version mismatches when multiple batches commit in quick succession.

## Finding Description

The vulnerability exists in the notification flow where committed transactions are reported to downstream components (mempool, storage service, and event subscription service). [1](#0-0) 

The function `handle_committed_transactions` fetches the current `latest_synced_version` from storage rather than tracking the actual version of the `committed_transactions` it's processing. This creates a race condition because:

1. **Two concurrent execution paths** can call this function:
   - The driver's sequential event loop processing consensus/snapshot commit notifications
   - A separate spawned task (`commit_post_processor`) processing chunk commit notifications [2](#0-1) 

2. **The commit_post_processor runs as an independent task**, not synchronized with the driver loop: [3](#0-2) 

3. **Race window scenario:**
   - T1: Batch A (versions 100-110) commits to storage, including event E1
   - T2: Batch B (versions 111-120) commits to storage  
   - T3: Post-processor for Batch B fetches `latest_synced_version = 120`
   - T4: Post-processor for Batch B notifies with version 120 (correct)
   - T5: Post-processor for Batch A fetches `latest_synced_version = 120` (stale!)
   - T6: Post-processor for Batch A notifies event E1 with version 120 (INCORRECT - should be 110)

4. **Event subscription service receives incorrect version:** [4](#0-3) 

The event subscription service uses this version to tag event notifications: [5](#0-4) 

This breaks version correctness guarantees, particularly critical for:
- **Epoch change events**: Reconfiguration notifications may be tagged with wrong versions
- **Governance events**: Proposal and voting events could have incorrect version associations
- **Timestamp accuracy**: The `blockchain_timestamp_usecs` from `latest_synced_ledger_info` may not match the actual transaction batch

## Impact Explanation

**Severity: MEDIUM**

This vulnerability causes state inconsistencies that could affect protocol correctness:

1. **Event Version Integrity Violation**: Components subscribing to on-chain events receive incorrect version metadata, breaking the invariant that events are associated with their actual committed version.

2. **Reconfiguration Confusion**: During epoch transitions, reconfiguration events could be notified with wrong versions, potentially causing validators or nodes to process configuration changes at incorrect ledger states.

3. **Governance Impact**: Critical governance events (proposals, votes) could have mismatched versions, affecting any off-chain or on-chain logic that relies on event version ordering.

4. **Mempool Timestamp Mismatch**: Mempool receives transactions with potentially incorrect `block_timestamp_usecs`, which could affect transaction replay protection or time-based logic.

While this doesn't directly cause loss of funds or consensus violations, it qualifies as **Medium severity** per the Aptos bug bounty criteria as it creates "state inconsistencies requiring intervention" and could lead to protocol violations in components that depend on accurate event version information.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

This race condition is likely to occur in production environments:

1. **High-throughput scenarios**: When the network processes transactions rapidly, multiple batches can commit to storage in quick succession, creating the race window.

2. **No synchronization**: There's no mutex or coordination between the driver loop and the spawned commit_post_processor task, making concurrent execution the default behavior.

3. **Frequent state sync operations**: Both consensus commits and state sync commits can trigger this code path simultaneously.

4. **Epoch transitions**: During reconfiguration events, this bug is particularly dangerous as epoch change events must have accurate versions for proper protocol operation.

The likelihood increases proportionally with network activity and is almost certain to manifest during stress testing or mainnet operation under load.

## Recommendation

**Solution: Pass version information with CommittedTransactions**

Modify the notification structures to carry the actual committed version instead of fetching it from storage:

1. **Update `CommittedTransactions` structure** to include version information:
```rust
pub struct CommittedTransactions {
    pub events: Vec<ContractEvent>,
    pub transactions: Vec<Transaction>,
    pub version: Version, // Add this field
}
```

2. **Update `ChunkCommitNotification`** to include the committed version:
```rust
pub struct ChunkCommitNotification {
    pub subscribable_events: Vec<ContractEvent>,
    pub committed_transactions: Vec<Transaction>,
    pub reconfiguration_occurred: bool,
    pub committed_version: Version, // Add this field
}
```

3. **Update `handle_committed_transactions`** to use the provided version:
```rust
pub async fn handle_committed_transactions<...>(
    committed_transactions: CommittedTransactions,
    storage: Arc<dyn DbReader>,
    ...
) {
    let latest_synced_version = committed_transactions.version; // Use provided version
    
    let latest_synced_ledger_info = match fetch_latest_synced_ledger_info(storage.clone()) {
        Ok(info) => info,
        Err(error) => { ... }
    };
    
    // Rest of the function...
}
```

4. **Update all call sites** to pass the correct version when creating notifications.

This ensures each notification carries its actual committed version, eliminating the race condition.

## Proof of Concept

```rust
// Simulated race condition test (pseudo-code for demonstration)
#[tokio::test]
async fn test_notification_version_race() {
    // Setup: Mock storage, notification handlers
    let storage = create_mock_storage();
    let (mempool_handler, event_service, storage_handler) = create_handlers();
    
    // Commit Batch A (versions 100-110) with event E1
    storage.commit_transactions(100..=110, vec![event_e1]);
    let batch_a = CommittedTransactions {
        events: vec![event_e1],
        transactions: txns_100_to_110,
    };
    
    // Commit Batch B (versions 111-120) with event E2
    storage.commit_transactions(111..=120, vec![event_e2]);
    let batch_b = CommittedTransactions {
        events: vec![event_e2],
        transactions: txns_111_to_120,
    };
    
    // Process notifications concurrently
    let task_b = tokio::spawn(handle_committed_transactions(
        batch_b, storage.clone(), ...
    ));
    
    let task_a = tokio::spawn(handle_committed_transactions(
        batch_a, storage.clone(), ...
    ));
    
    // Wait for both
    task_b.await;
    task_a.await;
    
    // Verify: Event E1 should be at version 110, but due to race,
    // it was notified with version 120
    let notifications = event_service.get_notifications();
    assert_eq!(notifications[0].version, 110); // FAILS due to race
}
```

## Notes

This vulnerability demonstrates a subtle but significant race condition in the state synchronization driver. The root cause is the architectural decision to fetch version information from storage at notification time rather than tracking it through the commit pipeline. While the impact is primarily on metadata correctness rather than transaction execution, it could have cascading effects on any system component that relies on accurate event version information, particularly during critical operations like epoch transitions.

The fix requires careful coordination to ensure version information flows through the entire commit and notification pipeline without introducing new race conditions or synchronization bottlenecks.

### Citations

**File:** state-sync/state-sync-driver/src/utils.rs (L325-371)
```rust
pub async fn handle_committed_transactions<
    M: MempoolNotificationSender,
    S: StorageServiceNotificationSender,
>(
    committed_transactions: CommittedTransactions,
    storage: Arc<dyn DbReader>,
    mempool_notification_handler: MempoolNotificationHandler<M>,
    event_subscription_service: Arc<Mutex<EventSubscriptionService>>,
    storage_service_notification_handler: StorageServiceNotificationHandler<S>,
) {
    // Fetch the latest synced version and ledger info from storage
    let (latest_synced_version, latest_synced_ledger_info) =
        match fetch_pre_committed_version(storage.clone()) {
            Ok(latest_synced_version) => match fetch_latest_synced_ledger_info(storage.clone()) {
                Ok(latest_synced_ledger_info) => (latest_synced_version, latest_synced_ledger_info),
                Err(error) => {
                    error!(LogSchema::new(LogEntry::SynchronizerNotification)
                        .error(&error)
                        .message("Failed to fetch latest synced ledger info!"));
                    return;
                },
            },
            Err(error) => {
                error!(LogSchema::new(LogEntry::SynchronizerNotification)
                    .error(&error)
                    .message("Failed to fetch latest synced version!"));
                return;
            },
        };

    // Handle the commit notification
    if let Err(error) = CommitNotification::handle_transaction_notification(
        committed_transactions.events,
        committed_transactions.transactions,
        latest_synced_version,
        latest_synced_ledger_info,
        mempool_notification_handler,
        event_subscription_service,
        storage_service_notification_handler,
    )
    .await
    {
        error!(LogSchema::new(LogEntry::SynchronizerNotification)
            .error(&error)
            .message("Failed to handle a transaction commit notification!"));
    }
}
```

**File:** state-sync/state-sync-driver/src/storage_synchronizer.rs (L784-824)
```rust
fn spawn_commit_post_processor<
    MempoolNotifier: MempoolNotificationSender,
    StorageServiceNotifier: StorageServiceNotificationSender,
>(
    mut commit_post_processor_listener: mpsc::Receiver<ChunkCommitNotification>,
    event_subscription_service: Arc<Mutex<EventSubscriptionService>>,
    mempool_notification_handler: MempoolNotificationHandler<MempoolNotifier>,
    storage_service_notification_handler: StorageServiceNotificationHandler<StorageServiceNotifier>,
    pending_data_chunks: Arc<AtomicU64>,
    runtime: Option<Handle>,
    storage: Arc<dyn DbReader>,
) -> JoinHandle<()> {
    // Create a commit post-processor
    let commit_post_processor = async move {
        while let Some(notification) = commit_post_processor_listener.next().await {
            // Start the commit post-process timer
            let _timer = metrics::start_timer(
                &metrics::STORAGE_SYNCHRONIZER_LATENCIES,
                metrics::STORAGE_SYNCHRONIZER_COMMIT_POST_PROCESS,
            );

            // Handle the committed transaction notification (e.g., notify mempool)
            let committed_transactions = CommittedTransactions {
                events: notification.subscribable_events,
                transactions: notification.committed_transactions,
            };
            utils::handle_committed_transactions(
                committed_transactions,
                storage.clone(),
                mempool_notification_handler.clone(),
                event_subscription_service.clone(),
                storage_service_notification_handler.clone(),
            )
            .await;
            decrement_pending_data_chunks(pending_data_chunks.clone());
        }
    };

    // Spawn the commit post-processor
    spawn(runtime, commit_post_processor)
}
```

**File:** state-sync/state-sync-driver/src/driver.rs (L212-240)
```rust
    pub async fn start_driver(mut self) {
        let mut progress_check_interval = IntervalStream::new(interval(Duration::from_millis(
            self.driver_configuration.config.progress_check_interval_ms,
        )))
        .fuse();

        // Start the driver
        info!(LogSchema::new(LogEntry::Driver).message("Started the state sync v2 driver!"));
        self.start_time = Some(self.time_service.now());
        loop {
            ::futures::select! {
                notification = self.client_notification_listener.select_next_some() => {
                    self.handle_client_notification(notification).await;
                },
                notification = self.commit_notification_listener.select_next_some() => {
                    self.handle_snapshot_commit_notification(notification).await;
                }
                notification = self.consensus_notification_handler.select_next_some() => {
                    self.handle_consensus_or_observer_notification(notification).await;
                }
                notification = self.error_notification_listener.select_next_some() => {
                    self.handle_error_notification(notification).await;
                }
                _ = progress_check_interval.select_next_some() => {
                    self.drive_progress().await;
                }
            }
        }
    }
```

**File:** state-sync/state-sync-driver/src/notification_handlers.rs (L96-112)
```rust
        // Notify the storage service of the committed transactions
        storage_service_notification_handler
            .notify_storage_service_of_committed_transactions(latest_synced_version)
            .await?;

        // Notify mempool of the committed transactions
        mempool_notification_handler
            .notify_mempool_of_committed_transactions(transactions, blockchain_timestamp_usecs)
            .await?;

        // Notify the event subscription service of the events
        event_subscription_service
            .lock()
            .notify_events(latest_synced_version, events)?;

        Ok(())
    }
```

**File:** state-sync/inter-component/event-notifications/src/lib.rs (L349-358)
```rust
    fn notify_subscriber_of_events(&mut self, version: Version) -> Result<(), Error> {
        let event_notification = EventNotification {
            subscribed_events: self.event_buffer.drain(..).collect(),
            version,
        };

        self.notification_sender
            .push((), event_notification)
            .map_err(|error| Error::UnexpectedErrorEncountered(format!("{:?}", error)))
    }
```
