# Audit Report

## Title
Division-by-Zero Panic in Batch Request Logic with Empty Responders Vector

## Summary
The `BatchRequester::next_request_peers()` function performs a modulo operation on an empty signers collection without validation, causing a division-by-zero panic that propagates through shared futures, potentially crashing consensus nodes when processing batches with empty responder sets.

## Finding Description

The vulnerability exists in the batch fetching mechanism used by the Quorum Store payload manager. When `request_transactions()` is called with a batch that has an empty responders vector, the following execution path occurs:

1. `QuorumStorePayloadManager::request_transactions()` calls `batch_reader.get_batch(batch_info, responders.clone())` with an empty `Vec<PeerId>` [1](#0-0) 

2. The empty vector is converted to an empty `BTreeSet<PeerId>` in `get_or_fetch_batch()` [2](#0-1) 

3. When the batch is not in local storage, `request_batch()` is invoked with the empty responders set [3](#0-2) 

4. Inside `BatchRequesterState::next_request_peers()`, the code performs an unchecked modulo operation on the first retry attempt: [4](#0-3) 

5. When `signers.len()` is 0, the expression `rng.r#gen::<usize>() % signers.len()` triggers a **division-by-zero panic**

6. Line 59 contains a second modulo-by-zero vulnerability: [5](#0-4) 

The panic occurs within an async block that is spawned as a separate tokio task but also wrapped in a `Shared` future. When the caller awaits this shared future via `join_all()`, the panic propagates: [6](#0-5) 

**When can responders be empty?**

Responders are derived from `ProofOfStore::shuffled_signers()`, which extracts signers from an `AggregateSignature` bitmask: [7](#0-6) 

The underlying `get_signers_addresses()` method returns an empty vector when the validator bitmask has no bits set: [8](#0-7) 

While `ProofOfStore::verify()` validation should reject proofs with insufficient voting power, there are edge cases:

1. **Test/Fuzzing Mode Bypass**: The validation explicitly allows `quorum_voting_power == 0` in test/fuzzing configurations: [9](#0-8) 

2. **Genesis/NilBlock Edge Cases**: Certain block types return `None` for `author()`: [10](#0-9) 

   In `process_optqs_payload()`, if both the proof has no signers AND `block.author()` is `None`, the responders vector would be empty: [11](#0-10) 

## Impact Explanation

**Severity: High**

This vulnerability causes **consensus node liveness failure** through an unhandled panic:

1. **Immediate Impact**: The panic crashes the batch fetching task
2. **Propagation**: The shared future propagates the panic to all awaiters
3. **Node Impact**: The consensus processing path panics, potentially crashing the validator node or causing it to hang indefinitely waiting for a future that never resolves
4. **Network Impact**: If multiple validators encounter malformed payloads simultaneously, it could cause widespread liveness degradation

This meets the **High Severity** criteria per Aptos bug bounty:
- "Validator node slowdowns" - nodes hang waiting for unresolvable futures
- "Significant protocol violations" - consensus processing fails due to uncaught panic

While not reaching Critical severity (no fund loss or permanent network partition), the ability to cause validator node failures represents a significant availability threat.

## Likelihood Explanation

**Likelihood: Low to Medium**

In production environments, `ProofOfStore` validation should prevent proofs with zero signers from reaching this code path, as they would fail the quorum voting power check: [12](#0-11) 

However, the likelihood increases due to:

1. **Defensive Programming Gap**: No explicit validation guards against empty responders before the modulo operation
2. **Future Code Changes**: Modifications to validation logic could inadvertently allow empty signers
3. **Edge Case Scenarios**: Complex interactions during epoch transitions or with special block types (Genesis, NilBlock) that lack authors
4. **Test/Fuzzing Environments**: The bypass for zero quorum voting power could mask this issue during testing

The vulnerability represents a "time bomb" - while not currently exploitable by external attackers, it creates fragility in the codebase that could be triggered by future changes or undiscovered edge cases.

## Recommendation

Add defensive checks for empty responders at multiple layers:

**1. In `BatchRequesterState::next_request_peers()`**, validate signers before the modulo operation:

```rust
fn next_request_peers(&mut self, num_peers: usize) -> Option<Vec<PeerId>> {
    let signers = self.signers.lock();
    
    // Defensive check: handle empty signers gracefully
    if signers.is_empty() {
        debug!("QS: Cannot request batch - no signers available");
        return None;
    }
    
    if self.num_retries == 0 {
        let mut rng = rand::thread_rng();
        self.next_index = rng.r#gen::<usize>() % signers.len(); // Now safe
        counters::SENT_BATCH_REQUEST_COUNT.inc_by(num_peers as u64);
    } else {
        counters::SENT_BATCH_REQUEST_RETRY_COUNT.inc_by(num_peers as u64);
    }
    // ... rest of function
}
```

**2. In `QuorumStorePayloadManager::request_transactions()`**, filter out batches with empty responders:

```rust
fn request_transactions(...) -> Vec<...> {
    let mut futures = Vec::new();
    for (batch_info, responders) in batches {
        if responders.is_empty() {
            warn!("QS: Skipping batch with no responders: {}", batch_info.digest());
            continue;
        }
        // ... proceed with request
    }
    futures
}
```

**3. Add assertion in `process_optqs_payload()`** to ensure non-empty responders:

```rust
let batches_and_responders = data_ptr
    .batch_summary
    .iter()
    .map(|summary| {
        let mut signers = signers.clone();
        signers.append(&mut summary.signers(ordered_authors));
        ensure!(!signers.is_empty(), "Batch must have at least one responder");
        (summary.info().clone(), signers)
    })
    .collect();
```

## Proof of Concept

```rust
#[tokio::test]
async fn test_empty_responders_panic() {
    use consensus::quorum_store::batch_requester::BatchRequester;
    use aptos_types::PeerId;
    use std::collections::BTreeSet;
    use std::sync::Arc;
    use aptos_infallible::Mutex;
    
    // Create a batch requester with test configuration
    let batch_requester = /* ... initialize with test config ... */;
    
    // Create empty responders set (the vulnerability trigger)
    let empty_responders = Arc::new(Mutex::new(BTreeSet::<PeerId>::new()));
    
    // Create a test batch digest
    let batch_digest = HashValue::random();
    let expiration = 1000000;
    
    // This should panic with "attempt to calculate the remainder with a divisor of zero"
    let result = batch_requester.request_batch(
        batch_digest,
        expiration,
        empty_responders,
        oneshot::channel().1, // subscriber_rx
    ).await;
    
    // The test should catch the panic or demonstrate the hang
    assert!(result.is_err(), "Expected error when requesting batch with no responders");
}
```

**Notes**

While ProofOfStore validation SHOULD prevent this scenario in production through quorum voting power checks, the lack of defensive programming creates a critical reliability gap. The vulnerability violates the principle of defense-in-depth and could be triggered by:

1. Future modifications to validation logic
2. Undiscovered edge cases in special block types (Genesis, NilBlock)  
3. Race conditions during epoch transitions
4. Test environments with relaxed validation

The fix requires minimal code changes but significantly improves system robustness by failing gracefully rather than panicking when encountering unexpected empty responder sets.

### Citations

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L96-103)
```rust
        for (batch_info, responders) in batches {
            trace!(
                "QSE: requesting batch {:?}, time = {}",
                batch_info,
                block_timestamp
            );
            if block_timestamp <= batch_info.expiration() {
                futures.push(batch_reader.get_batch(batch_info, responders.clone()));
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L116-121)
```rust
        let futures = Self::request_transactions(batches, block_timestamp, batch_reader);
        let mut all_txns = Vec::new();
        for result in futures::future::join_all(futures).await {
            all_txns.append(&mut result?);
        }
        Ok(all_txns)
```

**File:** consensus/src/payload_manager/quorum_store_payload_manager.rs (L609-618)
```rust
    if let Some(peers) = additional_peers_to_request {
        for i in peers.iter_ones() {
            if let Some(author) = ordered_authors.get(i) {
                signers.push(*author);
            }
        }
    }
    if let Some(author) = block.author() {
        signers.push(author);
    }
```

**File:** consensus/src/quorum_store/batch_store.rs (L668-668)
```rust
        let mut responders = responders.into_iter().collect();
```

**File:** consensus/src/quorum_store/batch_store.rs (L696-703)
```rust
                        let payload = requester
                            .request_batch(
                                batch_digest,
                                batch_info.expiration(),
                                responders,
                                subscriber_rx,
                            )
                            .await?;
```

**File:** consensus/src/quorum_store/batch_requester.rs (L42-46)
```rust
        if self.num_retries == 0 {
            let mut rng = rand::thread_rng();
            // make sure nodes request from the different set of nodes
            self.next_index = rng.r#gen::<usize>() % signers.len();
            counters::SENT_BATCH_REQUEST_COUNT.inc_by(num_peers as u64);
```

**File:** consensus/src/quorum_store/batch_requester.rs (L59-59)
```rust
            self.next_index = (self.next_index + num_peers) % signers.len();
```

**File:** consensus/consensus-types/src/proof_of_store.rs (L654-658)
```rust
    pub fn shuffled_signers(&self, ordered_authors: &[PeerId]) -> Vec<PeerId> {
        let mut ret: Vec<PeerId> = self.multi_signature.get_signers_addresses(ordered_authors);
        ret.shuffle(&mut thread_rng());
        ret
    }
```

**File:** types/src/aggregate_signature.rs (L43-58)
```rust
    pub fn get_signers_addresses(
        &self,
        validator_addresses: &[AccountAddress],
    ) -> Vec<AccountAddress> {
        validator_addresses
            .iter()
            .enumerate()
            .filter_map(|(index, addr)| {
                if self.validator_bitmask.is_set(index as u16) {
                    Some(*addr)
                } else {
                    None
                }
            })
            .collect()
    }
```

**File:** types/src/validator_verifier.rs (L364-371)
```rust
        #[cfg(any(test, feature = "fuzzing"))]
        {
            if self.quorum_voting_power == 0 {
                // This should happen only in case of tests.
                // TODO(skedia): Clean up the test behaviors to not rely on empty signature
                // verification
                return Ok(());
            }
```

**File:** types/src/validator_verifier.rs (L453-460)
```rust
    pub fn check_voting_power<'a>(
        &self,
        authors: impl Iterator<Item = &'a AccountAddress>,
        check_super_majority: bool,
    ) -> std::result::Result<u128, VerifyError> {
        let aggregated_voting_power = self.sum_voting_power(authors)?;
        self.check_aggregated_voting_power(aggregated_voting_power, check_super_majority)
    }
```

**File:** consensus/consensus-types/src/block_data.rs (L137-145)
```rust
    pub fn author(&self) -> Option<Author> {
        match &self.block_type {
            BlockType::Proposal { author, .. } | BlockType::DAGBlock { author, .. } => {
                Some(*author)
            },
            BlockType::ProposalExt(p) => Some(*p.author()),
            BlockType::OptimisticProposal(p) => Some(*p.author()),
            _ => None,
        }
```
