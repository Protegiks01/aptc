# Audit Report

## Title
Validator Node Crash Due to Non-Atomic PartialStateComputeResult Updates in Block Executor with Retry Logic

## Summary
The `ledger_update` function in the block executor sets two `OnceCell` fields of `PartialStateComputeResult` sequentially without atomicity. If the first succeeds but the second fails, subsequent retry attempts panic with "StateCheckpointOutput already set", causing validator node crashes and loss of liveness.

## Finding Description

The vulnerability exists in the block executor's ledger update workflow where `PartialStateComputeResult` contains two `OnceCell` fields that must be set together atomically, but are actually set sequentially with fallible operations in between. [1](#0-0) 

These `OnceCell` fields provide interior mutability and panic when set twice: [2](#0-1) [3](#0-2) 

The critical vulnerability occurs in the `ledger_update` function where blocks stored in the block tree are updated: [4](#0-3) 

**Attack Scenario:**
1. Block is added to block tree with `PartialStateComputeResult` (both OnceCells unset)
2. `ledger_update()` executes line 315: `set_state_checkpoint_output()` successfully - first OnceCell is SET
3. Line 321: `DoLedgerUpdate::run()` FAILS (out of memory, parallel processing panic, injected error)
4. Error propagates, function returns, block remains in tree with partial state
5. Subsequent call to `ledger_update()` for the same block (due to retry or reprocessing)
6. Retry detection only checks if BOTH fields are complete: [5](#0-4) 

7. Returns `None` because `ledger_update_output` is not set, continues to line 315
8. Attempts `set_state_checkpoint_output()` again on already-set OnceCell
9. **PANIC**: "StateCheckpointOutput already set" - validator node CRASHES

The developer comment reveals awareness of retry scenarios: [6](#0-5) 

The reconfig suffix path has the same vulnerability: [7](#0-6) 

## Impact Explanation

**Critical Severity** - This meets the "Total loss of liveness/network availability" criterion from the Aptos bug bounty program:

1. **Validator Node Crash**: Once triggered, the validator panics and exits due to OnceCell double-set panic
2. **Persistent State Issue**: The block with partial state remains in the in-memory BlockTree structure
3. **Network Halt Risk**: If multiple validators encounter the same transient failure, >1/3 could crash, halting consensus
4. **Breaks Atomicity Invariant**: Partial state updates violate the atomicity guarantee expected from the two-phase commit pattern

The BlockTree persistence means the partially-updated block persists across function calls: [8](#0-7) 

## Likelihood Explanation

**Medium-to-High Likelihood** based on code structure:

1. **Retry Detection Exists**: The presence of retry detection logic with explicit log message "ledger_update already done" proves developers anticipated retry scenarios

2. **Transient Failures Are Realistic**: `DoLedgerUpdate` uses parallel iterators which can panic under resource pressure: [9](#0-8) 

3. **Failpoint Testing**: The codebase includes failpoint injection demonstrating errors can occur: [10](#0-9) 

4. **Test Evidence**: Test suite demonstrates multiple executions of the same block are supported: [11](#0-10) 

5. **Logic Bug**: Even if automatic retries are not currently implemented in consensus, this represents a latent logic vulnerability in the retry detection mechanism that could be triggered by future code changes or edge cases.

## Recommendation

Fix the retry detection to check for partial state and either complete the operation or reset both OnceCells atomically:

```rust
// At line 291, check for partial state:
if let Some(state_checkpoint) = block.output.state_checkpoint_output.get() {
    if block.output.ledger_update_output.get().is_none() {
        // Partial state detected - this is an error condition
        // Either: 1) Complete the operation, or 2) Clear both and retry
        return Err(ExecutorError::InternalError {
            error: "Partial ledger update state detected".into(),
        }.into());
    }
    // Both set - return complete result
    return Ok(block.output.expect_complete_result());
}
```

Alternatively, use a single OnceCell containing both outputs to ensure atomic updates, or implement a state machine with explicit partial-state handling.

## Proof of Concept

The vulnerability can be demonstrated by:

1. Calling `execute_and_update_state` to add a block to the BlockTree
2. Calling `ledger_update` with a failpoint configured to fail after `DoStateCheckpoint::run` but before `DoLedgerUpdate::run`
3. Calling `ledger_update` again for the same block
4. Observing the panic: "StateCheckpointOutput already set"

The test framework at [12](#0-11)  demonstrates the pattern, and the failpoint at [10](#0-9)  can be used to inject the failure between the two OnceCell sets.

## Notes

This is a logic vulnerability in the retry detection mechanism. While the exact conditions for triggering retries in production consensus are unclear, the presence of explicit retry detection code with logging proves developers anticipated this scenario. The retry check is buggy - it only detects complete results, not partial state, creating a crash vulnerability. This represents a violation of atomicity guarantees in the block execution pipeline that could lead to validator crashes and network liveness issues.

### Citations

**File:** execution/executor/src/types/partial_state_compute_result.rs (L17-22)
```rust
#[derive(Clone, Debug)]
pub struct PartialStateComputeResult {
    pub execution_output: ExecutionOutput,
    pub state_checkpoint_output: OnceCell<StateCheckpointOutput>,
    pub ledger_update_output: OnceCell<LedgerUpdateOutput>,
}
```

**File:** execution/executor/src/types/partial_state_compute_result.rs (L76-80)
```rust
    pub fn set_state_checkpoint_output(&self, state_checkpoint_output: StateCheckpointOutput) {
        self.state_checkpoint_output
            .set(state_checkpoint_output)
            .expect("StateCheckpointOutput already set");
    }
```

**File:** execution/executor/src/types/partial_state_compute_result.rs (L88-92)
```rust
    pub fn set_ledger_update_output(&self, ledger_update_output: LedgerUpdateOutput) {
        self.ledger_update_output
            .set(ledger_update_output)
            .expect("LedgerUpdateOutput already set");
    }
```

**File:** execution/executor/src/types/partial_state_compute_result.rs (L94-105)
```rust
    pub fn get_complete_result(&self) -> Option<StateComputeResult> {
        self.ledger_update_output.get().map(|ledger_update_output| {
            StateComputeResult::new(
                self.execution_output.clone(),
                // ledger_update_output is set in a later stage, so it's safe to `expect` here.
                self.ensure_state_checkpoint_output()
                    .expect("StateCheckpointOutput missing.")
                    .clone(),
                ledger_update_output.clone(),
            )
        })
    }
```

**File:** execution/executor/src/block_executor/mod.rs (L260-334)
```rust
    fn ledger_update(
        &self,
        block_id: HashValue,
        parent_block_id: HashValue,
    ) -> ExecutorResult<StateComputeResult> {
        let _timer = UPDATE_LEDGER.start_timer();
        info!(
            LogSchema::new(LogEntry::BlockExecutor).block_id(block_id),
            "ledger_update"
        );
        let committed_block_id = self.committed_block_id();
        let mut block_vec = self
            .block_tree
            .get_blocks_opt(&[block_id, parent_block_id])?;
        let parent_block = block_vec
            .pop()
            .expect("Must exist.")
            .ok_or(ExecutorError::BlockNotFound(parent_block_id))?;
        // At this point of time two things must happen
        // 1. The block tree must also have the current block id with or without the ledger update output.
        // 2. We must have the ledger update output of the parent block.
        // Above is not ture if the block is on a forked branch.
        let block = block_vec
            .pop()
            .expect("Must exist")
            .ok_or(ExecutorError::BlockNotFound(parent_block_id))?;
        parent_block.ensure_has_child(block_id)?;
        let output = &block.output;
        let parent_out = &parent_block.output;

        // TODO(aldenhu): remove, assuming no retries.
        if let Some(complete_result) = block.output.get_complete_result() {
            info!(block_id = block_id, "ledger_update already done.");
            return Ok(complete_result);
        }

        if parent_block_id != committed_block_id && parent_out.has_reconfiguration() {
            info!(block_id = block_id, "ledger_update for reconfig suffix.");

            // Parent must have done all state checkpoint and ledger update since this method
            // is being called.
            output.set_state_checkpoint_output(
                parent_out
                    .ensure_state_checkpoint_output()?
                    .reconfig_suffix(),
            );
            output.set_ledger_update_output(
                parent_out.ensure_ledger_update_output()?.reconfig_suffix(),
            );
        } else {
            THREAD_MANAGER.get_non_exe_cpu_pool().install(|| {
                // TODO(aldenhu): remove? no known strategy to recover from this failure
                fail_point!("executor::block_state_checkpoint", |_| {
                    Err(anyhow::anyhow!("Injected error in block state checkpoint."))
                });
                output.set_state_checkpoint_output(DoStateCheckpoint::run(
                    &output.execution_output,
                    parent_block.output.ensure_result_state_summary()?,
                    &ProvableStateSummary::new_persisted(self.db.reader.as_ref())?,
                    None,
                )?);
                output.set_ledger_update_output(DoLedgerUpdate::run(
                    &output.execution_output,
                    output.ensure_state_checkpoint_output()?,
                    parent_out
                        .ensure_ledger_update_output()?
                        .transaction_accumulator
                        .clone(),
                )?);
                Result::<_>::Ok(())
            })?;
        }

        Ok(block.output.expect_complete_result())
    }
```

**File:** execution/executor/src/block_executor/block_tree/mod.rs (L109-127)
```rust
        match self.0.entry(id) {
            Entry::Occupied(entry) => {
                let existing = entry
                    .get()
                    .upgrade()
                    .ok_or_else(|| anyhow!("block dropped unexpected."))?;
                Ok((existing, true, parent_block))
            },
            Entry::Vacant(entry) => {
                let block = Arc::new(Block {
                    id,
                    output,
                    children: Mutex::new(Vec::new()),
                    block_lookup: block_lookup.clone(),
                });
                entry.insert(Arc::downgrade(&block));
                Ok((block, false, parent_block))
            },
        }
```

**File:** execution/executor/src/workflow/do_ledger_update.rs (L53-56)
```rust
        (0..to_commit.len())
            .into_par_iter()
            .with_min_len(optimal_min_len(to_commit.len(), 64))
            .map(|i| {
```

**File:** execution/executor/src/tests/mod.rs (L302-332)
```rust
#[test]
fn test_executor_execute_same_block_multiple_times() {
    let executor = TestExecutor::new();
    let parent_block_id = executor.committed_block_id();
    let block_id = gen_block_id(1);
    let version = 100;

    let txns: Vec<_> = (0..version)
        .map(|i| encode_mint_transaction(gen_address(i), 100))
        .collect();

    let mut responses = vec![];
    for _i in 0..10 {
        let output = executor
            .execute_block(
                (block_id, block(txns.clone())).into(),
                parent_block_id,
                TEST_BLOCK_EXECUTOR_ONCHAIN_CONFIG,
            )
            .unwrap();
        responses.push(output);
    }
    assert_eq!(
        responses
            .iter()
            .map(|output| output.root_hash())
            .dedup()
            .count(),
        1,
    );
}
```
