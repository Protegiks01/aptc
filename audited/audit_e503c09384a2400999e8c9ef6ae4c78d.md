# Audit Report

## Title
Estimate Flag and size_has_changed Desynchronization Enables Incorrect Transaction Validation in BlockSTM

## Summary
The `mark_estimate()` function in `versioned_group_data.rs` marks size entries as estimates without updating the `size_has_changed` flag, creating a synchronization mismatch. This allows transactions to read and validate against stale group size estimates when `size_has_changed` is false, potentially leading to transactions committing with incorrect group size data under specific execution orderings in BlockSTM's parallel execution engine.

## Finding Description

The vulnerability stems from a synchronization gap between two mechanisms that control estimate handling for resource group sizes:

1. **Estimate Flag**: Set via `mark_estimate()` to indicate a write is speculative [1](#0-0) 

2. **size_has_changed Flag**: Set during `write()` operations to track if group sizes have varied across incarnations [2](#0-1) 

The critical issue is that `mark_estimate()` marks the size entry as an estimate but **does not update `size_has_changed`**. Subsequently, when `get_group_size_no_record()` checks whether to return a dependency error, it evaluates `size.is_estimate() && g.size_has_changed` [3](#0-2) 

This creates a vulnerability window when:
- A transaction at incarnation 0 writes a group size different from base
- The `size_has_changed` flag is NOT set (line 241 condition: `*idx != ShiftedTxnIndex::zero_idx() || incarnation > 0` evaluates to false) [4](#0-3) 
- The transaction is aborted and `mark_estimate()` is called [5](#0-4) 
- Other transactions can now read the estimate without receiving a dependency error
- Critically, **validation** also uses `get_group_size_no_record` via `validate_group_size` [6](#0-5) 

**Attack Scenario:**

1. Transaction T1 (index 5), incarnation 0, writes resource group with size 200 bytes (base was 100 bytes)
   - Previous size entry is base (ShiftedTxnIndex::zero_idx)
   - `update_flag = false` (incarnation == 0 AND idx == zero_idx)
   - Even though size changed (100 â†’ 200), `size_has_changed` remains **false**

2. T1 is aborted (validation failure), `mark_estimate()` called
   - Size entry marked as estimate
   - `size_has_changed` still **false**

3. Transaction T2 (index 10) reads group size during execution
   - `get_group_size_no_record` finds estimate from T1
   - Checks: `size.is_estimate() && g.size_has_changed` = `true && false` = **false**
   - Returns 200 bytes without dependency error
   - T2 executes based on size 200

4. T2 reaches validation phase
   - `validate_group_size` calls `get_group_size_no_record` [7](#0-6) 
   - Same check, still returns 200 bytes
   - Validation passes (200 == 200)

5. T1 re-executes, incarnation 1, writes with size 300 bytes
   - Now `size_has_changed` is set to true
   - But T2 already passed validation with stale size 200

If T2 commits before re-validation is triggered, it commits with incorrect group size data, breaking the deterministic execution invariant.

## Impact Explanation

**Severity: High to Critical**

This vulnerability can break the **Deterministic Execution** invariant: "All validators must produce identical state roots for identical blocks."

If transactions commit with different group sizes on different validators due to timing differences in BlockSTM's parallel execution, validators will compute different state roots for the same block, causing:
- **Consensus divergence** (Critical)
- **Potential chain splits** requiring manual intervention or hard fork
- **State inconsistency** across validator nodes

The impact severity depends on BlockSTM's scheduler implementation. If the scheduler guarantees re-validation before commit when lower-indexed transactions change, the vulnerability may only cause temporary inconsistencies (High severity). However, if race conditions allow commits with stale data, this becomes a Critical consensus violation.

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability requires:
1. A transaction writing at incarnation 0 with a size different from base (Common in normal operation)
2. The transaction being aborted and marked as estimate (Common in BlockSTM's optimistic execution)
3. Another transaction reading and validating during the estimate window (Timing-dependent)
4. The first transaction re-executing with a different size (Possible but not guaranteed)
5. The reading transaction committing before re-validation (Depends on scheduler implementation)

While each individual condition is plausible, the full attack chain requires specific timing. The likelihood increases with:
- High transaction throughput (more parallel execution)
- Resource groups with variable sizes across incarnations
- Longer validation windows

## Recommendation

**Fix Option 1: Update size_has_changed in mark_estimate()**
```rust
pub fn mark_estimate(&self, group_key: &K, txn_idx: TxnIndex, tags: HashSet<&T>) {
    for tag in tags {
        let key_ref = GroupKeyRef { group_key, tag };
        self.values.mark_estimate(&key_ref, txn_idx);
    }

    // Update: Set size_has_changed when marking estimate to ensure conservative reads
    let mut group_sizes = self.group_sizes.get_mut(group_key)
        .expect("Path must exist");
    group_sizes.size_has_changed = true;  // Force dependency on estimates
    
    group_sizes
        .size_entries
        .get(&ShiftedTxnIndex::new(txn_idx))
        .expect("Entry by the txn must exist to mark estimate")
        .mark_estimate();
}
```

**Fix Option 2: Remove estimate heuristic from validation**
Create a separate `get_group_size_for_validation()` that always returns dependency errors for estimates, regardless of `size_has_changed`:
```rust
pub fn get_group_size_for_validation(
    &self,
    group_key: &K,
    txn_idx: TxnIndex,
) -> Result<ResourceGroupSize, MVGroupError> {
    match self.group_sizes.get(group_key) {
        Some(g) => {
            Self::get_latest_entry(&g.size_entries, txn_idx, ReadPosition::BeforeCurrentTxn)
                .map_or(Err(MVGroupError::Uninitialized), |(idx, size)| {
                    // Always return dependency for estimates during validation
                    if size.is_estimate() {
                        Err(MVGroupError::Dependency(
                            idx.idx().expect("May not depend on storage version"),
                        ))
                    } else {
                        Ok(size.value.size)
                    }
                })
        },
        None => Err(MVGroupError::Uninitialized),
    }
}
```

## Proof of Concept

```rust
#[test]
fn test_estimate_validation_race() {
    use crate::types::test::{KeyType, TestValue};
    use aptos_vm_types::resolver::ResourceGroupSize;
    
    let group_key = KeyType(b"/group/test".to_vec());
    let map = VersionedGroupData::<KeyType<Vec<u8>>, usize, TestValue>::empty();
    
    // Initialize group
    assert_ok!(map.set_raw_base_values(group_key.clone(), vec![]));
    
    // T1 (index 5), incarnation 0: writes size 200 (different from base)
    let size_200 = ResourceGroupSize::Combined {
        num_tagged_resources: 2,
        all_tagged_resources_size: 200,
    };
    assert_ok!(map.write(
        group_key.clone(),
        5,
        0,  // incarnation 0
        vec![(1, (TestValue::creation_with_len(10), None))],
        size_200,
        HashSet::new(),
    ));
    
    // Verify size_has_changed is false (incarnation 0 doesn't set it)
    assert!(!map.group_sizes.get(&group_key).unwrap().size_has_changed);
    
    // T1 is aborted, mark as estimate
    map.mark_estimate(&group_key, 5, vec![&1].into_iter().collect());
    
    // T2 (index 10) reads during estimate - should get dependency but doesn't!
    let read_size = map.get_group_size_no_record(&group_key, 10);
    // BUG: Returns Ok(size_200) instead of Err(Dependency(5))
    assert_ok_eq!(read_size, size_200);
    
    // Validation also passes incorrectly
    assert!(map.validate_group_size(&group_key, 10, size_200));
    
    // T1 re-executes with different size 300
    let size_300 = ResourceGroupSize::Combined {
        num_tagged_resources: 3,
        all_tagged_resources_size: 300,
    };
    map.remove(&group_key, 5, vec![1].into_iter().collect());
    assert_ok!(map.write(
        group_key.clone(),
        5,
        1,  // incarnation 1
        vec![(1, (TestValue::creation_with_len(15), None))],
        size_300,
        HashSet::new(),
    ));
    
    // Now size_has_changed is true
    assert!(map.group_sizes.get(&group_key).unwrap().size_has_changed);
    
    // But T2 already validated with size_200!
    // In a real execution, T2 might commit with stale size before re-validation
}
```

## Notes

The existing test at line 1522-1527 explicitly expects and validates this behavior ("Despite estimates, should still return size"), suggesting this was an intentional optimization rather than an oversight. However, the optimization creates a soundness issue for validation where estimates can be treated as valid values, violating BlockSTM's dependency tracking guarantees. The severity depends critically on whether BlockSTM's scheduler guarantees re-validation of all dependent transactions before allowing commits, which would require examining the full executor implementation to confirm.

### Citations

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L227-251)
```rust
        if !(group_sizes.size_has_changed && ret) {
            let (size_changed, update_flag) = Self::get_latest_entry(
                &group_sizes.size_entries,
                txn_idx,
                ReadPosition::AfterCurrentTxn,
            )
            .ok_or_else(|| {
                code_invariant_error("Initialized group sizes must contain storage version")
            })
            .map(|(idx, prev_size)| {
                (
                    prev_size.value.size != size,
                    // Update the size_has_changed flag if the entry isn't the base value
                    // (which may be non-existent) or if the incarnation > 0.
                    *idx != ShiftedTxnIndex::zero_idx() || incarnation > 0,
                )
            })?;

            if size_changed {
                ret = true;
                if update_flag {
                    group_sizes.size_has_changed = true;
                }
            }
        }
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L322-336)
```rust
    pub fn mark_estimate(&self, group_key: &K, txn_idx: TxnIndex, tags: HashSet<&T>) {
        for tag in tags {
            // Use GroupKeyRef to avoid cloning the group_key
            let key_ref = GroupKeyRef { group_key, tag };
            self.values.mark_estimate(&key_ref, txn_idx);
        }

        self.group_sizes
            .get(group_key)
            .expect("Path must exist")
            .size_entries
            .get(&ShiftedTxnIndex::new(txn_idx))
            .expect("Entry by the txn must exist to mark estimate")
            .mark_estimate();
    }
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L462-482)
```rust
    pub fn get_group_size_no_record(
        &self,
        group_key: &K,
        txn_idx: TxnIndex,
    ) -> Result<ResourceGroupSize, MVGroupError> {
        match self.group_sizes.get(group_key) {
            Some(g) => {
                Self::get_latest_entry(&g.size_entries, txn_idx, ReadPosition::BeforeCurrentTxn)
                    .map_or(Err(MVGroupError::Uninitialized), |(idx, size)| {
                        if size.is_estimate() && g.size_has_changed {
                            Err(MVGroupError::Dependency(
                                idx.idx().expect("May not depend on storage version"),
                            ))
                        } else {
                            Ok(size.value.size)
                        }
                    })
            },
            None => Err(MVGroupError::Uninitialized),
        }
    }
```

**File:** aptos-move/mvhashmap/src/versioned_group_data.rs (L504-511)
```rust
    pub fn validate_group_size(
        &self,
        group_key: &K,
        txn_idx: TxnIndex,
        group_size_to_validate: ResourceGroupSize,
    ) -> bool {
        self.get_group_size_no_record(group_key, txn_idx) == Ok(group_size_to_validate)
    }
```

**File:** aptos-move/block-executor/src/executor_utilities.rs (L332-339)
```rust
    last_input_output
        .for_each_resource_group_key_and_tags(txn_idx, |key, tags| {
            versioned_cache
                .group_data()
                .mark_estimate(key, txn_idx, tags);
            Ok(())
        })
        .expect("Passed closure always returns Ok");
```

**File:** aptos-move/block-executor/src/captured_reads.rs (L1102-1106)
```rust
        self.group_reads.iter().all(|(key, group)| {
            let mut ret = true;
            if let Some(size) = group.collected_size {
                ret &= group_map.validate_group_size(key, idx_to_validate, size);
            }
```
