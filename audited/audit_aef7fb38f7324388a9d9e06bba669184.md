# Audit Report

## Title
URL Path Traversal in REST Client `build_path()` Allows Access to Internal Debugging Endpoints

## Summary
The `build_path()` function in the Aptos REST client does not sanitize path parameters, allowing attackers to use path traversal sequences (`../`) to access arbitrary API endpoints, including internal debugging endpoints like `/set_failpoint`.

## Finding Description
The `build_path()` function uses Rust's `url` crate to join URL paths without validating or sanitizing the input path parameter: [1](#0-0) 

When client methods like `get_account_resource()` construct paths, they format user-controlled parameters directly into the path string: [2](#0-1) 

The `url` crate's `join()` method implements RFC 3986, which normalizes paths by resolving `..` segments. An attacker can exploit this by passing a crafted `resource_type` parameter:

**Attack Example:**
```
client.get_account_resource(address, "../../../set_failpoint?name=test&actions=panic")
```

This constructs the path:
```
accounts/0x1/resource/../../../set_failpoint?name=test&actions=panic
```

After URL normalization:
```
/v1/set_failpoint?name=test&actions=panic
```

The REST API exposes a debugging endpoint at `/v1/set_failpoint`: [3](#0-2) 

This endpoint can manipulate fail points when enabled: [4](#0-3) 

## Impact Explanation
**High Severity** - This vulnerability allows bypassing the intended REST client API design to access internal debugging endpoints. While the `/set_failpoint` endpoint requires `failpoints_enabled()` configuration (typically disabled in production), the path traversal pattern itself is a significant security flaw that violates defense-in-depth principles.

In development/testing environments where failpoints are enabled: [5](#0-4) 

An attacker could trigger node crashes or manipulate behavior, potentially causing validator node slowdowns or API crashes (High Severity per bug bounty criteria).

## Likelihood Explanation
**Medium-to-High Likelihood** in affected environments. Any application using the Aptos REST client library where:
1. Developers accept user input for `resource_type` parameters
2. The target node has failpoints or other sensitive endpoints enabled
3. No additional input validation is performed at the application level

The attack requires no special privileges and can be executed by any REST client user.

## Recommendation
Implement strict path sanitization in `build_path()` to reject path traversal sequences:

```rust
pub fn build_path(&self, path: &str) -> AptosResult<Url> {
    // Reject path traversal attempts
    if path.contains("..") || path.starts_with('/') {
        return Err(anyhow!("Invalid path: path traversal not allowed").into());
    }
    Ok(self.base_url.join(&self.version_path_base)?.join(path)?)
}
```

Additionally, validate input parameters at the call sites:
- For `resource_type`, validate against the expected format (`address::module::name`)
- Reject any input containing special characters like `../` or absolute paths

## Proof of Concept
```rust
#[cfg(test)]
mod tests {
    use super::*;
    use url::Url;

    #[test]
    fn test_path_traversal_vulnerability() {
        let client = Client {
            inner: reqwest::Client::new(),
            base_url: Url::parse("http://localhost:8080/").unwrap(),
            version_path_base: "v1/".to_string(),
        };
        
        // Demonstrate path traversal
        let malicious_resource = "../../../set_failpoint?name=test&actions=panic";
        let address = AccountAddress::from_hex_literal("0x1").unwrap();
        
        let path = format!(
            "accounts/{}/resource/{}",
            address.to_hex(),
            malicious_resource
        );
        
        let url = client.build_path(&path).unwrap();
        
        // Verify the URL ends up at /v1/set_failpoint
        assert_eq!(url.path(), "/v1/set_failpoint");
        assert_eq!(url.query(), Some("name=test&actions=panic"));
    }
}
```

## Notes
While this vulnerability exists in the REST client code, its exploitation requires that debugging endpoints be enabled, which is typically not the case in production mainnet nodes. The primary concern is defense-in-depth: client libraries should never allow path traversal regardless of server-side protections. This is particularly relevant in testnet/devnet environments where debugging features may be active.

### Citations

**File:** crates/aptos-rest-client/src/lib.rs (L155-157)
```rust
    pub fn build_path(&self, path: &str) -> AptosResult<Url> {
        Ok(self.base_url.join(&self.version_path_base)?.join(path)?)
    }
```

**File:** crates/aptos-rest-client/src/lib.rs (L1194-1198)
```rust
        let url = self.build_path(&format!(
            "accounts/{}/resource/{}",
            address.to_hex(),
            resource_type
        ))?;
```

**File:** api/src/runtime.rs (L248-251)
```rust
                    .at(
                        "/set_failpoint",
                        poem::get(set_failpoints::set_failpoint_poem).data(context.clone()),
                    ),
```

**File:** api/src/set_failpoints.rs (L22-40)
```rust
#[handler]
pub fn set_failpoint_poem(
    context: Data<&std::sync::Arc<Context>>,
    Query(failpoint_conf): Query<FailpointConf>,
) -> poem::Result<String> {
    if context.failpoints_enabled() {
        fail::cfg(&failpoint_conf.name, &failpoint_conf.actions)
            .map_err(|e| poem::Error::from(anyhow::anyhow!(e)))?;
        info!(
            "Configured failpoint {} to {}",
            failpoint_conf.name, failpoint_conf.actions
        );
        Ok(format!("Set failpoint {}", failpoint_conf.name))
    } else {
        Err(poem::Error::from(anyhow::anyhow!(
            "Failpoints are not enabled at a config level"
        )))
    }
}
```

**File:** config/src/config/admin_service_config.rs (L93-101)
```rust
        if node_config.admin_service.enabled.is_none() {
            // Only enable the admin service if the chain is not mainnet
            let admin_service_enabled = if let Some(chain_id) = chain_id {
                !chain_id.is_mainnet()
            } else {
                false // We cannot determine the chain ID, so we disable the admin service
            };
            node_config.admin_service.enabled = Some(admin_service_enabled);

```
