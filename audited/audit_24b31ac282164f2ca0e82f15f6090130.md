# Audit Report

## Title
Dependency Digest Bypass Vulnerability: Optional Cryptographic Verification Allows Malicious Code Substitution

## Summary
The Move package build system does not enforce cryptographic digest verification for git dependencies. The `digest` field in dependency declarations is optional, and when omitted, downloaded dependencies are not verified against any cryptographic hash. This allows attackers who compromise upstream git repositories or perform man-in-the-middle attacks to substitute malicious Move code into validator nodes, potentially causing consensus violations, state corruption, or theft of funds.

## Finding Description

The vulnerability exists in the Move package dependency resolution system. When a Move package declares a git dependency in its `Move.toml` file, it can optionally specify a `digest` field containing a cryptographic hash of the dependency's source code. However, this field is **optional**, not mandatory. [1](#0-0) 

The dependency parsing logic treats the digest as optional: [2](#0-1) 

During dependency resolution, the system downloads git dependencies without any cryptographic verification: [3](#0-2) 

The digest verification only occurs **if a digest was specified** in the Move.toml: [4](#0-3) 

This is called from the Move CLI build command: [5](#0-4) 

**Attack Scenario:**

1. A Move package developer declares a git dependency without specifying a digest field
2. An attacker compromises the upstream git repository or performs a MITM attack on git connections
3. When validators build the package (either initial build or dependency update), the malicious code is downloaded
4. No cryptographic verification occurs because digest was not specified
5. Malicious Move bytecode is compiled into the validator node

**Broken Invariants:**

- **Deterministic Execution**: Different validators could compile different versions of dependencies if the upstream repository changes between builds
- **Move VM Safety**: Malicious Move bytecode could exploit VM vulnerabilities or bypass safety checks
- **Cryptographic Correctness**: Dependencies lack cryptographic integrity verification

## Impact Explanation

This vulnerability is **CRITICAL** severity per Aptos bug bounty criteria for the following reasons:

1. **Consensus/Safety Violations**: If different validators compile packages at different times and the upstream dependency changes, they will execute different bytecode for the same transactions, producing different state roots. This violates the fundamental AptosBFT safety property and could cause permanent chain splits requiring a hard fork.

2. **Loss of Funds**: Malicious Move code could contain logic to steal funds, bypass access controls on resources, or manipulate governance/staking mechanisms. Examples include:
   - Modifying coin transfer logic to redirect funds
   - Bypassing authentication checks
   - Manipulating validator rewards/penalties

3. **State Corruption**: Compromised dependencies could corrupt the Jellyfish Merkle Tree or introduce state inconsistencies that require manual intervention or hard fork to resolve.

4. **Validator Compromise**: Malicious code could potentially escape Move VM sandbox boundaries or exploit native function vulnerabilities to achieve remote code execution on validator nodes.

The vulnerability affects **all packages that declare git dependencies without digest fields**, which may include critical Aptos Framework dependencies, governance modules, or third-party packages used by validators.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

The likelihood depends on several factors:

**Factors Increasing Likelihood:**
- Digest fields are **optional** and not enforced by the build system
- Many developers may not be aware of the security implications
- No warnings or errors are generated when digest is omitted
- Package documentation may not emphasize digest requirement
- Git repository compromises are a realistic threat (supply chain attacks are increasingly common)
- Dependency updates without `--skip-fetch-latest-git-deps` automatically fetch latest code

**Factors Decreasing Likelihood:**
- Requires attacker to compromise specific upstream repositories
- HTTPS git connections provide some transport security (but not content integrity)
- Sophisticated validators may audit dependency code

**Realistic Attack Vectors:**
1. **Upstream Repository Compromise**: Attacker gains access to a popular Move library's git repository
2. **Typosquatting**: Attacker creates similarly-named repositories that developers accidentally use
3. **MITM on CI/CD**: Attacker compromises build infrastructure to inject malicious dependencies

Given the critical impact and realistic attack scenarios, this vulnerability requires immediate remediation.

## Recommendation

**Immediate Fix: Enforce Mandatory Digest Verification**

1. **Make digest field mandatory** for all git dependencies:

Modify the dependency parsing to require digest for git dependencies: [6](#0-5) 

Add validation after parsing to ensure git dependencies have digests:

```rust
// After line 472 in resolution_graph.rs, add:
if dep.git_info.is_some() && dep.digest.is_none() {
    bail!(
        "Dependency '{}' is a git dependency but lacks a required 'digest' field. \
         Git dependencies must specify a cryptographic digest for security. \
         Run with --generate-digest to automatically compute and add digest.",
        dep_name_in_pkg
    );
}
```

2. **Add CLI flag to generate digests**: Implement `--generate-digest` flag that:
   - Downloads dependencies
   - Computes their digests
   - Outputs updated Move.toml with digest fields

3. **Add warnings for local dependencies**: While local dependencies don't have the same MITM risk, they should still include digests for reproducibility

4. **Update documentation**: Clearly document that digest fields are mandatory for security-critical packages

5. **Add migration guide**: Help existing packages add digest fields to their dependencies

## Proof of Concept

**Step 1: Create a vulnerable Move.toml**

```toml
[package]
name = "VulnerablePackage"
version = "1.0.0"

[dependencies]
MoveStdlib = { git = "https://github.com/attacker/move-stdlib.git", rev = "main", subdir = "language/move-stdlib" }
# Note: No 'digest' field specified!

[addresses]
std = "0x1"
```

**Step 2: Trace execution flow**

When `move build` or `aptos move compile` is executed:

1. `Build::execute()` is called in `third_party/move/tools/move-cli/src/base/build.rs`
2. This calls `config.compile_package()` or `config.download_deps_for_package()`
3. Eventually calls `ResolutionGraph::download_and_update_if_remote()`
4. Git clone/fetch occurs without verification
5. `process_dependency()` checks digest but finds `None`, so no verification occurs
6. Malicious code is compiled into the package

**Step 3: Demonstrate the vulnerability**

```rust
// Test case demonstrating the issue
#[test]
fn test_missing_digest_allows_unverified_download() {
    // Create a Move.toml with git dependency without digest
    let manifest = r#"
[package]
name = "TestPackage"
version = "1.0.0"

[dependencies]
SomeLib = { git = "https://example.com/lib.git", rev = "main", subdir = "." }

[addresses]
test = "0x1"
"#;
    
    // Parse the manifest
    let parsed = parse_move_manifest_string(manifest.to_string()).unwrap();
    let source_manifest = parse_source_manifest(parsed).unwrap();
    
    // Verify that digest is None
    let dep = source_manifest.dependencies.get(&PackageName::from("SomeLib")).unwrap();
    assert!(dep.digest.is_none(), "Digest should be None");
    
    // When this dependency is processed, no cryptographic verification occurs
    // An attacker who controls the git repository can inject malicious code
}
```

**Impact Demonstration:**

If an attacker compromises the `move-stdlib` repository and a validator rebuilds their node:
1. Malicious Move bytecode gets compiled into the validator
2. During transaction execution, the compromised code runs
3. The validator produces different state roots than honest validators
4. Consensus breaks, potentially causing chain split

## Notes

This vulnerability is particularly dangerous because:

1. **Silent Failure**: The system provides no warning when digest is omitted
2. **Widespread Impact**: Affects all packages in the ecosystem that don't use digests
3. **Supply Chain Attack**: Exploits trust in upstream dependencies
4. **Consensus Critical**: Direct path to consensus violations

The fix must be implemented carefully to avoid breaking existing packages, but the security requirement is clear: **all remote dependencies must be cryptographically verified**.

### Citations

**File:** third_party/move/tools/move-package/src/source_package/parsed_manifest.rs (L74-81)
```rust
pub struct Dependency {
    pub local: PathBuf,
    pub subst: Option<Substitution>,
    pub version: Option<Version>,
    pub digest: Option<PackageDigest>,
    pub git_info: Option<GitInfo>,
    pub node_info: Option<CustomDepInfo>,
}
```

**File:** third_party/move/tools/move-package/src/source_package/manifest_parser.rs (L307-350)
```rust
fn parse_dependency(dep_name: &str, tval: TV) -> Result<PM::Dependency> {
    match tval {
        TV::Table(mut table) => {
            let mut known_fields = vec![
                "addr_subst",
                "version",
                "local",
                "digest",
                "git",
                "rev",
                "subdir",
                "address",
            ];
            let custom_key_opt = &package_hooks::custom_dependency_key();
            if let Some(key) = custom_key_opt {
                known_fields.push(key.as_ref())
            }
            warn_if_unknown_field_names(&table, known_fields.as_slice());
            let subst = table
                .remove("addr_subst")
                .map(parse_substitution)
                .transpose()?;
            let version = table.remove("version").map(parse_version).transpose()?;
            let digest = table.remove("digest").map(parse_digest).transpose()?;
            let mut git_info = None;
            let mut node_info = None;
            match (
                table.remove("local"),
                table.remove("git"),
                if let Some(key) = custom_key_opt {
                    table.remove(key)
                } else {
                    None
                },
            ) {
                (Some(local), None, None) => {
                    let local_str = local
                        .as_str()
                        .ok_or_else(|| format_err!("Local source path not a string"))?;
                    let local_path = PathBuf::from(local_str);
                    Ok(PM::Dependency {
                        subst,
                        version,
                        digest,
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L456-472)
```rust
        match dep.digest {
            None => (),
            Some(fixed_digest) => {
                let resolved_pkg = self
                    .package_table
                    .get(&dep_name_in_pkg)
                    .context("Unable to find resolved package by name")?;
                if fixed_digest != resolved_pkg.source_digest {
                    bail!(
                        "Source digest mismatch in dependency '{}'. Expected '{}' but got '{}'.",
                        dep_name_in_pkg,
                        fixed_digest,
                        resolved_pkg.source_digest
                    )
                }
            },
        }
```

**File:** third_party/move/tools/move-package/src/resolution/resolution_graph.rs (L551-616)
```rust
    fn download_and_update_if_remote<W: Write>(
        dep_name: PackageName,
        dep: &Dependency,
        skip_fetch_latest_git_deps: bool,
        writer: &mut W,
    ) -> Result<()> {
        if let Some(git_info) = &dep.git_info {
            let git_url = git_info.git_url.as_str();
            let git_rev = git_info.git_rev.as_str();
            let git_path = &git_info.download_to.display().to_string();

            // If there is no cached dependency, download it
            if !git_info.download_to.exists() {
                writeln!(
                    writer,
                    "{} {}",
                    "FETCHING GIT DEPENDENCY".bold().green(),
                    git_url,
                )?;

                // Confirm git is available.
                git::confirm_git_available()?;

                // If the cached folder does not exist, download and clone accordingly
                git::clone(git_url, git_path, dep_name)?;
                git::checkout(git_path, git_rev, dep_name)?;
            } else if !skip_fetch_latest_git_deps {
                // Confirm git is available.
                git::confirm_git_available()?;

                // Update the git dependency
                // Check first that it isn't a git rev (if it doesn't work, just continue with the fetch)
                if let Ok(parsed_rev) = git::find_rev(git_path, git_rev) {
                    // If it's exactly the same, then it's a git rev
                    if parsed_rev.trim().starts_with(git_rev) {
                        return Ok(());
                    }
                }

                if let Ok(tag) = git::find_tag(git_path, git_rev) {
                    // If it's exactly the same, then it's a git tag, for now tags won't be updated
                    // Tags don't easily update locally and you can't use reset --hard to cleanup
                    // any extra files
                    if tag.trim().starts_with(git_rev) {
                        return Ok(());
                    }
                }

                writeln!(
                    writer,
                    "{} {}",
                    "UPDATING GIT DEPENDENCY".bold().green(),
                    git_url,
                )?;
                // If the current folder exists, do a fetch and reset to ensure that the branch
                // is up to date
                // NOTE: this means that you must run the package system with a working network connection
                git::fetch_origin(git_path, dep_name)?;
                git::reset_hard(git_path, git_rev, dep_name)?;
            }
        }
        if let Some(node_info) = &dep.node_info {
            package_hooks::resolve_custom_dependency(dep_name, node_info)?
        }
        Ok(())
    }
```

**File:** third_party/move/tools/move-cli/src/base/build.rs (L15-27)
```rust
    pub fn execute(self, path: Option<PathBuf>, config: BuildConfig) -> anyhow::Result<()> {
        let rerooted_path = reroot_path(path)?;
        if config.fetch_deps_only {
            let mut config = config;
            if config.test_mode {
                config.dev_mode = true;
            }
            config.download_deps_for_package(&rerooted_path, &mut std::io::stdout())?;
            return Ok(());
        }
        config.compile_package(&rerooted_path, &mut std::io::stdout())?;
        Ok(())
    }
```
