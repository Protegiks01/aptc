# Audit Report

## Title
Missing Peer Authorization in Consensus Observer Allows Unauthorized Subscription and Information Disclosure

## Summary
The `send_serialized_message_to_peer()` function in the ConsensusObserverClient does not validate that the peer_network_id is in an authorized peer set before sending consensus data. More critically, the ConsensusPublisher's Subscribe request handler adds ANY connected peer to active_subscribers without authorization checks, allowing unauthorized peers to receive all consensus updates including pre-commit blocks, transaction payloads, and commit decisions.

## Finding Description

The vulnerability consists of two related security issues:

**Issue 1: Missing Authorization in Subscribe Request Handler**

When a peer sends a Subscribe RPC request, the `process_network_message()` function in ConsensusPublisher immediately adds the peer to `active_subscribers` without any authorization validation: [1](#0-0) 

Any peer that can establish a network connection and supports the ConsensusObserver protocols can subscribe and receive consensus updates. There is no check against a trusted peer set, no role-based access control, and no configuration option to restrict subscribers.

**Issue 2: Missing Peer Validation in send_serialized_message_to_peer()**

The `send_serialized_message_to_peer()` function accepts any peer_network_id parameter and sends directly without validating that the peer is authorized: [2](#0-1) 

The function only increments metrics, logs the send, and calls the network client's `send_to_peer_raw()`. There is no check that the peer_network_id is in the `active_subscribers` set or any other authorization list.

**Attack Surface Expansion**

Unlike regular consensus which only registers on the Validator network, consensus observer registers on ALL configured networks: [3](#0-2) 

This means:
- Validators expose consensus observer on both Validator AND Vfn networks
- VFNs expose it on both Vfn AND Public networks (if configured)

The Vfn network allows untrusted peer connections where PeerRole is automatically assigned during handshake, significantly expanding the attack surface.

**Attack Scenario:**

1. Attacker establishes connection to a Validator's VFN network as an untrusted VFN
2. Attacker sends `ConsensusObserverRequest::Subscribe` RPC to the ConsensusPublisher
3. `process_network_message()` adds attacker to `active_subscribers` without authorization
4. `publish_message()` iterates through `active_subscribers` and sends all consensus updates to attacker: [4](#0-3) 

5. Attacker receives ordered blocks, commit decisions, and transaction payloads before public commitment

## Impact Explanation

This vulnerability meets **HIGH severity** criteria per the Aptos bug bounty program as a "Significant protocol violation" with the following impacts:

**Information Disclosure (High)**
- Unauthorized peers gain access to pre-commit consensus data including blocks, transaction ordering, and quorum certificates
- Violates confidentiality expectations for consensus data before public commitment

**Front-running Risk (High)**  
- Attackers with early access to transaction ordering can submit competing transactions with higher gas prices
- Enables MEV (Miner Extractable Value) extraction opportunities
- Unfair advantage in transaction ordering visibility

**Resource Exhaustion (Medium)**
- Each unauthorized subscriber receives the full consensus data stream
- Multiple malicious subscribers can exhaust validator bandwidth and CPU
- The `max_concurrent_subscriptions=2` limit only applies to the observer side, not the publisher [5](#0-4) 

**Access Control Violation (High)**
- System design implicitly expects some form of peer authorization (hence the security question)
- No mechanism exists to restrict or audit which peers receive consensus data
- Violates defense-in-depth principles

## Likelihood Explanation

**Likelihood: HIGH**

The attack is highly likely to succeed because:

1. **Minimal Prerequisites**: Attacker only needs to connect to a validator's VFN network, which is designed to accept connections from untrusted VFNs
2. **No Authentication Required**: Beyond network-level peer authentication, no additional authorization is checked
3. **Simple Exploitation**: A single RPC call (`Subscribe`) is sufficient to gain access
4. **Enabled by Default**: Consensus observer publisher is enabled by default on validators and VFNs: [6](#0-5) 

5. **No Detection**: The attack uses legitimate protocol operations and appears as normal observer traffic

## Recommendation

Implement multi-layered authorization for consensus observer subscriptions:

**1. Add Authorization Check in Subscribe Handler:**

```rust
fn process_network_message(&self, network_message: ConsensusPublisherNetworkMessage) {
    let (peer_network_id, message, response_sender) = network_message.into_parts();
    
    // ... existing metrics code ...
    
    match message {
        ConsensusObserverRequest::Subscribe => {
            // NEW: Validate peer is authorized to subscribe
            if !self.is_peer_authorized(&peer_network_id) {
                warn!(LogSchema::new(LogEntry::ConsensusPublisher)
                    .event(LogEvent::Subscription)
                    .message(&format!(
                        "Rejected unauthorized subscription from peer: {:?}",
                        peer_network_id
                    )));
                response_sender.send(ConsensusObserverResponse::SubscribeRejected);
                return;
            }
            
            // Add the peer to the set of active subscribers
            self.add_active_subscriber(peer_network_id);
            // ... rest of existing code ...
        },
        // ... rest of match arms ...
    }
}
```

**2. Add Peer Validation in send_serialized_message_to_peer():**

```rust
pub fn send_serialized_message_to_peer(
    &self,
    peer_network_id: &PeerNetworkId,
    message: Bytes,
    message_label: &str,
    active_subscribers: &HashSet<PeerNetworkId>, // NEW parameter
) -> Result<(), Error> {
    // NEW: Validate peer is in active subscribers
    if !active_subscribers.contains(peer_network_id) {
        return Err(Error::UnexpectedError(format!(
            "Attempted to send to unauthorized peer: {:?}",
            peer_network_id
        )));
    }
    
    // ... rest of existing code ...
}
```

**3. Add Configuration for Authorized Observers:**

Add to `ConsensusObserverConfig`:
```rust
pub authorized_observer_peers: Option<HashSet<PeerId>>,
pub allow_all_observers: bool, // For backwards compatibility
```

## Proof of Concept

```rust
// Test demonstrating unauthorized subscription
#[tokio::test]
async fn test_unauthorized_subscription_exploit() {
    use aptos_config::network_id::{NetworkId, PeerNetworkId};
    use aptos_types::PeerId;
    
    // Setup: Create a ConsensusPublisher on VFN network
    let network_id = NetworkId::Vfn;
    let peers_and_metadata = PeersAndMetadata::new(&[network_id]);
    let network_client = NetworkClient::new(
        vec![ProtocolId::ConsensusObserver],
        vec![ProtocolId::ConsensusObserverRpc],
        hashmap!{},
        peers_and_metadata.clone()
    );
    let consensus_observer_client = Arc::new(ConsensusObserverClient::new(network_client));
    let (consensus_publisher, _) = ConsensusPublisher::new(
        ConsensusObserverConfig::default(),
        consensus_observer_client,
    );
    
    // Attack: Unauthorized peer sends Subscribe request
    let attacker_peer = PeerNetworkId::new(network_id, PeerId::random());
    let subscribe_request = ConsensusObserverRequest::Subscribe;
    let (response_sender, _response_receiver) = oneshot::channel();
    
    let network_message = ConsensusPublisherNetworkMessage::new(
        attacker_peer,
        subscribe_request,
        ResponseSender::new_for_test(),
    );
    
    // Process the malicious subscription
    consensus_publisher.process_network_message(network_message);
    
    // Verify: Attacker is now in active_subscribers
    let active_subscribers = consensus_publisher.get_active_subscribers();
    assert!(active_subscribers.contains(&attacker_peer), 
        "Unauthorized peer successfully subscribed without authorization check!");
    
    // The attacker will now receive all consensus updates
    // including pre-commit blocks, transaction payloads, and commit decisions
}
```

This PoC demonstrates that any peer can subscribe without authorization checks, gaining access to consensus data streams that should be restricted to authorized observers only.

---

**Notes:**

The vulnerability exists because the consensus observer system lacks any peer authorization mechanism beyond basic network-level authentication. While the underlying network layer authenticates peer identities, there is no application-level authorization to determine which authenticated peers should be allowed to observe consensus data. This violates the principle of defense-in-depth and creates significant information disclosure risks.

### Citations

**File:** consensus/src/consensus_observer/publisher/consensus_publisher.rs (L181-192)
```rust
            ConsensusObserverRequest::Subscribe => {
                // Add the peer to the set of active subscribers
                self.add_active_subscriber(peer_network_id);
                info!(LogSchema::new(LogEntry::ConsensusPublisher)
                    .event(LogEvent::Subscription)
                    .message(&format!(
                        "New peer subscribed to consensus updates! Peer: {:?}",
                        peer_network_id
                    )));

                // Send a simple subscription ACK
                response_sender.send(ConsensusObserverResponse::SubscribeAck);
```

**File:** consensus/src/consensus_observer/publisher/consensus_publisher.rs (L212-232)
```rust
    pub fn publish_message(&self, message: ConsensusObserverDirectSend) {
        // Get the active subscribers
        let active_subscribers = self.get_active_subscribers();

        // Send the message to all active subscribers
        for peer_network_id in &active_subscribers {
            // Send the message to the outbound receiver for publishing
            let mut outbound_message_sender = self.outbound_message_sender.clone();
            if let Err(error) =
                outbound_message_sender.try_send((*peer_network_id, message.clone()))
            {
                // The message send failed
                warn!(LogSchema::new(LogEntry::ConsensusPublisher)
                        .event(LogEvent::SendDirectSendMessage)
                        .message(&format!(
                            "Failed to send outbound message to the receiver for peer {:?}! Error: {:?}",
                            peer_network_id, error
                    )));
            }
        }
    }
```

**File:** consensus/src/consensus_observer/network/observer_client.rs (L42-87)
```rust
    pub fn send_serialized_message_to_peer(
        &self,
        peer_network_id: &PeerNetworkId,
        message: Bytes,
        message_label: &str,
    ) -> Result<(), Error> {
        // Increment the message counter
        metrics::increment_counter(
            &metrics::PUBLISHER_SENT_MESSAGES,
            message_label,
            peer_network_id,
        );

        // Log the message being sent
        debug!(LogSchema::new(LogEntry::SendDirectSendMessage)
            .event(LogEvent::SendDirectSendMessage)
            .message_type(message_label)
            .peer(peer_network_id));

        // Send the message
        let result = self
            .network_client
            .send_to_peer_raw(message, *peer_network_id)
            .map_err(|error| Error::NetworkError(error.to_string()));

        // Process any error results
        if let Err(error) = result {
            // Log the failed send
            warn!(LogSchema::new(LogEntry::SendDirectSendMessage)
                .event(LogEvent::NetworkError)
                .message_type(message_label)
                .peer(peer_network_id)
                .message(&format!("Failed to send message: {:?}", error)));

            // Update the direct send error metrics
            metrics::increment_counter(
                &metrics::PUBLISHER_SENT_MESSAGE_ERRORS,
                error.get_label(),
                peer_network_id,
            );

            Err(Error::NetworkError(error.to_string()))
        } else {
            Ok(())
        }
    }
```

**File:** aptos-node/src/network.rs (L336-358)
```rust
        // Register consensus observer (both client and server) with the network
        if node_config
            .consensus_observer
            .is_observer_or_publisher_enabled()
        {
            // Create the network handle for this network type
            let network_handle = register_client_and_service_with_network(
                &mut network_builder,
                network_id,
                &network_config,
                consensus_observer_network_configuration(node_config),
                false,
            );

            // Add the network handle to the set of handles
            if let Some(consensus_observer_network_handles) =
                &mut consensus_observer_network_handles
            {
                consensus_observer_network_handles.push(network_handle);
            } else {
                consensus_observer_network_handles = Some(vec![network_handle]);
            }
        }
```

**File:** config/src/config/consensus_observer_config.rs (L11-14)
```rust
// Useful constants for enabling consensus observer on different node types
const ENABLE_ON_VALIDATORS: bool = true;
const ENABLE_ON_VALIDATOR_FULLNODES: bool = true;
const ENABLE_ON_PUBLIC_FULLNODES: bool = false;
```

**File:** config/src/config/consensus_observer_config.rs (L41-42)
```rust
    /// The maximum number of concurrent subscriptions
    pub max_concurrent_subscriptions: u64,
```
