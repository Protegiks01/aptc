# Audit Report

## Title
Configuration Sanitizer Bypass Allows Mainnet Validators to Disable Critical VM Safety Checks

## Summary
Mainnet validators can bypass the config sanitizer by setting `skip_config_sanitizer: true` in their YAML configuration, allowing them to disable `paranoid_type_verification` and other critical Move VM safety checks that are explicitly required for mainnet operation. This creates a risk of consensus divergence if validators run with different VM safety configurations.

## Finding Description

The Aptos configuration system implements a sanitizer that enforces critical safety requirements for mainnet nodes. Specifically, the `ExecutionConfig::sanitize()` method validates that mainnet validators must have `paranoid_type_verification` and `paranoid_hot_potato_verification` enabled: [1](#0-0) 

However, the `NodeConfig::sanitize()` method contains an early return that bypasses ALL validation checks if `skip_config_sanitizer` is set to `true`: [2](#0-1) 

The `skip_config_sanitizer` field is a legitimate configuration option that can be set via YAML: [3](#0-2) 

This bypass is explicitly demonstrated in a test case: [4](#0-3) 

The `paranoid_type_verification` flag is actively used to configure VM behavior. When disabled, the VM runtime uses `NoRuntimeTypeCheck` instead of `FullRuntimeTypeCheck`: [5](#0-4) [6](#0-5) 

When paranoid type checks are disabled, `NoRuntimeTypeCheck` performs zero runtime type safety validation: [7](#0-6) 

**Attack Scenario:**
1. A validator operator creates a node configuration YAML with:
```yaml
node_startup:
  skip_config_sanitizer: true
execution:
  paranoid_type_verification: false
```
2. They start their mainnet validator node
3. The sanitizer check is bypassed, and the node starts successfully with disabled paranoid checks
4. Their node executes Move bytecode without runtime type safety checks
5. If any type safety edge cases exist in transactions, their node may compute different results than validators with checks enabled
6. This causes state divergence and potential consensus failure

## Impact Explanation

This qualifies as **Critical Severity** under Aptos bug bounty criteria for the following reasons:

**Consensus/Safety Violation:** The vulnerability directly enables breaking the "Deterministic Execution" invariant - validators MUST produce identical state roots for identical blocks. When validators run with different VM configurations (some with paranoid checks, some without), they may execute the same transactions differently if any type safety violations exist in the bytecode. This leads to state divergence and consensus splits.

**Non-Recoverable Network Partition:** If a subset of validators disable paranoid checks and diverge from the main chain, it could require manual intervention or a hardfork to resolve, especially if these validators represent significant voting power.

The paranoid type checks perform critical safety validations including:
- Type assignability checks
- Ability checks (copy, drop, store, key)
- Cross-module call visibility validation
- Hot potato handling verification

Disabling these checks removes a critical layer of runtime safety enforcement that protects against type safety bugs in Move bytecode execution.

## Likelihood Explanation

**Likelihood: Medium to High**

While this requires a validator operator to intentionally misconfigure their node, the likelihood is concerning because:

1. **Ease of Exploitation:** Requires only editing a YAML configuration file - no code changes or sophisticated attacks needed
2. **Unintentional Misconfiguration:** Operators copying test configurations or following outdated documentation might accidentally set this flag
3. **No Runtime Detection:** The bypass is silent - there's no warning or logging that sanitization was skipped
4. **Performance Motivation:** Operators seeking performance improvements might intentionally disable checks believing they're "unnecessary overhead"
5. **Configuration Drift:** In large validator sets, configuration inconsistencies are common

The existence of the test case demonstrating this exact bypass suggests it's a known pattern that could be inadvertently used in production.

## Recommendation

**Immediate Fix:** Remove the ability to skip config sanitization for production mainnet nodes. The sanitizer should ONLY be skippable in test/development environments.

**Recommended Code Changes:**

In `config/src/config/config_sanitizer.rs`, modify the sanitize method to respect `skip_config_sanitizer` only for non-mainnet chains:

```rust
impl ConfigSanitizer for NodeConfig {
    fn sanitize(
        node_config: &NodeConfig,
        node_type: NodeType,
        chain_id: Option<ChainId>,
    ) -> Result<(), Error> {
        // Only allow skipping sanitization for non-mainnet chains
        if node_config.node_startup.skip_config_sanitizer {
            if let Some(chain_id) = chain_id {
                if chain_id.is_mainnet() {
                    return Err(Error::ConfigSanitizerFailed(
                        "NodeConfig".to_string(),
                        "Cannot skip config sanitization on mainnet!".to_string(),
                    ));
                }
            }
            return Ok(());
        }

        // Sanitize all of the sub-configs...
        // (rest of the function remains unchanged)
    }
}
```

**Additional Hardening:**
1. Add logging when `skip_config_sanitizer` is set to ensure visibility
2. Consider removing the flag entirely and using compile-time features for test configurations
3. Add monitoring/alerting if validators report different VM configurations via telemetry

**Note on `paranoid_hot_potato_verification`:** During investigation, I discovered this flag is checked by the sanitizer but never actually used in VM configuration. This is a separate issue - the flag should either be removed or properly wired to VM behavior.

## Proof of Concept

**Setup:**
1. Obtain mainnet genesis and chain ID configuration
2. Create a validator node configuration

**Configuration File (`validator.yaml`):**
```yaml
base:
  role: validator
  data_dir: "/opt/aptos/data"
  waypoint:
    from_config: "0:6072b68a942aace147e0655c5704beaa255c84a7829baa4e72a500f1516584c4"

node_startup:
  skip_config_sanitizer: true

execution:
  paranoid_type_verification: false
  paranoid_hot_potato_verification: false
  genesis_file_location: "genesis.blob"

# ... (rest of validator config)
```

**Test Steps:**
```rust
use aptos_config::config::{NodeConfig, NodeType};
use aptos_types::chain_id::ChainId;

#[test]
fn test_mainnet_sanitizer_bypass() {
    // Load the malicious config
    let mut node_config = NodeConfig::load_from_path("validator.yaml").unwrap();
    
    // Verify paranoid checks are disabled
    assert!(!node_config.execution.paranoid_type_verification);
    assert!(!node_config.execution.paranoid_hot_potato_verification);
    
    // Verify sanitizer is skipped
    assert!(node_config.node_startup.skip_config_sanitizer);
    
    // This should fail but succeeds due to bypass
    let result = NodeConfig::sanitize(
        &node_config,
        NodeType::Validator,
        Some(ChainId::mainnet())
    );
    
    // BUG: This passes when it should fail!
    assert!(result.is_ok());
}
```

**Expected vs Actual Behavior:**
- **Expected:** Node fails to start with error "paranoid_type_verification must be enabled for mainnet nodes!"
- **Actual:** Node starts successfully with disabled safety checks

This can be verified by running the existing test `test_disable_config_sanitizer` in the config_sanitizer module, which explicitly demonstrates this bypass working on mainnet configuration.

## Notes

1. The `paranoid_hot_potato_verification` flag mentioned in the security question is validated but never actually used in VM configuration - only `paranoid_type_verification` is wired through to the VM runtime.

2. While validator operators are typically trusted, the sanitizer's existence proves the system intends to enforce these safety requirements. The bypass defeats this protection mechanism.

3. The impact depends on whether type safety bugs exist in bytecode being executed. With checks enabled, such bugs would be caught; without checks, they could cause divergent execution.

### Citations

**File:** config/src/config/execution_config.rs (L166-183)
```rust
        // If this is a mainnet node, ensure that additional verifiers are enabled
        if let Some(chain_id) = chain_id {
            if chain_id.is_mainnet() {
                if !execution_config.paranoid_hot_potato_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_hot_potato_verification must be enabled for mainnet nodes!"
                            .into(),
                    ));
                }
                if !execution_config.paranoid_type_verification {
                    return Err(Error::ConfigSanitizerFailed(
                        sanitizer_name,
                        "paranoid_type_verification must be enabled for mainnet nodes!".into(),
                    ));
                }
            }
        }
```

**File:** config/src/config/config_sanitizer.rs (L45-48)
```rust
        // If config sanitization is disabled, don't do anything!
        if node_config.node_startup.skip_config_sanitizer {
            return Ok(());
        }
```

**File:** config/src/config/config_sanitizer.rs (L212-239)
```rust
    fn test_disable_config_sanitizer() {
        // Create a default node config (with sanitization enabled)
        let mut node_config = NodeConfig::default();

        // Set a bad node config for mainnet
        node_config.execution.paranoid_hot_potato_verification = false;

        // Sanitize the config and verify the sanitizer fails
        let error =
            NodeConfig::sanitize(&node_config, NodeType::Validator, Some(ChainId::mainnet()))
                .unwrap_err();
        assert!(matches!(error, Error::ConfigSanitizerFailed(_, _)));

        // Create a node config with the sanitizer disabled
        let mut node_config = NodeConfig {
            node_startup: NodeStartupConfig {
                skip_config_sanitizer: true,
                ..Default::default()
            },
            ..Default::default()
        };

        // Set a bad node config for mainnet
        node_config.execution.paranoid_hot_potato_verification = false;

        // Sanitize the config and verify the sanitizer passes
        NodeConfig::sanitize(&node_config, NodeType::Validator, Some(ChainId::mainnet())).unwrap();
    }
```

**File:** config/src/config/node_startup_config.rs (L8-11)
```rust
pub struct NodeStartupConfig {
    pub skip_config_optimizer: bool, // Whether or not to skip the config optimizer at startup
    pub skip_config_sanitizer: bool, // Whether or not to skip the config sanitizer at startup
}
```

**File:** aptos-node/src/utils.rs (L53-56)
```rust
pub fn set_aptos_vm_configurations(node_config: &NodeConfig) {
    set_layout_caches(node_config.execution.layout_caches_enabled);
    set_paranoid_type_checks(node_config.execution.paranoid_type_verification);
    set_async_runtime_checks(node_config.execution.async_runtime_checks);
```

**File:** third_party/move/move-vm/runtime/src/interpreter.rs (L244-278)
```rust
        let paranoid_type_checks =
            !trace_recorder.is_enabled() && interpreter.vm_config.paranoid_type_checks;
        let optimize_trusted_code =
            !trace_recorder.is_enabled() && interpreter.vm_config.optimize_trusted_code;
        let paranoid_ref_checks = interpreter.vm_config.paranoid_ref_checks;

        let function = Rc::new(function);
        macro_rules! execute_main {
            ($type_check:ty, $ref_check:ty) => {
                interpreter.execute_main::<$type_check, $ref_check>(
                    data_cache,
                    function_caches,
                    gas_meter,
                    traversal_context,
                    extensions,
                    trace_recorder,
                    function,
                    args,
                )
            };
        }

        // Note: we have organized the code below from most-likely config to least-likely config.
        match (
            paranoid_type_checks,
            optimize_trusted_code,
            paranoid_ref_checks,
        ) {
            (true, true, false) => execute_main!(UntrustedOnlyRuntimeTypeCheck, NoRuntimeRefCheck),
            (true, false, false) => execute_main!(FullRuntimeTypeCheck, NoRuntimeRefCheck),
            (true, true, true) => execute_main!(UntrustedOnlyRuntimeTypeCheck, FullRuntimeRefCheck),
            (true, false, true) => execute_main!(FullRuntimeTypeCheck, FullRuntimeRefCheck),
            (false, _, false) => execute_main!(NoRuntimeTypeCheck, NoRuntimeRefCheck),
            (false, _, true) => execute_main!(NoRuntimeTypeCheck, FullRuntimeRefCheck),
        }
```

**File:** third_party/move/move-vm/runtime/src/runtime_type_checks.rs (L220-253)
```rust
impl RuntimeTypeCheck for NoRuntimeTypeCheck {
    #[cfg_attr(feature = "force-inline", inline(always))]
    fn pre_execution_type_stack_transition(
        _frame: &Frame,
        _operand_stack: &mut Stack,
        _instruction: &Instruction,
        _ty_cache: &mut FrameTypeCache,
    ) -> PartialVMResult<()> {
        Ok(())
    }

    #[cfg_attr(feature = "force-inline", inline(always))]
    fn post_execution_type_stack_transition(
        _frame: &Frame,
        _operand_stack: &mut Stack,
        _instruction: &Instruction,
        _ty_cache: &mut FrameTypeCache,
    ) -> PartialVMResult<()> {
        Ok(())
    }

    #[cfg_attr(feature = "force-inline", inline(always))]
    fn should_perform_checks(_for_fun: &Function) -> bool {
        false
    }

    #[cfg_attr(feature = "force-inline", inline(always))]
    fn check_cross_module_regular_call_visibility(
        _caller: &LoadedFunction,
        _callee: &LoadedFunction,
    ) -> PartialVMResult<()> {
        Ok(())
    }
}
```
