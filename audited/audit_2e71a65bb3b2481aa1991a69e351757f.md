# Audit Report

## Title
Optimistic Proposals Bypass Validator Performance Penalties Leading to Staking System Manipulation

## Summary
When optimistic proposals are executed in Aptos consensus, the `failed_proposer_indices` field is always set to an empty vector, completely bypassing the validator performance penalty mechanism. This allows validators who fail to propose blocks to avoid accountability, breaking the staking security invariant and enabling malicious validators to receive higher rewards than deserved.

## Finding Description

The Aptos consensus system tracks validator performance by recording failed proposals through the `failed_proposer_indices` mechanism. When blocks are executed, this data is passed to `stake::update_performance_statistics()` to increment the `failed_proposals` counter for validators who didn't propose when they should have. [1](#0-0) 

However, optimistic proposals bypass this accountability mechanism through three critical flaws:

**Flaw 1: Optimistic proposals have no `failed_authors` field** [2](#0-1) 

When `failed_authors()` is called on an `OptimisticProposal` block type, it returns `None` instead of the list of failed validators.

**Flaw 2: Validation is explicitly skipped for optimistic proposals** [3](#0-2) 

The validation that ensures `failed_authors` matches the expected list based on proposer election is completely bypassed when `is_opt_block()` returns true.

**Flaw 3: Empty vector used during execution** [4](#0-3) 

When creating the block metadata for execution, `failed_authors()` returning `None` causes `map_or(vec![], ...)` to use an empty vector for `failed_proposer_indices`.

**Flaw 4: Optimistic proposals are enabled by default** [5](#0-4) 

The `enable_optimistic_proposal_tx: true` default configuration means this vulnerability affects the network in normal operation.

**Impact on Staking System** [6](#0-5) 

When `update_performance_statistics()` receives an empty `failed_proposer_indices` vector, the loop at lines 1321-1331 never executes, meaning no validators have their `failed_proposals` counter incremented. [7](#0-6) 

The `calculate_rewards_amount()` function uses the ratio `num_successful_proposals / num_total_proposals` where `num_total_proposals = successful_proposals + failed_proposals`. When failed proposals are not counted, this ratio is artificially inflated, leading to higher rewards for failing validators.

## Impact Explanation

This vulnerability has **HIGH** severity impact as it breaks the **Staking Security** invariant: "Validator rewards and penalties must be calculated correctly."

**Concrete Impact:**
1. **Incorrect Reward Distribution**: Validators who fail to propose blocks during optimistic proposal rounds receive higher rewards than they deserve because their failure rate is understated
2. **Broken Accountability**: The consensus performance tracking system is fundamentally compromised, reporting inaccurate validator statistics
3. **Economic Manipulation**: Malicious validators can benefit from unreliable behavior without facing appropriate penalties
4. **Governance Impact**: Validator selection and removal decisions based on performance metrics are compromised by inaccurate data

**Severity Classification:**
Per Aptos bug bounty criteria, this qualifies as **HIGH severity** ($50,000 range) because it represents a "Significant protocol violation" affecting the core staking and validator accountability mechanisms. While it doesn't directly enable fund theft, it corrupts the economic incentive structure that secures the network.

## Likelihood Explanation

**Likelihood: HIGH** - This vulnerability occurs automatically in normal network operation:

1. Optimistic proposals are **enabled by default** in the consensus configuration
2. They are sent automatically when validators vote on blocks and are the next round's leader
3. The vulnerability triggers **every time an optimistic proposal is executed**
4. No special attacker actions or privileges are required beyond being an active validator [8](#0-7) 

The conditions for sending optimistic proposals are met regularly during normal operation, meaning the performance penalty bypass occurs frequently across the network.

## Recommendation

**Immediate Fix**: Optimistic proposals must track and validate `failed_authors` just like regular proposals.

**Recommended Code Changes:**

1. **Add `failed_authors` to OptBlockBody structure** in `consensus/consensus-types/src/proposal_ext.rs`

2. **Include failed_authors in OptBlockData creation** in `consensus/src/liveness/proposal_generator.rs`:
   ```rust
   let failed_authors = self.compute_failed_authors(
       round, 
       parent.round(), 
       false,
       proposer_election.clone()
   );
   ```

3. **Update BlockData::failed_authors()** in `consensus/consensus-types/src/block_data.rs`:
   ```rust
   pub fn failed_authors(&self) -> Option<&Vec<(Round, Author)>> {
       match &self.block_type {
           BlockType::Proposal { failed_authors, .. }
           | BlockType::NilBlock { failed_authors, .. }
           | BlockType::DAGBlock { failed_authors, .. } => Some(failed_authors),
           BlockType::ProposalExt(p) => Some(p.failed_authors()),
           BlockType::OptimisticProposal(p) => Some(p.failed_authors()), // Add this
           BlockType::Genesis => None,
       }
   }
   ```

4. **Remove the validation bypass** in `consensus/src/round_manager.rs` or extend it to validate optimistic proposals after they're filled with the parent QC.

## Proof of Concept

**Scenario**: A malicious validator fails to propose in round N, but an optimistic proposal is used for round N+1.

**Reproduction Steps:**

1. **Setup**: Enable optimistic proposals (default configuration)
2. **Network state**: Validator V1 is scheduled to propose in round N but fails (timeout/offline)
3. **Next round**: Validator V2 proposes block B for round N+1 as a regular proposal
4. **Optimistic proposal**: Validator V3 (leader of round N+2) votes on B and sends optimistic proposal O for round N+2
5. **Execution**: When O is executed:
   - `block.new_metadata_with_randomness()` is called
   - `failed_authors()` returns `None` for the OptimisticProposal
   - `failed_proposer_indices` becomes empty vector `vec![]`
   - V1's failure in round N is **not recorded**
6. **Result**: V1's `failed_proposals` counter is not incremented, affecting reward calculations at epoch end

**Expected Behavior**: V1 should have their `failed_proposals` counter incremented regardless of whether the next block is a regular proposal or optimistic proposal.

**Actual Behavior**: V1's failure is only recorded if the next block is a regular proposal, not an optimistic proposal.

**Verification**: Compare `ValidatorPerformance` statistics after an epoch with mixed regular and optimistic proposals versus one with only regular proposals - the failed_proposals counts will be systematically lower in the first case despite identical validator behavior.

### Citations

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L2469-2523)
```rust
    fn process_block_prologue_ext(
        &self,
        resolver: &impl AptosMoveResolver,
        module_storage: &impl AptosModuleStorage,
        block_metadata_ext: BlockMetadataExt,
        log_context: &AdapterLogSchema,
    ) -> Result<(VMStatus, VMOutput), VMStatus> {
        fail_point!("move_adapter::process_block_prologue_ext", |_| {
            Err(VMStatus::error(
                StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR,
                None,
            ))
        });

        let mut gas_meter = UnmeteredGasMeter;
        let mut session = self.new_session(
            resolver,
            SessionId::block_meta_ext(&block_metadata_ext),
            None,
        );

        let block_metadata_with_randomness = match block_metadata_ext {
            BlockMetadataExt::V0(_) => unreachable!(),
            BlockMetadataExt::V1(v1) => v1,
        };

        let BlockMetadataWithRandomness {
            id,
            epoch,
            round,
            proposer,
            previous_block_votes_bitvec,
            failed_proposer_indices,
            timestamp_usecs,
            randomness,
        } = block_metadata_with_randomness;

        let args = vec![
            MoveValue::Signer(AccountAddress::ZERO), // Run as 0x0
            MoveValue::Address(AccountAddress::from_bytes(id.to_vec()).unwrap()),
            MoveValue::U64(epoch),
            MoveValue::U64(round),
            MoveValue::Address(proposer),
            failed_proposer_indices
                .into_iter()
                .map(|i| i as u64)
                .collect::<Vec<_>>()
                .as_move_value(),
            previous_block_votes_bitvec.as_move_value(),
            MoveValue::U64(timestamp_usecs),
            randomness
                .as_ref()
                .map(Randomness::randomness_cloned)
                .as_move_value(),
        ];
```

**File:** consensus/consensus-types/src/block_data.rs (L225-233)
```rust
    pub fn failed_authors(&self) -> Option<&Vec<(Round, Author)>> {
        match &self.block_type {
            BlockType::Proposal { failed_authors, .. }
            | BlockType::NilBlock { failed_authors, .. }
            | BlockType::DAGBlock { failed_authors, .. } => Some(failed_authors),
            BlockType::ProposalExt(p) => Some(p.failed_authors()),
            BlockType::OptimisticProposal(_) | BlockType::Genesis => None,
        }
    }
```

**File:** consensus/src/round_manager.rs (L1216-1231)
```rust
        if !proposal.is_opt_block() {
            // Validate that failed_authors list is correctly specified in the block.
            let expected_failed_authors = self.proposal_generator.compute_failed_authors(
                proposal.round(),
                proposal.quorum_cert().certified_block().round(),
                false,
                self.proposer_election.clone(),
            );
            ensure!(
                proposal.block_data().failed_authors().is_some_and(|failed_authors| *failed_authors == expected_failed_authors),
                "[RoundManager] Proposal for block {} has invalid failed_authors list {:?}, expected {:?}",
                proposal.round(),
                proposal.block_data().failed_authors(),
                expected_failed_authors,
            );
        }
```

**File:** consensus/src/round_manager.rs (L1427-1463)
```rust
    fn start_next_opt_round(
        &self,
        parent_vote: Vote,
        grandparent_qc: QuorumCert,
    ) -> anyhow::Result<()> {
        // Optimistic Proposal:
        // When receiving round r block, send optimistic proposal for round r+1 if:
        // 0. opt proposal is enabled
        // 1. it is the leader of the next round r+1
        // 2. voted for round r block
        // 3. the round r block contains QC of round r-1
        // 4. does not propose in round r+1
        if !self.local_config.enable_optimistic_proposal_tx {
            return Ok(());
        };

        ensure!(
            !self.proposal_generator.is_proposal_under_backpressure(),
            "Cannot start next opt round due to backpressure"
        );

        let parent = parent_vote.vote_data().proposed().clone();
        let opt_proposal_round = parent.round() + 1;
        if self
            .proposer_election
            .is_valid_proposer(self.proposal_generator.author(), opt_proposal_round)
        {
            let expected_grandparent_round = parent
                .round()
                .checked_sub(1)
                .ok_or_else(|| anyhow::anyhow!("Invalid parent round {}", parent.round()))?;
            ensure!(
                grandparent_qc.certified_block().round() == expected_grandparent_round,
                "Cannot start Optimistic Round. Grandparent QC is not for round minus one: {} < {}",
                grandparent_qc.certified_block().round(),
                parent.round()
            );
```

**File:** consensus/consensus-types/src/block.rs (L597-617)
```rust
    pub fn new_metadata_with_randomness(
        &self,
        validators: &[AccountAddress],
        randomness: Option<Randomness>,
    ) -> BlockMetadataExt {
        BlockMetadataExt::new_v1(
            self.id(),
            self.epoch(),
            self.round(),
            self.author().unwrap_or(AccountAddress::ZERO),
            self.previous_bitvec().into(),
            // For nil block, we use 0x0 which is convention for nil address in move.
            self.block_data()
                .failed_authors()
                .map_or(vec![], |failed_authors| {
                    Self::failed_authors_to_indices(validators, failed_authors)
                }),
            self.timestamp_usecs(),
            randomness,
        )
    }
```

**File:** config/src/config/consensus_config.rs (L384-385)
```rust
            enable_optimistic_proposal_rx: true,
            enable_optimistic_proposal_tx: true,
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1282-1332)
```text
    public(friend) fun update_performance_statistics(
        proposer_index: Option<u64>,
        failed_proposer_indices: vector<u64>
    ) acquires ValidatorPerformance {
        // Validator set cannot change until the end of the epoch, so the validator index in arguments should
        // match with those of the validators in ValidatorPerformance resource.
        let validator_perf = borrow_global_mut<ValidatorPerformance>(@aptos_framework);
        let validator_len = vector::length(&validator_perf.validators);

        spec {
            update ghost_valid_perf = validator_perf;
            update ghost_proposer_idx = proposer_index;
        };
        // proposer_index is an option because it can be missing (for NilBlocks)
        if (option::is_some(&proposer_index)) {
            let cur_proposer_index = option::extract(&mut proposer_index);
            // Here, and in all other vector::borrow, skip any validator indices that are out of bounds,
            // this ensures that this function doesn't abort if there are out of bounds errors.
            if (cur_proposer_index < validator_len) {
                let validator = vector::borrow_mut(&mut validator_perf.validators, cur_proposer_index);
                spec {
                    assume validator.successful_proposals + 1 <= MAX_U64;
                };
                validator.successful_proposals = validator.successful_proposals + 1;
            };
        };

        let f = 0;
        let f_len = vector::length(&failed_proposer_indices);
        while ({
            spec {
                invariant len(validator_perf.validators) == validator_len;
                invariant (option::is_some(ghost_proposer_idx) && option::borrow(
                    ghost_proposer_idx
                ) < validator_len) ==>
                    (validator_perf.validators[option::borrow(ghost_proposer_idx)].successful_proposals ==
                        ghost_valid_perf.validators[option::borrow(ghost_proposer_idx)].successful_proposals + 1);
            };
            f < f_len
        }) {
            let validator_index = *vector::borrow(&failed_proposer_indices, f);
            if (validator_index < validator_len) {
                let validator = vector::borrow_mut(&mut validator_perf.validators, validator_index);
                spec {
                    assume validator.failed_proposals + 1 <= MAX_U64;
                };
                validator.failed_proposals = validator.failed_proposals + 1;
            };
            f = f + 1;
        };
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1761-1784)
```text
    fun calculate_rewards_amount(
        stake_amount: u64,
        num_successful_proposals: u64,
        num_total_proposals: u64,
        rewards_rate: u64,
        rewards_rate_denominator: u64,
    ): u64 {
        spec {
            // The following condition must hold because
            // (1) num_successful_proposals <= num_total_proposals, and
            // (2) `num_total_proposals` cannot be larger than 86400, the maximum number of proposals
            //     in a day (1 proposal per second), and `num_total_proposals` is reset to 0 every epoch.
            assume num_successful_proposals * MAX_REWARDS_RATE <= MAX_U64;
        };
        // The rewards amount is equal to (stake amount * rewards rate * performance multiplier).
        // We do multiplication in u128 before division to avoid the overflow and minimize the rounding error.
        let rewards_numerator = (stake_amount as u128) * (rewards_rate as u128) * (num_successful_proposals as u128);
        let rewards_denominator = (rewards_rate_denominator as u128) * (num_total_proposals as u128);
        if (rewards_denominator > 0) {
            ((rewards_numerator / rewards_denominator) as u64)
        } else {
            0
        }
    }
```
