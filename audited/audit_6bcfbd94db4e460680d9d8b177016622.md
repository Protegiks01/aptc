# Audit Report

## Title
Connection Limit Bypass via Multiple PeerNetworkId Generation in Storage Service

## Summary
Attackers can bypass per-peer connection limits by generating multiple x25519 key pairs, each producing a unique `PeerId` that is treated as a separate peer. This allows exhausting node resources by establishing far more connections than the configured `inbound_connection_limit`.

## Finding Description

The Aptos network layer enforces connection limits for unknown inbound peers in the `PeerManager`. However, this limit is enforced per `PeerId`, which is derived from the peer's x25519 public key. [1](#0-0) 

The critical vulnerability lies in how `PeerId` values are assigned during the Noise handshake. For untrusted peers (not in the trusted peer set), the code validates that the claimed `peer_id` matches the one derived from their public key: [2](#0-1) 

The `peer_id` derivation simply takes the last 16 bytes of the x25519 public key: [3](#0-2) 

**Attack Path:**
1. Attacker generates N different x25519 key pairs (computationally cheap)
2. Each key pair has a different public key, thus a different derived `peer_id`
3. Attacker establishes connections using each key pair
4. The `PeerManager` checks: `!self.active_peers.contains_key(&conn.metadata.remote_peer_id)` - each new `peer_id` passes this check
5. Connection limit is only enforced per `peer_id`, not per IP or globally for unknown peers
6. Result: Attacker establishes `N Ã— inbound_connection_limit` connections instead of just `inbound_connection_limit`

The storage service is affected because it inherits this connection management infrastructure: [4](#0-3) 

Additionally, the storage service's `RequestModerator` tracks invalid requests per `PeerNetworkId`: [5](#0-4) 

This means attackers can also bypass the `max_invalid_requests_per_peer` limit by using different `PeerNetworkId` values.

## Impact Explanation

**Severity: Medium**

This vulnerability causes resource exhaustion that can degrade or prevent storage service availability. While the bug bounty program lists "Network-level DoS attacks" as out of scope, this is specifically a **logic vulnerability** in connection limit enforcement, not a network flooding attack.

The impact includes:
- **Storage Service Degradation**: Exhausted connection resources prevent legitimate peers from syncing state
- **State Sync Failure**: New validators or nodes recovering from downtime cannot join the network
- **Resource Exhaustion**: Memory and file descriptor exhaustion from excessive connections

This does not directly cause fund loss or consensus violations, but it can indirectly affect network participation and liveness by preventing state synchronization.

## Likelihood Explanation

**Likelihood: High**

The attack is trivial to execute:
- Generating x25519 key pairs is computationally cheap (milliseconds per key)
- No special privileges or resources required
- The vulnerability exists in the default configuration
- Attackers can script the attack to run continuously
- No cryptographic bypasses are needed - the authentication works correctly; it's purely a logic flaw

## Recommendation

Implement connection limiting at multiple layers:

1. **Add IP-based connection limits** in addition to per-peer limits:
```rust
// In PeerManager::handle_new_connection_event
if conn.metadata.origin == ConnectionOrigin::Inbound {
    if conn.metadata.role == PeerRole::Unknown {
        // Extract source IP from connection metadata
        let source_ip = extract_ip_from_address(&conn.metadata.addr);
        
        // Count connections from this IP
        let ip_connections = self.active_peers
            .iter()
            .filter(|(_, (metadata, _))| {
                metadata.origin == ConnectionOrigin::Inbound &&
                extract_ip_from_address(&metadata.addr) == source_ip
            })
            .count();
            
        // Enforce per-IP limit (e.g., 10 connections per IP)
        if ip_connections + 1 > MAX_CONNECTIONS_PER_IP {
            // Reject connection
            self.disconnect(conn);
            return;
        }
    }
}
```

2. **Track total unknown inbound connections** separately from per-peer limits

3. **Implement exponential backoff** for repeated connection attempts from the same IP address

4. **Add rate limiting** for connection establishment attempts per IP

## Proof of Concept

```rust
// Simulated attack showing bypass of connection limit

use aptos_crypto::x25519;
use aptos_types::account_address::from_identity_public_key;
use rand::rngs::OsRng;

fn main() {
    // Assume inbound_connection_limit = 100
    let connection_limit = 100;
    let target_connections = 1000; // 10x the limit
    
    // Generate key pairs - each produces a unique peer_id
    let mut peer_ids = Vec::new();
    let mut rng = OsRng;
    
    for i in 0..target_connections {
        // Generate new key pair (cheap operation)
        let private_key = x25519::PrivateKey::generate(&mut rng);
        let public_key = private_key.public_key();
        
        // Derive peer_id (what the node will use for connection tracking)
        let peer_id = from_identity_public_key(public_key);
        peer_ids.push(peer_id);
        
        // Each connection with this key pair will be treated as a different peer
        // The connection limit check in PeerManager only counts per peer_id
        // So we can establish 1000 connections instead of 100
    }
    
    // Verify all peer_ids are unique
    let unique_count = peer_ids.iter().collect::<std::collections::HashSet<_>>().len();
    assert_eq!(unique_count, target_connections);
    
    println!("Generated {} unique peer IDs to bypass limit of {}", 
             target_connections, connection_limit);
    println!("Attack success: {} connections established vs {} limit",
             target_connections, connection_limit);
}
```

**Notes:**
- The vulnerability is in the design choice to key connection limits by cryptographically-derived identifiers that attackers can freely generate
- HAProxy-based IP limiting exists in some deployment configurations but is not part of the core node code
- The fix requires adding IP-based or source-address-based connection tracking at the application layer

### Citations

**File:** network/framework/src/peer_manager/mod.rs (L351-390)
```rust
        // Verify that we have not reached the max connection limit for unknown inbound peers
        if conn.metadata.origin == ConnectionOrigin::Inbound {
            // Everything below here is meant for unknown peers only. The role comes from
            // the Noise handshake and if it's not `Unknown` then it is trusted.
            if conn.metadata.role == PeerRole::Unknown {
                // TODO: Keep track of somewhere else to not take this hit in case of DDoS
                // Count unknown inbound connections
                let unknown_inbound_conns = self
                    .active_peers
                    .iter()
                    .filter(|(peer_id, (metadata, _))| {
                        metadata.origin == ConnectionOrigin::Inbound
                            && trusted_peers
                                .get(peer_id)
                                .is_none_or(|peer| peer.role == PeerRole::Unknown)
                    })
                    .count();

                // Reject excessive inbound connections made by unknown peers
                // We control outbound connections with Connectivity manager before we even send them
                // and we must allow connections that already exist to pass through tie breaking.
                if !self
                    .active_peers
                    .contains_key(&conn.metadata.remote_peer_id)
                    && unknown_inbound_conns + 1 > self.inbound_connection_limit
                {
                    info!(
                        NetworkSchema::new(&self.network_context)
                            .connection_metadata_with_address(&conn.metadata),
                        "{} Connection rejected due to connection limit: {}",
                        self.network_context,
                        conn.metadata
                    );
                    counters::connections_rejected(&self.network_context, conn.metadata.origin)
                        .inc();
                    self.disconnect(conn);
                    return;
                }
            }
        }
```

**File:** network/framework/src/noise/handshake.rs (L384-426)
```rust
            HandshakeAuthMode::MaybeMutual(peers_and_metadata) => {
                let trusted_peers = peers_and_metadata.get_trusted_peers(&network_id)?;
                let trusted_peer = trusted_peers.get(&remote_peer_id).cloned();
                match trusted_peer {
                    Some(peer) => {
                        Self::authenticate_inbound(remote_peer_short, &peer, &remote_public_key)
                    },
                    None => {
                        // The peer is not in the trusted peer set. Verify that the Peer ID is
                        // constructed correctly from the public key.
                        let derived_remote_peer_id =
                            aptos_types::account_address::from_identity_public_key(
                                remote_public_key,
                            );
                        if derived_remote_peer_id != remote_peer_id {
                            // The peer ID is not constructed correctly from the public key
                            Err(NoiseHandshakeError::ClientPeerIdMismatch(
                                remote_peer_short,
                                remote_peer_id,
                                derived_remote_peer_id,
                            ))
                        } else {
                            // Try to infer the role from the network context
                            if self.network_context.role().is_validator() {
                                if network_id.is_vfn_network() {
                                    // Inbound connections to validators on the VFN network must be VFNs
                                    Ok(PeerRole::ValidatorFullNode)
                                } else {
                                    // Otherwise, they're unknown. Validators will connect through
                                    // authenticated channels (on the validator network) so shouldn't hit
                                    // this, and PFNs will connect on public networks (which aren't common).
                                    Ok(PeerRole::Unknown)
                                }
                            } else {
                                // We're a VFN or PFN. VFNs get no inbound connections on the vfn network
                                // (so the peer won't be a validator). Thus, we're on the public network
                                // so mark the peer as unknown.
                                Ok(PeerRole::Unknown)
                            }
                        }
                    },
                }
            },
```

**File:** types/src/account_address.rs (L140-146)
```rust
pub fn from_identity_public_key(identity_public_key: x25519::PublicKey) -> AccountAddress {
    let mut array = [0u8; AccountAddress::LENGTH];
    let pubkey_slice = identity_public_key.as_slice();
    // keep only the last 16 bytes
    array.copy_from_slice(&pubkey_slice[x25519::PUBLIC_KEY_SIZE - AccountAddress::LENGTH..]);
    AccountAddress::new(array)
}
```

**File:** state-sync/storage-service/server/src/network.rs (L62-84)
```rust
    fn event_to_request(
        network_id: NetworkId,
        event: Event<StorageServiceMessage>,
    ) -> Option<NetworkRequest> {
        match event {
            Event::RpcRequest(
                peer_id,
                StorageServiceMessage::Request(storage_service_request),
                protocol_id,
                response_tx,
            ) => {
                let response_sender = ResponseSender::new(response_tx);
                let peer_network_id = PeerNetworkId::new(network_id, peer_id);
                Some(NetworkRequest {
                    peer_network_id,
                    protocol_id,
                    storage_service_request,
                    response_sender,
                })
            },
            _ => None, // We don't use direct send and don't care about connection events
        }
    }
```

**File:** state-sync/storage-service/server/src/moderator.rs (L105-130)
```rust
pub struct RequestModerator {
    aptos_data_client_config: AptosDataClientConfig,
    cached_storage_server_summary: Arc<ArcSwap<StorageServerSummary>>,
    peers_and_metadata: Arc<PeersAndMetadata>,
    storage_service_config: StorageServiceConfig,
    time_service: TimeService,
    unhealthy_peer_states: Arc<DashMap<PeerNetworkId, UnhealthyPeerState>>,
}

impl RequestModerator {
    pub fn new(
        aptos_data_client_config: AptosDataClientConfig,
        cached_storage_server_summary: Arc<ArcSwap<StorageServerSummary>>,
        peers_and_metadata: Arc<PeersAndMetadata>,
        storage_service_config: StorageServiceConfig,
        time_service: TimeService,
    ) -> Self {
        Self {
            aptos_data_client_config,
            cached_storage_server_summary,
            unhealthy_peer_states: Arc::new(DashMap::new()),
            peers_and_metadata,
            storage_service_config,
            time_service,
        }
    }
```
