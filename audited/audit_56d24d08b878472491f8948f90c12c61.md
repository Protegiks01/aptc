# Audit Report

## Title
SharedData Configuration Divergence via Timed Feature Override Causes Consensus Fork

## Summary
The `SharedData` struct used by native functions loads `timed_features` from a combination of on-chain state and a global static variable `TIMED_FEATURE_OVERRIDE`. Different validators can set different override values via node-local configuration, causing them to execute identical blocks with different native function behavior (particularly different gas metering), leading to different state roots and a consensus fork requiring a hardfork to resolve.

## Finding Description

The vulnerability exists in how `SharedData` is populated with `timed_features` configuration. The `SharedData` struct contains configuration shared by all native functions: [1](#0-0) 

When `AptosEnvironment` is created during block execution, it builds `TimedFeatures` using both on-chain state (chain_id, timestamp) and a node-local override: [2](#0-1) 

This override comes from a global static variable that can be set via node configuration: [3](#0-2) 

The override takes precedence over timestamp-based activation: [4](#0-3) 

Native functions use these timed features to control execution behavior. For example, table natives conditionally charge memory based on the `FixTableNativesMemoryDoubleCounting` flag: [5](#0-4) 

**Attack Scenario:**
1. Different validator operators set different `TIMED_FEATURE_OVERRIDE` values in their node configurations (e.g., some set `Replay`, others set `Testing`, others set nothing)
2. All validators execute the same block with the same transactions
3. Native functions (particularly table operations) charge different amounts of gas depending on the timed feature flags
4. Transactions near the gas limit succeed on some validators but fail on others
5. Validators produce different state roots for the identical block
6. Consensus permanently diverges, requiring a hardfork to resolve

The environment hash comparison does include the override, but this only flushes caches - it doesn't prevent validators from executing with different configurations and producing different results.

## Impact Explanation

This is **Critical Severity** under the Aptos Bug Bounty Program as it causes "Non-recoverable network partition (requires hardfork)". 

The vulnerability breaks the fundamental invariant: **"Deterministic Execution: All validators must produce identical state roots for identical blocks"**. Once validators execute blocks with different timed feature configurations:

- They produce different transaction outcomes (different success/failure results)
- They generate different state roots
- The network permanently forks into multiple chains
- No automatic recovery mechanism exists
- Requires coordinated hardfork and state rollback to resolve

This is more severe than a temporary liveness failure because the divergence is systematic and persists across all subsequent blocks.

## Likelihood Explanation

**Likelihood: Medium to High**

This vulnerability can occur through:

1. **Accidental misconfiguration**: Different validator operators independently configure their nodes for different purposes (testing, replay analysis) and forget to reset overrides before joining mainnet
2. **Upgrade coordination failures**: During network upgrades, operators may temporarily set different overrides for compatibility testing
3. **Multi-environment operators**: Validators running both testnet and mainnet nodes may accidentally apply testnet configurations to mainnet

The vulnerability doesn't require Byzantine behavior - it can happen through honest misconfiguration. The global static nature makes it easy to set once and forget, with no on-chain visibility or validation.

## Recommendation

**Immediate Fix: Remove the ability to override timed features via node configuration for consensus execution.**

The timed feature override mechanism should only be available in:
- Test environments with explicit compile-time flags
- Replay/debugging tools that don't participate in consensus

For production validators:

1. Remove the global static `TIMED_FEATURE_OVERRIDE` or make it only available under `#[cfg(test)]`
2. Ensure `get_timed_feature_override()` always returns `None` in production builds
3. Add runtime assertions during environment initialization to verify no override is set
4. Make `set_timed_feature_override()` a compile-time error in production builds

**Code Fix:**

```rust
// In aptos-move/aptos-vm-environment/src/prod_configs.rs

#[cfg(any(test, feature = "testing"))]
static TIMED_FEATURE_OVERRIDE: OnceCell<TimedFeatureOverride> = OnceCell::new();

#[cfg(any(test, feature = "testing"))]
pub fn set_timed_feature_override(profile: TimedFeatureOverride) {
    TIMED_FEATURE_OVERRIDE.set(profile).ok();
}

pub fn get_timed_feature_override() -> Option<TimedFeatureOverride> {
    #[cfg(any(test, feature = "testing"))]
    return TIMED_FEATURE_OVERRIDE.get().cloned();
    
    #[cfg(not(any(test, feature = "testing")))]
    return None;
}
```

Additionally, add a runtime check in `Environment::new`:

```rust
// In aptos-move/aptos-vm-environment/src/environment.rs
fn new(...) -> Self {
    // ... existing code ...
    
    #[cfg(not(any(test, feature = "testing")))]
    {
        assert!(
            get_timed_feature_override().is_none(),
            "Timed feature override must not be set in production"
        );
    }
    
    // ... rest of the function ...
}
```

## Proof of Concept

**Reproduction Steps:**

1. Set up two validator nodes with identical blockchain state
2. On Validator A, set no override (default behavior)
3. On Validator B, add this to the initialization code:
```rust
set_timed_feature_override(TimedFeatureOverride::Replay);
```

4. Have both validators execute a block containing a transaction that:
   - Uses table operations (e.g., `table::add` or `table::borrow`)
   - Is calibrated to use gas very close to the limit
   
5. Observe that:
   - Validator A's timed features follow timestamp-based activation
   - Validator B's timed features use the Replay override
   - The transaction succeeds on one validator but runs out of gas on the other
   - The validators produce different state roots
   - Consensus diverges permanently

**Concrete Test Case:**

```rust
// In a test environment, create two AptosEnvironments with different overrides
use aptos_types::chain_id::ChainId;
use aptos_vm_environment::prod_configs::set_timed_feature_override;
use aptos_vm_environment::environment::AptosEnvironment;

#[test]
fn test_timed_feature_divergence() {
    let state_view = create_test_state_view();
    
    // Validator A: No override
    let env_a = AptosEnvironment::new(&state_view);
    
    // Validator B: With override
    set_timed_feature_override(TimedFeatureOverride::Testing);
    let env_b = AptosEnvironment::new(&state_view);
    
    // Verify they have different timed features
    assert_ne!(env_a.timed_features(), env_b.timed_features());
    
    // Execute the same transaction on both
    let txn = create_table_operation_near_gas_limit();
    let result_a = execute_on_env(env_a, txn.clone());
    let result_b = execute_on_env(env_b, txn);
    
    // Different execution results -> different state roots
    assert_ne!(result_a.state_root(), result_b.state_root());
}
```

## Notes

While the environment hash comparison does include the override bytes, this only affects cache invalidation - it doesn't prevent the fundamental issue. Validators with different overrides will:
1. Have different environment hashes (cache flush)
2. Still execute with their respective overrides
3. Produce different results

The issue is particularly insidious because it's not immediately visible - validators continue participating in consensus, voting on blocks, but computing different state roots. The divergence may not be detected until validators compare state roots or experience fork-related issues.

### Citations

**File:** aptos-move/aptos-native-interface/src/builder.rs (L18-26)
```rust
/// Data shared by all native functions, mostly on-chain configurations.
#[derive(Debug)]
struct SharedData {
    gas_feature_version: u64,
    native_gas_params: NativeGasParameters,
    misc_gas_params: MiscGasParameters,
    timed_features: TimedFeatures,
    features: Features,
}
```

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L230-239)
```rust
        let mut timed_features_builder = TimedFeaturesBuilder::new(chain_id, timestamp_micros);
        if let Some(profile) = get_timed_feature_override() {
            // We need to ensure the override is taken into account for the hash.
            let profile_bytes = bcs::to_bytes(&profile)
                .expect("Timed features override should always be serializable");
            sha3_256.update(&profile_bytes);

            timed_features_builder = timed_features_builder.with_override_profile(profile)
        }
        let timed_features = timed_features_builder.build();
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L36-103)
```rust
static TIMED_FEATURE_OVERRIDE: OnceCell<TimedFeatureOverride> = OnceCell::new();

/// Controls whether debugging is enabled. This is thread safe.
static DEBUGGING_ENABLED: OnceLock<bool> = OnceLock::new();

/// If enabled, types layouts are cached in a global long-living cache. Caches ensure the behavior
/// is the same as without caches, and so, using node config suffices.
static LAYOUT_CACHES: OnceCell<bool> = OnceCell::new();

/// Set the paranoid type check flag.
pub fn set_paranoid_type_checks(enable: bool) {
    PARANOID_TYPE_CHECKS.set(enable).ok();
}

/// Returns the paranoid type check flag if already set, and true otherwise.
pub fn get_paranoid_type_checks() -> bool {
    PARANOID_TYPE_CHECKS.get().cloned().unwrap_or(true)
}

/// Sets the async check flag.
pub fn set_async_runtime_checks(enable: bool) {
    ASYNC_RUNTIME_CHECKS.set(enable).ok();
}

/// Returns the async check flag if already set, and false otherwise.
pub fn get_async_runtime_checks() -> bool {
    ASYNC_RUNTIME_CHECKS.get().cloned().unwrap_or(false)
}

/// Set the paranoid reference check flag.
pub fn set_paranoid_ref_checks(enable: bool) {
    PARANOID_REF_CHECKS.set(enable).ok();
}

/// Returns the paranoid reference check flag if already set, and false otherwise.
pub fn get_paranoid_ref_checks() -> bool {
    PARANOID_REF_CHECKS.get().cloned().unwrap_or(false)
}

/// Set whether debugging is enabled. This can be called from multiple threads. If there
/// are multiple sets, all must have the same value. Notice that enabling debugging can
/// make execution slower.
pub fn set_debugging_enabled(enable: bool) {
    match DEBUGGING_ENABLED.set(enable) {
        Err(old) if old != enable => panic!(
            "tried to set \
        enable_debugging to {}, but was already set to {}",
            enable, old
        ),
        _ => {},
    }
}

/// Returns whether debugging is enabled. Only accessed privately to construct
/// VMConfig.
fn get_debugging_enabled() -> bool {
    DEBUGGING_ENABLED.get().cloned().unwrap_or(false)
}

/// Set the timed feature override.
pub fn set_timed_feature_override(profile: TimedFeatureOverride) {
    TIMED_FEATURE_OVERRIDE.set(profile).ok();
}

/// Returns the timed feature override, and [None] if not set.
pub fn get_timed_feature_override() -> Option<TimedFeatureOverride> {
    TIMED_FEATURE_OVERRIDE.get().cloned()
}
```

**File:** types/src/on_chain_config/timed_features.rs (L180-199)
```rust
    /// Determine whether the given feature should be enabled or not.
    fn is_enabled(&self, flag: TimedFeatureFlag) -> bool {
        use TimedFeaturesImpl::*;

        if let Some(override_) = &self.override_ {
            if let Some(enabled) = override_.get_override(flag) {
                return enabled;
            }
        }

        match &self.inner {
            OnNamedChain {
                named_chain,
                timestamp_micros,
            } => {
                *timestamp_micros >= flag.activation_time_on(named_chain).timestamp_micros() as u64
            },
            EnableAll => true,
        }
    }
```

**File:** aptos-move/framework/table-natives/src/lib.rs (L386-420)
```rust
fn native_add_box(
    context: &mut SafeNativeContext,
    ty_args: &[Type],
    mut args: VecDeque<Value>,
) -> SafeNativeResult<SmallVec<[Value; 1]>> {
    assert_eq!(ty_args.len(), 3);
    assert_eq!(args.len(), 3);

    context.charge(ADD_BOX_BASE)?;
    let fix_memory_double_counting =
        context.timed_feature_enabled(TimedFeatureFlag::FixTableNativesMemoryDoubleCounting);

    let (extensions, mut loader_context, abs_val_gas_params, gas_feature_version) =
        context.extensions_with_loader_context_and_gas_params();
    let table_context = extensions.get::<NativeTableContext>();
    let mut table_data = table_context.table_data.borrow_mut();

    let val = args.pop_back().unwrap();
    let key = args.pop_back().unwrap();
    let handle = get_table_handle(&safely_pop_arg!(args, StructRef))?;

    let table =
        table_data.get_or_create_table(&mut loader_context, handle, &ty_args[0], &ty_args[2])?;

    let function_value_extension = loader_context.function_value_extension();
    let key_bytes = serialize_key(&function_value_extension, &table.key_layout, &key)?;
    let key_cost = ADD_BOX_PER_BYTE_SERIALIZED * NumBytes::new(key_bytes.len() as u64);

    let (gv, loaded) =
        table.get_or_create_global_value(&function_value_extension, table_context, key_bytes)?;
    let mem_usage = if !fix_memory_double_counting || loaded.is_some() {
        gv.view()
            .map(|val| {
                abs_val_gas_params
                    .abstract_heap_size(&val, gas_feature_version)
```
