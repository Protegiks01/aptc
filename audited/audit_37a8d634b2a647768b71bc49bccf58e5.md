# Audit Report

## Title
Consensus Ignores Executor Commit Failures Leading to State Inconsistency

## Summary
The consensus persisting phase blindly trusts the executor's commit operation without verifying success or failure. When `wait_for_commit_ledger()` is called, any errors from the executor's `commit_ledger()` operation are explicitly ignored, allowing consensus to proceed as if commitment succeeded even when storage validation fails or the executor encounters errors.

## Finding Description

The persisting phase's `process()` function calls `wait_for_commit_ledger()` which internally ignores all errors from the commit operation: [1](#0-0) 

The `wait_for_commit_ledger()` implementation explicitly discards errors: [2](#0-1) 

Despite the comment suggesting this is only for cancellation handling, this pattern ignores ALL errors, including legitimate validation failures.

The executor's commit process includes critical validations in the storage layer: [3](#0-2) 

When root hash verification fails, the executor correctly returns an error: [4](#0-3) 

However, this error is completely ignored by the persisting phase, which then returns success: [5](#0-4) 

The BufferManager receives this success response and updates consensus state accordingly: [6](#0-5) 

**Security Invariant Violation:**
This breaks the **State Consistency** invariant - consensus believes blocks are committed when storage may not contain them, and the **Deterministic Execution** invariant - validators may diverge if some successfully commit while others fail but report success.

**Attack Scenario with Compromised Executor:**
If an executor is compromised (via memory corruption, malicious code injection, or exploitation of an executor bug):

1. Malicious executor bypasses `check_and_put_ledger_info` validation
2. Commits incorrect state root or skips commitment entirely  
3. Returns `Ok()` to satisfy the async future
4. Consensus accepts this via the ignored error path
5. This validator now has different committed state than honest validators
6. Creates potential for chain splits or consensus safety violations

**Attack Scenario with Honest Executor Errors:**
Even with an honest executor:

1. Storage experiences transient failure (disk error, corruption)
2. Root hash verification fails in `check_and_put_ledger_info`
3. Executor correctly returns error
4. Consensus ignores error and updates `highest_committed_round`
5. Node believes block is committed but storage doesn't have it
6. On restart, node recovers from inconsistent state

## Impact Explanation

This issue constitutes a **Medium to High severity** vulnerability:

- **Medium Severity**: The ignored errors can cause state inconsistencies requiring manual intervention when legitimate storage errors occur
- **High Severity**: If exploited via a compromised executor, it enables consensus safety violations by allowing validators to commit different states

The impact falls under "State inconsistencies requiring intervention" (Medium) but approaches "Significant protocol violations" (High) when considering the compromised executor scenario.

## Likelihood Explanation

**Likelihood: Medium to Low**

- **For honest error scenario**: Storage errors are rare but do occur (disk failures, corruption). When they happen, the impact is guaranteed due to ignored errors.
- **For compromised executor scenario**: Requires pre-existing vulnerability in executor code or node compromise. The executor and consensus run in the same process, so compromising one typically means compromising both.

The architectural assumption is that executor and consensus are in the same trust boundary: [7](#0-6) 

However, defense-in-depth principles suggest consensus should still validate executor operations.

## Recommendation

Consensus must check the result of `commit_ledger_fut` and handle errors appropriately:

**Option 1: Propagate errors from wait_for_commit_ledger()**
```rust
pub async fn wait_for_commit_ledger(&self) -> Result<(), TaskError> {
    if let Some(fut) = self.pipeline_futs() {
        // Check for internal errors that indicate real commit failures
        if let Err(e @ TaskError::InternalError(_)) = fut.commit_ledger_fut.await {
            return Err(e);
        }
        // Ignore only cancellation/abort errors
    }
    Ok(())
}
```

**Option 2: Check errors in persisting phase process()**
```rust
async fn process(&self, req: PersistingRequest) -> PersistingResponse {
    let PersistingRequest { blocks, commit_ledger_info } = req;
    
    for b in &blocks {
        if let Some(tx) = b.pipeline_tx().lock().as_mut() {
            tx.commit_proof_tx
                .take()
                .map(|tx| tx.send(commit_ledger_info.clone()));
        }
        // Actually check the commit result
        if let Some(fut) = b.pipeline_futs() {
            if let Err(e @ TaskError::InternalError(_)) = fut.commit_ledger_fut.await {
                return Err(e.into());
            }
        }
    }
    // ... rest of function
}
```

Additionally, the BufferManager should handle error responses:
```rust
Some(response) = self.persisting_phase_rx.next() => {
    match response {
        Ok(round) => {
            self.pending_commit_votes = self.pending_commit_votes.split_off(&(round + 1));
            self.highest_committed_round = round;
            self.pending_commit_blocks = self.pending_commit_blocks.split_off(&(round + 1));
        }
        Err(e) => {
            error!("Commit failed: {:?}", e);
            // Trigger recovery or state sync
        }
    }
}
```

## Proof of Concept

While a full PoC requires modifying the executor to simulate failures, the vulnerability can be demonstrated by tracing the error path:

```rust
// Test scenario: Executor returns error due to root hash mismatch
// Location: storage/aptosdb/src/db/aptosdb_writer.rs:564-569

// Step 1: Root hash check fails
ensure!(
    db_root_hash == li_root_hash,  // This fails
    "Root hash pre-committed doesn't match LedgerInfo..."
);
// Returns: Err(AptosDbError)

// Step 2: Executor propagates error (block_executor/mod.rs:388-390)
self.db.writer.commit_ledger(...)?;  // Propagates error

// Step 3: Pipeline builder propagates error (pipeline_builder.rs:1098-1104)  
executor.commit_ledger(...)
    .map_err(anyhow::Error::from)?;  // Returns Err(TaskError::InternalError)

// Step 4: Error ignored (pipelined_block.rs:566)
let _ = fut.commit_ledger_fut.await;  // ERROR SILENTLY DROPPED

// Step 5: Success returned despite failure (persisting_phase.rs:74)
Ok(blocks.last().expect("Blocks can't be empty").round())

// Step 6: BufferManager updates state (buffer_manager.rs:968-972)
Some(Ok(round)) = self.persisting_phase_rx.next() => {
    self.highest_committed_round = round;  // Updated despite commit failure!
}
```

The vulnerability is in the architecture: consensus assumes executor is trusted and doesn't verify its operations, even ignoring explicit error signals.

### Citations

**File:** consensus/src/pipeline/persisting_phase.rs (L71-71)
```rust
            b.wait_for_commit_ledger().await;
```

**File:** consensus/src/pipeline/persisting_phase.rs (L74-74)
```rust
        let response = Ok(blocks.last().expect("Blocks can't be empty").round());
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L562-568)
```rust
    pub async fn wait_for_commit_ledger(&self) {
        // may be aborted (e.g. by reset)
        if let Some(fut) = self.pipeline_futs() {
            // this may be cancelled
            let _ = fut.commit_ledger_fut.await;
        }
    }
```

**File:** storage/aptosdb/src/db/aptosdb_writer.rs (L556-569)
```rust
        // Verify the root hash.
        let db_root_hash = self
            .ledger_db
            .transaction_accumulator_db()
            .get_root_hash(version)?;
        let li_root_hash = ledger_info_with_sig
            .ledger_info()
            .transaction_accumulator_hash();
        ensure!(
            db_root_hash == li_root_hash,
            "Root hash pre-committed doesn't match LedgerInfo. pre-commited: {:?} vs in LedgerInfo: {:?}",
            db_root_hash,
            li_root_hash,
        );
```

**File:** consensus/src/pipeline/pipeline_builder.rs (L1096-1105)
```rust
        tracker.start_working();
        let ledger_info_with_sigs_clone = ledger_info_with_sigs.clone();
        tokio::task::spawn_blocking(move || {
            executor
                .commit_ledger(ledger_info_with_sigs_clone)
                .map_err(anyhow::Error::from)
        })
        .await
        .expect("spawn blocking failed")?;
        Ok(Some(ledger_info_with_sigs))
```

**File:** consensus/src/pipeline/buffer_manager.rs (L968-973)
```rust
                Some(Ok(round)) = self.persisting_phase_rx.next() => {
                    // see where `need_backpressure()` is called.
                    self.pending_commit_votes = self.pending_commit_votes.split_off(&(round + 1));
                    self.highest_committed_round = round;
                    self.pending_commit_blocks = self.pending_commit_blocks.split_off(&(round + 1));
                },
```

**File:** consensus/src/consensus_provider.rs (L65-72)
```rust
    let execution_proxy = ExecutionProxy::new(
        Arc::new(BlockExecutor::<AptosVMBlockExecutor>::new(aptos_db)),
        txn_notifier,
        state_sync_notifier,
        node_config.transaction_filters.execution_filter.clone(),
        node_config.consensus.enable_pre_commit,
        None,
    );
```
