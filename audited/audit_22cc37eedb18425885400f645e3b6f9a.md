# Audit Report

## Title
Case-Sensitive Filter Bypass in Transaction Filter Allowing Emergency Filter Evasion

## Summary
The `standardize_address()` function in the transaction filter system preserves the case of hex characters in addresses instead of normalizing them to lowercase. Since blockchain-serialized addresses are always lowercase (via `AccountAddress.to_string()`), filters configured with uppercase or mixed-case addresses will fail to match transactions from those addresses, allowing critical emergency filters to be bypassed.

## Finding Description

The vulnerability exists in the transaction filter system used by the Aptos indexer-grpc infrastructure. The issue stems from a mismatch between how addresses are standardized in filters versus how they're serialized in the blockchain.

**The Core Issue:**

The `standardize_address()` function preserves the original case of hex characters: [1](#0-0) 

This function takes an address string and standardizes its format (short vs long), but critically, it preserves the case of hex characters. If you pass "0xABCD", it outputs "0x0000...ABCD" with uppercase preserved.

**How Blockchain Addresses are Serialized:**

When transactions are converted to protobuf format for the indexer, addresses are serialized using `AccountAddress.to_string()`: [2](#0-1) 

The `to_string()` method on `AccountAddress` calls `to_standard_string()` which uses `hex::encode()` internally, producing **lowercase** hex strings: [3](#0-2) 

**Filter Matching Logic:**

Filters standardize both the filter rule address and the transaction address, then perform case-sensitive string comparison: [4](#0-3) 

**The Vulnerability:**

1. Operator configures emergency filter with address "0xABCD" (uppercase)
2. Filter standardizes to "0x0000000000000000000000000000000000000000000000000000000000ABCD" (uppercase preserved)
3. Transaction arrives with sender address bytes for 0xabcd
4. Serialized as "0x0000000000000000000000000000000000000000000000000000000000abcd" (lowercase)
5. Comparison: "0x...ABCD" ≠ "0x...abcd" → **Filter doesn't match!**

**Critical Use Case:**

This is especially severe for the `txns_to_strip_filter` used for emergency transaction stripping: [5](#0-4) 

If emergency filters are configured with wrong-case addresses, problematic transactions will bypass the filter and reach downstream systems.

## Impact Explanation

**Severity: Medium to High**

While this doesn't affect core blockchain consensus or execution, it has significant impact on the indexer infrastructure:

1. **Emergency Response Failure**: The `txns_to_strip_filter` is designed for emergency situations to block problematic transactions (e.g., from buggy contracts causing data service issues). If configured with wrong-case addresses, it silently fails.

2. **Security Filter Bypass**: Applications and indexers relying on filters for security purposes (e.g., blocking specific addresses) may be misconfigured without realizing it.

3. **Silent Failure**: The filter appears to be correctly configured but doesn't work, making debugging difficult.

This qualifies as **High Severity** for the indexer system per the impact categories (significant protocol violations, API crashes from unfiltered problematic transactions), though it's Medium overall since it doesn't affect core blockchain operations.

## Likelihood Explanation

**Likelihood: Medium to High**

This issue is highly likely to occur because:

1. **Natural Behavior**: Users commonly copy-paste addresses from various sources (explorers, documentation, logs) which may have different casing.

2. **No Validation**: There's no warning or validation that alerts operators when filter addresses don't match the canonical lowercase format.

3. **Ethereum Precedent**: Ethereum addresses use checksummed mixed-case format (EIP-55), making users accustomed to preserving case. Aptos users might similarly preserve case without realizing it matters.

4. **Silent Failure**: The filter validates successfully but doesn't match, with no error indication.

## Recommendation

**Fix the `standardize_address()` function to normalize addresses to lowercase:**

```rust
pub fn standardize_address(address: &str) -> String {
    // Remove "0x" prefix if it exists
    let trimmed = address.strip_prefix("0x").unwrap_or(address);
    
    // Convert to lowercase for case-insensitive comparison
    let trimmed = trimmed.to_lowercase();

    // Check if the address is a special address
    if let Some(last_char) = trimmed.chars().last() {
        if trimmed[..trimmed.len().saturating_sub(1)]
            .chars()
            .all(|c| c == '0')
            && last_char.is_ascii_hexdigit()
            && last_char <= 'f'
        {
            // Return special addresses in short format
            let mut result = String::with_capacity(3);
            result.push_str("0x");
            result.push(last_char);
            return result;
        }
    }

    // Return non-special addresses in long format
    let mut result = String::with_capacity(66);
    result.push_str("0x");
    result.push_str(&ZEROS[..64 - trimmed.len()]);
    result.push_str(&trimmed);
    result
}
```

**Alternative**: Add validation to reject non-lowercase addresses in filter configuration, or add a warning when addresses contain uppercase characters.

## Proof of Concept

```rust
#[cfg(test)]
mod test_case_sensitivity_bypass {
    use super::*;

    #[test]
    fn test_case_sensitive_filter_bypass() {
        // Simulate operator setting up filter with uppercase address
        let filter_address = "0xABCD";
        let standardized_filter = standardize_address(filter_address);
        // Result: "0x000000000000000000000000000000000000000000000000000000000000ABCD"
        
        // Simulate transaction address as it comes from blockchain (always lowercase)
        let txn_address = "0xabcd"; // This is how AccountAddress.to_string() returns it
        let standardized_txn = standardize_address(txn_address);
        // Result: "0x000000000000000000000000000000000000000000000000000000000000abcd"
        
        // Case-sensitive comparison fails!
        assert_ne!(standardized_filter, standardized_txn);
        
        // This means a filter configured with "0xABCD" will NOT match 
        // transactions from address 0xabcd, even though they represent 
        // the same blockchain address
        println!("Filter: {}", standardized_filter);
        println!("Transaction: {}", standardized_txn);
        println!("Match: {}", standardized_filter == standardized_txn); // false!
    }
    
    #[test]
    fn test_emergency_filter_bypass() {
        use crate::UserTransactionFilterBuilder;
        
        // Emergency: Operator wants to strip all transactions from problematic address
        // But accidentally uses uppercase from copy-paste
        let filter = UserTransactionFilterBuilder::default()
            .sender("0xBADC0FFEE") // Uppercase
            .build()
            .unwrap();
            
        // Simulate checking if a transaction matches
        // In reality, the transaction sender will be lowercase: "0xbadc0ffee"
        // The filter will fail to match, allowing problematic txns through
        
        let filter_standardized = filter.get_standardized_sender();
        // This will be "0x00...BADC0FFEE" (uppercase)
        
        // But actual transactions will have "0x00...badc0ffee" (lowercase)
        // So the filter silently fails!
    }
}
```

## Notes

This vulnerability is specific to the indexer-grpc transaction filter system and does not affect core blockchain consensus or execution. However, it has real security implications for:

1. Emergency response procedures using `txns_to_strip_filter`
2. Applications relying on transaction filtering for security
3. Indexer operators filtering specific addresses

The fix is straightforward: normalize all addresses to lowercase in `standardize_address()` to match the blockchain's canonical representation.

### Citations

**File:** ecosystem/indexer-grpc/transaction-filter/src/utils.rs (L10-36)
```rust
pub fn standardize_address(address: &str) -> String {
    // Remove "0x" prefix if it exists
    let trimmed = address.strip_prefix("0x").unwrap_or(address);

    // Check if the address is a special address by seeing if the first 31 bytes are zero and the last byte is smaller than 0b10000
    if let Some(last_char) = trimmed.chars().last() {
        if trimmed[..trimmed.len().saturating_sub(1)]
            .chars()
            .all(|c| c == '0')
            && last_char.is_ascii_hexdigit()
            && last_char <= 'f'
        {
            // Return special addresses in short format
            let mut result = String::with_capacity(3);
            result.push_str("0x");
            result.push(last_char);
            return result;
        }
    }

    // Return non-special addresses in long format
    let mut result = String::with_capacity(66);
    result.push_str("0x");
    result.push_str(&ZEROS[..64 - trimmed.len()]);
    result.push_str(trimmed);
    result
}
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/convert.rs (L861-861)
```rust
                    sender: ut.request.sender.to_string(),
```

**File:** third_party/move/move-core/types/src/account_address.rs (L132-134)
```rust
    pub fn to_canonical_string(&self) -> String {
        hex::encode(self.0)
    }
```

**File:** ecosystem/indexer-grpc/transaction-filter/src/filters/user_transaction.rs (L94-98)
```rust
        if let Some(sender_filter) = self.get_standardized_sender() {
            if &standardize_address(&user_request.sender) != sender_filter {
                return false;
            }
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service/src/config.rs (L73-84)
```rust
    /// Any transaction that matches this filter will be stripped. This means we remove
    /// the payload, signature, events, and writesets from it before sending it
    /// downstream. This should only be used in an emergency situation, e.g. when txns
    /// related to a certain module are too large and are causing issues for the data
    /// service. Learn more here:
    ///
    /// https://www.notion.so/aptoslabs/Runbook-c006a37259394ac2ba904d6b54d180fa?pvs=4#171c210964ec42a89574fc80154f9e85
    ///
    /// Generally you will want to start with this with an OR, and then list out
    /// separate filters that describe each type of txn we want to strip.
    #[serde(default = "IndexerGrpcDataServiceConfig::default_txns_to_strip_filter")]
    pub txns_to_strip_filter: BooleanTransactionFilter,
```
