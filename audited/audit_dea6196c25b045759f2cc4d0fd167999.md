# Audit Report

## Title
Incomplete State Value Truncation - State Values Without Stale Indices Persist After Rollback

## Summary
The truncation operation in AptosDB's state KV storage relies exclusively on stale indices to identify state values for deletion. First-time writes to new state keys do not create stale indices, causing these values to persist in the database after truncation when their version exceeds the target. This violates the critical invariant that all data with version > target must be removed during rollback operations.

## Finding Description

**Vulnerability Mechanism:**

The truncation logic in `delete_state_value_and_index` only deletes state values by iterating through stale index entries: [1](#0-0) 

This approach has a critical flaw: stale indices are only created in specific scenarios during state value writes:

1. **For tombstones (deletions)**: A self-referencing stale index is created [2](#0-1) 

2. **For value updates**: A stale index is created ONLY when overwriting an existing value [3](#0-2) 

The critical issue: when a new state key is written for the first time (no previous value exists), the `old_entry.is_occupied()` check returns false, and NO stale index is created. This is because `StateSlot::ColdVacant` represents an empty state: [4](#0-3) 

**Attack Scenario:**

1. At version 100: New state key K written with first value (account creation, resource publication, etc.)
   - Entry created: `StateValueByKeyHashSchema[(hash(K), 100)] = value`
   - NO stale index created (no previous value to mark as stale)

2. Node crashes and performs truncation to version 75 via `sync_commit_progress`: [5](#0-4) 

3. Truncation seeks stale indices with `stale_since_version ≥ 76`, finds NONE for key K, and does NOT delete the orphaned value at version 100

4. Result: State value at version 100 persists in database despite version > truncation target

**Test Coverage Gap:**

The existing truncation test validates the invariant that all remaining data has version ≤ target: [6](#0-5) 

However, this test uses `arb_blocks_to_commit_with_block_nums` which generates transactions that update the same fixed set of account resources. The first writes to these resources occur at low versions (kept during truncation), so the test never exercises the scenario of first-time writes at high versions being orphaned. [7](#0-6) 

**Contrast with Merkle Tree Truncation:**

Notably, the state Merkle tree truncation does NOT have this bug because it directly iterates and deletes nodes by version: [8](#0-7) 

This architectural inconsistency—Merkle tree using direct iteration while state KV relies on indices—is the root cause.

## Impact Explanation

This is a **HIGH Severity** vulnerability causing significant protocol violations:

1. **State Database Corruption**: The database contains state values from after the truncation point, directly violating the truncation invariant verified by the test suite. This constitutes database corruption where internal consistency guarantees are broken.

2. **Non-Deterministic State**: Different nodes may have different sets of orphaned values depending on:
   - When they crashed relative to new key writes
   - Which transactions they processed before truncation
   - This breaks the assumption of deterministic state across validators

3. **Merkle Tree Desynchronization Risk**: The state Merkle tree is correctly truncated (using direct iteration), but orphaned state values remain in the KV store. This mismatch could cause verification failures or incorrect state proofs.

4. **Transaction Replay Issues**: After truncation, replaying transactions may produce different results if orphaned values interfere with state reads or if internal operations assume all data is ≤ current version.

This meets the Aptos bug bounty criteria for **HIGH severity** under "Validator Node Slowdowns" and approaches **MEDIUM severity** under "State inconsistencies requiring manual intervention."

## Likelihood Explanation

**Likelihood: MEDIUM-HIGH**

This vulnerability can be triggered during normal node operations:

1. **Trigger Condition**: Node restart/crash that invokes `sync_commit_progress` for truncation [9](#0-8) 

2. **First-Time State Key Writes** occur regularly in production:
   - **New account creation**: Creating accounts writes new `AccountResource` and `CoinStore` keys
   - **Resource publishing**: Publishing Move resources to new addresses
   - **Module deployment**: Deploying new Move modules creates new state keys
   - **Dynamic key generation**: Smart contracts generating runtime storage keys

3. **No Special Access Required**: Any normal user transaction can create new state keys. The bug manifests automatically during crash recovery—no attacker action needed beyond normal transaction submission.

4. **Test Suite Gap**: Current tests don't catch this because they update existing keys from genesis rather than creating new keys mid-execution at high versions.

The combination of regular new key writes and periodic node restarts makes this a realistically triggerable bug in production environments.

## Recommendation

**Root Cause**: Truncation relies on stale indices, but first-time writes don't create stale indices.

**Solution**: Modify truncation to directly iterate state values by version, similar to Merkle tree truncation:

```rust
fn delete_state_value_and_index(
    state_kv_db_shard: &DB,
    start_version: Version,
    batch: &mut SchemaBatch,
    enable_sharding: bool,
) -> Result<()> {
    if enable_sharding {
        // Delete stale indices
        let mut iter = state_kv_db_shard.iter::<StaleStateValueIndexByKeyHashSchema>()?;
        iter.seek(&start_version)?;
        for item in iter {
            let (index, _) = item?;
            batch.delete::<StaleStateValueIndexByKeyHashSchema>(&index)?;
        }
        
        // NEW: Directly iterate and delete state values by version
        let mut iter = state_kv_db_shard.iter::<StateValueByKeyHashSchema>()?;
        iter.seek_to_first();
        for item in iter {
            let ((state_key_hash, version), _) = item?;
            if version >= start_version {
                batch.delete::<StateValueByKeyHashSchema>(&(state_key_hash, version))?;
            }
        }
    } else {
        // Similar fix for non-sharded case
        // ...
    }
    Ok(())
}
```

**Alternative**: Create stale indices for first-time writes immediately upon write, not just when overwritten.

## Proof of Concept

The vulnerability can be verified by creating a test that:
1. Writes a new state key at version 100
2. Performs truncation to version 75
3. Verifies the orphaned value at version 100 still exists in `StateValueByKeyHashSchema`

The existing test framework in `storage/aptosdb/src/db_debugger/truncate/mod.rs` can be extended to cover this scenario by ensuring some state keys are written for the first time at high versions before truncation.

---

**Notes**

This is a logic vulnerability in the truncation implementation where the mechanism (stale index iteration) is fundamentally incomplete for finding all state values that need deletion. The architectural inconsistency between Merkle tree truncation (direct iteration) and state KV truncation (index-based) reveals this gap. While the impact doesn't directly cause consensus failure, it represents significant database corruption that violates critical invariants and could lead to downstream issues in state management and verification.

### Citations

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L557-568)
```rust
    if enable_sharding {
        let mut iter = state_kv_db_shard.iter::<StaleStateValueIndexByKeyHashSchema>()?;
        iter.seek(&start_version)?;

        for item in iter {
            let (index, _) = item?;
            batch.delete::<StaleStateValueIndexByKeyHashSchema>(&index)?;
            batch.delete::<StateValueByKeyHashSchema>(&(
                index.state_key_hash,
                index.stale_since_version,
            ))?;
        }
```

**File:** storage/aptosdb/src/utils/truncation_helper.rs (L614-619)
```rust
    let mut iter = db.iter::<JellyfishMerkleNodeSchema>()?;
    iter.seek(&NodeKey::new_empty_path(version))?;
    for item in iter {
        let (key, _) = item?;
        batch.delete::<JellyfishMerkleNodeSchema>(&key)?;
    }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L354-359)
```rust
            Self::sync_commit_progress(
                Arc::clone(&ledger_db),
                Arc::clone(&state_kv_db),
                Arc::clone(&state_merkle_db),
                /*crash_if_difference_is_too_large=*/ true,
            );
```

**File:** storage/aptosdb/src/state_store/mod.rs (L410-467)
```rust
    pub fn sync_commit_progress(
        ledger_db: Arc<LedgerDb>,
        state_kv_db: Arc<StateKvDb>,
        state_merkle_db: Arc<StateMerkleDb>,
        crash_if_difference_is_too_large: bool,
    ) {
        let ledger_metadata_db = ledger_db.metadata_db();
        if let Some(overall_commit_progress) = ledger_metadata_db
            .get_synced_version()
            .expect("DB read failed.")
        {
            info!(
                overall_commit_progress = overall_commit_progress,
                "Start syncing databases..."
            );
            let ledger_commit_progress = ledger_metadata_db
                .get_ledger_commit_progress()
                .expect("Failed to read ledger commit progress.");
            assert_ge!(ledger_commit_progress, overall_commit_progress);

            let state_kv_commit_progress = state_kv_db
                .metadata_db()
                .get::<DbMetadataSchema>(&DbMetadataKey::StateKvCommitProgress)
                .expect("Failed to read state K/V commit progress.")
                .expect("State K/V commit progress cannot be None.")
                .expect_version();
            assert_ge!(state_kv_commit_progress, overall_commit_progress);

            // LedgerCommitProgress was not guaranteed to commit after all ledger changes finish,
            // have to attempt truncating every column family.
            info!(
                ledger_commit_progress = ledger_commit_progress,
                "Attempt ledger truncation...",
            );
            let difference = ledger_commit_progress - overall_commit_progress;
            if crash_if_difference_is_too_large {
                assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
            }
            truncate_ledger_db(ledger_db.clone(), overall_commit_progress)
                .expect("Failed to truncate ledger db.");

            // State K/V commit progress isn't (can't be) written atomically with the data,
            // because there are shards, so we have to attempt truncation anyway.
            info!(
                state_kv_commit_progress = state_kv_commit_progress,
                "Start state KV truncation..."
            );
            let difference = state_kv_commit_progress - overall_commit_progress;
            if crash_if_difference_is_too_large {
                assert_le!(difference, MAX_COMMIT_PROGRESS_DIFFERENCE);
            }
            truncate_state_kv_db(
                &state_kv_db,
                state_kv_commit_progress,
                overall_commit_progress,
                std::cmp::max(difference as usize, 1), /* batch_size */
            )
            .expect("Failed to truncate state K/V db.");
```

**File:** storage/aptosdb/src/state_store/mod.rs (L947-951)
```rust
                if update_to_cold.state_op.expect_as_write_op().is_delete() {
                    // This is a tombstone, can be pruned once this `version` goes out of
                    // the pruning window.
                    Self::put_state_kv_index(batch, enable_sharding, version, version, key);
                }
```

**File:** storage/aptosdb/src/state_store/mod.rs (L970-980)
```rust
                if old_entry.is_occupied() {
                    // The value at the old version can be pruned once the pruning window hits
                    // this `version`.
                    Self::put_state_kv_index(
                        batch,
                        enable_sharding,
                        version,
                        old_entry.expect_value_version(),
                        key,
                    )
                }
```

**File:** types/src/state_store/state_slot.rs (L146-151)
```rust
    pub fn is_occupied(&self) -> bool {
        match self {
            ColdVacant | HotVacant { .. } => false,
            ColdOccupied { .. } | HotOccupied { .. } => true,
        }
    }
```

**File:** storage/aptosdb/src/db_debugger/truncate/mod.rs (L357-362)
```rust
                    let mut kv_shard_iter = state_kv_db.db_shard(i).iter::<StateValueByKeyHashSchema>().unwrap();
                    kv_shard_iter.seek_to_first();
                    for item in kv_shard_iter {
                        let ((_, version), _) = item.unwrap();
                        prop_assert!(version <= target_version);
                    }
```

**File:** storage/aptosdb/src/db/test_helper.rs (L212-229)
```rust
pub fn arb_blocks_to_commit_with_block_nums(
    min_blocks: usize,
    max_blocks: usize,
) -> impl Strategy<
    Value = (
        Vec<(Vec<TransactionToCommit>, LedgerInfoWithSignatures)>,
        bool,
    ),
> {
    (
        arb_blocks_to_commit_impl(
            5, /* num_accounts */
            2, /* max_user_txn_per_block */
            min_blocks, max_blocks,
        ),
        proptest::bool::ANY,
    )
}
```
