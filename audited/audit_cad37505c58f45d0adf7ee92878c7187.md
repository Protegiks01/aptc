# Audit Report

## Title
Transaction Validation Resource Exhaustion via Concurrent Duplicate Submissions

## Summary
The `PooledVMValidator::validate_transaction()` function does not check for transaction uniqueness before performing expensive VM validation. Duplicate transactions submitted concurrently will all undergo full validation (including signature verification, state reads, and Move prologue execution) before being rejected at mempool insertion time, enabling resource exhaustion attacks against validator nodes.

## Finding Description
The transaction submission flow in Aptos has a critical gap in duplicate detection timing: [1](#0-0) 

In `validate_and_add_transactions()`, VM validation occurs in parallel for all submitted transactions [2](#0-1)  **without holding the mempool lock**. The duplicate check only occurs after validation completes when attempting to insert into mempool [3](#0-2) .

This creates a race condition where:

1. Multiple identical transactions (same sender + sequence number) can simultaneously pass through `process_incoming_transactions()` [4](#0-3) 

2. All proceed to expensive VM validation via `PooledVMValidator::validate_transaction()` [5](#0-4) 

3. Each validation performs:
   - Signature verification [6](#0-5) 
   - State reads for sequence number and authentication key [7](#0-6) 
   - Full Move prologue execution [8](#0-7) 

4. Only the first transaction succeeds insertion; all others are rejected as idempotent after wasting CPU resources [9](#0-8) 

**Attack Path:**
An attacker submits the same transaction T (sender: Alice, sequence: N) thousands of times concurrently. Each submission:
- Bypasses the sequence number filter (all have seq â‰¥ current) [10](#0-9) 
- Enters parallel validation pool
- Consumes CPU for cryptographic operations and state access
- Only gets rejected after validation completes

## Impact Explanation
**High Severity** - Validator Node Slowdowns (per Aptos Bug Bounty criteria):

This vulnerability enables a resource exhaustion attack against validator nodes by forcing redundant expensive validation operations. While API rate limiting (default 100 req/min) provides some mitigation, an attacker can:

1. Use multiple IP addresses/connections to multiply attack capacity
2. Continuously submit duplicates to keep the validation thread pool saturated
3. Delay or prevent legitimate transaction processing
4. Degrade validator performance during high-load periods

The impact is amplified because:
- Signature verification is cryptographically expensive
- State reads require database access
- Move prologue execution involves VM overhead
- No early exit mechanism exists for duplicates

This does not cause permanent network damage but significantly degrades validator availability and responsiveness.

## Likelihood Explanation
**High Likelihood** - The attack is:
- **Easy to execute**: Requires only the ability to submit transactions via REST API (no special privileges)
- **Low cost**: Attacker only needs to craft one valid transaction and replay it
- **Difficult to detect**: Appears as legitimate transaction submissions initially
- **Effective**: Guaranteed to waste resources on every duplicate validation

The only limiting factors are:
- Per-connection API rate limits (easily bypassed with multiple connections)
- Validation thread pool size (still allows significant parallel waste)

## Recommendation
Add duplicate transaction detection **before** VM validation in `process_incoming_transactions`:

```rust
// In mempool/src/shared_mempool/tasks.rs, before line 395:

// Check for duplicates already in mempool before expensive validation
let transactions: Vec<_> = transactions
    .into_iter()
    .filter_map(|(txn, seq_num, ready_time, priority)| {
        let address = txn.sender();
        let replay_protector = txn.replay_protector();
        
        // Quick check if transaction already exists in mempool
        if smp.mempool.lock().get(&address, replay_protector).is_some() {
            statuses.push((
                txn,
                (
                    MempoolStatus::new(MempoolStatusCode::Accepted),
                    None,
                ),
            ));
            counters::CORE_MEMPOOL_IDEMPOTENT_TXNS.inc();
            None
        } else {
            Some((txn, seq_num, ready_time, priority))
        }
    })
    .collect();
```

This ensures duplicate detection occurs **before** expensive validation, preventing resource waste while maintaining identical behavior (returning `Accepted` for idempotent submissions).

## Proof of Concept

```rust
// Test in mempool/src/tests/core_mempool_test.rs
#[tokio::test]
async fn test_concurrent_duplicate_validation_resource_exhaustion() {
    use std::sync::{Arc, atomic::{AtomicUsize, Ordering}};
    use futures::future::join_all;
    
    let (mut shared_mempool, _) = setup_mempool();
    let validation_counter = Arc::new(AtomicUsize::new(0));
    
    // Create one valid transaction
    let txn = test_transaction(0, 1, 10);
    
    // Submit same transaction 100 times concurrently
    let mut handles = vec![];
    for _ in 0..100 {
        let smp = shared_mempool.clone();
        let t = txn.clone();
        let counter = validation_counter.clone();
        
        handles.push(tokio::spawn(async move {
            // Hook into validation to count invocations
            counter.fetch_add(1, Ordering::SeqCst);
            process_incoming_transactions(
                &smp,
                vec![(t, None, None)],
                TimelineState::NotReady,
                true,
            )
        }));
    }
    
    join_all(handles).await;
    
    // Verify: validation was called 100 times but only 1 transaction inserted
    assert_eq!(validation_counter.load(Ordering::SeqCst), 100);
    assert_eq!(shared_mempool.mempool.lock().system_ttl_index.size(), 1);
    // 99 validations were wasted resources!
}
```

**Notes:**
- The vulnerability exists in the design of the validation pipeline where uniqueness is checked after expensive validation rather than before
- The sequence number check during validation [11](#0-10)  only verifies correctness, not uniqueness
- Current idempotent handling [12](#0-11)  prevents duplicate insertion but cannot prevent duplicate validation
- This affects all transaction types and is not limited to specific payload formats

### Citations

**File:** mempool/src/shared_mempool/tasks.rs (L304-404)
```rust
pub(crate) fn process_incoming_transactions<NetworkClient, TransactionValidator>(
    smp: &SharedMempool<NetworkClient, TransactionValidator>,
    transactions: Vec<(
        SignedTransaction,
        Option<u64>,
        Option<BroadcastPeerPriority>,
    )>,
    timeline_state: TimelineState,
    client_submitted: bool,
) -> Vec<SubmissionStatusBundle>
where
    NetworkClient: NetworkClientInterface<MempoolSyncMsg>,
    TransactionValidator: TransactionValidation,
{
    // Filter out any disallowed transactions
    let mut statuses = vec![];
    let transactions =
        filter_transactions(&smp.transaction_filter_config, transactions, &mut statuses);

    // If there are no transactions left after filtering, return early
    if transactions.is_empty() {
        return statuses;
    }

    let start_storage_read = Instant::now();
    let state_view = smp
        .db
        .latest_state_checkpoint_view()
        .expect("Failed to get latest state checkpoint view.");

    // Track latency: fetching seq number
    let account_seq_numbers = IO_POOL.install(|| {
        transactions
            .par_iter()
            .map(|(t, _, _)| match t.replay_protector() {
                ReplayProtector::Nonce(_) => Ok(None),
                ReplayProtector::SequenceNumber(_) => {
                    get_account_sequence_number(&state_view, t.sender())
                        .map(Some)
                        .inspect_err(|e| {
                            error!(LogSchema::new(LogEntry::DBError).error(e));
                            counters::DB_ERROR.inc();
                        })
                },
            })
            .collect::<Vec<_>>()
    });

    // Track latency for storage read fetching sequence number
    let storage_read_latency = start_storage_read.elapsed();
    counters::PROCESS_TXN_BREAKDOWN_LATENCY
        .with_label_values(&[counters::FETCH_SEQ_NUM_LABEL])
        .observe(storage_read_latency.as_secs_f64() / transactions.len() as f64);

    let transactions: Vec<_> = transactions
        .into_iter()
        .enumerate()
        .filter_map(|(idx, (t, ready_time_at_sender, priority))| {
            if let Ok(account_sequence_num) = account_seq_numbers[idx] {
                match account_sequence_num {
                    Some(sequence_num) => {
                        if t.sequence_number() >= sequence_num {
                            return Some((t, Some(sequence_num), ready_time_at_sender, priority));
                        } else {
                            statuses.push((
                                t,
                                (
                                    MempoolStatus::new(MempoolStatusCode::VmError),
                                    Some(DiscardedVMStatus::SEQUENCE_NUMBER_TOO_OLD),
                                ),
                            ));
                        }
                    },
                    None => {
                        return Some((t, None, ready_time_at_sender, priority));
                    },
                }
            } else {
                // Failed to get account's onchain sequence number
                statuses.push((
                    t,
                    (
                        MempoolStatus::new(MempoolStatusCode::VmError),
                        Some(DiscardedVMStatus::RESOURCE_DOES_NOT_EXIST),
                    ),
                ));
            }
            None
        })
        .collect();

    validate_and_add_transactions(
        transactions,
        smp,
        timeline_state,
        &mut statuses,
        client_submitted,
    );
    notify_subscribers(SharedMempoolNotification::NewTransactions, &smp.subscribers);
    statuses
}
```

**File:** mempool/src/shared_mempool/tasks.rs (L471-546)
```rust
fn validate_and_add_transactions<NetworkClient, TransactionValidator>(
    transactions: Vec<(
        SignedTransaction,
        Option<u64>,
        Option<u64>,
        Option<BroadcastPeerPriority>,
    )>,
    smp: &SharedMempool<NetworkClient, TransactionValidator>,
    timeline_state: TimelineState,
    statuses: &mut Vec<(SignedTransaction, (MempoolStatus, Option<StatusCode>))>,
    client_submitted: bool,
) where
    NetworkClient: NetworkClientInterface<MempoolSyncMsg>,
    TransactionValidator: TransactionValidation,
{
    // Track latency: VM validation
    let vm_validation_timer = counters::PROCESS_TXN_BREAKDOWN_LATENCY
        .with_label_values(&[counters::VM_VALIDATION_LABEL])
        .start_timer();
    let validation_results = VALIDATION_POOL.install(|| {
        transactions
            .par_iter()
            .map(|t| {
                let result = smp.validator.read().validate_transaction(t.0.clone());
                // Pre-compute the hash and length if the transaction is valid, before locking mempool
                if result.is_ok() {
                    t.0.committed_hash();
                    t.0.txn_bytes_len();
                }
                result
            })
            .collect::<Vec<_>>()
    });
    vm_validation_timer.stop_and_record();
    {
        let mut mempool = smp.mempool.lock();
        for (idx, (transaction, account_sequence_number, ready_time_at_sender, priority)) in
            transactions.into_iter().enumerate()
        {
            if let Ok(validation_result) = &validation_results[idx] {
                match validation_result.status() {
                    None => {
                        let ranking_score = validation_result.score();
                        let mempool_status = mempool.add_txn(
                            transaction.clone(),
                            ranking_score,
                            account_sequence_number,
                            timeline_state,
                            client_submitted,
                            ready_time_at_sender,
                            priority.clone(),
                        );
                        statuses.push((transaction, (mempool_status, None)));
                    },
                    Some(validation_status) => {
                        statuses.push((
                            transaction.clone(),
                            (
                                MempoolStatus::new(MempoolStatusCode::VmError),
                                Some(validation_status),
                            ),
                        ));
                    },
                }
            } else {
                statuses.push((
                    transaction.clone(),
                    (
                        MempoolStatus::new(MempoolStatusCode::VmError),
                        Some(DiscardedVMStatus::UNKNOWN_STATUS),
                    ),
                ));
            }
        }
    }
}
```

**File:** mempool/src/core_mempool/transaction_store.rs (L256-293)
```rust
        if let Some(txns) = self.transactions.get_mut(&address) {
            if let Some(current_version) = txns.get_mut(&txn_replay_protector) {
                if current_version.txn.payload() != txn.txn.payload() {
                    return MempoolStatus::new(MempoolStatusCode::InvalidUpdate).with_message(
                        "Transaction already in mempool with a different payload".to_string(),
                    );
                } else if current_version.txn.expiration_timestamp_secs()
                    != txn.txn.expiration_timestamp_secs()
                {
                    return MempoolStatus::new(MempoolStatusCode::InvalidUpdate).with_message(
                        "Transaction already in mempool with a different expiration timestamp"
                            .to_string(),
                    );
                } else if current_version.txn.max_gas_amount() != txn.txn.max_gas_amount() {
                    return MempoolStatus::new(MempoolStatusCode::InvalidUpdate).with_message(
                        "Transaction already in mempool with a different max gas amount"
                            .to_string(),
                    );
                } else if current_version.get_gas_price() < txn.get_gas_price() {
                    // Update txn if gas unit price is a larger value than before
                    if let Some(txn) = txns.remove(&txn_replay_protector) {
                        self.index_remove(&txn);
                    };
                    counters::CORE_MEMPOOL_GAS_UPGRADED_TXNS.inc();
                } else if current_version.get_gas_price() > txn.get_gas_price() {
                    return MempoolStatus::new(MempoolStatusCode::InvalidUpdate).with_message(
                        "Transaction already in mempool with a higher gas price".to_string(),
                    );
                } else {
                    // If the transaction is the same, it's an idempotent call
                    // Updating signers is not supported, the previous submission must fail
                    counters::CORE_MEMPOOL_IDEMPOTENT_TXNS.inc();
                    if let Some(acc_seq_num) = account_sequence_number {
                        self.process_ready_seq_num_based_transactions(&address, acc_seq_num);
                    }
                    return MempoolStatus::new(MempoolStatusCode::Accepted);
                }
            }
```

**File:** vm-validator/src/vm_validator.rs (L146-170)
```rust
    fn validate_transaction(&self, txn: SignedTransaction) -> Result<VMValidatorResult> {
        let vm_validator = self.get_next_vm();

        fail_point!("vm_validator::validate_transaction", |_| {
            Err(anyhow::anyhow!(
                "Injected error in vm_validator::validate_transaction"
            ))
        });

        let result = std::panic::catch_unwind(move || {
            let vm_validator_locked = vm_validator.lock().unwrap();

            use aptos_vm::VMValidator;
            let vm = AptosVM::new(&vm_validator_locked.state.environment);
            vm.validate_transaction(
                txn,
                &vm_validator_locked.state.state_view,
                &vm_validator_locked.state,
            )
        });
        if let Err(err) = &result {
            error!("VMValidator panicked: {:?}", err);
        }
        result.map_err(|_| anyhow::anyhow!("panic validating transaction"))
    }
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L3232-3236)
```rust
        let txn = match transaction.check_signature() {
            Ok(t) => t,
            _ => {
                return VMValidatorResult::error(StatusCode::INVALID_SIGNATURE);
            },
```

**File:** aptos-move/framework/aptos-framework/sources/transaction_validation.move (L215-250)
```text
    fun check_for_replay_protection_regular_txn(
        sender_address: address,
        gas_payer_address: address,
        txn_sequence_number: u64,
    ) {
        if (
            sender_address == gas_payer_address
                || account::exists_at(sender_address)
                || !features::sponsored_automatic_account_creation_enabled()
                || txn_sequence_number > 0
        ) {
            assert!(account::exists_at(sender_address), error::invalid_argument(PROLOGUE_EACCOUNT_DOES_NOT_EXIST));
            let account_sequence_number = account::get_sequence_number(sender_address);
            assert!(
                txn_sequence_number < (1u64 << 63),
                error::out_of_range(PROLOGUE_ESEQUENCE_NUMBER_TOO_BIG)
            );

            assert!(
                txn_sequence_number >= account_sequence_number,
                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_OLD)
            );

            assert!(
                txn_sequence_number == account_sequence_number,
                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_NEW)
            );
        } else {
            // In this case, the transaction is sponsored and the account does not exist, so ensure
            // the default values match.
            assert!(
                txn_sequence_number == 0,
                error::invalid_argument(PROLOGUE_ESEQUENCE_NUMBER_TOO_NEW)
            );
        };
    }
```

**File:** aptos-move/aptos-vm/src/transaction_validation.rs (L107-391)
```rust
pub(crate) fn run_script_prologue(
    session: &mut SessionExt<impl AptosMoveResolver>,
    module_storage: &impl ModuleStorage,
    serialized_signers: &SerializedSigners,
    txn_data: &TransactionMetadata,
    features: &Features,
    log_context: &AdapterLogSchema,
    traversal_context: &mut TraversalContext,
    is_simulation: bool,
) -> Result<(), VMStatus> {
    let txn_replay_protector = txn_data.replay_protector();
    let txn_authentication_key = txn_data.authentication_proof().optional_auth_key();
    let txn_gas_price = txn_data.gas_unit_price();
    let txn_max_gas_units = txn_data.max_gas_amount();
    let txn_expiration_timestamp_secs = txn_data.expiration_timestamp_secs();
    let chain_id = txn_data.chain_id();
    let mut gas_meter = UnmeteredGasMeter;

    // Use the new prologues that takes signer from both sender and optional gas payer
    if features.is_account_abstraction_enabled()
        || features.is_derivable_account_abstraction_enabled()
    {
        let secondary_auth_keys: Vec<MoveValue> = txn_data
            .secondary_authentication_proofs
            .iter()
            .map(|auth_key| auth_key.optional_auth_key().as_move_value())
            .collect();
        let replay_protector_move_value = if features.is_transaction_payload_v2_enabled() {
            txn_replay_protector
                .to_move_value()
                .simple_serialize()
                .unwrap()
        } else {
            match txn_replay_protector {
                ReplayProtector::SequenceNumber(seq_num) => {
                    MoveValue::U64(seq_num).simple_serialize().unwrap()
                },
                ReplayProtector::Nonce(_) => {
                    unreachable!("Orderless transactions are discarded already")
                },
            }
        };

        let (prologue_function_name, serialized_args) =
            if let (Some(_fee_payer), Some(fee_payer_auth_key)) = (
                txn_data.fee_payer(),
                txn_data
                    .fee_payer_authentication_proof
                    .as_ref()
                    .map(|proof| proof.optional_auth_key()),
            ) {
                let serialized_args = vec![
                    serialized_signers.sender(),
                    serialized_signers
                        .fee_payer()
                        .ok_or_else(|| VMStatus::error(StatusCode::UNREACHABLE, None))?,
                    txn_authentication_key
                        .as_move_value()
                        .simple_serialize()
                        .unwrap(),
                    fee_payer_auth_key
                        .as_move_value()
                        .simple_serialize()
                        .unwrap(),
                    replay_protector_move_value,
                    MoveValue::vector_address(txn_data.secondary_signers())
                        .simple_serialize()
                        .unwrap(),
                    MoveValue::Vector(secondary_auth_keys)
                        .simple_serialize()
                        .unwrap(),
                    MoveValue::U64(txn_gas_price.into())
                        .simple_serialize()
                        .unwrap(),
                    MoveValue::U64(txn_max_gas_units.into())
                        .simple_serialize()
                        .unwrap(),
                    MoveValue::U64(txn_expiration_timestamp_secs)
                        .simple_serialize()
                        .unwrap(),
                    MoveValue::U8(chain_id.id()).simple_serialize().unwrap(),
                    MoveValue::Bool(is_simulation).simple_serialize().unwrap(),
                ];
                (
                    if features.is_transaction_payload_v2_enabled() {
                        &APTOS_TRANSACTION_VALIDATION.unified_prologue_fee_payer_v2_name
                    } else {
                        &APTOS_TRANSACTION_VALIDATION.unified_prologue_fee_payer_name
                    },
                    serialized_args,
                )
            } else {
                let serialized_args = vec![
                    serialized_signers.sender(),
                    txn_authentication_key
                        .as_move_value()
                        .simple_serialize()
                        .unwrap(),
                    replay_protector_move_value,
                    MoveValue::vector_address(txn_data.secondary_signers())
                        .simple_serialize()
                        .unwrap(),
                    MoveValue::Vector(secondary_auth_keys)
                        .simple_serialize()
                        .unwrap(),
                    MoveValue::U64(txn_gas_price.into())
                        .simple_serialize()
                        .unwrap(),
                    MoveValue::U64(txn_max_gas_units.into())
                        .simple_serialize()
                        .unwrap(),
                    MoveValue::U64(txn_expiration_timestamp_secs)
                        .simple_serialize()
                        .unwrap(),
                    MoveValue::U8(chain_id.id()).simple_serialize().unwrap(),
                    MoveValue::Bool(is_simulation).simple_serialize().unwrap(),
                ];
                (
                    if features.is_transaction_payload_v2_enabled() {
                        &APTOS_TRANSACTION_VALIDATION.unified_prologue_v2_name
                    } else {
                        &APTOS_TRANSACTION_VALIDATION.unified_prologue_name
                    },
                    serialized_args,
                )
            };
        session
            .execute_function_bypass_visibility(
                &APTOS_TRANSACTION_VALIDATION.module_id(),
                prologue_function_name,
                vec![],
                serialized_args,
                &mut gas_meter,
                traversal_context,
                module_storage,
            )
            .map(|_return_vals| ())
            .map_err(expect_no_verification_errors)
            .or_else(|err| convert_prologue_error(err, log_context))
    } else {
        // Txn payload v2 format and orderless transactions are only supported with unified_prologue methods.
        // Old prologue functions do not support these features.
        let txn_sequence_number = match txn_replay_protector {
            ReplayProtector::SequenceNumber(seq_num) => seq_num,
            ReplayProtector::Nonce(_) => {
                return Err(VMStatus::error(
                    StatusCode::FEATURE_UNDER_GATING,
                    Some(
                        "Orderless transactions is not supported without unified_prologue methods"
                            .to_string(),
                    ),
                ));
            },
        };

        let secondary_auth_keys: Vec<MoveValue> = txn_data
            .secondary_authentication_proofs
            .iter()
            .map(|auth_key| MoveValue::vector_u8(auth_key.optional_auth_key().unwrap_or_default()))
            .collect();
        let (prologue_function_name, args) = if let (Some(fee_payer), Some(fee_payer_auth_key)) = (
            txn_data.fee_payer(),
            txn_data
                .fee_payer_authentication_proof
                .as_ref()
                .map(|proof| proof.optional_auth_key()),
        ) {
            if features.is_transaction_simulation_enhancement_enabled() {
                let args = vec![
                    MoveValue::Signer(txn_data.sender),
                    MoveValue::U64(txn_sequence_number),
                    MoveValue::vector_u8(txn_authentication_key.unwrap_or_default()),
                    MoveValue::vector_address(txn_data.secondary_signers()),
                    MoveValue::Vector(secondary_auth_keys),
                    MoveValue::Address(fee_payer),
                    MoveValue::vector_u8(fee_payer_auth_key.unwrap_or_default()),
                    MoveValue::U64(txn_gas_price.into()),
                    MoveValue::U64(txn_max_gas_units.into()),
                    MoveValue::U64(txn_expiration_timestamp_secs),
                    MoveValue::U8(chain_id.id()),
                    MoveValue::Bool(is_simulation),
                ];
                (
                    &APTOS_TRANSACTION_VALIDATION.fee_payer_prologue_extended_name,
                    args,
                )
            } else {
                let args = vec![
                    MoveValue::Signer(txn_data.sender),
                    MoveValue::U64(txn_sequence_number),
                    MoveValue::vector_u8(txn_authentication_key.unwrap_or_default()),
                    MoveValue::vector_address(txn_data.secondary_signers()),
                    MoveValue::Vector(secondary_auth_keys),
                    MoveValue::Address(fee_payer),
                    MoveValue::vector_u8(fee_payer_auth_key.unwrap_or_default()),
                    MoveValue::U64(txn_gas_price.into()),
                    MoveValue::U64(txn_max_gas_units.into()),
                    MoveValue::U64(txn_expiration_timestamp_secs),
                    MoveValue::U8(chain_id.id()),
                ];
                (&APTOS_TRANSACTION_VALIDATION.fee_payer_prologue_name, args)
            }
        } else if txn_data.is_multi_agent() {
            if features.is_transaction_simulation_enhancement_enabled() {
                let args = vec![
                    MoveValue::Signer(txn_data.sender),
                    MoveValue::U64(txn_sequence_number),
                    MoveValue::vector_u8(txn_authentication_key.unwrap_or_default()),
                    MoveValue::vector_address(txn_data.secondary_signers()),
                    MoveValue::Vector(secondary_auth_keys),
                    MoveValue::U64(txn_gas_price.into()),
                    MoveValue::U64(txn_max_gas_units.into()),
                    MoveValue::U64(txn_expiration_timestamp_secs),
                    MoveValue::U8(chain_id.id()),
                    MoveValue::Bool(is_simulation),
                ];
                (
                    &APTOS_TRANSACTION_VALIDATION.multi_agent_prologue_extended_name,
                    args,
                )
            } else {
                let args = vec![
                    MoveValue::Signer(txn_data.sender),
                    MoveValue::U64(txn_sequence_number),
                    MoveValue::vector_u8(txn_authentication_key.unwrap_or_default()),
                    MoveValue::vector_address(txn_data.secondary_signers()),
                    MoveValue::Vector(secondary_auth_keys),
                    MoveValue::U64(txn_gas_price.into()),
                    MoveValue::U64(txn_max_gas_units.into()),
                    MoveValue::U64(txn_expiration_timestamp_secs),
                    MoveValue::U8(chain_id.id()),
                ];
                (
                    &APTOS_TRANSACTION_VALIDATION.multi_agent_prologue_name,
                    args,
                )
            }
        } else {
            #[allow(clippy::collapsible_else_if)]
            if features.is_transaction_simulation_enhancement_enabled() {
                let args = vec![
                    MoveValue::Signer(txn_data.sender),
                    MoveValue::U64(txn_sequence_number),
                    MoveValue::vector_u8(txn_authentication_key.unwrap_or_default()),
                    MoveValue::U64(txn_gas_price.into()),
                    MoveValue::U64(txn_max_gas_units.into()),
                    MoveValue::U64(txn_expiration_timestamp_secs),
                    MoveValue::U8(chain_id.id()),
                    MoveValue::vector_u8(txn_data.script_hash.clone()),
                    MoveValue::Bool(is_simulation),
                ];
                (
                    &APTOS_TRANSACTION_VALIDATION.script_prologue_extended_name,
                    args,
                )
            } else {
                let args = vec![
                    MoveValue::Signer(txn_data.sender),
                    MoveValue::U64(txn_sequence_number),
                    MoveValue::vector_u8(txn_authentication_key.unwrap_or_default()),
                    MoveValue::U64(txn_gas_price.into()),
                    MoveValue::U64(txn_max_gas_units.into()),
                    MoveValue::U64(txn_expiration_timestamp_secs),
                    MoveValue::U8(chain_id.id()),
                    MoveValue::vector_u8(txn_data.script_hash.clone()),
                ];
                (&APTOS_TRANSACTION_VALIDATION.script_prologue_name, args)
            }
        };

        session
            .execute_function_bypass_visibility(
                &APTOS_TRANSACTION_VALIDATION.module_id(),
                prologue_function_name,
                vec![],
                serialize_values(&args),
                &mut gas_meter,
                traversal_context,
                module_storage,
            )
            .map(|_return_vals| ())
            .map_err(expect_no_verification_errors)
            .or_else(|err| convert_prologue_error(err, log_context))
    }
}
```
