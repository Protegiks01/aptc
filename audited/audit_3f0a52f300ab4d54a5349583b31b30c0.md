# Audit Report

## Title
Missing Decompression CPU Time Validation in Indexer gRPC Fullnode Service

## Summary
The indexer-grpc-fullnode service accepts compressed gRPC requests via Zstd and Gzip without explicit decompression CPU time limits or appropriate message size configuration, potentially allowing attackers to cause CPU exhaustion through pathological compressed payloads.

## Finding Description

The `bootstrap()` function in `ecosystem/indexer-grpc/indexer-grpc-fullnode/src/runtime.rs` configures gRPC services to accept compressed requests without setting explicit message size limits or decompression timeouts. [1](#0-0) [2](#0-1) 

The services use tonic's default `max_decoding_message_size` of 4MB without explicit configuration, and no request-level timeouts are set beyond HTTP2 keepalive settings. [3](#0-2) 

In contrast, other indexer-grpc services explicitly configure message size limits. For example, the data-service-v2 sets `MAX_MESSAGE_SIZE` (256MB) on both decoding and encoding: [4](#0-3) [5](#0-4) 

The attack vector involves sending specially crafted compressed payloads that require excessive CPU cycles to decompress, even if the decompressed size stays within the 4MB limit. This could exploit algorithmic complexity weaknesses in compression algorithms or nested compression patterns.

The actual request messages are minimal in size: [6](#0-5) 

Despite their small legitimate size, an attacker could craft pathological compressed data designed to maximize decompression CPU time while staying under size limits.

## Impact Explanation

This falls under **Medium severity** based on the Aptos bug bounty criteria:
- Service degradation affecting indexer API availability
- Potential CPU exhaustion on fullnodes running the indexer service
- Not directly affecting consensus, funds, or validator operations
- Limited to DoS on the indexer gRPC interface

The indexer service, while important for ecosystem tooling, is not consensus-critical and runs as an optional component on fullnodes.

## Likelihood Explanation

**Likelihood: Low to Medium**

While the technical possibility exists, several factors reduce likelihood:
- Modern compression libraries (zstd, gzip) have internal safeguards
- The 4MB decompressed size limit provides some boundary
- Request messages are legitimately tiny (two uint64 fields)
- Requires crafting pathological compression patterns
- Impact limited to optional indexer service, not core blockchain

However, compression bomb attacks are well-documented, and the lack of explicit protections represents a security gap compared to other similar services in the codebase.

## Recommendation

Add explicit message size limits and consider request-level timeouts:

```rust
let svc = FullnodeDataServer::new(server)
    .send_compressed(CompressionEncoding::Zstd)
    .accept_compressed(CompressionEncoding::Zstd)
    .accept_compressed(CompressionEncoding::Gzip)
    .max_decoding_message_size(MAX_MESSAGE_SIZE)  // Add explicit limit
    .max_encoding_message_size(MAX_MESSAGE_SIZE);
```

Define `MAX_MESSAGE_SIZE` similar to other indexer services:
```rust
const MAX_MESSAGE_SIZE: usize = 256 * (1 << 20); // 256 MB
```

Additionally, consider adding request-level timeout using `Server::builder().timeout()` as demonstrated in other services: [7](#0-6) 

## Proof of Concept

While a full PoC would require crafting pathological compression data, the configuration gap can be demonstrated:

```rust
// Current vulnerable configuration (no explicit limits)
let svc = FullnodeDataServer::new(server)
    .accept_compressed(CompressionEncoding::Zstd); // Uses 4MB default only

// An attacker could send a request that:
// 1. Has small compressed size (< 4MB compressed)
// 2. Decompresses to < 4MB uncompressed
// 3. But requires O(nÂ²) or worse CPU time to decompress
// 4. Exploits algorithmic complexity in decompression
```

To test, send gRPC requests with nested compression patterns or repetitive back-references designed to maximize decompression cycles while staying under size limits.

## Notes

The vulnerability exists as a **configuration oversight** rather than a fundamental flaw. The primary concern is the inconsistency with other indexer-grpc services that explicitly set limits. While modern compression libraries provide some protection, defense-in-depth principles suggest explicit limits should be configured at the application layer.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/runtime.rs (L101-104)
```rust
        let tonic_server = Server::builder()
            .http2_keepalive_interval(Some(std::time::Duration::from_secs(60)))
            .http2_keepalive_timeout(Some(std::time::Duration::from_secs(5)))
            .add_service(reflection_service_clone);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/runtime.rs (L108-111)
```rust
                let svc = FullnodeDataServer::new(server)
                    .send_compressed(CompressionEncoding::Zstd)
                    .accept_compressed(CompressionEncoding::Zstd)
                    .accept_compressed(CompressionEncoding::Gzip);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-fullnode/src/runtime.rs (L115-118)
```rust
                let svc = RawDataServer::new(localnet_data_server)
                    .send_compressed(CompressionEncoding::Zstd)
                    .accept_compressed(CompressionEncoding::Zstd)
                    .accept_compressed(CompressionEncoding::Gzip);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/config.rs (L31-31)
```rust
pub(crate) const MAX_MESSAGE_SIZE: usize = 256 * (1 << 20);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/config.rs (L240-241)
```rust
                .max_decoding_message_size(MAX_MESSAGE_SIZE)
                .max_encoding_message_size(MAX_MESSAGE_SIZE);
```

**File:** protos/proto/aptos/internal/fullnode/v1/fullnode_data.proto (L37-45)
```text
message GetTransactionsFromNodeRequest {
  // Required; start version of current stream.
  // If not set will panic somewhere
  optional uint64 starting_version = 1 [jstype = JS_STRING];

  // Optional; number of transactions to return in current stream.
  // If not set, response streams infinitely.
  optional uint64 transactions_count = 2 [jstype = JS_STRING];
}
```

**File:** secure/net/src/grpc_network_service/mod.rs (L75-76)
```rust
        Server::builder()
            .timeout(std::time::Duration::from_millis(rpc_timeout_ms))
```
