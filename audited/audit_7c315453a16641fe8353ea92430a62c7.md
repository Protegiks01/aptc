# Audit Report

## Title
Missing HTTP Timeout Configuration in Warp Webserver Enables Slowloris Resource Exhaustion Attack

## Summary
The `WebServer::serve()` function in `aptos-warp-webserver` lacks connection and request timeout configuration, allowing slowloris attacks to exhaust system resources. This affects the Rosetta API service which can be deployed alongside fullnodes or validators.

## Finding Description
The `serve()` function directly invokes warp's HTTP server without configuring any connection, request header, or request body timeouts. [1](#0-0) 

The warp webserver is exclusively used by the aptos-rosetta service. [2](#0-1)  The Rosetta implementation can operate in three modes, including an "Online" mode that runs a local Aptos node alongside the Rosetta API server. [3](#0-2) 

In this deployment mode, both the node (which can be configured as a validator via `AptosNodeArgs`) and the Rosetta HTTP server run in the same process. [4](#0-3) 

**Attack Path:**
1. Attacker opens multiple HTTP connections to the Rosetta API (default port 8082)
2. Sends partial HTTP request headers very slowly (e.g., one byte every 10 seconds)
3. Keeps connections alive indefinitely without completing requests
4. Exhausts server connection pool, file descriptors, and memory
5. Prevents legitimate API clients from connecting
6. If Rosetta runs on the same machine as validator infrastructure, resource exhaustion impacts validator operations

This breaks **Invariant #9** (Resource Limits): "All operations must respect gas, storage, and computational limits." The webserver fails to enforce time-based resource limits on HTTP connections.

## Impact Explanation
Per the Aptos bug bounty program, this qualifies as **High Severity** under two categories:
- **"API crashes"**: The Rosetta API becomes unavailable due to connection pool exhaustion
- **"Validator node slowdowns"**: If deployed on shared infrastructure, resource exhaustion affects validator consensus participation, block production, and network communication

While the Rosetta documentation describes it as a "sidecar to an Aptos fullnode" [5](#0-4) , the code architecture allows running it alongside validator nodes in the same process/container, making this a realistic threat to validator infrastructure.

This is **not** a network-level DoS (which would be out of scope), but an **application-level vulnerability** requiring a code fix to implement proper timeout configuration.

## Likelihood Explanation
**High Likelihood:**
- Slowloris is a well-documented HTTP DoS technique with publicly available tools (slowhttptest, slowloris.py)
- No authentication required to open HTTP connections to Rosetta API
- Default deployment exposes Rosetta on `0.0.0.0:8082` [6](#0-5) 
- Attack requires minimal resources (single attacking machine can exhaust target server)
- No rate limiting or connection timeout protection at application layer

## Recommendation
Implement HTTP timeout configuration in the `WebServer::serve()` function. Since warp is built on hyper, timeout configuration requires using hyper's server builder directly:

```rust
pub async fn serve<F>(&self, routes: F)
where
    F: Filter<Error = Infallible> + Clone + Sync + Send + 'static,
    F::Extract: Reply,
{
    // Add timeout configurations
    let server = warp::serve(routes)
        .bind_with_graceful_shutdown(self.address, async {
            // Configure via hyper's builder
        });
    
    // Alternative: Add configuration fields to WebServer struct:
    // - connection_timeout: Duration (e.g., 60 seconds)
    // - header_read_timeout: Duration (e.g., 10 seconds)  
    // - request_body_timeout: Duration (e.g., 30 seconds)
    // - keep_alive_timeout: Duration (e.g., 5 seconds)
}
```

Update `ApiConfig` to expose timeout configuration options. [7](#0-6) 

For immediate mitigation, deploy Rosetta behind HAProxy or similar reverse proxy with configured timeouts. The existing HAProxy configurations show proper timeout settings but only apply to other services. [8](#0-7) 

## Proof of Concept
```bash
# Install slowhttptest tool
# Ubuntu/Debian: apt-get install slowhttptest
# macOS: brew install slowhttptest

# Run Rosetta API in Online mode
# (assuming aptos-rosetta binary is built and fullnode.yaml configured)
./target/release/aptos-rosetta online \
  --config fullnode.yaml \
  --listen-address 0.0.0.0:8082

# From attacker machine, execute slowloris attack:
slowhttptest -c 1000 -H -g -o slowloris_results \
  -i 10 -r 200 -t GET -u http://<target-ip>:8082/network/list \
  -x 240 -p 3

# Parameters:
# -c 1000: Open 1000 connections
# -H: Slowloris mode (slow headers)
# -i 10: 10 second interval between bytes
# -r 200: Connections per second rate
# -x 240: Run for 240 seconds
# -p 3: Pipeline depth

# Expected result:
# - Rosetta API becomes unresponsive
# - Legitimate requests timeout or fail to connect  
# - Server resources (connections, memory) exhausted
# - If running on same machine as validator: metrics show degraded performance
```

**Validation**: Monitor server metrics during attack:
- `netstat -an | grep :8082 | wc -l` (connection count increases)
- `ss -s` (TCP memory usage increases)
- System CPU/memory usage spikes
- Legitimate API requests fail with connection timeout errors

## Notes
- This vulnerability exists in application code and requires an application-level fix (timeout configuration), distinguishing it from out-of-scope network-level DoS attacks
- The Rosetta service is primarily intended for fullnodes, but the code architecture permits validator deployment
- Proper operational practice involves deploying Rosetta on separate infrastructure, but the code does not enforce this
- Other Aptos services using hyper directly (admin-service, inspection-service) bind servers without explicit timeout configuration but use different frameworks that may have different default behaviors

### Citations

**File:** crates/aptos-warp-webserver/src/webserver.rs (L34-50)
```rust
    pub async fn serve<F>(&self, routes: F)
    where
        F: Filter<Error = Infallible> + Clone + Sync + Send + 'static,
        F::Extract: Reply,
    {
        match &self.tls_cert_path {
            None => warp::serve(routes).bind(self.address).await,
            Some(cert_path) => {
                warp::serve(routes)
                    .tls()
                    .cert_path(cert_path)
                    .key_path(self.tls_key_path.as_ref().unwrap())
                    .bind(self.address)
                    .await
            },
        }
    }
```

**File:** crates/aptos-rosetta/src/lib.rs (L17-17)
```rust
use aptos_warp_webserver::{logger, Error, WebServer};
```

**File:** crates/aptos-rosetta/src/main.rs (L50-83)
```rust
    let _maybe_node = if let CommandArgs::Online(OnlineLocalArgs {
        ref node_args,
        ref online_args,
    }) = args
    {
        println!("aptos-rosetta: Starting local full node");
        let node_args = node_args.clone();
        let runtime = thread::spawn(move || node_args.run());

        // Wait and ensure the node is running on the URL
        let client = aptos_rest_client::Client::new(online_args.rest_api_url.clone());
        let start = Instant::now();
        loop {
            match client.get_index_bcs().await {
                Ok(_) => {
                    break;
                },
                Err(err) => {
                    sample!(
                        SampleRate::Duration(Duration::from_millis(LOG_INTERVAL_MS)),
                        println!(
                            "aptos-rosetta: Full node REST API isn't responding yet.  You should check the node logs.  It's been waiting {} seconds.  Error: {:?}",
                            start.elapsed().as_secs(),
                            err
                        )
                    );
                    tokio::time::sleep(Duration::from_millis(DEFAULT_REST_API_WAIT_INTERVAL_MS))
                        .await;
                },
            }
        }

        println!("aptos-rosetta: Local full node started successfully");
        Some(runtime)
```

**File:** crates/aptos-rosetta/src/main.rs (L174-175)
```rust
    #[clap(long, default_value = "0.0.0.0:8082")]
    listen_address: SocketAddr,
```

**File:** crates/aptos-rosetta/src/main.rs (L306-312)
```rust
#[derive(Debug, Parser)]
pub struct OnlineLocalArgs {
    #[clap(flatten)]
    online_args: OnlineRemoteArgs,
    #[clap(flatten)]
    node_args: AptosNodeArgs,
}
```

**File:** crates/aptos-rosetta/README.md (L9-10)
```markdown
[Rosetta](https://en.wikipedia.org/wiki/Rosetta_(software)) works as a sidecar to an Aptos fullnode.  Rosetta then proxies the Rosetta standard
API calls to underlying Aptos REST API calls and builds the appropriate data.  
```

**File:** config/src/config/api_config.rs (L17-93)
```rust
pub struct ApiConfig {
    /// Enables the REST API endpoint
    #[serde(default = "default_enabled")]
    pub enabled: bool,
    /// Address for the REST API to listen on. Set to 0.0.0.0:port to allow all inbound connections.
    pub address: SocketAddr,
    /// Path to a local TLS certificate to enable HTTPS
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_cert_path: Option<String>,
    /// Path to a local TLS key to enable HTTPS
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub tls_key_path: Option<String>,
    /// A maximum limit to the body of a POST request in bytes
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub content_length_limit: Option<u64>,
    /// Enables failpoints for error testing
    #[serde(default = "default_disabled")]
    pub failpoints_enabled: bool,
    /// Enables JSON output of APIs that support it
    #[serde(default = "default_enabled")]
    pub json_output_enabled: bool,
    /// Enables BCS output of APIs that support it
    #[serde(default = "default_enabled")]
    pub bcs_output_enabled: bool,
    /// Enables compression middleware for API responses
    #[serde(default = "default_enabled")]
    pub compression_enabled: bool,
    /// Enables encode submission API
    #[serde(default = "default_enabled")]
    pub encode_submission_enabled: bool,
    /// Enables transaction submission APIs
    #[serde(default = "default_enabled")]
    pub transaction_submission_enabled: bool,
    /// Enables transaction simulation
    #[serde(default = "default_enabled")]
    pub transaction_simulation_enabled: bool,
    /// Maximum number of transactions that can be sent with the Batch submit API
    pub max_submit_transaction_batch_size: usize,
    /// Maximum page size for transaction paginated APIs
    pub max_transactions_page_size: u16,
    /// Maximum page size for block transaction APIs
    pub max_block_transactions_page_size: u16,
    /// Maximum page size for event paginated APIs
    pub max_events_page_size: u16,
    /// Maximum page size for resource paginated APIs
    pub max_account_resources_page_size: u16,
    /// Maximum page size for module paginated APIs
    pub max_account_modules_page_size: u16,
    /// Maximum gas unit limit for view functions
    ///
    /// This limits the execution length of a view function to the given gas used.
    pub max_gas_view_function: u64,
    /// Optional: Maximum number of worker threads for the API.
    ///
    /// If not set, `runtime_worker_multiplier` will multiply times the number of CPU cores on the machine
    pub max_runtime_workers: Option<usize>,
    /// Multiplier for number of worker threads with number of CPU cores
    ///
    /// If `max_runtime_workers` is set, this is ignored
    pub runtime_worker_multiplier: usize,
    /// Configs for computing unit gas price estimation
    pub gas_estimation: GasEstimationConfig,
    /// Periodically call gas estimation
    pub periodic_gas_estimation_ms: Option<u64>,
    /// Configuration to filter view function requests.
    pub view_filter: ViewFilter,
    /// Periodically log stats for view function and simulate transaction usage
    pub periodic_function_stats_sec: Option<u64>,
    /// The time wait_by_hash will wait before returning 404.
    pub wait_by_hash_timeout_ms: u64,
    /// The interval at which wait_by_hash will poll the storage for the transaction.
    pub wait_by_hash_poll_interval_ms: u64,
    /// The number of active wait_by_hash requests that can be active at any given time.
    pub wait_by_hash_max_active_connections: usize,
    /// Allow submission of encrypted transactions via the API
    pub allow_encrypted_txns_submission: bool,
}
```

**File:** docker/compose/aptos-node/haproxy.cfg (L1-30)
```text
# Config manual: https://www.haproxy.com/documentation/haproxy-configuration-manual/latest/

## Global settings
global
    # Specify the stdout log format and size
    log stdout len 10240 format raw local0

    # Limit the maximum number of connections to 500 (this is ~5x the validator set size)
    maxconn 500

    # Limit the maximum number of connections per second to 300 (this is ~3x the validator set size)
    maxconnrate 300

    # Limit user privileges
    user haproxy

## Default settings
defaults
    # Enable logging of events and traffic
    log global

    # Set the default mode to TCP
    mode tcp

    # Don't log normal events
    option dontlog-normal

    # Set timeouts for connections
    timeout client 60s
    timeout connect 10s
```
