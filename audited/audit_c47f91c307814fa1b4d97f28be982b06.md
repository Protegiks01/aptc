# Audit Report

## Title
Conditional SyncInfo Verification Leads to Consensus Safety Violation via State-Dependent Acceptance

## Summary
The `verify_well_formed()` function in ProposalMsg does not cryptographically verify the SyncInfo's `highest_quorum_cert` (HQC), `highest_ordered_cert`, and `highest_commit_cert` fields. Full verification only occurs in `sync_up()` when `has_newer_certificates()` returns true, which depends on each node's local state. A malicious proposer can craft a ProposalMsg with forged SyncInfo certificates that will be accepted by some nodes (where `has_newer_certificates()` returns false) but rejected by others (where it returns true and verification fails), causing consensus divergence.

## Finding Description

The vulnerability exists in how ProposalMsg verification is split between multiple functions: [1](#0-0) 

The `verify_well_formed()` function performs structural consistency checks but does NOT cryptographically verify the SyncInfo's certificates. It only checks that the epoch matches and that the HQC's certified block ID matches the proposal's parent ID, without verifying the HQC's signatures. [2](#0-1) 

The `verify()` method only verifies the `highest_2chain_timeout_cert` if present, then calls `verify_well_formed()`. The comment at line 116 explicitly states "we postpone the verification of SyncInfo until it's being used." [3](#0-2) 

The actual SyncInfo verification happens in `sync_up()`, but ONLY when `has_newer_certificates()` returns true (line 880). If false, the function returns `Ok(())` without any verification (line 905). [4](#0-3) 

When verification does occur, it cryptographically verifies all certificates including the HQC (line 188). If signatures are invalid, this verification fails.

**Attack Path:**

1. Due to normal network asynchrony, different honest nodes have different local states:
   - Node A has local HQC at round 100
   - Node B has local HQC at round 95

2. A malicious proposer (legitimately elected for round 101) creates a ProposalMsg:
   - Valid proposal Block with valid QC for round 100
   - **Forged** SyncInfo with HQC for round 98 containing **invalid signatures** but correct certified_block ID

3. Both nodes receive the proposal:
   - **Node A**: `has_newer_certificates()` returns false (98 â‰¤ 100), skips verification, **accepts proposal**
   - **Node B**: `has_newer_certificates()` returns true (98 > 95), performs verification, **rejects proposal**

4. **Result**: Consensus divergence where honest nodes disagree on the same proposal's validity.

This violates the **Consensus Safety** invariant: all honest validators must agree on block validity regardless of their synchronization state.

## Impact Explanation

**Severity: Critical** (Consensus/Safety violations)

This vulnerability breaks the fundamental safety property of AptosBFT consensus. When different honest nodes make different decisions about the same proposal based solely on their local synchronization state, it can lead to:

1. **Chain splits**: Different validators may commit different blocks at the same round
2. **Double-spending**: Conflicting transactions could be committed on different forks
3. **Network partition**: The validator set may permanently split into groups with incompatible states

This meets the **Critical Severity** criteria from the Aptos bug bounty program as it directly violates consensus safety and could lead to a non-recoverable network partition requiring a hardfork to resolve.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to occur because:

1. **Normal operation triggers the bug**: Network asynchrony causing different local states is expected and common in distributed systems
2. **No special attacker capabilities required**: Any validator who becomes the legitimate proposer through normal round rotation can exploit this
3. **No detection mechanism**: The conditional verification appears intentional (per the code comment), so monitoring systems won't flag it
4. **Persistent condition**: As long as the network has any asynchrony, nodes will have different local states, making the attack consistently exploitable

The attack requires the malicious validator to be the proposer for a round, which happens automatically through the consensus protocol's proposer rotation.

## Recommendation

**Fix: Always verify SyncInfo before accepting a ProposalMsg**

The SyncInfo verification should be unconditional and occur during the initial message verification phase, not postponed to `sync_up()`. Modify the `verify()` method in `ProposalMsg`:

```rust
pub fn verify(
    &self,
    sender: Author,
    validator: &ValidatorVerifier,
    proof_cache: &ProofCache,
    quorum_store_enabled: bool,
) -> Result<()> {
    // ... existing author and payload verification ...
    
    // ALWAYS verify SyncInfo, not just the timeout cert
    self.sync_info.verify(validator)
        .context("Failed to verify SyncInfo in ProposalMsg")?;
    
    self.verify_well_formed()
}
```

This ensures that all nodes perform the same cryptographic verification regardless of their local state, maintaining consensus safety. The `sync_up()` function can then safely use the already-verified SyncInfo to update local state when `has_newer_certificates()` is true.

## Proof of Concept

```rust
// Integration test demonstrating the vulnerability
#[tokio::test]
async fn test_syncinfo_conditional_verification_divergence() {
    // Setup two validators with different local states
    let mut validator_a = create_validator_at_round(100); // HQC at round 100
    let mut validator_b = create_validator_at_round(95);  // HQC at round 95
    
    // Create a valid proposal for round 101
    let valid_proposal = create_proposal(101, parent_qc_round_100);
    
    // Create FORGED SyncInfo with invalid signatures but correct structure
    let forged_syncinfo = SyncInfo::new(
        create_forged_qc_round_98(), // Invalid signatures!
        create_ledger_info(98),
        None, // No TC
    );
    
    let malicious_proposal_msg = ProposalMsg::new(
        valid_proposal.clone(),
        forged_syncinfo,
    );
    
    // Verify with validator verifier (passes verify_well_formed)
    assert!(malicious_proposal_msg.verify_well_formed().is_ok());
    
    // Process at both nodes
    let result_a = validator_a.process_proposal_msg(malicious_proposal_msg.clone()).await;
    let result_b = validator_b.process_proposal_msg(malicious_proposal_msg.clone()).await;
    
    // VULNERABILITY: Different outcomes based on local state!
    // Node A: has_newer_certificates() = false (98 <= 100), accepts
    assert!(result_a.is_ok(), "Node A accepted proposal");
    
    // Node B: has_newer_certificates() = true (98 > 95), verifies and rejects
    assert!(result_b.is_err(), "Node B rejected proposal");
    
    // This demonstrates consensus divergence!
    println!("CONSENSUS SAFETY VIOLATED: Nodes disagree on proposal validity");
}
```

**Notes:**

The vulnerability stems from the architectural decision to postpone SyncInfo verification until it's "used" (when `has_newer_certificates()` is true). However, this creates a state-dependent verification path that violates the deterministic execution requirement for consensus protocols. All honest nodes must make identical decisions about message validity regardless of their local synchronization state to maintain consensus safety.

### Citations

**File:** consensus/consensus-types/src/proposal_msg.rs (L33-80)
```rust
    pub fn verify_well_formed(&self) -> Result<()> {
        ensure!(
            !self.proposal.is_nil_block(),
            "Proposal {} for a NIL block",
            self.proposal
        );
        self.proposal
            .verify_well_formed()
            .context("Fail to verify ProposalMsg's block")?;
        ensure!(
            self.proposal.round() > 0,
            "Proposal for {} has an incorrect round of 0",
            self.proposal,
        );
        ensure!(
            self.proposal.epoch() == self.sync_info.epoch(),
            "ProposalMsg has different epoch number from SyncInfo"
        );
        ensure!(
            self.proposal.parent_id()
                == self.sync_info.highest_quorum_cert().certified_block().id(),
            "Proposal HQC in SyncInfo certifies {}, but block parent id is {}",
            self.sync_info.highest_quorum_cert().certified_block().id(),
            self.proposal.parent_id(),
        );
        let previous_round = self
            .proposal
            .round()
            .checked_sub(1)
            .ok_or_else(|| anyhow!("proposal round overflowed!"))?;

        let highest_certified_round = std::cmp::max(
            self.proposal.quorum_cert().certified_block().round(),
            self.sync_info.highest_timeout_round(),
        );
        ensure!(
            previous_round == highest_certified_round,
            "Proposal {} does not have a certified round {}",
            self.proposal,
            previous_round
        );
        ensure!(
            self.proposal.author().is_some(),
            "Proposal {} does not define an author",
            self.proposal
        );
        Ok(())
    }
```

**File:** consensus/consensus-types/src/proposal_msg.rs (L82-118)
```rust
    pub fn verify(
        &self,
        sender: Author,
        validator: &ValidatorVerifier,
        proof_cache: &ProofCache,
        quorum_store_enabled: bool,
    ) -> Result<()> {
        if let Some(proposal_author) = self.proposal.author() {
            ensure!(
                proposal_author == sender,
                "Proposal author {:?} doesn't match sender {:?}",
                proposal_author,
                sender
            );
        }
        let (payload_result, sig_result) = rayon::join(
            || {
                self.proposal().payload().map_or(Ok(()), |p| {
                    p.verify(validator, proof_cache, quorum_store_enabled)
                })
            },
            || {
                self.proposal()
                    .validate_signature(validator)
                    .map_err(|e| format_err!("{:?}", e))
            },
        );
        payload_result?;
        sig_result?;

        // if there is a timeout certificate, verify its signatures
        if let Some(tc) = self.sync_info.highest_2chain_timeout_cert() {
            tc.verify(validator).map_err(|e| format_err!("{:?}", e))?;
        }
        // Note that we postpone the verification of SyncInfo until it's being used.
        self.verify_well_formed()
    }
```

**File:** consensus/src/round_manager.rs (L878-907)
```rust
    async fn sync_up(&mut self, sync_info: &SyncInfo, author: Author) -> anyhow::Result<()> {
        let local_sync_info = self.block_store.sync_info();
        if sync_info.has_newer_certificates(&local_sync_info) {
            info!(
                self.new_log(LogEvent::ReceiveNewCertificate)
                    .remote_peer(author),
                "Local state {},\n remote state {}", local_sync_info, sync_info
            );
            // Some information in SyncInfo is ahead of what we have locally.
            // First verify the SyncInfo (didn't verify it in the yet).
            sync_info.verify(&self.epoch_state.verifier).map_err(|e| {
                error!(
                    SecurityEvent::InvalidSyncInfoMsg,
                    sync_info = sync_info,
                    remote_peer = author,
                    error = ?e,
                );
                VerifyError::from(e)
            })?;
            SYNC_INFO_RECEIVED_WITH_NEWER_CERT.inc();
            let result = self
                .block_store
                .add_certs(sync_info, self.create_block_retriever(author))
                .await;
            self.process_certificates().await?;
            result
        } else {
            Ok(())
        }
    }
```

**File:** consensus/consensus-types/src/sync_info.rs (L187-211)
```rust
        self.highest_quorum_cert
            .verify(validator)
            .and_then(|_| {
                self.highest_ordered_cert
                    .as_ref()
                    .map_or(Ok(()), |cert| cert.verify(validator))
                    .context("Fail to verify ordered certificate")
            })
            .and_then(|_| {
                // we do not verify genesis ledger info
                if self.highest_commit_cert.commit_info().round() > 0 {
                    self.highest_commit_cert
                        .verify(validator)
                        .context("Fail to verify commit certificate")?
                }
                Ok(())
            })
            .and_then(|_| {
                if let Some(tc) = &self.highest_2chain_timeout_cert {
                    tc.verify(validator)?;
                }
                Ok(())
            })
            .context("Fail to verify SyncInfo")?;
        Ok(())
```
