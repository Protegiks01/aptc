# Audit Report

## Title
Event V2 Translation Feature Flag Bypass in Indexer Event Query Path

## Summary
The `get_events_by_event_key()` method in the indexer reader bypasses the `event_v2_translation_enabled()` feature flag check, allowing access to translated V2 events even when translation functionality is disabled. This violates access control invariants and can expose stale or inconsistent translation data.

## Finding Description

The indexer provides a feature flag `event_v2_translation_enabled()` to control Event V2-to-V1 translation functionality. This flag is intended to gate access to translation features, as evidenced by the explicit check in `get_translated_v1_event_by_version_and_index()`: [1](#0-0) 

However, the `get_events_by_event_key()` method only checks `event_enabled()` but not `event_v2_translation_enabled()`: [2](#0-1) 

This method delegates to the underlying `DBIndexer::get_events_by_event_key()`, which unconditionally attempts to access translated events when V2 events are encountered: [3](#0-2) 

The bypass occurs because there is no `event_v2_translation_enabled()` check before calling `get_translated_v1_event_by_version_and_index()` at line 701-702, directly accessing the `TranslatedV1EventSchema` database.

**Attack Scenario:**

1. Event V2 translation is enabled and events are indexed with translations based on blockchain state at version N
2. A bug is discovered in the translation logic producing incorrect event keys or sequence numbers
3. Administrator disables `event_v2_translation_enabled()` to prevent new buggy translations
4. Attacker can still access the buggy translated events via `get_events_by_event_key()` API
5. Applications consuming this data may make incorrect decisions based on malformed event information

The feature flag's purpose is violated—it should protect ALL access to translation data, but the bypass path allows continued access to potentially stale, buggy, or inconsistent translations.

## Impact Explanation

This issue meets **Medium severity** criteria per the Aptos bug bounty program: "State inconsistencies requiring intervention."

The bypass creates multiple data consistency problems:

1. **Inconsistent Access Control**: The same translated event data is accessible via one API path but blocked via another, violating the principle of defense in depth

2. **Stale Translation Data**: Translated events are computed using blockchain state at translation time. If the flag is disabled after translation and blockchain state changes, the bypass allows accessing translations with event keys and sequence numbers that may no longer match current resource states

3. **Partial Translation State**: If translation is interrupted mid-process and then disabled, some V2 events have translations while others don't. The bypass causes queries to return inconsistent results—some events succeed, others fail with "NotFound" errors

4. **Buggy Data Exposure**: If translation logic contains bugs (e.g., incorrect event key derivation) and the flag is disabled as a mitigation, the bypass still exposes the buggy data

While this doesn't directly affect blockchain consensus or validator operations, it violates API data integrity guarantees and could require manual database intervention to clean up inconsistent indexer state.

## Likelihood Explanation

**Likelihood: Medium-High**

This vulnerability can be triggered by any API consumer through normal query operations. No special privileges are required. The conditions for exploitation are:

1. `event_enabled()` is true (standard configuration)
2. `event_v2_translation_enabled()` is false (deliberate configuration choice)
3. Translated event data exists in `TranslatedV1EventSchema` from previous indexing runs
4. Attacker calls `get_events_by_event_key()` with event keys that have V2 events

The vulnerability is structural—it exists in the code path design, not in rare edge cases. Any environment where the translation flag is toggled (common during feature rollout, bug mitigation, or configuration changes) will exhibit this behavior.

## Recommendation

Add a feature flag check before attempting to access translated events in the query path. The fix should be applied in `DBIndexer::get_events_by_event_key()`:

**File: storage/indexer/src/db_indexer.rs (lines 694-704)**

```rust
let event = match self
    .main_db_reader
    .get_event_by_version_and_index(ver, idx)?
{
    event @ ContractEvent::V1(_) => event,
    ContractEvent::V2(_) => {
        // Check feature flag before accessing translated events
        if !self.indexer_db.event_v2_translation_enabled() {
            bail!("Event V2 translation is not enabled");
        }
        ContractEvent::V1(
            self.indexer_db
                .get_translated_v1_event_by_version_and_index(ver, idx)?,
        )
    },
};
```

Additionally, consider whether the flag should control only new translations (indexing-time) or also access to existing translations (query-time). Document this behavior clearly and ensure consistent enforcement across all code paths.

## Proof of Concept

```rust
// This PoC demonstrates the bypass by showing two different code paths
// with inconsistent feature flag enforcement

use aptos_types::event::EventKey;
use aptos_indexer::indexer_reader::IndexerReaders;

#[test]
fn test_event_translation_bypass() {
    // Setup: Create indexer with translation DISABLED
    let config = InternalIndexerDBConfig {
        enable_event: true,
        enable_event_v2_translation: false,  // Translation DISABLED
        // ... other config
    };
    
    let indexer_readers = IndexerReaders::new(
        None,
        Some(Arc::new(DBIndexer::new(indexer_db, db_reader)))
    ).unwrap();
    
    // Assume translated events exist in database from previous run
    // when translation was enabled
    
    let event_key = EventKey::new(2, test_account);
    
    // Path 1: Direct call - BLOCKED by feature flag check
    let result1 = indexer_readers.get_translated_v1_event_by_version_and_index(
        version, index
    );
    assert!(result1.is_err());  // Correctly blocked: "Event translation is not enabled"
    
    // Path 2: Indirect call via get_events_by_event_key - BYPASS
    let result2 = indexer_readers.get_events_by_event_key(
        &event_key,
        0,      // start_seq_num
        Order::Ascending,
        10,     // limit
        version // ledger_version
    );
    
    // BUG: This succeeds even though event_v2_translation_enabled() is false!
    // It accesses the same translated event data through a different path
    assert!(result2.is_ok());  // Bypass successful - inconsistent behavior
    
    // The same data is accessible via one path but not the other,
    // violating the feature flag's access control purpose
}
```

**Notes**

The vulnerability exists in the architectural design of the indexer's access control. The feature flag `event_v2_translation_enabled()` is checked at the API boundary for direct translation access but not for the query path that internally accesses the same translated data. This creates an inconsistency where the flag's protection can be circumvented through an indirect code path.

The translation process reads blockchain state to derive event keys and sequence numbers [4](#0-3) , making translated events dependent on blockchain state at translation time. Accessing stale translations when the flag is disabled could return events with metadata that no longer matches current on-chain resources.

The validation check at the query level [5](#0-4)  provides some protection by verifying sequence number consistency, but this only catches certain types of inconsistencies and does not prevent all forms of stale data access.

### Citations

**File:** storage/indexer/src/indexer_reader.rs (L92-114)
```rust
    fn get_events_by_event_key(
        &self,
        event_key: &EventKey,
        start_seq_num: u64,
        order: Order,
        limit: u64,
        ledger_version: Version,
    ) -> anyhow::Result<Vec<EventWithVersion>> {
        if let Some(db_indexer_reader) = &self.db_indexer_reader {
            if db_indexer_reader.indexer_db.event_enabled() {
                return Ok(db_indexer_reader.get_events_by_event_key(
                    event_key,
                    start_seq_num,
                    order,
                    limit,
                    ledger_version,
                )?);
            } else {
                anyhow::bail!("Internal event index is not enabled")
            }
        }
        anyhow::bail!("DB indexer reader is not available")
    }
```

**File:** storage/indexer/src/indexer_reader.rs (L168-183)
```rust
    fn get_translated_v1_event_by_version_and_index(
        &self,
        version: Version,
        index: u64,
    ) -> anyhow::Result<ContractEventV1> {
        if let Some(db_indexer_reader) = &self.db_indexer_reader {
            if db_indexer_reader.indexer_db.event_v2_translation_enabled() {
                return Ok(db_indexer_reader
                    .indexer_db
                    .get_translated_v1_event_by_version_and_index(version, index)?);
            } else {
                anyhow::bail!("Event translation is not enabled")
            }
        }
        anyhow::bail!("DB indexer reader is not available")
    }
```

**File:** storage/indexer/src/db_indexer.rs (L694-704)
```rust
            .map(|(seq, ver, idx)| {
                let event = match self
                    .main_db_reader
                    .get_event_by_version_and_index(ver, idx)?
                {
                    event @ ContractEvent::V1(_) => event,
                    ContractEvent::V2(_) => ContractEvent::V1(
                        self.indexer_db
                            .get_translated_v1_event_by_version_and_index(ver, idx)?,
                    ),
                };
```

**File:** storage/indexer/src/db_indexer.rs (L709-714)
```rust
                ensure!(
                    seq == v0.sequence_number(),
                    "Index broken, expected seq:{}, actual:{}",
                    seq,
                    v0.sequence_number()
                );
```

**File:** storage/indexer/src/event_v2_translator.rs (L239-273)
```rust
impl EventV2Translator for CoinDepositTranslator {
    fn translate_event_v2_to_v1(
        &self,
        v2: &ContractEventV2,
        engine: &EventV2TranslationEngine,
    ) -> Result<ContractEventV1> {
        let coin_deposit = CoinDeposit::try_from_bytes(v2.event_data())?;
        let struct_tag_str = format!("0x1::coin::CoinStore<{}>", coin_deposit.coin_type());
        let struct_tag = StructTag::from_str(&struct_tag_str)?;
        let (key, sequence_number) = if let Some(state_value_bytes) =
            engine.get_state_value_bytes_for_resource(coin_deposit.account(), &struct_tag)?
        {
            // We can use `DummyCoinType` as it does not affect the correctness of deserialization.
            let coin_store_resource: CoinStoreResource<DummyCoinType> =
                bcs::from_bytes(&state_value_bytes)?;
            let key = *coin_store_resource.deposit_events().key();
            let sequence_number = engine
                .get_next_sequence_number(&key, coin_store_resource.deposit_events().count())?;
            (key, sequence_number)
        } else {
            // The creation number of DepositEvent is deterministically 2.
            static DEPOSIT_EVENT_CREATION_NUMBER: u64 = 2;
            (
                EventKey::new(DEPOSIT_EVENT_CREATION_NUMBER, *coin_deposit.account()),
                0,
            )
        };
        let deposit_event = DepositEvent::new(coin_deposit.amount());
        Ok(ContractEventV1::new(
            key,
            sequence_number,
            DEPOSIT_EVENT_TYPE.clone(),
            bcs::to_bytes(&deposit_event)?,
        )?)
    }
```
