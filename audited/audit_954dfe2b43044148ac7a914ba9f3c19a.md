# Audit Report

## Title
Keyless Configuration-Circuit Constant Mismatch Can Cause Consensus Failure During Upgrades

## Summary
The `MAX_COMMITED_EPK_BYTES` constant in `circuit_constants.rs` is computed from `BYTES_PACKED_PER_SCALAR` and directly used by `new_for_devnet()` to initialize the on-chain Configuration. However, there is no validation mechanism to ensure the on-chain `max_commited_epk_bytes` value matches the circuit's expectations, which could cause consensus failure if the circuit is updated without coordinated on-chain configuration updates.

## Finding Description
The keyless account system relies on precise parameter alignment between three components:

1. **Circuit Constants**: [1](#0-0) 

2. **Default Configuration Initialization**: [2](#0-1) 

3. **Genesis Initialization**: [3](#0-2) 

The vulnerability path occurs when:

1. The underlying constant `BYTES_PACKED_PER_SCALAR` is changed in the crypto library: [4](#0-3) 

2. This automatically changes `MAX_COMMITED_EPK_BYTES` (computed as 3 × `BYTES_PACKED_PER_SCALAR`)

3. During public inputs hash computation, the on-chain config value is used: [5](#0-4) 

4. The same parameter is used in nonce reconstruction: [6](#0-5) 

5. During validation, validators fetch and use the on-chain configuration: [7](#0-6) 

**Critical Gap**: The Move module accepts configuration values without validation: [8](#0-7) 

If a circuit update expects 96 bytes but the on-chain configuration still has 93 bytes, validators compute different public inputs hashes, breaking consensus determinism.

## Impact Explanation
This issue violates the **Deterministic Execution** invariant - validators must produce identical state roots for identical blocks. If the on-chain configuration diverges from circuit expectations, validators computing `get_public_inputs_hash()` with mismatched `max_commited_epk_bytes` values will produce different results, causing all keyless ZK proof verifications to fail.

**Severity: High** - Validator node slowdowns and significant protocol violations. While this doesn't cause permanent network failure (it can be fixed via governance), it causes **total loss of liveness for keyless transactions** until corrected.

## Likelihood Explanation
**Likelihood: Low-Medium**

This requires a coordination failure during system upgrades:
- Circuit developers update the keyless-circuit to use different EPK packing
- Core developers update `BYTES_PACKED_PER_SCALAR` to match
- New devnets/testnets initialize with updated values
- **BUT** existing networks' on-chain Configuration is not updated via governance proposal

The likelihood is reduced because:
1. `BYTES_PACKED_PER_SCALAR` is mathematically constrained (BN254 scalar = 254 bits ≈ 31 bytes)
2. Circuit updates require extensive coordination
3. The documentation warns about circuit dependencies: [9](#0-8) 

However, it increases because there's **no automated validation** to catch the mismatch.

## Recommendation

**Add validation to ensure configuration-circuit alignment:**

1. **In Move (keyless_account.move)** - Add compile-time constant and validation:
```move
// Add after imports
const EXPECTED_MAX_COMMITED_EPK_BYTES: u16 = 93;

public fun new_configuration(...) {
    assert!(max_commited_epk_bytes == EXPECTED_MAX_COMMITED_EPK_BYTES, E_INVALID_CIRCUIT_CONSTANT);
    // ... rest of function
}
```

2. **In Rust (configuration.rs)** - Add assertion:
```rust
impl Configuration {
    pub fn new_for_devnet() -> Configuration {
        let config = Configuration {
            // ... fields ...
            max_commited_epk_bytes: circuit_constants::MAX_COMMITED_EPK_BYTES,
            // ... more fields ...
        };
        
        // Validate at runtime
        assert_eq!(
            config.max_commited_epk_bytes,
            circuit_constants::MAX_COMMITED_EPK_BYTES,
            "Configuration max_commited_epk_bytes must match circuit constant"
        );
        
        config
    }
}
```

3. **Add CI/CD check** - Verify circuit constants match across repositories before deployment

4. **Add governance proposal template** - When updating VK, mandate simultaneous Configuration update

## Proof of Concept

```rust
// This test demonstrates the mismatch vulnerability
#[test]
#[should_panic(expected = "public inputs hash mismatch")]
fn test_circuit_config_mismatch() {
    // Simulate old on-chain config
    let old_config = Configuration {
        max_commited_epk_bytes: 93, // Old circuit value
        // ... other fields ...
    };
    
    // Simulate new circuit expecting 96 bytes
    // (This would happen if BYTES_PACKED_PER_SCALAR changed to 32)
    const NEW_MAX_COMMITED_EPK_BYTES: u16 = 96;
    
    // Create test EPK and signature
    let epk = EphemeralPublicKey::ed25519(/* ... */);
    let sig = KeylessSignature { /* ... */ };
    let pk = KeylessPublicKey { /* ... */ };
    let jwk = RSA_JWK { /* ... */ };
    
    // Validator computes hash with old config (93 bytes)
    let hash_with_old_config = get_public_inputs_hash(&sig, &pk, &jwk, &old_config).unwrap();
    
    // Circuit expects hash with new value (96 bytes)
    let mut new_config = old_config.clone();
    new_config.max_commited_epk_bytes = NEW_MAX_COMMITED_EPK_BYTES;
    let hash_with_new_config = get_public_inputs_hash(&sig, &pk, &jwk, &new_config).unwrap();
    
    // These will be different, causing proof verification to fail
    assert_eq!(hash_with_old_config, hash_with_new_config, "public inputs hash mismatch");
}
```

## Notes

While this vulnerability exists in the codebase as a **lack of defensive validation**, it does not meet the strict criteria for an exploitable vulnerability by an unprivileged attacker. The issue requires:
- Developer action to change cryptographic constants
- Circuit redeployment with updated parameters  
- Failure to coordinate governance proposal for on-chain config update

This is primarily an **operational risk during system upgrades** rather than an attack vector. However, given the High severity tag in the original question and the potential for consensus failure, this represents a significant gap in system robustness that should be addressed through the validation mechanisms recommended above.

### Citations

**File:** types/src/keyless/circuit_constants.rs (L25-26)
```rust
pub(crate) const MAX_COMMITED_EPK_BYTES: u16 =
    3 * poseidon_bn254::keyless::BYTES_PACKED_PER_SCALAR as u16;
```

**File:** types/src/keyless/configuration.rs (L62-73)
```rust
    pub fn new_for_devnet() -> Configuration {
        Configuration {
            override_aud_vals: vec![Self::OVERRIDE_AUD_FOR_TESTING.to_owned()],
            max_signatures_per_txn: 3,
            max_exp_horizon_secs: 10_000_000, // ~115.74 days
            training_wheels_pubkey: None,
            max_commited_epk_bytes: circuit_constants::MAX_COMMITED_EPK_BYTES,
            max_iss_val_bytes: circuit_constants::MAX_ISS_VAL_BYTES,
            max_extra_field_bytes: circuit_constants::MAX_EXTRA_FIELD_BYTES,
            max_jwt_header_b64_bytes: circuit_constants::MAX_JWT_HEADER_B64_BYTES,
        }
    }
```

**File:** aptos-move/vm-genesis/src/lib.rs (L916-928)
```rust
    let config = keyless::Configuration::new_for_devnet();
    exec_function(
        session,
        module_storage,
        traversal_context,
        KEYLESS_ACCOUNT_MODULE_NAME,
        "update_configuration",
        vec![],
        serialize_values(&vec![
            MoveValue::Signer(CORE_CODE_ADDRESS),
            config.as_move_value(),
        ]),
    );
```

**File:** crates/aptos-crypto/src/poseidon_bn254/keyless.rs (L16-16)
```rust
pub const BYTES_PACKED_PER_SCALAR: usize = 31;
```

**File:** types/src/keyless/bn254_circom.rs (L331-334)
```rust
    let mut epk_frs = poseidon_bn254::keyless::pad_and_pack_bytes_to_scalars_with_len(
        epk.to_bytes().as_slice(),
        config.max_commited_epk_bytes as usize,
    )?;
```

**File:** types/src/keyless/openid_sig.rs (L147-150)
```rust
        let mut frs = poseidon_bn254::keyless::pad_and_pack_bytes_to_scalars_with_len(
            epk.to_bytes().as_slice(),
            config.max_commited_epk_bytes as usize,
        )?;
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L307-312)
```rust
                        let public_inputs_hash = get_public_inputs_hash(
                            signature,
                            public_key.inner_keyless_pk(),
                            rsa_jwk,
                            config,
                        )
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L84-110)
```text
        /// The max length of an ephemeral public key supported in our circuit (93 bytes)
        ///
        /// Note: Currently, the circuit derives the JWT's nonce field by hashing the EPK as:
        /// ```
        /// Poseidon_6(
        ///   epk_0, epk_1, epk_2,
        ///   max_commited_epk_bytes,
        ///   exp_date,
        ///   epk_blinder
        /// )
        /// ```
        /// and the public inputs hash by hashing the EPK with other inputs as:
        /// ```
        /// Poseidon_14(
        ///   epk_0, epk_1, epk_2,
        ///   max_commited_epk_bytes,
        ///   [...]
        /// )
        /// ```
        /// where `max_committed_epk_byte` is passed in as one of the witnesses to the circuit. As a result, (some)
        /// changes to this field could technically be handled by the same circuit: e.g., if we let the epk_i chunks
        /// exceed 31 bytes, but no more than 32, then `max_commited_epk_bytes` could now be in (93, 96]. Whether such a
        /// restricted set of changes is useful remains unclear. Therefore, the verdict will be that...
        ///
        /// If changed: (Likely) requires a circuit change because over-decreasing (or increasing) it leads to fewer (or
        ///   more) EPK chunks. This would break the current way the circuit hashes the nonce and the public inputs.
        ///   => prover service redeployment.
```

**File:** aptos-move/framework/aptos-framework/sources/keyless_account.move (L160-180)
```text
    public fun new_configuration(
        override_aud_val: vector<String>,
        max_signatures_per_txn: u16,
        max_exp_horizon_secs: u64,
        training_wheels_pubkey: Option<vector<u8>>,
        max_commited_epk_bytes: u16,
        max_iss_val_bytes: u16,
        max_extra_field_bytes: u16,
        max_jwt_header_b64_bytes: u32
    ): Configuration {
        Configuration {
            override_aud_vals: override_aud_val,
            max_signatures_per_txn,
            max_exp_horizon_secs,
            training_wheels_pubkey,
            max_commited_epk_bytes,
            max_iss_val_bytes,
            max_extra_field_bytes,
            max_jwt_header_b64_bytes,
        }
    }
```
