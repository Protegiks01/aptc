# Audit Report

## Title
Silent Failure in Event Translation During Transaction Simulation Causes Incomplete Event Data in API Responses

## Summary
The `simulate()` function in `api/src/transactions.rs` unconditionally calls `translate_v2_to_v1_events_for_simulation()` and discards the result using `let _`, causing any translation errors to be silently ignored. This results in incomplete or incorrect event data being returned to API clients without any error indication.

## Finding Description

The vulnerability exists in the transaction simulation endpoint where V2 events need to be translated to V1 format for backward compatibility. The simulation function contains a critical error handling flaw: [1](#0-0) 

The error from `translate_v2_to_v1_events_for_simulation()` is discarded, but this function can fail in multiple ways: [2](#0-1) 

The function fails with an error at line 1048 if `indexer_reader` is `None`, which occurs when:
1. The internal indexer is not configured (default configuration has it disabled)
2. Storage sharding is disabled
3. Node is running in certain deployment configurations [3](#0-2) 

The function can also fail at line 1049 when calling `translate_event_v2_to_v1()`, or at lines 1052-1057 when constructing the V1 event.

**Critical Comparison**: For normal transaction processing, event translation includes safety checks: [4](#0-3) 

The normal path checks both `indexer_reader.is_some()` AND `enable_event_v2_translation` before attempting translation. **The simulation path skips these critical safety checks entirely.**

When translation fails:
- V2 events remain untranslated in the `events` array
- The simulation response contains raw V2 events instead of expected V1 events
- API clients receive incomplete/incorrect event data
- No error is returned to indicate the problem

## Impact Explanation

This qualifies as **Medium Severity** per the Aptos bug bounty program for the following reasons:

1. **API Correctness Violation**: The simulation endpoint is a critical API used by wallets, dApps, and developers to validate transactions before submission. Returning incorrect event data violates the API contract and breaks client assumptions.

2. **Silent Failure**: The error is completely hidden from clients. There is no indication in the response that event translation failed, making it impossible for clients to detect and handle the issue.

3. **Potential Downstream Impact**: DApps and wallets may rely on simulated event data to:
   - Verify transaction safety before submission
   - Estimate fees and gas consumption
   - Determine transaction side effects
   - Make critical business logic decisions
   
   Incorrect event data could lead to:
   - Submission of transactions with unexpected consequences
   - Failed transactions in production
   - User fund losses due to incorrect transaction decisions

4. **Configuration-Dependent**: The issue occurs in real-world deployments where the indexer is not configured, which is the default setting, making it highly likely to affect production systems.

While this doesn't directly compromise consensus or cause immediate fund loss, the incorrect API responses can lead to indirect security issues through client misbehavior.

## Likelihood Explanation

**High Likelihood** - This issue will occur in any deployment where:
1. The internal indexer is not configured (default state: `enable_event_v2_translation: false`)
2. The simulation API is called with transactions that emit V2 events
3. Clients expect translated V1 event format

The likelihood is high because:
- Default configuration has translation disabled
- Many node operators may not enable the internal indexer due to resource requirements
- The simulation endpoint is commonly used by wallets and dApps
- No error is surfaced, making the issue invisible until clients experience unexpected behavior

## Recommendation

Add the same safety checks used in normal transaction processing before attempting event translation:

```rust
// In api/src/transactions.rs, simulate() function:
let mut events = output.events().to_vec();

// Add safety checks before translation
if self.context.indexer_reader.is_some()
    && self
        .context
        .node_config
        .indexer_db_config
        .enable_event_v2_translation
{
    // Only attempt translation if prerequisites are met
    if let Err(e) = self
        .context
        .translate_v2_to_v1_events_for_simulation(&mut events)
    {
        // Log the error for debugging but continue with untranslated events
        aptos_logger::warn!(
            "Failed to translate V2 events for simulation: {}. Returning untranslated events.",
            e
        );
    }
}
```

Alternatively, return an explicit error to clients when translation is expected but fails:

```rust
// Return error if translation is required but unavailable
if !events.iter().all(|e| matches!(e, ContractEvent::V1(_))) {
    if self.context.indexer_reader.is_none() 
        || !self.context.node_config.indexer_db_config.enable_event_v2_translation 
    {
        return Err(SubmitTransactionError::service_unavailable_with_code(
            "Event V2 translation is not available on this node. V2 events cannot be translated for simulation.",
            AptosErrorCode::InternalError,
            &ledger_info,
        ));
    }
}
```

## Proof of Concept

**Setup**: Deploy an Aptos node with default configuration (internal indexer disabled).

**Steps**:
1. Create a transaction that emits V2 events (e.g., coin transfer with new event format)
2. Submit to `/transactions/simulate` endpoint
3. Observe the response contains raw V2 events instead of translated V1 events
4. No error is returned despite translation failure

**Expected Behavior**: Either translated V1 events should be returned, OR an explicit error should indicate translation is unavailable.

**Actual Behavior**: Raw untranslated V2 events are returned with HTTP 200 OK, silently providing incorrect data to clients.

**Code to reproduce**:
```rust
// In a test environment with indexer_reader = None
let signed_txn = create_test_transaction_with_v2_events();
let result = api.simulate(&AcceptType::Json, ledger_info, signed_txn);

// Result succeeds but contains untranslated V2 events
assert!(result.is_ok());
let user_txn = result.unwrap();
// Events are V2 instead of expected translated V1
assert!(user_txn.events.iter().any(|e| matches!(e, ContractEvent::V2(_))));
```

## Notes

The vulnerability stems from inconsistent error handling between simulation and normal transaction paths. The simulation code should either:
1. Apply the same safety checks before attempting translation, or
2. Return explicit errors when translation prerequisites are not met

The current silent failure violates the principle of fail-fast and makes debugging extremely difficult for API clients.

### Citations

**File:** api/src/transactions.rs (L1719-1722)
```rust
        let mut events = output.events().to_vec();
        let _ = self
            .context
            .translate_v2_to_v1_events_for_simulation(&mut events);
```

**File:** api/src/context.rs (L1004-1018)
```rust
    fn maybe_translate_v2_to_v1_events(
        &self,
        mut txn: TransactionOnChainData,
    ) -> TransactionOnChainData {
        if self.indexer_reader.is_some()
            && self
                .node_config
                .indexer_db_config
                .enable_event_v2_translation
        {
            self.translate_v2_to_v1_events_for_version(txn.version, &mut txn.events)
                .ok();
        }
        txn
    }
```

**File:** api/src/context.rs (L1038-1064)
```rust
    pub fn translate_v2_to_v1_events_for_simulation(
        &self,
        events: &mut [ContractEvent],
    ) -> Result<()> {
        let mut count_map: HashMap<EventKey, u64> = HashMap::new();
        for event in events.iter_mut() {
            if let ContractEvent::V2(v2) = event {
                let translated_event = self
                    .indexer_reader
                    .as_ref()
                    .ok_or(anyhow!("Internal indexer reader doesn't exist"))?
                    .translate_event_v2_to_v1(v2)?;
                if let Some(v1) = translated_event {
                    let count = count_map.get(v1.key()).unwrap_or(&0);
                    let v1_adjusted = ContractEventV1::new(
                        *v1.key(),
                        v1.sequence_number() + count,
                        v1.type_tag().clone(),
                        v1.event_data().to_vec(),
                    )?;
                    *event = ContractEvent::V1(v1_adjusted);
                    count_map.insert(*v1.key(), count + 1);
                }
            }
        }
        Ok(())
    }
```

**File:** config/src/config/internal_indexer_db_config.rs (L69-80)
```rust
impl Default for InternalIndexerDBConfig {
    fn default() -> Self {
        Self {
            enable_transaction: false,
            enable_event: false,
            enable_event_v2_translation: false,
            event_v2_translation_ignores_below_version: 0,
            enable_statekeys: false,
            batch_size: 10_000,
        }
    }
}
```
