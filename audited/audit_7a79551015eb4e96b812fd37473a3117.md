# Audit Report

## Title
Consensus Deadlock via Feature Flag Inconsistency in order_vote_enabled Configuration

## Summary
Validators can have inconsistent `order_vote_enabled` settings when on-chain configuration deserialization fails. This causes validators with `order_vote_enabled=false` to incorrectly process `WrappedLedgerInfo` objects created by validators with `order_vote_enabled=true`, resulting in hash verification failures and sync deadlock.

## Finding Description

The vulnerability exists in the configuration loading and WrappedLedgerInfo processing logic:

**Root Cause**: When reading the on-chain consensus configuration, the code uses `unwrap_or_default()` as a fallback mechanism. [1](#0-0) 

The default configuration has `order_vote_enabled: false` [2](#0-1) , while genesis and active networks may have `order_vote_enabled: true` [3](#0-2) .

**Attack Scenario**:

1. **Configuration Inconsistency**: If validator A successfully reads `order_vote_enabled: true` from on-chain config, but validator B fails deserialization (corrupted state, version mismatch, etc.) and falls back to default `order_vote_enabled: false`, they now have inconsistent settings.

2. **WrappedLedgerInfo Creation**: Validator A creates `WrappedLedgerInfo` with `VoteData::dummy()` [4](#0-3)  and `LedgerInfo` with `consensus_data_hash = HashValue::zero()` [5](#0-4) .

3. **Sync Failure**: Validator B receives this `WrappedLedgerInfo` in a `SyncInfo` message. Because its local config has `order_vote_enabled: false`, it enters the else branch and calls `into_quorum_cert(false)` [6](#0-5) .

4. **Hash Mismatch**: The `into_quorum_cert()` function passes the first check (`ensure!(!order_vote_enabled, ...)`) [7](#0-6)  but then calls `verify_consensus_data_hash()` [8](#0-7) .

5. **Verification Failure**: The `verify_consensus_data_hash()` function checks if `vote_data.hash() == ledger_info().consensus_data_hash()` [9](#0-8) . Since `VoteData::dummy()` contains two `BlockInfo::empty()` structures [10](#0-9) , its BCS hash cannot equal `HashValue::zero()` (cryptographically impossible for SHA3-256 to output all zeros for non-trivial input). The check fails with error.

6. **Sync Deadlock**: Validator B cannot process sync messages, falls behind, and becomes unable to participate in consensus. If multiple validators are affected by the same configuration deserialization issue, consensus liveness degrades or halts entirely.

**Invariant Violation**: This breaks the **Deterministic Execution** and **Consensus Safety** invariants - validators processing identical network messages must reach identical states, but here they diverge based on local configuration.

## Impact Explanation

**Critical Severity** - This vulnerability can cause:

1. **Network Liveness Failure**: If multiple validators fail to read the on-chain config and fall into the inconsistent state, they cannot sync with correctly-configured validators, reducing the effective validator set and potentially causing consensus to stall if the affected validators represent > 1/3 of voting power.

2. **Non-Recoverable Partition**: Validators stuck in the wrong configuration mode cannot self-recover without manual intervention (node restart, state wipe, or config override), potentially requiring coordinated network-wide recovery or hardfork.

3. **Silent Failures**: The error handling only logs warnings [11](#0-10) , so operators may not immediately detect the misconfiguration until consensus failures occur.

This meets the **Critical Severity** category: "Non-recoverable network partition (requires hardfork)" and "Total loss of liveness/network availability."

## Likelihood Explanation

**Medium-High Likelihood**:

1. **Configuration Deserialization Failures**: BCS deserialization can fail due to:
   - On-chain config data corruption
   - Version mismatches during upgrades
   - Storage backend errors
   - State sync inconsistencies

2. **Upgrade Scenarios**: During network upgrades where `order_vote_enabled` is toggled, validators that fail to read the new config will diverge from the network.

3. **No Safeguards**: The code lacks validation to ensure all validators have consistent feature flag settings before critical operations.

4. **Real-World Precedent**: Multiple validators could experience the same deserialization error if triggered by a common upgrade path or storage backend issue.

## Recommendation

**Immediate Fix**: Replace `unwrap_or_default()` with explicit error handling that halts the validator if critical configuration cannot be read:

```rust
let consensus_config = onchain_consensus_config.map_err(|e| {
    error!("FATAL: Cannot read on-chain consensus config: {}", e);
    panic!("Validator cannot start without valid consensus configuration");
})?;
```

**Better Solution**: Implement configuration consistency verification:

1. Add a consensus check during epoch start that verifies all validators agree on critical feature flags like `order_vote_enabled`
2. Include `order_vote_enabled` value in block headers/quorum certificates so validators can detect mismatches
3. Add runtime assertions that panic if `certified_block()` or `into_quorum_cert()` are called with mismatched `order_vote_enabled` values
4. Improve error handling to surface configuration read failures prominently to operators

**Additional Safeguard**: In `WrappedLedgerInfo::new()`, validate that when using `VoteData::dummy()`, the corresponding `LedgerInfo` must have `consensus_data_hash == HashValue::zero()`, and document this invariant clearly.

## Proof of Concept

**Reproduction Steps**:

1. Set up two validator nodes A and B
2. Configure on-chain consensus config with `order_vote_enabled: true`
3. Corrupt node B's state to cause config deserialization failure:
   ```rust
   // In test, inject deserialization error
   let onchain_consensus_config: anyhow::Result<OnChainConsensusConfig> = 
       Err(anyhow::anyhow!("Simulated deserialization failure"));
   ```
4. Node B falls back to default with `order_vote_enabled: false`
5. Node A creates `WrappedLedgerInfo` with `VoteData::dummy()` and `consensus_data_hash=HashValue::zero()`
6. Node A sends `SyncInfo` to Node B
7. Node B attempts to process: `wrapped_ledger_info.into_quorum_cert(false)`
8. Observe failure in `verify_consensus_data_hash()`:
   ```
   Error: WrappedLedgerInfo's vote data hash mismatch LedgerInfo
   Expected: HashValue::zero()
   Got: <hash of VoteData::dummy()>
   ```
9. Node B cannot sync and falls behind

**Test Code Skeleton**:
```rust
#[test]
fn test_order_vote_enabled_inconsistency() {
    // Create WrappedLedgerInfo with VoteData::dummy() and consensus_data_hash=zero
    let vote_data = VoteData::dummy();
    let ledger_info = LedgerInfo::new(BlockInfo::empty(), HashValue::zero());
    let wrapped = WrappedLedgerInfo::new(vote_data, 
        LedgerInfoWithSignatures::new(ledger_info, AggregateSignature::empty()));
    
    // Attempt to convert with order_vote_enabled=false
    let result = wrapped.into_quorum_cert(false);
    
    // This should fail with hash mismatch
    assert!(result.is_err());
    assert!(result.unwrap_err().to_string().contains("hash mismatch"));
}
```

## Notes

This vulnerability demonstrates a critical failure mode in feature flag management across distributed systems. The combination of silent error handling, default fallbacks, and hash-based verification creates a deadlock scenario that violates consensus safety guarantees. The issue is particularly dangerous during network upgrades when feature flags change, as partial deployment failures could leave validators in inconsistent states that prevent network progress.

### Citations

**File:** consensus/src/epoch_manager.rs (L1187-1189)
```rust
        if let Err(error) = &onchain_consensus_config {
            warn!("Failed to read on-chain consensus config {}", error);
        }
```

**File:** consensus/src/epoch_manager.rs (L1201-1201)
```rust
        let consensus_config = onchain_consensus_config.unwrap_or_default();
```

**File:** types/src/on_chain_config/consensus_config.rs (L30-36)
```rust
    pub fn default_for_genesis() -> Self {
        Self::JolteonV2 {
            main: ConsensusConfigV1::default(),
            quorum_store_enabled: true,
            order_vote_enabled: true,
        }
    }
```

**File:** types/src/on_chain_config/consensus_config.rs (L46-51)
```rust
    pub fn default_if_missing() -> Self {
        Self::JolteonV2 {
            main: ConsensusConfigV1::default(),
            quorum_store_enabled: true,
            order_vote_enabled: false,
        }
```

**File:** consensus/src/round_manager.rs (L1908-1908)
```rust
                    WrappedLedgerInfo::new(VoteData::dummy(), ledger_info_with_signatures),
```

**File:** consensus/src/pipeline/buffer_item.rs (L32-33)
```rust
        if order_vote_enabled {
            HashValue::zero()
```

**File:** consensus/src/block_storage/sync_manager.rs (L158-166)
```rust
            self.insert_quorum_cert(
                &self
                    .highest_ordered_cert()
                    .as_ref()
                    .clone()
                    .into_quorum_cert(self.order_vote_enabled)?,
                &mut retriever,
            )
            .await?;
```

**File:** consensus/consensus-types/src/wrapped_ledger_info.rs (L53-62)
```rust
    fn verify_consensus_data_hash(&self) -> anyhow::Result<()> {
        let vote_hash = self.vote_data.hash();
        ensure!(
            self.ledger_info().ledger_info().consensus_data_hash() == vote_hash,
            "WrappedLedgerInfo's vote data hash mismatch LedgerInfo, {} {}",
            self.ledger_info(),
            self.vote_data
        );
        Ok(())
    }
```

**File:** consensus/consensus-types/src/wrapped_ledger_info.rs (L126-128)
```rust
        ensure!(
            !order_vote_enabled,
            "wrapped_ledger_info.into_quorum_cert should not be called when order votes are enabled"
```

**File:** consensus/consensus-types/src/wrapped_ledger_info.rs (L130-130)
```rust
        self.verify_consensus_data_hash()?;
```

**File:** consensus/consensus-types/src/vote_data.rs (L41-46)
```rust
    pub fn dummy() -> Self {
        Self {
            proposed: BlockInfo::empty(),
            parent: BlockInfo::empty(),
        }
    }
```
