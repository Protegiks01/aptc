# Audit Report

## Title
File Discovery Symlink Attack Leading to Sensitive File Disclosure

## Summary
The file-based peer discovery mechanism in `network/discovery/src/file.rs` uses `std::fs::read_to_string()` without validating that the configured path is not a symlink. This allows an attacker with filesystem access to cause the node to read arbitrary files by replacing the discovery file with a symlink, potentially leaking sensitive information through error logs.

## Finding Description

The network builder's `setup_discovery()` function processes file-based discovery configuration without symlink validation. [1](#0-0) 

The `DiscoveryChangeListener::file()` constructor accepts the path and creates a `FileStream`: [2](#0-1) 

The critical vulnerability lies in `load_file()`, which uses `std::fs::read_to_string()` that follows symlinks by default: [3](#0-2) 

**Attack Path:**

1. Node operator configures file discovery: `discovery_method: file` with `path: /var/lib/aptos/peers.yaml`
2. Attacker gains write access to `/var/lib/aptos/` directory (but not to the main config file)
3. Attacker replaces `peers.yaml` with symlink: `ln -s /etc/shadow /var/lib/aptos/peers.yaml`
4. On next poll interval, FileStream reads `/etc/shadow` content
5. YAML parsing fails, creating `DiscoveryError::Parsing` with serde_yaml error message
6. Error is logged including snippets of the sensitive file: [4](#0-3) 

The FileDiscovery configuration is loaded directly from YAML without path validation: [5](#0-4) 

## Impact Explanation

This vulnerability enables **information disclosure** through log leakage. Per the Aptos bug bounty severity categories, information leaks fall under **Low Severity** (up to $1,000): "Minor information leaks, Non-critical implementation bugs."

However, the question categorizes this as Medium severity, which may reflect:
- Potential exposure of validator private keys or node secrets if accessible
- Risk in shared hosting environments
- Defense-in-depth failure enabling further attacks

The vulnerability does NOT directly affect:
- Consensus safety or liveness
- State consistency or Merkle tree integrity  
- Transaction validation or execution
- Funds or on-chain governance

## Likelihood Explanation

**Moderate to Low likelihood** depending on deployment:

**Prerequisites for exploitation:**
1. Node uses file-based discovery (uncommon - most use on-chain discovery)
2. Discovery file directory has write permissions for attacker
3. Node runs with privileges to read target sensitive files
4. Attacker can access logs (direct access or centralized logging)

**Likelihood factors:**
- Most production nodes use on-chain discovery, not file-based
- Proper deployment restricts directory permissions (e.g., 0600 owned by aptos user)
- Nodes should run with minimal privileges (not root)
- Attack requires sustained filesystem access

## Recommendation

Implement symlink validation before reading the discovery file:

```rust
fn load_file(path: &Path) -> Result<PeerSet, DiscoveryError> {
    // Validate path is not a symlink
    let metadata = std::fs::symlink_metadata(path)
        .map_err(DiscoveryError::IO)?;
    
    if metadata.is_symlink() {
        return Err(DiscoveryError::IO(std::io::Error::new(
            std::io::ErrorKind::InvalidInput,
            "Discovery file path must not be a symlink"
        )));
    }
    
    // Optionally: canonicalize and validate path is within expected directory
    let canonical_path = path.canonicalize()
        .map_err(DiscoveryError::IO)?;
    
    // Read file contents
    let contents = std::fs::read_to_string(&canonical_path)
        .map_err(DiscoveryError::IO)?;
    
    serde_yaml::from_str(&contents)
        .map_err(|err| DiscoveryError::Parsing(err.to_string()))
}
```

Additional hardening:
1. Document secure file permissions (0600) for discovery files
2. Sanitize error messages to prevent content leakage
3. Validate discovery file path is within expected directory bounds
4. Consider dropping privileges if running as root

## Proof of Concept

```rust
#[test]
fn test_symlink_rejection() {
    use std::os::unix::fs::symlink;
    use tempfile::TempDir;
    
    // Create temporary directory
    let temp_dir = TempDir::new().unwrap();
    let target_file = temp_dir.path().join("sensitive.txt");
    let symlink_file = temp_dir.path().join("peers.yaml");
    
    // Create sensitive file
    std::fs::write(&target_file, "secret_data").unwrap();
    
    // Create symlink
    symlink(&target_file, &symlink_file).unwrap();
    
    // Attempt to load should fail with symlink error
    let result = load_file(symlink_file.as_path());
    assert!(result.is_err());
    
    // Verify error indicates symlink rejection
    match result {
        Err(DiscoveryError::IO(e)) => {
            assert!(e.to_string().contains("symlink"));
        },
        _ => panic!("Expected IO error for symlink"),
    }
}
```

## Notes

While this vulnerability exists in the codebase, its practical exploitability is limited by:
- File-based discovery being rarely used in production (on-chain discovery is standard)
- Need for specific filesystem permission misconfigurations
- Classification as Low Severity per bug bounty criteria (information leak)

The fix is straightforward and should be implemented as defense-in-depth, even though the attack surface is minimal in properly configured deployments.

### Citations

**File:** network/builder/src/builder.rs (L372-378)
```rust
                DiscoveryMethod::File(file_discovery) => DiscoveryChangeListener::file(
                    self.network_context,
                    conn_mgr_reqs_tx.clone(),
                    file_discovery.path.as_path(),
                    Duration::from_secs(file_discovery.interval_secs),
                    self.time_service.clone(),
                ),
```

**File:** network/discovery/src/lib.rs (L86-104)
```rust
    pub fn file(
        network_context: NetworkContext,
        update_channel: aptos_channels::Sender<ConnectivityRequest>,
        file_path: &Path,
        interval_duration: Duration,
        time_service: TimeService,
    ) -> Self {
        let source_stream = DiscoveryChangeStream::File(FileStream::new(
            file_path,
            interval_duration,
            time_service,
        ));
        DiscoveryChangeListener {
            discovery_source: DiscoverySource::File,
            network_context,
            update_channel,
            source_stream,
        }
    }
```

**File:** network/discovery/src/lib.rs (L157-165)
```rust
            } else {
                warn!(
                    NetworkSchema::new(&network_context),
                    "{} {} Discovery update failed {:?}",
                    &network_context,
                    discovery_source,
                    update
                );
            }
```

**File:** network/discovery/src/file.rs (L50-53)
```rust
fn load_file(path: &Path) -> Result<PeerSet, DiscoveryError> {
    let contents = std::fs::read_to_string(path).map_err(DiscoveryError::IO)?;
    serde_yaml::from_str(&contents).map_err(|err| DiscoveryError::Parsing(err.to_string()))
}
```

**File:** config/src/config/network_config.rs (L352-357)
```rust
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
#[serde(rename_all = "snake_case")]
pub struct FileDiscovery {
    pub path: PathBuf,
    pub interval_secs: u64,
}
```
