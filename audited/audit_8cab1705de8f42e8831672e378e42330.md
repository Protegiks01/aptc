# Audit Report

## Title
Missing Type Depth Validation in ViewRequest JSON Deserialization Enables Stack Overflow DoS

## Summary
The ViewRequest JSON deserialization path in the View Function API endpoint fails to validate the nesting depth of `type_arguments` before converting them to TypeTags, unlike Script transactions which explicitly validate type depth. This allows an attacker to send deeply nested generic types (e.g., `vector<vector<vector<...>>>` nested 200+ levels) that can cause stack overflow during recursive type conversion, crashing the API node.

## Finding Description
The vulnerability exists in the asymmetric handling of type argument validation between Script transactions and View function requests:

**Script transactions** perform explicit depth validation: [1](#0-0) 

The `verify()` method is called with recursion_count=0, enforcing the `MAX_RECURSIVE_TYPES_ALLOWED = 8` limit: [2](#0-1) 

**ViewRequest** does NOT perform this validation. When processing JSON view requests: [3](#0-2) 

The conversion function simply maps type_arguments to ty_args without validation: [4](#0-3) 

The `TryFrom<&MoveType> for TypeTag` implementation is recursive without depth checks: [5](#0-4) 

**Attack Path:**
1. Attacker crafts JSON ViewRequest with deeply nested type_arguments (e.g., 200-level nested vectors)
2. Serde deserializes the JSON into `ViewRequest` struct successfully
3. `convert_view_function` is called, which skips the `verify()` check that exists for Scripts
4. Each MoveType is converted to TypeTag via recursive `try_into()` 
5. The unbounded recursion (200 stack frames) exhausts the thread stack (typically 2MB for spawn_blocking tasks)
6. Stack overflow occurs during conversion, before reaching VM's `max_ty_depth` runtime check

While the BCS deserialization path is protected by TypeTag's safe_serialize limits: [6](#0-5) 

The JSON path bypasses this by deserializing into MoveType first, then converting without validation.

**Broken Invariant:**
- **Resource Limits**: The API fails to enforce computational limits on type conversion depth
- **Move VM Safety**: Stack exhaustion violates memory constraint guarantees

## Impact Explanation
This qualifies as **High Severity** per Aptos bug bounty criteria:
- **API crashes**: Stack overflow causes the API worker thread to panic, degrading service availability
- **Denial of Service**: Repeated exploitation can continuously crash API nodes, preventing users from executing view functions
- **Validator node slowdowns**: If validators expose the View API endpoint, this affects their availability

The impact is contained to API layer crashes and does not affect consensus or state integrity, preventing Critical severity classification.

## Likelihood Explanation
**Likelihood: High**
- **Zero authentication required**: Any user can POST to `/v1/view` endpoint
- **Trivial to exploit**: Simple JSON payload with nested type structure
- **No rate limiting on type complexity**: Only MAX_RECURSIVE_TYPES_ALLOWED constant exists but is not enforced
- **Easily discoverable**: The inconsistency between Script and ViewRequest validation is apparent in code review

## Recommendation
Add the same type depth validation to ViewRequest that exists for Script transactions:

```rust
// In api/types/src/convert.rs, in convert_view_function function, add after line 1028:
pub fn convert_view_function(&self, view_request: ViewRequest) -> Result<ViewFunction> {
    let ViewRequest {
        function,
        type_arguments,
        arguments,
    } = view_request;

    // Add validation (like Script does):
    for type_arg in &type_arguments {
        type_arg.verify(0)
            .context("ViewRequest type argument invalid")?;
    }

    let module = function.module.clone();
    // ... rest of function
}
```

This enforces the MAX_RECURSIVE_TYPES_ALLOWED = 8 depth limit before attempting recursive conversion, matching Script transaction behavior and preventing stack overflow.

## Proof of Concept

Create a test file `api/src/tests/view_function_depth_test.rs`:

```rust
#[tokio::test]
async fn test_deeply_nested_type_causes_stack_overflow() {
    use serde_json::json;
    
    // Create deeply nested vector type (200 levels)
    fn create_nested_vector(depth: usize) -> serde_json::Value {
        if depth == 0 {
            json!("u8")
        } else {
            json!({
                "vector": {
                    "items": create_nested_vector(depth - 1)
                }
            })
        }
    }
    
    let malicious_request = json!({
        "function": "0x1::some_module::some_function",
        "type_arguments": [create_nested_vector(200)],
        "arguments": []
    });
    
    // Attempt to deserialize and convert
    let view_request: ViewRequest = serde_json::from_value(malicious_request).unwrap();
    
    // This should cause stack overflow during try_into() conversion
    // Without the fix, this will panic. With the fix, it returns an error.
    let result = converter.convert_view_function(view_request);
    
    // Expected: Err with depth limit exceeded
    // Actual (vulnerable): Stack overflow panic
    assert!(result.is_err());
}
```

To reproduce:
1. Send POST request to `/v1/view` with JSON containing 200-level nested vector type
2. Observe API worker thread panic with stack overflow
3. API endpoint becomes temporarily unavailable

**Notes**
The runtime type resolution also has depth checks (max_ty_depth typically 20): [7](#0-6) 

However, the stack overflow occurs during MoveTypeâ†’TypeTag conversion BEFORE reaching this VM-level check, making it ineffective as a defense.

### Citations

**File:** api/src/transactions.rs (L1200-1211)
```rust
        for arg in script.ty_args() {
            let arg = MoveType::from(arg);
            arg.verify(0)
                .context("Transaction script function type arg invalid")
                .map_err(|err| {
                    SubmitTransactionError::bad_request_with_code(
                        err,
                        AptosErrorCode::InvalidInput,
                        ledger_info,
                    )
                })?;
        }
```

**File:** api/types/src/move_types.rs (L686-713)
```rust
/// Maximum number of recursive types - Same as (non-public)
/// move_core_types::safe_serialize::MAX_TYPE_TAG_NESTING
pub const MAX_RECURSIVE_TYPES_ALLOWED: u8 = 8;

impl VerifyInputWithRecursion for MoveType {
    fn verify(&self, recursion_count: u8) -> anyhow::Result<()> {
        if recursion_count > MAX_RECURSIVE_TYPES_ALLOWED {
            bail!(
                "Move type {} has gone over the limit of recursive types {}",
                self,
                MAX_RECURSIVE_TYPES_ALLOWED
            );
        }
        match self {
            MoveType::Vector { items } => items.verify(recursion_count + 1),
            MoveType::Struct(struct_tag) => struct_tag.verify(recursion_count + 1),
            MoveType::Function { args, results, .. } => {
                for ty in args.iter().chain(results) {
                    ty.verify(recursion_count + 1)?
                }
                Ok(())
            },
            MoveType::GenericTypeParam { .. } => Ok(()),
            MoveType::Reference { to, .. } => to.verify(recursion_count + 1),
            MoveType::Unparsable(inner) => bail!("Unable to parse move type {}", inner),
            _ => Ok(()),
        }
    }
```

**File:** api/types/src/move_types.rs (L928-987)
```rust
impl TryFrom<&MoveType> for TypeTag {
    type Error = anyhow::Error;

    fn try_from(tag: &MoveType) -> anyhow::Result<Self> {
        let ret = match tag {
            MoveType::Bool => TypeTag::Bool,
            MoveType::U8 => TypeTag::U8,
            MoveType::U16 => TypeTag::U16,
            MoveType::U32 => TypeTag::U32,
            MoveType::U64 => TypeTag::U64,
            MoveType::U128 => TypeTag::U128,
            MoveType::U256 => TypeTag::U256,
            MoveType::I8 => TypeTag::I8,
            MoveType::I16 => TypeTag::I16,
            MoveType::I32 => TypeTag::I32,
            MoveType::I64 => TypeTag::I64,
            MoveType::I128 => TypeTag::I128,
            MoveType::I256 => TypeTag::I256,
            MoveType::Address => TypeTag::Address,
            MoveType::Signer => TypeTag::Signer,
            MoveType::Vector { items } => TypeTag::Vector(Box::new(items.as_ref().try_into()?)),
            MoveType::Struct(v) => TypeTag::Struct(Box::new(v.try_into()?)),
            MoveType::Function {
                args,
                results,
                abilities,
            } => {
                let try_vec = |tys: &[MoveType]| {
                    tys.iter()
                        .map(|t| {
                            Ok(match t {
                                MoveType::Reference { mutable, to } => {
                                    let tag = to.as_ref().try_into()?;
                                    if *mutable {
                                        FunctionParamOrReturnTag::MutableReference(tag)
                                    } else {
                                        FunctionParamOrReturnTag::Reference(tag)
                                    }
                                },
                                t => FunctionParamOrReturnTag::Value(t.try_into()?),
                            })
                        })
                        .collect::<anyhow::Result<_>>()
                };
                TypeTag::Function(Box::new(FunctionTag {
                    args: try_vec(args)?,
                    results: try_vec(results)?,
                    abilities: *abilities,
                }))
            },
            MoveType::GenericTypeParam { index: _ } => TypeTag::Address, // Dummy type, allows for Object<T>
            MoveType::Reference { .. } | MoveType::Unparsable(_) => {
                return Err(anyhow::anyhow!(
                    "Invalid move type for converting into `TypeTag`: {:?}",
                    &tag
                ))
            },
        };
        Ok(ret)
    }
```

**File:** api/src/view_function.rs (L115-125)
```rust
    let view_function: ViewFunction = match request {
        ViewFunctionRequest::Json(data) => state_view
            .as_converter(context.db.clone(), context.indexer_reader.clone())
            .convert_view_function(data.0)
            .map_err(|err| {
                BasicErrorWith404::bad_request_with_code(
                    err,
                    AptosErrorCode::InvalidInput,
                    &ledger_info,
                )
            })?,
```

**File:** api/types/src/convert.rs (L1024-1058)
```rust
    pub fn convert_view_function(&self, view_request: ViewRequest) -> Result<ViewFunction> {
        let ViewRequest {
            function,
            type_arguments,
            arguments,
        } = view_request;

        let module = function.module.clone();
        let code = self.inner.view_existing_module(&module.clone().into())? as Arc<dyn Bytecode>;
        let func = code
            .find_function(function.name.0.as_ident_str())
            .ok_or_else(|| format_err!("could not find view function by {}", function))?;
        ensure!(
            func.generic_type_params.len() == type_arguments.len(),
            "expected {} type arguments for view function {}, but got {}",
            func.generic_type_params.len(),
            function,
            type_arguments.len()
        );
        let args = self
            .try_into_vm_values(&func, &arguments)?
            .iter()
            .map(bcs::to_bytes)
            .collect::<Result<_, bcs::Error>>()?;

        Ok(ViewFunction {
            module: module.into(),
            function: function.name.into(),
            ty_args: type_arguments
                .iter()
                .map(|v| v.try_into())
                .collect::<Result<_>>()?,
            args,
        })
    }
```

**File:** third_party/move/move-core/types/src/safe_serialize.rs (L11-67)
```rust
pub(crate) const MAX_TYPE_TAG_NESTING: u8 = 8;

thread_local! {
    static TYPE_TAG_DEPTH: RefCell<u8> = const { RefCell::new(0) };
}

pub(crate) fn type_tag_recursive_serialize<S, T>(t: &T, s: S) -> Result<S::Ok, S::Error>
where
    S: Serializer,
    T: Serialize,
{
    use serde::ser::Error;

    // For testability, we allow to serialize one more level than deserialize.
    const MAX_TYPE_TAG_NESTING_WHEN_SERIALIZING: u8 =
        MAX_TYPE_TAG_NESTING + if cfg!(test) { 1 } else { 0 };

    TYPE_TAG_DEPTH.with(|depth| {
        let mut r = depth.borrow_mut();
        if *r >= MAX_TYPE_TAG_NESTING_WHEN_SERIALIZING {
            return Err(S::Error::custom(
                "type tag nesting exceeded during serialization",
            ));
        }
        *r += 1;
        Ok(())
    })?;
    let res = t.serialize(s);
    TYPE_TAG_DEPTH.with(|depth| {
        let mut r = depth.borrow_mut();
        *r -= 1;
    });
    res
}

pub(crate) fn type_tag_recursive_deserialize<'de, D, T>(d: D) -> Result<T, D::Error>
where
    D: Deserializer<'de>,
    T: Deserialize<'de>,
{
    use serde::de::Error;
    TYPE_TAG_DEPTH.with(|depth| {
        let mut r = depth.borrow_mut();
        if *r >= MAX_TYPE_TAG_NESTING {
            return Err(D::Error::custom(
                "type tag nesting exceeded during deserialization",
            ));
        }
        *r += 1;
        Ok(())
    })?;
    let res = T::deserialize(d);
    TYPE_TAG_DEPTH.with(|depth| {
        let mut r = depth.borrow_mut();
        *r -= 1;
    });
    res
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_types.rs (L1178-1223)
```rust
    /// Creates a fully-instantiated type from its storage representation.
    pub fn create_ty<F>(&self, ty_tag: &TypeTag, mut resolver: F) -> PartialVMResult<Type>
    where
        F: FnMut(&StructTag) -> PartialVMResult<Arc<StructType>>,
    {
        let mut count = 0;
        self.create_ty_impl(ty_tag, &mut resolver, &mut count, 1)
    }

    /// Clones the given type, at the same time instantiating all its type parameters.
    pub fn create_ty_with_subst(&self, ty: &Type, ty_args: &[Type]) -> PartialVMResult<Type> {
        let mut count = 0;
        let check = |c: &mut u64, d: u64| self.check(c, d);
        self.subst_impl(ty, ty_args, &mut count, 1, check)
    }

    #[inline]
    fn check(&self, count: &mut u64, depth: u64) -> PartialVMResult<()> {
        if *count >= self.max_ty_size {
            return self.too_many_nodes_error();
        }
        if depth > self.max_ty_depth {
            return self.too_large_depth_error();
        }
        Ok(())
    }

    #[cold]
    fn too_many_nodes_error(&self) -> PartialVMResult<()> {
        Err(
            PartialVMError::new(StatusCode::TOO_MANY_TYPE_NODES).with_message(format!(
                "Type size is larger than maximum {}",
                self.max_ty_size
            )),
        )
    }

    #[cold]
    fn too_large_depth_error(&self) -> PartialVMResult<()> {
        Err(
            PartialVMError::new(StatusCode::VM_MAX_TYPE_DEPTH_REACHED).with_message(format!(
                "Type depth is larger than maximum {}",
                self.max_ty_depth
            )),
        )
    }
```
