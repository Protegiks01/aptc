# Audit Report

## Title
Root Account Sequence Number Race Condition in Transaction Generator Pipeline

## Summary
The `create_seed_accounts()` function in the executor-benchmark contains a race condition where multiple transaction blocks are generated using stale sequence numbers from the database. When the pipeline buffer is large enough to queue multiple blocks before execution, subsequent blocks read the same sequence number from the database as previous blocks that haven't been executed yet, resulting in duplicate sequence numbers and transaction failures. [1](#0-0) 

## Finding Description
The vulnerability occurs in the `create_seed_accounts()` function's main loop that processes chunks of accounts. For each chunk, the function:

1. Reads the current sequence number from the database [2](#0-1) 

2. Sets the LocalAccount's sequence number to this value [3](#0-2) 

3. Creates multiple transactions, each incrementing the LocalAccount's internal sequence number [4](#0-3) 

4. Sends transactions to the pipeline **without waiting for execution** [5](#0-4) 

The critical issue is that when `generate_then_execute` mode is enabled, the pipeline uses a large buffer: [6](#0-5) 

This allows multiple chunks to be queued before any are executed. When chunk N+1 reads the sequence number from the database (step 1), chunk N's transactions haven't executed yet, so the database still contains the **original sequence number**. This causes both chunks to create transactions with identical sequence numbers.

The `LocalAccount::sign_with_transaction_builder()` method increments the sequence number atomically: [7](#0-6) [8](#0-7) 

But the `set_sequence_number()` call overwrites this value with the stale database value: [9](#0-8) 

**Broken Invariant:** Transaction sequence numbers must be strictly increasing and unique per account. This vulnerability causes duplicate sequence numbers across different transaction blocks.

## Impact Explanation
This qualifies as **HIGH** severity:

1. **Transaction Failures**: Multiple transactions from the root account will have duplicate sequence numbers, causing validation failures when submitted to the blockchain. This breaks the fundamental requirement that sequence numbers must be strictly increasing.

2. **Root Account Compromise**: The root account is a privileged account used for critical operations like account creation and funding. Transaction failures on this account can halt the benchmark's ability to create seed accounts.

3. **Benchmark Reliability**: The benchmark is used to test and validate blockchain performance. If transactions systematically fail due to sequence number conflicts, benchmark results become unreliable and could mask real performance issues.

4. **Pattern Indicates Broader Risk**: While this specific code is in the benchmark, similar sequence number management patterns may exist in production transaction generation code. The vulnerability demonstrates a dangerous pattern of reading sequence numbers from the database without proper synchronization.

## Likelihood Explanation
**Likelihood: HIGH**

This vulnerability triggers automatically under normal benchmark operation when:
- `generate_then_execute: true` is configured (which is the default) [10](#0-9) 

- Multiple chunks of seed accounts are created (happens when num_seed_accounts > block_size)
- Pipeline buffer is large enough to queue multiple blocks (buffer size â‰¥ 50 by default)

No attacker action is required - this is a logic bug that manifests during normal benchmark execution.

## Recommendation
Implement proper synchronization to ensure transactions are executed and committed before reading the sequence number for the next chunk. Two possible solutions:

**Option 1: Synchronous execution per chunk**
Add a completion signal after sending each block to wait for execution before proceeding to the next chunk. This ensures the database is updated with the new sequence number.

**Option 2: Track sequence number locally**
Instead of re-reading from the database every iteration, maintain the sequence number locally across chunks and only refresh from the database at the beginning of `create_seed_accounts()`:

```rust
pub fn create_seed_accounts(
    &mut self,
    reader: Arc<dyn DbReader>,
    num_new_accounts: usize,
    block_size: usize,
    seed_account_balance: u64,
    is_keyless: bool,
) {
    let num_seed_accounts = (num_new_accounts / 1000).clamp(1, 100000);
    let seed_accounts_cache =
        Self::gen_seed_account_cache(reader.clone(), num_seed_accounts, is_keyless);

    // Refresh ONCE at the beginning, not per chunk
    let current_seq_num = get_sequence_number(self.root_account.address(), reader.clone());
    self.root_account.set_sequence_number(current_seq_num);

    for chunk in seed_accounts_cache
        .accounts
        .iter()
        .collect::<Vec<_>>()
        .chunks(block_size)
    {
        // Remove the per-chunk refresh - rely on LocalAccount's internal counter
        let transactions: Vec<_> = chunk
            .iter()
            .map(|new_account| {
                let payload = aptos_stdlib::aptos_account_transfer(
                    new_account.authentication_key().account_address(),
                    seed_account_balance,
                );
                let builder = self.transaction_factory.payload(payload);
                let txn = self.root_account.sign_with_transaction_builder(builder);
                Transaction::UserTransaction(txn)
            })
            .collect();
        // ... rest of the function
    }
}
```

## Proof of Concept
The vulnerability can be demonstrated by running the executor-benchmark with instrumented logging:

```rust
// Add to create_seed_accounts() before line 494
eprintln!("Chunk iteration - LocalAccount seq_num before refresh: {}", 
          self.root_account.sequence_number());

// Add after line 495  
eprintln!("Chunk iteration - DB seq_num: {}, LocalAccount seq_num after refresh: {}", 
          current_seq_num, self.root_account.sequence_number());

// Add after line 508
eprintln!("Chunk iteration - LocalAccount seq_num after creating {} txns: {}", 
          transactions.len(), self.root_account.sequence_number());
```

Run the benchmark with settings that create multiple chunks:
- num_new_accounts = 10000 (creates 10 seed accounts with block_size=10)
- generate_then_execute = true (large pipeline buffer)
- Monitor the output for duplicate sequence numbers across chunks

Expected output demonstrating the bug:
```
Chunk 0 - LocalAccount seq_num before refresh: 0
Chunk 0 - DB seq_num: 0, LocalAccount seq_num after refresh: 0
Chunk 0 - LocalAccount seq_num after creating 10 txns: 10
Chunk 1 - LocalAccount seq_num before refresh: 10
Chunk 1 - DB seq_num: 0, LocalAccount seq_num after refresh: 0  // BUG: Reset to 0!
Chunk 1 - LocalAccount seq_num after creating 10 txns: 10      // Duplicate seq nums 0-9
```

## Notes
While this vulnerability exists in benchmark code rather than production node code, it represents a critical pattern of sequence number mismanagement that violates blockchain transaction ordering requirements. The root account is used for privileged operations, making transaction failures on this account particularly problematic. The vulnerability demonstrates the importance of proper synchronization when managing sequence numbers across async transaction pipelines.

### Citations

**File:** execution/executor-benchmark/src/transaction_generator.rs (L486-516)
```rust
        for chunk in seed_accounts_cache
            .accounts
            .iter()
            .collect::<Vec<_>>()
            .chunks(block_size)
        {
            // Refresh root account sequence number once per block from database
            // This ensures we stay in sync even if BlockMetadata or other transactions affected the account
            let current_seq_num = get_sequence_number(self.root_account.address(), reader.clone());
            self.root_account.set_sequence_number(current_seq_num);

            let transactions: Vec<_> = chunk
                .iter()
                .map(|new_account| {
                    let payload = aptos_stdlib::aptos_account_transfer(
                        new_account.authentication_key().account_address(),
                        seed_account_balance,
                    );
                    let builder = self.transaction_factory.payload(payload);
                    let txn = self.root_account.sign_with_transaction_builder(builder);
                    Transaction::UserTransaction(txn)
                })
                .collect();
            bar.inc(transactions.len() as u64 - 1);
            if let Some(sender) = &self.block_sender {
                // Add BlockMetadata transaction at the beginning of the block
                let mut block_transactions = vec![create_block_metadata_transaction(1, &self.db)];
                block_transactions.extend(transactions);
                sender.send(block_transactions).unwrap();
            }
        }
```

**File:** execution/executor-benchmark/src/pipeline.rs (L85-91)
```rust
        let (raw_block_sender, raw_block_receiver) = mpsc::sync_channel::<Vec<Transaction>>(
            if config.generate_then_execute {
                (num_blocks.unwrap() + 1).max(50)
            } else {
                10
            }, /* bound */
        );
```

**File:** sdk/src/types.rs (L354-368)
```rust
    pub fn sign_with_transaction_builder(&self, builder: TransactionBuilder) -> SignedTransaction {
        let raw_txn = if builder.has_nonce() {
            // Do not increment sequence number for orderless transactions.
            builder
                .sender(self.address())
                .sequence_number(u64::MAX)
                .build()
        } else {
            builder
                .sender(self.address())
                .sequence_number(self.increment_sequence_number())
                .build()
        };
        self.sign_transaction(raw_txn)
    }
```

**File:** sdk/src/types.rs (L546-548)
```rust
    pub fn increment_sequence_number(&self) -> u64 {
        self.sequence_number.fetch_add(1, Ordering::SeqCst)
    }
```

**File:** sdk/src/types.rs (L554-557)
```rust
    pub fn set_sequence_number(&self, sequence_number: u64) {
        self.sequence_number
            .store(sequence_number, Ordering::SeqCst);
    }
```

**File:** execution/executor-benchmark/src/lib.rs (L897-898)
```rust
    let execute_pipeline_config = PipelineConfig {
        generate_then_execute: true,
```
