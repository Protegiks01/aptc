# Audit Report

## Title
Out-of-Bounds Panic in Ristretto255 Native Functions via Malicious Bytecode Publishing

## Summary
An attacker can craft malicious Move bytecode that bypasses compiler-enforced struct visibility constraints to create a `RistrettoPoint` struct with an arbitrary handle value exceeding the `points` vector length. When this malicious point is passed to any native function, it triggers an out-of-bounds panic via `.unwrap()`, crashing the validator node during transaction execution.

## Finding Description
The Ristretto255 native implementation assumes that `RistrettoPoint` structs can only be created through legitimate functions in the `ristretto255.move` module, which allocate handles sequentially via `safe_add_point()`. However, this invariant relies on the Move compiler's enforcement that the `Pack` bytecode instruction can only be used within the defining module.

The vulnerability exists because:

1. **No bounds checking in native functions:** The `get_point()` function directly accesses the vector without validation: [1](#0-0) 

2. **Handle extraction without validation:** Native functions extract handle values from Move structs without bounds checking: [2](#0-1) 

3. **Bytecode verifier gap:** The bytecode verifier performs type safety, stack safety, and resource safety checks, but does NOT enforce struct Pack visibility constraints: [3](#0-2) 

4. **Module publishing allows hand-crafted bytecode:** Modules are published as raw bytes that only need to pass bytecode verification: [4](#0-3) 

5. **Bytecode verification occurs but doesn't check Pack visibility:** During module publishing, bytecode verification runs but only validates the checks documented in the verifier README: [5](#0-4) 

**Attack path:**
1. Attacker crafts malicious Move bytecode (not using official compiler) containing a `Pack` instruction that creates `RistrettoPoint { handle: u64::MAX }`
2. Bytecode passes deserialization and verification (type-correct Pack operation)
3. Module is published successfully
4. Transaction executes, creating the malicious point
5. Point is passed to any native function (`point_compress`, `point_add`, `point_mul`, etc.)
6. Native function calls `get_point(&handle)` â†’ `self.points.get(u64::MAX as usize).unwrap()`
7. `.get()` returns `None` for out-of-bounds access
8. `.unwrap()` panics, crashing validator node

## Impact Explanation
This vulnerability is classified as **HIGH severity** according to Aptos bug bounty criteria because it enables:

- **Validator node crashes:** Executing the malicious transaction causes a panic that crashes the validator node
- **Consensus disruption:** If multiple validators execute the same malicious transaction during consensus, it can disrupt block production
- **Deterministic execution violation:** The panic breaks the invariant that all validators produce identical state roots for identical blocks

The impact is limited to availability (node crashes) rather than fund theft or state corruption, qualifying it as High rather than Critical severity per the bug bounty guidelines: "Validator node slowdowns / API crashes / Significant protocol violations."

## Likelihood Explanation
The likelihood is **MEDIUM** because:

**Attacker requirements (Low barrier):**
- Ability to craft or modify Move bytecode (tools exist, or manually edit compiled bytecode)
- Knowledge of the Pack bytecode instruction format
- Ability to submit transactions (no special privileges required)

**Complexity (Medium):**
- Requires understanding of Move bytecode format
- Must bypass compiler to craft malicious bytecode
- Needs to construct valid bytecode that passes verifier checks

**Detection:**
- The malicious module would be published on-chain and visible
- However, detecting the specific Pack instruction targeting RistrettoPoint requires bytecode analysis

## Recommendation

**Immediate fix:** Add bounds checking in the native functions to return errors instead of panicking:

```rust
pub fn get_point(&self, handle: &RistrettoPointHandle) -> SafeNativeResult<&RistrettoPoint> {
    self.points.get(handle.0 as usize)
        .ok_or_else(|| SafeNativeError::Abort { 
            abort_code: INVALID_POINT_HANDLE 
        })
}

pub fn get_point_mut(&mut self, handle: &RistrettoPointHandle) -> SafeNativeResult<&mut RistrettoPoint> {
    self.points.get_mut(handle.0 as usize)
        .ok_or_else(|| SafeNativeError::Abort { 
            abort_code: INVALID_POINT_HANDLE 
        })
}
```

**Long-term fix:** Consider adding bytecode verifier checks to enforce that Pack instructions for structs only appear in the defining module, or implement runtime validation of struct construction.

## Proof of Concept

```move
// Malicious module (conceptual - would require hand-crafting bytecode)
module attacker::exploit {
    use aptos_std::ristretto255;
    
    // This function would contain malicious bytecode that directly
    // packs a RistrettoPoint with handle = u64::MAX
    // Normal Move compiler would reject this, but hand-crafted bytecode
    // with the Pack instruction could bypass this check
    
    public entry fun crash_validator() {
        // Bytecode instruction: Pack RistrettoPoint { handle: 18446744073709551615 }
        // When passed to any native function like point_compress, 
        // causes validator crash
    }
}
```

**Rust test demonstrating the panic:**
```rust
#[test]
#[should_panic(expected = "called `Option::unwrap()` on a `None` value")]
fn test_out_of_bounds_handle_panic() {
    let mut point_store = PointStore::default();
    point_store.points.push(RistrettoPoint::identity());
    
    let malicious_handle = RistrettoPointHandle(u64::MAX);
    let _point = point_store.get_point(&malicious_handle); // Panics
}
```

## Notes
This vulnerability represents a fundamental gap between compiler-time and bytecode verification-time security checks. The Move security model assumes code originates from the compiler, but the VM accepts raw bytecode that bypasses compiler invariant enforcement. This affects not just Ristretto255 but potentially other native functions that assume struct fields contain only "legitimate" values.

### Citations

**File:** aptos-move/framework/src/natives/cryptography/ristretto255_point.rs (L119-122)
```rust
    pub fn get_point(&self, handle: &RistrettoPointHandle) -> &RistrettoPoint {
        //&self.points[handle.0 as usize]
        self.points.get(handle.0 as usize).unwrap()
    }
```

**File:** aptos-move/framework/src/natives/cryptography/ristretto255_point.rs (L662-670)
```rust
pub fn get_point_handle(move_point: &StructRef) -> SafeNativeResult<RistrettoPointHandle> {
    let field_ref = move_point
        .borrow_field(HANDLE_FIELD_INDEX)?
        .value_as::<Reference>()?;

    let handle = field_ref.read_ref()?.value_as::<u64>()?;

    Ok(RistrettoPointHandle(handle))
}
```

**File:** third_party/move/move-bytecode-verifier/src/type_safety.rs (L435-455)
```rust
fn pack(
    verifier: &mut TypeSafetyChecker,
    meter: &mut impl Meter,
    offset: CodeOffset,
    struct_def: &StructDefinition,
    variant: Option<VariantIndex>,
    type_args: &Signature,
) -> PartialVMResult<()> {
    let struct_type = materialize_type(struct_def.struct_handle, type_args);
    let field_sig = type_fields_signature(verifier, meter, offset, struct_def, variant, type_args)?;
    for sig in field_sig.0.iter().rev() {
        let arg = safe_unwrap!(verifier.stack.pop());
        // For field signature to argument, use assignability
        if !sig.is_assignable_from(&arg) {
            return Err(verifier.error(StatusCode::PACK_TYPE_MISMATCH_ERROR, offset));
        }
    }

    verifier.push(meter, struct_type)?;
    Ok(())
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1444-1460)
```rust
    fn deserialize_module_bundle(&self, modules: &ModuleBundle) -> VMResult<Vec<CompiledModule>> {
        let mut result = vec![];
        for module_blob in modules.iter() {
            match CompiledModule::deserialize_with_config(
                module_blob.code(),
                self.deserializer_config(),
            ) {
                Ok(module) => {
                    result.push(module);
                },
                Err(_err) => {
                    return Err(PartialVMError::new(StatusCode::CODE_DESERIALIZATION_ERROR)
                        .finish(Location::Undefined))
                },
            }
        }
        Ok(result)
```

**File:** third_party/move/move-vm/runtime/src/storage/environment.rs (L192-195)
```rust
            move_bytecode_verifier::verify_module_with_config(
                &self.vm_config().verifier_config,
                compiled_module.as_ref(),
            )?;
```
