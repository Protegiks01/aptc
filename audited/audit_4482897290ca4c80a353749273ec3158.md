# Audit Report

## Title
Incorrect Version-to-Slot Mapping in Indexer Cache Causes Data Corruption

## Summary
A critical logic error in the `update_data()` function of the indexer-grpc data service causes transactions to be stored at wrong cache slots when the cache window has advanced. This results in `get_data()` returning transactions from incorrect versions, corrupting indexer databases and applications that rely on this service.

## Finding Description

The vulnerability exists in the version calculation logic when updating the in-memory cache with historical transaction data. [1](#0-0) 

The bug occurs when:
1. `fetch_past_data()` is called for a version range (e.g., [105, 115))
2. During the fetch, another thread advances the cache window (e.g., to [110, 210))
3. When `update_data()` processes the fetched transactions:
   - It calculates `num_to_skip = 110 - 105 = 5` to skip old transactions
   - It adjusts `start_version` to `110`
   - It uses `enumerate().skip(5)` which preserves original indices [5, 6, 7, 8, 9]
   - It calculates `version = adjusted_start_version + enumeration_index`
   - For transaction 110 (at index 5): `version = 110 + 5 = 115` ‚ùå
   - This stores transaction 110 at slot 15 instead of slot 10

When `get_data()` subsequently reads version 110, it accesses slot 10 which is empty or contains wrong data, while the actual transaction 110 is at slot 15. [2](#0-1) 

The race condition triggering this bug occurs here: [3](#0-2) 

After checking that data is missing (line 73), the lock is dropped (line 74) before calling `fetch_past_data()` (line 75), allowing other threads to modify the cache window.

## Impact Explanation

**Medium Severity**: This vulnerability causes state inconsistencies in the indexer-grpc data service, a critical infrastructure component that serves transaction data to external indexers, DApps, wallets, and blockchain explorers.

Impact:
- **Data Corruption**: Indexers receive transactions from wrong versions, causing database corruption
- **Application Failures**: DApps and wallets display incorrect balances, events, and NFT ownership
- **User Harm**: Users see wrong account states, potentially leading to incorrect financial decisions
- **Ecosystem Disruption**: All services depending on this indexer service are affected

This qualifies as **Medium Severity** per the bug bounty program: "State inconsistencies requiring intervention" - indexer databases would need to be wiped and re-synchronized.

## Likelihood Explanation

**High Likelihood**: This bug triggers naturally during normal operation without requiring malicious input:

1. **Common Scenario**: When clients request historical data while new blocks are being produced
2. **Race Window**: The time between lines 74-75 in `in_memory_cache.rs` is sufficient for cache advancement
3. **Automatic Occurrence**: The `continuously_fetch_latest_data()` task constantly advances the cache
4. **No Mitigation**: No locks prevent this race condition
5. **Persistent Effect**: Once wrong data is cached, it continues to be served to all subsequent clients

The bug will trigger whenever fetch latency overlaps with cache eviction, which happens regularly under normal load.

## Recommendation

Fix the version calculation by using the original `start_version` parameter instead of the adjusted value:

```rust
pub(super) fn update_data(&mut self, start_version: u64, transactions: Vec<Transaction>) {
    let end_version = start_version + transactions.len() as u64;
    
    // ... validation checks ...
    
    let num_to_skip = self.start_version.saturating_sub(start_version);
    let adjusted_start_version = start_version.max(self.start_version);
    
    let mut size_increased = 0;
    let mut size_decreased = 0;
    
    for (i, transaction) in transactions
        .into_iter()
        .enumerate()
        .skip(num_to_skip as usize)
    {
        // Use original start_version, not adjusted
        let version = start_version + i as u64;
        let slot_index = version as usize % self.num_slots;
        // ... rest of the logic ...
    }
}
```

Alternatively, move `enumerate()` after `skip()`:

```rust
for (i, transaction) in transactions
    .into_iter()
    .skip(num_to_skip as usize)
    .enumerate()
{
    let version = adjusted_start_version + i as u64;
    // ... rest of the logic ...
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[test]
    fn test_version_mismatch_bug() {
        let mut dm = DataManager::new(200, 100, 1_000_000);
        
        // Simulate cache advancement to [110, 200)
        dm.start_version = 110;
        dm.end_version = 200;
        
        // Create transactions for versions [105, 115)
        let transactions: Vec<Transaction> = (105..115)
            .map(|v| {
                let mut txn = Transaction::default();
                txn.version = v;
                txn
            })
            .collect();
        
        // Update cache - this should store txn_110 at slot 10
        dm.update_data(105, transactions);
        
        // Try to read version 110
        let txn_110 = dm.get_data(110);
        
        // BUG: txn_110 is None or contains wrong data
        // because the actual txn_110 was stored at slot 15
        assert!(txn_110.is_some());
        assert_eq!(txn_110.as_ref().unwrap().version, 110); // This fails!
        
        // Verify wrong data is at slot 15 (version 115's slot)
        let txn_115 = dm.get_data(115);
        assert!(txn_115.is_some());
        assert_eq!(txn_115.as_ref().unwrap().version, 110); // txn_110 is here!
    }
}
```

## Notes

This vulnerability is specific to the indexer-grpc data service infrastructure component and does not affect blockchain consensus, validator operations, or on-chain state. However, it has significant impact on the Aptos ecosystem as this service is the primary data source for indexers, explorers, wallets, and DApps. The bug causes systematic data corruption that propagates to all downstream services and cannot self-correct without manual intervention.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/data_manager.rs (L40-42)
```rust
    pub(super) fn get_data(&self, version: u64) -> &Option<Box<Transaction>> {
        &self.data[version as usize % self.num_slots]
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/data_manager.rs (L75-87)
```rust
        for (i, transaction) in transactions
            .into_iter()
            .enumerate()
            .skip(num_to_skip as usize)
        {
            let version = start_version + i as u64;
            let slot_index = version as usize % self.num_slots;
            if let Some(transaction) = self.data[slot_index].take() {
                size_decreased += transaction.encoded_len();
            }
            size_increased += transaction.encoded_len();
            self.data[version as usize % self.num_slots] = Some(Box::new(transaction));
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-data-service-v2/src/live_data_service/in_memory_cache.rs (L73-77)
```rust
            if data_manager.get_data(starting_version).is_none() {
                drop(data_manager);
                self.fetch_manager.fetch_past_data(starting_version).await;
                continue;
            }
```
