# Audit Report

## Title
Topology Isolation Attack via Insufficient Validator Distance Validation in Peer Monitoring Service

## Summary
The validation logic in `handle_monitoring_service_response()` allows validators and VFNs to report arbitrary high distances from the validator set (≥2) without proper verification of their actual role-based distance. This enables malicious or compromised validators to cause victim nodes to miscalculate their network topology position, leading to peer deprioritization and protocol degradation.

## Finding Description

The peer monitoring service validates distance reports using a unidirectional logical implication that is insufficient to prevent validators from lying about their topology position. [1](#0-0) 

The validation logic implements:
- **IF distance = 0 THEN peer must be validator** (lines 119-126)
- **IF distance = 1 THEN peer must be VFN** (lines 128-135)  
- **IF distance ≥ 2 THEN only check distance ≤ MAX_DISTANCE_FROM_VALIDATORS** (lines 137-140)

However, it fails to enforce the converse:
- **IF peer is validator THEN distance must be 0**
- **IF peer is VFN THEN distance must be 1**

This allows validators to report `distance_from_validators = 100` (or any value ≥2) which passes validation on line 139, even though validators should always report distance 0.

**Attack Propagation**:

1. A victim VFN connects to malicious/compromised validators
2. The malicious validators report `distance_from_validators = 100` instead of the correct value 0
3. This passes validation since the only check for distance ≥2 is whether it's ≤ MAX_DISTANCE_FROM_VALIDATORS (100)
4. The victim VFN stores this false information via `record_network_info_response()` (line 157)
5. When calculating its own distance, the VFN uses the minimum reported distance from peers: [2](#0-1) 

6. The VFN calculates `min(100) + 1 = min(100, 101) = 100` and believes it's distance 100 from validators when actually distance 1
7. This false distance is then propagated to other nodes and affects critical peer selection algorithms

**Security Guarantees Broken**:

The vulnerability violates the network topology integrity invariant. Nodes must accurately know their distance from validators to make correct peer selection decisions for:

- **Mempool transaction propagation** - Uses `compare_validator_distance()` to prioritize peers: [3](#0-2) 

- **Consensus observer subscriptions** - Sorts peers by distance, prioritizing closer peers: [4](#0-3) 

- **State sync peer selection** - Chooses peers weighted by distance: [5](#0-4) 

## Impact Explanation

**Severity: High** (per Aptos Bug Bounty criteria)

This vulnerability causes **validator node slowdowns** and **significant protocol violations**:

1. **Mempool Priority Inversion**: Victim nodes with artificially inflated distances are severely deprioritized by honest nodes for transaction propagation, causing transaction delivery delays and network inefficiency

2. **Consensus Observer Degradation**: Victim nodes attempting to subscribe to consensus updates will be deprioritized, potentially receiving stale or delayed consensus information

3. **Virtual Network Partition**: If multiple validators collude to report false distances, a subset of the network can be effectively isolated from proper validator connectivity, creating a soft partition without actual network failure

4. **Cascading Mis-prioritization**: The victim node itself will make suboptimal peer selection decisions and propagate its false distance to others, amplifying the attack's impact

While this doesn't directly break consensus safety or cause fund loss, it significantly degrades network performance and can cause validator operational issues, meeting the High severity threshold of "validator node slowdowns" and "significant protocol violations."

## Likelihood Explanation

**Likelihood: Medium to High**

The attack requires:
- A compromised or malicious validator (privileged role)
- Victim nodes connecting to the malicious validator(s)
- No additional cryptographic breaks or complex exploitation

While validator compromise requires insider access or sophisticated attack, the simplicity of exploitation once access is gained makes this realistic. The attack is:
- **Trivial to execute**: Single line change in validator's response
- **Hard to detect**: False distances look like legitimate reports from partitioned nodes
- **Difficult to remediate**: Requires identifying and disconnecting from malicious validators

Given the high-value targets (validators) and increasing sophistication of attacks against blockchain infrastructure, validator compromise is a credible threat model that defense-in-depth measures should address.

## Recommendation

Implement bidirectional validation that enforces role-to-distance constraints:

```rust
// Sanity check the response depth from the peer metadata
let network_id = peer_network_id.network_id();
let peer_role = peer_metadata.get_connection_metadata().role;

let is_valid_depth = match network_info_response.distance_from_validators {
    0 => {
        // Verify the peer is a validator and has the correct network id
        let peer_is_validator = peer_role.is_validator();
        let peer_has_correct_network = match self.base_config.role {
            RoleType::Validator => network_id.is_validator_network(),
            RoleType::FullNode => network_id.is_vfn_network(),
        };
        peer_is_validator && peer_has_correct_network
    },
    1 => {
        // Verify the peer is a VFN and has the correct network id
        let peer_is_vfn = peer_role.is_vfn();
        let peer_has_correct_network = match self.base_config.role {
            RoleType::Validator => network_id.is_vfn_network(),
            RoleType::FullNode => network_id.is_public_network(),
        };
        peer_is_vfn && peer_has_correct_network
    },
    distance_from_validators => {
        // For distance >= 2, validate that the peer is NOT a validator or VFN
        // (since they should report 0 or 1 respectively)
        let peer_is_validator = peer_role.is_validator();
        let peer_is_vfn = peer_role.is_vfn();
        
        // Validators and VFNs should never report distance >= 2
        if peer_is_validator || peer_is_vfn {
            return false;
        }
        
        // For other peers, just check the maximum distance constraint
        distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS
    },
};
```

This enforces that validators MUST report distance 0 and VFNs MUST report distance 1, preventing the topology isolation attack.

## Proof of Concept

```rust
#[cfg(test)]
mod vulnerability_test {
    use super::*;
    use aptos_config::{
        config::{BaseConfig, NodeConfig, PeerRole, RoleType},
        network_id::{NetworkId, PeerNetworkId},
    };
    use aptos_netcore::transport::ConnectionOrigin;
    use aptos_network::{
        application::metadata::PeerMetadata,
        protocols::wire::handshake::v1::{MessagingProtocolVersion, ProtocolIdSet},
        transport::{ConnectionId, ConnectionMetadata},
    };
    use aptos_peer_monitoring_service_types::{
        request::PeerMonitoringServiceRequest,
        response::{NetworkInformationResponse, PeerMonitoringServiceResponse},
    };
    use aptos_time_service::TimeService;
    use aptos_types::{network_address::NetworkAddress, PeerId};
    use std::str::FromStr;

    #[test]
    fn test_validator_can_lie_about_distance() {
        // Create a VFN node
        let node_config = NodeConfig {
            base: BaseConfig {
                role: RoleType::FullNode,
                ..Default::default()
            },
            ..Default::default()
        };
        let mut network_info_state = NetworkInfoState::new(node_config, TimeService::mock());

        // Create a malicious validator peer that reports distance 100 instead of 0
        let malicious_validator = PeerNetworkId::new(NetworkId::Vfn, PeerId::random());
        let connection_metadata = ConnectionMetadata::new(
            malicious_validator.peer_id(),
            ConnectionId::default(),
            NetworkAddress::from_str("/ip4/127.0.0.1/tcp/8081").unwrap(),
            ConnectionOrigin::Outbound,
            MessagingProtocolVersion::V1,
            ProtocolIdSet::empty(),
            PeerRole::Validator, // This is a validator
        );
        let peer_metadata = PeerMetadata::new(connection_metadata);

        // The malicious validator reports distance 100 (should be 0)
        let malicious_response =
            PeerMonitoringServiceResponse::NetworkInformation(NetworkInformationResponse {
                connected_peers: Default::default(),
                distance_from_validators: 100, // Lying!
            });

        // Handle the response - this SHOULD fail but actually passes
        network_info_state.handle_monitoring_service_response(
            &malicious_validator,
            peer_metadata,
            PeerMonitoringServiceRequest::GetNetworkInformation,
            malicious_response,
            0.0,
        );

        // Verify that the false distance was accepted
        let stored_response = network_info_state.get_latest_network_info_response();
        assert!(stored_response.is_some());
        assert_eq!(stored_response.unwrap().distance_from_validators, 100);
        
        // This demonstrates the vulnerability: a validator successfully lied about its distance
        // The VFN now believes it's far from validators when it's actually directly connected
    }
}
```

The test demonstrates that a validator can report `distance_from_validators = 100` and the validation logic incorrectly accepts it, allowing topology isolation attacks.

## Notes

This vulnerability requires a compromised validator (privileged role), which is typically considered a trusted actor. However, defense-in-depth principles dictate that even trusted components should be validated. The current validation logic has a clear logical flaw that makes the system unnecessarily vulnerable to insider threats or validator compromise scenarios.

### Citations

**File:** peer-monitoring-service/client/src/peer_states/network_info.rs (L118-141)
```rust
        let is_valid_depth = match network_info_response.distance_from_validators {
            0 => {
                // Verify the peer is a validator and has the correct network id
                let peer_is_validator = peer_metadata.get_connection_metadata().role.is_validator();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_validator_network(), // We're a validator
                    RoleType::FullNode => network_id.is_vfn_network(),        // We're a VFN
                };
                peer_is_validator && peer_has_correct_network
            },
            1 => {
                // Verify the peer is a VFN and has the correct network id
                let peer_is_vfn = peer_metadata.get_connection_metadata().role.is_vfn();
                let peer_has_correct_network = match self.base_config.role {
                    RoleType::Validator => network_id.is_vfn_network(), // We're a validator
                    RoleType::FullNode => network_id.is_public_network(), // We're a VFN or PFN
                };
                peer_is_vfn && peer_has_correct_network
            },
            distance_from_validators => {
                // The distance must be less than or equal to the max
                distance_from_validators <= MAX_DISTANCE_FROM_VALIDATORS
            },
        };
```

**File:** peer-monitoring-service/server/src/lib.rs (L321-339)
```rust
    // Otherwise, go through our peers, find the min, and return a distance relative to the min
    let mut min_peer_distance_from_validators = MAX_DISTANCE_FROM_VALIDATORS;
    for peer_metadata in connected_peers_and_metadata.values() {
        if let Some(ref latest_network_info_response) = peer_metadata
            .get_peer_monitoring_metadata()
            .latest_network_info_response
        {
            min_peer_distance_from_validators = min(
                min_peer_distance_from_validators,
                latest_network_info_response.distance_from_validators,
            );
        }
    }

    // We're one hop away from the peer
    min(
        MAX_DISTANCE_FROM_VALIDATORS,
        min_peer_distance_from_validators + 1,
    )
```

**File:** mempool/src/shared_mempool/priority.rs (L613-639)
```rust
/// Compares the validator distance for the given pair of monitoring metadata.
/// The peer with the lowest validator distance is prioritized.
fn compare_validator_distance(
    monitoring_metadata_a: &Option<&PeerMonitoringMetadata>,
    monitoring_metadata_b: &Option<&PeerMonitoringMetadata>,
) -> Ordering {
    // Get the validator distance from the monitoring metadata
    let validator_distance_a = get_distance_from_validators(monitoring_metadata_a);
    let validator_distance_b = get_distance_from_validators(monitoring_metadata_b);

    // Compare the distances
    match (validator_distance_a, validator_distance_b) {
        (Some(validator_distance_a), Some(validator_distance_b)) => {
            // Prioritize the peer with the lowest validator distance
            validator_distance_a.cmp(&validator_distance_b).reverse()
        },
        (Some(_), None) => {
            Ordering::Greater // Prioritize the peer with a validator distance
        },
        (None, Some(_)) => {
            Ordering::Less // Prioritize the peer with a validator distance
        },
        (None, None) => {
            Ordering::Equal // Neither peer has a validator distance
        },
    }
}
```

**File:** consensus/src/consensus_observer/observer/subscription_utils.rs (L283-312)
```rust
pub fn sort_peers_by_subscription_optimality(
    peers_and_metadata: &HashMap<PeerNetworkId, PeerMetadata>,
) -> Vec<PeerNetworkId> {
    // Group peers and latencies by validator distance, i.e., distance -> [(peer, latency)]
    let mut unsupported_peers = Vec::new();
    let mut peers_and_latencies_by_distance = BTreeMap::new();
    for (peer_network_id, peer_metadata) in peers_and_metadata {
        // Verify that the peer supports consensus observer
        if !supports_consensus_observer(peer_metadata) {
            unsupported_peers.push(*peer_network_id);
            continue; // Skip the peer
        }

        // Get the distance and latency for the peer
        let distance = get_distance_for_peer(peer_network_id, peer_metadata);
        let latency = get_latency_for_peer(peer_network_id, peer_metadata);

        // If the distance is not found, use the maximum distance
        let distance =
            distance.unwrap_or(aptos_peer_monitoring_service_types::MAX_DISTANCE_FROM_VALIDATORS);

        // If the latency is not found, use a large latency
        let latency = latency.unwrap_or(MAX_PING_LATENCY_SECS);

        // Add the peer and latency to the distance group
        peers_and_latencies_by_distance
            .entry(distance)
            .or_insert_with(Vec::new)
            .push((*peer_network_id, OrderedFloat(latency)));
    }
```

**File:** state-sync/aptos-data-client/src/utils.rs (L26-64)
```rust
pub fn choose_random_peers_by_distance_and_latency(
    peers: HashSet<PeerNetworkId>,
    peers_and_metadata: Arc<PeersAndMetadata>,
    num_peers_to_choose: usize,
) -> HashSet<PeerNetworkId> {
    // Group peers and latency weights by validator distance, i.e., distance -> [(peer, latency weight)]
    let mut peers_and_latencies_by_distance = BTreeMap::new();
    for peer in peers {
        if let Some((distance, latency)) =
            get_distance_and_latency_for_peer(&peers_and_metadata, peer)
        {
            let latency_weight = convert_latency_to_weight(latency);
            peers_and_latencies_by_distance
                .entry(distance)
                .or_insert_with(Vec::new)
                .push((peer, latency_weight));
        }
    }

    // Select the peers by distance and latency weights. Note: BTreeMaps are
    // sorted by key, so the entries will be sorted by distance in ascending order.
    let mut selected_peers = HashSet::new();
    for (_, peers_and_latencies) in peers_and_latencies_by_distance {
        // Select the peers by latency weights
        let num_peers_remaining = num_peers_to_choose.saturating_sub(selected_peers.len()) as u64;
        let peers = choose_random_peers_by_weight(num_peers_remaining, peers_and_latencies);

        // Add the peers to the entire set
        selected_peers.extend(peers);

        // If we have selected enough peers, return early
        if selected_peers.len() >= num_peers_to_choose {
            return selected_peers;
        }
    }

    // Return the selected peers
    selected_peers
}
```
