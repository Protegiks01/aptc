# Audit Report

## Title
Missing Bounds Validation for MAX_PROMOTIONS_PER_BLOCK On-Chain Configuration Enables Memory Exhaustion Attacks

## Summary
The `MAX_PROMOTIONS_PER_BLOCK` constant in `BlockHotStateOpAccumulator` is planned to become an on-chain governance-controlled parameter (per TODO comment), but lacks bounds validation. If governance sets this to extremely high values (e.g., millions or billions), attackers can exploit this to cause memory exhaustion on validator nodes by crafting transactions that read many unique state keys, potentially leading to network liveness degradation. [1](#0-0) 

## Finding Description

The hot state optimization system tracks frequently-read state keys to promote them to "hot state" for faster access. The `BlockHotStateOpAccumulator` maintains a `BTreeSet<Key>` called `to_make_hot` that accumulates read-only keys across all transactions in a block. [2](#0-1) 

Currently, `MAX_PROMOTIONS_PER_BLOCK` is hardcoded to 10,240 (1024 * 10). During transaction accumulation, keys are added to the `to_make_hot` set until the limit is reached: [3](#0-2) 

The TODO comment at line 27 indicates this should become an on-chain configuration parameter. However, examining similar on-chain configs reveals they implement validation bounds. For example, `staking_config.move` validates stake bounds to prevent invalid configurations.

**The Vulnerability:**

If `MAX_PROMOTIONS_PER_BLOCK` becomes on-chain configurable without bounds validation, the following attack scenario becomes possible:

1. **Governance sets extreme value:** Through a governance proposal, `MAX_PROMOTIONS_PER_BLOCK` is set to an extremely high value (e.g., 10 million or 100 million) either accidentally or maliciously.

2. **Memory consumption math:** Each `StateKey` is approximately 100 bytes (32-byte address + 32-byte hash + metadata). With 10 million keys: 10,000,000 × 100 bytes = ~1 GB for the `BTreeSet` alone.

3. **Multiple memory allocations:** The keys are held in multiple data structures during block execution:
   - Original `to_make_hot` BTreeSet in `BlockHotStateOpAccumulator`
   - Cloned when calling `get_keys_to_make_hot()` [4](#0-3) 
   - Stored in `TBlockEndInfoExt` [5](#0-4) 
   - Converted to `BTreeMap<StateKey, HotStateOp>` in WriteSet's hotness field [6](#0-5) 

4. **Attacker exploitation:** An attacker crafts transactions that read many unique state keys. While block gas limits constrain total reads, if the limit is removed or set too high, the attacker can fill the `to_make_hot` set to approach `MAX_PROMOTIONS_PER_BLOCK`.

5. **Deterministic impact:** All validators execute the same block with identical transactions, so all nodes experience simultaneous memory pressure, potentially causing:
   - Memory exhaustion (OOM errors)
   - Severe performance degradation
   - Node crashes
   - Network liveness failures

**Critical Observation:** The `to_make_hot` keys are NOT serialized in the BlockEpiloguePayload (only the inner BlockEndInfo is serialized), so transaction size limits don't protect against this: [7](#0-6) 

## Impact Explanation

This vulnerability qualifies as **Medium severity** under the Aptos bug bounty criteria:

- **"State inconsistencies requiring intervention"**: Memory exhaustion could cause validator nodes to crash or become unresponsive, requiring manual intervention to recover the network.
  
- **Potential High severity** if it causes "Validator node slowdowns": Processing millions of keys in BTreeSet operations (O(log n) per insert) could severely degrade block execution performance across the entire validator set.

The impact is amplified because:
1. All validators are affected simultaneously (deterministic execution)
2. It doesn't require special privileges to exploit once the config is set high
3. Recovery requires governance action to reduce the limit
4. Existing block gas limits provide some natural protection, but removing this safety cap is dangerous

## Likelihood Explanation

**Current Likelihood: Low** (requires configuration change that hasn't been implemented yet)

**Future Likelihood: Medium** (if implemented without bounds validation):
- Governance could accidentally set unsafe values during configuration updates
- Malicious governance proposals could intentionally set extreme values
- The TODO comment indicates this change is planned: "TODO(HotState): make on-chain config" [8](#0-7) 

The attacker requirements are minimal once an unsafe value is set:
- No special privileges needed
- Can craft transactions with many state reads
- Constrained only by block gas limits, but gas costs may be low enough to read thousands of keys per block

## Recommendation

Implement strict bounds validation when making `MAX_PROMOTIONS_PER_BLOCK` an on-chain configuration parameter. Follow the pattern used in other on-chain configs:

1. **Define reasonable bounds:**
   - Minimum value: 0 (allows disabling the feature)
   - Maximum value: A safe upper bound (e.g., 100,000) that prevents memory exhaustion
   - Consider memory constraints: Even with 100k keys × 100 bytes = 10 MB, which is manageable

2. **Add validation function** (pseudocode pattern based on staking_config validation):
   ```move
   public fun validate_hot_state_config(max_promotions_per_block: u64) {
       assert!(max_promotions_per_block <= MAX_SAFE_PROMOTIONS, EINVALID_CONFIG);
   }
   ```

3. **Enforce validation during configuration updates:**
   - In the genesis initialization function
   - In any governance update functions that modify this parameter
   - Similar to how `validate_required_stake` is called in staking_config:

4. **Add monitoring:** Implement metrics to track when `max_promotions_per_block_hit` counter is triggered frequently, indicating the limit may need adjustment.

5. **Consider dynamic sizing:** Instead of a fixed limit, calculate based on available memory and current block gas limits to ensure safety even as other parameters change.

## Proof of Concept

While a full PoC would require implementing the on-chain config (which doesn't exist yet), here's a conceptual reproduction:

**Step 1:** Modify `BlockHotStateOpAccumulator::new()` to accept a dangerously high value:
```rust
// Simulating malicious governance setting
let accumulator = BlockHotStateOpAccumulator::new_with_config(10_000_000); 
```

**Step 2:** Create transactions that read unique state keys:
```rust
// Each transaction reads 1000 unique keys
for i in 0..10_000 {
    let reads = (0..1000).map(|j| StateKey::new(i * 1000 + j));
    accumulator.add_transaction(std::iter::empty(), reads);
}
// Result: to_make_hot BTreeSet contains 10,000,000 keys
// Memory usage: ~1 GB just for this structure
```

**Step 3:** Observe memory exhaustion during `get_keys_to_make_hot()`:
```rust
let keys = accumulator.get_keys_to_make_hot(); // Clones 10M keys = another 1 GB
// Total memory for hot state tracking: multiple GBs per block
```

**Expected outcome:** On validator nodes with limited memory, this causes OOM errors or severe performance degradation, affecting network liveness.

**Notes:**
- The actual exploitability depends on block gas limits and gas costs for state reads
- Even if current constraints prevent reaching millions of keys, the lack of bounds validation is a design flaw that could become exploitable if gas parameters change
- The hardcoded 10,240 limit provides critical protection that should be preserved through validation if the parameter becomes configurable

### Citations

**File:** aptos-move/block-executor/src/hot_state_op_accumulator.rs (L10-21)
```rust
pub struct BlockHotStateOpAccumulator<Key> {
    /// Keys read but never written to across the entire block are to be made hot (or refreshed
    /// `hot_since_version` one is already hot but last refresh is far in the history) as the side
    /// effect of the block epilogue (subject to per block limit)
    to_make_hot: BTreeSet<Key>,
    /// Keep track of all the keys that are written to across the whole block, these keys are made
    /// hot (or have a refreshed `hot_since_version`) immediately at the version they got changed,
    /// so no need to issue separate HotStateOps to promote them to the hot state.
    writes: hashbrown::HashSet<Key>,
    /// To prevent the block epilogue from being too heavy.
    max_promotions_per_block: usize,
}
```

**File:** aptos-move/block-executor/src/hot_state_op_accumulator.rs (L27-28)
```rust
    /// TODO(HotState): make on-chain config
    const MAX_PROMOTIONS_PER_BLOCK: usize = 1024 * 10;
```

**File:** aptos-move/block-executor/src/hot_state_op_accumulator.rs (L56-65)
```rust
        for key in reads {
            if self.to_make_hot.len() >= self.max_promotions_per_block {
                COUNTER.inc_with(&["max_promotions_per_block_hit"]);
                continue;
            }
            if self.writes.contains(key) {
                continue;
            }
            self.to_make_hot.insert(key.clone());
        }
```

**File:** aptos-move/block-executor/src/hot_state_op_accumulator.rs (L68-70)
```rust
    pub fn get_keys_to_make_hot(&self) -> BTreeSet<Key> {
        self.to_make_hot.clone()
    }
```

**File:** types/src/transaction/block_epilogue.rs (L108-112)
```rust
#[derive(Clone, Debug, PartialEq, Eq)]
pub struct TBlockEndInfoExt<Key: Debug + Ord> {
    inner: BlockEndInfo,
    to_make_hot: BTreeSet<Key>,
}
```

**File:** types/src/transaction/block_epilogue.rs (L133-156)
```rust
impl<Key> Serialize for TBlockEndInfoExt<Key>
where
    Key: Debug + Ord,
{
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        self.inner.serialize(serializer)
    }
}

impl<'de, Key> Deserialize<'de> for TBlockEndInfoExt<Key>
where
    Key: Debug + Ord,
{
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        let inner = BlockEndInfo::deserialize(deserializer)?;
        Ok(Self::new(inner, BTreeSet::new()))
    }
}
```

**File:** types/src/write_set.rs (L548-553)
```rust
#[derive(BCSCryptoHash, Clone, CryptoHasher, Debug, Default, Eq, PartialEq)]
pub struct WriteSet {
    value: ValueWriteSet,
    /// TODO(HotState): this field is not serialized for now.
    hotness: BTreeMap<StateKey, HotStateOp>,
}
```
