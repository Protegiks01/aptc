# Audit Report

## Title
Incomplete Module Complexity Metering Allows Resource Exhaustion and Complexity Limit Bypass via Unmetered Constants and Metadata

## Summary
The `check_module_complexity()` function fails to meter the `constant_pool` and `metadata` components of compiled modules. Since these components are fully deserialized during module verification but consume zero complexity budget, attackers can craft modules with massive constants or metadata to cause resource exhaustion during verification or bypass complexity limits entirely.

## Finding Description

The `check_module_complexity()` function is designed to limit module complexity by metering various module components against a budget. However, critical analysis reveals that several `CompiledModule` fields are completely unmetered:

**Unmetered Components:**

1. **constant_pool** - Never iterated or metered in `check_module_complexity()` [1](#0-0) 

2. **metadata** - Never iterated or metered [1](#0-0) 

3. **address_identifiers** - Not metered [2](#0-1) 

4. **friend_decls** - Not metered [2](#0-1) 

**The Exploit Path:**

During module publishing, the complexity budget is calculated based on total binary size: [3](#0-2) 

However, during module verification, ALL constants are deserialized regardless of whether they're referenced: [4](#0-3) 

Each constant undergoes full deserialization: [5](#0-4) 

The `Constant` structure contains arbitrary-length byte data: [6](#0-5) 

Similarly, metadata contains arbitrary-length byte arrays that are also deserialized during validation: [7](#0-6) [8](#0-7) 

**Attack Scenario:**

1. Attacker creates a module with 100 constants, each being a `vector<u8>` of 50,000 bytes (total: 5MB)
2. Module binary size: 5MB + minimal code = ~5.1MB
3. Complexity budget: `2048 + 5,100,000 * 20 = 102,002,048`
4. During `check_module_complexity()`, constants consume ZERO budget (never metered)
5. Attacker uses the full 102M budget for other components (signatures, functions, etc.)
6. During verification, all 5MB of constants are deserialized via `MoveValue::simple_deserialize()`
7. This causes significant CPU/memory consumption on ALL validators simultaneously
8. Different validators may timeout or exhaust memory differently, potentially causing consensus divergence

**Invariant Violations:**

- **Resource Limits (Invariant #9)**: Operations exceed intended computational limits
- **Deterministic Execution (Invariant #1)**: Different validators may handle resource exhaustion differently
- **Move VM Safety (Invariant #3)**: Memory constraints can be violated during verification

## Impact Explanation

This vulnerability qualifies as **HIGH severity** per Aptos bug bounty criteria:

1. **Validator Node Slowdowns**: Deserializing 5-10MB of constant data per module causes significant CPU/memory spikes across all validators processing the transaction, directly impacting network performance.

2. **Complexity Limit Bypass**: The intended protection of complexity metering is circumvented. Modules that should be rejected as "too complex" can pass checks by hiding complexity in unmetered constants.

3. **Potential Consensus Impact**: If validators have different resource limits or timeout behaviors, some may successfully verify a module while others fail or timeout, potentially causing state divergence or liveness issues.

4. **Resource Exhaustion Attack Surface**: Attackers can force validators to deserialize arbitrary amounts of data (limited only by transaction size limits, typically several MB), causing predictable resource consumption.

The attack doesn't require validator privileges and can be executed by any user submitting a module publishing transaction. While not reaching Critical severity (no direct fund loss), it represents a significant protocol violation enabling validator DoS.

## Likelihood Explanation

**Likelihood: HIGH**

- **Ease of Exploitation**: Trivial - attacker needs only to compile a Move module with large constant vectors
- **Attack Cost**: Minimal - just transaction gas fees for module publishing
- **Detection Difficulty**: Difficult - the complexity check passes, and the resource exhaustion appears legitimate during verification
- **Attacker Requirements**: None - any user can publish modules
- **Current Deployment**: The vulnerable code is in production across all Aptos validators

The attack is deterministic and repeatable. No special conditions or timing windows are required.

## Recommendation

**Immediate Fix:**

Extend `check_module_complexity()` to meter constant pool and metadata:

```rust
pub fn check_module_complexity(module: &CompiledModule, budget: u64) -> PartialVMResult<u64> {
    let meter = BinaryComplexityMeter {
        resolver: BinaryIndexedView::Module(module),
        cached_signature_costs: RefCell::new(BTreeMap::new()),
        balance: RefCell::new(budget),
    };

    meter.meter_signatures()?;
    meter.meter_function_instantiations()?;
    meter.meter_struct_def_instantiations()?;
    meter.meter_field_instantiations()?;

    meter.meter_function_handles()?;
    meter.meter_struct_handles()?;
    meter.meter_function_defs()?;
    meter.meter_struct_defs()?;
    
    // ADD: Meter constant pool
    meter.meter_constant_pool()?;
    
    // ADD: Meter metadata
    meter.meter_metadata()?;

    let used = budget - *meter.balance.borrow();
    Ok(used)
}
```

Add new metering methods:

```rust
fn meter_constant_pool(&self) -> PartialVMResult<()> {
    let constants = self.resolver.constant_pool().ok_or_else(|| {
        PartialVMError::new(StatusCode::UNKNOWN_INVARIANT_VIOLATION_ERROR)
            .with_message("Can't get constant pool -- not a module.".to_string())
    })?;
    
    for constant in constants {
        // Charge for type complexity
        self.charge(self.signature_token_cost(&constant.type_)?)?;
        // Charge for data size (1 cost per byte)
        self.charge(constant.data.len() as u64)?;
    }
    Ok(())
}

fn meter_metadata(&self) -> PartialVMResult<()> {
    let module = match &self.resolver {
        BinaryIndexedView::Module(m) => m,
        _ => return Ok(()),
    };
    
    for metadata in &module.metadata {
        // Charge for key and value sizes
        self.charge(metadata.key.len() as u64)?;
        self.charge(metadata.value.len() as u64)?;
    }
    Ok(())
}
```

**Additional Hardening:**

1. Consider adding explicit size limits for individual constants (e.g., max 64KB per constant)
2. Add limits on total metadata size (e.g., max 1MB total)
3. Consider metering `address_identifiers` and `friend_decls` for completeness

## Proof of Concept

```rust
// PoC: Create a module with large unmetered constants
// File: exploit_module.move

module 0xCAFE::exploit {
    const LARGE_DATA_1: vector<u8> = x"00{repeated 50000 times}";
    const LARGE_DATA_2: vector<u8> = x"00{repeated 50000 times}";
    const LARGE_DATA_3: vector<u8> = x"00{repeated 50000 times}";
    // ... repeat for 100 constants
    
    public fun dummy() {
        // Constants never referenced in code
        // But they're still deserialized during verification
    }
}
```

**Verification Steps:**

1. Compile the above module with 100 large constants (5MB total)
2. Submit as module publishing transaction
3. Observe `check_module_complexity()` passes (constants not metered)
4. Monitor validator CPU/memory during verification phase
5. Observe resource spike when `constants::verify_module()` deserializes all constants
6. With sufficient constants, can cause timeouts or OOM on validators

**Expected Behavior:** Module should be rejected during complexity checking

**Actual Behavior:** Module passes complexity check, causes resource exhaustion during verification

---

**Notes:**

This vulnerability represents a fundamental gap in the complexity metering system. The constants and metadata are part of the module's computational footprint during verification but are completely invisible to the complexity budgeting mechanism. This creates an asymmetry where the budget calculation accounts for their size (in blob length) but the metering doesn't consume budget for them, effectively giving attackers "free" complexity budget.

### Citations

**File:** third_party/move/move-binary-format/src/check_complexity.rs (L401-420)
```rust
pub fn check_module_complexity(module: &CompiledModule, budget: u64) -> PartialVMResult<u64> {
    let meter = BinaryComplexityMeter {
        resolver: BinaryIndexedView::Module(module),
        cached_signature_costs: RefCell::new(BTreeMap::new()),
        balance: RefCell::new(budget),
    };

    meter.meter_signatures()?;
    meter.meter_function_instantiations()?;
    meter.meter_struct_def_instantiations()?;
    meter.meter_field_instantiations()?;

    meter.meter_function_handles()?;
    meter.meter_struct_handles()?;
    meter.meter_function_defs()?;
    meter.meter_struct_defs()?;

    let used = budget - *meter.balance.borrow();
    Ok(used)
}
```

**File:** third_party/move/move-binary-format/src/file_format.rs (L1324-1327)
```rust
pub struct Constant {
    pub type_: SignatureToken,
    pub data: Vec<u8>,
}
```

**File:** third_party/move/move-binary-format/src/file_format.rs (L3434-3479)
```rust
pub struct CompiledModule {
    /// Version number found during deserialization
    pub version: u32,
    /// Handle to self.
    pub self_module_handle_idx: ModuleHandleIndex,
    /// Handles to external dependency modules and self.
    pub module_handles: Vec<ModuleHandle>,
    /// Handles to external and internal types.
    pub struct_handles: Vec<StructHandle>,
    /// Handles to external and internal functions.
    pub function_handles: Vec<FunctionHandle>,
    /// Handles to fields.
    pub field_handles: Vec<FieldHandle>,
    /// Friend declarations, represented as a collection of handles to external friend modules.
    pub friend_decls: Vec<ModuleHandle>,

    /// Struct instantiations.
    pub struct_def_instantiations: Vec<StructDefInstantiation>,
    /// Function instantiations.
    pub function_instantiations: Vec<FunctionInstantiation>,
    /// Field instantiations.
    pub field_instantiations: Vec<FieldInstantiation>,

    /// Locals signature pool. The signature for all locals of the functions defined in the module.
    pub signatures: SignaturePool,

    /// All identifiers used in this module.
    pub identifiers: IdentifierPool,
    /// All address identifiers used in this module.
    pub address_identifiers: AddressIdentifierPool,
    /// Constant pool. The constant values used in the module.
    pub constant_pool: ConstantPool,

    pub metadata: Vec<Metadata>,

    /// Types defined in this module.
    pub struct_defs: Vec<StructDefinition>,
    /// Function defined in this module.
    pub function_defs: Vec<FunctionDefinition>,

    /// Since bytecode version 7: variant related handle tables
    pub struct_variant_handles: Vec<StructVariantHandle>,
    pub struct_variant_instantiations: Vec<StructVariantInstantiation>,
    pub variant_field_handles: Vec<VariantFieldHandle>,
    pub variant_field_instantiations: Vec<VariantFieldInstantiation>,
}
```

**File:** aptos-move/aptos-vm/src/aptos_vm.rs (L1554-1559)
```rust
        for (module, blob) in modules.iter().zip(bundle.iter()) {
            // TODO(Gas): Make budget configurable.
            let budget = 2048 + blob.code().len() as u64 * 20;
            move_binary_format::check_complexity::check_module_complexity(module, budget)
                .map_err(|err| err.finish(Location::Undefined))?;
        }
```

**File:** third_party/move/move-bytecode-verifier/src/constants.rs (L20-24)
```rust
fn verify_module_impl(module: &CompiledModule) -> PartialVMResult<()> {
    for (idx, constant) in module.constant_pool().iter().enumerate() {
        verify_constant(idx, constant)?
    }
    Ok(())
```

**File:** third_party/move/move-binary-format/src/constant.rs (L71-74)
```rust
    pub fn deserialize_constant(&self) -> Option<MoveValue> {
        let ty = sig_to_ty(&self.type_)?;
        MoveValue::simple_deserialize(&self.data, &ty).ok()
    }
```

**File:** third_party/move/move-core/types/src/metadata.rs (L10-15)
```rust
pub struct Metadata {
    /// The key identifying the type of metadata.
    pub key: Vec<u8>,
    /// The value of the metadata.
    pub value: Vec<u8>,
}
```

**File:** types/src/vm/module_metadata.rs (L253-269)
```rust
fn check_metadata_format(module: &CompiledModule) -> Result<(), MalformedError> {
    let mut exist = false;
    let mut compilation_key_exist = false;
    for data in module.metadata.iter() {
        if data.key == *APTOS_METADATA_KEY || data.key == *APTOS_METADATA_KEY_V1 {
            if exist {
                return Err(MalformedError::DuplicateKey);
            }
            exist = true;

            if data.key == *APTOS_METADATA_KEY {
                bcs::from_bytes::<RuntimeModuleMetadata>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            } else if data.key == *APTOS_METADATA_KEY_V1 {
                bcs::from_bytes::<RuntimeModuleMetadataV1>(&data.value)
                    .map_err(|e| MalformedError::DeserializedError(data.key.clone(), e))?;
            }
```
