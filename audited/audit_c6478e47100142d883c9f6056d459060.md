# Audit Report

## Title
Race Condition in KNOWN_LATEST_VERSION Metric Update Allows Monitoring Bypass of Indexer Lag

## Summary
The `update_known_latest_version()` method in the indexer-grpc-manager contains a race condition where the `KNOWN_LATEST_VERSION` Prometheus metric can be set to a stale value while the internal atomic counter remains correct. This discrepancy can hide indexer lag from monitoring systems, potentially delaying operator response to performance degradation.

## Finding Description

The vulnerability exists in the metric update logic: [1](#0-0) 

The function uses `fetch_max()` to atomically update the `known_latest_version` atomic counter, which correctly ensures the value only increases. However, it then unconditionally sets the `KNOWN_LATEST_VERSION` Prometheus metric to the input `version` parameter, not the actual maximum value stored in the atomic.

**Race Condition Scenario:**

1. Current state: `known_latest_version` (atomic) = 10000, `KNOWN_LATEST_VERSION` (metric) = 10000
2. Thread A receives fullnode update with version 11000 (newer)
3. Thread B receives fullnode update with version 10500 (slightly delayed response)
4. If Thread A executes first:
   - `fetch_max(11000)` sets atomic to 11000
   - `KNOWN_LATEST_VERSION.set(11000)` sets metric to 11000
5. Then Thread B executes:
   - `fetch_max(10500)` keeps atomic at 11000 (correct!)
   - `KNOWN_LATEST_VERSION.set(10500)` **sets metric to 10500** (BUG!)

The metric now shows 10500 while the actual value is 11000, creating a 500-version discrepancy.

This occurs naturally when multiple fullnode ping responses arrive concurrently: [2](#0-1) 

The function `handle_fullnode_info()` calls `update_known_latest_version()` with the version from each fullnode response: [3](#0-2) 

**Why This Hides Lag:**

Monitoring systems track the gap: `KNOWN_LATEST_VERSION - CACHE_END_VERSION` to detect indexer lag. If `CACHE_END_VERSION` is 10800 and:
- Real gap: 11000 - 10800 = 200 (cache is 200 versions behind)
- Metric gap: 10500 - 10800 = -300 (appears cache is ahead)

The monitoring system would not trigger lag alerts despite the cache being behind.

**Important Note:** The internal lag detection logic is **not affected** because it uses the correct atomic value: [4](#0-3) [5](#0-4) 

## Impact Explanation

**Severity Assessment: Medium (Borderline Low)**

This vulnerability does **NOT** allow serving outdated transaction data to clients directly, as the internal lag detection uses the correct atomic value. However, it creates a monitoring blind spot:

1. **Delayed Incident Response**: Operators relying on Prometheus metrics won't detect indexer lag, delaying investigation and remediation
2. **False Sense of Security**: Dashboards and alerts show incorrect system health
3. **Extended Stale Data Window**: If other issues cause real lag, this bug hides it from monitoring, potentially extending the time clients receive stale data

This does not meet the "High Severity" criteria (validator slowdowns, API crashes, significant protocol violations) as it's purely a monitoring issue. It's closer to "Low Severity" (minor implementation bug) but has operational impact on incident response.

## Likelihood Explanation

**Likelihood: High** 

This bug triggers naturally without malicious actors through normal concurrent operations:

- Multiple fullnodes respond to pings simultaneously (1-second interval)
- Network delays cause responses to arrive out of order
- The `tokio_scoped::scope` spawns concurrent tasks for all fullnode pings
- No special conditions or attacker control required

The bug can also be amplified (though not required) if a compromised fullnode sends outdated version numbers, but this is not necessary for exploitation.

## Recommendation

Fix the metric update to reflect the actual atomic value after `fetch_max`:

```rust
fn update_known_latest_version(&self, version: u64) {
    self.known_latest_version.fetch_max(version, Ordering::SeqCst);
    // Read the actual current value after fetch_max to ensure metric accuracy
    let actual_version = self.known_latest_version.load(Ordering::SeqCst);
    KNOWN_LATEST_VERSION.set(actual_version as i64);
}
```

Alternatively, use the return value of `fetch_max`:

```rust
fn update_known_latest_version(&self, version: u64) {
    let prev = self.known_latest_version.fetch_max(version, Ordering::SeqCst);
    let actual_version = std::cmp::max(prev, version);
    KNOWN_LATEST_VERSION.set(actual_version as i64);
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use std::sync::Arc;
    use std::thread;

    #[test]
    fn test_known_latest_version_race_condition() {
        // Simulate the bug with concurrent updates
        let known_latest = Arc::new(AtomicU64::new(10000));
        
        // Thread 1: Update to 11000
        let atomic1 = known_latest.clone();
        let h1 = thread::spawn(move || {
            atomic1.fetch_max(11000, Ordering::SeqCst);
            // In real code: KNOWN_LATEST_VERSION.set(11000)
            thread::sleep(std::time::Duration::from_millis(10));
        });
        
        // Thread 2: Update to 10500 (delayed response)
        let atomic2 = known_latest.clone();
        let h2 = thread::spawn(move || {
            thread::sleep(std::time::Duration::from_millis(5));
            atomic2.fetch_max(10500, Ordering::SeqCst);
            // In real code: KNOWN_LATEST_VERSION.set(10500) â† Bug: sets stale value!
        });
        
        h1.join().unwrap();
        h2.join().unwrap();
        
        // Atomic is correct: 11000
        assert_eq!(known_latest.load(Ordering::SeqCst), 11000);
        
        // But metric would show: 10500 (if Thread 2 executed second)
        // This creates a 500-version discrepancy in monitoring
    }
}
```

## Notes

While this is a legitimate bug causing monitoring inaccuracy, it does **not** meet the strict criteria for a high-severity security vulnerability because:

1. It does not enable serving outdated data to clients (internal logic uses correct atomic value)
2. It does not affect consensus, execution, state management, governance, or staking (core components)
3. The indexer-grpc system is an API/observability layer, not part of the core blockchain protocol
4. No core invariants are violated (all 10 documented invariants remain intact)

The bug should be fixed for operational correctness, but it represents a monitoring/observability issue rather than a protocol security vulnerability.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L196-214)
```rust
                for kv in &self.fullnodes {
                    let (address, fullnode) = kv.pair();
                    let need_ping = fullnode.recent_states.back().is_none_or(|s| {
                        Self::is_stale_timestamp(
                            s.timestamp.unwrap_or_default(),
                            Duration::from_secs(1),
                        )
                    });
                    if need_ping {
                        let address = address.clone();
                        let client = fullnode.client.clone();
                        s.spawn(async move {
                            if let Err(e) = self.ping_fullnode(address.clone(), client).await {
                                warn!("Failed to ping FN ({address}): {e:?}.");
                            } else {
                                trace!("Successfully pinged FN ({address}).");
                            }
                        });
                    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L401-403)
```rust
    pub(crate) fn get_known_latest_version(&self) -> u64 {
        self.known_latest_version.load(Ordering::SeqCst)
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L405-409)
```rust
    fn update_known_latest_version(&self, version: u64) {
        self.known_latest_version
            .fetch_max(version, Ordering::SeqCst);
        KNOWN_LATEST_VERSION.set(version as i64);
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L539-544)
```rust
        if let Some(known_latest_version) = info.known_latest_version {
            trace!(
                "Received known_latest_version ({known_latest_version}) from fullnode {address}."
            );
            self.update_known_latest_version(known_latest_version);
        }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/data_manager.rs (L284-287)
```rust
    pub(crate) fn lagging(&self, cache_next_version: u64) -> bool {
        // TODO(grao): Need a better way, we can use the information in the metadata_manager.
        cache_next_version + 20000 < self.metadata_manager.get_known_latest_version()
    }
```
