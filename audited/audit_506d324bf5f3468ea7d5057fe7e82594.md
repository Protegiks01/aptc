# Audit Report

## Title
Magic Header Secret Credentials Leaked Through Application Logs

## Summary
The `MagicHeaderCheckerConfig` struct stores secret authentication credentials (`magic_header_key` and `magic_header_value`) that are exposed in plaintext through INFO-level application logs during faucet startup and config validation, compromising the authentication mechanism's security.

## Finding Description

The faucet service uses a magic header checker as an authentication mechanism to restrict access. The `MagicHeaderCheckerConfig` struct is defined with the `Debug` trait derived: [1](#0-0) 

This struct is part of the `CheckerConfig` enum which also derives `Debug`: [2](#0-1) 

The vulnerability occurs when the entire `RunConfig` (which contains `checker_configs: Vec<CheckerConfig>`) is logged using Debug formatting at INFO level in two critical locations:

**Location 1 - Faucet Startup:** [3](#0-2) 

**Location 2 - Config Validation:** [4](#0-3) 

When the faucet starts or when configuration is validated, the entire config structure—including the secret `magic_header_key` and `magic_header_value`—is printed to logs at INFO level. Since INFO is a standard logging level typically enabled in production environments, these secrets will be exposed in:
- Application logs
- Centralized logging systems (ELK, Splunk, CloudWatch, etc.)
- Log aggregation services
- Debug dumps and error reports
- Logs accessible to operations teams

An attacker who gains read access to these logs can extract the magic header credentials and bypass the authentication check entirely.

## Impact Explanation

**HIGH Severity** per the Aptos bug bounty criteria. This vulnerability falls under "Significant protocol violations" as it:

1. **Compromises Authentication**: The magic header acts as a secret token to restrict faucet access. Leaking it defeats the entire security control.

2. **Wide Attack Surface**: Application logs are commonly exposed through:
   - Log management systems with broad access permissions
   - Backup systems
   - Log export features
   - Developer/operator access
   - Compromised monitoring systems
   - Accidental disclosure in support tickets

3. **Persistent Exposure**: Logs are typically retained for extended periods (weeks to months), providing attackers a large time window to discover the secrets.

4. **Enables Faucet Abuse**: Once the magic header is compromised, attackers can:
   - Bypass rate limiting intended for public users
   - Drain faucet funds through repeated requests
   - Potentially abuse the faucet for denial-of-service

While this doesn't directly affect consensus or validator operations, it represents a significant security failure in access control that could lead to resource exhaustion and financial impact on faucet operators.

## Likelihood Explanation

**HIGH Likelihood**. This vulnerability triggers automatically every time:
- The faucet service starts (common in deployments, restarts, updates)
- A configuration validation is performed
- The INFO log level is enabled (standard in most production deployments)

No special conditions or attacker actions are required for the leak to occur—it happens during normal operations. The only requirement for exploitation is that an attacker gains access to application logs, which is a common attack vector in many security incidents.

## Recommendation

Implement a secret-safe wrapper type that redacts sensitive values when Debug-formatted. Here's the recommended fix:

**Step 1:** Create a `Secret<T>` wrapper type in a new file:

```rust
// crates/aptos-faucet/core/src/common/secret.rs
use serde::{Deserialize, Serialize};
use std::fmt;

#[derive(Clone, Deserialize, Serialize)]
pub struct Secret<T>(T);

impl<T> Secret<T> {
    pub fn new(value: T) -> Self {
        Self(value)
    }
    
    pub fn expose_secret(&self) -> &T {
        &self.0
    }
}

impl<T> fmt::Debug for Secret<T> {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.write_str("***REDACTED***")
    }
}
```

**Step 2:** Update `MagicHeaderCheckerConfig` to use `Secret<String>`:

```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct MagicHeaderCheckerConfig {
    pub magic_header_key: String,  // Key name can remain public
    pub magic_header_value: Secret<String>,  // Wrap the secret value
}
```

**Step 3:** Update usage sites to call `expose_secret()`:

```rust
if header_value != self.config.magic_header_value.expose_secret() {
    // ... error handling
}
```

This ensures that when the config is logged with `{:#?}`, the sensitive value appears as `***REDACTED***` instead of the actual secret.

## Proof of Concept

**Reproduction Steps:**

1. Create a faucet config file with magic header checker:
```yaml
checker_configs:
  - type: MagicHeader
    magic_header_key: "X-Secret-Token"
    magic_header_value: "super_secret_password_12345"
```

2. Start the faucet service:
```bash
cargo run --bin aptos-faucet -- run -c config.yaml
```

3. Observe the logs at INFO level. You will see output similar to:
```
INFO Running with config: RunConfig {
    ...
    checker_configs: [
        MagicHeader(
            MagicHeaderCheckerConfig {
                magic_header_key: "X-Secret-Token",
                magic_header_value: "super_secret_password_12345",
            }
        )
    ],
    ...
}
```

4. The secret value `"super_secret_password_12345"` is now exposed in logs.

5. An attacker with log access can now make authenticated requests:
```bash
curl -H "X-Secret-Token: super_secret_password_12345" \
     -H "Content-Type: application/json" \
     -X POST -d '{"amount": 1000000, "address": "0x..."}' \
     http://faucet-url/fund
```

The request bypasses the magic header check because the attacker has the correct secret extracted from logs.

## Notes

This vulnerability violates fundamental security principles that secrets should never be logged. While the error messages in the checker implementation correctly avoid logging the secret value (only logging the key name), the startup/validation logs inadvertently expose both the key and value through Debug formatting of the entire config structure.

### Citations

**File:** crates/aptos-faucet/core/src/checkers/magic_header.rs (L10-14)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
pub struct MagicHeaderCheckerConfig {
    pub magic_header_key: String,
    pub magic_header_value: String,
}
```

**File:** crates/aptos-faucet/core/src/checkers/mod.rs (L81-94)
```rust
#[derive(Clone, Debug, Deserialize, Serialize)]
#[serde(tag = "type")]
pub enum CheckerConfig {
    /// Requires that an auth token is included in the Authorization header.
    AuthToken(ListManagerConfig),

    /// Requires a legitimate Google ReCaptcha token.
    GoogleCaptcha(GoogleCaptchaCheckerConfig),

    /// Rejects requests if their IP is in a blocklisted IPrnage.
    IpBlocklist(IpRangeManagerConfig),

    /// Checkers whether a config-defined magic header kv is present.
    MagicHeader(MagicHeaderCheckerConfig),
```

**File:** crates/aptos-faucet/core/src/server/run.rs (L86-86)
```rust
        info!("Running with config: {:#?}", self);
```

**File:** crates/aptos-faucet/core/src/server/validate_config.rs (L32-32)
```rust
        info!("Config is valid: {:#?}", run_config);
```
