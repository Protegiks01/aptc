# Audit Report

## Title
Indexer Version Starvation: Infinite Loop in get_highest_known_version() Causes Service Hang

## Summary
The `get_highest_known_version()` function in the Table Info indexer service contains an unbounded polling loop that can hang indefinitely if `current_version` exceeds the actual ledger version due to database corruption, manual misconfiguration, or state sync issues. This causes a complete denial-of-service for the indexer-grpc API service.

## Finding Description

The vulnerability exists in the `get_highest_known_version()` function [1](#0-0) , which polls for the latest ledger version until it equals or exceeds `current_version`.

The problematic loop condition executes while `ledger_version == 0 OR current_version > ledger_version`. The loop has **no timeout** and **no maximum iteration count**. It only exits when:
1. The `aborted` flag is manually set from another thread, OR
2. The ledger naturally advances to catch up with `current_version`

**How the vulnerability manifests:**

The `current_version` is initialized from persistent storage [2](#0-1)  using `request_start_version` parameter, which comes from `indexer_async_v2.next_version()` [3](#0-2) . This reads from the IndexerAsyncV2 database metadata.

After processing transactions, `current_version` is updated [4](#0-3)  to `last_version + 1`, and this is persisted via `update_next_version()` [5](#0-4)  which performs **no validation** that the version is reasonable.

**Trigger scenarios:**

1. **Database Corruption**: Disk failure or improper shutdown corrupts the IndexerAsyncV2 metadata, causing `next_version()` to return an inflated value (e.g., version 1000 when ledger is at 500)
2. **Manual Misconfiguration**: Operator manually edits the indexer database during recovery and sets an incorrect version
3. **State Sync Rollback**: Main node database is restored from backup while indexer database is not, creating a version mismatch
4. **Bug in Version Management**: A bug in `update_next_version()` or transaction processing writes an incorrect future version

When this occurs, the main `run()` loop blocks at line 108 [6](#0-5) , waiting indefinitely in `get_highest_known_version()`. The indexer stops processing new transactions completely.

The loop sleeps for only 10 milliseconds between retries [7](#0-6) , creating a tight polling loop that wastes CPU resources while accomplishing nothing.

## Impact Explanation

This qualifies as **High Severity** under the Aptos bug bounty program criteria: **"API crashes"**.

The indexer-grpc-table-info service provides gRPC API access to blockchain table information. A complete hang of this service results in:
- **Complete API unavailability** for table info queries
- **Service degradation** for applications depending on this indexer
- **Operational disruption** requiring manual intervention (restart or abort)
- **CPU waste** from tight 10ms polling loop

While this doesn't directly affect consensus or validator operations, it's a critical infrastructure component for API access to blockchain state.

## Likelihood Explanation

**Likelihood: Medium-High** in production environments

This vulnerability can be triggered through realistic operational scenarios:

1. **Database corruption** from disk failures is a well-known occurrence in production systems
2. **Improper shutdown** during crashes can leave inconsistent database state
3. **Operator errors** during disaster recovery or manual database maintenance
4. **State sync issues** during node recovery or blockchain reorganization

While not directly exploitable by external attackers without file system access, the operational scenarios that trigger this bug are **common in real-world deployments**. The complete lack of defensive programming (no timeout, no max retry) means that when it occurs, recovery requires manual intervention.

## Recommendation

Add timeout and maximum retry logic to prevent infinite loops. Here's the recommended fix:

```rust
async fn get_highest_known_version(&self) -> Result<u64, Error> {
    let mut info = self.context.get_latest_ledger_info_wrapped();
    let mut ledger_version = info.unwrap().ledger_version.0;
    let mut empty_loops = 0;
    const MAX_RETRIES: u64 = 1000; // Maximum 10 seconds of retries
    
    while ledger_version == 0 || self.current_version.load(Ordering::SeqCst) > ledger_version {
        if self.aborted.load(Ordering::SeqCst) {
            break;
        }
        
        // Add safety check for version starvation
        if empty_loops >= MAX_RETRIES {
            let current_ver = self.current_version.load(Ordering::SeqCst);
            error!(
                current_version = current_ver,
                ledger_version = ledger_version,
                "[Table Info] Version starvation detected: current_version exceeds ledger_version after {} retries. 
                This may indicate database corruption. Resetting current_version to ledger_version.",
                MAX_RETRIES
            );
            // Reset to safe state rather than hang forever
            self.current_version.store(ledger_version, Ordering::SeqCst);
            break;
        }
        
        if empty_loops > 0 {
            tokio::time::sleep(Duration::from_millis(LEDGER_VERSION_RETRY_TIME_MILLIS)).await;
        }
        empty_loops += 1;
        
        if let Err(err) = {
            info = self.context.get_latest_ledger_info_wrapped();
            ledger_version = info.unwrap().ledger_version.0;
            Ok::<(), Error>(())
        } {
            error!(
                error = format!("{:?}", err),
                "[Table Info] Failed to set highest known version"
            );
            continue;
        } else {
            sample!(
                SampleRate::Frequency(100),
                debug!(
                    ledger_version = ledger_version,
                    "[Table Info] Found new highest known ledger version",
                )
            );
        }
    }
    Ok(ledger_version)
}
```

Additionally, add validation in `update_next_version()` to prevent storing unreasonable version values:

```rust
pub fn update_next_version(&self, end_version: u64) -> Result<()> {
    // Validate version is not regressing
    let current = self.next_version.load(Ordering::Relaxed);
    if end_version < current {
        bail!("Attempted to update version backwards: {} -> {}", current, end_version);
    }
    
    self.db.put::<IndexerMetadataSchema>(
        &MetadataKey::LatestVersion,
        &MetadataValue::Version(end_version - 1),
    )?;
    self.next_version.store(end_version, Ordering::Relaxed);
    Ok(())
}
```

## Proof of Concept

**Reproduction Steps:**

1. **Setup**: Start an Aptos node with indexer-grpc-table-info service enabled
2. **Corrupt Database**: Manually edit the IndexerAsyncV2 RocksDB metadata to set a version higher than current ledger (e.g., set version to 1000000 when ledger is at 1000):
   ```bash
   # Stop the service
   # Use rocksdb tools to update metadata:
   # ldb --db=/path/to/indexer_async_v2/db put LatestVersion 1000000
   ```
3. **Restart Service**: Start the TableInfoService
4. **Observe Hang**: The service will hang in `get_highest_known_version()`, continuously polling every 10ms
5. **Verify**: Check CPU usage (should be elevated from tight polling) and logs (should show repeated "Found new highest known ledger version" debug messages)
6. **Impact**: The indexer is now completely hung and cannot process new transactions

**Expected Behavior**: Service should detect the version anomaly, log an error, reset to safe state, and continue operation.

**Actual Behavior**: Service hangs indefinitely in a tight polling loop with no automatic recovery.

---

## Notes

This vulnerability represents a **liveness failure** in the indexer infrastructure. While the indexer is not part of core consensus, it's critical API infrastructure. The bug demonstrates poor defensive programmingâ€”no timeout, no validation, no maximum retry count. Production systems must account for database corruption and operational errors with appropriate safety mechanisms.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs (L27-27)
```rust
const LEDGER_VERSION_RETRY_TIME_MILLIS: u64 = 10;
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs (L53-70)
```rust
    pub fn new(
        context: Arc<ApiContext>,
        request_start_version: u64,
        parser_task_count: u16,
        parser_batch_size: u16,
        backup_restore_operator: Option<Arc<GcsBackupRestoreOperator>>,
        indexer_async_v2: Arc<IndexerAsyncV2>,
    ) -> Self {
        Self {
            current_version: AtomicU64::new(request_start_version),
            parser_task_count,
            parser_batch_size,
            context,
            backup_restore_operator,
            indexer_async_v2,
            aborted: AtomicBool::new(false),
        }
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs (L106-112)
```rust
        loop {
            let start_time = std::time::Instant::now();
            let ledger_version = self.get_highest_known_version().await.unwrap_or_default();
            if self.aborted.load(Ordering::SeqCst) {
                info!("table info service aborted");
                break;
            }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs (L189-190)
```rust
            self.current_version
                .store(last_version + 1, Ordering::SeqCst);
```

**File:** ecosystem/indexer-grpc/indexer-grpc-table-info/src/table_info_service.rs (L494-528)
```rust
    async fn get_highest_known_version(&self) -> Result<u64, Error> {
        let mut info = self.context.get_latest_ledger_info_wrapped();
        let mut ledger_version = info.unwrap().ledger_version.0;
        let mut empty_loops = 0;

        while ledger_version == 0 || self.current_version.load(Ordering::SeqCst) > ledger_version {
            if self.aborted.load(Ordering::SeqCst) {
                break;
            }
            if empty_loops > 0 {
                tokio::time::sleep(Duration::from_millis(LEDGER_VERSION_RETRY_TIME_MILLIS)).await;
            }
            empty_loops += 1;
            if let Err(err) = {
                info = self.context.get_latest_ledger_info_wrapped();
                ledger_version = info.unwrap().ledger_version.0;
                Ok::<(), Error>(())
            } {
                error!(
                    error = format!("{:?}", err),
                    "[Table Info] Failed to set highest known version"
                );
                continue;
            } else {
                sample!(
                    SampleRate::Frequency(100),
                    debug!(
                        ledger_version = ledger_version,
                        "[Table Info] Found new highest known ledger version",
                    )
                );
            }
        }
        Ok(ledger_version)
    }
```

**File:** storage/indexer/src/db_v2.rs (L117-124)
```rust
    pub fn update_next_version(&self, end_version: u64) -> Result<()> {
        self.db.put::<IndexerMetadataSchema>(
            &MetadataKey::LatestVersion,
            &MetadataValue::Version(end_version - 1),
        )?;
        self.next_version.store(end_version, Ordering::Relaxed);
        Ok(())
    }
```

**File:** storage/indexer/src/db_v2.rs (L142-147)
```rust
    pub fn next_version(&self) -> Version {
        self.db
            .get::<IndexerMetadataSchema>(&MetadataKey::LatestVersion)
            .unwrap()
            .map_or(0, |v| v.expect_version())
    }
```
