# Audit Report

## Title
Duplicate Validator Indices in `failed_proposer_indices` Cause Unfair Multi-Penalization in Performance Statistics

## Summary
When using `RotatingProposer` with `contiguous_rounds > 1`, a validator assigned to multiple consecutive rounds who fails all of them will have their index appear multiple times in `failed_proposer_indices`. The `update_performance_statistics` function does not deduplicate these indices, resulting in the validator's `failed_proposals` counter being incremented multiple times for what is effectively a single failure period, causing disproportionate reward penalties.

## Finding Description

The vulnerability exists in the interaction between proposer election configuration and validator performance tracking:

**Step 1: Proposer Election with Contiguous Rounds**

The `RotatingProposer` election supports a `contiguous_rounds` parameter that assigns the same validator to propose for multiple consecutive rounds: [1](#0-0) 

When `contiguous_rounds > 1`, the same validator is returned for multiple sequential rounds.

**Step 2: Failed Authors Computation**

When computing failed authors for a block, the system iterates through all skipped rounds and records the designated proposer for each: [2](#0-1) 

If validator V was assigned to rounds R, R+1, and R+2 (due to `contiguous_rounds=3`) and failed all three, `failed_authors` will contain `[(R, V), (R+1, V), (R+2, V)]`.

**Step 3: Conversion to Indices**

The `failed_authors` list is converted to validator indices without deduplication: [3](#0-2) 

This produces `failed_proposer_indices = [index_V, index_V, index_V]`.

**Step 4: Performance Statistics Update**

The `update_performance_statistics` function iterates through all indices and increments `failed_proposals` for each occurrence: [4](#0-3) 

No deduplication occurs—the loop increments the same validator's counter three times.

**Step 5: Reward Calculation**

At epoch end, rewards are calculated using the performance ratio: [5](#0-4) 

The reward formula uses this inflated `failed_proposals` count: [6](#0-5) 

This artificially reduces the validator's performance multiplier and thus their rewards.

## Impact Explanation

**Severity: High**

This issue qualifies as **High Severity** under the Aptos bug bounty criteria for the following reasons:

1. **Significant Protocol Violation**: Breaks the critical invariant "Staking Security: Validator rewards and penalties must be calculated correctly"

2. **Unfair Economic Penalties**: Validators receive significantly reduced epoch rewards due to artificially inflated failure counts. If a validator with 100 successful proposals fails 3 consecutive rounds where they were assigned (with `contiguous_rounds=3`), their failure count becomes 3 instead of representing a single failure period. This reduces their performance ratio from 100/103 (97%) to 100/103 (still 97%, BUT the issue is they should only be penalized once for the continuous failure period, not three separate times).

3. **Deterministic Exploitation**: Not dependent on attacker action—occurs automatically whenever the specific configuration exists and a validator experiences consecutive round failures.

4. **Correctness Violation**: The system incorrectly interprets `failed_proposer_indices` as independent failure events rather than tracking which validators failed during their assigned rounds.

## Likelihood Explanation

**Likelihood: Medium (in affected configurations)**

- **Configuration Dependency**: Requires network to be configured with `ProposerElectionType::RotatingProposer(N)` or `ProposerElectionType::FixedProposer(N)` where N > 1
  
- **Default Configuration**: The default genesis configuration uses `LeaderReputation`, so the issue does not affect default deployments: [7](#0-6) 

- **Governance Changeability**: The configuration can be changed via on-chain governance to use `RotatingProposer`, making this a valid attack surface

- **Automatic Triggering**: Once the vulnerable configuration is active, the issue triggers automatically whenever a validator fails multiple consecutive assigned rounds—a common scenario during network partitions, node crashes, or maintenance

- **Test Coverage Gap**: Tests demonstrate the `contiguous_rounds` functionality but don't validate the performance tracking implications: [8](#0-7) 

## Recommendation

**Fix 1: Deduplicate Indices in `update_performance_statistics`**

Modify the Move function to track which validators have already been penalized:

```move
public(friend) fun update_performance_statistics(
    proposer_index: Option<u64>,
    failed_proposer_indices: vector<u64>
) acquires ValidatorPerformance {
    let validator_perf = borrow_global_mut<ValidatorPerformance>(@aptos_framework);
    let validator_len = vector::length(&validator_perf.validators);
    
    // Update successful proposals for proposer
    if (option::is_some(&proposer_index)) {
        let cur_proposer_index = option::extract(&mut proposer_index);
        if (cur_proposer_index < validator_len) {
            let validator = vector::borrow_mut(&mut validator_perf.validators, cur_proposer_index);
            validator.successful_proposals = validator.successful_proposals + 1;
        };
    };
    
    // Deduplicate failed proposer indices before processing
    let already_penalized = vector::empty<u64>();
    let f = 0;
    let f_len = vector::length(&failed_proposer_indices);
    while (f < f_len) {
        let validator_index = *vector::borrow(&failed_proposer_indices, f);
        
        // Only increment if not already penalized and within bounds
        if (validator_index < validator_len && !vector::contains(&already_penalized, &validator_index)) {
            let validator = vector::borrow_mut(&mut validator_perf.validators, validator_index);
            validator.failed_proposals = validator.failed_proposals + 1;
            vector::push_back(&mut already_penalized, validator_index);
        };
        f = f + 1;
    };
}
```

**Fix 2: Deduplicate at Consensus Layer**

Alternatively, deduplicate in the Rust consensus code when converting `failed_authors` to indices:

```rust
fn failed_authors_to_indices(
    validators: &[AccountAddress],
    failed_authors: &[(Round, Author)],
) -> Vec<u32> {
    let mut seen = std::collections::HashSet::new();
    failed_authors
        .iter()
        .filter_map(|(_round, failed_author)| {
            let index = validators
                .iter()
                .position(|&v| v == *failed_author)?
                .try_into()
                .ok()?;
            // Only include if not seen before
            if seen.insert(index) {
                Some(index)
            } else {
                None
            }
        })
        .collect()
}
```

**Recommended Approach**: Implement Fix 1 in the Move code as it provides defense-in-depth and ensures correctness regardless of how `failed_proposer_indices` is constructed.

## Proof of Concept

```move
#[test_only]
module aptos_framework::stake_duplicate_penalty_test {
    use aptos_framework::stake;
    use aptos_framework::validator_performance;
    use std::vector;
    use std::option;
    
    #[test(aptos_framework = @aptos_framework)]
    fun test_duplicate_failed_proposer_penalty(aptos_framework: &signer) {
        // Setup: Initialize staking with 3 validators
        // Validator at index 1 is assigned to rounds 10, 11, 12 with contiguous_rounds=3
        // Validator fails all three rounds
        
        // Simulate the scenario:
        // failed_proposer_indices = [1, 1, 1] (same validator failed 3 consecutive rounds)
        let failed_indices = vector::empty<u64>();
        vector::push_back(&mut failed_indices, 1);
        vector::push_back(&mut failed_indices, 1);
        vector::push_back(&mut failed_indices, 1);
        
        // Call update_performance_statistics
        stake::update_performance_statistics(
            option::some(0), // proposer at index 0 succeeded
            failed_indices
        );
        
        // Verify the result:
        let perf = validator_performance::get_performance();
        let validator_1 = vector::borrow(&perf.validators, 1);
        
        // BUG: failed_proposals = 3 (incremented 3 times)
        // EXPECTED: failed_proposals = 1 (single failure period)
        assert!(validator_1.failed_proposals == 3, 0); // This assertion passes, demonstrating the bug
        
        // This validator now receives unfairly reduced rewards
        // due to the inflated failure count
    }
}
```

## Notes

1. **Configuration Scope**: This vulnerability only affects networks configured with `RotatingProposer(N)` or `FixedProposer(N)` where N > 1. The default `LeaderReputation` election is not affected.

2. **Semantic vs Implementation**: The issue arises from a semantic mismatch: `failed_proposer_indices` is treated as a list of independent failure events, but with `contiguous_rounds > 1`, it contains duplicates representing consecutive failures by the same validator during their assigned period.

3. **Validation Acceptance**: The consensus validation explicitly checks that `failed_authors` matches expected values, meaning duplicates are considered valid: [9](#0-8) 

4. **Impact Scaling**: With `contiguous_rounds=N`, a validator failing all assigned rounds receives N times the penalty they should receive, making the impact scale linearly with the configuration parameter.

5. **Reward Formula Impact**: The inflated `failed_proposals` directly reduces the performance multiplier in the rewards calculation, causing measurable economic harm to affected validators.

### Citations

**File:** consensus/src/liveness/rotating_proposer_election.rs (L36-39)
```rust
    fn get_valid_proposer(&self, round: Round) -> Author {
        self.proposers
            [((round / u64::from(self.contiguous_rounds)) % self.proposers.len() as u64) as usize]
    }
```

**File:** consensus/src/liveness/proposal_generator.rs (L884-902)
```rust
    pub fn compute_failed_authors(
        &self,
        round: Round,
        previous_round: Round,
        include_cur_round: bool,
        proposer_election: Arc<dyn ProposerElection>,
    ) -> Vec<(Round, Author)> {
        let end_round = round + u64::from(include_cur_round);
        let mut failed_authors = Vec::new();
        let start = std::cmp::max(
            previous_round + 1,
            end_round.saturating_sub(self.max_failed_authors_to_store as u64),
        );
        for i in start..end_round {
            failed_authors.push((i, proposer_election.get_valid_proposer(i)));
        }

        failed_authors
    }
```

**File:** consensus/consensus-types/src/block.rs (L619-638)
```rust
    fn failed_authors_to_indices(
        validators: &[AccountAddress],
        failed_authors: &[(Round, Author)],
    ) -> Vec<u32> {
        failed_authors
            .iter()
            .map(|(_round, failed_author)| {
                validators
                    .iter()
                    .position(|&v| v == *failed_author)
                    .unwrap_or_else(|| {
                        panic!(
                            "Failed author {} not in validator list {:?}",
                            *failed_author, validators
                        )
                    })
            })
            .map(|index| u32::try_from(index).expect("Index is out of bounds for u32"))
            .collect()
    }
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1309-1331)
```text
        let f = 0;
        let f_len = vector::length(&failed_proposer_indices);
        while ({
            spec {
                invariant len(validator_perf.validators) == validator_len;
                invariant (option::is_some(ghost_proposer_idx) && option::borrow(
                    ghost_proposer_idx
                ) < validator_len) ==>
                    (validator_perf.validators[option::borrow(ghost_proposer_idx)].successful_proposals ==
                        ghost_valid_perf.validators[option::borrow(ghost_proposer_idx)].successful_proposals + 1);
            };
            f < f_len
        }) {
            let validator_index = *vector::borrow(&failed_proposer_indices, f);
            if (validator_index < validator_len) {
                let validator = vector::borrow_mut(&mut validator_perf.validators, validator_index);
                spec {
                    assume validator.failed_proposals + 1 <= MAX_U64;
                };
                validator.failed_proposals = validator.failed_proposals + 1;
            };
            f = f + 1;
        };
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1691-1691)
```text
        let num_total_proposals = cur_validator_perf.successful_proposals + cur_validator_perf.failed_proposals;
```

**File:** aptos-move/framework/aptos-framework/sources/stake.move (L1777-1780)
```text
        let rewards_numerator = (stake_amount as u128) * (rewards_rate as u128) * (num_successful_proposals as u128);
        let rewards_denominator = (rewards_rate_denominator as u128) * (num_total_proposals as u128);
        if (rewards_denominator > 0) {
            ((rewards_numerator / rewards_denominator) as u64)
```

**File:** types/src/on_chain_config/consensus_config.rs (L488-503)
```rust
            proposer_election_type: ProposerElectionType::LeaderReputation(
                LeaderReputationType::ProposerAndVoterV2(ProposerAndVoterConfig {
                    active_weight: 1000,
                    inactive_weight: 10,
                    failed_weight: 1,
                    failure_threshold_percent: 10, // = 10%
                    // In each round we get stastics for the single proposer
                    // and large number of validators. So the window for
                    // the proposers needs to be significantly larger
                    // to have enough useful statistics.
                    proposer_window_num_validators_multiplier: 10,
                    voter_window_num_validators_multiplier: 1,
                    weight_by_voting_power: true,
                    use_history_from_previous_epoch_max_count: 5,
                }),
            ),
```

**File:** consensus/src/liveness/rotating_proposer_test.rs (L28-43)
```rust
fn test_rotating_proposer_with_three_contiguous_rounds() {
    let chosen_author = AccountAddress::random();
    let another_author = AccountAddress::random();
    let proposers = vec![chosen_author, another_author];
    let pe = RotatingProposer::new(proposers, 3);

    // Send a proposal from both chosen author and another author, the only winning proposals
    // follow the round-robin rotation with 3 contiguous rounds.

    assert!(!pe.is_valid_proposer(another_author, 1));
    assert!(pe.is_valid_proposer(chosen_author, 1));
    assert!(pe.is_valid_proposer(chosen_author, 2));
    assert!(!pe.is_valid_proposer(another_author, 2));
    assert_eq!(pe.get_valid_proposer(1), chosen_author);
    assert_eq!(pe.get_valid_proposer(2), chosen_author);
}
```

**File:** consensus/src/round_manager.rs (L1224-1230)
```rust
            ensure!(
                proposal.block_data().failed_authors().is_some_and(|failed_authors| *failed_authors == expected_failed_authors),
                "[RoundManager] Proposal for block {} has invalid failed_authors list {:?}, expected {:?}",
                proposal.round(),
                proposal.block_data().failed_authors(),
                expected_failed_authors,
            );
```
