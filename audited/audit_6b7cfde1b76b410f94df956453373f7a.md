# Audit Report

## Title
Consensus Observer Accepts Unvalidated Randomness Values Bypassing Cryptographic Verification

## Summary
The consensus observer implementation accepts randomness values from network messages without cryptographic verification, allowing malicious or compromised validator publishers to inject arbitrary randomness into observer nodes, breaking the cryptographic correctness invariant and enabling manipulation of randomness-dependent on-chain applications.

## Finding Description

The Aptos consensus system implements a dual-path randomness handling mechanism with a critical validation gap in the consensus observer path.

**Normal Validator Path (Secure)**:
Validators generate randomness through a cryptographically secure process:
1. Validators exchange WVUF (Weighted Verifiable Unpredictable Function) shares
2. Each share is verified via cryptographic proof before acceptance [1](#0-0) 
3. Verified shares are aggregated using WVUF to produce final randomness [2](#0-1) 
4. The randomness is sent through an internal channel to be attached to blocks [3](#0-2) 

**Consensus Observer Path (Vulnerable)**:
Observer nodes receive `OrderedBlock` messages from validator publishers containing serialized `PipelinedBlock` instances. The serialization includes the randomness field: [4](#0-3) 

During deserialization, randomness is directly set without any validation: [5](#0-4) 

The `OrderedBlock::verify_ordered_blocks()` method only validates block structure and chaining, not randomness: [6](#0-5) 

**Attack Scenario**:
1. A malicious or compromised validator acts as a consensus observer publisher
2. The validator generates valid blocks with proper consensus proofs
3. Instead of including cryptographically generated randomness, the attacker crafts malicious randomness (e.g., predictable patterns, all zeros, or biased values)
4. The attacker serializes `PipelinedBlock` instances with crafted randomness
5. These blocks are sent to subscribed observers via `OrderedBlock` messages [7](#0-6) 
6. Observer nodes deserialize and accept the crafted randomness without WVUF verification
7. The manipulated randomness is used in on-chain execution, affecting Move contracts that depend on randomness APIs

## Impact Explanation

**Severity: Critical**

This vulnerability meets the Critical severity criteria for the following reasons:

1. **Consensus Safety Violation**: Different observer nodes could receive different randomness for the same blocks, breaking deterministic execution guarantees and causing state divergence.

2. **Loss of Funds**: Applications using Aptos randomness APIs (e.g., lotteries, games, fair selection mechanisms) would operate with manipulated randomness, enabling theft of user funds through biased outcomes.

3. **Cryptographic Correctness Breach**: The entire WVUF-based randomness generation is bypassed on the observer path, violating the fundamental security guarantee that randomness must be verifiable and unpredictable.

4. **Widespread Impact**: A single compromised validator publisher can affect all subscribed consensus observers, potentially impacting a large portion of the network's non-validator nodes.

## Likelihood Explanation

**Likelihood: Medium to High**

1. **Attack Prerequisites**: Requires control of a validator node acting as consensus observer publisher, which could occur through:
   - Validator key compromise
   - Malicious validator operator
   - Software vulnerability in validator node

2. **Detection Difficulty**: The attack is stealthy because:
   - Observers have no mechanism to detect invalid randomness
   - The consensus proof remains valid
   - Block execution succeeds normally

3. **Ease of Exploitation**: Once validator access is obtained:
   - No complex cryptographic attacks required
   - Simple modification of randomness values before serialization
   - No coordination with other validators needed

## Recommendation

Implement cryptographic verification of randomness in the consensus observer path:

```rust
// In consensus/src/consensus_observer/network/observer_message.rs
impl OrderedBlock {
    /// Verifies the randomness in ordered blocks using WVUF proofs
    pub fn verify_randomness(&self, epoch_state: &EpochState, rand_config: &RandConfig) -> Result<(), Error> {
        for block in &self.blocks {
            if let Some(randomness) = block.randomness() {
                // Verify randomness matches block's epoch and round
                ensure!(
                    randomness.epoch() == block.epoch() && randomness.round() == block.round(),
                    Error::InvalidMessageError(format!(
                        "Randomness metadata mismatch! Block: epoch={}, round={}, Randomness: epoch={}, round={}",
                        block.epoch(), block.round(), randomness.epoch(), randomness.round()
                    ))
                );
                
                // TODO: Implement WVUF proof verification
                // This requires including WVUF proofs in the OrderedBlock message
                // or having observers independently verify randomness shares
            }
        }
        Ok(())
    }
}
```

Additionally, modify the serialization format to include WVUF proofs or shares: [4](#0-3) 

The serialized format should be extended to include verifiable proofs alongside randomness values, enabling observers to validate randomness independently.

## Proof of Concept

```rust
// Proof of Concept: Malicious validator crafting OrderedBlock with fake randomness
use aptos_consensus_types::pipelined_block::PipelinedBlock;
use aptos_types::randomness::{Randomness, RandMetadata};

// Step 1: Validator creates valid blocks with consensus proof
let mut ordered_blocks = create_valid_ordered_blocks();

// Step 2: Attacker crafts malicious randomness (all zeros for predictability)
let malicious_randomness = Randomness::new(
    RandMetadata { epoch: 1, round: 100 },
    vec![0u8; 32]  // Predictable randomness instead of WVUF-derived
);

// Step 3: Set crafted randomness on blocks
for block in &ordered_blocks.ordered_blocks {
    block.set_randomness(malicious_randomness.clone());
}

// Step 4: Serialize and send to observers
let ordered_block_msg = ConsensusObserverMessage::new_ordered_block_message(
    ordered_blocks.ordered_blocks.clone(),
    ordered_blocks.ordered_proof.clone()
);

// Step 5: Observer deserializes - randomness is set WITHOUT verification
// The malicious randomness is now accepted and will be used in execution
// Breaking any on-chain applications that depend on fair randomness
```

**Impact**: Observer nodes execute blocks with attacker-controlled randomness, enabling manipulation of games, lotteries, and other randomness-dependent protocols, potentially resulting in loss of user funds.

### Citations

**File:** consensus/src/rand/rand_gen/network_messages.rs (L36-60)
```rust
    pub fn verify(
        &self,
        epoch_state: &EpochState,
        rand_config: &RandConfig,
        fast_rand_config: &Option<RandConfig>,
        sender: Author,
    ) -> anyhow::Result<()> {
        ensure!(self.epoch() == epoch_state.epoch);
        match self {
            RandMessage::RequestShare(_) => Ok(()),
            RandMessage::Share(share) => share.verify(rand_config),
            RandMessage::AugData(aug_data) => {
                aug_data.verify(rand_config, fast_rand_config, sender)
            },
            RandMessage::CertifiedAugData(certified_aug_data) => {
                certified_aug_data.verify(&epoch_state.verifier)
            },
            RandMessage::FastShare(share) => {
                share.share.verify(fast_rand_config.as_ref().ok_or_else(|| {
                    anyhow::anyhow!("[RandMessage] rand config for fast path not found")
                })?)
            },
            _ => bail!("[RandMessage] unexpected message type"),
        }
    }
```

**File:** consensus/src/rand/rand_gen/types.rs (L97-148)
```rust
    fn aggregate<'a>(
        shares: impl Iterator<Item = &'a RandShare<Self>>,
        rand_config: &RandConfig,
        rand_metadata: RandMetadata,
    ) -> anyhow::Result<Randomness>
    where
        Self: Sized,
    {
        let timer = std::time::Instant::now();
        let mut apks_and_proofs = vec![];
        for share in shares {
            let id = rand_config
                .validator
                .address_to_validator_index()
                .get(share.author())
                .copied()
                .ok_or_else(|| {
                    anyhow!(
                        "Share::aggregate failed with invalid share author: {}",
                        share.author
                    )
                })?;
            let apk = rand_config
                .get_certified_apk(share.author())
                .ok_or_else(|| {
                    anyhow!(
                        "Share::aggregate failed with missing apk for share from {}",
                        share.author
                    )
                })?;
            apks_and_proofs.push((Player { id }, apk.clone(), share.share().share));
        }

        let proof = WVUF::aggregate_shares(&rand_config.wconfig, &apks_and_proofs);
        let metadata_serialized = bcs::to_bytes(&rand_metadata).map_err(|e| {
            anyhow!("Share::aggregate failed with metadata serialization error: {e}")
        })?;
        let eval = WVUF::derive_eval(
            &rand_config.wconfig,
            &rand_config.vuf_pp,
            metadata_serialized.as_slice(),
            &rand_config.get_all_certified_apk(),
            &proof,
            THREAD_MANAGER.get_exe_cpu_pool(),
        )
        .map_err(|e| anyhow!("Share::aggregate failed with WVUF derive_eval error: {e}"))?;
        debug!("WVUF derivation time: {} ms", timer.elapsed().as_millis());
        let eval_bytes = bcs::to_bytes(&eval)
            .map_err(|e| anyhow!("Share::aggregate failed with eval serialization error: {e}"))?;
        let rand_bytes = Sha3_256::digest(eval_bytes.as_slice()).to_vec();
        Ok(Randomness::new(rand_metadata, rand_bytes))
    }
```

**File:** consensus/src/rand/rand_gen/rand_manager.rs (L196-206)
```rust
    fn process_randomness(&mut self, randomness: Randomness) {
        let rand = hex::encode(randomness.randomness());
        info!(
            metadata = randomness.metadata(),
            rand = rand,
            "Processing decisioned randomness."
        );
        if let Some(block) = self.block_queue.item_mut(randomness.round()) {
            block.set_randomness(randomness.round(), randomness);
        }
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L228-247)
```rust
impl Serialize for PipelinedBlock {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: Serializer,
    {
        #[derive(Serialize)]
        #[serde(rename = "PipelineBlock")]
        struct SerializedBlock<'a> {
            block: &'a Block,
            input_transactions: &'a Vec<SignedTransaction>,
            randomness: Option<&'a Randomness>,
        }

        let serialized = SerializedBlock {
            block: &self.block,
            input_transactions: &self.input_transactions,
            randomness: self.randomness.get(),
        };
        serialized.serialize(serializer)
    }
```

**File:** consensus/consensus-types/src/pipelined_block.rs (L250-273)
```rust
impl<'de> Deserialize<'de> for PipelinedBlock {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        #[derive(Deserialize)]
        #[serde(rename = "PipelineBlock")]
        struct SerializedBlock {
            block: Block,
            input_transactions: Vec<SignedTransaction>,
            randomness: Option<Randomness>,
        }

        let SerializedBlock {
            block,
            input_transactions,
            randomness,
        } = SerializedBlock::deserialize(deserializer)?;
        let block = PipelinedBlock::new(block, input_transactions, StateComputeResult::new_dummy());
        if let Some(r) = randomness {
            block.set_randomness(r);
        }
        Ok(block)
    }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L179-218)
```rust
/// OrderedBlock message contains the ordered blocks and the proof of the ordering
#[derive(Clone, Debug, Deserialize, Eq, PartialEq, Serialize)]
pub struct OrderedBlock {
    blocks: Vec<Arc<PipelinedBlock>>,
    ordered_proof: LedgerInfoWithSignatures,
}

impl OrderedBlock {
    pub fn new(blocks: Vec<Arc<PipelinedBlock>>, ordered_proof: LedgerInfoWithSignatures) -> Self {
        Self {
            blocks,
            ordered_proof,
        }
    }

    /// Returns a reference to the ordered blocks
    pub fn blocks(&self) -> &Vec<Arc<PipelinedBlock>> {
        &self.blocks
    }

    /// Returns a copy of the first ordered block
    pub fn first_block(&self) -> Arc<PipelinedBlock> {
        self.blocks
            .first()
            .cloned()
            .expect("At least one block is expected!")
    }

    /// Returns a copy of the last ordered block
    pub fn last_block(&self) -> Arc<PipelinedBlock> {
        self.blocks
            .last()
            .cloned()
            .expect("At least one block is expected!")
    }

    /// Returns a reference to the ordered proof
    pub fn ordered_proof(&self) -> &LedgerInfoWithSignatures {
        &self.ordered_proof
    }
```

**File:** consensus/src/consensus_observer/network/observer_message.rs (L225-266)
```rust
    /// Verifies the ordered blocks and returns an error if the data is invalid.
    /// Note: this does not check the ordered proof.
    pub fn verify_ordered_blocks(&self) -> Result<(), Error> {
        // Verify that we have at least one ordered block
        if self.blocks.is_empty() {
            return Err(Error::InvalidMessageError(
                "Received empty ordered block!".to_string(),
            ));
        }

        // Verify the last block ID matches the ordered proof block ID
        if self.last_block().id() != self.proof_block_info().id() {
            return Err(Error::InvalidMessageError(
                format!(
                    "Last ordered block ID does not match the ordered proof ID! Number of blocks: {:?}, Last ordered block ID: {:?}, Ordered proof ID: {:?}",
                    self.blocks.len(),
                    self.last_block().id(),
                    self.proof_block_info().id()
                )
            ));
        }

        // Verify the blocks are correctly chained together (from the last block to the first)
        let mut expected_parent_id = None;
        for block in self.blocks.iter().rev() {
            if let Some(expected_parent_id) = expected_parent_id {
                if block.id() != expected_parent_id {
                    return Err(Error::InvalidMessageError(
                        format!(
                            "Block parent ID does not match the expected parent ID! Block ID: {:?}, Expected parent ID: {:?}",
                            block.id(),
                            expected_parent_id
                        )
                    ));
                }
            }

            expected_parent_id = Some(block.parent_id());
        }

        Ok(())
    }
```
