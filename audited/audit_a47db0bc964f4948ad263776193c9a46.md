# Audit Report

## Title
Bytecode Corruption via Integer Overflow in Script Composer StLoc Generation

## Summary
The `TransactionComposer` in `aptos-move/script-composer/src/builder.rs` contains an inconsistent bounds check that allows total parameters and locals to exceed 255, causing integer overflow during `StLoc` bytecode generation. This produces corrupted bytecode that stores return values to incorrect local indices, potentially overwriting parameters.

## Finding Description

The vulnerability stems from an inconsistency between the bounds check and bytecode generation logic.

The bounds check at line 331 validates against `parameters.len()`, which only counts raw parameters added via `CallArgument::Raw`: [1](#0-0) 

However, `parameters.len()` is a `Vec<Vec<u8>>` that excludes signer parameters initialized by `multi_signer()`. The signer parameters are only stored in `parameters_ty`: [2](#0-1) 

During bytecode generation, the code uses `parameters_ty.len()` which includes ALL parameters: [3](#0-2) 

When generating `StLoc` instructions for return values, an unchecked cast occurs: [4](#0-3) 

In Rust, `as u8` performs truncating conversion - when `*arg + parameters_count >= 256`, the value wraps (e.g., 256 becomes 0).

**Attack Scenario:**

1. Create `TransactionComposer` with `multi_signer(32)`:
   - `parameters_ty` contains 32 `&signer` entries
   - `parameters` remains empty (0 entries)

2. Add function calls returning 225 values:
   - Bounds check: `0 + 225 = 225 <= 255` ✓ PASSES
   - Actual total: `32 + 225 = 257` (exceeds 255)

3. During generation for return value at local index 224:
   - `(224 + 32) as u8 = 256 as u8 = 0`
   - Generates `StLoc(0)` instead of `StLoc(256)`
   - Stores to parameter 0 instead of local 256

The `to_instruction()` method has proper bounds checking with `checked_add()`: [5](#0-4) 

However, this is bypassed because return value `StLoc` instructions are generated directly at line 401, not through `to_instruction()`.

The bytecode verifier provides partial protection by checking type assignability: [6](#0-5) 

However, if the return type happens to be assignable to the parameter type at the overflowed index, verification passes with corrupted semantics.

## Impact Explanation

This vulnerability qualifies as **Medium severity** per the Aptos bug bounty criteria for "state inconsistencies requiring manual intervention."

**Impacts:**
- **Bytecode Corruption**: Return values stored to wrong indices due to integer overflow
- **Semantic Incorrectness**: Scripts execute with unintended behavior when verification passes
- **Deterministic Execution Violation**: Different semantic meaning than intended by composer
- **Type System Partial Bypass**: Verification only catches mismatches, not semantic corruption

While the bytecode verifier mitigates many cases through type checking, edge cases where return types align with parameter types allow corrupted execution. This violates Move VM correctness guarantees and could lead to unpredictable behavior in automated systems using the script composer.

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability is triggerable when:
- Using `multi_signer()` with multiple signers (2-32)
- Composing complex scripts with sufficient return values
- Total locals exceeding 255 (e.g., 32 signers + 225 locals)

This scenario is realistic for complex multi-agent transactions with numerous function calls. The inconsistent bounds check using `parameters.len()` instead of `parameters_ty.len()` allows the overflow to occur undetected until bytecode generation.

## Recommendation

Fix the bounds check to use `parameters_ty.len()` instead of `parameters.len()`:

```rust
if self.parameters_ty.len() + self.locals_ty.len() > u8::MAX as usize {
    bail!("Too many locals being allocated, please truncate the transaction");
}
```

Additionally, use `to_instruction()` for generating all bytecode instructions including `StLoc` for return values, or add explicit bounds checking before the cast at line 401.

## Proof of Concept

```rust
#[test]
fn test_integer_overflow_stloc() {
    use move_core_types::language_storage::ModuleId;
    use std::str::FromStr;
    
    // Create composer with 32 signers
    let mut composer = TransactionComposer::multi_signer(32);
    
    // Add a module with a function returning a value
    // (module details omitted for brevity)
    
    // Add 225 function calls that each return one value
    for i in 0..225 {
        composer.add_batched_call(
            "0x1::test".to_string(),
            "return_u64".to_string(),
            vec![],
            vec![],
        ).unwrap();
    }
    
    // This should fail but doesn't due to incorrect bounds check
    // parameters.len() = 0, locals_ty.len() = 225
    // Check: 0 + 225 = 225 <= 255 ✓ PASSES
    
    // During generation: parameters_count = 32
    // Last StLoc: (224 + 32) as u8 = 0
    // Corrupted bytecode generated!
    
    let result = composer.generate_batched_calls(false);
    // May pass or fail verification depending on type compatibility
}
```

**Notes:**
- The vulnerability requires specific type alignment to pass bytecode verification
- The inconsistent bounds check is the root cause allowing overflow
- Fix requires checking against `parameters_ty.len()` for correct validation

### Citations

**File:** aptos-move/script-composer/src/builder.rs (L106-126)
```rust
    pub fn multi_signer(signer_count: u16) -> Self {
        let mut script = empty_script();
        script.code.code = vec![];

        let builder = CompiledScriptBuilder::new(script);
        Self {
            builder,
            calls: vec![],
            parameters: vec![],
            locals_availability: vec![],
            locals_ty: vec![],
            parameters_ty: std::iter::repeat_n(
                SignatureToken::Reference(Box::new(SignatureToken::Signer)),
                signer_count.into(),
            )
            .collect(),

            #[cfg(test)]
            signer_count,
        }
    }
```

**File:** aptos-move/script-composer/src/builder.rs (L331-333)
```rust
        if self.parameters.len() + self.locals_ty.len() > u8::MAX as usize {
            bail!("Too many locals being allocated, please truncate the transaction");
        }
```

**File:** aptos-move/script-composer/src/builder.rs (L364-364)
```rust
        let parameters_count = self.parameters_ty.len() as u16;
```

**File:** aptos-move/script-composer/src/builder.rs (L397-402)
```rust
            for arg in call.returns.iter().rev() {
                script
                    .code
                    .code
                    .push(Bytecode::StLoc((*arg + parameters_count) as u8));
            }
```

**File:** aptos-move/script-composer/src/builder.rs (L492-509)
```rust
    fn to_instruction(&self, parameter_size: u16) -> anyhow::Result<Bytecode> {
        let local_idx = if self.is_parameter {
            self.local_idx
        } else {
            parameter_size
                .checked_add(self.local_idx)
                .ok_or_else(|| anyhow!("Too many locals"))?
        };
        if local_idx >= u8::MAX as u16 {
            bail!("Too many locals");
        };
        Ok(match self.op_type {
            ArgumentOperation::Borrow => Bytecode::ImmBorrowLoc(local_idx as u8),
            ArgumentOperation::BorrowMut => Bytecode::MutBorrowLoc(local_idx as u8),
            ArgumentOperation::Move => Bytecode::MoveLoc(local_idx as u8),
            ArgumentOperation::Copy => Bytecode::CopyLoc(local_idx as u8),
        })
    }
```

**File:** third_party/move/move-bytecode-verifier/src/type_safety.rs (L630-635)
```rust
        Bytecode::StLoc(idx) => {
            let operand = safe_unwrap!(verifier.stack.pop());
            if !verifier.local_at(*idx).is_assignable_from(&operand) {
                return Err(verifier.error(StatusCode::STLOC_TYPE_MISMATCH_ERROR, offset));
            }
        },
```
