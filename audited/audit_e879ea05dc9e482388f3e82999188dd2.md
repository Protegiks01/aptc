# Audit Report

## Title
Network Topology Exposure via Centralized Prometheus Metrics Collection Enables Eclipse Attack Planning

## Summary
The Aptos telemetry system collects and transmits detailed validator network topology information (including peer-to-peer connection mappings) to a centralized telemetry service every 15 seconds. The `APTOS_NETWORK_PEER_CONNECTED` metric explicitly tracks which validators are connected to which other validators, creating a complete real-time map of the validator network topology that could be accessed by attackers to plan eclipse attacks or targeted DDoS campaigns.

## Finding Description

The telemetry system pushes ALL Prometheus metrics to Aptos Labs' centralized telemetry service at regular intervals. The network layer tracks validator connections using the `APTOS_NETWORK_PEER_CONNECTED` metric with labels that identify both the local and remote validator: [1](#0-0) 

This metric is specifically populated only for validator networks, creating an exact mapping of the validator network topology: [2](#0-1) 

Every 15 seconds, the telemetry service pushes ALL Prometheus metrics (including these topology-revealing metrics) to the centralized backend: [3](#0-2) [4](#0-3) 

The metrics are sent to VictoriaMetrics with additional labels including peer identity and optionally geographic location: [5](#0-4) [6](#0-5) 

This telemetry is enabled by default unless explicitly disabled: [7](#0-6) 

**Attack Scenario:**
1. Attacker gains access to Aptos Labs telemetry infrastructure (VictoriaMetrics dashboards, BigQuery, or monitoring systems) through compromise, insider access, or cloud provider access
2. Attacker queries `APTOS_NETWORK_PEER_CONNECTED` metric to build complete validator topology map
3. Attacker identifies critical validators with high connectivity or specific network positions
4. Attacker plans eclipse attack by targeting specific validators to partition a victim validator from the network
5. Attacker executes targeted DDoS or network-level attacks informed by the topology knowledge

## Impact Explanation

**Severity: MEDIUM**

This vulnerability falls under the "Minor information leaks" category but with significant security implications that elevate it toward medium severity:

1. **Eclipse Attack Enablement**: Complete visibility into validator network topology allows attackers to identify optimal targets for eclipse attacks, where a victim validator is isolated from honest peers
2. **Targeted DDoS Planning**: Knowledge of highly-connected validators enables focused attacks on critical network infrastructure
3. **Network Analysis**: Continuous 15-second updates provide near real-time intelligence on validator connection patterns, churn, and network changes
4. **Geographic Targeting**: Optional location labels reveal geographic distribution, enabling region-specific attacks

While this does not directly cause consensus violations or fund loss, it significantly lowers the bar for executing attacks that could lead to those outcomes. The centralized collection of sensitive network topology data violates defense-in-depth principles.

## Likelihood Explanation

**Likelihood: MEDIUM to HIGH**

The vulnerability is likely to be exploited because:

1. **Default Enabled**: Telemetry metrics push is enabled by default on all validators
2. **Broad Access Surface**: Multiple parties potentially have access to the telemetry backend:
   - Aptos Labs employees and contractors
   - Cloud service provider personnel
   - Monitoring dashboard users
   - Third-party security/analytics tools
3. **High-Value Target**: Validator network topology is valuable intelligence for sophisticated attackers
4. **Continuous Collection**: 15-second push interval provides real-time network state
5. **No Access Controls Visible**: The codebase shows authentication for pushing metrics but does not demonstrate access controls for querying the stored metrics

An attacker only needs read access to the telemetry backend to extract this information—no code execution or validator compromise required.

## Recommendation

**Immediate Mitigations:**

1. **Disable Topology Metrics in Telemetry Push**: Exclude `APTOS_NETWORK_PEER_CONNECTED` and similar topology-revealing metrics from the default Prometheus push:

```rust
// In crates/aptos-telemetry/src/sender.rs
pub(crate) async fn push_prometheus_metrics(
    &self,
    registry: &Registry,
) -> Result<(), anyhow::Error> {
    let mut scraped_metrics = prometheus::TextEncoder::new()
        .encode_to_string(&registry.gather())?;
    
    // Filter out topology-sensitive metrics
    scraped_metrics = filter_sensitive_metrics(scraped_metrics);
    // ... rest of implementation
}

fn filter_sensitive_metrics(metrics: String) -> String {
    metrics
        .lines()
        .filter(|line| {
            !line.contains("aptos_network_peer_connected") &&
            !line.contains("remote_peer_id=")
        })
        .collect::<Vec<_>>()
        .join("\n")
}
```

2. **Anonymize Peer IDs**: Replace peer IDs with anonymized identifiers in telemetry:

```rust
// Use hash of peer_id instead of actual peer_id
format!("peer_id_hash={}", 
    blake3::hash(peer_id.as_ref()).to_hex()[..8])
```

3. **Disable by Default for Sensitive Metrics**: Create separate opt-in for topology metrics: [8](#0-7) 

Add new environment variable `APTOS_ENABLE_TOPOLOGY_TELEMETRY` that must be explicitly set.

4. **Implement Access Controls**: Add role-based access controls to the telemetry service backend to restrict who can query validator topology metrics.

5. **Audit Existing Data**: Review and potentially purge historical topology data from VictoriaMetrics.

## Proof of Concept

**Demonstration of Data Flow:**

```rust
// 1. Validator connects to peer - metric is recorded
// In network/framework/src/counters.rs:
pub fn peer_connected(network_context: &NetworkContext, remote_peer_id: &PeerId, v: i64) {
    if network_context.network_id().is_validator_network() {
        APTOS_NETWORK_PEER_CONNECTED
            .with_label_values(&[
                network_context.role().as_str(),           // "validator"
                network_context.network_id().as_str(),     // "validator"
                network_context.peer_id().short_str().as_str(), // "0xabc123..."
                remote_peer_id.short_str().as_str(),       // "0xdef456..." <- TOPOLOGY INFO
            ])
            .set(v)
    }
}

// 2. Every 15 seconds, ALL metrics are pushed
// In crates/aptos-telemetry/src/service.rs:
tokio::spawn(async move {
    let mut interval = time::interval(Duration::from_secs(15));
    loop {
        interval.tick().await;
        telemetry_sender.try_push_prometheus_metrics().await; // Pushes EVERYTHING
    }
});

// 3. Telemetry service receives and stores in VictoriaMetrics
// In crates/aptos-telemetry-service/src/prometheus_push_metrics.rs:
client.post_prometheus_metrics(
    metrics_body.clone(),
    extra_labels.clone(), // Includes peer_id, potentially geo location
    encoding.clone().unwrap_or_default(),
)
```

**Query Example (Attacker's Perspective):**

An attacker with access to VictoriaMetrics can run queries like:
```promql
aptos_network_peer_connected{role="validator", network_id="validator"}
```

This returns the complete validator network graph showing all peer-to-peer connections in real-time.

## Notes

The vulnerability exists at the intersection of system design and implementation. While individual components (Prometheus metrics, telemetry service, authentication) are implemented correctly, the overall system design centralizes sensitive network topology data without sufficient consideration for the security implications.

The presence of `ENV_APTOS_DISABLE_TELEMETRY_PUSH_METRICS` suggests some awareness that metrics pushing might be sensitive, but it's not disabled by default and documentation doesn't warn about the topology disclosure risks.

This issue is particularly concerning for a blockchain network where validator network topology should be kept confidential to prevent eclipse attacks—a well-known attack vector in distributed consensus systems.

### Citations

**File:** network/framework/src/counters.rs (L47-63)
```rust
pub static APTOS_CONNECTIONS: Lazy<IntGaugeVec> = Lazy::new(|| {
    register_int_gauge_vec!(
        "aptos_connections",
        "Number of current connections and their direction",
        &["role_type", "network_id", "peer_id", "direction"]
    )
    .unwrap()
});

pub fn connections(network_context: &NetworkContext, origin: ConnectionOrigin) -> IntGauge {
    APTOS_CONNECTIONS.with_label_values(&[
        network_context.role().as_str(),
        network_context.network_id().as_str(),
        network_context.peer_id().short_str().as_str(),
        origin.as_str(),
    ])
}
```

**File:** network/framework/src/counters.rs (L86-106)
```rust
pub static APTOS_NETWORK_PEER_CONNECTED: Lazy<IntGaugeVec> = Lazy::new(|| {
    register_int_gauge_vec!(
        "aptos_network_peer_connected",
        "Indicates if we are connected to a particular peer",
        &["role_type", "network_id", "peer_id", "remote_peer_id"]
    )
    .unwrap()
});

pub fn peer_connected(network_context: &NetworkContext, remote_peer_id: &PeerId, v: i64) {
    if network_context.network_id().is_validator_network() {
        APTOS_NETWORK_PEER_CONNECTED
            .with_label_values(&[
                network_context.role().as_str(),
                network_context.network_id().as_str(),
                network_context.peer_id().short_str().as_str(),
                remote_peer_id.short_str().as_str(),
            ])
            .set(v)
    }
}
```

**File:** crates/aptos-telemetry/src/service.rs (L77-83)
```rust
/// Flag to control enabling/disabling prometheus push metrics
#[inline]
fn enable_prometheus_push_metrics() -> bool {
    force_enable_telemetry()
        || !(telemetry_is_disabled()
            || is_env_variable_true(ENV_APTOS_DISABLE_TELEMETRY_PUSH_METRICS))
}
```

**File:** crates/aptos-telemetry/src/service.rs (L259-271)
```rust
fn try_spawn_metrics_sender(telemetry_sender: TelemetrySender) {
    if enable_prometheus_push_metrics() {
        tokio::spawn(async move {
            // Periodically send ALL prometheus metrics (This replaces the previous core and network metrics implementation)
            let mut interval =
                time::interval(Duration::from_secs(PROMETHEUS_PUSH_METRICS_FREQ_SECS));
            loop {
                interval.tick().await;
                telemetry_sender.try_push_prometheus_metrics().await;
            }
        });
    }
}
```

**File:** crates/aptos-telemetry/src/constants.rs (L9-10)
```rust
pub(crate) const ENV_APTOS_DISABLE_TELEMETRY_PUSH_METRICS: &str =
    "APTOS_DISABLE_TELEMETRY_PUSH_METRICS";
```

**File:** crates/aptos-telemetry/src/constants.rs (L42-42)
```rust
pub(crate) const PROMETHEUS_PUSH_METRICS_FREQ_SECS: u64 = 15; // 15 seconds
```

**File:** crates/aptos-telemetry-service/src/prometheus_push_metrics.rs (L40-79)
```rust
pub async fn handle_metrics_ingest(
    context: Context,
    claims: Claims,
    encoding: Option<String>,
    metrics_body: Bytes,
) -> anyhow::Result<impl Reply, Rejection> {
    debug!("handling prometheus metrics ingest");

    let enable_location_labels = env::var("FEATURE_LOCATION_LABELS_ENABLED")
        .map(|val| val.parse::<bool>().unwrap_or(false))
        .unwrap_or(false);

    let enable_random_label = env::var("FEATURE_RANDOM_LABEL_ENABLED")
        .map(|val| val.parse::<bool>().unwrap_or(false))
        .unwrap_or(false);

    let max_random_value = env::var("FEATURE_RANDOM_LABEL_MAX_VALUE")
        .map(|val| val.parse::<i32>().unwrap_or(20))
        .unwrap_or(20);

    let mut extra_labels = claims_to_extra_labels(
        &claims,
        context
            .peer_identities()
            .get(&claims.chain_id)
            .and_then(|peers| peers.get(&claims.peer_id)),
    );
    if enable_location_labels {
        extra_labels.extend_from_slice(&peer_location_labels(&context, &claims.peer_id));
    }

    let extra_labels_with_random_label = if enable_random_label {
        let random_num = rand::thread_rng().gen_range(0, max_random_value);
        let mut labels = extra_labels.clone();
        labels.push(format!("random_label={}", random_num));
        labels
    } else {
        extra_labels.clone()
    };

```

**File:** crates/aptos-telemetry-service/src/prometheus_push_metrics.rs (L193-206)
```rust
fn peer_location_labels(context: &Context, peer_id: &PeerId) -> Vec<String> {
    let peer_locations = context.peer_locations().read();
    let peer_location = peer_locations.get(peer_id);
    let mut labels = vec![];
    if let Some(location) = peer_location {
        if let Some(country) = &location.country {
            labels.push(format!("country={}", sanitize_location(country)));
        }
        if let Some(region) = &location.region {
            labels.push(format!("region={}", sanitize_location(region)));
        }
    }
    labels
}
```
