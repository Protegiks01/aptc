# Audit Report

## Title
Absence of Byte-Level Rate Limiting on Encrypted Network Connections Enables Potential CPU Exhaustion Attack

## Summary
The Aptos network framework lacks byte-level rate limiting on inbound encrypted connections despite configuration options existing for it. An attacker can establish multiple connections and flood validators with maximum-sized encrypted messages (65,535 bytes each), forcing repeated CPU-intensive AES-GCM decryption operations that could degrade validator consensus performance.

## Finding Description

The vulnerability exists in the noise protocol implementation used for encrypted validator communications. The attack path is as follows:

1. **Missing Rate Limiter Implementation**: The network configuration defines `inbound_rate_limit_config` and `outbound_rate_limit_config` options [1](#0-0) , but the network framework does not depend on the `aptos-rate-limiter` crate [2](#0-1) , meaning these configurations are non-functional.

2. **Decryption Operation**: When encrypted messages arrive, `NoiseStream` reads the frame length and encrypted payload, then performs in-place AES-GCM decryption [3](#0-2) . The actual decryption occurs in `NoiseSession::read_message_in_place()` [4](#0-3) , which processes the entire message payload.

3. **Maximum Message Size**: Individual noise messages can be up to 65,535 bytes [5](#0-4) , maximizing the CPU cost per decryption.

4. **Connection Limits**: An attacker can establish up to 100 inbound connections by default [6](#0-5) , multiplying the attack surface.

5. **Attack Execution**: 
   - Attacker establishes 100 connections to a validator
   - Each connection sends rapid streams of 65,535-byte encrypted messages
   - The validator must decrypt each message before processing
   - With 100 connections sending at line rate, cumulative CPU usage increases significantly

6. **Impact on Consensus**: The Peer event loop processes messages sequentially [7](#0-6) . Excessive time spent decrypting malicious messages delays processing of legitimate consensus messages, degrading validator responsiveness and potentially affecting consensus performance.

## Impact Explanation

This vulnerability qualifies as **High Severity** per the Aptos bug bounty program's criteria for "Validator node slowdowns". The attack forces validators to perform computationally expensive cryptographic operations (AES-GCM decryption on 65,535-byte payloads) across 100 concurrent connections without rate limiting. This directly violates the **Resource Limits** invariant: "All operations must respect gas, storage, and computational limits."

While AES-GCM with hardware acceleration (AES-NI) is optimized, processing maximum-sized messages at high frequency across many connections can consume significant CPU resources. On validators with limited CPU capacity or under heavy legitimate load, this could:
- Delay consensus message processing
- Increase round times
- Reduce overall network throughput
- Create opportunities for consensus timing attacks

## Likelihood Explanation

**Likelihood: Medium-High**

The attack is straightforward to execute:
- No special privileges required (any network peer can connect)
- Simple attack script: establish connections and send max-sized encrypted payloads
- Configuration infrastructure for rate limiting exists but is unimplemented, suggesting this protection was planned but not completed
- Default configuration leaves validators vulnerable

Mitigating factors:
- TCP flow control provides some natural backpressure
- Modern servers have substantial CPU resources
- AES-NI hardware acceleration makes decryption relatively fast

However, the lack of explicit rate limiting on a security-critical path is a significant design flaw that attackers could exploit, especially during network stress or against resource-constrained validators.

## Recommendation

**Immediate Fix**: Implement byte-level rate limiting on NoiseStream connections using the existing `aptos-rate-limiter` crate.

1. Add `aptos-rate-limiter` as a dependency to `network/framework/Cargo.toml`
2. Wrap `NoiseStream` with `AsyncRateLimiter` when connections are established
3. Use the existing `inbound_rate_limit_config` from `NetworkConfig` to configure rate limits
4. Default to conservative limits (e.g., 100 KiB/s per IP) even when config is `None`

Implementation location: In `network/framework/src/transport/mod.rs`, wrap the NoiseStream returned by `upgrade_inbound()` and `upgrade_outbound()` with rate limiting based on configuration.

**Long-term**: Consider additional protections:
- Per-connection message frequency limits
- Progressive backoff for high-frequency senders
- Priority queuing for consensus messages vs. other traffic

## Proof of Concept

```rust
// Simulation demonstrating CPU impact of decryption flood
// Add to network/framework/src/noise/fuzzing.rs for testing

#[cfg(test)]
mod cpu_exhaustion_test {
    use super::*;
    use std::time::Instant;
    
    #[test]
    fn test_decryption_cpu_load() {
        // Simulate what an attacker would send
        let max_size_message = vec![0xAA; noise::MAX_SIZE_NOISE_MSG];
        let num_connections = 100;
        let messages_per_connection = 1000;
        
        let start = Instant::now();
        
        // Simulate multiple connections each sending many max-sized messages
        for _ in 0..num_connections {
            for _ in 0..messages_per_connection {
                let mut fake_socket = ReadOnlyTestSocket::new(&max_size_message);
                fake_socket.set_trailing();
                
                let noise_session = NoiseSession::new_for_testing();
                let mut peer = NoiseStream::new(fake_socket, noise_session);
                
                block_on(async {
                    let mut buffer = vec![0u8; noise::MAX_SIZE_NOISE_MSG];
                    let _ = peer.read(&mut buffer).await;
                });
            }
        }
        
        let duration = start.elapsed();
        println!("Decrypted {} messages in {:?}", 
                 num_connections * messages_per_connection, duration);
        println!("Average per message: {:?}", 
                 duration / (num_connections * messages_per_connection));
        
        // If duration is significant (e.g., > 1 second), demonstrates CPU impact
        assert!(duration.as_secs() < 10, 
                "Decryption took too long, indicating CPU exhaustion risk");
    }
}
```

To execute the attack in a real network environment:
1. Connect to validator's public network endpoint
2. Complete noise handshake
3. Send continuous stream of 65,535-byte encrypted messages at maximum rate
4. Multiply across 100 concurrent connections
5. Monitor validator's CPU usage and consensus round times

---

**Notes**

This vulnerability specifically addresses the "Resource Limits" invariant failure. While TCP backpressure and hardware-accelerated AES-GCM provide some natural protection, the complete absence of implemented rate limiting on a security-critical path represents a significant design flaw. The configuration infrastructure exists but remains non-functional, suggesting incomplete implementation of planned security controls.

### Citations

**File:** config/src/config/network_config.rs (L44-44)
```rust
pub const MAX_INBOUND_CONNECTIONS: usize = 100;
```

**File:** config/src/config/network_config.rs (L117-119)
```rust
    pub inbound_rate_limit_config: Option<RateLimitConfig>,
    /// Outbound rate limiting configuration, if not specified, no rate limiting
    pub outbound_rate_limit_config: Option<RateLimitConfig>,
```

**File:** network/framework/Cargo.toml (L1-80)
```text
[package]
name = "aptos-network"
description = "Aptos networking stack"
version = "0.1.0"

# Workspace inherited keys
authors = { workspace = true }
edition = { workspace = true }
homepage = { workspace = true }
license = { workspace = true }
publish = { workspace = true }
repository = { workspace = true }
rust-version = { workspace = true }

[dependencies]
anyhow = { workspace = true }
aptos-bitvec = { workspace = true }
aptos-channels = { workspace = true }
aptos-compression = { workspace = true }
aptos-config = { workspace = true }
aptos-crypto = { workspace = true }
aptos-id-generator = { workspace = true }
aptos-infallible = { workspace = true }
aptos-logger = { workspace = true }
aptos-memsocket = { workspace = true, optional = true }
aptos-metrics-core = { workspace = true }
aptos-netcore = { workspace = true }
aptos-num-variants = { workspace = true }
aptos-peer-monitoring-service-types = { workspace = true }
aptos-proptest-helpers = { workspace = true, optional = true }
aptos-short-hex-str = { workspace = true }
aptos-time-service = { workspace = true }
aptos-types = { workspace = true }
arc-swap = { workspace = true }
async-trait = { workspace = true }
bcs = { workspace = true }
bytes = { workspace = true }
futures = { workspace = true }
futures-util = { workspace = true }
hex = { workspace = true }
itertools = { workspace = true }
maplit = { workspace = true }
once_cell = { workspace = true }
ordered-float = { workspace = true }
pin-project = { workspace = true }
proptest = { workspace = true, optional = true }
proptest-derive = { workspace = true, optional = true }
rand = { workspace = true, features = ["small_rng"] }
# Note: we cannot rely on the workspace version of rand. So we use this workaround. See:
# https://github.com/aptos-labs/aptos-core/blob/main/state-sync/aptos-data-client/Cargo.toml#L41.
# See also https://github.com/aptos-labs/aptos-core/issues/13031
rand_latest = { package = "rand", version = "0.8.5" }
serde = { workspace = true }
serde_bytes = { workspace = true }
serde_json = { workspace = true }
thiserror = { workspace = true }
tokio = { workspace = true }
tokio-retry = { workspace = true }
tokio-stream = { workspace = true }
tokio-util = { workspace = true }

[dev-dependencies]
aptos-bitvec = { workspace = true, features = ["fuzzing"] }
aptos-config = { workspace = true, features = ["testing"] }
aptos-memsocket = { workspace = true }
aptos-netcore = { workspace = true, features = ["testing"] }
aptos-proptest-helpers = { workspace = true }
aptos-time-service = { workspace = true, features = ["testing"] }
aptos-types = { workspace = true, features = ["fuzzing"] }
proptest = { workspace = true }
proptest-derive = { workspace = true }
rand_core = { workspace = true }

[features]
default = []
fuzzing = ["aptos-bitvec/fuzzing", "aptos-config/fuzzing", "aptos-crypto/fuzzing", "aptos-types/fuzzing", "aptos-proptest-helpers", "aptos-time-service/testing", "aptos-types/fuzzing", "aptos-memsocket/testing", "aptos-netcore/fuzzing", "proptest", "proptest-derive"]
testing = ["aptos-config/testing", "aptos-time-service/testing", "aptos-memsocket/testing", "aptos-netcore/testing"]

[package.metadata.cargo-machete]
ignored = ["serde_bytes"]
```

**File:** network/framework/src/noise/stream.rs (L134-167)
```rust
                ReadState::ReadFrame {
                    frame_len,
                    ref mut offset,
                } => {
                    match ready!(poll_read_exact(
                        context,
                        Pin::new(&mut self.socket),
                        &mut self.buffers.read_buffer[..(frame_len as usize)],
                        offset
                    )) {
                        Ok(()) => {
                            match self.session.read_message_in_place(
                                &mut self.buffers.read_buffer[..(frame_len as usize)],
                            ) {
                                Ok(decrypted) => {
                                    self.read_state = ReadState::CopyDecryptedFrame {
                                        decrypted_len: decrypted.len(),
                                        offset: 0,
                                    };
                                },
                                Err(e) => {
                                    error!(error = %e, "Decryption Error: {}", e);
                                    self.read_state = ReadState::DecryptionError(e);
                                },
                            }
                        },
                        Err(e) => {
                            if e.kind() == io::ErrorKind::UnexpectedEof {
                                self.read_state = ReadState::Eof(Err(()));
                            }
                            return Poll::Ready(Err(e));
                        },
                    }
                },
```

**File:** crates/aptos-crypto/src/noise.rs (L79-80)
```rust
/// A noise message cannot be larger than 65535 bytes as per the specification.
pub const MAX_SIZE_NOISE_MSG: usize = 65535;
```

**File:** crates/aptos-crypto/src/noise.rs (L661-707)
```rust
    /// decrypts a message from the other peer (post-handshake)
    /// the function decrypts in place, and returns a subslice without the auth tag
    pub fn read_message_in_place<'a>(
        &mut self,
        message: &'a mut [u8],
    ) -> Result<&'a [u8], NoiseError> {
        // checks
        if !self.valid {
            return Err(NoiseError::SessionClosed);
        }
        if message.len() > MAX_SIZE_NOISE_MSG {
            self.valid = false;
            return Err(NoiseError::ReceivedMsgTooLarge);
        }
        if message.len() < AES_GCM_TAGLEN {
            self.valid = false;
            return Err(NoiseError::ResponseBufferTooSmall);
        }

        // decrypt in place
        let read_key = aes_key(&self.read_key[..]);

        let mut nonce = [0u8; 4].to_vec();
        nonce.extend_from_slice(&self.read_nonce.to_be_bytes());
        assert_eq!(nonce.len(), 12);
        let nonce = aead::Nonce::assume_unique_for_key(
            nonce.try_into().expect("Wrong AES256-GCM nonce length"),
        );

        read_key
            .open_in_place(nonce, aead::Aad::empty(), message)
            .map_err(|_| {
                self.valid = false;
                NoiseError::Decrypt
            })?;

        let (buffer, _authentication_tag) = message.split_at_mut(message.len() - AES_GCM_TAGLEN);

        // increment nonce
        self.read_nonce = self
            .read_nonce
            .checked_add(1)
            .ok_or(NoiseError::NonceOverflow)?;

        // return a subslice of the buffer representing the decrypted plaintext
        Ok(buffer)
    }
```

**File:** network/framework/src/peer/mod.rs (L235-270)
```rust
        let reason = loop {
            if let State::ShuttingDown(reason) = self.state {
                break reason;
            }

            futures::select! {
                // Handle a new outbound request from the PeerManager.
                maybe_request = self.peer_reqs_rx.next() => {
                    match maybe_request {
                        Some(request) => self.handle_outbound_request(request, &mut write_reqs_tx),
                        // The PeerManager is requesting this connection to close
                        // by dropping the corresponding peer_reqs_tx handle.
                        None => self.shutdown(DisconnectReason::RequestedByPeerManager),
                    }
                },
                // Handle a new inbound MultiplexMessage that we've just read off
                // the wire from the remote peer.
                maybe_message = reader.next() => {
                    match maybe_message {
                        Some(message) =>  {
                            if let Err(err) = self.handle_inbound_message(message, &mut write_reqs_tx) {
                                warn!(
                                    NetworkSchema::new(&self.network_context)
                                        .connection_metadata(&self.connection_metadata),
                                    error = %err,
                                    "{} Error in handling inbound message from peer: {}, error: {}",
                                    self.network_context,
                                    remote_peer_id.short_str(),
                                    err
                                );
                            }
                        },
                        // The socket was gracefully closed by the remote peer.
                        None => self.shutdown(DisconnectReason::ConnectionClosed),
                    }
                },
```
