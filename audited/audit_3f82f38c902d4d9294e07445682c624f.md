# Audit Report

## Title
Missing Validation of Type Builder Limits Allows Network Halt via Gas Schedule Update

## Summary
The gas schedule update mechanism lacks validation for critical VM type builder parameters (`max_ty_size` and `max_ty_depth`). A governance proposal can set these values to zero or dangerously low limits, causing complete network liveness failure by making all type operations in the Move VM immediately fail.

## Finding Description

The vulnerability exists in the interaction between the gas schedule governance system and the VM environment initialization. When `gas_feature_version >= 20` (RELEASE_V1_15), the type builder limits are derived directly from on-chain gas parameters without validation. [1](#0-0) 

The `aptos_prod_ty_builder` function uses gas parameters directly to configure type limits: [2](#0-1) 

The `TypeBuilder::check()` method enforces these limits during type construction: [3](#0-2) 

The gas schedule governance functions explicitly document missing validation with TODO comments: [4](#0-3) [5](#0-4) 

**Attack Path:**

1. A governance proposal is created setting `txn.max_ty_size = 0` and `txn.max_ty_depth = 0` in the gas schedule
2. The proposal passes validation (only checks: non-empty blob, version >= current, optional hash match) 
3. Proposal is approved and executed via `set_for_next_epoch()`
4. At next epoch transition, `on_new_epoch()` applies the new gas schedule
5. All validators create `TypeBuilder::with_limits(0, 0)`
6. Any type operation (function calls with generics, vector creation, etc.) immediately fails with `TOO_MANY_TYPE_NODES` error
7. No transactions can execute, network halts completely
8. Requires hard fork to recover with corrected gas schedule

**Broken Invariants:**
- **Move VM Safety**: Type system constraints are violated by allowing zero limits
- **Deterministic Execution**: All validators halt, unable to produce state roots
- **Resource Limits**: The VM's type size/depth enforcement becomes dysfunctional

## Impact Explanation

This is **CRITICAL severity** under Aptos bug bounty criteria:

1. **Total loss of liveness/network availability**: Setting `max_ty_size=0` or `max_ty_depth=0` causes the Move VM to reject all non-primitive types. Even basic operations like calling functions with type parameters fail. The network cannot process any transactions.

2. **Non-recoverable network partition (requires hardfork)**: The broken gas schedule is stored on-chain. Recovery requires a hard fork to:
   - Override the on-chain gas schedule with valid values
   - Potentially rollback to pre-failure state
   - Coordinate all validators to apply the fix

The vulnerability also affects defense-in-depth: even with trusted governance participants, critical safety parameters should have sanity checks to prevent accidental misconfiguration from human error or tooling bugs.

## Likelihood Explanation

**Likelihood: Medium**

While this requires governance approval, the likelihood is non-negligible because:

1. **No validation exists**: The TODO comments at three different locations confirm validation is missing and acknowledged as needed
2. **Complex parameter space**: Gas schedules contain 100+ parameters, increasing chance of typos or errors
3. **Automated tooling**: Gas schedule proposals are generated programmatically, bugs in generation tools could produce invalid values
4. **Historical precedent**: The existence of multiple TODO comments suggests this gap has persisted through multiple releases
5. **Catastrophic impact**: Even a single misconfigured proposal causes total network failure

The attack does not require malicious intentâ€”an honest mistake in proposal creation could trigger this vulnerability.

## Recommendation

Add validation in the gas schedule update functions to enforce minimum safe values for type builder parameters:

```rust
// In aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move
// Add after line 94-95:

const EINVALID_TYPE_LIMITS: u64 = 4;
const MIN_TYPE_SIZE: u64 = 64;   // Minimum safe type size limit
const MIN_TYPE_DEPTH: u64 = 10;  // Minimum safe type depth limit

// Add validation function
fun validate_gas_schedule(gas_schedule: &GasScheduleV2) {
    let i = 0;
    while (i < vector::length(&gas_schedule.entries)) {
        let entry = vector::borrow(&gas_schedule.entries, i);
        if (entry.key == string::utf8(b"txn.max_ty_size")) {
            assert!(entry.val >= MIN_TYPE_SIZE, error::invalid_argument(EINVALID_TYPE_LIMITS));
        };
        if (entry.key == string::utf8(b"txn.max_ty_depth")) {
            assert!(entry.val >= MIN_TYPE_DEPTH, error::invalid_argument(EINVALID_TYPE_LIMITS));
        };
        i = i + 1;
    };
}

// Call validate_gas_schedule() in set_for_next_epoch() after line 94
// Call validate_gas_schedule() in set_for_next_epoch_check_hash() after line 116
```

Additionally, add Rust-side validation in `aptos_prod_ty_builder`: [2](#0-1) 

Replace with:

```rust
pub fn aptos_prod_ty_builder(
    gas_feature_version: u64,
    gas_params: &AptosGasParameters,
) -> TypeBuilder {
    if gas_feature_version >= RELEASE_V1_15 {
        let max_ty_size = gas_params.vm.txn.max_ty_size;
        let max_ty_depth = gas_params.vm.txn.max_ty_depth;
        
        // Enforce minimum safe limits
        const MIN_TY_SIZE: u64 = 64;
        const MIN_TY_DEPTH: u64 = 10;
        
        if u64::from(max_ty_size) < MIN_TY_SIZE || u64::from(max_ty_depth) < MIN_TY_DEPTH {
            // Fall back to defaults if limits are dangerously low
            return aptos_default_ty_builder();
        }
        
        TypeBuilder::with_limits(max_ty_size.into(), max_ty_depth.into())
    } else {
        aptos_default_ty_builder()
    }
}
```

## Proof of Concept

```rust
// Reproduction steps in Rust:
#[test]
fn test_zero_type_limits_break_vm() {
    use move_vm_types::loaded_data::runtime_types::TypeBuilder;
    
    // Simulate malicious gas schedule with zero limits
    let broken_ty_builder = TypeBuilder::with_limits(0, 0);
    
    // Attempt to create a basic vector type
    let u64_ty = broken_ty_builder.create_u64_ty();
    let result = broken_ty_builder.create_vec_ty(&u64_ty);
    
    // This will fail with TOO_MANY_TYPE_NODES
    assert!(result.is_err());
    match result.unwrap_err().major_status() {
        StatusCode::TOO_MANY_TYPE_NODES => {
            println!("VULNERABILITY CONFIRMED: Zero type limits break VM");
        },
        _ => panic!("Unexpected error"),
    }
}
```

```move
// Move governance proposal PoC:
script {
    use aptos_framework::gas_schedule;
    use std::vector;
    
    fun malicious_gas_schedule_proposal(governance: &signer) {
        // Create gas schedule with zero type limits
        let entries = vector::empty();
        vector::push_back(&mut entries, GasEntry {
            key: b"txn.max_ty_size",
            val: 0  // DANGEROUS: Will break all type operations
        });
        vector::push_back(&mut entries, GasEntry {
            key: b"txn.max_ty_depth", 
            val: 0  // DANGEROUS: Will break all type operations
        });
        
        let bad_schedule = GasScheduleV2 {
            feature_version: 20,
            entries
        };
        
        // This would pass current validation (no value checks)
        gas_schedule::set_for_next_epoch(governance, bcs::to_bytes(&bad_schedule));
        // Network will halt at next epoch when this activates
    }
}
```

**Notes**

The vulnerability stems from incomplete implementation of gas schedule validation, as evidenced by the persistent TODO comments. While exploitation requires governance approval, the missing validation violates defense-in-depth principles for safety-critical parameters. The default type builder limits (128, 20) represent tested safe values [6](#0-5)  that should be enforced as minimum bounds for on-chain gas parameters.

### Citations

**File:** aptos-move/aptos-vm-environment/src/environment.rs (L246-265)
```rust
        let (gas_params, storage_gas_params, gas_feature_version) =
            get_gas_parameters(&mut sha3_256, &features, state_view);
        let (native_gas_params, misc_gas_params, ty_builder) = match &gas_params {
            Ok(gas_params) => {
                let ty_builder = aptos_prod_ty_builder(gas_feature_version, gas_params);
                (
                    gas_params.natives.clone(),
                    gas_params.vm.misc.clone(),
                    ty_builder,
                )
            },
            Err(_) => {
                let ty_builder = aptos_default_ty_builder();
                (
                    NativeGasParameters::zeros(),
                    MiscGasParameters::zeros(),
                    ty_builder,
                )
            },
        };
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L116-127)
```rust
pub fn aptos_prod_ty_builder(
    gas_feature_version: u64,
    gas_params: &AptosGasParameters,
) -> TypeBuilder {
    if gas_feature_version >= RELEASE_V1_15 {
        let max_ty_size = gas_params.vm.txn.max_ty_size;
        let max_ty_depth = gas_params.vm.txn.max_ty_depth;
        TypeBuilder::with_limits(max_ty_size.into(), max_ty_depth.into())
    } else {
        aptos_default_ty_builder()
    }
}
```

**File:** aptos-move/aptos-vm-environment/src/prod_configs.rs (L132-134)
```rust
pub fn aptos_default_ty_builder() -> TypeBuilder {
    TypeBuilder::with_limits(128, 20)
}
```

**File:** third_party/move/move-vm/types/src/loaded_data/runtime_types.rs (L1195-1203)
```rust
    fn check(&self, count: &mut u64, depth: u64) -> PartialVMResult<()> {
        if *count >= self.max_ty_size {
            return self.too_many_nodes_error();
        }
        if depth > self.max_ty_depth {
            return self.too_large_depth_error();
        }
        Ok(())
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L43-50)
```text
    public(friend) fun initialize(aptos_framework: &signer, gas_schedule_blob: vector<u8>) {
        system_addresses::assert_aptos_framework(aptos_framework);
        assert!(!vector::is_empty(&gas_schedule_blob), error::invalid_argument(EINVALID_GAS_SCHEDULE));

        // TODO(Gas): check if gas schedule is consistent
        let gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
        move_to<GasScheduleV2>(aptos_framework, gas_schedule);
    }
```

**File:** aptos-move/framework/aptos-framework/sources/configs/gas_schedule.move (L62-69)
```text
        if (exists<GasScheduleV2>(@aptos_framework)) {
            let gas_schedule = borrow_global_mut<GasScheduleV2>(@aptos_framework);
            let new_gas_schedule: GasScheduleV2 = from_bytes(gas_schedule_blob);
            assert!(new_gas_schedule.feature_version >= gas_schedule.feature_version,
                error::invalid_argument(EINVALID_GAS_FEATURE_VERSION));
            // TODO(Gas): check if gas schedule is consistent
            *gas_schedule = new_gas_schedule;
        }
```
