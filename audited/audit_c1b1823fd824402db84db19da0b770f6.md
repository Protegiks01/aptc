# Audit Report

## Title
Panic-Based Denial of Service in ThresholdConfigBlstrs Deserialization Due to Unhandled Integer Overflow and Missing Validation

## Summary
The `deserialize()` function for `ThresholdConfigBlstrs` uses `map_err()` to convert errors from `new()`, but fails to handle panics that can occur during evaluation domain construction. When deserializing configurations with large `n` values, integer overflow in bit shift operations or assertion failures in subdomain creation cause unrecoverable panics instead of returning serde errors, leading to validator node crashes. [1](#0-0) 

## Finding Description

The vulnerability lies in the error propagation chain when deserializing `ThresholdConfigBlstrs`. The custom `Deserialize` implementation calls `ThresholdConfigBlstrs::new()` and uses `map_err()` to convert `anyhow::Error` results into serde errors. [2](#0-1) 

However, `new()` invokes `BatchEvaluationDomain::new(n)` followed by `batch_dom.get_subdomain(n)`, neither of which return `Result` types. These functions can panic in multiple ways:

**Panic Source 1: Integer Overflow**

`BatchEvaluationDomain::new()` calls `smallest_power_of_2_greater_than_or_eq(n)` which uses left bit shifts to find the smallest power of 2 greater than or equal to `n`: [3](#0-2) 

For large values of `n` (e.g., values approaching `usize::MAX/2` or beyond certain BLS12-381 field limits), the bit shift `N <<= 1` will overflow. In debug mode, this causes an immediate panic. In release mode, it wraps around, producing incorrect values.

**Panic Source 2: Assertion Failures**

The `get_subdomain()` function contains explicit assertions that panic if violated: [4](#0-3) 

If the overflow produces a corrupted `N` value where `omegas.len() < n`, the assertion `assert_le!(k, self.omegas.len())` fails and panics.

**Missing Validation**

Critically, `EvaluationDomain::new()` includes validation to prevent excessively large domains: [5](#0-4) 

This check ensures `log_N < Scalar::S` (where `Scalar::S = 32` for BLS12-381). However, `BatchEvaluationDomain::new()` lacks this validation entirely, allowing construction with parameters that exceed cryptographic field constraints. [6](#0-5) 

**Why map_err Fails**

The `map_err()` function at line 52 of `threshold_config.rs` only converts `Result::Err` values - it cannot catch Rust panics. When a panic occurs in `BatchEvaluationDomain::new()` or `get_subdomain()`, the panic propagates up the call stack, bypassing error conversion and crashing the validator node instead of returning a deserialization error.

**Attack Vector**

The `DKGPvssConfig` struct, which contains `wconfig: WeightedConfigBlstrs` (which wraps `ThresholdConfigBlstrs`), derives both `Serialize` and `Deserialize`: [7](#0-6) 

While current code constructs these configs from validator stakes, the presence of serialization traits indicates they may be persisted or transmitted. If a malicious or corrupted configuration with `n > 2^32` is deserialized (from storage, RPC, state sync, or future network protocols), all nodes attempting deserialization will panic and crash.

## Impact Explanation

**Severity: High** 

This vulnerability enables denial of service against validator nodes. Per Aptos bug bounty criteria, "Validator node slowdowns" and "API crashes" qualify as High severity.

**Affected Components:**
- Consensus randomness generation (`RandConfig` uses `WeightedConfigBlstrs`)
- DKG (Distributed Key Generation) transcript verification
- Any component deserializing PVSS configurations

**Potential Damage:**
- Targeted validator crashes during epoch transitions
- Network-wide outages if malicious configs reach state sync or storage
- Liveness failures if sufficient validators crash simultaneously
- Potential for repeated crashes if configs are persisted

## Likelihood Explanation

**Current Likelihood: Low to Medium**

While I did not identify direct network deserialization of `DKGPvssConfig` in the examined code paths, several factors increase likelihood:

1. **Serialization Capability Present**: The structs explicitly derive `Serialize`/`Deserialize`, indicating design intent for persistence or transmission
2. **Storage Persistence Risk**: Configs may be persisted to disk and reloaded, where corruption could trigger the bug
3. **State Sync Attack Vector**: If configs are part of synchronized state, malicious nodes could propagate panic-inducing values
4. **Future Code Evolution**: New features may deserialize these configs from network input
5. **DKG Transcript Processing**: Transcripts are deserialized from validator transactions, and while they don't directly contain the config, related structures might [8](#0-7) 

## Recommendation

**Immediate Fix:**

1. Add validation to `BatchEvaluationDomain::new()` matching `EvaluationDomain::new()`:

```rust
pub fn new(n: usize) -> Result<Self, CryptoMaterialError> {
    let (N, log_N) = smallest_power_of_2_greater_than_or_eq(n);
    
    // Add validation to prevent overflow and excessive sizes
    if log_N >= Scalar::S as usize {
        return Err(CryptoMaterialError::WrongLengthError);
    }
    
    // ... rest of implementation
}
```

2. Make `get_subdomain()` return `Result` instead of using assertions:

```rust
pub fn get_subdomain(&self, k: usize) -> Result<EvaluationDomain, CryptoMaterialError> {
    if k > self.omegas.len() || k == 0 {
        return Err(CryptoMaterialError::WrongLengthError);
    }
    // ... rest of implementation
}
```

3. Update `ThresholdConfigBlstrs::new()` to propagate these errors:

```rust
fn new(t: usize, n: usize) -> anyhow::Result<Self> {
    // ... validation checks
    
    let batch_dom = BatchEvaluationDomain::new(n)
        .map_err(|e| anyhow!("Failed to create batch evaluation domain: {:?}", e))?;
    let dom = batch_dom.get_subdomain(n)
        .map_err(|e| anyhow!("Failed to create subdomain: {:?}", e))?;
    
    Ok(ThresholdConfigBlstrs { t, n, dom, batch_dom })
}
```

4. Add overflow protection to `smallest_power_of_2_greater_than_or_eq()`:

```rust
pub fn smallest_power_of_2_greater_than_or_eq(n: usize) -> (usize, usize) {
    if n == 0 {
        return (1, 0);
    }
    
    let log_N = (usize::BITS - n.leading_zeros()) as usize;
    let N = 1usize.checked_shl(log_N as u32)
        .unwrap_or(usize::MAX);
    
    if N < n {
        // Overflow occurred
        return (usize::MAX, usize::BITS as usize);
    }
    
    (N, log_N)
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod panic_poc {
    use super::*;
    use serde_json;

    #[test]
    #[should_panic(expected = "assertion failed")]
    fn test_deserialization_panic_with_large_n() {
        // Create a JSON representation with n = 2^33 (exceeds BLS12-381 limits)
        let malicious_json = r#"{"t": 1, "n": 8589934592}"#;
        
        // Attempt to deserialize - this will PANIC instead of returning Err
        let _config: ThresholdConfigBlstrs = serde_json::from_str(malicious_json)
            .expect("Should have returned error but panicked instead");
    }

    #[test]
    fn test_deserialization_should_return_error_not_panic() {
        // With proper error handling, this should return Err, not panic
        let malicious_json = r#"{"t": 1, "n": 4294967296}"#; // 2^32
        
        let result: Result<ThresholdConfigBlstrs, _> = serde_json::from_str(malicious_json);
        
        // Expected: result.is_err() == true
        // Actual: panics before reaching this assertion
        assert!(result.is_err(), "Should gracefully return error for oversized n");
    }
}
```

## Notes

This vulnerability represents a **defensive programming failure** where panic-inducing operations are used in a deserialization context without proper error boundaries. While the current code may not immediately expose this to network attackers, the combination of serialization capabilities, missing validation, and panic-based error handling creates a latent denial-of-service vulnerability that could be triggered through storage corruption, future feature additions, or undiscovered code paths.

The fix is straightforward: replace assertions and panic-inducing operations with proper `Result`-based error handling that can be caught and converted by `map_err()`.

### Citations

**File:** crates/aptos-crypto/src/blstrs/threshold_config.rs (L37-54)
```rust
impl<'de> Deserialize<'de> for ThresholdConfigBlstrs {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: Deserializer<'de>,
    {
        // Deserialize only the serializable fields (t, n)
        #[derive(Deserialize)]
        struct SerializedFields {
            t: usize,
            n: usize,
        }

        let serialized = SerializedFields::deserialize(deserializer)?;

        // Rebuild the skipped fields using `new`
        ThresholdConfigBlstrs::new(serialized.t, serialized.n).map_err(serde::de::Error::custom)
    }
}
```

**File:** crates/aptos-crypto/src/blstrs/threshold_config.rs (L109-132)
```rust
    fn new(t: usize, n: usize) -> anyhow::Result<Self> {
        if t == 0 {
            return Err(anyhow!("expected the reconstruction threshold to be > 0"));
        }

        if n == 0 {
            return Err(anyhow!("expected the number of shares to be > 0"));
        }

        if t > n {
            return Err(anyhow!(
                "expected the reconstruction threshold {t} to be < than the number of shares {n}"
            ));
        }

        let batch_dom = BatchEvaluationDomain::new(n);
        let dom = batch_dom.get_subdomain(n);
        Ok(ThresholdConfigBlstrs {
            t,
            n,
            dom,
            batch_dom,
        })
    }
```

**File:** crates/aptos-crypto/src/blstrs/evaluation_domain.rs (L48-64)
```rust
/// Returns the highest $N = 2^k$ such that $N \ge n$.
#[allow(non_snake_case)]
pub fn smallest_power_of_2_greater_than_or_eq(n: usize) -> (usize, usize) {
    let mut N = 1;
    let mut log_N: usize = 0;

    while N < n {
        N <<= 1;
        log_N += 1;
    }

    (N, log_N)
    // TODO: Replace with:
    // let N = n.next_power_of_two();
    // let log_N = N.trailing_zeros() as usize;
    // (N, log_N)
}
```

**File:** crates/aptos-crypto/src/blstrs/evaluation_domain.rs (L73-81)
```rust
    pub fn new(n: usize) -> Result<EvaluationDomain, CryptoMaterialError> {
        // Compute the size of our evaluation domain
        let (N, log_N) = smallest_power_of_2_greater_than_or_eq(n);

        // The pairing-friendly curve may not be able to support
        // large enough (radix2) evaluation domains.
        if log_N >= Scalar::S as usize {
            return Err(CryptoMaterialError::WrongLengthError);
        }
```

**File:** crates/aptos-crypto/src/blstrs/evaluation_domain.rs (L113-153)
```rust
impl BatchEvaluationDomain {
    /// Returns a batch evaluation domain for FFTs of size $1, 2, 4, 8, 16, \ldots n$, where $n$ is the
    /// number of coefficients in the polynomial $f(X) \cdot g(X)$.
    ///
    /// This then allows more efficient fetching of subdomains for any of those sizes than via
    /// `get_evaluation_dom_for_multiplication`.
    #[allow(non_snake_case)]
    pub fn new(n: usize) -> Self {
        let (N, log_N) = smallest_power_of_2_greater_than_or_eq(n);
        let omega = EvaluationDomain::get_Nth_root_of_unity(log_N);

        let mut omegas = Vec::with_capacity(N);
        omegas.push(Scalar::ONE);

        let mut acc = omega;
        for _ in 1..N {
            omegas.push(acc);
            acc *= omega; // $\omega^i$
        }

        debug_assert_eq!(omegas.len(), N);

        let mut N_inverses = Vec::with_capacity(log_N);
        let mut i = 1u64;
        for _ in 0..=log_N {
            N_inverses.push(Scalar::from(i).invert().unwrap());

            i *= 2;
        }

        debug_assert_eq!(
            N_inverses.last().unwrap().invert().unwrap(),
            Scalar::from(N as u64)
        );

        BatchEvaluationDomain {
            log_N,
            omegas,
            N_inverses,
        }
    }
```

**File:** crates/aptos-crypto/src/blstrs/evaluation_domain.rs (L163-165)
```rust
    pub fn get_subdomain(&self, k: usize) -> EvaluationDomain {
        assert_le!(k, self.omegas.len());
        assert_ne!(k, 0);
```

**File:** types/src/dkg/real_dkg/mod.rs (L43-57)
```rust
#[derive(Deserialize, Serialize, Clone, Debug)]
pub struct DKGPvssConfig {
    pub epoch: u64,
    // weighted config for randomness generation
    pub wconfig: SSConfig,
    // weighted config for randomness generation in fast path
    pub fast_wconfig: Option<SSConfig>,
    // DKG public parameters
    pub pp: DkgPP,
    // DKG encryption public keys
    pub eks: Vec<EncPK>,
    // Some metrics for caller to consume.
    #[serde(skip)]
    pub rounding_summary: RoundingSummary,
}
```

**File:** aptos-move/aptos-vm/src/validator_txns/dkg.rs (L104-109)
```rust
        // Deserialize transcript and verify it.
        let pub_params = DefaultDKG::new_public_params(&in_progress_session_state.metadata);
        let transcript = bcs::from_bytes::<<DefaultDKG as DKGTrait>::Transcript>(
            dkg_node.transcript_bytes.as_slice(),
        )
        .map_err(|_| Expected(TranscriptDeserializationFailed))?;
```
