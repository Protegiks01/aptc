# Audit Report

## Title
Missing Per-Player Dimension Validation in Chunky Weighted PVSS Transcripts Enables DKG Disruption

## Summary
The chunky weighted PVSS transcript implementation lacks explicit validation that each player's public key share vector length (`Vs[i].len()`) matches their ciphertext vector length (`Cs[i].len()`) and configured weight. This allows a malicious validator to submit a transcript with balanced total dimensions but mismatched per-player dimensions, causing honest validators to crash or produce unusable shares during DKG.

## Finding Description

The weighted PVSS (Publicly Verifiable Secret Sharing) implementation in the chunky transcript uses nested vector structures where each player receives shares proportional to their weight. The `Subtranscript` struct defines: [1](#0-0) 

During transcript verification, the code validates that the total flattened lengths match expected values: [2](#0-1) 

However, there is **no validation** that for each individual player `i`: `Vs[i].len() == Cs[i].len() == player_weight[i]`. The code only checks:
1. `Cs.len() == total_num_players` (outer array size)
2. `Vs.len() == total_num_players` (outer array size)  
3. `Cs_flat.len() == total_weight` (total ciphertexts) [3](#0-2) 

Notably, there is no check that `Vs_flat.len() == total_weight`, only a comment suggesting it should be added: [4](#0-3) 

A malicious validator can exploit this by creating a transcript where:
- Player A: `Vs[A].len() = 2`, `Cs[A].len() = 4`, weight = 3
- Player B: `Vs[B].len() = 4`, `Cs[B].len() = 2`, weight = 3
- Total: `Vs_flat.len() = 6 = Cs_flat.len() = 6 = total_weight` ✓

This transcript passes verification but causes failures during share decryption: [5](#0-4) 

The `decrypt_own_share` function has explicit TODO comments acknowledging this missing validation: [6](#0-5) 

When Player A decrypts:
- Line 347: `pk_shares = get_public_key_share()` returns `Vs[A].len() = 2` elements
- Line 349-374: Loop tries to decrypt `weight = 3` secret shares
- Line 351: Accesses `Cs[2]` → **panic** (out of bounds)

When Player B decrypts:
- Returns `(sk_shares.len() = 3, pk_shares.len() = 4)` → **dimension mismatch**

During reconstruction, the mismatch causes failures: [7](#0-6) 

The reconstruction attempts to create virtual players for each sub-share, but the assertion at line 179 will fail if dimensions don't match the configured weight: [8](#0-7) 

## Impact Explanation

**Medium Severity** - This vulnerability enables a single byzantine validator to disrupt the DKG process by causing honest validators to crash or fail during share decryption. While this doesn't directly cause loss of funds or consensus violations, it can:

1. **Prevent DKG completion**: Honest validators crash when decrypting malformed shares, blocking randomness generation
2. **Cause validator node crashes**: Index out-of-bounds panics in production code
3. **Require manual intervention**: Failed DKG sessions may need operator intervention to restart

This falls under "State inconsistencies requiring intervention" (Medium severity, up to $10,000) per the Aptos bug bounty criteria.

## Likelihood Explanation

**Medium likelihood** - While the attack requires:
- Being a validator participant in DKG (limited actors)
- Crafting a malicious transcript with balanced but mismatched dimensions
- The transcript passing aggregation checks

The lack of explicit validation combined with TODO comments indicating developers' awareness suggests this is a known gap. Byzantine validators are part of the expected threat model for DKG systems. The attack is technically feasible for any malicious validator.

## Recommendation

Add explicit per-player dimension validation in the `verify` function:

```rust
// In weighted_transcript.rs verify() function, after line 153:
for i in 0..sc.get_total_num_players() {
    let player = sc.get_player(i);
    let expected_weight = sc.get_player_weight(&player);
    
    if self.subtrs.Vs[i].len() != expected_weight {
        bail!(
            "Player {} has {} public key shares but expected {} (weight mismatch)",
            i, self.subtrs.Vs[i].len(), expected_weight
        );
    }
    
    if self.subtrs.Cs[i].len() != expected_weight {
        bail!(
            "Player {} has {} ciphertext shares but expected {} (weight mismatch)",
            i, self.subtrs.Cs[i].len(), expected_weight
        );
    }
}

// Also add explicit check for Vs_flat total:
let Vs_flat: Vec<_> = self.subtrs.Vs.iter().flatten().cloned().collect();
if Vs_flat.len() != sc.get_total_weight() {
    bail!(
        "Expected {} total public key shares, but got {}",
        sc.get_total_weight(), Vs_flat.len()
    );
}
```

Apply the same validation to `weighted_transcriptv2.rs` which has identical issues: [9](#0-8) 

## Proof of Concept

```rust
// Proof of Concept: Create malicious transcript with dimension mismatch
use aptos_dkg::pvss::chunky::weighted_transcript::*;
use aptos_crypto::weighted_config::WeightedConfigBlstrs;

#[test]
fn test_dimension_mismatch_attack() {
    let weights = vec![3, 3]; // Two players, each weight 3
    let sc = WeightedConfigBlstrs::new(4, weights).unwrap();
    
    // Create malicious transcript where:
    // Player 0: Vs[0].len() = 2, Cs[0].len() = 4  
    // Player 1: Vs[1].len() = 4, Cs[1].len() = 2
    // Total: Vs_flat.len() = 6 = Cs_flat.len() (passes total check)
    
    let mut malicious_subtrs = Subtranscript {
        V0: random_g2_point(),
        Vs: vec![
            vec![random_g2_point(); 2], // Player 0: 2 instead of 3
            vec![random_g2_point(); 4], // Player 1: 4 instead of 3  
        ],
        Cs: vec![
            vec![vec![random_g1_point(); 1]; 4], // Player 0: 4 instead of 3
            vec![vec![random_g1_point(); 1]; 2], // Player 1: 2 instead of 3
        ],
        Rs: vec![vec![random_g1_point(); 1]; 6],
    };
    
    let transcript = Transcript {
        dealer: Player { id: 0 },
        subtrs: malicious_subtrs,
        sharing_proof: // ... proof data
    };
    
    // This should fail verification but currently doesn't check per-player dimensions
    // After fix, should return error about dimension mismatch
    let result = transcript.verify(&sc, &pp, &spks, &eks, &sid);
    
    // Without fix: verification may pass, but decrypt_own_share panics
    // With fix: verification should fail with explicit error
}
```

**Notes:**

The DAS weighted protocol implementation provides a reference for proper dimension checking: [10](#0-9) 

This `check_sizes` method validates all vector dimensions match expected values and should be called during verification, not just in debug assertions during dealing.

### Citations

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L56-68)
```rust
use std::ops::{Mul, Sub};

/// Domain-separation tag (DST) used to ensure that all cryptographic hashes and
/// transcript operations within the protocol are uniquely namespaced
pub const DST: &[u8; 39] = b"APTOS_WEIGHTED_CHUNKY_FIELD_PVSS_FS_DST";

#[allow(non_snake_case)]
#[derive(Serialize, Deserialize, Clone, Debug, PartialEq, Eq)]
pub struct Transcript<E: Pairing> {
    dealer: Player,
    #[serde(serialize_with = "ark_se", deserialize_with = "ark_de")]
    /// This is the aggregatable subtranscript
    pub subtrs: Subtranscript<E>,
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L140-153)
```rust
        if self.subtrs.Cs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of chunked ciphertexts, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Cs.len()
            );
        }
        if self.subtrs.Vs.len() != sc.get_total_num_players() {
            bail!(
                "Expected {} arrays of commitment elements, but got {}",
                sc.get_total_num_players(),
                self.subtrs.Vs.len()
            );
        }
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L213-216)
```rust
        let mut Vs_flat: Vec<_> = self.subtrs.Vs.iter().flatten().cloned().collect();
        Vs_flat.push(self.subtrs.V0);
        // could add an assert_eq here with sc.get_total_weight()
        ldt.low_degree_test_group(&Vs_flat)?;
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L247-252)
```rust
        let Cs_flat: Vec<_> = self.subtrs.Cs.iter().flatten().cloned().collect();
        assert_eq!(
            Cs_flat.len(),
            sc.get_total_weight(),
            "Number of ciphertexts does not equal number of weights"
        ); // TODO what if zero weight?
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcript.rs (L318-380)
```rust
    fn decrypt_own_share(
        &self,
        sc: &Self::SecretSharingConfig,
        player: &Player,
        dk: &Self::DecryptPrivKey,
        pp: &Self::PublicParameters,
    ) -> (Self::DealtSecretKeyShare, Self::DealtPubKeyShare) {
        let weight = sc.get_player_weight(player);

        let Cs = &self.Cs[player.id];

        // TODO: put an assert here saying that len(Cs) = weight

        let ephemeral_keys: Vec<_> = self
            .Rs
            .iter()
            .take(weight)
            .map(|R_i_vec| R_i_vec.iter().map(|R_i| R_i.mul(dk.dk)).collect::<Vec<_>>())
            .collect();

        if let Some(first_key) = ephemeral_keys.first() {
            debug_assert_eq!(
                first_key.len(),
                Cs[0].len(),
                "Number of ephemeral keys does not match the number of ciphertext chunks"
            );
        }

        let mut sk_shares: Vec<Scalar<E::ScalarField>> = Vec::with_capacity(weight);
        let pk_shares = self.get_public_key_share(sc, player);

        for i in 0..weight {
            // TODO: should really put this in a separate function
            let dealt_encrypted_secret_key_share_chunks: Vec<_> = Cs[i]
                .iter()
                .zip(ephemeral_keys[i].iter())
                .map(|(C_ij, ephemeral_key)| C_ij.sub(ephemeral_key))
                .collect();

            let dealt_chunked_secret_key_share = bsgs::dlog_vec(
                pp.pp_elgamal.G.into_group(),
                &dealt_encrypted_secret_key_share_chunks,
                &pp.table,
                pp.get_dlog_range_bound(),
            )
            .expect("BSGS dlog failed");

            let dealt_chunked_secret_key_share_fr: Vec<E::ScalarField> =
                dealt_chunked_secret_key_share
                    .iter()
                    .map(|&x| E::ScalarField::from(x))
                    .collect();

            let dealt_secret_key_share =
                chunks::le_chunks_to_scalar(pp.ell, &dealt_chunked_secret_key_share_fr);

            sk_shares.push(Scalar(dealt_secret_key_share));
        }

        (
            sk_shares, pk_shares, // TODO: review this formalism... why do we need this here?
        )
    }
```

**File:** crates/aptos-crypto/src/weighted_config.rs (L177-184)
```rust
    pub fn get_virtual_player(&self, player: &Player, j: usize) -> Player {
        // println!("WeightedConfig::get_virtual_player({player}, {i})");
        assert_lt!(j, self.weights[player.id]);

        let id = self.get_share_index(player.id, j).unwrap();

        Player { id }
    }
```

**File:** crates/aptos-crypto/src/weighted_config.rs (L387-413)
```rust
    fn reconstruct(
        sc: &WeightedConfigBlstrs,
        shares: &[ShamirShare<Self::ShareValue>],
    ) -> anyhow::Result<Self> {
        let mut flattened_shares = Vec::with_capacity(sc.get_total_weight());

        // println!();
        for (player, sub_shares) in shares {
            // println!(
            //     "Flattening {} share(s) for player {player}",
            //     sub_shares.len()
            // );
            for (pos, share) in sub_shares.iter().enumerate() {
                let virtual_player = sc.get_virtual_player(player, pos);

                // println!(
                //     " + Adding share {pos} as virtual player {virtual_player}: {:?}",
                //     share
                // );
                // TODO(Performance): Avoiding the cloning here might be nice
                let tuple = (virtual_player, share.clone());
                flattened_shares.push(tuple);
            }
        }

        SK::reconstruct(sc.get_threshold_config(), &flattened_shares)
    }
```

**File:** crates/aptos-dkg/src/pvss/chunky/weighted_transcriptv2.rs (L839-841)
```rust
        let Cs = &self.subtrs.Cs[player.id];

        // TODO: put an assert here saying that len(Cs) = weight
```

**File:** crates/aptos-dkg/src/pvss/das/weighted_protocol.rs (L415-454)
```rust
    fn check_sizes(&self, sc: &WeightedConfigBlstrs) -> anyhow::Result<()> {
        let W = sc.get_total_weight();

        if self.V.len() != W + 1 {
            bail!(
                "Expected {} G_2 (polynomial) commitment elements, but got {}",
                W + 1,
                self.V.len()
            );
        }

        if self.V_hat.len() != W + 1 {
            bail!(
                "Expected {} G_2 (polynomial) commitment elements, but got {}",
                W + 1,
                self.V_hat.len()
            );
        }

        if self.R.len() != W {
            bail!(
                "Expected {} G_1 commitment(s) to ElGamal randomness, but got {}",
                W,
                self.R.len()
            );
        }

        if self.R_hat.len() != W {
            bail!(
                "Expected {} G_2 commitment(s) to ElGamal randomness, but got {}",
                W,
                self.R_hat.len()
            );
        }

        if self.C.len() != W {
            bail!("Expected C of length {}, but got {}", W, self.C.len());
        }

        Ok(())
```
