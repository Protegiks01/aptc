# Audit Report

## Title
Health Checker Allows Malicious Peers to Bypass Disconnection Through Inbound Ping Manipulation

## Summary
The health checker's `reset_peer_failures()` function is called unconditionally when receiving inbound Ping requests from peers, allowing malicious peers to reset their failure counters even when they are not responding to the local node's outbound health checks. This enables unresponsive peers to avoid automatic disconnection.

## Finding Description

The Aptos network health checker is designed to monitor peer liveness by periodically sending Ping probes and disconnecting peers that fail to respond after a configurable number of failures (`ping_failures_tolerated`). However, a critical validation flaw exists in how inbound health checks are processed. [1](#0-0) 

When the local node receives a Ping request from a remote peer in `handle_ping_request()`, it unconditionally calls `reset_peer_failures(peer_id)`. This function clears the failure counter to zero without validating whether the peer is actually responding to the local node's health checks. [2](#0-1) 

The `reset_peer_failures()` function performs no validation and simply sets the failure count to zero for the specified peer.

**Attack Scenario:**

1. **Malicious Peer B connects to Honest Node A**
2. **Node A sends periodic health check Pings to Peer B** (every `ping_interval`)
3. **Peer B ignores or fails to respond to Node A's Pings** - failure counter increments via `increment_peer_round_failure()`
4. **Simultaneously, Peer B sends its own Ping requests to Node A**
5. **Node A receives these Pings and calls `reset_peer_failures(peer_id)` for Peer B** - failure counter is reset to 0
6. **Peer B's failure count never exceeds `ping_failures_tolerated`** - Node A never disconnects from Peer B

The vulnerability is that **inbound health checks (receiving Pings) are treated as proof of peer health, independent of outbound health checks (sending Pings)**. A peer can appear "healthy" by actively sending Pings while simultaneously failing to respond to Pings it receives. [3](#0-2) 

In contrast, when handling successful outbound Ping responses in `handle_ping_response()`, the code properly validates the nonce and only resets state via `reset_peer_round_state()` after successful verification. But this protection is bypassed by the unconditional reset in `handle_ping_request()`.

## Impact Explanation

**Severity: Medium** (per Aptos Bug Bounty criteria: "State inconsistencies requiring intervention")

This vulnerability enables the following attacks:

1. **Network Health Monitoring Bypass**: Malicious peers can maintain connections to honest nodes indefinitely, even when unresponsive to health checks
2. **Resource Exhaustion**: Honest nodes maintain connections and allocate resources (memory, connection state, network bandwidth) to unresponsive peers
3. **Network Degradation**: If many peers exploit this, the network's ability to maintain healthy connections is compromised
4. **Amplification in Coordinated Attacks**: Multiple malicious peers exploiting this simultaneously could cause widespread resource exhaustion across validator nodes

While this doesn't directly compromise consensus safety or cause loss of funds, it violates the network's liveness guarantees and could be used as part of a broader attack to degrade network performance or cause partial network partitions. [4](#0-3) 

The health checker is explicitly designed to detect and disconnect from unresponsive peers to maintain network health. This vulnerability completely bypasses that protection mechanism.

## Likelihood Explanation

**Likelihood: High**

This vulnerability is highly likely to be exploited because:

1. **Low Complexity**: The attack requires only basic network peer capabilities - sending Ping messages
2. **No Special Privileges**: Any connected peer can exploit this without validator status or special permissions
3. **Easy Detection Avoidance**: The attack appears as normal health check behavior
4. **No Cost**: The attacker can send Pings at minimal resource cost
5. **Immediate Effect**: The failure counter resets immediately upon receiving a Ping

An attacker needs only to:
- Establish a connection to target nodes (standard P2P network behavior)
- Send periodic Ping messages (legitimate protocol messages)
- Ignore incoming Pings (passive non-response)

The comment in the code suggests this behavior may have been intentionally implemented but without proper security analysis: [5](#0-4) 

## Recommendation

**Fix: Separate inbound and outbound health tracking**

The health checker should track inbound and outbound health independently. A peer should only be considered healthy if it responds to the local node's health checks, regardless of whether it can send its own Pings.

**Recommended Code Changes:**

1. **Remove the unconditional reset** in `handle_ping_request()`:

```rust
fn handle_ping_request(
    &mut self,
    peer_id: PeerId,
    ping: Ping,
    protocol: ProtocolId,
    res_tx: oneshot::Sender<Result<Bytes, RpcError>>,
) {
    let message = match protocol.to_bytes(&HealthCheckerMsg::Pong(Pong(ping.0))) {
        Ok(msg) => msg,
        Err(e) => {
            warn!(...);
            return;
        },
    };
    trace!(...);
    // REMOVE: self.network_interface.reset_peer_failures(peer_id);
    // Inbound pings should NOT reset outbound health check failures
    
    let _ = res_tx.send(Ok(message.into()));
}
```

2. **Optionally track inbound health separately** if bidirectional health checking is desired:

Add separate tracking in `HealthCheckData`:
```rust
pub struct HealthCheckData {
    pub round: u64,
    pub outbound_failures: u64,  // Failures to respond to our Pings
    pub last_inbound_ping: Option<Instant>,  // Last time they pinged us
}
```

Then implement policy that considers both metrics separately rather than conflating them.

The key principle: **A peer's ability to send Pings to us does not indicate it will respond to our Pings**. These are independent properties that should be tracked separately.

## Proof of Concept

Add the following test to `network/framework/src/protocols/health_checker/test.rs`:

```rust
#[tokio::test]
async fn inbound_ping_does_not_reset_outbound_failures() {
    let ping_failures_tolerated = 3;
    let (mut harness, health_checker) = TestHarness::new_permissive(ping_failures_tolerated);

    let test = async move {
        let peer_id = PeerId::new([0x42; PeerId::LENGTH]);
        harness.send_new_peer_notification(peer_id).await;

        // Step 1: Accumulate some outbound ping failures
        for _ in 0..2 {
            harness.trigger_ping().await;
            harness.expect_ping_send_not_ok().await;
        }

        // Step 2: Malicious peer sends inbound ping (attempting to reset failures)
        let res_rx = harness.send_inbound_ping(peer_id, 123).await;
        expect_pong(res_rx).await;

        // Step 3: Continue failing outbound pings
        // With the bug: failure counter was reset to 0, so we can fail 4 more times
        // Without the bug: failure counter is still at 2, so 2 more failures trigger disconnect
        for _ in 0..2 {
            harness.trigger_ping().await;
            harness.expect_ping_send_not_ok().await;
        }

        // Expected: Peer should be disconnected after total of 4 outbound failures
        // Actual (with bug): Peer is NOT disconnected because counter was reset by inbound ping
        harness.expect_disconnect(peer_id).await;
    };
    future::join(health_checker.start(), test).await;
}
```

This test demonstrates that a peer can avoid disconnection by sending inbound Pings while failing to respond to outbound Pings. With the current implementation, the test would **fail** (timeout waiting for disconnect) because the inbound Ping resets the failure counter. After applying the fix, the test should **pass** because outbound failures are tracked independently.

## Notes

- The comment "Record Ingress HC here and reset failures" suggests this may have been an intentional design decision, possibly inspired by the TODO comment about "Use successful inbound pings as a sign of remote note being healthy"
- However, treating inbound Pings as proof of health creates this security vulnerability
- The bidirectional health checking approach requires more careful design - both peers should succeed at responding to each other's Pings, not just be able to send Pings
- This vulnerability affects all network types (Validator, VFN, PFN) since they all use the same health checker implementation

### Citations

**File:** network/framework/src/protocols/health_checker/mod.rs (L106-109)
```rust
    /// Number of successive ping failures we tolerate before declaring a node as unhealthy and
    /// disconnecting from it. In the future, this can be replaced with a more general failure
    /// detection policy.
    ping_failures_tolerated: u64,
```

**File:** network/framework/src/protocols/health_checker/mod.rs (L277-306)
```rust
    fn handle_ping_request(
        &mut self,
        peer_id: PeerId,
        ping: Ping,
        protocol: ProtocolId,
        res_tx: oneshot::Sender<Result<Bytes, RpcError>>,
    ) {
        let message = match protocol.to_bytes(&HealthCheckerMsg::Pong(Pong(ping.0))) {
            Ok(msg) => msg,
            Err(e) => {
                warn!(
                    NetworkSchema::new(&self.network_context),
                    error = ?e,
                    "{} Unable to serialize pong response: {}", self.network_context, e
                );
                return;
            },
        };
        trace!(
            NetworkSchema::new(&self.network_context).remote_peer(&peer_id),
            "{} Sending Pong response to peer: {} with nonce: {}",
            self.network_context,
            peer_id.short_str(),
            ping.0,
        );
        // Record Ingress HC here and reset failures.
        self.network_interface.reset_peer_failures(peer_id);

        let _ = res_tx.send(Ok(message.into()));
    }
```

**File:** network/framework/src/protocols/health_checker/mod.rs (L308-395)
```rust
    async fn handle_ping_response(
        &mut self,
        peer_id: PeerId,
        round: u64,
        req_nonce: u32,
        ping_result: Result<Pong, RpcError>,
    ) {
        match ping_result {
            Ok(pong) => {
                if pong.0 == req_nonce {
                    trace!(
                        NetworkSchema::new(&self.network_context).remote_peer(&peer_id),
                        rount = round,
                        "{} Ping successful for peer: {} round: {}",
                        self.network_context,
                        peer_id.short_str(),
                        round
                    );
                    // Update last successful ping to current round.
                    // If it's not in storage, don't bother updating it
                    self.network_interface
                        .reset_peer_round_state(peer_id, round);
                } else {
                    warn!(
                        SecurityEvent::InvalidHealthCheckerMsg,
                        NetworkSchema::new(&self.network_context).remote_peer(&peer_id),
                        "{} Pong nonce doesn't match Ping nonce. Round: {}, Pong: {}, Ping: {}",
                        self.network_context,
                        round,
                        pong.0,
                        req_nonce
                    );
                    debug_assert!(false, "Pong nonce doesn't match our challenge Ping nonce");
                }
            },
            Err(err) => {
                warn!(
                    NetworkSchema::new(&self.network_context).remote_peer(&peer_id),
                    round = round,
                    "{} Ping failed for peer: {} round: {} with error: {:#}",
                    self.network_context,
                    peer_id.short_str(),
                    round,
                    err
                );
                self.network_interface
                    .increment_peer_round_failure(peer_id, round);

                // If the ping failures are now more than
                // `self.ping_failures_tolerated`, we disconnect from the node.
                // The HealthChecker only performs the disconnect. It relies on
                // ConnectivityManager or the remote peer to re-establish the connection.
                let failures = self
                    .network_interface
                    .get_peer_failures(peer_id)
                    .unwrap_or(0);
                if failures > self.ping_failures_tolerated {
                    info!(
                        NetworkSchema::new(&self.network_context).remote_peer(&peer_id),
                        "{} Disconnecting from peer: {}",
                        self.network_context,
                        peer_id.short_str()
                    );
                    let peer_network_id =
                        PeerNetworkId::new(self.network_context.network_id(), peer_id);
                    if let Err(err) = timeout(
                        Duration::from_millis(50),
                        self.network_interface.disconnect_peer(
                            peer_network_id,
                            DisconnectReason::NetworkHealthCheckFailure,
                        ),
                    )
                    .await
                    {
                        warn!(
                            NetworkSchema::new(&self.network_context)
                                .remote_peer(&peer_id),
                            error = ?err,
                            "{} Failed to disconnect from peer: {} with error: {:?}",
                            self.network_context,
                            peer_id.short_str(),
                            err
                        );
                    }
                }
            },
        }
    }
```

**File:** network/framework/src/protocols/health_checker/interface.rs (L118-124)
```rust
    /// Resets the number of peer failures for the given peer.
    /// If the peer is not found, nothing is done.
    pub fn reset_peer_failures(&mut self, peer_id: PeerId) {
        if let Some(health_check_data) = self.health_check_data.write().get_mut(&peer_id) {
            health_check_data.failures = 0;
        }
    }
```
