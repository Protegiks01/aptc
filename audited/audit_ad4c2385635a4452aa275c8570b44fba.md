# Audit Report

## Title
Peer Monitoring Service Deserialization Errors Bypass Application-Level Metrics

## Summary
The peer monitoring service's `PEER_MONITORING_ERRORS_ENCOUNTERED` metric only tracks errors that occur after successful message deserialization. Malformed messages that fail BCS deserialization at the network layer are silently dropped without incrementing this counter, creating a monitoring blind spot for attacks targeting the peer monitoring service.

## Finding Description

The peer monitoring service defines an error counter to track operational issues: [1](#0-0) 

This counter is only incremented when errors occur during request processing in the handler: [2](#0-1) 

However, messages must first be deserialized at the network layer before reaching the handler. When deserialization fails, the network layer logs the error but returns `None`, causing the message to be filtered out: [3](#0-2) 

The filtered messages never reach the peer monitoring service handler, so the `PEER_MONITORING_ERRORS_ENCOUNTERED` counter is never incremented. Additionally, there is an `INVALID_NETWORK_MESSAGES` counter defined at the network layer: [4](#0-3) 

But this counter is never actually used anywhere in the codebase—deserialization failures are only logged, not metricated.

**Attack Flow:**
1. Attacker sends malformed messages with invalid BCS encoding to peer monitoring service endpoints
2. Network layer attempts deserialization using `ProtocolId::from_bytes()` [5](#0-4) 
3. Deserialization fails and returns `Err`
4. Error is logged as `SecurityEvent::InvalidNetworkEvent` but no metrics are incremented
5. Message is filtered out via `filter_map` returning `None`
6. Peer monitoring service never sees the request
7. `PEER_MONITORING_ERRORS_ENCOUNTERED` remains unchanged

## Impact Explanation

**Severity Assessment: Low (Not Medium)**

While this creates a monitoring gap, it does not meet the Medium severity criteria:
- **Not "Limited funds loss or manipulation"**: No financial impact
- **Not "State inconsistencies requiring intervention"**: No blockchain state affected

This is a **Low severity observability issue** because:
- Attacks are still logged (though logs may not be actively monitored)
- No direct impact on consensus, funds, or validator operations
- Does not enable bypass of any security controls
- Network-level DoS attacks are explicitly out of scope per bug bounty rules

The monitoring gap could make it harder to detect reconnaissance or probe attempts, but the actual security impact is minimal as the peer monitoring service is a non-critical auxiliary service for network diagnostics.

## Likelihood Explanation

**High likelihood** of occurrence:
- Zero complexity to exploit—simply send malformed BCS data
- No authentication or special privileges required
- Any network peer can send RPC requests
- Natural occurrence through network errors or buggy clients

## Recommendation

Implement proper metrics tracking at the appropriate layer:

1. **Option A - Network Layer Tracking**: Actually use the defined `INVALID_NETWORK_MESSAGES` counter in `request_to_network_event()` when deserialization fails

2. **Option B - Application Layer Tracking**: Add a counter in the peer monitoring service that tracks total inbound RPC requests (before deserialization) and compare against successfully processed requests to detect anomalies

3. **Option C - Comprehensive Monitoring**: Implement both network-level deserialization error tracking AND application-level request accounting for complete observability

## Proof of Concept

```rust
// Test demonstrating the monitoring bypass
#[tokio::test]
async fn test_malformed_message_bypasses_monitoring() {
    // Setup peer monitoring service with metrics
    let (mut network_sender, network_receiver) = /* setup network */;
    let peer_monitoring_server = PeerMonitoringServiceServer::new(/* config */);
    
    // Get initial error count
    let initial_errors = PEER_MONITORING_ERRORS_ENCOUNTERED
        .with_label_values(&["validator", "test_error"])
        .get();
    
    // Send malformed BCS message (invalid encoding)
    let malformed_bytes = vec![0xFF, 0xFF, 0xFF, 0xFF]; // Invalid BCS
    network_sender.send_rpc_request(
        peer_id,
        ProtocolId::PeerMonitoringServiceRpc,
        malformed_bytes,
    ).await;
    
    // Wait for processing
    tokio::time::sleep(Duration::from_millis(100)).await;
    
    // Check that error counter was NOT incremented
    let final_errors = PEER_MONITORING_ERRORS_ENCOUNTERED
        .with_label_values(&["validator", "test_error"])
        .get();
    
    assert_eq!(initial_errors, final_errors, 
        "Deserialization errors should bypass peer monitoring metrics");
}
```

---

**Notes:**

This is a legitimate observability gap in the codebase, but it falls below the Medium severity threshold required for bug bounty consideration. The peer monitoring service is a diagnostic/observability service rather than a critical consensus or execution component, and the monitoring bypass does not enable any direct attacks on validator security, funds, or blockchain integrity.

### Citations

**File:** peer-monitoring-service/server/src/metrics.rs (L21-28)
```rust
pub static PEER_MONITORING_ERRORS_ENCOUNTERED: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "aptos_peer_monitoring_service_server_errors",
        "Counters related to the peer monitoring server errors encountered",
        &["network_id", "error_type"]
    )
    .unwrap()
});
```

**File:** peer-monitoring-service/server/src/lib.rs (L186-192)
```rust
            Err(error) => {
                // Log the error and update the counters
                increment_counter(
                    &metrics::PEER_MONITORING_ERRORS_ENCOUNTERED,
                    network_id,
                    error.get_label(),
                );
```

**File:** network/framework/src/protocols/network/mod.rs (L303-321)
```rust
fn request_to_network_event<TMessage: Message, Request: IncomingRequest>(
    peer_id: PeerId,
    request: &Request,
) -> Option<TMessage> {
    match request.to_message() {
        Ok(msg) => Some(msg),
        Err(err) => {
            let data = request.data();
            warn!(
                SecurityEvent::InvalidNetworkEvent,
                error = ?err,
                remote_peer_id = peer_id.short_str(),
                protocol_id = request.protocol_id(),
                data_prefix = hex::encode(&data[..min(16, data.len())]),
            );
            None
        },
    }
}
```

**File:** network/framework/src/counters.rs (L259-266)
```rust
pub static INVALID_NETWORK_MESSAGES: Lazy<IntCounterVec> = Lazy::new(|| {
    register_int_counter_vec!(
        "aptos_network_invalid_messages",
        "Number of invalid messages (RPC/direct_send)",
        &["role_type", "network_id", "peer_id", "type"]
    )
    .unwrap()
});
```

**File:** network/framework/src/protocols/wire/handshake/v1/mod.rs (L226-252)
```rust
    pub fn from_bytes<T: DeserializeOwned>(&self, bytes: &[u8]) -> anyhow::Result<T> {
        // Start the deserialization timer
        let deserialization_timer = start_serialization_timer(*self, DESERIALIZATION_LABEL);

        // Deserialize the message
        let result = match self.encoding() {
            Encoding::Bcs(limit) => self.bcs_decode(bytes, limit),
            Encoding::CompressedBcs(limit) => {
                let compression_client = self.get_compression_client();
                let raw_bytes = aptos_compression::decompress(
                    &bytes.to_vec(),
                    compression_client,
                    MAX_APPLICATION_MESSAGE_SIZE,
                )
                .map_err(|e| anyhow! {"{:?}", e})?;
                self.bcs_decode(&raw_bytes, limit)
            },
            Encoding::Json => serde_json::from_slice(bytes).map_err(|e| anyhow!("{:?}", e)),
        };

        // Only record the duration if deserialization was successful
        if result.is_ok() {
            deserialization_timer.observe_duration();
        }

        result
    }
```
