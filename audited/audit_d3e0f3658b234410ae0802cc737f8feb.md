# Audit Report

## Title
Malformed JWKs Can Be Certified and Stored On-Chain in Per-Issuer Mode, Causing Keyless Authentication DoS

## Summary
In per-issuer mode, the JWK consensus mechanism fails to validate JWK deserialization before certification and on-chain storage. Malformed `JWKMoveStruct` objects with invalid `MoveAny` data can be quorum-certified and permanently stored on-chain, only failing when users attempt keyless authentication. This creates a persistent denial-of-service condition for affected identity providers until governance intervention.

## Finding Description
The vulnerability exists in the validation gap between JWK certification and usage in per-issuer consensus mode:

**Certification Path (No Validation):** [1](#0-0) 

In per-issuer mode, `new_rb_request` only extracts the issuer from the payload without validating the JWK contents. [2](#0-1) 

The `start_produce` function creates a reliable broadcast request and aggregates signatures, but never attempts to deserialize the JWKs. [3](#0-2) 

During signature aggregation, only equality checks and signature verification occurâ€”no JWK deserialization validation. [4](#0-3) 

When processing the validator transaction, only version, voting power, and multi-signature are validated. The JWK contents remain unchecked. [5](#0-4) 

In per-issuer mode (lines 496-499), `upsert_into_observed_jwks` directly stores the `ProviderJWKs` without unpacking or validating individual JWKs.

**Failure Point (Authentication):** [6](#0-5) 

JWK deserialization is only attempted during authentication at line 128-129, where `JWK::try_from(jwk_move_struct)` can fail with "Could not unpack Any in JWK Move struct". [7](#0-6) 

The conversion fails if the `MoveAny` contains invalid BCS data or an unknown type variant. [8](#0-7) 

`MoveAny::unpack` can fail with BCS deserialization errors or type mismatches.

**Contrast with Per-Key Mode:** [9](#0-8) 

Per-key mode validates JWKs in `new_rb_request` by calling `try_from_issuer_level_repr`. [10](#0-9) 

This performs JWK conversion at line 365-366, catching malformed JWKs before certification.

## Impact Explanation
**High Severity** - This qualifies as "Significant protocol violations" per the bug bounty program:

1. **Denial of Service**: All keyless authentication attempts for the affected issuer/KID fail permanently
2. **User Impact**: All users relying on that identity provider cannot authenticate
3. **Persistence**: The malformed JWKs remain on-chain until governance removes them via patches
4. **Critical Infrastructure**: Could affect major OIDC providers (Google, Facebook, etc.)
5. **No Self-Healing**: Unlike temporary network issues, this requires manual governance intervention

The vulnerability breaks the **Deterministic Execution** invariant, as authentication outcomes differ from the expected behavior, and creates a **State Consistency** issue where on-chain data is unusable.

## Likelihood Explanation
**Medium-to-High Likelihood:**

**Attack Vectors:**
1. **Compromised OIDC Provider**: If an OIDC provider's JWK endpoint returns malformed JSON that passes serde_json parsing but creates invalid `MoveAny` data, all validators would observe and certify the same malformed data
2. **Malicious Validator**: A validator with modified consensus code could craft malformed `JWKMoveStruct` objects

**Feasibility:**
- Requires quorum agreement, but this is natural if the malformed data originates from the OIDC provider that all validators fetch from
- No special privileges required if exploiting a compromised OIDC endpoint
- The per-issuer mode is actively used in production

**Detection Difficulty:**
- The malformed JWKs pass all pre-certification checks
- Only discovered when users attempt authentication
- By then, the damage is done (data is on-chain)

## Recommendation
Implement mandatory JWK deserialization validation before certification in per-issuer mode:

```rust
// In crates/aptos-jwk-consensus/src/mode/per_issuer.rs
fn new_rb_request(epoch: u64, payload: &ProviderJWKs) -> anyhow::Result<ObservedUpdateRequest> {
    // Validate all JWKs can be deserialized
    for jwk_move in &payload.jwks {
        JWK::try_from(jwk_move)
            .context("new_rb_request failed: invalid JWK in payload")?;
    }
    
    Ok(ObservedUpdateRequest {
        epoch,
        issuer: payload.issuer.clone(),
    })
}
```

Alternatively, add validation in `start_produce`:

```rust
// In crates/aptos-jwk-consensus/src/update_certifier.rs
fn start_produce(...) -> anyhow::Result<AbortHandle> {
    ConsensusMode::log_certify_start(epoch_state.epoch, &payload);
    
    // Validate payload JWKs before broadcasting
    payload.indexed()
        .context("start_produce failed: payload contains invalid JWKs")?;
    
    // ... rest of function
}
```

## Proof of Concept

```rust
#[cfg(test)]
mod jwk_malformed_payload_test {
    use aptos_types::jwks::{ProviderJWKs, jwk::JWKMoveStruct};
    use aptos_types::move_any::Any as MoveAny;
    
    #[test]
    fn test_malformed_jwk_bypasses_certification() {
        // Create a JWKMoveStruct with valid type_name but corrupted data
        let malformed_jwk = JWKMoveStruct {
            variant: MoveAny {
                type_name: "0x1::jwks::RSA_JWK".to_string(),
                data: vec![0xFF, 0xFF, 0xFF], // Invalid BCS data
            }
        };
        
        let payload = ProviderJWKs {
            issuer: b"https://malicious.example.com".to_vec(),
            version: 1,
            jwks: vec![malformed_jwk],
        };
        
        // This should fail in per-issuer mode's new_rb_request but currently doesn't
        // The malformed payload would be certified and stored on-chain
        // Only failing later during authentication when JWK::try_from is called
        
        use aptos_types::jwks::jwk::JWK;
        let result = JWK::try_from(&payload.jwks[0]);
        assert!(result.is_err()); // Proves deserialization fails
        
        // In per-issuer mode, this check never happens before certification
    }
}
```

**Move Test Scenario:**
```move
#[test(framework = @aptos_framework)]
fun test_malformed_jwk_storage(framework: &signer) {
    // Scenario: Malformed JWK gets stored via validator transaction
    // Later, authentication attempts fail with deserialization error
    // This leaves the keyless authentication system in a broken state
    // requiring governance intervention to patch/remove the malformed JWK
}
```

## Notes
This vulnerability is specific to **per-issuer mode** only. Per-key mode performs validation in `new_rb_request` via `KeyLevelUpdate::try_from_issuer_level_repr`, which catches deserialization failures before certification. The fix should align per-issuer mode with per-key mode's validation strategy to maintain consistency and prevent malformed data from reaching on-chain storage.

### Citations

**File:** crates/aptos-jwk-consensus/src/mode/per_issuer.rs (L23-28)
```rust
    fn new_rb_request(epoch: u64, payload: &ProviderJWKs) -> anyhow::Result<ObservedUpdateRequest> {
        Ok(ObservedUpdateRequest {
            epoch,
            issuer: payload.issuer.clone(),
        })
    }
```

**File:** crates/aptos-jwk-consensus/src/update_certifier.rs (L49-83)
```rust
    fn start_produce(
        &self,
        epoch_state: Arc<EpochState>,
        payload: ProviderJWKs,
        qc_update_tx: aptos_channel::Sender<
            ConsensusMode::ConsensusSessionKey,
            QuorumCertifiedUpdate,
        >,
    ) -> anyhow::Result<AbortHandle> {
        ConsensusMode::log_certify_start(epoch_state.epoch, &payload);
        let rb = self.reliable_broadcast.clone();
        let epoch = epoch_state.epoch;
        let req = ConsensusMode::new_rb_request(epoch, &payload)
            .context("UpdateCertifier::start_produce failed at rb request construction")?;
        let agg_state = Arc::new(ObservationAggregationState::<ConsensusMode>::new(
            epoch_state,
            payload,
        ));
        let task = async move {
            let qc_update = rb.broadcast(req, agg_state).await.expect("cannot fail");
            ConsensusMode::log_certify_done(epoch, &qc_update);
            let session_key = ConsensusMode::session_key_from_qc(&qc_update);
            match session_key {
                Ok(key) => {
                    let _ = qc_update_tx.push(key, qc_update);
                },
                Err(e) => {
                    error!("JWK update QCed but could not identify the session key: {e}");
                },
            }
        };
        let (abort_handle, abort_registration) = AbortHandle::new_pair();
        tokio::spawn(Abortable::new(task, abort_registration));
        Ok(abort_handle)
    }
```

**File:** crates/aptos-jwk-consensus/src/observation_aggregation/mod.rs (L49-124)
```rust
    fn add(
        &self,
        sender: Author,
        response: Self::Response,
    ) -> anyhow::Result<Option<Self::Aggregated>> {
        let ObservedUpdateResponse { epoch, update } = response;
        let ObservedUpdate {
            author,
            observed: peer_view,
            signature,
        } = update;
        ensure!(
            epoch == self.epoch_state.epoch,
            "adding peer observation failed with invalid epoch",
        );
        ensure!(
            author == sender,
            "adding peer observation failed with mismatched author",
        );

        let peer_power = self.epoch_state.verifier.get_voting_power(&author);
        ensure!(
            peer_power.is_some(),
            "adding peer observation failed with illegal signer"
        );
        let peer_power = peer_power.unwrap();

        let mut partial_sigs = self.inner_state.lock();
        if partial_sigs.contains_voter(&sender) {
            return Ok(None);
        }

        ensure!(
            self.local_view == peer_view,
            "adding peer observation failed with mismatched view"
        );

        // Verify peer signature.
        self.epoch_state
            .verifier
            .verify(sender, &peer_view, &signature)?;

        // All checks passed. Aggregating.
        partial_sigs.add_signature(sender, signature);
        let voters: BTreeSet<AccountAddress> = partial_sigs.signatures().keys().copied().collect();
        let power_check_result = self
            .epoch_state
            .verifier
            .check_voting_power(voters.iter(), true);
        let new_total_power = match &power_check_result {
            Ok(x) => Some(*x),
            Err(VerifyError::TooLittleVotingPower { voting_power, .. }) => Some(*voting_power),
            _ => None,
        };

        info!(
            epoch = self.epoch_state.epoch,
            peer = sender,
            issuer = String::from_utf8(self.local_view.issuer.clone()).ok(),
            peer_power = peer_power,
            new_total_power = new_total_power,
            threshold = self.epoch_state.verifier.quorum_voting_power(),
            threshold_exceeded = power_check_result.is_ok(),
            "Peer vote aggregated."
        );

        if power_check_result.is_err() {
            return Ok(None);
        }
        let multi_sig = self.epoch_state.verifier.aggregate_signatures(partial_sigs.signatures_iter()).map_err(|e|anyhow!("adding peer observation failed with partial-to-aggregated conversion error: {e}"))?;

        Ok(Some(QuorumCertifiedUpdate {
            update: peer_view,
            multi_sig,
        }))
    }
```

**File:** aptos-move/aptos-vm/src/validator_txns/jwk.rs (L100-179)
```rust
    fn process_jwk_update_inner(
        &self,
        resolver: &impl AptosMoveResolver,
        module_storage: &impl AptosModuleStorage,
        log_context: &AdapterLogSchema,
        session_id: SessionId,
        update: jwks::QuorumCertifiedUpdate,
    ) -> Result<(VMStatus, VMOutput), ExecutionFailure> {
        // Load resources.
        let validator_set =
            ValidatorSet::fetch_config(resolver).ok_or(Expected(MissingResourceValidatorSet))?;
        let observed_jwks =
            ObservedJWKs::fetch_config(resolver).ok_or(Expected(MissingResourceObservedJWKs))?;

        let mut jwks_by_issuer: HashMap<Issuer, ProviderJWKs> =
            observed_jwks.into_providers_jwks().into();
        let issuer = update.update.issuer.clone();
        let on_chain = jwks_by_issuer
            .entry(issuer.clone())
            .or_insert_with(|| ProviderJWKs::new(issuer));
        let verifier = ValidatorVerifier::from(&validator_set);

        let QuorumCertifiedUpdate {
            update: observed,
            multi_sig,
        } = update;

        // Check version.
        if on_chain.version + 1 != observed.version {
            return Err(Expected(IncorrectVersion));
        }

        let authors = multi_sig.get_signers_addresses(&verifier.get_ordered_account_addresses());

        // Check voting power.
        verifier
            .check_voting_power(authors.iter(), true)
            .map_err(|_| Expected(NotEnoughVotingPower))?;

        // Verify multi-sig.
        verifier
            .verify_multi_signatures(&observed, &multi_sig)
            .map_err(|_| Expected(MultiSigVerificationFailed))?;

        // All verification passed. Apply the `observed`.
        let mut gas_meter = UnmeteredGasMeter;
        let mut session = self.new_session(resolver, session_id, None);
        let args = vec![
            MoveValue::Signer(AccountAddress::ONE),
            vec![observed].as_move_value(),
        ];

        let traversal_storage = TraversalStorage::new();
        session
            .execute_function_bypass_visibility(
                &JWKS_MODULE,
                UPSERT_INTO_OBSERVED_JWKS,
                vec![],
                serialize_values(&args),
                &mut gas_meter,
                &mut TraversalContext::new(&traversal_storage),
                module_storage,
            )
            .map_err(|e| {
                expect_only_successful_execution(e, UPSERT_INTO_OBSERVED_JWKS.as_str(), log_context)
            })
            .map_err(|r| Unexpected(r.unwrap_err()))?;

        let output = get_system_transaction_output(
            session,
            module_storage,
            &self
                .storage_gas_params(log_context)
                .map_err(Unexpected)?
                .change_set_configs,
        )
        .map_err(Unexpected)?;

        Ok((VMStatus::Executed, output))
    }
```

**File:** aptos-move/framework/aptos-framework/sources/jwks.move (L462-505)
```text
    public fun upsert_into_observed_jwks(fx: &signer, provider_jwks_vec: vector<ProviderJWKs>) acquires ObservedJWKs, PatchedJWKs, Patches {
        system_addresses::assert_aptos_framework(fx);
        let observed_jwks = borrow_global_mut<ObservedJWKs>(@aptos_framework);

        if (features::is_jwk_consensus_per_key_mode_enabled()) {
            vector::for_each(provider_jwks_vec, |proposed_provider_jwks|{
                let maybe_cur_issuer_jwks = remove_issuer(&mut observed_jwks.jwks, proposed_provider_jwks.issuer);
                let cur_issuer_jwks = if (option::is_some(&maybe_cur_issuer_jwks)) {
                    option::extract(&mut maybe_cur_issuer_jwks)
                } else {
                    ProviderJWKs {
                        issuer: proposed_provider_jwks.issuer,
                        version: 0,
                        jwks: vector[],
                    }
                };
                assert!(cur_issuer_jwks.version + 1 == proposed_provider_jwks.version, error::invalid_argument(EUNEXPECTED_VERSION));
                vector::for_each(proposed_provider_jwks.jwks, |jwk|{
                    let variant_type_name = *string::bytes(copyable_any::type_name(&jwk.variant));
                    let is_delete = if (variant_type_name == b"0x1::jwks::UnsupportedJWK") {
                        let repr = copyable_any::unpack<UnsupportedJWK>(jwk.variant);
                        &repr.payload == &DELETE_COMMAND_INDICATOR
                    } else {
                        false
                    };
                    if (is_delete) {
                        remove_jwk(&mut cur_issuer_jwks, get_jwk_id(&jwk));
                    } else {
                        upsert_jwk(&mut cur_issuer_jwks, jwk);
                    }
                });
                cur_issuer_jwks.version = cur_issuer_jwks.version + 1;
                upsert_provider_jwks(&mut observed_jwks.jwks, cur_issuer_jwks);
            });
        } else {
            vector::for_each(provider_jwks_vec, |provider_jwks| {
                upsert_provider_jwks(&mut observed_jwks.jwks, provider_jwks);
            });
        };

        let epoch = reconfiguration::current_epoch();
        emit(ObservedJWKsUpdated { epoch, jwks: observed_jwks.jwks });
        regenerate_patched_jwks();
    }
```

**File:** aptos-move/aptos-vm/src/keyless_validation.rs (L112-150)
```rust
fn get_jwk_for_authenticator(
    jwks: &AllProvidersJWKs,
    pk: &KeylessPublicKey,
    sig: &KeylessSignature,
) -> Result<JWK, VMStatus> {
    let jwt_header = sig
        .parse_jwt_header()
        .map_err(|_| invalid_signature!("Failed to parse JWT header"))?;

    let jwk_move_struct = jwks.get_jwk(&pk.iss_val, &jwt_header.kid).map_err(|_| {
        invalid_signature!(format!(
            "JWK for {} with KID {} was not found",
            pk.iss_val, jwt_header.kid
        ))
    })?;

    let jwk = JWK::try_from(jwk_move_struct)
        .map_err(|_| invalid_signature!("Could not unpack Any in JWK Move struct"))?;

    match &jwk {
        JWK::RSA(rsa_jwk) => {
            if rsa_jwk.alg != jwt_header.alg {
                return Err(invalid_signature!(format!(
                    "JWK alg ({}) does not match JWT header's alg ({})",
                    rsa_jwk.alg, jwt_header.alg
                )));
            }
        },
        JWK::Unsupported(jwk) => {
            return Err(invalid_signature!(format!(
                "JWK with KID {} and hex-encoded payload {} is not supported",
                jwt_header.kid,
                hex::encode(&jwk.payload)
            )))
        },
    }

    Ok(jwk)
}
```

**File:** types/src/jwks/jwk/mod.rs (L102-122)
```rust
impl TryFrom<&JWKMoveStruct> for JWK {
    type Error = anyhow::Error;

    fn try_from(value: &JWKMoveStruct) -> Result<Self, Self::Error> {
        match value.variant.type_name.as_str() {
            RSA_JWK::MOVE_TYPE_NAME => {
                let rsa_jwk =
                    MoveAny::unpack(RSA_JWK::MOVE_TYPE_NAME, value.variant.clone()).map_err(|e|anyhow!("converting from jwk move struct to jwk failed with move any to rsa unpacking error: {e}"))?;
                Ok(Self::RSA(rsa_jwk))
            },
            UnsupportedJWK::MOVE_TYPE_NAME => {
                let unsupported_jwk =
                    MoveAny::unpack(UnsupportedJWK::MOVE_TYPE_NAME, value.variant.clone()).map_err(|e|anyhow!("converting from jwk move struct to jwk failed with move any to unsupported unpacking error: {e}"))?;
                Ok(Self::Unsupported(unsupported_jwk))
            },
            _ => Err(anyhow!(
                "converting from jwk move struct to jwk failed with unknown variant"
            )),
        }
    }
}
```

**File:** types/src/move_any.rs (L25-33)
```rust
    pub fn unpack<T: DeserializeOwned>(move_name: &str, x: Any) -> anyhow::Result<T> {
        let Any { type_name, data } = x;
        if type_name == move_name {
            let y = bcs::from_bytes::<T>(&data)?;
            Ok(y)
        } else {
            bail!("type mismatch")
        }
    }
```

**File:** crates/aptos-jwk-consensus/src/mode/per_key.rs (L32-40)
```rust
    fn new_rb_request(
        epoch: u64,
        payload: &ProviderJWKs,
    ) -> anyhow::Result<ObservedKeyLevelUpdateRequest> {
        let KeyLevelUpdate { issuer, kid, .. } =
            KeyLevelUpdate::try_from_issuer_level_repr(payload)
                .context("new_rb_request failed with repr translation")?;
        Ok(ObservedKeyLevelUpdateRequest { epoch, issuer, kid })
    }
```

**File:** types/src/jwks/mod.rs (L360-384)
```rust
    pub fn try_from_issuer_level_repr(repr: &ProviderJWKs) -> anyhow::Result<Self> {
        ensure!(
            repr.jwks.len() == 1,
            "wrapped repr of a key-level update should have exactly 1 jwk"
        );
        let jwk =
            JWK::try_from(&repr.jwks[0]).context("try_from_issuer_level_repr failed on JWK")?;
        let base_version = repr
            .version
            .checked_sub(1)
            .context("try_from_issuer_level_repr on version")?;
        Ok(Self {
            issuer: repr.issuer.clone(),
            base_version,
            kid: jwk.id(),
            to_upsert: match jwk {
                JWK::Unsupported(unsupported)
                    if unsupported.payload.as_slice() == DELETE_COMMAND_INDICATOR.as_bytes() =>
                {
                    None
                },
                _ => Some(jwk),
            },
        })
    }
```
