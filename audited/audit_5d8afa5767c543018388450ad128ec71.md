# Audit Report

## Title
Missing Extension Check in Commit Vote Signing Allows Validators to Sign Non-Monotonic or Conflicting Commits

## Summary
The `sign_commit_vote()` function in SafetyRules lacks validation that new commits extend previously signed commits, enabling validators to sign conflicting execution results or sign commits with non-monotonic version/round progression. The TODO comments in the code explicitly acknowledge these missing checks, and the DAG consensus implementation completely bypasses safety validation.

## Finding Description

The `SafetyRules::guarded_sign_commit_vote()` implementation performs insufficient validation before signing commit votes. [1](#0-0) 

The function only verifies that both ledger infos reference the **same block** via `match_ordered_only()`, which explicitly compares ordering-related fields for the same block, not whether one block extends another: [2](#0-1) 

**Critical Missing Checks:**

1. **No extension validation**: The function does not verify that `new_ledger_info.version()` ≥ previously signed version or that `new_ledger_info.round()` ≥ previously signed round

2. **No state persistence**: The function does not update `SafetyData` to track what commits have been signed. The `SafetyData` structure has `last_voted_round` for ordering votes but no corresponding field for commit votes: [3](#0-2) 

3. **Explicit TODO comments**: The code contains TODO comments acknowledging these missing checks: [4](#0-3) 

4. **DagCommitSigner bypasses all checks**: The DAG consensus implementation uses `DagCommitSigner` which completely ignores the old ledger info parameter and bypasses all safety validation: [5](#0-4) 

This implementation is used whenever DAG consensus is enabled: [6](#0-5) 

Additionally, when SafetyRules runs in remote mode, it exposes an unauthenticated network interface that accepts `sign_commit_vote` requests: [7](#0-6) 

While mainnet configuration explicitly disallows remote mode for optimal performance [8](#0-7) , this represents a defense-in-depth violation where SafetyRules lacks fundamental safety checks it should enforce regardless of configuration.

## Impact Explanation

**Severity: Critical** - This violates fundamental consensus safety invariants:

- **Consensus Safety Violation**: Validators can sign conflicting commits, potentially enabling different honest nodes to commit different execution results for the same or conflicting blocks
- **Defense-in-Depth Failure**: SafetyRules is designed to be the final safety check, but lacks critical validation
- **DAG Consensus Risk**: All DAG consensus deployments use `DagCommitSigner` which has zero safety checks
- **State Inconsistency**: Could lead to permanent state divergence requiring manual intervention

Per Aptos bug bounty criteria, this qualifies as **Critical Severity** as it represents a "Consensus/Safety violation" that could cause consensus splits or state inconsistencies.

The explicit TODO comments indicate developers recognize these checks are necessary but haven't implemented them, confirming this is a known limitation rather than by-design behavior.

## Likelihood Explanation

**Likelihood: Medium**

The vulnerability can be triggered through multiple paths:

1. **DAG Consensus Path**: When DAG consensus is enabled, `DagCommitSigner` is used which completely bypasses safety checks. This affects all DAG deployments.

2. **Remote SafetyRules**: If SafetyRules is configured in remote mode (disallowed on mainnet but possible on testnets), the unauthenticated network interface could be exploited by attackers who can reach the service port.

3. **Consensus Edge Cases**: During state sync, fast-forward scenarios, or Byzantine behavior from other validators, the lack of safety checks could allow signing of conflicting or non-monotonic commits.

While mainnet configuration restrictions reduce likelihood for the remote mode attack vector, the DAG consensus path and defense-in-depth concerns justify a Medium likelihood assessment.

## Recommendation

Implement the missing safety checks in `guarded_sign_commit_vote()`:

1. Add fields to `SafetyData` to track last signed commit round and version
2. Implement extension validation to ensure new commits extend previously signed commits
3. Add monotonicity checks for version and round progression
4. Update `DagCommitSigner` to include basic safety validation
5. Add authentication to remote SafetyRules service

The TODO comments at lines 412-413 already identify these missing checks - they need to be implemented.

## Proof of Concept

The vulnerability is demonstrated by the code structure itself:

1. `SafetyData` lacks commit tracking fields (only has `last_voted_round`)
2. `guarded_sign_commit_vote()` does not update `SafetyData`  
3. `match_ordered_only()` only validates same block, not extension
4. TODO comments explicitly acknowledge missing checks
5. `DagCommitSigner` ignores the `_ledger_info` parameter entirely

A validator could theoretically sign commit votes for version 1000, then later sign for version 500, or sign conflicting execution results for the same block from different forks, as there is no validation preventing this behavior.

### Citations

**File:** consensus/safety-rules/src/safety_rules.rs (L372-418)
```rust
    fn guarded_sign_commit_vote(
        &mut self,
        ledger_info: LedgerInfoWithSignatures,
        new_ledger_info: LedgerInfo,
    ) -> Result<bls12381::Signature, Error> {
        self.signer()?;

        let old_ledger_info = ledger_info.ledger_info();

        if !old_ledger_info.commit_info().is_ordered_only()
            // When doing fast forward sync, we pull the latest blocks and quorum certs from peers
            // and store them in storage. We then compute the root ordered cert and root commit cert
            // from storage and start the consensus from there. But given that we are not storing the
            // ordered cert obtained from order votes in storage, instead of obtaining the root ordered cert
            // from storage, we set root ordered cert to commit certificate.
            // This means, the root ordered cert will not have a dummy executed_state_id in this case.
            // To handle this, we do not raise error if the old_ledger_info.commit_info() matches with
            // new_ledger_info.commit_info().
            && old_ledger_info.commit_info() != new_ledger_info.commit_info()
        {
            return Err(Error::InvalidOrderedLedgerInfo(old_ledger_info.to_string()));
        }

        if !old_ledger_info
            .commit_info()
            .match_ordered_only(new_ledger_info.commit_info())
        {
            return Err(Error::InconsistentExecutionResult(
                old_ledger_info.commit_info().to_string(),
                new_ledger_info.commit_info().to_string(),
            ));
        }

        // Verify that ledger_info contains at least 2f + 1 dostinct signatures
        if !self.skip_sig_verify {
            ledger_info
                .verify_signatures(&self.epoch_state()?.verifier)
                .map_err(|error| Error::InvalidQuorumCertificate(error.to_string()))?;
        }

        // TODO: add guarding rules in unhappy path
        // TODO: add extension check

        let signature = self.sign(&new_ledger_info)?;

        Ok(signature)
    }
```

**File:** types/src/block_info.rs (L196-204)
```rust
    pub fn match_ordered_only(&self, executed_block_info: &BlockInfo) -> bool {
        self.epoch == executed_block_info.epoch
            && self.round == executed_block_info.round
            && self.id == executed_block_info.id
            && (self.timestamp_usecs == executed_block_info.timestamp_usecs
            // executed block info has changed its timestamp because it's a reconfiguration suffix
                || (self.timestamp_usecs > executed_block_info.timestamp_usecs
                    && executed_block_info.has_reconfiguration()))
    }
```

**File:** consensus/consensus-types/src/safety_data.rs (L8-21)
```rust
/// Data structure for safety rules to ensure consensus safety.
#[derive(Debug, Deserialize, Eq, PartialEq, Serialize, Clone, Default)]
pub struct SafetyData {
    pub epoch: u64,
    pub last_voted_round: u64,
    // highest 2-chain round, used for 3-chain
    pub preferred_round: u64,
    // highest 1-chain round, used for 2-chain
    #[serde(default)]
    pub one_chain_round: u64,
    pub last_vote: Option<Vote>,
    #[serde(default)]
    pub highest_timeout_round: u64,
}
```

**File:** consensus/src/dag/commit_signer.rs (L19-32)
```rust
impl CommitSignerProvider for DagCommitSigner {
    fn sign_commit_vote(
        &self,
        _ledger_info: aptos_types::ledger_info::LedgerInfoWithSignatures,
        new_ledger_info: aptos_types::ledger_info::LedgerInfo,
    ) -> Result<bls12381::Signature, aptos_safety_rules::Error> {
        let signature = self
            .signer
            .sign(&new_ledger_info)
            .map_err(|err| aptos_safety_rules::Error::SerializationError(err.to_string()))?;

        Ok(signature)
    }
}
```

**File:** consensus/src/epoch_manager.rs (L1441-1441)
```rust
        let commit_signer = Arc::new(DagCommitSigner::new(signer.clone()));
```

**File:** consensus/safety-rules/src/remote_service.rs (L30-55)
```rust
pub fn execute(storage: PersistentSafetyStorage, listen_addr: SocketAddr, network_timeout_ms: u64) {
    let mut safety_rules = SafetyRules::new(storage, false);
    if let Err(e) = safety_rules.consensus_state() {
        warn!("Unable to print consensus state: {}", e);
    }

    let mut serializer_service = SerializerService::new(safety_rules);
    let mut network_server =
        NetworkServer::new("safety-rules".to_string(), listen_addr, network_timeout_ms);

    loop {
        if let Err(e) = process_one_message(&mut network_server, &mut serializer_service) {
            warn!("Failed to process message: {}", e);
        }
    }
}

fn process_one_message(
    network_server: &mut NetworkServer,
    serializer_service: &mut SerializerService,
) -> Result<(), Error> {
    let request = network_server.read()?;
    let response = serializer_service.handle_message(request)?;
    network_server.write(&response)?;
    Ok(())
}
```

**File:** config/src/config/safety_rules_config.rs (L98-104)
```rust
            // Verify that the safety rules service is set to local for optimal performance
            if chain_id.is_mainnet() && !safety_rules_config.service.is_local() {
                return Err(Error::ConfigSanitizerFailed(
                    sanitizer_name,
                    format!("The safety rules service should be set to local in mainnet for optimal performance! Given config: {:?}", &safety_rules_config.service)
                ));
            }
```
