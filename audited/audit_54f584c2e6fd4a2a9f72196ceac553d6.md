# Audit Report

## Title
Arbitrary File Write via Unsanitized Path in node-checker OutputArgs::write() Leading to Privilege Escalation

## Summary
The `OutputArgs::write()` method in the node-checker tool accepts user-controlled file paths from command-line arguments without validation or sanitization, allowing arbitrary file writes. If node-checker runs with elevated privileges, an attacker can overwrite critical system files to achieve privilege escalation or compromise the validator node.

## Finding Description

The `OutputArgs` struct in the node-checker module exposes a dangerous arbitrary file write vulnerability. [1](#0-0) 

The `write()` method directly passes user-supplied paths to `std::fs::write()` without any validation: [2](#0-1) 

The `output_path` field is populated directly from command-line arguments via clap's Parser derive macro, with no restrictions on the path value. This means an attacker can specify any absolute or relative path.

The vulnerability is currently exploited in the `generate_openapi` command: [3](#0-2) 

**Attack Scenario:**

If a validator operator or administrator runs node-checker with elevated privileges (sudo/root) - whether due to misconfiguration, deployment choices, or mistaken belief that it's needed - an attacker can exploit this by specifying malicious output paths:

```bash
# Overwrite sudoers file to grant passwordless sudo
sudo aptos-node-checker server generate-openapi --output-path /etc/sudoers

# Write to cron.d for scheduled code execution  
sudo aptos-node-checker server generate-openapi --output-path /etc/cron.d/malicious

# Compromise SSH access
sudo aptos-node-checker server generate-openapi --output-path /root/.ssh/authorized_keys

# Overwrite systemd service units
sudo aptos-node-checker server generate-openapi --output-path /etc/systemd/system/aptos-node.service
```

While the written content is an OpenAPI specification (not directly attacker-controlled), writing to critical system files can:
- Cause denial of service by corrupting configuration files
- Enable privilege escalation by modifying access control files
- Achieve code execution by writing to cron jobs or systemd units

**Note on Premise:** The security question assumes node-checker runs with elevated privileges "to access validator metrics." However, validator metrics are accessed via HTTP GET requests [4](#0-3) , which does not require elevated OS privileges. The premise appears incorrect, but the vulnerability remains exploitable if the tool is ever run with elevated privileges for any reason.

## Impact Explanation

This vulnerability is classified as **High Severity** and could escalate to **Critical** depending on exploitation:

**High Severity** - Meets criteria for "Significant protocol violations" and "Validator node slowdowns":
- Arbitrary file write can corrupt validator node configuration
- Writing to log files or data directories can cause node failures
- Overwriting application files can disrupt validator operations

**Potential Critical Severity** - Could achieve "Remote Code Execution on validator node":
- Writing to `/etc/cron.d/`, `/etc/systemd/system/`, or similar directories can achieve arbitrary code execution
- If RCE is achieved on a validator node, it compromises consensus participation
- Could lead to validator key theft, consensus manipulation, or network disruption

Even without elevated privileges, the vulnerability allows overwriting user files, which could lead to configuration corruption or data loss for the node operator.

## Likelihood Explanation

**Likelihood: Medium to Low**

The exploitation requires specific conditions:
1. **Node-checker must run with elevated privileges** - This is unusual since HTTP metric access doesn't require it, but could occur due to:
   - Deployment automation running all validator tools as root
   - Misconfiguration or misunderstanding of requirements
   - Containerized deployments with elevated container privileges
   - Systemd services configured to run as root

2. **Attacker must control command-line arguments** - This requires:
   - Social engineering to trick an operator into running a malicious command
   - Compromise of deployment scripts or automation
   - Access to the system to execute commands (though not necessarily as root)

3. **Simple exploitation** - Once conditions are met, exploitation is trivial (single CLI argument)

The likelihood increases in environments where:
- Operators routinely use sudo for validator operations
- Deployment scripts run with elevated privileges
- Security awareness about tool privileges is low

## Recommendation

Implement strict path validation and sanitization in `OutputArgs::write()`:

```rust
use std::path::{Path, PathBuf};

impl OutputArgs {
    pub fn write(&self, output: &str) -> Result<()> {
        match &self.output_path {
            Some(path) => {
                // Validate the path
                self.validate_output_path(path)?;
                std::fs::write(path, output)?;
            },
            None => println!("{}", output),
        }
        Ok(())
    }
    
    fn validate_output_path(&self, path: &Path) -> Result<()> {
        // Canonicalize to resolve symlinks and relative paths
        let canonical = path.canonicalize()
            .or_else(|_| {
                // If file doesn't exist, canonicalize parent
                path.parent()
                    .ok_or_else(|| anyhow::anyhow!("Invalid path"))?
                    .canonicalize()
                    .map(|p| p.join(path.file_name().unwrap()))
            })?;
        
        // Reject absolute paths to system directories
        let forbidden_prefixes = [
            "/etc/", "/bin/", "/sbin/", "/usr/", "/boot/", 
            "/sys/", "/proc/", "/root/", "/var/", "/opt/"
        ];
        
        let path_str = canonical.to_string_lossy();
        for prefix in &forbidden_prefixes {
            if path_str.starts_with(prefix) {
                return Err(anyhow::anyhow!(
                    "Cannot write to system directory: {}", prefix
                ));
            }
        }
        
        // Optionally: restrict to specific allowed directories
        // or require paths to be relative to a safe base directory
        
        Ok(())
    }
}
```

**Additional recommendations:**
1. Document that node-checker should NOT be run with elevated privileges
2. Add a warning if the tool detects it's running as root
3. Use capability-based security to drop unnecessary privileges
4. Implement a whitelist of allowed output directories

## Proof of Concept

```bash
# Setup: Create a test scenario
mkdir -p /tmp/node-checker-test
cd /tmp/node-checker-test

# Compile node-checker (assuming in aptos-core repository)
# cargo build --release -p aptos-node-checker

# Create a protected file to demonstrate the issue
echo "PROTECTED CONTENT" > /tmp/protected-file.txt
chmod 644 /tmp/protected-file.txt

# Run node-checker with elevated privileges (simulating the vulnerable scenario)
# This will overwrite the protected file with OpenAPI spec
sudo ../target/release/aptos-node-checker server generate-openapi \
    --output-path /tmp/protected-file.txt

# Verify the file was overwritten
cat /tmp/protected-file.txt
# Output will show OpenAPI YAML spec instead of "PROTECTED CONTENT"

# More dangerous example (DO NOT RUN on production systems):
# sudo aptos-node-checker server generate-openapi \
#     --output-path /etc/cron.d/malicious-job
# This would write to /etc/cron.d/, potentially achieving code execution
```

**Reproduction Steps:**
1. Build the node-checker binary from the Aptos Core repository
2. Run the binary with sudo/elevated privileges
3. Pass `--output-path` pointing to a sensitive system file
4. Observe that the file is overwritten with the OpenAPI specification
5. Note that if targeting files like `/etc/cron.d/*`, this could lead to code execution

**Notes**
- The premise that node-checker requires elevated privileges to access validator metrics is questionable, as metrics are accessed via HTTP endpoints that don't require OS-level privileges
- However, the vulnerability remains valid if operators run the tool with elevated privileges for any reason (misconfiguration, deployment choices, etc.)
- The tool is part of validator operations, making this a relevant security concern for the Aptos ecosystem
- While not directly a blockchain consensus vulnerability, compromising validator nodes through this vector could indirectly impact network security

### Citations

**File:** ecosystem/node-checker/src/common/common_args.rs (L14-24)
```rust
#[derive(Clone, Debug, Parser)]
pub struct OutputArgs {
    /// By default, the spec is written to stdout. If this is provided, the
    /// tool will instead write the spec to the provided path.
    #[clap(short, long)]
    pub output_path: Option<PathBuf>,

    /// What format to output the spec in.
    #[clap(short, long, value_enum, ignore_case = true, default_value_t = OutputFormat::Yaml)]
    pub format: OutputFormat,
}
```

**File:** ecosystem/node-checker/src/common/common_args.rs (L26-34)
```rust
impl OutputArgs {
    pub fn write(&self, output: &str) -> Result<()> {
        match &self.output_path {
            Some(path) => std::fs::write(path, output)?,
            None => println!("{}", output),
        }
        Ok(())
    }
}
```

**File:** ecosystem/node-checker/src/server/generate_openapi.rs (L26-40)
```rust
pub async fn generate_openapi(args: GenerateOpenapi) -> Result<()> {
    let baseline_configurations = BaselineConfigurationRunners(HashMap::new());

    let api: Api<SyncRunner> = Api {
        baseline_configurations,
    };

    let api_service = build_openapi_service(api, args.server_args.clone());

    let spec = match args.output_args.format {
        OutputFormat::Json => api_service.spec(),
        OutputFormat::Yaml => api_service.spec_yaml(),
    };
    args.output_args.write(&spec)
}
```

**File:** ecosystem/node-checker/src/provider/metrics.rs (L59-86)
```rust
    pub async fn get_scrape(&self) -> Result<Scrape, ProviderError> {
        let response = self
            .client
            .get(self.metrics_url.clone())
            .send()
            .await
            .with_context(|| format!("Failed to get data from {}", self.metrics_url))
            .map_err(|e| ProviderError::RetryableEndpointError("/metrics", e))?;
        let body = response
            .text()
            .await
            .with_context(|| {
                format!(
                    "Failed to process response body from {} as text",
                    self.metrics_url
                )
            })
            .map_err(|e| ProviderError::ParseError(anyhow!(e)))?;
        Scrape::parse(body.lines().map(|l| Ok(l.to_string())))
            .with_context(|| {
                format!(
                    "Failed to parse response text from {} as a Prometheus scrape",
                    self.metrics_url
                )
            })
            .map_err(|e| ProviderError::ParseError(anyhow!(e)))
    }
}
```
